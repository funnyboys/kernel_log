commit 0558f33c06bb910e2879e355192227a8e8f0219d
Author: Jason Yan <yanaijie@huawei.com>
Date:   Fri Dec 8 17:42:09 2017 +0800

    scsi: libsas: direct call probe and destruct
    
    In commit 87c8331fcf72 ("[SCSI] libsas: prevent domain rediscovery
    competing with ata error handling") introduced disco mutex to prevent
    rediscovery competing with ata error handling and put the whole
    revalidation in the mutex. But the rphy add/remove needs to wait for the
    error handling which also grabs the disco mutex. This may leads to dead
    lock.So the probe and destruct event were introduce to do the rphy
    add/remove asynchronously and out of the lock.
    
    The asynchronously processed workers makes the whole discovery process
    not atomic, the other events may interrupt the process. For example,
    if a loss of signal event inserted before the probe event, the
    sas_deform_port() is called and the port will be deleted.
    
    And sas_port_delete() may run before the destruct event, but the
    port-x:x is the top parent of end device or expander. This leads to
    a kernel WARNING such as:
    
    [   82.042979] sysfs group 'power' not found for kobject 'phy-1:0:22'
    [   82.042983] ------------[ cut here ]------------
    [   82.042986] WARNING: CPU: 54 PID: 1714 at fs/sysfs/group.c:237
    sysfs_remove_group+0x94/0xa0
    [   82.043059] Call trace:
    [   82.043082] [<ffff0000082e7624>] sysfs_remove_group+0x94/0xa0
    [   82.043085] [<ffff00000864e320>] dpm_sysfs_remove+0x60/0x70
    [   82.043086] [<ffff00000863ee10>] device_del+0x138/0x308
    [   82.043089] [<ffff00000869a2d0>] sas_phy_delete+0x38/0x60
    [   82.043091] [<ffff00000869a86c>] do_sas_phy_delete+0x6c/0x80
    [   82.043093] [<ffff00000863dc20>] device_for_each_child+0x58/0xa0
    [   82.043095] [<ffff000008696f80>] sas_remove_children+0x40/0x50
    [   82.043100] [<ffff00000869d1bc>] sas_destruct_devices+0x64/0xa0
    [   82.043102] [<ffff0000080e93bc>] process_one_work+0x1fc/0x4b0
    [   82.043104] [<ffff0000080e96c0>] worker_thread+0x50/0x490
    [   82.043105] [<ffff0000080f0364>] kthread+0xfc/0x128
    [   82.043107] [<ffff0000080836c0>] ret_from_fork+0x10/0x50
    
    Make probe and destruct a direct call in the disco and revalidate function,
    but put them outside the lock. The whole discovery or revalidate won't
    be interrupted by other events. And the DISCE_PROBE and DISCE_DESTRUCT
    event are deleted as a result of the direct call.
    
    Introduce a new list to destruct the sas_port and put the port delete after
    the destruct. This makes sure the right order of destroying the sysfs
    kobject and fix the warning above.
    
    In sas_ex_revalidate_domain() have a loop to find all broadcasted
    device, and sometimes we have a chance to find the same expander twice.
    Because the sas_port will be deleted at the end of the whole revalidate
    process, sas_port with the same name cannot be added before this.
    Otherwise the sysfs will complain of creating duplicate filename. Since
    the LLDD will send broadcast for every device change, we can only
    process one expander's revalidation.
    
    [mkp: kbuild test robot warning]
    
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    CC: John Garry <john.garry@huawei.com>
    CC: Johannes Thumshirn <jthumshirn@suse.de>
    CC: Ewan Milne <emilne@redhat.com>
    CC: Christoph Hellwig <hch@lst.de>
    CC: Tomas Henzl <thenzl@redhat.com>
    CC: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 62895b405933..05ec927a3c72 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -156,6 +156,7 @@ struct sas_port {
 
 	struct mutex		phy_list_mutex;
 	struct list_head	phy_list;
+	struct list_head	del_list; /* libsas only */
 };
 
 #define dev_to_sas_port(d) \

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index a23304b7fb2e..62895b405933 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef SCSI_TRANSPORT_SAS_H
 #define SCSI_TRANSPORT_SAS_H
 

commit 651a013649943710a900551ec6e03d2084e1a65a
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Aug 25 17:37:41 2017 +0200

    scsi: scsi_transport_sas: switch to bsg-lib for SMP passthrough
    
    Simplify the SMP passthrough code by switching it to the generic bsg-lib
    helpers that abstract away the details of the request code, and gets
    drivers out of seeing struct scsi_request.
    
    For the libsas host SMP code there is a small behavior difference in
    that we now always clear the residual len for successful commands,
    similar to the three other SMP handler implementations.  Given that
    there is no partial command handling in the host SMP handler this should
    not matter in practice.
    
    [mkp: typos and checkpatch fixes]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 73d870918939..a23304b7fb2e 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -5,6 +5,7 @@
 #include <linux/types.h>
 #include <linux/mutex.h>
 #include <scsi/sas.h>
+#include <linux/bsg-lib.h>
 
 struct scsi_transport_template;
 struct sas_rphy;
@@ -176,7 +177,8 @@ struct sas_function_template {
 	int (*phy_setup)(struct sas_phy *);
 	void (*phy_release)(struct sas_phy *);
 	int (*set_phy_speed)(struct sas_phy *, struct sas_phy_linkrates *);
-	int (*smp_handler)(struct Scsi_Host *, struct sas_rphy *, struct request *);
+	void (*smp_handler)(struct bsg_job *, struct Scsi_Host *,
+			struct sas_rphy *);
 };
 
 

commit a0f81dbeef13aa0aeaa8b955b38735dbf09de392
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Aug 17 11:46:18 2016 +0200

    scsi: sas: remove is_sas_attached()
    
    As there are no more users of is_sas_attached() left, remove it.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: James E.J. Bottomley <jejb@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 31ae074dad9d..73d870918939 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -11,17 +11,11 @@ struct sas_rphy;
 struct request;
 
 #if !IS_ENABLED(CONFIG_SCSI_SAS_ATTRS)
-static inline int is_sas_attached(struct scsi_device *sdev)
-{
-	return 0;
-}
-
 static inline int scsi_is_sas_rphy(const struct device *sdev)
 {
 	return 0;
 }
 #else
-extern int is_sas_attached(struct scsi_device *sdev);
 extern int scsi_is_sas_rphy(const struct device *);
 #endif
 

commit c1a23f6d64552b4480208aa584ec7e9c13d6d9c3
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Aug 17 11:46:16 2016 +0200

    scsi: sas: provide stub implementation for scsi_is_sas_rphy
    
    Provide a stub implementation for scsi_is_sas_rphy for kernel
    configurations which do not have CONFIG_SCSI_SAS_ATTRS defined.
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Suggested-by: James Bottomley <jejb@linux.vnet.ibm.com>
    Reviewed-by: James E.J. Bottomley <jejb@linux.vnet.ibm.com>
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 13c0b2ba1b6c..31ae074dad9d 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -15,8 +15,14 @@ static inline int is_sas_attached(struct scsi_device *sdev)
 {
 	return 0;
 }
+
+static inline int scsi_is_sas_rphy(const struct device *sdev)
+{
+	return 0;
+}
 #else
 extern int is_sas_attached(struct scsi_device *sdev);
+extern int scsi_is_sas_rphy(const struct device *);
 #endif
 
 static inline int sas_protocol_ata(enum sas_protocol proto)
@@ -202,7 +208,6 @@ extern int sas_rphy_add(struct sas_rphy *);
 extern void sas_rphy_remove(struct sas_rphy *);
 extern void sas_rphy_delete(struct sas_rphy *);
 extern void sas_rphy_unlink(struct sas_rphy *);
-extern int scsi_is_sas_rphy(const struct device *);
 
 struct sas_port *sas_port_alloc(struct device *, int);
 struct sas_port *sas_port_alloc_num(struct device *);

commit bcf508c13385e74972f5cc06d8471d5c100395b0
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Wed Dec 9 11:13:35 2015 -0800

    scsi_transport_sas: add function to get SAS endpoint address
    
    For a device known to be SAS connected, this will return the endpoint
    address.  This is useful for getting the SAS address of SATA devices.
    
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index a8fdd10fc9c5..13c0b2ba1b6c 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -189,6 +189,7 @@ extern int sas_phy_add(struct sas_phy *);
 extern void sas_phy_delete(struct sas_phy *);
 extern int scsi_is_sas_phy(const struct device *);
 
+u64 sas_get_address(struct scsi_device *);
 unsigned int sas_tlr_supported(struct scsi_device *);
 unsigned int sas_is_tlr_enabled(struct scsi_device *);
 void sas_disable_tlr(struct scsi_device *);

commit 3b91d09c1ca69a69c470efe5fbf346e3e90181d5
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Wed Dec 9 11:12:03 2015 -0800

    scsi_transport_sas: add is_sas_attached() function
    
    Adds a function designed to be callable any time (regardless of
    whether the transport attributes are configured or not) which returns
    true if the device is attached over a SAS transport.  The design of
    this function is that transport specific functions can be embedded
    within a
    
    if (is_sas_attached(sdev)) {
            ...
    }
    
    which would be compiled out (and thus eliminate the symbols) if SAS is
    not configured.
    
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 0bd71e2702e3..a8fdd10fc9c5 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -10,6 +10,15 @@ struct scsi_transport_template;
 struct sas_rphy;
 struct request;
 
+#if !IS_ENABLED(CONFIG_SCSI_SAS_ATTRS)
+static inline int is_sas_attached(struct scsi_device *sdev)
+{
+	return 0;
+}
+#else
+extern int is_sas_attached(struct scsi_device *sdev);
+#endif
+
 static inline int sas_protocol_ata(enum sas_protocol proto)
 {
 	return ((proto & SAS_PROTOCOL_SATA) ||

commit aa9f8328fc51460e15da129caf622b6560fa8c99
Author: James Bottomley <JBottomley@Parallels.com>
Date:   Tue May 7 14:44:06 2013 -0700

    [SCSI] sas: unify the pointlessly separated enums sas_dev_type and sas_device_type
    
    These enums have been separate since the dawn of SAS, mainly because the
    latter is a procotol only enum and the former includes additional state
    for libsas.  The dichotomy causes endless confusion about which one you
    should use where and leads to pointless warnings like this:
    
    drivers/scsi/mvsas/mv_sas.c: In function 'mvs_update_phyinfo':
    drivers/scsi/mvsas/mv_sas.c:1162:34: warning: comparison between 'enum sas_device_type' and 'enum sas_dev_type' [-Wenum-compare]
    
    Fix by eliminating one of them.  The one kept is effectively the sas.h
    one, but call it sas_device_type and make sure the enums are all
    properly namespaced with the SAS_ prefix.
    
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 9b8e08879cfc..0bd71e2702e3 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -10,13 +10,6 @@ struct scsi_transport_template;
 struct sas_rphy;
 struct request;
 
-enum sas_device_type {
-	SAS_PHY_UNUSED = 0,
-	SAS_END_DEVICE = 1,
-	SAS_EDGE_EXPANDER_DEVICE = 2,
-	SAS_FANOUT_EXPANDER_DEVICE = 3,
-};
-
 static inline int sas_protocol_ata(enum sas_protocol proto)
 {
 	return ((proto & SAS_PROTOCOL_SATA) ||

commit d84fd392bd61524c4d81367969424e6c17086c8c
Author: Sreekanth Reddy <Sreekanth.Reddy@lsi.com>
Date:   Fri Nov 30 07:43:11 2012 +0530

    [SCSI] scsi_transport_sas: add 12GB definitions for mpt3sas
    
    [jejb: split this core change into a separate patch]
    Signed-off-by: Sreekanth Reddy <Sreekanth.Reddy@lsi.com>
    Reviewed-by: Nagalakshmi Nandigama <Nagalakshmi.Nandigama@lsi.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 98b3a20a0102..9b8e08879cfc 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -36,6 +36,7 @@ enum sas_linkrate {
 	SAS_LINK_RATE_3_0_GBPS = 9,
 	SAS_LINK_RATE_G2 = SAS_LINK_RATE_3_0_GBPS,
 	SAS_LINK_RATE_6_0_GBPS = 10,
+	SAS_LINK_RATE_12_0_GBPS = 11,
 	/* These are virtual to the transport class and may never
 	 * be signalled normally since the standard defined field
 	 * is only 4 bits */

commit f41a0c441c3fe43e79ebeb75584dbb5bfa83e5cd
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Dec 21 21:33:17 2011 -0800

    [SCSI] libsas: fix sas_find_local_phy(), take phy references
    
    In the direct-attached case this routine returns the phy on which this
    device was first discovered.  Which is broken if we want to support
    wide-targets, as this phy reference can become stale even though the
    port is still active.
    
    In the expander-attached case this routine tries to lookup the phy by
    scanning the attached sas addresses of the parent expander, and BUG_ONs
    if it can't find it.  However since eh and the libsas workqueue run
    independently we can still be attempting device recovery via eh after
    libsas has recorded the device as detached.  This is even easier to hit
    now that eh is blocked while device domain rediscovery takes place, and
    that libata is fed more timed out commands increasing the chances that
    it will try to recover the ata device.
    
    Arrange for dev->phy to always point to a last known good phy, it may be
    stale after the port is torn down, but it will catch up for wide port
    reconfigurations, and never be NULL.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 42817facaeda..98b3a20a0102 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -209,6 +209,12 @@ void sas_port_add_phy(struct sas_port *, struct sas_phy *);
 void sas_port_delete_phy(struct sas_port *, struct sas_phy *);
 void sas_port_mark_backlink(struct sas_port *);
 int scsi_is_sas_port(const struct device *);
+struct sas_phy *sas_port_get_phy(struct sas_port *port);
+static inline void sas_port_put_phy(struct sas_phy *phy)
+{
+	if (phy)
+		put_device(&phy->dev);
+}
 
 extern struct scsi_transport_template *
 sas_attach_transport(struct sas_function_template *);

commit 0b3e09da1350397f3f8b6fd839ab455b0b587451
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Dec 20 01:03:48 2011 -0800

    [SCSI] libsas: perform sas-transport resets in shost->workq context
    
    Extend the sas transport class to allow transport users to attach extra
    data to a sas_phy (->hostdata).  Use this area in libsas to move resets
    to workq context in preparation for scheduling ata device resets through
    libata-eh.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 6d14daac7589..42817facaeda 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -75,7 +75,8 @@ struct sas_phy {
 	/* for the list of phys belonging to a port */
 	struct list_head	port_siblings;
 
-	struct work_struct      reset_work;
+	/* available to the lldd */
+	void			*hostdata;
 };
 
 #define dev_to_phy(d) \
@@ -169,6 +170,8 @@ struct sas_function_template {
 	int (*get_bay_identifier)(struct sas_rphy *);
 	int (*phy_reset)(struct sas_phy *, int);
 	int (*phy_enable)(struct sas_phy *, int);
+	int (*phy_setup)(struct sas_phy *);
+	void (*phy_release)(struct sas_phy *);
 	int (*set_phy_speed)(struct sas_phy *, struct sas_phy_linkrates *);
 	int (*smp_handler)(struct Scsi_Host *, struct sas_rphy *, struct request *);
 };

commit 87c8331fcf72e501c3a3c0cdc5c9391ec72f7cf2
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Nov 17 17:59:51 2011 -0800

    [SCSI] libsas: prevent domain rediscovery competing with ata error handling
    
    libata error handling provides for a timeout for link recovery.  libsas
    must not rescan for previously known devices in this interval otherwise
    it may remove a device that is simply waiting for its link to recover.
    Let libata-eh make the determination of when the link is stable and
    prevent libsas (host workqueue) from taking action while this
    determination is pending.
    
    Using a mutex (ha->disco_mutex) to flush and disable revalidation while
    eh is running requires any discovery action that may block on eh be
    moved to its own context outside the lock.  Probing ATA devices
    explicitly waits on ata-eh and the cache-flush-io issued during device
    removal may also pend awaiting eh completion.  Essentially any rphy
    add/remove activity needs to run outside the lock.
    
    This adds two new cleanup states for sas_unregister_domain_devices()
    'allocated-but-not-probed', and 'flagged-for-destruction'.  In the
    'allocated-but-not-probed' state  dev->rphy points to a rphy that is
    known to have not been through a sas_rphy_add() event.  At domain
    teardown check if this device is still pending probe and cleanup
    accordingly.  Similarly if a device has already been queued for removal
    then sas_unregister_domain_devices has nothing to do.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index ffeebc34a4f7..6d14daac7589 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -194,6 +194,7 @@ void sas_rphy_free(struct sas_rphy *);
 extern int sas_rphy_add(struct sas_rphy *);
 extern void sas_rphy_remove(struct sas_rphy *);
 extern void sas_rphy_delete(struct sas_rphy *);
+extern void sas_rphy_unlink(struct sas_rphy *);
 extern int scsi_is_sas_rphy(const struct device *);
 
 struct sas_port *sas_port_alloc(struct device *, int);

commit 0f88009d5cfae890bd3466126d1622ad4f16b798
Author: James Bottomley <James.Bottomley@suse.de>
Date:   Mon Jan 18 10:14:51 2010 -0600

    [SCSI] scsi_transport_sas: add support for transport layer retries (TLR)
    
    The mpt2sas driver wants to use transport layer retries (TLR) so the
    simplest thing to do seems to be to add the enabling flags and checks
    to the SAS transport class, since they're a SAS specific protocol
    feature.
    
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 61ad3594aad6..ffeebc34a4f7 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -107,6 +107,8 @@ struct sas_end_device {
 	struct sas_rphy		rphy;
 	/* flags */
 	unsigned		ready_led_meaning:1;
+	unsigned		tlr_supported:1;
+	unsigned		tlr_enabled:1;
 	/* parameters */
 	u16			I_T_nexus_loss_timeout;
 	u16			initiator_response_timeout;
@@ -181,6 +183,11 @@ extern int sas_phy_add(struct sas_phy *);
 extern void sas_phy_delete(struct sas_phy *);
 extern int scsi_is_sas_phy(const struct device *);
 
+unsigned int sas_tlr_supported(struct scsi_device *);
+unsigned int sas_is_tlr_enabled(struct scsi_device *);
+void sas_disable_tlr(struct scsi_device *);
+void sas_enable_tlr(struct scsi_device *);
+
 extern struct sas_rphy *sas_end_device_alloc(struct sas_port *);
 extern struct sas_rphy *sas_expander_alloc(struct sas_port *, enum sas_device_type);
 void sas_rphy_free(struct sas_rphy *);

commit ee959b00c335d7780136c5abda37809191fe52c3
Author: Tony Jones <tonyj@suse.de>
Date:   Fri Feb 22 00:13:36 2008 +0100

    SCSI: convert struct class_device to struct device
    
    It's big, but there doesn't seem to be a way to split it up smaller...
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Roland Dreier <rolandd@cisco.com>
    Cc: Sean Hefty <sean.hefty@intel.com>
    Cc: Hal Rosenstock <hal.rosenstock@gmail.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 09125fa95b93..61ad3594aad6 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -80,8 +80,8 @@ struct sas_phy {
 
 #define dev_to_phy(d) \
 	container_of((d), struct sas_phy, dev)
-#define transport_class_to_phy(cdev) \
-	dev_to_phy((cdev)->dev)
+#define transport_class_to_phy(dev) \
+	dev_to_phy((dev)->parent)
 #define phy_to_shost(phy) \
 	dev_to_shost((phy)->dev.parent)
 
@@ -96,8 +96,8 @@ struct sas_rphy {
 
 #define dev_to_rphy(d) \
 	container_of((d), struct sas_rphy, dev)
-#define transport_class_to_rphy(cdev) \
-	dev_to_rphy((cdev)->dev)
+#define transport_class_to_rphy(dev) \
+	dev_to_rphy((dev)->parent)
 #define rphy_to_shost(rphy) \
 	dev_to_shost((rphy)->dev.parent)
 #define target_to_rphy(targ) \
@@ -152,8 +152,8 @@ struct sas_port {
 
 #define dev_to_sas_port(d) \
 	container_of((d), struct sas_port, dev)
-#define transport_class_to_sas_port(cdev) \
-	dev_to_sas_port((cdev)->dev)
+#define transport_class_to_sas_port(dev) \
+	dev_to_sas_port((dev)->parent)
 
 struct sas_phy_linkrates {
 	enum sas_linkrate maximum_linkrate;

commit b98e66fa0b687149dc3b26179096dc542c7d5001
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Fri Dec 28 16:35:17 2007 -0600

    [SCSI] libsas: add host SMP processing
    
    This adds support for host side SMP processing, via a separate
    SMP interpreter file.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 007d92904207..09125fa95b93 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -11,10 +11,10 @@ struct sas_rphy;
 struct request;
 
 enum sas_device_type {
-	SAS_PHY_UNUSED,
-	SAS_END_DEVICE,
-	SAS_EDGE_EXPANDER_DEVICE,
-	SAS_FANOUT_EXPANDER_DEVICE,
+	SAS_PHY_UNUSED = 0,
+	SAS_END_DEVICE = 1,
+	SAS_EDGE_EXPANDER_DEVICE = 2,
+	SAS_FANOUT_EXPANDER_DEVICE = 3,
 };
 
 static inline int sas_protocol_ata(enum sas_protocol proto)

commit 5929faf3334f4c69f3bb02be59d7c127e0cefa1f
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Mon Nov 5 11:51:17 2007 -0800

    [SCSI] libsas: Convert sas_proto users to sas_protocol
    
    sparse complains about the mixing of enums in libsas.  Since the
    underlying numeric values of both enums are the same, combine them
    to get rid of the warning.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index abdfd2e27dd7..007d92904207 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -4,6 +4,7 @@
 #include <linux/transport_class.h>
 #include <linux/types.h>
 #include <linux/mutex.h>
+#include <scsi/sas.h>
 
 struct scsi_transport_template;
 struct sas_rphy;
@@ -16,13 +17,6 @@ enum sas_device_type {
 	SAS_FANOUT_EXPANDER_DEVICE,
 };
 
-enum sas_protocol {
-	SAS_PROTOCOL_SATA		= 0x01,
-	SAS_PROTOCOL_SMP		= 0x02,
-	SAS_PROTOCOL_STP		= 0x04,
-	SAS_PROTOCOL_SSP		= 0x08,
-};
-
 static inline int sas_protocol_ata(enum sas_protocol proto)
 {
 	return ((proto & SAS_PROTOCOL_SATA) ||

commit b6aff66953a29e40e0683be9b39c369ade143a5b
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Fri Jul 20 11:10:05 2007 -0500

    [SCSI] scsi_transport_sas: add destructor for bsg
    
    There's currently no destructor for the bsg components.  If you insert
    and remove the module, you see the bsg devices building up and up.  This
    patch adds the destructor in the correct place in the transport class so
    that the bsg and request queue are removed just before the device
    destruction.
    
    Acked-by: FUJITA Tomonori <tomof@acm.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index af304fb9d979..abdfd2e27dd7 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -91,10 +91,12 @@ struct sas_phy {
 #define phy_to_shost(phy) \
 	dev_to_shost((phy)->dev.parent)
 
+struct request_queue;
 struct sas_rphy {
 	struct device		dev;
 	struct sas_identify	identify;
 	struct list_head	list;
+	struct request_queue	*q;
 	u32			scsi_target_id;
 };
 

commit 7aa68e80bd481faae1234bc2a7e4bcc9348f98b4
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Mon Jul 9 12:52:06 2007 +0900

    [SCSI] transport_sas: add SAS management protocol support
    
    The sas transport class attaches one bsg device to every SAS object
    (host, device, expander, etc). LLDs can define a function to handle
    SMP requests via sas_function_template::smp_handler.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 97eeb5b59ea5..af304fb9d979 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -7,7 +7,7 @@
 
 struct scsi_transport_template;
 struct sas_rphy;
-
+struct request;
 
 enum sas_device_type {
 	SAS_PHY_UNUSED,
@@ -172,6 +172,7 @@ struct sas_function_template {
 	int (*phy_reset)(struct sas_phy *, int);
 	int (*phy_enable)(struct sas_phy *, int);
 	int (*set_phy_speed)(struct sas_phy *, struct sas_phy_linkrates *);
+	int (*smp_handler)(struct Scsi_Host *, struct sas_rphy *, struct request *);
 };
 
 

commit 0f05df8b3b41bc258bdf520b72e8cf7c524048b7
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Mon Jul 16 13:41:04 2007 -0500

    [SCSI] libsas, aic94xx: fix dma mapping cockups with ATA
    
    This one was noticed by Gilbert Wu of Adaptec:
    
    The libata core actually does the DMA mapping for you, so there has to
    be an exception in the device drivers that *don't* do dma mapping for
    ATA commands.  However, since we've already done this, libsas must now
    dma map any ATA commands that it wishes to issue ... and yes, this is a
    horrible mess.
    
    Additionally, the test in aic94xx for ATA protocols isn't quite right.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 9aedc19820b0..97eeb5b59ea5 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -23,6 +23,12 @@ enum sas_protocol {
 	SAS_PROTOCOL_SSP		= 0x08,
 };
 
+static inline int sas_protocol_ata(enum sas_protocol proto)
+{
+	return ((proto & SAS_PROTOCOL_SATA) ||
+		(proto & SAS_PROTOCOL_STP))? 1 : 0;
+}
+
 enum sas_linkrate {
 	/* These Values are defined in the SAS standard */
 	SAS_LINK_RATE_UNKNOWN = 0,

commit 6f63caae2172e97e528b58319480217b0b36542e
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Fri Jan 26 14:08:43 2007 -0800

    [SCSI] libsas: Clean up discovery failure handler code
    
    sas_rphy_delete does two things: it removes the sas_rphy from the transport
    layer and frees the sas_rphy.  This can be broken down into two functions,
    sas_rphy_remove and sas_rphy_free; sas_rphy_remove is of interest to
    sas_discover_root_expander because it calls functions that require
    sas_rphy_add as a prerequisite and can fail (namely sas_discover_expander).
    In that case, sas_discover_root_expander needs to be able to undo the effects
    of sas_rphy_add yet leave the job of freeing the sas_rphy to the caller of
    sas_discover_root_expander.
    
    This patch also removes some unnecessary code from sas_discover_end_dev
    to eliminate an unnecessary cycle of sas_notify_lldd_gone/found for SAS
    devices, thus eliminating a sas_rphy_remove call (and fixing a race condition
    where a SCSI target scan can come in between the gone and found call).
    It also moves the sas_rphy_free calls into sas_discover_domain and
    sas_ex_discover_end_dev to complement the sas_rphy_allocation via
    sas_get_port_device.
    
    This patch does not change the semantics of sas_rphy_delete.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 45d58598c3ee..9aedc19820b0 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -182,6 +182,7 @@ extern struct sas_rphy *sas_end_device_alloc(struct sas_port *);
 extern struct sas_rphy *sas_expander_alloc(struct sas_port *, enum sas_device_type);
 void sas_rphy_free(struct sas_rphy *);
 extern int sas_rphy_add(struct sas_rphy *);
+extern void sas_rphy_remove(struct sas_rphy *);
 extern void sas_rphy_delete(struct sas_rphy *);
 extern int scsi_is_sas_rphy(const struct device *);
 

commit acbf167d4ad8c27f9743a4b539d51ae9535bf21c
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Thu Jan 11 14:14:57 2007 -0800

    [SCSI] libsas: Add a sysfs knob to enable/disable a phy
    
    This patch lets a user arbitrarily enable or disable a phy via sysfs.
    Potential applications include shutting down a phy to replace one
    lane of wide port, and (more importantly) providing a method for the
    libata SATL to control the phy.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 59633a82de47..45d58598c3ee 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -54,6 +54,7 @@ struct sas_identify {
 struct sas_phy {
 	struct device		dev;
 	int			number;
+	int			enabled;
 
 	/* phy identification */
 	struct sas_identify	identify;
@@ -163,6 +164,7 @@ struct sas_function_template {
 	int (*get_enclosure_identifier)(struct sas_rphy *, u64 *);
 	int (*get_bay_identifier)(struct sas_rphy *);
 	int (*phy_reset)(struct sas_phy *, int);
+	int (*phy_enable)(struct sas_phy *, int);
 	int (*set_phy_speed)(struct sas_phy *, struct sas_phy_linkrates *);
 };
 

commit dea22214790d1306f3a3444db13d2c726037b189
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Tue Nov 7 17:28:55 2006 -0800

    [PATCH] aic94xx: handle REQ_DEVICE_RESET
    
    This patch implements a REQ_DEVICE_RESET handler for the aic94xx
    driver.  Like the earlier REQ_TASK_ABORT patch, this patch defers the
    device reset to the Scsi_Host's workqueue, which has the added benefit
    of ensuring that the device reset does not happen at the same time
    that the abort tmfs are being processed.  After the phy reset, the
    busted drive should go away and be re-detected later, which is indeed
    what I've seen on both a x260 and a x206m.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 53024377f3b8..59633a82de47 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -73,6 +73,8 @@ struct sas_phy {
 
 	/* for the list of phys belonging to a port */
 	struct list_head	port_siblings;
+
+	struct work_struct      reset_work;
 };
 
 #define dev_to_phy(d) \

commit d24e1eeb3a16e4944288c2f3bf082e1513f4b425
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Wed Sep 6 19:25:22 2006 -0500

    [SCSI] scsi_transport_sas: make minimum and maximum linkrate settable quantities
    
    According to SPEC, the minimum_linkrate and maximum_linkrate should be
    settable by the user.  This patch introduces a callback that allows the
    sas class to pass these settings on to the driver.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 87de518960c1..53024377f3b8 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -150,12 +150,18 @@ struct sas_port {
 #define transport_class_to_sas_port(cdev) \
 	dev_to_sas_port((cdev)->dev)
 
+struct sas_phy_linkrates {
+	enum sas_linkrate maximum_linkrate;
+	enum sas_linkrate minimum_linkrate;
+};
+
 /* The functions by which the transport class and the driver communicate */
 struct sas_function_template {
 	int (*get_linkerrors)(struct sas_phy *);
 	int (*get_enclosure_identifier)(struct sas_rphy *, u64 *);
 	int (*get_bay_identifier)(struct sas_rphy *);
 	int (*phy_reset)(struct sas_phy *, int);
+	int (*set_phy_speed)(struct sas_phy *, struct sas_phy_linkrates *);
 };
 
 

commit 88edf74610bd894b93438f389688bc8b4a2d3414
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Wed Sep 6 17:36:13 2006 -0500

    [SCSI] SAS: consolidate linkspeed definitions
    
    At the moment we have two separate linkspeed enumerations covering
    roughly the same values.  This patch consolidates on a single one enum
    sas_linkspeed in scsi_transport_sas.h and uses it everywhere in the
    aic94xx driver.  Eventually I'll get around to removing the duplicated
    fields in asd_sas_phy and sas_phy ...
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index eeb2200de855..87de518960c1 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -24,15 +24,23 @@ enum sas_protocol {
 };
 
 enum sas_linkrate {
-	SAS_LINK_RATE_UNKNOWN,
-	SAS_PHY_DISABLED,
-	SAS_LINK_RATE_FAILED,
-	SAS_SATA_SPINUP_HOLD,
-	SAS_SATA_PORT_SELECTOR,
-	SAS_LINK_RATE_1_5_GBPS,
-	SAS_LINK_RATE_3_0_GBPS,
-	SAS_LINK_RATE_6_0_GBPS,
-	SAS_LINK_VIRTUAL,
+	/* These Values are defined in the SAS standard */
+	SAS_LINK_RATE_UNKNOWN = 0,
+	SAS_PHY_DISABLED = 1,
+	SAS_PHY_RESET_PROBLEM = 2,
+	SAS_SATA_SPINUP_HOLD = 3,
+	SAS_SATA_PORT_SELECTOR = 4,
+	SAS_PHY_RESET_IN_PROGRESS = 5,
+	SAS_LINK_RATE_1_5_GBPS = 8,
+	SAS_LINK_RATE_G1 = SAS_LINK_RATE_1_5_GBPS,
+	SAS_LINK_RATE_3_0_GBPS = 9,
+	SAS_LINK_RATE_G2 = SAS_LINK_RATE_3_0_GBPS,
+	SAS_LINK_RATE_6_0_GBPS = 10,
+	/* These are virtual to the transport class and may never
+	 * be signalled normally since the standard defined field
+	 * is only 4 bits */
+	SAS_LINK_RATE_FAILED = 0x10,
+	SAS_PHY_VIRTUAL = 0x11,
 };
 
 struct sas_identify {

commit f4ad7b5807385ad1fed0347d966e51a797cd1013
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Fri Aug 25 13:48:18 2006 -0500

    [SCSI] scsi_transport_sas: remove local_attached flag
    
    This flag denotes local attachment of the phy.  There are two problems
    with it:
    
    1) It's actually redundant ... you can get the same information simply
    by seeing whether a host is the phys parent
    2) we condition a lot of phy parameters on it on the false assumption
    that we can only control local phys.  I'm wiring up phy resets in the
    aic94xx now, and it will be able to reset non-local phys as well.
    
    I fixed 2) by moving the local check into the reset and stats function
    of the mptsas, since that seems to be the only HBA that can't
    (currently) control non-local phys.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 6cc2314098cf..eeb2200de855 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -57,9 +57,6 @@ struct sas_phy {
 	enum sas_linkrate	maximum_linkrate_hw;
 	enum sas_linkrate	maximum_linkrate;
 
-	/* internal state */
-	unsigned int		local_attached : 1;
-
 	/* link error statistics */
 	u32			invalid_dword_count;
 	u32			running_disparity_error_count;
@@ -196,4 +193,6 @@ scsi_is_sas_expander_device(struct device *dev)
 		rphy->identify.device_type == SAS_EDGE_EXPANDER_DEVICE;
 }
 
+#define scsi_is_sas_phy_local(phy)	scsi_is_host_device((phy)->dev.parent)
+
 #endif /* SCSI_TRANSPORT_SAS_H */

commit a0e1b6ef3b851fe6f1dcc259432e83de79ce5e7f
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sun Jul 9 12:38:19 2006 -0500

    [SCSI] scsi_transport_sas: add expander backlink
    
    This patch adds the ability to add a backlink to a particular port.  The
    idea is to represent properly ports on expanders that are used
    specifically for linking to the parent device in the topology.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index f5772ff61d0d..6cc2314098cf 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -130,6 +130,8 @@ struct sas_port {
 
 	int			port_identifier;
 	int			num_phys;
+	/* port flags */
+	unsigned int		is_backlink:1;
 
 	/* the other end of the link */
 	struct sas_rphy		*rphy;
@@ -175,6 +177,7 @@ void sas_port_free(struct sas_port *);
 void sas_port_delete(struct sas_port *);
 void sas_port_add_phy(struct sas_port *, struct sas_phy *);
 void sas_port_delete_phy(struct sas_port *, struct sas_phy *);
+void sas_port_mark_backlink(struct sas_port *);
 int scsi_is_sas_port(const struct device *);
 
 extern struct scsi_transport_template *

commit c9fefeb26457b87f4a767faefcf77321bb90db52
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sun Jul 2 11:10:18 2006 -0500

    [SCSI] scsi_transport_sas: add unindexed ports
    
    Some SAS HBAs don't want to go to the trouble of tracking port numbers,
    so they'd simply like to say "add this port and give it a number".
    This is especially beneficial from the hotplug point of view, since
    tracking ports and the available number space can be a real pain.
    
    The current implementation uses an incrementing number per expander to
    add the port on.  However, since there can never be more ports than
    there are phys, a later implementation will try to be more intelligent
    about this.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index e3c503cd175e..f5772ff61d0d 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -106,6 +106,7 @@ struct sas_end_device {
 
 struct sas_expander_device {
 	int    level;
+	int    next_port_id;
 
 	#define SAS_EXPANDER_VENDOR_ID_LEN	8
 	char   vendor_id[SAS_EXPANDER_VENDOR_ID_LEN+1];
@@ -127,7 +128,7 @@ struct sas_expander_device {
 struct sas_port {
 	struct device		dev;
 
-	u8			port_identifier;
+	int			port_identifier;
 	int			num_phys;
 
 	/* the other end of the link */
@@ -168,6 +169,7 @@ extern void sas_rphy_delete(struct sas_rphy *);
 extern int scsi_is_sas_rphy(const struct device *);
 
 struct sas_port *sas_port_alloc(struct device *, int);
+struct sas_port *sas_port_alloc_num(struct device *);
 int sas_port_add(struct sas_port *);
 void sas_port_free(struct sas_port *);
 void sas_port_delete(struct sas_port *);

commit 65c92b09acf0218b64f1c7ba4fdabeb8b732c876
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Wed Jun 28 12:22:50 2006 -0400

    [SCSI] scsi_transport_sas: introduce a sas_port entity
    
    this patch introduces a port object, separates out ports and phys,
    with ports becoming the primary objects of the tree.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 93cfb4bf4211..e3c503cd175e 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -3,6 +3,7 @@
 
 #include <linux/transport_class.h>
 #include <linux/types.h>
+#include <linux/mutex.h>
 
 struct scsi_transport_template;
 struct sas_rphy;
@@ -55,7 +56,6 @@ struct sas_phy {
 	enum sas_linkrate	minimum_linkrate;
 	enum sas_linkrate	maximum_linkrate_hw;
 	enum sas_linkrate	maximum_linkrate;
-	u8			port_identifier;
 
 	/* internal state */
 	unsigned int		local_attached : 1;
@@ -66,8 +66,8 @@ struct sas_phy {
 	u32			loss_of_dword_sync_count;
 	u32			phy_reset_problem_count;
 
-	/* the other end of the link */
-	struct sas_rphy		*rphy;
+	/* for the list of phys belonging to a port */
+	struct list_head	port_siblings;
 };
 
 #define dev_to_phy(d) \
@@ -124,6 +124,24 @@ struct sas_expander_device {
 #define rphy_to_expander_device(r) \
 	container_of((r), struct sas_expander_device, rphy)
 
+struct sas_port {
+	struct device		dev;
+
+	u8			port_identifier;
+	int			num_phys;
+
+	/* the other end of the link */
+	struct sas_rphy		*rphy;
+
+	struct mutex		phy_list_mutex;
+	struct list_head	phy_list;
+};
+
+#define dev_to_sas_port(d) \
+	container_of((d), struct sas_port, dev)
+#define transport_class_to_sas_port(cdev) \
+	dev_to_sas_port((cdev)->dev)
+
 /* The functions by which the transport class and the driver communicate */
 struct sas_function_template {
 	int (*get_linkerrors)(struct sas_phy *);
@@ -133,6 +151,7 @@ struct sas_function_template {
 };
 
 
+void sas_remove_children(struct device *);
 extern void sas_remove_host(struct Scsi_Host *);
 
 extern struct sas_phy *sas_phy_alloc(struct device *, int);
@@ -141,13 +160,21 @@ extern int sas_phy_add(struct sas_phy *);
 extern void sas_phy_delete(struct sas_phy *);
 extern int scsi_is_sas_phy(const struct device *);
 
-extern struct sas_rphy *sas_end_device_alloc(struct sas_phy *);
-extern struct sas_rphy *sas_expander_alloc(struct sas_phy *, enum sas_device_type);
+extern struct sas_rphy *sas_end_device_alloc(struct sas_port *);
+extern struct sas_rphy *sas_expander_alloc(struct sas_port *, enum sas_device_type);
 void sas_rphy_free(struct sas_rphy *);
 extern int sas_rphy_add(struct sas_rphy *);
 extern void sas_rphy_delete(struct sas_rphy *);
 extern int scsi_is_sas_rphy(const struct device *);
 
+struct sas_port *sas_port_alloc(struct device *, int);
+int sas_port_add(struct sas_port *);
+void sas_port_free(struct sas_port *);
+void sas_port_delete(struct sas_port *);
+void sas_port_add_phy(struct sas_port *, struct sas_phy *);
+void sas_port_delete_phy(struct sas_port *, struct sas_phy *);
+int scsi_is_sas_port(const struct device *);
+
 extern struct scsi_transport_template *
 sas_attach_transport(struct sas_function_template *);
 extern void sas_release_transport(struct scsi_transport_template *);

commit 2f8600dff2b140096a7df781884e918a16aa90e0
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sat Mar 18 15:00:50 2006 -0600

    [SCSI] eliminate rphy allocation in favour of expander/end device allocation
    
    This allows the removal of the contained flag and also does a bit of
    class renaming (sas_rphy->sas_device).
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 2943ccc22a43..93cfb4bf4211 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -82,10 +82,6 @@ struct sas_rphy {
 	struct sas_identify	identify;
 	struct list_head	list;
 	u32			scsi_target_id;
-	/* temporary expedient: mark the rphy as being contained
-	 * within a type specific rphy
-	 * FIXME: pull this out when everything uses the containers */
-	unsigned		contained:1;
 };
 
 #define dev_to_rphy(d) \
@@ -145,7 +141,6 @@ extern int sas_phy_add(struct sas_phy *);
 extern void sas_phy_delete(struct sas_phy *);
 extern int scsi_is_sas_phy(const struct device *);
 
-extern struct sas_rphy *sas_rphy_alloc(struct sas_phy *);
 extern struct sas_rphy *sas_end_device_alloc(struct sas_phy *);
 extern struct sas_rphy *sas_expander_alloc(struct sas_phy *, enum sas_device_type);
 void sas_rphy_free(struct sas_rphy *);

commit 79cb1819e231f811211133a09a5382cb89d7ec67
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Mon Mar 13 13:50:04 2006 -0600

    [SCSI] add preliminary expander support to the sas transport class
    
    This patch makes expanders appear as labelled objects with properties in
    the SAS tree.
    
    I've also modified the phy code to make expander phys appear labelled by
    host number, expander number and phy index.
    
    So, for my current config, you see something like this in sysfs:
    
    /sys/class/scsi_host/host1/device/phy-1:4/expander-1:0/phy-1-0:12/rphy-1:0-12/target1:0:1
    
    And the expander properties are:
    
    jejb@sparkweed> cd /sys/class/sas_expander/expander-1\:0/
    jejb@sparkweed> for f in *; do echo -n $f ": "; cat $f; done
    component_id : 29024
    component_revision_id : 4
    component_vendor_id : VITESSE
    device : cat: device: Is a directory
    level : 0
    product_id : VSC7160 Eval Brd
    product_rev : 4
    uevent : cat: uevent: Permission denied
    vendor_id : VITESSE
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 8fded431cf46..2943ccc22a43 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -108,6 +108,25 @@ struct sas_end_device {
 #define rphy_to_end_device(r) \
 	container_of((r), struct sas_end_device, rphy)
 
+struct sas_expander_device {
+	int    level;
+
+	#define SAS_EXPANDER_VENDOR_ID_LEN	8
+	char   vendor_id[SAS_EXPANDER_VENDOR_ID_LEN+1];
+	#define SAS_EXPANDER_PRODUCT_ID_LEN	16
+	char   product_id[SAS_EXPANDER_PRODUCT_ID_LEN+1];
+	#define SAS_EXPANDER_PRODUCT_REV_LEN	4
+	char   product_rev[SAS_EXPANDER_PRODUCT_REV_LEN+1];
+	#define SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN	8
+	char   component_vendor_id[SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN+1];
+	u16    component_id;
+	u8     component_revision_id;
+
+	struct sas_rphy		rphy;
+
+};
+#define rphy_to_expander_device(r) \
+	container_of((r), struct sas_expander_device, rphy)
 
 /* The functions by which the transport class and the driver communicate */
 struct sas_function_template {
@@ -128,6 +147,7 @@ extern int scsi_is_sas_phy(const struct device *);
 
 extern struct sas_rphy *sas_rphy_alloc(struct sas_phy *);
 extern struct sas_rphy *sas_end_device_alloc(struct sas_phy *);
+extern struct sas_rphy *sas_expander_alloc(struct sas_phy *, enum sas_device_type);
 void sas_rphy_free(struct sas_rphy *);
 extern int sas_rphy_add(struct sas_rphy *);
 extern void sas_rphy_delete(struct sas_rphy *);
@@ -138,4 +158,15 @@ sas_attach_transport(struct sas_function_template *);
 extern void sas_release_transport(struct scsi_transport_template *);
 int sas_read_port_mode_page(struct scsi_device *);
 
+static inline int
+scsi_is_sas_expander_device(struct device *dev)
+{
+	struct sas_rphy *rphy;
+	if (!scsi_is_sas_rphy(dev))
+		return 0;
+	rphy = dev_to_rphy(dev);
+	return rphy->identify.device_type == SAS_FANOUT_EXPANDER_DEVICE ||
+		rphy->identify.device_type == SAS_EDGE_EXPANDER_DEVICE;
+}
+
 #endif /* SCSI_TRANSPORT_SAS_H */

commit 42ab03609cca4ef5079e248296f015650c626899
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sat Mar 4 09:10:18 2006 -0600

    [PATCH] convert aic94xx over to using the sas transport end device
    
    Begin introducing the concept of sas remote devices that have an rphy
    embedded.  The first one (this) is a simple end device.  All that an
    end device really does is have port mode page parameters contained.
    The next and more complex piece will be expander remote devices.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 95e2132d485e..8fded431cf46 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -82,6 +82,10 @@ struct sas_rphy {
 	struct sas_identify	identify;
 	struct list_head	list;
 	u32			scsi_target_id;
+	/* temporary expedient: mark the rphy as being contained
+	 * within a type specific rphy
+	 * FIXME: pull this out when everything uses the containers */
+	unsigned		contained:1;
 };
 
 #define dev_to_rphy(d) \
@@ -90,6 +94,19 @@ struct sas_rphy {
 	dev_to_rphy((cdev)->dev)
 #define rphy_to_shost(rphy) \
 	dev_to_shost((rphy)->dev.parent)
+#define target_to_rphy(targ) \
+	dev_to_rphy((targ)->dev.parent)
+
+struct sas_end_device {
+	struct sas_rphy		rphy;
+	/* flags */
+	unsigned		ready_led_meaning:1;
+	/* parameters */
+	u16			I_T_nexus_loss_timeout;
+	u16			initiator_response_timeout;
+};
+#define rphy_to_end_device(r) \
+	container_of((r), struct sas_end_device, rphy)
 
 
 /* The functions by which the transport class and the driver communicate */
@@ -110,6 +127,7 @@ extern void sas_phy_delete(struct sas_phy *);
 extern int scsi_is_sas_phy(const struct device *);
 
 extern struct sas_rphy *sas_rphy_alloc(struct sas_phy *);
+extern struct sas_rphy *sas_end_device_alloc(struct sas_phy *);
 void sas_rphy_free(struct sas_rphy *);
 extern int sas_rphy_add(struct sas_rphy *);
 extern void sas_rphy_delete(struct sas_rphy *);
@@ -118,5 +136,6 @@ extern int scsi_is_sas_rphy(const struct device *);
 extern struct scsi_transport_template *
 sas_attach_transport(struct sas_function_template *);
 extern void sas_release_transport(struct scsi_transport_template *);
+int sas_read_port_mode_page(struct scsi_device *);
 
 #endif /* SCSI_TRANSPORT_SAS_H */

commit 7e6dff62dad539cbd608bb3b8b833193d13f00ac
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Thu Mar 2 14:12:56 2006 -0600

    [SCSI] add 6.0 Gbit phy definitions to the sas transport class
    
    I don't think these exist in silicon yet, but the aic94xx driver has a
    register setting for them.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index ccef5d2cf478..95e2132d485e 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -30,6 +30,7 @@ enum sas_linkrate {
 	SAS_SATA_PORT_SELECTOR,
 	SAS_LINK_RATE_1_5_GBPS,
 	SAS_LINK_RATE_3_0_GBPS,
+	SAS_LINK_RATE_6_0_GBPS,
 	SAS_LINK_VIRTUAL,
 };
 

commit a012564136a665f8d63443c057ba368572b483df
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Feb 16 13:31:47 2006 +0100

    [SCSI] sas: add support for enclosure and bad ID rphy attributes
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index b91400bfb02a..ccef5d2cf478 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -94,6 +94,8 @@ struct sas_rphy {
 /* The functions by which the transport class and the driver communicate */
 struct sas_function_template {
 	int (*get_linkerrors)(struct sas_phy *);
+	int (*get_enclosure_identifier)(struct sas_rphy *, u64 *);
+	int (*get_bay_identifier)(struct sas_rphy *);
 	int (*phy_reset)(struct sas_phy *, int);
 };
 

commit 07ba3a954714da10cbd3f6249d93ac2c1df72c4f
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Oct 19 20:01:31 2005 +0200

    [SCSI] sas: add support for PHY resets
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 57eb68c6e9a7..b91400bfb02a 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -94,6 +94,7 @@ struct sas_rphy {
 /* The functions by which the transport class and the driver communicate */
 struct sas_function_template {
 	int (*get_linkerrors)(struct sas_phy *);
+	int (*phy_reset)(struct sas_phy *, int);
 };
 
 

commit ac01bbbd3b7ebfca64357aed12cf476b16abe3ce
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Oct 19 20:01:17 2005 +0200

    [SCSI] sas: add flag for locally attached PHYs
    
    Add a flag to mark a PHY as attached to the HBA as opposed to beeing on
    an expander.  This is needed because various features are only supported
    on those.  This is a crude hack, the proper fix would be to use
    different classes for host-attached vs expander phys.  I'm looking into
    that.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index 38389d8dd56e..57eb68c6e9a7 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -56,6 +56,9 @@ struct sas_phy {
 	enum sas_linkrate	maximum_linkrate;
 	u8			port_identifier;
 
+	/* internal state */
+	unsigned int		local_attached : 1;
+
 	/* link error statistics */
 	u32			invalid_dword_count;
 	u32			running_disparity_error_count;

commit c3ee74c4e91017169c7f1fa74a57ba8502ec49c3
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Sep 19 21:59:42 2005 +0200

    [SCSI] scsi_transport_sas: support link error attributes
    
    For now supporting the ->get_linkerrors method is mandatory.  I'll
    probably be beaten to implement the .show_foo variables and different
    types of attributes soon..
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
index bc4aeb660dd3..38389d8dd56e 100644
--- a/include/scsi/scsi_transport_sas.h
+++ b/include/scsi/scsi_transport_sas.h
@@ -41,20 +41,28 @@ struct sas_identify {
 	u8			phy_identifier;
 };
 
-/* The functions by which the transport class and the driver communicate */
-struct sas_function_template {
-};
-
 struct sas_phy {
 	struct device		dev;
 	int			number;
+
+	/* phy identification */
 	struct sas_identify	identify;
+
+	/* phy attributes */
 	enum sas_linkrate	negotiated_linkrate;
 	enum sas_linkrate	minimum_linkrate_hw;
 	enum sas_linkrate	minimum_linkrate;
 	enum sas_linkrate	maximum_linkrate_hw;
 	enum sas_linkrate	maximum_linkrate;
 	u8			port_identifier;
+
+	/* link error statistics */
+	u32			invalid_dword_count;
+	u32			running_disparity_error_count;
+	u32			loss_of_dword_sync_count;
+	u32			phy_reset_problem_count;
+
+	/* the other end of the link */
 	struct sas_rphy		*rphy;
 };
 
@@ -79,6 +87,13 @@ struct sas_rphy {
 #define rphy_to_shost(rphy) \
 	dev_to_shost((rphy)->dev.parent)
 
+
+/* The functions by which the transport class and the driver communicate */
+struct sas_function_template {
+	int (*get_linkerrors)(struct sas_phy *);
+};
+
+
 extern void sas_remove_host(struct Scsi_Host *);
 
 extern struct sas_phy *sas_phy_alloc(struct device *, int);

commit c7ebbbce366c02e5657ac6b6059933fe0353b175
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Sep 9 16:22:50 2005 +0200

    [SCSI] SAS transport class
    
    The SAS transport class contains common code to deal with SAS HBAs, an
    aproximated representation of SAS topologies in the driver model,
    and various sysfs attributes to expose these topologies and managment
    interfaces to userspace.
    
    In addition to the basic SCSI core objects this transport class introduces
    two additional intermediate objects:  The SAS PHY as represented by struct
    sas_phy defines an "outgoing" PHY on a SAS HBA or Expander, and the SAS
    remote PHY represented by struct sas_rphy defines an "incoming" PHY on a
    SAS Expander or end device.  Note that this is purely a software concept, the
    underlying hardware for a PHY and a remote PHY is the exactly the same.
    
    There is no concept of a SAS port in this code, users can see what PHYs
    form a wide port based on the port_identifier attribute, which is the same
    for all PHYs in a port.
    
    This submission doesn't handle hot-plug addition or removal of SAS devices
    and thus doesn't do scanning in a workqueue yet, that will be added in
    phase2 after this submission.  In a third phase I will add additional
    managment infrastructure.
    
    I think this submission is ready for 2.6.14, but additional comments are
    of course very welcome.
    
    I'd like to thanks James Smart a lot for his very useful input on the
    design.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h
new file mode 100644
index 000000000000..bc4aeb660dd3
--- /dev/null
+++ b/include/scsi/scsi_transport_sas.h
@@ -0,0 +1,100 @@
+#ifndef SCSI_TRANSPORT_SAS_H
+#define SCSI_TRANSPORT_SAS_H
+
+#include <linux/transport_class.h>
+#include <linux/types.h>
+
+struct scsi_transport_template;
+struct sas_rphy;
+
+
+enum sas_device_type {
+	SAS_PHY_UNUSED,
+	SAS_END_DEVICE,
+	SAS_EDGE_EXPANDER_DEVICE,
+	SAS_FANOUT_EXPANDER_DEVICE,
+};
+
+enum sas_protocol {
+	SAS_PROTOCOL_SATA		= 0x01,
+	SAS_PROTOCOL_SMP		= 0x02,
+	SAS_PROTOCOL_STP		= 0x04,
+	SAS_PROTOCOL_SSP		= 0x08,
+};
+
+enum sas_linkrate {
+	SAS_LINK_RATE_UNKNOWN,
+	SAS_PHY_DISABLED,
+	SAS_LINK_RATE_FAILED,
+	SAS_SATA_SPINUP_HOLD,
+	SAS_SATA_PORT_SELECTOR,
+	SAS_LINK_RATE_1_5_GBPS,
+	SAS_LINK_RATE_3_0_GBPS,
+	SAS_LINK_VIRTUAL,
+};
+
+struct sas_identify {
+	enum sas_device_type	device_type;
+	enum sas_protocol	initiator_port_protocols;
+	enum sas_protocol	target_port_protocols;
+	u64			sas_address;
+	u8			phy_identifier;
+};
+
+/* The functions by which the transport class and the driver communicate */
+struct sas_function_template {
+};
+
+struct sas_phy {
+	struct device		dev;
+	int			number;
+	struct sas_identify	identify;
+	enum sas_linkrate	negotiated_linkrate;
+	enum sas_linkrate	minimum_linkrate_hw;
+	enum sas_linkrate	minimum_linkrate;
+	enum sas_linkrate	maximum_linkrate_hw;
+	enum sas_linkrate	maximum_linkrate;
+	u8			port_identifier;
+	struct sas_rphy		*rphy;
+};
+
+#define dev_to_phy(d) \
+	container_of((d), struct sas_phy, dev)
+#define transport_class_to_phy(cdev) \
+	dev_to_phy((cdev)->dev)
+#define phy_to_shost(phy) \
+	dev_to_shost((phy)->dev.parent)
+
+struct sas_rphy {
+	struct device		dev;
+	struct sas_identify	identify;
+	struct list_head	list;
+	u32			scsi_target_id;
+};
+
+#define dev_to_rphy(d) \
+	container_of((d), struct sas_rphy, dev)
+#define transport_class_to_rphy(cdev) \
+	dev_to_rphy((cdev)->dev)
+#define rphy_to_shost(rphy) \
+	dev_to_shost((rphy)->dev.parent)
+
+extern void sas_remove_host(struct Scsi_Host *);
+
+extern struct sas_phy *sas_phy_alloc(struct device *, int);
+extern void sas_phy_free(struct sas_phy *);
+extern int sas_phy_add(struct sas_phy *);
+extern void sas_phy_delete(struct sas_phy *);
+extern int scsi_is_sas_phy(const struct device *);
+
+extern struct sas_rphy *sas_rphy_alloc(struct sas_phy *);
+void sas_rphy_free(struct sas_rphy *);
+extern int sas_rphy_add(struct sas_rphy *);
+extern void sas_rphy_delete(struct sas_rphy *);
+extern int scsi_is_sas_rphy(const struct device *);
+
+extern struct scsi_transport_template *
+sas_attach_transport(struct sas_function_template *);
+extern void sas_release_transport(struct scsi_transport_template *);
+
+#endif /* SCSI_TRANSPORT_SAS_H */
