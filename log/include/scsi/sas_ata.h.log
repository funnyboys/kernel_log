commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index 00f41aeeecf5..416c9c47d0e7 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -1,25 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Support for SATA devices on Serial Attached SCSI (SAS) controllers
  *
  * Copyright (C) 2006 IBM Corporation
  *
  * Written by: Darrick J. Wong <djwong@us.ibm.com>, IBM Corporation
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA
- *
  */
 
 #ifndef _SAS_ATA_H_

commit aa9f8328fc51460e15da129caf622b6560fa8c99
Author: James Bottomley <JBottomley@Parallels.com>
Date:   Tue May 7 14:44:06 2013 -0700

    [SCSI] sas: unify the pointlessly separated enums sas_dev_type and sas_device_type
    
    These enums have been separate since the dawn of SAS, mainly because the
    latter is a procotol only enum and the former includes additional state
    for libsas.  The dichotomy causes endless confusion about which one you
    should use where and leads to pointless warnings like this:
    
    drivers/scsi/mvsas/mv_sas.c: In function 'mvs_update_phyinfo':
    drivers/scsi/mvsas/mv_sas.c:1162:34: warning: comparison between 'enum sas_device_type' and 'enum sas_dev_type' [-Wenum-compare]
    
    Fix by eliminating one of them.  The one kept is effectively the sas.h
    one, but call it sas_device_type and make sure the enums are all
    properly namespaced with the SAS_ prefix.
    
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index ff71a5654684..00f41aeeecf5 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -32,8 +32,8 @@
 
 static inline int dev_is_sata(struct domain_device *dev)
 {
-	return dev->dev_type == SATA_DEV || dev->dev_type == SATA_PM ||
-	       dev->dev_type == SATA_PM_PORT || dev->dev_type == SATA_PENDING;
+	return dev->dev_type == SAS_SATA_DEV || dev->dev_type == SAS_SATA_PM ||
+	       dev->dev_type == SAS_SATA_PM_PORT || dev->dev_type == SAS_SATA_PENDING;
 }
 
 int sas_get_ata_info(struct domain_device *dev, struct ex_phy *phy);

commit 303694eeee5eacad5b84105a15afd9e351e1891b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 21 23:41:51 2012 -0700

    [SCSI] libsas: suspend / resume support
    
    libsas power management routines to suspend and recover the sas domain
    based on a model where the lldd is allowed and expected to be
    "forgetful".
    
    sas_suspend_ha - disable event processing allowing the lldd to take down
                     links without concern for causing hotplug events.
                     Regardless of whether the lldd actually posts link down
                     messages libsas notifies the lldd that all
                     domain_devices are gone.
    
    sas_prep_resume_ha - on the way back up before the lldd starts link
                         training clean out any spurious events that were
                         generated on the way down, and re-enable event
                         processing
    
    sas_resume_ha - after the lldd has started and decided that all phys
                    have posted link-up events this routine is called to let
                    libsas start it's own timeout of any phys that did not
                    resume.  After the timeout an lldd can cancel the
                    phy teardown by posting a link-up event.
    
    Storage for ex_change_count (u16) and phy_change_count (u8) are changed
    to int so they can be set to -1 to indicate 'invalidated'.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Jacek Danecki <jacek.danecki@intel.com>
    Tested-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index 2dfbdaa0b34a..ff71a5654684 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -45,6 +45,8 @@ void sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
 void sas_ata_schedule_reset(struct domain_device *dev);
 void sas_ata_wait_eh(struct domain_device *dev);
 void sas_probe_sata(struct asd_sas_port *port);
+void sas_suspend_sata(struct asd_sas_port *port);
+void sas_resume_sata(struct asd_sas_port *port);
 void sas_ata_end_eh(struct ata_port *ap);
 #else
 
@@ -82,6 +84,14 @@ static inline void sas_probe_sata(struct asd_sas_port *port)
 {
 }
 
+static inline void sas_suspend_sata(struct asd_sas_port *port)
+{
+}
+
+static inline void sas_resume_sata(struct asd_sas_port *port)
+{
+}
+
 static inline int sas_get_ata_info(struct domain_device *dev, struct ex_phy *phy)
 {
 	return 0;

commit e4a9c3732cea3e3c8c704aad86636090ffe6b25f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 21 23:25:27 2012 -0700

    [SCSI] libata, libsas: introduce sched_eh and end_eh port ops
    
    When managing shost->host_eh_scheduled libata assumes that there is a
    1:1 shost-to-ata_port relationship.  libsas creates a 1:N relationship
    so it needs to manage host_eh_scheduled cumulatively at the host level.
    The sched_eh and end_eh port port ops allow libsas to track when domain
    devices enter/leave the "eh-pending" state under ha->lock (previously
    named ha->state_lock, but it is no longer just a lock for ha->state
    changes).
    
    Since host_eh_scheduled indicates eh without backing commands pinning
    the device it can be deallocated at any time.  Move the taking of the
    domain_device reference under the port_lock to guarantee that the
    ata_port stays around for the duration of eh.
    
    Reviewed-by: Jacek Danecki <jacek.danecki@intel.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index 77670e823ed8..2dfbdaa0b34a 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -45,6 +45,7 @@ void sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
 void sas_ata_schedule_reset(struct domain_device *dev);
 void sas_ata_wait_eh(struct domain_device *dev);
 void sas_probe_sata(struct asd_sas_port *port);
+void sas_ata_end_eh(struct ata_port *ap);
 #else
 
 
@@ -85,6 +86,10 @@ static inline int sas_get_ata_info(struct domain_device *dev, struct ex_phy *phy
 {
 	return 0;
 }
+
+static inline void sas_ata_end_eh(struct ata_port *ap)
+{
+}
 #endif
 
 #endif /* _SAS_ATA_H_ */

commit b2024459252a9d2d312ee562f86f332a1498f412
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Mar 21 21:09:07 2012 -0700

    [SCSI] libsas, libata: fix start of life for a sas ata_port
    
    This changes the ordering of initialization and probing events from:
      1/ allocate rphy in PORTE_BYTES_DMAED, DISCE_REVALIDATE_DOMAIN
      2/ allocate ata_port and schedule port probe in DISCE_PROBE
    ...to:
      1/ allocate ata_port in PORTE_BYTES_DMAED, DISCE_REVALIDATE_DOMAIN
      2/ allocate rphy in PORTE_BYTES_DMAED, DISCE_REVALIDATE_DOMAIN
      3/ schedule port probe in DISCE_PROBE
    
    This ordering prevents PHYE_SIGNAL_LOSS_EVENTS from sneaking in to
    destrory ata devices before they have been fully initialized:
    
      BUG: unable to handle kernel paging request at 0000000000003b10
      IP: [<ffffffffa0053d7e>] sas_ata_end_eh+0x12/0x5e [libsas]
      ...
      [<ffffffffa004d1af>] sas_unregister_common_dev+0x78/0xc9 [libsas]
      [<ffffffffa004d4d4>] sas_unregister_dev+0x4f/0xad [libsas]
      [<ffffffffa004d5b1>] sas_unregister_domain_devices+0x7f/0xbf [libsas]
      [<ffffffffa004c487>] sas_deform_port+0x61/0x1b8 [libsas]
      [<ffffffffa004bed0>] sas_phye_loss_of_signal+0x29/0x2b [libsas]
    
    ...and kills the awkward "sata domain_device briefly existing in the
    domain without an ata_port" state.
    
    Reported-by: Michal Kosciowski <michal.kosciowski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index cdccd2eb7b6c..77670e823ed8 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -37,7 +37,7 @@ static inline int dev_is_sata(struct domain_device *dev)
 }
 
 int sas_get_ata_info(struct domain_device *dev, struct ex_phy *phy);
-int sas_ata_init_host_and_port(struct domain_device *found_dev);
+int sas_ata_init(struct domain_device *dev);
 void sas_ata_task_abort(struct sas_task *task);
 void sas_ata_strategy_handler(struct Scsi_Host *shost);
 void sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
@@ -52,7 +52,7 @@ static inline int dev_is_sata(struct domain_device *dev)
 {
 	return 0;
 }
-static inline int sas_ata_init_host_and_port(struct domain_device *found_dev)
+static inline int sas_ata_init(struct domain_device *dev)
 {
 	return 0;
 }

commit 9508a66f898d46e726a318469312b45e0b1d078b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jan 18 20:47:01 2012 -0800

    [SCSI] libsas: async ata scanning
    
    libsas ata error handling is already async but this does not help the
    scan case.  Move initial link recovery out from under host->scan_mutex,
    and delay synchronization with eh until after all port probe/recovery
    work has been queued.
    
    Device ordering is maintained with scan order by still calling
    sas_rphy_add() in order of domain discovery.
    
    Since we now scan the domain list when invoking libata-eh we need to be
    careful to check for fully initialized ata ports.
    
    Acked-by: Jack Wang <jack_wang@usish.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index 1556eff4cc44..cdccd2eb7b6c 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -37,15 +37,14 @@ static inline int dev_is_sata(struct domain_device *dev)
 }
 
 int sas_get_ata_info(struct domain_device *dev, struct ex_phy *phy);
-int sas_ata_init_host_and_port(struct domain_device *found_dev,
-			       struct scsi_target *starget);
-
+int sas_ata_init_host_and_port(struct domain_device *found_dev);
 void sas_ata_task_abort(struct sas_task *task);
 void sas_ata_strategy_handler(struct Scsi_Host *shost);
 void sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
 		struct list_head *done_q);
 void sas_ata_schedule_reset(struct domain_device *dev);
 void sas_ata_wait_eh(struct domain_device *dev);
+void sas_probe_sata(struct asd_sas_port *port);
 #else
 
 
@@ -53,8 +52,7 @@ static inline int dev_is_sata(struct domain_device *dev)
 {
 	return 0;
 }
-static inline int sas_ata_init_host_and_port(struct domain_device *found_dev,
-			       struct scsi_target *starget)
+static inline int sas_ata_init_host_and_port(struct domain_device *found_dev)
 {
 	return 0;
 }
@@ -79,6 +77,10 @@ static inline void sas_ata_wait_eh(struct domain_device *dev)
 {
 }
 
+static inline void sas_probe_sata(struct asd_sas_port *port)
+{
+}
+
 static inline int sas_get_ata_info(struct domain_device *dev, struct ex_phy *phy)
 {
 	return 0;

commit 92625f9bff3853951cc75f5bc084ee67c1317d2f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jan 18 20:14:01 2012 -0800

    [SCSI] libsas: restore scan order
    
    ata devices are always scanned after ssp.  Prior to the ata error
    handling reworks libsas would tend to scan devices in ascending expander
    phy order.  Restore this ordering by deferring ssp discovery to a
    DISCE_PROBE event, and keep the probe order consistent with the
    discovery order, not the placement of sata devices.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index 0ca2f8a6bc60..1556eff4cc44 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -44,7 +44,6 @@ void sas_ata_task_abort(struct sas_task *task);
 void sas_ata_strategy_handler(struct Scsi_Host *shost);
 void sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
 		struct list_head *done_q);
-void sas_probe_sata(struct work_struct *work);
 void sas_ata_schedule_reset(struct domain_device *dev);
 void sas_ata_wait_eh(struct domain_device *dev);
 #else
@@ -72,10 +71,6 @@ static inline void sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
 {
 }
 
-static inline void sas_probe_sata(struct work_struct *work)
-{
-}
-
 static inline void sas_ata_schedule_reset(struct domain_device *dev)
 {
 }

commit 354cf82980e2449e71fdaa3c6f170357ebd65467
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jan 12 17:57:35 2012 -0800

    [SCSI] libsas: let libata recover links that fail to transmit initial sig-fis
    
    libsas fails to discover all sata devices in the domain.  If a device fails
    negotiation and does not transmit a signature fis the link needs recovery.
    libata already understands how to manage slow to come up links, so treat these
    conditions as ata device attach events for the purposes of creating an
    ata_port.  This allows libata to manage retrying link bring up.
    
    Rediscovery is modified to be careful about checking changes in dev_type.  It
    looks like libsas leaks old devices if the sas address changes, but that's a
    fix for another patch.
    
    Acked-by: Jack Wang <jack_wang@usish.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index cb724fd010f6..0ca2f8a6bc60 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -33,9 +33,10 @@
 static inline int dev_is_sata(struct domain_device *dev)
 {
 	return dev->dev_type == SATA_DEV || dev->dev_type == SATA_PM ||
-	       dev->dev_type == SATA_PM_PORT;
+	       dev->dev_type == SATA_PM_PORT || dev->dev_type == SATA_PENDING;
 }
 
+int sas_get_ata_info(struct domain_device *dev, struct ex_phy *phy);
 int sas_ata_init_host_and_port(struct domain_device *found_dev,
 			       struct scsi_target *starget);
 
@@ -82,6 +83,11 @@ static inline void sas_ata_schedule_reset(struct domain_device *dev)
 static inline void sas_ata_wait_eh(struct domain_device *dev)
 {
 }
+
+static inline int sas_get_ata_info(struct domain_device *dev, struct ex_phy *phy)
+{
+	return 0;
+}
 #endif
 
 #endif /* _SAS_ATA_H_ */

commit d230ce691c7712c4f56ba3378d6d2f44628a49f1
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jan 11 12:08:36 2012 -0800

    [SCSI] libsas: fix mixed topology recovery
    
    If we have a domain with sas and sata devices there may still be sas
    recovery actions to take after peeling off the commands to send to
    libata.
    
    Reported-by: Andrzej Jakowski <andrzej.jakowski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index da3f37727387..cb724fd010f6 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -41,8 +41,8 @@ int sas_ata_init_host_and_port(struct domain_device *found_dev,
 
 void sas_ata_task_abort(struct sas_task *task);
 void sas_ata_strategy_handler(struct Scsi_Host *shost);
-int sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
-	       struct list_head *done_q);
+void sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
+		struct list_head *done_q);
 void sas_probe_sata(struct work_struct *work);
 void sas_ata_schedule_reset(struct domain_device *dev);
 void sas_ata_wait_eh(struct domain_device *dev);
@@ -66,10 +66,9 @@ static inline void sas_ata_strategy_handler(struct Scsi_Host *shost)
 {
 }
 
-static inline int sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
-			     struct list_head *done_q)
+static inline void sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
+			      struct list_head *done_q)
 {
-	return 0;
 }
 
 static inline void sas_probe_sata(struct work_struct *work)

commit 81c757bc696284f39f07766f0c2ca67af64ce9bd
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Dec 2 16:07:01 2011 -0800

    [SCSI] libsas: execute transport link resets with libata-eh via host workqueue
    
    Link resets leave ata affiliations intact, so arrange for libsas to make
    an effort to avoid dropping the device due to a slow-to-recover link.
    Towards this end carry out reset in the host workqueue so that it can
    check for ata devices and kick the reset request to libata.  Hard
    resets, in contrast, bypass libata since they are meant for associating
    an ata device with another initiator in the domain (tears down
    affiliations).
    
    Need to add a new transport_sas_phy_reset() since the current
    sas_phy_reset() is a utility function to libsas lldds.  They are not
    prepared for it to loop back into eh.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index c0bcd30eec56..da3f37727387 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -45,6 +45,7 @@ int sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
 	       struct list_head *done_q);
 void sas_probe_sata(struct work_struct *work);
 void sas_ata_schedule_reset(struct domain_device *dev);
+void sas_ata_wait_eh(struct domain_device *dev);
 #else
 
 
@@ -79,6 +80,9 @@ static inline void sas_ata_schedule_reset(struct domain_device *dev)
 {
 }
 
+static inline void sas_ata_wait_eh(struct domain_device *dev)
+{
+}
 #endif
 
 #endif /* _SAS_ATA_H_ */

commit b52df4174dff7e587f6fbfb21e3c2cb57109e5cf
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Nov 30 23:23:33 2011 -0800

    [SCSI] libsas: use libata-eh-reset for sata rediscovery fis transmit failures
    
    Since sata devices can take several seconds to recover the link on reset
    the 0.5 seconds that libsas currently waits may not be enough.  Instead
    if we are rediscovering a phy that was previously attached to a sata
    device let libata handle any resets to encourage the device to transmit
    the initial fis.
    
    Once sas_ata_hard_reset() and lldds learn how to honor 'deadline' libsas
    should stop encountering phys in an intermediate state, until then this
    will loop until the fis is transmitted or ->attached_sas_addr gets
    cleared, but in the more likely initial discovery case we keep existing
    behavior.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index 9f7a23d1146d..c0bcd30eec56 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -44,7 +44,7 @@ void sas_ata_strategy_handler(struct Scsi_Host *shost);
 int sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
 	       struct list_head *done_q);
 void sas_probe_sata(struct work_struct *work);
-
+void sas_ata_schedule_reset(struct domain_device *dev);
 #else
 
 
@@ -75,6 +75,10 @@ static inline void sas_probe_sata(struct work_struct *work)
 {
 }
 
+static inline void sas_ata_schedule_reset(struct domain_device *dev)
+{
+}
+
 #endif
 
 #endif /* _SAS_ATA_H_ */

commit 9095a64a9aead653df320e3a6fc70835c15d46e4
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Nov 28 11:29:20 2011 -0800

    [SCSI] libsas: fix timeout vs completion race
    
    Until we have told the lldd to forget a task a timed out operation can
    return from the hardware at any time.  Since completion frees the task
    we need to make sure that no tasks run their normal completion handler
    once eh has decided to manage the task.  Similar to
    ata_scsi_cmd_error_handler() freeze completions to let eh judge the
    outcome of the race.
    
    Task collector mode is problematic because it presents a situation where
    a task can be timed out and aborted before the lldd has even seen it.
    For this case we need to guarantee that a task that an lldd has been
    told to forget does not get queued after the lldd says "never seen it".
    With sas_scsi_timed_out we achieve this with the ->task_queue_flush
    mutex, rather than adding more time.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index 557fc9a8559b..9f7a23d1146d 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -41,8 +41,6 @@ int sas_ata_init_host_and_port(struct domain_device *found_dev,
 
 void sas_ata_task_abort(struct sas_task *task);
 void sas_ata_strategy_handler(struct Scsi_Host *shost);
-int sas_ata_timed_out(struct scsi_cmnd *cmd, struct sas_task *task,
-		      enum blk_eh_timer_return *rtn);
 int sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
 	       struct list_head *done_q);
 void sas_probe_sata(struct work_struct *work);
@@ -67,12 +65,6 @@ static inline void sas_ata_strategy_handler(struct Scsi_Host *shost)
 {
 }
 
-static inline int sas_ata_timed_out(struct scsi_cmnd *cmd,
-				    struct sas_task *task,
-				    enum blk_eh_timer_return *rtn)
-{
-	return 0;
-}
 static inline int sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
 			     struct list_head *done_q)
 {

commit 87c8331fcf72e501c3a3c0cdc5c9391ec72f7cf2
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Nov 17 17:59:51 2011 -0800

    [SCSI] libsas: prevent domain rediscovery competing with ata error handling
    
    libata error handling provides for a timeout for link recovery.  libsas
    must not rescan for previously known devices in this interval otherwise
    it may remove a device that is simply waiting for its link to recover.
    Let libata-eh make the determination of when the link is stable and
    prevent libsas (host workqueue) from taking action while this
    determination is pending.
    
    Using a mutex (ha->disco_mutex) to flush and disable revalidation while
    eh is running requires any discovery action that may block on eh be
    moved to its own context outside the lock.  Probing ATA devices
    explicitly waits on ata-eh and the cache-flush-io issued during device
    removal may also pend awaiting eh completion.  Essentially any rphy
    add/remove activity needs to run outside the lock.
    
    This adds two new cleanup states for sas_unregister_domain_devices()
    'allocated-but-not-probed', and 'flagged-for-destruction'.  In the
    'allocated-but-not-probed' state  dev->rphy points to a rphy that is
    known to have not been through a sas_rphy_add() event.  At domain
    teardown check if this device is still pending probe and cleanup
    accordingly.  Similarly if a device has already been queued for removal
    then sas_unregister_domain_devices has nothing to do.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index 7d5013f8653d..557fc9a8559b 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -45,6 +45,7 @@ int sas_ata_timed_out(struct scsi_cmnd *cmd, struct sas_task *task,
 		      enum blk_eh_timer_return *rtn);
 int sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
 	       struct list_head *done_q);
+void sas_probe_sata(struct work_struct *work);
 
 #else
 
@@ -78,6 +79,10 @@ static inline int sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
 	return 0;
 }
 
+static inline void sas_probe_sata(struct work_struct *work)
+{
+}
+
 #endif
 
 #endif /* _SAS_ATA_H_ */

commit 756f173fb5fa90ec15222e80fb579288be7794fd
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Nov 17 17:59:48 2011 -0800

    [SCSI] libsas: fix leak of dev->sata_dev.identify_[packet_]device
    
    These are never freed in the nominal path.  A domain_device has a
    different lifetime than a sas_rphy we need a dev->rphy independent way
    of identifying sata devices.
    
    Reviewed-by: Jack Wang <jack_wang@usish.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index 9c159f74c6d0..7d5013f8653d 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -32,7 +32,8 @@
 
 static inline int dev_is_sata(struct domain_device *dev)
 {
-	return (dev->rphy->identify.target_port_protocols & SAS_PROTOCOL_SATA);
+	return dev->dev_type == SATA_DEV || dev->dev_type == SATA_PM ||
+	       dev->dev_type == SATA_PM_PORT;
 }
 
 int sas_ata_init_host_and_port(struct domain_device *found_dev,

commit 00dd4998a60599d98b4d6635820a1fbeafa5b021
Author: James Bottomley <James.Bottomley@suse.de>
Date:   Sun Jan 23 09:44:12 2011 -0600

    libsas: convert to libata new error handler
    
    The conversion is quite complex given that the libata new error
    handler has to be hooked into the current libsas timeout and error
    handling.  The way this is done is to process all the failed commands
    via libsas first, but if they have no underlying sas task (and they're
    on a sata device) assume they are destined for the libata error
    handler and send them accordingly.
    
    Finally, activate the port recovery of the libata error handler for
    each port known to the host.  This is somewhat suboptimal, since that
    port may not need recovering, but given the current architecture of
    the libata error handler, it's the only way; and the spurious
    activation is harmless.
    
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index c583193ae929..9c159f74c6d0 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -39,6 +39,11 @@ int sas_ata_init_host_and_port(struct domain_device *found_dev,
 			       struct scsi_target *starget);
 
 void sas_ata_task_abort(struct sas_task *task);
+void sas_ata_strategy_handler(struct Scsi_Host *shost);
+int sas_ata_timed_out(struct scsi_cmnd *cmd, struct sas_task *task,
+		      enum blk_eh_timer_return *rtn);
+int sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
+	       struct list_head *done_q);
 
 #else
 
@@ -55,6 +60,23 @@ static inline int sas_ata_init_host_and_port(struct domain_device *found_dev,
 static inline void sas_ata_task_abort(struct sas_task *task)
 {
 }
+
+static inline void sas_ata_strategy_handler(struct Scsi_Host *shost)
+{
+}
+
+static inline int sas_ata_timed_out(struct scsi_cmnd *cmd,
+				    struct sas_task *task,
+				    enum blk_eh_timer_return *rtn)
+{
+	return 0;
+}
+static inline int sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,
+			     struct list_head *done_q)
+{
+	return 0;
+}
+
 #endif
 
 #endif /* _SAS_ATA_H_ */

commit 79bc14813cd7e1b75d2e4cbbc17043261cf4bcdc
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Thu Apr 3 09:04:31 2008 -0500

    [SCSI] libsas: fix missing inlines in header file
    
    Two functions in include/scsi/sas_ata.h don't have static inlines
    leading to problems if they're built in:
    
    On Thu, 2008-04-03 at 14:06 +0200, Toralf Förster wrote:
    > drivers/scsi/mvsas.o: In function `sas_ata_init_host_and_port':
    > mvsas.c:(.text+0x0): multiple definition of `sas_ata_init_host_and_port'
    > drivers/scsi/libsas/built-in.o:(.text+0x37f4): first defined here
    > drivers/scsi/mvsas.o: In function `sas_ata_task_abort':
    > mvsas.c:(.text+0x7): multiple definition of `sas_ata_task_abort'
    > drivers/scsi/libsas/built-in.o:(.text+0x37fb): first defined here
    > make[2]: *** [drivers/scsi/built-in.o] Error 1
    > make[1]: *** [drivers/scsi] Error 2
    > make: *** [drivers] Error 2
    
    Add the correct static inline modifiers.
    
    Tested-by: Toralf Förster <toralf.foerster@gmx.de>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index dd5edc915417..c583193ae929 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -47,12 +47,12 @@ static inline int dev_is_sata(struct domain_device *dev)
 {
 	return 0;
 }
-int sas_ata_init_host_and_port(struct domain_device *found_dev,
+static inline int sas_ata_init_host_and_port(struct domain_device *found_dev,
 			       struct scsi_target *starget)
 {
 	return 0;
 }
-void sas_ata_task_abort(struct sas_task *task)
+static inline void sas_ata_task_abort(struct sas_task *task)
 {
 }
 #endif

commit b91421749a1840148d8c81637c03c0ace3f35269
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sun Jul 22 13:15:55 2007 -0500

    [SCSI] libsas: make ATA functions selectable by a config option
    
    Not everyone wants libsas automatically to pull in libata.  This patch
    makes the behaviour configurable, so you can build libsas with or
    without ATA support.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index 3407c819522d..dd5edc915417 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -28,6 +28,8 @@
 #include <linux/libata.h>
 #include <scsi/libsas.h>
 
+#ifdef CONFIG_SCSI_SAS_ATA
+
 static inline int dev_is_sata(struct domain_device *dev)
 {
 	return (dev->rphy->identify.target_port_protocols & SAS_PROTOCOL_SATA);
@@ -38,4 +40,21 @@ int sas_ata_init_host_and_port(struct domain_device *found_dev,
 
 void sas_ata_task_abort(struct sas_task *task);
 
+#else
+
+
+static inline int dev_is_sata(struct domain_device *dev)
+{
+	return 0;
+}
+int sas_ata_init_host_and_port(struct domain_device *found_dev,
+			       struct scsi_target *starget)
+{
+	return 0;
+}
+void sas_ata_task_abort(struct sas_task *task)
+{
+}
+#endif
+
 #endif /* _SAS_ATA_H_ */

commit 3a2755af37b317d47fdc3dd15178adaf5d47263e
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Tue Jan 30 01:18:58 2007 -0800

    [SCSI] sas_ata: Implement sas_task_abort for ATA devices
    
    ATA devices need special handling for sas_task_abort.  If the ATA command
    came from SCSI, then we merely need to tell SCSI to abort the scsi_cmnd.
    However, internal commands require a bit more work--we need to fill the qc
    with the appropriate error status and complete the command, and eventually
    post_internal will issue the actual ABORT TASK.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
index 72a1904169a5..3407c819522d 100644
--- a/include/scsi/sas_ata.h
+++ b/include/scsi/sas_ata.h
@@ -36,4 +36,6 @@ static inline int dev_is_sata(struct domain_device *dev)
 int sas_ata_init_host_and_port(struct domain_device *found_dev,
 			       struct scsi_target *starget);
 
+void sas_ata_task_abort(struct sas_task *task);
+
 #endif /* _SAS_ATA_H_ */

commit 338ec57003ff9d7bc1471677e61872455977a5de
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Wed Oct 18 14:43:37 2006 -0700

    [SCSI] Migrate libsas ATA code into a separate file
    
    This is a respin of my earlier patch that migrates the ATA support code
    into a separate file.  For now, the controversial linking bits have
    been removed per James Bottomley's request for a patch that contains
    only the migration diffs, which means that libsas continues to require
    libata.  I intend to address that problem in a separate patch.
    
    This patch is against the aic94xx-sas-2.6 git tree, and it has been
    sanity tested on my x206m with Seagate SATA and SAS disks without
    uncovering any new problems.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/sas_ata.h b/include/scsi/sas_ata.h
new file mode 100644
index 000000000000..72a1904169a5
--- /dev/null
+++ b/include/scsi/sas_ata.h
@@ -0,0 +1,39 @@
+/*
+ * Support for SATA devices on Serial Attached SCSI (SAS) controllers
+ *
+ * Copyright (C) 2006 IBM Corporation
+ *
+ * Written by: Darrick J. Wong <djwong@us.ibm.com>, IBM Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ *
+ */
+
+#ifndef _SAS_ATA_H_
+#define _SAS_ATA_H_
+
+#include <linux/libata.h>
+#include <scsi/libsas.h>
+
+static inline int dev_is_sata(struct domain_device *dev)
+{
+	return (dev->rphy->identify.target_port_protocols & SAS_PROTOCOL_SATA);
+}
+
+int sas_ata_init_host_and_port(struct domain_device *found_dev,
+			       struct scsi_target *starget);
+
+#endif /* _SAS_ATA_H_ */
