commit 023358b136d490ca91735ac6490db3741af5a8bd
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Jul 24 11:00:55 2019 +0200

    scsi: fcoe: Embed fc_rport_priv in fcoe_rport structure
    
    Gcc-9 complains for a memset across pointer boundaries, which happens as
    the code tries to allocate a flexible array on the stack.  Turns out we
    cannot do this without relying on gcc-isms, so with this patch we'll embed
    the fc_rport_priv structure into fcoe_rport, can use the normal
    'container_of' outcast, and will only have to do a memset over one
    structure.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index dc14b52577f7..2568cb0627ec 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -229,6 +229,7 @@ struct fcoe_fcf {
  * @vn_mac:	VN_Node assigned MAC address for data
  */
 struct fcoe_rport {
+	struct fc_rport_priv rdata;
 	unsigned long time;
 	u16 fcoe_len;
 	u16 flags;

commit 5523ca8f624dc9268bda109d37cbdc3efb5e79be
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Sun Jul 21 14:50:39 2019 +0200

    scsi: fcoe: fix a typo
    
    #define relative to FCOE CTLR start with FCOE_CTLR, except
    FCOE_CTRL_SOL_TOV.
    
    This is likely a typo and CTRL should be CTLR here as well.
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index c50fb297e265..dc14b52577f7 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -31,7 +31,7 @@
  * FIP tunable parameters.
  */
 #define FCOE_CTLR_START_DELAY	2000	/* mS after first adv. to choose FCF */
-#define FCOE_CTRL_SOL_TOV	2000	/* min. solicitation interval (mS) */
+#define FCOE_CTLR_SOL_TOV	2000	/* min. solicitation interval (mS) */
 #define FCOE_CTLR_FCF_LIMIT	20	/* max. number of FCF entries */
 #define FCOE_CTLR_VN2VN_LOGIN_LIMIT 3	/* max. VN2VN rport login retries */
 

commit a61127c2130236168321cc76c5a58e15c00ad154
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:49 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 335
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 51 franklin st fifth floor boston ma 02110
      1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 111 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.567572064@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index bb8092fa1e36..c50fb297e265 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -1,20 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (c) 2008-2009 Cisco Systems, Inc.  All rights reserved.
  * Copyright (c) 2007-2008 Intel Corporation.  All rights reserved.
  *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
  * Maintained at www.Open-FCoE.org
  */
 

commit 8beb90aaf334a6efa3e924339926b5f93a234dbb
Author: Sedat Dilek <sedat.dilek@gmail.com>
Date:   Fri Feb 15 13:19:20 2019 +0100

    scsi: fcoe: make use of fip_mode enum complete
    
    commit 1917d42d14b7 ("fcoe: use enum for fip_mode") introduces a separate
    enum for the fip_mode that shall be used during initialisation handling
    until it is passed to fcoe_ctrl_link_up to set the initial fip_state.  That
    change was incomplete and gcc quietly converted in various places between
    the fip_mode and the fip_state enum values with implicit enum conversions,
    which fortunately cannot cause any issues in the actual code's execution.
    
    clang however warns about these implicit enum conversions in the scsi
    drivers. This commit consolidates the use of the two enums, guided by
    clang's enum-conversion warnings.
    
    This commit now completes the use of the fip_mode: It expects and uses
    fip_mode in {bnx2fc,fcoe}_interface_create and fcoe_ctlr_init, and it calls
    fcoe_ctrl_set_set() with the correct values in fcoe_ctlr_link_up().  It
    also breaks the association between FIP_MODE_AUTO and FIP_ST_AUTO to
    indicate these two enums are distinct.
    
    Link: https://github.com/ClangBuiltLinux/linux/issues/151
    Fixes: 1917d42d14b7 ("fcoe: use enum for fip_mode")
    Reported-by: Dmitry Golovin <dima@golovin.in>
    Original-by: Lukas Bulwahn <lukas.bulwahn@gmail.com>
    CC: Lukas Bulwahn <lukas.bulwahn@gmail.com>
    CC: Nick Desaulniers <ndesaulniers@google.com>
    CC: Nathan Chancellor <natechancellor@gmail.com>
    Reviewed-by: Nathan Chancellor <natechancellor@gmail.com>
    Tested-by: Nathan Chancellor <natechancellor@gmail.com>
    Suggested-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Sedat Dilek <sedat.dilek@gmail.com>
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index cb8a273732cf..bb8092fa1e36 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -79,7 +79,7 @@ enum fip_state {
  * It must not change after fcoe_ctlr_init() sets it.
  */
 enum fip_mode {
-	FIP_MODE_AUTO = FIP_ST_AUTO,
+	FIP_MODE_AUTO,
 	FIP_MODE_NON_FIP,
 	FIP_MODE_FABRIC,
 	FIP_MODE_VN2VN,
@@ -250,7 +250,7 @@ struct fcoe_rport {
 };
 
 /* FIP API functions */
-void fcoe_ctlr_init(struct fcoe_ctlr *, enum fip_state);
+void fcoe_ctlr_init(struct fcoe_ctlr *, enum fip_mode);
 void fcoe_ctlr_destroy(struct fcoe_ctlr *);
 void fcoe_ctlr_link_up(struct fcoe_ctlr *);
 int fcoe_ctlr_link_down(struct fcoe_ctlr *);

commit 13059106242bc96f8f5ab79c0f6cb15c7b756f40
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Sep 21 13:12:15 2017 -0700

    scsi: fcoe: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: QLogic-Storage-Upstream@qlogic.com
    Cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Johannes Thumshirn <jth@kernel.org>
    Cc: linux-scsi@vger.kernel.org
    Cc: fcoe-devel@open-fcoe.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Johannes Thumshirn <jth@kernel.org>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 722d3264d3bf..cb8a273732cf 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -382,7 +382,7 @@ static inline struct net_device *fcoe_get_netdev(const struct fc_lport *lport)
 
 void fcoe_clean_pending_queue(struct fc_lport *);
 void fcoe_check_wait_queue(struct fc_lport *lport, struct sk_buff *skb);
-void fcoe_queue_timer(ulong lport);
+void fcoe_queue_timer(struct timer_list *t);
 int fcoe_get_paged_crc_eof(struct sk_buff *skb, int tlen,
 			   struct fcoe_percpu_s *fps);
 

commit 9a6cf881df0293cc1c06d31bcbeda6c23b95dcac
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Jul 19 13:49:40 2016 +0200

    fcoe: implement FIP VLAN responder
    
    When running in VN2VN mode there is no central instance which would send
    out any FIP VLAN discovery notifications. So this patch adds a new sysfs
    attribute 'fip_vlan_responder' which will activate a FIP VLAN discovery
    responder.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index bcc5c3e82977..722d3264d3bf 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -110,8 +110,10 @@ enum fip_mode {
  * @flogi_req_send: send of FLOGI requested
  * @flogi_count:   number of FLOGI attempts in AUTO mode.
  * @map_dest:	   use the FC_MAP mode for destination MAC addresses.
+ * @fip_resp:	   start FIP VLAN discovery responder
  * @spma:	   supports SPMA server-provided MACs mode
  * @probe_tries:   number of FC_IDs probed
+ * @priority:      DCBx FCoE APP priority
  * @dest_addr:	   MAC address of the selected FC forwarder.
  * @ctl_src_addr:  the native MAC address of our local port.
  * @send:	   LLD-supplied function to handle sending FIP Ethernet frames
@@ -149,7 +151,8 @@ struct fcoe_ctlr {
 	u16 flogi_oxid;
 	u8 flogi_req_send;
 	u8 flogi_count;
-	u8 map_dest;
+	bool map_dest;
+	bool fip_resp;
 	u8 spma;
 	u8 probe_tries;
 	u8 priority;

commit 1917d42d14b744e7298872138dd281376a83a3fe
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Jul 4 10:29:19 2016 +0200

    fcoe: use enum for fip_mode
    
    The FIP mode is independent on the FIP state machine, so use a separate
    enum for that instead of overloading it with state machine values.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index c6fbbb6581d3..bcc5c3e82977 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -78,10 +78,12 @@ enum fip_state {
  * The mode is the state that is to be entered after link up.
  * It must not change after fcoe_ctlr_init() sets it.
  */
-#define FIP_MODE_AUTO		FIP_ST_AUTO
-#define FIP_MODE_NON_FIP	FIP_ST_NON_FIP
-#define FIP_MODE_FABRIC		FIP_ST_ENABLED
-#define FIP_MODE_VN2VN		FIP_ST_VNMP_START
+enum fip_mode {
+	FIP_MODE_AUTO = FIP_ST_AUTO,
+	FIP_MODE_NON_FIP,
+	FIP_MODE_FABRIC,
+	FIP_MODE_VN2VN,
+};
 
 /**
  * struct fcoe_ctlr - FCoE Controller and FIP state
@@ -124,7 +126,7 @@ enum fip_state {
  */
 struct fcoe_ctlr {
 	enum fip_state state;
-	enum fip_state mode;
+	enum fip_mode mode;
 	struct fc_lport *lp;
 	struct fcoe_fcf *sel_fcf;
 	struct list_head fcfs;
@@ -311,7 +313,7 @@ struct fcoe_transport {
 	struct list_head list;
 	bool (*match) (struct net_device *device);
 	int (*alloc) (struct net_device *device);
-	int (*create) (struct net_device *device, enum fip_state fip_mode);
+	int (*create) (struct net_device *device, enum fip_mode fip_mode);
 	int (*destroy) (struct net_device *device);
 	int (*enable) (struct net_device *device);
 	int (*disable) (struct net_device *device);

commit 4b9bc86d5a999e344098303882d6395d39e36c13
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Apr 12 17:16:54 2016 +0200

    fcoe: convert to kworker
    
    The driver creates its own per-CPU threads which are updated based on
    CPU hotplug events. It is also possible to use kworkers and remove some
    of the kthread infrastrucure.
    
    The code checked ->thread to decide if there is an active per-CPU
    thread. By using the kworker infrastructure this is no longer
    possible (or required). The thread pointer is saved in `kthread' instead
    of `thread' so anything trying to use thread is caught by the
    compiler. Currently only the bnx2fc driver is using struct fcoe_percpu_s
    and the kthread member.
    
    After a CPU went offline, we may still enqueue items on the "offline"
    CPU. This isn't much of a problem. The work will be done on a random
    CPU. The allocated crc_eof_page page won't be cleaned up. It is probably
    expected that the CPU comes up at some point so it should not be a
    problem. The crc_eof_page memory is released of course once the module
    is removed.
    
    This patch was only compile-tested due to -ENODEV.
    
    Cc: Vasu Dev <vasu.dev@intel.com>
    Cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: fcoe-devel@open-fcoe.org
    Cc: linux-scsi@vger.kernel.org
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Tested-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index de7e3ee60f0c..c6fbbb6581d3 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -319,14 +319,16 @@ struct fcoe_transport {
 
 /**
  * struct fcoe_percpu_s - The context for FCoE receive thread(s)
- * @thread:	    The thread context
+ * @kthread:	    The thread context (used by bnx2fc)
+ * @work:	    The work item (used by fcoe)
  * @fcoe_rx_list:   The queue of pending packets to process
  * @page:	    The memory page for calculating frame trailer CRCs
  * @crc_eof_offset: The offset into the CRC page pointing to available
  *		    memory for a new trailer
  */
 struct fcoe_percpu_s {
-	struct task_struct *thread;
+	struct task_struct *kthread;
+	struct work_struct work;
 	struct sk_buff_head fcoe_rx_list;
 	struct page *crc_eof_page;
 	int crc_eof_offset;

commit 9d34876f820d55c94bd0b2a2ed3d2e2976cbd997
Author: Robert Love <robert.w.love@intel.com>
Date:   Thu Sep 5 07:47:27 2013 +0000

    libfcoe: Make fcoe_sysfs optional / fix fnic NULL exception
    
    fnic doesn't use any of the create/destroy/enable/disable interfaces
    either from the (legacy) module paramaters or the (new) fcoe_sysfs
    interfaces. When fcoe_sysfs was introduced fnic wasn't changed since
    it wasn't using the interfaces. libfcoe incorrectly assumed that that
    all of its users were using fcoe_sysfs and when adding and deleting
    FCFs would assume the existance of a fcoe_ctlr_device. fnic was not
    allocating this structure because it doesn't care about the standard
    user interfaces (fnic starts on link only). If/When libfcoe tried to use
    the fcoe_ctlr_device's lock for the first time a NULL pointer exception
    would be triggered.
    
    Since fnic doesn't care about sysfs or user interfaces, the solution
    is to drop libfcoe's assumption that all drivers are using fcoe_sysfs.
    
    This patch accomplishes this by changing some of the structure
    relationships.
    
    We need a way to determine when a LLD is using fcoe_sysfs or not and
    we can do that by checking for the existance of the fcoe_ctlr_device.
    Prior to this patch, it was assumed that the fcoe_ctlr structure was
    allocated with the fcoe_ctlr_device and immediately followed it in
    memory. To reach the fcoe_ctlr_device we would simply go back in memory
    from the fcoe_ctlr to get the fcoe_ctlr_device.
    
    Since fnic doesn't allocate the fcoe_ctlr_device, we cannot keep that
    assumption. This patch adds a pointer from the fcoe_ctlr to the
    fcoe_ctlr_device. For bnx2fc and fcoe we will continue to allocate the
    two structures together, but then we'll set the ctlr->cdev pointer
    to point at the fcoe_ctlr_device. fnic will not change and will continue
    to allocate the fcoe_ctlr itself, and ctlr->cdev will remain NULL.
    
    When libfcoe adds fcoe_fcf's to the fcoe_ctlr it will check if ctlr->cdev
    is set and only if so will it continue to interact with fcoe_sysfs.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Tested-by: Hiral Patel <hiralpat@cisco.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 4427393115ea..de7e3ee60f0c 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -90,6 +90,7 @@ enum fip_state {
  * @lp:		   &fc_lport: libfc local port.
  * @sel_fcf:	   currently selected FCF, or NULL.
  * @fcfs:	   list of discovered FCFs.
+ * @cdev:          (Optional) pointer to sysfs fcoe_ctlr_device.
  * @fcf_count:	   number of discovered FCF entries.
  * @sol_time:	   time when a multicast solicitation was last sent.
  * @sel_time:	   time after which to select an FCF.
@@ -127,6 +128,7 @@ struct fcoe_ctlr {
 	struct fc_lport *lp;
 	struct fcoe_fcf *sel_fcf;
 	struct list_head fcfs;
+	struct fcoe_ctlr_device *cdev;
 	u16 fcf_count;
 	unsigned long sol_time;
 	unsigned long sel_time;
@@ -168,8 +170,11 @@ static inline void *fcoe_ctlr_priv(const struct fcoe_ctlr *ctlr)
 	return (void *)(ctlr + 1);
 }
 
+/*
+ * This assumes that the fcoe_ctlr (x) is allocated with the fcoe_ctlr_device.
+ */
 #define fcoe_ctlr_to_ctlr_dev(x)					\
-	(struct fcoe_ctlr_device *)(((struct fcoe_ctlr_device *)(x)) - 1)
+	(x)->cdev
 
 /**
  * struct fcoe_fcf - Fibre-Channel Forwarder

commit 57c2728fa806aff08703e5739620454d723bc865
Author: Yi Zou <yi.zou@intel.com>
Date:   Thu Dec 6 06:24:13 2012 +0000

    libfcoe, fcoe: consolidate the fcoe_ctlr_get_lesb/fcoe_get_lesb
    
    Similarly they can be moved into libfcoe instead of being private to fcoe now.
    Also add comments particularly on the term LESB to the corresponding function.
    
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Cc: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
    Tested-by: Marcus Dennis <marcusx.e.dennis@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 6c59ba7af28a..4427393115ea 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -261,6 +261,8 @@ void __fcoe_get_lesb(struct fc_lport *lport, struct fc_els_lesb *fc_lesb,
 void fcoe_wwn_to_str(u64 wwn, char *buf, int len);
 int fcoe_validate_vport_create(struct fc_vport *vport);
 int fcoe_link_speed_update(struct fc_lport *);
+void fcoe_get_lesb(struct fc_lport *, struct fc_els_lesb *);
+void fcoe_ctlr_get_lesb(struct fcoe_ctlr_device *ctlr_dev);
 
 /**
  * is_fip_mode() - returns true if FIP mode selected.

commit 03702689fcc985e9cb45b57099ebd5066f674739
Author: Yi Zou <yi.zou@intel.com>
Date:   Thu Dec 6 06:23:58 2012 +0000

    libfcoe, fcoe: move fcoe_link_speed_update() to libfcoe and export it
    
    With the previous patch, fcoe_link_speed_update() can be moved into libfcoe and
    exported to used by fcoe, bnx2fc, and etc.
    
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Cc: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
    Tested-by: Marcus Dennis <marcusx.e.dennis@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 746bc587ae34..6c59ba7af28a 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -260,6 +260,7 @@ void __fcoe_get_lesb(struct fc_lport *lport, struct fc_els_lesb *fc_lesb,
 		     struct net_device *netdev);
 void fcoe_wwn_to_str(u64 wwn, char *buf, int len);
 int fcoe_validate_vport_create(struct fc_vport *vport);
+int fcoe_link_speed_update(struct fc_lport *);
 
 /**
  * is_fip_mode() - returns true if FIP mode selected.

commit 66524ec9d0aeaa8bc59077c7c5f78d09ec9eeb9d
Author: Yi Zou <yi.zou@intel.com>
Date:   Thu Dec 6 06:23:43 2012 +0000

    fcoe: add support to the get_netdev() for fcoe_interface
    
    Adds support to fcoe_port's newly added get_netdev fucntion pointer.
    
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Cc: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
    Tested-by: Marcus Dennis <marcusx.e.dennis@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 52bba7138069..746bc587ae34 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -353,6 +353,18 @@ struct fcoe_port {
 	u8		      data_src_addr[ETH_ALEN];
 	struct net_device * (*get_netdev)(const struct fc_lport *lport);
 };
+
+/**
+ * fcoe_get_netdev() - Return the net device associated with a local port
+ * @lport: The local port to get the net device from
+ */
+static inline struct net_device *fcoe_get_netdev(const struct fc_lport *lport)
+{
+	struct fcoe_port *port = ((struct fcoe_port *)lport_priv(lport));
+
+	return (port->get_netdev) ? port->get_netdev(lport) : NULL;
+}
+
 void fcoe_clean_pending_queue(struct fc_lport *);
 void fcoe_check_wait_queue(struct fc_lport *lport, struct sk_buff *skb);
 void fcoe_queue_timer(ulong lport);

commit 8106fb4790c33547a034db53f7658bccd3cfbf6b
Author: Yi Zou <yi.zou@intel.com>
Date:   Thu Dec 6 06:23:27 2012 +0000

    fcoe: prep work to start consolidate the usage of fcoe_netdev
    
    Currently, in the default kernel fcoe driver, it is needed to get to the underlying
    private per fcoe transport's private structure, e.g., fcoe_interface in
    fcoe.ko, and returns the associated netdev. The similar logic exists in other
    fcoe drivers, e.g., bnx2fc, so we add a function pointer into the common
    fcoe_port struct to allow individual fcoe transport implementaion (fcoe
    and bnx2fc) to get the corresponding netdev associated with a give lport.
    
    Then a inline fcoe_get_netdev() is added as part of libfcoe for all underlying
    fcoe transport drivers to use regardless of its individual fcoe transport
    driver, and also allows move more common code such as fcoe_link_speed_update or
    fcoe_ctlr_get_lesb to be in libfcoe, rather than specific to fcoe.
    
    This patch is a prep work that adds aforementioned fucntion pointer, and
    followed by the actual code changes to make use of it.
    
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Cc: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
    Tested-by: Marcus Dennis <marcusx.e.dennis@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 6add37ac8609..52bba7138069 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -351,6 +351,7 @@ struct fcoe_port {
 	struct timer_list     timer;
 	struct work_struct    destroy_work;
 	u8		      data_src_addr[ETH_ALEN];
+	struct net_device * (*get_netdev)(const struct fc_lport *lport);
 };
 void fcoe_clean_pending_queue(struct fc_lport *);
 void fcoe_check_wait_queue(struct fc_lport *lport, struct sk_buff *skb);

commit 6a891b071b640e1de44c4a5117fa2c974dcfa84a
Author: Robert Love <robert.w.love@intel.com>
Date:   Tue Nov 27 06:53:30 2012 +0000

    libfcoe, fcoe, bnx2fc: Add new fcoe control interface
    
    This patch does a few things.
    
    1) Makes /sys/bus/fcoe/ctlr_{create,destroy} interfaces.
       These interfaces take an <ifname> and will either
       create an FCoE Controller or destroy an FCoE
       Controller depending on which file is written to.
    
       The new FCoE Controller will start in a DISABLED
       state and will not do discovery or login until it
       is ENABLED. This pause will allow us to configure
       the FCoE Controller before enabling it.
    
    2) Makes the 'mode' attribute of a fcoe_ctlr_device
       writale. This allows the user to configure the mode
       in which the FCoE Controller will start in when it
       is ENABLED.
    
       Possible modes are 'Fabric', or 'VN2VN'.
    
       The default mode for a fcoe_ctlr{,_device} is 'Fabric'.
       Drivers must implement the set_fcoe_ctlr_mode routine
       to support this feature.
    
       libfcoe offers an exported routine to set a FCoE
       Controller's mode. The mode can only be changed
       when the FCoE Controller is DISABLED.
    
       This patch also removes the get_fcoe_ctlr_mode pointer
       in the fcoe_sysfs function template, the code in
       fcoe_ctlr.c to get the mode and the assignment of
       the fcoe_sysfs function pointer to the fcoe_ctlr.c
       implementation (in fcoe and bnx2fc). fcoe_sysfs can
       return that value for the mode without consulting the
       LLD.
    
    3) Make a 'enabled' attribute of a fcoe_ctlr_device. On a
       read, fcoe_sysfs will return the attribute's value. On
       a write, fcoe_sysfs will call the LLD (if there is a
       callback) to notifiy that the enalbed state has changed.
    
    This patch maintains the old FCoE control interfaces as
    module parameters, but it adds comments pointing out that
    the old interfaces are deprecated.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 8742d853a3b8..6add37ac8609 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -289,8 +289,11 @@ static inline bool is_fip_mode(struct fcoe_ctlr *fip)
  * @attached:	whether this transport is already attached
  * @list:	list linkage to all attached transports
  * @match:	handler to allow the transport driver to match up a given netdev
+ * @alloc:      handler to allocate per-instance FCoE structures
+ *		(no discovery or login)
  * @create:	handler to sysfs entry of create for FCoE instances
- * @destroy:	handler to sysfs entry of destroy for FCoE instances
+ * @destroy:    handler to delete per-instance FCoE structures
+ *		(frees all memory)
  * @enable:	handler to sysfs entry of enable for FCoE instances
  * @disable:	handler to sysfs entry of disable for FCoE instances
  */
@@ -299,6 +302,7 @@ struct fcoe_transport {
 	bool attached;
 	struct list_head list;
 	bool (*match) (struct net_device *device);
+	int (*alloc) (struct net_device *device);
 	int (*create) (struct net_device *device, enum fip_state fip_mode);
 	int (*destroy) (struct net_device *device);
 	int (*enable) (struct net_device *device);
@@ -356,7 +360,7 @@ int fcoe_get_paged_crc_eof(struct sk_buff *skb, int tlen,
 
 /* FCoE Sysfs helpers */
 void fcoe_fcf_get_selected(struct fcoe_fcf_device *);
-void fcoe_ctlr_get_fip_mode(struct fcoe_ctlr_device *);
+void fcoe_ctlr_set_fip_mode(struct fcoe_ctlr_device *);
 
 /**
  * struct netdev_list
@@ -372,4 +376,12 @@ struct fcoe_netdev_mapping {
 int fcoe_transport_attach(struct fcoe_transport *ft);
 int fcoe_transport_detach(struct fcoe_transport *ft);
 
+/* sysfs store handler for ctrl_control interface */
+ssize_t fcoe_ctlr_create_store(struct bus_type *bus,
+			       const char *buf, size_t count);
+ssize_t fcoe_ctlr_destroy_store(struct bus_type *bus,
+				const char *buf, size_t count);
+
 #endif /* _LIBFCOE_H */
+
+

commit 31c37a6f21d86e6bca095b71d603ed543ae070ad
Author: Neerav Parikh <Neerav.Parikh@intel.com>
Date:   Mon Sep 24 11:52:45 2012 -0700

    [SCSI] fcoe: Fix write errors on NPIV ports
    
    SCSI errors were generated while writing to LUNs
    connected via NPIV ports.
    
    Debugging this it was found that the FCoE packets
    transmitted via the NPIV ports were not tagged with
    correct user priority as negotiated with peer by DCB
    agent. This resulted in FCoE traffic going with priority
    zero(0) that did not have priority flow control (PFC)
    enabled for it. The initiator after transferring data
    to the target never saw any reply indicating the transfer
    was complete. This resulted in error recovery (ABTS) and
    SCSI command retries by the scsi-mid layer; eventually
    resulting in I/O errors.
    
    This patch fixes this issue by keeping the FCoE user
    priority information in the fcoe_interface instance
    that is common for both the physical port as well as
    NPIV ports connected to that physical port; instead
    of storing it in fcoe_port structure that has a per
    port instance.
    
    Signed-off-by: Neerav Parikh <Neerav.Parikh@intel.com>
    Acked-by: Yi Zou <yi.zou@intel.com>
    Acked-by: John Fastabend <john.r.fastabend@intel.com>
    Tested-by: Marcus Dennis <marcusx.e.dennis@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 22b07cc99808..8742d853a3b8 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -327,7 +327,6 @@ struct fcoe_percpu_s {
  * @lport:		       The associated local port
  * @fcoe_pending_queue:	       The pending Rx queue of skbs
  * @fcoe_pending_queue_active: Indicates if the pending queue is active
- * @priority:		       Packet priority (DCB)
  * @max_queue_depth:	       Max queue depth of pending queue
  * @min_queue_depth:	       Min queue depth of pending queue
  * @timer:		       The queue timer
@@ -343,7 +342,6 @@ struct fcoe_port {
 	struct fc_lport	      *lport;
 	struct sk_buff_head   fcoe_pending_queue;
 	u8		      fcoe_pending_queue_active;
-	u8		      priority;
 	u32		      max_queue_depth;
 	u32		      min_queue_depth;
 	struct timer_list     timer;

commit 8d55e507d24c6db7eb012c379c62912e642eb75e
Author: Robert Love <robert.w.love@intel.com>
Date:   Tue May 22 19:06:26 2012 -0700

    [SCSI] fcoe, bnx2fc, libfcoe: SW FCoE and bnx2fc use FCoE Syfs
    
    This patch has the SW FCoE driver and the bnx2fc
    driver make use of the new fcoe_sysfs API added
    earlier in this patch series.
    
    After this patch a fcoe_ctlr_device is allocated with
    private data in this order.
    
    +------------------+   +------------------+
    | fcoe_ctlr_device |   | fcoe_ctlr_device |
    +------------------+   +------------------+
    | fcoe_ctlr        |   | fcoe_ctlr        |
    +------------------+   +------------------+
    | fcoe_interface   |   | bnx2fc_interface |
    +------------------+   +------------------+
    
    libfcoe also takes part in this new model since it
    discovers and manages fcoe_fcf instances. The memory
    allocation is different for FCFs. I didn't want to
    impact libfcoe's fcoe_fcf processing, so this patch
    creates fcoe_fcf_device instances for each discovered
    fcoe_fcf. The two are paired using a (void * priv)
    member of the fcoe_ctlr_device. This allows libfcoe
    to continue maintaining its list of fcoe_fcf instances
    and simply attaches and detaches them from existing
    or new fcoe_fcf_device instances.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Tested-by: Ross Brattain <ross.b.brattain@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 7b93f211b935..22b07cc99808 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -168,9 +168,16 @@ static inline void *fcoe_ctlr_priv(const struct fcoe_ctlr *ctlr)
 	return (void *)(ctlr + 1);
 }
 
+#define fcoe_ctlr_to_ctlr_dev(x)					\
+	(struct fcoe_ctlr_device *)(((struct fcoe_ctlr_device *)(x)) - 1)
+
 /**
  * struct fcoe_fcf - Fibre-Channel Forwarder
  * @list:	 list linkage
+ * @event_work:  Work for FC Transport actions queue
+ * @event:       The event to be processed
+ * @fip:         The controller that the FCF was discovered on
+ * @fcf_dev:     The associated fcoe_fcf_device instance
  * @time:	 system time (jiffies) when an advertisement was last received
  * @switch_name: WWN of switch from advertisement
  * @fabric_name: WWN of fabric from advertisement
@@ -192,6 +199,9 @@ static inline void *fcoe_ctlr_priv(const struct fcoe_ctlr *ctlr)
  */
 struct fcoe_fcf {
 	struct list_head list;
+	struct work_struct event_work;
+	struct fcoe_ctlr *fip;
+	struct fcoe_fcf_device *fcf_dev;
 	unsigned long time;
 
 	u64 switch_name;
@@ -208,6 +218,9 @@ struct fcoe_fcf {
 	u8 fd_flags:1;
 };
 
+#define fcoe_fcf_to_fcf_dev(x)			\
+	((x)->fcf_dev)
+
 /**
  * struct fcoe_rport - VN2VN remote port
  * @time:	time of create or last beacon packet received from node
@@ -343,6 +356,10 @@ void fcoe_queue_timer(ulong lport);
 int fcoe_get_paged_crc_eof(struct sk_buff *skb, int tlen,
 			   struct fcoe_percpu_s *fps);
 
+/* FCoE Sysfs helpers */
+void fcoe_fcf_get_selected(struct fcoe_fcf_device *);
+void fcoe_ctlr_get_fip_mode(struct fcoe_ctlr_device *);
+
 /**
  * struct netdev_list
  * A mapping from netdevice to fcoe_transport

commit 9a74e884ee71dbf3d0967b0321d7b4529a04826c
Author: Robert Love <robert.w.love@intel.com>
Date:   Tue May 22 19:06:21 2012 -0700

    [SCSI] libfcoe: Add fcoe_sysfs
    
    This patch adds a 'fcoe bus' infrastructure to the kernel
    that is driven by changes to libfcoe which allow LLDs to
    present FIP (FCoE Initialization Protocol) discovered
    entities and their attributes to user space via sysfs.
    
    This patch adds the following APIs-
    
    fcoe_ctlr_device_add
    fcoe_ctlr_device_delete
    fcoe_fcf_device_add
    fcoe_fcf_device_delete
    
    They allow the LLD to expose the FCoE ENode Controller
    and any discovered FCFs (Fibre Channel Forwarders, e.g.
    FCoE switches) to the user. Each of these new devices
    has their own bus_type so that they are grouped together
    for easy lookup from a user space application. Each
    new class has an attribute_group to expose attributes
    for any created instances. The attributes are-
    
    fcoe_ctlr_device
    * fcf_dev_loss_tmo
    * lesb_link_fail
    * lesb_vlink_fail
    * lesb_miss_fka
    * lesb_symb_err
    * lesb_err_block
    * lesb_fcs_error
    
    fcoe_fcf_device
    * fabric_name
    * switch_name
    * priority
    * selected
    * fc_map
    * vfid
    * mac
    * fka_peroid
    * fabric_state
    * dev_loss_tmo
    
    A device loss infrastructre similar to the FC Transport's
    is also added by this patch. It is nice to have so that a
    link flapping adapter doesn't continually advance the count
    used to identify the discovered FCF. FCFs will exist in a
    "Disconnected" state until either the timer expires or the
    FCF is rediscovered and becomes "Connected."
    
    This patch generates a few checkpatch.pl WARNINGS that
    I'm not sure what to do about. They're macros modeled
    around the FC Transport attribute building macros, which
    have the same 'feature' where the caller can ommit a cast
    in the argument list and no cast occurs in the code. I'm
    not sure how to keep the code condensed while keeping the
    macros. Any advice would be appreciated.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Tested-by: Ross Brattain <ross.b.brattain@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 69eca4b7ce2b..7b93f211b935 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -29,6 +29,7 @@
 #include <linux/random.h>
 #include <scsi/fc/fc_fcoe.h>
 #include <scsi/libfc.h>
+#include <scsi/fcoe_sysfs.h>
 
 #define FCOE_MAX_CMD_LEN	16	/* Supported CDB length */
 

commit 619fe4bed415e5d8a4749937f42b6a8a9031d4aa
Author: Robert Love <robert.w.love@intel.com>
Date:   Tue May 22 19:06:10 2012 -0700

    [SCSI] fcoe: Allocate fcoe_ctlr with fcoe_interface, not as a member
    
    Currently the fcoe_ctlr associated with an interface is allocated
    as a member of struct fcoe_interface. This causes problems when
    attempting to use the new fcoe_sysfs APIs which allow us to allocate
    the fcoe_interface as private data to the fcoe_ctlr_device instance.
    The problem is that libfcoe wants to be able use pointer math to find a
    fcoe_ctlr's fcoe_ctlr_device as well as finding a fcoe_ctlr_device's
    assocated fcoe_ctlr. To do this we need to allocate the
    fcoe_ctlr_device, with private data for the LLD. The private data
    contains the fcoe_ctlr and its private data is the fcoe_interface.
    This patch only allocates the fcoe_interface with the fcoe_ctlr, the
    fcoe_ctlr_device will be added in a later patch, which will complete
    the below diagram-
    
    +------------------+
    | fcoe_ctlr_device |
    +------------------+
    | fcoe_ctlr        |
    +------------------+
    | fcoe_interface   |
    +------------------+
    
    This prep work will allow us to go from a fcoe_ctlr_device instance
    to its fcoe_ctlr as well as from a fcoe_ctlr to its fcoe_ctlr_device
    once the fcoe_sysfs API is in use (later patches in this series).
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Tested-by: Ross Brattain <ross.b.brattain@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index cfdb55f0937e..69eca4b7ce2b 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -158,6 +158,15 @@ struct fcoe_ctlr {
 	spinlock_t ctlr_lock;
 };
 
+/**
+ * fcoe_ctlr_priv() - Return the private data from a fcoe_ctlr
+ * @cltr: The fcoe_ctlr whose private data will be returned
+ */
+static inline void *fcoe_ctlr_priv(const struct fcoe_ctlr *ctlr)
+{
+	return (void *)(ctlr + 1);
+}
+
 /**
  * struct fcoe_fcf - Fibre-Channel Forwarder
  * @list:	 list linkage

commit 81c11dd2ed154b351eb6ee3443e07094a1d53ce1
Author: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
Date:   Fri Mar 9 14:50:03 2012 -0800

    [SCSI] libfcoe: Support extra MAC descriptor to be used as FCoE MAC
    
    Some switch implementations (eg., HP virtual connect FlexFabric) send two MAC
    descriptors in FIP FLOGI response, with first MAC descriptor (granted_mac) used
    as FPMA, and the second one (fcoe_mac) used as destination address for
    sending/receiving FCoE packets. fip_mac continues to be used for FIP traffic.
    This patch introduces fcoe_mac in fcoe_fcf structure. For regular switches,
    both fcoe_mac and fip_mac will be the same. For the switches that send
    additional MAC descriptor, fcoe_mac is updated.
    
    Signed-off-by: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 5a35a2a2d3c5..cfdb55f0937e 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -165,7 +165,8 @@ struct fcoe_ctlr {
  * @switch_name: WWN of switch from advertisement
  * @fabric_name: WWN of fabric from advertisement
  * @fc_map:	 FC_MAP value from advertisement
- * @fcf_mac:	 Ethernet address of the FCF
+ * @fcf_mac:	 Ethernet address of the FCF for FIP traffic
+ * @fcoe_mac:	 Ethernet address of the FCF for FCoE traffic
  * @vfid:	 virtual fabric ID
  * @pri:	 selection priority, smaller values are better
  * @flogi_sent:	 current FLOGI sent to this FCF
@@ -188,6 +189,7 @@ struct fcoe_fcf {
 	u32 fc_map;
 	u16 vfid;
 	u8 fcf_mac[ETH_ALEN];
+	u8 fcoe_mac[ETH_ALEN];
 
 	u8 pri;
 	u8 flogi_sent;

commit 6f6c2aa33b915c574543f176dee89d7aefc115c1
Author: john fastabend <john.r.fastabend@intel.com>
Date:   Fri Nov 18 13:35:56 2011 -0800

    [SCSI] fcoe: fix fcoe in a DCB environment by adding DCB notifiers to set skb priority
    
    Use DCB notifiers to set the skb priority to allow packets
    to be steered and tagged correctly over DCB enabled drivers
    that setup traffic classes.
    
    This allows queue_mapping() routines to be removed in these
    drivers that were previously inspecting the ethertype of
    every skb to mark FCoE/FIP frames.
    
    Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index d1e95c6ac776..5a35a2a2d3c5 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -147,6 +147,7 @@ struct fcoe_ctlr {
 	u8 map_dest;
 	u8 spma;
 	u8 probe_tries;
+	u8 priority;
 	u8 dest_addr[ETH_ALEN];
 	u8 ctl_src_addr[ETH_ALEN];
 
@@ -301,6 +302,7 @@ struct fcoe_percpu_s {
  * @lport:		       The associated local port
  * @fcoe_pending_queue:	       The pending Rx queue of skbs
  * @fcoe_pending_queue_active: Indicates if the pending queue is active
+ * @priority:		       Packet priority (DCB)
  * @max_queue_depth:	       Max queue depth of pending queue
  * @min_queue_depth:	       Min queue depth of pending queue
  * @timer:		       The queue timer
@@ -316,6 +318,7 @@ struct fcoe_port {
 	struct fc_lport	      *lport;
 	struct sk_buff_head   fcoe_pending_queue;
 	u8		      fcoe_pending_queue_active;
+	u8		      priority;
 	u32		      max_queue_depth;
 	u32		      min_queue_depth;
 	struct timer_list     timer;

commit 814740d5f67ae5f205349019bfaae38bcd0c8732
Author: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
Date:   Mon Oct 3 16:45:01 2011 -0700

    [SCSI] fcoe,libfcoe: Move common code for fcoe_get_lesb to fcoe_transport
    
    Except for obtaining the netdev from lport, fcoe_get_lesb is the common code
    for the LLDs.
    
    Signed-off-by: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
    Acked-by: Yi Zou <yi.zou@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 0b2f84304f34..d1e95c6ac776 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -230,6 +230,8 @@ int fcoe_libfc_config(struct fc_lport *, struct fcoe_ctlr *,
 u32 fcoe_fc_crc(struct fc_frame *fp);
 int fcoe_start_io(struct sk_buff *skb);
 int fcoe_get_wwn(struct net_device *netdev, u64 *wwn, int type);
+void __fcoe_get_lesb(struct fc_lport *lport, struct fc_els_lesb *fc_lesb,
+		     struct net_device *netdev);
 void fcoe_wwn_to_str(u64 wwn, char *buf, int len);
 int fcoe_validate_vport_create(struct fc_vport *vport);
 

commit d834895c41d34b64a1923fa631e6a64f763ed31c
Author: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
Date:   Thu Aug 4 17:38:49 2011 -0700

    [SCSI] fcoe: Move common functions to fcoe_transport library
    
    Export fcoe_get_wwn, fcoe_validate_vport_create and fcoe_wwn_to_str so that all
    LLDs can use these common function.
    
    Signed-off-by: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 8c1638b8c28e..0b2f84304f34 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -229,6 +229,9 @@ int fcoe_libfc_config(struct fc_lport *, struct fcoe_ctlr *,
 		      const struct libfc_function_template *, int init_fcp);
 u32 fcoe_fc_crc(struct fc_frame *fp);
 int fcoe_start_io(struct sk_buff *skb);
+int fcoe_get_wwn(struct net_device *netdev, u64 *wwn, int type);
+void fcoe_wwn_to_str(u64 wwn, char *buf, int len);
+int fcoe_validate_vport_create(struct fc_vport *vport);
 
 /**
  * is_fip_mode() - returns true if FIP mode selected.

commit f4d2b2b6ea8abd0df72a31b4724522a277af6a6c
Author: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
Date:   Fri Feb 25 15:03:12 2011 -0800

    [SCSI] libfcoe: Move FCOE_MTU definition from fcoe.h to libfcoe.h
    
    both fcoe and bnx2fc drivers can access the common definition of
    FCOE_MTU.
    
    Signed-off-by: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index e5024634bfab..8c1638b8c28e 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -32,6 +32,12 @@
 
 #define FCOE_MAX_CMD_LEN	16	/* Supported CDB length */
 
+/*
+ * Max MTU for FCoE: 14 (FCoE header) + 24 (FC header) + 2112 (max FC payload)
+ * + 4 (FC CRC) + 4 (FCoE trailer) =  2158 bytes
+ */
+#define FCOE_MTU	2158
+
 /*
  * FIP tunable parameters.
  */

commit 8597ae8bfe35f5e438b00ba5df852e97ebe1ac23
Author: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
Date:   Fri Jan 28 16:05:37 2011 -0800

    [SCSI] libfcoe: Move common code from fcoe to libfcoe module
    
    To facilitate LLDDs to reuse the code, skb queue related functions are moved to
    libfcoe, so that both fcoe and bnx2fc drivers can use them. The common structures
    fcoe_port, fcoe_percpu_s are moved to libfcoe. fcoe_port will now have an
    opaque pointer that points to corresponding driver's interface structure.
    Also, fcoe_start_io and fcoe_fc_crc are moved to libfcoe.
    
    As part of this change, fixed fcoe_start_io to return ENOMEM if
    skb_clone fails.
    
    Signed-off-by: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index efb6ae5b94ad..e5024634bfab 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -221,6 +221,8 @@ int fcoe_ctlr_recv_flogi(struct fcoe_ctlr *, struct fc_lport *,
 u64 fcoe_wwn_from_mac(unsigned char mac[], unsigned int, unsigned int);
 int fcoe_libfc_config(struct fc_lport *, struct fcoe_ctlr *,
 		      const struct libfc_function_template *, int init_fcp);
+u32 fcoe_fc_crc(struct fc_frame *fp);
+int fcoe_start_io(struct sk_buff *skb);
 
 /**
  * is_fip_mode() - returns true if FIP mode selected.
@@ -266,6 +268,55 @@ struct fcoe_transport {
 	int (*disable) (struct net_device *device);
 };
 
+/**
+ * struct fcoe_percpu_s - The context for FCoE receive thread(s)
+ * @thread:	    The thread context
+ * @fcoe_rx_list:   The queue of pending packets to process
+ * @page:	    The memory page for calculating frame trailer CRCs
+ * @crc_eof_offset: The offset into the CRC page pointing to available
+ *		    memory for a new trailer
+ */
+struct fcoe_percpu_s {
+	struct task_struct *thread;
+	struct sk_buff_head fcoe_rx_list;
+	struct page *crc_eof_page;
+	int crc_eof_offset;
+};
+
+/**
+ * struct fcoe_port - The FCoE private structure
+ * @priv:		       The associated fcoe interface. The structure is
+ *			       defined by the low level driver
+ * @lport:		       The associated local port
+ * @fcoe_pending_queue:	       The pending Rx queue of skbs
+ * @fcoe_pending_queue_active: Indicates if the pending queue is active
+ * @max_queue_depth:	       Max queue depth of pending queue
+ * @min_queue_depth:	       Min queue depth of pending queue
+ * @timer:		       The queue timer
+ * @destroy_work:	       Handle for work context
+ *			       (to prevent RTNL deadlocks)
+ * @data_srt_addr:	       Source address for data
+ *
+ * An instance of this structure is to be allocated along with the
+ * Scsi_Host and libfc fc_lport structures.
+ */
+struct fcoe_port {
+	void		      *priv;
+	struct fc_lport	      *lport;
+	struct sk_buff_head   fcoe_pending_queue;
+	u8		      fcoe_pending_queue_active;
+	u32		      max_queue_depth;
+	u32		      min_queue_depth;
+	struct timer_list     timer;
+	struct work_struct    destroy_work;
+	u8		      data_src_addr[ETH_ALEN];
+};
+void fcoe_clean_pending_queue(struct fc_lport *);
+void fcoe_check_wait_queue(struct fc_lport *lport, struct sk_buff *skb);
+void fcoe_queue_timer(ulong lport);
+int fcoe_get_paged_crc_eof(struct sk_buff *skb, int tlen,
+			   struct fcoe_percpu_s *fps);
+
 /**
  * struct netdev_list
  * A mapping from netdevice to fcoe_transport

commit 0ade7d290b6aa8b1626a4077b853c02cd12415c2
Author: Yi Zou <yi.zou@intel.com>
Date:   Fri Jan 28 16:04:50 2011 -0800

    [SCSI] libfcoe: add fcoe_transport structure defines to include/scsi/libfcoe.h
    
    add the fcoe_transport struct to the common libfcoe.h header so all fcoe
    transport provides can use it to attach itself as an fcoe transport. This
    is the header part, and the next patch will be the transport code itself.
    
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Signed-off-by: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index feb6a94c90ea..efb6ae5b94ad 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -231,5 +231,53 @@ static inline bool is_fip_mode(struct fcoe_ctlr *fip)
 	return fip->state == FIP_ST_ENABLED;
 }
 
+/* helper for FCoE SW HBA drivers, can include subven and subdev if needed. The
+ * modpost would use pci_device_id table to auto-generate formatted module alias
+ * into the corresponding .mod.c file, but there may or may not be a pci device
+ * id table for FCoE drivers so we use the following helper for build the fcoe
+ * driver module alias.
+ */
+#define MODULE_ALIAS_FCOE_PCI(ven, dev) \
+	MODULE_ALIAS("fcoe-pci:"	\
+		"v" __stringify(ven)	\
+		"d" __stringify(dev) "sv*sd*bc*sc*i*")
+
+/* the name of the default FCoE transport driver fcoe.ko */
+#define FCOE_TRANSPORT_DEFAULT	"fcoe"
+
+/* struct fcoe_transport - The FCoE transport interface
+ * @name:	a vendor specific name for their FCoE transport driver
+ * @attached:	whether this transport is already attached
+ * @list:	list linkage to all attached transports
+ * @match:	handler to allow the transport driver to match up a given netdev
+ * @create:	handler to sysfs entry of create for FCoE instances
+ * @destroy:	handler to sysfs entry of destroy for FCoE instances
+ * @enable:	handler to sysfs entry of enable for FCoE instances
+ * @disable:	handler to sysfs entry of disable for FCoE instances
+ */
+struct fcoe_transport {
+	char name[IFNAMSIZ];
+	bool attached;
+	struct list_head list;
+	bool (*match) (struct net_device *device);
+	int (*create) (struct net_device *device, enum fip_state fip_mode);
+	int (*destroy) (struct net_device *device);
+	int (*enable) (struct net_device *device);
+	int (*disable) (struct net_device *device);
+};
+
+/**
+ * struct netdev_list
+ * A mapping from netdevice to fcoe_transport
+ */
+struct fcoe_netdev_mapping {
+	struct list_head list;
+	struct net_device *netdev;
+	struct fcoe_transport *ft;
+};
+
+/* fcoe transports registration and deregistration */
+int fcoe_transport_attach(struct fcoe_transport *ft);
+int fcoe_transport_detach(struct fcoe_transport *ft);
 
 #endif /* _LIBFCOE_H */

commit 794d98e77f5901ceded697f1633463e88f078038
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Nov 30 16:19:56 2010 -0800

    [SCSI] libfcoe: retry rejected FLOGI to another FCF if possible
    
    Switches using multiple-FCFs may reject FLOGI in order to
    balance the load between multiple FCFs.  Even though the FCF
    was available, it may have more load at the point we actually
    send the FLOGI.
    
    If the FLOGI fails, select a different FCF
    if possible, among those with the same priority.  If no other
    FCF is available, just deliver the reject to libfc for retry.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 06f1b5a8ed19..feb6a94c90ea 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -92,10 +92,12 @@ enum fip_state {
  * @timer_work:	   &work_struct for doing keep-alives and resets.
  * @recv_work:	   &work_struct for receiving FIP frames.
  * @fip_recv_list: list of received FIP frames.
+ * @flogi_req:	   clone of FLOGI request sent
  * @rnd_state:	   state for pseudo-random number generator.
  * @port_id:	   proposed or selected local-port ID.
  * @user_mfs:	   configured maximum FC frame size, including FC header.
  * @flogi_oxid:    exchange ID of most recent fabric login.
+ * @flogi_req_send: send of FLOGI requested
  * @flogi_count:   number of FLOGI attempts in AUTO mode.
  * @map_dest:	   use the FC_MAP mode for destination MAC addresses.
  * @spma:	   supports SPMA server-provided MACs mode
@@ -106,6 +108,7 @@ enum fip_state {
  * @update_mac:    LLD-supplied function to handle changes to MAC addresses.
  * @get_src_addr:  LLD-supplied function to supply a source MAC address.
  * @ctlr_mutex:	   lock protecting this structure.
+ * @ctlr_lock:     spinlock covering flogi_req
  *
  * This structure is used by all FCoE drivers.  It contains information
  * needed by all FCoE low-level drivers (LLDs) as well as internal state
@@ -126,12 +129,14 @@ struct fcoe_ctlr {
 	struct work_struct timer_work;
 	struct work_struct recv_work;
 	struct sk_buff_head fip_recv_list;
+	struct sk_buff *flogi_req;
 
 	struct rnd_state rnd_state;
 	u32 port_id;
 
 	u16 user_mfs;
 	u16 flogi_oxid;
+	u8 flogi_req_send;
 	u8 flogi_count;
 	u8 map_dest;
 	u8 spma;
@@ -143,6 +148,7 @@ struct fcoe_ctlr {
 	void (*update_mac)(struct fc_lport *, u8 *addr);
 	u8 * (*get_src_addr)(struct fc_lport *);
 	struct mutex ctlr_mutex;
+	spinlock_t ctlr_lock;
 };
 
 /**
@@ -155,6 +161,7 @@ struct fcoe_ctlr {
  * @fcf_mac:	 Ethernet address of the FCF
  * @vfid:	 virtual fabric ID
  * @pri:	 selection priority, smaller values are better
+ * @flogi_sent:	 current FLOGI sent to this FCF
  * @flags:	 flags received from advertisement
  * @fka_period:	 keep-alive period, in jiffies
  *
@@ -176,6 +183,7 @@ struct fcoe_fcf {
 	u8 fcf_mac[ETH_ALEN];
 
 	u8 pri;
+	u8 flogi_sent;
 	u16 flags;
 	u32 fka_period;
 	u8 fd_flags:1;

commit e10f8c667b874a57512c936089092a3d1ef7ab8a
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Jul 20 15:20:30 2010 -0700

    [SCSI] libfcoe: fcoe: fnic: add FIP VN2VN point-to-multipoint support
    
    The FC-BB-6 committee is proposing a new FIP usage model called
    VN_port to VN_port mode.  It allows VN_ports to discover each other
    over a loss-free L2 Ethernet without any FCF or Fibre-channel fabric
    services.  This is point-to-multipoint.  There is also a variant
    of this called point-to-point which provides for making sure there
    is just one pair of ports operating over the Ethernet fabric.
    
    We add these new states:  VNMP_START, _PROBE1, _PROBE2, _CLAIM, and _UP.
    These usually go quickly in that sequence.  After waiting a random
    amount of time up to 100 ms in START, we select a pseudo-random
    proposed locally-unique port ID and send out probes in states PROBE1
    and PROBE2, 100 ms apart.  If no probe responses are heard, we
    proceed to CLAIM state 400 ms later and send a claim notification.
    We wait another 400 ms to receive claim responses, which give us
    a list of the other nodes on the network, including their FC-4
    capabilities.  After another 400 ms we go to VNMP_UP state and
    should start interoperating with any of the nodes for whic we
    receivec claim responses.  More details are in the spec.j
    
    Add the new mode as FIP_MODE_VN2VN.  The driver must specify
    explicitly that it wants to operate in this mode.  There is
    no automatic detection between point-to-multipoint and fabric
    mode, and the local port initialization is affected, so it isn't
    anticipated that there will ever be any such automatic switchover.
    
    It may eventually be possible to have both fabric and VN2VN
    modes on the same L2 network, which may be done by two separate
    local VN_ports (lports).
    
    When in VN2VN mode, FIP replaces libfc's fabric-oriented discovery
    module with its own simple code that adds remote ports as they
    are discovered from incoming claim notifications and responses.
    These hooks are placed by fcoe_disc_init().
    
    A linear list of discovered vn_ports is maintained under the
    fcoe_ctlr struct.  It is expected to be short for now, and
    accessed infrequently.  It is kept under RCU for lock-ordering
    reasons.  The lport and/or rport mutexes may be held when we
    need to lookup a fcoe_vnport during an ELS send.
    
    Change fcoe_ctlr_encaps() to lookup the destination vn_port in
    the list of peers for the destination MAC address of the
    FIP-encapsulated frame.
    
    Add a new function fcoe_disc_init() to initialize just the
    discovery portion of libfcoe for VN2VN mode.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 1a84a3182da0..06f1b5a8ed19 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -26,6 +26,7 @@
 #include <linux/netdevice.h>
 #include <linux/skbuff.h>
 #include <linux/workqueue.h>
+#include <linux/random.h>
 #include <scsi/fc/fc_fcoe.h>
 #include <scsi/libfc.h>
 
@@ -37,6 +38,7 @@
 #define FCOE_CTLR_START_DELAY	2000	/* mS after first adv. to choose FCF */
 #define FCOE_CTRL_SOL_TOV	2000	/* min. solicitation interval (mS) */
 #define FCOE_CTLR_FCF_LIMIT	20	/* max. number of FCF entries */
+#define FCOE_CTLR_VN2VN_LOGIN_LIMIT 3	/* max. VN2VN rport login retries */
 
 /**
  * enum fip_state - internal state of FCoE controller.
@@ -45,6 +47,11 @@
  * @FIP_ST_AUTO:	determining whether to use FIP or non-FIP mode.
  * @FIP_ST_NON_FIP:	non-FIP mode selected.
  * @FIP_ST_ENABLED:	FIP mode selected.
+ * @FIP_ST_VNMP_START:	VN2VN multipath mode start, wait
+ * @FIP_ST_VNMP_PROBE1:	VN2VN sent first probe, listening
+ * @FIP_ST_VNMP_PROBE2:	VN2VN sent second probe, listening
+ * @FIP_ST_VNMP_CLAIM:	VN2VN sent claim, waiting for responses
+ * @FIP_ST_VNMP_UP:	VN2VN multipath mode operation
  */
 enum fip_state {
 	FIP_ST_DISABLED,
@@ -52,6 +59,11 @@ enum fip_state {
 	FIP_ST_AUTO,
 	FIP_ST_NON_FIP,
 	FIP_ST_ENABLED,
+	FIP_ST_VNMP_START,
+	FIP_ST_VNMP_PROBE1,
+	FIP_ST_VNMP_PROBE2,
+	FIP_ST_VNMP_CLAIM,
+	FIP_ST_VNMP_UP,
 };
 
 /*
@@ -62,6 +74,7 @@ enum fip_state {
 #define FIP_MODE_AUTO		FIP_ST_AUTO
 #define FIP_MODE_NON_FIP	FIP_ST_NON_FIP
 #define FIP_MODE_FABRIC		FIP_ST_ENABLED
+#define FIP_MODE_VN2VN		FIP_ST_VNMP_START
 
 /**
  * struct fcoe_ctlr - FCoE Controller and FIP state
@@ -79,11 +92,14 @@ enum fip_state {
  * @timer_work:	   &work_struct for doing keep-alives and resets.
  * @recv_work:	   &work_struct for receiving FIP frames.
  * @fip_recv_list: list of received FIP frames.
+ * @rnd_state:	   state for pseudo-random number generator.
+ * @port_id:	   proposed or selected local-port ID.
  * @user_mfs:	   configured maximum FC frame size, including FC header.
  * @flogi_oxid:    exchange ID of most recent fabric login.
  * @flogi_count:   number of FLOGI attempts in AUTO mode.
  * @map_dest:	   use the FC_MAP mode for destination MAC addresses.
  * @spma:	   supports SPMA server-provided MACs mode
+ * @probe_tries:   number of FC_IDs probed
  * @dest_addr:	   MAC address of the selected FC forwarder.
  * @ctl_src_addr:  the native MAC address of our local port.
  * @send:	   LLD-supplied function to handle sending FIP Ethernet frames
@@ -110,11 +126,16 @@ struct fcoe_ctlr {
 	struct work_struct timer_work;
 	struct work_struct recv_work;
 	struct sk_buff_head fip_recv_list;
+
+	struct rnd_state rnd_state;
+	u32 port_id;
+
 	u16 user_mfs;
 	u16 flogi_oxid;
 	u8 flogi_count;
 	u8 map_dest;
 	u8 spma;
+	u8 probe_tries;
 	u8 dest_addr[ETH_ALEN];
 	u8 ctl_src_addr[ETH_ALEN];
 
@@ -160,6 +181,24 @@ struct fcoe_fcf {
 	u8 fd_flags:1;
 };
 
+/**
+ * struct fcoe_rport - VN2VN remote port
+ * @time:	time of create or last beacon packet received from node
+ * @fcoe_len:	max FCoE frame size, not including VLAN or Ethernet headers
+ * @flags:	flags from probe or claim
+ * @login_count: number of unsuccessful rport logins to this port
+ * @enode_mac:	E_Node control MAC address
+ * @vn_mac:	VN_Node assigned MAC address for data
+ */
+struct fcoe_rport {
+	unsigned long time;
+	u16 fcoe_len;
+	u16 flags;
+	u8 login_count;
+	u8 enode_mac[ETH_ALEN];
+	u8 vn_mac[ETH_ALEN];
+};
+
 /* FIP API functions */
 void fcoe_ctlr_init(struct fcoe_ctlr *, enum fip_state);
 void fcoe_ctlr_destroy(struct fcoe_ctlr *);
@@ -172,7 +211,8 @@ int fcoe_ctlr_recv_flogi(struct fcoe_ctlr *, struct fc_lport *,
 
 /* libfcoe funcs */
 u64 fcoe_wwn_from_mac(unsigned char mac[], unsigned int, unsigned int);
-int fcoe_libfc_config(struct fc_lport *, struct libfc_function_template *);
+int fcoe_libfc_config(struct fc_lport *, struct fcoe_ctlr *,
+		      const struct libfc_function_template *, int init_fcp);
 
 /**
  * is_fip_mode() - returns true if FIP mode selected.

commit 3d902ac09a2812b359edf633425d1327a18399e9
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Jul 20 15:19:58 2010 -0700

    [SCSI] libfcoe: fcoe: fnic: change fcoe_ctlr_init interface to specify mode
    
    There are three modes that libfcoe currently supports, and a new one
    is coming.  Change the fcoe_ctlr_init() interface to add the mode
    desired.  This should not change any functionality.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 7d18b500f2c1..1a84a3182da0 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -54,6 +54,15 @@ enum fip_state {
 	FIP_ST_ENABLED,
 };
 
+/*
+ * Modes:
+ * The mode is the state that is to be entered after link up.
+ * It must not change after fcoe_ctlr_init() sets it.
+ */
+#define FIP_MODE_AUTO		FIP_ST_AUTO
+#define FIP_MODE_NON_FIP	FIP_ST_NON_FIP
+#define FIP_MODE_FABRIC		FIP_ST_ENABLED
+
 /**
  * struct fcoe_ctlr - FCoE Controller and FIP state
  * @state:	   internal FIP state for network link and FIP or non-FIP mode.
@@ -152,7 +161,7 @@ struct fcoe_fcf {
 };
 
 /* FIP API functions */
-void fcoe_ctlr_init(struct fcoe_ctlr *);
+void fcoe_ctlr_init(struct fcoe_ctlr *, enum fip_state);
 void fcoe_ctlr_destroy(struct fcoe_ctlr *);
 void fcoe_ctlr_link_up(struct fcoe_ctlr *);
 int fcoe_ctlr_link_down(struct fcoe_ctlr *);

commit fdb068c6cd6e30d43664f856d3530715a5742713
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Jul 20 15:19:47 2010 -0700

    [SCSI] libfcoe: convert FIP to lock with mutex instead of spin lock
    
    It turns out most of the FIP work is now done from worker threads
    or process context now, so there's no need to use a spin lock.
    
    Change to use mutex instead of spin lock and delayed_work instead
    of a timer.
    
    This will make it nicer for the VN_port to VN_port feature that
    will interact more with the libfc layers requiring that
    spinlocks not be held.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 81aee1c4c2f3..7d18b500f2c1 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -75,14 +75,12 @@ enum fip_state {
  * @flogi_count:   number of FLOGI attempts in AUTO mode.
  * @map_dest:	   use the FC_MAP mode for destination MAC addresses.
  * @spma:	   supports SPMA server-provided MACs mode
- * @send_ctlr_ka:  need to send controller keep alive
- * @send_port_ka:  need to send port keep alives
  * @dest_addr:	   MAC address of the selected FC forwarder.
  * @ctl_src_addr:  the native MAC address of our local port.
  * @send:	   LLD-supplied function to handle sending FIP Ethernet frames
  * @update_mac:    LLD-supplied function to handle changes to MAC addresses.
  * @get_src_addr:  LLD-supplied function to supply a source MAC address.
- * @lock:	   lock protecting this structure.
+ * @ctlr_mutex:	   lock protecting this structure.
  *
  * This structure is used by all FCoE drivers.  It contains information
  * needed by all FCoE low-level drivers (LLDs) as well as internal state
@@ -106,18 +104,15 @@ struct fcoe_ctlr {
 	u16 user_mfs;
 	u16 flogi_oxid;
 	u8 flogi_count;
-	u8 reset_req;
 	u8 map_dest;
 	u8 spma;
-	u8 send_ctlr_ka;
-	u8 send_port_ka;
 	u8 dest_addr[ETH_ALEN];
 	u8 ctl_src_addr[ETH_ALEN];
 
 	void (*send)(struct fcoe_ctlr *, struct sk_buff *);
 	void (*update_mac)(struct fc_lport *, u8 *addr);
 	u8 * (*get_src_addr)(struct fc_lport *);
-	spinlock_t lock;
+	struct mutex ctlr_mutex;
 };
 
 /**

commit 519e5135e2537c9dbc1cbcc0891b0a936ff5dcd2
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Tue Jul 20 15:19:32 2010 -0700

    [SCSI] fcoe: adds src and dest mac address checking for fcoe frames
    
    This is  per FC-BB-5 Annex-D recommendation and per that
    if address checking fails then drop the frame.
    
    FIP code paths are already doing this so only needed for fcoe
    frames.
    
    The src address checking is limited to only fip mode since
    this might break non-fip mode used in p2p due to used OUI
    based addressing in some p2p code paths, going forward FIP
    will be the only mode, therefore limited this to only FIP
    mode so that it won't break non-fip p2p mode for now.
    
    -v2
    Removes FCOE packet type checking since fcoe_rcv is
    registered to receive only FCoE type packets from netdev
    and it is already checked by netdev.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index ec13f51531f8..81aee1c4c2f3 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -170,4 +170,14 @@ int fcoe_ctlr_recv_flogi(struct fcoe_ctlr *, struct fc_lport *,
 u64 fcoe_wwn_from_mac(unsigned char mac[], unsigned int, unsigned int);
 int fcoe_libfc_config(struct fc_lport *, struct libfc_function_template *);
 
+/**
+ * is_fip_mode() - returns true if FIP mode selected.
+ * @fip:	FCoE controller.
+ */
+static inline bool is_fip_mode(struct fcoe_ctlr *fip)
+{
+	return fip->state == FIP_ST_ENABLED;
+}
+
+
 #endif /* _LIBFCOE_H */

commit da87bfab8a7e6cfd0e1e5c5874d7fd4f7d11e64e
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Fri Apr 9 14:22:59 2010 -0700

    [SCSI] fcoe, fnic, libfc: increased CDB size to 16 bytes for fcoe.
    
    No reason to restrict CDB size to 12 bytes in fcoe, so
    increased to 16 so that 16 bytes SCSI CDB doesn't fail.
    
    Uses common define to set max_cmd_len for fcoe and fnic,
    fnic is already setting max_cmd_len to 16.
    
    sg_readcap -l fails without this fix.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 868ed26a9767..ec13f51531f8 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -29,6 +29,8 @@
 #include <scsi/fc/fc_fcoe.h>
 #include <scsi/libfc.h>
 
+#define FCOE_MAX_CMD_LEN	16	/* Supported CDB length */
+
 /*
  * FIP tunable parameters.
  */

commit 4291365784c9622c9d643cf23421f9c7b9662d71
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Fri Mar 12 16:08:23 2010 -0800

    [SCSI] libfcoe: eliminate unused link and last_link fields
    
    The link and last_link fields in the fcoe_ctlr struct are no
    longer useful, since they are always set to the same value,
    and FIP always calls libfc to pass link information to the lport.
    
    Eliminate those fields and rename link_work to timer_work, since
    it no longer has any link change work to do.
    
    Thanks to Brian Uchino for discovering this issue.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index c603f4a7e7fc..868ed26a9767 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -65,14 +65,12 @@ enum fip_state {
  * @port_ka_time:  time of next port keep-alive.
  * @ctlr_ka_time:  time of next controller keep-alive.
  * @timer:	   timer struct used for all delayed events.
- * @link_work:	   &work_struct for doing FCF selection.
+ * @timer_work:	   &work_struct for doing keep-alives and resets.
  * @recv_work:	   &work_struct for receiving FIP frames.
  * @fip_recv_list: list of received FIP frames.
  * @user_mfs:	   configured maximum FC frame size, including FC header.
  * @flogi_oxid:    exchange ID of most recent fabric login.
  * @flogi_count:   number of FLOGI attempts in AUTO mode.
- * @link:	   current link status for libfc.
- * @last_link:	   last link state reported to libfc.
  * @map_dest:	   use the FC_MAP mode for destination MAC addresses.
  * @spma:	   supports SPMA server-provided MACs mode
  * @send_ctlr_ka:  need to send controller keep alive
@@ -100,14 +98,12 @@ struct fcoe_ctlr {
 	unsigned long port_ka_time;
 	unsigned long ctlr_ka_time;
 	struct timer_list timer;
-	struct work_struct link_work;
+	struct work_struct timer_work;
 	struct work_struct recv_work;
 	struct sk_buff_head fip_recv_list;
 	u16 user_mfs;
 	u16 flogi_oxid;
 	u8 flogi_count;
-	u8 link;
-	u8 last_link;
 	u8 reset_req;
 	u8 map_dest;
 	u8 spma;

commit 8cdffdccd948ea4872b7b65280bc04f2fa93fc96
Author: Yi Zou <yi.zou@intel.com>
Date:   Fri Nov 20 14:54:57 2009 -0800

    [SCSI] libfcoe: add checking disable flag in FIP_FKA_ADV
    
    When the D bit is set if the FKA_ADV_Period of the FIP Discovery
    Advertisement, the ENode should not transmit period ENode FIP Keep Alive and
    VN_Port FIP Keep Alive (FC-BB-5 Rev2, 7.8.3.13).
    
    Note that fcf->flags is taken directly from the fip_header, I am claiming one
    bit for the purpose of the FIP_FKA_Period D bit as FIP_FL_FK_ADV_B, and use
    FIP_HEADER_FLAGS as bitmask for bits used in fip_header.
    
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 3837872f1965..c603f4a7e7fc 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -155,6 +155,7 @@ struct fcoe_fcf {
 	u8 pri;
 	u16 flags;
 	u32 fka_period;
+	u8 fd_flags:1;
 };
 
 /* FIP API functions */

commit 386309ce927a308d7742a6fb24a536d3383fbd49
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Nov 3 11:49:16 2009 -0800

    [SCSI] libfcoe: fcoe: simplify receive FLOGI response
    
    There was a locking problem where the fip->lock was held during
    the call to update_mac().  The rtnl_lock() must be taken before
    the fip->lock, not the other way around.  This fixes that.
    
    Now that fcoe_ctlr_recv_flog() is called only from the response handler
    to a FLOGI request, some checking can be eliminated.  Instead of calling
    update_mac(), just fill in the granted_mac address for the passed-in
    frame (skb).
    
    Eliminate the passed-in source MAC address since it is also in the skb.
    
    Also, in fcoe, call fcoe_set_src_mac() directly instead of going thru
    the fip function pointer.  This will generate less code.
    Then, since fip isn't needed for LOGO response, use lport as the arg.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index e38ffa05dc26..3837872f1965 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -165,7 +165,7 @@ int fcoe_ctlr_link_down(struct fcoe_ctlr *);
 int fcoe_ctlr_els_send(struct fcoe_ctlr *, struct fc_lport *, struct sk_buff *);
 void fcoe_ctlr_recv(struct fcoe_ctlr *, struct sk_buff *);
 int fcoe_ctlr_recv_flogi(struct fcoe_ctlr *, struct fc_lport *,
-			 struct fc_frame *, u8 *);
+			 struct fc_frame *);
 
 /* libfcoe funcs */
 u64 fcoe_wwn_from_mac(unsigned char mac[], unsigned int, unsigned int);

commit dd42dac4ecd1799077c132aab35d3c36b26d4d8c
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Nov 3 11:48:27 2009 -0800

    [SCSI] libfcoe: FIP should report link to libfc whether selected or not
    
    The fnic driver with FIP is reporting link up, even though it's down.
    
    When the interface is shut down by the switch, we receive a clear
    virtual link, and set the state reported to libfc as down, although
    we still report it up.  Clearly wrong.  That causes the subsequent
    link down event not to be reported, and /sys shows the host "Online".
    
    Currently, in FIP mode, if an FCF times out, then link to libfc
    is reported as down, to stop FLOGIs.  That interferes with the LLD
    link down being reported.
    
    Users really need to know the physical link information, to diagnose
    cabling issues, so physical link status should be reported to libfc.
    
    If the selected FCF needs to be reported, that should be done
    separately, in a later patch.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 2344a00e92ef..e38ffa05dc26 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -108,6 +108,7 @@ struct fcoe_ctlr {
 	u8 flogi_count;
 	u8 link;
 	u8 last_link;
+	u8 reset_req;
 	u8 map_dest;
 	u8 spma;
 	u8 send_ctlr_ka;

commit 22bcd225bfe2107725228758137d2109befa942a
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Nov 3 11:48:11 2009 -0800

    [SCSI] libfcoe: Allow FIP to be disabled by the driver
    
    Allow FIP to be disabled by the driver for devices
    that want to use libfcoe in non-FIP mode.
    
    The driver merely sets the fcoe_ctlr mode to the state which
    should be entered when the link comes up.  The default is auto.
    No change is needed for fcoe.c which uses auto mode.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 76d08c9a7678..2344a00e92ef 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -55,6 +55,7 @@ enum fip_state {
 /**
  * struct fcoe_ctlr - FCoE Controller and FIP state
  * @state:	   internal FIP state for network link and FIP or non-FIP mode.
+ * @mode:	   LLD-selected mode.
  * @lp:		   &fc_lport: libfc local port.
  * @sel_fcf:	   currently selected FCF, or NULL.
  * @fcfs:	   list of discovered FCFs.
@@ -89,6 +90,7 @@ enum fip_state {
  */
 struct fcoe_ctlr {
 	enum fip_state state;
+	enum fip_state mode;
 	struct fc_lport *lp;
 	struct fcoe_fcf *sel_fcf;
 	struct list_head fcfs;

commit 70b51aabf3b03fbf8d61c14847ccce4c69fb0cdd
Author: Robert Love <robert.w.love@intel.com>
Date:   Tue Nov 3 11:47:45 2009 -0800

    [SCSI] libfcoe: formatting and comment cleanups
    
    Ensures that there are kernel-doc style comments for all
    routines and structures.
    
    There were also a few instances of fc_lport's named 'lp'
    which were switched to 'lport' as per the libfc/libfcoe/fcoe
    naming convention.
    
    Also, emacs 'indent-region' and 'tabify' were ran on libfcoe.c.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 8ef5e209c216..76d08c9a7678 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -53,35 +53,35 @@ enum fip_state {
 };
 
 /**
- * struct fcoe_ctlr - FCoE Controller and FIP state.
- * @state:	internal FIP state for network link and FIP or non-FIP mode.
- * @lp:		&fc_lport: libfc local port.
- * @sel_fcf:	currently selected FCF, or NULL.
- * @fcfs:	list of discovered FCFs.
- * @fcf_count:	number of discovered FCF entries.
- * @sol_time:	time when a multicast solicitation was last sent.
- * @sel_time:	time after which to select an FCF.
- * @port_ka_time: time of next port keep-alive.
- * @ctlr_ka_time: time of next controller keep-alive.
- * @timer:	timer struct used for all delayed events.
- * @link_work:	&work_struct for doing FCF selection.
- * @recv_work:	&work_struct for receiving FIP frames.
+ * struct fcoe_ctlr - FCoE Controller and FIP state
+ * @state:	   internal FIP state for network link and FIP or non-FIP mode.
+ * @lp:		   &fc_lport: libfc local port.
+ * @sel_fcf:	   currently selected FCF, or NULL.
+ * @fcfs:	   list of discovered FCFs.
+ * @fcf_count:	   number of discovered FCF entries.
+ * @sol_time:	   time when a multicast solicitation was last sent.
+ * @sel_time:	   time after which to select an FCF.
+ * @port_ka_time:  time of next port keep-alive.
+ * @ctlr_ka_time:  time of next controller keep-alive.
+ * @timer:	   timer struct used for all delayed events.
+ * @link_work:	   &work_struct for doing FCF selection.
+ * @recv_work:	   &work_struct for receiving FIP frames.
  * @fip_recv_list: list of received FIP frames.
- * @user_mfs:	configured maximum FC frame size, including FC header.
- * @flogi_oxid: exchange ID of most recent fabric login.
- * @flogi_count: number of FLOGI attempts in AUTO mode.
- * @link:	current link status for libfc.
- * @last_link:	last link state reported to libfc.
- * @map_dest:	use the FC_MAP mode for destination MAC addresses.
- * @spma:	supports SPMA server-provided MACs mode
- * @send_ctlr_ka: need to send controller keep alive
- * @send_port_ka: need to send port keep alives
- * @dest_addr:	MAC address of the selected FC forwarder.
- * @ctl_src_addr: the native MAC address of our local port.
- * @send:	LLD-supplied function to handle sending of FIP Ethernet frames.
- * @update_mac: LLD-supplied function to handle changes to MAC addresses.
- * @get_src_addr: LLD-supplied function to supply a source MAC address.
- * @lock:	lock protecting this structure.
+ * @user_mfs:	   configured maximum FC frame size, including FC header.
+ * @flogi_oxid:    exchange ID of most recent fabric login.
+ * @flogi_count:   number of FLOGI attempts in AUTO mode.
+ * @link:	   current link status for libfc.
+ * @last_link:	   last link state reported to libfc.
+ * @map_dest:	   use the FC_MAP mode for destination MAC addresses.
+ * @spma:	   supports SPMA server-provided MACs mode
+ * @send_ctlr_ka:  need to send controller keep alive
+ * @send_port_ka:  need to send port keep alives
+ * @dest_addr:	   MAC address of the selected FC forwarder.
+ * @ctl_src_addr:  the native MAC address of our local port.
+ * @send:	   LLD-supplied function to handle sending FIP Ethernet frames
+ * @update_mac:    LLD-supplied function to handle changes to MAC addresses.
+ * @get_src_addr:  LLD-supplied function to supply a source MAC address.
+ * @lock:	   lock protecting this structure.
  *
  * This structure is used by all FCoE drivers.  It contains information
  * needed by all FCoE low-level drivers (LLDs) as well as internal state
@@ -119,18 +119,18 @@ struct fcoe_ctlr {
 	spinlock_t lock;
 };
 
-/*
- * struct fcoe_fcf - Fibre-Channel Forwarder.
- * @list:	list linkage.
- * @time:	system time (jiffies) when an advertisement was last received.
- * @switch_name: WWN of switch from advertisement.
- * @fabric_name: WWN of fabric from advertisement.
- * @fc_map:	FC_MAP value from advertisement.
- * @fcf_mac:	Ethernet address of the FCF.
- * @vfid:	virtual fabric ID.
- * @pri:	seletion priority, smaller values are better.
- * @flags:	flags received from advertisement.
- * @fka_period:	keep-alive period, in jiffies.
+/**
+ * struct fcoe_fcf - Fibre-Channel Forwarder
+ * @list:	 list linkage
+ * @time:	 system time (jiffies) when an advertisement was last received
+ * @switch_name: WWN of switch from advertisement
+ * @fabric_name: WWN of fabric from advertisement
+ * @fc_map:	 FC_MAP value from advertisement
+ * @fcf_mac:	 Ethernet address of the FCF
+ * @vfid:	 virtual fabric ID
+ * @pri:	 selection priority, smaller values are better
+ * @flags:	 flags received from advertisement
+ * @fka_period:	 keep-alive period, in jiffies
  *
  * A Fibre-Channel Forwarder (FCF) is the entity on the Ethernet that
  * passes FCoE frames on to an FC fabric.  This structure represents
@@ -161,8 +161,8 @@ void fcoe_ctlr_link_up(struct fcoe_ctlr *);
 int fcoe_ctlr_link_down(struct fcoe_ctlr *);
 int fcoe_ctlr_els_send(struct fcoe_ctlr *, struct fc_lport *, struct sk_buff *);
 void fcoe_ctlr_recv(struct fcoe_ctlr *, struct sk_buff *);
-int fcoe_ctlr_recv_flogi(struct fcoe_ctlr *, struct fc_lport *lport,
-			 struct fc_frame *fp, u8 *sa);
+int fcoe_ctlr_recv_flogi(struct fcoe_ctlr *, struct fc_lport *,
+			 struct fc_frame *, u8 *);
 
 /* libfcoe funcs */
 u64 fcoe_wwn_from_mac(unsigned char mac[], unsigned int, unsigned int);

commit 11b561886643d4e23d0fd58c205d830a448dd0a2
Author: Chris Leech <christopher.leech@intel.com>
Date:   Tue Nov 3 11:46:29 2009 -0800

    [SCSI] libfcoe, fcoe: libfcoe NPIV support
    
    The FIP code in libfcoe needed several changes to support NPIV
    
    1) dst_src_addr needs to be managed per-n_port-ID for FPMA fabrics with NPIV
       enabled.  Managing the MAC address is now handled in fcoe, with some slight
       changes to update_mac() and a new get_src_addr() function pointer.
    
    2) The libfc elsct_send() hook is used to setup FCoE specific response
       handlers for FIP encapsulated ELS exchanges.  This lets the FCoE specific
       handling know which VN_Port the exchange is for, and doesn't require
       tracking OX_IDs.  It might be possible to roll back to the full FIP frame
       in these, but for now I've just stashed the contents of the MAC address
       descriptor in the skb context block for later use.  Also, because
       fcoe_elsct_send() just passes control on to fc_elsct_send(), all transmits
       still come through the normal frame_send() path.
    
    3) The NPIV changes added a mutex hold in the keep alive sending, the lport
       mutex is protecting the vport list.  We can't take a mutex from a timer,
       so move the FIP keep alive logic to the link work struct.
    
    Signed-off-by: Chris Leech <christopher.leech@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index b2410605b740..8ef5e209c216 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -74,11 +74,13 @@ enum fip_state {
  * @last_link:	last link state reported to libfc.
  * @map_dest:	use the FC_MAP mode for destination MAC addresses.
  * @spma:	supports SPMA server-provided MACs mode
+ * @send_ctlr_ka: need to send controller keep alive
+ * @send_port_ka: need to send port keep alives
  * @dest_addr:	MAC address of the selected FC forwarder.
  * @ctl_src_addr: the native MAC address of our local port.
- * @data_src_addr: the assigned MAC address for the local port after FLOGI.
  * @send:	LLD-supplied function to handle sending of FIP Ethernet frames.
  * @update_mac: LLD-supplied function to handle changes to MAC addresses.
+ * @get_src_addr: LLD-supplied function to supply a source MAC address.
  * @lock:	lock protecting this structure.
  *
  * This structure is used by all FCoE drivers.  It contains information
@@ -106,12 +108,14 @@ struct fcoe_ctlr {
 	u8 last_link;
 	u8 map_dest;
 	u8 spma;
+	u8 send_ctlr_ka;
+	u8 send_port_ka;
 	u8 dest_addr[ETH_ALEN];
 	u8 ctl_src_addr[ETH_ALEN];
-	u8 data_src_addr[ETH_ALEN];
 
 	void (*send)(struct fcoe_ctlr *, struct sk_buff *);
-	void (*update_mac)(struct fcoe_ctlr *, u8 *old, u8 *new);
+	void (*update_mac)(struct fc_lport *, u8 *addr);
+	u8 * (*get_src_addr)(struct fc_lport *);
 	spinlock_t lock;
 };
 
@@ -155,9 +159,10 @@ void fcoe_ctlr_init(struct fcoe_ctlr *);
 void fcoe_ctlr_destroy(struct fcoe_ctlr *);
 void fcoe_ctlr_link_up(struct fcoe_ctlr *);
 int fcoe_ctlr_link_down(struct fcoe_ctlr *);
-int fcoe_ctlr_els_send(struct fcoe_ctlr *, struct sk_buff *);
+int fcoe_ctlr_els_send(struct fcoe_ctlr *, struct fc_lport *, struct sk_buff *);
 void fcoe_ctlr_recv(struct fcoe_ctlr *, struct sk_buff *);
-int fcoe_ctlr_recv_flogi(struct fcoe_ctlr *, struct fc_frame *fp, u8 *sa);
+int fcoe_ctlr_recv_flogi(struct fcoe_ctlr *, struct fc_lport *lport,
+			 struct fc_frame *fp, u8 *sa);
 
 /* libfcoe funcs */
 u64 fcoe_wwn_from_mac(unsigned char mac[], unsigned int, unsigned int);

commit 184dd3459bb334d9061b58faed3610d08d6c7ff8
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Sun May 17 12:33:28 2009 +0000

    fcoe: adds spma mode support
    
    If we can find a type NETDEV_HW_ADDR_T_SAN mac address from the
    corresponding netdev for a fcoe interface then sets up added the
    fc->ctlr.spma flag and stores spma mode address in ctl_src_addr.
    
    In case the spma flag is set then:-
    
     1. Adds spma mode MAC address in ctl_src_addr as secondary
        MAC address, the FLOGI for FIP and pre-FIP will go out
        using this address.
     2. Cleans up stored spma MAC address in ctl_src_addr in
        fcoe_netdev_cleanup.
     3. Sets up spma bit in fip_flags for FIP solicitations along
        with exiting FPMA bit setting.
     4. Initialize the FLOGI FIP MAC descriptor to stored spma
        MAC address in ctl_src_addr. This is used as proposed
        FCoE MAC address from initiator along with both SPMA
        and FPMA bit set in FIP solicitation, in response the
        switch may grant any FPMA or SPMA mode MAC address to
        initiator.
    
    Removes FIP descriptor type checking against ELS type
    ELS_FLOGI in fcoe_ctlr_encaps to update a FIP MAC descriptor,
    instead now checks against FIP_DT_FLOGI.
    
    I've tested this with available FPMA-only FCoE switch but
    since data_src_addr is updated using same old code for
    both FPMA and SPMA modes with FIP or pre-FIP links, so added
    SPMA mode will work with SPMA-only switch also provided that
    switch grants a valid MAC address.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 666cc131732e..b2410605b740 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -73,6 +73,7 @@ enum fip_state {
  * @link:	current link status for libfc.
  * @last_link:	last link state reported to libfc.
  * @map_dest:	use the FC_MAP mode for destination MAC addresses.
+ * @spma:	supports SPMA server-provided MACs mode
  * @dest_addr:	MAC address of the selected FC forwarder.
  * @ctl_src_addr: the native MAC address of our local port.
  * @data_src_addr: the assigned MAC address for the local port after FLOGI.
@@ -104,6 +105,7 @@ struct fcoe_ctlr {
 	u8 link;
 	u8 last_link;
 	u8 map_dest;
+	u8 spma;
 	u8 dest_addr[ETH_ALEN];
 	u8 ctl_src_addr[ETH_ALEN];
 	u8 data_src_addr[ETH_ALEN];

commit 97c8389d54b9665c38105ea72a428a44b97ff2f6
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Mar 17 11:42:40 2009 -0700

    [SCSI] fcoe, libfcoe: Add support for FIP. FCoE discovery and keep-alive.
    
    FIP is the new standard way to discover Fibre-Channel Forwarders (FCFs)
    by sending solicitations and listening for advertisements from FCFs.
    
    It also provides for keep-alives and period advertisements so that both
    parties know they have connectivity.  If the FCF loses connectivity to
    the storage fabric, it can send a Link Reset to inform the E_node.
    
    This version is also compatible with pre-FIP implementations, so no
    configured selection between FIP mode and non-FIP mode is required.
    
    We wait a couple seconds after sending the initial solicitation
    and then send an old-style FLOGI.  If we receive any FIP frames,
    we use FIP only mode.  If the old FLOGI receives a response,
    we disable FIP mode.  After every reset or link up, this
    determination is repeated.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index d07ebe688403..666cc131732e 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -1,5 +1,6 @@
 /*
- * Copyright(c) 2007 - 2008 Intel Corporation. All rights reserved.
+ * Copyright (c) 2008-2009 Cisco Systems, Inc.  All rights reserved.
+ * Copyright (c) 2007-2008 Intel Corporation.  All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -20,11 +21,142 @@
 #ifndef _LIBFCOE_H
 #define _LIBFCOE_H
 
+#include <linux/etherdevice.h>
+#include <linux/if_ether.h>
 #include <linux/netdevice.h>
 #include <linux/skbuff.h>
+#include <linux/workqueue.h>
 #include <scsi/fc/fc_fcoe.h>
 #include <scsi/libfc.h>
 
+/*
+ * FIP tunable parameters.
+ */
+#define FCOE_CTLR_START_DELAY	2000	/* mS after first adv. to choose FCF */
+#define FCOE_CTRL_SOL_TOV	2000	/* min. solicitation interval (mS) */
+#define FCOE_CTLR_FCF_LIMIT	20	/* max. number of FCF entries */
+
+/**
+ * enum fip_state - internal state of FCoE controller.
+ * @FIP_ST_DISABLED: 	controller has been disabled or not yet enabled.
+ * @FIP_ST_LINK_WAIT:	the physical link is down or unusable.
+ * @FIP_ST_AUTO:	determining whether to use FIP or non-FIP mode.
+ * @FIP_ST_NON_FIP:	non-FIP mode selected.
+ * @FIP_ST_ENABLED:	FIP mode selected.
+ */
+enum fip_state {
+	FIP_ST_DISABLED,
+	FIP_ST_LINK_WAIT,
+	FIP_ST_AUTO,
+	FIP_ST_NON_FIP,
+	FIP_ST_ENABLED,
+};
+
+/**
+ * struct fcoe_ctlr - FCoE Controller and FIP state.
+ * @state:	internal FIP state for network link and FIP or non-FIP mode.
+ * @lp:		&fc_lport: libfc local port.
+ * @sel_fcf:	currently selected FCF, or NULL.
+ * @fcfs:	list of discovered FCFs.
+ * @fcf_count:	number of discovered FCF entries.
+ * @sol_time:	time when a multicast solicitation was last sent.
+ * @sel_time:	time after which to select an FCF.
+ * @port_ka_time: time of next port keep-alive.
+ * @ctlr_ka_time: time of next controller keep-alive.
+ * @timer:	timer struct used for all delayed events.
+ * @link_work:	&work_struct for doing FCF selection.
+ * @recv_work:	&work_struct for receiving FIP frames.
+ * @fip_recv_list: list of received FIP frames.
+ * @user_mfs:	configured maximum FC frame size, including FC header.
+ * @flogi_oxid: exchange ID of most recent fabric login.
+ * @flogi_count: number of FLOGI attempts in AUTO mode.
+ * @link:	current link status for libfc.
+ * @last_link:	last link state reported to libfc.
+ * @map_dest:	use the FC_MAP mode for destination MAC addresses.
+ * @dest_addr:	MAC address of the selected FC forwarder.
+ * @ctl_src_addr: the native MAC address of our local port.
+ * @data_src_addr: the assigned MAC address for the local port after FLOGI.
+ * @send:	LLD-supplied function to handle sending of FIP Ethernet frames.
+ * @update_mac: LLD-supplied function to handle changes to MAC addresses.
+ * @lock:	lock protecting this structure.
+ *
+ * This structure is used by all FCoE drivers.  It contains information
+ * needed by all FCoE low-level drivers (LLDs) as well as internal state
+ * for FIP, and fields shared with the LLDS.
+ */
+struct fcoe_ctlr {
+	enum fip_state state;
+	struct fc_lport *lp;
+	struct fcoe_fcf *sel_fcf;
+	struct list_head fcfs;
+	u16 fcf_count;
+	unsigned long sol_time;
+	unsigned long sel_time;
+	unsigned long port_ka_time;
+	unsigned long ctlr_ka_time;
+	struct timer_list timer;
+	struct work_struct link_work;
+	struct work_struct recv_work;
+	struct sk_buff_head fip_recv_list;
+	u16 user_mfs;
+	u16 flogi_oxid;
+	u8 flogi_count;
+	u8 link;
+	u8 last_link;
+	u8 map_dest;
+	u8 dest_addr[ETH_ALEN];
+	u8 ctl_src_addr[ETH_ALEN];
+	u8 data_src_addr[ETH_ALEN];
+
+	void (*send)(struct fcoe_ctlr *, struct sk_buff *);
+	void (*update_mac)(struct fcoe_ctlr *, u8 *old, u8 *new);
+	spinlock_t lock;
+};
+
+/*
+ * struct fcoe_fcf - Fibre-Channel Forwarder.
+ * @list:	list linkage.
+ * @time:	system time (jiffies) when an advertisement was last received.
+ * @switch_name: WWN of switch from advertisement.
+ * @fabric_name: WWN of fabric from advertisement.
+ * @fc_map:	FC_MAP value from advertisement.
+ * @fcf_mac:	Ethernet address of the FCF.
+ * @vfid:	virtual fabric ID.
+ * @pri:	seletion priority, smaller values are better.
+ * @flags:	flags received from advertisement.
+ * @fka_period:	keep-alive period, in jiffies.
+ *
+ * A Fibre-Channel Forwarder (FCF) is the entity on the Ethernet that
+ * passes FCoE frames on to an FC fabric.  This structure represents
+ * one FCF from which advertisements have been received.
+ *
+ * When looking up an FCF, @switch_name, @fabric_name, @fc_map, @vfid, and
+ * @fcf_mac together form the lookup key.
+ */
+struct fcoe_fcf {
+	struct list_head list;
+	unsigned long time;
+
+	u64 switch_name;
+	u64 fabric_name;
+	u32 fc_map;
+	u16 vfid;
+	u8 fcf_mac[ETH_ALEN];
+
+	u8 pri;
+	u16 flags;
+	u32 fka_period;
+};
+
+/* FIP API functions */
+void fcoe_ctlr_init(struct fcoe_ctlr *);
+void fcoe_ctlr_destroy(struct fcoe_ctlr *);
+void fcoe_ctlr_link_up(struct fcoe_ctlr *);
+int fcoe_ctlr_link_down(struct fcoe_ctlr *);
+int fcoe_ctlr_els_send(struct fcoe_ctlr *, struct sk_buff *);
+void fcoe_ctlr_recv(struct fcoe_ctlr *, struct sk_buff *);
+int fcoe_ctlr_recv_flogi(struct fcoe_ctlr *, struct fc_frame *fp, u8 *sa);
+
 /* libfcoe funcs */
 u64 fcoe_wwn_from_mac(unsigned char mac[], unsigned int, unsigned int);
 int fcoe_libfc_config(struct fc_lport *, struct libfc_function_template *);

commit fdd78027fd472351783fb6110a72d991c1a07402
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Tue Mar 17 11:42:24 2009 -0700

    [SCSI] fcoe: cleans up libfcoe.h and adds fcoe.h for fcoe module
    
    Removes no where used several inline functions prefixed with skb_*
    and be16_to_cpu.
    
    Moves fcoe module specific func prototypes to fcoe.c from libfcoe.h,
    moved only need for build.
    
    Adds fcoe module header file fcoe.h and then moves fcoe module
    specific fcoe_percpu_s and fcoe_softc to fcoe.h from libfcoe.h.
    
    Moves all defines from fcoe.c to fcoe.h since now fcoe module
    has its own header file fcoe.h.
    
    [jejb: removed EXPORT_SYMBOL_GPL(fcoe_fc_crc) which caused a section mismatch]
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index e99633cefd37..d07ebe688403 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -25,124 +25,8 @@
 #include <scsi/fc/fc_fcoe.h>
 #include <scsi/libfc.h>
 
-/*
- * this percpu struct for fcoe
- */
-struct fcoe_percpu_s {
-	struct task_struct *thread;
-	struct sk_buff_head fcoe_rx_list;
-	struct page *crc_eof_page;
-	int crc_eof_offset;
-};
-
-/*
- * the fcoe sw transport private data
- */
-struct fcoe_softc {
-	struct list_head list;
-	struct fc_lport *lp;
-	struct net_device *real_dev;
-	struct net_device *phys_dev;		/* device with ethtool_ops */
-	struct packet_type  fcoe_packet_type;
-	struct sk_buff_head fcoe_pending_queue;
-	u8	fcoe_pending_queue_active;
-
-	u8 dest_addr[ETH_ALEN];
-	u8 ctl_src_addr[ETH_ALEN];
-	u8 data_src_addr[ETH_ALEN];
-	/*
-	 * fcoe protocol address learning related stuff
-	 */
-	u16 flogi_oxid;
-	u8 flogi_progress;
-	u8 address_mode;
-};
-
-static inline struct net_device *fcoe_netdev(
-	const struct fc_lport *lp)
-{
-	return ((struct fcoe_softc *)lport_priv(lp))->real_dev;
-}
-
-static inline struct fcoe_hdr *skb_fcoe_header(const struct sk_buff *skb)
-{
-	return (struct fcoe_hdr *)skb_network_header(skb);
-}
-
-static inline int skb_fcoe_offset(const struct sk_buff *skb)
-{
-	return skb_network_offset(skb);
-}
-
-static inline struct fc_frame_header *skb_fc_header(const struct sk_buff *skb)
-{
-	return (struct fc_frame_header *)skb_transport_header(skb);
-}
-
-static inline int skb_fc_offset(const struct sk_buff *skb)
-{
-	return skb_transport_offset(skb);
-}
-
-static inline void skb_reset_fc_header(struct sk_buff *skb)
-{
-	skb_reset_network_header(skb);
-	skb_set_transport_header(skb, skb_network_offset(skb) +
-				 sizeof(struct fcoe_hdr));
-}
-
-static inline bool skb_fc_is_data(const struct sk_buff *skb)
-{
-	return skb_fc_header(skb)->fh_r_ctl == FC_RCTL_DD_SOL_DATA;
-}
-
-static inline bool skb_fc_is_cmd(const struct sk_buff *skb)
-{
-	return skb_fc_header(skb)->fh_r_ctl == FC_RCTL_DD_UNSOL_CMD;
-}
-
-static inline bool skb_fc_has_exthdr(const struct sk_buff *skb)
-{
-	return (skb_fc_header(skb)->fh_r_ctl == FC_RCTL_VFTH) ||
-	    (skb_fc_header(skb)->fh_r_ctl == FC_RCTL_IFRH) ||
-	    (skb_fc_header(skb)->fh_r_ctl == FC_RCTL_ENCH);
-}
-
-static inline bool skb_fc_is_roff(const struct sk_buff *skb)
-{
-	return skb_fc_header(skb)->fh_f_ctl[2] & FC_FC_REL_OFF;
-}
-
-static inline u16 skb_fc_oxid(const struct sk_buff *skb)
-{
-	return be16_to_cpu(skb_fc_header(skb)->fh_ox_id);
-}
-
-static inline u16 skb_fc_rxid(const struct sk_buff *skb)
-{
-	return be16_to_cpu(skb_fc_header(skb)->fh_rx_id);
-}
-
 /* libfcoe funcs */
-int fcoe_reset(struct Scsi_Host *shost);
-u64 fcoe_wwn_from_mac(unsigned char mac[MAX_ADDR_LEN],
-		      unsigned int scheme, unsigned int port);
-
-u32 fcoe_fc_crc(struct fc_frame *fp);
-int fcoe_xmit(struct fc_lport *, struct fc_frame *);
-int fcoe_rcv(struct sk_buff *, struct net_device *,
-	     struct packet_type *, struct net_device *);
-
-int fcoe_percpu_receive_thread(void *arg);
-void fcoe_clean_pending_queue(struct fc_lport *lp);
-void fcoe_percpu_clean(struct fc_lport *lp);
-void fcoe_watchdog(ulong vp);
-int fcoe_link_ok(struct fc_lport *lp);
-
-struct fc_lport *fcoe_hostlist_lookup(const struct net_device *);
-int fcoe_hostlist_add(const struct fc_lport *);
-int fcoe_hostlist_remove(const struct fc_lport *);
-
-struct Scsi_Host *fcoe_host_alloc(struct scsi_host_template *, int);
+u64 fcoe_wwn_from_mac(unsigned char mac[], unsigned int, unsigned int);
 int fcoe_libfc_config(struct fc_lport *, struct libfc_function_template *);
+
 #endif /* _LIBFCOE_H */

commit 7f3491429553cbff20367851fb897c449d028393
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Fri Mar 27 09:06:31 2009 -0700

    [SCSI] fcoe: removes default sw transport code file fcoe_sw.c
    
    Moves only required code from fcoe_sw.c to libfcoe.c towards having
    just one source file for fcoe module, this gets rid off default sw
    transport code in a separate fcoe_sw.c file.
    
    Very minor renaming along this move, dropped _sw_ or _SW_ use
    in names and replaced them by _if_ as a auxiliary interface
    functions. Now some of these funcs can be removed or merged with
    other func after fcoe transport is gone, but that should be
    in another patch to keep this patch simple.
    
    Now the libfcoe.c file name for fcoe module doesn't go along well,
    so the libfcoe.c file renaming to fcoe.c as the only single fcoe
    module file is done in next patch to keep this patch clean
    and small for review.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index dc64405b5814..e99633cefd37 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -145,10 +145,4 @@ int fcoe_hostlist_remove(const struct fc_lport *);
 
 struct Scsi_Host *fcoe_host_alloc(struct scsi_host_template *, int);
 int fcoe_libfc_config(struct fc_lport *, struct libfc_function_template *);
-
-/* fcoe sw hba */
-int __init fcoe_sw_init(void);
-int __exit fcoe_sw_exit(void);
-int fcoe_sw_create(struct net_device *);
-int fcoe_sw_destroy(struct net_device *);
 #endif /* _LIBFCOE_H */

commit 5919a59503577c2dc6eaa8bfba0f7bde3f9924ba
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Fri Mar 27 09:03:29 2009 -0700

    [SCSI] fcoe: prep work to completely remove fc_transport_fcoe code
    
    The fcoe transport code was added for generic FCoE transport
    infrastructure to allow additional offload related module loading
    on demand, this is not required anymore after recently added
    different offload approach by having offload related func ops
    in netdev.
    
    This patch removes fcoe transport related code use, calls functions
    directly between existing libfcoe.c and fcoe_sw.c for now, for
    example fcoe_sw_destroy and fcoe_sw_create calling.
    
    The fcoe_sw.c and libfcoe.c code will be further consolidated in
    later patches and then also the default fcoe sw transport code
    file fcoe_sw.c will be completely removed.
    
    The fcoe transport code files are completely removed in next
    patch to keep this patch simple for reviewing.
    
    [This patch is an update to a previous patch. This update
    resolves a build error as well as fixes a defect related to
    not calling fc_release_transport().]
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 1ad4f93d5548..dc64405b5814 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -149,4 +149,6 @@ int fcoe_libfc_config(struct fc_lport *, struct libfc_function_template *);
 /* fcoe sw hba */
 int __init fcoe_sw_init(void);
 int __exit fcoe_sw_exit(void);
+int fcoe_sw_create(struct net_device *);
+int fcoe_sw_destroy(struct net_device *);
 #endif /* _LIBFCOE_H */

commit 5e5e92df49d4dfbef9ba981297c7f76d189376ac
Author: Robert Love <robert.w.love@intel.com>
Date:   Tue Mar 17 11:41:35 2009 -0700

    [SCSI] fcoe: Use percpu kernel funcs for struct fcoe_percpu_s
    
    Convert fcoe_percpu array to use the per-cpu variables
    that the kernel provides. Use the kernel's functions to
    access this structure.
    
    The cpu member of the fcoe_percpu_s is no longer needed,
    so this patch removes it too.
    
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 124dc5bd9f87..1ad4f93d5548 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -29,7 +29,6 @@
  * this percpu struct for fcoe
  */
 struct fcoe_percpu_s {
-	unsigned int cpu;
 	struct task_struct *thread;
 	struct sk_buff_head fcoe_rx_list;
 	struct page *crc_eof_page;

commit 38eccabd1067b93af0fedbf447ab846e7df1ca66
Author: Robert Love <robert.w.love@intel.com>
Date:   Tue Mar 17 11:41:30 2009 -0700

    [SCSI] fcoe: Initialize all possilbe skb_queue(s) when module is loaded
    
    Currently the skb_queue is initialized every time the associated
    CPU goes online. This patch has libfcoe initializing the skb_queue
    for all possible CPUs when the module is loaded.
    
    This patch also re-orders some declarations in the fcoe_rcv()
    function so the structure declarations are grouped before
    the primitive declarations.
    
    Lastly, this patch converts all CPU indicies to use unsigned int
    since CPU indicies should not be negative.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index c41f7d0c6efc..124dc5bd9f87 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -29,7 +29,7 @@
  * this percpu struct for fcoe
  */
 struct fcoe_percpu_s {
-	int		cpu;
+	unsigned int cpu;
 	struct task_struct *thread;
 	struct sk_buff_head fcoe_rx_list;
 	struct page *crc_eof_page;

commit b277d2aa9a4d969002c4157bf77b76b9ad9ca04a
Author: Yi Zou <yi.zou@intel.com>
Date:   Fri Feb 27 14:07:21 2009 -0800

    [SCSI] libfc: add support of large receive offload by ddp in fc_fcp
    
    When LLD supports direct data placement (ddp) for large receive of an scsi
    i/o coming into fc_fcp, we call into libfc_function_template's ddp_setup()
    to prepare for a ddp of large receive for this read I/O. When I/O is complete,
    we call the corresponding ddp_done() to get the length of data ddped as well
    as to let LLD do clean up.
    
    fc_fcp_ddp_setup()/fc_fcp_ddp_done() are added to setup and complete a ddped
    read I/O described by the given fc_fcp_pkt. They would call into corresponding
    ddp_setup/ddp_done implemented by the fcoe layer. Eventually, fcoe layer calls
    into LLD's ddp_setup/ddp_done provided through net_device
    
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 941818f29f59..c41f7d0c6efc 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -124,24 +124,6 @@ static inline u16 skb_fc_rxid(const struct sk_buff *skb)
 	return be16_to_cpu(skb_fc_header(skb)->fh_rx_id);
 }
 
-/* FIXME - DMA_BIDIRECTIONAL ? */
-#define skb_cb(skb)	((struct fcoe_rcv_info *)&((skb)->cb[0]))
-#define skb_cmd(skb)	(skb_cb(skb)->fr_cmd)
-#define skb_dir(skb)	(skb_cmd(skb)->sc_data_direction)
-static inline bool skb_fc_is_read(const struct sk_buff *skb)
-{
-	if (skb_fc_is_cmd(skb) && skb_cmd(skb))
-		return skb_dir(skb) == DMA_FROM_DEVICE;
-	return false;
-}
-
-static inline bool skb_fc_is_write(const struct sk_buff *skb)
-{
-	if (skb_fc_is_cmd(skb) && skb_cmd(skb))
-		return skb_dir(skb) == DMA_TO_DEVICE;
-	return false;
-}
-
 /* libfcoe funcs */
 int fcoe_reset(struct Scsi_Host *shost);
 u64 fcoe_wwn_from_mac(unsigned char mac[MAX_ADDR_LEN],

commit c826a3145736e3baabebccfd0aecfbb6dae059f2
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Fri Feb 27 10:56:27 2009 -0800

    [SCSI] fcoe: Out of order tx frames was causing several check condition SCSI status
    
    frames followed by these errors in log.
    
            [sdp] Result: hostbyte=DID_OK driverbyte=DRIVER_SENSE,SUGGEST_OK
            [sdp] Sense Key : Aborted Command [current]
            [sdp] Add. Sense: Data phase error
    
    This was causing some test apps to exit due to write failure under heavy
    load.
    
    This was due to a race around adding and removing tx frame skb in
    fcoe_pending_queue, Chris Leech helped me to find that brief unlocking
    period when pulling skb from fcoe_pending_queue in various contexts
    (fcoe_watchdog and fcoe_xmit) and then adding skb back into fcoe_pending_queue
    up on a failed fcoe_start_io could change skb/tx frame order in
    fcoe_pending_queue. Thanks Chris.
    
    This patch allows only single context to pull skb from fcoe_pending_queue
    at any time to prevent above described ordering issue/race by use of
    fcoe_pending_queue_active flag.
    
    This patch simplified fcoe_watchdog with modified fcoe_check_wait_queue by
    use of FCOE_LOW_QUEUE_DEPTH instead previously used several conditionals
    to clear and set lp->qfull.
    
    I think FCOE_MAX_QUEUE_DEPTH with FCOE_LOW_QUEUE_DEPTH  will work better
    in re/setting lp->qfull and these could be fine tuned for performance.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index f43d3833a7a8..941818f29f59 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -46,6 +46,7 @@ struct fcoe_softc {
 	struct net_device *phys_dev;		/* device with ethtool_ops */
 	struct packet_type  fcoe_packet_type;
 	struct sk_buff_head fcoe_pending_queue;
+	u8	fcoe_pending_queue_active;
 
 	u8 dest_addr[ETH_ALEN];
 	u8 ctl_src_addr[ETH_ALEN];

commit fc47ff6b1b27fb736f255ed8cd490356e0cd228f
Author: Robert Love <robert.w.love@intel.com>
Date:   Fri Feb 27 10:55:55 2009 -0800

    [SCSI] libfc, fcoe: Remove unnecessary cast by removing inline wrapper
    
    Comment from "Andrew Morton <akpm@linux-foundation.org>"
    
    > +{
    > +     return (struct fcoe_softc *)lport_priv(lp);
    
    unneeded/undesirable cast of void*.  There are probably zillions of
    instances of this - there always are.
    
    This whole inline function was unnecessary. The FCoE layer knows
    that it's data structure is stored in the lport private data, it
    can just access it from lport_priv().
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
index 89fdbb9a6a1b..f43d3833a7a8 100644
--- a/include/scsi/libfcoe.h
+++ b/include/scsi/libfcoe.h
@@ -58,16 +58,10 @@ struct fcoe_softc {
 	u8 address_mode;
 };
 
-static inline struct fcoe_softc *fcoe_softc(
-	const struct fc_lport *lp)
-{
-	return (struct fcoe_softc *)lport_priv(lp);
-}
-
 static inline struct net_device *fcoe_netdev(
 	const struct fc_lport *lp)
 {
-	return fcoe_softc(lp)->real_dev;
+	return ((struct fcoe_softc *)lport_priv(lp))->real_dev;
 }
 
 static inline struct fcoe_hdr *skb_fcoe_header(const struct sk_buff *skb)

commit 85b4aa4926a50210b683ac89326e338e7d131211
Author: Robert Love <robert.w.love@intel.com>
Date:   Tue Dec 9 15:10:24 2008 -0800

    [SCSI] fcoe: Fibre Channel over Ethernet
    
    Encapsulation protocol for running Fibre Channel over Ethernet interfaces.
    Creates virtual Fibre Channel host adapters using libfc.
    
    This layer is the LLD to the scsi-ml. It allocates the Scsi_Host, utilizes
    libfc for Fibre Channel protocol processing and interacts with netdev to
    send/receive Ethernet packets.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfcoe.h b/include/scsi/libfcoe.h
new file mode 100644
index 000000000000..89fdbb9a6a1b
--- /dev/null
+++ b/include/scsi/libfcoe.h
@@ -0,0 +1,176 @@
+/*
+ * Copyright(c) 2007 - 2008 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Maintained at www.Open-FCoE.org
+ */
+
+#ifndef _LIBFCOE_H
+#define _LIBFCOE_H
+
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <scsi/fc/fc_fcoe.h>
+#include <scsi/libfc.h>
+
+/*
+ * this percpu struct for fcoe
+ */
+struct fcoe_percpu_s {
+	int		cpu;
+	struct task_struct *thread;
+	struct sk_buff_head fcoe_rx_list;
+	struct page *crc_eof_page;
+	int crc_eof_offset;
+};
+
+/*
+ * the fcoe sw transport private data
+ */
+struct fcoe_softc {
+	struct list_head list;
+	struct fc_lport *lp;
+	struct net_device *real_dev;
+	struct net_device *phys_dev;		/* device with ethtool_ops */
+	struct packet_type  fcoe_packet_type;
+	struct sk_buff_head fcoe_pending_queue;
+
+	u8 dest_addr[ETH_ALEN];
+	u8 ctl_src_addr[ETH_ALEN];
+	u8 data_src_addr[ETH_ALEN];
+	/*
+	 * fcoe protocol address learning related stuff
+	 */
+	u16 flogi_oxid;
+	u8 flogi_progress;
+	u8 address_mode;
+};
+
+static inline struct fcoe_softc *fcoe_softc(
+	const struct fc_lport *lp)
+{
+	return (struct fcoe_softc *)lport_priv(lp);
+}
+
+static inline struct net_device *fcoe_netdev(
+	const struct fc_lport *lp)
+{
+	return fcoe_softc(lp)->real_dev;
+}
+
+static inline struct fcoe_hdr *skb_fcoe_header(const struct sk_buff *skb)
+{
+	return (struct fcoe_hdr *)skb_network_header(skb);
+}
+
+static inline int skb_fcoe_offset(const struct sk_buff *skb)
+{
+	return skb_network_offset(skb);
+}
+
+static inline struct fc_frame_header *skb_fc_header(const struct sk_buff *skb)
+{
+	return (struct fc_frame_header *)skb_transport_header(skb);
+}
+
+static inline int skb_fc_offset(const struct sk_buff *skb)
+{
+	return skb_transport_offset(skb);
+}
+
+static inline void skb_reset_fc_header(struct sk_buff *skb)
+{
+	skb_reset_network_header(skb);
+	skb_set_transport_header(skb, skb_network_offset(skb) +
+				 sizeof(struct fcoe_hdr));
+}
+
+static inline bool skb_fc_is_data(const struct sk_buff *skb)
+{
+	return skb_fc_header(skb)->fh_r_ctl == FC_RCTL_DD_SOL_DATA;
+}
+
+static inline bool skb_fc_is_cmd(const struct sk_buff *skb)
+{
+	return skb_fc_header(skb)->fh_r_ctl == FC_RCTL_DD_UNSOL_CMD;
+}
+
+static inline bool skb_fc_has_exthdr(const struct sk_buff *skb)
+{
+	return (skb_fc_header(skb)->fh_r_ctl == FC_RCTL_VFTH) ||
+	    (skb_fc_header(skb)->fh_r_ctl == FC_RCTL_IFRH) ||
+	    (skb_fc_header(skb)->fh_r_ctl == FC_RCTL_ENCH);
+}
+
+static inline bool skb_fc_is_roff(const struct sk_buff *skb)
+{
+	return skb_fc_header(skb)->fh_f_ctl[2] & FC_FC_REL_OFF;
+}
+
+static inline u16 skb_fc_oxid(const struct sk_buff *skb)
+{
+	return be16_to_cpu(skb_fc_header(skb)->fh_ox_id);
+}
+
+static inline u16 skb_fc_rxid(const struct sk_buff *skb)
+{
+	return be16_to_cpu(skb_fc_header(skb)->fh_rx_id);
+}
+
+/* FIXME - DMA_BIDIRECTIONAL ? */
+#define skb_cb(skb)	((struct fcoe_rcv_info *)&((skb)->cb[0]))
+#define skb_cmd(skb)	(skb_cb(skb)->fr_cmd)
+#define skb_dir(skb)	(skb_cmd(skb)->sc_data_direction)
+static inline bool skb_fc_is_read(const struct sk_buff *skb)
+{
+	if (skb_fc_is_cmd(skb) && skb_cmd(skb))
+		return skb_dir(skb) == DMA_FROM_DEVICE;
+	return false;
+}
+
+static inline bool skb_fc_is_write(const struct sk_buff *skb)
+{
+	if (skb_fc_is_cmd(skb) && skb_cmd(skb))
+		return skb_dir(skb) == DMA_TO_DEVICE;
+	return false;
+}
+
+/* libfcoe funcs */
+int fcoe_reset(struct Scsi_Host *shost);
+u64 fcoe_wwn_from_mac(unsigned char mac[MAX_ADDR_LEN],
+		      unsigned int scheme, unsigned int port);
+
+u32 fcoe_fc_crc(struct fc_frame *fp);
+int fcoe_xmit(struct fc_lport *, struct fc_frame *);
+int fcoe_rcv(struct sk_buff *, struct net_device *,
+	     struct packet_type *, struct net_device *);
+
+int fcoe_percpu_receive_thread(void *arg);
+void fcoe_clean_pending_queue(struct fc_lport *lp);
+void fcoe_percpu_clean(struct fc_lport *lp);
+void fcoe_watchdog(ulong vp);
+int fcoe_link_ok(struct fc_lport *lp);
+
+struct fc_lport *fcoe_hostlist_lookup(const struct net_device *);
+int fcoe_hostlist_add(const struct fc_lport *);
+int fcoe_hostlist_remove(const struct fc_lport *);
+
+struct Scsi_Host *fcoe_host_alloc(struct scsi_host_template *, int);
+int fcoe_libfc_config(struct fc_lport *, struct libfc_function_template *);
+
+/* fcoe sw hba */
+int __init fcoe_sw_init(void);
+int __exit fcoe_sw_exit(void);
+#endif /* _LIBFCOE_H */
