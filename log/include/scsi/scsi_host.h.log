commit cc97923a5bccc776851c242b61015faf288d5c22
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Apr 14 09:42:24 2020 +0200

    block: move dma drain handling to scsi
    
    Don't burden the common block code with with specifics of the libata DMA
    draining mechanism.  Instead move most of the code to the scsi midlayer.
    
    That also means the nr_phys_segments adjustments in the blk-mq fast path
    can go away entirely, given that SCSI never looks at nr_phys_segments
    after mapping the request to a scatterlist.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 822e8cda8d9b..46ef8cccc982 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -270,6 +270,13 @@ struct scsi_host_template {
 	 */
 	int (* map_queues)(struct Scsi_Host *shost);
 
+	/*
+	 * Check if scatterlists need to be padded for DMA draining.
+	 *
+	 * Status: OPTIONAL
+	 */
+	bool (* dma_need_drain)(struct request *rq);
+
 	/*
 	 * This function determines the BIOS parameters for a given
 	 * harddisk.  These tend to be numbers that are made up by

commit 5febf6d6ae4d488a5dc388c46d96c17f9556238f
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Feb 24 10:14:06 2020 -0600

    scsi: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language extension
    to the C90 standard, but the preferred mechanism to declare variable-length
    types such as these ones is a flexible array member[1][2], introduced in
    C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning in
    case the flexible array does not occur last in the structure, which will
    help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by this
    change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Link: https://lore.kernel.org/r/20200224161406.GA21454@embeddedor
    Reviewed-by: Lee Duncan <lduncan@suse.com>
    Reviewed-by: Satish Kharat <satishkh@cisco.com>
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 7464394e7d01..822e8cda8d9b 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -683,7 +683,7 @@ struct Scsi_Host {
 	 * and also because some compilers (m68k) don't automatically force
 	 * alignment to a long boundary.
 	 */
-	unsigned long hostdata[0]  /* Used for storage of host specific stuff */
+	unsigned long hostdata[]  /* Used for storage of host specific stuff */
 		__attribute__ ((aligned (sizeof(unsigned long))));
 };
 

commit 65ca846a53149a1a72cd8d02e7b2e73dd545b834
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Wed Jan 22 19:56:34 2020 -0800

    scsi: core: Introduce {init,exit}_cmd_priv()
    
    The current behavior of the SCSI core is to clear driver-private data
    before preparing a request for submission to the SCSI LLD. Make it possible
    for SCSI LLDs to disable clearing of driver-private data.
    
    These hooks will be used by a later patch, namely "scsi: ufs: Let the SCSI
    core allocate per-command UFS data".
    
    Link: https://lore.kernel.org/r/20200123035637.21848-2-bvanassche@acm.org
    Cc: Tomas Winkler <tomas.winkler@intel.com>
    Cc: Stanley Chu <stanley.chu@mediatek.com>
    Cc: Bean Huo <beanhuo@micron.com>
    Cc: Avri Altman <avri.altman@wdc.com>
    Cc: Can Guo <cang@codeaurora.org>
    Cc: Ming Lei <ming.lei@redhat.com>
    Cc: Johannes Thumshirn <jth@kernel.org>
    Cc: Hannes Reinecke <hare@suse.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 74dc7d4f2a96..7464394e7d01 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -62,6 +62,9 @@ struct scsi_host_template {
 			    void __user *arg);
 #endif
 
+	int (*init_cmd_priv)(struct Scsi_Host *shost, struct scsi_cmnd *cmd);
+	int (*exit_cmd_priv)(struct Scsi_Host *shost, struct scsi_cmnd *cmd);
+
 	/*
 	 * The queuecommand function is used to queue up a scsi
 	 * command block to the LLDD.  When the driver finished

commit c5a9707672fe22865d90fc04ac2fbc4f812666f3
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Feb 28 08:53:18 2020 +0100

    scsi: core: Remove cmd_list functionality
    
    Remove cmd_list functionality; no users left.  With that the
    scsi_put_command() becomes empty, so remove that one, too.
    
    Link: https://lore.kernel.org/r/20200228075318.91255-14-hare@suse.de
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart van Assche <bvanassche@acm.org>
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index eff12445b823..74dc7d4f2a96 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -624,8 +624,6 @@ struct Scsi_Host {
 	/* The controller does not support WRITE SAME */
 	unsigned no_write_same:1;
 
-	unsigned use_cmd_list:1;
-
 	/* Host responded with short (<36 bytes) INQUIRY result */
 	unsigned short_inquiry:1;
 

commit dcece99e86b1191d2789fb5b5caa4c5b7fc2bfef
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Feb 28 08:53:15 2020 +0100

    scsi: core: add scsi_host_busy_iter()
    
    Add an iterator scsi_host_busy_iter() to traverse all busy commands.  If
    locking against concurrent command completions is required, it has to be
    provided by the caller.
    
    Link: https://lore.kernel.org/r/20200228075318.91255-11-hare@suse.de
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 613c3820028e..eff12445b823 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -761,6 +761,9 @@ extern void scsi_block_requests(struct Scsi_Host *);
 extern int scsi_host_block(struct Scsi_Host *shost);
 extern int scsi_host_unblock(struct Scsi_Host *shost, int new_state);
 
+void scsi_host_busy_iter(struct Scsi_Host *,
+			 bool (*fn)(struct scsi_cmnd *, void *, bool), void *priv);
+
 struct class_container;
 
 /*

commit 2bb955840c1dc44746af8a7873d9a0ba70debbd6
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Feb 28 08:53:13 2020 +0100

    scsi: core: add scsi_host_(block,unblock) helper function
    
    Add helper functions to call scsi_internal_device_block()/
    scsi_internal_device_unblock() for all attached devices on a SCSI host.
    
    Link: https://lore.kernel.org/r/20200228075318.91255-9-hare@suse.de
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 25bef781cbe1..613c3820028e 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -758,6 +758,8 @@ static inline int scsi_host_scan_allowed(struct Scsi_Host *shost)
 
 extern void scsi_unblock_requests(struct Scsi_Host *);
 extern void scsi_block_requests(struct Scsi_Host *);
+extern int scsi_host_block(struct Scsi_Host *shost);
+extern int scsi_host_unblock(struct Scsi_Host *shost, int new_state);
 
 struct class_container;
 

commit 466552b9f3730f06fee75776a208f5fa9c06c6a3
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Feb 28 08:53:07 2020 +0100

    scsi: core: add scsi_host_complete_all_commands() helper
    
    Add a helper scsi_host_complete_all_commands() to terminate all outstanding
    commands on a SCSI host.
    
    Link: https://lore.kernel.org/r/20200228075318.91255-3-hare@suse.de
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 7a97fb8104cf..25bef781cbe1 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -732,6 +732,8 @@ extern int scsi_host_busy(struct Scsi_Host *shost);
 extern void scsi_host_put(struct Scsi_Host *t);
 extern struct Scsi_Host *scsi_host_lookup(unsigned short);
 extern const char *scsi_host_state_name(enum scsi_host_state);
+extern void scsi_host_complete_all_commands(struct Scsi_Host *shost,
+					    int status);
 
 static inline int __must_check scsi_add_host(struct Scsi_Host *host,
 					     struct device *dev)

commit 3d8b24a0f438d812d14849bd42516f54e80b57e8
Author: Ming Lei <ming.lei@redhat.com>
Date:   Sun Jan 19 15:14:28 2020 +0800

    scsi: core: remove .for_blk_mq
    
    Not in use anymore. Remove the flag.
    
    Cc: Sathya Prakash <sathya.prakash@broadcom.com>
    Cc: Chaitra P B <chaitra.basappa@broadcom.com>
    Cc: Suganath Prabu Subramani <suganath-prabu.subramani@broadcom.com>
    Cc: Kashyap Desai <kashyap.desai@broadcom.com>
    Cc: Sumit Saxena <sumit.saxena@broadcom.com>
    Cc: Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
    Cc: Ewan D. Milne <emilne@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Bart Van Assche <bart.vanassche@wdc.com>
    Link: https://lore.kernel.org/r/20200119071432.18558-3-ming.lei@redhat.com
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index f577647bf5f2..7a97fb8104cf 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -426,9 +426,6 @@ struct scsi_host_template {
 	/* True if the controller does not support WRITE SAME */
 	unsigned no_write_same:1;
 
-	/* True if the low-level driver supports blk-mq only */
-	unsigned force_blk_mq:1;
-
 	/*
 	 * Countdown for host blocking with no commands outstanding.
 	 */

commit 35c3363363ac7c8877b4984cdd8a2af377a4e92e
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Nov 2 12:06:54 2019 +1100

    scsi: core: Clean up SG_NONE
    
    Remove SG_NONE and a related misleading comment. Update documentation.
    
    This patch does not affect behaviour as zero initialization is redundant.
    
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Viresh Kumar <vireshk@kernel.org>
    Cc: Oliver Neukum <oneukum@suse.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: usb-storage@lists.one-eyed-alien.net
    Link: https://lore.kernel.org/r/b4779b7a6563f6bd8d259ee457871c1c463c420e.1572656814.git.fthain@telegraphics.com.au
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index fccdf84ec7e2..f577647bf5f2 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -23,19 +23,6 @@ struct scsi_host_cmd_pool;
 struct scsi_transport_template;
 
 
-/*
- * The various choices mean:
- * NONE: Self evident.	Host adapter is not capable of scatter-gather.
- * ALL:	 Means that the host adapter module can do scatter-gather,
- *	 and that there is no limit to the size of the table to which
- *	 we scatter/gather data.  The value we set here is the maximum
- *	 single element sglist.  To use chained sglists, the adapter
- *	 has to set a value beyond ALL (and correctly use the chain
- *	 handling API.
- * Anything else:  Indicates the maximum number of chains that can be
- *	 used in one scatter-gather request.
- */
-#define SG_NONE 0
 #define SG_ALL	SG_CHUNK_SIZE
 
 #define MODE_UNKNOWN 0x00

commit 6eb045e092efefafc6687409a6fa6d1dabf0fb69
Author: Ming Lei <ming.lei@redhat.com>
Date:   Fri Oct 25 14:58:55 2019 +0800

    scsi: core: avoid host-wide host_busy counter for scsi_mq
    
    It isn't necessary to check the host depth in scsi_queue_rq() any more
    since it has been respected by blk-mq before calling scsi_queue_rq() via
    getting driver tag.
    
    Lots of LUNs may attach to same host and per-host IOPS may reach millions,
    so we should avoid expensive atomic operations on the host-wide counter in
    the IO path.
    
    This patch implements scsi_host_busy() via blk_mq_tagset_busy_iter() with
    one scsi command state for reading the count of busy IOs for scsi_mq.
    
    It is observed that IOPS is increased by 15% in IO test on scsi_debug (32
    LUNs, 32 submit queues, 1024 can_queue, libaio/dio) in a dual-socket
    system.
    
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Ewan D. Milne <emilne@redhat.com>
    Cc: Omar Sandoval <osandov@fb.com>,
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>,
    Cc: James Bottomley <james.bottomley@hansenpartnership.com>,
    Cc: Christoph Hellwig <hch@lst.de>,
    Cc: Kashyap Desai <kashyap.desai@broadcom.com>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Laurence Oberman <loberman@redhat.com>
    Cc: Bart Van Assche <bvanassche@acm.org>
    Link: https://lore.kernel.org/r/20191025065855.6309-1-ming.lei@redhat.com
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Jens Axboe <axboe@kernel.dk>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 2c3f0c58869b..fccdf84ec7e2 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -345,7 +345,7 @@ struct scsi_host_template {
 	/*
 	 * This determines if we will use a non-interrupt driven
 	 * or an interrupt driven scheme.  It is set to the maximum number
-	 * of simultaneous commands a given host adapter will accept.
+	 * of simultaneous commands a single hw queue in HBA will accept.
 	 */
 	int can_queue;
 
@@ -554,7 +554,6 @@ struct Scsi_Host {
 	/* Area to keep a shared tag map */
 	struct blk_mq_tag_set	tag_set;
 
-	atomic_t host_busy;		   /* commands actually active on low-level */
 	atomic_t host_blocked;
 
 	unsigned int host_failed;	   /* commands that failed.

commit c74f8056621738f5be9f5d3d7e0caa927b21aef6
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Mon Sep 16 23:56:49 2019 +0800

    scsi: core: allow auto suspend override by low-level driver
    
    Rework from previous work by:
    Sujit Reddy Thumma <sthumma@codeaurora.org>
    
    Until now the scsi mid-layer forbids runtime suspend till userspace enables
    it. This is mainly to quarantine some disks with broken runtime power
    management or have high latencies executing suspend resume callbacks. If
    the userspace doesn't enable the runtime suspend the underlying hardware
    will be always on even when it is not doing any useful work and thus
    wasting power.
    
    Some low-level drivers for the controllers can efficiently use runtime
    power management to reduce power consumption and improve battery life.
    Allow runtime suspend parameters override within the LLD itself instead of
    waiting for userspace to control the power management.
    
    Link: https://lore.kernel.org/r/1568649411-5127-2-git-send-email-stanley.chu@mediatek.com
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 31e0d6ca1eba..2c3f0c58869b 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -486,6 +486,9 @@ struct scsi_host_template {
 	 */
 	unsigned int cmd_size;
 	struct scsi_host_cmd_pool *cmd_pool;
+
+	/* Delay for runtime autosuspend */
+	int rpm_autosuspend_delay;
 };
 
 /*

commit 8930a6c207918d5a5675eedab06a71096b1a3d47
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Thu May 30 13:28:10 2019 +0200

    scsi: core: add support for request batching
    
    This allows a list of requests to be issued, with the LLD only writing the
    hardware doorbell when necessary, after the last request was prepared.
    This is more efficient if we have lists of requests to issue, particularly
    on virtualized hardware, where writing the doorbell is more expensive than
    on real hardware.
    
    The use case for this is plugged IO, where blk-mq flushes a batch of
    requests all at once.
    
    The API is the same as for blk-mq, just with blk-mq concepts tweaked to
    fit the SCSI subsystem API: the "last" flag in blk_mq_queue_data becomes a
    flag in scsi_cmnd, while the queue_num in the commit_rqs callback is
    extracted from the hctx and passed as a parameter.
    
    The only complication is that blk-mq uses different plugging heuristics
    depending on whether commit_rqs is present or not.  So we have two
    different sets of blk_mq_ops and pick one depending on whether the
    scsi_host template uses commit_rqs or not.
    
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index cc139dbd71e5..31e0d6ca1eba 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -80,8 +80,10 @@ struct scsi_host_template {
 	 * command block to the LLDD.  When the driver finished
 	 * processing the command the done callback is invoked.
 	 *
-	 * If queuecommand returns 0, then the HBA has accepted the
-	 * command.  The done() function must be called on the command
+	 * If queuecommand returns 0, then the driver has accepted the
+	 * command.  It must also push it to the HBA if the scsi_cmnd
+	 * flag SCMD_LAST is set, or if the driver does not implement
+	 * commit_rqs.  The done() function must be called on the command
 	 * when the driver has finished with it. (you may call done on the
 	 * command before queuecommand returns, but in this case you
 	 * *must* return 0 from queuecommand).
@@ -109,6 +111,16 @@ struct scsi_host_template {
 	 */
 	int (* queuecommand)(struct Scsi_Host *, struct scsi_cmnd *);
 
+	/*
+	 * The commit_rqs function is used to trigger a hardware
+	 * doorbell after some requests have been queued with
+	 * queuecommand, when an error is encountered before sending
+	 * the request with SCMD_LAST set.
+	 *
+	 * STATUS: OPTIONAL
+	 */
+	void (*commit_rqs)(struct Scsi_Host *, u16);
+
 	/*
 	 * This is an error handling strategy routine.  You don't need to
 	 * define one of these if you don't want to - there is a default

commit 7ad388d8e4c703980b7018b938cdeec58832d78d
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jun 17 14:19:53 2019 +0200

    scsi: core: add a host / host template field for the virt boundary
    
    This allows drivers setting it up easily instead of branching out to block
    layer calls in slave_alloc, and ensures the upgraded max_segment_size
    setting gets picked up by the DMA layer.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Kashyap Desai < kashyap.desai@broadcom.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index a5fcdad4a03e..cc139dbd71e5 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -369,6 +369,8 @@ struct scsi_host_template {
 	 */
 	unsigned long dma_boundary;
 
+	unsigned long virt_boundary_mask;
+
 	/*
 	 * This specifies "machine infinity" for host templates which don't
 	 * limit the transfer size.  Note this limit represents an absolute
@@ -587,6 +589,7 @@ struct Scsi_Host {
 	unsigned int max_sectors;
 	unsigned int max_segment_size;
 	unsigned long dma_boundary;
+	unsigned long virt_boundary_mask;
 	/*
 	 * In scsi-mq mode, the number of hardware queues supported by the LLD.
 	 *

commit 93ab8c8fc81e78b700b2b375ebc4847f0c1f8aed
Author: Hannes Reinecke <hare@suse.com>
Date:   Tue Feb 26 16:00:39 2019 +0100

    scsi: core: reshuffle no_scsi2_lun_in_cdb for better alignment
    
    no_scsi2_lun_in_cdb declares a new bitfield, but we should rather move
    it to the existing bitfield for better alignment.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 2b539a1b3f62..a5fcdad4a03e 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -628,6 +628,9 @@ struct Scsi_Host {
 	/* Host responded with short (<36 bytes) INQUIRY result */
 	unsigned short_inquiry:1;
 
+	/* The transport requires the LUN bits NOT to be stored in CDB[1] */
+	unsigned no_scsi2_lun_in_cdb:1;
+
 	/*
 	 * Optional work queue to be utilized by the transport
 	 */
@@ -639,9 +642,6 @@ struct Scsi_Host {
 	 */
 	struct workqueue_struct *tmf_work_q;
 
-	/* The transport requires the LUN bits NOT to be stored in CDB[1] */
-	unsigned no_scsi2_lun_in_cdb:1;
-
 	/*
 	 * Value host_blocked counts down from
 	 */

commit b9cef50921eb018917e3c60b0c7f4ae1e113ad03
Author: Hannes Reinecke <hare@suse.com>
Date:   Tue Feb 26 15:56:42 2019 +0100

    scsi: kill command serial number
    
    No users left, kill it.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index dbbdfbdb1a04..2b539a1b3f62 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -486,7 +486,6 @@ struct scsi_host_template {
 		unsigned long irq_flags;				\
 		int rc;							\
 		spin_lock_irqsave(shost->host_lock, irq_flags);		\
-		scsi_cmd_get_serial(shost, cmd);			\
 		rc = func_name##_lck (cmd, cmd->scsi_done);			\
 		spin_unlock_irqrestore(shost->host_lock, irq_flags);	\
 		return rc;						\
@@ -596,12 +595,6 @@ struct Scsi_Host {
 	 * is nr_hw_queues * can_queue.
 	 */
 	unsigned nr_hw_queues;
-	/* 
-	 * Used to assign serial numbers to the cmds.
-	 * Protected by the host lock.
-	 */
-	unsigned long cmd_serial_number;
-	
 	unsigned active_mode:2;
 	unsigned unchecked_isa_dma:1;
 
@@ -738,7 +731,6 @@ extern int scsi_host_busy(struct Scsi_Host *shost);
 extern void scsi_host_put(struct Scsi_Host *t);
 extern struct Scsi_Host *scsi_host_lookup(unsigned short);
 extern const char *scsi_host_state_name(enum scsi_host_state);
-extern void scsi_cmd_get_serial(struct Scsi_Host *, struct scsi_cmnd *);
 
 static inline int __must_check scsi_add_host(struct Scsi_Host *host,
 					     struct device *dev)

commit 82c10ac79b79481f3246cb6d011da7a15776e762
Author: Avri Altman <avri.altman@wdc.com>
Date:   Sun Feb 17 08:30:27 2019 +0200

    scsi: clean obsolete return values of eh_timed_out
    
    Those are no longer in use since commit 242f9dcb8ba6
    ("block: unify request timeout handling").
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 4047d68d1b08..dbbdfbdb1a04 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -300,11 +300,7 @@ struct scsi_host_template {
 	/*
 	 * This is an optional routine that allows the transport to become
 	 * involved when a scsi io timer fires. The return value tells the
-	 * timer routine how to finish the io timeout handling:
-	 * EH_HANDLED:		I fixed the error, please complete the command
-	 * EH_RESET_TIMER:	I need more time, reset the timer and
-	 *			begin counting again
-	 * EH_DONE:		Begin normal error recovery
+	 * timer routine how to finish the io timeout handling.
 	 *
 	 * Status: OPTIONAL
 	 */

commit 6f4e626fb0cc93d50b49b79c2ee33bd769ee57f0
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Thu Feb 7 09:07:20 2019 -0700

    scsi: ata: Use unsigned int for cmd's type in ioctls in scsi_host_template
    
    Clang warns several times in the scsi subsystem (trimmed for brevity):
    
    drivers/scsi/hpsa.c:6209:7: warning: overflow converting case value to
    switch condition type (2147762695 to 18446744071562347015) [-Wswitch]
            case CCISS_GETBUSTYPES:
                 ^
    drivers/scsi/hpsa.c:6208:7: warning: overflow converting case value to
    switch condition type (2147762694 to 18446744071562347014) [-Wswitch]
            case CCISS_GETHEARTBEAT:
                 ^
    
    The root cause is that the _IOC macro can generate really large numbers,
    which don't fit into type 'int', which is used for the cmd parameter in
    the ioctls in scsi_host_template. My research into how GCC and Clang are
    handling this at a low level didn't prove fruitful. However, looking at
    the rest of the kernel tree, all ioctls use an 'unsigned int' for the
    cmd parameter, which will fit all of the _IOC values in the scsi/ata
    subsystems.
    
    Make that change because none of the ioctls expect a negative value for
    any command, it brings the ioctls inline with the reset of the kernel,
    and it removes ambiguity, which is never good when dealing with compilers.
    
    Link: https://github.com/ClangBuiltLinux/linux/issues/85
    Link: https://github.com/ClangBuiltLinux/linux/issues/154
    Link: https://github.com/ClangBuiltLinux/linux/issues/157
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Acked-by: Bradley Grove <bgrove@attotech.com>
    Acked-by: Don Brace <don.brace@microsemi.com>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Tested-by: Nick Desaulniers <ndesaulniers@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 6ca954e9f752..4047d68d1b08 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -60,7 +60,8 @@ struct scsi_host_template {
 	 *
 	 * Status: OPTIONAL
 	 */
-	int (* ioctl)(struct scsi_device *dev, int cmd, void __user *arg);
+	int (*ioctl)(struct scsi_device *dev, unsigned int cmd,
+		     void __user *arg);
 
 
 #ifdef CONFIG_COMPAT
@@ -70,7 +71,8 @@ struct scsi_host_template {
 	 *
 	 * Status: OPTIONAL
 	 */
-	int (* compat_ioctl)(struct scsi_device *dev, int cmd, void __user *arg);
+	int (*compat_ioctl)(struct scsi_device *dev, unsigned int cmd,
+			    void __user *arg);
 #endif
 
 	/*

commit 938edb8a31b976c9a92eb0cd4ff481e93f76c1f1
Merge: af7ddd8a627c da7903092b88
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 28 14:48:06 2018 -0800

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This is mostly update of the usual drivers: smarpqi, lpfc, qedi,
      megaraid_sas, libsas, zfcp, mpt3sas, hisi_sas.
    
      Additionally, we have a pile of annotation, unused variable and minor
      updates.
    
      The big API change is the updates for Christoph's DMA rework which
      include removing the DISABLE_CLUSTERING flag.
    
      And finally there are a couple of target tree updates"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (259 commits)
      scsi: isci: request: mark expected switch fall-through
      scsi: isci: remote_node_context: mark expected switch fall-throughs
      scsi: isci: remote_device: Mark expected switch fall-throughs
      scsi: isci: phy: Mark expected switch fall-through
      scsi: iscsi: Capture iscsi debug messages using tracepoints
      scsi: myrb: Mark expected switch fall-throughs
      scsi: megaraid: fix out-of-bound array accesses
      scsi: mpt3sas: mpt3sas_scsih: Mark expected switch fall-through
      scsi: fcoe: remove set but not used variable 'port'
      scsi: smartpqi: call pqi_free_interrupts() in pqi_shutdown()
      scsi: smartpqi: fix build warnings
      scsi: smartpqi: update driver version
      scsi: smartpqi: add ofa support
      scsi: smartpqi: increase fw status register read timeout
      scsi: smartpqi: bump driver version
      scsi: smartpqi: add smp_utils support
      scsi: smartpqi: correct lun reset issues
      scsi: smartpqi: correct volume status
      scsi: smartpqi: do not offline disks for transient did no connect conditions
      scsi: smartpqi: allow for larger raid maps
      ...

commit 4af14d113bcf95c12d1462ba623b7e7117bd3fb3
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:09 2018 +0100

    scsi: remove the use_clustering flag
    
    The same effects can be achieved by setting the dma_boundary to
    PAGE_SIZE - 1 and the max_segment_size to PAGE_SIZE, so shift those
    settings into the drivers.  Note that in many cases the setting might
    be bogus, but this keeps the status quo.
    
    [mkp: fix myrs and myrb]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 834204681ca3..7ba34a0ca8bf 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -44,8 +44,6 @@ struct blk_queue_tags;
 #define MODE_INITIATOR 0x01
 #define MODE_TARGET 0x02
 
-#define DISABLE_CLUSTERING (-1)
-
 struct scsi_host_template {
 	struct module *module;
 	const char *name;
@@ -418,16 +416,6 @@ struct scsi_host_template {
 	 */
 	unsigned unchecked_isa_dma:1;
 
-	/*
-	 * True if this host adapter can make good use of clustering.
-	 * I originally thought that if the tablesize was large that it
-	 * was a waste of CPU cycles to prepare a cluster list, but
-	 * it works out that the Buslogic is faster if you use a smaller
-	 * number of segments (i.e. use clustering).  I guess it is
-	 * inefficient.
-	 */
-	unsigned use_clustering:1;
-
 	/*
 	 * True for emulated SCSI host adapters (e.g. ATAPI).
 	 */
@@ -626,7 +614,6 @@ struct Scsi_Host {
 	
 	unsigned active_mode:2;
 	unsigned unchecked_isa_dma:1;
-	unsigned use_clustering:1;
 
 	/*
 	 * Host has requested that no further requests come through for the

commit 50c2e9107f176a82e14567b39c5d0f2a208cc82c
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:03 2018 +0100

    scsi: introduce a max_segment_size host_template parameters
    
    This allows the host driver to indicate the maximum supported
    segment size in a nice an easy way, so that the driver doesn't
    have to worry about DMA-layer imposed limitations.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 7dc534c794dc..834204681ca3 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -364,6 +364,11 @@ struct scsi_host_template {
 	 */
 	unsigned int max_sectors;
 
+	/*
+	 * Maximum size in bytes of a single segment.
+	 */
+	unsigned int max_segment_size;
+
 	/*
 	 * DMA scatter gather segment boundary limit. A segment crossing this
 	 * boundary will be split in two.
@@ -603,6 +608,7 @@ struct Scsi_Host {
 	short unsigned int sg_tablesize;
 	short unsigned int sg_prot_tablesize;
 	unsigned int max_sectors;
+	unsigned int max_segment_size;
 	unsigned long dma_boundary;
 	/*
 	 * In scsi-mq mode, the number of hardware queues supported by the LLD.

commit 2a3d4eb8e228061c09d5ca8bf39e7f00c2091213
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:02 2018 +0100

    scsi: flip the default on use_clustering
    
    Most SCSI drivers want to enable "clustering", that is merging of
    segments so that they might span more than a single page.  Remove the
    ENABLE_CLUSTERING define, and require drivers to explicitly set
    DISABLE_CLUSTERING to disable this feature.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 5ea06d310a25..7dc534c794dc 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -44,8 +44,7 @@ struct blk_queue_tags;
 #define MODE_INITIATOR 0x01
 #define MODE_TARGET 0x02
 
-#define DISABLE_CLUSTERING 0
-#define ENABLE_CLUSTERING 1
+#define DISABLE_CLUSTERING (-1)
 
 struct scsi_host_template {
 	struct module *module;

commit f664a3cc17b7d0a2bc3b3ab96181e1029b0ec0e6
Author: Jens Axboe <axboe@kernel.dk>
Date:   Thu Nov 1 16:36:27 2018 -0600

    scsi: kill off the legacy IO path
    
    This removes the legacy (non-mq) IO path for SCSI.
    
    Cc: linux-scsi@vger.kernel.org
    Acked-by: Himanshu Madhani <himanshu.madhani@cavium.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Omar Sandoval <osandov@fb.com>
    Acked-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 5ea06d310a25..aa760df8c6b3 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -11,7 +11,6 @@
 #include <linux/blk-mq.h>
 #include <scsi/scsi.h>
 
-struct request_queue;
 struct block_device;
 struct completion;
 struct module;
@@ -22,7 +21,6 @@ struct scsi_target;
 struct Scsi_Host;
 struct scsi_host_cmd_pool;
 struct scsi_transport_template;
-struct blk_queue_tags;
 
 
 /*
@@ -547,14 +545,8 @@ struct Scsi_Host {
 	struct scsi_host_template *hostt;
 	struct scsi_transport_template *transportt;
 
-	/*
-	 * Area to keep a shared tag map (if needed, will be
-	 * NULL if not).
-	 */
-	union {
-		struct blk_queue_tag	*bqt;
-		struct blk_mq_tag_set	tag_set;
-	};
+	/* Area to keep a shared tag map */
+	struct blk_mq_tag_set	tag_set;
 
 	atomic_t host_busy;		   /* commands actually active on low-level */
 	atomic_t host_blocked;
@@ -648,7 +640,6 @@ struct Scsi_Host {
 	/* The controller does not support WRITE SAME */
 	unsigned no_write_same:1;
 
-	unsigned use_blk_mq:1;
 	unsigned use_cmd_list:1;
 
 	/* Host responded with short (<36 bytes) INQUIRY result */
@@ -742,11 +733,6 @@ static inline int scsi_host_in_recovery(struct Scsi_Host *shost)
 		shost->tmf_in_progress;
 }
 
-static inline bool shost_use_blk_mq(struct Scsi_Host *shost)
-{
-	return shost->use_blk_mq;
-}
-
 extern int scsi_queue_work(struct Scsi_Host *, struct work_struct *);
 extern void scsi_flush_work(struct Scsi_Host *);
 

commit c84b023a4c1461498abf0eda54f60e2fd64a1ca2
Author: Ming Lei <ming.lei@redhat.com>
Date:   Sun Jun 24 22:03:26 2018 +0800

    scsi: read host_busy via scsi_host_busy()
    
    No functional change.
    
    Just introduce scsi_host_busy() and replace the direct read of
    scsi_host->host_busy with this new API.
    
    Cc: Omar Sandoval <osandov@fb.com>,
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>,
    Cc: James Bottomley <james.bottomley@hansenpartnership.com>,
    Cc: Christoph Hellwig <hch@lst.de>,
    Cc: Don Brace <don.brace@microsemi.com>
    Cc: Kashyap Desai <kashyap.desai@broadcom.com>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Laurence Oberman <loberman@redhat.com>
    Cc: Bart Van Assche <bart.vanassche@wdc.com>
    
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 53b485fe9b67..5ea06d310a25 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -758,6 +758,7 @@ extern void scsi_scan_host(struct Scsi_Host *);
 extern void scsi_rescan_device(struct device *);
 extern void scsi_remove_host(struct Scsi_Host *);
 extern struct Scsi_Host *scsi_host_get(struct Scsi_Host *);
+extern int scsi_host_busy(struct Scsi_Host *shost);
 extern void scsi_host_put(struct Scsi_Host *t);
 extern struct Scsi_Host *scsi_host_lookup(unsigned short);
 extern const char *scsi_host_state_name(enum scsi_host_state);

commit 6600593cbd9340b3d4fcde8e58d17653732620c4
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 29 15:52:29 2018 +0200

    block: rename BLK_EH_NOT_HANDLED to BLK_EH_DONE
    
    The BLK_EH_NOT_HANDLED implies nothing happen, but very often that
    is not what is happening - instead the driver already completed the
    command.  Fix the symbolic name to reflect that a little better.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 12f454cb6f61..53b485fe9b67 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -307,7 +307,7 @@ struct scsi_host_template {
 	 * EH_HANDLED:		I fixed the error, please complete the command
 	 * EH_RESET_TIMER:	I need more time, reset the timer and
 	 *			begin counting again
-	 * EH_NOT_HANDLED	Begin normal error recovery
+	 * EH_DONE:		Begin normal error recovery
 	 *
 	 * Status: OPTIONAL
 	 */

commit 2e1f44f6ad8008be353c7c99286f7a747b4b3cf4
Merge: ad448378825f 3f6c9be27ae1
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Mar 27 12:27:34 2018 -0400

    Merge branch 'fixes' into misc
    
    Somewhat nasty merge due to conflicts between "33b28357dd00 scsi:
    qla2xxx: Fix Async GPN_FT for FCP and FC-NVMe scan" and "2b5b96473efc
    scsi: qla2xxx: Fix FC-NVMe LUN discovery"
    
    Merge is non-trivial and has been verified by Qlogic (Cavium)
    
    Signed-off-by: James E.J. Bottomley <jejb@linux.vnet.ibm.com>

commit 83c9f08e6c6a6dc668384882de4dcf5ef4ae0ba7
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Mar 19 08:37:53 2018 +0100

    scsi: remove the old scsi_module.c initialization model
    
    After more than 15 years all users of this legacy interface are finally
    gone.  Rest in peace!
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 19317585ae48..4e418fb539f8 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -51,21 +51,6 @@ struct scsi_host_template {
 	struct module *module;
 	const char *name;
 
-	/*
-	 * Used to initialize old-style drivers.  For new-style drivers
-	 * just perform all work in your module initialization function.
-	 *
-	 * Status:  OBSOLETE
-	 */
-	int (* detect)(struct scsi_host_template *);
-
-	/*
-	 * Used as unload callback for hosts with old-style drivers.
-	 *
-	 * Status: OBSOLETE
-	 */
-	int (* release)(struct Scsi_Host *);
-
 	/*
 	 * The info function will return whatever useful information the
 	 * developer sees fit.  If not provided, then the name field will
@@ -482,15 +467,6 @@ struct scsi_host_template {
 	 */
 	const struct attribute_group **sdev_groups;
 
-	/*
-	 * List of hosts per template.
-	 *
-	 * This is only for use by scsi_module.c for legacy templates.
-	 * For these access to it is synchronized implicitly by
-	 * module_init/module_exit.
-	 */
-	struct list_head legacy_hosts;
-
 	/*
 	 * Vendor Identifier associated with the host
 	 *
@@ -713,15 +689,6 @@ struct Scsi_Host {
 	/* ldm bits */
 	struct device		shost_gendev, shost_dev;
 
-	/*
-	 * List of hosts per template.
-	 *
-	 * This is only for use by scsi_module.c for legacy templates.
-	 * For these access to it is synchronized implicitly by
-	 * module_init/module_exit.
-	 */
-	struct list_head sht_legacy_list;
-
 	/*
 	 * Points to the transport data (if any) which is allocated
 	 * separately
@@ -922,9 +889,6 @@ static inline unsigned char scsi_host_get_guard(struct Scsi_Host *shost)
 	return shost->prot_guard_type;
 }
 
-/* legacy interfaces */
-extern struct Scsi_Host *scsi_register(struct scsi_host_template *, int);
-extern void scsi_unregister(struct Scsi_Host *);
 extern int scsi_host_set_state(struct Scsi_Host *, enum scsi_host_state);
 
 #endif /* _SCSI_SCSI_HOST_H */

commit 2f31115e940c4afd49b99c33123534e2ac924ffb
Author: Ming Lei <ming.lei@redhat.com>
Date:   Tue Mar 13 17:42:41 2018 +0800

    scsi: core: introduce force_blk_mq
    
    This patch introduces 'force_blk_mq' to the scsi_host_template so that
    drivers that have no desire to support the legacy I/O path can signal
    blk-mq only support.
    
    [mkp: commit desc]
    
    Cc: Omar Sandoval <osandov@fb.com>,
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>,
    Cc: James Bottomley <james.bottomley@hansenpartnership.com>,
    Cc: Christoph Hellwig <hch@lst.de>,
    Cc: Don Brace <don.brace@microsemi.com>
    Cc: Kashyap Desai <kashyap.desai@broadcom.com>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Laurence Oberman <loberman@redhat.com>
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index a8b7bf879ced..9c1e4bad6581 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -452,6 +452,9 @@ struct scsi_host_template {
 	/* True if the controller does not support WRITE SAME */
 	unsigned no_write_same:1;
 
+	/* True if the low-level driver supports blk-mq only */
+	unsigned force_blk_mq:1;
+
 	/*
 	 * Countdown for host blocking with no commands outstanding.
 	 */

commit 3be8828fc507cdafe7040a3dcf361a2bcd8e305b
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Thu Feb 22 11:30:20 2018 -0800

    scsi: core: Avoid that ATA error handling can trigger a kernel hang or oops
    
    Avoid that the recently introduced call_rcu() call in the SCSI core
    triggers a double call_rcu() call.
    
    Reported-by: Natanael Copa <ncopa@alpinelinux.org>
    Reported-by: Damien Le Moal <damien.lemoal@wdc.com>
    References: https://bugzilla.kernel.org/show_bug.cgi?id=198861
    Fixes: 3bd6f43f5cb3 ("scsi: core: Ensure that the SCSI error handler gets woken up")
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Reviewed-by: Damien Le Moal <damien.lemoal@wdc.com>
    Tested-by: Damien Le Moal <damien.lemoal@wdc.com>
    Cc: Natanael Copa <ncopa@alpinelinux.org>
    Cc: Damien Le Moal <damien.lemoal@wdc.com>
    Cc: Alexandre Oliva <oliva@gnu.org>
    Cc: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
    Cc: Hannes Reinecke <hare@suse.com>
    Cc: Johannes Thumshirn <jthumshirn@suse.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 1a1df0d21ee3..a8b7bf879ced 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -571,8 +571,6 @@ struct Scsi_Host {
 		struct blk_mq_tag_set	tag_set;
 	};
 
-	struct rcu_head rcu;
-
 	atomic_t host_busy;		   /* commands actually active on low-level */
 	atomic_t host_blocked;
 

commit 86b87cde0b5581cdb1a7babeb9c4c387761f151b
Author: Stanislav Nijnikov <stanislav.nijnikov@wdc.com>
Date:   Thu Feb 15 14:14:08 2018 +0200

    scsi: core: host template attribute groups
    
    The patch introduces an additional field in the scsi_host_template
    structure - struct attribute_group **sdev_group.  This field allows to
    define groups of attributes. It will provide an ability to use binary
    attributes as well as device attributes and to group them under
    subfolders if necessary.
    
    Signed-off-by: Stanislav Nijnikov <stanislav.nijnikov@wdc.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 1a1df0d21ee3..19317585ae48 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -476,6 +476,12 @@ struct scsi_host_template {
 	 */
 	struct device_attribute **sdev_attrs;
 
+	/*
+	 * Pointer to the SCSI device attribute groups for this host,
+	 * NULL terminated.
+	 */
+	const struct attribute_group **sdev_groups;
+
 	/*
 	 * List of hosts per template.
 	 *

commit 3bd6f43f5cb3714f70c591514f344389df593501
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Mon Dec 4 10:06:23 2017 -0800

    scsi: core: Ensure that the SCSI error handler gets woken up
    
    If scsi_eh_scmd_add() is called concurrently with
    scsi_host_queue_ready() while shost->host_blocked > 0 then it can
    happen that neither function wakes up the SCSI error handler. Fix
    this by making every function that decreases the host_busy counter
    wake up the error handler if necessary and by protecting the
    host_failed checks with the SCSI host lock.
    
    Reported-by: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
    References: https://marc.info/?l=linux-kernel&m=150461610630736
    Fixes: commit 746650160866 ("scsi: convert host_busy to atomic_t")
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Reviewed-by: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
    Tested-by: Stuart Hayes <stuart.w.hayes@gmail.com>
    Cc: Konstantin Khorenko <khorenko@virtuozzo.com>
    Cc: Stuart Hayes <stuart.w.hayes@gmail.com>
    Cc: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Hannes Reinecke <hare@suse.com>
    Cc: Johannes Thumshirn <jthumshirn@suse.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index a8b7bf879ced..1a1df0d21ee3 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -571,6 +571,8 @@ struct Scsi_Host {
 		struct blk_mq_tag_set	tag_set;
 	};
 
+	struct rcu_head rcu;
+
 	atomic_t host_busy;		   /* commands actually active on low-level */
 	atomic_t host_blocked;
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 0a804b1a4726..a8b7bf879ced 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _SCSI_SCSI_HOST_H
 #define _SCSI_SCSI_HOST_H
 

commit 7760e223507b5218d0674b5e2e8dc29fea079a89
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Thu Aug 31 16:59:06 2017 -0700

    scsi: Remove Scsi_Host.uspace_req_q
    
    A patch I wrote myself several years ago removed SCSI target support
    from the code under drivers/scsi. That patch removed the code that sets
    uspace_req_q to a non-NULL value. Hence also remove the code that
    depends on uspace_req_q != NULL.
    
    References: commit 066465251303 ("tgt: removal")
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index afb04811b7b9..0a804b1a4726 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -691,12 +691,6 @@ struct Scsi_Host {
 	unsigned int prot_capabilities;
 	unsigned char prot_guard_type;
 
-	/*
-	 * q used for scsi_tgt msgs, async events or any other requests that
-	 * need to be processed in userspace
-	 */
-	struct request_queue *uspace_req_q;
-
 	/* legacy crap */
 	unsigned long base;
 	unsigned long io_port;

commit a06586325f371c0f0f6095454b5beca0602eaab4
Author: Hannes Reinecke <hare@suse.de>
Date:   Thu Apr 6 15:36:35 2017 +0200

    scsi: make asynchronous aborts mandatory
    
    There hasn't been any reports for HBAs where asynchronous abort
    would not work, so we should make it mandatory and remove
    the fallback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 3cd8c3bec638..afb04811b7b9 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -451,11 +451,6 @@ struct scsi_host_template {
 	/* True if the controller does not support WRITE SAME */
 	unsigned no_write_same:1;
 
-	/*
-	 * True if asynchronous aborts are not supported
-	 */
-	unsigned no_async_abort:1;
-
 	/*
 	 * Countdown for host blocking with no commands outstanding.
 	 */

commit e9c787e65c0c36529745be47d490d998b4b6e589
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 2 21:55:26 2017 +0300

    scsi: allocate scsi_cmnd structures as part of struct request
    
    Rely on the new block layer functionality to allocate additional driver
    specific data behind struct request instead of implementing it in SCSI
    itelf.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index f4964d7db313..3cd8c3bec638 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -551,9 +551,6 @@ struct Scsi_Host {
 	struct list_head	__devices;
 	struct list_head	__targets;
 	
-	struct scsi_host_cmd_pool *cmd_pool;
-	spinlock_t		free_list_lock;
-	struct list_head	free_list; /* backup store of cmd structs */
 	struct list_head	starved_list;
 
 	spinlock_t		default_lock;

commit d48777a633d6fa7ccde0f0e6509f0c01fbfc5299
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 2 21:52:10 2017 +0300

    scsi: remove __scsi_alloc_queue
    
    Instead do an internal export of __scsi_init_queue for the transport
    classes that export BSG nodes.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 36680f13270d..f4964d7db313 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -826,8 +826,6 @@ extern void scsi_block_requests(struct Scsi_Host *);
 
 struct class_container;
 
-extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
-						void (*) (struct request_queue *));
 /*
  * These two functions are used to allocate and free a pseudo device
  * which will connect to the host adapter itself rather than any

commit 2d9c5c20c93eacc00642f6ce10ce47f31fa0b6ac
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 1 08:12:48 2016 -0600

    scsi: allow LLDDs to expose the queue mapping to blk-mq
    
    Just hand through the blk-mq map_queues method in the host template.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 7e4cd53139ed..36680f13270d 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -277,6 +277,14 @@ struct scsi_host_template {
 	 */
 	int (* change_queue_depth)(struct scsi_device *, int);
 
+	/*
+	 * This functions lets the driver expose the queue mapping
+	 * to the block layer.
+	 *
+	 * Status: OPTIONAL
+	 */
+	int (* map_queues)(struct Scsi_Host *shost);
+
 	/*
 	 * This function determines the BIOS parameters for a given
 	 * harddisk.  These tend to be numbers that are made up by

commit 8d58881b995904bf8b150dae69be0829f832e7be
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Sep 22 14:20:54 2016 -0700

    scsi: Avoid that toggling use_blk_mq triggers a memory leak
    
    This patch avoids that the following memory leak is triggered if
    use_blk_mq is disabled after a SCSI host has been allocated by the
    ib_srp driver and before the same SCSI host is freed:
    
    unreferenced object 0xffff8803a168c568 (size 256):
      backtrace:
        [<ffffffff81620c95>] kmemleak_alloc+0x45/0xa0
        [<ffffffff811bb104>] __kmalloc_node+0x1e4/0x400
        [<ffffffff81309fe4>] blk_mq_alloc_tag_set+0xb4/0x230
        [<ffffffff814731b7>] scsi_mq_setup_tags+0xc7/0xd0
        [<ffffffff81469c26>] scsi_add_host_with_dma+0x216/0x2d0
        [<ffffffffa064bef5>] srp_create_target+0xe55/0x13d0 [ib_srp]
        [<ffffffff8143ce23>] dev_attr_store+0x13/0x20
        [<ffffffff8125f030>] sysfs_kf_write+0x40/0x50
        [<ffffffff8125e397>] kernfs_fop_write+0x137/0x1c0
        [<ffffffff811d8c13>] __vfs_write+0x23/0x140
        [<ffffffff811d92e0>] vfs_write+0xb0/0x190
        [<ffffffff811da5b4>] SyS_write+0x44/0xa0
        [<ffffffff8162c8a5>] entry_SYSCALL_64_fastpath+0x18/0xa8
    
    Fixes: 9aa9cc4221f5 ("scsi: remove the disable_blk_mq host flag")
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Martin K. Petersen <martin.petersen@oracle.com>
    Cc: <stable@vger.kernel.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 0dee7afa93d6..7e4cd53139ed 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -771,12 +771,9 @@ static inline int scsi_host_in_recovery(struct Scsi_Host *shost)
 		shost->tmf_in_progress;
 }
 
-extern bool scsi_use_blk_mq;
-
 static inline bool shost_use_blk_mq(struct Scsi_Host *shost)
 {
-	return scsi_use_blk_mq;
-
+	return shost->use_blk_mq;
 }
 
 extern int scsi_queue_work(struct Scsi_Host *, struct work_struct *);

commit 9aa9cc4221f5154ed93e999662ccfef7b6a82e3e
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jul 13 13:19:05 2016 +0900

    scsi: remove the disable_blk_mq host flag
    
    We've had scsi-mq for 2.5 years now, so we can remove the unused flag to
    disable the code on a per-host basis that was put in for unexpected
    emergencies during bringup.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 76e9d278c334..0dee7afa93d6 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -495,9 +495,6 @@ struct scsi_host_template {
 	 */
 	unsigned int cmd_size;
 	struct scsi_host_cmd_pool *cmd_pool;
-
-	/* temporary flag to disable blk-mq I/O path */
-	bool disable_blk_mq;
 };
 
 /*
@@ -778,7 +775,8 @@ extern bool scsi_use_blk_mq;
 
 static inline bool shost_use_blk_mq(struct Scsi_Host *shost)
 {
-	return shost->use_blk_mq;
+	return scsi_use_blk_mq;
+
 }
 
 extern int scsi_queue_work(struct Scsi_Host *, struct work_struct *);

commit 65e8617fba17732b4c68d3369a621725838b6f28
Author: Ming Lin <ming.l@ssi.samsung.com>
Date:   Mon Apr 4 14:48:10 2016 -0700

    scsi: rename SCSI_MAX_{SG, SG_CHAIN}_SEGMENTS
    
    Rename SCSI_MAX_SG_SEGMENTS to SG_CHUNK_SIZE, which means the amount
    we fit into a single scatterlist chunk.
    
    Rename SCSI_MAX_SG_CHAIN_SEGMENTS to SG_MAX_SEGMENTS.
    
    Will move these 2 generic definitions to scatterlist.h later.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Bart Van Assche <bart.vanassche@sandisk.com> (for ib_srp changes)
    Signed-off-by: Ming Lin <ming.l@ssi.samsung.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index fcfa3d7f5e7e..76e9d278c334 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -37,7 +37,7 @@ struct blk_queue_tags;
  *	 used in one scatter-gather request.
  */
 #define SG_NONE 0
-#define SG_ALL	SCSI_MAX_SG_SEGMENTS
+#define SG_ALL	SG_CHUNK_SIZE
 
 #define MODE_UNKNOWN 0x00
 #define MODE_INITIATOR 0x01

commit be9e2f775f5a3147205c552534c3abf0f9374a13
Merge: e619e6cbecb7 3ddda3e4c82d
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Thu Dec 3 09:32:33 2015 -0800

    Merge branch 'mkp-fixes' into fixes

commit a35bb4458e5e5c9dc19a0daa0629409285f3b25e
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Thu Nov 19 14:17:06 2015 +0100

    scsi: report 'INQUIRY result too short' once per host
    
    Some host adapters (e.g. Hyper-V storvsc) are known for not respecting
    the SPC-2/3/4 requirement for 'INQUIRY data (see table ...) shall
    contain at least 36 bytes'. As a result we get tons on 'scsi 0:7:1:1:
    scsi scan: INQUIRY result too short (5), using 36' messages on
    console. This can be problematic for slow consoles. Introduce
    short_inquiry flag in struct Scsi_Host to print the message once per
    host.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index e113c757d555..3a22da73d59a 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -673,6 +673,9 @@ struct Scsi_Host {
 	unsigned use_blk_mq:1;
 	unsigned use_cmd_list:1;
 
+	/* Host responded with short (<36 bytes) INQUIRY result */
+	unsigned short_inquiry:1;
+
 	/*
 	 * Optional work queue to be utilized by the transport
 	 */

commit 64d513ac31bd02a3c9b69ef04444f36c196f9a9d
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Oct 8 09:28:04 2015 +0100

    scsi: use host wide tags by default
    
    This patch changes the !blk-mq path to the same defaults as the blk-mq
    I/O path by always enabling block tagging, and always using host wide
    tags.  We've had blk-mq available for a few releases so bugs with
    this mode should have been ironed out, and this ensures we get better
    coverage of over tagging setup over different configs.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index e113c757d555..ed527121031d 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -405,11 +405,6 @@ struct scsi_host_template {
 	/* If use block layer to manage tags, this is tag allocation policy */
 	int tag_alloc_policy;
 
-	/*
-	 * Let the block layer assigns tags to all commands.
-	 */
-	unsigned use_blk_tags:1;
-
 	/*
 	 * Track QUEUE_FULL events and reduce queue depth on demand.
 	 */

commit ee1b6f7aff94019c09e73837054979063f722046
Author: Shaohua Li <shli@fb.com>
Date:   Thu Jan 15 17:32:25 2015 -0800

    block: support different tag allocation policy
    
    The libata tag allocation is using a round-robin policy. Next patch will
    make libata use block generic tag allocation, so let's add a policy to
    tag allocation.
    
    Currently two policies: FIFO (default) and round-robin.
    
    Cc: Jens Axboe <axboe@fb.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 019e66858ce6..e113c757d555 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -402,6 +402,9 @@ struct scsi_host_template {
 	 */
 	unsigned char present;
 
+	/* If use block layer to manage tags, this is tag allocation policy */
+	int tag_alloc_policy;
+
 	/*
 	 * Let the block layer assigns tags to all commands.
 	 */

commit e61745769125a3c788e7aceb2a5fb680ebb461e6
Merge: 198a956a11b1 e86fb5e8ab95
Author: James Bottomley <JBottomley@Parallels.com>
Date:   Thu Dec 18 05:56:29 2014 -0800

    Merge remote-tracking branch 'scsi-queue/drivers-for-3.19' into for-linus

commit a7cb7bb664543e4562ab0e9a072470d2d18c761f
Merge: ccb5a4910d0c 078014dd3698
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 12 10:08:06 2014 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull trivial tree update from Jiri Kosina:
     "Usual stuff: documentation updates, printk() fixes, etc"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (24 commits)
      intel_ips: fix a type in error message
      cpufreq: cpufreq-dt: Move newline to end of error message
      ps3rom: fix error return code
      treewide: fix typo in printk and Kconfig
      ARM: dts: bcm63138: change "interupts" to "interrupts"
      Replace mentions of "list_struct" to "list_head"
      kernel: trace: fix printk message
      scsi: mpt2sas: fix ioctl in comment
      zbud, zswap: change module author email
      clocksource: Fix 'clcoksource' typo in comment
      arm: fix wording of "Crotex" in CONFIG_ARCH_EXYNOS3 help
      gpio: msm-v1: make boolean argument more obvious
      usb: Fix typo in usb-serial-simple.c
      PCI: Fix comment typo 'COMFIG_PM_OPS'
      powerpc: Fix comment typo 'CONIFG_8xx'
      powerpc: Fix comment typos 'CONFiG_ALTIVEC'
      clk: st: Spelling s/stucture/structure/
      isci: Spelling s/stucture/structure/
      usb: gadget: zero: Spelling s/infrastucture/infrastructure/
      treewide: Fix company name in module descriptions
      ...

commit efc3c1df5fda0aee84f53c226d55804e6dbede4f
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Nov 24 15:36:18 2014 +0100

    scsi: remove ->change_queue_type method
    
    Since we got rid of ordered tag support in 2010 the prime use case of
    switching on and off ordered tags has been obsolete.  The other function
    of enabling/disabling tagging entirely has only been correctly implemented
    by the 53c700 driver and isn't generally useful.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index c8a462ef9a4e..c2fa8b49cb2e 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -277,19 +277,6 @@ struct scsi_host_template {
 	 */
 	int (* change_queue_depth)(struct scsi_device *, int);
 
-	/*
-	 * Fill in this function to allow the changing of tag types
-	 * (this also allows the enabling/disabling of tag command
-	 * queueing).  An error should only be returned if something
-	 * went wrong in the driver while trying to set the tag type.
-	 * If the driver doesn't support the requested tag type, then
-	 * it should set the closest type it does support without
-	 * returning an error.  Returns the actual tag type set.
-	 *
-	 * Status: OPTIONAL
-	 */
-	int (* change_queue_type)(struct scsi_device *, int);
-
 	/*
 	 * This function determines the BIOS parameters for a given
 	 * harddisk.  These tend to be numbers that are made up by

commit db5ed4dfd5dd0142ec36ff7b335e0ec3b836b3e6
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Nov 13 15:08:42 2014 +0100

    scsi: drop reason argument from ->change_queue_depth
    
    Drop the now unused reason argument from the ->change_queue_depth method.
    Also add a return value to scsi_adjust_queue_depth, and rename it to
    scsi_change_queue_depth now that it can be used as the default
    ->change_queue_depth implementation.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index a0b13a5cd25e..c8a462ef9a4e 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -46,10 +46,6 @@ struct blk_queue_tags;
 #define DISABLE_CLUSTERING 0
 #define ENABLE_CLUSTERING 1
 
-enum {
-	SCSI_QDEPTH_DEFAULT,	/* default requested change, e.g. from sysfs */
-};
-
 struct scsi_host_template {
 	struct module *module;
 	const char *name;
@@ -193,7 +189,7 @@ struct scsi_host_template {
 	 * Things currently recommended to be handled at this time include:
 	 *
 	 * 1.  Setting the device queue depth.  Proper setting of this is
-	 *     described in the comments for scsi_adjust_queue_depth.
+	 *     described in the comments for scsi_change_queue_depth.
 	 * 2.  Determining if the device supports the various synchronous
 	 *     negotiation protocols.  The device struct will already have
 	 *     responded to INQUIRY and the results of the standard items
@@ -279,7 +275,7 @@ struct scsi_host_template {
 	 *
 	 * Status: OPTIONAL
 	 */
-	int (* change_queue_depth)(struct scsi_device *, int, int);
+	int (* change_queue_depth)(struct scsi_device *, int);
 
 	/*
 	 * Fill in this function to allow the changing of tag types

commit c40ecc12cfdb630332198a04e2832ae8218a61f1
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Nov 13 14:25:11 2014 +0100

    scsi: avoid ->change_queue_depth indirection for queue full tracking
    
    All drivers use the implementation for ramping the queue up and down, so
    instead of overloading the change_queue_depth method call the
    implementation diretly if the driver opts into it by setting the
    track_queue_depth flag in the host template.
    
    Note that a few drivers validated the new queue depth in their
    change_queue_depth method, but as we never go over the queue depth
    set during slave_configure or the sysfs file this isn't nessecary
    and can safely be removed.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Venkatesh Srinivas <venkateshs@google.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 61a81bf77e28..a0b13a5cd25e 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -48,8 +48,6 @@ struct blk_queue_tags;
 
 enum {
 	SCSI_QDEPTH_DEFAULT,	/* default requested change, e.g. from sysfs */
-	SCSI_QDEPTH_QFULL,	/* scsi-ml requested due to queue full */
-	SCSI_QDEPTH_RAMP_UP,	/* scsi-ml requested due to threshold event */
 };
 
 struct scsi_host_template {
@@ -426,6 +424,11 @@ struct scsi_host_template {
 	 */
 	unsigned use_blk_tags:1;
 
+	/*
+	 * Track QUEUE_FULL events and reduce queue depth on demand.
+	 */
+	unsigned track_queue_depth:1;
+
 	/*
 	 * This specifies the mode that a LLD supports.
 	 */

commit a02001086bbfb4da35d1228bebc2f1b442db455f
Merge: eff264efeeb0 fc14f9c1272f
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Nov 20 14:42:02 2014 +0100

    Merge Linus' tree to be be to apply submitted patches to newer code than
    current trivial.git base

commit 2ecb204d07ac8debe3893c362415919bc78bebd6
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Nov 3 14:09:02 2014 +0100

    scsi: always assign block layer tags if enabled
    
    Allow a driver to ask for block layer tags by setting .use_blk_tags in the
    host template, in which case it will always see a valid value in
    request->tag, similar to the behavior when using blk-mq.  This means even
    SCSI "untagged" commands will now have a tag, which is especially useful
    when using a host-wide tag map.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index d6bd65294009..61a81bf77e28 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -421,6 +421,11 @@ struct scsi_host_template {
 	 */
 	unsigned char present;
 
+	/*
+	 * Let the block layer assigns tags to all commands.
+	 */
+	unsigned use_blk_tags:1;
+
 	/*
 	 * This specifies the mode that a LLD supports.
 	 */

commit e2eddf4d530df745019fded0fedfb78f6d3e33ca
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 4 07:58:28 2014 +0100

    scsi: remove use_blk_tcq Scsi_Host field
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 5b03ba9d7390..d6bd65294009 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -650,7 +650,6 @@ struct Scsi_Host {
 	unsigned active_mode:2;
 	unsigned unchecked_isa_dma:1;
 	unsigned use_clustering:1;
-	unsigned use_blk_tcq:1;
 
 	/*
 	 * Host has requested that no further requests come through for the

commit abd0c533e37789ef56a73562d6d06d39897bd801
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Nov 3 14:47:07 2014 +0100

    scsi: remove ordered_tag host template field
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index bb9e27815be5..5b03ba9d7390 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -451,11 +451,6 @@ struct scsi_host_template {
 	 */
 	unsigned skip_settle_delay:1;
 
-	/*
-	 * True if we are using ordered write support.
-	 */
-	unsigned ordered_tag:1;
-
 	/* True if the controller does not support WRITE SAME */
 	unsigned no_write_same:1;
 
@@ -670,11 +665,6 @@ struct Scsi_Host {
 	 */
 	unsigned reverse_ordering:1;
 
-	/*
-	 * Ordered write support
-	 */
-	unsigned ordered_tag:1;
-
 	/* Task mgmt function in progress */
 	unsigned tmf_in_progress:1;
 

commit efec4b90f1a9b4c80827e4b8c0863334e13b0bf1
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Thu Oct 30 14:45:36 2014 +0100

    scsi: add support for multiple hardware queues
    
    Allow a SCSI LLD to declare how many hardware queues it supports
    by setting Scsi_Host.nr_hw_queues before calling scsi_add_host().
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 5e362489ee88..bb9e27815be5 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -638,6 +638,14 @@ struct Scsi_Host {
 	short unsigned int sg_prot_tablesize;
 	unsigned int max_sectors;
 	unsigned long dma_boundary;
+	/*
+	 * In scsi-mq mode, the number of hardware queues supported by the LLD.
+	 *
+	 * Note: it is assumed that each hardware queue has a queue depth of
+	 * can_queue. In other words, the total queue depth per host
+	 * is nr_hw_queues * can_queue.
+	 */
+	unsigned nr_hw_queues;
 	/* 
 	 * Used to assign serial numbers to the cmds.
 	 * Protected by the host lock.

commit 542cb4593104ae306970eb181ea42a01f1a79ed2
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Fri Oct 3 11:42:17 2014 +1000

    scsi: Fix "choir" and "beeing" malaprops
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index ba2034779961..b286b5787c85 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -555,7 +555,7 @@ struct Scsi_Host {
 	 * __devices is protected by the host_lock, but you should
 	 * usually use scsi_device_lookup / shost_for_each_device
 	 * to access it and don't care about locking yourself.
-	 * In the rare case of beeing in irq context you can use
+	 * In the rare case of being in irq context you can use
 	 * their __ prefixed variants with the lock held. NEVER
 	 * access this list directly from a driver.
 	 */

commit 8e4a5da69c39788fabc9e7cf178eb62b6077c96b
Author: Sebastian Herbszt <herbszt@gmx.de>
Date:   Sat Sep 20 13:37:55 2014 +0200

    scsi: fix comment in struct Scsi_Host definition
    
    Commit 1abf635 (scsi: use 64-bit value for 'max_luns') changed the order
    of Scsi_Host members. Update the comment to reflect this.
    
    Signed-off-by: Sebastian Herbszt <herbszt@gmx.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index d0f69a3210df..5e362489ee88 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -606,7 +606,7 @@ struct Scsi_Host {
 	/*
 	 * These three parameters can be used to allow for wide scsi,
 	 * and for host adapters that support multiple busses
-	 * The first two should be set to 1 more than the actual max id
+	 * The last two should be set to 1 more than the actual max id
 	 * or lun (e.g. 8 for SCSI parallel systems).
 	 */
 	unsigned int max_channel;

commit 50c4e96411a6cd728f04cf70d8d6def57828b320
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Sep 2 11:35:50 2014 -0400

    scsi: don't store LUN bits in CDB[1] for USB mass-storage devices
    
    The SCSI specification requires that the second Command Data Byte
    should contain the LUN value in its high-order bits if the recipient
    device reports SCSI level 2 or below.  Nevertheless, some USB
    mass-storage devices use those bits for other purposes in
    vendor-specific commands.  Currently Linux has no way to send such
    commands, because the SCSI stack always overwrites the LUN bits.
    
    Testing shows that Windows 7 and XP do not store the LUN bits in the
    CDB when sending commands to a USB device.  This doesn't matter if the
    device uses the Bulk-Only or UAS transports (which virtually all
    modern USB mass-storage devices do), as these have a separate
    mechanism for sending the LUN value.
    
    Therefore this patch introduces a flag in the Scsi_Host structure to
    inform the SCSI midlayer that a transport does not require the LUN
    bits to be stored in the CDB, and it makes usb-storage set this flag
    for all devices using the Bulk-Only transport.  (UAS is handled by a
    separate driver, but it doesn't really matter because no SCSI-2 or
    lower device is at all likely to use UAS.)
    
    The patch also cleans up the code responsible for storing the LUN
    value by adding a bitflag to the scsi_device structure.  The test for
    whether to stick the LUN value in the CDB can be made when the device
    is probed, and stored for future use rather than being made over and
    over in the fast path.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Tiziano Bacocco <tiziano.bacocco@gmail.com>
    Acked-by: Martin K. Petersen <martin.petersen@oracle.com>
    Acked-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index cafb260ef2d3..d0f69a3210df 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -693,6 +693,9 @@ struct Scsi_Host {
 	 */
 	struct workqueue_struct *tmf_work_q;
 
+	/* The transport requires the LUN bits NOT to be stored in CDB[1] */
+	unsigned no_scsi2_lun_in_cdb:1;
+
 	/*
 	 * Value host_blocked counts down from
 	 */

commit 64bdcbc449105377dd60c8da97cfc1663b39562c
Author: Kashyap.Desai@avagotech.com <Kashyap.Desai@avagotech.com>
Date:   Wed Aug 20 19:24:33 2014 +0530

    scsi: add use_cmd_list flag
    
    Add a use_cmd_list flag in struct Scsi_Host to request keeping track of
    all outstanding commands per device.
    
    Default behaviour is not to keep track of cmd_list per sdev, as this may
    introduce lock contention. (overhead is more on multi-node NUMA.), and
    only enable it on the two drivers that need it.
    
    Signed-off-by: Kashyap Desai <kashyap.desai@avagotech.com>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index ba2034779961..cafb260ef2d3 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -680,6 +680,7 @@ struct Scsi_Host {
 	unsigned no_write_same:1;
 
 	unsigned use_blk_mq:1;
+	unsigned use_cmd_list:1;
 
 	/*
 	 * Optional work queue to be utilized by the transport

commit d285203cf647d7c97db3a1c33794315c9008593f
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jan 17 12:06:53 2014 +0100

    scsi: add support for a blk-mq based I/O path.
    
    This patch adds support for an alternate I/O path in the scsi midlayer
    which uses the blk-mq infrastructure instead of the legacy request code.
    
    Use of blk-mq is fully transparent to drivers, although for now a host
    template field is provided to opt out of blk-mq usage in case any unforseen
    incompatibilities arise.
    
    In general replacing the legacy request code with blk-mq is a simple and
    mostly mechanical transformation.  The biggest exception is the new code
    that deals with the fact the I/O submissions in blk-mq must happen from
    process context, which slightly complicates the I/O completion handler.
    The second biggest differences is that blk-mq is build around the concept
    of preallocated requests that also include driver specific data, which
    in SCSI context means the scsi_cmnd structure.  This completely avoids
    dynamic memory allocations for the fast path through I/O submission.
    
    Due the preallocated requests the MQ code path exclusively uses the
    host-wide shared tag allocator instead of a per-LUN one.  This only
    affects drivers actually using the block layer provided tag allocator
    instead of their own.  Unlike the old path blk-mq always provides a tag,
    although drivers don't have to use it.
    
    For now the blk-mq path is disable by defauly and must be enabled using
    the "use_blk_mq" module parameter.  Once the remaining work in the block
    layer to make blk-mq more suitable for slow devices is complete I hope
    to make it the default and eventually even remove the old code path.
    
    Based on the earlier scsi-mq prototype by Nicholas Bellinger.
    
    Thanks to Bart Van Assche and Robert Elliot for testing, benchmarking and
    various sugestions and code contributions.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Webb Scales <webbnh@hp.com>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Tested-by: Bart Van Assche <bvanassche@acm.org>
    Tested-by: Robert Elliott <elliott@hp.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 5e8ebc1ac12b..ba2034779961 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -7,6 +7,7 @@
 #include <linux/workqueue.h>
 #include <linux/mutex.h>
 #include <linux/seq_file.h>
+#include <linux/blk-mq.h>
 #include <scsi/scsi.h>
 
 struct request_queue;
@@ -510,6 +511,9 @@ struct scsi_host_template {
 	 */
 	unsigned int cmd_size;
 	struct scsi_host_cmd_pool *cmd_pool;
+
+	/* temporary flag to disable blk-mq I/O path */
+	bool disable_blk_mq;
 };
 
 /*
@@ -580,7 +584,10 @@ struct Scsi_Host {
 	 * Area to keep a shared tag map (if needed, will be
 	 * NULL if not).
 	 */
-	struct blk_queue_tag	*bqt;
+	union {
+		struct blk_queue_tag	*bqt;
+		struct blk_mq_tag_set	tag_set;
+	};
 
 	atomic_t host_busy;		   /* commands actually active on low-level */
 	atomic_t host_blocked;
@@ -672,6 +679,8 @@ struct Scsi_Host {
 	/* The controller does not support WRITE SAME */
 	unsigned no_write_same:1;
 
+	unsigned use_blk_mq:1;
+
 	/*
 	 * Optional work queue to be utilized by the transport
 	 */
@@ -772,6 +781,13 @@ static inline int scsi_host_in_recovery(struct Scsi_Host *shost)
 		shost->tmf_in_progress;
 }
 
+extern bool scsi_use_blk_mq;
+
+static inline bool shost_use_blk_mq(struct Scsi_Host *shost)
+{
+	return shost->use_blk_mq;
+}
+
 extern int scsi_queue_work(struct Scsi_Host *, struct work_struct *);
 extern void scsi_flush_work(struct Scsi_Host *);
 

commit cd9070c9c512ff7995f9019392e0ae548df3a088
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Jan 23 12:07:41 2014 +0100

    scsi: fix the {host,target,device}_blocked counter mess
    
    Seems like these counters are missing any sort of synchronization for
    updates, as a over 10 year old comment from me noted.  Fix this by
    using atomic counters, and while we're at it also make sure they are
    in the same cacheline as the _busy counters and not needlessly stored
    to in every I/O completion.
    
    With the new model the _busy counters can temporarily go negative,
    so all the readers are updated to check for > 0 values.  Longer
    term every successful I/O completion will reset the counters to zero,
    so the temporarily negative values will not cause any harm.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Webb Scales <webbnh@hp.com>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Tested-by: Bart Van Assche <bvanassche@acm.org>
    Tested-by: Robert Elliott <elliott@hp.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 51f7911b1cbb..5e8ebc1ac12b 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -583,6 +583,8 @@ struct Scsi_Host {
 	struct blk_queue_tag	*bqt;
 
 	atomic_t host_busy;		   /* commands actually active on low-level */
+	atomic_t host_blocked;
+
 	unsigned int host_failed;	   /* commands that failed.
 					      protected by host_lock */
 	unsigned int host_eh_scheduled;    /* EH scheduled without command */
@@ -681,11 +683,6 @@ struct Scsi_Host {
 	 */
 	struct workqueue_struct *tmf_work_q;
 
-	/*
-	 * Host has rejected a command because it was busy.
-	 */
-	unsigned int host_blocked;
-
 	/*
 	 * Value host_blocked counts down from
 	 */

commit 74665016086615bbaa3fa6f83af410a0a4e029ee
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jan 22 15:29:29 2014 +0100

    scsi: convert host_busy to atomic_t
    
    Avoid taking the host-wide host_lock to check the per-host queue limit.
    Instead we do an atomic_inc_return early on to grab our slot in the queue,
    and if necessary decrement it after finishing all checks.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Webb Scales <webbnh@hp.com>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Tested-by: Bart Van Assche <bvanassche@acm.org>
    Tested-by: Robert Elliott <elliott@hp.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index b2bc5198b7fb..51f7911b1cbb 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -582,13 +582,9 @@ struct Scsi_Host {
 	 */
 	struct blk_queue_tag	*bqt;
 
-	/*
-	 * The following two fields are protected with host_lock;
-	 * however, eh routines can safely access during eh processing
-	 * without acquiring the lock.
-	 */
-	unsigned int host_busy;		   /* commands actually active on low-level */
-	unsigned int host_failed;	   /* commands that failed. */
+	atomic_t host_busy;		   /* commands actually active on low-level */
+	unsigned int host_failed;	   /* commands that failed.
+					      protected by host_lock */
 	unsigned int host_eh_scheduled;    /* EH scheduled without command */
     
 	unsigned int host_no;  /* Used for IOCTL_GET_IDLUN, /proc/scsi et al. */

commit f1bea55d5afa371c311b61946c58b2cd4e78fb2d
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Apr 15 12:26:54 2014 +0200

    scsi: remove various exports that were only used by scsi_tgt
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index f7adfe0a6dc8..b2bc5198b7fb 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -795,8 +795,6 @@ extern struct Scsi_Host *scsi_host_lookup(unsigned short);
 extern const char *scsi_host_state_name(enum scsi_host_state);
 extern void scsi_cmd_get_serial(struct Scsi_Host *, struct scsi_cmnd *);
 
-extern u64 scsi_calculate_bounce_limit(struct Scsi_Host *);
-
 static inline int __must_check scsi_add_host(struct Scsi_Host *host,
 					     struct device *dev)
 {

commit 066465251303c2a4ba489596f1ecda279711273d
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Tue Apr 15 12:26:52 2014 +0200

    tgt: removal
    
    Now that the ibmvstgt driver as the only user of scsi_tgt is gone, the
    scsi_tgt kernel module, the CONFIG_SCSI_TGT, CONFIG_SCSI_SRP_TGT_ATTRS and
    CONFIG_SCSI_FC_TGT_ATTRS kbuild variable, the scsi_host_template
    transfer_response method are no longer needed.
    
    [hch: minor updates to the current tree, changelog update]
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index abb695882fed..f7adfe0a6dc8 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -131,27 +131,6 @@ struct scsi_host_template {
 	 */
 	int (* queuecommand)(struct Scsi_Host *, struct scsi_cmnd *);
 
-	/*
-	 * The transfer functions are used to queue a scsi command to
-	 * the LLD. When the driver is finished processing the command
-	 * the done callback is invoked.
-	 *
-	 * This is called to inform the LLD to transfer
-	 * scsi_bufflen(cmd) bytes. scsi_sg_count(cmd) speciefies the
-	 * number of scatterlist entried in the command and
-	 * scsi_sglist(cmd) returns the scatterlist.
-	 *
-	 * return values: see queuecommand
-	 *
-	 * If the LLD accepts the cmd, it should set the result to an
-	 * appropriate value when completed before calling the done function.
-	 *
-	 * STATUS: REQUIRED FOR TARGET DRIVERS
-	 */
-	/* TODO: rename */
-	int (* transfer_response)(struct scsi_cmnd *,
-				  void (*done)(struct scsi_cmnd *));
-
 	/*
 	 * This is an error handling strategy routine.  You don't need to
 	 * define one of these if you don't want to - there is a default

commit 1abf635d2f3332641570e1913e317073834a055f
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Jun 25 15:27:38 2014 +0200

    scsi: use 64-bit value for 'max_luns'
    
    Now that we're using 64-bit LUNs internally we need to increase
    the size of max_luns to 64 bits, too.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@infradead.org>
    Reviewed-by: Ewan Milne <emilne@redhat.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index db7d8bd2f86f..abb695882fed 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -623,11 +623,11 @@ struct Scsi_Host {
 	 * These three parameters can be used to allow for wide scsi,
 	 * and for host adapters that support multiple busses
 	 * The first two should be set to 1 more than the actual max id
-	 * or lun (i.e. 8 for normal systems).
+	 * or lun (e.g. 8 for SCSI parallel systems).
 	 */
-	unsigned int max_id;
-	unsigned int max_lun;
 	unsigned int max_channel;
+	unsigned int max_id;
+	u64 max_lun;
 
 	/*
 	 * This is a unique identifier that must be assigned so that we

commit 8ed5a4d2f7d8b296a22fed7ec2b543c0500d13be
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Mon Jun 2 22:56:48 2014 +0900

    scsi: increase upper limit for max_sectors
    
    max_sectors in struct Scsi_Host specifies maximum number of sectors
    allowed in a single SCSI command.  The data type of max_sectors is
    unsigned short, so the maximum transfer length per SCSI command is
    limited to less than 256MB in 4096-bytes sector size. (0xffff * 4096)
    
    This commit increases the SCSI mid level's limitation for max_sectors
    upto the block layer's limitation for max_hw_sectors by extending the
    data type of max_sectors in struct Scsi_Host and scsi_host_template,
    so that SCSI lower level drivers can specify more than 0xffff.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 94844fc77b97..db7d8bd2f86f 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -408,7 +408,7 @@ struct scsi_host_template {
 	/*
 	 * Set this if the host adapter has limitations beside segment count.
 	 */
-	unsigned short max_sectors;
+	unsigned int max_sectors;
 
 	/*
 	 * DMA scatter gather segment boundary limit. A segment crossing this
@@ -652,7 +652,7 @@ struct Scsi_Host {
 	short cmd_per_lun;
 	short unsigned int sg_tablesize;
 	short unsigned int sg_prot_tablesize;
-	short unsigned int max_sectors;
+	unsigned int max_sectors;
 	unsigned long dma_boundary;
 	/* 
 	 * Used to assign serial numbers to the cmds.

commit 89d9a567952baec13e26ada3e438f1b642d66b6e
Author: Christoph Hellwig <hch@infradead.org>
Date:   Thu Feb 20 14:21:01 2014 -0800

    [SCSI] add support for per-host cmd pools
    
    This allows drivers to specify the size of their per-command private
    data in the host template and then get extra memory allocated for
    each command instead of needing another allocation in ->queuecommand.
    
    With the current SCSI code that already does multiple allocations for
    each command this probably doesn't make a big performance impact, but
    it allows to clean up the drivers, and prepare them for using the
    blk-mq infrastructure where the common allocation will make a difference.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 53075e5039e6..94844fc77b97 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -15,6 +15,7 @@ struct completion;
 struct module;
 struct scsi_cmnd;
 struct scsi_device;
+struct scsi_host_cmd_pool;
 struct scsi_target;
 struct Scsi_Host;
 struct scsi_host_cmd_pool;
@@ -524,6 +525,12 @@ struct scsi_host_template {
 	 *   scsi_netlink.h
 	 */
 	u64 vendor_id;
+
+	/*
+	 * Additional per-command data allocated for the driver.
+	 */
+	unsigned int cmd_size;
+	struct scsi_host_cmd_pool *cmd_pool;
 };
 
 /*

commit e494f6a728394ab0df194342549ee20e6f0752df
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Nov 11 13:44:54 2013 +0100

    [SCSI] improved eh timeout handler
    
    When a command runs into a timeout we need to send an 'ABORT TASK'
    TMF. This is typically done by the 'eh_abort_handler' LLDD callback.
    
    Conceptually, however, this function is a normal SCSI command, so
    there is no need to enter the error handler.
    
    This patch implements a new scsi_abort_command() function which
    invokes an asynchronous function scsi_eh_abort_handler() to
    abort the commands via the usual 'eh_abort_handler'.
    
    If abort succeeds the command is either retried or terminated,
    depending on the number of allowed retries. However, 'eh_eflags'
    records the abort, so if the retry would fail again the
    command is pushed onto the error handler without trying to
    abort it (again); it'll be cleared up from SCSI EH.
    
    [hare: smatch detected stray switch fixed]
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index fe3b58e836c8..53075e5039e6 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -478,6 +478,11 @@ struct scsi_host_template {
 	/* True if the controller does not support WRITE SAME */
 	unsigned no_write_same:1;
 
+	/*
+	 * True if asynchronous aborts are not supported
+	 */
+	unsigned no_async_abort:1;
+
 	/*
 	 * Countdown for host blocking with no commands outstanding.
 	 */
@@ -689,6 +694,11 @@ struct Scsi_Host {
 	char work_q_name[20];
 	struct workqueue_struct *work_q;
 
+	/*
+	 * Task management function work queue
+	 */
+	struct workqueue_struct *tmf_work_q;
+
 	/*
 	 * Host has rejected a command because it was busy.
 	 */

commit 54b2b50c20a61b51199bedb6e5d2f8ec2568fb43
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Wed Oct 23 06:25:40 2013 -0400

    [SCSI] Disable WRITE SAME for RAID and virtual host adapter drivers
    
    Some host adapters do not pass commands through to the target disk
    directly. Instead they provide an emulated target which may or may not
    accurately report its capabilities. In some cases the physical device
    characteristics are reported even when the host adapter is processing
    commands on the device's behalf. This can lead to adapter firmware hangs
    or excessive I/O errors.
    
    This patch disables WRITE SAME for devices connected to host adapters
    that provide an emulated target. Driver writers can disable WRITE SAME
    by setting the no_write_same flag in the host adapter template.
    
    [jejb: fix up rejections due to eh_deadline patch]
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Cc: stable@kernel.org
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 546084964d55..fe3b58e836c8 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -475,6 +475,9 @@ struct scsi_host_template {
 	 */
 	unsigned ordered_tag:1;
 
+	/* True if the controller does not support WRITE SAME */
+	unsigned no_write_same:1;
+
 	/*
 	 * Countdown for host blocking with no commands outstanding.
 	 */
@@ -677,6 +680,9 @@ struct Scsi_Host {
 	/* Don't resume host in EH */
 	unsigned eh_noresume:1;
 
+	/* The controller does not support WRITE SAME */
+	unsigned no_write_same:1;
+
 	/*
 	 * Optional work queue to be utilized by the transport
 	 */

commit b45620229dd67ff1daffa8adce57f37b37860f78
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Oct 23 10:51:21 2013 +0200

    [SCSI] Add 'eh_deadline' to limit SCSI EH runtime
    
    This patchs adds an 'eh_deadline' sysfs attribute to the scsi
    host which limits the overall runtime of the SCSI EH.
    The 'eh_deadline' value is stored in the now obsolete field
    'resetting'.
    When a command is failed the start time of the EH is stored
    in 'last_reset'. If the overall runtime of the SCSI EH is longer
    than last_reset + eh_deadline, the EH is short-circuited and
    falls through to issue a host reset only.
    
    [jejb: add comments in Scsi_Host about new fields]
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index a74b7d9afe8e..546084964d55 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -599,6 +599,11 @@ struct Scsi_Host {
     
 	unsigned int host_no;  /* Used for IOCTL_GET_IDLUN, /proc/scsi et al. */
 
+	/* next two fields are used to bound the time spent in error handling */
+	int eh_deadline;
+	unsigned long last_reset;
+
+
 	/*
 	 * These three parameters can be used to allow for wide scsi,
 	 * and for host adapters that support multiple busses

commit 6b1e5a45d4eaa75e28f2d170ea43ab8fc6dd34d8
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Oct 23 10:51:20 2013 +0200

    [SCSI] remove check for 'resetting'
    
    Field is now unused, so this is dead code.
    
    [jejb: remove resetting and last_reset from Scsi_Host]
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 755243572219..a74b7d9afe8e 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -598,8 +598,6 @@ struct Scsi_Host {
 	unsigned int host_eh_scheduled;    /* EH scheduled without command */
     
 	unsigned int host_no;  /* Used for IOCTL_GET_IDLUN, /proc/scsi et al. */
-	int resetting; /* if set, it means that last_reset is a valid value */
-	unsigned long last_reset;
 
 	/*
 	 * These three parameters can be used to allow for wide scsi,

commit 70ef457dc92bdd03c0c8d640fce45909166983a1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 13:27:56 2013 -0400

    scsi: bury ->proc_info()
    
    all users converted to ->show_info()/->write_info()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 70e08e442bfc..755243572219 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -341,7 +341,6 @@ struct scsi_host_template {
 	 *
 	 * Status: OBSOLETE
 	 */
-	int (*proc_info)(struct Scsi_Host *, char *, char **, off_t, int, int);
 	int (*show_info)(struct seq_file *, struct Scsi_Host *);
 	int (*write_info)(struct Scsi_Host *, char *, int);
 
@@ -378,7 +377,7 @@ struct scsi_host_template {
 
 	/*
 	 * Used to store the procfs directory if a driver implements the
-	 * proc_info or show_info method.
+	 * show_info method.
 	 */
 	struct proc_dir_entry *proc_dir;
 

commit 0ffddfbb834557b8babc7f050b83d11dbcbb1008
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 30 23:58:05 2013 -0400

    scsi: saner replacements for ->proc_info()
    
    It's still an obsolete interface; don't introduce those in new drivers.
    However, it's saner than the ->proc_info() and commits after this one
    will convert the existing ->proc_info() users to it.
    
    The read side is ->show_info(seq_file *, struct Scsi_Host *); use
    seq_... for generating contents.
    
    The write side is ->write_info(struct Scsi_Host *, char *, int).
    
    Again, this is driven by procfs needs; we are going to kill ->write_proc()
    and ->read_proc() and this is the main obstacle to burying that piece of
    shit.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 2b6956e9853d..70e08e442bfc 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -6,6 +6,7 @@
 #include <linux/types.h>
 #include <linux/workqueue.h>
 #include <linux/mutex.h>
+#include <linux/seq_file.h>
 #include <scsi/scsi.h>
 
 struct request_queue;
@@ -341,6 +342,8 @@ struct scsi_host_template {
 	 * Status: OBSOLETE
 	 */
 	int (*proc_info)(struct Scsi_Host *, char *, char **, off_t, int, int);
+	int (*show_info)(struct seq_file *, struct Scsi_Host *);
+	int (*write_info)(struct Scsi_Host *, char *, int);
 
 	/*
 	 * This is an optional routine that allows the transport to become
@@ -375,7 +378,7 @@ struct scsi_host_template {
 
 	/*
 	 * Used to store the procfs directory if a driver implements the
-	 * proc_info method.
+	 * proc_info or show_info method.
 	 */
 	struct proc_dir_entry *proc_dir;
 

commit 4d24834dfd25f2dab5977241cd5a6662edde92f7
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Wed Sep 26 22:39:44 2012 -0400

    [SCSI] Fix range check in scsi_host_dif_capable()
    
    The range checking from fe542396 was bad. We would still end up walking
    beyond the array as Type 3 is defined to be 4 in the protection
    bitmask. Instead use ARRAY_SIZE() for the range check.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 49084807eb6b..2b6956e9853d 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -873,7 +873,7 @@ static inline unsigned int scsi_host_dif_capable(struct Scsi_Host *shost, unsign
 				       SHOST_DIF_TYPE2_PROTECTION,
 				       SHOST_DIF_TYPE3_PROTECTION };
 
-	if (target_type > SHOST_DIF_TYPE3_PROTECTION)
+	if (target_type >= ARRAY_SIZE(cap))
 		return 0;
 
 	return shost->prot_capabilities & cap[target_type] ? target_type : 0;
@@ -887,7 +887,7 @@ static inline unsigned int scsi_host_dix_capable(struct Scsi_Host *shost, unsign
 				       SHOST_DIX_TYPE2_PROTECTION,
 				       SHOST_DIX_TYPE3_PROTECTION };
 
-	if (target_type > SHOST_DIX_TYPE3_PROTECTION)
+	if (target_type >= ARRAY_SIZE(cap))
 		return 0;
 
 	return shost->prot_capabilities & cap[target_type];

commit fe542396da73b7e2b0848618c7e95855c1b75689
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Fri Sep 21 12:44:12 2012 -0400

    [SCSI] sd: Ensure we correctly disable devices with unknown protection type
    
    We set the capacity to zero when we discovered a device formatted with
    an unknown DIF protection type. However, the read_capacity code would
    override the capacity and cause the device to be enabled regardless.
    
    Make sd_read_protection_type() return an error if the protection type is
    unknown. Also prevent duplicate printk lines when the device is being
    revalidated.
    
    Reported-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 5f7d5b3b1c6e..49084807eb6b 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -873,6 +873,9 @@ static inline unsigned int scsi_host_dif_capable(struct Scsi_Host *shost, unsign
 				       SHOST_DIF_TYPE2_PROTECTION,
 				       SHOST_DIF_TYPE3_PROTECTION };
 
+	if (target_type > SHOST_DIF_TYPE3_PROTECTION)
+		return 0;
+
 	return shost->prot_capabilities & cap[target_type] ? target_type : 0;
 }
 
@@ -884,6 +887,9 @@ static inline unsigned int scsi_host_dix_capable(struct Scsi_Host *shost, unsign
 				       SHOST_DIX_TYPE2_PROTECTION,
 				       SHOST_DIX_TYPE3_PROTECTION };
 
+	if (target_type > SHOST_DIX_TYPE3_PROTECTION)
+		return 0;
+
 	return shost->prot_capabilities & cap[target_type];
 #endif
 	return 0;

commit ae0751ffc77e7f21629970fdab5528c573e637f8
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Dec 5 09:20:24 2011 +0800

    [SCSI] add flag to skip the runtime PM calls on the host
    
    With previous change, now the ata port runtime suspend will happen as:
    
    disk suspend --> scsi target suspend --> scsi host suspend --> ata port
    suspend
    
    ata port(parent device) suspend need to schedule scsi EH which will resume
    scsi host(child device). Then the child device resume will in turn make
    parent device resume first. This is kind of recursive.
    
    This patch adds a new flag Scsi_Host::eh_noresume.
    ata port will set this flag to skip the runtime PM calls on scsi host.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 50266c9405fc..5f7d5b3b1c6e 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -669,6 +669,9 @@ struct Scsi_Host {
 	/* Asynchronous scan in progress */
 	unsigned async_scan:1;
 
+	/* Don't resume host in EH */
+	unsigned eh_noresume:1;
+
 	/*
 	 * Optional work queue to be utilized by the transport
 	 */

commit 76e4e12ff2b3ef86773989fd897b194eb38016e6
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Aug 25 00:36:38 2011 -0500

    [SCSI] scsi scan: don't fail scans when host is in recovery
    
    The problem is that if we are doing a scsi scan then the device goes
    into recovery then we will wait for the recovery to complete. It waits
    because scsi-ml will send inquiries or report luns and the queueing code
    will have been blocked due to the host not being ready. However, if we
    are in recovery and then a scan is started the scan will silently fail
    and some devices will not be added.
    
    It is easy to hit the problem where devices do not show up with
    FC where we are doing tests that disrupt the target controllers.
    When the controller is disruprted (reboot, or setting firmware, etc),
    and we cause the dev loss tmo to fire then devices will be removed
    Then when the problem has been fixed, the rport will be scanned and
    devices should be added back. But if we cause another disruption before
    scanning has started then devices will not get added back. If the problem
    is not started until the scan is started then the devices will be added
    back.
    
    This patch fixes that problem by not failing scans when the host
    is in recovery. We will let scsi-ml send the IO and let the queueing
    and scsi error handling deal with it like is done if we went into
    recovery while scanning.
    
    For recovery cases where the host is being torn down then with the
    patch we will still fail the scan since there is not point in scanning.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index fc22ad9dba77..50266c9405fc 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -804,7 +804,8 @@ static inline struct device *scsi_get_device(struct Scsi_Host *shost)
  **/
 static inline int scsi_host_scan_allowed(struct Scsi_Host *shost)
 {
-	return shost->shost_state == SHOST_RUNNING;
+	return shost->shost_state == SHOST_RUNNING ||
+	       shost->shost_state == SHOST_RECOVERY;
 }
 
 extern void scsi_unblock_requests(struct Scsi_Host *);

commit 2944369144548432f3a5ffce7a2926bfb4ce4f0a
Author: Vikas Chaudhary <vikas.chaudhary@qlogic.com>
Date:   Fri Aug 12 02:51:28 2011 -0700

    [SCSI] scsi: Added support for adapter and firmware reset
    
    Added new sysfs attr 'host_reset' in scsi_sysfs.c to
    perform adapter or firmware reset as suggested by
    Mike Christie here:
    http://marc.info/?l=linux-scsi&m=127359347111167&w=2
    
    user/application can write "adapter" or "firmware" on
    this attr and it will call newly added function hook
    in scsi_host_template to call LDD adapter or firmware
    reset implementation.
    
    Signed-off-by: Vikas Chaudhary <vikas.chaudhary@qlogic.com>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index f1f2644137b8..fc22ad9dba77 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -355,6 +355,19 @@ struct scsi_host_template {
 	 */
 	enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd *);
 
+	/* This is an optional routine that allows transport to initiate
+	 * LLD adapter or firmware reset using sysfs attribute.
+	 *
+	 * Return values: 0 on success, -ve value on failure.
+	 *
+	 * Status: OPTIONAL
+	 */
+
+	int (*host_reset)(struct Scsi_Host *shost, int reset_type);
+#define SCSI_ADAPTER_RESET	1
+#define SCSI_FIRMWARE_RESET	2
+
+
 	/*
 	 * Name of proc directory
 	 */

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index e7e385842a38..f1f2644137b8 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -46,7 +46,7 @@ struct blk_queue_tags;
 enum {
 	SCSI_QDEPTH_DEFAULT,	/* default requested change, e.g. from sysfs */
 	SCSI_QDEPTH_QFULL,	/* scsi-ml requested due to queue full */
-	SCSI_QDEPTH_RAMP_UP,	/* scsi-ml requested due to threshhold event */
+	SCSI_QDEPTH_RAMP_UP,	/* scsi-ml requested due to threshold event */
 };
 
 struct scsi_host_template {

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index d0a6a845f204..e7e385842a38 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -127,8 +127,7 @@ struct scsi_host_template {
 	 *
 	 * STATUS: REQUIRED
 	 */
-	int (* queuecommand)(struct scsi_cmnd *,
-			     void (*done)(struct scsi_cmnd *));
+	int (* queuecommand)(struct Scsi_Host *, struct scsi_cmnd *);
 
 	/*
 	 * The transfer functions are used to queue a scsi command to
@@ -504,6 +503,25 @@ struct scsi_host_template {
 	u64 vendor_id;
 };
 
+/*
+ * Temporary #define for host lock push down. Can be removed when all
+ * drivers have been updated to take advantage of unlocked
+ * queuecommand.
+ *
+ */
+#define DEF_SCSI_QCMD(func_name) \
+	int func_name(struct Scsi_Host *shost, struct scsi_cmnd *cmd)	\
+	{								\
+		unsigned long irq_flags;				\
+		int rc;							\
+		spin_lock_irqsave(shost->host_lock, irq_flags);		\
+		scsi_cmd_get_serial(shost, cmd);			\
+		rc = func_name##_lck (cmd, cmd->scsi_done);			\
+		spin_unlock_irqrestore(shost->host_lock, irq_flags);	\
+		return rc;						\
+	}
+
+
 /*
  * shost state: If you alter this, you also need to alter scsi_sysfs.c
  * (for the ascii descriptions) and the state model enforcer:
@@ -752,6 +770,7 @@ extern struct Scsi_Host *scsi_host_get(struct Scsi_Host *);
 extern void scsi_host_put(struct Scsi_Host *t);
 extern struct Scsi_Host *scsi_host_lookup(unsigned short);
 extern const char *scsi_host_state_name(enum scsi_host_state);
+extern void scsi_cmd_get_serial(struct Scsi_Host *, struct scsi_cmnd *);
 
 extern u64 scsi_calculate_bounce_limit(struct Scsi_Host *);
 

commit 13f05c8d8e98bbdce89158bfdb2e380940695a88
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Fri Sep 10 20:50:10 2010 +0200

    block/scsi: Provide a limit on the number of integrity segments
    
    Some controllers have a hardware limit on the number of protection
    information scatter-gather list segments they can handle.
    
    Introduce a max_integrity_segments limit in the block layer and provide
    a new scsi_host_template setting that allows HBA drivers to provide a
    value suitable for the hardware.
    
    Add support for honoring the integrity segment limit when merging both
    bios and requests.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jens Axboe <axboe@carl.home.kernel.dk>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index b7bdecb7b76e..d0a6a845f204 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -388,6 +388,7 @@ struct scsi_host_template {
 	 * of scatter-gather.
 	 */
 	unsigned short sg_tablesize;
+	unsigned short sg_prot_tablesize;
 
 	/*
 	 * Set this if the host adapter has limitations beside segment count.
@@ -599,6 +600,7 @@ struct Scsi_Host {
 	int can_queue;
 	short cmd_per_lun;
 	short unsigned int sg_tablesize;
+	short unsigned int sg_prot_tablesize;
 	short unsigned int max_sectors;
 	unsigned long dma_boundary;
 	/* 
@@ -823,6 +825,11 @@ static inline unsigned int scsi_host_get_prot(struct Scsi_Host *shost)
 	return shost->prot_capabilities;
 }
 
+static inline int scsi_host_prot_dma(struct Scsi_Host *shost)
+{
+	return shost->prot_capabilities >= SHOST_DIX_TYPE0_PROTECTION;
+}
+
 static inline unsigned int scsi_host_dif_capable(struct Scsi_Host *shost, unsigned int target_type)
 {
 	static unsigned char cap[] = { 0,

commit 72ec24bd7725545bc149d80cbd21a7578d9aa206
Author: Tejun Heo <tj@kernel.org>
Date:   Sat May 15 20:09:32 2010 +0200

    SCSI: implement sd_unlock_native_capacity()
    
    Implement sd_unlock_native_capacity() method which calls into
    hostt->unlock_native_capacity() if implemented.  This will be invoked
    by block layer if partitions extend beyond the end of the device and
    can be used to implement, for example, on-demand ATA host protected
    area unlocking.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index c50a97fc76f9..b7bdecb7b76e 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -326,6 +326,14 @@ struct scsi_host_template {
 	int (* bios_param)(struct scsi_device *, struct block_device *,
 			sector_t, int []);
 
+	/*
+	 * This function is called when one or more partitions on the
+	 * device reach beyond the end of the device.
+	 *
+	 * Status: OPTIONAL
+	 */
+	void (*unlock_native_capacity)(struct scsi_device *);
+
 	/*
 	 * Can be used to export driver statistics and other infos to the
 	 * world outside the kernel ie. userspace and it also provides an

commit 382f51fe2f2276344d8a21447656778cdf6583b6
Merge: 701791cc3c8f 54987386ee37
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 9 19:42:25 2009 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (222 commits)
      [SCSI] zfcp: Remove flag ZFCP_STATUS_FSFREQ_TMFUNCNOTSUPP
      [SCSI] zfcp: Activate fc4s attributes for zfcp in FC transport class
      [SCSI] zfcp: Block scsi_eh thread for rport state BLOCKED
      [SCSI] zfcp: Update FSF error reporting
      [SCSI] zfcp: Improve ELS ADISC handling
      [SCSI] zfcp: Simplify handling of ct and els requests
      [SCSI] zfcp: Remove ZFCP_DID_MASK
      [SCSI] zfcp: Move WKA port to zfcp FC code
      [SCSI] zfcp: Use common code definitions for FC CT structs
      [SCSI] zfcp: Use common code definitions for FC ELS structs
      [SCSI] zfcp: Update FCP protocol related code
      [SCSI] zfcp: Dont fail SCSI commands when transitioning to blocked fc_rport
      [SCSI] zfcp: Assign scheduled work to driver queue
      [SCSI] zfcp: Remove STATUS_COMMON_REMOVE flag as it is not required anymore
      [SCSI] zfcp: Implement module unloading
      [SCSI] zfcp: Merge trace code for fsf requests in one function
      [SCSI] zfcp: Access ports and units with container_of in sysfs code
      [SCSI] zfcp: Remove suspend callback
      [SCSI] zfcp: Remove global config_mutex
      [SCSI] zfcp: Replace local reference counting with common kref
      ...

commit d139b9bd0e52dda14fd13412e7096e68b56d0076
Author: James Bottomley <James.Bottomley@suse.de>
Date:   Thu Nov 5 13:33:12 2009 -0600

    [SCSI] scsi_lib_dma: fix bug with dma maps on nested scsi objects
    
    Some of our virtual SCSI hosts don't have a proper bus parent at the
    top, which can be a problem for doing DMA on them
    
    This patch makes the host device cache a pointer to the physical bus
    device and provides an extra API for setting it (the normal API picks
    it up from the parent).  This patch also modifies the qla2xxx and lpfc
    vport logic to use the new DMA host setting API.
    
    Acked-By: James Smart  <james.smart@emulex.com>
    Cc: Stable Tree <stable@kernel.org>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 603054d8f40c..6ff6bc18e294 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -682,6 +682,12 @@ struct Scsi_Host {
 	 */
 	void *shost_data;
 
+	/*
+	 * Points to the physical bus device we'd use to do DMA
+	 * Needed just in case we have virtual hosts.
+	 */
+	struct device *dma_dev;
+
 	/*
 	 * We should ensure that this is aligned, both for better performance
 	 * and also because some compilers (m68k) don't automatically force
@@ -726,7 +732,9 @@ extern int scsi_queue_work(struct Scsi_Host *, struct work_struct *);
 extern void scsi_flush_work(struct Scsi_Host *);
 
 extern struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *, int);
-extern int __must_check scsi_add_host(struct Scsi_Host *, struct device *);
+extern int __must_check scsi_add_host_with_dma(struct Scsi_Host *,
+					       struct device *,
+					       struct device *);
 extern void scsi_scan_host(struct Scsi_Host *);
 extern void scsi_rescan_device(struct device *);
 extern void scsi_remove_host(struct Scsi_Host *);
@@ -737,6 +745,12 @@ extern const char *scsi_host_state_name(enum scsi_host_state);
 
 extern u64 scsi_calculate_bounce_limit(struct Scsi_Host *);
 
+static inline int __must_check scsi_add_host(struct Scsi_Host *host,
+					     struct device *dev)
+{
+	return scsi_add_host_with_dma(host, dev, dev);
+}
+
 static inline struct device *scsi_get_device(struct Scsi_Host *shost)
 {
         return shost->shost_gendev.parent;

commit e881a172dac4d9ea3b2a1540041d872963c269bd
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Oct 15 17:46:39 2009 -0700

    [SCSI] modify change_queue_depth to take in reason why it is being called
    
    This patch modifies scsi_host_template->change_queue_depth so that
    it takes an argument indicating why it is being called. This will be
    used so that if a LLD needs to do some extra processing when
    handling queue fulls or later ramp ups, it can do so.
    
    This is a simple port of the drivers setting a change_queue_depth
    callback. In the patch I just have these LLDs adjust the queue depth
    if the user was requesting it.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    
    [Vasu.Dev: v2
            Also converted pmcraid_change_queue_depth and then verified
    all modules compile  using "make allmodconfig" for any new build
    warnings on X86_64.
    
            Updated original description after combing two original
    patches from Mike to make this patch git bisectable.]
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    [jejb: fixed up 53c700]
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 6e728b176904..603054d8f40c 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -43,6 +43,12 @@ struct blk_queue_tags;
 #define DISABLE_CLUSTERING 0
 #define ENABLE_CLUSTERING 1
 
+enum {
+	SCSI_QDEPTH_DEFAULT,	/* default requested change, e.g. from sysfs */
+	SCSI_QDEPTH_QFULL,	/* scsi-ml requested due to queue full */
+	SCSI_QDEPTH_RAMP_UP,	/* scsi-ml requested due to threshhold event */
+};
+
 struct scsi_host_template {
 	struct module *module;
 	const char *name;
@@ -294,7 +300,7 @@ struct scsi_host_template {
 	 *
 	 * Status: OPTIONAL
 	 */
-	int (* change_queue_depth)(struct scsi_device *, int);
+	int (* change_queue_depth)(struct scsi_device *, int, int);
 
 	/*
 	 * Fill in this function to allow the changing of tag types

commit b2b465e9280b739a528435d2916c0a5c1b4eb100
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Thu Oct 29 22:32:26 2009 -0400

    [SCSI] Fix incorrect reporting of host protection capabilities
    
    The advent of DIF Type 2 devices exposed some missing break statements
    in the protection mask switch constructs.  However, rewriting the code
    to use an index into a small static array seemed like a more elegant
    solution.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 6e728b176904..47941fc5aba7 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -797,30 +797,23 @@ static inline unsigned int scsi_host_get_prot(struct Scsi_Host *shost)
 
 static inline unsigned int scsi_host_dif_capable(struct Scsi_Host *shost, unsigned int target_type)
 {
-	switch (target_type) {
-	case 1:
-		if (shost->prot_capabilities & SHOST_DIF_TYPE1_PROTECTION)
-			return target_type;
-	case 2:
-		if (shost->prot_capabilities & SHOST_DIF_TYPE2_PROTECTION)
-			return target_type;
-	case 3:
-		if (shost->prot_capabilities & SHOST_DIF_TYPE3_PROTECTION)
-			return target_type;
-	}
+	static unsigned char cap[] = { 0,
+				       SHOST_DIF_TYPE1_PROTECTION,
+				       SHOST_DIF_TYPE2_PROTECTION,
+				       SHOST_DIF_TYPE3_PROTECTION };
 
-	return 0;
+	return shost->prot_capabilities & cap[target_type] ? target_type : 0;
 }
 
 static inline unsigned int scsi_host_dix_capable(struct Scsi_Host *shost, unsigned int target_type)
 {
 #if defined(CONFIG_BLK_DEV_INTEGRITY)
-	switch (target_type) {
-	case 0: return shost->prot_capabilities & SHOST_DIX_TYPE0_PROTECTION;
-	case 1: return shost->prot_capabilities & SHOST_DIX_TYPE1_PROTECTION;
-	case 2: return shost->prot_capabilities & SHOST_DIX_TYPE2_PROTECTION;
-	case 3: return shost->prot_capabilities & SHOST_DIX_TYPE3_PROTECTION;
-	}
+	static unsigned char cap[] = { SHOST_DIX_TYPE0_PROTECTION,
+				       SHOST_DIX_TYPE1_PROTECTION,
+				       SHOST_DIX_TYPE2_PROTECTION,
+				       SHOST_DIX_TYPE3_PROTECTION };
+
+	return shost->prot_capabilities & cap[target_type];
 #endif
 	return 0;
 }

commit 35e1a5d90b66487d754ef2f2dcbf1007f806d921
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Fri Sep 18 17:33:00 2009 -0400

    [SCSI] sd: Detach DIF from block integrity infrastructure
    
    So far we have only issued DIF commands if CONFIG_BLK_DEV_INTEGRITY is
    enabled.  However, communication between initiator and target should be
    independent of protection information DMA.  There are DIF-only host
    adapters coming out that will be able to take advantage of this.
    
    Move the relevant DIF bits to sd.c.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index b62a097b3ecb..6e728b176904 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -798,9 +798,15 @@ static inline unsigned int scsi_host_get_prot(struct Scsi_Host *shost)
 static inline unsigned int scsi_host_dif_capable(struct Scsi_Host *shost, unsigned int target_type)
 {
 	switch (target_type) {
-	case 1: return shost->prot_capabilities & SHOST_DIF_TYPE1_PROTECTION;
-	case 2: return shost->prot_capabilities & SHOST_DIF_TYPE2_PROTECTION;
-	case 3: return shost->prot_capabilities & SHOST_DIF_TYPE3_PROTECTION;
+	case 1:
+		if (shost->prot_capabilities & SHOST_DIF_TYPE1_PROTECTION)
+			return target_type;
+	case 2:
+		if (shost->prot_capabilities & SHOST_DIF_TYPE2_PROTECTION)
+			return target_type;
+	case 3:
+		if (shost->prot_capabilities & SHOST_DIF_TYPE3_PROTECTION)
+			return target_type;
 	}
 
 	return 0;
@@ -808,13 +814,14 @@ static inline unsigned int scsi_host_dif_capable(struct Scsi_Host *shost, unsign
 
 static inline unsigned int scsi_host_dix_capable(struct Scsi_Host *shost, unsigned int target_type)
 {
+#if defined(CONFIG_BLK_DEV_INTEGRITY)
 	switch (target_type) {
 	case 0: return shost->prot_capabilities & SHOST_DIX_TYPE0_PROTECTION;
 	case 1: return shost->prot_capabilities & SHOST_DIX_TYPE1_PROTECTION;
 	case 2: return shost->prot_capabilities & SHOST_DIX_TYPE2_PROTECTION;
 	case 3: return shost->prot_capabilities & SHOST_DIX_TYPE3_PROTECTION;
 	}
-
+#endif
 	return 0;
 }
 

commit 9e4f5e29610162fd426366f3b29e3cc6e575b858
Author: James Smart <James.Smart@Emulex.Com>
Date:   Thu Mar 26 13:33:19 2009 -0400

    [SCSI] FC Pass Thru support
    
    Attached is the ELS/CT pass-thru patch for the FC Transport. The patch
    creates a generic framework that lays on top of bsg and the SGIO v4 ioctl
    in order to pass transaction requests to LLDD's.
    
    The interface supports the following operations:
      On an fc_host basis:
        Request login to the specified N_Port_ID, creating an fc_rport.
        Request logout of the specified N_Port_ID, deleting an fc_rport
        Send ELS request to specified N_Port_ID w/o requiring a login, and
          wait for ELS response.
        Send CT request to specified N_Port_ID and wait for CT response.
          Login is required, but LLDD is allowed to manage login and decide
          whether it stays in place after the request is satisfied.
        Vendor-Unique request. Allows a LLDD-specific request to be passed
          to the LLDD, and the passing of a response back to the application.
      On an fc_rport basis:
        Send ELS request to nport and wait for ELS response.
        Send CT request to nport and wait for CT response.
    
    The patch also exports several headers from include/scsi such that
    they can be available to user-space applications:
      include/scsi/scsi.h
      include/scsi/scsi_netlink.h
      include/scsi/scsi_netlink_fc.h
      include/scsi/scsi_bsg_fc.h
    
    For further information, refer to the last RFC:
    http://marc.info/?l=linux-scsi&m=123436574018579&w=2
    
    Note: Documentation is still spotty and will be added later.
    
    [bharrosh@panasas.com: update for new block API]
    Signed-off-by: James Smart <james.smart@emulex.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index d123ca84e732..b62a097b3ecb 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -478,6 +478,15 @@ struct scsi_host_template {
 	 * module_init/module_exit.
 	 */
 	struct list_head legacy_hosts;
+
+	/*
+	 * Vendor Identifier associated with the host
+	 *
+	 * Note: When specifying vendor_id, be sure to read the
+	 *   Vendor Type and ID formatting requirements specified in
+	 *   scsi_netlink.h
+	 */
+	u64 vendor_id;
 };
 
 /*

commit 242f9dcb8ba6f68fcd217a119a7648a4f69290e9
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Sun Sep 14 05:55:09 2008 -0700

    block: unify request timeout handling
    
    Right now SCSI and others do their own command timeout handling.
    Move those bits to the block layer.
    
    Instead of having a timer per command, we try to be a bit more clever
    and simply have one per-queue. This avoids the overhead of having to
    tear down and setup a timer for each command, so it will result in a lot
    less timer fiddling.
    
    Signed-off-by: Mike Anderson <andmike@linux.vnet.ibm.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 44a55d1bf530..d123ca84e732 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -43,13 +43,6 @@ struct blk_queue_tags;
 #define DISABLE_CLUSTERING 0
 #define ENABLE_CLUSTERING 1
 
-enum scsi_eh_timer_return {
-	EH_NOT_HANDLED,
-	EH_HANDLED,
-	EH_RESET_TIMER,
-};
-
-
 struct scsi_host_template {
 	struct module *module;
 	const char *name;
@@ -347,7 +340,7 @@ struct scsi_host_template {
 	 *
 	 * Status: OPTIONAL
 	 */
-	enum scsi_eh_timer_return (* eh_timed_out)(struct scsi_cmnd *);
+	enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd *);
 
 	/*
 	 * Name of proc directory

commit 4469f9878059f1707f021512e6b34252c4096ee7
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Thu Jul 17 04:28:30 2008 -0400

    [SCSI] Host protection capabilities
    
    Controllers that support protection information must indicate this to
    the SCSI midlayer so that the ULD can prepare scsi_cmnds accordingly.
    
    This patch implements a host mask and various types of protection:
    
     - DIF Type 1-3 (between HBA and disk)
     - DIX Type 0-3 (between OS and HBA)
    
    The patch also allows the HBA to set the guard type to something
    different than the T10-mandated CRC.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index d3b1e06fb142..44a55d1bf530 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -636,6 +636,10 @@ struct Scsi_Host {
 	 */
 	unsigned int max_host_blocked;
 
+	/* Protection Information */
+	unsigned int prot_capabilities;
+	unsigned char prot_guard_type;
+
 	/*
 	 * q used for scsi_tgt msgs, async events or any other requests that
 	 * need to be processed in userspace
@@ -756,6 +760,86 @@ extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
 extern void scsi_free_host_dev(struct scsi_device *);
 extern struct scsi_device *scsi_get_host_dev(struct Scsi_Host *);
 
+/*
+ * DIF defines the exchange of protection information between
+ * initiator and SBC block device.
+ *
+ * DIX defines the exchange of protection information between OS and
+ * initiator.
+ */
+enum scsi_host_prot_capabilities {
+	SHOST_DIF_TYPE1_PROTECTION = 1 << 0, /* T10 DIF Type 1 */
+	SHOST_DIF_TYPE2_PROTECTION = 1 << 1, /* T10 DIF Type 2 */
+	SHOST_DIF_TYPE3_PROTECTION = 1 << 2, /* T10 DIF Type 3 */
+
+	SHOST_DIX_TYPE0_PROTECTION = 1 << 3, /* DIX between OS and HBA only */
+	SHOST_DIX_TYPE1_PROTECTION = 1 << 4, /* DIX with DIF Type 1 */
+	SHOST_DIX_TYPE2_PROTECTION = 1 << 5, /* DIX with DIF Type 2 */
+	SHOST_DIX_TYPE3_PROTECTION = 1 << 6, /* DIX with DIF Type 3 */
+};
+
+/*
+ * SCSI hosts which support the Data Integrity Extensions must
+ * indicate their capabilities by setting the prot_capabilities using
+ * this call.
+ */
+static inline void scsi_host_set_prot(struct Scsi_Host *shost, unsigned int mask)
+{
+	shost->prot_capabilities = mask;
+}
+
+static inline unsigned int scsi_host_get_prot(struct Scsi_Host *shost)
+{
+	return shost->prot_capabilities;
+}
+
+static inline unsigned int scsi_host_dif_capable(struct Scsi_Host *shost, unsigned int target_type)
+{
+	switch (target_type) {
+	case 1: return shost->prot_capabilities & SHOST_DIF_TYPE1_PROTECTION;
+	case 2: return shost->prot_capabilities & SHOST_DIF_TYPE2_PROTECTION;
+	case 3: return shost->prot_capabilities & SHOST_DIF_TYPE3_PROTECTION;
+	}
+
+	return 0;
+}
+
+static inline unsigned int scsi_host_dix_capable(struct Scsi_Host *shost, unsigned int target_type)
+{
+	switch (target_type) {
+	case 0: return shost->prot_capabilities & SHOST_DIX_TYPE0_PROTECTION;
+	case 1: return shost->prot_capabilities & SHOST_DIX_TYPE1_PROTECTION;
+	case 2: return shost->prot_capabilities & SHOST_DIX_TYPE2_PROTECTION;
+	case 3: return shost->prot_capabilities & SHOST_DIX_TYPE3_PROTECTION;
+	}
+
+	return 0;
+}
+
+/*
+ * All DIX-capable initiators must support the T10-mandated CRC
+ * checksum.  Controllers can optionally implement the IP checksum
+ * scheme which has much lower impact on system performance.  Note
+ * that the main rationale for the checksum is to match integrity
+ * metadata with data.  Detecting bit errors are a job for ECC memory
+ * and buses.
+ */
+
+enum scsi_host_guard_type {
+	SHOST_DIX_GUARD_CRC = 1 << 0,
+	SHOST_DIX_GUARD_IP  = 1 << 1,
+};
+
+static inline void scsi_host_set_guard(struct Scsi_Host *shost, unsigned char type)
+{
+	shost->prot_guard_type = type;
+}
+
+static inline unsigned char scsi_host_get_guard(struct Scsi_Host *shost)
+{
+	return shost->prot_guard_type;
+}
+
 /* legacy interfaces */
 extern struct Scsi_Host *scsi_register(struct scsi_host_template *, int);
 extern void scsi_unregister(struct Scsi_Host *);

commit 6d49f63b415ca02223e01e187076cb69a5a38eaf
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Jul 15 14:54:16 2008 -0600

    [SCSI] Make host_no an unsigned int
    
    Daniel Debonzi reports that he has managed to wrap host_no.  Increasing
    the number of host numbers available to 32-bit from 16-bit allows the
    problem to be evaded for another hundred years.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index a594bac4a77d..d3b1e06fb142 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -547,7 +547,7 @@ struct Scsi_Host {
 	unsigned int host_failed;	   /* commands that failed. */
 	unsigned int host_eh_scheduled;    /* EH scheduled without command */
     
-	unsigned short host_no;  /* Used for IOCTL_GET_IDLUN, /proc/scsi et al. */
+	unsigned int host_no;  /* Used for IOCTL_GET_IDLUN, /proc/scsi et al. */
 	int resetting; /* if set, it means that last_reset is a valid value */
 	unsigned long last_reset;
 

commit aab0de245150c09e61c30962feb16aacde508dc3
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri May 2 06:02:41 2008 +0200

    driver core: remove KOBJ_NAME_LEN define
    
    Kobjects do not have a limit in name size since a while, so stop
    pretending that they do.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 1834fdfe82a7..a594bac4a77d 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -623,7 +623,7 @@ struct Scsi_Host {
 	/*
 	 * Optional work queue to be utilized by the transport
 	 */
-	char work_q_name[KOBJ_NAME_LEN];
+	char work_q_name[20];
 	struct workqueue_struct *work_q;
 
 	/*

commit db4742dd8f0aa9125b74f9b2516336a75f3d9106
Author: Boaz Harrosh <bharrosh@panasas.com>
Date:   Wed Apr 30 11:27:26 2008 +0300

    [SCSI] add support for variable length extended commands
    
    Add support for variable-length, extended, and vendor specific
    CDBs to scsi-ml. It is now possible for initiators and ULD's
    to issue these types of commands. LLDs need not change much.
    All they need is to raise the .max_cmd_len to the longest command
    they support (see iscsi patch).
    
    - clean-up some code paths that did not expect commands to be
      larger than 16, and change cmd_len members' type to short as
      char is not enough.
    
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index d967d6dc7a28..1834fdfe82a7 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -573,13 +573,11 @@ struct Scsi_Host {
 	/*
 	 * The maximum length of SCSI commands that this host can accept.
 	 * Probably 12 for most host adapters, but could be 16 for others.
+	 * or 260 if the driver supports variable length cdbs.
 	 * For drivers that don't set this field, a value of 12 is
-	 * assumed.  I am leaving this as a number rather than a bit
-	 * because you never know what subsequent SCSI standards might do
-	 * (i.e. could there be a 20 byte or a 24-byte command a few years
-	 * down the road?).  
+	 * assumed.
 	 */
-	unsigned char max_cmd_len;
+	unsigned short max_cmd_len;
 
 	int this_id;
 	int can_queue;

commit ee959b00c335d7780136c5abda37809191fe52c3
Author: Tony Jones <tonyj@suse.de>
Date:   Fri Feb 22 00:13:36 2008 +0100

    SCSI: convert struct class_device to struct device
    
    It's big, but there doesn't seem to be a way to split it up smaller...
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Roland Dreier <rolandd@cisco.com>
    Cc: Sean Hefty <sean.hefty@intel.com>
    Cc: Hal Rosenstock <hal.rosenstock@gmail.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 49132862bfaa..d967d6dc7a28 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -470,7 +470,7 @@ struct scsi_host_template {
 	/*
 	 * Pointer to the sysfs class properties for this host, NULL terminated.
 	 */
-	struct class_device_attribute **shost_attrs;
+	struct device_attribute **shost_attrs;
 
 	/*
 	 * Pointer to the SCSI device properties for this host, NULL terminated.
@@ -655,8 +655,7 @@ struct Scsi_Host {
 	enum scsi_host_state shost_state;
 
 	/* ldm bits */
-	struct device		shost_gendev;
-	struct class_device	shost_classdev;
+	struct device		shost_gendev, shost_dev;
 
 	/*
 	 * List of hosts per template.
@@ -683,7 +682,7 @@ struct Scsi_Host {
 };
 
 #define		class_to_shost(d)	\
-	container_of(d, struct Scsi_Host, shost_classdev)
+	container_of(d, struct Scsi_Host, shost_dev)
 
 #define shost_printk(prefix, shost, fmt, a...)	\
 	dev_printk(prefix, &(shost)->shost_gendev, fmt, ##a)

commit 30bd7df8ced23eefec87a5cda96dc99b002ed9da
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Fri Feb 29 18:25:19 2008 -0600

    [SCSI] scsi_error: add target reset handler
    
    The problem is that serveral drivers are sending a target reset from the
    device reset handler, and if we have multiple devices a target reset gets
    sent for each device when only one would be sufficient. And if we do a target
    reset it affects all the commands on the target so the device reset handler
    code only cleaning up one devices's commands makes programming the driver a
    little more difficult than it should be.
    
    This patch adds a target reset handler, which drivers can use to send
    a target reset. If successful it cleans up the commands for a devices
    accessed through that starget.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 530ff4c553f8..49132862bfaa 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -172,6 +172,7 @@ struct scsi_host_template {
 	 */
 	int (* eh_abort_handler)(struct scsi_cmnd *);
 	int (* eh_device_reset_handler)(struct scsi_cmnd *);
+	int (* eh_target_reset_handler)(struct scsi_cmnd *);
 	int (* eh_bus_reset_handler)(struct scsi_cmnd *);
 	int (* eh_host_reset_handler)(struct scsi_cmnd *);
 

commit 4660c8ed5aaed99d82785499f034a8cc9199866d
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Sun Feb 10 09:42:46 2008 -0600

    [SCSI] update SG_ALL to avoid causing chaining
    
    Since the sg chaining patches went in, our current value of 255 for
    SG_ALL excites chaining on some drivers which cannot support it (and
    would thus oops).  Redefine SG_ALL to mean no sg table size
    preference, but use the single allocation (non chained) limit.  This
    also helps for drivers that use it to size an internal table.
    
    We'll do an opt in system later where truly chaining supporting
    drivers can define their sg_tablesize to be anything up to
    SCSI_MAX_SG_CHAIN_ELEMENTS.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index d1299e999723..530ff4c553f8 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -6,6 +6,7 @@
 #include <linux/types.h>
 #include <linux/workqueue.h>
 #include <linux/mutex.h>
+#include <scsi/scsi.h>
 
 struct request_queue;
 struct block_device;
@@ -25,12 +26,15 @@ struct blk_queue_tags;
  * NONE: Self evident.	Host adapter is not capable of scatter-gather.
  * ALL:	 Means that the host adapter module can do scatter-gather,
  *	 and that there is no limit to the size of the table to which
- *	 we scatter/gather data.
+ *	 we scatter/gather data.  The value we set here is the maximum
+ *	 single element sglist.  To use chained sglists, the adapter
+ *	 has to set a value beyond ALL (and correctly use the chain
+ *	 handling API.
  * Anything else:  Indicates the maximum number of chains that can be
  *	 used in one scatter-gather request.
  */
 #define SG_NONE 0
-#define SG_ALL 0xff
+#define SG_ALL	SCSI_MAX_SG_SEGMENTS
 
 #define MODE_UNKNOWN 0x00
 #define MODE_INITIATOR 0x01

commit d850bd34f5b2a52ccec90188ad86165f940693e9
Author: Pavel Machek <pavel@ucw.cz>
Date:   Mon Feb 4 23:53:24 2008 -0800

    [SCSI] Small cleanups for scsi_host.h
    
    Small cleanups in scsi_host.h. Few #defines make me wonder if their
    description is still up to date..?
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 5c58d594126a..d1299e999723 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -280,39 +280,45 @@ struct scsi_host_template {
 	 * If the host wants to be called before the scan starts, but
 	 * after the midlayer has set up ready for the scan, it can fill
 	 * in this function.
+	 *
+	 * Status: OPTIONAL
 	 */
 	void (* scan_start)(struct Scsi_Host *);
 
 	/*
-	 * fill in this function to allow the queue depth of this host
-	 * to be changeable (on a per device basis).  returns either
+	 * Fill in this function to allow the queue depth of this host
+	 * to be changeable (on a per device basis).  Returns either
 	 * the current queue depth setting (may be different from what
 	 * was passed in) or an error.  An error should only be
 	 * returned if the requested depth is legal but the driver was
 	 * unable to set it.  If the requested depth is illegal, the
 	 * driver should set and return the closest legal queue depth.
 	 *
+	 * Status: OPTIONAL
 	 */
 	int (* change_queue_depth)(struct scsi_device *, int);
 
 	/*
-	 * fill in this function to allow the changing of tag types
+	 * Fill in this function to allow the changing of tag types
 	 * (this also allows the enabling/disabling of tag command
 	 * queueing).  An error should only be returned if something
 	 * went wrong in the driver while trying to set the tag type.
 	 * If the driver doesn't support the requested tag type, then
 	 * it should set the closest type it does support without
 	 * returning an error.  Returns the actual tag type set.
+	 *
+	 * Status: OPTIONAL
 	 */
 	int (* change_queue_type)(struct scsi_device *, int);
 
 	/*
-	 * This function determines the bios parameters for a given
+	 * This function determines the BIOS parameters for a given
 	 * harddisk.  These tend to be numbers that are made up by
 	 * the host adapter.  Parameters:
 	 * size, device, list (heads, sectors, cylinders)
 	 *
-	 * Status: OPTIONAL */
+	 * Status: OPTIONAL
+	 */
 	int (* bios_param)(struct scsi_device *, struct block_device *,
 			sector_t, int []);
 
@@ -351,7 +357,7 @@ struct scsi_host_template {
 
 	/*
 	 * This determines if we will use a non-interrupt driven
-	 * or an interrupt driven scheme,  It is set to the maximum number
+	 * or an interrupt driven scheme.  It is set to the maximum number
 	 * of simultaneous commands a given host adapter will accept.
 	 */
 	int can_queue;
@@ -372,12 +378,12 @@ struct scsi_host_template {
 	unsigned short sg_tablesize;
 
 	/*
-	 * If the host adapter has limitations beside segment count
+	 * Set this if the host adapter has limitations beside segment count.
 	 */
 	unsigned short max_sectors;
 
 	/*
-	 * dma scatter gather segment boundary limit. a segment crossing this
+	 * DMA scatter gather segment boundary limit. A segment crossing this
 	 * boundary will be split in two.
 	 */
 	unsigned long dma_boundary;
@@ -386,7 +392,7 @@ struct scsi_host_template {
 	 * This specifies "machine infinity" for host templates which don't
 	 * limit the transfer size.  Note this limit represents an absolute
 	 * maximum, and may be over the transfer limits allowed for
-	 * individual devices (e.g. 256 for SCSI-1)
+	 * individual devices (e.g. 256 for SCSI-1).
 	 */
 #define SCSI_DEFAULT_MAX_SECTORS	1024
 
@@ -413,12 +419,12 @@ struct scsi_host_template {
 	unsigned supported_mode:2;
 
 	/*
-	 * true if this host adapter uses unchecked DMA onto an ISA bus.
+	 * True if this host adapter uses unchecked DMA onto an ISA bus.
 	 */
 	unsigned unchecked_isa_dma:1;
 
 	/*
-	 * true if this host adapter can make good use of clustering.
+	 * True if this host adapter can make good use of clustering.
 	 * I originally thought that if the tablesize was large that it
 	 * was a waste of CPU cycles to prepare a cluster list, but
 	 * it works out that the Buslogic is faster if you use a smaller
@@ -428,7 +434,7 @@ struct scsi_host_template {
 	unsigned use_clustering:1;
 
 	/*
-	 * True for emulated SCSI host adapters (e.g. ATAPI)
+	 * True for emulated SCSI host adapters (e.g. ATAPI).
 	 */
 	unsigned emulated:1;
 
@@ -438,12 +444,12 @@ struct scsi_host_template {
 	unsigned skip_settle_delay:1;
 
 	/*
-	 * ordered write support
+	 * True if we are using ordered write support.
 	 */
 	unsigned ordered_tag:1;
 
 	/*
-	 * Countdown for host blocking with no commands outstanding
+	 * Countdown for host blocking with no commands outstanding.
 	 */
 	unsigned int max_host_blocked;
 
@@ -522,8 +528,8 @@ struct Scsi_Host {
 	struct scsi_transport_template *transportt;
 
 	/*
-	 * area to keep a shared tag map (if needed, will be
-	 * NULL if not)
+	 * Area to keep a shared tag map (if needed, will be
+	 * NULL if not).
 	 */
 	struct blk_queue_tag	*bqt;
 
@@ -596,16 +602,16 @@ struct Scsi_Host {
 	/*
 	 * Host uses correct SCSI ordering not PC ordering. The bit is
 	 * set for the minority of drivers whose authors actually read
-	 * the spec ;)
+	 * the spec ;).
 	 */
 	unsigned reverse_ordering:1;
 
 	/*
-	 * ordered write support
+	 * Ordered write support
 	 */
 	unsigned ordered_tag:1;
 
-	/* task mgmt function in progress */
+	/* Task mgmt function in progress */
 	unsigned tmf_in_progress:1;
 
 	/* Asynchronous scan in progress */

commit d3f46f39b7092594b498abc12f0c73b0b9913bde
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Jan 15 11:11:46 2008 -0600

    [SCSI] remove use_sg_chaining
    
    With the sg table code, every SCSI driver is now either chain capable
    or broken (or has sg_tablesize set so chaining is never activated), so
    there's no need to have a check in the host template.
    
    Also tidy up the code by moving the scatterlist size defines into the
    SCSI includes and permit the last entry of the scatterlist pools not
    to be a power of two.
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index cb2bcab41dfb..5c58d594126a 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -39,9 +39,6 @@ struct blk_queue_tags;
 #define DISABLE_CLUSTERING 0
 #define ENABLE_CLUSTERING 1
 
-#define DISABLE_SG_CHAINING 0
-#define ENABLE_SG_CHAINING 1
-
 enum scsi_eh_timer_return {
 	EH_NOT_HANDLED,
 	EH_HANDLED,
@@ -445,15 +442,6 @@ struct scsi_host_template {
 	 */
 	unsigned ordered_tag:1;
 
-	/*
-	 * true if the low-level driver can support sg chaining. this
-	 * will be removed eventually when all the drivers are
-	 * converted to support sg chaining.
-	 *
-	 * Status: OBSOLETE
-	 */
-	unsigned use_sg_chaining:1;
-
 	/*
 	 * Countdown for host blocking with no commands outstanding
 	 */
@@ -598,7 +586,6 @@ struct Scsi_Host {
 	unsigned unchecked_isa_dma:1;
 	unsigned use_clustering:1;
 	unsigned use_blk_tcq:1;
-	unsigned use_sg_chaining:1;
 
 	/*
 	 * Host has requested that no further requests come through for the

commit 30b0c37b27485a9cb897bfe3824f6f517b8c80d6
Author: Boaz Harrosh <bharrosh@panasas.com>
Date:   Thu Dec 13 13:47:40 2007 +0200

    [SCSI] implement scsi_data_buffer
    
    In preparation for bidi we abstract all IO members of scsi_cmnd,
    that will need to duplicate, into a substructure.
    
    - Group all IO members of scsi_cmnd into a scsi_data_buffer
      structure.
    - Adjust accessors to new members.
    - scsi_{alloc,free}_sgtable receive a scsi_data_buffer instead of
      scsi_cmnd. And work on it.
    - Adjust scsi_init_io() and  scsi_release_buffers() for above
      change.
    - Fix other parts of scsi_lib/scsi.c to members migration. Use
      accessors where appropriate.
    
    - fix Documentation about scsi_cmnd in scsi_host.h
    
    - scsi_error.c
      * Changed needed members of struct scsi_eh_save.
      * Careful considerations in scsi_eh_prep/restore_cmnd.
    
    - sd.c and sr.c
      * sd and sr would adjust IO size to align on device's block
        size so code needs to change once we move to scsi_data_buff
        implementation.
      * Convert code to use scsi_for_each_sg
      * Use data accessors where appropriate.
    
    - tgt: convert libsrp to use scsi_data_buffer
    
    - isd200: This driver still bangs on scsi_cmnd IO members,
      so need changing
    
    [jejb: rebased on top of sg_table patches fixed up conflicts
    and used the synergy to eliminate use_sg and sg_count]
    
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 0fd4746ee39d..cb2bcab41dfb 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -136,9 +136,9 @@ struct scsi_host_template {
 	 * the done callback is invoked.
 	 *
 	 * This is called to inform the LLD to transfer
-	 * cmd->request_bufflen bytes. The cmd->use_sg speciefies the
+	 * scsi_bufflen(cmd) bytes. scsi_sg_count(cmd) speciefies the
 	 * number of scatterlist entried in the command and
-	 * cmd->request_buffer contains the scatterlist.
+	 * scsi_sglist(cmd) returns the scatterlist.
 	 *
 	 * return values: see queuecommand
 	 *

commit 9cb83c7529d929c00f37d821daed1942a1b20602
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Tue Oct 16 11:24:32 2007 +0200

    [SCSI] add use_sg_chaining option to scsi_host_template
    
    This option is true if a low-level driver can support sg
    chaining. This will be removed eventually when all the drivers are
    converted to support sg chaining. q->max_phys_segments is set to
    SCSI_MAX_SG_SEGMENTS if false.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 7d210cd6c38d..0fd4746ee39d 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -39,6 +39,9 @@ struct blk_queue_tags;
 #define DISABLE_CLUSTERING 0
 #define ENABLE_CLUSTERING 1
 
+#define DISABLE_SG_CHAINING 0
+#define ENABLE_SG_CHAINING 1
+
 enum scsi_eh_timer_return {
 	EH_NOT_HANDLED,
 	EH_HANDLED,
@@ -442,6 +445,15 @@ struct scsi_host_template {
 	 */
 	unsigned ordered_tag:1;
 
+	/*
+	 * true if the low-level driver can support sg chaining. this
+	 * will be removed eventually when all the drivers are
+	 * converted to support sg chaining.
+	 *
+	 * Status: OBSOLETE
+	 */
+	unsigned use_sg_chaining:1;
+
 	/*
 	 * Countdown for host blocking with no commands outstanding
 	 */
@@ -586,6 +598,7 @@ struct Scsi_Host {
 	unsigned unchecked_isa_dma:1;
 	unsigned use_clustering:1;
 	unsigned use_blk_tcq:1;
+	unsigned use_sg_chaining:1;
 
 	/*
 	 * Host has requested that no further requests come through for the

commit 12a441622b753684cc73d1c6f225e9ac53e0bf77
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Sep 18 19:54:43 2007 -0600

    [SCSI] Remove ->pid field from scsi_cmnd
    
    The pid field is a duplicate of the serial_number field and has been
    scheduled for removal for a long time.  A few drivers were still using
    it, so just change them to use serial_number instead.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 5b79697a3a80..7d210cd6c38d 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -580,7 +580,7 @@ struct Scsi_Host {
 	 * Used to assign serial numbers to the cmds.
 	 * Protected by the host lock.
 	 */
-	unsigned long cmd_serial_number, cmd_pid; 
+	unsigned long cmd_serial_number;
 	
 	unsigned active_mode:2;
 	unsigned unchecked_isa_dma:1;

commit 5dc2b89e124251662f580f4ba3c9f6195d1eaff6
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Sat Sep 1 02:02:20 2007 +0900

    [SCSI] add supported_mode and active_mode attributes to the host
    
    This adds supported_mode and active_mode attributes to
    /sys/class/sys_host/hostX/ for specifying the mode that a lld supports
    and the currently activated mode. The output format is similar to fc
    rport roles:
    
    luce:/sys/class/scsi_host/host0$ cat supported_mode
    Initiator
    luce:/sys/class/scsi_host/host0$ cat active_mode
    Initiator
    
    The mode values uses bitmap since we would support dual-mode llds in
    the future like this:
    
    luce:/sys/class/scsi_host/host0$ cat supported_mode
    Initiator, Target
    
    The supported_mode attribute looks at a scsi_host_template and the
    active_mode attribute looks at a scsi_host. We would add a hook to a
    scsi_host_template to change the active_mode attribute
    dynamically. But now there is no hook since no lld supports that
    feature.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 88f6871badd8..5b79697a3a80 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -32,6 +32,9 @@ struct blk_queue_tags;
 #define SG_NONE 0
 #define SG_ALL 0xff
 
+#define MODE_UNKNOWN 0x00
+#define MODE_INITIATOR 0x01
+#define MODE_TARGET 0x02
 
 #define DISABLE_CLUSTERING 0
 #define ENABLE_CLUSTERING 1
@@ -404,6 +407,11 @@ struct scsi_host_template {
 	 */
 	unsigned char present;
 
+	/*
+	 * This specifies the mode that a LLD supports.
+	 */
+	unsigned supported_mode:2;
+
 	/*
 	 * true if this host adapter uses unchecked DMA onto an ISA bus.
 	 */
@@ -574,6 +582,7 @@ struct Scsi_Host {
 	 */
 	unsigned long cmd_serial_number, cmd_pid; 
 	
+	unsigned active_mode:2;
 	unsigned unchecked_isa_dma:1;
 	unsigned use_clustering:1;
 	unsigned use_blk_tcq:1;

commit bfb743740e1598d3030c4972a8808f2bb5b95b6b
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Wed Jul 11 15:08:22 2007 +0900

    [SCSI] tgt: move tsk_mgmt_response callback to transport class
    
    This moves tsk_mgmt_response callback in struct scsi_host_template to
    struct scsi_transport_template since struct scsi_transport_template is
    more suitable for the task management stuff.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 89c40c4bd5c4..88f6871badd8 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -145,9 +145,6 @@ struct scsi_host_template {
 	int (* transfer_response)(struct scsi_cmnd *,
 				  void (*done)(struct scsi_cmnd *));
 
-	/* Used as callback for the completion of task management request. */
-	int (* tsk_mgmt_response)(struct Scsi_Host *, u64, u64 mid, int result);
-
 	/*
 	 * This is an error handling strategy routine.  You don't need to
 	 * define one of these if you don't want to - there is a default

commit 2c47f9efbedbe5749b6bb16e59bc11d6e460855f
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Wed Jul 11 15:08:17 2007 +0900

    [SCSI] tgt: add I_T nexus support
    
    tgt uses scsi_host as I_T nexus. This works for ibmvstgt because it
    creates one scsi_host for one initiator. However, other target drivers
    don't work like that.
    
    This adds I_T nexus support, which enable one scsi_host to handle
    multiple initiators. New scsi_tgt_it_nexus_create/destroy functions
    are expected be called transport classes. For example, ibmvstgt
    creates an initiator remote port, then the srp transport calls
    tgt_it_nexus_create. tgt doesn't manages I_T nexus, instead it tells
    tgtd, user-space daemon, to create a new I_T nexus.
    
    On the receiving the response from tgtd, tgt calls
    shost->transportt->it_nexus_response. transports should notify a
    lld. The srp transport uses it_nexus_response callback in
    srp_function_template to do that.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 3b8a6a85c2f8..89c40c4bd5c4 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -146,7 +146,7 @@ struct scsi_host_template {
 				  void (*done)(struct scsi_cmnd *));
 
 	/* Used as callback for the completion of task management request. */
-	int (* tsk_mgmt_response)(u64 mid, int result);
+	int (* tsk_mgmt_response)(struct Scsi_Host *, u64, u64 mid, int result);
 
 	/*
 	 * This is an error handling strategy routine.  You don't need to

commit b02b6bc46571b21a545c9e697df1e226ff22bc81
Author: Kristian Hgsberg <krh@redhat.com>
Date:   Wed May 9 19:23:12 2007 -0400

    [SCSI] Make scsi_host_template::proc_name const char * instead of char *.
    
    Signed-off-by: Kristian Hgsberg <krh@redhat.com>
    
    collapsed with fw-sbp2 patch "Drop cast to non-const char * in host
    template initialization." from Kristian Hgsberg
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index ba07cf7c04ba..3b8a6a85c2f8 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -341,7 +341,7 @@ struct scsi_host_template {
 	/*
 	 * Name of proc directory
 	 */
-	char *proc_name;
+	const char *proc_name;
 
 	/*
 	 * Used to store the procfs directory if a driver implements the

commit bcd92c9fbcc679ee95003083056f0441a1f474fa
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu May 31 20:12:26 2007 +0200

    [SCSI] introduce shost_priv helper
    
    Currently accessing the scsi host private data is rather messy because
    it comes as an unsigned long that always needs a cast first.  This patch
    introduces a helper that does the cast called shost_priv.  It's similar
    in spirit to netdev_priv for network drivers.
    
    This is the first patch introducing the macro, and the second patch
    in the series will convert esp and it's subdrivers as an example.
    Further conversion will wait until the helper is in the tree to make
    patch juggling easier.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 4a2e490abfed..ba07cf7c04ba 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -671,6 +671,10 @@ struct Scsi_Host {
 #define shost_printk(prefix, shost, fmt, a...)	\
 	dev_printk(prefix, &(shost)->shost_gendev, fmt, ##a)
 
+static inline void *shost_priv(struct Scsi_Host *shost)
+{
+	return (void *)shost->hostdata;
+}
 
 int scsi_is_host_device(const struct device *);
 

commit 1dfcda06a67d6ad6f890dbd1bab84be5f17ef46d
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Mar 21 16:05:16 2007 +0900

    [SCSI] kill scsi host template suspend/resume
    
    With libata converted to use sdev->manage_start_stop for suspend and
    resume, sht->suspend/resume() has no user left and low level
    suspend/ressume should be taken care of by low level driver's
    suspend/resume callbacks (e.g. PCI or PCMCIA driver callbacks).  This
    patch removes sht->suspend/resume() callbacks.
    
    This change is suggested by Christoph Hellwig.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 68f461b7a835..4a2e490abfed 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -338,12 +338,6 @@ struct scsi_host_template {
 	 */
 	enum scsi_eh_timer_return (* eh_timed_out)(struct scsi_cmnd *);
 
-	/*
-	 * suspend support
-	 */
-	int (*resume)(struct scsi_device *);
-	int (*suspend)(struct scsi_device *, pm_message_t state);
-
 	/*
 	 * Name of proc directory
 	 */

commit 6c5f8ce1fb7e8925d957f754a9513911399791b9
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Fri Mar 16 17:44:41 2007 -0500

    [SCSI] expose eh_timed_out to the host template
    
    It looks like megaraid_sas at least needs this to throttle its commands
    as they begin to time out.  The code keeps the existing transport
    template use of eh_timed_out (and allows the transport to override the
    host if they both have this callback).
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 965b6b8ffec5..68f461b7a835 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -325,6 +325,19 @@ struct scsi_host_template {
 	 */
 	int (*proc_info)(struct Scsi_Host *, char *, char **, off_t, int, int);
 
+	/*
+	 * This is an optional routine that allows the transport to become
+	 * involved when a scsi io timer fires. The return value tells the
+	 * timer routine how to finish the io timeout handling:
+	 * EH_HANDLED:		I fixed the error, please complete the command
+	 * EH_RESET_TIMER:	I need more time, reset the timer and
+	 *			begin counting again
+	 * EH_NOT_HANDLED	Begin normal error recovery
+	 *
+	 * Status: OPTIONAL
+	 */
+	enum scsi_eh_timer_return (* eh_timed_out)(struct scsi_cmnd *);
+
 	/*
 	 * suspend support
 	 */

commit bc7e380a6a4c94f79a49c36bdb28062a750b3c2b
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Sat Mar 3 09:55:54 2007 +0900

    [SCSI] tgt: fix sesnse buffer problems
    
    This patch simplify the way to notify LLDs of the command completion
    and addresses the following sense buffer problems:
    
    - can't handle both data and sense.
    - forces user-space to use aligned sense buffer
    
    tgt copies sense_data from userspace to cmnd->sense_buffer (if
    necessary), maps user-space pages (if necessary) and then calls
    host->transfer_response (host->transfer_data is removed).
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 7f1f411d07af..965b6b8ffec5 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -129,6 +129,11 @@ struct scsi_host_template {
 	 * the LLD. When the driver is finished processing the command
 	 * the done callback is invoked.
 	 *
+	 * This is called to inform the LLD to transfer
+	 * cmd->request_bufflen bytes. The cmd->use_sg speciefies the
+	 * number of scatterlist entried in the command and
+	 * cmd->request_buffer contains the scatterlist.
+	 *
 	 * return values: see queuecommand
 	 *
 	 * If the LLD accepts the cmd, it should set the result to an
@@ -139,20 +144,6 @@ struct scsi_host_template {
 	/* TODO: rename */
 	int (* transfer_response)(struct scsi_cmnd *,
 				  void (*done)(struct scsi_cmnd *));
-	/*
-	 * This is called to inform the LLD to transfer cmd->request_bufflen
-	 * bytes of the cmd at cmd->offset in the cmd. The cmd->use_sg
-	 * speciefies the number of scatterlist entried in the command
-	 * and cmd->request_buffer contains the scatterlist.
-	 *
-	 * If the command cannot be processed in one transfer_data call
-	 * becuase a scatterlist within the LLD's limits cannot be
-	 * created then transfer_data will be called multiple times.
-	 * It is initially called from process context, and later
-	 * calls are from the interrup context.
-	 */
-	int (* transfer_data)(struct scsi_cmnd *,
-			      void (*done)(struct scsi_cmnd *));
 
 	/* Used as callback for the completion of task management request. */
 	int (* tsk_mgmt_response)(u64 mid, int result);

commit b58d91547fb17c65ad621f3f98b1f2c228c812a5
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Thu Nov 16 19:24:10 2006 +0900

    [SCSI] export scsi-ml functions needed by tgt_scsi_lib and its LLDs
    
    This patch contains the needed changes to the scsi-ml for the target
    mode support.
    
    Note, per the last review we moved almost all the fields we added
    to the scsi_cmnd to our internal data structure which we are going
    to try and kill off when we can replace it with support from other
    parts of the kernel.
    
    The one field we left on was the offset variable. This is needed to handle
    the case where the target gets request that is so large that it cannot
    execute it in one dma operation. So max_secotors or a segment limit may
    limit the size of the transfer. In this case our tgt core code will
    break up the command into managable transfers and send them to the
    LLD one at a time. The offset is then used to tell the LLD where in
    the command we are at. Is there another field on the scsi_cmd for
    that?
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 6d8945d71c65..7f1f411d07af 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -7,6 +7,7 @@
 #include <linux/workqueue.h>
 #include <linux/mutex.h>
 
+struct request_queue;
 struct block_device;
 struct completion;
 struct module;
@@ -123,6 +124,39 @@ struct scsi_host_template {
 	int (* queuecommand)(struct scsi_cmnd *,
 			     void (*done)(struct scsi_cmnd *));
 
+	/*
+	 * The transfer functions are used to queue a scsi command to
+	 * the LLD. When the driver is finished processing the command
+	 * the done callback is invoked.
+	 *
+	 * return values: see queuecommand
+	 *
+	 * If the LLD accepts the cmd, it should set the result to an
+	 * appropriate value when completed before calling the done function.
+	 *
+	 * STATUS: REQUIRED FOR TARGET DRIVERS
+	 */
+	/* TODO: rename */
+	int (* transfer_response)(struct scsi_cmnd *,
+				  void (*done)(struct scsi_cmnd *));
+	/*
+	 * This is called to inform the LLD to transfer cmd->request_bufflen
+	 * bytes of the cmd at cmd->offset in the cmd. The cmd->use_sg
+	 * speciefies the number of scatterlist entried in the command
+	 * and cmd->request_buffer contains the scatterlist.
+	 *
+	 * If the command cannot be processed in one transfer_data call
+	 * becuase a scatterlist within the LLD's limits cannot be
+	 * created then transfer_data will be called multiple times.
+	 * It is initially called from process context, and later
+	 * calls are from the interrup context.
+	 */
+	int (* transfer_data)(struct scsi_cmnd *,
+			      void (*done)(struct scsi_cmnd *));
+
+	/* Used as callback for the completion of task management request. */
+	int (* tsk_mgmt_response)(u64 mid, int result);
+
 	/*
 	 * This is an error handling strategy routine.  You don't need to
 	 * define one of these if you don't want to - there is a default
@@ -589,6 +623,12 @@ struct Scsi_Host {
 	 */
 	unsigned int max_host_blocked;
 
+	/*
+	 * q used for scsi_tgt msgs, async events or any other requests that
+	 * need to be processed in userspace
+	 */
+	struct request_queue *uspace_req_q;
+
 	/* legacy crap */
 	unsigned long base;
 	unsigned long io_port;
@@ -687,6 +727,9 @@ extern void scsi_unblock_requests(struct Scsi_Host *);
 extern void scsi_block_requests(struct Scsi_Host *);
 
 struct class_container;
+
+extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
+						void (*) (struct request_queue *));
 /*
  * These two functions are used to allocate and free a pseudo device
  * which will connect to the host adapter itself rather than any

commit 1aa8fab2acf1cb8b341131b726773fcff0abc707
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Wed Nov 22 13:24:54 2006 -0700

    [SCSI] Make scsi_scan_host work for drivers which find their own targets
    
    If a driver can find its own targets, it can now fill in scan_finished and
    (optionally) scan_start in the scsi_host_template.  Then, when it calls
    scsi_scan_host(), it will be called back (from a thread if asynchronous
    discovery is enabled), first to start the scan, and then at intervals to
    check if the scan is completed.
    
    Also make scsi_prep_async_scan and scsi_finish_async_scan static.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index e618e711ea57..6d8945d71c65 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -240,6 +240,24 @@ struct scsi_host_template {
 	 */
 	void (* target_destroy)(struct scsi_target *);
 
+	/*
+	 * If a host has the ability to discover targets on its own instead
+	 * of scanning the entire bus, it can fill in this function and
+	 * call scsi_scan_host().  This function will be called periodically
+	 * until it returns 1 with the scsi_host and the elapsed time of
+	 * the scan in jiffies.
+	 *
+	 * Status: OPTIONAL
+	 */
+	int (* scan_finished)(struct Scsi_Host *, unsigned long);
+
+	/*
+	 * If the host wants to be called before the scan starts, but
+	 * after the midlayer has set up ready for the scan, it can fill
+	 * in this function.
+	 */
+	void (* scan_start)(struct Scsi_Host *);
+
 	/*
 	 * fill in this function to allow the queue depth of this host
 	 * to be changeable (on a per device basis).  returns either

commit 4f777ed26086452737ea52597cf8de26137090d5
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Nov 4 20:11:36 2006 +0100

    [SCSI] kill scsi_assign_lock
    
    scsi_assign_lock has been unused for a long time and is a bad idea
    in general, so kill it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index ba5b3eb6b43f..e618e711ea57 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -651,11 +651,6 @@ extern const char *scsi_host_state_name(enum scsi_host_state);
 
 extern u64 scsi_calculate_bounce_limit(struct Scsi_Host *);
 
-static inline void scsi_assign_lock(struct Scsi_Host *shost, spinlock_t *lock)
-{
-	shost->host_lock = lock;
-}
-
 static inline struct device *scsi_get_device(struct Scsi_Host *shost)
 {
         return shost->shost_gendev.parent;

commit 3e082a910d217b2e7b186077ebf5a1126a68c62f
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Sep 28 15:19:20 2006 -0600

    [SCSI] Add ability to scan scsi busses asynchronously
    
    Since it often takes around 20-30 seconds to scan a scsi bus, it's
    highly advantageous to do this in parallel with other things.  The bulk
    of this patch is ensuring that devices don't change numbering, and that
    all devices are discovered prior to trying to start init.  For those
    who build SCSI as modules, there's a new scsi_wait_scan module that will
    ensure all bus scans are finished.
    
    This patch only handles drivers which call scsi_scan_host.  Fibre Channel,
    SAS, SATA, USB and Firewire all need additional work.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 39c6f8cc20c3..ba5b3eb6b43f 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -552,6 +552,9 @@ struct Scsi_Host {
 	/* task mgmt function in progress */
 	unsigned tmf_in_progress:1;
 
+	/* Asynchronous scan in progress */
+	unsigned async_scan:1;
+
 	/*
 	 * Optional work queue to be utilized by the transport
 	 */

commit 86e33a296c2c9ed6eece0bfff4ac776f42040504
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Wed Aug 30 09:45:51 2006 -0400

    [SCSI] add shared tag map helpers
    
    This patch adds support for sharing tag maps at the host level
    (i.e. either every queue [LUN] has its own tag map or there's a single
    one for the entire host).  This formulation is primarily intended to
    help single issue queue hardware, like the aic7xxx
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index b3dd90f3e858..39c6f8cc20c3 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -16,6 +16,7 @@ struct scsi_target;
 struct Scsi_Host;
 struct scsi_host_cmd_pool;
 struct scsi_transport_template;
+struct blk_queue_tags;
 
 
 /*
@@ -465,6 +466,12 @@ struct Scsi_Host {
 	struct scsi_host_template *hostt;
 	struct scsi_transport_template *transportt;
 
+	/*
+	 * area to keep a shared tag map (if needed, will be
+	 * NULL if not)
+	 */
+	struct blk_queue_tag	*bqt;
+
 	/*
 	 * The following two fields are protected with host_lock;
 	 * however, eh routines can safely access during eh processing

commit d7a1bb0a04ca835bffc0a91e64ab827dfba7d8f5
Author: James Smart <James.Smart@Emulex.Com>
Date:   Wed Mar 8 14:50:12 2006 -0500

    [SCSI] Block I/O while SG reset operation in progress - the midlayer patch
    
    The scsi midlayer portion of the patch
    
    Signed-off-by: James Smart <James.Smart@emulex.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index a42efd6e4be8..b3dd90f3e858 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -542,6 +542,9 @@ struct Scsi_Host {
 	 */
 	unsigned ordered_tag:1;
 
+	/* task mgmt function in progress */
+	unsigned tmf_in_progress:1;
+
 	/*
 	 * Optional work queue to be utilized by the transport
 	 */
@@ -619,7 +622,8 @@ static inline int scsi_host_in_recovery(struct Scsi_Host *shost)
 {
 	return shost->shost_state == SHOST_RECOVERY ||
 		shost->shost_state == SHOST_CANCEL_RECOVERY ||
-		shost->shost_state == SHOST_DEL_RECOVERY;
+		shost->shost_state == SHOST_DEL_RECOVERY ||
+		shost->tmf_in_progress;
 }
 
 extern int scsi_queue_work(struct Scsi_Host *, struct work_struct *);

commit ee7863bc68fa6ad6fe7cfcc0e5ebe9efe0c0664e
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:57:20 2006 +0900

    [PATCH] SCSI: implement shost->host_eh_scheduled
    
    libata needs to invoke EH without scmd.  This patch adds
    shost->host_eh_scheduled to implement such behavior.
    
    Currently the only user of this feature is libata and no general
    interface is defined.  This patch simply adds handling for
    host_eh_scheduled where needed and exports scsi_eh_wakeup() to
    modules.  The rest is upto libata.  This is the result of the
    following discussion.
    
    http://thread.gmane.org/gmane.linux.scsi/23853/focus=9760
    
    In short, SCSI host is not supposed to know about exceptions unrelated
    to specific device or command.  Such exceptions should be handled by
    transport layer proper.  However, the distinction is not essential to
    ATA and libata is planning to depart from SCSI, so, for the time
    being, libata will be using SCSI EH to handle such exceptions.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index de6ce541a046..a42efd6e4be8 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -472,6 +472,7 @@ struct Scsi_Host {
 	 */
 	unsigned int host_busy;		   /* commands actually active on low-level */
 	unsigned int host_failed;	   /* commands that failed. */
+	unsigned int host_eh_scheduled;    /* EH scheduled without command */
     
 	unsigned short host_no;  /* Used for IOCTL_GET_IDLUN, /proc/scsi et al. */
 	int resetting; /* if set, it means that last_reset is a valid value */

commit 9227c33de80ac01f269ed33624990ce84358e419
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Apr 1 19:21:04 2006 +0200

    [PATCH] move ->eh_strategy_handler to the transport class
    
    Overriding the whole EH code is a per-transport, not per-host thing.
    Move ->eh_strategy_handler to the transport class, same as
    ->eh_timed_out.
    
    Downside is that scsi_host_alloc can't check for the total lack of EH
    anymore, but the transition period from old EH where we needed it is
    long gone already.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index dc6862d09e53..de6ce541a046 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -140,7 +140,6 @@ struct scsi_host_template {
 	 *
 	 * Status: REQUIRED	(at least one of them)
 	 */
-	int (* eh_strategy_handler)(struct Scsi_Host *);
 	int (* eh_abort_handler)(struct scsi_cmnd *);
 	int (* eh_device_reset_handler)(struct scsi_cmnd *);
 	int (* eh_bus_reset_handler)(struct scsi_cmnd *);

commit 082776e4be791736c32baf818e50f501a7f83819
Author: Nigel Cunningham <ncunningham@cyclades.com>
Date:   Thu Mar 23 23:22:16 2006 +1000

    [PATCH] Make libata not powerdown drivers on PM_EVENT_FREEZE.
    
    At the moment libata doesn't pass pm_message_t down ata_device_suspend.
    This causes drives to be powered down when we just want a freeze,
    causing unnecessary wear and tear. This patch gets pm_message_t passed
    down so that it can be used to determine whether to power down the
    drive.
    
    Signed-off-by: Nigel Cunningham <nigel@suspend2.net>
    
     drivers/scsi/libata-core.c |    5 +++--
     drivers/scsi/libata-scsi.c |    4 ++--
     drivers/scsi/scsi_sysfs.c  |    2 +-
     include/linux/libata.h     |    4 ++--
     include/scsi/scsi_host.h   |    2 +-
     5 files changed, 9 insertions(+), 8 deletions(-)
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index a6cf3e535c0b..dc6862d09e53 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -286,7 +286,7 @@ struct scsi_host_template {
 	 * suspend support
 	 */
 	int (*resume)(struct scsi_device *);
-	int (*suspend)(struct scsi_device *);
+	int (*suspend)(struct scsi_device *, pm_message_t state);
 
 	/*
 	 * Name of proc directory

commit c829c394165f981d49f05a9be228404d7a9398d4
Author: James Smart <James.Smart@Emulex.Com>
Date:   Mon Mar 13 08:28:57 2006 -0500

    [SCSI] FC transport : Avoid device offline cases by stalling aborts until device unblocked
    
    This moves the eh_timed_out functionality from the scsi_host_template
    to the transport_template. Given that this is now a transport function,
    the EH_RESET_TIMER case no longer caps the timer reschedulings. The
    transport guarantees that this is not an infinite condition.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 827992949c4b..a6cf3e535c0b 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -146,20 +146,6 @@ struct scsi_host_template {
 	int (* eh_bus_reset_handler)(struct scsi_cmnd *);
 	int (* eh_host_reset_handler)(struct scsi_cmnd *);
 
-	/*
-	 * This is an optional routine to notify the host that the scsi
-	 * timer just fired.  The returns tell the timer routine what to
-	 * do about this:
-	 *
-	 * EH_HANDLED:		I fixed the error, please complete the command
-	 * EH_RESET_TIMER:	I need more time, reset the timer and
-	 *			begin counting again
-	 * EH_NOT_HANDLED	Begin normal error recovery
-	 *
-	 * Status: OPTIONAL
-	 */
-	enum scsi_eh_timer_return (* eh_timed_out)(struct scsi_cmnd *);
-
 	/*
 	 * Before the mid layer attempts to scan for a new device where none
 	 * currently exists, it will call this entry in your driver.  Should

commit dfcd77d16b5745fbfea7d5636f15fc80cc05fef8
Author: Tetsuo Takata <takatan.linux@gmail.com>
Date:   Wed Jan 25 11:12:40 2006 +0100

    [SCSI] Remove host template ordered_flush variable
    
    After the recent overhaul of the block layer the variable
    "ordered_flush" is no longer used.
    
    Signed-off-by: Tetsuo Takata <takatatt@intellilink.co.jp>
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 467274a764d1..827992949c4b 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -554,7 +554,6 @@ struct Scsi_Host {
 	/*
 	 * ordered write support
 	 */
-	unsigned ordered_flush:1;
 	unsigned ordered_tag:1;
 
 	/*

commit 0b9506723826c68b50fa33e345700ddcac1bed36
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Wed Jan 11 13:16:10 2006 +0100

    [SCSI] turn most scsi semaphores into mutexes
    
    the scsi layer is using semaphores in a mutex way, this patch converts
    these into using mutexes instead
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 230bc55c0bfa..467274a764d1 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -5,6 +5,7 @@
 #include <linux/list.h>
 #include <linux/types.h>
 #include <linux/workqueue.h>
+#include <linux/mutex.h>
 
 struct block_device;
 struct completion;
@@ -469,7 +470,7 @@ struct Scsi_Host {
 	spinlock_t		default_lock;
 	spinlock_t		*host_lock;
 
-	struct semaphore	scan_mutex;/* serialize scanning activity */
+	struct mutex		scan_mutex;/* serialize scanning activity */
 
 	struct list_head	eh_cmd_q;
 	struct task_struct    * ehandler;  /* Error recovery thread. */

commit d99cf9d679a520d67f81d805b7cb91c68e1847f0
Merge: 7ed40918a386 e650c305ec31
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Fri Jan 6 09:01:25 2006 -0800

    Merge branch 'post-2.6.15' of git://brick.kernel.dk/data/git/linux-2.6-block
    
    Manual fixup for merge with Jens' "Suspend support for libata", commit
    ID 9b847548663ef1039dd49f0eb4463d001e596bc3.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 9b847548663ef1039dd49f0eb4463d001e596bc3
Author: Jens Axboe <axboe@suse.de>
Date:   Fri Jan 6 09:28:07 2006 +0100

    [PATCH] Suspend support for libata
    
    This patch adds suspend patch to libata, and ata_piix in particular. For
    most low level drivers, they should just need to add the 4 hooks to
    work. As I can only test ata_piix, I didn't enable it for more
    though.
    
    Suspend support is the single most important feature on a notebook, and
    most new notebooks have sata drives. It's quite embarrassing that we
    _still_ do not support this. Right now, it's perfectly possible to
    suspend the drive in mid-transfer.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 6cbb1982ed03..6297885a35e7 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -295,6 +295,12 @@ struct scsi_host_template {
 	 */
 	int (*proc_info)(struct Scsi_Host *, char *, char **, off_t, int, int);
 
+	/*
+	 * suspend support
+	 */
+	int (*resume)(struct scsi_device *);
+	int (*suspend)(struct scsi_device *);
+
 	/*
 	 * Name of proc directory
 	 */

commit 461d4e90c8cd049718884cd17c955e231140d3be
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Jan 6 09:52:55 2006 +0100

    [BLOCK] update SCSI to use new blk_ordered for barriers
    
    All ordered request related stuff delegated to HLD.  Midlayer
    now doens't deal with ordered setting or prepare_flush
    callback.  sd.c updated to deal with blk_queue_ordered
    setting.  Currently, ordered tag isn't used as SCSI midlayer
    cannot guarantee request ordering.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 6cbb1982ed03..25f637bd38b9 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -392,7 +392,6 @@ struct scsi_host_template {
 	/*
 	 * ordered write support
 	 */
-	unsigned ordered_flush:1;
 	unsigned ordered_tag:1;
 
 	/*

commit 7dfdc9a52b4219fba8240750e36de5db860ddd5f
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 18:49:52 2005 +0100

    [SCSI] use a completion in scsi_send_eh_cmnd
    
    scsi_send_eh_cmnd currently uses a semaphore and an overload of eh_timer
    to either get a completion for a command for a timeout.
    Switch to using a completion and wait_for_completion_timeout to simply
    the code and not having to deal with the races ourselves.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 9984d3fbb1f0..6cbb1982ed03 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -7,6 +7,7 @@
 #include <linux/workqueue.h>
 
 struct block_device;
+struct completion;
 struct module;
 struct scsi_cmnd;
 struct scsi_device;
@@ -467,8 +468,8 @@ struct Scsi_Host {
 
 	struct list_head	eh_cmd_q;
 	struct task_struct    * ehandler;  /* Error recovery thread. */
-	struct semaphore      * eh_action; /* Wait for specific actions on the
-                                          host. */
+	struct completion     * eh_action; /* Wait for specific actions on the
+					      host. */
 	wait_queue_head_t       host_wait;
 	struct scsi_host_template *hostt;
 	struct scsi_transport_template *transportt;

commit 474838d5e5b5fa768803abc5522ae3fdf85c5f4e
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Oct 29 01:02:43 2005 +0200

    [SCSI] remove Scsi_Host.eh_active
    
    now that the abuse in qla2xxx is gone this field can be remove.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index ecd53d7872d2..9984d3fbb1f0 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -469,8 +469,6 @@ struct Scsi_Host {
 	struct task_struct    * ehandler;  /* Error recovery thread. */
 	struct semaphore      * eh_action; /* Wait for specific actions on the
                                           host. */
-	unsigned int            eh_active:1; /* Indicates the eh thread is awake and active if
-                                          this is true. */
 	wait_queue_head_t       host_wait;
 	struct scsi_host_template *hostt;
 	struct scsi_transport_template *transportt;

commit 13ec92b33e4f41b81b3a237ad1d9a588a81f2f03
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Oct 24 18:01:11 2005 -0400

    [SCSI] kill unused scsi_scan_single_target()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index ea7ad7235397..ecd53d7872d2 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -638,8 +638,6 @@ extern void scsi_flush_work(struct Scsi_Host *);
 extern struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *, int);
 extern int __must_check scsi_add_host(struct Scsi_Host *, struct device *);
 extern void scsi_scan_host(struct Scsi_Host *);
-extern void scsi_scan_single_target(struct Scsi_Host *, unsigned int,
-	unsigned int);
 extern void scsi_rescan_device(struct device *);
 extern void scsi_remove_host(struct Scsi_Host *);
 extern struct Scsi_Host *scsi_host_get(struct Scsi_Host *);

commit 9ccfc756a70d454dfa82f48897e2883560c01a0e
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sun Oct 2 11:45:08 2005 -0500

    [SCSI] move the mid-layer printk's over to shost/starget/sdev_printk
    
    This should eliminate (at least in the mid layer) to make numeric
    assumptions about any of the enumeration variables.  As a side effect,
    it will also make all the messages consistent and line us up nicely for
    the error logging strategy (if it ever shows itself again).
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 69313ba7505b..ea7ad7235397 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -609,6 +609,10 @@ struct Scsi_Host {
 #define		class_to_shost(d)	\
 	container_of(d, struct Scsi_Host, shost_classdev)
 
+#define shost_printk(prefix, shost, fmt, a...)	\
+	dev_printk(prefix, &(shost)->shost_gendev, fmt, ##a)
+
+
 int scsi_is_host_device(const struct device *);
 
 static inline struct Scsi_Host *dev_to_shost(struct device *dev)

commit 3ed7a4704beb66a155acd67b78b7e9a5674d55fb
Author: James Bottomley <jejb@titanic.(none)>
Date:   Mon Sep 19 09:50:04 2005 -0500

    [SCSI] Fix thread termination for the SCSI error handle
    
    From:   Alan Stern <stern@rowland.harvard.edu>
    
    This patch (as561) fixes the error handler's thread-exit code.  The
    kthread_stop call won't wake the thread from a down_interruptible, so
    the patch gets rid of the semaphore and simply does
    
            set_current_state(TASK_INTERRUPTIBLE);
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    
    Modified to simplify the termination loop and correct the sleep condition.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 540369ff815c..69313ba7505b 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -467,8 +467,6 @@ struct Scsi_Host {
 
 	struct list_head	eh_cmd_q;
 	struct task_struct    * ehandler;  /* Error recovery thread. */
-	struct semaphore      * eh_wait;   /* The error recovery thread waits
-					      on this. */
 	struct semaphore      * eh_action; /* Wait for specific actions on the
                                           host. */
 	unsigned int            eh_active:1; /* Indicates the eh thread is awake and active if

commit 939647ee308e0ad924e776657704c7bedd498664
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sun Sep 18 15:05:20 2005 -0500

    [SCSI] fix oops on usb storage device disconnect
    
    We fix the oops by enforcing the host state model.  There have also
    been two extra states added: SHOST_CANCEL_RECOVERY and
    SHOST_DEL_RECOVERY so we can take the model through host removal while
    the recovery thread is active.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 916144be208b..540369ff815c 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -439,6 +439,8 @@ enum scsi_host_state {
 	SHOST_CANCEL,
 	SHOST_DEL,
 	SHOST_RECOVERY,
+	SHOST_CANCEL_RECOVERY,
+	SHOST_DEL_RECOVERY,
 };
 
 struct Scsi_Host {
@@ -621,6 +623,13 @@ static inline struct Scsi_Host *dev_to_shost(struct device *dev)
 	return container_of(dev, struct Scsi_Host, shost_gendev);
 }
 
+static inline int scsi_host_in_recovery(struct Scsi_Host *shost)
+{
+	return shost->shost_state == SHOST_RECOVERY ||
+		shost->shost_state == SHOST_CANCEL_RECOVERY ||
+		shost->shost_state == SHOST_DEL_RECOVERY;
+}
+
 extern int scsi_queue_work(struct Scsi_Host *, struct work_struct *);
 extern void scsi_flush_work(struct Scsi_Host *);
 

commit c5478def7a3a2dba9ceda452c2aa3539514d30a9
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Sep 6 14:04:26 2005 +0200

    [SCSI] switch EH thread startup to the kthread API
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index ac1b6125e3ae..916144be208b 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -467,12 +467,10 @@ struct Scsi_Host {
 	struct task_struct    * ehandler;  /* Error recovery thread. */
 	struct semaphore      * eh_wait;   /* The error recovery thread waits
 					      on this. */
-	struct completion     * eh_notify; /* wait for eh to begin or end */
 	struct semaphore      * eh_action; /* Wait for specific actions on the
                                           host. */
 	unsigned int            eh_active:1; /* Indicates the eh thread is awake and active if
                                           this is true. */
-	unsigned int            eh_kill:1; /* set when killing the eh thread */
 	wait_queue_head_t       host_wait;
 	struct scsi_host_template *hostt;
 	struct scsi_transport_template *transportt;

commit 47ba39eead9f4495cd6a3eca39d7c73d0f0d61c9
Author: James Bottomley <jejb@titanic.(none)>
Date:   Sat Jul 30 11:39:53 2005 -0500

    [SCSI] add template for scsi_host_set_state()
    
    Fixes up some warnings in the tree.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 1ea5b51d1749..ac1b6125e3ae 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -676,5 +676,6 @@ extern struct scsi_device *scsi_get_host_dev(struct Scsi_Host *);
 /* legacy interfaces */
 extern struct Scsi_Host *scsi_register(struct scsi_host_template *, int);
 extern void scsi_unregister(struct Scsi_Host *);
+extern int scsi_host_set_state(struct Scsi_Host *, enum scsi_host_state);
 
 #endif /* _SCSI_SCSI_HOST_H */

commit 82f29467a025f6a2192d281e97fca0be46e905cc
Author: Mike Anderson <andmike@us.ibm.com>
Date:   Thu Jun 16 11:14:33 2005 -0700

    [SCSI] host state model update: mediate host add/remove race
    
    Add support to not allow additions to a host when it is being removed.
    
    Signed-off-by: Mike Anderson <andmike@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 0b1e275b2699..1ea5b51d1749 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -650,6 +650,15 @@ static inline struct device *scsi_get_device(struct Scsi_Host *shost)
         return shost->shost_gendev.parent;
 }
 
+/**
+ * scsi_host_scan_allowed - Is scanning of this host allowed
+ * @shost:	Pointer to Scsi_Host.
+ **/
+static inline int scsi_host_scan_allowed(struct Scsi_Host *shost)
+{
+	return shost->shost_state == SHOST_RUNNING;
+}
+
 extern void scsi_unblock_requests(struct Scsi_Host *);
 extern void scsi_block_requests(struct Scsi_Host *);
 

commit d3301874083874f8a0ac88aa1bb7da6b62df34d2
Author: Mike Anderson <andmike@us.ibm.com>
Date:   Thu Jun 16 11:12:38 2005 -0700

    [SCSI] host state model update: replace old host bitmap state
    
    Migrate the current SCSI host state model to a model like SCSI
    device is using.
    
    Signed-off-by: Mike Anderson <andmike@us.ibm.com>
    
    Rejections fixed up and
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 81d5234f6771..0b1e275b2699 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -429,12 +429,15 @@ struct scsi_host_template {
 };
 
 /*
- * shost states
+ * shost state: If you alter this, you also need to alter scsi_sysfs.c
+ * (for the ascii descriptions) and the state model enforcer:
+ * scsi_host_set_state()
  */
-enum {
-	SHOST_ADD,
-	SHOST_DEL,
+enum scsi_host_state {
+	SHOST_CREATED = 1,
+	SHOST_RUNNING,
 	SHOST_CANCEL,
+	SHOST_DEL,
 	SHOST_RECOVERY,
 };
 
@@ -575,7 +578,7 @@ struct Scsi_Host {
 	unsigned int  irq;
 	
 
-	unsigned long shost_state;
+	enum scsi_host_state shost_state;
 
 	/* ldm bits */
 	struct device		shost_gendev;
@@ -633,6 +636,7 @@ extern void scsi_remove_host(struct Scsi_Host *);
 extern struct Scsi_Host *scsi_host_get(struct Scsi_Host *);
 extern void scsi_host_put(struct Scsi_Host *t);
 extern struct Scsi_Host *scsi_host_lookup(unsigned short);
+extern const char *scsi_host_state_name(enum scsi_host_state);
 
 extern u64 scsi_calculate_bounce_limit(struct Scsi_Host *);
 

commit 12413197eef2a29e0b9fb0fa541f5cbaeb1d3f3f
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 11 01:05:01 2005 +0200

    [SCSI] remove scsi_set_device
    
    scsi_add_host is the proper place to set the device, but people copy
    the scsi_set_device usage from older drivers again and again.
    
    note that this leaves some legacy drivers like qlogicisp/qlogicfc
    without pci association in sysfs, but they're scheduled to go away soon
    anyway.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index db9914adeac9..81d5234f6771 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -641,12 +641,6 @@ static inline void scsi_assign_lock(struct Scsi_Host *shost, spinlock_t *lock)
 	shost->host_lock = lock;
 }
 
-static inline void scsi_set_device(struct Scsi_Host *shost,
-                                   struct device *dev)
-{
-        shost->shost_gendev.parent = dev;
-}
-
 static inline struct device *scsi_get_device(struct Scsi_Host *shost)
 {
         return shost->shost_gendev.parent;

commit a283bd37d00e92e8874ca6325ae071691d4db388
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Tue May 24 12:06:38 2005 -0500

    [SCSI] Add target alloc/destroy callbacks to the host template
    
    This gives the HBA driver notice when a target is created and
    destroyed to allow it to manage its own target based allocations
    accordingly.
    
    This is a much reduced verson of the original patch sent in by
    James.Smart@Emulex.com
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 1cee1e100943..db9914adeac9 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -10,6 +10,7 @@ struct block_device;
 struct module;
 struct scsi_cmnd;
 struct scsi_device;
+struct scsi_target;
 struct Scsi_Host;
 struct scsi_host_cmd_pool;
 struct scsi_transport_template;
@@ -227,6 +228,30 @@ struct scsi_host_template {
 	 */
 	void (* slave_destroy)(struct scsi_device *);
 
+	/*
+	 * Before the mid layer attempts to scan for a new device attached
+	 * to a target where no target currently exists, it will call this
+	 * entry in your driver.  Should your driver need to allocate any
+	 * structs or perform any other init items in order to send commands
+	 * to a currently unused target, then this is where you can perform
+	 * those allocations.
+	 *
+	 * Return values: 0 on success, non-0 on failure
+	 *
+	 * Status: OPTIONAL
+	 */
+	int (* target_alloc)(struct scsi_target *);
+
+	/*
+	 * Immediately prior to deallocating the target structure, and
+	 * after all activity to attached scsi devices has ceased, the
+	 * midlayer calls this point so that the driver may deallocate
+	 * and terminate any references to the target.
+	 *
+	 * Status: OPTIONAL
+	 */
+	void (* target_destroy)(struct scsi_target *);
+
 	/*
 	 * fill in this function to allow the queue depth of this host
 	 * to be changeable (on a per device basis).  returns either

commit 06f81ea8ca09b880cadf101d7e23b500e9c164bc
Author:  <htejun@gmail.com>
Date:   Sun Apr 17 14:57:29 2005 -0500

    [PATCH] scsi: remove volatile from scsi data
    
    This patch removes volatile qualifier from scsi_device->device_busy,
    Scsi_Host->host_busy and ->host_failed as the volatile qualifiers
    don't serve any purpose now.  While at it, convert those fields from
    unsigned short to unsigned int as suggested by Christoph.
    
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 27f2c4e8943a..1cee1e100943 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -448,8 +448,14 @@ struct Scsi_Host {
 	wait_queue_head_t       host_wait;
 	struct scsi_host_template *hostt;
 	struct scsi_transport_template *transportt;
-	volatile unsigned short host_busy;   /* commands actually active on low-level */
-	volatile unsigned short host_failed; /* commands that failed. */
+
+	/*
+	 * The following two fields are protected with host_lock;
+	 * however, eh routines can safely access during eh processing
+	 * without acquiring the lock.
+	 */
+	unsigned int host_busy;		   /* commands actually active on low-level */
+	unsigned int host_failed;	   /* commands that failed. */
     
 	unsigned short host_no;  /* Used for IOCTL_GET_IDLUN, /proc/scsi et al. */
 	int resetting; /* if set, it means that last_reset is a valid value */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
new file mode 100644
index 000000000000..27f2c4e8943a
--- /dev/null
+++ b/include/scsi/scsi_host.h
@@ -0,0 +1,642 @@
+#ifndef _SCSI_SCSI_HOST_H
+#define _SCSI_SCSI_HOST_H
+
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+
+struct block_device;
+struct module;
+struct scsi_cmnd;
+struct scsi_device;
+struct Scsi_Host;
+struct scsi_host_cmd_pool;
+struct scsi_transport_template;
+
+
+/*
+ * The various choices mean:
+ * NONE: Self evident.	Host adapter is not capable of scatter-gather.
+ * ALL:	 Means that the host adapter module can do scatter-gather,
+ *	 and that there is no limit to the size of the table to which
+ *	 we scatter/gather data.
+ * Anything else:  Indicates the maximum number of chains that can be
+ *	 used in one scatter-gather request.
+ */
+#define SG_NONE 0
+#define SG_ALL 0xff
+
+
+#define DISABLE_CLUSTERING 0
+#define ENABLE_CLUSTERING 1
+
+enum scsi_eh_timer_return {
+	EH_NOT_HANDLED,
+	EH_HANDLED,
+	EH_RESET_TIMER,
+};
+
+
+struct scsi_host_template {
+	struct module *module;
+	const char *name;
+
+	/*
+	 * Used to initialize old-style drivers.  For new-style drivers
+	 * just perform all work in your module initialization function.
+	 *
+	 * Status:  OBSOLETE
+	 */
+	int (* detect)(struct scsi_host_template *);
+
+	/*
+	 * Used as unload callback for hosts with old-style drivers.
+	 *
+	 * Status: OBSOLETE
+	 */
+	int (* release)(struct Scsi_Host *);
+
+	/*
+	 * The info function will return whatever useful information the
+	 * developer sees fit.  If not provided, then the name field will
+	 * be used instead.
+	 *
+	 * Status: OPTIONAL
+	 */
+	const char *(* info)(struct Scsi_Host *);
+
+	/*
+	 * Ioctl interface
+	 *
+	 * Status: OPTIONAL
+	 */
+	int (* ioctl)(struct scsi_device *dev, int cmd, void __user *arg);
+
+
+#ifdef CONFIG_COMPAT
+	/* 
+	 * Compat handler. Handle 32bit ABI.
+	 * When unknown ioctl is passed return -ENOIOCTLCMD.
+	 *
+	 * Status: OPTIONAL
+	 */
+	int (* compat_ioctl)(struct scsi_device *dev, int cmd, void __user *arg);
+#endif
+
+	/*
+	 * The queuecommand function is used to queue up a scsi
+	 * command block to the LLDD.  When the driver finished
+	 * processing the command the done callback is invoked.
+	 *
+	 * If queuecommand returns 0, then the HBA has accepted the
+	 * command.  The done() function must be called on the command
+	 * when the driver has finished with it. (you may call done on the
+	 * command before queuecommand returns, but in this case you
+	 * *must* return 0 from queuecommand).
+	 *
+	 * Queuecommand may also reject the command, in which case it may
+	 * not touch the command and must not call done() for it.
+	 *
+	 * There are two possible rejection returns:
+	 *
+	 *   SCSI_MLQUEUE_DEVICE_BUSY: Block this device temporarily, but
+	 *   allow commands to other devices serviced by this host.
+	 *
+	 *   SCSI_MLQUEUE_HOST_BUSY: Block all devices served by this
+	 *   host temporarily.
+	 *
+         * For compatibility, any other non-zero return is treated the
+         * same as SCSI_MLQUEUE_HOST_BUSY.
+	 *
+	 * NOTE: "temporarily" means either until the next command for#
+	 * this device/host completes, or a period of time determined by
+	 * I/O pressure in the system if there are no other outstanding
+	 * commands.
+	 *
+	 * STATUS: REQUIRED
+	 */
+	int (* queuecommand)(struct scsi_cmnd *,
+			     void (*done)(struct scsi_cmnd *));
+
+	/*
+	 * This is an error handling strategy routine.  You don't need to
+	 * define one of these if you don't want to - there is a default
+	 * routine that is present that should work in most cases.  For those
+	 * driver authors that have the inclination and ability to write their
+	 * own strategy routine, this is where it is specified.  Note - the
+	 * strategy routine is *ALWAYS* run in the context of the kernel eh
+	 * thread.  Thus you are guaranteed to *NOT* be in an interrupt
+	 * handler when you execute this, and you are also guaranteed to
+	 * *NOT* have any other commands being queued while you are in the
+	 * strategy routine. When you return from this function, operations
+	 * return to normal.
+	 *
+	 * See scsi_error.c scsi_unjam_host for additional comments about
+	 * what this function should and should not be attempting to do.
+	 *
+	 * Status: REQUIRED	(at least one of them)
+	 */
+	int (* eh_strategy_handler)(struct Scsi_Host *);
+	int (* eh_abort_handler)(struct scsi_cmnd *);
+	int (* eh_device_reset_handler)(struct scsi_cmnd *);
+	int (* eh_bus_reset_handler)(struct scsi_cmnd *);
+	int (* eh_host_reset_handler)(struct scsi_cmnd *);
+
+	/*
+	 * This is an optional routine to notify the host that the scsi
+	 * timer just fired.  The returns tell the timer routine what to
+	 * do about this:
+	 *
+	 * EH_HANDLED:		I fixed the error, please complete the command
+	 * EH_RESET_TIMER:	I need more time, reset the timer and
+	 *			begin counting again
+	 * EH_NOT_HANDLED	Begin normal error recovery
+	 *
+	 * Status: OPTIONAL
+	 */
+	enum scsi_eh_timer_return (* eh_timed_out)(struct scsi_cmnd *);
+
+	/*
+	 * Before the mid layer attempts to scan for a new device where none
+	 * currently exists, it will call this entry in your driver.  Should
+	 * your driver need to allocate any structs or perform any other init
+	 * items in order to send commands to a currently unused target/lun
+	 * combo, then this is where you can perform those allocations.  This
+	 * is specifically so that drivers won't have to perform any kind of
+	 * "is this a new device" checks in their queuecommand routine,
+	 * thereby making the hot path a bit quicker.
+	 *
+	 * Return values: 0 on success, non-0 on failure
+	 *
+	 * Deallocation:  If we didn't find any devices at this ID, you will
+	 * get an immediate call to slave_destroy().  If we find something
+	 * here then you will get a call to slave_configure(), then the
+	 * device will be used for however long it is kept around, then when
+	 * the device is removed from the system (or * possibly at reboot
+	 * time), you will then get a call to slave_destroy().  This is
+	 * assuming you implement slave_configure and slave_destroy.
+	 * However, if you allocate memory and hang it off the device struct,
+	 * then you must implement the slave_destroy() routine at a minimum
+	 * in order to avoid leaking memory
+	 * each time a device is tore down.
+	 *
+	 * Status: OPTIONAL
+	 */
+	int (* slave_alloc)(struct scsi_device *);
+
+	/*
+	 * Once the device has responded to an INQUIRY and we know the
+	 * device is online, we call into the low level driver with the
+	 * struct scsi_device *.  If the low level device driver implements
+	 * this function, it *must* perform the task of setting the queue
+	 * depth on the device.  All other tasks are optional and depend
+	 * on what the driver supports and various implementation details.
+	 * 
+	 * Things currently recommended to be handled at this time include:
+	 *
+	 * 1.  Setting the device queue depth.  Proper setting of this is
+	 *     described in the comments for scsi_adjust_queue_depth.
+	 * 2.  Determining if the device supports the various synchronous
+	 *     negotiation protocols.  The device struct will already have
+	 *     responded to INQUIRY and the results of the standard items
+	 *     will have been shoved into the various device flag bits, eg.
+	 *     device->sdtr will be true if the device supports SDTR messages.
+	 * 3.  Allocating command structs that the device will need.
+	 * 4.  Setting the default timeout on this device (if needed).
+	 * 5.  Anything else the low level driver might want to do on a device
+	 *     specific setup basis...
+	 * 6.  Return 0 on success, non-0 on error.  The device will be marked
+	 *     as offline on error so that no access will occur.  If you return
+	 *     non-0, your slave_destroy routine will never get called for this
+	 *     device, so don't leave any loose memory hanging around, clean
+	 *     up after yourself before returning non-0
+	 *
+	 * Status: OPTIONAL
+	 */
+	int (* slave_configure)(struct scsi_device *);
+
+	/*
+	 * Immediately prior to deallocating the device and after all activity
+	 * has ceased the mid layer calls this point so that the low level
+	 * driver may completely detach itself from the scsi device and vice
+	 * versa.  The low level driver is responsible for freeing any memory
+	 * it allocated in the slave_alloc or slave_configure calls. 
+	 *
+	 * Status: OPTIONAL
+	 */
+	void (* slave_destroy)(struct scsi_device *);
+
+	/*
+	 * fill in this function to allow the queue depth of this host
+	 * to be changeable (on a per device basis).  returns either
+	 * the current queue depth setting (may be different from what
+	 * was passed in) or an error.  An error should only be
+	 * returned if the requested depth is legal but the driver was
+	 * unable to set it.  If the requested depth is illegal, the
+	 * driver should set and return the closest legal queue depth.
+	 *
+	 */
+	int (* change_queue_depth)(struct scsi_device *, int);
+
+	/*
+	 * fill in this function to allow the changing of tag types
+	 * (this also allows the enabling/disabling of tag command
+	 * queueing).  An error should only be returned if something
+	 * went wrong in the driver while trying to set the tag type.
+	 * If the driver doesn't support the requested tag type, then
+	 * it should set the closest type it does support without
+	 * returning an error.  Returns the actual tag type set.
+	 */
+	int (* change_queue_type)(struct scsi_device *, int);
+
+	/*
+	 * This function determines the bios parameters for a given
+	 * harddisk.  These tend to be numbers that are made up by
+	 * the host adapter.  Parameters:
+	 * size, device, list (heads, sectors, cylinders)
+	 *
+	 * Status: OPTIONAL */
+	int (* bios_param)(struct scsi_device *, struct block_device *,
+			sector_t, int []);
+
+	/*
+	 * Can be used to export driver statistics and other infos to the
+	 * world outside the kernel ie. userspace and it also provides an
+	 * interface to feed the driver with information.
+	 *
+	 * Status: OBSOLETE
+	 */
+	int (*proc_info)(struct Scsi_Host *, char *, char **, off_t, int, int);
+
+	/*
+	 * Name of proc directory
+	 */
+	char *proc_name;
+
+	/*
+	 * Used to store the procfs directory if a driver implements the
+	 * proc_info method.
+	 */
+	struct proc_dir_entry *proc_dir;
+
+	/*
+	 * This determines if we will use a non-interrupt driven
+	 * or an interrupt driven scheme,  It is set to the maximum number
+	 * of simultaneous commands a given host adapter will accept.
+	 */
+	int can_queue;
+
+	/*
+	 * In many instances, especially where disconnect / reconnect are
+	 * supported, our host also has an ID on the SCSI bus.  If this is
+	 * the case, then it must be reserved.  Please set this_id to -1 if
+	 * your setup is in single initiator mode, and the host lacks an
+	 * ID.
+	 */
+	int this_id;
+
+	/*
+	 * This determines the degree to which the host adapter is capable
+	 * of scatter-gather.
+	 */
+	unsigned short sg_tablesize;
+
+	/*
+	 * If the host adapter has limitations beside segment count
+	 */
+	unsigned short max_sectors;
+
+	/*
+	 * dma scatter gather segment boundary limit. a segment crossing this
+	 * boundary will be split in two.
+	 */
+	unsigned long dma_boundary;
+
+	/*
+	 * This specifies "machine infinity" for host templates which don't
+	 * limit the transfer size.  Note this limit represents an absolute
+	 * maximum, and may be over the transfer limits allowed for
+	 * individual devices (e.g. 256 for SCSI-1)
+	 */
+#define SCSI_DEFAULT_MAX_SECTORS	1024
+
+	/*
+	 * True if this host adapter can make good use of linked commands.
+	 * This will allow more than one command to be queued to a given
+	 * unit on a given host.  Set this to the maximum number of command
+	 * blocks to be provided for each device.  Set this to 1 for one
+	 * command block per lun, 2 for two, etc.  Do not set this to 0.
+	 * You should make sure that the host adapter will do the right thing
+	 * before you try setting this above 1.
+	 */
+	short cmd_per_lun;
+
+	/*
+	 * present contains counter indicating how many boards of this
+	 * type were found when we did the scan.
+	 */
+	unsigned char present;
+
+	/*
+	 * true if this host adapter uses unchecked DMA onto an ISA bus.
+	 */
+	unsigned unchecked_isa_dma:1;
+
+	/*
+	 * true if this host adapter can make good use of clustering.
+	 * I originally thought that if the tablesize was large that it
+	 * was a waste of CPU cycles to prepare a cluster list, but
+	 * it works out that the Buslogic is faster if you use a smaller
+	 * number of segments (i.e. use clustering).  I guess it is
+	 * inefficient.
+	 */
+	unsigned use_clustering:1;
+
+	/*
+	 * True for emulated SCSI host adapters (e.g. ATAPI)
+	 */
+	unsigned emulated:1;
+
+	/*
+	 * True if the low-level driver performs its own reset-settle delays.
+	 */
+	unsigned skip_settle_delay:1;
+
+	/*
+	 * ordered write support
+	 */
+	unsigned ordered_flush:1;
+	unsigned ordered_tag:1;
+
+	/*
+	 * Countdown for host blocking with no commands outstanding
+	 */
+	unsigned int max_host_blocked;
+
+	/*
+	 * Default value for the blocking.  If the queue is empty,
+	 * host_blocked counts down in the request_fn until it restarts
+	 * host operations as zero is reached.  
+	 *
+	 * FIXME: This should probably be a value in the template
+	 */
+#define SCSI_DEFAULT_HOST_BLOCKED	7
+
+	/*
+	 * Pointer to the sysfs class properties for this host, NULL terminated.
+	 */
+	struct class_device_attribute **shost_attrs;
+
+	/*
+	 * Pointer to the SCSI device properties for this host, NULL terminated.
+	 */
+	struct device_attribute **sdev_attrs;
+
+	/*
+	 * List of hosts per template.
+	 *
+	 * This is only for use by scsi_module.c for legacy templates.
+	 * For these access to it is synchronized implicitly by
+	 * module_init/module_exit.
+	 */
+	struct list_head legacy_hosts;
+};
+
+/*
+ * shost states
+ */
+enum {
+	SHOST_ADD,
+	SHOST_DEL,
+	SHOST_CANCEL,
+	SHOST_RECOVERY,
+};
+
+struct Scsi_Host {
+	/*
+	 * __devices is protected by the host_lock, but you should
+	 * usually use scsi_device_lookup / shost_for_each_device
+	 * to access it and don't care about locking yourself.
+	 * In the rare case of beeing in irq context you can use
+	 * their __ prefixed variants with the lock held. NEVER
+	 * access this list directly from a driver.
+	 */
+	struct list_head	__devices;
+	struct list_head	__targets;
+	
+	struct scsi_host_cmd_pool *cmd_pool;
+	spinlock_t		free_list_lock;
+	struct list_head	free_list; /* backup store of cmd structs */
+	struct list_head	starved_list;
+
+	spinlock_t		default_lock;
+	spinlock_t		*host_lock;
+
+	struct semaphore	scan_mutex;/* serialize scanning activity */
+
+	struct list_head	eh_cmd_q;
+	struct task_struct    * ehandler;  /* Error recovery thread. */
+	struct semaphore      * eh_wait;   /* The error recovery thread waits
+					      on this. */
+	struct completion     * eh_notify; /* wait for eh to begin or end */
+	struct semaphore      * eh_action; /* Wait for specific actions on the
+                                          host. */
+	unsigned int            eh_active:1; /* Indicates the eh thread is awake and active if
+                                          this is true. */
+	unsigned int            eh_kill:1; /* set when killing the eh thread */
+	wait_queue_head_t       host_wait;
+	struct scsi_host_template *hostt;
+	struct scsi_transport_template *transportt;
+	volatile unsigned short host_busy;   /* commands actually active on low-level */
+	volatile unsigned short host_failed; /* commands that failed. */
+    
+	unsigned short host_no;  /* Used for IOCTL_GET_IDLUN, /proc/scsi et al. */
+	int resetting; /* if set, it means that last_reset is a valid value */
+	unsigned long last_reset;
+
+	/*
+	 * These three parameters can be used to allow for wide scsi,
+	 * and for host adapters that support multiple busses
+	 * The first two should be set to 1 more than the actual max id
+	 * or lun (i.e. 8 for normal systems).
+	 */
+	unsigned int max_id;
+	unsigned int max_lun;
+	unsigned int max_channel;
+
+	/*
+	 * This is a unique identifier that must be assigned so that we
+	 * have some way of identifying each detected host adapter properly
+	 * and uniquely.  For hosts that do not support more than one card
+	 * in the system at one time, this does not need to be set.  It is
+	 * initialized to 0 in scsi_register.
+	 */
+	unsigned int unique_id;
+
+	/*
+	 * The maximum length of SCSI commands that this host can accept.
+	 * Probably 12 for most host adapters, but could be 16 for others.
+	 * For drivers that don't set this field, a value of 12 is
+	 * assumed.  I am leaving this as a number rather than a bit
+	 * because you never know what subsequent SCSI standards might do
+	 * (i.e. could there be a 20 byte or a 24-byte command a few years
+	 * down the road?).  
+	 */
+	unsigned char max_cmd_len;
+
+	int this_id;
+	int can_queue;
+	short cmd_per_lun;
+	short unsigned int sg_tablesize;
+	short unsigned int max_sectors;
+	unsigned long dma_boundary;
+	/* 
+	 * Used to assign serial numbers to the cmds.
+	 * Protected by the host lock.
+	 */
+	unsigned long cmd_serial_number, cmd_pid; 
+	
+	unsigned unchecked_isa_dma:1;
+	unsigned use_clustering:1;
+	unsigned use_blk_tcq:1;
+
+	/*
+	 * Host has requested that no further requests come through for the
+	 * time being.
+	 */
+	unsigned host_self_blocked:1;
+    
+	/*
+	 * Host uses correct SCSI ordering not PC ordering. The bit is
+	 * set for the minority of drivers whose authors actually read
+	 * the spec ;)
+	 */
+	unsigned reverse_ordering:1;
+
+	/*
+	 * ordered write support
+	 */
+	unsigned ordered_flush:1;
+	unsigned ordered_tag:1;
+
+	/*
+	 * Optional work queue to be utilized by the transport
+	 */
+	char work_q_name[KOBJ_NAME_LEN];
+	struct workqueue_struct *work_q;
+
+	/*
+	 * Host has rejected a command because it was busy.
+	 */
+	unsigned int host_blocked;
+
+	/*
+	 * Value host_blocked counts down from
+	 */
+	unsigned int max_host_blocked;
+
+	/* legacy crap */
+	unsigned long base;
+	unsigned long io_port;
+	unsigned char n_io_port;
+	unsigned char dma_channel;
+	unsigned int  irq;
+	
+
+	unsigned long shost_state;
+
+	/* ldm bits */
+	struct device		shost_gendev;
+	struct class_device	shost_classdev;
+
+	/*
+	 * List of hosts per template.
+	 *
+	 * This is only for use by scsi_module.c for legacy templates.
+	 * For these access to it is synchronized implicitly by
+	 * module_init/module_exit.
+	 */
+	struct list_head sht_legacy_list;
+
+	/*
+	 * Points to the transport data (if any) which is allocated
+	 * separately
+	 */
+	void *shost_data;
+
+	/*
+	 * We should ensure that this is aligned, both for better performance
+	 * and also because some compilers (m68k) don't automatically force
+	 * alignment to a long boundary.
+	 */
+	unsigned long hostdata[0]  /* Used for storage of host specific stuff */
+		__attribute__ ((aligned (sizeof(unsigned long))));
+};
+
+#define		class_to_shost(d)	\
+	container_of(d, struct Scsi_Host, shost_classdev)
+
+int scsi_is_host_device(const struct device *);
+
+static inline struct Scsi_Host *dev_to_shost(struct device *dev)
+{
+	while (!scsi_is_host_device(dev)) {
+		if (!dev->parent)
+			return NULL;
+		dev = dev->parent;
+	}
+	return container_of(dev, struct Scsi_Host, shost_gendev);
+}
+
+extern int scsi_queue_work(struct Scsi_Host *, struct work_struct *);
+extern void scsi_flush_work(struct Scsi_Host *);
+
+extern struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *, int);
+extern int __must_check scsi_add_host(struct Scsi_Host *, struct device *);
+extern void scsi_scan_host(struct Scsi_Host *);
+extern void scsi_scan_single_target(struct Scsi_Host *, unsigned int,
+	unsigned int);
+extern void scsi_rescan_device(struct device *);
+extern void scsi_remove_host(struct Scsi_Host *);
+extern struct Scsi_Host *scsi_host_get(struct Scsi_Host *);
+extern void scsi_host_put(struct Scsi_Host *t);
+extern struct Scsi_Host *scsi_host_lookup(unsigned short);
+
+extern u64 scsi_calculate_bounce_limit(struct Scsi_Host *);
+
+static inline void scsi_assign_lock(struct Scsi_Host *shost, spinlock_t *lock)
+{
+	shost->host_lock = lock;
+}
+
+static inline void scsi_set_device(struct Scsi_Host *shost,
+                                   struct device *dev)
+{
+        shost->shost_gendev.parent = dev;
+}
+
+static inline struct device *scsi_get_device(struct Scsi_Host *shost)
+{
+        return shost->shost_gendev.parent;
+}
+
+extern void scsi_unblock_requests(struct Scsi_Host *);
+extern void scsi_block_requests(struct Scsi_Host *);
+
+struct class_container;
+/*
+ * These two functions are used to allocate and free a pseudo device
+ * which will connect to the host adapter itself rather than any
+ * physical device.  You must deallocate when you are done with the
+ * thing.  This physical pseudo-device isn't real and won't be available
+ * from any high-level drivers.
+ */
+extern void scsi_free_host_dev(struct scsi_device *);
+extern struct scsi_device *scsi_get_host_dev(struct Scsi_Host *);
+
+/* legacy interfaces */
+extern struct Scsi_Host *scsi_register(struct scsi_host_template *, int);
+extern void scsi_unregister(struct Scsi_Host *);
+
+#endif /* _SCSI_SCSI_HOST_H */
