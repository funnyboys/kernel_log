commit f3e4ff28b8685d856f381ee6bcf88b6149a6db5b
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Jul 24 11:00:54 2019 +0200

    scsi: libfc: Whitespace cleanup in libfc.h
    
    No functional change.
    
    [mkp: typo]
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 2d64b53f947c..9b87e1a1c646 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -115,7 +115,7 @@ struct fc_disc_port {
 	struct fc_lport    *lp;
 	struct list_head   peers;
 	struct work_struct rport_work;
-	u32                port_id;
+	u32		   port_id;
 };
 
 /**
@@ -155,14 +155,14 @@ struct fc_rport_operations {
  */
 struct fc_rport_libfc_priv {
 	struct fc_lport		   *local_port;
-	enum fc_rport_state        rp_state;
+	enum fc_rport_state	   rp_state;
 	u16			   flags;
 	#define FC_RP_FLAGS_REC_SUPPORTED	(1 << 0)
 	#define FC_RP_FLAGS_RETRY		(1 << 1)
 	#define FC_RP_STARTED			(1 << 2)
 	#define FC_RP_FLAGS_CONF_REQ		(1 << 3)
-	unsigned int	           e_d_tov;
-	unsigned int	           r_a_tov;
+	unsigned int		   e_d_tov;
+	unsigned int		   r_a_tov;
 };
 
 /**
@@ -191,24 +191,24 @@ struct fc_rport_priv {
 	struct fc_lport		    *local_port;
 	struct fc_rport		    *rport;
 	struct kref		    kref;
-	enum fc_rport_state         rp_state;
+	enum fc_rport_state	    rp_state;
 	struct fc_rport_identifiers ids;
 	u16			    flags;
-	u16		            max_seq;
+	u16			    max_seq;
 	u16			    disc_id;
 	u16			    maxframe_size;
-	unsigned int	            retries;
-	unsigned int	            major_retries;
-	unsigned int	            e_d_tov;
-	unsigned int	            r_a_tov;
-	struct mutex                rp_mutex;
+	unsigned int		    retries;
+	unsigned int		    major_retries;
+	unsigned int		    e_d_tov;
+	unsigned int		    r_a_tov;
+	struct mutex		    rp_mutex;
 	struct delayed_work	    retry_work;
-	enum fc_rport_event         event;
+	enum fc_rport_event	    event;
 	struct fc_rport_operations  *ops;
-	struct list_head            peers;
-	struct work_struct          event_work;
+	struct list_head	    peers;
+	struct work_struct	    event_work;
 	u32			    supported_classes;
-	u16                         prli_count;
+	u16			    prli_count;
 	struct rcu_head		    rcu;
 	u16			    sp_features;
 	u8			    spp_type;
@@ -618,12 +618,12 @@ struct libfc_function_template {
  * @disc_callback: Callback routine called when discovery completes
  */
 struct fc_disc {
-	unsigned char         retry_count;
-	unsigned char         pending;
-	unsigned char         requested;
-	unsigned short        seq_count;
-	unsigned char         buf_len;
-	u16                   disc_id;
+	unsigned char	      retry_count;
+	unsigned char	      pending;
+	unsigned char	      requested;
+	unsigned short	      seq_count;
+	unsigned char	      buf_len;
+	u16		      disc_id;
 
 	struct list_head      rports;
 	void		      *priv;
@@ -697,7 +697,7 @@ struct fc_lport {
 	struct fc_rport_priv	       *ms_rdata;
 	struct fc_rport_priv	       *ptp_rdata;
 	void			       *scsi_priv;
-	struct fc_disc                 disc;
+	struct fc_disc		       disc;
 
 	/* Virtual port information */
 	struct list_head	       vports;
@@ -715,7 +715,7 @@ struct fc_lport {
 	u8			       retry_count;
 
 	/* Fabric information */
-	u32                            port_id;
+	u32			       port_id;
 	u64			       wwpn;
 	u64			       wwnn;
 	unsigned int		       service_params;
@@ -743,11 +743,11 @@ struct fc_lport {
 	struct fc_ns_fts	       fcts;
 
 	/* Miscellaneous */
-	struct mutex                   lp_mutex;
-	struct list_head               list;
+	struct mutex		       lp_mutex;
+	struct list_head	       list;
 	struct delayed_work	       retry_work;
 	void			       *prov[FC_FC4_PROV_SIZE];
-	struct list_head               lport_list;
+	struct list_head	       lport_list;
 };
 
 /**

commit a61127c2130236168321cc76c5a58e15c00ad154
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:49 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 335
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 51 franklin st fifth floor boston ma 02110
      1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 111 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.567572064@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 2109844be53d..2d64b53f947c 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -1,19 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright(c) 2007 Intel Corporation. All rights reserved.
  *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
  * Maintained at www.Open-FCoE.org
  */
 

commit 22c70d1a9c639b432ffdf083bea44752ad9fc8f3
Author: Elena Reshetova <elena.reshetova@intel.com>
Date:   Thu Mar 9 09:44:02 2017 +0200

    scsi: libfc: convert fc_fcp_pkt.ref_cnt from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be used instead of atomic_t
    when the variable is used as a reference counter. This allows to avoid
    accidental refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index da5033dd8cbc..2109844be53d 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -23,6 +23,7 @@
 #include <linux/timer.h>
 #include <linux/if.h>
 #include <linux/percpu.h>
+#include <linux/refcount.h>
 
 #include <scsi/scsi_transport.h>
 #include <scsi/scsi_transport_fc.h>
@@ -321,7 +322,7 @@ struct fc_seq_els_data {
  */
 struct fc_fcp_pkt {
 	spinlock_t	  scsi_pkt_lock;
-	atomic_t	  ref_cnt;
+	refcount_t	  ref_cnt;
 
 	/* SCSI command and data transfer information */
 	u32		  data_len;

commit 67d35e70af9cabb663c827e03bc5c1e89b43db72
Author: Fam Zheng <famz@redhat.com>
Date:   Fri Jan 13 11:40:01 2017 +0800

    scsi: libfc: Fix variable name in fc_set_wwpn
    
    The parameter name should be wwpn instead of wwnn.
    
    Signed-off-by: Fam Zheng <famz@redhat.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 96dd0b3f70d7..da5033dd8cbc 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -809,11 +809,11 @@ static inline void fc_set_wwnn(struct fc_lport *lport, u64 wwnn)
 /**
  * fc_set_wwpn() - Set the World Wide Port Name of a local port
  * @lport: The local port whose WWPN is to be set
- * @wwnn:  The new WWPN
+ * @wwpn:  The new WWPN
  */
-static inline void fc_set_wwpn(struct fc_lport *lport, u64 wwnn)
+static inline void fc_set_wwpn(struct fc_lport *lport, u64 wwpn)
 {
-	lport->wwpn = wwnn;
+	lport->wwpn = wwpn;
 }
 
 /**

commit 75cc8cfc6e13d42d50c2bf4307d0a68c2a70f709
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Thu Nov 17 10:31:19 2016 +0100

    scsi: change FC drivers to use 'struct bsg_job'
    
    Change FC drivers to use 'struct bsg_job' from bsg-lib.h instead of
    'struct fc_bsg_job' from scsi_transport_fc.h and remove 'struct
    fc_bsg_job'.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 6f81b28364da..96dd0b3f70d7 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -912,7 +912,7 @@ void fc_lport_recv(struct fc_lport *lport, struct fc_frame *fp);
 int fc_set_mfs(struct fc_lport *, u32 mfs);
 struct fc_lport *libfc_vport_create(struct fc_vport *, int privsize);
 struct fc_lport *fc_vport_id_lookup(struct fc_lport *, u32 port_id);
-int fc_lport_bsg_request(struct fc_bsg_job *);
+int fc_lport_bsg_request(struct bsg_job *);
 void fc_lport_set_local_id(struct fc_lport *, u32 port_id);
 void fc_lport_iterate(void (*func)(struct fc_lport *, void *), void *);
 

commit 9625cc483b8c41d500ec78f0f2e61d71db1431f5
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:54 2016 +0200

    scsi: libfc: Replace ->seq_release callback with function call
    
    The ->seq_release callback only ever had one implementation,
    so call the function directly and drop the callback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 2baa2553c977..6f81b28364da 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -514,13 +514,6 @@ struct libfc_function_template {
 	 */
 	void (*get_lesb)(struct fc_lport *, struct fc_els_lesb *lesb);
 
-	/*
-	 * Release the reference on the sequence returned by seq_assign().
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	void (*seq_release)(struct fc_seq *);
-
 	/*
 	 * Reset an exchange manager, completing all sequences and exchanges.
 	 * If s_id is non-zero, reset only exchanges originating from that FID.
@@ -1000,6 +993,7 @@ void fc_seq_set_resp(struct fc_seq *sp,
 		     void (*resp)(struct fc_seq *, struct fc_frame *, void *),
 		     void *arg);
 struct fc_seq *fc_seq_assign(struct fc_lport *lport, struct fc_frame *fp);
+void fc_seq_release(struct fc_seq *sp);
 struct fc_exch_mgr_anchor *fc_exch_mgr_add(struct fc_lport *,
 					   struct fc_exch_mgr *,
 					   bool (*match)(struct fc_frame *));

commit 96d564e24ac2b69fbfa2b81d48069ffeede549d7
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:53 2016 +0200

    scsi: libfc: Replace ->seq_assign callback with function call
    
    The ->seq_assign callback only ever had one implementation,
    so call the function directly and drop the callback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index e8669f9f2e50..2baa2553c977 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -514,13 +514,6 @@ struct libfc_function_template {
 	 */
 	void (*get_lesb)(struct fc_lport *, struct fc_els_lesb *lesb);
 
-	/*
-	 * Assign a sequence for an incoming request frame.
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	struct fc_seq *(*seq_assign)(struct fc_lport *, struct fc_frame *);
-
 	/*
 	 * Release the reference on the sequence returned by seq_assign().
 	 *
@@ -1006,6 +999,7 @@ struct fc_seq *fc_seq_start_next(struct fc_seq *sp);
 void fc_seq_set_resp(struct fc_seq *sp,
 		     void (*resp)(struct fc_seq *, struct fc_frame *, void *),
 		     void *arg);
+struct fc_seq *fc_seq_assign(struct fc_lport *lport, struct fc_frame *fp);
 struct fc_exch_mgr_anchor *fc_exch_mgr_add(struct fc_lport *,
 					   struct fc_exch_mgr *,
 					   bool (*match)(struct fc_frame *));

commit f1d61e6e682cd241c145e6268be3a9f30af934eb
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:52 2016 +0200

    scsi: libfc: Replace ->seq_set_resp callback with direct function call
    
    The ->seq_set_resp callback only ever had one implementation,
    so call it directly and drop the callback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 39143cabaa90..e8669f9f2e50 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -514,16 +514,6 @@ struct libfc_function_template {
 	 */
 	void (*get_lesb)(struct fc_lport *, struct fc_els_lesb *lesb);
 
-	/*
-	 * Set a response handler for the exchange of the sequence.
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	void (*seq_set_resp)(struct fc_seq *sp,
-			     void (*resp)(struct fc_seq *, struct fc_frame *,
-					  void *),
-			     void *arg);
-
 	/*
 	 * Assign a sequence for an incoming request frame.
 	 *
@@ -1013,6 +1003,9 @@ struct fc_seq *fc_exch_seq_send(struct fc_lport *lport,
 void fc_seq_els_rsp_send(struct fc_frame *, enum fc_els_cmd,
 			 struct fc_seq_els_data *);
 struct fc_seq *fc_seq_start_next(struct fc_seq *sp);
+void fc_seq_set_resp(struct fc_seq *sp,
+		     void (*resp)(struct fc_seq *, struct fc_frame *, void *),
+		     void *arg);
 struct fc_exch_mgr_anchor *fc_exch_mgr_add(struct fc_lport *,
 					   struct fc_exch_mgr *,
 					   bool (*match)(struct fc_frame *));

commit c6865b30be7ed894839687b26f2cde9b99b97270
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:51 2016 +0200

    scsi: libfc: Replace ->seq_start_next callback with function call
    
    The ->seq_start_next callback only ever had one implementation,
    so call the function directly and drop the callback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 19f38eb318ec..39143cabaa90 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -514,13 +514,6 @@ struct libfc_function_template {
 	 */
 	void (*get_lesb)(struct fc_lport *, struct fc_els_lesb *lesb);
 
-	/*
-	 * Start a new sequence on the same exchange/sequence tuple.
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	struct fc_seq *(*seq_start_next)(struct fc_seq *);
-
 	/*
 	 * Set a response handler for the exchange of the sequence.
 	 *
@@ -1019,6 +1012,7 @@ struct fc_seq *fc_exch_seq_send(struct fc_lport *lport,
 				void *arg, u32 timer_msec);
 void fc_seq_els_rsp_send(struct fc_frame *, enum fc_els_cmd,
 			 struct fc_seq_els_data *);
+struct fc_seq *fc_seq_start_next(struct fc_seq *sp);
 struct fc_exch_mgr_anchor *fc_exch_mgr_add(struct fc_lport *,
 					   struct fc_exch_mgr *,
 					   bool (*match)(struct fc_frame *));

commit 768c72cc34a26ed1c41c9af89886f91af08ded8c
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:50 2016 +0200

    scsi: libfc: Replace ->exch_done callback with function call
    
    The ->exch_done callback only ever had one implementation,
    so we can as well call it directly and drop the callback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 50d1af1eba1e..19f38eb318ec 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -514,14 +514,6 @@ struct libfc_function_template {
 	 */
 	void (*get_lesb)(struct fc_lport *, struct fc_els_lesb *lesb);
 
-	/*
-	 * Indicate that an exchange/sequence tuple is complete and the memory
-	 * allocated for the related objects may be freed.
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	void (*exch_done)(struct fc_seq *);
-
 	/*
 	 * Start a new sequence on the same exchange/sequence tuple.
 	 *
@@ -1040,6 +1032,7 @@ void fc_exch_recv(struct fc_lport *, struct fc_frame *);
 void fc_exch_mgr_reset(struct fc_lport *, u32 s_id, u32 d_id);
 int fc_seq_send(struct fc_lport *lport, struct fc_seq *sp, struct fc_frame *fp);
 int fc_seq_exch_abort(const struct fc_seq *, unsigned int timer_msec);
+void fc_exch_done(struct fc_seq *sp);
 
 /*
  * Functions for fc_functions_template

commit 0ebaed17febadeda0f4da21da2c0f295f46348a4
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:49 2016 +0200

    scsi: libfc: Replace ->seq_exch_abort callback with function call
    
    The ->seq_exch_abort callback only ever had one implementation,
    so we can as well call it directly and drop the callback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 7514cc969f8c..50d1af1eba1e 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -514,19 +514,6 @@ struct libfc_function_template {
 	 */
 	void (*get_lesb)(struct fc_lport *, struct fc_els_lesb *lesb);
 
-	/*
-	 * Abort an exchange and sequence. Generally called because of a
-	 * exchange timeout or an abort from the upper layer.
-	 *
-	 * A timer_msec can be specified for abort timeout, if non-zero
-	 * timer_msec value is specified then exchange resp handler
-	 * will be called with timeout error if no response to abort.
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	int (*seq_exch_abort)(const struct fc_seq *,
-			      unsigned int timer_msec);
-
 	/*
 	 * Indicate that an exchange/sequence tuple is complete and the memory
 	 * allocated for the related objects may be freed.
@@ -1052,6 +1039,7 @@ void fc_exch_mgr_free(struct fc_lport *);
 void fc_exch_recv(struct fc_lport *, struct fc_frame *);
 void fc_exch_mgr_reset(struct fc_lport *, u32 s_id, u32 d_id);
 int fc_seq_send(struct fc_lport *lport, struct fc_seq *sp, struct fc_frame *fp);
+int fc_seq_exch_abort(const struct fc_seq *, unsigned int timer_msec);
 
 /*
  * Functions for fc_functions_template

commit 0cac937da525ae3aa9f4b82c6ca129d16bb321fe
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:48 2016 +0200

    scsi: libfc: Replace ->seq_send callback with function call
    
    The ->seq_send callback only ever had one implementation,
    so we can as well call it directly and drop the callback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index a77690125021..7514cc969f8c 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -513,13 +513,6 @@ struct libfc_function_template {
 	 * STATUS: OPTIONAL
 	 */
 	void (*get_lesb)(struct fc_lport *, struct fc_els_lesb *lesb);
-	/*
-	 * Send a frame using an existing sequence and exchange.
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	int (*seq_send)(struct fc_lport *, struct fc_seq *,
-			struct fc_frame *);
 
 	/*
 	 * Abort an exchange and sequence. Generally called because of a
@@ -1058,6 +1051,7 @@ struct fc_exch_mgr *fc_exch_mgr_alloc(struct fc_lport *, enum fc_class class,
 void fc_exch_mgr_free(struct fc_lport *);
 void fc_exch_recv(struct fc_lport *, struct fc_frame *);
 void fc_exch_mgr_reset(struct fc_lport *, u32 s_id, u32 d_id);
+int fc_seq_send(struct fc_lport *lport, struct fc_seq *sp, struct fc_frame *fp);
 
 /*
  * Functions for fc_functions_template

commit a8220ded095695f2f11f0c35e1d2578bb0ec0e8f
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:47 2016 +0200

    scsi: libfc: Remove fc_rport_init()
    
    Function is empty now and can be removed.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Reviewed-by: Chad Dupuis <chad.dupuis@cavium.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 57630c5a7fc4..a77690125021 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -978,7 +978,6 @@ void fc_lport_iterate(void (*func)(struct fc_lport *, void *), void *);
 /*
  * REMOTE PORT LAYER
  *****************************/
-int fc_rport_init(struct fc_lport *);
 void fc_rport_terminate_io(struct fc_rport *);
 struct fc_rport_priv *fc_rport_lookup(const struct fc_lport *lport,
 				      u32 port_id);

commit 5922a957457c9146fc601ce3c36a076dde249593
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:46 2016 +0200

    scsi: libfc: Replace ->rport_flush_queue callback with function call
    
    The ->rport_flush_queue callback only ever had a single
    implementation, so we can as well call it directly and
    drop the callback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 1e1dbc94d54a..57630c5a7fc4 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -582,13 +582,6 @@ struct libfc_function_template {
 	 */
 	void (*exch_mgr_reset)(struct fc_lport *, u32 s_id, u32 d_id);
 
-	/*
-	 * Flush the rport work queue. Generally used before shutdown.
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	void (*rport_flush_queue)(void);
-
 	/*
 	 * Set the local port FC_ID.
 	 *
@@ -994,6 +987,7 @@ void fc_rport_destroy(struct kref *kref);
 int fc_rport_login(struct fc_rport_priv *rdata);
 int fc_rport_logoff(struct fc_rport_priv *rdata);
 void fc_rport_recv_req(struct fc_lport *lport, struct fc_frame *fp);
+void fc_rport_flush_queue(void);
 
 /*
  * DISCOVERY LAYER

commit e76ee65fa649740fde0da44a0e1dc458407c685c
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:45 2016 +0200

    scsi: libfc: Replace ->rport_recv_req callback with function call
    
    The ->rport_recv_req callback only ever had one implementation,
    so we can as well call it directly and drop the callback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index b75a1820d226..1e1dbc94d54a 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -609,13 +609,6 @@ struct libfc_function_template {
 	void (*lport_set_port_id)(struct fc_lport *, u32 port_id,
 				  struct fc_frame *);
 
-	/*
-	 * Receive a request from a remote port.
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	void (*rport_recv_req)(struct fc_lport *, struct fc_frame *);
-
 	/*
 	 * Callback routine after the remote port is logged in
 	 *
@@ -1000,6 +993,7 @@ struct fc_rport_priv *fc_rport_create(struct fc_lport *, u32);
 void fc_rport_destroy(struct kref *kref);
 int fc_rport_login(struct fc_rport_priv *rdata);
 int fc_rport_logoff(struct fc_rport_priv *rdata);
+void fc_rport_recv_req(struct fc_lport *lport, struct fc_frame *fp);
 
 /*
  * DISCOVERY LAYER

commit c96c792aee33ab1a06c4d595959cd92eddbdbf3e
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:44 2016 +0200

    scsi: libfc: Replace ->rport_logoff callback with function call
    
    The ->rport_logoff callback only ever had one implementation,
    so we can as well call it directly and drop the callback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Reviewed-by: Chad Dupuis <chad.dupuis@cavium.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 64045778e616..b75a1820d226 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -609,14 +609,6 @@ struct libfc_function_template {
 	void (*lport_set_port_id)(struct fc_lport *, u32 port_id,
 				  struct fc_frame *);
 
-	/*
-	 * Logoff, and remove the rport from the transport if
-	 * it had been added. This will send a LOGO to the target.
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	int (*rport_logoff)(struct fc_rport_priv *);
-
 	/*
 	 * Receive a request from a remote port.
 	 *
@@ -1007,6 +999,7 @@ struct fc_rport_priv *fc_rport_lookup(const struct fc_lport *lport,
 struct fc_rport_priv *fc_rport_create(struct fc_lport *, u32);
 void fc_rport_destroy(struct kref *kref);
 int fc_rport_login(struct fc_rport_priv *rdata);
+int fc_rport_logoff(struct fc_rport_priv *rdata);
 
 /*
  * DISCOVERY LAYER

commit 05d7d3b0bd07e3990ab7a39ee93be28dbf7091d4
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:43 2016 +0200

    scsi: libfc: Replace ->rport_login callback with function call
    
    The ->rport_login callback only ever had one implementation,
    so we can as well call it directly and drop the callback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 47b69d26be99..64045778e616 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -609,19 +609,6 @@ struct libfc_function_template {
 	void (*lport_set_port_id)(struct fc_lport *, u32 port_id,
 				  struct fc_frame *);
 
-	/*
-	 * Initiates the RP state machine. It is called from the LP module.
-	 * This function will issue the following commands to the N_Port
-	 * identified by the FC ID provided.
-	 *
-	 * - PLOGI
-	 * - PRLI
-	 * - RTV
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	int (*rport_login)(struct fc_rport_priv *);
-
 	/*
 	 * Logoff, and remove the rport from the transport if
 	 * it had been added. This will send a LOGO to the target.
@@ -1019,6 +1006,7 @@ struct fc_rport_priv *fc_rport_lookup(const struct fc_lport *lport,
 				      u32 port_id);
 struct fc_rport_priv *fc_rport_create(struct fc_lport *, u32);
 void fc_rport_destroy(struct kref *kref);
+int fc_rport_login(struct fc_rport_priv *rdata);
 
 /*
  * DISCOVERY LAYER

commit 2580064b5ec6dc9efa475298b276ab21f5cc287d
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:42 2016 +0200

    scsi: libfc: Replace ->rport_create callback with function call
    
    The ->rport_create callback only ever had a single implementation,
    so we can as well call it directly and drop the callback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 683201f23500..47b69d26be99 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -609,13 +609,6 @@ struct libfc_function_template {
 	void (*lport_set_port_id)(struct fc_lport *, u32 port_id,
 				  struct fc_frame *);
 
-	/*
-	 * Create a remote port with a given port ID
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	struct fc_rport_priv *(*rport_create)(struct fc_lport *, u32);
-
 	/*
 	 * Initiates the RP state machine. It is called from the LP module.
 	 * This function will issue the following commands to the N_Port
@@ -1024,6 +1017,7 @@ int fc_rport_init(struct fc_lport *);
 void fc_rport_terminate_io(struct fc_rport *);
 struct fc_rport_priv *fc_rport_lookup(const struct fc_lport *lport,
 				      u32 port_id);
+struct fc_rport_priv *fc_rport_create(struct fc_lport *, u32);
 void fc_rport_destroy(struct kref *kref);
 
 /*

commit e87b77779381ca148006da1d5f541df52ff6a445
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:40 2016 +0200

    scsi: libfc: Replace ->rport_lookup callback with function call
    
    The ->rport_lookup callback only ever had a single implementation,
    so we can as well call it directly and drop the callback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index cec450f2db7b..683201f23500 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -644,13 +644,6 @@ struct libfc_function_template {
 	 */
 	void (*rport_recv_req)(struct fc_lport *, struct fc_frame *);
 
-	/*
-	 * lookup an rport by it's port ID.
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	struct fc_rport_priv *(*rport_lookup)(const struct fc_lport *, u32);
-
 	/*
 	 * Callback routine after the remote port is logged in
 	 *
@@ -1029,6 +1022,8 @@ void fc_lport_iterate(void (*func)(struct fc_lport *, void *), void *);
  *****************************/
 int fc_rport_init(struct fc_lport *);
 void fc_rport_terminate_io(struct fc_rport *);
+struct fc_rport_priv *fc_rport_lookup(const struct fc_lport *lport,
+				      u32 port_id);
 void fc_rport_destroy(struct kref *kref);
 
 /*

commit 944ef9689d8affc13d16c09ac2dba56c5b4c5ff7
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:39 2016 +0200

    scsi: libfc: Replace ->rport_destroy callback with function call
    
    The ->rport_destroy callback only ever had one implementation,
    so we can as well call it directly and drop the callback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 5e8a2083dbf0..cec450f2db7b 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -651,12 +651,6 @@ struct libfc_function_template {
 	 */
 	struct fc_rport_priv *(*rport_lookup)(const struct fc_lport *, u32);
 
-	/*
-	 * Destroy an rport after final kref_put().
-	 * The argument is a pointer to the kref inside the fc_rport_priv.
-	 */
-	void (*rport_destroy)(struct kref *);
-
 	/*
 	 * Callback routine after the remote port is logged in
 	 *
@@ -1035,6 +1029,7 @@ void fc_lport_iterate(void (*func)(struct fc_lport *, void *), void *);
  *****************************/
 int fc_rport_init(struct fc_lport *);
 void fc_rport_terminate_io(struct fc_rport *);
+void fc_rport_destroy(struct kref *kref);
 
 /*
  * DISCOVERY LAYER

commit 3afd2d1521951cb05ef5279b71634cc55ace688b
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:38 2016 +0200

    scsi: libfc: Replace ->exch_seq_send callback with function call
    
    The ->exch_seq_send callback only ever had one implementation,
    so we can call the function directly and drop the callback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 7bba81ebb0e7..5e8a2083dbf0 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -484,37 +484,6 @@ struct libfc_function_template {
 					     struct fc_frame *, void *arg),
 				     void *arg, u32 timer_msec);
 
-	/*
-	 * Send the FC frame payload using a new exchange and sequence.
-	 *
-	 * The exchange response handler is set in this routine to resp()
-	 * function pointer. It can be called in two scenarios: if a timeout
-	 * occurs or if a response frame is received for the exchange. The
-	 * fc_frame pointer in response handler will also indicate timeout
-	 * as error using IS_ERR related macros.
-	 *
-	 * The exchange destructor handler is also set in this routine.
-	 * The destructor handler is invoked by EM layer when exchange
-	 * is about to free, this can be used by caller to free its
-	 * resources along with exchange free.
-	 *
-	 * The arg is passed back to resp and destructor handler.
-	 *
-	 * The timeout value (in msec) for an exchange is set if non zero
-	 * timer_msec argument is specified. The timer is canceled when
-	 * it fires or when the exchange is done. The exchange timeout handler
-	 * is registered by EM layer.
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	struct fc_seq *(*exch_seq_send)(struct fc_lport *, struct fc_frame *,
-					void (*resp)(struct fc_seq *,
-						     struct fc_frame *,
-						     void *),
-					void (*destructor)(struct fc_seq *,
-							   void *),
-					void *, unsigned int timer_msec);
-
 	/*
 	 * Sets up the DDP context for a given exchange id on the given
 	 * scatterlist if LLD supports DDP for large receive.
@@ -1117,6 +1086,13 @@ void fc_fill_hdr(struct fc_frame *, const struct fc_frame *,
  *****************************/
 int fc_exch_init(struct fc_lport *);
 void fc_exch_update_stats(struct fc_lport *lport);
+struct fc_seq *fc_exch_seq_send(struct fc_lport *lport,
+				struct fc_frame *fp,
+				void (*resp)(struct fc_seq *,
+					     struct fc_frame *fp,
+					     void *arg),
+				void (*destructor)(struct fc_seq *, void *),
+				void *arg, u32 timer_msec);
 void fc_seq_els_rsp_send(struct fc_frame *, enum fc_els_cmd,
 			 struct fc_seq_els_data *);
 struct fc_exch_mgr_anchor *fc_exch_mgr_add(struct fc_lport *,

commit c5cb444c31d1577d2dd207101ba9cf498e1c2d48
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:37 2016 +0200

    scsi: libfc: Replace ->lport_recv with function call
    
    The ->lport_recv callback only ever had one implementation,
    so call the function directly and remove the callback.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 7ee0d2741192..7bba81ebb0e7 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -620,13 +620,6 @@ struct libfc_function_template {
 	 */
 	void (*rport_flush_queue)(void);
 
-	/*
-	 * Receive a frame for a local port.
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	void (*lport_recv)(struct fc_lport *, struct fc_frame *);
-
 	/*
 	 * Set the local port FC_ID.
 	 *
@@ -1060,6 +1053,7 @@ void fc_vport_setlink(struct fc_lport *);
 void fc_vports_linkchange(struct fc_lport *);
 int fc_lport_config(struct fc_lport *);
 int fc_lport_reset(struct fc_lport *);
+void fc_lport_recv(struct fc_lport *lport, struct fc_frame *fp);
 int fc_set_mfs(struct fc_lport *, u32 mfs);
 struct fc_lport *libfc_vport_create(struct fc_vport *, int privsize);
 struct fc_lport *fc_vport_id_lookup(struct fc_lport *, u32 port_id);

commit 31c0a631a430b01e05ff1e35f287fb8dfa0ef519
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:36 2016 +0200

    scsi: libfc: Replace ->lport_reset callback with function call
    
    The ->lport_reset callback only ever had one implementation,
    which already is exported. So remove it and use the function
    directly.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 0e9580311e60..7ee0d2741192 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -627,13 +627,6 @@ struct libfc_function_template {
 	 */
 	void (*lport_recv)(struct fc_lport *, struct fc_frame *);
 
-	/*
-	 * Reset the local port.
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	int (*lport_reset)(struct fc_lport *);
-
 	/*
 	 * Set the local port FC_ID.
 	 *

commit 7ab24dd16579514d261a669aa3b9e19220df5456
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Oct 18 10:01:35 2016 +0200

    scsi: libfc: Replace ->seq_els_rsp_send callback with function call
    
    The 'seq_els_rsp_send' callback only ever had one implementation,
    so we might as well drop it and use the function directly.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index f5aa54b40e75..0e9580311e60 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -552,14 +552,6 @@ struct libfc_function_template {
 	int (*seq_send)(struct fc_lport *, struct fc_seq *,
 			struct fc_frame *);
 
-	/*
-	 * Send an ELS response using information from the received frame.
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	void (*seq_els_rsp_send)(struct fc_frame *, enum fc_els_cmd,
-				 struct fc_seq_els_data *);
-
 	/*
 	 * Abort an exchange and sequence. Generally called because of a
 	 * exchange timeout or an abort from the upper layer.
@@ -1138,6 +1130,8 @@ void fc_fill_hdr(struct fc_frame *, const struct fc_frame *,
  *****************************/
 int fc_exch_init(struct fc_lport *);
 void fc_exch_update_stats(struct fc_lport *lport);
+void fc_seq_els_rsp_send(struct fc_frame *, enum fc_els_cmd,
+			 struct fc_seq_els_data *);
 struct fc_exch_mgr_anchor *fc_exch_mgr_add(struct fc_lport *,
 					   struct fc_exch_mgr *,
 					   bool (*match)(struct fc_frame *));

commit ad3120cfe0c5dcd5aaa87a0f7c42d4b09a94fa12
Author: Hannes Reinecke <hare@suse.de>
Date:   Thu Oct 13 15:10:53 2016 +0200

    scsi: libfc: reset timeout on queue full
    
    When we're receiving a timeout we should be checking for queue
    full status; if there are still some packets pending we should
    be resetting the counter to ensure we're not missing out any
    packets which are still queued.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 8cb752f8d12b..f5aa54b40e75 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -355,7 +355,8 @@ struct fc_fcp_pkt {
 
 	/* Timeout/error related information */
 	struct timer_list timer;
-	int	          wait_for_comp;
+	int		  wait_for_comp;
+	int		  timer_delay;
 	u32		  recov_retry;
 	struct fc_seq	  *recov_seq;
 	struct completion tm_done;

commit 9ca1e182b9d1ef3f97718c4072a18a23dc47d4f9
Author: Hannes Reinecke <hare@suse.de>
Date:   Thu Oct 13 15:10:50 2016 +0200

    scsi: libfc: quarantine timed out xids
    
    When a sequence times out we have no idea what happened to the
    frame. And we do not know if we will ever receive the frame.
    Hence we cannot re-use the xid as we would risk data corruption
    if the xid had been re-used and the timed out frame would be
    received after that.
    So we need to quarantine the xid until the lport is reset.
    Yes, I know this will (eventually) deplete the xid pool.
    But for now it's the safest method.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index dc42d8070f6f..8cb752f8d12b 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -390,6 +390,7 @@ struct fc_seq {
 
 #define FC_EX_DONE		(1 << 0) /* ep is completed */
 #define FC_EX_RST_CLEANUP	(1 << 1) /* reset is forcing completion */
+#define FC_EX_QUARANTINE	(1 << 2) /* exch is quarantined */
 
 /**
  * struct fc_exch - Fibre Channel Exchange

commit 9f9504a7cdee39e167f0421346ff17568a5f29a0
Author: Hannes Reinecke <hare@suse.de>
Date:   Thu Oct 13 15:10:44 2016 +0200

    scsi: libfc: use error code for fc_rport_error()
    
    We only ever use the 'fp' argument for fc_rport_error() to
    encapsulate the error code, so we can as well do away with that
    and pass the error directly.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 7428a53257ca..dc42d8070f6f 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -44,6 +44,11 @@
 #define	FC_NO_ERR	0	/* no error */
 #define	FC_EX_TIMEOUT	1	/* Exchange timeout */
 #define	FC_EX_CLOSED	2	/* Exchange closed */
+#define FC_EX_ALLOC_ERR	3	/* Exchange allocation failed */
+#define FC_EX_XMIT_ERR	4	/* Exchange transmit failed */
+#define FC_EX_ELS_RJT	5	/* ELS rejected */
+#define FC_EX_INV_LOGIN	6	/* Login not completed */
+#define FC_EX_SEQ_ERR	6	/* Exchange sequence error */
 
 /**
  * enum fc_lport_state - Local port states

commit 9a6cf881df0293cc1c06d31bcbeda6c23b95dcac
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Jul 19 13:49:40 2016 +0200

    fcoe: implement FIP VLAN responder
    
    When running in VN2VN mode there is no central instance which would send
    out any FIP VLAN discovery notifications. So this patch adds a new sysfs
    attribute 'fip_vlan_responder' which will activate a FIP VLAN discovery
    responder.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 93d14daf0994..7428a53257ca 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -878,6 +878,7 @@ struct fc_lport {
 	struct libfc_function_template tt;
 	u8			       link_up;
 	u8			       qfull;
+	u16			       vlan;
 	enum fc_lport_state	       state;
 	unsigned long		       boot_time;
 	struct fc_host_statistics      host_stats;

commit db5ed4dfd5dd0142ec36ff7b335e0ec3b836b3e6
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Nov 13 15:08:42 2014 +0100

    scsi: drop reason argument from ->change_queue_depth
    
    Drop the now unused reason argument from the ->change_queue_depth method.
    Also add a return value to scsi_adjust_queue_depth, and rename it to
    scsi_change_queue_depth now that it can be used as the default
    ->change_queue_depth implementation.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 2e0cf568a9c1..93d14daf0994 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -1105,7 +1105,6 @@ int fc_eh_abort(struct scsi_cmnd *);
 int fc_eh_device_reset(struct scsi_cmnd *);
 int fc_eh_host_reset(struct scsi_cmnd *);
 int fc_slave_alloc(struct scsi_device *);
-int fc_change_queue_depth(struct scsi_device *, int qdepth, int reason);
 
 /*
  * ELS/CT interface

commit a62182f338b39a22035531c6afc0a8d2928b1df2
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Oct 2 14:39:55 2014 +0200

    scsi: provide a generic change_queue_type method
    
    Most drivers use exactly the same implementation, so provide it as a
    library function.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 52beadf9a29b..2e0cf568a9c1 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -1106,7 +1106,6 @@ int fc_eh_device_reset(struct scsi_cmnd *);
 int fc_eh_host_reset(struct scsi_cmnd *);
 int fc_slave_alloc(struct scsi_device *);
 int fc_change_queue_depth(struct scsi_device *, int qdepth, int reason);
-int fc_change_queue_type(struct scsi_device *, int tag_type);
 
 /*
  * ELS/CT interface

commit 7030fd626129ec4d616784516a462d317c251d39
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Sat Aug 17 20:34:43 2013 +0000

    libfc: Do not invoke the response handler after fc_exch_done()
    
    While the FCoE initiator driver invokes fc_exch_done() from inside
    the libfc response handler, FCoE target drivers typically invoke
    fc_exch_done() from outside the libfc response handler. The object
    fc_exch.arg points at may disappear as soon as fc_exch_done() has
    finished. So it's important not to invoke the response handler
    function after fc_exch_done() has finished. Modify libfc such that
    this guarantee is provided if fc_exch_done() is invoked from
    outside a response handler. This patch fixes a sporadic crash in
    FCoE target implementations after a command has been aborted.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Cc: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index e1379b4e8faf..52beadf9a29b 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -410,6 +410,12 @@ struct fc_seq {
  * @fh_type:      The frame type
  * @class:        The class of service
  * @seq:          The sequence in use on this exchange
+ * @resp_active:  Number of tasks that are concurrently executing @resp().
+ * @resp_task:    If @resp_active > 0, either the task executing @resp(), the
+ *                task that has been interrupted to execute the soft-IRQ
+ *                executing @resp() or NULL if more than one task is executing
+ *                @resp concurrently.
+ * @resp_wq:      Waitqueue for the tasks waiting on @resp_active.
  * @resp:         Callback for responses on this exchange
  * @destructor:   Called when destroying the exchange
  * @arg:          Passed as a void pointer to the resp() callback
@@ -441,6 +447,9 @@ struct fc_exch {
 	u32		    r_a_tov;
 	u32		    f_ctl;
 	struct fc_seq       seq;
+	int		    resp_active;
+	struct task_struct  *resp_task;
+	wait_queue_head_t   resp_wq;
 	void		    (*resp)(struct fc_seq *, struct fc_frame *, void *);
 	void		    *arg;
 	void		    (*destructor)(struct fc_seq *, void *);

commit 0807619d3c64d935c257a377ac86982c777f969c
Author: Robert Love <robert.w.love@intel.com>
Date:   Mon Mar 25 11:00:28 2013 -0700

    libfc, fcoe, bnx2fc: Split fc_disc_init into fc_disc_{init, config}
    
    Split discovery initialization in code that is setup once (fcoe_disc_init)
    and code that can be re-configured (fcoe_disc_config).
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Tested-by: Jack Morgan <jack.morgan@intel.com>
    Reviewed-by: Bhanu Prakash Gollapudi <bprakash@broadcom.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index add2a498bd44..e1379b4e8faf 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -1074,7 +1074,8 @@ void fc_rport_terminate_io(struct fc_rport *);
 /*
  * DISCOVERY LAYER
  *****************************/
-int fc_disc_init(struct fc_lport *, void *);
+void fc_disc_init(struct fc_lport *);
+void fc_disc_config(struct fc_lport *, void *);
 
 static inline struct fc_lport *fc_disc_lport(struct fc_disc *disc)
 {

commit 8a9a71381208b2364a2d12b0d257ae333917a1bc
Author: Robert Love <robert.w.love@intel.com>
Date:   Mon Mar 25 11:00:27 2013 -0700

    libfc, fcoe, bnx2fc: Always use fcoe_disc_init for discovery layer initialization
    
    Currently libfcoe is doing some libfc discovery layer initialization outside of
    libfc. This patch moves this code into libfc and sets up a split in discovery
    (one time) initialization code and (re-configurable) settings that will come in
    the next patch.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Tested-by: Jack Morgan <jack.morgan@intel.com>
    Reviewed-by: Bhanu Prakash Gollapudi <bprakash@broadcom.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 399162b50a8d..add2a498bd44 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -1074,7 +1074,7 @@ void fc_rport_terminate_io(struct fc_rport *);
 /*
  * DISCOVERY LAYER
  *****************************/
-int fc_disc_init(struct fc_lport *);
+int fc_disc_init(struct fc_lport *, void *);
 
 static inline struct fc_lport *fc_disc_lport(struct fc_disc *disc)
 {

commit 4e5fae7adbe4f21538b9e62c0fc9b029bbd606cb
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Fri May 25 10:26:54 2012 -0700

    [SCSI] libfc: update fcp and exch stats
    
    Updates newly added stats from fc_get_host_stats,
    added new function fc_exch_update_stats to
    update exches related stats from fc_exch.c
    by going thru internal ema_list elements.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Acked-by : Robert Love <robert.w.love@intel.com>
    Tested-by: Ross Brattain <ross.b.brattain@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index f257a74e6de4..399162b50a8d 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -1121,6 +1121,7 @@ void fc_fill_hdr(struct fc_frame *, const struct fc_frame *,
  * EXCHANGE MANAGER LAYER
  *****************************/
 int fc_exch_init(struct fc_lport *);
+void fc_exch_update_stats(struct fc_lport *lport);
 struct fc_exch_mgr_anchor *fc_exch_mgr_add(struct fc_lport *,
 					   struct fc_exch_mgr *,
 					   bool (*match)(struct fc_frame *));

commit 0f02a6652803235a4893c7b01dd6eab862a913ec
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Fri May 25 10:26:48 2012 -0700

    [SCSI] libfc: adds FCP failures stats
    
    Adds stats to track FCP pkt and frame alloc
    failure.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Acked-by : Robert Love <robert.w.love@intel.com>
    Tested-by: Ross Brattain <ross.b.brattain@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index ea52ca203c95..f257a74e6de4 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -232,6 +232,9 @@ struct fc_rport_priv {
  * @RxWords:               Number of received words
  * @ErrorFrames:           Number of received error frames
  * @DumpedFrames:          Number of dumped frames
+ * @FcpPktAllocFails:      Number of fcp packet allocation failures
+ * @FcpPktAborts:          Number of fcp packet aborts
+ * @FcpFrameAllocFails:    Number of fcp frame allocation failures
  * @LinkFailureCount:      Number of link failures
  * @LossOfSignalCount:     Number for signal losses
  * @InvalidTxWordCount:    Number of invalid transmitted words
@@ -252,6 +255,9 @@ struct fc_stats {
 	u64		RxWords;
 	u64		ErrorFrames;
 	u64		DumpedFrames;
+	u64		FcpPktAllocFails;
+	u64		FcpPktAborts;
+	u64		FcpFrameAllocFails;
 	u64		LinkFailureCount;
 	u64		LossOfSignalCount;
 	u64		InvalidTxWordCount;

commit 1bd49b482077e231842352621169dedff1f41931
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Fri May 25 10:26:43 2012 -0700

    [SCSI] libfc, fcoe, bnx2fc: cleanup fcoe_dev_stats
    
    The libfc is used by fcoe but fcoe agnostic,
    and therefore should not have any fcoe references.
    
    So renaming fcoe_dev_stats from libfc as its for fc_stats.
    After that libfc is fcoe string free except some strings for
    Open-FCoE.org.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Acked-by : Robert Love <robert.w.love@intel.com>
    Tested-by: Ross Brattain <ross.b.brattain@intel.com>
    Acked-by: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 8f9dfba3fcf0..ea52ca203c95 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -224,7 +224,7 @@ struct fc_rport_priv {
 };
 
 /**
- * struct fcoe_dev_stats - fcoe stats structure
+ * struct fc_stats - fc stats structure
  * @SecondsSinceLastReset: Seconds since the last reset
  * @TxFrames:              Number of transmitted frames
  * @TxWords:               Number of transmitted words
@@ -244,7 +244,7 @@ struct fc_rport_priv {
  * @VLinkFailureCount:     Number of virtual link failures
  * @MissDiscAdvCount:      Number of missing FIP discovery advertisement
  */
-struct fcoe_dev_stats {
+struct fc_stats {
 	u64		SecondsSinceLastReset;
 	u64		TxFrames;
 	u64		TxWords;
@@ -510,7 +510,7 @@ struct libfc_function_template {
 	int (*ddp_done)(struct fc_lport *, u16);
 	/*
 	 * Sets up the DDP context for a given exchange id on the given
-	 * scatterlist if LLD supports DDP for FCoE target.
+	 * scatterlist if LLD supports DDP for target.
 	 *
 	 * STATUS: OPTIONAL
 	 */
@@ -817,8 +817,7 @@ enum fc_lport_event {
  * @state:                 Identifies the state
  * @boot_time:             Timestamp indicating when the local port came online
  * @host_stats:            SCSI host statistics
- * @dev_stats:             FCoE device stats (TODO: libfc should not be
- *                         FCoE aware)
+ * @stats:                 FC local port stats (TODO separate libfc LLD stats)
  * @retry_count:           Number of retries in the current state
  * @port_id:               FC Port ID
  * @wwpn:                  World Wide Port Name
@@ -867,7 +866,7 @@ struct fc_lport {
 	enum fc_lport_state	       state;
 	unsigned long		       boot_time;
 	struct fc_host_statistics      host_stats;
-	struct fcoe_dev_stats __percpu *dev_stats;
+	struct fc_stats	__percpu       *stats;
 	u8			       retry_count;
 
 	/* Fabric information */
@@ -980,8 +979,8 @@ static inline void fc_lport_state_enter(struct fc_lport *lport,
  */
 static inline int fc_lport_init_stats(struct fc_lport *lport)
 {
-	lport->dev_stats = alloc_percpu(struct fcoe_dev_stats);
-	if (!lport->dev_stats)
+	lport->stats = alloc_percpu(struct fc_stats);
+	if (!lport->stats)
 		return -ENOMEM;
 	return 0;
 }
@@ -992,7 +991,7 @@ static inline int fc_lport_init_stats(struct fc_lport *lport)
  */
 static inline void fc_lport_free_stats(struct fc_lport *lport)
 {
-	free_percpu(lport->dev_stats);
+	free_percpu(lport->stats);
 }
 
 /**

commit d78c317f6cd701bda9f6dbfbfbcba72f39dd6ad7
Author: Neerav Parikh <neerav.parikh@intel.com>
Date:   Sun Jan 22 17:30:05 2012 -0800

    [SCSI] libfc: Add support for FDMI
    
    This patch adds support for Fabric Device Management
    Interface as per FC-GS-4 spec. in libfc. Any driver
    making use of libfc can enable fdmi state machine
    for a given lport.
    
    If lport has enabled FDMI support the lport state
    machine will transition into FDMI after completing
    the DNS states and before entering the SCR state.
    The FDMI state transition is such that if there is an
    error, it won't stop the lport state machine from
    transitioning and the it will behave as if there was
    no FDMI support.
    
    The FDMI HBA attributes are registed with the Management
    server via Register HBA (RHBA) command and the port
    attributes are reigstered using the Register Port(RPA)
    command.
    
    Signed-off-by: Neerav Parikh <neerav.parikh@intel.com>
    Tested-by: Ross Brattain <ross.b.brattain@intel.com>
    Acked-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 6a3922fe0be0..8f9dfba3fcf0 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -30,6 +30,7 @@
 
 #include <scsi/fc/fc_fcp.h>
 #include <scsi/fc/fc_ns.h>
+#include <scsi/fc/fc_ms.h>
 #include <scsi/fc/fc_els.h>
 #include <scsi/fc/fc_gs.h>
 
@@ -52,6 +53,8 @@
  * @LPORT_ST_RPN_ID:   Register port name by ID (RPN_ID) sent
  * @LPORT_ST_RFT_ID:   Register Fibre Channel types by ID (RFT_ID) sent
  * @LPORT_ST_RFF_ID:   Register FC-4 Features by ID (RFF_ID) sent
+ * @LPORT_ST_FDMI:     Waiting for mgmt server rport to become ready
+ * @LPORT_ST_RHBA:
  * @LPORT_ST_SCR:      State Change Register (SCR) sent
  * @LPORT_ST_READY:    Ready for use
  * @LPORT_ST_LOGO:     Local port logout (LOGO) sent
@@ -66,6 +69,11 @@ enum fc_lport_state {
 	LPORT_ST_RSPN_ID,
 	LPORT_ST_RFT_ID,
 	LPORT_ST_RFF_ID,
+	LPORT_ST_FDMI,
+	LPORT_ST_RHBA,
+	LPORT_ST_RPA,
+	LPORT_ST_DHBA,
+	LPORT_ST_DPRT,
 	LPORT_ST_SCR,
 	LPORT_ST_READY,
 	LPORT_ST_LOGO,
@@ -797,6 +805,7 @@ enum fc_lport_event {
  * @host:                  The SCSI host associated with a local port
  * @ema_list:              Exchange manager anchor list
  * @dns_rdata:             The directory server remote port
+ * @ms_rdata:		   The management server remote port
  * @ptp_rdata:             Point to point remote port
  * @scsi_priv:             FCP layer internal data
  * @disc:                  Discovery context
@@ -842,6 +851,7 @@ struct fc_lport {
 	struct Scsi_Host	       *host;
 	struct list_head	       ema_list;
 	struct fc_rport_priv	       *dns_rdata;
+	struct fc_rport_priv	       *ms_rdata;
 	struct fc_rport_priv	       *ptp_rdata;
 	void			       *scsi_priv;
 	struct fc_disc                 disc;
@@ -877,6 +887,7 @@ struct fc_lport {
 	u32			       does_npiv:1;
 	u32			       npiv_enabled:1;
 	u32			       point_to_multipoint:1;
+	u32			       fdmi_enabled:1;
 	u32			       mfs;
 	u8			       max_retry_count;
 	u8			       max_rport_retry_count;

commit c6b21c93c1794113c68f3d43f321968191d87b1b
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Fri Jan 13 17:26:20 2012 -0800

    [SCSI] libfc: Declare local functions static
    
    Avoid that sparse complains about missing declarations for local
    functions by declaring these static or by adding an #include directive.
    Add the __percpu annotation where it is missing.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Yi Zou <yi.zou@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 5d1a758e0595..6a3922fe0be0 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -857,7 +857,7 @@ struct fc_lport {
 	enum fc_lport_state	       state;
 	unsigned long		       boot_time;
 	struct fc_host_statistics      host_stats;
-	struct fcoe_dev_stats	       *dev_stats;
+	struct fcoe_dev_stats __percpu *dev_stats;
 	u8			       retry_count;
 
 	/* Fabric information */

commit 49a198898e889038c6601288cd2b0e037edada24
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Tue Sep 27 21:38:02 2011 -0700

    [SCSI] libfc: cache align struct fc_exch fields
    
    cache aligned xid and ex_lock beside
    removing holes.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Tested-by: Ross Brattain <ross.b.brattain@intel.com>
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 05e2583d8fa6..5d1a758e0595 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -406,35 +406,32 @@ struct fc_seq {
  *	sequence allocation
  */
 struct fc_exch {
+	spinlock_t	    ex_lock;
+	atomic_t	    ex_refcnt;
+	enum fc_class	    class;
 	struct fc_exch_mgr  *em;
 	struct fc_exch_pool *pool;
-	u32		    state;
-	u16		    xid;
 	struct list_head    ex_list;
-	spinlock_t	    ex_lock;
-	atomic_t	    ex_refcnt;
-	struct delayed_work timeout_work;
 	struct fc_lport	    *lp;
+	u32		    esb_stat;
+	u8		    state;
+	u8		    fh_type;
+	u8		    seq_id;
+	u8		    encaps;
+	u16		    xid;
 	u16		    oxid;
 	u16		    rxid;
 	u32		    oid;
 	u32		    sid;
 	u32		    did;
-	u32		    esb_stat;
 	u32		    r_a_tov;
-	u8		    seq_id;
-	u8		    encaps;
 	u32		    f_ctl;
-	u8		    fh_type;
-	enum fc_class	    class;
-	struct fc_seq	    seq;
-
+	struct fc_seq       seq;
 	void		    (*resp)(struct fc_seq *, struct fc_frame *, void *);
 	void		    *arg;
-
 	void		    (*destructor)(struct fc_seq *, void *);
-
-};
+	struct delayed_work timeout_work;
+} ____cacheline_aligned_in_smp;
 #define	fc_seq_exch(sp) container_of(sp, struct fc_exch, seq)
 
 

commit ed26cfece6177310ad8f5896651a3187ce02711c
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Tue Sep 27 21:37:57 2011 -0700

    [SCSI] libfc: cache align struct fc_fcp_pkt fields
    
    Re-arrange its fields to avoid padding and have better
    cacheline alignments.
    
    Removed not used start_time, end_time and last_pkt_time
    fields.
    
    This all reduced this struct size to 448 from 480 and
    that also reduced one cacheline on x86_64 beside
    eliminating 8 pads. However kept logical fields together.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Tested-by: Ross Brattain <ross.b.brattain@intel.com>
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 7d96829b0c00..05e2583d8fa6 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -281,9 +281,6 @@ struct fc_seq_els_data {
  * @timer:           The command timer
  * @tm_done:         Completion indicator
  * @wait_for_comp:   Indicator to wait for completion of the I/O (in jiffies)
- * @start_time:      Timestamp indicating the start of the I/O (in jiffies)
- * @end_time:        Timestamp indicating the end of the I/O (in jiffies)
- * @last_pkt_time:   Timestamp of the last frame received (in jiffies)
  * @data_len:        The length of the data
  * @cdb_cmd:         The CDB command
  * @xfer_len:        The transfer length
@@ -304,50 +301,46 @@ struct fc_seq_els_data {
  * @recov_seq:       The sequence for REC or SRR
  */
 struct fc_fcp_pkt {
-	/* Housekeeping information */
-	struct fc_lport   *lp;
-	u16		  state;
-	atomic_t	  ref_cnt;
 	spinlock_t	  scsi_pkt_lock;
+	atomic_t	  ref_cnt;
+
+	/* SCSI command and data transfer information */
+	u32		  data_len;
 
 	/* SCSI I/O related information */
 	struct scsi_cmnd  *cmd;
 	struct list_head  list;
 
-	/* Timeout related information */
-	struct timer_list timer;
-	struct completion tm_done;
-	int	          wait_for_comp;
-	unsigned long	  start_time;
-	unsigned long	  end_time;
-	unsigned long	  last_pkt_time;
-
-	/* SCSI command and data transfer information */
-	u32		  data_len;
-
-	/* Transport related veriables */
-	struct fcp_cmnd   cdb_cmd;
-	size_t		  xfer_len;
-	u16		  xfer_ddp;
-	u32		  xfer_contig_end;
-	u16		  max_payload;
+	/* Housekeeping information */
+	struct fc_lport   *lp;
+	u8		  state;
 
 	/* SCSI/FCP return status */
-	u32		  io_status;
 	u8		  cdb_status;
 	u8		  status_code;
 	u8		  scsi_comp_flags;
+	u32		  io_status;
 	u32		  req_flags;
 	u32		  scsi_resid;
 
+	/* Transport related veriables */
+	size_t		  xfer_len;
+	struct fcp_cmnd   cdb_cmd;
+	u32		  xfer_contig_end;
+	u16		  max_payload;
+	u16		  xfer_ddp;
+
 	/* Associated structures */
 	struct fc_rport	  *rport;
 	struct fc_seq	  *seq_ptr;
 
-	/* Error Processing information */
-	u8		  recov_retry;
+	/* Timeout/error related information */
+	struct timer_list timer;
+	int	          wait_for_comp;
+	u32		  recov_retry;
 	struct fc_seq	  *recov_seq;
-};
+	struct completion tm_done;
+} ____cacheline_aligned_in_smp;
 
 /*
  * Structure and function definitions for managing Fibre Channel Exchanges

commit 33dc362b7f155a584688bcab2facdd4d21232001
Author: Yi Zou <yi.zou@intel.com>
Date:   Mon Jun 20 16:59:05 2011 -0700

    [SCSI] libfc, tcm_fc: add ddp_targ() to libfc function template to supprot FCoE DDP in target mode
    
    The fcoe driver can implement ddp_targ() similarly to ddp_setup() when fcoe
    stack works with existing target frame, e.g., tcm, where the ddp_targ() would
    eventually point to the underlying hardware driver's implementation of
    ndo_fcoe_ddp_targ() through net_device_ops. This new API sets up DDP context
    for target appropriately by setting required bits for DDP context.
    
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Signed-off-by: Kiran Patil <kiran.patil@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index a3cbda4ddb5c..7d96829b0c00 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -510,6 +510,14 @@ struct libfc_function_template {
 	 * STATUS: OPTIONAL
 	 */
 	int (*ddp_done)(struct fc_lport *, u16);
+	/*
+	 * Sets up the DDP context for a given exchange id on the given
+	 * scatterlist if LLD supports DDP for FCoE target.
+	 *
+	 * STATUS: OPTIONAL
+	 */
+	int (*ddp_target)(struct fc_lport *, u16, struct scatterlist *,
+			  unsigned int);
 	/*
 	 * Allow LLD to fill its own Link Error Status Block
 	 *

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 24193c1b0da0..a3cbda4ddb5c 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -260,7 +260,7 @@ struct fcoe_dev_stats {
 /**
  * struct fc_seq_els_data - ELS data used for passing ELS specific responses
  * @reason: The reason for rejection
- * @explan: The explaination of the rejection
+ * @explan: The explanation of the rejection
  *
  * Mainly used by the exchange manager layer.
  */
@@ -525,7 +525,7 @@ struct libfc_function_template {
 			struct fc_frame *);
 
 	/*
-	 * Send an ELS response using infomation from the received frame.
+	 * Send an ELS response using information from the received frame.
 	 *
 	 * STATUS: OPTIONAL
 	 */
@@ -663,7 +663,7 @@ struct libfc_function_template {
 	int (*rport_logoff)(struct fc_rport_priv *);
 
 	/*
-	 * Recieve a request from a remote port.
+	 * Receive a request from a remote port.
 	 *
 	 * STATUS: OPTIONAL
 	 */
@@ -704,7 +704,7 @@ struct libfc_function_template {
 					 void *));
 
 	/*
-	 * Cleanup the FCP layer, used durring link down and reset
+	 * Cleanup the FCP layer, used during link down and reset
 	 *
 	 * STATUS: OPTIONAL
 	 */

commit 75a2792df296c77004a72056c76628a1f835bc93
Author: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
Date:   Fri Jan 28 16:05:27 2011 -0800

    [SCSI] libfc: introduce LLD event callback
    
    This patch enables LLD to listen to rport events and perform LLD
    specific operations based on the rport event. This patch also stores
    sp_features and spp_type in rdata for further reference by LLD.
    
    Signed-off-by: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 6d64e44bc3bf..24193c1b0da0 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -158,6 +158,7 @@ struct fc_rport_libfc_priv {
 	#define FC_RP_FLAGS_REC_SUPPORTED	(1 << 0)
 	#define FC_RP_FLAGS_RETRY		(1 << 1)
 	#define FC_RP_STARTED			(1 << 2)
+	#define FC_RP_FLAGS_CONF_REQ		(1 << 3)
 	unsigned int	           e_d_tov;
 	unsigned int	           r_a_tov;
 };
@@ -207,6 +208,11 @@ struct fc_rport_priv {
 	u32			    supported_classes;
 	u16                         prli_count;
 	struct rcu_head		    rcu;
+	u16			    sp_features;
+	u8			    spp_type;
+	void			    (*lld_event_callback)(struct fc_lport *,
+						      struct fc_rport_priv *,
+						      enum fc_rport_event);
 };
 
 /**
@@ -676,6 +682,15 @@ struct libfc_function_template {
 	 */
 	void (*rport_destroy)(struct kref *);
 
+	/*
+	 * Callback routine after the remote port is logged in
+	 *
+	 * STATUS: OPTIONAL
+	 */
+	void (*rport_event_callback)(struct fc_lport *,
+				     struct fc_rport_priv *,
+				     enum fc_rport_event);
+
 	/*
 	 * Send a fcp cmd from fsp pkt.
 	 * Called with the SCSI host lock unlocked and irqs disabled.

commit 62bdb6455e8326f864ae1b43b4c4db7f630edc1c
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Fri Jan 28 16:04:34 2011 -0800

    [SCSI] libfc: export seq_release() for users of seq_assign()
    
    Target modules using lport->tt.seq_assign() get a hold on the
    exchange but have no way of releasing it.  Add that.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 79d1c76b4269..6d64e44bc3bf 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -571,6 +571,13 @@ struct libfc_function_template {
 	 */
 	struct fc_seq *(*seq_assign)(struct fc_lport *, struct fc_frame *);
 
+	/*
+	 * Release the reference on the sequence returned by seq_assign().
+	 *
+	 * STATUS: OPTIONAL
+	 */
+	void (*seq_release)(struct fc_seq *);
+
 	/*
 	 * Reset an exchange manager, completing all sequences and exchanges.
 	 * If s_id is non-zero, reset only exchanges originating from that FID.

commit 70d53b046a6221e3ceb3bd8eaa807ef6a1c53762
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Fri Jan 28 16:04:18 2011 -0800

    [SCSI] libfc: add hook to notify providers of local port changes
    
    When an SCST provider is registered, it needs to know what
    local ports are available for configuration as targets.
    
    Add a notifier chain that is invoked when any local port
    that is added or deleted.
    
    Maintain a global list of local ports and add an
    interator function that calls a given function for
    every existing local port.  This is used when first
    loading a provider.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index a9aff25a399b..79d1c76b4269 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -763,6 +763,15 @@ struct fc_disc {
 			      enum fc_disc_event);
 };
 
+/*
+ * Local port notifier and events.
+ */
+extern struct blocking_notifier_head fc_lport_notifier_head;
+enum fc_lport_event {
+	FC_LPORT_EV_ADD,
+	FC_LPORT_EV_DEL,
+};
+
 /**
  * struct fc_lport - Local port
  * @host:                  The SCSI host associated with a local port
@@ -803,9 +812,10 @@ struct fc_disc {
  * @lso_max:               The maximum large offload send size
  * @fcts:                  FC-4 type mask
  * @lp_mutex:              Mutex to protect the local port
- * @list:                  Handle for list of local ports
+ * @list:                  Linkage on list of vport peers
  * @retry_work:            Handle to local port for delayed retry context
  * @prov:		   Pointers available for use by passive FC-4 providers
+ * @lport_list:            Linkage on module-wide list of local ports
  */
 struct fc_lport {
 	/* Associations */
@@ -862,6 +872,7 @@ struct fc_lport {
 	struct list_head               list;
 	struct delayed_work	       retry_work;
 	void			       *prov[FC_FC4_PROV_SIZE];
+	struct list_head               lport_list;
 };
 
 /**
@@ -1016,6 +1027,7 @@ struct fc_lport *libfc_vport_create(struct fc_vport *, int privsize);
 struct fc_lport *fc_vport_id_lookup(struct fc_lport *, u32 port_id);
 int fc_lport_bsg_request(struct fc_bsg_job *);
 void fc_lport_set_local_id(struct fc_lport *, u32 port_id);
+void fc_lport_iterate(void (*func)(struct fc_lport *, void *), void *);
 
 /*
  * REMOTE PORT LAYER

commit baf9fdf076a8976431b5de565aef2b98816caecf
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Fri Jan 28 16:04:13 2011 -0800

    [SCSI] libfc: add local port hook for provider session lookup
    
    The target provider needs a per-instance lookup table
    or other way to lookup sessions quickly without going through
    a linear list or serializing too much.
    
    Add a simple void * array indexed by FC-4 type to the fc_lport.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Committed-by: Nicholas A. Bellinger <nab@linux-iscsi.org>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 3b8f5d83611b..a9aff25a399b 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -805,6 +805,7 @@ struct fc_disc {
  * @lp_mutex:              Mutex to protect the local port
  * @list:                  Handle for list of local ports
  * @retry_work:            Handle to local port for delayed retry context
+ * @prov:		   Pointers available for use by passive FC-4 providers
  */
 struct fc_lport {
 	/* Associations */
@@ -860,6 +861,7 @@ struct fc_lport {
 	struct mutex                   lp_mutex;
 	struct list_head               list;
 	struct delayed_work	       retry_work;
+	void			       *prov[FC_FC4_PROV_SIZE];
 };
 
 /**

commit 1a5c2d7e5c8ef239804cb08b68363e0cd2f74a3d
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Fri Jan 28 16:04:08 2011 -0800

    [SCSI] libfc: add method for setting handler for incoming exchange
    
    Add a method for setting handler for incoming exchange.
    For multi-sequence exchanges, this allows the target driver
    to add a response handler for handling subsequent sequences,
    and exchange manager resets.
    
    The new function is called fc_seq_set_resp().
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 3ae2a760b4f3..3b8f5d83611b 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -554,6 +554,16 @@ struct libfc_function_template {
 	 */
 	struct fc_seq *(*seq_start_next)(struct fc_seq *);
 
+	/*
+	 * Set a response handler for the exchange of the sequence.
+	 *
+	 * STATUS: OPTIONAL
+	 */
+	void (*seq_set_resp)(struct fc_seq *sp,
+			     void (*resp)(struct fc_seq *, struct fc_frame *,
+					  void *),
+			     void *arg);
+
 	/*
 	 * Assign a sequence for an incoming request frame.
 	 *

commit 96ad846445ae33dcae1805b68752e3d5c840e3ed
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Fri Jan 28 16:04:02 2011 -0800

    [SCSI] libfc: add hook for FC-4 provider registration
    
    Allow FC-4 provider modules to hook into libfc, mostly for targets.
    This should allow any FC-4 module to handle PRLI requests and maintain
    process-association states.
    
    Each provider registers its ops with libfc and then will be called for
    any incoming PRLI for that FC-4 type on any instance.   The provider
    can decide whether to handle that particular instance using any method
    it likes, such as ACLs or other configuration information.
    
    A count is kept of the number of successful PRLIs from the remote port.
    Providers are called back with an implicit PRLO when the remote port
    is about to be deleted or has been reset.
    
    fc_lport_recv_req() now sends incoming FC-4 requests to FC-4 providers,
    and there is a built-in provider always registered for handling
    incoming ELS requests.
    
    The call to provider recv() routines uses rcu_read_lock()
    so that providers aren't removed during the call.  That lock is very
    cheap and shouldn't affect any performance on ELS requests.
    Providers can rely on the RCU lock to protect a session lookup as well.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index f53c8e31d5fb..3ae2a760b4f3 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -35,6 +35,8 @@
 
 #include <scsi/fc_frame.h>
 
+#define	FC_FC4_PROV_SIZE	(FC_TYPE_FCP + 1)	/* size of tables */
+
 /*
  * libfc error codes
  */
@@ -179,6 +181,7 @@ struct fc_rport_libfc_priv {
  * @rp_mutex:       The mutex that protects the remote port
  * @retry_work:     Handle for retries
  * @event_callback: Callback when READY, FAILED or LOGO states complete
+ * @prli_count:     Count of open PRLI sessions in providers
  * @rcu:	    Structure used for freeing in an RCU-safe manner
  */
 struct fc_rport_priv {
@@ -202,6 +205,7 @@ struct fc_rport_priv {
 	struct list_head            peers;
 	struct work_struct          event_work;
 	u32			    supported_classes;
+	u16                         prli_count;
 	struct rcu_head		    rcu;
 };
 
@@ -848,6 +852,28 @@ struct fc_lport {
 	struct delayed_work	       retry_work;
 };
 
+/**
+ * struct fc4_prov - FC-4 provider registration
+ * @prli:               Handler for incoming PRLI
+ * @prlo:               Handler for session reset
+ * @recv:		Handler for incoming request
+ * @module:		Pointer to module.  May be NULL.
+ */
+struct fc4_prov {
+	int (*prli)(struct fc_rport_priv *, u32 spp_len,
+		    const struct fc_els_spp *spp_in,
+		    struct fc_els_spp *spp_out);
+	void (*prlo)(struct fc_rport_priv *);
+	void (*recv)(struct fc_lport *, struct fc_frame *);
+	struct module *module;
+};
+
+/*
+ * Register FC-4 provider with libfc.
+ */
+int fc_fc4_register_provider(enum fc_fh_type type, struct fc4_prov *);
+void fc_fc4_deregister_provider(enum fc_fh_type type, struct fc4_prov *);
+
 /*
  * FC_LPORT HELPER FUNCTIONS
  *****************************/

commit 5f0e385fdafb7d6c8ded6464fa6421c735d96caf
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Nov 30 16:20:18 2010 -0800

    [SCSI] libfc: fix statistics for FCP input/output megabytes
    
    The statistics for InputMegabytes and OutputMegabytes are
    misnamed.  They're accumulating bytes, not megabytes.
    
    The statistic returned via /sys must be in megabytes, however,
    which is what the HBA-API wants.  The FCP code needs to accumulate
    it in bytes and then divide by 1,000,000 (not 2^20) before it
    presented via sysfs.
    
    This affects fcoe.ko only, not fnic.  The fnic driver
    correctly by accumulating bytes and then converts to megabytes.
    
    I checked that libhbalinux is using the /sys file directly without
    conversion.
    
    BTW, qla2xxx does divide by 2^20, which I'm not fixing here.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 3eb3915eb557..f53c8e31d5fb 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -221,8 +221,8 @@ struct fc_rport_priv {
  * @InputRequests:         Number of input requests
  * @OutputRequests:        Number of output requests
  * @ControlRequests:       Number of control requests
- * @InputMegabytes:        Number of received megabytes
- * @OutputMegabytes:       Number of transmitted megabytes
+ * @InputBytes:            Number of received bytes
+ * @OutputBytes:           Number of transmitted bytes
  * @VLinkFailureCount:     Number of virtual link failures
  * @MissDiscAdvCount:      Number of missing FIP discovery advertisement
  */
@@ -241,8 +241,8 @@ struct fcoe_dev_stats {
 	u64		InputRequests;
 	u64		OutputRequests;
 	u64		ControlRequests;
-	u64		InputMegabytes;
-	u64		OutputMegabytes;
+	u64		InputBytes;
+	u64		OutputBytes;
 	u64		VLinkFailureCount;
 	u64		MissDiscAdvCount;
 };

commit 05fee645e96e732a79ad083cab8ddd4efd108e2c
Author: john fastabend <john.r.fastabend@intel.com>
Date:   Tue Nov 30 16:18:49 2010 -0800

    [SCSI] libfc: remove tgt_flags from fc_fcp_pkt struct
    
    We can easily remove the tgt_flags from fc_fcp_pkt struct
    and use rpriv->tgt_flags directly where needed.
    
    Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 5c4c1678f7be..3eb3915eb557 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -263,7 +263,6 @@ struct fc_seq_els_data {
  * struct fc_fcp_pkt - FCP request structure (one for each scsi_cmnd request)
  * @lp:              The associated local port
  * @state:           The state of the I/O
- * @tgt_flags:       Target's flags
  * @ref_cnt:         Reference count
  * @scsi_pkt_lock:   Lock to protect the SCSI packet (must be taken before the
  *                   host_lock if both are to be held at the same time)
@@ -298,7 +297,6 @@ struct fc_fcp_pkt {
 	/* Housekeeping information */
 	struct fc_lport   *lp;
 	u16		  state;
-	u16		  tgt_flags;
 	atomic_t	  ref_cnt;
 	spinlock_t	  scsi_pkt_lock;
 

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index f986ab7ffe6f..5c4c1678f7be 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -1006,8 +1006,7 @@ void fc_fcp_destroy(struct fc_lport *);
 /*
  * SCSI INTERACTION LAYER
  *****************************/
-int fc_queuecommand(struct scsi_cmnd *,
-		    void (*done)(struct scsi_cmnd *));
+int fc_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);
 int fc_eh_abort(struct scsi_cmnd *);
 int fc_eh_device_reset(struct scsi_cmnd *);
 int fc_eh_host_reset(struct scsi_cmnd *);

commit c531b9b49b146e1535dbed006d15e58f4f528f7e
Author: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
Date:   Fri Oct 8 17:12:36 2010 -0700

    [SCSI] libfc: Do not let disc work cancel itself
    
    When number of NPIV ports created are greater than the xids
    allocated per pool -- for eg., creating 255 NPIV ports on a
    system with nr_cpu_ids of 32, with each pool containing 128
    xids -- and then generating a link event - for eg.,
    shutdown/no shutdown -- on the switch port causes the hang
    with the following stack trace.
    
    Call Trace:
    schedule_timeout+0x19d/0x230
    wait_for_common+0xc0/0x170
    __cancel_work_timer+0xcf/0x1b0
    fc_disc_stop+0x16/0x30 [libfc]
    fc_lport_reset_locked+0x47/0x90 [libfc]
    fc_lport_enter_reset+0x67/0xe0 [libfc]
    fc_lport_disc_callback+0xbc/0xe0 [libfc]
    fc_disc_done+0xa8/0xf0 [libfc]
    fc_disc_timeout+0x29/0x40 [libfc]
    run_workqueue+0xb8/0x140
    worker_thread+0x96/0x110
    kthread+0x96/0xa0
    child_rip+0xa/0x20
    
    Fix is to not cancel the disc_work if discovery is already
    stopped, thus allowing lport state machine to restart and try
    discovery again.
    
    Signed-off-by: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
    Acked-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 14be49b44e84..f986ab7ffe6f 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -721,7 +721,7 @@ struct libfc_function_template {
  * struct fc_disc - Discovery context
  * @retry_count:   Number of retries
  * @pending:       1 if discovery is pending, 0 if not
- * @requesting:    1 if discovery has been requested, 0 if not
+ * @requested:     1 if discovery has been requested, 0 if not
  * @seq_count:     Number of sequences used for discovery
  * @buf_len:       Length of the discovery buffer
  * @disc_id:       Discovery ID

commit 922611569572d3c1aa0ed6491d21583fb3fcca22
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Jul 20 15:21:12 2010 -0700

    [SCSI] libfc: don't require a local exchange for incoming requests
    
    Incoming requests shouldn't require a local exchange if we're
    just going to reply with one or two frames and don't expect
    anything further.  Don't allocate exchanges for such requests
    until requested by the upper-layer protocol.
    
    The sequence is always NULL for new requests, so remove
    that as an argument to request handlers.
    
    Also change the first argument to lport->tt.seq_els_rsp_send
    from the sequence pointer to the received frame pointer, to
    supply the exchange IDs and destination ID info.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 605f1d7861a7..14be49b44e84 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -249,14 +249,12 @@ struct fcoe_dev_stats {
 
 /**
  * struct fc_seq_els_data - ELS data used for passing ELS specific responses
- * @fp:     The ELS frame
  * @reason: The reason for rejection
  * @explan: The explaination of the rejection
  *
  * Mainly used by the exchange manager layer.
  */
 struct fc_seq_els_data {
-	struct fc_frame *fp;
 	enum fc_els_rjt_reason reason;
 	enum fc_els_rjt_explan explan;
 };
@@ -519,12 +517,11 @@ struct libfc_function_template {
 			struct fc_frame *);
 
 	/*
-	 * Send an ELS response using infomation from a previous
-	 * exchange and sequence.
+	 * Send an ELS response using infomation from the received frame.
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	void (*seq_els_rsp_send)(struct fc_seq *, enum fc_els_cmd,
+	void (*seq_els_rsp_send)(struct fc_frame *, enum fc_els_cmd,
 				 struct fc_seq_els_data *);
 
 	/*
@@ -583,8 +580,7 @@ struct libfc_function_template {
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	void (*lport_recv)(struct fc_lport *, struct fc_seq *,
-			   struct fc_frame *);
+	void (*lport_recv)(struct fc_lport *, struct fc_frame *);
 
 	/*
 	 * Reset the local port.
@@ -646,8 +642,7 @@ struct libfc_function_template {
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	void (*rport_recv_req)(struct fc_seq *, struct fc_frame *,
-			       struct fc_lport *);
+	void (*rport_recv_req)(struct fc_lport *, struct fc_frame *);
 
 	/*
 	 * lookup an rport by it's port ID.
@@ -693,8 +688,7 @@ struct libfc_function_template {
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	void (*disc_recv_req)(struct fc_seq *, struct fc_frame *,
-			      struct fc_lport *);
+	void (*disc_recv_req)(struct fc_lport *, struct fc_frame *);
 
 	/*
 	 * Start discovery for a local port.

commit 239e81048b7dcd27448db40c845f88ac7c68424e
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Jul 20 15:21:07 2010 -0700

    [SCSI] libfc: add interface to allocate a sequence for incoming requests
    
    For incoming ELS and FCP requests, we often don't require an
    exchange and sequence, however, sometimes we do.  For those cases,
    (primarily FCP requests for targets) add a function to set up
    the exchange and sequence.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index a6414ec63809..605f1d7861a7 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -555,6 +555,13 @@ struct libfc_function_template {
 	 */
 	struct fc_seq *(*seq_start_next)(struct fc_seq *);
 
+	/*
+	 * Assign a sequence for an incoming request frame.
+	 *
+	 * STATUS: OPTIONAL
+	 */
+	struct fc_seq *(*seq_assign)(struct fc_lport *, struct fc_frame *);
+
 	/*
 	 * Reset an exchange manager, completing all sequences and exchanges.
 	 * If s_id is non-zero, reset only exchanges originating from that FID.

commit 24f089e2f2c800f88039e9d536d558ec6e349fad
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Jul 20 15:21:01 2010 -0700

    [SCSI] libfc: add fc_fill_reply_hdr() and fc_fill_hdr()
    
    Add functions to fill in an FC header given a request header.
    These reduces code lines in fc_lport and fc_rport and works
    without an exchange/sequence assigned.
    
    fc_fill_reply_hdr() fills a header for a final reply frame.
    
    fc_fill_hdr() which is similar but allows specifying the
    f_ctl parameter.
    
    Add defines for F_CTL values FC_FCTL_REQ and FC_FCTL_RESP.
    These can be used for most request and response sequences.
    
    v2 of patch adds a line to copy the frame encapsulation
    info from the received frame.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index f1ce793f33b3..a6414ec63809 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -1027,6 +1027,10 @@ struct fc_seq *fc_elsct_send(struct fc_lport *, u32 did,
 				    void *arg, u32 timer_msec);
 void fc_lport_flogi_resp(struct fc_seq *, struct fc_frame *, void *);
 void fc_lport_logo_resp(struct fc_seq *, struct fc_frame *, void *);
+void fc_fill_reply_hdr(struct fc_frame *, const struct fc_frame *,
+		       enum fc_rctl, u32 parm_offset);
+void fc_fill_hdr(struct fc_frame *, const struct fc_frame *,
+		 enum fc_rctl, u32 f_ctl, u16 seq_cnt, u32 parm_offset);
 
 
 /*

commit 251748a99e631a2c46edcf9e519cfc60fae8153d
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Jul 20 15:20:56 2010 -0700

    [SCSI] libfc: add fc_frame_sid() and fc_frame_did() functions
    
    To pave the way for eliminating exchanges from incoming requests,
    add simple inline fc_frame_sid() and fc_frame_did() functions
    which get the FC_IDs from the frame header.  This can be almost
    as efficient as getting them from the sequence/exchange.
    
    Move ntohll, htonll, ntoh24 and hton24 to <scsi/fc_frame.h>
    since we need them there and that's included by <scsi/libfc.h>
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index e6f07fba432c..f1ce793f33b3 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -42,24 +42,6 @@
 #define	FC_EX_TIMEOUT	1	/* Exchange timeout */
 #define	FC_EX_CLOSED	2	/* Exchange closed */
 
-/* some helpful macros */
-
-#define ntohll(x) be64_to_cpu(x)
-#define htonll(x) cpu_to_be64(x)
-
-
-static inline u32 ntoh24(const u8 *p)
-{
-	return (p[0] << 16) | (p[1] << 8) | p[2];
-}
-
-static inline void hton24(u8 *p, u32 v)
-{
-	p[0] = (v >> 16) & 0xff;
-	p[1] = (v >> 8) & 0xff;
-	p[2] = v & 0xff;
-}
-
 /**
  * enum fc_lport_state - Local port states
  * @LPORT_ST_DISABLED: Disabled

commit 079ecd8cfe95dfd28b74f3a00d66fdbcdfc8c611
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Jul 20 15:20:51 2010 -0700

    [SCSI] libfc: eliminate rport LOGO state
    
    The LOGO state hasn't been used in a while, except in a brief
    transition to DELETE state while holding the rport mutex.
    All port LOGO responses have been ignored as well as any timeout
    if we don't get a response.
    
    So this patch just removes LOGO state and simplifies the response handler.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 8d297f9a0a47..e6f07fba432c 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -103,7 +103,6 @@ enum fc_disc_event {
  * @RPORT_ST_PRLI:    Waiting for PRLI completion
  * @RPORT_ST_RTV:     Waiting for RTV completion
  * @RPORT_ST_READY:   Ready for use
- * @RPORT_ST_LOGO:    Remote port logout (LOGO) sent
  * @RPORT_ST_ADISC:   Discover Address sent
  * @RPORT_ST_DELETE:  Remote port being deleted
 */
@@ -115,7 +114,6 @@ enum fc_rport_state {
 	RPORT_ST_PRLI,
 	RPORT_ST_RTV,
 	RPORT_ST_READY,
-	RPORT_ST_LOGO,
 	RPORT_ST_ADISC,
 	RPORT_ST_DELETE,
 };

commit f60e12e9c778c8256a646f80603d1b88ba5ce891
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Jul 20 15:20:14 2010 -0700

    [SCSI] libfc: track FIP exchanges
    
    When an exchange is received with a FIP encapsulation, we need
    to know that the response must be sent via FIP and what the original
    ELS opcode was.  This becomes important for VN2VN mode, where we may
    receive FLOGI or LOGO from several peer VN_ports, and the LS_ACC or
    LS_RJT must be sent FIP-encapsulated with the correct sub-type.
    
    Add a field to the struct fc_frame, fr_encaps, to indicate the
    encapsulation values.  That term is chosen to be neutral and
    LLD-agnostic in case non-FCoE/FIP LLDs might find it useful.
    
    The frame fr_encaps is transferred from the ingress frame to the
    exchange by fc_exch_recv_req(), and back to the outgoing frame
    by fc_seq_send().
    
    This is taking the last byte in the skb->cb array.  If needed,
    we could combine the info in sof, eof, flags, and encaps
    together into one field, but it'd be better to do that if
    and when its needed.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 24b91c922055..8d297f9a0a47 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -412,6 +412,7 @@ struct fc_seq {
  * @esb_stat:     ESB exchange status
  * @r_a_tov:      Resouce allocation time out value (in msecs)
  * @seq_id:       The next sequence ID to use
+ * @encaps:       encapsulation information for lower-level driver
  * @f_ctl:        F_CTL flags for the sequence
  * @fh_type:      The frame type
  * @class:        The class of service
@@ -443,6 +444,7 @@ struct fc_exch {
 	u32		    esb_stat;
 	u32		    r_a_tov;
 	u8		    seq_id;
+	u8		    encaps;
 	u32		    f_ctl;
 	u8		    fh_type;
 	enum fc_class	    class;

commit a7b12a279faaad26837276065104a1f9cf60e962
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Jul 20 15:20:08 2010 -0700

    [SCSI] libfc: add FLOGI state to rport for VN2VN
    
    The FIP proposal for VN_port to VN_port point-to-multipoint
    operation requires a FLOGI be sent to each remote port.
    The FLOGI is sent with the assigned S_ID and D_IDs of the
    local and remote ports.  This and the response get
    FIP-encapsulated for Ethernet.
    
    Add FLOGI state to the remote port state machine.
    This will be skipped if not in point-to-multipoint mode.
    
    To reduce a little duplication between PLOGI and FLOGI
    response handling, added fc_rport_login_complete(), which
    handles the parameters for the rdata struct.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index bd0560509ce6..24b91c922055 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -97,6 +97,8 @@ enum fc_disc_event {
 /**
  * enum fc_rport_state - Remote port states
  * @RPORT_ST_INIT:    Initialized
+ * @RPORT_ST_FLOGI:   Waiting for FLOGI completion for point-to-multipoint
+ * @RPORT_ST_PLOGI_WAIT:   Waiting for peer to login for point-to-multipoint
  * @RPORT_ST_PLOGI:   Waiting for PLOGI completion
  * @RPORT_ST_PRLI:    Waiting for PRLI completion
  * @RPORT_ST_RTV:     Waiting for RTV completion
@@ -107,6 +109,8 @@ enum fc_disc_event {
 */
 enum fc_rport_state {
 	RPORT_ST_INIT,
+	RPORT_ST_FLOGI,
+	RPORT_ST_PLOGI_WAIT,
 	RPORT_ST_PLOGI,
 	RPORT_ST_PRLI,
 	RPORT_ST_RTV,

commit 3726f3584e113697b68d3d4ff1ecf1042a06f800
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Jul 20 15:20:03 2010 -0700

    [SCSI] libfc: Add local port point-to-multipoint flag
    
    For VN_port to VN_port mode, the transport sets the port_id and
    there's no lport FLOGI.  This is similar to FC loop mode.
    
    Add a point_to_multipoint flag that indicates the local port is in
    point-to-multipoint mode.  This skips FLOGI and discovery.
    It also skips resetting the port_id on resets other than link down.
    
    Add function fc_lport_set_local_id() that sets the local port_id.
    This is called by libfcoe on behalf of the low-level driver
    to set the port_id when the link comes up.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 5f64e593cca8..bd0560509ce6 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -846,6 +846,7 @@ struct fc_lport {
 	u32			       lro_enabled:1;
 	u32			       does_npiv:1;
 	u32			       npiv_enabled:1;
+	u32			       point_to_multipoint:1;
 	u32			       mfs;
 	u8			       max_retry_count;
 	u8			       max_rport_retry_count;
@@ -991,6 +992,7 @@ int fc_set_mfs(struct fc_lport *, u32 mfs);
 struct fc_lport *libfc_vport_create(struct fc_vport *, int privsize);
 struct fc_lport *fc_vport_id_lookup(struct fc_lport *, u32 port_id);
 int fc_lport_bsg_request(struct fc_bsg_job *);
+void fc_lport_set_local_id(struct fc_lport *, u32 port_id);
 
 /*
  * REMOTE PORT LAYER

commit 0685230c59b5482e04ab50e7afc51119ceaba651
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Jul 20 15:19:53 2010 -0700

    [SCSI] libfc: add discovery-private pointer for LLD
    
    For VN_port to VN_port mode, FIP will do discovery and needs a
    way to find its state from the local port or discovery structure.
    It seems that any other LLD that implements its own discovery
    would also need something like this.
    
    Replace disc->lport with disc->priv, and use container_of to
    find the lport.  We could use disc->priv for that, but
    container_of is smaller and faster.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index fcbee8c38b0c..5f64e593cca8 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -739,7 +739,7 @@ struct libfc_function_template {
  * @buf_len:       Length of the discovery buffer
  * @disc_id:       Discovery ID
  * @rports:        List of discovered remote ports
- * @lport:         The local port that discovery is for
+ * @priv:          Private pointer for use by discovery code
  * @disc_mutex:    Mutex that protects the discovery context
  * @partial_buf:   Partial name buffer (if names are returned
  *                 in multiple frames)
@@ -755,7 +755,7 @@ struct fc_disc {
 	u16                   disc_id;
 
 	struct list_head      rports;
-	struct fc_lport	      *lport;
+	void		      *priv;
 	struct mutex	      disc_mutex;
 	struct fc_gpn_ft_resp partial_buf;
 	struct delayed_work   disc_work;
@@ -1003,6 +1003,11 @@ void fc_rport_terminate_io(struct fc_rport *);
  *****************************/
 int fc_disc_init(struct fc_lport *);
 
+static inline struct fc_lport *fc_disc_lport(struct fc_disc *disc)
+{
+	return container_of(disc, struct fc_lport, disc);
+}
+
 /*
  * FCP LAYER
  *****************************/

commit f90377abcab2e305450ee76a0f9042907560c5d8
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Jul 20 15:19:42 2010 -0700

    [SCSI] libfc: provide space for LLD after remote port structure
    
    Add pre-zeroed space after the allocation for fc_rport_priv
    for use by the lower-level driver.
    
    This is primarily for VN2VN FIP mode, but could be used in
    other ways someday.
    
    The space required is specified in lport->rport_priv_size.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index b0310b9b3469..fcbee8c38b0c 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -799,6 +799,7 @@ struct fc_disc {
  * @mfs:                   The maximum Fibre Channel payload size
  * @max_retry_count:       The maximum retry attempts
  * @max_rport_retry_count: The maximum remote port retry attempts
+ * @rport_priv_size:       Size needed by driver after struct fc_rport_priv
  * @lro_xid:               The maximum XID for LRO
  * @lso_max:               The maximum large offload send size
  * @fcts:                  FC-4 type mask
@@ -848,6 +849,7 @@ struct fc_lport {
 	u32			       mfs;
 	u8			       max_retry_count;
 	u8			       max_rport_retry_count;
+	u16			       rport_priv_size;
 	u16			       link_speed;
 	u16			       link_supported_speeds;
 	u16			       lro_xid;

commit 42e9041467cf5fd33501b91b27e26807c259c896
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Jul 20 15:19:37 2010 -0700

    [SCSI] libfc: convert rport lookup to be RCU safe
    
    To allow LLD to do lookups on rports without grabbing a mutex,
    make them RCU-safe.  The caller of lport->tt.rport_lookup will
    have the choice of holding disc_mutex or the rcu_read_lock().
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 6d78df77dab6..b0310b9b3469 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -195,6 +195,7 @@ struct fc_rport_libfc_priv {
  * @rp_mutex:       The mutex that protects the remote port
  * @retry_work:     Handle for retries
  * @event_callback: Callback when READY, FAILED or LOGO states complete
+ * @rcu:	    Structure used for freeing in an RCU-safe manner
  */
 struct fc_rport_priv {
 	struct fc_lport		    *local_port;
@@ -217,6 +218,7 @@ struct fc_rport_priv {
 	struct list_head            peers;
 	struct work_struct          event_work;
 	u32			    supported_classes;
+	struct rcu_head		    rcu;
 };
 
 /**

commit f034260db330bb3ffc815fcb682b1c84aca09591
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Fri Jun 11 16:44:57 2010 -0700

    [SCSI] libfc: fix indefinite rport restart
    
    Remote ports were restarting indefinitely after getting
    rejects in PRLI.
    
    Fix by adding a counter of restarts and limiting that with
    the port login retry limit as well.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index db54c4a2d14b..6d78df77dab6 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -189,6 +189,7 @@ struct fc_rport_libfc_priv {
  * @disc_id:        The discovery identifier
  * @maxframe_size:  The maximum frame size
  * @retries:        The retry count for the current state
+ * @major_retries:  The retry count for the entire PLOGI/PRLI state machine
  * @e_d_tov:        Error detect timeout value (in msec)
  * @r_a_tov:        Resource allocation timeout value (in msec)
  * @rp_mutex:       The mutex that protects the remote port
@@ -206,6 +207,7 @@ struct fc_rport_priv {
 	u16			    disc_id;
 	u16			    maxframe_size;
 	unsigned int	            retries;
+	unsigned int	            major_retries;
 	unsigned int	            e_d_tov;
 	unsigned int	            r_a_tov;
 	struct mutex                rp_mutex;

commit 4b2164d4d212e437c9f080023a67f8f9356d2c4c
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Fri Jun 11 16:44:51 2010 -0700

    [SCSI] libfc: Fix remote port restart problem
    
    This patch somewhat combines two fixes to remote port handing in libfc.
    
    The first problem was that rport work could be queued on a deleted
    and freed rport.  This is handled by not resetting rdata->event
    ton NONE if the rdata is about to be deleted.
    
    However, that fix led to the second problem, described by
    Bhanu Gollapudi, as follows:
    > Here is the sequence of events. T1 is first LOGO receive thread, T2 is
    > fc_rport_work() scheduled by T1 and T3 is second LOGO receive thread and
    > T4 is fc_rport_work scheduled by T3.
    >
    > 1. (T1)Received 1st LOGO in state Ready
    > 2. (T1)Delete port & enter to RESTART state.
    > 3. (T1)schdule event_work, since event is RPORT_EV_NONE.
    > 4. (T1)set event = RPORT_EV_LOGO
    > 5. (T1)Enter RESTART state as disc_id is set.
    > 6. (T2)remember to PLOGI, and set event = RPORT_EV_NONE
    > 6. (T3)Received 2nd LOGO
    > 7. (T3)Delete Port & enter to RESTART state.
    > 8. (T3)schedule event_work, since event is RPORT_EV_NONE.
    > 9. (T3)Enter RESTART state as disc_id is set.
    > 9. (T3)set event = RPORT_EV_LOGO
    > 10.(T2)work restart, enter PLOGI state and issues PLOGI
    > 11.(T4)Since state is not RESTART anymore, restart is not set, and the
    > event is not reset to RPORT_EV_NONE. (current event is RPORT_EV_LOGO).
    > 12. Now, PLOGI succeeds and fc_rport_enter_ready() will not schedule
    > event_work, and hence the rport will never be created, eventually losing
    > the target after dev_loss_tmo.
    
    So, the problem here is that we were tracking the desire for
    the rport be restarted by state RESTART, which was otherwise
    equivalent to DELETE.  A contributing factor is that we dropped
    the lock between steps 6 and 10 in thread T2, which allows the
    state to change, and we didn't completely re-evaluate then.
    
    This is hopefully corrected by the following minor redesign:
    
    Simplify the rport restart logic by making the decision to
    restart after deleting the transport rport.  That decision
    is based on a new STARTED flag that indicates fc_rport_login()
    has been called and fc_rport_logoff() has not been called
    since then.  This replaces the need for the RESTART state.
    
    Only restart if the rdata is still in DELETED state
    and only if it still has the STARTED flag set.
    
    Also now, since we clear the event code much later in the
    work thread, allow for the possibility that the rport may
    have become READY again via incoming PLOGI, and if so,
    queue another event to handle that.
    
    In the problem scenario, the second LOGO received will
    cause the LOGO event to occur again.
    
    Reported-by: Bhanu Gollapudi <bprakash@broadcom.com>
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 7495c0ba67ee..db54c4a2d14b 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -104,7 +104,6 @@ enum fc_disc_event {
  * @RPORT_ST_LOGO:    Remote port logout (LOGO) sent
  * @RPORT_ST_ADISC:   Discover Address sent
  * @RPORT_ST_DELETE:  Remote port being deleted
- * @RPORT_ST_RESTART: Remote port being deleted and will restart
 */
 enum fc_rport_state {
 	RPORT_ST_INIT,
@@ -115,7 +114,6 @@ enum fc_rport_state {
 	RPORT_ST_LOGO,
 	RPORT_ST_ADISC,
 	RPORT_ST_DELETE,
-	RPORT_ST_RESTART,
 };
 
 /**
@@ -173,6 +171,7 @@ struct fc_rport_libfc_priv {
 	u16			   flags;
 	#define FC_RP_FLAGS_REC_SUPPORTED	(1 << 0)
 	#define FC_RP_FLAGS_RETRY		(1 << 1)
+	#define FC_RP_STARTED			(1 << 2)
 	unsigned int	           e_d_tov;
 	unsigned int	           r_a_tov;
 };
@@ -185,7 +184,7 @@ struct fc_rport_libfc_priv {
  * @rp_state:       Enumeration that tracks progress of PLOGI, PRLI,
  *                  and RTV exchanges
  * @ids:            The remote port identifiers and roles
- * @flags:          REC and RETRY supported flags
+ * @flags:          STARTED, REC and RETRY_SUPPORTED flags
  * @max_seq:        Maximum number of concurrent sequences
  * @disc_id:        The discovery identifier
  * @maxframe_size:  The maximum frame size

commit 7b2787ec15b9d1c2f716da61b0eec21a3f5e6520
Author: Robert Love <robert.w.love@intel.com>
Date:   Fri May 7 15:18:41 2010 -0700

    [SCSI] libfc: Move the port_id into lport
    
    This patch creates a port_id member in struct fc_lport.
    This allows libfc to just deal with fc_lport instances
    instead of calling into the fc_host to get the port_id.
    
    This change helps in only using symbols necessary for
    operation from the libfc structures. libfc still needs
    to change the fc_host_port_id() if the port_id changes
    so the presentation layer (scsi_transport_fc) can provide
    the user with the correct value, but libfc shouldn't
    rely on the presentation layer for operational values.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 1755fa7e9271..7495c0ba67ee 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -780,6 +780,7 @@ struct fc_disc {
  * @dev_stats:             FCoE device stats (TODO: libfc should not be
  *                         FCoE aware)
  * @retry_count:           Number of retries in the current state
+ * @port_id:               FC Port ID
  * @wwpn:                  World Wide Port Name
  * @wwnn:                  World Wide Node Name
  * @service_params:        Common service parameters
@@ -826,6 +827,7 @@ struct fc_lport {
 	u8			       retry_count;
 
 	/* Fabric information */
+	u32                            port_id;
 	u64			       wwpn;
 	u64			       wwnn;
 	unsigned int		       service_params;

commit 1b80e0f91c41db4633c0a61f727de169a9e9b275
Author: Robert Love <robert.w.love@intel.com>
Date:   Fri May 7 15:18:24 2010 -0700

    [SCSI] libfc: Remove unused fc_get_host_port_type
    
    Remove this unused routine.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index a26bb50c0c8b..1755fa7e9271 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -1049,7 +1049,6 @@ void fc_exch_mgr_reset(struct fc_lport *, u32 s_id, u32 d_id);
  * Functions for fc_functions_template
  */
 void fc_get_host_speed(struct Scsi_Host *);
-void fc_get_host_port_type(struct Scsi_Host *);
 void fc_get_host_port_state(struct Scsi_Host *);
 void fc_set_rport_loss_tmo(struct fc_rport *, u32 timeout);
 struct fc_host_statistics *fc_get_host_stats(struct Scsi_Host *);

commit 0b2f74a47f2b10bd4c70324820a93c070b3960a5
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Fri Apr 9 14:22:39 2010 -0700

    [SCSI] libfc: fix hton24 macro to take expressions as args
    
    hton24(p + 3, value) would fail to compile because
    p + 3[0] is not a valid expression.
    
    Went ahead and converted hton24 and ntoh24 to inline
    functions, which is better because the parameters
    are evalutated only once.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 8d0d1b2d8258..a26bb50c0c8b 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -47,13 +47,18 @@
 #define ntohll(x) be64_to_cpu(x)
 #define htonll(x) cpu_to_be64(x)
 
-#define ntoh24(p) (((p)[0] << 16) | ((p)[1] << 8) | ((p)[2]))
 
-#define hton24(p, v)	do {			\
-		p[0] = (((v) >> 16) & 0xFF);	\
-		p[1] = (((v) >> 8) & 0xFF);	\
-		p[2] = ((v) & 0xFF);		\
-	} while (0)
+static inline u32 ntoh24(const u8 *p)
+{
+	return (p[0] << 16) | (p[1] << 8) | p[2];
+}
+
+static inline void hton24(u8 *p, u32 v)
+{
+	p[0] = (v >> 16) & 0xff;
+	p[1] = (v >> 8) & 0xff;
+	p[2] = v & 0xff;
+}
 
 /**
  * enum fc_lport_state - Local port states

commit f018b73af6db4f330ad5da9ac53997a699c30c42
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Fri Mar 12 16:08:55 2010 -0800

    [SCSI] libfc, libfcoe, fcoe: use smp_processor_id() only when preempt disabled
    
    When the kernel is configured for preemption, using smp_processor_id()
    when preemption is enabled causes a warning backtrace and is wrong
    since we could move off of that CPU as soon as we get the ID,
    and we would be referencing the wrong CPU, and possibly an invalid one
    if it could be hotswapped out.
    
    Remove the fc_lport_get_stats() function and explicitly use per_cpu_ptr()
    to get the statistics.  Where preemption has been disabled by holding
    a _bh lock continue to use smp_processor_id(), but otherwise use
    get_cpu()/put_cpu().
    
    In fcoe_recv_frame() also changed the cases where we return in the
    middle to do a goto to the code which bumps ErrorFrames and does
    a put_cpu().  Two of these cases didn't bump ErrorFrames before, but
    doing so is harmless because they "can't happen", due to prior length
    checks.
    
    Also rearranged code in fcoe_recv_frame() to have only one call to
    fc_exch_recv().  It's just as efficient and saves a call to put_cpu().
    
    In fc_fcp.c, adjusted a FIXME comment for code which doesn't need fixing.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 4b912eee33e5..8d0d1b2d8258 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -917,15 +917,6 @@ static inline void fc_lport_free_stats(struct fc_lport *lport)
 	free_percpu(lport->dev_stats);
 }
 
-/**
- * fc_lport_get_stats() - Get a local port's statistics
- * @lport: The local port whose statistics are to be retreived
- */
-static inline struct fcoe_dev_stats *fc_lport_get_stats(struct fc_lport *lport)
-{
-	return per_cpu_ptr(lport->dev_stats, smp_processor_id());
-}
-
 /**
  * lport_priv() - Return the private data from a local port
  * @lport: The local port whose private data is to be retreived

commit b84056bf68404a5fe06b452ea9790b9927e793a6
Author: Yi Zou <yi.zou@intel.com>
Date:   Fri Nov 20 14:55:19 2009 -0800

    [SCSI] fcoe, libfc: add get_lesb() to allow LLD to fill the link error status block (LESB)
    
    Add a member function pointer as get_lesb to libfc_function_template so LLD
    can fill the LESB based on its own statistics. For fcoe, it fills the LESB
    as a fcoe_fc_els_lesb struct according to FC-BB-5.
    
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index b97be2903cbc..4b912eee33e5 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -510,6 +510,12 @@ struct libfc_function_template {
 	 * STATUS: OPTIONAL
 	 */
 	int (*ddp_done)(struct fc_lport *, u16);
+	/*
+	 * Allow LLD to fill its own Link Error Status Block
+	 *
+	 * STATUS: OPTIONAL
+	 */
+	void (*get_lesb)(struct fc_lport *, struct fc_els_lesb *lesb);
 	/*
 	 * Send a frame using an existing sequence and exchange.
 	 *

commit 6580bbd0afe6ba1be5d53b331e92a7690046c923
Author: Yi Zou <yi.zou@intel.com>
Date:   Fri Nov 20 14:54:52 2009 -0800

    [SCSI] libfc: add FC-BB-5 LESB counters to fcoe_dev_stats
    
    FC-BB-5 Rev2.0, Clause 7.10 extends the FC-LS-3 LESB for FC-BB_E. We are
    already tracking Link Failure Count so add the rest in this patch.
    
    For VLinkFailureCount and MissDiscAdvCount, they are part of the per-cpu
    fcoe_dev_stats. For SymbolErrorCount, ErroredBlockCount, and FCSErrorCount,
    they are defined in IEEE 802.3-2008 and are per LLD. They are expected to
    come from LLD.
    
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 2936fbae41e4..b97be2903cbc 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -231,6 +231,8 @@ struct fc_rport_priv {
  * @ControlRequests:       Number of control requests
  * @InputMegabytes:        Number of received megabytes
  * @OutputMegabytes:       Number of transmitted megabytes
+ * @VLinkFailureCount:     Number of virtual link failures
+ * @MissDiscAdvCount:      Number of missing FIP discovery advertisement
  */
 struct fcoe_dev_stats {
 	u64		SecondsSinceLastReset;
@@ -249,6 +251,8 @@ struct fcoe_dev_stats {
 	u64		ControlRequests;
 	u64		InputMegabytes;
 	u64		OutputMegabytes;
+	u64		VLinkFailureCount;
+	u64		MissDiscAdvCount;
 };
 
 /**

commit ab593b187391bdd03ccad2968972a2e118a88cd4
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Nov 3 11:49:27 2009 -0800

    [SCSI] libfc: register FC4 features with the FC switch
    
    Customers and certification tests have pointed out that we don't
    show up on the switch management software as an initiator.
    
    On some MDS switches 'show fcns database' command shows libfc
    initiators as 'fcp' not 'fcp:init' like other initiators.
    
    On others switches, I think the switch gets the features by doing a PRLI,
    but it may be only certain models or under certain configurations.
    
    Fix this by registering our FC4 features with the RFF_ID CT request
    after local port login and after the RFT_ID.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 67ce9fa1fee4..2936fbae41e4 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -62,6 +62,7 @@
  * @LPORT_ST_DNS:      Waiting for name server remote port to become ready
  * @LPORT_ST_RPN_ID:   Register port name by ID (RPN_ID) sent
  * @LPORT_ST_RFT_ID:   Register Fibre Channel types by ID (RFT_ID) sent
+ * @LPORT_ST_RFF_ID:   Register FC-4 Features by ID (RFF_ID) sent
  * @LPORT_ST_SCR:      State Change Register (SCR) sent
  * @LPORT_ST_READY:    Ready for use
  * @LPORT_ST_LOGO:     Local port logout (LOGO) sent
@@ -75,6 +76,7 @@ enum fc_lport_state {
 	LPORT_ST_RSNN_NN,
 	LPORT_ST_RSPN_ID,
 	LPORT_ST_RFT_ID,
+	LPORT_ST_RFF_ID,
 	LPORT_ST_SCR,
 	LPORT_ST_READY,
 	LPORT_ST_LOGO,

commit 093bb6a2d378ee83fc6ab886c772b6be86abb5a8
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Nov 3 11:49:05 2009 -0800

    [SCSI] libfc: add set_fid function to libfc template
    
    This is to notify the LLD when an FC_ID is assigned to the local port.
    
    The fnic driver needs to push the assigned FC_ID to firmware.
    It currently does this by intercepting the FLOGI responses, and
    in order to make that code more common with FIP and NPIV, it
    makes more sense to wait until the local port has completely
    handled the FLOGI or FDISC response.  Also, when we fix
    point-to-point FC_ID assignment, we'll need this callback as well.
    
    Add a call to the libfc template, which is called whenever
    the local port FC_ID is being assigned.  It defaults to
    fc_lport_set_fid(), supplied by libfc.
    
    As additional benefit of this function, the LLD may determine
    the MAC address that caused the change by looking at the received frame.
    
    We also print the assigned port ID as long as it isn't 0.
    Setting port ID to 0 happens often in reset while retrying FLOGI,
    and would be uninteresting.  This replaces the previous message
    which didn't identify the host adapter instance.
    
    patch v2 note: changed one word in a comment.  "intercepted" -> "provided".
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 310d8a22b726..67ce9fa1fee4 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -580,6 +580,26 @@ struct libfc_function_template {
 	 */
 	int (*lport_reset)(struct fc_lport *);
 
+	/*
+	 * Set the local port FC_ID.
+	 *
+	 * This may be provided by the LLD to allow it to be
+	 * notified when the local port is assigned a FC-ID.
+	 *
+	 * The frame, if non-NULL, is the incoming frame with the
+	 * FLOGI LS_ACC or FLOGI, and may contain the granted MAC
+	 * address for the LLD.  The frame pointer may be NULL if
+	 * no MAC is associated with this assignment (LOGO or PLOGI).
+	 *
+	 * If FC_ID is non-zero, r_a_tov and e_d_tov must be valid.
+	 *
+	 * Note: this is called with the local port mutex held.
+	 *
+	 * STATUS: OPTIONAL
+	 */
+	void (*lport_set_port_id)(struct fc_lport *, u32 port_id,
+				  struct fc_frame *);
+
 	/*
 	 * Create a remote port with a given port ID
 	 *

commit 3a3b42bf89a9b90ae9ed2c57fdc378e5473a0ef9
Author: Robert Love <robert.w.love@intel.com>
Date:   Tue Nov 3 11:47:39 2009 -0800

    [SCSI] libfc: Formatting cleanups across libfc
    
    This patch makes a variety of cleanup changes to all libfc files.
    
    This patch adds kernel-doc headers to all functions lacking them
    and attempts to better format existing headers. It also add kernel-doc
    headers to structures.
    
    This patch ensures that the current naming conventions for local ports,
    remote ports and remote port private data is upheld in the following
    manner.
    
    struct               instance (i.e. variable name)
    --------------------------------------------------
    fc_lport                      lport
    fc_rport                      rport
    fc_rport_libfc_priv           rpriv
    fc_rport_priv                 rdata
    
    I also renamed dns_rp and ptp_rp to dns_rdata and ptp_rdata
    respectively.
    
    I used emacs 'indent-region' and 'tabify' on all libfc files
    to correct spacing alignments.
    
    I feel sorry for anyone attempting to review this patch.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 54df9fe00c14..310d8a22b726 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -55,8 +55,17 @@
 		p[2] = ((v) & 0xFF);		\
 	} while (0)
 
-/*
- * FC HBA status
+/**
+ * enum fc_lport_state - Local port states
+ * @LPORT_ST_DISABLED: Disabled
+ * @LPORT_ST_FLOGI:    Fabric login (FLOGI) sent
+ * @LPORT_ST_DNS:      Waiting for name server remote port to become ready
+ * @LPORT_ST_RPN_ID:   Register port name by ID (RPN_ID) sent
+ * @LPORT_ST_RFT_ID:   Register Fibre Channel types by ID (RFT_ID) sent
+ * @LPORT_ST_SCR:      State Change Register (SCR) sent
+ * @LPORT_ST_READY:    Ready for use
+ * @LPORT_ST_LOGO:     Local port logout (LOGO) sent
+ * @LPORT_ST_RESET:    Local port reset
  */
 enum fc_lport_state {
 	LPORT_ST_DISABLED = 0,
@@ -78,16 +87,28 @@ enum fc_disc_event {
 	DISC_EV_FAILED
 };
 
+/**
+ * enum fc_rport_state - Remote port states
+ * @RPORT_ST_INIT:    Initialized
+ * @RPORT_ST_PLOGI:   Waiting for PLOGI completion
+ * @RPORT_ST_PRLI:    Waiting for PRLI completion
+ * @RPORT_ST_RTV:     Waiting for RTV completion
+ * @RPORT_ST_READY:   Ready for use
+ * @RPORT_ST_LOGO:    Remote port logout (LOGO) sent
+ * @RPORT_ST_ADISC:   Discover Address sent
+ * @RPORT_ST_DELETE:  Remote port being deleted
+ * @RPORT_ST_RESTART: Remote port being deleted and will restart
+*/
 enum fc_rport_state {
-	RPORT_ST_INIT,		/* initialized */
-	RPORT_ST_PLOGI,		/* waiting for PLOGI completion */
-	RPORT_ST_PRLI,		/* waiting for PRLI completion */
-	RPORT_ST_RTV,		/* waiting for RTV completion */
-	RPORT_ST_READY,		/* ready for use */
-	RPORT_ST_LOGO,		/* port logout sent */
-	RPORT_ST_ADISC,		/* Discover Address sent */
-	RPORT_ST_DELETE,	/* port being deleted */
-	RPORT_ST_RESTART,       /* remote port being deleted and will restart */
+	RPORT_ST_INIT,
+	RPORT_ST_PLOGI,
+	RPORT_ST_PRLI,
+	RPORT_ST_RTV,
+	RPORT_ST_READY,
+	RPORT_ST_LOGO,
+	RPORT_ST_ADISC,
+	RPORT_ST_DELETE,
+	RPORT_ST_RESTART,
 };
 
 /**
@@ -98,12 +119,20 @@ enum fc_rport_state {
  * @port_id:    Port ID of the discovered port
  */
 struct fc_disc_port {
-	struct fc_lport             *lp;
-	struct list_head            peers;
-	struct work_struct	    rport_work;
-	u32                         port_id;
+	struct fc_lport    *lp;
+	struct list_head   peers;
+	struct work_struct rport_work;
+	u32                port_id;
 };
 
+/**
+ * enum fc_rport_event - Remote port events
+ * @RPORT_EV_NONE:   No event
+ * @RPORT_EV_READY:  Remote port is ready for use
+ * @RPORT_EV_FAILED: State machine failed, remote port is not ready
+ * @RPORT_EV_STOP:   Remote port has been stopped
+ * @RPORT_EV_LOGO:   Remote port logout (LOGO) sent
+ */
 enum fc_rport_event {
 	RPORT_EV_NONE = 0,
 	RPORT_EV_READY,
@@ -114,6 +143,10 @@ enum fc_rport_event {
 
 struct fc_rport_priv;
 
+/**
+ * struct fc_rport_operations - Operations for a remote port
+ * @event_callback: Function to be called for remote port events
+ */
 struct fc_rport_operations {
 	void (*event_callback)(struct fc_lport *, struct fc_rport_priv *,
 			       enum fc_rport_event);
@@ -121,11 +154,11 @@ struct fc_rport_operations {
 
 /**
  * struct fc_rport_libfc_priv - libfc internal information about a remote port
- * @local_port: Fibre Channel host port instance
- * @rp_state: indicates READY for I/O or DELETE when blocked.
- * @flags: REC and RETRY supported flags
- * @e_d_tov: error detect timeout value (in msec)
- * @r_a_tov: resource allocation timeout value (in msec)
+ * @local_port: The associated local port
+ * @rp_state:   Indicates READY for I/O or DELETE when blocked
+ * @flags:      REC and RETRY supported flags
+ * @e_d_tov:    Error detect timeout value (in msec)
+ * @r_a_tov:    Resource allocation timeout value (in msec)
  */
 struct fc_rport_libfc_priv {
 	struct fc_lport		   *local_port;
@@ -138,47 +171,64 @@ struct fc_rport_libfc_priv {
 };
 
 /**
- * struct fc_rport_priv - libfc rport and discovery info about a remote port
- * @local_port: Fibre Channel host port instance
- * @rport: transport remote port
- * @kref: reference counter
- * @rp_state: state tracks progress of PLOGI, PRLI, and RTV exchanges
- * @ids: remote port identifiers and roles
- * @flags: REC and RETRY supported flags
- * @max_seq: maximum number of concurrent sequences
- * @disc_id: discovery identifier
- * @maxframe_size: maximum frame size
- * @retries: retry count in current state
- * @e_d_tov: error detect timeout value (in msec)
- * @r_a_tov: resource allocation timeout value (in msec)
- * @rp_mutex: mutex protects rport
- * @retry_work:
- * @event_callback: Callback for rport READY, FAILED or LOGO
+ * struct fc_rport_priv - libfc remote port and discovery info
+ * @local_port:     The associated local port
+ * @rport:          The FC transport remote port
+ * @kref:           Reference counter
+ * @rp_state:       Enumeration that tracks progress of PLOGI, PRLI,
+ *                  and RTV exchanges
+ * @ids:            The remote port identifiers and roles
+ * @flags:          REC and RETRY supported flags
+ * @max_seq:        Maximum number of concurrent sequences
+ * @disc_id:        The discovery identifier
+ * @maxframe_size:  The maximum frame size
+ * @retries:        The retry count for the current state
+ * @e_d_tov:        Error detect timeout value (in msec)
+ * @r_a_tov:        Resource allocation timeout value (in msec)
+ * @rp_mutex:       The mutex that protects the remote port
+ * @retry_work:     Handle for retries
+ * @event_callback: Callback when READY, FAILED or LOGO states complete
  */
 struct fc_rport_priv {
-	struct fc_lport		   *local_port;
-	struct fc_rport		   *rport;
-	struct kref		   kref;
-	enum fc_rport_state        rp_state;
+	struct fc_lport		    *local_port;
+	struct fc_rport		    *rport;
+	struct kref		    kref;
+	enum fc_rport_state         rp_state;
 	struct fc_rport_identifiers ids;
-	u16			   flags;
-	u16		           max_seq;
-	u16			   disc_id;
-	u16			   maxframe_size;
-	unsigned int	           retries;
-	unsigned int	           e_d_tov;
-	unsigned int	           r_a_tov;
-	struct mutex               rp_mutex;
-	struct delayed_work	   retry_work;
-	enum fc_rport_event        event;
-	struct fc_rport_operations *ops;
-	struct list_head           peers;
-	struct work_struct         event_work;
-	u32			   supported_classes;
+	u16			    flags;
+	u16		            max_seq;
+	u16			    disc_id;
+	u16			    maxframe_size;
+	unsigned int	            retries;
+	unsigned int	            e_d_tov;
+	unsigned int	            r_a_tov;
+	struct mutex                rp_mutex;
+	struct delayed_work	    retry_work;
+	enum fc_rport_event         event;
+	struct fc_rport_operations  *ops;
+	struct list_head            peers;
+	struct work_struct          event_work;
+	u32			    supported_classes;
 };
 
-/*
- * fcoe stats structure
+/**
+ * struct fcoe_dev_stats - fcoe stats structure
+ * @SecondsSinceLastReset: Seconds since the last reset
+ * @TxFrames:              Number of transmitted frames
+ * @TxWords:               Number of transmitted words
+ * @RxFrames:              Number of received frames
+ * @RxWords:               Number of received words
+ * @ErrorFrames:           Number of received error frames
+ * @DumpedFrames:          Number of dumped frames
+ * @LinkFailureCount:      Number of link failures
+ * @LossOfSignalCount:     Number for signal losses
+ * @InvalidTxWordCount:    Number of invalid transmitted words
+ * @InvalidCRCCount:       Number of invalid CRCs
+ * @InputRequests:         Number of input requests
+ * @OutputRequests:        Number of output requests
+ * @ControlRequests:       Number of control requests
+ * @InputMegabytes:        Number of received megabytes
+ * @OutputMegabytes:       Number of transmitted megabytes
  */
 struct fcoe_dev_stats {
 	u64		SecondsSinceLastReset;
@@ -199,10 +249,13 @@ struct fcoe_dev_stats {
 	u64		OutputMegabytes;
 };
 
-/*
- * els data is used for passing ELS respone specific
- * data to send ELS response mainly using infomation
- * in exchange and sequence in EM layer.
+/**
+ * struct fc_seq_els_data - ELS data used for passing ELS specific responses
+ * @fp:     The ELS frame
+ * @reason: The reason for rejection
+ * @explan: The explaination of the rejection
+ *
+ * Mainly used by the exchange manager layer.
  */
 struct fc_seq_els_data {
 	struct fc_frame *fp;
@@ -210,77 +263,87 @@ struct fc_seq_els_data {
 	enum fc_els_rjt_explan explan;
 };
 
-/*
- * FCP request structure, one for each scsi cmd request
+/**
+ * struct fc_fcp_pkt - FCP request structure (one for each scsi_cmnd request)
+ * @lp:              The associated local port
+ * @state:           The state of the I/O
+ * @tgt_flags:       Target's flags
+ * @ref_cnt:         Reference count
+ * @scsi_pkt_lock:   Lock to protect the SCSI packet (must be taken before the
+ *                   host_lock if both are to be held at the same time)
+ * @cmd:             The SCSI command (set and clear with the host_lock held)
+ * @list:            Tracks queued commands (accessed with the host_lock held)
+ * @timer:           The command timer
+ * @tm_done:         Completion indicator
+ * @wait_for_comp:   Indicator to wait for completion of the I/O (in jiffies)
+ * @start_time:      Timestamp indicating the start of the I/O (in jiffies)
+ * @end_time:        Timestamp indicating the end of the I/O (in jiffies)
+ * @last_pkt_time:   Timestamp of the last frame received (in jiffies)
+ * @data_len:        The length of the data
+ * @cdb_cmd:         The CDB command
+ * @xfer_len:        The transfer length
+ * @xfer_ddp:        Indicates if this transfer used DDP (XID of the exchange
+ *                   will be set here if DDP was setup)
+ * @xfer_contig_end: The offset into the buffer if the buffer is contiguous
+ *                   (Tx and Rx)
+ * @max_payload:     The maximum payload size (in bytes)
+ * @io_status:       SCSI result (upper 24 bits)
+ * @cdb_status:      CDB status
+ * @status_code:     FCP I/O status
+ * @scsi_comp_flags: Completion flags (bit 3 Underrun bit 2: overrun)
+ * @req_flags:       Request flags (bit 0: read bit:1 write)
+ * @scsi_resid:      SCSI residule length
+ * @rport:           The remote port that the SCSI command is targeted at
+ * @seq_ptr:         The sequence that will carry the SCSI command
+ * @recov_retry:     Number of recovery retries
+ * @recov_seq:       The sequence for REC or SRR
  */
 struct fc_fcp_pkt {
-	/*
-	 * housekeeping stuff
-	 */
-	struct fc_lport *lp;	/* handle to hba struct */
-	u16		state;		/* scsi_pkt state state */
-	u16		tgt_flags;	/* target flags	 */
-	atomic_t	ref_cnt;	/* fcp pkt ref count */
-	spinlock_t	scsi_pkt_lock;	/* Must be taken before the host lock
-					 * if both are held at the same time */
-	/*
-	 * SCSI I/O related stuff
-	 */
-	struct scsi_cmnd *cmd;		/* scsi command pointer. set/clear
-					 * under host lock */
-	struct list_head list;		/* tracks queued commands. access under
-					 * host lock */
-	/*
-	 * timeout related stuff
-	 */
-	struct timer_list timer;	/* command timer */
+	/* Housekeeping information */
+	struct fc_lport   *lp;
+	u16		  state;
+	u16		  tgt_flags;
+	atomic_t	  ref_cnt;
+	spinlock_t	  scsi_pkt_lock;
+
+	/* SCSI I/O related information */
+	struct scsi_cmnd  *cmd;
+	struct list_head  list;
+
+	/* Timeout related information */
+	struct timer_list timer;
 	struct completion tm_done;
-	int	wait_for_comp;
-	unsigned long	start_time;	/* start jiffie */
-	unsigned long	end_time;	/* end jiffie */
-	unsigned long	last_pkt_time;	 /* jiffies of last frame received */
-
-	/*
-	 * scsi cmd and data transfer information
-	 */
-	u32		data_len;
-	/*
-	 * transport related veriables
-	 */
-	struct fcp_cmnd cdb_cmd;
-	size_t		xfer_len;
-	u16		xfer_ddp;	/* this xfer is ddped */
-	u32		xfer_contig_end; /* offset of end of contiguous xfer */
-	u16		max_payload;	/* max payload size in bytes */
-
-	/*
-	 * scsi/fcp return status
-	 */
-	u32		io_status;	/* SCSI result upper 24 bits */
-	u8		cdb_status;
-	u8		status_code;	/* FCP I/O status */
-	/* bit 3 Underrun bit 2: overrun */
-	u8		scsi_comp_flags;
-	u32		req_flags;	/* bit 0: read bit:1 write */
-	u32		scsi_resid;	/* residule length */
-
-	struct fc_rport	*rport;		/* remote port pointer */
-	struct fc_seq	*seq_ptr;	/* current sequence pointer */
-	/*
-	 * Error Processing
-	 */
-	u8		recov_retry;	/* count of recovery retries */
-	struct fc_seq	*recov_seq;	/* sequence for REC or SRR */
+	int	          wait_for_comp;
+	unsigned long	  start_time;
+	unsigned long	  end_time;
+	unsigned long	  last_pkt_time;
+
+	/* SCSI command and data transfer information */
+	u32		  data_len;
+
+	/* Transport related veriables */
+	struct fcp_cmnd   cdb_cmd;
+	size_t		  xfer_len;
+	u16		  xfer_ddp;
+	u32		  xfer_contig_end;
+	u16		  max_payload;
+
+	/* SCSI/FCP return status */
+	u32		  io_status;
+	u8		  cdb_status;
+	u8		  status_code;
+	u8		  scsi_comp_flags;
+	u32		  req_flags;
+	u32		  scsi_resid;
+
+	/* Associated structures */
+	struct fc_rport	  *rport;
+	struct fc_seq	  *seq_ptr;
+
+	/* Error Processing information */
+	u8		  recov_retry;
+	struct fc_seq	  *recov_seq;
 };
-/*
- * FC_FCP HELPER FUNCTIONS
- *****************************/
-static inline bool fc_fcp_is_read(const struct fc_fcp_pkt *fsp)
-{
-	if (fsp && fsp->cmd)
-		return fsp->cmd->sc_data_direction == DMA_FROM_DEVICE;
-	return false;
-}
 
 /*
  * Structure and function definitions for managing Fibre Channel Exchanges
@@ -293,23 +356,51 @@ static inline bool fc_fcp_is_read(const struct fc_fcp_pkt *fsp)
 
 struct fc_exch_mgr;
 struct fc_exch_mgr_anchor;
-extern u16	fc_cpu_mask;	/* cpu mask for possible cpus */
+extern u16 fc_cpu_mask;	/* cpu mask for possible cpus */
 
-/*
- * Sequence.
+/**
+ * struct fc_seq - FC sequence
+ * @id:       The sequence ID
+ * @ssb_stat: Status flags for the sequence status block (SSB)
+ * @cnt:      Number of frames sent so far
+ * @rec_data: FC-4 value for REC
  */
 struct fc_seq {
-	u8	id;		/* seq ID */
-	u16	ssb_stat;	/* status flags for sequence status block */
-	u16	cnt;		/* frames sent so far on sequence */
-	u32	rec_data;	/* FC-4 value for REC */
+	u8  id;
+	u16 ssb_stat;
+	u16 cnt;
+	u32 rec_data;
 };
 
 #define FC_EX_DONE		(1 << 0) /* ep is completed */
 #define FC_EX_RST_CLEANUP	(1 << 1) /* reset is forcing completion */
 
-/*
- * Exchange.
+/**
+ * struct fc_exch - Fibre Channel Exchange
+ * @em:           Exchange manager
+ * @pool:         Exchange pool
+ * @state:        The exchange's state
+ * @xid:          The exchange ID
+ * @ex_list:      Handle used by the EM to track free exchanges
+ * @ex_lock:      Lock that protects the exchange
+ * @ex_refcnt:    Reference count
+ * @timeout_work: Handle for timeout handler
+ * @lp:           The local port that this exchange is on
+ * @oxid:         Originator's exchange ID
+ * @rxid:         Responder's exchange ID
+ * @oid:          Originator's FCID
+ * @sid:          Source FCID
+ * @did:          Destination FCID
+ * @esb_stat:     ESB exchange status
+ * @r_a_tov:      Resouce allocation time out value (in msecs)
+ * @seq_id:       The next sequence ID to use
+ * @f_ctl:        F_CTL flags for the sequence
+ * @fh_type:      The frame type
+ * @class:        The class of service
+ * @seq:          The sequence in use on this exchange
+ * @resp:         Callback for responses on this exchange
+ * @destructor:   Called when destroying the exchange
+ * @arg:          Passed as a void pointer to the resp() callback
  *
  * Locking notes: The ex_lock protects following items:
  *	state, esb_stat, f_ctl, seq.ssb_stat
@@ -317,76 +408,59 @@ struct fc_seq {
  *	sequence allocation
  */
 struct fc_exch {
-	struct fc_exch_mgr *em;		/* exchange manager */
-	struct fc_exch_pool *pool;	/* per cpu exches pool */
-	u32		state;		/* internal driver state */
-	u16		xid;		/* our exchange ID */
-	struct list_head	ex_list;	/* free or busy list linkage */
-	spinlock_t	ex_lock;	/* lock covering exchange state */
-	atomic_t	ex_refcnt;	/* reference counter */
-	struct delayed_work timeout_work; /* timer for upper level protocols */
-	struct fc_lport	*lp;		/* fc device instance */
-	u16		oxid;		/* originator's exchange ID */
-	u16		rxid;		/* responder's exchange ID */
-	u32		oid;		/* originator's FCID */
-	u32		sid;		/* source FCID */
-	u32		did;		/* destination FCID */
-	u32		esb_stat;	/* exchange status for ESB */
-	u32		r_a_tov;	/* r_a_tov from rport (msec) */
-	u8		seq_id;		/* next sequence ID to use */
-	u32		f_ctl;		/* F_CTL flags for sequences */
-	u8		fh_type;	/* frame type */
-	enum fc_class	class;		/* class of service */
-	struct fc_seq	seq;		/* single sequence */
-	/*
-	 * Handler for responses to this current exchange.
-	 */
-	void		(*resp)(struct fc_seq *, struct fc_frame *, void *);
-	void		(*destructor)(struct fc_seq *, void *);
-	/*
-	 * arg is passed as void pointer to exchange
-	 * resp and destructor handlers
-	 */
-	void		*arg;
+	struct fc_exch_mgr  *em;
+	struct fc_exch_pool *pool;
+	u32		    state;
+	u16		    xid;
+	struct list_head    ex_list;
+	spinlock_t	    ex_lock;
+	atomic_t	    ex_refcnt;
+	struct delayed_work timeout_work;
+	struct fc_lport	    *lp;
+	u16		    oxid;
+	u16		    rxid;
+	u32		    oid;
+	u32		    sid;
+	u32		    did;
+	u32		    esb_stat;
+	u32		    r_a_tov;
+	u8		    seq_id;
+	u32		    f_ctl;
+	u8		    fh_type;
+	enum fc_class	    class;
+	struct fc_seq	    seq;
+
+	void		    (*resp)(struct fc_seq *, struct fc_frame *, void *);
+	void		    *arg;
+
+	void		    (*destructor)(struct fc_seq *, void *);
+
 };
 #define	fc_seq_exch(sp) container_of(sp, struct fc_exch, seq)
 
-struct libfc_function_template {
 
+struct libfc_function_template {
 	/*
 	 * Interface to send a FC frame
 	 *
 	 * STATUS: REQUIRED
 	 */
-	int (*frame_send)(struct fc_lport *lp, struct fc_frame *fp);
+	int (*frame_send)(struct fc_lport *, struct fc_frame *);
 
 	/*
 	 * Interface to send ELS/CT frames
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	struct fc_seq *(*elsct_send)(struct fc_lport *lport,
-				     u32 did,
-				     struct fc_frame *fp,
-				     unsigned int op,
+	struct fc_seq *(*elsct_send)(struct fc_lport *, u32 did,
+				     struct fc_frame *, unsigned int op,
 				     void (*resp)(struct fc_seq *,
-					     struct fc_frame *fp,
-					     void *arg),
+					     struct fc_frame *, void *arg),
 				     void *arg, u32 timer_msec);
 
 	/*
 	 * Send the FC frame payload using a new exchange and sequence.
 	 *
-	 * The frame pointer with some of the header's fields must be
-	 * filled before calling exch_seq_send(), those fields are,
-	 *
-	 * - routing control
-	 * - FC port did
-	 * - FC port sid
-	 * - FC header type
-	 * - frame control
-	 * - parameter or relative offset
-	 *
 	 * The exchange response handler is set in this routine to resp()
 	 * function pointer. It can be called in two scenarios: if a timeout
 	 * occurs or if a response frame is received for the exchange. The
@@ -407,14 +481,13 @@ struct libfc_function_template {
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	struct fc_seq *(*exch_seq_send)(struct fc_lport *lp,
-					struct fc_frame *fp,
-					void (*resp)(struct fc_seq *sp,
-						     struct fc_frame *fp,
-						     void *arg),
-					void (*destructor)(struct fc_seq *sp,
-							   void *arg),
-					void *arg, unsigned int timer_msec);
+	struct fc_seq *(*exch_seq_send)(struct fc_lport *, struct fc_frame *,
+					void (*resp)(struct fc_seq *,
+						     struct fc_frame *,
+						     void *),
+					void (*destructor)(struct fc_seq *,
+							   void *),
+					void *, unsigned int timer_msec);
 
 	/*
 	 * Sets up the DDP context for a given exchange id on the given
@@ -422,22 +495,22 @@ struct libfc_function_template {
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	int (*ddp_setup)(struct fc_lport *lp, u16 xid,
-			 struct scatterlist *sgl, unsigned int sgc);
+	int (*ddp_setup)(struct fc_lport *, u16, struct scatterlist *,
+			 unsigned int);
 	/*
 	 * Completes the DDP transfer and returns the length of data DDPed
 	 * for the given exchange id.
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	int (*ddp_done)(struct fc_lport *lp, u16 xid);
+	int (*ddp_done)(struct fc_lport *, u16);
 	/*
 	 * Send a frame using an existing sequence and exchange.
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	int (*seq_send)(struct fc_lport *lp, struct fc_seq *sp,
-			struct fc_frame *fp);
+	int (*seq_send)(struct fc_lport *, struct fc_seq *,
+			struct fc_frame *);
 
 	/*
 	 * Send an ELS response using infomation from a previous
@@ -445,8 +518,8 @@ struct libfc_function_template {
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	void (*seq_els_rsp_send)(struct fc_seq *sp, enum fc_els_cmd els_cmd,
-				 struct fc_seq_els_data *els_data);
+	void (*seq_els_rsp_send)(struct fc_seq *, enum fc_els_cmd,
+				 struct fc_seq_els_data *);
 
 	/*
 	 * Abort an exchange and sequence. Generally called because of a
@@ -458,7 +531,7 @@ struct libfc_function_template {
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	int (*seq_exch_abort)(const struct fc_seq *req_sp,
+	int (*seq_exch_abort)(const struct fc_seq *,
 			      unsigned int timer_msec);
 
 	/*
@@ -467,14 +540,14 @@ struct libfc_function_template {
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	void (*exch_done)(struct fc_seq *sp);
+	void (*exch_done)(struct fc_seq *);
 
 	/*
 	 * Start a new sequence on the same exchange/sequence tuple.
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	struct fc_seq *(*seq_start_next)(struct fc_seq *sp);
+	struct fc_seq *(*seq_start_next)(struct fc_seq *);
 
 	/*
 	 * Reset an exchange manager, completing all sequences and exchanges.
@@ -483,8 +556,7 @@ struct libfc_function_template {
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	void (*exch_mgr_reset)(struct fc_lport *,
-			       u32 s_id, u32 d_id);
+	void (*exch_mgr_reset)(struct fc_lport *, u32 s_id, u32 d_id);
 
 	/*
 	 * Flush the rport work queue. Generally used before shutdown.
@@ -498,8 +570,8 @@ struct libfc_function_template {
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	void (*lport_recv)(struct fc_lport *lp, struct fc_seq *sp,
-			   struct fc_frame *fp);
+	void (*lport_recv)(struct fc_lport *, struct fc_seq *,
+			   struct fc_frame *);
 
 	/*
 	 * Reset the local port.
@@ -565,31 +637,31 @@ struct libfc_function_template {
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	int (*fcp_cmd_send)(struct fc_lport *lp, struct fc_fcp_pkt *fsp,
-			    void (*resp)(struct fc_seq *, struct fc_frame *fp,
-					 void *arg));
+	int (*fcp_cmd_send)(struct fc_lport *, struct fc_fcp_pkt *,
+			    void (*resp)(struct fc_seq *, struct fc_frame *,
+					 void *));
 
 	/*
 	 * Cleanup the FCP layer, used durring link down and reset
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	void (*fcp_cleanup)(struct fc_lport *lp);
+	void (*fcp_cleanup)(struct fc_lport *);
 
 	/*
 	 * Abort all I/O on a local port
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	void (*fcp_abort_io)(struct fc_lport *lp);
+	void (*fcp_abort_io)(struct fc_lport *);
 
 	/*
 	 * Receive a request for the discovery layer.
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	void (*disc_recv_req)(struct fc_seq *,
-			      struct fc_frame *, struct fc_lport *);
+	void (*disc_recv_req)(struct fc_seq *, struct fc_frame *,
+			      struct fc_lport *);
 
 	/*
 	 * Start discovery for a local port.
@@ -618,133 +690,224 @@ struct libfc_function_template {
 	void (*disc_stop_final) (struct fc_lport *);
 };
 
-/* information used by the discovery layer */
+/**
+ * struct fc_disc - Discovery context
+ * @retry_count:   Number of retries
+ * @pending:       1 if discovery is pending, 0 if not
+ * @requesting:    1 if discovery has been requested, 0 if not
+ * @seq_count:     Number of sequences used for discovery
+ * @buf_len:       Length of the discovery buffer
+ * @disc_id:       Discovery ID
+ * @rports:        List of discovered remote ports
+ * @lport:         The local port that discovery is for
+ * @disc_mutex:    Mutex that protects the discovery context
+ * @partial_buf:   Partial name buffer (if names are returned
+ *                 in multiple frames)
+ * @disc_work:     handle for delayed work context
+ * @disc_callback: Callback routine called when discovery completes
+ */
 struct fc_disc {
-	unsigned char		retry_count;
-	unsigned char		pending;
-	unsigned char		requested;
-	unsigned short		seq_count;
-	unsigned char		buf_len;
-	u16			disc_id;
+	unsigned char         retry_count;
+	unsigned char         pending;
+	unsigned char         requested;
+	unsigned short        seq_count;
+	unsigned char         buf_len;
+	u16                   disc_id;
+
+	struct list_head      rports;
+	struct fc_lport	      *lport;
+	struct mutex	      disc_mutex;
+	struct fc_gpn_ft_resp partial_buf;
+	struct delayed_work   disc_work;
 
 	void (*disc_callback)(struct fc_lport *,
 			      enum fc_disc_event);
-
-	struct list_head	 rports;
-	struct fc_lport		*lport;
-	struct mutex		disc_mutex;
-	struct fc_gpn_ft_resp	partial_buf;	/* partial name buffer */
-	struct delayed_work	disc_work;
 };
 
+/**
+ * struct fc_lport - Local port
+ * @host:                  The SCSI host associated with a local port
+ * @ema_list:              Exchange manager anchor list
+ * @dns_rdata:             The directory server remote port
+ * @ptp_rdata:             Point to point remote port
+ * @scsi_priv:             FCP layer internal data
+ * @disc:                  Discovery context
+ * @vports:                Child vports if N_Port
+ * @vport:                 Parent vport if VN_Port
+ * @tt:                    Libfc function template
+ * @link_up:               Link state (1 = link up, 0 = link down)
+ * @qfull:                 Queue state (1 queue is full, 0 queue is not full)
+ * @state:                 Identifies the state
+ * @boot_time:             Timestamp indicating when the local port came online
+ * @host_stats:            SCSI host statistics
+ * @dev_stats:             FCoE device stats (TODO: libfc should not be
+ *                         FCoE aware)
+ * @retry_count:           Number of retries in the current state
+ * @wwpn:                  World Wide Port Name
+ * @wwnn:                  World Wide Node Name
+ * @service_params:        Common service parameters
+ * @e_d_tov:               Error detection timeout value
+ * @r_a_tov:               Resouce allocation timeout value
+ * @rnid_gen:              RNID information
+ * @sg_supp:               Indicates if scatter gather is supported
+ * @seq_offload:           Indicates if sequence offload is supported
+ * @crc_offload:           Indicates if CRC offload is supported
+ * @lro_enabled:           Indicates if large receive offload is supported
+ * @does_npiv:             Supports multiple vports
+ * @npiv_enabled:          Switch/fabric allows NPIV
+ * @mfs:                   The maximum Fibre Channel payload size
+ * @max_retry_count:       The maximum retry attempts
+ * @max_rport_retry_count: The maximum remote port retry attempts
+ * @lro_xid:               The maximum XID for LRO
+ * @lso_max:               The maximum large offload send size
+ * @fcts:                  FC-4 type mask
+ * @lp_mutex:              Mutex to protect the local port
+ * @list:                  Handle for list of local ports
+ * @retry_work:            Handle to local port for delayed retry context
+ */
 struct fc_lport {
-	struct list_head list;
-
 	/* Associations */
-	struct Scsi_Host	*host;
-	struct list_head	ema_list;
-	struct list_head	vports;		/* child vports if N_Port */
-	struct fc_vport		*vport;		/* parent vport if VN_Port */
-	struct fc_rport_priv	*dns_rp;
-	struct fc_rport_priv	*ptp_rp;
-	void			*scsi_priv;
-	struct fc_disc          disc;
+	struct Scsi_Host	       *host;
+	struct list_head	       ema_list;
+	struct fc_rport_priv	       *dns_rdata;
+	struct fc_rport_priv	       *ptp_rdata;
+	void			       *scsi_priv;
+	struct fc_disc                 disc;
+
+	/* Virtual port information */
+	struct list_head	       vports;
+	struct fc_vport		       *vport;
 
 	/* Operational Information */
 	struct libfc_function_template tt;
-	u8			link_up;
-	u8			qfull;
-	enum fc_lport_state	state;
-	unsigned long		boot_time;
-
-	struct fc_host_statistics host_stats;
-	struct fcoe_dev_stats	*dev_stats;
-
-	u64			wwpn;
-	u64			wwnn;
-	u8			retry_count;
+	u8			       link_up;
+	u8			       qfull;
+	enum fc_lport_state	       state;
+	unsigned long		       boot_time;
+	struct fc_host_statistics      host_stats;
+	struct fcoe_dev_stats	       *dev_stats;
+	u8			       retry_count;
+
+	/* Fabric information */
+	u64			       wwpn;
+	u64			       wwnn;
+	unsigned int		       service_params;
+	unsigned int		       e_d_tov;
+	unsigned int		       r_a_tov;
+	struct fc_els_rnid_gen	       rnid_gen;
 
 	/* Capabilities */
-	u32			sg_supp:1;	/* scatter gather supported */
-	u32			seq_offload:1;	/* seq offload supported */
-	u32			crc_offload:1;	/* crc offload supported */
-	u32			lro_enabled:1;	/* large receive offload */
-	u32			does_npiv:1;	/* supports multiple vports */
-	u32			npiv_enabled:1;	/* switch/fabric allows NPIV */
-	u32			mfs;	        /* max FC payload size */
-	unsigned int		service_params;
-	unsigned int		e_d_tov;
-	unsigned int		r_a_tov;
-	u8			max_retry_count;
-	u8			max_rport_retry_count;
-	u16			link_speed;
-	u16			link_supported_speeds;
-	u16			lro_xid;	/* max xid for fcoe lro */
-	unsigned int		lso_max;	/* max large send size */
-	struct fc_ns_fts	fcts;	        /* FC-4 type masks */
-	struct fc_els_rnid_gen	rnid_gen;	/* RNID information */
-
-	/* Semaphores */
-	struct mutex lp_mutex;
+	u32			       sg_supp:1;
+	u32			       seq_offload:1;
+	u32			       crc_offload:1;
+	u32			       lro_enabled:1;
+	u32			       does_npiv:1;
+	u32			       npiv_enabled:1;
+	u32			       mfs;
+	u8			       max_retry_count;
+	u8			       max_rport_retry_count;
+	u16			       link_speed;
+	u16			       link_supported_speeds;
+	u16			       lro_xid;
+	unsigned int		       lso_max;
+	struct fc_ns_fts	       fcts;
 
 	/* Miscellaneous */
-	struct delayed_work	retry_work;
+	struct mutex                   lp_mutex;
+	struct list_head               list;
+	struct delayed_work	       retry_work;
 };
 
 /*
  * FC_LPORT HELPER FUNCTIONS
  *****************************/
-static inline int fc_lport_test_ready(struct fc_lport *lp)
+
+/**
+ * fc_lport_test_ready() - Determine if a local port is in the READY state
+ * @lport: The local port to test
+ */
+static inline int fc_lport_test_ready(struct fc_lport *lport)
 {
-	return lp->state == LPORT_ST_READY;
+	return lport->state == LPORT_ST_READY;
 }
 
-static inline void fc_set_wwnn(struct fc_lport *lp, u64 wwnn)
+/**
+ * fc_set_wwnn() - Set the World Wide Node Name of a local port
+ * @lport: The local port whose WWNN is to be set
+ * @wwnn:  The new WWNN
+ */
+static inline void fc_set_wwnn(struct fc_lport *lport, u64 wwnn)
 {
-	lp->wwnn = wwnn;
+	lport->wwnn = wwnn;
 }
 
-static inline void fc_set_wwpn(struct fc_lport *lp, u64 wwnn)
+/**
+ * fc_set_wwpn() - Set the World Wide Port Name of a local port
+ * @lport: The local port whose WWPN is to be set
+ * @wwnn:  The new WWPN
+ */
+static inline void fc_set_wwpn(struct fc_lport *lport, u64 wwnn)
 {
-	lp->wwpn = wwnn;
+	lport->wwpn = wwnn;
 }
 
-static inline void fc_lport_state_enter(struct fc_lport *lp,
+/**
+ * fc_lport_state_enter() - Change a local port's state
+ * @lport: The local port whose state is to change
+ * @state: The new state
+ */
+static inline void fc_lport_state_enter(struct fc_lport *lport,
 					enum fc_lport_state state)
 {
-	if (state != lp->state)
-		lp->retry_count = 0;
-	lp->state = state;
+	if (state != lport->state)
+		lport->retry_count = 0;
+	lport->state = state;
 }
 
-static inline int fc_lport_init_stats(struct fc_lport *lp)
+/**
+ * fc_lport_init_stats() - Allocate per-CPU statistics for a local port
+ * @lport: The local port whose statistics are to be initialized
+ */
+static inline int fc_lport_init_stats(struct fc_lport *lport)
 {
-	/* allocate per cpu stats block */
-	lp->dev_stats = alloc_percpu(struct fcoe_dev_stats);
-	if (!lp->dev_stats)
+	lport->dev_stats = alloc_percpu(struct fcoe_dev_stats);
+	if (!lport->dev_stats)
 		return -ENOMEM;
 	return 0;
 }
 
-static inline void fc_lport_free_stats(struct fc_lport *lp)
+/**
+ * fc_lport_free_stats() - Free memory for a local port's statistics
+ * @lport: The local port whose statistics are to be freed
+ */
+static inline void fc_lport_free_stats(struct fc_lport *lport)
 {
-	free_percpu(lp->dev_stats);
+	free_percpu(lport->dev_stats);
 }
 
-static inline struct fcoe_dev_stats *fc_lport_get_stats(struct fc_lport *lp)
+/**
+ * fc_lport_get_stats() - Get a local port's statistics
+ * @lport: The local port whose statistics are to be retreived
+ */
+static inline struct fcoe_dev_stats *fc_lport_get_stats(struct fc_lport *lport)
 {
-	return per_cpu_ptr(lp->dev_stats, smp_processor_id());
+	return per_cpu_ptr(lport->dev_stats, smp_processor_id());
 }
 
-static inline void *lport_priv(const struct fc_lport *lp)
+/**
+ * lport_priv() - Return the private data from a local port
+ * @lport: The local port whose private data is to be retreived
+ */
+static inline void *lport_priv(const struct fc_lport *lport)
 {
-	return (void *)(lp + 1);
+	return (void *)(lport + 1);
 }
 
 /**
- * libfc_host_alloc() - Allocate a Scsi_Host with room for the fc_lport
- * @sht: ptr to the scsi host templ
- * @priv_size: size of private data after fc_lport
+ * libfc_host_alloc() - Allocate a Scsi_Host with room for a local port and
+ *                      LLD private data
+ * @sht:       The SCSI host template
+ * @priv_size: Size of private data
  *
  * Returns: libfc lport
  */
@@ -765,156 +928,73 @@ libfc_host_alloc(struct scsi_host_template *sht, int priv_size)
 }
 
 /*
- * LOCAL PORT LAYER
+ * FC_FCP HELPER FUNCTIONS
  *****************************/
-int fc_lport_init(struct fc_lport *lp);
-
-/*
- * Destroy the specified local port by finding and freeing all
- * fc_rports associated with it and then by freeing the fc_lport
- * itself.
- */
-int fc_lport_destroy(struct fc_lport *lp);
-
-/*
- * Logout the specified local port from the fabric
- */
-int fc_fabric_logoff(struct fc_lport *lp);
-
-/*
- * Initiate the LP state machine. This handler will use fc_host_attr
- * to store the FLOGI service parameters, so fc_host_attr must be
- * initialized before calling this handler.
- */
-int fc_fabric_login(struct fc_lport *lp);
+static inline bool fc_fcp_is_read(const struct fc_fcp_pkt *fsp)
+{
+	if (fsp && fsp->cmd)
+		return fsp->cmd->sc_data_direction == DMA_FROM_DEVICE;
+	return false;
+}
 
 /*
- * The link is up for the given local port.
- */
+ * LOCAL PORT LAYER
+ *****************************/
+int fc_lport_init(struct fc_lport *);
+int fc_lport_destroy(struct fc_lport *);
+int fc_fabric_logoff(struct fc_lport *);
+int fc_fabric_login(struct fc_lport *);
 void __fc_linkup(struct fc_lport *);
 void fc_linkup(struct fc_lport *);
-
-/*
- * Link is down for the given local port.
- */
 void __fc_linkdown(struct fc_lport *);
 void fc_linkdown(struct fc_lport *);
-
-/*
- * Configure the local port.
- */
+void fc_vport_setlink(struct fc_lport *);
+void fc_vports_linkchange(struct fc_lport *);
 int fc_lport_config(struct fc_lport *);
-
-/*
- * Reset the local port.
- */
 int fc_lport_reset(struct fc_lport *);
-
-/*
- * Set the mfs or reset
- */
-int fc_set_mfs(struct fc_lport *lp, u32 mfs);
-
-/*
- * Allocate a new lport struct for an NPIV VN_Port
- */
-struct fc_lport *libfc_vport_create(struct fc_vport *vport, int privsize);
-
-/*
- * Find an NPIV VN_Port by port ID
- */
-struct fc_lport *fc_vport_id_lookup(struct fc_lport *n_port, u32 port_id);
-
-/*
- * NPIV VN_Port link state management
- */
-void fc_vport_setlink(struct fc_lport *vn_port);
-void fc_vports_linkchange(struct fc_lport *n_port);
-
-/*
- * Issue fc pass-thru request via bsg interface
- */
-int fc_lport_bsg_request(struct fc_bsg_job *job);
-
+int fc_set_mfs(struct fc_lport *, u32 mfs);
+struct fc_lport *libfc_vport_create(struct fc_vport *, int privsize);
+struct fc_lport *fc_vport_id_lookup(struct fc_lport *, u32 port_id);
+int fc_lport_bsg_request(struct fc_bsg_job *);
 
 /*
  * REMOTE PORT LAYER
  *****************************/
-int fc_rport_init(struct fc_lport *lp);
-void fc_rport_terminate_io(struct fc_rport *rp);
+int fc_rport_init(struct fc_lport *);
+void fc_rport_terminate_io(struct fc_rport *);
 
 /*
  * DISCOVERY LAYER
  *****************************/
-int fc_disc_init(struct fc_lport *lp);
-
+int fc_disc_init(struct fc_lport *);
 
 /*
- * SCSI LAYER
+ * FCP LAYER
  *****************************/
-/*
- * Initialize the SCSI block of libfc
- */
 int fc_fcp_init(struct fc_lport *);
+void fc_fcp_destroy(struct fc_lport *);
 
 /*
- * This section provides an API which allows direct interaction
- * with the SCSI-ml. Each of these functions satisfies a function
- * pointer defined in Scsi_Host and therefore is always called
- * directly from the SCSI-ml.
- */
-int fc_queuecommand(struct scsi_cmnd *sc_cmd,
+ * SCSI INTERACTION LAYER
+ *****************************/
+int fc_queuecommand(struct scsi_cmnd *,
 		    void (*done)(struct scsi_cmnd *));
-
-/*
- * Send an ABTS frame to the target device. The sc_cmd argument
- * is a pointer to the SCSI command to be aborted.
- */
-int fc_eh_abort(struct scsi_cmnd *sc_cmd);
-
-/*
- * Reset a LUN by sending send the tm cmd to the target.
- */
-int fc_eh_device_reset(struct scsi_cmnd *sc_cmd);
-
-/*
- * Reset the host adapter.
- */
-int fc_eh_host_reset(struct scsi_cmnd *sc_cmd);
-
-/*
- * Check rport status.
- */
-int fc_slave_alloc(struct scsi_device *sdev);
-
-/*
- * Adjust the queue depth.
- */
-int fc_change_queue_depth(struct scsi_device *sdev, int qdepth, int reason);
-
-/*
- * Change the tag type.
- */
-int fc_change_queue_type(struct scsi_device *sdev, int tag_type);
-
-/*
- * Free memory pools used by the FCP layer.
- */
-void fc_fcp_destroy(struct fc_lport *);
+int fc_eh_abort(struct scsi_cmnd *);
+int fc_eh_device_reset(struct scsi_cmnd *);
+int fc_eh_host_reset(struct scsi_cmnd *);
+int fc_slave_alloc(struct scsi_device *);
+int fc_change_queue_depth(struct scsi_device *, int qdepth, int reason);
+int fc_change_queue_type(struct scsi_device *, int tag_type);
 
 /*
  * ELS/CT interface
  *****************************/
-/*
- * Initializes ELS/CT interface
- */
-int fc_elsct_init(struct fc_lport *lp);
-struct fc_seq *fc_elsct_send(struct fc_lport *lport,
-				    u32 did,
-				    struct fc_frame *fp,
+int fc_elsct_init(struct fc_lport *);
+struct fc_seq *fc_elsct_send(struct fc_lport *, u32 did,
+				    struct fc_frame *,
 				    unsigned int op,
 				    void (*resp)(struct fc_seq *,
-						 struct fc_frame *fp,
+						 struct fc_frame *,
 						 void *arg),
 				    void *arg, u32 timer_msec);
 void fc_lport_flogi_resp(struct fc_seq *, struct fc_frame *, void *);
@@ -924,90 +1004,26 @@ void fc_lport_logo_resp(struct fc_seq *, struct fc_frame *, void *);
 /*
  * EXCHANGE MANAGER LAYER
  *****************************/
-/*
- * Initializes Exchange Manager related
- * function pointers in struct libfc_function_template.
- */
-int fc_exch_init(struct fc_lport *lp);
-
-/*
- * Adds Exchange Manager (EM) mp to lport.
- *
- * Adds specified mp to lport using struct fc_exch_mgr_anchor,
- * the struct fc_exch_mgr_anchor allows same EM sharing by
- * more than one lport with their specified match function,
- * the match function is used in allocating exchange from
- * added mp.
- */
-struct fc_exch_mgr_anchor *fc_exch_mgr_add(struct fc_lport *lport,
-					   struct fc_exch_mgr *mp,
+int fc_exch_init(struct fc_lport *);
+struct fc_exch_mgr_anchor *fc_exch_mgr_add(struct fc_lport *,
+					   struct fc_exch_mgr *,
 					   bool (*match)(struct fc_frame *));
-
-/*
- * Deletes Exchange Manager (EM) from lport by removing
- * its anchor ema from lport.
- *
- * If removed anchor ema was the last user of its associated EM
- * then also destroys associated EM.
- */
-void fc_exch_mgr_del(struct fc_exch_mgr_anchor *ema);
-
-/*
- * Clone an exchange manager list, getting reference holds for each EM.
- * This is for use with NPIV and sharing the X_ID space between VN_Ports.
- */
+void fc_exch_mgr_del(struct fc_exch_mgr_anchor *);
 int fc_exch_mgr_list_clone(struct fc_lport *src, struct fc_lport *dst);
-
-/*
- * Allocates an Exchange Manager (EM).
- *
- * The EM manages exchanges for their allocation and
- * free, also allows exchange lookup for received
- * frame.
- *
- * The class is used for initializing FC class of
- * allocated exchange from EM.
- *
- * The min_xid and max_xid will limit new
- * exchange ID (XID) within this range for
- * a new exchange.
- * The LLD may choose to have multiple EMs,
- * e.g. one EM instance per CPU receive thread in LLD.
- *
- * Specified match function is used in allocating exchanges
- * from newly allocated EM.
- */
-struct fc_exch_mgr *fc_exch_mgr_alloc(struct fc_lport *lp,
-				      enum fc_class class,
-				      u16 min_xid,
-				      u16 max_xid,
+struct fc_exch_mgr *fc_exch_mgr_alloc(struct fc_lport *, enum fc_class class,
+				      u16 min_xid, u16 max_xid,
 				      bool (*match)(struct fc_frame *));
-
-/*
- * Free all exchange managers of a lport.
- */
-void fc_exch_mgr_free(struct fc_lport *lport);
-
-/*
- * Receive a frame on specified local port and exchange manager.
- */
-void fc_exch_recv(struct fc_lport *lp, struct fc_frame *fp);
-
-/*
- * Reset all EMs of a lport, releasing its all sequences and
- * exchanges. If sid is non-zero, then reset only exchanges
- * we sourced from that FID. If did is non-zero, reset only
- * exchanges destined to that FID.
- */
+void fc_exch_mgr_free(struct fc_lport *);
+void fc_exch_recv(struct fc_lport *, struct fc_frame *);
 void fc_exch_mgr_reset(struct fc_lport *, u32 s_id, u32 d_id);
 
 /*
  * Functions for fc_functions_template
  */
-void fc_get_host_speed(struct Scsi_Host *shost);
-void fc_get_host_port_type(struct Scsi_Host *shost);
-void fc_get_host_port_state(struct Scsi_Host *shost);
-void fc_set_rport_loss_tmo(struct fc_rport *rport, u32 timeout);
+void fc_get_host_speed(struct Scsi_Host *);
+void fc_get_host_port_type(struct Scsi_Host *);
+void fc_get_host_port_state(struct Scsi_Host *);
+void fc_set_rport_loss_tmo(struct fc_rport *, u32 timeout);
 struct fc_host_statistics *fc_get_host_stats(struct Scsi_Host *);
 
 #endif /* _LIBFC_H_ */

commit a51ab39606042e76a483547620699530caa12c40
Author: Steve Ma <steve.ma@intel.com>
Date:   Tue Nov 3 11:47:34 2009 -0800

    [SCSI] libfc, fcoe: Add FC passthrough support
    
    This is the Open-FCoE implementation of the FC
    passthrough support via bsg interface.
    
    Passthrough support is added to both N_Ports and
    VN_Ports.
    
    Signed-off-by: Steve Ma <steve.ma@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 8258edfa328c..54df9fe00c14 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -26,6 +26,7 @@
 
 #include <scsi/scsi_transport.h>
 #include <scsi/scsi_transport_fc.h>
+#include <scsi/scsi_bsg_fc.h>
 
 #include <scsi/fc/fc_fcp.h>
 #include <scsi/fc/fc_ns.h>
@@ -830,6 +831,12 @@ struct fc_lport *fc_vport_id_lookup(struct fc_lport *n_port, u32 port_id);
 void fc_vport_setlink(struct fc_lport *vn_port);
 void fc_vports_linkchange(struct fc_lport *n_port);
 
+/*
+ * Issue fc pass-thru request via bsg interface
+ */
+int fc_lport_bsg_request(struct fc_bsg_job *job);
+
+
 /*
  * REMOTE PORT LAYER
  *****************************/

commit c9866a548024c33e30f35a14bbcb71ba78266383
Author: Chris Leech <christopher.leech@intel.com>
Date:   Tue Nov 3 11:47:01 2009 -0800

    [SCSI] libfc: Register Symbolic Port Name (RSPN_ID)
    
    Register the fc_host symbolic name as the symbolic port name
    with the fabric name server.
    
    Signed-off-by: Chris Leech <christopher.leech@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 1a632069c402..8258edfa328c 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -63,6 +63,7 @@ enum fc_lport_state {
 	LPORT_ST_DNS,
 	LPORT_ST_RNN_ID,
 	LPORT_ST_RSNN_NN,
+	LPORT_ST_RSPN_ID,
 	LPORT_ST_RFT_ID,
 	LPORT_ST_SCR,
 	LPORT_ST_READY,

commit 5baa17c3e66fc2e414f501b2dd59b962dfc64919
Author: Chris Leech <christopher.leech@intel.com>
Date:   Tue Nov 3 11:46:56 2009 -0800

    [SCSI] libfc: Register Symbolic Node Name (RSNN_NN)
    
    Register the fc_host symbolic name as the symbolic node name
    with the fabric name server.
    
    Signed-off-by: Chris Leech <christopher.leech@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 3d22dfd67209..1a632069c402 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -62,6 +62,7 @@ enum fc_lport_state {
 	LPORT_ST_FLOGI,
 	LPORT_ST_DNS,
 	LPORT_ST_RNN_ID,
+	LPORT_ST_RSNN_NN,
 	LPORT_ST_RFT_ID,
 	LPORT_ST_SCR,
 	LPORT_ST_READY,

commit c9c7bd7a5e7321aa96289c9b48fdbcc828c105e6
Author: Chris Leech <christopher.leech@intel.com>
Date:   Tue Nov 3 11:46:51 2009 -0800

    [SCSI] libfc: RNN_ID may be required before RSNN_NN with some switches
    
    One could interpret FC-GS-5 to say that an explicit RNN_ID is required
    before RSNN_NN is allowed to succeed, which is why RNN_ID was not obsoleted
    along with RPN_ID acording to this document:
    ftp://ftp.t11.org/t11/member/fc/gs-5/05-546v2.pdf
    
    Signed-off-by: Chris Leech <christopher.leech@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 75be713ea036..3d22dfd67209 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -61,6 +61,7 @@ enum fc_lport_state {
 	LPORT_ST_DISABLED = 0,
 	LPORT_ST_FLOGI,
 	LPORT_ST_DNS,
+	LPORT_ST_RNN_ID,
 	LPORT_ST_RFT_ID,
 	LPORT_ST_SCR,
 	LPORT_ST_READY,

commit 28cc0e31d874af05244da421e05565f2ba72fd5c
Author: Chris Leech <christopher.leech@intel.com>
Date:   Tue Nov 3 11:46:46 2009 -0800

    [SCSI] libfc: RPN_ID is obsolete and unnecessary
    
    RPN_ID has been obsolete per FC-GS-5 for several years.  The port name is
    registered implicitly as part of FLOGI, and it is undesirable for ports to
    change a registered port name using RPN_ID while logged into the fabric.
    
    Signed-off-by: Chris Leech <christopher.leech@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index dad66ce8673d..75be713ea036 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -61,7 +61,6 @@ enum fc_lport_state {
 	LPORT_ST_DISABLED = 0,
 	LPORT_ST_FLOGI,
 	LPORT_ST_DNS,
-	LPORT_ST_RPN_ID,
 	LPORT_ST_RFT_ID,
 	LPORT_ST_SCR,
 	LPORT_ST_READY,

commit 11b561886643d4e23d0fd58c205d830a448dd0a2
Author: Chris Leech <christopher.leech@intel.com>
Date:   Tue Nov 3 11:46:29 2009 -0800

    [SCSI] libfcoe, fcoe: libfcoe NPIV support
    
    The FIP code in libfcoe needed several changes to support NPIV
    
    1) dst_src_addr needs to be managed per-n_port-ID for FPMA fabrics with NPIV
       enabled.  Managing the MAC address is now handled in fcoe, with some slight
       changes to update_mac() and a new get_src_addr() function pointer.
    
    2) The libfc elsct_send() hook is used to setup FCoE specific response
       handlers for FIP encapsulated ELS exchanges.  This lets the FCoE specific
       handling know which VN_Port the exchange is for, and doesn't require
       tracking OX_IDs.  It might be possible to roll back to the full FIP frame
       in these, but for now I've just stashed the contents of the MAC address
       descriptor in the skb context block for later use.  Also, because
       fcoe_elsct_send() just passes control on to fc_elsct_send(), all transmits
       still come through the normal frame_send() path.
    
    3) The NPIV changes added a mutex hold in the keep alive sending, the lport
       mutex is protecting the vport list.  We can't take a mutex from a timer,
       so move the FIP keep alive logic to the link work struct.
    
    Signed-off-by: Chris Leech <christopher.leech@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index dfeb1ee4f03f..dad66ce8673d 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -900,6 +900,16 @@ void fc_fcp_destroy(struct fc_lport *);
  * Initializes ELS/CT interface
  */
 int fc_elsct_init(struct fc_lport *lp);
+struct fc_seq *fc_elsct_send(struct fc_lport *lport,
+				    u32 did,
+				    struct fc_frame *fp,
+				    unsigned int op,
+				    void (*resp)(struct fc_seq *,
+						 struct fc_frame *fp,
+						 void *arg),
+				    void *arg, u32 timer_msec);
+void fc_lport_flogi_resp(struct fc_seq *, struct fc_frame *, void *);
+void fc_lport_logo_resp(struct fc_seq *, struct fc_frame *, void *);
 
 
 /*

commit 8faecddb212d502b1b77936498b9a82b13c4ff44
Author: Chris Leech <christopher.leech@intel.com>
Date:   Tue Nov 3 11:46:19 2009 -0800

    [SCSI] libfc: vport link handling and fc_vport state managment
    
    NPIV vports are managed in libfc by changing their virtual link state
    when the parent N_Ports internal state changes.  The vport link is only
    online when the N_Port is in a ready state (logged into the fabric).
    
    vport_state is updated as needed in this patch as well, currently the states
    LINKDOWN, INITIALIZING, ACTIVE, DSIABLED, and NO_FABRIC_SUPP are used.
    
    This also changes the fc_host port_state handling to differentiate between
    LINKDOWN and OFFLINE.
    
    Signed-off-by: Chris Leech <christopher.leech@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 2c6d55de8ccd..dfeb1ee4f03f 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -788,11 +788,13 @@ int fc_fabric_login(struct fc_lport *lp);
 /*
  * The link is up for the given local port.
  */
+void __fc_linkup(struct fc_lport *);
 void fc_linkup(struct fc_lport *);
 
 /*
  * Link is down for the given local port.
  */
+void __fc_linkdown(struct fc_lport *);
 void fc_linkdown(struct fc_lport *);
 
 /*
@@ -820,6 +822,12 @@ struct fc_lport *libfc_vport_create(struct fc_vport *vport, int privsize);
  */
 struct fc_lport *fc_vport_id_lookup(struct fc_lport *n_port, u32 port_id);
 
+/*
+ * NPIV VN_Port link state management
+ */
+void fc_vport_setlink(struct fc_lport *vn_port);
+void fc_vports_linkchange(struct fc_lport *n_port);
+
 /*
  * REMOTE PORT LAYER
  *****************************/

commit 174e1ebffd30a7599b889900089f7acef944cc6b
Author: Chris Leech <christopher.leech@intel.com>
Date:   Tue Nov 3 11:46:14 2009 -0800

    [SCSI] libfc: add some generic NPIV support routines to libfc
    
    Adds a function to create a new VN_Port instances, which share the EM
    list with the N_Port, VN_Port lookup by fabric ID when responding to a new
    request (otherwise the exchange lookup from the N_Ports EM list is trusted to
    return an exchange with a cached lport value for the correct VN_Port),
    a pointer to a fc_vport structure for VN_Ports, and flags to indicate if an
    N_Port supports NPIV and if the switch/fabric allows it.
    
    Signed-off-by: Chris Leech <christopher.leech@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index ed3057b4e78d..2c6d55de8ccd 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -640,6 +640,8 @@ struct fc_lport {
 	/* Associations */
 	struct Scsi_Host	*host;
 	struct list_head	ema_list;
+	struct list_head	vports;		/* child vports if N_Port */
+	struct fc_vport		*vport;		/* parent vport if VN_Port */
 	struct fc_rport_priv	*dns_rp;
 	struct fc_rport_priv	*ptp_rp;
 	void			*scsi_priv;
@@ -664,6 +666,8 @@ struct fc_lport {
 	u32			seq_offload:1;	/* seq offload supported */
 	u32			crc_offload:1;	/* crc offload supported */
 	u32			lro_enabled:1;	/* large receive offload */
+	u32			does_npiv:1;	/* supports multiple vports */
+	u32			npiv_enabled:1;	/* switch/fabric allows NPIV */
 	u32			mfs;	        /* max FC payload size */
 	unsigned int		service_params;
 	unsigned int		e_d_tov;
@@ -753,6 +757,7 @@ libfc_host_alloc(struct scsi_host_template *sht, int priv_size)
 	lport = shost_priv(shost);
 	lport->host = shost;
 	INIT_LIST_HEAD(&lport->ema_list);
+	INIT_LIST_HEAD(&lport->vports);
 	return lport;
 }
 
@@ -805,6 +810,15 @@ int fc_lport_reset(struct fc_lport *);
  */
 int fc_set_mfs(struct fc_lport *lp, u32 mfs);
 
+/*
+ * Allocate a new lport struct for an NPIV VN_Port
+ */
+struct fc_lport *libfc_vport_create(struct fc_vport *vport, int privsize);
+
+/*
+ * Find an NPIV VN_Port by port ID
+ */
+struct fc_lport *fc_vport_id_lookup(struct fc_lport *n_port, u32 port_id);
 
 /*
  * REMOTE PORT LAYER
@@ -911,6 +925,12 @@ struct fc_exch_mgr_anchor *fc_exch_mgr_add(struct fc_lport *lport,
  */
 void fc_exch_mgr_del(struct fc_exch_mgr_anchor *ema);
 
+/*
+ * Clone an exchange manager list, getting reference holds for each EM.
+ * This is for use with NPIV and sharing the X_ID space between VN_Ports.
+ */
+int fc_exch_mgr_list_clone(struct fc_lport *src, struct fc_lport *dst);
+
 /*
  * Allocates an Exchange Manager (EM).
  *

commit 86221969e20a2f60ce104160dc836a964974673b
Author: Chris Leech <christopher.leech@intel.com>
Date:   Tue Nov 3 11:46:08 2009 -0800

    [SCSI] libfc: changes to libfc_host_alloc to consolidate initialization with allocation
    
    I'd like to keep basic initialization together with allocation, which means
    this can't just be a tail-call to scsi_host_alloc.
    
    This is needed to create a generic libfc host allocation routine for NPIV
    VN_Ports, which will share the exchange ID space (through sharing exchange
    manager structures) with the parent lport.  In order to clone the exchange
    manager list when the lport is allocated, the list head must be initialized
    earlier.
    
    Also, update fnic to use the libfc_host_alloc so that later changes do not break
    it. (contribution by Joe Eykholt)
    
    Signed-off-by: Chris Leech <christopher.leech@intel.com>
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 690f8296e633..ed3057b4e78d 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -739,12 +739,21 @@ static inline void *lport_priv(const struct fc_lport *lp)
  * @sht: ptr to the scsi host templ
  * @priv_size: size of private data after fc_lport
  *
- * Returns: ptr to Scsi_Host
+ * Returns: libfc lport
  */
-static inline struct Scsi_Host *
+static inline struct fc_lport *
 libfc_host_alloc(struct scsi_host_template *sht, int priv_size)
 {
-	return scsi_host_alloc(sht, sizeof(struct fc_lport) + priv_size);
+	struct fc_lport *lport;
+	struct Scsi_Host *shost;
+
+	shost = scsi_host_alloc(sht, sizeof(*lport) + priv_size);
+	if (!shost)
+		return NULL;
+	lport = shost_priv(shost);
+	lport->host = shost;
+	INIT_LIST_HEAD(&lport->ema_list);
+	return lport;
 }
 
 /*

commit 8866a5d9075b7129194576f5f810e85a693c40ba
Author: Robert Love <robert.w.love@intel.com>
Date:   Tue Nov 3 11:45:58 2009 -0800

    [SCSI] libfc: Add libfc/fc_libfc.[ch] for libfc internal routines
    
    include/scsi/libfc.h is currently loaded with common code
    shared between libfc's sub-modules as well as shared between
    libfc and fcoe. Previous patches attempted to move out
    non-common code. This patch creates two files for common
    libfc routines that will not be shared with fcoe, fnic or
    any other LLDs.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index db2175da2da5..690f8296e633 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -34,67 +34,6 @@
 
 #include <scsi/fc_frame.h>
 
-#define FC_LIBFC_LOGGING 0x01 /* General logging, not categorized */
-#define FC_LPORT_LOGGING 0x02 /* lport layer logging */
-#define FC_DISC_LOGGING  0x04 /* discovery layer logging */
-#define FC_RPORT_LOGGING 0x08 /* rport layer logging */
-#define FC_FCP_LOGGING   0x10 /* I/O path logging */
-#define FC_EM_LOGGING    0x20 /* Exchange Manager logging */
-#define FC_EXCH_LOGGING  0x40 /* Exchange/Sequence logging */
-#define FC_SCSI_LOGGING  0x80 /* SCSI logging (mostly error handling) */
-
-extern unsigned int fc_debug_logging;
-
-#define FC_CHECK_LOGGING(LEVEL, CMD)				\
-do {								\
-	if (unlikely(fc_debug_logging & LEVEL))			\
-		do {						\
-			CMD;					\
-		} while (0);					\
-} while (0)
-
-#define FC_LIBFC_DBG(fmt, args...)					\
-	FC_CHECK_LOGGING(FC_LIBFC_LOGGING,				\
-			 printk(KERN_INFO "libfc: " fmt, ##args))
-
-#define FC_LPORT_DBG(lport, fmt, args...)				\
-	FC_CHECK_LOGGING(FC_LPORT_LOGGING,				\
-			 printk(KERN_INFO "host%u: lport %6x: " fmt,	\
-				(lport)->host->host_no,			\
-				fc_host_port_id((lport)->host), ##args))
-
-#define FC_DISC_DBG(disc, fmt, args...)					\
-	FC_CHECK_LOGGING(FC_DISC_LOGGING,				\
-			 printk(KERN_INFO "host%u: disc: " fmt,		\
-				(disc)->lport->host->host_no,		\
-				##args))
-
-#define FC_RPORT_ID_DBG(lport, port_id, fmt, args...)			\
-	FC_CHECK_LOGGING(FC_RPORT_LOGGING,				\
-			 printk(KERN_INFO "host%u: rport %6x: " fmt,	\
-				(lport)->host->host_no,			\
-				(port_id), ##args))
-
-#define FC_RPORT_DBG(rdata, fmt, args...)				\
-	FC_RPORT_ID_DBG((rdata)->local_port, (rdata)->ids.port_id, fmt, ##args)
-
-#define FC_FCP_DBG(pkt, fmt, args...)					\
-	FC_CHECK_LOGGING(FC_FCP_LOGGING,				\
-			 printk(KERN_INFO "host%u: fcp: %6x: " fmt,	\
-				(pkt)->lp->host->host_no,		\
-				pkt->rport->port_id, ##args))
-
-#define FC_EXCH_DBG(exch, fmt, args...)					\
-	FC_CHECK_LOGGING(FC_EXCH_LOGGING,				\
-			 printk(KERN_INFO "host%u: xid %4x: " fmt,	\
-				(exch)->lp->host->host_no,		\
-				exch->xid, ##args))
-
-#define FC_SCSI_DBG(lport, fmt, args...)				\
-	FC_CHECK_LOGGING(FC_SCSI_LOGGING,                               \
-			 printk(KERN_INFO "host%u: scsi: " fmt,		\
-				(lport)->host->host_no,	##args))
-
 /*
  * libfc error codes
  */
@@ -923,11 +862,6 @@ int fc_change_queue_type(struct scsi_device *sdev, int tag_type);
  */
 void fc_fcp_destroy(struct fc_lport *);
 
-/*
- * Set up direct-data placement for this I/O request
- */
-void fc_fcp_ddp_setup(struct fc_fcp_pkt *fsp, u16 xid);
-
 /*
  * ELS/CT interface
  *****************************/
@@ -1020,17 +954,4 @@ void fc_get_host_port_state(struct Scsi_Host *shost);
 void fc_set_rport_loss_tmo(struct fc_rport *rport, u32 timeout);
 struct fc_host_statistics *fc_get_host_stats(struct Scsi_Host *);
 
-/*
- * module setup functions.
- */
-int fc_setup_exch_mgr(void);
-void fc_destroy_exch_mgr(void);
-int fc_setup_rport(void);
-void fc_destroy_rport(void);
-
-/*
- * Internal libfc functions.
- */
-const char *fc_els_resp_type(struct fc_frame *);
-
 #endif /* _LIBFC_H_ */

commit 255f6386b816b2bc0c251af0ee4985ad5a8461b7
Author: Robert Love <robert.w.love@intel.com>
Date:   Tue Nov 3 11:45:52 2009 -0800

    [SCSI] libfc: Remove fc_fcp_complete
    
    This function is never used, let's remove it.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index f207b6cac06f..db2175da2da5 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -887,14 +887,6 @@ int fc_fcp_init(struct fc_lport *);
 int fc_queuecommand(struct scsi_cmnd *sc_cmd,
 		    void (*done)(struct scsi_cmnd *));
 
-/*
- * complete processing of a fcp packet
- *
- * This function may sleep if a fsp timer is pending.
- * The host lock must not be held by caller.
- */
-void fc_fcp_complete(struct fc_fcp_pkt *fsp);
-
 /*
  * Send an ABTS frame to the target device. The sc_cmd argument
  * is a pointer to the SCSI command to be aborted.

commit 1a7b75ae719754c77ccd4d18b0d258ae5db38a25
Author: Robert Love <robert.w.love@intel.com>
Date:   Tue Nov 3 11:45:47 2009 -0800

    [SCSI] libfc: Move non-common routines and prototypes out of libfc.h
    
    This patch moves all non-common routines and function prototypes
    out of libfc.h and into the appropriate .c files. It makes these
    routines 'static' when necessary and removes any unnecessary EXPORT_SYMBOL
    statements.
    
    A result of moving the fc_exch_seq_send, fc_seq_els_rsp_send, fc_exch_alloc
    and fc_seq_start_next prototypes out of libfc.h is that they were no longer
    being imported into fc_exch.c when libfc.h was included. This caused errors
    where routines in fc_exch.c were looking for undefined symbols. To fix this
    this patch reorganizes fc_seq_alloc, fc_seq_start_next and
    fc_seq_start_next_locked. This move also made it so that
    fc_seq_start_next_locked did not need to be prototyped at the top of
    fc_exch.c.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 9617f9365e45..f207b6cac06f 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -1011,55 +1011,6 @@ void fc_exch_mgr_free(struct fc_lport *lport);
  */
 void fc_exch_recv(struct fc_lport *lp, struct fc_frame *fp);
 
-/*
- * This function is for exch_seq_send function pointer in
- * struct libfc_function_template, see comment block on
- * exch_seq_send for description of this function.
- */
-struct fc_seq *fc_exch_seq_send(struct fc_lport *lp,
-				struct fc_frame *fp,
-				void (*resp)(struct fc_seq *sp,
-					     struct fc_frame *fp,
-					     void *arg),
-				void (*destructor)(struct fc_seq *sp,
-						   void *arg),
-				void *arg, u32 timer_msec);
-
-/*
- * send a frame using existing sequence and exchange.
- */
-int fc_seq_send(struct fc_lport *lp, struct fc_seq *sp, struct fc_frame *fp);
-
-/*
- * Send ELS response using mainly infomation
- * in exchange and sequence in EM layer.
- */
-void fc_seq_els_rsp_send(struct fc_seq *sp, enum fc_els_cmd els_cmd,
-			 struct fc_seq_els_data *els_data);
-
-/*
- * This function is for seq_exch_abort function pointer in
- * struct libfc_function_template, see comment block on
- * seq_exch_abort for description of this function.
- */
-int fc_seq_exch_abort(const struct fc_seq *req_sp, unsigned int timer_msec);
-
-/*
- * Indicate that an exchange/sequence tuple is complete and the memory
- * allocated for the related objects may be freed.
- */
-void fc_exch_done(struct fc_seq *sp);
-
-/*
- * Allocate a new exchange and sequence pair.
- */
-struct fc_exch *fc_exch_alloc(struct fc_lport *lport, struct fc_frame *fp);
-/*
- * Start a new sequence on the same exchange as the supplied sequence.
- */
-struct fc_seq *fc_seq_start_next(struct fc_seq *sp);
-
-
 /*
  * Reset all EMs of a lport, releasing its all sequences and
  * exchanges. If sid is non-zero, then reset only exchanges

commit e881a172dac4d9ea3b2a1540041d872963c269bd
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Oct 15 17:46:39 2009 -0700

    [SCSI] modify change_queue_depth to take in reason why it is being called
    
    This patch modifies scsi_host_template->change_queue_depth so that
    it takes an argument indicating why it is being called. This will be
    used so that if a LLD needs to do some extra processing when
    handling queue fulls or later ramp ups, it can do so.
    
    This is a simple port of the drivers setting a change_queue_depth
    callback. In the patch I just have these LLDs adjust the queue depth
    if the user was requesting it.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    
    [Vasu.Dev: v2
            Also converted pmcraid_change_queue_depth and then verified
    all modules compile  using "make allmodconfig" for any new build
    warnings on X86_64.
    
            Updated original description after combing two original
    patches from Mike to make this patch git bisectable.]
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    [jejb: fixed up 53c700]
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 1662d73d85a7..9617f9365e45 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -919,7 +919,7 @@ int fc_slave_alloc(struct scsi_device *sdev);
 /*
  * Adjust the queue depth.
  */
-int fc_change_queue_depth(struct scsi_device *sdev, int qdepth);
+int fc_change_queue_depth(struct scsi_device *sdev, int qdepth, int reason);
 
 /*
  * Change the tag type.

commit b4a9c7ede96e90f7b1ec009ce7256059295e76df
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Wed Oct 21 16:28:30 2009 -0700

    [SCSI] libfc: fix free of fc_rport_priv with timer pending
    
    Timer crashes were caused by freeing a struct fc_rport_priv
    with a timer pending, causing the timer facility list to be
    corrupted.  This was during FC uplink flap tests with a lot
    of targets.
    
    After discovery, we were doing an PLOGI on an rdata that was
    in DELETE state but not yet removed from the lookup list.
    This moved the rdata from DELETE state to PLOGI state.
    If the PLOGI exchange allocation failed and needed to be
    retried, the timer scheduling could race with the free
    being done by fc_rport_work().
    
    When fc_rport_login() is called on a rport in DELETE state,
    move it to a new state RESTART.  In fc_rport_work, when
    handling a LOGO, STOPPED or FAILED event, look for restart
    state.  In the RESTART case, don't take the rdata off the
    list and after the transport remote port is deleted and
    exchanges are reset, re-login to the remote port.
    
    Note that the new RESTART state also corrects a problem we
    had when re-discovering a port that had moved to DELETE state.
    In that case, a new rdata was created, but the old rdata
    would do an exchange manager reset affecting the FC_ID
    for both the new rdata and old rdata.  With the new state,
    the new port isn't logged into until after any old exchanges
    are reset.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 4ff148580562..1662d73d85a7 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -145,6 +145,7 @@ enum fc_rport_state {
 	RPORT_ST_LOGO,		/* port logout sent */
 	RPORT_ST_ADISC,		/* Discover Address sent */
 	RPORT_ST_DELETE,	/* port being deleted */
+	RPORT_ST_RESTART,       /* remote port being deleted and will restart */
 };
 
 /**

commit e95147d8fa4e63bf6d8ff249f074d0047338fc61
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Wed Oct 21 16:27:39 2009 -0700

    [SCSI] libfc: removes unused disc_work and ex_list
    
    Reported-by: Alex Lyakas <alexl@mellanox.co.il>
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 65dc9aacbf70..4ff148580562 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -742,7 +742,6 @@ struct fc_lport {
 
 	/* Miscellaneous */
 	struct delayed_work	retry_work;
-	struct delayed_work	disc_work;
 };
 
 /*

commit 370c3bd05cf02afabea9cd3f2de66202d6b516dc
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Aug 25 14:03:47 2009 -0700

    [SCSI] libfc: use ADISC to verify rport login state
    
    When rport_login is called on an rport that is already thought
    to be logged in, use ADISC.  If that fails, redo PLOGI.
    This is less disruptive after fabric changes that don't affect
    the state of the target.
    
    Implement the sending of ADISC via fc_els_fill.
    
    Add ADISC state to the rport state machine.  This is entered from READY
    and returns to READY after successful completion.  If it fails, the rport
    is either logged off and deleted or re-does PLOGI.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index e18e5ce5af51..65dc9aacbf70 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -143,6 +143,7 @@ enum fc_rport_state {
 	RPORT_ST_RTV,		/* waiting for RTV completion */
 	RPORT_ST_READY,		/* ready for use */
 	RPORT_ST_LOGO,		/* port logout sent */
+	RPORT_ST_ADISC,		/* Discover Address sent */
 	RPORT_ST_DELETE,	/* port being deleted */
 };
 

commit f657d299cf05883e23e12a69e86842da1df378ad
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Aug 25 14:03:21 2009 -0700

    [SCSI] libfc: improve debug messages for ELS response handlers
    
    Improve lport and rport debug messages to indicate whether
    the response is LS_ACC, LS_RJT, closed, or timeout.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 265f106d9fd6..e18e5ce5af51 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -1084,4 +1084,9 @@ void fc_destroy_exch_mgr(void);
 int fc_setup_rport(void);
 void fc_destroy_rport(void);
 
+/*
+ * Internal libfc functions.
+ */
+const char *fc_els_resp_type(struct fc_frame *);
+
 #endif /* _LIBFC_H_ */

commit 131203a1ef53f3a4deb3260031bc53c7e4db4a24
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Aug 25 14:03:10 2009 -0700

    [SCSI] libfc: move remote port lookup for ELS requests into fc_rport.c.
    
    This moves the remote port lookup for incoming ELS requests into
    fc_rport.c, in preparation for handing PLOGI and LOGO from
    unknown rports.
    
    This changes the arg to rport_recv_req from an rdata to an lport.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index cd410c123b99..265f106d9fd6 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -598,7 +598,7 @@ struct libfc_function_template {
 	 * STATUS: OPTIONAL
 	 */
 	void (*rport_recv_req)(struct fc_seq *, struct fc_frame *,
-			       struct fc_rport_priv *);
+			       struct fc_lport *);
 
 	/*
 	 * lookup an rport by it's port ID.

commit 9737e6a7b5b8af48f983cd565df93493597c565b
Author: Robert Love <robert.w.love@intel.com>
Date:   Tue Aug 25 14:02:59 2009 -0700

    [SCSI] libfc: Initialize fc_rport_identifiers inside fc_rport_create
    
    Currently these values are initialized by the callers. This was exposed
    by a later patch that adds PLOGI request support. The patch failed to
    initialize the new remote port's roles and it caused problems. This patch
    has the rport_create routine initialize the identifiers and then the
    callers can override them with real values.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 517dce5c8d0d..cd410c123b99 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -148,16 +148,16 @@ enum fc_rport_state {
 
 /**
  * struct fc_disc_port - temporary discovery port to hold rport identifiers
- * @lp: Fibre Channel host port instance
- * @peers: node for list management during discovery and RSCN processing
- * @ids: identifiers structure to pass to fc_remote_port_add()
- * @rport_work: work struct for starting the rport state machine
+ * @lp:         Fibre Channel host port instance
+ * @peers:      Node for list management during discovery and RSCN processing
+ * @rport_work: Work struct for starting the rport state machine
+ * @port_id:    Port ID of the discovered port
  */
 struct fc_disc_port {
 	struct fc_lport             *lp;
 	struct list_head            peers;
-	struct fc_rport_identifiers ids;
 	struct work_struct	    rport_work;
+	u32                         port_id;
 };
 
 enum fc_rport_event {
@@ -565,10 +565,11 @@ struct libfc_function_template {
 	int (*lport_reset)(struct fc_lport *);
 
 	/*
-	 * Create a remote port
+	 * Create a remote port with a given port ID
+	 *
+	 * STATUS: OPTIONAL
 	 */
-	struct fc_rport_priv *(*rport_create)(struct fc_lport *,
-					      struct fc_rport_identifiers *);
+	struct fc_rport_priv *(*rport_create)(struct fc_lport *, u32);
 
 	/*
 	 * Initiates the RP state machine. It is called from the LP module.

commit 0f6c6149870e03c722af6eae406758b28cb71320
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Aug 25 14:02:11 2009 -0700

    [SCSI] libfc: do not log off rports before or after discovery
    
    When receiving an RSCN, do not log off all rports.  This is
    extremely disruptive.  If, after the GPN_FT response, some
    rports haven't been listed, delete them.
    
    Add field disc_id to structs fc_rport_priv and fc_disc.
    disc_id is an arbitrary serial number used to identify the
    rports found by the latest discovery.  This eliminates the need
    to go through the rport list when restarting discovery.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 093b0439a2cf..517dce5c8d0d 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -202,6 +202,7 @@ struct fc_rport_libfc_priv {
  * @ids: remote port identifiers and roles
  * @flags: REC and RETRY supported flags
  * @max_seq: maximum number of concurrent sequences
+ * @disc_id: discovery identifier
  * @maxframe_size: maximum frame size
  * @retries: retry count in current state
  * @e_d_tov: error detect timeout value (in msec)
@@ -218,6 +219,7 @@ struct fc_rport_priv {
 	struct fc_rport_identifiers ids;
 	u16			   flags;
 	u16		           max_seq;
+	u16			   disc_id;
 	u16			   maxframe_size;
 	unsigned int	           retries;
 	unsigned int	           e_d_tov;
@@ -678,6 +680,7 @@ struct fc_disc {
 	unsigned char		requested;
 	unsigned short		seq_count;
 	unsigned char		buf_len;
+	u16			disc_id;
 
 	void (*disc_callback)(struct fc_lport *,
 			      enum fc_disc_event);

commit b84c7962653e4d04065d2603f0e1424ee0f455ae
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Aug 25 14:01:34 2009 -0700

    [SCSI] libfc: remove unused disc->delay element
    
    Delete unused disc->delay element.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index f3f320f1d399..093b0439a2cf 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -674,7 +674,6 @@ struct libfc_function_template {
 /* information used by the discovery layer */
 struct fc_disc {
 	unsigned char		retry_count;
-	unsigned char		delay;
 	unsigned char		pending;
 	unsigned char		requested;
 	unsigned short		seq_count;

commit 786681b96fc1a5b94d187160b7bf80bf6b4681ed
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Aug 25 14:01:29 2009 -0700

    [SCSI] libfc: eliminate disc->event
    
    There was no need to have the discovery status stored in struct fc_disc.
    
    Change fc_disc_done() to take the discovery status as an argument
    and just pass it on to the discovery callback.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index bf4b1c2ec600..f3f320f1d399 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -679,7 +679,6 @@ struct fc_disc {
 	unsigned char		requested;
 	unsigned short		seq_count;
 	unsigned char		buf_len;
-	enum fc_disc_event	event;
 
 	void (*disc_callback)(struct fc_lport *,
 			      enum fc_disc_event);

commit 9e9d0452fe12115b1c1883c0d4d2ee509079791b
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Aug 25 14:01:18 2009 -0700

    [SCSI] libfc: don't create dummy (rogue) remote ports
    
    Don't create a "dummy" remote port to go with fc_rport_priv.
    
    Make the rport truly optional by allocating fc_rport_priv separately
    and not requiring a dummy rport to be there if we haven't yet done
    fc_remote_port_add().
    
    The fc_rport_libfc_priv remains as a structure attached to the
    rport for I/O purposes.
    
    Be sure to hold references on rdata when the lock is dropped in
    fc_rport_work().
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index d324df8c36e6..bf4b1c2ec600 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -146,11 +146,6 @@ enum fc_rport_state {
 	RPORT_ST_DELETE,	/* port being deleted */
 };
 
-enum fc_rport_trans_state {
-	FC_PORTSTATE_ROGUE,
-	FC_PORTSTATE_REAL,
-};
-
 /**
  * struct fc_disc_port - temporary discovery port to hold rport identifiers
  * @lp: Fibre Channel host port instance
@@ -173,14 +168,6 @@ enum fc_rport_event {
 	RPORT_EV_LOGO
 };
 
-/*
- * Temporary definition to prepare for split off from fc_rport_libfc_priv
- * of a separately-allocated structure called fc_rport_priv.  This will
- * be the primary object for the discovery and rport state machines.
- * This definition is just to make this patch series easier to review.
- */
-#define fc_rport_priv fc_rport_libfc_priv
-
 struct fc_rport_priv;
 
 struct fc_rport_operations {
@@ -191,6 +178,24 @@ struct fc_rport_operations {
 /**
  * struct fc_rport_libfc_priv - libfc internal information about a remote port
  * @local_port: Fibre Channel host port instance
+ * @rp_state: indicates READY for I/O or DELETE when blocked.
+ * @flags: REC and RETRY supported flags
+ * @e_d_tov: error detect timeout value (in msec)
+ * @r_a_tov: resource allocation timeout value (in msec)
+ */
+struct fc_rport_libfc_priv {
+	struct fc_lport		   *local_port;
+	enum fc_rport_state        rp_state;
+	u16			   flags;
+	#define FC_RP_FLAGS_REC_SUPPORTED	(1 << 0)
+	#define FC_RP_FLAGS_RETRY		(1 << 1)
+	unsigned int	           e_d_tov;
+	unsigned int	           r_a_tov;
+};
+
+/**
+ * struct fc_rport_priv - libfc rport and discovery info about a remote port
+ * @local_port: Fibre Channel host port instance
  * @rport: transport remote port
  * @kref: reference counter
  * @rp_state: state tracks progress of PLOGI, PRLI, and RTV exchanges
@@ -205,21 +210,18 @@ struct fc_rport_operations {
  * @retry_work:
  * @event_callback: Callback for rport READY, FAILED or LOGO
  */
-struct fc_rport_libfc_priv {
+struct fc_rport_priv {
 	struct fc_lport		   *local_port;
 	struct fc_rport		   *rport;
 	struct kref		   kref;
 	enum fc_rport_state        rp_state;
 	struct fc_rport_identifiers ids;
 	u16			   flags;
-	#define FC_RP_FLAGS_REC_SUPPORTED	(1 << 0)
-	#define FC_RP_FLAGS_RETRY		(1 << 1)
 	u16		           max_seq;
 	u16			   maxframe_size;
 	unsigned int	           retries;
 	unsigned int	           e_d_tov;
 	unsigned int	           r_a_tov;
-	enum fc_rport_trans_state  trans_state;
 	struct mutex               rp_mutex;
 	struct delayed_work	   retry_work;
 	enum fc_rport_event        event;
@@ -229,9 +231,6 @@ struct fc_rport_libfc_priv {
 	u32			   supported_classes;
 };
 
-#define RPORT_TO_PRIV(x)						\
-	((struct fc_rport_libfc_priv *)((void *)(x) + sizeof(struct fc_rport)))
-
 /*
  * fcoe stats structure
  */
@@ -686,7 +685,6 @@ struct fc_disc {
 			      enum fc_disc_event);
 
 	struct list_head	 rports;
-	struct list_head	 rogue_rports;
 	struct fc_lport		*lport;
 	struct mutex		disc_mutex;
 	struct fc_gpn_ft_resp	partial_buf;	/* partial name buffer */

commit 4c0f62b5679321b2e5572cf541ffb9f7b344d47c
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Aug 25 14:01:12 2009 -0700

    [SCSI] libfc: rename rport event CREATED to READY
    
    Remote ports will become READY more than once after
    ADISC is implemented in a later patch.
    
    The event callback that has been called "CREATED" will mean "READY".
    Rename it now in preparation for those changes.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index a94d216d2207..d324df8c36e6 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -167,7 +167,7 @@ struct fc_disc_port {
 
 enum fc_rport_event {
 	RPORT_EV_NONE = 0,
-	RPORT_EV_CREATED,
+	RPORT_EV_READY,
 	RPORT_EV_FAILED,
 	RPORT_EV_STOP,
 	RPORT_EV_LOGO

commit f211fa514a07326c0f9364c0e6ed17e38860172f
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Aug 25 14:01:01 2009 -0700

    [SCSI] libfc: make rport structure optional
    
    Allow a struct fc_rport_priv to have no fc_rport associated with it.
    This sets up to remove the need for "rogue" rports.
    
    Add a few fields to fc_rport_priv that are needed before the fc_rport
    is created.  These are the ids, maxframe_size, classes, and rport pointer.
    
    Remove the macro PRIV_TO_RPORT().  Just use rdata->rport where appropriate.
    
    To take the place of the get_device()/put_device ops that were used to
    hold both the rport and rdata, add a reference count to rdata structures
    using kref.  When kref_get decrements the refcount to zero, a new template
    function releasing the rdata should be called.  This will take care of
    freeing the rdata and releasing the hold on the rport (for now).  After
    subsequent patches make the rport truly optional, this release function
    will simply free the rdata.
    
    Remove the simple inline function fc_rport_set_name(), which becomes
    semanticly ambiguous otherwise.  The caller will set the port_name and
    node_name in the rdata->Ids, which will later be copied to the rport
    when it its created.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 2473167464c2..a94d216d2207 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -76,11 +76,7 @@ do {								\
 				(port_id), ##args))
 
 #define FC_RPORT_DBG(rdata, fmt, args...)				\
-do {									\
-	struct fc_lport *lport = rdata->local_port;			\
-	struct fc_rport *rport = PRIV_TO_RPORT(rdata);			\
-	FC_RPORT_ID_DBG(lport, rport->port_id, fmt, ##args);		\
-} while (0)
+	FC_RPORT_ID_DBG((rdata)->local_port, (rdata)->ids.port_id, fmt, ##args)
 
 #define FC_FCP_DBG(pkt, fmt, args...)					\
 	FC_CHECK_LOGGING(FC_FCP_LOGGING,				\
@@ -195,9 +191,13 @@ struct fc_rport_operations {
 /**
  * struct fc_rport_libfc_priv - libfc internal information about a remote port
  * @local_port: Fibre Channel host port instance
+ * @rport: transport remote port
+ * @kref: reference counter
  * @rp_state: state tracks progress of PLOGI, PRLI, and RTV exchanges
+ * @ids: remote port identifiers and roles
  * @flags: REC and RETRY supported flags
  * @max_seq: maximum number of concurrent sequences
+ * @maxframe_size: maximum frame size
  * @retries: retry count in current state
  * @e_d_tov: error detect timeout value (in msec)
  * @r_a_tov: resource allocation timeout value (in msec)
@@ -207,11 +207,15 @@ struct fc_rport_operations {
  */
 struct fc_rport_libfc_priv {
 	struct fc_lport		   *local_port;
+	struct fc_rport		   *rport;
+	struct kref		   kref;
 	enum fc_rport_state        rp_state;
+	struct fc_rport_identifiers ids;
 	u16			   flags;
 	#define FC_RP_FLAGS_REC_SUPPORTED	(1 << 0)
 	#define FC_RP_FLAGS_RETRY		(1 << 1)
 	u16		           max_seq;
+	u16			   maxframe_size;
 	unsigned int	           retries;
 	unsigned int	           e_d_tov;
 	unsigned int	           r_a_tov;
@@ -222,19 +226,12 @@ struct fc_rport_libfc_priv {
 	struct fc_rport_operations *ops;
 	struct list_head           peers;
 	struct work_struct         event_work;
+	u32			   supported_classes;
 };
 
-#define PRIV_TO_RPORT(x)						\
-	((struct fc_rport *)((void *)(x) - sizeof(struct fc_rport)))
 #define RPORT_TO_PRIV(x)						\
 	((struct fc_rport_libfc_priv *)((void *)(x) + sizeof(struct fc_rport)))
 
-static inline void fc_rport_set_name(struct fc_rport *rport, u64 wwpn, u64 wwnn)
-{
-	rport->node_name = wwnn;
-	rport->port_name = wwpn;
-}
-
 /*
  * fcoe stats structure
  */
@@ -608,6 +605,12 @@ struct libfc_function_template {
 	 */
 	struct fc_rport_priv *(*rport_lookup)(const struct fc_lport *, u32);
 
+	/*
+	 * Destroy an rport after final kref_put().
+	 * The argument is a pointer to the kref inside the fc_rport_priv.
+	 */
+	void (*rport_destroy)(struct kref *);
+
 	/*
 	 * Send a fcp cmd from fsp pkt.
 	 * Called with the SCSI host lock unlocked and irqs disabled.

commit a46f327aa5caf2cce138e98ddd863b6cca0e71e2
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Aug 25 14:00:55 2009 -0700

    [SCSI] libfc: change elsct to use FC_ID instead of rdata
    
    tt.elsct_send is used by both FCP and by the rport state machine.
    After further patches, these two modules will use different
    structures for the remote port.
    
    So, change elsct_send to use the FC_ID instead of the fc_rport_priv
    as its argument.  It currently only uses the FC_ID anyway.
    
    For CT requests the destination FC_ID is still implicitly 0xfffffc.
    After further patches the did arg on CT requests will be used to
    specify the FC_ID being inquired about for GPN_ID or other queries.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index df57cb762dc2..2473167464c2 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -424,7 +424,7 @@ struct libfc_function_template {
 	 * STATUS: OPTIONAL
 	 */
 	struct fc_seq *(*elsct_send)(struct fc_lport *lport,
-				     struct fc_rport_priv *,
+				     u32 did,
 				     struct fc_frame *fp,
 				     unsigned int op,
 				     void (*resp)(struct fc_seq *,

commit 9fb9d32831fd687e427ec5b147bb690f468b99a0
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Aug 25 14:00:50 2009 -0700

    [SCSI] libfc: make fc_rport_priv the primary rport interface.
    
    The rport and discovery modules deal with remote ports
    before fc_remote_port_add() can be done, because the
    full set of rport identifiers is not known at early stages.
    
    In preparation for splitting the fc_rport/fc_rport_priv allocation,
    make fc_rport_priv the primary interface for the remote port and
    discovery engines.
    
    The FCP / SCSI layers still deal with fc_rport and
    fc_rport_libfc_priv, however.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 2fdd8ac12b89..df57cb762dc2 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -75,10 +75,10 @@ do {								\
 				(lport)->host->host_no,			\
 				(port_id), ##args))
 
-#define FC_RPORT_DBG(rport, fmt, args...)				\
+#define FC_RPORT_DBG(rdata, fmt, args...)				\
 do {									\
-	struct fc_rport_priv *rdata = rport->dd_data;			\
 	struct fc_lport *lport = rdata->local_port;			\
+	struct fc_rport *rport = PRIV_TO_RPORT(rdata);			\
 	FC_RPORT_ID_DBG(lport, rport->port_id, fmt, ##args);		\
 } while (0)
 
@@ -185,8 +185,10 @@ enum fc_rport_event {
  */
 #define fc_rport_priv fc_rport_libfc_priv
 
+struct fc_rport_priv;
+
 struct fc_rport_operations {
-	void (*event_callback)(struct fc_lport *, struct fc_rport *,
+	void (*event_callback)(struct fc_lport *, struct fc_rport_priv *,
 			       enum fc_rport_event);
 };
 
@@ -422,7 +424,7 @@ struct libfc_function_template {
 	 * STATUS: OPTIONAL
 	 */
 	struct fc_seq *(*elsct_send)(struct fc_lport *lport,
-				     struct fc_rport *rport,
+				     struct fc_rport_priv *,
 				     struct fc_frame *fp,
 				     unsigned int op,
 				     void (*resp)(struct fc_seq *,
@@ -567,8 +569,8 @@ struct libfc_function_template {
 	/*
 	 * Create a remote port
 	 */
-	struct fc_rport *(*rport_create)(struct fc_lport *,
-					 struct fc_rport_identifiers *);
+	struct fc_rport_priv *(*rport_create)(struct fc_lport *,
+					      struct fc_rport_identifiers *);
 
 	/*
 	 * Initiates the RP state machine. It is called from the LP module.
@@ -581,7 +583,7 @@ struct libfc_function_template {
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	int (*rport_login)(struct fc_rport *rport);
+	int (*rport_login)(struct fc_rport_priv *);
 
 	/*
 	 * Logoff, and remove the rport from the transport if
@@ -589,7 +591,7 @@ struct libfc_function_template {
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	int (*rport_logoff)(struct fc_rport *rport);
+	int (*rport_logoff)(struct fc_rport_priv *);
 
 	/*
 	 * Recieve a request from a remote port.
@@ -597,14 +599,14 @@ struct libfc_function_template {
 	 * STATUS: OPTIONAL
 	 */
 	void (*rport_recv_req)(struct fc_seq *, struct fc_frame *,
-			       struct fc_rport *);
+			       struct fc_rport_priv *);
 
 	/*
 	 * lookup an rport by it's port ID.
 	 *
 	 * STATUS: OPTIONAL
 	 */
-	struct fc_rport *(*rport_lookup)(const struct fc_lport *, u32);
+	struct fc_rport_priv *(*rport_lookup)(const struct fc_lport *, u32);
 
 	/*
 	 * Send a fcp cmd from fsp pkt.
@@ -694,8 +696,8 @@ struct fc_lport {
 	/* Associations */
 	struct Scsi_Host	*host;
 	struct list_head	ema_list;
-	struct fc_rport		*dns_rp;
-	struct fc_rport		*ptp_rp;
+	struct fc_rport_priv	*dns_rp;
+	struct fc_rport_priv	*ptp_rp;
 	void			*scsi_priv;
 	struct fc_disc          disc;
 

commit 922aa210bcad4b34a7bb98ec9d318b7e59e7a5ca
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Aug 25 14:00:45 2009 -0700

    [SCSI] libfc: fix RPORT_TO_PRIV and PRIV_TO_RPORT() macros.
    
    These macros introduce extra undesirable semicolons that keep
    them from being used in expressions, and they don't protect
    against being passed an expression.
    
    Add parens and remove the semicolons.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index d888cbecd72e..2fdd8ac12b89 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -223,9 +223,9 @@ struct fc_rport_libfc_priv {
 };
 
 #define PRIV_TO_RPORT(x)						\
-	(struct fc_rport *)((void *)x - sizeof(struct fc_rport));
+	((struct fc_rport *)((void *)(x) - sizeof(struct fc_rport)))
 #define RPORT_TO_PRIV(x)						\
-	(struct fc_rport_libfc_priv *)((void *)x + sizeof(struct fc_rport));
+	((struct fc_rport_libfc_priv *)((void *)(x) + sizeof(struct fc_rport)))
 
 static inline void fc_rport_set_name(struct fc_rport *rport, u64 wwpn, u64 wwnn)
 {

commit 795d86f55ec3bf6280dda368f208943f1fb7d366
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Aug 25 14:00:39 2009 -0700

    [SCSI] libfc: change interface for rport_create
    
    The interface for lport->tt.rport_create() takes a fc_disc_port arg,
    which is unnatural for most calls.   The only reason for this was
    to avoid passing in the local port as an argument, but otherwise
    added to complexity.
    
    Simplify by just using lport and fc_rport_identifiers.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index aa219514c96b..d888cbecd72e 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -227,8 +227,6 @@ struct fc_rport_libfc_priv {
 #define RPORT_TO_PRIV(x)						\
 	(struct fc_rport_libfc_priv *)((void *)x + sizeof(struct fc_rport));
 
-struct fc_rport *fc_rport_rogue_create(struct fc_disc_port *);
-
 static inline void fc_rport_set_name(struct fc_rport *rport, u64 wwpn, u64 wwnn)
 {
 	rport->node_name = wwnn;
@@ -569,7 +567,8 @@ struct libfc_function_template {
 	/*
 	 * Create a remote port
 	 */
-	struct fc_rport *(*rport_create)(struct fc_disc_port *);
+	struct fc_rport *(*rport_create)(struct fc_lport *,
+					 struct fc_rport_identifiers *);
 
 	/*
 	 * Initiates the RP state machine. It is called from the LP module.

commit ab28f1fd3b0d14c1bd693e640decd711d5e6642a
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Aug 25 14:00:34 2009 -0700

    [SCSI] libfc: prepare to split off struct fc_rport_priv from fc_rport_libfc_priv
    
    While the I/O and LLD interfaces use fc_rport_libfc_priv, the
    disc and rport interfaces will use fc_rport_priv, which will
    be separately allocated.
    
    Change the disc and rport usage of fc_rport_libfc_priv to fc_rport_priv.
    
    Use #define temporarily to make both names equivalent until a
    subsequent patch splits them.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 53b38814d38a..aa219514c96b 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -77,7 +77,7 @@ do {								\
 
 #define FC_RPORT_DBG(rport, fmt, args...)				\
 do {									\
-	struct fc_rport_libfc_priv *rdata = rport->dd_data;		\
+	struct fc_rport_priv *rdata = rport->dd_data;			\
 	struct fc_lport *lport = rdata->local_port;			\
 	FC_RPORT_ID_DBG(lport, rport->port_id, fmt, ##args);		\
 } while (0)
@@ -177,6 +177,14 @@ enum fc_rport_event {
 	RPORT_EV_LOGO
 };
 
+/*
+ * Temporary definition to prepare for split off from fc_rport_libfc_priv
+ * of a separately-allocated structure called fc_rport_priv.  This will
+ * be the primary object for the discovery and rport state machines.
+ * This definition is just to make this patch series easier to review.
+ */
+#define fc_rport_priv fc_rport_libfc_priv
+
 struct fc_rport_operations {
 	void (*event_callback)(struct fc_lport *, struct fc_rport *,
 			       enum fc_rport_event);

commit b2f0091fbf8b475fa09b5e1712e0ab84cb3e1ca4
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Tue Aug 25 13:58:53 2009 -0700

    [SCSI] fcoe, libfc: fully makes use of per cpu exch pool and then removes em_lock
    
    1. Updates fcoe_rcv() to queue incoming frames to the fcoe per
       cpu thread on which this frame's exch was originated and simply
       use current cpu for request exch not originated by initiator.
       It is redundant to add this code under CONFIG_SMP, so removes
       CONFIG_SMP uses around this code.
    
    2. Updates fc_exch_em_alloc, fc_exch_delete, fc_exch_find to use
       per cpu exch pools, here fc_exch_delete is rename of older
       fc_exch_mgr_delete_ep since ep/exch are now deleted in pools
       of EM and so brief new name is sufficient and better name.
    
       Updates these functions to map exch id to their index into exch
       pool using fc_cpu_mask, fc_cpu_order and EM min_xid.
       This mapping is as per detailed explanation about this in
       last patch and basically this is just as lower fc_cpu_mask
       bits of exch id as cpu number and upper bit sum of EM min_xid
       and exch index in pool.
    
       Uses pool next_index to keep track of exch allocation from
       pool along with pool_max_index as upper bound of exches array
       in pool.
    
    3. Adds exch pool ptr to fc_exch to free exch to its pool in
       fc_exch_delete.
    
    4. Updates fc_exch_mgr_reset to reset all exch pools of an EM,
       this required adding fc_exch_pool_reset func to reset exches
       in pool and then have fc_exch_mgr_reset call fc_exch_pool_reset
       for each pool within each EM for a lport.
    
    5. Removes no longer needed exches array, em_lock, next_xid, and
       total_exches from struct fc_exch_mgr, these are not needed after
       use of per cpu exch pool, also removes not used max_read,
       last_read from struct fc_exch_mgr.
    
    6. Updates locking notes for exch pool lock with fc_exch lock and
       uses pool lock in exch allocation, lookup and reset.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 32063389c4b0..53b38814d38a 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -368,6 +368,7 @@ struct fc_seq {
  */
 struct fc_exch {
 	struct fc_exch_mgr *em;		/* exchange manager */
+	struct fc_exch_pool *pool;	/* per cpu exches pool */
 	u32		state;		/* internal driver state */
 	u16		xid;		/* our exchange ID */
 	struct list_head	ex_list;	/* free or busy list linkage */
@@ -1045,10 +1046,12 @@ struct fc_exch *fc_exch_alloc(struct fc_lport *lport, struct fc_frame *fp);
  */
 struct fc_seq *fc_seq_start_next(struct fc_seq *sp);
 
+
 /*
- * Reset an exchange manager, completing all sequences and exchanges.
- * If s_id is non-zero, reset only exchanges originating from that FID.
- * If d_id is non-zero, reset only exchanges sending to that FID.
+ * Reset all EMs of a lport, releasing its all sequences and
+ * exchanges. If sid is non-zero, then reset only exchanges
+ * we sourced from that FID. If did is non-zero, reset only
+ * exchanges destined to that FID.
  */
 void fc_exch_mgr_reset(struct fc_lport *, u32 s_id, u32 d_id);
 

commit e4bc50bedf0dd6c63f20a7bc0a2b46667664fba1
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Tue Aug 25 13:58:47 2009 -0700

    [SCSI] fcoe, libfc: adds per cpu exch pool within exchange manager(EM)
    
    Adds per cpu exch pool for these reasons:-
    
     1. Currently an EM instance is shared across all cpus to manage
        all exches for all cpus. This required em_lock across all
        cpus for an exch alloc, free, lookup and reset each frame
        and that made em_lock expensive, so instead having per cpu
        exch pool with their own per cpu pool lock will likely reduce
        locking contention in fast path for an exch alloc, free and
        lookup.
    
     2. Per cpu exch pool will likely improve cache hit ratio since
        all frames of an exch will be processed on the same cpu on
        which exch originated.
    
    This patch is only prep work to help in keeping complexity of next
    patch low, so this patch only sets up per cpu exch pool and related
    helper funcs to be used by next patch. The next patch fully makes
    use of per cpu exch pool in all code paths ie. tx, rx and reset.
    
    Divides per EM exch id range equally across all cpus to setup per
    cpu exch pool. This division is such that lower bits of exch id
    carries cpu number info on which exch originated, later a simple
    bitwise AND operation on exch id of incoming frame with fc_cpu_mask
    retrieves cpu number info to direct all frames to same cpu on which
    exch originated. This required a global fc_cpu_mask and fc_cpu_order
    initialized to max possible cpus number nr_cpu_ids rounded up to 2's
    power, this will be used in mapping exch id and exch ptr array
    index in pool during exch allocation, find or reset code paths.
    
    Adds a check in fc_exch_mgr_alloc() to ensure specified min_xid
    lower bits are zero since these bits are used to carry cpu info.
    
    Adds and initializes struct fc_exch_pool with all required fields
    to manage exches in pool.
    
    Allocates per cpu struct fc_exch_pool with memory for exches array
    for range of exches per pool. The exches array memory is followed
    by struct fc_exch_pool.
    
    Adds fc_exch_ptr_get/set() helper functions to get/set exch ptr in
    pool exches array at specified array index.
    
    Increases default FCOE_MAX_XID to 0x0FFF from 0x07EF, so that more
    exches are available per cpu after above described exch id range
    division across all cpus to each pool.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index c2b928cfafb9..32063389c4b0 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -343,6 +343,7 @@ static inline bool fc_fcp_is_read(const struct fc_fcp_pkt *fsp)
 
 struct fc_exch_mgr;
 struct fc_exch_mgr_anchor;
+extern u16	fc_cpu_mask;	/* cpu mask for possible cpus */
 
 /*
  * Sequence.

commit 52ff878c912215210f53c0a080552dd6ba3055a2
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Wed Jul 29 17:05:10 2009 -0700

    [SCSI] fcoe, fnic, libfc: modifies current code paths to use EM anchor list
    
    Modifies current code to use EM anchor list in EM allocation, EM free,
    EM reset, exch allocation and exch lookup code paths.
    
     1. Modifies fc_exch_mgr_alloc to accept EM match function and then
        have allocated EM added to the lport using fc_exch_mgr_add API
        while also updating EM kref for newly added EM.
    
     2. Updates fc_exch_mgr_free API to accept only lport pointer instead
        EM and then have this API free all EMs of the lport from EM anchor
        list.
    
     3. Removes single lport pointer link from the EM, which was used in
        associating lport pointer in newly allocated exchange. Instead have
        lport pointer passed along new exchange allocation call path and
        then store passed lport pointer in newly allocated exchange, this
        will allow a single EM instance to be used across more than one
        lport and used in EM reset to reset only lport specific exchanges.
    
     4. Modifies fc_exch_mgr_reset to reset all EMs from the EM anchor list
        of the lport, adds additional exch lport pointer (ep->lp) check for
        shared EM case to reset exchange specific to a lport requested reset.
    
     5. Updates exch allocation API fc_exch_alloc to use EM anchor list and
        its anchor match func pointer. The fc_exch_alloc will walk the list
        of EMs until it finds a match, a match will be either null match
        func pointer or call to match function returning true value.
    
     6. Updates fc_exch_recv to accept incoming frame on local port using
        only lport pointer and frame pointer without specifying EM instance
        of incoming frame. Instead modified fc_exch_recv to locate EM for the
        incoming frame by matching xid of incoming frame against a EM xid range.
        This change was required to use EM list in libfc Rx path and after this
        change the lport fc_exch_mgr pointer emp is not needed anymore, so
        removed emp pointer.
    
     7. Updates fnic for removed lport emp pointer and above modified libfc APIs
        fc_exch_recv, fc_exch_mgr_alloc and fc_exch_mgr_free.
    
     8. Removes exch_get and exch_put from libfc_function_template as these
        are no longer needed with EM anchor list and its match function use.
        Also removes its default function fc_exch_get.
    
    A defect this patch introduced regarding the libfc initialization order in
    the fnic driver was fixed by Joe Eykholt <jeykholt@cisco.com>.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index f1bde91f98a2..c2b928cfafb9 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -517,25 +517,6 @@ struct libfc_function_template {
 	 */
 	void (*exch_done)(struct fc_seq *sp);
 
-	/*
-	 * Assigns a EM and a free XID for an new exchange and then
-	 * allocates a new exchange and sequence pair.
-	 * The fp can be used to determine free XID.
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	struct fc_exch *(*exch_get)(struct fc_lport *lp, struct fc_frame *fp);
-
-	/*
-	 * Release previously assigned XID by exch_get API.
-	 * The LLD may implement this if XID is assigned by LLD
-	 * in exch_get().
-	 *
-	 * STATUS: OPTIONAL
-	 */
-	void (*exch_put)(struct fc_lport *lp, struct fc_exch_mgr *mp,
-			 u16 ex_id);
-
 	/*
 	 * Start a new sequence on the same exchange/sequence tuple.
 	 *
@@ -703,7 +684,6 @@ struct fc_lport {
 
 	/* Associations */
 	struct Scsi_Host	*host;
-	struct fc_exch_mgr	*emp;
 	struct list_head	ema_list;
 	struct fc_rport		*dns_rp;
 	struct fc_rport		*ptp_rp;
@@ -996,27 +976,25 @@ void fc_exch_mgr_del(struct fc_exch_mgr_anchor *ema);
  * a new exchange.
  * The LLD may choose to have multiple EMs,
  * e.g. one EM instance per CPU receive thread in LLD.
- * The LLD can use exch_get() of struct libfc_function_template
- * to specify XID for a new exchange within
- * a specified EM instance.
  *
- * The em_idx to uniquely identify an EM instance.
+ * Specified match function is used in allocating exchanges
+ * from newly allocated EM.
  */
 struct fc_exch_mgr *fc_exch_mgr_alloc(struct fc_lport *lp,
 				      enum fc_class class,
 				      u16 min_xid,
-				      u16 max_xid);
+				      u16 max_xid,
+				      bool (*match)(struct fc_frame *));
 
 /*
- * Free an exchange manager.
+ * Free all exchange managers of a lport.
  */
-void fc_exch_mgr_free(struct fc_exch_mgr *mp);
+void fc_exch_mgr_free(struct fc_lport *lport);
 
 /*
  * Receive a frame on specified local port and exchange manager.
  */
-void fc_exch_recv(struct fc_lport *lp, struct fc_exch_mgr *mp,
-		  struct fc_frame *fp);
+void fc_exch_recv(struct fc_lport *lp, struct fc_frame *fp);
 
 /*
  * This function is for exch_seq_send function pointer in
@@ -1057,20 +1035,10 @@ int fc_seq_exch_abort(const struct fc_seq *req_sp, unsigned int timer_msec);
  */
 void fc_exch_done(struct fc_seq *sp);
 
-/*
- * Assigns a EM and XID for a frame and then allocates
- * a new exchange and sequence pair.
- * The fp can be used to determine free XID.
- */
-struct fc_exch *fc_exch_get(struct fc_lport *lp, struct fc_frame *fp);
-
 /*
  * Allocate a new exchange and sequence pair.
- * if ex_id is zero then next free exchange id
- * from specified exchange manger mp will be assigned.
  */
-struct fc_exch *fc_exch_alloc(struct fc_exch_mgr *mp,
-			      struct fc_frame *fp, u16 ex_id);
+struct fc_exch *fc_exch_alloc(struct fc_lport *lport, struct fc_frame *fp);
 /*
  * Start a new sequence on the same exchange as the supplied sequence.
  */

commit d459b7ea1b4c7aa3dacfeee174d02b2f7a95850d
Author: Robert Love <robert.w.love@intel.com>
Date:   Wed Jul 29 17:05:05 2009 -0700

    [SCSI] libfc: Remove the FC_EM_DBG macro
    
    Currently there is a 1:1 relationship between the lport
    and exchange manager. This macro takes an EM as an argument
    and determines the lport from it. However, later patches
    will use an EM list per lport, so we will no longer have
    this 1:1 relationship- this macro must change.
    
    The FC_EM_DBG macro is rarely used. There are four callers,
    two can use FC_LPORT_DBG instead and two can be removed
    since they're not necessary. This patch makes those changes
    and removes the macro.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index b381b1ca9aec..f1bde91f98a2 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -88,12 +88,6 @@ do {									\
 				(pkt)->lp->host->host_no,		\
 				pkt->rport->port_id, ##args))
 
-#define FC_EM_DBG(em, fmt, args...)					\
-	FC_CHECK_LOGGING(FC_EM_LOGGING,					\
-			 printk(KERN_INFO "host%u: em: " fmt,		\
-				(em)->lp->host->host_no,		\
-				##args))
-
 #define FC_EXCH_DBG(exch, fmt, args...)					\
 	FC_CHECK_LOGGING(FC_EXCH_LOGGING,				\
 			 printk(KERN_INFO "host%u: xid %4x: " fmt,	\

commit 96316099ac3cb259eac2d6891f3c75b38b29d26e
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Wed Jul 29 17:05:00 2009 -0700

    [SCSI] fcoe, libfc: adds exchange manager(EM) anchor list per lport and related APIs
    
    Adds EM list using a anchor struct fc_exch_mgr_anchor, anchor is used
    to allow same EM instance sharing across more than one lport on a eth
    device, this implementation is per discussed design posted at
    http://www.open-fcoe.org/pipermail/devel/2009-June/002566.html.
    
    The shared EM is required for multiple lports on eth device when
    using multiple VLANs or NPIV.
    
    Adds fc_exch_mgr_add API to add a EM to the lport and fc_exch_mgr_del
    API to delete previously added EM.
    
    Also adds function fc_exch_mgr_destroy() to destroy allocated EM.
    The kref is added to the EM to keep track of EM usage count, the EM is
    destroyed when no longer in use upon kref reaching to zero.
    
    The caller can specify match function to fc_exch_mgr_add, this
    will be used in determining exchange allocation from its EM or not.
    
    Moved calling of fcoe_em_config below fcoe_libfc_config calling,
    so that list head lp->ema_list is initialized before configuring
    EM.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 04db7a9e631b..b381b1ca9aec 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -348,6 +348,7 @@ static inline bool fc_fcp_is_read(const struct fc_fcp_pkt *fsp)
  */
 
 struct fc_exch_mgr;
+struct fc_exch_mgr_anchor;
 
 /*
  * Sequence.
@@ -709,6 +710,7 @@ struct fc_lport {
 	/* Associations */
 	struct Scsi_Host	*host;
 	struct fc_exch_mgr	*emp;
+	struct list_head	ema_list;
 	struct fc_rport		*dns_rp;
 	struct fc_rport		*ptp_rp;
 	void			*scsi_priv;
@@ -963,6 +965,28 @@ int fc_elsct_init(struct fc_lport *lp);
  */
 int fc_exch_init(struct fc_lport *lp);
 
+/*
+ * Adds Exchange Manager (EM) mp to lport.
+ *
+ * Adds specified mp to lport using struct fc_exch_mgr_anchor,
+ * the struct fc_exch_mgr_anchor allows same EM sharing by
+ * more than one lport with their specified match function,
+ * the match function is used in allocating exchange from
+ * added mp.
+ */
+struct fc_exch_mgr_anchor *fc_exch_mgr_add(struct fc_lport *lport,
+					   struct fc_exch_mgr *mp,
+					   bool (*match)(struct fc_frame *));
+
+/*
+ * Deletes Exchange Manager (EM) from lport by removing
+ * its anchor ema from lport.
+ *
+ * If removed anchor ema was the last user of its associated EM
+ * then also destroys associated EM.
+ */
+void fc_exch_mgr_del(struct fc_exch_mgr_anchor *ema);
+
 /*
  * Allocates an Exchange Manager (EM).
  *

commit 141940548c6919c22bf0573c68fd59d961e22475
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Wed Jul 29 17:04:43 2009 -0700

    [SCSI] libfc: rename rport state "NONE" to "DELETE".
    
    State RPORT_ST_NONE was intented to be an invalid state (0), never used.
    This was a misguided attempt to be sure it was always initialized.
    Having an extra state meaning nothing requires switch statements to
    have a case covering that state.
    
    State NONE has been used instead to mean the remote port is being deleted.
    Changing the name to RPORT_ST_DELETE.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index b5c9b285b462..04db7a9e631b 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -147,13 +147,13 @@ enum fc_disc_event {
 };
 
 enum fc_rport_state {
-	RPORT_ST_NONE = 0,
 	RPORT_ST_INIT,		/* initialized */
 	RPORT_ST_PLOGI,		/* waiting for PLOGI completion */
 	RPORT_ST_PRLI,		/* waiting for PRLI completion */
 	RPORT_ST_RTV,		/* waiting for RTV completion */
 	RPORT_ST_READY,		/* ready for use */
 	RPORT_ST_LOGO,		/* port logout sent */
+	RPORT_ST_DELETE,	/* port being deleted */
 };
 
 enum fc_rport_trans_state {

commit b1d9fd5574763abe5c763e32e3547a4adee9bd88
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Wed Jul 29 17:04:22 2009 -0700

    [SCSI] libfc: rename lport NONE state to DISABLED
    
    The state NONE was meant to be invalid, but has been used as
    the initial state.  Rename it to be DISABLED, as more descriptive.
    Further patches will make it the like the RESET state, except
    it won't transition to FLOGI until fc_lport_fabric_login() is called.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index efdb6ba310e5..b5c9b285b462 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -129,7 +129,7 @@ do {									\
  * FC HBA status
  */
 enum fc_lport_state {
-	LPORT_ST_NONE = 0,
+	LPORT_ST_DISABLED = 0,
 	LPORT_ST_FLOGI,
 	LPORT_ST_DNS,
 	LPORT_ST_RPN_ID,

commit 7f74549ff630ad444b0b6bbcabf426f781910906
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Wed Jul 29 17:04:12 2009 -0700

    [SCSI] libfc: change debug messages to give host number.
    
    libfc debug messages currently show 'lport: <fc-id>:'
    wher <fc-id> is the hex assigned port-id.  When the lport
    is logged off, that will be zero, so its hard to distinguish
    which instance is involved.  The FC-ID can change
    if the port is re-patched or changes VSANs.
    
    Two lports may even have the same FC-ID if connected to isolated SANs.
    
    Change the debug messages to print the SCSI host number "hostN:",
    which will not change for the life of the lport.
    Still show the FC_ID on lport messages.
    
    Also, add a macro to FC_RPORT_ID_DBG for rport debugging where there's
    no rdata structure involved.  It takes the lport and port_id as parameters.
    Use this in fc_rport_recv_plogi_req() and fc_rport_recv_logo_req().
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index ef04a2c52b8c..efdb6ba310e5 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -59,47 +59,51 @@ do {								\
 
 #define FC_LPORT_DBG(lport, fmt, args...)				\
 	FC_CHECK_LOGGING(FC_LPORT_LOGGING,				\
-			 printk(KERN_INFO "lport: %6x: " fmt,		\
-				fc_host_port_id(lport->host), ##args))
+			 printk(KERN_INFO "host%u: lport %6x: " fmt,	\
+				(lport)->host->host_no,			\
+				fc_host_port_id((lport)->host), ##args))
 
 #define FC_DISC_DBG(disc, fmt, args...)					\
 	FC_CHECK_LOGGING(FC_DISC_LOGGING,				\
-			 printk(KERN_INFO "disc: %6x: " fmt,		\
-				fc_host_port_id(disc->lport->host),	\
+			 printk(KERN_INFO "host%u: disc: " fmt,		\
+				(disc)->lport->host->host_no,		\
 				##args))
 
+#define FC_RPORT_ID_DBG(lport, port_id, fmt, args...)			\
+	FC_CHECK_LOGGING(FC_RPORT_LOGGING,				\
+			 printk(KERN_INFO "host%u: rport %6x: " fmt,	\
+				(lport)->host->host_no,			\
+				(port_id), ##args))
+
 #define FC_RPORT_DBG(rport, fmt, args...)				\
 do {									\
 	struct fc_rport_libfc_priv *rdata = rport->dd_data;		\
 	struct fc_lport *lport = rdata->local_port;			\
-	FC_CHECK_LOGGING(FC_RPORT_LOGGING,				\
-			 printk(KERN_INFO "rport: %6x: %6x: " fmt,	\
-				fc_host_port_id(lport->host),		\
-				rport->port_id, ##args));		\
+	FC_RPORT_ID_DBG(lport, rport->port_id, fmt, ##args);		\
 } while (0)
 
 #define FC_FCP_DBG(pkt, fmt, args...)					\
 	FC_CHECK_LOGGING(FC_FCP_LOGGING,				\
-			 printk(KERN_INFO "fcp: %6x: %6x: " fmt,	\
-				fc_host_port_id(pkt->lp->host),		\
+			 printk(KERN_INFO "host%u: fcp: %6x: " fmt,	\
+				(pkt)->lp->host->host_no,		\
 				pkt->rport->port_id, ##args))
 
 #define FC_EM_DBG(em, fmt, args...)					\
 	FC_CHECK_LOGGING(FC_EM_LOGGING,					\
-			 printk(KERN_INFO "em: %6x: " fmt,		\
-				fc_host_port_id(em->lp->host),		\
+			 printk(KERN_INFO "host%u: em: " fmt,		\
+				(em)->lp->host->host_no,		\
 				##args))
 
 #define FC_EXCH_DBG(exch, fmt, args...)					\
 	FC_CHECK_LOGGING(FC_EXCH_LOGGING,				\
-			 printk(KERN_INFO "exch: %6x: %4x: " fmt,	\
-				fc_host_port_id(exch->lp->host),	\
+			 printk(KERN_INFO "host%u: xid %4x: " fmt,	\
+				(exch)->lp->host->host_no,		\
 				exch->xid, ##args))
 
 #define FC_SCSI_DBG(lport, fmt, args...)				\
 	FC_CHECK_LOGGING(FC_SCSI_LOGGING,                               \
-			 printk(KERN_INFO "scsi: %6x: " fmt,		\
-				fc_host_port_id(lport->host), ##args))
+			 printk(KERN_INFO "host%u: scsi: " fmt,		\
+				(lport)->host->host_no,	##args))
 
 /*
  * libfc error codes

commit beb29a6d421f6dbd41d68d0621c1b28ad1d4a9f4
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Wed Jul 29 17:04:06 2009 -0700

    [SCSI] libfc: remove extra semicolons from debug macros
    
    This is unlikely to cause any problems, but the libfc debug macros
    introduce extra undesirable semicolons.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index b92584a8843a..ef04a2c52b8c 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -51,22 +51,22 @@ do {								\
 		do {						\
 			CMD;					\
 		} while (0);					\
-} while (0);
+} while (0)
 
 #define FC_LIBFC_DBG(fmt, args...)					\
 	FC_CHECK_LOGGING(FC_LIBFC_LOGGING,				\
-			 printk(KERN_INFO "libfc: " fmt, ##args);)
+			 printk(KERN_INFO "libfc: " fmt, ##args))
 
 #define FC_LPORT_DBG(lport, fmt, args...)				\
 	FC_CHECK_LOGGING(FC_LPORT_LOGGING,				\
 			 printk(KERN_INFO "lport: %6x: " fmt,		\
-				fc_host_port_id(lport->host), ##args);)
+				fc_host_port_id(lport->host), ##args))
 
 #define FC_DISC_DBG(disc, fmt, args...)					\
 	FC_CHECK_LOGGING(FC_DISC_LOGGING,				\
 			 printk(KERN_INFO "disc: %6x: " fmt,		\
 				fc_host_port_id(disc->lport->host),	\
-				##args);)
+				##args))
 
 #define FC_RPORT_DBG(rport, fmt, args...)				\
 do {									\
@@ -75,31 +75,31 @@ do {									\
 	FC_CHECK_LOGGING(FC_RPORT_LOGGING,				\
 			 printk(KERN_INFO "rport: %6x: %6x: " fmt,	\
 				fc_host_port_id(lport->host),		\
-				rport->port_id, ##args);)		\
-} while (0);
+				rport->port_id, ##args));		\
+} while (0)
 
 #define FC_FCP_DBG(pkt, fmt, args...)					\
 	FC_CHECK_LOGGING(FC_FCP_LOGGING,				\
 			 printk(KERN_INFO "fcp: %6x: %6x: " fmt,	\
 				fc_host_port_id(pkt->lp->host),		\
-				pkt->rport->port_id, ##args);)
+				pkt->rport->port_id, ##args))
 
 #define FC_EM_DBG(em, fmt, args...)					\
 	FC_CHECK_LOGGING(FC_EM_LOGGING,					\
 			 printk(KERN_INFO "em: %6x: " fmt,		\
 				fc_host_port_id(em->lp->host),		\
-				##args);)
+				##args))
 
 #define FC_EXCH_DBG(exch, fmt, args...)					\
 	FC_CHECK_LOGGING(FC_EXCH_LOGGING,				\
 			 printk(KERN_INFO "exch: %6x: %4x: " fmt,	\
 				fc_host_port_id(exch->lp->host),	\
-				exch->xid, ##args);)
+				exch->xid, ##args))
 
 #define FC_SCSI_DBG(lport, fmt, args...)				\
 	FC_CHECK_LOGGING(FC_SCSI_LOGGING,                               \
 			 printk(KERN_INFO "scsi: %6x: " fmt,		\
-				fc_host_port_id(lport->host), ##args);)
+				fc_host_port_id(lport->host), ##args))
 
 /*
  * libfc error codes

commit 7414705ea4aef9ce438e547f3138a680d2d1096c
Author: Robert Love <robert.w.love@intel.com>
Date:   Wed Jun 10 15:31:10 2009 -0700

    libfc: Add runtime debugging with debug_logging module parameter
    
    This patch adds the /sys/module/libfc/parameters/debug_logging
    file to sysfs as a module parameter. It accepts an integer
    bitmask for logging. Currently it supports:
    
       bit
    LSB 0 = general libfc debugging
        1 = lport debugging
        2 = disc debugging
        3 = rport debugging
        4 = fcp debugging
        5 = EM debugging
        6 = exch/seq debugging
        7 = scsi logging (mostly error handling)
    
    the other bits are not used at this time.
    
    The patch converts all of the libfc source files to use
    these new macros and removes the old FC_DBG macro.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index ebdd9f4cf070..b92584a8843a 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -34,17 +34,72 @@
 
 #include <scsi/fc_frame.h>
 
-#define LIBFC_DEBUG
-
-#ifdef LIBFC_DEBUG
-/* Log messages */
-#define FC_DBG(fmt, args...)						\
-	do {								\
-		printk(KERN_INFO "%s " fmt, __func__, ##args);		\
-	} while (0)
-#else
-#define FC_DBG(fmt, args...)
-#endif
+#define FC_LIBFC_LOGGING 0x01 /* General logging, not categorized */
+#define FC_LPORT_LOGGING 0x02 /* lport layer logging */
+#define FC_DISC_LOGGING  0x04 /* discovery layer logging */
+#define FC_RPORT_LOGGING 0x08 /* rport layer logging */
+#define FC_FCP_LOGGING   0x10 /* I/O path logging */
+#define FC_EM_LOGGING    0x20 /* Exchange Manager logging */
+#define FC_EXCH_LOGGING  0x40 /* Exchange/Sequence logging */
+#define FC_SCSI_LOGGING  0x80 /* SCSI logging (mostly error handling) */
+
+extern unsigned int fc_debug_logging;
+
+#define FC_CHECK_LOGGING(LEVEL, CMD)				\
+do {								\
+	if (unlikely(fc_debug_logging & LEVEL))			\
+		do {						\
+			CMD;					\
+		} while (0);					\
+} while (0);
+
+#define FC_LIBFC_DBG(fmt, args...)					\
+	FC_CHECK_LOGGING(FC_LIBFC_LOGGING,				\
+			 printk(KERN_INFO "libfc: " fmt, ##args);)
+
+#define FC_LPORT_DBG(lport, fmt, args...)				\
+	FC_CHECK_LOGGING(FC_LPORT_LOGGING,				\
+			 printk(KERN_INFO "lport: %6x: " fmt,		\
+				fc_host_port_id(lport->host), ##args);)
+
+#define FC_DISC_DBG(disc, fmt, args...)					\
+	FC_CHECK_LOGGING(FC_DISC_LOGGING,				\
+			 printk(KERN_INFO "disc: %6x: " fmt,		\
+				fc_host_port_id(disc->lport->host),	\
+				##args);)
+
+#define FC_RPORT_DBG(rport, fmt, args...)				\
+do {									\
+	struct fc_rport_libfc_priv *rdata = rport->dd_data;		\
+	struct fc_lport *lport = rdata->local_port;			\
+	FC_CHECK_LOGGING(FC_RPORT_LOGGING,				\
+			 printk(KERN_INFO "rport: %6x: %6x: " fmt,	\
+				fc_host_port_id(lport->host),		\
+				rport->port_id, ##args);)		\
+} while (0);
+
+#define FC_FCP_DBG(pkt, fmt, args...)					\
+	FC_CHECK_LOGGING(FC_FCP_LOGGING,				\
+			 printk(KERN_INFO "fcp: %6x: %6x: " fmt,	\
+				fc_host_port_id(pkt->lp->host),		\
+				pkt->rport->port_id, ##args);)
+
+#define FC_EM_DBG(em, fmt, args...)					\
+	FC_CHECK_LOGGING(FC_EM_LOGGING,					\
+			 printk(KERN_INFO "em: %6x: " fmt,		\
+				fc_host_port_id(em->lp->host),		\
+				##args);)
+
+#define FC_EXCH_DBG(exch, fmt, args...)					\
+	FC_CHECK_LOGGING(FC_EXCH_LOGGING,				\
+			 printk(KERN_INFO "exch: %6x: %4x: " fmt,	\
+				fc_host_port_id(exch->lp->host),	\
+				exch->xid, ##args);)
+
+#define FC_SCSI_DBG(lport, fmt, args...)				\
+	FC_CHECK_LOGGING(FC_SCSI_LOGGING,                               \
+			 printk(KERN_INFO "scsi: %6x: " fmt,		\
+				fc_host_port_id(lport->host), ##args);)
 
 /*
  * libfc error codes

commit a366695592ebc9151dd5a248681270f0925d8324
Author: Abhijeet Joglekar <abjoglek@cisco.com>
Date:   Fri May 1 10:01:26 2009 -0700

    [SCSI] libfc,fcoe,fnic: Separate rport and lport max retry counts
    
    This allows fnic to configure number of retries for lport and rport
    separately.
    
    Signed-off-by: Abhijeet Joglekar <abjoglek@cisco.com>
    Acked-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 45f9cc642c46..ebdd9f4cf070 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -679,6 +679,7 @@ struct fc_lport {
 	unsigned int		e_d_tov;
 	unsigned int		r_a_tov;
 	u8			max_retry_count;
+	u8			max_rport_retry_count;
 	u16			link_speed;
 	u16			link_supported_speeds;
 	u16			lro_xid;	/* max xid for fcoe lro */

commit b4c6f54632ad664a3d9e7f05e4ea0f1803e32755
Author: Abhijeet Joglekar <abjoglek@cisco.com>
Date:   Tue Apr 21 16:27:04 2009 -0700

    [SCSI] libfc: Track rogue remote ports
    
    Rogue ports are currently not tracked on any list. The only reference
    to them is through any outstanding exchanges pending on the rogue ports.
    If the module is removed while a retry is set on a rogue port
    (say a Plogi retry for instance), this retry is not cancelled because there
    is no reference to the rogue port in the discovery rports list. Thus the
    local port can clean itself up, delete the exchange pool, and then the
    rogue port timeout can fire and try to start up another exchange.
    
    This patch tracks the rogue ports in a new list disc->rogue_rports. Creating
    a new list instead of using the disc->rports list keeps remote port code
    change to a minimum.
    
    1)  Whenever a rogue port is created, it is immediately added to the
    disc->rogue_rports list.
    
    2) When the rogues port goes to ready, it is removed from the rogue list
    and the real remote port is added to the disc->rports list
    
    3) The removal of the rogue from the disc->rogue_rports list is done in
    the context of the fc_rport_work() workQ thread in discovery callback.
    
    4) Real rports are removed from the disc->rports list like before. Lookup
    is done only in the real rports list. This avoids making large changes
    to the remote port code.
    
    5) In fc_disc_stop_rports, the rogues list is traversed in addition to the
    real list to stop the rogue ports and issue logoffs on them. This way, rogue
    ports get cleaned up when the local port goes away.
    
    6) rogue remote ports are not removed from the list right away, but
    removed late in fc_rport_work() context, multiple threads can find the same
    remote port in the list and call rport_logoff(). Rport_logoff() only
    continues with the logoff if port is not in NONE state, thus preventing
    multiple logoffs and multiple list deletions.
    
    7) Since the rport is removed from the disc list at a later stage
    (in the disc callback), incoming frames can find the rport even if
    rport_logoff() has been called on the rport. When rport_logoff() is called,
    the rport state is set to NONE, and we are trying to cancel all exchanges
    and retries on that port. While in this state, if an incoming
    Plogi/Prli/Logo or other frames match the rport, we should not reply
    because the rport is in the NONE state. Just drop the frame, since the
    rport will be deleted soon in the disc callback (fc_rport_work)
    
    8)  In fc_disc_single(), remove rport lookup and call to fc_disc_del_target.
    fc_disc_single() is called from recv_rscn_req() where rport lookup
    and rport_logoff is already done.
    
    Signed-off-by: Abhijeet Joglekar <abjoglek@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 0303a6a098cc..45f9cc642c46 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -637,6 +637,7 @@ struct fc_disc {
 			      enum fc_disc_event);
 
 	struct list_head	 rports;
+	struct list_head	 rogue_rports;
 	struct fc_lport		*lport;
 	struct mutex		disc_mutex;
 	struct fc_gpn_ft_resp	partial_buf;	/* partial name buffer */

commit a0a25da2a495a889664dc946942b8666665cd1e1
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Tue Mar 17 11:42:29 2009 -0700

    [SCSI] fcoe, libfc: fix double fcoe_softc memory alloc
    
    The foce_softc mem was reserved by libfc_host_alloc as well as
    by fcoe_host_alloc.
    
    Removes one liner fcoe_host_alloc completely, instead directly calls
    libfc_host_alloc to alloc scsi_host with libfc for just one fcoe_softc
    as fcoe private data.
    
    Moves libfc_host_alloc to libfc.h since it is a libfc API, placed
    lport_priv API adjacent to libfc_host_alloc since this is related
    to scsi_host priv data.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 4e1d394348cf..0303a6a098cc 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -696,11 +696,6 @@ struct fc_lport {
 /*
  * FC_LPORT HELPER FUNCTIONS
  *****************************/
-static inline void *lport_priv(const struct fc_lport *lp)
-{
-	return (void *)(lp + 1);
-}
-
 static inline int fc_lport_test_ready(struct fc_lport *lp)
 {
 	return lp->state == LPORT_ST_READY;
@@ -743,6 +738,23 @@ static inline struct fcoe_dev_stats *fc_lport_get_stats(struct fc_lport *lp)
 	return per_cpu_ptr(lp->dev_stats, smp_processor_id());
 }
 
+static inline void *lport_priv(const struct fc_lport *lp)
+{
+	return (void *)(lp + 1);
+}
+
+/**
+ * libfc_host_alloc() - Allocate a Scsi_Host with room for the fc_lport
+ * @sht: ptr to the scsi host templ
+ * @priv_size: size of private data after fc_lport
+ *
+ * Returns: ptr to Scsi_Host
+ */
+static inline struct Scsi_Host *
+libfc_host_alloc(struct scsi_host_template *sht, int priv_size)
+{
+	return scsi_host_alloc(sht, sizeof(struct fc_lport) + priv_size);
+}
 
 /*
  * LOCAL PORT LAYER

commit 582b45bc577f78b5bfff3db874594ce2d962b846
Author: Robert Love <robert.w.love@intel.com>
Date:   Tue Mar 31 15:51:50 2009 -0700

    [SCSI] fcoe: Use per-CPU kernel function for dev_stats instead of an array
    
    Remove the hotplug creation of dev_stats, we allocate for all possible CPUs
    now when we allocate the lport.
    
    v2: Durring the 2.6.30 merge window, before these patches were comitted,
    'percpu_ptr' was renamed 'per_cpu_ptr'. This latest update updates this
    patch for the name change.
    
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index a70eafaad084..4e1d394348cf 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -22,6 +22,7 @@
 
 #include <linux/timer.h>
 #include <linux/if.h>
+#include <linux/percpu.h>
 
 #include <scsi/scsi_transport.h>
 #include <scsi/scsi_transport_fc.h>
@@ -661,7 +662,8 @@ struct fc_lport {
 	unsigned long		boot_time;
 
 	struct fc_host_statistics host_stats;
-	struct fcoe_dev_stats	*dev_stats[NR_CPUS];
+	struct fcoe_dev_stats	*dev_stats;
+
 	u64			wwpn;
 	u64			wwnn;
 	u8			retry_count;
@@ -722,6 +724,25 @@ static inline void fc_lport_state_enter(struct fc_lport *lp,
 	lp->state = state;
 }
 
+static inline int fc_lport_init_stats(struct fc_lport *lp)
+{
+	/* allocate per cpu stats block */
+	lp->dev_stats = alloc_percpu(struct fcoe_dev_stats);
+	if (!lp->dev_stats)
+		return -ENOMEM;
+	return 0;
+}
+
+static inline void fc_lport_free_stats(struct fc_lport *lp)
+{
+	free_percpu(lp->dev_stats);
+}
+
+static inline struct fcoe_dev_stats *fc_lport_get_stats(struct fc_lport *lp)
+{
+	return per_cpu_ptr(lp->dev_stats, smp_processor_id());
+}
+
 
 /*
  * LOCAL PORT LAYER

commit b277d2aa9a4d969002c4157bf77b76b9ad9ca04a
Author: Yi Zou <yi.zou@intel.com>
Date:   Fri Feb 27 14:07:21 2009 -0800

    [SCSI] libfc: add support of large receive offload by ddp in fc_fcp
    
    When LLD supports direct data placement (ddp) for large receive of an scsi
    i/o coming into fc_fcp, we call into libfc_function_template's ddp_setup()
    to prepare for a ddp of large receive for this read I/O. When I/O is complete,
    we call the corresponding ddp_done() to get the length of data ddped as well
    as to let LLD do clean up.
    
    fc_fcp_ddp_setup()/fc_fcp_ddp_done() are added to setup and complete a ddped
    read I/O described by the given fc_fcp_pkt. They would call into corresponding
    ddp_setup/ddp_done implemented by the fcoe layer. Eventually, fcoe layer calls
    into LLD's ddp_setup/ddp_done provided through net_device
    
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 61c746cf55f3..a70eafaad084 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -245,6 +245,7 @@ struct fc_fcp_pkt {
 	 */
 	struct fcp_cmnd cdb_cmd;
 	size_t		xfer_len;
+	u16		xfer_ddp;	/* this xfer is ddped */
 	u32		xfer_contig_end; /* offset of end of contiguous xfer */
 	u16		max_payload;	/* max payload size in bytes */
 
@@ -267,6 +268,15 @@ struct fc_fcp_pkt {
 	u8		recov_retry;	/* count of recovery retries */
 	struct fc_seq	*recov_seq;	/* sequence for REC or SRR */
 };
+/*
+ * FC_FCP HELPER FUNCTIONS
+ *****************************/
+static inline bool fc_fcp_is_read(const struct fc_fcp_pkt *fsp)
+{
+	if (fsp && fsp->cmd)
+		return fsp->cmd->sc_data_direction == DMA_FROM_DEVICE;
+	return false;
+}
 
 /*
  * Structure and function definitions for managing Fibre Channel Exchanges
@@ -399,6 +409,21 @@ struct libfc_function_template {
 							   void *arg),
 					void *arg, unsigned int timer_msec);
 
+	/*
+	 * Sets up the DDP context for a given exchange id on the given
+	 * scatterlist if LLD supports DDP for large receive.
+	 *
+	 * STATUS: OPTIONAL
+	 */
+	int (*ddp_setup)(struct fc_lport *lp, u16 xid,
+			 struct scatterlist *sgl, unsigned int sgc);
+	/*
+	 * Completes the DDP transfer and returns the length of data DDPed
+	 * for the given exchange id.
+	 *
+	 * STATUS: OPTIONAL
+	 */
+	int (*ddp_done)(struct fc_lport *lp, u16 xid);
 	/*
 	 * Send a frame using an existing sequence and exchange.
 	 *
@@ -821,6 +846,11 @@ int fc_change_queue_type(struct scsi_device *sdev, int tag_type);
  */
 void fc_fcp_destroy(struct fc_lport *);
 
+/*
+ * Set up direct-data placement for this I/O request
+ */
+void fc_fcp_ddp_setup(struct fc_fcp_pkt *fsp, u16 xid);
+
 /*
  * ELS/CT interface
  *****************************/

commit ea1e9a9df5e1fde7ad8878c85b4a097cad0ddcea
Author: Yi Zou <yi.zou@intel.com>
Date:   Fri Feb 27 14:07:04 2009 -0800

    [SCSI] fcoe, libfc: check offload features from LLD through netdev
    
    This checks if net_devices supports FCoE offload ops in netdev_ops and it
    if it does, then sets up the corresponding flags in the associated fc_lport.
    
    For large send offload, the maximum length supported in one large send is now
    described by the added lso_max in fc_lport, which is setup initially from
    netdev->gso_max_size.
    
    Signed-off-by: Yi Zou <yi.zou@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index a2e126b86e3e..61c746cf55f3 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -654,6 +654,7 @@ struct fc_lport {
 	u16			link_speed;
 	u16			link_supported_speeds;
 	u16			lro_xid;	/* max xid for fcoe lro */
+	unsigned int		lso_max;	/* max large send size */
 	struct fc_ns_fts	fcts;	        /* FC-4 type masks */
 	struct fc_els_rnid_gen	rnid_gen;	/* RNID information */
 

commit 34f42a070fc98f5dc07e9fa2338b7b8d1dc347eb
Author: Robert Love <robert.w.love@intel.com>
Date:   Fri Feb 27 10:55:45 2009 -0800

    [SCSI] libfc, fcoe: Fix kerneldoc comments
    
    1) Added '()' for function names in kerneldoc comments
    
    2) Changed comment bookends from '**/' to '*/'. The comment on the the
       mailing list was that '**/' "is consistently unconventional.  Not
       wrong, just odd." The Documentation/kernel-doc-nano-HOWTO.txt
       states that kerneldoc comment blocks should end with '**/' but most
       (if not all) instance I found under drivers/scsi/ were only using
       the '*/' so I converted to that style.
    
    3) Removed incorrect linebreaks in kerneldoc comments where found
    
    4) Removed a few unnecessary blank comment lines in kerneldoc comment
       blocks
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 282829cdf352..a2e126b86e3e 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -665,7 +665,7 @@ struct fc_lport {
 	struct delayed_work	disc_work;
 };
 
-/**
+/*
  * FC_LPORT HELPER FUNCTIONS
  *****************************/
 static inline void *lport_priv(const struct fc_lport *lp)
@@ -697,7 +697,7 @@ static inline void fc_lport_state_enter(struct fc_lport *lp,
 }
 
 
-/**
+/*
  * LOCAL PORT LAYER
  *****************************/
 int fc_lport_init(struct fc_lport *lp);
@@ -747,19 +747,19 @@ int fc_lport_reset(struct fc_lport *);
 int fc_set_mfs(struct fc_lport *lp, u32 mfs);
 
 
-/**
+/*
  * REMOTE PORT LAYER
  *****************************/
 int fc_rport_init(struct fc_lport *lp);
 void fc_rport_terminate_io(struct fc_rport *rp);
 
-/**
+/*
  * DISCOVERY LAYER
  *****************************/
 int fc_disc_init(struct fc_lport *lp);
 
 
-/**
+/*
  * SCSI LAYER
  *****************************/
 /*
@@ -820,7 +820,7 @@ int fc_change_queue_type(struct scsi_device *sdev, int tag_type);
  */
 void fc_fcp_destroy(struct fc_lport *);
 
-/**
+/*
  * ELS/CT interface
  *****************************/
 /*
@@ -829,7 +829,7 @@ void fc_fcp_destroy(struct fc_lport *);
 int fc_elsct_init(struct fc_lport *lp);
 
 
-/**
+/*
  * EXCHANGE MANAGER LAYER
  *****************************/
 /*

commit 0ae4d4ae47d2ccbcad813b0d6d8fe12590c7d648
Author: Robert Love <robert.w.love@intel.com>
Date:   Fri Feb 27 10:55:39 2009 -0800

    [SCSI] libfc: Cleanup libfc_function_template comments
    
    Made the comments more like the comments for struct scsi_host_template.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 37df48e13b97..282829cdf352 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -336,31 +336,17 @@ struct fc_exch {
 
 struct libfc_function_template {
 
-	/**
-	 * Mandatory Fields
-	 *
-	 * These handlers must be implemented by the LLD.
-	 */
-
 	/*
 	 * Interface to send a FC frame
-	 */
-	int (*frame_send)(struct fc_lport *lp, struct fc_frame *fp);
-
-	/**
-	 * Optional Fields
 	 *
-	 * The LLD may choose to implement any of the following handlers.
-	 * If LLD doesn't specify hander and leaves its pointer NULL then
-	 * the default libfc function will be used for that handler.
-	 */
-
-	/**
-	 * ELS/CT interfaces
+	 * STATUS: REQUIRED
 	 */
+	int (*frame_send)(struct fc_lport *lp, struct fc_frame *fp);
 
 	/*
-	 * elsct_send - sends ELS/CT frame
+	 * Interface to send ELS/CT frames
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	struct fc_seq *(*elsct_send)(struct fc_lport *lport,
 				     struct fc_rport *rport,
@@ -370,9 +356,6 @@ struct libfc_function_template {
 					     struct fc_frame *fp,
 					     void *arg),
 				     void *arg, u32 timer_msec);
-	/**
-	 * Exhance Manager interfaces
-	 */
 
 	/*
 	 * Send the FC frame payload using a new exchange and sequence.
@@ -404,6 +387,8 @@ struct libfc_function_template {
 	 * timer_msec argument is specified. The timer is canceled when
 	 * it fires or when the exchange is done. The exchange timeout handler
 	 * is registered by EM layer.
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	struct fc_seq *(*exch_seq_send)(struct fc_lport *lp,
 					struct fc_frame *fp,
@@ -415,14 +400,18 @@ struct libfc_function_template {
 					void *arg, unsigned int timer_msec);
 
 	/*
-	 * send a frame using existing sequence and exchange.
+	 * Send a frame using an existing sequence and exchange.
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	int (*seq_send)(struct fc_lport *lp, struct fc_seq *sp,
 			struct fc_frame *fp);
 
 	/*
-	 * Send ELS response using mainly infomation
-	 * in exchange and sequence in EM layer.
+	 * Send an ELS response using infomation from a previous
+	 * exchange and sequence.
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	void (*seq_els_rsp_send)(struct fc_seq *sp, enum fc_els_cmd els_cmd,
 				 struct fc_seq_els_data *els_data);
@@ -434,6 +423,8 @@ struct libfc_function_template {
 	 * A timer_msec can be specified for abort timeout, if non-zero
 	 * timer_msec value is specified then exchange resp handler
 	 * will be called with timeout error if no response to abort.
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	int (*seq_exch_abort)(const struct fc_seq *req_sp,
 			      unsigned int timer_msec);
@@ -441,6 +432,8 @@ struct libfc_function_template {
 	/*
 	 * Indicate that an exchange/sequence tuple is complete and the memory
 	 * allocated for the related objects may be freed.
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	void (*exch_done)(struct fc_seq *sp);
 
@@ -448,6 +441,8 @@ struct libfc_function_template {
 	 * Assigns a EM and a free XID for an new exchange and then
 	 * allocates a new exchange and sequence pair.
 	 * The fp can be used to determine free XID.
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	struct fc_exch *(*exch_get)(struct fc_lport *lp, struct fc_frame *fp);
 
@@ -455,12 +450,16 @@ struct libfc_function_template {
 	 * Release previously assigned XID by exch_get API.
 	 * The LLD may implement this if XID is assigned by LLD
 	 * in exch_get().
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	void (*exch_put)(struct fc_lport *lp, struct fc_exch_mgr *mp,
 			 u16 ex_id);
 
 	/*
 	 * Start a new sequence on the same exchange/sequence tuple.
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	struct fc_seq *(*seq_start_next)(struct fc_seq *sp);
 
@@ -468,26 +467,33 @@ struct libfc_function_template {
 	 * Reset an exchange manager, completing all sequences and exchanges.
 	 * If s_id is non-zero, reset only exchanges originating from that FID.
 	 * If d_id is non-zero, reset only exchanges sending to that FID.
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	void (*exch_mgr_reset)(struct fc_lport *,
 			       u32 s_id, u32 d_id);
 
-	void (*rport_flush_queue)(void);
-	/**
-	 * Local Port interfaces
+	/*
+	 * Flush the rport work queue. Generally used before shutdown.
+	 *
+	 * STATUS: OPTIONAL
 	 */
+	void (*rport_flush_queue)(void);
 
 	/*
-	 * Receive a frame to a local port.
+	 * Receive a frame for a local port.
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	void (*lport_recv)(struct fc_lport *lp, struct fc_seq *sp,
 			   struct fc_frame *fp);
 
-	int (*lport_reset)(struct fc_lport *);
-
-	/**
-	 * Remote Port interfaces
+	/*
+	 * Reset the local port.
+	 *
+	 * STATUS: OPTIONAL
 	 */
+	int (*lport_reset)(struct fc_lport *);
 
 	/*
 	 * Create a remote port
@@ -502,26 +508,33 @@ struct libfc_function_template {
 	 * - PLOGI
 	 * - PRLI
 	 * - RTV
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	int (*rport_login)(struct fc_rport *rport);
 
 	/*
 	 * Logoff, and remove the rport from the transport if
 	 * it had been added. This will send a LOGO to the target.
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	int (*rport_logoff)(struct fc_rport *rport);
 
 	/*
 	 * Recieve a request from a remote port.
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	void (*rport_recv_req)(struct fc_seq *, struct fc_frame *,
 			       struct fc_rport *);
 
-	struct fc_rport *(*rport_lookup)(const struct fc_lport *, u32);
-
-	/**
-	 * FCP interfaces
+	/*
+	 * lookup an rport by it's port ID.
+	 *
+	 * STATUS: OPTIONAL
 	 */
+	struct fc_rport *(*rport_lookup)(const struct fc_lport *, u32);
 
 	/*
 	 * Send a fcp cmd from fsp pkt.
@@ -529,30 +542,38 @@ struct libfc_function_template {
 	 *
 	 * The resp handler is called when FCP_RSP received.
 	 *
+	 * STATUS: OPTIONAL
 	 */
 	int (*fcp_cmd_send)(struct fc_lport *lp, struct fc_fcp_pkt *fsp,
 			    void (*resp)(struct fc_seq *, struct fc_frame *fp,
 					 void *arg));
 
 	/*
-	 * Used at least durring linkdown and reset
+	 * Cleanup the FCP layer, used durring link down and reset
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	void (*fcp_cleanup)(struct fc_lport *lp);
 
 	/*
 	 * Abort all I/O on a local port
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	void (*fcp_abort_io)(struct fc_lport *lp);
 
-	/**
-	 * Discovery interfaces
+	/*
+	 * Receive a request for the discovery layer.
+	 *
+	 * STATUS: OPTIONAL
 	 */
-
 	void (*disc_recv_req)(struct fc_seq *,
 			      struct fc_frame *, struct fc_lport *);
 
 	/*
 	 * Start discovery for a local port.
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	void (*disc_start)(void (*disc_callback)(struct fc_lport *,
 						 enum fc_disc_event),
@@ -561,6 +582,8 @@ struct libfc_function_template {
 	/*
 	 * Stop discovery for a given lport. This will remove
 	 * all discovered rports
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	void (*disc_stop) (struct fc_lport *);
 
@@ -568,6 +591,8 @@ struct libfc_function_template {
 	 * Stop discovery for a given lport. This will block
 	 * until all discovered rports are deleted from the
 	 * FC transport class
+	 *
+	 * STATUS: OPTIONAL
 	 */
 	void (*disc_stop_final) (struct fc_lport *);
 };

commit 5101ff99f59aefb72e0c96e82aa32048ac9f8425
Author: Robert Love <robert.w.love@intel.com>
Date:   Fri Feb 27 10:55:18 2009 -0800

    [SCSI] libfc: Don't violate transport template for rogue port creation
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index b9e6c1cd8914..37df48e13b97 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -489,6 +489,11 @@ struct libfc_function_template {
 	 * Remote Port interfaces
 	 */
 
+	/*
+	 * Create a remote port
+	 */
+	struct fc_rport *(*rport_create)(struct fc_disc_port *);
+
 	/*
 	 * Initiates the RP state machine. It is called from the LP module.
 	 * This function will issue the following commands to the N_Port

commit bc0e17f691085315ae9303eb5b0883fe16dfe6b1
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Fri Feb 27 10:54:57 2009 -0800

    [SCSI] libfc, fcoe: fixed locking issues with lport->lp_mutex around lport->link_status
    
    The fcoe_xmit could call fc_pause in case the pending skb queue len is larger
    than FCOE_MAX_QUEUE_DEPTH, the fc_pause was trying to grab lport->lp_muex to
    change lport->link_status and that had these issues :-
    
    1. The fcoe_xmit was getting called with bh disabled, thus causing
    "BUG: scheduling while atomic" when grabbing lport->lp_muex with bh disabled.
    
    2. fc_linkup and fc_linkdown function calls lport_enter function with
    lport->lp_mutex held and these enter function in turn calls fcoe_xmit to send
    lport related FC frame, e.g. fc_linkup => fc_lport_enter_flogi to send flogi
    req. In this case grabbing the same lport->lp_mutex again in fc_puase from
    fcoe_xmit would cause deadlock.
    
    The lport->lp_mutex was used for setting FC_PAUSE in fcoe_xmit path but
    FC_PAUSE bit was not used anywhere beside just setting and clear this
    bit in lport->link_status, instead used a separate field qfull in fc_lport
    to eliminate need for lport->lp_mutex to track pending queue full condition
    and in turn avoid above described two locking issues.
    
    Also added check for lp->qfull in fc_fcp_lport_queue_ready to trigger
    SCSI_MLQUEUE_HOST_BUSY when lp->qfull is set to prevent more scsi-ml cmds
    while lp->qfull is set.
    
    This patch eliminated FC_LINK_UP and FC_PAUSE and instead used dedicated
    fields in fc_lport for this, this simplified all related conditional
    code.
    
    Also removed fc_pause and fc_unpause functions and instead used newly added
    lport->qfull directly in fcoe.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 042f4ade73d7..b9e6c1cd8914 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -68,9 +68,6 @@
 /*
  * FC HBA status
  */
-#define FC_PAUSE		    (1 << 1)
-#define FC_LINK_UP		    (1 << 0)
-
 enum fc_lport_state {
 	LPORT_ST_NONE = 0,
 	LPORT_ST_FLOGI,
@@ -603,7 +600,8 @@ struct fc_lport {
 
 	/* Operational Information */
 	struct libfc_function_template tt;
-	u16			link_status;
+	u8			link_up;
+	u8			qfull;
 	enum fc_lport_state	state;
 	unsigned long		boot_time;
 
@@ -703,12 +701,6 @@ void fc_linkup(struct fc_lport *);
  */
 void fc_linkdown(struct fc_lport *);
 
-/*
- * Pause and unpause traffic.
- */
-void fc_pause(struct fc_lport *);
-void fc_unpause(struct fc_lport *);
-
 /*
  * Configure the local port.
  */

commit 1f6ff364ceda516f88351a8ab640e656beed0b26
Author: Abhijeet Joglekar <abjoglek@cisco.com>
Date:   Fri Feb 27 10:54:35 2009 -0800

    [SCSI] libfc: Pass lport in exch_mgr_reset
    
    fc_exch_mgr structure is private to fc_exch.c. To export exch_mgr_reset to
    transport, transport needs access to the exch manager. Change
    exch_mgr_reset to use lport param which is the shared structure between
    libFC and transport.
    
    Alternatively, fc_exch_mgr definition can be moved to libfc.h so that lport
    can be accessed from mp*.
    
    Signed-off-by: Abhijeet Joglekar <abjoglek@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 9f2876397dda..042f4ade73d7 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -472,7 +472,7 @@ struct libfc_function_template {
 	 * If s_id is non-zero, reset only exchanges originating from that FID.
 	 * If d_id is non-zero, reset only exchanges sending to that FID.
 	 */
-	void (*exch_mgr_reset)(struct fc_exch_mgr *,
+	void (*exch_mgr_reset)(struct fc_lport *,
 			       u32 s_id, u32 d_id);
 
 	void (*rport_flush_queue)(void);
@@ -916,7 +916,7 @@ struct fc_seq *fc_seq_start_next(struct fc_seq *sp);
  * If s_id is non-zero, reset only exchanges originating from that FID.
  * If d_id is non-zero, reset only exchanges sending to that FID.
  */
-void fc_exch_mgr_reset(struct fc_exch_mgr *, u32 s_id, u32 d_id);
+void fc_exch_mgr_reset(struct fc_lport *, u32 s_id, u32 d_id);
 
 /*
  * Functions for fc_functions_template

commit 42e9a92fe6a9095bd68a379aaec7ad2be0337f7a
Author: Robert Love <robert.w.love@intel.com>
Date:   Tue Dec 9 15:10:17 2008 -0800

    [SCSI] libfc: A modular Fibre Channel library
    
    libFC is composed of 4 blocks supported by an exchange manager
    and a framing library. The upper 4 layers are fc_lport, fc_disc,
    fc_rport and fc_fcp. A LLD that uses libfc could choose to
    either use libfc's block, or using the transport template
    defined in libfc.h, override one or more blocks with its own
    implementation.
    
    The EM (Exchange Manager) manages exhcanges/sequences for all
    commands- ELS, CT and FCP.
    
    The framing library frames ELS and CT commands.
    
    The fc_lport block manages the library's representation of the
    host's FC enabled ports.
    
    The fc_disc block manages discovery of targets as well as
    handling changes that occur in the FC fabric (via. RSCN events).
    
    The fc_rport block manages the library's representation of other
    entities in the FC fabric. Currently the library uses this block
    for targets, its peer when in point-to-point mode and the
    directory server, but can be extended for other entities if
    needed.
    
    The fc_fcp block interacts with the scsi-ml and handles all
    I/O.
    
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    [jejb: added include of delay.h to fix ppc64 compile prob spotted by sfr]
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
new file mode 100644
index 000000000000..9f2876397dda
--- /dev/null
+++ b/include/scsi/libfc.h
@@ -0,0 +1,938 @@
+/*
+ * Copyright(c) 2007 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Maintained at www.Open-FCoE.org
+ */
+
+#ifndef _LIBFC_H_
+#define _LIBFC_H_
+
+#include <linux/timer.h>
+#include <linux/if.h>
+
+#include <scsi/scsi_transport.h>
+#include <scsi/scsi_transport_fc.h>
+
+#include <scsi/fc/fc_fcp.h>
+#include <scsi/fc/fc_ns.h>
+#include <scsi/fc/fc_els.h>
+#include <scsi/fc/fc_gs.h>
+
+#include <scsi/fc_frame.h>
+
+#define LIBFC_DEBUG
+
+#ifdef LIBFC_DEBUG
+/* Log messages */
+#define FC_DBG(fmt, args...)						\
+	do {								\
+		printk(KERN_INFO "%s " fmt, __func__, ##args);		\
+	} while (0)
+#else
+#define FC_DBG(fmt, args...)
+#endif
+
+/*
+ * libfc error codes
+ */
+#define	FC_NO_ERR	0	/* no error */
+#define	FC_EX_TIMEOUT	1	/* Exchange timeout */
+#define	FC_EX_CLOSED	2	/* Exchange closed */
+
+/* some helpful macros */
+
+#define ntohll(x) be64_to_cpu(x)
+#define htonll(x) cpu_to_be64(x)
+
+#define ntoh24(p) (((p)[0] << 16) | ((p)[1] << 8) | ((p)[2]))
+
+#define hton24(p, v)	do {			\
+		p[0] = (((v) >> 16) & 0xFF);	\
+		p[1] = (((v) >> 8) & 0xFF);	\
+		p[2] = ((v) & 0xFF);		\
+	} while (0)
+
+/*
+ * FC HBA status
+ */
+#define FC_PAUSE		    (1 << 1)
+#define FC_LINK_UP		    (1 << 0)
+
+enum fc_lport_state {
+	LPORT_ST_NONE = 0,
+	LPORT_ST_FLOGI,
+	LPORT_ST_DNS,
+	LPORT_ST_RPN_ID,
+	LPORT_ST_RFT_ID,
+	LPORT_ST_SCR,
+	LPORT_ST_READY,
+	LPORT_ST_LOGO,
+	LPORT_ST_RESET
+};
+
+enum fc_disc_event {
+	DISC_EV_NONE = 0,
+	DISC_EV_SUCCESS,
+	DISC_EV_FAILED
+};
+
+enum fc_rport_state {
+	RPORT_ST_NONE = 0,
+	RPORT_ST_INIT,		/* initialized */
+	RPORT_ST_PLOGI,		/* waiting for PLOGI completion */
+	RPORT_ST_PRLI,		/* waiting for PRLI completion */
+	RPORT_ST_RTV,		/* waiting for RTV completion */
+	RPORT_ST_READY,		/* ready for use */
+	RPORT_ST_LOGO,		/* port logout sent */
+};
+
+enum fc_rport_trans_state {
+	FC_PORTSTATE_ROGUE,
+	FC_PORTSTATE_REAL,
+};
+
+/**
+ * struct fc_disc_port - temporary discovery port to hold rport identifiers
+ * @lp: Fibre Channel host port instance
+ * @peers: node for list management during discovery and RSCN processing
+ * @ids: identifiers structure to pass to fc_remote_port_add()
+ * @rport_work: work struct for starting the rport state machine
+ */
+struct fc_disc_port {
+	struct fc_lport             *lp;
+	struct list_head            peers;
+	struct fc_rport_identifiers ids;
+	struct work_struct	    rport_work;
+};
+
+enum fc_rport_event {
+	RPORT_EV_NONE = 0,
+	RPORT_EV_CREATED,
+	RPORT_EV_FAILED,
+	RPORT_EV_STOP,
+	RPORT_EV_LOGO
+};
+
+struct fc_rport_operations {
+	void (*event_callback)(struct fc_lport *, struct fc_rport *,
+			       enum fc_rport_event);
+};
+
+/**
+ * struct fc_rport_libfc_priv - libfc internal information about a remote port
+ * @local_port: Fibre Channel host port instance
+ * @rp_state: state tracks progress of PLOGI, PRLI, and RTV exchanges
+ * @flags: REC and RETRY supported flags
+ * @max_seq: maximum number of concurrent sequences
+ * @retries: retry count in current state
+ * @e_d_tov: error detect timeout value (in msec)
+ * @r_a_tov: resource allocation timeout value (in msec)
+ * @rp_mutex: mutex protects rport
+ * @retry_work:
+ * @event_callback: Callback for rport READY, FAILED or LOGO
+ */
+struct fc_rport_libfc_priv {
+	struct fc_lport		   *local_port;
+	enum fc_rport_state        rp_state;
+	u16			   flags;
+	#define FC_RP_FLAGS_REC_SUPPORTED	(1 << 0)
+	#define FC_RP_FLAGS_RETRY		(1 << 1)
+	u16		           max_seq;
+	unsigned int	           retries;
+	unsigned int	           e_d_tov;
+	unsigned int	           r_a_tov;
+	enum fc_rport_trans_state  trans_state;
+	struct mutex               rp_mutex;
+	struct delayed_work	   retry_work;
+	enum fc_rport_event        event;
+	struct fc_rport_operations *ops;
+	struct list_head           peers;
+	struct work_struct         event_work;
+};
+
+#define PRIV_TO_RPORT(x)						\
+	(struct fc_rport *)((void *)x - sizeof(struct fc_rport));
+#define RPORT_TO_PRIV(x)						\
+	(struct fc_rport_libfc_priv *)((void *)x + sizeof(struct fc_rport));
+
+struct fc_rport *fc_rport_rogue_create(struct fc_disc_port *);
+
+static inline void fc_rport_set_name(struct fc_rport *rport, u64 wwpn, u64 wwnn)
+{
+	rport->node_name = wwnn;
+	rport->port_name = wwpn;
+}
+
+/*
+ * fcoe stats structure
+ */
+struct fcoe_dev_stats {
+	u64		SecondsSinceLastReset;
+	u64		TxFrames;
+	u64		TxWords;
+	u64		RxFrames;
+	u64		RxWords;
+	u64		ErrorFrames;
+	u64		DumpedFrames;
+	u64		LinkFailureCount;
+	u64		LossOfSignalCount;
+	u64		InvalidTxWordCount;
+	u64		InvalidCRCCount;
+	u64		InputRequests;
+	u64		OutputRequests;
+	u64		ControlRequests;
+	u64		InputMegabytes;
+	u64		OutputMegabytes;
+};
+
+/*
+ * els data is used for passing ELS respone specific
+ * data to send ELS response mainly using infomation
+ * in exchange and sequence in EM layer.
+ */
+struct fc_seq_els_data {
+	struct fc_frame *fp;
+	enum fc_els_rjt_reason reason;
+	enum fc_els_rjt_explan explan;
+};
+
+/*
+ * FCP request structure, one for each scsi cmd request
+ */
+struct fc_fcp_pkt {
+	/*
+	 * housekeeping stuff
+	 */
+	struct fc_lport *lp;	/* handle to hba struct */
+	u16		state;		/* scsi_pkt state state */
+	u16		tgt_flags;	/* target flags	 */
+	atomic_t	ref_cnt;	/* fcp pkt ref count */
+	spinlock_t	scsi_pkt_lock;	/* Must be taken before the host lock
+					 * if both are held at the same time */
+	/*
+	 * SCSI I/O related stuff
+	 */
+	struct scsi_cmnd *cmd;		/* scsi command pointer. set/clear
+					 * under host lock */
+	struct list_head list;		/* tracks queued commands. access under
+					 * host lock */
+	/*
+	 * timeout related stuff
+	 */
+	struct timer_list timer;	/* command timer */
+	struct completion tm_done;
+	int	wait_for_comp;
+	unsigned long	start_time;	/* start jiffie */
+	unsigned long	end_time;	/* end jiffie */
+	unsigned long	last_pkt_time;	 /* jiffies of last frame received */
+
+	/*
+	 * scsi cmd and data transfer information
+	 */
+	u32		data_len;
+	/*
+	 * transport related veriables
+	 */
+	struct fcp_cmnd cdb_cmd;
+	size_t		xfer_len;
+	u32		xfer_contig_end; /* offset of end of contiguous xfer */
+	u16		max_payload;	/* max payload size in bytes */
+
+	/*
+	 * scsi/fcp return status
+	 */
+	u32		io_status;	/* SCSI result upper 24 bits */
+	u8		cdb_status;
+	u8		status_code;	/* FCP I/O status */
+	/* bit 3 Underrun bit 2: overrun */
+	u8		scsi_comp_flags;
+	u32		req_flags;	/* bit 0: read bit:1 write */
+	u32		scsi_resid;	/* residule length */
+
+	struct fc_rport	*rport;		/* remote port pointer */
+	struct fc_seq	*seq_ptr;	/* current sequence pointer */
+	/*
+	 * Error Processing
+	 */
+	u8		recov_retry;	/* count of recovery retries */
+	struct fc_seq	*recov_seq;	/* sequence for REC or SRR */
+};
+
+/*
+ * Structure and function definitions for managing Fibre Channel Exchanges
+ * and Sequences
+ *
+ * fc_exch holds state for one exchange and links to its active sequence.
+ *
+ * fc_seq holds the state for an individual sequence.
+ */
+
+struct fc_exch_mgr;
+
+/*
+ * Sequence.
+ */
+struct fc_seq {
+	u8	id;		/* seq ID */
+	u16	ssb_stat;	/* status flags for sequence status block */
+	u16	cnt;		/* frames sent so far on sequence */
+	u32	rec_data;	/* FC-4 value for REC */
+};
+
+#define FC_EX_DONE		(1 << 0) /* ep is completed */
+#define FC_EX_RST_CLEANUP	(1 << 1) /* reset is forcing completion */
+
+/*
+ * Exchange.
+ *
+ * Locking notes: The ex_lock protects following items:
+ *	state, esb_stat, f_ctl, seq.ssb_stat
+ *	seq_id
+ *	sequence allocation
+ */
+struct fc_exch {
+	struct fc_exch_mgr *em;		/* exchange manager */
+	u32		state;		/* internal driver state */
+	u16		xid;		/* our exchange ID */
+	struct list_head	ex_list;	/* free or busy list linkage */
+	spinlock_t	ex_lock;	/* lock covering exchange state */
+	atomic_t	ex_refcnt;	/* reference counter */
+	struct delayed_work timeout_work; /* timer for upper level protocols */
+	struct fc_lport	*lp;		/* fc device instance */
+	u16		oxid;		/* originator's exchange ID */
+	u16		rxid;		/* responder's exchange ID */
+	u32		oid;		/* originator's FCID */
+	u32		sid;		/* source FCID */
+	u32		did;		/* destination FCID */
+	u32		esb_stat;	/* exchange status for ESB */
+	u32		r_a_tov;	/* r_a_tov from rport (msec) */
+	u8		seq_id;		/* next sequence ID to use */
+	u32		f_ctl;		/* F_CTL flags for sequences */
+	u8		fh_type;	/* frame type */
+	enum fc_class	class;		/* class of service */
+	struct fc_seq	seq;		/* single sequence */
+	/*
+	 * Handler for responses to this current exchange.
+	 */
+	void		(*resp)(struct fc_seq *, struct fc_frame *, void *);
+	void		(*destructor)(struct fc_seq *, void *);
+	/*
+	 * arg is passed as void pointer to exchange
+	 * resp and destructor handlers
+	 */
+	void		*arg;
+};
+#define	fc_seq_exch(sp) container_of(sp, struct fc_exch, seq)
+
+struct libfc_function_template {
+
+	/**
+	 * Mandatory Fields
+	 *
+	 * These handlers must be implemented by the LLD.
+	 */
+
+	/*
+	 * Interface to send a FC frame
+	 */
+	int (*frame_send)(struct fc_lport *lp, struct fc_frame *fp);
+
+	/**
+	 * Optional Fields
+	 *
+	 * The LLD may choose to implement any of the following handlers.
+	 * If LLD doesn't specify hander and leaves its pointer NULL then
+	 * the default libfc function will be used for that handler.
+	 */
+
+	/**
+	 * ELS/CT interfaces
+	 */
+
+	/*
+	 * elsct_send - sends ELS/CT frame
+	 */
+	struct fc_seq *(*elsct_send)(struct fc_lport *lport,
+				     struct fc_rport *rport,
+				     struct fc_frame *fp,
+				     unsigned int op,
+				     void (*resp)(struct fc_seq *,
+					     struct fc_frame *fp,
+					     void *arg),
+				     void *arg, u32 timer_msec);
+	/**
+	 * Exhance Manager interfaces
+	 */
+
+	/*
+	 * Send the FC frame payload using a new exchange and sequence.
+	 *
+	 * The frame pointer with some of the header's fields must be
+	 * filled before calling exch_seq_send(), those fields are,
+	 *
+	 * - routing control
+	 * - FC port did
+	 * - FC port sid
+	 * - FC header type
+	 * - frame control
+	 * - parameter or relative offset
+	 *
+	 * The exchange response handler is set in this routine to resp()
+	 * function pointer. It can be called in two scenarios: if a timeout
+	 * occurs or if a response frame is received for the exchange. The
+	 * fc_frame pointer in response handler will also indicate timeout
+	 * as error using IS_ERR related macros.
+	 *
+	 * The exchange destructor handler is also set in this routine.
+	 * The destructor handler is invoked by EM layer when exchange
+	 * is about to free, this can be used by caller to free its
+	 * resources along with exchange free.
+	 *
+	 * The arg is passed back to resp and destructor handler.
+	 *
+	 * The timeout value (in msec) for an exchange is set if non zero
+	 * timer_msec argument is specified. The timer is canceled when
+	 * it fires or when the exchange is done. The exchange timeout handler
+	 * is registered by EM layer.
+	 */
+	struct fc_seq *(*exch_seq_send)(struct fc_lport *lp,
+					struct fc_frame *fp,
+					void (*resp)(struct fc_seq *sp,
+						     struct fc_frame *fp,
+						     void *arg),
+					void (*destructor)(struct fc_seq *sp,
+							   void *arg),
+					void *arg, unsigned int timer_msec);
+
+	/*
+	 * send a frame using existing sequence and exchange.
+	 */
+	int (*seq_send)(struct fc_lport *lp, struct fc_seq *sp,
+			struct fc_frame *fp);
+
+	/*
+	 * Send ELS response using mainly infomation
+	 * in exchange and sequence in EM layer.
+	 */
+	void (*seq_els_rsp_send)(struct fc_seq *sp, enum fc_els_cmd els_cmd,
+				 struct fc_seq_els_data *els_data);
+
+	/*
+	 * Abort an exchange and sequence. Generally called because of a
+	 * exchange timeout or an abort from the upper layer.
+	 *
+	 * A timer_msec can be specified for abort timeout, if non-zero
+	 * timer_msec value is specified then exchange resp handler
+	 * will be called with timeout error if no response to abort.
+	 */
+	int (*seq_exch_abort)(const struct fc_seq *req_sp,
+			      unsigned int timer_msec);
+
+	/*
+	 * Indicate that an exchange/sequence tuple is complete and the memory
+	 * allocated for the related objects may be freed.
+	 */
+	void (*exch_done)(struct fc_seq *sp);
+
+	/*
+	 * Assigns a EM and a free XID for an new exchange and then
+	 * allocates a new exchange and sequence pair.
+	 * The fp can be used to determine free XID.
+	 */
+	struct fc_exch *(*exch_get)(struct fc_lport *lp, struct fc_frame *fp);
+
+	/*
+	 * Release previously assigned XID by exch_get API.
+	 * The LLD may implement this if XID is assigned by LLD
+	 * in exch_get().
+	 */
+	void (*exch_put)(struct fc_lport *lp, struct fc_exch_mgr *mp,
+			 u16 ex_id);
+
+	/*
+	 * Start a new sequence on the same exchange/sequence tuple.
+	 */
+	struct fc_seq *(*seq_start_next)(struct fc_seq *sp);
+
+	/*
+	 * Reset an exchange manager, completing all sequences and exchanges.
+	 * If s_id is non-zero, reset only exchanges originating from that FID.
+	 * If d_id is non-zero, reset only exchanges sending to that FID.
+	 */
+	void (*exch_mgr_reset)(struct fc_exch_mgr *,
+			       u32 s_id, u32 d_id);
+
+	void (*rport_flush_queue)(void);
+	/**
+	 * Local Port interfaces
+	 */
+
+	/*
+	 * Receive a frame to a local port.
+	 */
+	void (*lport_recv)(struct fc_lport *lp, struct fc_seq *sp,
+			   struct fc_frame *fp);
+
+	int (*lport_reset)(struct fc_lport *);
+
+	/**
+	 * Remote Port interfaces
+	 */
+
+	/*
+	 * Initiates the RP state machine. It is called from the LP module.
+	 * This function will issue the following commands to the N_Port
+	 * identified by the FC ID provided.
+	 *
+	 * - PLOGI
+	 * - PRLI
+	 * - RTV
+	 */
+	int (*rport_login)(struct fc_rport *rport);
+
+	/*
+	 * Logoff, and remove the rport from the transport if
+	 * it had been added. This will send a LOGO to the target.
+	 */
+	int (*rport_logoff)(struct fc_rport *rport);
+
+	/*
+	 * Recieve a request from a remote port.
+	 */
+	void (*rport_recv_req)(struct fc_seq *, struct fc_frame *,
+			       struct fc_rport *);
+
+	struct fc_rport *(*rport_lookup)(const struct fc_lport *, u32);
+
+	/**
+	 * FCP interfaces
+	 */
+
+	/*
+	 * Send a fcp cmd from fsp pkt.
+	 * Called with the SCSI host lock unlocked and irqs disabled.
+	 *
+	 * The resp handler is called when FCP_RSP received.
+	 *
+	 */
+	int (*fcp_cmd_send)(struct fc_lport *lp, struct fc_fcp_pkt *fsp,
+			    void (*resp)(struct fc_seq *, struct fc_frame *fp,
+					 void *arg));
+
+	/*
+	 * Used at least durring linkdown and reset
+	 */
+	void (*fcp_cleanup)(struct fc_lport *lp);
+
+	/*
+	 * Abort all I/O on a local port
+	 */
+	void (*fcp_abort_io)(struct fc_lport *lp);
+
+	/**
+	 * Discovery interfaces
+	 */
+
+	void (*disc_recv_req)(struct fc_seq *,
+			      struct fc_frame *, struct fc_lport *);
+
+	/*
+	 * Start discovery for a local port.
+	 */
+	void (*disc_start)(void (*disc_callback)(struct fc_lport *,
+						 enum fc_disc_event),
+			   struct fc_lport *);
+
+	/*
+	 * Stop discovery for a given lport. This will remove
+	 * all discovered rports
+	 */
+	void (*disc_stop) (struct fc_lport *);
+
+	/*
+	 * Stop discovery for a given lport. This will block
+	 * until all discovered rports are deleted from the
+	 * FC transport class
+	 */
+	void (*disc_stop_final) (struct fc_lport *);
+};
+
+/* information used by the discovery layer */
+struct fc_disc {
+	unsigned char		retry_count;
+	unsigned char		delay;
+	unsigned char		pending;
+	unsigned char		requested;
+	unsigned short		seq_count;
+	unsigned char		buf_len;
+	enum fc_disc_event	event;
+
+	void (*disc_callback)(struct fc_lport *,
+			      enum fc_disc_event);
+
+	struct list_head	 rports;
+	struct fc_lport		*lport;
+	struct mutex		disc_mutex;
+	struct fc_gpn_ft_resp	partial_buf;	/* partial name buffer */
+	struct delayed_work	disc_work;
+};
+
+struct fc_lport {
+	struct list_head list;
+
+	/* Associations */
+	struct Scsi_Host	*host;
+	struct fc_exch_mgr	*emp;
+	struct fc_rport		*dns_rp;
+	struct fc_rport		*ptp_rp;
+	void			*scsi_priv;
+	struct fc_disc          disc;
+
+	/* Operational Information */
+	struct libfc_function_template tt;
+	u16			link_status;
+	enum fc_lport_state	state;
+	unsigned long		boot_time;
+
+	struct fc_host_statistics host_stats;
+	struct fcoe_dev_stats	*dev_stats[NR_CPUS];
+	u64			wwpn;
+	u64			wwnn;
+	u8			retry_count;
+
+	/* Capabilities */
+	u32			sg_supp:1;	/* scatter gather supported */
+	u32			seq_offload:1;	/* seq offload supported */
+	u32			crc_offload:1;	/* crc offload supported */
+	u32			lro_enabled:1;	/* large receive offload */
+	u32			mfs;	        /* max FC payload size */
+	unsigned int		service_params;
+	unsigned int		e_d_tov;
+	unsigned int		r_a_tov;
+	u8			max_retry_count;
+	u16			link_speed;
+	u16			link_supported_speeds;
+	u16			lro_xid;	/* max xid for fcoe lro */
+	struct fc_ns_fts	fcts;	        /* FC-4 type masks */
+	struct fc_els_rnid_gen	rnid_gen;	/* RNID information */
+
+	/* Semaphores */
+	struct mutex lp_mutex;
+
+	/* Miscellaneous */
+	struct delayed_work	retry_work;
+	struct delayed_work	disc_work;
+};
+
+/**
+ * FC_LPORT HELPER FUNCTIONS
+ *****************************/
+static inline void *lport_priv(const struct fc_lport *lp)
+{
+	return (void *)(lp + 1);
+}
+
+static inline int fc_lport_test_ready(struct fc_lport *lp)
+{
+	return lp->state == LPORT_ST_READY;
+}
+
+static inline void fc_set_wwnn(struct fc_lport *lp, u64 wwnn)
+{
+	lp->wwnn = wwnn;
+}
+
+static inline void fc_set_wwpn(struct fc_lport *lp, u64 wwnn)
+{
+	lp->wwpn = wwnn;
+}
+
+static inline void fc_lport_state_enter(struct fc_lport *lp,
+					enum fc_lport_state state)
+{
+	if (state != lp->state)
+		lp->retry_count = 0;
+	lp->state = state;
+}
+
+
+/**
+ * LOCAL PORT LAYER
+ *****************************/
+int fc_lport_init(struct fc_lport *lp);
+
+/*
+ * Destroy the specified local port by finding and freeing all
+ * fc_rports associated with it and then by freeing the fc_lport
+ * itself.
+ */
+int fc_lport_destroy(struct fc_lport *lp);
+
+/*
+ * Logout the specified local port from the fabric
+ */
+int fc_fabric_logoff(struct fc_lport *lp);
+
+/*
+ * Initiate the LP state machine. This handler will use fc_host_attr
+ * to store the FLOGI service parameters, so fc_host_attr must be
+ * initialized before calling this handler.
+ */
+int fc_fabric_login(struct fc_lport *lp);
+
+/*
+ * The link is up for the given local port.
+ */
+void fc_linkup(struct fc_lport *);
+
+/*
+ * Link is down for the given local port.
+ */
+void fc_linkdown(struct fc_lport *);
+
+/*
+ * Pause and unpause traffic.
+ */
+void fc_pause(struct fc_lport *);
+void fc_unpause(struct fc_lport *);
+
+/*
+ * Configure the local port.
+ */
+int fc_lport_config(struct fc_lport *);
+
+/*
+ * Reset the local port.
+ */
+int fc_lport_reset(struct fc_lport *);
+
+/*
+ * Set the mfs or reset
+ */
+int fc_set_mfs(struct fc_lport *lp, u32 mfs);
+
+
+/**
+ * REMOTE PORT LAYER
+ *****************************/
+int fc_rport_init(struct fc_lport *lp);
+void fc_rport_terminate_io(struct fc_rport *rp);
+
+/**
+ * DISCOVERY LAYER
+ *****************************/
+int fc_disc_init(struct fc_lport *lp);
+
+
+/**
+ * SCSI LAYER
+ *****************************/
+/*
+ * Initialize the SCSI block of libfc
+ */
+int fc_fcp_init(struct fc_lport *);
+
+/*
+ * This section provides an API which allows direct interaction
+ * with the SCSI-ml. Each of these functions satisfies a function
+ * pointer defined in Scsi_Host and therefore is always called
+ * directly from the SCSI-ml.
+ */
+int fc_queuecommand(struct scsi_cmnd *sc_cmd,
+		    void (*done)(struct scsi_cmnd *));
+
+/*
+ * complete processing of a fcp packet
+ *
+ * This function may sleep if a fsp timer is pending.
+ * The host lock must not be held by caller.
+ */
+void fc_fcp_complete(struct fc_fcp_pkt *fsp);
+
+/*
+ * Send an ABTS frame to the target device. The sc_cmd argument
+ * is a pointer to the SCSI command to be aborted.
+ */
+int fc_eh_abort(struct scsi_cmnd *sc_cmd);
+
+/*
+ * Reset a LUN by sending send the tm cmd to the target.
+ */
+int fc_eh_device_reset(struct scsi_cmnd *sc_cmd);
+
+/*
+ * Reset the host adapter.
+ */
+int fc_eh_host_reset(struct scsi_cmnd *sc_cmd);
+
+/*
+ * Check rport status.
+ */
+int fc_slave_alloc(struct scsi_device *sdev);
+
+/*
+ * Adjust the queue depth.
+ */
+int fc_change_queue_depth(struct scsi_device *sdev, int qdepth);
+
+/*
+ * Change the tag type.
+ */
+int fc_change_queue_type(struct scsi_device *sdev, int tag_type);
+
+/*
+ * Free memory pools used by the FCP layer.
+ */
+void fc_fcp_destroy(struct fc_lport *);
+
+/**
+ * ELS/CT interface
+ *****************************/
+/*
+ * Initializes ELS/CT interface
+ */
+int fc_elsct_init(struct fc_lport *lp);
+
+
+/**
+ * EXCHANGE MANAGER LAYER
+ *****************************/
+/*
+ * Initializes Exchange Manager related
+ * function pointers in struct libfc_function_template.
+ */
+int fc_exch_init(struct fc_lport *lp);
+
+/*
+ * Allocates an Exchange Manager (EM).
+ *
+ * The EM manages exchanges for their allocation and
+ * free, also allows exchange lookup for received
+ * frame.
+ *
+ * The class is used for initializing FC class of
+ * allocated exchange from EM.
+ *
+ * The min_xid and max_xid will limit new
+ * exchange ID (XID) within this range for
+ * a new exchange.
+ * The LLD may choose to have multiple EMs,
+ * e.g. one EM instance per CPU receive thread in LLD.
+ * The LLD can use exch_get() of struct libfc_function_template
+ * to specify XID for a new exchange within
+ * a specified EM instance.
+ *
+ * The em_idx to uniquely identify an EM instance.
+ */
+struct fc_exch_mgr *fc_exch_mgr_alloc(struct fc_lport *lp,
+				      enum fc_class class,
+				      u16 min_xid,
+				      u16 max_xid);
+
+/*
+ * Free an exchange manager.
+ */
+void fc_exch_mgr_free(struct fc_exch_mgr *mp);
+
+/*
+ * Receive a frame on specified local port and exchange manager.
+ */
+void fc_exch_recv(struct fc_lport *lp, struct fc_exch_mgr *mp,
+		  struct fc_frame *fp);
+
+/*
+ * This function is for exch_seq_send function pointer in
+ * struct libfc_function_template, see comment block on
+ * exch_seq_send for description of this function.
+ */
+struct fc_seq *fc_exch_seq_send(struct fc_lport *lp,
+				struct fc_frame *fp,
+				void (*resp)(struct fc_seq *sp,
+					     struct fc_frame *fp,
+					     void *arg),
+				void (*destructor)(struct fc_seq *sp,
+						   void *arg),
+				void *arg, u32 timer_msec);
+
+/*
+ * send a frame using existing sequence and exchange.
+ */
+int fc_seq_send(struct fc_lport *lp, struct fc_seq *sp, struct fc_frame *fp);
+
+/*
+ * Send ELS response using mainly infomation
+ * in exchange and sequence in EM layer.
+ */
+void fc_seq_els_rsp_send(struct fc_seq *sp, enum fc_els_cmd els_cmd,
+			 struct fc_seq_els_data *els_data);
+
+/*
+ * This function is for seq_exch_abort function pointer in
+ * struct libfc_function_template, see comment block on
+ * seq_exch_abort for description of this function.
+ */
+int fc_seq_exch_abort(const struct fc_seq *req_sp, unsigned int timer_msec);
+
+/*
+ * Indicate that an exchange/sequence tuple is complete and the memory
+ * allocated for the related objects may be freed.
+ */
+void fc_exch_done(struct fc_seq *sp);
+
+/*
+ * Assigns a EM and XID for a frame and then allocates
+ * a new exchange and sequence pair.
+ * The fp can be used to determine free XID.
+ */
+struct fc_exch *fc_exch_get(struct fc_lport *lp, struct fc_frame *fp);
+
+/*
+ * Allocate a new exchange and sequence pair.
+ * if ex_id is zero then next free exchange id
+ * from specified exchange manger mp will be assigned.
+ */
+struct fc_exch *fc_exch_alloc(struct fc_exch_mgr *mp,
+			      struct fc_frame *fp, u16 ex_id);
+/*
+ * Start a new sequence on the same exchange as the supplied sequence.
+ */
+struct fc_seq *fc_seq_start_next(struct fc_seq *sp);
+
+/*
+ * Reset an exchange manager, completing all sequences and exchanges.
+ * If s_id is non-zero, reset only exchanges originating from that FID.
+ * If d_id is non-zero, reset only exchanges sending to that FID.
+ */
+void fc_exch_mgr_reset(struct fc_exch_mgr *, u32 s_id, u32 d_id);
+
+/*
+ * Functions for fc_functions_template
+ */
+void fc_get_host_speed(struct Scsi_Host *shost);
+void fc_get_host_port_type(struct Scsi_Host *shost);
+void fc_get_host_port_state(struct Scsi_Host *shost);
+void fc_set_rport_loss_tmo(struct fc_rport *rport, u32 timeout);
+struct fc_host_statistics *fc_get_host_stats(struct Scsi_Host *);
+
+/*
+ * module setup functions.
+ */
+int fc_setup_exch_mgr(void);
+void fc_destroy_exch_mgr(void);
+int fc_setup_rport(void);
+void fc_destroy_rport(void);
+
+#endif /* _LIBFC_H_ */
