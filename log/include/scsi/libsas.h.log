commit ba6d10ab8014ac10d25ca513352b6665e73b5785
Merge: 64b08df460cf baf23eddbf2a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 11 15:14:01 2019 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This is mostly update of the usual drivers: qla2xxx, hpsa, lpfc, ufs,
      mpt3sas, ibmvscsi, megaraid_sas, bnx2fc and hisi_sas as well as the
      removal of the osst driver (I heard from Willem privately that he
      would like the driver removed because all his test hardware has
      failed). Plus number of minor changes, spelling fixes and other
      trivia.
    
      The big merge conflict this time around is the SPDX licence tags.
      Following discussion on linux-next, we believe our version to be more
      accurate than the one in the tree, so the resolution is to take our
      version for all the SPDX conflicts"
    
    Note on the SPDX license tag conversion conflicts: the SCSI tree had
    done its own SPDX conversion, which in some cases conflicted with the
    treewide ones done by Thomas & co.
    
    In almost all cases, the conflicts were purely syntactic: the SCSI tree
    used the old-style SPDX tags ("GPL-2.0" and "GPL-2.0+") while the
    treewide conversion had used the new-style ones ("GPL-2.0-only" and
    "GPL-2.0-or-later").
    
    In these cases I picked the new-style one.
    
    In a few cases, the SPDX conversion was actually different, though.  As
    explained by James above, and in more detail in a pre-pull-request
    thread:
    
     "The other problem is actually substantive: In the libsas code Luben
      Tuikov originally specified gpl 2.0 only by dint of stating:
    
      * This file is licensed under GPLv2.
    
      In all the libsas files, but then muddied the water by quoting GPLv2
      verbatim (which includes the or later than language). So for these
      files Christoph did the conversion to v2 only SPDX tags and Thomas
      converted to v2 or later tags"
    
    So in those cases, where the spdx tag substantially mattered, I took the
    SCSI tree conversion of it, but then also took the opportunity to turn
    the old-style "GPL-2.0" into a new-style "GPL-2.0-only" tag.
    
    Similarly, when there were whitespace differences or other differences
    to the comments around the copyright notices, I took the version from
    the SCSI tree as being the more specific conversion.
    
    Finally, in the spdx conversions that had no conflicts (because the
    treewide ones hadn't been done for those files), I just took the SCSI
    tree version as-is, even if it was old-style.  The old-style conversions
    are perfectly valid, even if the "-only" and "-or-later" versions are
    perhaps more descriptive.
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (185 commits)
      scsi: qla2xxx: move IO flush to the front of NVME rport unregistration
      scsi: qla2xxx: Fix NVME cmd and LS cmd timeout race condition
      scsi: qla2xxx: on session delete, return nvme cmd
      scsi: qla2xxx: Fix kernel crash after disconnecting NVMe devices
      scsi: megaraid_sas: Update driver version to 07.710.06.00-rc1
      scsi: megaraid_sas: Introduce various Aero performance modes
      scsi: megaraid_sas: Use high IOPS queues based on IO workload
      scsi: megaraid_sas: Set affinity for high IOPS reply queues
      scsi: megaraid_sas: Enable coalescing for high IOPS queues
      scsi: megaraid_sas: Add support for High IOPS queues
      scsi: megaraid_sas: Add support for MPI toolbox commands
      scsi: megaraid_sas: Offload Aero RAID5/6 division calculations to driver
      scsi: megaraid_sas: RAID1 PCI bandwidth limit algorithm is applicable for only Ventura
      scsi: megaraid_sas: megaraid_sas: Add check for count returned by HOST_DEVICE_LIST DCMD
      scsi: megaraid_sas: Handle sequence JBOD map failure at driver level
      scsi: megaraid_sas: Don't send FPIO to RL Bypass queue
      scsi: megaraid_sas: In probe context, retry IOC INIT once if firmware is in fault
      scsi: megaraid_sas: Release Mutex lock before OCR in case of DCMD timeout
      scsi: megaraid_sas: Call disable_irq from process IRQ poll
      scsi: megaraid_sas: Remove few debug counters from IO path
      ...

commit 924a3541eab0d28101baf0831e4315593f06ba4a
Author: John Garry <john.garry@huawei.com>
Date:   Mon Jun 10 20:41:41 2019 +0800

    scsi: libsas: aic94xx: hisi_sas: mvsas: pm8001: Use dev_is_expander()
    
    Many times in libsas, and in LLDDs which use libsas, the check for an
    expander device is re-implemented or open coded.
    
    Use dev_is_expander() instead. We rename this from
    sas_dev_type_is_expander() to not spill so many lines in referencing.
    
    Signed-off-by: John Garry <john.garry@huawei.com>
    Reviewed-by: Jason Yan <yanaijie@huawei.com>
    Reviewed-by: Jack Wang <jinpu.wang@cloud.ionos.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 901355a1bc53..a8565a87291d 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -207,8 +207,7 @@ struct sas_work {
 	struct work_struct work;
 };
 
-/* Lots of code duplicates this in the SCSI tree, which can be factored out */
-static inline bool sas_dev_type_is_expander(enum sas_device_type type)
+static inline bool dev_is_expander(enum sas_device_type type)
 {
 	return type == SAS_EDGE_EXPANDER_DEVICE ||
 	       type == SAS_FANOUT_EXPANDER_DEVICE;

commit 5078709e89eff421d49c02392623da68ae356c3e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 09:19:00 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 59
    
    Based on 1 normalized pattern(s):
    
      this file is licensed under gplv2 this program is free software you
      can redistribute it and or modify it under the terms of the gnu
      general public license as published by the free software foundation
      either version 2 of the license or at your option any later version
      this program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details you should have received a
      copy of the gnu general public license along with this program if
      not write to the free software foundation inc 59 temple place suite
      330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 5 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520071858.561902672@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index b08febec7895..e9664bb7d188 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -1,26 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * SAS host prototypes and structures header file
  *
  * Copyright (C) 2005 Adaptec, Inc.  All rights reserved.
  * Copyright (C) 2005 Luben Tuikov <luben_tuikov@adaptec.com>
- *
- * This file is licensed under GPLv2.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA
- *
  */
 
 #ifndef _LIBSAS_H_

commit 86b89cb0d26c4050a1916094fcd867f34f44af66
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed May 1 12:14:10 2019 -0400

    scsi: libsas: switch remaining files to SPDX tags
    
    Use the the GPLv2 SPDX tag instead of verbose boilerplate text.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index b08febec7895..901355a1bc53 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -1,26 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * SAS host prototypes and structures header file
  *
  * Copyright (C) 2005 Adaptec, Inc.  All rights reserved.
  * Copyright (C) 2005 Luben Tuikov <luben_tuikov@adaptec.com>
- *
- * This file is licensed under GPLv2.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA
- *
  */
 
 #ifndef _LIBSAS_H_

commit 085f104a83d565097644889bf1f6f1aa6d345cb5
Author: John Garry <john.garry@huawei.com>
Date:   Fri Apr 12 16:57:55 2019 +0800

    scsi: libsas: Inject revalidate event for root port event
    
    According to the SAS spec, an expander device shall transmit BROADCAST
    (CHANGE) from at least one phy in each expander port other than the
    expander port that is the cause for transmitting BROADCAST (CHANGE).
    
    As such, for when the link is lost for a root PHY attached to an expander
    PHY, we get no broadcast event.
    
    This causes an issue for libsas, in that we will not revalidate the domain
    for these events.
    
    As a solution, for when a root PHY is formed or deformed from a root port,
    insert a broadcast event to trigger a domain revalidation.
    
    Signed-off-by: John Garry <john.garry@huawei.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index cfaaf1254211..b08febec7895 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -224,6 +224,13 @@ struct sas_work {
 	struct work_struct work;
 };
 
+/* Lots of code duplicates this in the SCSI tree, which can be factored out */
+static inline bool sas_dev_type_is_expander(enum sas_device_type type)
+{
+	return type == SAS_EDGE_EXPANDER_DEVICE ||
+	       type == SAS_FANOUT_EXPANDER_DEVICE;
+}
+
 static inline void INIT_SAS_WORK(struct sas_work *sw, void (*fn)(struct work_struct *))
 {
 	INIT_WORK(&sw->work, fn);

commit 7b27c5fe247b4288f41551ced5bf458f58dc77b8
Author: John Garry <john.garry@huawei.com>
Date:   Fri Apr 12 16:57:52 2019 +0800

    scsi: libsas: Stop hardcoding SAS address length
    
    Many times we use 8 for SAS address length, while we already have a macro
    for this - SAS_ADDR_SIZE.
    
    Replace instances of this with the macro. However, don't touch the SAS
    address array sizes sas.h, as these are defined according to the SAS spec.
    
    Some missing whitespaces are also added, and whitespace indentation
    in sas_hash_addr() is also fixed (see sas_hash_addr()).
    
    Signed-off-by: John Garry <john.garry@huawei.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 56b2dba7d911..cfaaf1254211 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -245,9 +245,9 @@ static inline struct sas_discovery_event *to_sas_discovery_event(struct work_str
 struct sas_discovery {
 	struct sas_discovery_event disc_work[DISC_NUM_EVENTS];
 	unsigned long    pending;
-	u8     fanout_sas_addr[8];
-	u8     eeds_a[8];
-	u8     eeds_b[8];
+	u8     fanout_sas_addr[SAS_ADDR_SIZE];
+	u8     eeds_a[SAS_ADDR_SIZE];
+	u8     eeds_b[SAS_ADDR_SIZE];
 	int    max_level;
 };
 

commit 6f4e626fb0cc93d50b49b79c2ee33bd769ee57f0
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Thu Feb 7 09:07:20 2019 -0700

    scsi: ata: Use unsigned int for cmd's type in ioctls in scsi_host_template
    
    Clang warns several times in the scsi subsystem (trimmed for brevity):
    
    drivers/scsi/hpsa.c:6209:7: warning: overflow converting case value to
    switch condition type (2147762695 to 18446744071562347015) [-Wswitch]
            case CCISS_GETBUSTYPES:
                 ^
    drivers/scsi/hpsa.c:6208:7: warning: overflow converting case value to
    switch condition type (2147762694 to 18446744071562347014) [-Wswitch]
            case CCISS_GETHEARTBEAT:
                 ^
    
    The root cause is that the _IOC macro can generate really large numbers,
    which don't fit into type 'int', which is used for the cmd parameter in
    the ioctls in scsi_host_template. My research into how GCC and Clang are
    handling this at a low level didn't prove fruitful. However, looking at
    the rest of the kernel tree, all ioctls use an 'unsigned int' for the
    cmd parameter, which will fit all of the _IOC values in the scsi/ata
    subsystems.
    
    Make that change because none of the ioctls expect a negative value for
    any command, it brings the ioctls inline with the reset of the kernel,
    and it removes ambiguity, which is never good when dealing with compilers.
    
    Link: https://github.com/ClangBuiltLinux/linux/issues/85
    Link: https://github.com/ClangBuiltLinux/linux/issues/154
    Link: https://github.com/ClangBuiltLinux/linux/issues/157
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Acked-by: Bradley Grove <bgrove@attotech.com>
    Acked-by: Don Brace <don.brace@microsemi.com>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Tested-by: Nick Desaulniers <ndesaulniers@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 857086cf7ebf..56b2dba7d911 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -707,7 +707,8 @@ int sas_eh_target_reset_handler(struct scsi_cmnd *cmd);
 
 extern void sas_target_destroy(struct scsi_target *);
 extern int sas_slave_alloc(struct scsi_device *);
-extern int sas_ioctl(struct scsi_device *sdev, int cmd, void __user *arg);
+extern int sas_ioctl(struct scsi_device *sdev, unsigned int cmd,
+		     void __user *arg);
 extern int sas_drain_work(struct sas_ha_struct *ha);
 
 extern void sas_ssp_task_response(struct device *dev, struct sas_task *task,

commit ff525b6e2d3011d5a1ef08d8b3f4f745c7245412
Author: John Garry <john.garry@huawei.com>
Date:   Sat Jan 5 00:01:26 2019 +0800

    scsi: libsas: Fix some indentation in libsas.h
    
    Currently much indentation in this file is done with whitespaces instead of
    tabs, which can make reading difficult, so fix this up.
    
    Some other little minor tidy-up is done, but this file still has many other
    checkpatch warnings (generally linelength > 80 or function arguments have
    no identifier names).
    
    All libsas code can be audited for checkpatch issues later.
    
    Signed-off-by: John Garry <john.garry@huawei.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 3de3b10da19a..857086cf7ebf 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -52,8 +52,8 @@ enum sas_phy_role {
 };
 
 enum sas_phy_type {
-        PHY_TYPE_PHYSICAL,
-        PHY_TYPE_VIRTUAL
+	PHY_TYPE_PHYSICAL,
+	PHY_TYPE_VIRTUAL
 };
 
 /* The events are mnemonically described in sas_dump.c
@@ -91,7 +91,7 @@ enum discover_event {
 
 #define to_dom_device(_obj) container_of(_obj, struct domain_device, dev_obj)
 #define to_dev_attr(_attr)  container_of(_attr, struct domain_dev_attribute,\
-                                         attr)
+					 attr)
 
 enum routing_attribute {
 	DIRECT_ROUTING,
@@ -184,37 +184,37 @@ struct domain_device {
 	spinlock_t done_lock;
 	enum sas_device_type dev_type;
 
-        enum sas_linkrate linkrate;
-        enum sas_linkrate min_linkrate;
-        enum sas_linkrate max_linkrate;
+	enum sas_linkrate linkrate;
+	enum sas_linkrate min_linkrate;
+	enum sas_linkrate max_linkrate;
 
-        int  pathways;
+	int  pathways;
 
-        struct domain_device *parent;
-        struct list_head siblings; /* devices on the same level */
-        struct asd_sas_port *port;        /* shortcut to root of the tree */
+	struct domain_device *parent;
+	struct list_head siblings; /* devices on the same level */
+	struct asd_sas_port *port;        /* shortcut to root of the tree */
 	struct sas_phy *phy;
 
-        struct list_head dev_list_node;
+	struct list_head dev_list_node;
 	struct list_head disco_list_node; /* awaiting probe or destruct */
 
-        enum sas_protocol    iproto;
-        enum sas_protocol    tproto;
+	enum sas_protocol    iproto;
+	enum sas_protocol    tproto;
 
-        struct sas_rphy *rphy;
+	struct sas_rphy *rphy;
 
-        u8  sas_addr[SAS_ADDR_SIZE];
-        u8  hashed_sas_addr[HASHED_SAS_ADDR_SIZE];
+	u8  sas_addr[SAS_ADDR_SIZE];
+	u8  hashed_sas_addr[HASHED_SAS_ADDR_SIZE];
 
-        u8  frame_rcvd[32];
+	u8  frame_rcvd[32];
 
-        union {
-                struct expander_device ex_dev;
-                struct sata_device     sata_dev; /* STP & directly attached */
+	union {
+		struct expander_device ex_dev;
+		struct sata_device     sata_dev; /* STP & directly attached */
 		struct ssp_device      ssp_dev;
-        };
+	};
 
-        void *lldd_dev;
+	void *lldd_dev;
 	unsigned long state;
 	struct kref kref;
 };
@@ -512,10 +512,10 @@ enum exec_status {
 
 /* When a task finishes with a response, the LLDD examines the
  * response:
- * 	- For an ATA task task_status_struct::stat is set to
+ *	- For an ATA task task_status_struct::stat is set to
  * SAS_PROTO_RESPONSE, and the task_status_struct::buf is set to the
  * contents of struct ata_task_resp.
- * 	- For SSP tasks, if no data is present or status/TMF response
+ *	- For SSP tasks, if no data is present or status/TMF response
  * is valid, task_status_struct::stat is set.  If data is present
  * (SENSE data), the LLDD copies up to SAS_STATUS_BUF_SIZE, sets
  * task_status_struct::buf_valid_size, and task_status_struct::stat is
@@ -671,15 +671,13 @@ extern void sas_prep_resume_ha(struct sas_ha_struct *sas_ha);
 extern void sas_resume_ha(struct sas_ha_struct *sas_ha);
 extern void sas_suspend_ha(struct sas_ha_struct *sas_ha);
 
-int sas_set_phy_speed(struct sas_phy *phy,
-		      struct sas_phy_linkrates *rates);
+int sas_set_phy_speed(struct sas_phy *phy, struct sas_phy_linkrates *rates);
 int sas_phy_reset(struct sas_phy *phy, int hard_reset);
-extern int sas_queuecommand(struct Scsi_Host * ,struct scsi_cmnd *);
+extern int sas_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);
 extern int sas_target_alloc(struct scsi_target *);
 extern int sas_slave_configure(struct scsi_device *);
 extern int sas_change_queue_depth(struct scsi_device *, int new_depth);
-extern int sas_bios_param(struct scsi_device *,
-			  struct block_device *,
+extern int sas_bios_param(struct scsi_device *, struct block_device *,
 			  sector_t capacity, int *hsc);
 extern struct scsi_transport_template *
 sas_domain_attach_transport(struct sas_domain_function_template *);

commit 2fa4a32613c9182b00e46872755b0662374424a7
Author: Jason Yan <yanaijie@huawei.com>
Date:   Thu May 10 11:05:16 2018 +0800

    scsi: libsas: dynamically allocate and free ata host
    
    Commit 2623c7a5f2 ("libata: add refcounting to ata_host") v4.17+ introduced
    refcounting to ata_host and will increase or decrease the refcount when
    adding or deleting transport ATA port.
    
    Now the ata host for libsas is embedded in domain_device, and the ->kref
    member is not initialized. Afer we add ata transport class, ata_host_get()
    will be called when adding transport ATA port and a warning will be
    triggered as below:
    
    refcount_t: increment on 0; use-after-free.
    WARNING: CPU: 2 PID: 103 at
    lib/refcount.c:153 refcount_inc+0x40/0x48 ......  Call trace:
     refcount_inc+0x40/0x48
     ata_host_get+0x10/0x18
     ata_tport_add+0x40/0x120
     ata_sas_tport_add+0xc/0x14
     sas_ata_init+0x7c/0xc8
     sas_discover_domain+0x380/0x53c
     process_one_work+0x12c/0x288
     worker_thread+0x58/0x3f0
     kthread+0xfc/0x128
     ret_from_fork+0x10/0x18
    
    And also when removing transport ATA port ata_host_put() will be called and
    another similar warning will be triggered. If the refcount decreased to
    zero, the ata host will be freed. But this ata host is only part of
    domain_device, it cannot be freed directly.
    
    So we have to change this embedded static ata host to a dynamically
    allocated ata host and initialize the ->kref member. To use ata_host_get()
    and ata_host_put() in libsas, we need to move the declaration of these
    functions to the public libata.h and export them.
    
    Fixes: b6240a4df018 ("scsi: libsas: add transport class for ATA devices")
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    CC: John Garry <john.garry@huawei.com>
    CC: Taras Kondratiuk <takondra@cisco.com>
    CC: Tejun Heo <tj@kernel.org>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 225ab7783dfd..3de3b10da19a 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -161,7 +161,7 @@ struct sata_device {
 	u8     port_no;        /* port number, if this is a PM (Port) */
 
 	struct ata_port *ap;
-	struct ata_host ata_host;
+	struct ata_host *ata_host;
 	struct smp_resp rps_resp ____cacheline_aligned; /* report_phy_sata_resp */
 	u8     fis[ATA_RESP_FIS_SIZE];
 };

commit 28bc6fb9596fe1e577d09fc17ee6e1bb051c6ba3
Merge: 0be600a5add7 a2390348c19d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 31 11:23:28 2018 -0800

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This is mostly updates of the usual driver suspects: arcmsr,
      scsi_debug, mpt3sas, lpfc, cxlflash, qla2xxx, aacraid, megaraid_sas,
      hisi_sas.
    
      We also have a rework of the libsas hotplug handling to make it more
      robust, a slew of 32 bit time conversions and fixes, and a host of the
      usual minor updates and style changes. The biggest potential for
      regressions is the libsas hotplug changes, but so far they seem stable
      under testing"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (313 commits)
      scsi: qla2xxx: Fix logo flag for qlt_free_session_done()
      scsi: arcmsr: avoid do_gettimeofday
      scsi: core: Add VENDOR_SPECIFIC sense code definitions
      scsi: qedi: Drop cqe response during connection recovery
      scsi: fas216: fix sense buffer initialization
      scsi: ibmvfc: Remove unneeded semicolons
      scsi: hisi_sas: fix a bug in hisi_sas_dev_gone()
      scsi: hisi_sas: directly attached disk LED feature for v2 hw
      scsi: hisi_sas: devicetree: bindings: add LED feature for v2 hw
      scsi: megaraid_sas: NVMe passthrough command support
      scsi: megaraid: use ktime_get_real for firmware time
      scsi: fnic: use 64-bit timestamps
      scsi: qedf: Fix error return code in __qedf_probe()
      scsi: devinfo: fix format of the device list
      scsi: qla2xxx: Update driver version to 10.00.00.05-k
      scsi: qla2xxx: Add XCB counters to debugfs
      scsi: qla2xxx: Fix queue ID for async abort with Multiqueue
      scsi: qla2xxx: Fix warning for code intentation in __qla24xx_handle_gpdb_event()
      scsi: qla2xxx: Fix warning during port_name debug print
      scsi: qla2xxx: Fix warning in qla2x00_async_iocb_timeout()
      ...

commit 0558f33c06bb910e2879e355192227a8e8f0219d
Author: Jason Yan <yanaijie@huawei.com>
Date:   Fri Dec 8 17:42:09 2017 +0800

    scsi: libsas: direct call probe and destruct
    
    In commit 87c8331fcf72 ("[SCSI] libsas: prevent domain rediscovery
    competing with ata error handling") introduced disco mutex to prevent
    rediscovery competing with ata error handling and put the whole
    revalidation in the mutex. But the rphy add/remove needs to wait for the
    error handling which also grabs the disco mutex. This may leads to dead
    lock.So the probe and destruct event were introduce to do the rphy
    add/remove asynchronously and out of the lock.
    
    The asynchronously processed workers makes the whole discovery process
    not atomic, the other events may interrupt the process. For example,
    if a loss of signal event inserted before the probe event, the
    sas_deform_port() is called and the port will be deleted.
    
    And sas_port_delete() may run before the destruct event, but the
    port-x:x is the top parent of end device or expander. This leads to
    a kernel WARNING such as:
    
    [   82.042979] sysfs group 'power' not found for kobject 'phy-1:0:22'
    [   82.042983] ------------[ cut here ]------------
    [   82.042986] WARNING: CPU: 54 PID: 1714 at fs/sysfs/group.c:237
    sysfs_remove_group+0x94/0xa0
    [   82.043059] Call trace:
    [   82.043082] [<ffff0000082e7624>] sysfs_remove_group+0x94/0xa0
    [   82.043085] [<ffff00000864e320>] dpm_sysfs_remove+0x60/0x70
    [   82.043086] [<ffff00000863ee10>] device_del+0x138/0x308
    [   82.043089] [<ffff00000869a2d0>] sas_phy_delete+0x38/0x60
    [   82.043091] [<ffff00000869a86c>] do_sas_phy_delete+0x6c/0x80
    [   82.043093] [<ffff00000863dc20>] device_for_each_child+0x58/0xa0
    [   82.043095] [<ffff000008696f80>] sas_remove_children+0x40/0x50
    [   82.043100] [<ffff00000869d1bc>] sas_destruct_devices+0x64/0xa0
    [   82.043102] [<ffff0000080e93bc>] process_one_work+0x1fc/0x4b0
    [   82.043104] [<ffff0000080e96c0>] worker_thread+0x50/0x490
    [   82.043105] [<ffff0000080f0364>] kthread+0xfc/0x128
    [   82.043107] [<ffff0000080836c0>] ret_from_fork+0x10/0x50
    
    Make probe and destruct a direct call in the disco and revalidate function,
    but put them outside the lock. The whole discovery or revalidate won't
    be interrupted by other events. And the DISCE_PROBE and DISCE_DESTRUCT
    event are deleted as a result of the direct call.
    
    Introduce a new list to destruct the sas_port and put the port delete after
    the destruct. This makes sure the right order of destroying the sysfs
    kobject and fix the warning above.
    
    In sas_ex_revalidate_domain() have a loop to find all broadcasted
    device, and sometimes we have a chance to find the same expander twice.
    Because the sas_port will be deleted at the end of the whole revalidate
    process, sas_port with the same name cannot be added before this.
    Otherwise the sysfs will complain of creating duplicate filename. Since
    the LLDD will send broadcast for every device change, we can only
    process one expander's revalidation.
    
    [mkp: kbuild test robot warning]
    
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    CC: John Garry <john.garry@huawei.com>
    CC: Johannes Thumshirn <jthumshirn@suse.de>
    CC: Ewan Milne <emilne@redhat.com>
    CC: Christoph Hellwig <hch@lst.de>
    CC: Tomas Henzl <thenzl@redhat.com>
    CC: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 6255bb5ed1e4..1cab6f7af425 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -82,10 +82,8 @@ enum phy_event {
 enum discover_event {
 	DISCE_DISCOVER_DOMAIN   = 0U,
 	DISCE_REVALIDATE_DOMAIN,
-	DISCE_PROBE,
 	DISCE_SUSPEND,
 	DISCE_RESUME,
-	DISCE_DESTRUCT,
 	DISC_NUM_EVENTS,
 };
 
@@ -262,6 +260,7 @@ struct asd_sas_port {
 	struct list_head dev_list;
 	struct list_head disco_list;
 	struct list_head destroy_list;
+	struct list_head sas_port_del_list;
 	enum   sas_linkrate linkrate;
 
 	struct sas_work work;

commit 93bdbd06b1644ac15aa152e91faefed86cc04937
Author: Jason Yan <yanaijie@huawei.com>
Date:   Fri Dec 8 17:42:07 2017 +0800

    scsi: libsas: Use new workqueue to run sas event and disco event
    
    Now all libsas works are queued to scsi host workqueue, include sas
    event work post by LLDD and sas discovery work, and a sas hotplug flow
    may be divided into several works, e.g libsas receive a
    PORTE_BYTES_DMAED event, currently we process it as following steps:
    
    sas_form_port  --- run in work in shost workq
            sas_discover_domain  --- run in another work in shost workq
                    ...
                    sas_probe_devices  --- run in new work in shost workq
    We found during hot-add a device, libsas may need run several
    works in same workqueue to add device in system, the process is
    not atomic, it may interrupt by other sas event works, like
    PHYE_LOSS_OF_SIGNAL.
    
    This patch is preparation of execute libsas sas event in sync. We need
    to use different workqueue to run sas event and disco event. Otherwise
    the work will be blocked for waiting another chained work in the same
    workqueue.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    CC: John Garry <john.garry@huawei.com>
    CC: Johannes Thumshirn <jthumshirn@suse.de>
    CC: Ewan Milne <emilne@redhat.com>
    CC: Christoph Hellwig <hch@lst.de>
    CC: Tomas Henzl <thenzl@redhat.com>
    CC: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 3769615d4ce9..6255bb5ed1e4 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -389,6 +389,9 @@ struct sas_ha_struct {
 	struct device *dev;	  /* should be set */
 	struct module *lldd_module; /* should be set */
 
+	struct workqueue_struct *event_q;
+	struct workqueue_struct *disco_q;
+
 	u8 *sas_addr;		  /* must be set */
 	u8 hashed_sas_addr[HASHED_SAS_ADDR_SIZE];
 

commit 8eea9dd84e450e5262643823691108f2a208a2ac
Author: Jason Yan <yanaijie@huawei.com>
Date:   Fri Dec 8 17:42:06 2017 +0800

    scsi: libsas: make the event threshold configurable
    
    Add a sysfs attr that LLDD can configure it for every host. We made an
    example in hisi_sas. Other LLDDs using libsas can implement it if they
    want.
    
    Suggested-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    CC: John Garry <john.garry@huawei.com>
    CC: Johannes Thumshirn <jthumshirn@suse.de>
    CC: Ewan Milne <emilne@redhat.com>
    CC: Christoph Hellwig <hch@lst.de>
    CC: Tomas Henzl <thenzl@redhat.com>
    CC: Dan Williams <dan.j.williams@intel.com>
    Acked-by: John Garry <john.garry@huawei.com> #for hisi_sas part
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index de8f043475c2..3769615d4ce9 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -681,6 +681,7 @@ extern int sas_bios_param(struct scsi_device *,
 			  sector_t capacity, int *hsc);
 extern struct scsi_transport_template *
 sas_domain_attach_transport(struct sas_domain_function_template *);
+extern struct device_attribute dev_attr_phy_event_threshold;
 
 int  sas_discover_root_expander(struct domain_device *);
 

commit f12486e06ae87453530f00a6cb49b60ae3fe4551
Author: Jason Yan <yanaijie@huawei.com>
Date:   Fri Dec 8 17:42:05 2017 +0800

    scsi: libsas: shut down the PHY if events reached the threshold
    
    If the PHY burst too many events, we will alloc a lot of events for the
    worker. This may leads to memory exhaustion.
    
    Dan Williams suggested to shut down the PHY if the events reached the
    threshold, because in this case the PHY may have gone into some
    erroneous state. Users can re-enable the PHY by sysfs if they want.
    
    We cannot use the fixed memory pool because if we run out of events, the
    shut down event and loss of signal event will lost too. The events still
    need to be allocated and processed in this case.
    
    Suggested-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    CC: John Garry <john.garry@huawei.com>
    CC: Johannes Thumshirn <jthumshirn@suse.de>
    CC: Ewan Milne <emilne@redhat.com>
    CC: Christoph Hellwig <hch@lst.de>
    CC: Tomas Henzl <thenzl@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index ee1b25299dd6..de8f043475c2 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -75,6 +75,7 @@ enum phy_event {
 	PHYE_OOB_ERROR,
 	PHYE_SPINUP_HOLD,             /* hot plug SATA, no COMWAKE sent */
 	PHYE_RESUME_TIMEOUT,
+	PHYE_SHUTDOWN,
 	PHY_NUM_EVENTS,
 };
 
@@ -311,12 +312,15 @@ static inline void INIT_SAS_EVENT(struct asd_sas_event *ev,
 	ev->event = event;
 }
 
+#define SAS_PHY_SHUTDOWN_THRES   1024
 
 /* The phy pretty much is controlled by the LLDD.
  * The class only reads those fields.
  */
 struct asd_sas_phy {
 /* private: */
+	atomic_t event_nr;
+	int in_shutdown;
 	int error;
 	int suspended;
 
@@ -404,6 +408,8 @@ struct sas_ha_struct {
 
 	struct list_head eh_done_q;  /* complete via scsi_eh_flush_done_q */
 	struct list_head eh_ata_q; /* scmds to promote from sas to ata eh */
+
+	int event_thres;
 };
 
 #define SHOST_TO_SAS_HA(_shost) (*(struct sas_ha_struct **)(_shost)->hostdata)

commit 1c393b970e0f4070e4376d45f89a2d19a5c895d0
Author: Jason Yan <yanaijie@huawei.com>
Date:   Fri Dec 8 17:42:04 2017 +0800

    scsi: libsas: Use dynamic alloced work to avoid sas event lost
    
    Now libsas hotplug work is static, every sas event type has its own
    static work, LLDD driver queues the hotplug work into shost->work_q.  If
    LLDD driver burst posts lots hotplug events to libsas, the hotplug
    events may pending in the workqueue like
    
    shost->work_q
    new work[PORTE_BYTES_DMAED] --> |[PHYE_LOSS_OF_SIGNAL][PORTE_BYTES_DMAED] -> processing
                                    |<-------wait worker to process-------->|
    
    In this case, a new PORTE_BYTES_DMAED event coming, libsas try to queue
    it to shost->work_q, but this work is already pending, so it would be
    lost. Finally, libsas delete the related sas port and sas devices, but
    LLDD driver expect libsas add the sas port and devices(last sas event).
    
    This patch use dynamic allocated work to avoid this issue.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    CC: John Garry <john.garry@huawei.com>
    CC: Johannes Thumshirn <jthumshirn@suse.de>
    CC: Ewan Milne <emilne@redhat.com>
    CC: Christoph Hellwig <hch@lst.de>
    CC: Tomas Henzl <thenzl@redhat.com>
    CC: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 0f9cbf96c093..ee1b25299dd6 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -292,6 +292,7 @@ struct asd_sas_port {
 struct asd_sas_event {
 	struct sas_work work;
 	struct asd_sas_phy *phy;
+	int event;
 };
 
 static inline struct asd_sas_event *to_asd_sas_event(struct work_struct *work)
@@ -301,17 +302,21 @@ static inline struct asd_sas_event *to_asd_sas_event(struct work_struct *work)
 	return ev;
 }
 
+static inline void INIT_SAS_EVENT(struct asd_sas_event *ev,
+		void (*fn)(struct work_struct *),
+		struct asd_sas_phy *phy, int event)
+{
+	INIT_SAS_WORK(&ev->work, fn);
+	ev->phy = phy;
+	ev->event = event;
+}
+
+
 /* The phy pretty much is controlled by the LLDD.
  * The class only reads those fields.
  */
 struct asd_sas_phy {
 /* private: */
-	struct asd_sas_event   port_events[PORT_NUM_EVENTS];
-	struct asd_sas_event   phy_events[PHY_NUM_EVENTS];
-
-	unsigned long port_events_pending;
-	unsigned long phy_events_pending;
-
 	int error;
 	int suspended;
 

commit c2e8fbf908afd81ad502b567a6639598f92c9b9d
Author: Huacai Chen <chenhc@lemote.com>
Date:   Tue Nov 21 14:23:39 2017 +0100

    scsi: libsas: align sata_device's rps_resp on a cacheline
    
    The rps_resp buffer in ata_device is a DMA target, but it isn't
    explicitly cacheline aligned. Due to this, adjacent fields can be
    overwritten with stale data from memory on non-coherent architectures.
    As a result, the kernel is sometimes unable to communicate with an SATA
    device behind a SAS expander.
    
    Fix this by ensuring that the rps_resp buffer is cacheline aligned.
    
    This issue is similar to that fixed by Commit 84bda12af31f93 ("libata:
    align ap->sector_buf") and Commit 4ee34ea3a12396f35b26 ("libata: Align
    ata_device's id on a cacheline").
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 0f9cbf96c093..6df6fe0c2198 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -159,11 +159,11 @@ struct expander_device {
 
 struct sata_device {
 	unsigned int class;
-	struct smp_resp        rps_resp; /* report_phy_sata_resp */
 	u8     port_no;        /* port number, if this is a PM (Port) */
 
 	struct ata_port *ap;
 	struct ata_host ata_host;
+	struct smp_resp rps_resp ____cacheline_aligned; /* report_phy_sata_resp */
 	u8     fis[ATA_RESP_FIS_SIZE];
 };
 

commit 670ffccb2f9183eb6cb32fe92257aea52b3f8a7d
Merge: 47f521ba1819 341b2aa83368
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 14 16:23:44 2017 -0800

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This is mostly updates of the usual suspects: lpfc, qla2xxx, hisi_sas,
      megaraid_sas, pm80xx, mpt3sas, be2iscsi, hpsa. and a host of minor
      updates.
    
      There's no major behaviour change or additions to the core in all of
      this, so the potential for regressions should be small (biggest
      potential being in the scsi error handler changes)"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (203 commits)
      scsi: lpfc: Fix hard lock up NMI in els timeout handling.
      scsi: mpt3sas: remove a stray KERN_INFO
      scsi: mpt3sas: cleanup _scsih_pcie_enumeration_event()
      scsi: aacraid: use timespec64 instead of timeval
      scsi: scsi_transport_fc: add 64GBIT and 128GBIT port speed definitions
      scsi: qla2xxx: Suppress a kernel complaint in qla_init_base_qpair()
      scsi: mpt3sas: fix dma_addr_t casts
      scsi: be2iscsi: Use kasprintf
      scsi: storvsc: Avoid excessive host scan on controller change
      scsi: lpfc: fix kzalloc-simple.cocci warnings
      scsi: mpt3sas: Update mpt3sas driver version.
      scsi: mpt3sas: Fix sparse warnings
      scsi: mpt3sas: Fix nvme drives checking for tlr.
      scsi: mpt3sas: NVMe drive support for BTDHMAPPING ioctl command and log info
      scsi: mpt3sas: Add-Task-management-debug-info-for-NVMe-drives.
      scsi: mpt3sas: scan and add nvme device after controller reset
      scsi: mpt3sas: Set NVMe device queue depth as 128
      scsi: mpt3sas: Handle NVMe PCIe device related events generated from firmware.
      scsi: mpt3sas: API's to remove nvme drive from sml
      scsi: mpt3sas: API 's to support NVMe drive addition to SML
      ...

commit 77570eedd92adfcf69fdde31183a56324f82ca5c
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Aug 22 16:05:14 2017 -0700

    scsi: sas: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly. This requires adding a pointer to
    hold the timer's target task, as there isn't a link back from slow_task.
    
    Cc: John Garry <john.garry@huawei.com>
    Cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Jack Wang <jinpu.wang@profitbricks.com>
    Cc: lindar_liu@usish.com
    Cc: Jens Axboe <axboe@fb.com>
    Cc: Hannes Reinecke <hare@suse.com>
    Cc: Johannes Thumshirn <jthumshirn@suse.de>
    Cc: Benjamin Block <bblock@linux.vnet.ibm.com>
    Cc: Baoyou Xie <baoyou.xie@linaro.org>
    Cc: Wei Yongjun <weiyongjun1@huawei.com>
    Cc: linux-scsi@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Acked-by: John Garry <john.garry@huawei.com> # for hisi_sas part
    Tested-by: John Garry <john.garry@huawei.com> # basic sanity test for hisi_sas
    Reviewed-by: Jack Wang <jinpu.wang@profitbricks.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 6c0dc6155ee7..388aaf72b480 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -629,6 +629,7 @@ struct sas_task_slow {
 	 */
 	struct timer_list     timer;
 	struct completion     completion;
+	struct sas_task       *task;
 };
 
 #define SAS_TASK_STATE_PENDING      1

commit 8a11282aa1b7d618f29f531e9d992561f87cfd8a
Author: Jason Yan <yanaijie@huawei.com>
Date:   Wed Sep 6 17:15:06 2017 +0800

    scsi: libsas: remove unused port_gone_completion and DISCE_PORT_GONE
    
    No one uses the port_gone_completion in struct asd_sas_port and
    DISCE_PORT_GONE in enum disover_event, clean them out.
    
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    CC: Johannes Thumshirn <jthumshirn@suse.de>
    CC: Ewan Milne <emilne@redhat.com>
    CC: Christoph Hellwig <hch@lst.de>
    CC: Tomas Henzl <thenzl@redhat.com>
    CC: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 4276f5b5686f..ab6e18f1c01f 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -81,7 +81,6 @@ enum phy_event {
 enum discover_event {
 	DISCE_DISCOVER_DOMAIN   = 0U,
 	DISCE_REVALIDATE_DOMAIN,
-	DISCE_PORT_GONE,
 	DISCE_PROBE,
 	DISCE_SUSPEND,
 	DISCE_RESUME,
@@ -256,8 +255,6 @@ struct sas_discovery {
 /* The port struct is Class:RW, driver:RO */
 struct asd_sas_port {
 /* private: */
-	struct completion port_gone_completion;
-
 	struct sas_discovery disc;
 	struct domain_device *port_dev;
 	spinlock_t dev_list_lock;

commit 0d78f969b10f27e0be34210d482a01e1ee92994c
Author: Jason Yan <yanaijie@huawei.com>
Date:   Wed Sep 6 17:15:05 2017 +0800

    scsi: libsas: remove the numbering for each event enum
    
    Numbering for each event enum makes no sense. Remove the numbering so
    that we don't have to calculate the number by hand every time.
    
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    CC: John Garry <john.garry@huawei.com>
    CC: Johannes Thumshirn <jthumshirn@suse.de>
    CC: Ewan Milne <emilne@redhat.com>
    CC: Christoph Hellwig <hch@lst.de>
    CC: Tomas Henzl <thenzl@redhat.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 52b3e863bea8..4276f5b5686f 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -62,31 +62,31 @@ enum sas_phy_type {
  */
 enum port_event {
 	PORTE_BYTES_DMAED     = 0U,
-	PORTE_BROADCAST_RCVD  = 1,
-	PORTE_LINK_RESET_ERR  = 2,
-	PORTE_TIMER_EVENT     = 3,
-	PORTE_HARD_RESET      = 4,
-	PORT_NUM_EVENTS       = 5,
+	PORTE_BROADCAST_RCVD,
+	PORTE_LINK_RESET_ERR,
+	PORTE_TIMER_EVENT,
+	PORTE_HARD_RESET,
+	PORT_NUM_EVENTS,
 };
 
 enum phy_event {
 	PHYE_LOSS_OF_SIGNAL   = 0U,
-	PHYE_OOB_DONE         = 1,
-	PHYE_OOB_ERROR        = 2,
-	PHYE_SPINUP_HOLD      = 3, /* hot plug SATA, no COMWAKE sent */
-	PHYE_RESUME_TIMEOUT   = 4,
-	PHY_NUM_EVENTS        = 5,
+	PHYE_OOB_DONE,
+	PHYE_OOB_ERROR,
+	PHYE_SPINUP_HOLD,             /* hot plug SATA, no COMWAKE sent */
+	PHYE_RESUME_TIMEOUT,
+	PHY_NUM_EVENTS,
 };
 
 enum discover_event {
 	DISCE_DISCOVER_DOMAIN   = 0U,
-	DISCE_REVALIDATE_DOMAIN = 1,
-	DISCE_PORT_GONE         = 2,
-	DISCE_PROBE		= 3,
-	DISCE_SUSPEND		= 4,
-	DISCE_RESUME		= 5,
-	DISCE_DESTRUCT		= 6,
-	DISC_NUM_EVENTS		= 7,
+	DISCE_REVALIDATE_DOMAIN,
+	DISCE_PORT_GONE,
+	DISCE_PROBE,
+	DISCE_SUSPEND,
+	DISCE_RESUME,
+	DISCE_DESTRUCT,
+	DISC_NUM_EVENTS,
 };
 
 /* ---------- Expander Devices ---------- */

commit 042ebd293b862c491e31aea17b540317a1b9af21
Author: Jason Yan <yanaijie@huawei.com>
Date:   Wed Sep 6 17:15:04 2017 +0800

    scsi: libsas: kill useless ha_event and do some cleanup
    
    The ha_event now has only one event HAE_RESET, and this event does
    nothing. Kill it and do some cleanup.
    
    This is a preparation for enhance libsas hotplug feature in the next
    patches.
    
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    Signed-off-by: John Garry <john.garry@huawei.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    CC: Johannes Thumshirn <jthumshirn@suse.de>
    CC: Ewan Milne <emilne@redhat.com>
    CC: Christoph Hellwig <hch@lst.de>
    CC: Tomas Henzl <thenzl@redhat.com>
    CC: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 6c0dc6155ee7..52b3e863bea8 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -60,11 +60,6 @@ enum sas_phy_type {
  * so when updating/adding events here, please also
  * update the other file too.
  */
-enum ha_event {
-	HAE_RESET             = 0U,
-	HA_NUM_EVENTS         = 1,
-};
-
 enum port_event {
 	PORTE_BYTES_DMAED     = 0U,
 	PORTE_BROADCAST_RCVD  = 1,
@@ -362,18 +357,6 @@ struct scsi_core {
 
 };
 
-struct sas_ha_event {
-	struct sas_work work;
-	struct sas_ha_struct *ha;
-};
-
-static inline struct sas_ha_event *to_sas_ha_event(struct work_struct *work)
-{
-	struct sas_ha_event *ev = container_of(work, typeof(*ev), work.work);
-
-	return ev;
-}
-
 enum sas_ha_state {
 	SAS_HA_REGISTERED,
 	SAS_HA_DRAINING,
@@ -383,9 +366,6 @@ enum sas_ha_state {
 
 struct sas_ha_struct {
 /* private: */
-	struct sas_ha_event ha_events[HA_NUM_EVENTS];
-	unsigned long	 pending;
-
 	struct list_head  defer_q; /* work queued while draining */
 	struct mutex	  drain_mutex;
 	unsigned long	  state;
@@ -415,7 +395,6 @@ struct sas_ha_struct {
 				* their siblings when forming wide ports */
 
 	/* LLDD calls these to notify the class of an event. */
-	int (*notify_ha_event)(struct sas_ha_struct *, enum ha_event);
 	int (*notify_port_event)(struct asd_sas_phy *, enum port_event);
 	int (*notify_phy_event)(struct asd_sas_phy *, enum phy_event);
 

commit 651a013649943710a900551ec6e03d2084e1a65a
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Aug 25 17:37:41 2017 +0200

    scsi: scsi_transport_sas: switch to bsg-lib for SMP passthrough
    
    Simplify the SMP passthrough code by switching it to the generic bsg-lib
    helpers that abstract away the details of the request code, and gets
    drivers out of seeing struct scsi_request.
    
    For the libsas host SMP code there is a small behavior difference in
    that we now always clear the residual len for successful commands,
    similar to the three other SMP handler implementations.  Given that
    there is no partial command handling in the host SMP handler this should
    not matter in practice.
    
    [mkp: typos and checkpatch fixes]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index e7c012ce5ecd..6c0dc6155ee7 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -721,9 +721,6 @@ extern int sas_slave_alloc(struct scsi_device *);
 extern int sas_ioctl(struct scsi_device *sdev, int cmd, void __user *arg);
 extern int sas_drain_work(struct sas_ha_struct *ha);
 
-extern int sas_smp_handler(struct Scsi_Host *shost, struct sas_rphy *rphy,
-			   struct request *req);
-
 extern void sas_ssp_task_response(struct device *dev, struct sas_task *task,
 				  struct ssp_response_iu *iu);
 struct sas_phy *sas_get_local_phy(struct domain_device *dev);

commit cc199e78460565eeab0399875dbf9da8e2901c42
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Aug 25 13:57:02 2017 +0200

    scsi: libsas: move bus_reset_handler() to target_reset_handler()
    
    The bus reset handler is calling I_T Nexus reset, which logically is a
    target reset as it need to specify both the initiator and the target.
    So move it to target reset.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index cfaeed256ab2..e7c012ce5ecd 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -714,7 +714,7 @@ void sas_init_dev(struct domain_device *);
 void sas_task_abort(struct sas_task *);
 int sas_eh_abort_handler(struct scsi_cmnd *cmd);
 int sas_eh_device_reset_handler(struct scsi_cmnd *cmd);
-int sas_eh_bus_reset_handler(struct scsi_cmnd *cmd);
+int sas_eh_target_reset_handler(struct scsi_cmnd *cmd);
 
 extern void sas_target_destroy(struct scsi_target *);
 extern int sas_slave_alloc(struct scsi_device *);

commit 6d311fa7d2c18659d040b9beba5e41fe24c2a6f5
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Jun 14 13:52:43 2017 +0200

    scsi: sas: scsi_queue_work can fail, so make callers aware
    
    libsas uses scsi_queue_work() to queue its internal event notifications.
    scsi_queue_work() can return -EINVAL if the work queue doesn't exist and
    it does call queue_work() which can return false if the work is already
    queued.
    
    Make the SAS event code capable of returning errors up to the caller,
    which is handy when changing to dynamically allocated work in libsas
    as well, as discussed here: https://lkml.org/lkml/2017/6/14/121.
    
    [mkp: fixed typo]
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index dd0f72c95abe..cfaeed256ab2 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -415,9 +415,9 @@ struct sas_ha_struct {
 				* their siblings when forming wide ports */
 
 	/* LLDD calls these to notify the class of an event. */
-	void (*notify_ha_event)(struct sas_ha_struct *, enum ha_event);
-	void (*notify_port_event)(struct asd_sas_phy *, enum port_event);
-	void (*notify_phy_event)(struct asd_sas_phy *, enum phy_event);
+	int (*notify_ha_event)(struct sas_ha_struct *, enum ha_event);
+	int (*notify_port_event)(struct asd_sas_phy *, enum port_event);
+	int (*notify_phy_event)(struct asd_sas_phy *, enum phy_event);
 
 	void *lldd_ha;		  /* not touched by sas class code */
 

commit 8690218a4c98af41f4abd3dba97bcf468c537629
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Mon Apr 3 16:32:50 2017 +0200

    scsi: sas: remove sas_domain_release_transport
    
    sas_domain_release_transport is unused since at least v3.13, remove it.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index dae99d7d2bc0..dd0f72c95abe 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -693,7 +693,6 @@ extern int sas_bios_param(struct scsi_device *,
 			  sector_t capacity, int *hsc);
 extern struct scsi_transport_template *
 sas_domain_attach_transport(struct sas_domain_function_template *);
-extern void sas_domain_release_transport(struct scsi_transport_template *);
 
 int  sas_discover_root_expander(struct domain_device *);
 

commit e61745769125a3c788e7aceb2a5fb680ebb461e6
Merge: 198a956a11b1 e86fb5e8ab95
Author: James Bottomley <JBottomley@Parallels.com>
Date:   Thu Dec 18 05:56:29 2014 -0800

    Merge remote-tracking branch 'scsi-queue/drivers-for-3.19' into for-linus

commit 4e8790f77f051d4cc745a57b48a73052521e8dfc
Merge: 0a27044c83fe 2ba520f0cd65
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 11 18:52:37 2014 -0800

    Merge branch 'for-3.19' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata
    
    Pull libata changes from Tejun Heo:
     "The only interesting piece is the support for shingled drives.  The
      changes in libata layer are minimal.  All it does is identifying the
      new class of device and report upwards accordingly"
    
    * 'for-3.19' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata:
      libata: Remove FIXME comment in atapi_request_sense()
      sata_rcar: Document deprecated "renesas,rcar-sata"
      sata_rcar: Add clocks to sata_rcar bindings
      ahci_sunxi: Make AHCI_HFLAG_NO_PMP flag configurable with a module option
      libata-scsi: Update SATL for ZAC drives
      libata: Implement ATA_DEV_ZAC
      libsas: use ata_dev_classify()

commit efc3c1df5fda0aee84f53c226d55804e6dbede4f
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Nov 24 15:36:18 2014 +0100

    scsi: remove ->change_queue_type method
    
    Since we got rid of ordered tag support in 2010 the prime use case of
    switching on and off ordered tags has been obsolete.  The other function
    of enabling/disabling tagging entirely has only been correctly implemented
    by the 53c700 driver and isn't generally useful.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 832dcc9f86ec..8280234fba90 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -693,7 +693,6 @@ extern int sas_queuecommand(struct Scsi_Host * ,struct scsi_cmnd *);
 extern int sas_target_alloc(struct scsi_target *);
 extern int sas_slave_configure(struct scsi_device *);
 extern int sas_change_queue_depth(struct scsi_device *, int new_depth);
-extern int sas_change_queue_type(struct scsi_device *, int qt);
 extern int sas_bios_param(struct scsi_device *,
 			  struct block_device *,
 			  sector_t capacity, int *hsc);

commit 79855d178557cc3e3ffd179fd26a64cef48dfb30
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Nov 5 10:36:28 2014 +0100

    libsas: remove task_collector mode
    
    The task_collector mode (or "latency_injector", (C) Dan Willians) is an
    optional I/O path in libsas that queues up scsi commands instead of
    directly sending it to the hardware.  It generall increases latencies
    to in the optiomal case slightly reduce mmio traffic to the hardware.
    
    Only the obsolete aic94xx driver and the mvsas driver allowed to use
    it without recompiling the kernel, and most drivers didn't support it
    at all.
    
    Remove the giant blob of code to allow better optimizations for scsi-mq
    in the future.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Acked-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 1f8b33ec612f..832dcc9f86ec 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -365,12 +365,6 @@ struct asd_sas_phy {
 struct scsi_core {
 	struct Scsi_Host *shost;
 
-	struct mutex	  task_queue_flush;
-	spinlock_t        task_queue_lock;
-	struct list_head  task_queue;
-	int               task_queue_size;
-
-	struct task_struct *queue_thread;
 };
 
 struct sas_ha_event {
@@ -422,9 +416,6 @@ struct sas_ha_struct {
 	struct asd_sas_port **sas_port; /* array of valid pointers, must be set */
 	int             num_phys; /* must be set, gt 0, static */
 
-	/* The class calls this to send a task for execution. */
-	int lldd_max_execute_num;
-	int lldd_queue_size;
 	int strict_wide_ports; /* both sas_addr and attached_sas_addr must match
 				* their siblings when forming wide ports */
 
@@ -612,7 +603,6 @@ struct sas_ssp_task {
 
 struct sas_task {
 	struct domain_device *dev;
-	struct list_head      list;
 
 	spinlock_t   task_state_lock;
 	unsigned     task_state_flags;
@@ -665,8 +655,7 @@ struct sas_domain_function_template {
 	int  (*lldd_dev_found)(struct domain_device *);
 	void (*lldd_dev_gone)(struct domain_device *);
 
-	int (*lldd_execute_task)(struct sas_task *, int num,
-				 gfp_t gfp_flags);
+	int (*lldd_execute_task)(struct sas_task *, gfp_t gfp_flags);
 
 	/* Task Management Functions. Must be called from process context. */
 	int (*lldd_abort_task)(struct sas_task *);
@@ -700,7 +689,6 @@ extern void sas_suspend_ha(struct sas_ha_struct *sas_ha);
 int sas_set_phy_speed(struct sas_phy *phy,
 		      struct sas_phy_linkrates *rates);
 int sas_phy_reset(struct sas_phy *phy, int hard_reset);
-int sas_queue_up(struct sas_task *task);
 extern int sas_queuecommand(struct Scsi_Host * ,struct scsi_cmnd *);
 extern int sas_target_alloc(struct scsi_target *);
 extern int sas_slave_configure(struct scsi_device *);

commit db5ed4dfd5dd0142ec36ff7b335e0ec3b836b3e6
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Nov 13 15:08:42 2014 +0100

    scsi: drop reason argument from ->change_queue_depth
    
    Drop the now unused reason argument from the ->change_queue_depth method.
    Also add a return value to scsi_adjust_queue_depth, and rename it to
    scsi_change_queue_depth now that it can be used as the default
    ->change_queue_depth implementation.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index ef7872c20da9..1f8b33ec612f 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -704,8 +704,7 @@ int sas_queue_up(struct sas_task *task);
 extern int sas_queuecommand(struct Scsi_Host * ,struct scsi_cmnd *);
 extern int sas_target_alloc(struct scsi_target *);
 extern int sas_slave_configure(struct scsi_device *);
-extern int sas_change_queue_depth(struct scsi_device *, int new_depth,
-				  int reason);
+extern int sas_change_queue_depth(struct scsi_device *, int new_depth);
 extern int sas_change_queue_type(struct scsi_device *, int qt);
 extern int sas_bios_param(struct scsi_device *,
 			  struct block_device *,

commit 1cbd772d9aaf6c697935cb855860b66cebacf950
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Nov 5 13:08:20 2014 +0100

    libsas: use ata_dev_classify()
    
    Use the ata device class from libata in libsas instead of checking
    the supported command set and switch to using ata_dev_classify()
    instead of our own method.
    
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index ef7872c20da9..8528a09a00c4 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -161,17 +161,12 @@ struct expander_device {
 };
 
 /* ---------- SATA device ---------- */
-enum ata_command_set {
-        ATA_COMMAND_SET   = 0,
-        ATAPI_COMMAND_SET = 1,
-};
-
 #define ATA_RESP_FIS_SIZE 24
 
 struct sata_device {
-        enum   ata_command_set command_set;
-        struct smp_resp        rps_resp; /* report_phy_sata_resp */
-        u8     port_no;        /* port number, if this is a PM (Port) */
+	unsigned int class;
+	struct smp_resp        rps_resp; /* report_phy_sata_resp */
+	u8     port_no;        /* port number, if this is a PM (Port) */
 
 	struct ata_port *ap;
 	struct ata_host ata_host;

commit bc6e7c4b0d1a1f742d96556f63d68f17f4e232c3
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Mar 14 13:52:48 2014 -0700

    libata, libsas: kill pm_result and related cleanup
    
    Tejun says:
      "At least for libata, worrying about suspend/resume failures don't make
       whole lot of sense.  If suspend failed, just proceed with suspend.  If
       the device can't be woken up afterwards, that's that.  There isn't
       anything we could have done differently anyway.  The same for resume, if
       spinup fails, the device is dud and the following commands will invoke
       EH actions and will eventually fail.  Again, there really isn't any
       *choice* to make.  Just making sure the errors are handled gracefully
       (ie. don't crash) and the following commands are handled correctly
       should be enough."
    
    The only libata user that actually cares about the result from a suspend
    operation is libsas.  However, it only cares about whether queuing a new
    operation collides with an in-flight one.  All libsas does with the
    error is retry, but we can just let libata wait for the previous
    operation before continuing.
    
    Other cleanups include:
    1/ Unifying all ata port pm operations on an ata_port_pm_ prefix
    2/ Marking all ata port pm helper routines as returning void, only
       ata_port_pm_ entry points need to fake a 0 return value.
    3/ Killing ata_port_{suspend|resume}_common() in favor of calling
       ata_port_request_pm() directly
    4/ Killing the wrappers that just do a to_ata_port() conversion
    5/ Clearly marking the entry points that do async operations with an
      _async suffix.
    
    Reference: http://marc.info/?l=linux-scsi&m=138995409532286&w=2
    
    Cc: Phillip Susi <psusi@ubuntu.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Suggested-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Todd Brandt <todd.e.brandt@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index f843dd8722a9..ef7872c20da9 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -172,7 +172,6 @@ struct sata_device {
         enum   ata_command_set command_set;
         struct smp_resp        rps_resp; /* report_phy_sata_resp */
         u8     port_no;        /* port number, if this is a PM (Port) */
-	int    pm_result;
 
 	struct ata_port *ap;
 	struct ata_host ata_host;

commit e73823f7a2c921dcf068d34ea03bd682498d9e42
Author: James Bottomley <JBottomley@Parallels.com>
Date:   Tue May 7 15:38:18 2013 -0700

    [SCSI] libsas: implement > 16 byte CDB support
    
    Remove the arbitrary expectation in libsas that all SCSI commands are 16 bytes
    or less.  Instead do all copies via cmd->cmd_len (and use a pointer to this in
    the libsas task instead of a copy).  Note that this still doesn't enable > 16
    byte CDB support in the underlying drivers because their internal format has
    to be fixed and the wire format of > 16 byte CDBs according to the SAS spec is
    different.  the libsas drivers (isci, aic94xx, mvsas and pm8xxx are all
    updated for this change.
    
    Cc: Lukasz Dorau <lukasz.dorau@intel.com>
    Cc: Maciej Patelczyk <maciej.patelczyk@intel.com>
    Cc: Dave Jiang <dave.jiang@intel.com>
    Cc: Jack Wang <xjtuwjp@gmail.com>
    Cc: Lindar Liu <lindar_liu@usish.com>
    Cc: Xiangliang Yu <yuxiangl@marvell.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index e2c1e66d58ae..f843dd8722a9 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -608,7 +608,7 @@ struct sas_ssp_task {
 	u8     enable_first_burst:1;
 	enum   task_attribute task_attr;
 	u8     task_prio;
-	u8     cdb[16];
+	struct scsi_cmnd *cmd;
 };
 
 struct sas_task {

commit aa9f8328fc51460e15da129caf622b6560fa8c99
Author: James Bottomley <JBottomley@Parallels.com>
Date:   Tue May 7 14:44:06 2013 -0700

    [SCSI] sas: unify the pointlessly separated enums sas_dev_type and sas_device_type
    
    These enums have been separate since the dawn of SAS, mainly because the
    latter is a procotol only enum and the former includes additional state
    for libsas.  The dichotomy causes endless confusion about which one you
    should use where and leads to pointless warnings like this:
    
    drivers/scsi/mvsas/mv_sas.c: In function 'mvs_update_phyinfo':
    drivers/scsi/mvsas/mv_sas.c:1162:34: warning: comparison between 'enum sas_device_type' and 'enum sas_dev_type' [-Wenum-compare]
    
    Fix by eliminating one of them.  The one kept is effectively the sas.h
    one, but call it sas_device_type and make sure the enums are all
    properly namespaced with the SAS_ prefix.
    
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index ef937b56f9b5..e2c1e66d58ae 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -118,7 +118,7 @@ struct ex_phy {
 
 	enum ex_phy_state phy_state;
 
-	enum sas_dev_type attached_dev_type;
+	enum sas_device_type attached_dev_type;
 	enum sas_linkrate linkrate;
 
 	u8   attached_sata_host:1;
@@ -195,7 +195,7 @@ enum {
 
 struct domain_device {
 	spinlock_t done_lock;
-        enum sas_dev_type dev_type;
+	enum sas_device_type dev_type;
 
         enum sas_linkrate linkrate;
         enum sas_linkrate min_linkrate;

commit 303694eeee5eacad5b84105a15afd9e351e1891b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 21 23:41:51 2012 -0700

    [SCSI] libsas: suspend / resume support
    
    libsas power management routines to suspend and recover the sas domain
    based on a model where the lldd is allowed and expected to be
    "forgetful".
    
    sas_suspend_ha - disable event processing allowing the lldd to take down
                     links without concern for causing hotplug events.
                     Regardless of whether the lldd actually posts link down
                     messages libsas notifies the lldd that all
                     domain_devices are gone.
    
    sas_prep_resume_ha - on the way back up before the lldd starts link
                         training clean out any spurious events that were
                         generated on the way down, and re-enable event
                         processing
    
    sas_resume_ha - after the lldd has started and decided that all phys
                    have posted link-up events this routine is called to let
                    libsas start it's own timeout of any phys that did not
                    resume.  After the timeout an lldd can cancel the
                    phy teardown by posting a link-up event.
    
    Storage for ex_change_count (u16) and phy_change_count (u8) are changed
    to int so they can be set to -1 to indicate 'invalidated'.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Jacek Danecki <jacek.danecki@intel.com>
    Tested-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index ae33706afeb0..ef937b56f9b5 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -79,7 +79,8 @@ enum phy_event {
 	PHYE_OOB_DONE         = 1,
 	PHYE_OOB_ERROR        = 2,
 	PHYE_SPINUP_HOLD      = 3, /* hot plug SATA, no COMWAKE sent */
-	PHY_NUM_EVENTS        = 4,
+	PHYE_RESUME_TIMEOUT   = 4,
+	PHY_NUM_EVENTS        = 5,
 };
 
 enum discover_event {
@@ -87,8 +88,10 @@ enum discover_event {
 	DISCE_REVALIDATE_DOMAIN = 1,
 	DISCE_PORT_GONE         = 2,
 	DISCE_PROBE		= 3,
-	DISCE_DESTRUCT		= 4,
-	DISC_NUM_EVENTS		= 5,
+	DISCE_SUSPEND		= 4,
+	DISCE_RESUME		= 5,
+	DISCE_DESTRUCT		= 6,
+	DISC_NUM_EVENTS		= 7,
 };
 
 /* ---------- Expander Devices ---------- */
@@ -128,7 +131,7 @@ struct ex_phy {
 	u8   attached_sas_addr[SAS_ADDR_SIZE];
 	u8   attached_phy_id;
 
-	u8   phy_change_count;
+	int phy_change_count;
 	enum routing_attribute routing_attr;
 	u8   virtual:1;
 
@@ -141,7 +144,7 @@ struct ex_phy {
 struct expander_device {
 	struct list_head children;
 
-	u16    ex_change_count;
+	int    ex_change_count;
 	u16    max_route_indexes;
 	u8     num_phys;
 
@@ -169,6 +172,7 @@ struct sata_device {
         enum   ata_command_set command_set;
         struct smp_resp        rps_resp; /* report_phy_sata_resp */
         u8     port_no;        /* port number, if this is a PM (Port) */
+	int    pm_result;
 
 	struct ata_port *ap;
 	struct ata_host ata_host;
@@ -182,6 +186,7 @@ struct ssp_device {
 
 enum {
 	SAS_DEV_GONE,
+	SAS_DEV_FOUND, /* device notified to lldd */
 	SAS_DEV_DESTROY,
 	SAS_DEV_EH_PENDING,
 	SAS_DEV_LU_RESET,
@@ -273,6 +278,7 @@ struct asd_sas_port {
 	enum   sas_linkrate linkrate;
 
 	struct sas_work work;
+	int suspended;
 
 /* public: */
 	int id;
@@ -321,6 +327,7 @@ struct asd_sas_phy {
 	unsigned long phy_events_pending;
 
 	int error;
+	int suspended;
 
 	struct sas_phy *phy;
 
@@ -687,6 +694,9 @@ struct sas_domain_function_template {
 
 extern int sas_register_ha(struct sas_ha_struct *);
 extern int sas_unregister_ha(struct sas_ha_struct *);
+extern void sas_prep_resume_ha(struct sas_ha_struct *sas_ha);
+extern void sas_resume_ha(struct sas_ha_struct *sas_ha);
+extern void sas_suspend_ha(struct sas_ha_struct *sas_ha);
 
 int sas_set_phy_speed(struct sas_phy *phy,
 		      struct sas_phy_linkrates *rates);

commit f0bf750c2d25c3a2131ececbff63c7878e0e3765
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 21 23:36:30 2012 -0700

    [SCSI] libsas: trim sas_task of slow path infrastructure
    
    The timer and the completion are only used for slow path tasks (smp, and
    lldd tmfs), yet we incur the allocation space and cpu setup time for
    every fast path task.
    
    Cc: Xiangliang Yu <yuxiangl@marvell.com>
    Acked-by: Jack Wang <jack_wang@usish.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 29a8cc7831af..ae33706afeb0 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -613,10 +613,6 @@ struct sas_task {
 
 	enum   sas_protocol      task_proto;
 
-	/* Used by the discovery code. */
-	struct timer_list     timer;
-	struct completion     completion;
-
 	union {
 		struct sas_ata_task ata_task;
 		struct sas_smp_task smp_task;
@@ -633,8 +629,15 @@ struct sas_task {
 
 	void   *lldd_task;	  /* for use by LLDDs */
 	void   *uldd_task;
+	struct sas_task_slow *slow_task;
+};
 
-	struct work_struct abort_work;
+struct sas_task_slow {
+	/* standard/extra infrastructure for slow path commands (SMP and
+	 * internal lldd commands
+	 */
+	struct timer_list     timer;
+	struct completion     completion;
 };
 
 #define SAS_TASK_STATE_PENDING      1
@@ -644,6 +647,7 @@ struct sas_task {
 #define SAS_TASK_AT_INITIATOR       16
 
 extern struct sas_task *sas_alloc_task(gfp_t flags);
+extern struct sas_task *sas_alloc_slow_task(gfp_t flags);
 extern void sas_free_task(struct sas_task *task);
 
 struct sas_domain_function_template {

commit a494fd5bd98bb35d5a9a274fecb768e14ebf499c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 21 23:36:25 2012 -0700

    [SCSI] libsas: drop sata port multiplier infrastructure
    
    On the way to add a new sata_device field, noticed that libsas is
    carrying port multiplier infrastructure that is explicitly disabled by
    sas_discover_sata().  The aic94xx touches the unused port_no, so leave
    that field in case there was some use for it.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index acefe13ebacf..29a8cc7831af 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -169,7 +169,6 @@ struct sata_device {
         enum   ata_command_set command_set;
         struct smp_resp        rps_resp; /* report_phy_sata_resp */
         u8     port_no;        /* port number, if this is a PM (Port) */
-        struct list_head children; /* PM Ports if this is a PM */
 
 	struct ata_port *ap;
 	struct ata_host ata_host;

commit 9524c6821849bddad4bf592a47276cfb8a8a98c0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 21 23:30:53 2012 -0700

    [SCSI] libsas: add sas_eh_abort_handler
    
    When recovering failed eh-cmnds let the lldd attempt an abort via
    scsi_abort_eh_cmnd before escalating.
    
    Reviewed-by: Jacek Danecki <jacek.danecki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index df9cefdf2a8e..acefe13ebacf 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -720,6 +720,7 @@ void sas_unregister_dev(struct asd_sas_port *port, struct domain_device *);
 void sas_init_dev(struct domain_device *);
 
 void sas_task_abort(struct sas_task *);
+int sas_eh_abort_handler(struct scsi_cmnd *cmd);
 int sas_eh_device_reset_handler(struct scsi_cmnd *cmd);
 int sas_eh_bus_reset_handler(struct scsi_cmnd *cmd);
 

commit 5db45bdc87ce4f503947adf7896586d60c63322c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 21 23:30:48 2012 -0700

    [SCSI] libsas: enforce eh strategy handlers only in eh context
    
    The strategy handlers may be called in places that are problematic for
    libsas (i.e. sata resets outside of domain revalidation filtering /
    libata link recovery), or problematic for userspace (non-blocking ioctl
    to sleeping reset functions).  However, these routines are also called
    for eh escalations and recovery of scsi_eh_prep_cmnd(), so permit them
    as long as we are running in the host's error handler, otherwise arrange
    for them to be triggered in eh_context.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 814d8cb592ad..df9cefdf2a8e 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -176,10 +176,17 @@ struct sata_device {
 	u8     fis[ATA_RESP_FIS_SIZE];
 };
 
+struct ssp_device {
+	struct list_head eh_list_node; /* pending a user requested eh action */
+	struct scsi_lun reset_lun;
+};
+
 enum {
 	SAS_DEV_GONE,
 	SAS_DEV_DESTROY,
 	SAS_DEV_EH_PENDING,
+	SAS_DEV_LU_RESET,
+	SAS_DEV_RESET,
 };
 
 struct domain_device {
@@ -213,6 +220,7 @@ struct domain_device {
         union {
                 struct expander_device ex_dev;
                 struct sata_device     sata_dev; /* STP & directly attached */
+		struct ssp_device      ssp_dev;
         };
 
         void *lldd_dev;
@@ -389,6 +397,8 @@ struct sas_ha_struct {
 	unsigned long	  state;
 	spinlock_t	  lock;
 	int		  eh_active;
+	wait_queue_head_t eh_wait_q;
+	struct list_head  eh_dev_q;
 
 	struct mutex disco_mutex;
 

commit e4a9c3732cea3e3c8c704aad86636090ffe6b25f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 21 23:25:27 2012 -0700

    [SCSI] libata, libsas: introduce sched_eh and end_eh port ops
    
    When managing shost->host_eh_scheduled libata assumes that there is a
    1:1 shost-to-ata_port relationship.  libsas creates a 1:N relationship
    so it needs to manage host_eh_scheduled cumulatively at the host level.
    The sched_eh and end_eh port port ops allow libsas to track when domain
    devices enter/leave the "eh-pending" state under ha->lock (previously
    named ha->state_lock, but it is no longer just a lock for ha->state
    changes).
    
    Since host_eh_scheduled indicates eh without backing commands pinning
    the device it can be deallocated at any time.  Move the taking of the
    domain_device reference under the port_lock to guarantee that the
    ata_port stays around for the duration of eh.
    
    Reviewed-by: Jacek Danecki <jacek.danecki@intel.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 10ce74f589c5..814d8cb592ad 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -179,6 +179,7 @@ struct sata_device {
 enum {
 	SAS_DEV_GONE,
 	SAS_DEV_DESTROY,
+	SAS_DEV_EH_PENDING,
 };
 
 struct domain_device {
@@ -386,7 +387,8 @@ struct sas_ha_struct {
 	struct list_head  defer_q; /* work queued while draining */
 	struct mutex	  drain_mutex;
 	unsigned long	  state;
-	spinlock_t 	  state_lock;
+	spinlock_t	  lock;
+	int		  eh_active;
 
 	struct mutex disco_mutex;
 

commit 6ef1b512f4e6f936d89aa20be3d97a7ec7c290ac
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jun 22 10:52:34 2012 -0700

    [SCSI] libsas: fix taskfile corruption in sas_ata_qc_fill_rtf
    
    fill_result_tf() grabs the taskfile flags from the originating qc which
    sas_ata_qc_fill_rtf() promptly overwrites.  The presence of an
    ata_taskfile in the sata_device makes it tempting to just copy the full
    contents in sas_ata_qc_fill_rtf().  However, libata really only wants
    the fis contents and expects the other portions of the taskfile to not
    be touched by ->qc_fill_rtf.  To that end store a fis buffer in the
    sata_device and use ata_tf_from_fis() like every other ->qc_fill_rtf()
    implementation.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Praveen Murali <pmurali@logicube.com>
    Tested-by: Praveen Murali <pmurali@logicube.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index f4f1c96dca72..10ce74f589c5 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -163,6 +163,8 @@ enum ata_command_set {
         ATAPI_COMMAND_SET = 1,
 };
 
+#define ATA_RESP_FIS_SIZE 24
+
 struct sata_device {
         enum   ata_command_set command_set;
         struct smp_resp        rps_resp; /* report_phy_sata_resp */
@@ -171,7 +173,7 @@ struct sata_device {
 
 	struct ata_port *ap;
 	struct ata_host ata_host;
-	struct ata_taskfile tf;
+	u8     fis[ATA_RESP_FIS_SIZE];
 };
 
 enum {
@@ -537,7 +539,7 @@ enum exec_status {
  */
 struct ata_task_resp {
 	u16  frame_len;
-	u8   ending_fis[24];	  /* dev to host or data-in */
+	u8   ending_fis[ATA_RESP_FIS_SIZE];	  /* dev to host or data-in */
 };
 
 #define SAS_STATUS_BUF_SIZE 96

commit 22b9153faa2263aa89625de25e71c7d44c8dbd16
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Mar 9 11:00:06 2012 -0800

    [SCSI] libsas: introduce sas_work to fix sas_drain_work vs sas_queue_work
    
    When requeuing work to a draining workqueue the last work instance may
    not be idle, so sas_queue_work() must not touch work->entry.  Introduce
    sas_work with a drain_node list_head to have a private list for
    collecting work deferred due to drain collision.
    
    Fixes reports like:
      BUG: unable to handle kernel NULL pointer dereference at           (null)
      IP: [<ffffffff810410d4>] process_one_work+0x2e/0x338
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 5f5ed1b8b41b..f4f1c96dca72 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -217,11 +217,29 @@ struct domain_device {
 	struct kref kref;
 };
 
-struct sas_discovery_event {
+struct sas_work {
+	struct list_head drain_node;
 	struct work_struct work;
+};
+
+static inline void INIT_SAS_WORK(struct sas_work *sw, void (*fn)(struct work_struct *))
+{
+	INIT_WORK(&sw->work, fn);
+	INIT_LIST_HEAD(&sw->drain_node);
+}
+
+struct sas_discovery_event {
+	struct sas_work work;
 	struct asd_sas_port *port;
 };
 
+static inline struct sas_discovery_event *to_sas_discovery_event(struct work_struct *work)
+{
+	struct sas_discovery_event *ev = container_of(work, typeof(*ev), work.work);
+
+	return ev;
+}
+
 struct sas_discovery {
 	struct sas_discovery_event disc_work[DISC_NUM_EVENTS];
 	unsigned long    pending;
@@ -244,7 +262,7 @@ struct asd_sas_port {
 	struct list_head destroy_list;
 	enum   sas_linkrate linkrate;
 
-	struct work_struct work;
+	struct sas_work work;
 
 /* public: */
 	int id;
@@ -270,10 +288,17 @@ struct asd_sas_port {
 };
 
 struct asd_sas_event {
-	struct work_struct work;
+	struct sas_work work;
 	struct asd_sas_phy *phy;
 };
 
+static inline struct asd_sas_event *to_asd_sas_event(struct work_struct *work)
+{
+	struct asd_sas_event *ev = container_of(work, typeof(*ev), work.work);
+
+	return ev;
+}
+
 /* The phy pretty much is controlled by the LLDD.
  * The class only reads those fields.
  */
@@ -333,10 +358,17 @@ struct scsi_core {
 };
 
 struct sas_ha_event {
-	struct work_struct work;
+	struct sas_work work;
 	struct sas_ha_struct *ha;
 };
 
+static inline struct sas_ha_event *to_sas_ha_event(struct work_struct *work)
+{
+	struct sas_ha_event *ev = container_of(work, typeof(*ev), work.work);
+
+	return ev;
+}
+
 enum sas_ha_state {
 	SAS_HA_REGISTERED,
 	SAS_HA_DRAINING,

commit 9a10b33caf78f897356ac006c455e6060a40af15
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jan 20 15:26:03 2012 -0800

    [SCSI] libsas: revert ata srst
    
    libata issues follow up srsts when the controller has a hard time
    recording the signature-fis after a reset, or if the link supports port
    multipliers.  libsas does not support port multipliers and no current
    libsas lldds appear to need help retrieving the signature fis.  Revert
    it for now to remove confusion.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 20153d58e4e6..5f5ed1b8b41b 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -619,7 +619,6 @@ struct sas_domain_function_template {
 	int (*lldd_clear_aca)(struct domain_device *, u8 *lun);
 	int (*lldd_clear_task_set)(struct domain_device *, u8 *lun);
 	int (*lldd_I_T_nexus_reset)(struct domain_device *);
-	int (*lldd_ata_soft_reset)(struct domain_device *);
 	int (*lldd_ata_check_ready)(struct domain_device *);
 	void (*lldd_ata_set_dmamode)(struct domain_device *);
 	int (*lldd_lu_reset)(struct domain_device *, u8 *lun);

commit 9508a66f898d46e726a318469312b45e0b1d078b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jan 18 20:47:01 2012 -0800

    [SCSI] libsas: async ata scanning
    
    libsas ata error handling is already async but this does not help the
    scan case.  Move initial link recovery out from under host->scan_mutex,
    and delay synchronization with eh until after all port probe/recovery
    work has been queued.
    
    Device ordering is maintained with scan order by still calling
    sas_rphy_add() in order of domain discovery.
    
    Since we now scan the domain list when invoking libata-eh we need to be
    careful to check for fully initialized ata ports.
    
    Acked-by: Jack Wang <jack_wang@usish.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 4a42be34fad0..20153d58e4e6 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -646,7 +646,6 @@ int sas_phy_reset(struct sas_phy *phy, int hard_reset);
 int sas_queue_up(struct sas_task *task);
 extern int sas_queuecommand(struct Scsi_Host * ,struct scsi_cmnd *);
 extern int sas_target_alloc(struct scsi_target *);
-extern int sas_slave_alloc(struct scsi_device *);
 extern int sas_slave_configure(struct scsi_device *);
 extern int sas_change_queue_depth(struct scsi_device *, int new_depth,
 				  int reason);

commit 7d05919aad080074453de880822fe5805875645f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jan 10 14:39:13 2012 -0800

    [SCSI] libsas: mark all domain devices gone if root port disappears
    
    If the top level expander is hot removed, mark all child devices as gone
    before unregistration to short circuit futile recovery.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 55bab8633807..4a42be34fad0 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -664,7 +664,7 @@ void sas_init_ex_attr(void);
 
 int  sas_ex_revalidate_domain(struct domain_device *);
 
-void sas_unregister_domain_devices(struct asd_sas_port *port);
+void sas_unregister_domain_devices(struct asd_sas_port *port, int gone);
 void sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *);
 int  sas_discover_event(struct asd_sas_port *, enum discover_event ev);
 

commit f41a0c441c3fe43e79ebeb75584dbb5bfa83e5cd
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Dec 21 21:33:17 2011 -0800

    [SCSI] libsas: fix sas_find_local_phy(), take phy references
    
    In the direct-attached case this routine returns the phy on which this
    device was first discovered.  Which is broken if we want to support
    wide-targets, as this phy reference can become stale even though the
    port is still active.
    
    In the expander-attached case this routine tries to lookup the phy by
    scanning the attached sas addresses of the parent expander, and BUG_ONs
    if it can't find it.  However since eh and the libsas workqueue run
    independently we can still be attempting device recovery via eh after
    libsas has recorded the device as detached.  This is even easier to hit
    now that eh is blocked while device domain rediscovery takes place, and
    that libata is fed more timed out commands increasing the chances that
    it will try to recover the ata device.
    
    Arrange for dev->phy to always point to a last known good phy, it may be
    stale after the port is torn down, but it will catch up for wide port
    reconfigurations, and never be NULL.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 2079b18467a1..55bab8633807 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -192,6 +192,7 @@ struct domain_device {
         struct domain_device *parent;
         struct list_head siblings; /* devices on the same level */
         struct asd_sas_port *port;        /* shortcut to root of the tree */
+	struct sas_phy *phy;
 
         struct list_head dev_list_node;
 	struct list_head disco_list_node; /* awaiting probe or destruct */
@@ -243,7 +244,6 @@ struct asd_sas_port {
 	struct list_head destroy_list;
 	enum   sas_linkrate linkrate;
 
-	struct sas_phy *phy;
 	struct work_struct work;
 
 /* public: */
@@ -429,6 +429,11 @@ static inline unsigned int to_sas_gpio_od(int device, int bit)
 	return 3 * device + bit;
 }
 
+static inline void sas_put_local_phy(struct sas_phy *phy)
+{
+	put_device(&phy->dev);
+}
+
 #ifdef CONFIG_SCSI_SAS_HOST_SMP
 int try_test_sas_gpio_gp_bit(unsigned int od, u8 *data, u8 index, u8 count);
 #else
@@ -684,7 +689,7 @@ extern int sas_smp_handler(struct Scsi_Host *shost, struct sas_rphy *rphy,
 
 extern void sas_ssp_task_response(struct device *dev, struct sas_task *task,
 				  struct ssp_response_iu *iu);
-struct sas_phy *sas_find_local_phy(struct domain_device *dev);
+struct sas_phy *sas_get_local_phy(struct domain_device *dev);
 
 int sas_request_addr(struct Scsi_Host *shost, u8 *addr);
 

commit 36a399473902a57218dc493c5a814708a56b73ab
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Nov 17 17:59:54 2011 -0800

    [SCSI] libsas: poll for ata device readiness after reset
    
    Use ata_wait_after_reset() to poll for link recovery after a reset.
    This combined with sas_ha->eh_mutex prevents expander rediscovery from
    probing phys in an intermediate state.  Local discovery does not have a
    mechanism to filter link status changes during this timeout, so it
    remains the responsibility of lldds to prevent premature port teardown.
    Although once all lldd's support ->lldd_ata_check_ready() that could be
    used as a gate to local port teardown.
    
    The signature fis is re-transmitted when the link comes back so we
    should be revalidating the ata device class, but that is left to a future
    patch.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 18704a2e4f07..2079b18467a1 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -615,6 +615,7 @@ struct sas_domain_function_template {
 	int (*lldd_clear_task_set)(struct domain_device *, u8 *lun);
 	int (*lldd_I_T_nexus_reset)(struct domain_device *);
 	int (*lldd_ata_soft_reset)(struct domain_device *);
+	int (*lldd_ata_check_ready)(struct domain_device *);
 	void (*lldd_ata_set_dmamode)(struct domain_device *);
 	int (*lldd_lu_reset)(struct domain_device *, u8 *lun);
 	int (*lldd_query_task)(struct sas_task *);

commit 89d3cf6ac3cdc4f15a82709f8c78ed169a98be5b
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Wed Nov 16 09:44:13 2011 +0000

    [SCSI] libsas: add mutex for SMP task execution
    
    SAS does not tag SMP requests, and at least one lldd (isci) does not permit
    more than one in-flight request at a time.
    
    [jejb: fix sas_init_dev tab issues while we're at it]
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index f388ba536128..18704a2e4f07 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -153,6 +153,8 @@ struct expander_device {
 
 	struct ex_phy *ex_phy;
 	struct sas_port *parent_port;
+
+	struct mutex cmd_mutex;
 };
 
 /* ---------- SATA device ---------- */

commit 2a559f4ba443265b4c58925b48296f1cf81b49f9
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun Dec 4 00:06:57 2011 -0800

    [SCSI] libsas: sas_phy_enable via transport_sas_phy_reset
    
    Execute the link-reset triggered by sas_phy_enable via
    transport_sas_phy_reset so that it can be managed by libata.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 6b80310e08af..f388ba536128 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -634,7 +634,6 @@ extern int sas_unregister_ha(struct sas_ha_struct *);
 
 int sas_set_phy_speed(struct sas_phy *phy,
 		      struct sas_phy_linkrates *rates);
-int sas_phy_enable(struct sas_phy *phy, int enabled);
 int sas_phy_reset(struct sas_phy *phy, int hard_reset);
 int sas_queue_up(struct sas_task *task);
 extern int sas_queuecommand(struct Scsi_Host * ,struct scsi_cmnd *);

commit 3944f50995f947558c35fb16ae0288354756762c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Nov 29 12:08:50 2011 -0800

    [SCSI] libsas: let libata handle command timeouts
    
    libsas-eh if it successfully aborts an ata command will hide the timeout
    condition (AC_ERR_TIMEOUT) from libata.  The command likely completes
    with the all-zero task->task_status it started with.  Instead, interpret
    a TMF_RESP_FUNC_COMPLETE as the end of the sas_task but keep the scmd
    around for libata-eh to handle.
    
    Tested-by: Andrzej Jakowski <andrzej.jakowski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index aa7192ff4355..6b80310e08af 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -382,7 +382,8 @@ struct sas_ha_struct {
 
 	void *lldd_ha;		  /* not touched by sas class code */
 
-	struct list_head eh_done_q;
+	struct list_head eh_done_q;  /* complete via scsi_eh_flush_done_q */
+	struct list_head eh_ata_q; /* scmds to promote from sas to ata eh */
 };
 
 #define SHOST_TO_SAS_HA(_shost) (*(struct sas_ha_struct **)(_shost)->hostdata)

commit 9095a64a9aead653df320e3a6fc70835c15d46e4
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Nov 28 11:29:20 2011 -0800

    [SCSI] libsas: fix timeout vs completion race
    
    Until we have told the lldd to forget a task a timed out operation can
    return from the hardware at any time.  Since completion frees the task
    we need to make sure that no tasks run their normal completion handler
    once eh has decided to manage the task.  Similar to
    ata_scsi_cmd_error_handler() freeze completions to let eh judge the
    outcome of the race.
    
    Task collector mode is problematic because it presents a situation where
    a task can be timed out and aborted before the lldd has even seen it.
    For this case we need to guarantee that a task that an lldd has been
    told to forget does not get queued after the lldd says "never seen it".
    With sas_scsi_timed_out we achieve this with the ->task_queue_flush
    mutex, rather than adding more time.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 071041b290d6..aa7192ff4355 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -178,6 +178,7 @@ enum {
 };
 
 struct domain_device {
+	spinlock_t done_lock;
         enum sas_dev_type dev_type;
 
         enum sas_linkrate linkrate;
@@ -321,6 +322,7 @@ struct asd_sas_phy {
 struct scsi_core {
 	struct Scsi_Host *shost;
 
+	struct mutex	  task_queue_flush;
 	spinlock_t        task_queue_lock;
 	struct list_head  task_queue;
 	int               task_queue_size;
@@ -337,6 +339,7 @@ enum sas_ha_state {
 	SAS_HA_REGISTERED,
 	SAS_HA_DRAINING,
 	SAS_HA_ATA_EH_ACTIVE,
+	SAS_HA_FROZEN,
 };
 
 struct sas_ha_struct {

commit a3a142524aa4b1539a64a55087bf12ffa4b1f94e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Dec 6 23:24:42 2011 -0800

    [SCSI] libsas: prevent double completion of scmds from eh
    
    We invoke task->task_done() to free the task in the eh case, but at this
    point we are prepared for scsi_eh_flush_done_q() to finish off the scmd.
    
    Introduce sas_end_task() to capture the final response status from the
    lldd and free the task.
    
    Also take the opportunity to kill this warning.
    drivers/scsi/libsas/sas_scsi_host.c: In function sas_end_task:
    drivers/scsi/libsas/sas_scsi_host.c:102:3: warning: case value 2 not in enumerated type enum exec_status [-Wswitch]
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 10eb2ea74431..071041b290d6 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -452,7 +452,10 @@ enum service_response {
 };
 
 enum exec_status {
-	/* The SAM_STAT_.. codes fit in the lower 6 bits */
+	/* The SAM_STAT_.. codes fit in the lower 6 bits, alias some of
+	 * them here to silence 'case value not in enumerated type' warnings
+	 */
+	__SAM_STAT_CHECK_CONDITION = SAM_STAT_CHECK_CONDITION,
 
 	SAS_DEV_NO_RESPONSE = 0x80,
 	SAS_DATA_UNDERRUN,

commit 3dff5721e4f67e6231dfc419d30aaa7563bfffd4
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Nov 28 12:08:22 2011 -0800

    [SCSI] libsas: close error handling vs sas_ata_task_done() race
    
    Since sas_ata does not implement ->freeze(), completions for scmds and
    internal commands can still arrive concurrent with
    ata_scsi_cmd_error_handler() and sas_ata_post_internal() respectively.
    By the time either of those is called libata has committed to completing
    the qc, and the ATA_PFLAG_FROZEN flag tells sas_ata_task_done() it has
    lost the race.
    
    In the sas_ata_post_internal() case we take on the additional
    responsibility of freeing the sas_task to close the race with
    sas_ata_task_done() freeing the the task while sas_ata_post_internal()
    is in the process of invoking ->lldd_abort_task().
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 9c13a5c0bb3a..10eb2ea74431 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -662,7 +662,6 @@ void sas_unregister_dev(struct asd_sas_port *port, struct domain_device *);
 void sas_init_dev(struct domain_device *);
 
 void sas_task_abort(struct sas_task *);
-int __sas_task_abort(struct sas_task *);
 int sas_eh_device_reset_handler(struct scsi_cmnd *cmd);
 int sas_eh_bus_reset_handler(struct scsi_cmnd *cmd);
 

commit b91bb296188118eea9fdc6093cfcf76bbe8589ba
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Nov 17 17:59:52 2011 -0800

    [SCSI] libsas: use ->set_dmamode to notify lldds of NCQ parameters
    
    sas_discover_sata() notifies lldds of sata devices twice.  Once to allow
    the 'identify' to be sent, and a second time to allow aic94xx (the only
    libsas driver that cares about sata_dev.identify) to setup NCQ
    parameters before the device becomes known to the midlayer.  Replace
    this double notification and intervening 'identify' with an explicit
    ->lldd_ata_set_dmamode notification.  With this change all ata internal
    commands are issued by libata, so we no longer need sas_issue_ata_cmd().
    
    The data from the identify command only needs to be cached in one
    location so ata_device.id replaces domain_device.sata_dev.identify.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index bd6e89ece2ab..9c13a5c0bb3a 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -164,9 +164,6 @@ enum ata_command_set {
 struct sata_device {
         enum   ata_command_set command_set;
         struct smp_resp        rps_resp; /* report_phy_sata_resp */
-        __le16 *identify_device;
-        __le16 *identify_packet_device;
-
         u8     port_no;        /* port number, if this is a PM (Port) */
         struct list_head children; /* PM Ports if this is a PM */
 
@@ -609,6 +606,7 @@ struct sas_domain_function_template {
 	int (*lldd_clear_task_set)(struct domain_device *, u8 *lun);
 	int (*lldd_I_T_nexus_reset)(struct domain_device *);
 	int (*lldd_ata_soft_reset)(struct domain_device *);
+	void (*lldd_ata_set_dmamode)(struct domain_device *);
 	int (*lldd_lu_reset)(struct domain_device *, u8 *lun);
 	int (*lldd_query_task)(struct sas_task *);
 

commit 87c8331fcf72e501c3a3c0cdc5c9391ec72f7cf2
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Nov 17 17:59:51 2011 -0800

    [SCSI] libsas: prevent domain rediscovery competing with ata error handling
    
    libata error handling provides for a timeout for link recovery.  libsas
    must not rescan for previously known devices in this interval otherwise
    it may remove a device that is simply waiting for its link to recover.
    Let libata-eh make the determination of when the link is stable and
    prevent libsas (host workqueue) from taking action while this
    determination is pending.
    
    Using a mutex (ha->disco_mutex) to flush and disable revalidation while
    eh is running requires any discovery action that may block on eh be
    moved to its own context outside the lock.  Probing ATA devices
    explicitly waits on ata-eh and the cache-flush-io issued during device
    removal may also pend awaiting eh completion.  Essentially any rphy
    add/remove activity needs to run outside the lock.
    
    This adds two new cleanup states for sas_unregister_domain_devices()
    'allocated-but-not-probed', and 'flagged-for-destruction'.  In the
    'allocated-but-not-probed' state  dev->rphy points to a rphy that is
    known to have not been through a sas_rphy_add() event.  At domain
    teardown check if this device is still pending probe and cleanup
    accordingly.  Similarly if a device has already been queued for removal
    then sas_unregister_domain_devices has nothing to do.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index d792b13cfcf5..bd6e89ece2ab 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -86,7 +86,9 @@ enum discover_event {
 	DISCE_DISCOVER_DOMAIN   = 0U,
 	DISCE_REVALIDATE_DOMAIN = 1,
 	DISCE_PORT_GONE         = 2,
-	DISC_NUM_EVENTS 	= 3,
+	DISCE_PROBE		= 3,
+	DISCE_DESTRUCT		= 4,
+	DISC_NUM_EVENTS		= 5,
 };
 
 /* ---------- Expander Devices ---------- */
@@ -175,6 +177,7 @@ struct sata_device {
 
 enum {
 	SAS_DEV_GONE,
+	SAS_DEV_DESTROY,
 };
 
 struct domain_device {
@@ -191,6 +194,7 @@ struct domain_device {
         struct asd_sas_port *port;        /* shortcut to root of the tree */
 
         struct list_head dev_list_node;
+	struct list_head disco_list_node; /* awaiting probe or destruct */
 
         enum sas_protocol    iproto;
         enum sas_protocol    tproto;
@@ -226,7 +230,6 @@ struct sas_discovery {
 	int    max_level;
 };
 
-
 /* The port struct is Class:RW, driver:RO */
 struct asd_sas_port {
 /* private: */
@@ -236,6 +239,8 @@ struct asd_sas_port {
 	struct domain_device *port_dev;
 	spinlock_t dev_list_lock;
 	struct list_head dev_list;
+	struct list_head disco_list;
+	struct list_head destroy_list;
 	enum   sas_linkrate linkrate;
 
 	struct sas_phy *phy;
@@ -334,6 +339,7 @@ struct sas_ha_event {
 enum sas_ha_state {
 	SAS_HA_REGISTERED,
 	SAS_HA_DRAINING,
+	SAS_HA_ATA_EH_ACTIVE,
 };
 
 struct sas_ha_struct {
@@ -346,6 +352,8 @@ struct sas_ha_struct {
 	unsigned long	  state;
 	spinlock_t 	  state_lock;
 
+	struct mutex disco_mutex;
+
 	struct scsi_core core;
 
 /* public: */

commit e139942d77a6e3ac83bc322e826668054a8601d6
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat Jan 7 08:52:39 2012 +0000

    [SCSI] libsas: convert dev->gone to flags
    
    In preparation for adding tracking of another device state "destroy".
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 42900fa95a03..d792b13cfcf5 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -173,7 +173,10 @@ struct sata_device {
 	struct ata_taskfile tf;
 };
 
-/* ---------- Domain device ---------- */
+enum {
+	SAS_DEV_GONE,
+};
+
 struct domain_device {
         enum sas_dev_type dev_type;
 
@@ -205,7 +208,7 @@ struct domain_device {
         };
 
         void *lldd_dev;
-	int gone;
+	unsigned long state;
 	struct kref kref;
 };
 

commit b1124cd3ec97406c767b90bf7e93ecd2d2915592
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Dec 19 16:42:34 2011 -0800

    [SCSI] libsas: introduce sas_drain_work()
    
    When an lldd invokes ->notify_port_event() it can trigger a chain of libsas
    events to:
    
      1/ form the port and find the direct attached device
    
      2/ if the attached device is an expander perform domain discovery
    
    A call to flush_workqueue() will only flush the initial port formation work.
    Currently libsas users need to call scsi_flush_work() up to the max depth of
    chain (which will grow from 2 to 3 when ata discovery is moved to its own
    discovery event).  Instead of open coding multiple calls switch to use
    drain_workqueue() to flush sas work.
    
    drain_workqueue() does not handle new work submitted during the drain so
    libsas needs a bit of infrastructure to hold off unchained work submissions
    while a drain is in flight.  A lldd ->notify() event is considered 'unchained'
    while a sas_discover_event() is 'chained'.  As Tejun notes:
    
      "For now, I think it would be best to add private wrapper in libsas to
       support deferring unchained work items while draining."
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 8e402d5a0640..42900fa95a03 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -330,6 +330,7 @@ struct sas_ha_event {
 
 enum sas_ha_state {
 	SAS_HA_REGISTERED,
+	SAS_HA_DRAINING,
 };
 
 struct sas_ha_struct {
@@ -337,6 +338,8 @@ struct sas_ha_struct {
 	struct sas_ha_event ha_events[HA_NUM_EVENTS];
 	unsigned long	 pending;
 
+	struct list_head  defer_q; /* work queued while draining */
+	struct mutex	  drain_mutex;
 	unsigned long	  state;
 	spinlock_t 	  state_lock;
 
@@ -657,6 +660,7 @@ int sas_eh_bus_reset_handler(struct scsi_cmnd *cmd);
 extern void sas_target_destroy(struct scsi_target *);
 extern int sas_slave_alloc(struct scsi_device *);
 extern int sas_ioctl(struct scsi_device *sdev, int cmd, void __user *arg);
+extern int sas_drain_work(struct sas_ha_struct *ha);
 
 extern int sas_smp_handler(struct Scsi_Host *shost, struct sas_rphy *rphy,
 			   struct request *req);

commit f8daa6e6d83f60a721752cb53433bfdc1503b45f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Dec 19 17:02:25 2011 -0800

    [SCSI] libsas: convert ha->state to flags
    
    In preparation for adding new states (SAS_HA_DRAINING, SAS_HA_FROZEN),
    convert ha->state into a set of flags.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index de63a664b5e5..8e402d5a0640 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -330,7 +330,6 @@ struct sas_ha_event {
 
 enum sas_ha_state {
 	SAS_HA_REGISTERED,
-	SAS_HA_UNREGISTERED
 };
 
 struct sas_ha_struct {
@@ -338,7 +337,7 @@ struct sas_ha_struct {
 	struct sas_ha_event ha_events[HA_NUM_EVENTS];
 	unsigned long	 pending;
 
-	enum sas_ha_state state;
+	unsigned long	  state;
 	spinlock_t 	  state_lock;
 
 	struct scsi_core core;

commit b15ebe0b5d0b95aeb1d84cae3649df1e0e065e9b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Nov 17 17:59:49 2011 -0800

    [SCSI] libsas: replace event locks with atomic bitops
    
    The locks only served to make sure the pending event bitmask was updated
    consistently.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 7ecb5c1c0851..de63a664b5e5 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -215,7 +215,6 @@ struct sas_discovery_event {
 };
 
 struct sas_discovery {
-	spinlock_t disc_event_lock;
 	struct sas_discovery_event disc_work[DISC_NUM_EVENTS];
 	unsigned long    pending;
 	u8     fanout_sas_addr[8];
@@ -272,7 +271,6 @@ struct asd_sas_event {
  */
 struct asd_sas_phy {
 /* private: */
-	/* protected by ha->event_lock */
 	struct asd_sas_event   port_events[PORT_NUM_EVENTS];
 	struct asd_sas_event   phy_events[PHY_NUM_EVENTS];
 
@@ -337,7 +335,6 @@ enum sas_ha_state {
 
 struct sas_ha_struct {
 /* private: */
-	spinlock_t       event_lock;
 	struct sas_ha_event ha_events[HA_NUM_EVENTS];
 	unsigned long	 pending;
 

commit 735f7d2fedf57380214221be7bed7f62d729e262
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Nov 17 17:59:47 2011 -0800

    [SCSI] libsas: fix domain_device leak
    
    Arrange for the deallocation of a struct domain_device object when it no
    longer has:
    1/ any children
    2/ references by any scsi_targets
    3/ references by a lldd
    
    The comment about domain_device lifetime in
    Documentation/scsi/libsas.txt is stale as it appears mainline never had
    a version of a struct domain_device that was registered as a kobject.
    We now manage domain_device reference counts on behalf of external
    agents.
    
    Reviewed-by: Jack Wang <jack_wang@usish.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 2b14348336d6..7ecb5c1c0851 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -206,6 +206,7 @@ struct domain_device {
 
         void *lldd_dev;
 	int gone;
+	struct kref kref;
 };
 
 struct sas_discovery_event {

commit 6f4e75a49fd07d707995865493b9f452302ae36b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Nov 17 17:59:46 2011 -0800

    [SCSI] libsas: kill sas_slave_destroy
    
    Per commit 3e4ec344 "libata: kill ATA_FLAG_DISABLED" needing to set
    ATA_DEV_NONE is a holdover from before libsas converted to the
    "new-style" ata-eh.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 6e64b038c649..2b14348336d6 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -625,7 +625,6 @@ extern int sas_queuecommand(struct Scsi_Host * ,struct scsi_cmnd *);
 extern int sas_target_alloc(struct scsi_target *);
 extern int sas_slave_alloc(struct scsi_device *);
 extern int sas_slave_configure(struct scsi_device *);
-extern void sas_slave_destroy(struct scsi_device *);
 extern int sas_change_queue_depth(struct scsi_device *, int new_depth,
 				  int reason);
 extern int sas_change_queue_type(struct scsi_device *, int qt);

commit 95ac7fd189b7e81a200b4d00b2bb6669b31acf3a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Nov 17 17:59:45 2011 -0800

    [SCSI] libsas: remove unused ata_task_resp fields
    
    Commit 1e34c838 "[SCSI] libsas: remove spurious sata control register
    read/write" removed the routines to fake the presence of the sata
    control registers, now remove the unused data structure fields to kill
    any remaining confusion.
    
    Acked-by: Jack Wang <jack_wang@usish.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 6a308d42d98f..6e64b038c649 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -171,9 +171,6 @@ struct sata_device {
 	struct ata_port *ap;
 	struct ata_host ata_host;
 	struct ata_taskfile tf;
-	u32 sstatus;
-	u32 serror;
-	u32 scontrol;
 };
 
 /* ---------- Domain device ---------- */
@@ -487,10 +484,6 @@ enum exec_status {
 struct ata_task_resp {
 	u16  frame_len;
 	u8   ending_fis[24];	  /* dev to host or data-in */
-	u32  sstatus;
-	u32  serror;
-	u32  scontrol;
-	u32  sactive;
 };
 
 #define SAS_STATUS_BUF_SIZE 96

commit 1a34c0640137eed8dabdac3a68a7a84116ac9e0d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Sep 21 22:05:34 2011 -0700

    [SCSI] libsas: fix port->dev_list locking
    
    port->dev_list maintains a list of devices attached to a given sas root port.
    It needs to be mutated under a lock as contexts outside of the
    single-threaded-libsas-workqueue access the list via sas_find_dev_by_rphy().
    Fixup locations where the list was being mutated without a lock.
    
    This is a follow-up to commit 5911e963 "[SCSI] libsas: remove expander
    from dev list on error", where Luben noted [1]:
    
        > 2/ We have unlocked list manipulations in sas_ex_discover_end_dev(),
        > sas_unregister_common_dev(), and sas_ex_discover_end_dev()
    
        Yes, I can see that and that is very unfortunate.
    
    [1]: http://marc.info/?l=linux-scsi&m=131480962006471&w=2
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index c4b7cd0b85e5..6a308d42d98f 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -656,7 +656,7 @@ int  sas_discover_event(struct asd_sas_port *, enum discover_event ev);
 int  sas_discover_sata(struct domain_device *);
 int  sas_discover_end_dev(struct domain_device *);
 
-void sas_unregister_dev(struct domain_device *);
+void sas_unregister_dev(struct asd_sas_port *port, struct domain_device *);
 
 void sas_init_dev(struct domain_device *);
 

commit b50102d3e9a43a75379407c2080f696f61cb286b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Sep 30 18:52:19 2011 -0700

    [SCSI] isci: atapi support
    
    Based on original implementation from Jiangbi Liu and Maciej Trela.
    
    ATAPI transfers happen in two-to-three stages.  The two stage atapi
    commands are those that include a dma data transfer.  The data transfer
    portion of these operations is handled by the hardware packet-dma
    acceleration.  The three-stage commands do not have a data transfer and
    are handled without hardware assistance in raw frame mode.
    
    stage1: transmit host-to-device fis to notify the device of an incoming
    atapi cdb.  Upon reception of the pio-setup-fis repost the task_context
    to perform the dma transfer of the cdb+data (go to stage3), or repost
    the task_context to transmit the cdb as a raw frame (go to stage 2).
    
    stage2: wait for hardware notification of the cdb transmission and then
    go to stage 3.
    
    stage3: wait for the arrival of the terminating device-to-host fis and
    terminate the command.
    
    To keep the implementation simple we only support ATAPI packet-dma
    protocol (for commands with data) to avoid needing to handle the data
    transfer manually (like we do for SATA-PIO).  This may affect
    compatibility for a small number of devices (see
    ATA_HORKAGE_ATAPI_MOD16_DMA).
    
    If the data-transfer underruns, or encounters an error the
    device-to-host fis is expected to arrive in the unsolicited frame queue
    to pass to libata for disposition.  However, in the DONE_UNEXP_FIS (data
    underrun) case it appears we need to craft a response.  In the
    DONE_REG_ERR case we do receive the UF and propagate it to libsas.
    
    Signed-off-by: Maciej Trela <maciej.trela@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index d455fa96dc8c..c4b7cd0b85e5 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -389,6 +389,11 @@ sdev_to_domain_dev(struct scsi_device *sdev) {
 	return starget_to_domain_dev(sdev->sdev_target);
 }
 
+static inline struct ata_device *sas_to_ata_dev(struct domain_device *dev)
+{
+	return &dev->sata_dev.ap->link.device[0];
+}
+
 static inline struct domain_device *
 cmd_to_domain_dev(struct scsi_cmnd *cmd)
 {

commit d962480e9a061505637bb16543d49e247349e25d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Sep 23 16:43:45 2011 -0700

    [SCSI] libsas: fix try_test_sas_gpio_gp_bit() build error
    
    If the user has disabled CONFIG_SCSI_SAS_HOST_SMP then libsas drivers
    will not be receiving smp-gpio frames and do not need this lookup code.
    
    Reported-by: Randy Dunlap <rdunlap@xenotime.net>
    Tested-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index ac9d80c93c68..d455fa96dc8c 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -413,7 +413,14 @@ static inline unsigned int to_sas_gpio_od(int device, int bit)
 	return 3 * device + bit;
 }
 
+#ifdef CONFIG_SCSI_SAS_HOST_SMP
 int try_test_sas_gpio_gp_bit(unsigned int od, u8 *data, u8 index, u8 count);
+#else
+static inline int try_test_sas_gpio_gp_bit(unsigned int od, u8 *data, u8 index, u8 count)
+{
+	return -1;
+}
+#endif
 
 /* ---------- Tasks ---------- */
 /*

commit ffaac8f45bfb2dffb78179baa5740de34058eef8
Author: Luben Tuikov <ltuikov@yahoo.com>
Date:   Thu Sep 22 09:41:36 2011 -0700

    [SCSI] libsas: Allow expander T-T attachments
    
    Allow expander table-to-table attachments for
    expanders that support it.
    
    Signed-off-by: Luben Tuikov <ltuikov@yahoo.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index af0a1deac930..ac9d80c93c68 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -142,8 +142,11 @@ struct expander_device {
 	u16    ex_change_count;
 	u16    max_route_indexes;
 	u8     num_phys;
+
+	u8     t2t_supp:1;
 	u8     configuring:1;
 	u8     conf_route_table:1;
+
 	u8     enclosure_logical_id[8];
 
 	struct ex_phy *ex_phy;

commit 8ec6552f4a77d15f446b00aed364e3c12d38aa6c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Sep 1 21:18:20 2011 -0700

    [SCSI] libsas: sgpio write support
    
    Add SFF-8485 v0.7 / SAS-1 smp-write-gpio register support to libsas.
    Defer SAS-2 support unless/until it defines an sgpio interface.
    
    Minimum implementation needed to get the lights blinking.
    try_test_sas_gpio_gp_bit() provides a common method to parse the
    incoming write data (raw bitstream), and the to_sas_gpio_gp_bit() helper
    routine can be used as a basis for the set/clear operations for the
    'read' implementation.  Host implementations parse as many bits
    (ODx.[012]) as are locally supported and report the number of registers
    successfully written.  If the submitted data overruns the internal
    number of registers available report the write as a success with the
    number of bytes remaining reported in ->resid_len.
    
    Example (assuming an active backplane) set the "identify" pattern for
    the first 21 devices:
    
    smp_write_gpio --count=2 --data=92,49,24,92,24,92,49,24 -t 4 --index=1 /dev/bsg/sas_hostX
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 2517254b8403..af0a1deac930 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -405,6 +405,13 @@ static inline void sas_phy_disconnected(struct asd_sas_phy *phy)
 	phy->linkrate = SAS_LINK_RATE_UNKNOWN;
 }
 
+static inline unsigned int to_sas_gpio_od(int device, int bit)
+{
+	return 3 * device + bit;
+}
+
+int try_test_sas_gpio_gp_bit(unsigned int od, u8 *data, u8 index, u8 count);
+
 /* ---------- Tasks ---------- */
 /*
       service_response |  SAS_TASK_COMPLETE  |  SAS_TASK_UNDELIVERED |
@@ -592,6 +599,10 @@ struct sas_domain_function_template {
 
 	/* Phy management */
 	int (*lldd_control_phy)(struct asd_sas_phy *, enum phy_func, void *);
+
+	/* GPIO support */
+	int (*lldd_write_gpio)(struct sas_ha_struct *, u8 reg_type,
+			       u8 reg_index, u8 reg_count, u8 *write_data);
 };
 
 extern int sas_register_ha(struct sas_ha_struct *);

commit 4fcf812ca392303aa79dd50e96e83a29faa13bd0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 29 17:26:39 2011 -0700

    [SCSI] libsas: export sas_alloc_task()
    
    Now that isci has added a 3rd open coded user of this functionality just
    share the libsas version.
    
    Acked-by: Jack Wang <jack_wang@usish.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index ee866060f8a4..2517254b8403 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -555,36 +555,14 @@ struct sas_task {
 	struct work_struct abort_work;
 };
 
-extern struct kmem_cache *sas_task_cache;
-
 #define SAS_TASK_STATE_PENDING      1
 #define SAS_TASK_STATE_DONE         2
 #define SAS_TASK_STATE_ABORTED      4
 #define SAS_TASK_NEED_DEV_RESET     8
 #define SAS_TASK_AT_INITIATOR       16
 
-static inline struct sas_task *sas_alloc_task(gfp_t flags)
-{
-	struct sas_task *task = kmem_cache_zalloc(sas_task_cache, flags);
-
-	if (task) {
-		INIT_LIST_HEAD(&task->list);
-		spin_lock_init(&task->task_state_lock);
-		task->task_state_flags = SAS_TASK_STATE_PENDING;
-		init_timer(&task->timer);
-		init_completion(&task->completion);
-	}
-
-	return task;
-}
-
-static inline void sas_free_task(struct sas_task *task)
-{
-	if (task) {
-		BUG_ON(!list_empty(&task->list));
-		kmem_cache_free(sas_task_cache, task);
-	}
-}
+extern struct sas_task *sas_alloc_task(gfp_t flags);
+extern void sas_free_task(struct sas_task *task);
 
 struct sas_domain_function_template {
 	/* The class calls these to notify the LLDD of an event. */

commit 1ca1e43e55f4cd068f997154ffaf5fa62b08b802
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Tue May 24 13:18:04 2011 -0700

    [SCSI] libsas: Add option for SATA soft reset
    
    This allows a libsas driver to optionally provide a soft reset handler
    for libata to drive.  The isci driver allows software to control the
    assertion/deassertion of SRST.
    
    [jejb: checkpatch.pl fixes]
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <jbottomley@parallels.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 8f6bb9c7f3eb..ee866060f8a4 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -604,6 +604,7 @@ struct sas_domain_function_template {
 	int (*lldd_clear_aca)(struct domain_device *, u8 *lun);
 	int (*lldd_clear_task_set)(struct domain_device *, u8 *lun);
 	int (*lldd_I_T_nexus_reset)(struct domain_device *);
+	int (*lldd_ata_soft_reset)(struct domain_device *);
 	int (*lldd_lu_reset)(struct domain_device *, u8 *lun);
 	int (*lldd_query_task)(struct sas_task *);
 

commit 00f0254ed9b19164d416dc2e3c2e81eda55a6faf
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Oct 1 13:55:52 2010 -0700

    [SCSI] libsas: fix definition of wideport, include local sas address
    
    To date libsas has only looked at the attached sas address when
    determining the formation of wide ports.  The specification and some
    hardware expects that phys with different addresses will not form a wide
    port unless the local peer phys also match each other.  Introduce a flag
    to select stricter behavior at sas_register_ha() time.  The flag can be
    dropped once it is known that all libsas users expect the same behavior.
    
    Current drivers just initialize this field to zero and get the
    traditional behavior.
    
    Reported-by: Patrick Thomson <patrick.s.thomson@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 90ce527ecf3d..8f6bb9c7f3eb 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -361,6 +361,8 @@ struct sas_ha_struct {
 	/* The class calls this to send a task for execution. */
 	int lldd_max_execute_num;
 	int lldd_queue_size;
+	int strict_wide_ports; /* both sas_addr and attached_sas_addr must match
+				* their siblings when forming wide ports */
 
 	/* LLDD calls these to notify the class of an event. */
 	void (*notify_ha_event)(struct sas_ha_struct *, enum ha_event);

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 3dec1949f69c..90ce527ecf3d 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -621,8 +621,7 @@ int sas_set_phy_speed(struct sas_phy *phy,
 int sas_phy_enable(struct sas_phy *phy, int enabled);
 int sas_phy_reset(struct sas_phy *phy, int hard_reset);
 int sas_queue_up(struct sas_task *task);
-extern int sas_queuecommand(struct scsi_cmnd *,
-		     void (*scsi_done)(struct scsi_cmnd *));
+extern int sas_queuecommand(struct Scsi_Host * ,struct scsi_cmnd *);
 extern int sas_target_alloc(struct scsi_target *);
 extern int sas_slave_alloc(struct scsi_device *);
 extern int sas_slave_configure(struct scsi_device *);

commit 56dd2c0691a5a387b7b05835fe547dc6fade9407
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Fri Oct 1 13:55:47 2010 -0700

    [SCSI] libsas: Don't issue commands to devices that have been hot-removed
    
    sd will get hung up issuing commands to flush write cache if a SAS
    device behind the expander is unplugged without warning.  Change libsas
    to reject commands to domain devices that have already gone away.
    
    [maciej.trela@intel.com: removed setting ->gone in sas_deform_port() to
     permit sync cache commands at module removal]
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Tested-by: Haipao Fan <haipao.fan@intel.com>
    Signed-off-by: Maciej Trela <maciej.trela@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index d06e13be717b..3dec1949f69c 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -205,6 +205,7 @@ struct domain_device {
         };
 
         void *lldd_dev;
+	int gone;
 };
 
 struct sas_discovery_event {

commit df64d3caab8db6ae17dacd229a03d7689a10c432
Author: James Bottomley <James.Bottomley@suse.de>
Date:   Tue Jul 27 15:51:13 2010 -0500

    [SCSI] Unify SAM_ and SAM_STAT_ macros
    
    We have two separate definitions for identical constants with nearly the
    same name.  One comes from the generic headers in scsi.h; the other is
    an enum in libsas.h ... it's causing confusion about which one is
    correct (fortunately they both are).
    
    Fix this by eliminating the libsas.h duplicate
    
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 3b586859669c..d06e13be717b 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -422,16 +422,7 @@ enum service_response {
 };
 
 enum exec_status {
-	SAM_GOOD         = 0,
-	SAM_CHECK_COND   = 2,
-	SAM_COND_MET     = 4,
-	SAM_BUSY         = 8,
-	SAM_INTERMEDIATE = 0x10,
-	SAM_IM_COND_MET  = 0x12,
-	SAM_RESV_CONFLICT= 0x14,
-	SAM_TASK_SET_FULL= 0x28,
-	SAM_ACA_ACTIVE   = 0x30,
-	SAM_TASK_ABORTED = 0x40,
+	/* The SAM_STAT_.. codes fit in the lower 6 bits */
 
 	SAS_DEV_NO_RESPONSE = 0x80,
 	SAS_DATA_UNDERRUN,

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 9eaa3f05f954..3b586859669c 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -36,6 +36,7 @@
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_transport_sas.h>
 #include <linux/scatterlist.h>
+#include <linux/slab.h>
 
 struct block_device;
 

commit e881a172dac4d9ea3b2a1540041d872963c269bd
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Oct 15 17:46:39 2009 -0700

    [SCSI] modify change_queue_depth to take in reason why it is being called
    
    This patch modifies scsi_host_template->change_queue_depth so that
    it takes an argument indicating why it is being called. This will be
    used so that if a LLD needs to do some extra processing when
    handling queue fulls or later ramp ups, it can do so.
    
    This is a simple port of the drivers setting a change_queue_depth
    callback. In the patch I just have these LLDs adjust the queue depth
    if the user was requesting it.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    
    [Vasu.Dev: v2
            Also converted pmcraid_change_queue_depth and then verified
    all modules compile  using "make allmodconfig" for any new build
    warnings on X86_64.
    
            Updated original description after combing two original
    patches from Mike to make this patch git bisectable.]
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    [jejb: fixed up 53c700]
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index e78d3b62d8ec..9eaa3f05f954 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -634,7 +634,8 @@ extern int sas_target_alloc(struct scsi_target *);
 extern int sas_slave_alloc(struct scsi_device *);
 extern int sas_slave_configure(struct scsi_device *);
 extern void sas_slave_destroy(struct scsi_device *);
-extern int sas_change_queue_depth(struct scsi_device *, int new_depth);
+extern int sas_change_queue_depth(struct scsi_device *, int new_depth,
+				  int reason);
 extern int sas_change_queue_type(struct scsi_device *, int qt);
 extern int sas_bios_param(struct scsi_device *,
 			  struct block_device *,

commit 5a6483feb0c5193519625d0ea8c4254364d423cc
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Feb 26 10:00:17 2008 -0500

    include: Remove unnecessary inclusions of asm/semaphore.h
    
    None of these files use any of the functionality promised by
    asm/semaphore.h.  It's possible that they (or some user of them) rely
    on it dragging in some unrelated header file, but I can't build all
    these files, so we'll have to fix any build failures as they come up.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 98724ba65a79..e78d3b62d8ec 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -32,7 +32,6 @@
 #include <scsi/sas.h>
 #include <linux/libata.h>
 #include <linux/list.h>
-#include <asm/semaphore.h>
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_transport_sas.h>

commit 45e6cdf41437c72ed79cee64dc69e7f740511e50
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Tue Feb 19 10:49:40 2008 -0800

    [SCSI] libsas: Provide a transport-level facility to request SAS addrs
    
    Provide a facility to use the request_firmware() interface to get a SAS
    address from userspace.  This can be used by SAS LLDDs that cannot
    obtain the address from the host adapter.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 39e1cac24bb7..98724ba65a79 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -677,4 +677,6 @@ extern void sas_ssp_task_response(struct device *dev, struct sas_task *task,
 				  struct ssp_response_iu *iu);
 struct sas_phy *sas_find_local_phy(struct domain_device *dev);
 
+int sas_request_addr(struct Scsi_Host *shost, u8 *addr);
+
 #endif /* _SASLIB_H_ */

commit 5319578ca38a8b90b6d0270c194c65d1dd8f7725
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Sat Feb 23 23:35:44 2008 -0600

    [SCSI] libsas: export sas_find_local_phy function
    
    This is needed by the to be added I_T reset function in aic94xx.  It
    needs to know the local phy so it can send a link or hard reset along
    the path.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 3ffd6b582a97..39e1cac24bb7 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -675,5 +675,6 @@ extern int sas_smp_handler(struct Scsi_Host *shost, struct sas_rphy *rphy,
 
 extern void sas_ssp_task_response(struct device *dev, struct sas_task *task,
 				  struct ssp_response_iu *iu);
+struct sas_phy *sas_find_local_phy(struct domain_device *dev);
 
 #endif /* _SASLIB_H_ */

commit 366ca51f30de1cbb5b356c70b7bb22051c558e41
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Fri Jan 18 10:47:01 2008 -0600

    [SCSI] libsas: abstract STP task status into a function
    
    Break out the frame processor for STP tasks from aic94xx so they can
    be shared by other SAS HBA's
    
    Original patch from Jeff Garzik <jeff@garzik.org>
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index a075f130303c..3ffd6b582a97 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -672,4 +672,8 @@ extern int sas_ioctl(struct scsi_device *sdev, int cmd, void __user *arg);
 
 extern int sas_smp_handler(struct Scsi_Host *shost, struct sas_rphy *rphy,
 			   struct request *req);
+
+extern void sas_ssp_task_response(struct device *dev, struct sas_task *task,
+				  struct ssp_response_iu *iu);
+
 #endif /* _SASLIB_H_ */

commit 32e8ae36b8f80372015b88b63c4358a376c9af0f
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Sun Dec 30 12:37:31 2007 -0600

    [SCSI] libsas: don't use made up error codes
    
    This is bad for two reasons:
    
         1. If they're returned to outside applications, no-one knows what
            they mean.
         2. Eventually they'll clash with the ever expanding standard error
            codes.
    
    The problem error code in question is ETASK.  I've replaced this by
    ECOMM (communications error on send) a network error code that seems to
    most closely relay what ETASK meant.
    
    Acked-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 93248cd48373..a075f130303c 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -91,8 +91,6 @@ enum discover_event {
 
 /* ---------- Expander Devices ---------- */
 
-#define ETASK 0xFA
-
 #define to_dom_device(_obj) container_of(_obj, struct domain_device, dev_obj)
 #define to_dev_attr(_attr)  container_of(_attr, struct domain_dev_attribute,\
                                          attr)

commit 8ee24023ef43c77cdaea1add00e1e45cc4fc3261
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Mon Nov 5 11:52:14 2007 -0800

    [SCSI] libsas: Fix various sparse complaints
    
    Annotate sas_queuecommand with locking details, and clean up a few
    more sparse warnings about static/non-static declarations.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index e42374cebf95..93248cd48373 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -563,7 +563,7 @@ struct sas_task {
 	struct work_struct abort_work;
 };
 
-
+extern struct kmem_cache *sas_task_cache;
 
 #define SAS_TASK_STATE_PENDING      1
 #define SAS_TASK_STATE_DONE         2
@@ -573,7 +573,6 @@ struct sas_task {
 
 static inline struct sas_task *sas_alloc_task(gfp_t flags)
 {
-	extern struct kmem_cache *sas_task_cache;
 	struct sas_task *task = kmem_cache_zalloc(sas_task_cache, flags);
 
 	if (task) {
@@ -590,7 +589,6 @@ static inline struct sas_task *sas_alloc_task(gfp_t flags)
 static inline void sas_free_task(struct sas_task *task)
 {
 	if (task) {
-		extern struct kmem_cache *sas_task_cache;
 		BUG_ON(!list_empty(&task->list));
 		kmem_cache_free(sas_task_cache, task);
 	}

commit 5929faf3334f4c69f3bb02be59d7c127e0cefa1f
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Mon Nov 5 11:51:17 2007 -0800

    [SCSI] libsas: Convert sas_proto users to sas_protocol
    
    sparse complains about the mixing of enums in libsas.  Since the
    underlying numeric values of both enums are the same, combine them
    to get rid of the warning.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index a466c2cb8955..e42374cebf95 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -122,8 +122,8 @@ struct ex_phy {
 	u8   attached_sata_dev:1;
 	u8   attached_sata_ps:1;
 
-	enum sas_proto attached_tproto;
-	enum sas_proto attached_iproto;
+	enum sas_protocol attached_tproto;
+	enum sas_protocol attached_iproto;
 
 	u8   attached_sas_addr[SAS_ADDR_SIZE];
 	u8   attached_phy_id;
@@ -191,8 +191,8 @@ struct domain_device {
 
         struct list_head dev_list_node;
 
-        enum sas_proto    iproto;
-        enum sas_proto    tproto;
+        enum sas_protocol    iproto;
+        enum sas_protocol    tproto;
 
         struct sas_rphy *rphy;
 
@@ -245,8 +245,8 @@ struct asd_sas_port {
 	enum sas_class   class;
 	u8               sas_addr[SAS_ADDR_SIZE];
 	u8               attached_sas_addr[SAS_ADDR_SIZE];
-	enum sas_proto   iproto;
-	enum sas_proto   tproto;
+	enum sas_protocol   iproto;
+	enum sas_protocol   tproto;
 
 	enum sas_oob_mode oob_mode;
 
@@ -289,8 +289,8 @@ struct asd_sas_phy {
 
 	int            id;	  /* must be set */
 	enum sas_class class;
-	enum sas_proto iproto;
-	enum sas_proto tproto;
+	enum sas_protocol iproto;
+	enum sas_protocol tproto;
 
 	enum sas_phy_type  type;
 	enum sas_phy_role  role;
@@ -537,7 +537,7 @@ struct sas_task {
 	spinlock_t   task_state_lock;
 	unsigned     task_state_flags;
 
-	enum   sas_proto      task_proto;
+	enum   sas_protocol      task_proto;
 
 	/* Used by the discovery code. */
 	struct timer_list     timer;

commit 87ae9afdcada236d0a1b38ce2c465a65916961dc
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Oct 30 10:35:04 2007 +0100

    cleanup asm/scatterlist.h includes
    
    Not architecture specific code should not #include <asm/scatterlist.h>.
    
    This patch therefore either replaces them with
    #include <linux/scatterlist.h> or simply removes them if they were
    unused.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 8dda2d66b5b9..a466c2cb8955 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -36,7 +36,7 @@
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_transport_sas.h>
-#include <asm/scatterlist.h>
+#include <linux/scatterlist.h>
 
 struct block_device;
 

commit 1d1bbee61e4ecdaad450e9bf4d9983876ed53a43
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Jul 26 09:28:37 2007 -0400

    [SCSI] libsas: Remove PCI dependencies
    
    Eliminate unnecessary PCI dependencies in libsas.  It should use generic
    DMA and struct device like other subsystems.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index df36461fe881..8dda2d66b5b9 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -348,7 +348,7 @@ struct sas_ha_struct {
 
 /* public: */
 	char *sas_ha_name;
-	struct pci_dev *pcidev;	  /* should be set */
+	struct device *dev;	  /* should be set */
 	struct module *lldd_module; /* should be set */
 
 	u8 *sas_addr;		  /* must be set */

commit ba1fc175cc6c0af7e78241e50160344f0f198282
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Mon Jul 9 12:52:08 2007 +0900

    [SCSI] libsas: add SAS management protocol handler
    
    This patch adds support for SAS Management Protocol (SMP) passthrough
    support via bsg. aic94xx can use this.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 9275a46bf2e3..df36461fe881 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -674,4 +674,6 @@ extern void sas_target_destroy(struct scsi_target *);
 extern int sas_slave_alloc(struct scsi_device *);
 extern int sas_ioctl(struct scsi_device *sdev, int cmd, void __user *arg);
 
+extern int sas_smp_handler(struct Scsi_Host *shost, struct sas_rphy *rphy,
+			   struct request *req);
 #endif /* _SASLIB_H_ */

commit 338ec57003ff9d7bc1471677e61872455977a5de
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Wed Oct 18 14:43:37 2006 -0700

    [SCSI] Migrate libsas ATA code into a separate file
    
    This is a respin of my earlier patch that migrates the ATA support code
    into a separate file.  For now, the controversial linking bits have
    been removed per James Bottomley's request for a patch that contains
    only the migration diffs, which means that libsas continues to require
    libata.  I intend to address that problem in a separate patch.
    
    This patch is against the aic94xx-sas-2.6 git tree, and it has been
    sanity tested on my x206m with Seagate SATA and SAS disks without
    uncovering any new problems.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index ce20177069a4..9275a46bf2e3 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -632,6 +632,7 @@ int sas_set_phy_speed(struct sas_phy *phy,
 		      struct sas_phy_linkrates *rates);
 int sas_phy_enable(struct sas_phy *phy, int enabled);
 int sas_phy_reset(struct sas_phy *phy, int hard_reset);
+int sas_queue_up(struct sas_task *task);
 extern int sas_queuecommand(struct scsi_cmnd *,
 		     void (*scsi_done)(struct scsi_cmnd *));
 extern int sas_target_alloc(struct scsi_target *);

commit fa1c1e8f1ece48c7baa3ba529bfd0d10a0bdf4eb
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Thu Aug 10 19:19:47 2006 -0700

    [SCSI] Add SATA support to libsas
    
    Hook the scsi_host_template functions in libsas to delegate
    functionality to libata when appropriate.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    
    Misc code changes and merge fixes and update for libata->drivers/ata
    move
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 2e6bdc4e7a0a..ce20177069a4 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -30,6 +30,7 @@
 #include <linux/timer.h>
 #include <linux/pci.h>
 #include <scsi/sas.h>
+#include <linux/libata.h>
 #include <linux/list.h>
 #include <asm/semaphore.h>
 #include <scsi/scsi_device.h>
@@ -165,6 +166,13 @@ struct sata_device {
 
         u8     port_no;        /* port number, if this is a PM (Port) */
         struct list_head children; /* PM Ports if this is a PM */
+
+	struct ata_port *ap;
+	struct ata_host ata_host;
+	struct ata_taskfile tf;
+	u32 sstatus;
+	u32 serror;
+	u32 scontrol;
 };
 
 /* ---------- Domain device ---------- */
@@ -661,4 +669,8 @@ int __sas_task_abort(struct sas_task *);
 int sas_eh_device_reset_handler(struct scsi_cmnd *cmd);
 int sas_eh_bus_reset_handler(struct scsi_cmnd *cmd);
 
+extern void sas_target_destroy(struct scsi_target *);
+extern int sas_slave_alloc(struct scsi_device *);
+extern int sas_ioctl(struct scsi_device *sdev, int cmd, void __user *arg);
+
 #endif /* _SASLIB_H_ */

commit d7a54e30d324b6f3b29a6cf2ff24c95b135013f5
Author: Christoph Hellwig <hch@infradead.org>
Date:   Thu Apr 26 09:38:01 2007 -0400

    [SCSI] sas_scsi_host: Convert to use the kthread API
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index ad0182ef7809..2e6bdc4e7a0a 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -314,8 +314,7 @@ struct scsi_core {
 	struct list_head  task_queue;
 	int               task_queue_size;
 
-	struct semaphore  queue_thread_sema;
-	int               queue_thread_kill;
+	struct task_struct *queue_thread;
 };
 
 struct sas_ha_event {

commit 5f0b1437e0708772b6fecae5900c01c3b5f9b512
Merge: 574009c1a895 81b7bbd1932a
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Sun Feb 11 11:44:25 2007 -0800

    Merge master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (97 commits)
      [SCSI] zfcp: removed wrong comment
      [SCSI] zfcp: use of uninitialized variable
      [SCSI] zfcp: Invalid locking order
      [SCSI] aic79xx: use dma_get_required_mask()
      [SCSI] aic79xx: fix bracket mismatch in unused macro
      [SCSI] BusLogic: Replace 'boolean' by 'bool'
      [SCSI] advansys: clean up warnings
      [SCSI] 53c7xx: brackets fix in uncompiled code
      [SCSI] nsp_cs: remove old scsi code
      [SCSI] aic79xx: make ahd_match_scb() static
      [SCSI] DAC960: kmalloc->kzalloc/Casting cleanups
      [SCSI] scsi_kmap_atomic_sg(): check that local irqs are disabled
      [SCSI] Buslogic: local_irq_disable() is redundant after local_irq_save()
      [SCSI] aic94xx: update for v28 firmware
      [SCSI] scsi_error: Fix lost EH commands
      [SCSI] aic94xx: Add default bus reset handler
      [SCSI] aic94xx: Remove TMF result code munging
      [SCSI] libsas: Add an LU reset mechanism to the error handler
      [SCSI] libsas: Don't BUG when connecting two expanders via wide port
      [SCSI] st: fix Tape dies if wrong block size used, bug 7919
      ...

commit c376222960ae91d5ffb9197ee36771aaed1d9f90
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Sat Feb 10 01:45:03 2007 -0800

    [PATCH] Transform kmem_cache_alloc()+memset(0) -> kmem_cache_zalloc().
    
    Replace appropriate pairs of "kmem_cache_alloc()" + "memset(0)" with the
    corresponding "kmem_cache_zalloc()" call.
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Andi Kleen <ak@muc.de>
    Cc: Roland McGrath <roland@redhat.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Greg KH <greg@kroah.com>
    Acked-by: Joel Becker <Joel.Becker@oracle.com>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Jan Kara <jack@ucw.cz>
    Cc: Michael Halcrow <mhalcrow@us.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: James Morris <jmorris@namei.org>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 0c775fceb675..0689e004a281 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -558,10 +558,9 @@ struct sas_task {
 static inline struct sas_task *sas_alloc_task(gfp_t flags)
 {
 	extern struct kmem_cache *sas_task_cache;
-	struct sas_task *task = kmem_cache_alloc(sas_task_cache, flags);
+	struct sas_task *task = kmem_cache_zalloc(sas_task_cache, flags);
 
 	if (task) {
-		memset(task, 0, sizeof(*task));
 		INIT_LIST_HEAD(&task->list);
 		spin_lock_init(&task->task_state_lock);
 		task->task_state_flags = SAS_TASK_STATE_PENDING;

commit a9344e68ac0a656475006737dbc258d69fe4f7b0
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Mon Jan 29 23:48:19 2007 -0800

    [SCSI] libsas: Add an LU reset mechanism to the error handler
    
    After discussion with andmike and dougg, it seems that the purpose of
    eh_device_reset_handler is to issue LU resets, and that
    eh_bus_reset_handler would be a more appropriate place for a phy reset.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index b200233cc6f4..8516ba68cc95 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -661,5 +661,6 @@ void sas_init_dev(struct domain_device *);
 void sas_task_abort(struct sas_task *);
 int __sas_task_abort(struct sas_task *);
 int sas_eh_device_reset_handler(struct scsi_cmnd *cmd);
+int sas_eh_bus_reset_handler(struct scsi_cmnd *cmd);
 
 #endif /* _SASLIB_H_ */

commit ad689233bee854dced741c91aff12a8771a22f6f
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Fri Jan 26 14:08:52 2007 -0800

    [SCSI] libsas: Handle SCSI commands that complete with failure codes
    
    This patch moves the code that handles SAS failures out of the main EH
    function and into a separate function.  It also detects commands that have
    no sas_task (i.e. they completed, but with error data) and sends them into
    scsi_error for processing.  This allows us to handle SCSI errors (and
    enables auto-spinup as a side effect) instead of dropping them on the
    floor and falling into an infinite loop.  It also requires the
    implementation of a device reset function, which the SAS failure code has
    been modified to employ for REQ_DEVICE_RESET.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index ca393929c10b..b200233cc6f4 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -660,5 +660,6 @@ void sas_init_dev(struct domain_device *);
 
 void sas_task_abort(struct sas_task *);
 int __sas_task_abort(struct sas_task *);
+int sas_eh_device_reset_handler(struct scsi_cmnd *cmd);
 
 #endif /* _SASLIB_H_ */

commit 6b0efb8516a5298e12033df61f9e0c376a306adb
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Thu Jan 11 14:15:43 2007 -0800

    [SCSI] libsas: Add SAS_HA state flags to avoid queueing events while unloading
    
    Track sas_ha_struct state so that we ignore events that come in while
    we're shutting things down.
    
    Signed-off-by: Malahal Naineni <malahal@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index c83426344e8f..ca393929c10b 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -323,12 +323,20 @@ struct sas_ha_event {
 	struct sas_ha_struct *ha;
 };
 
+enum sas_ha_state {
+	SAS_HA_REGISTERED,
+	SAS_HA_UNREGISTERED
+};
+
 struct sas_ha_struct {
 /* private: */
 	spinlock_t       event_lock;
 	struct sas_ha_event ha_events[HA_NUM_EVENTS];
 	unsigned long	 pending;
 
+	enum sas_ha_state state;
+	spinlock_t 	  state_lock;
+
 	struct scsi_core core;
 
 /* public: */

commit 396819fba821ad56f1b90090d256f0ab726c89c5
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Thu Jan 11 14:15:20 2007 -0800

    [SCSI] libsas: Delay issuing ABORT TASK TMF until the error handler
    
    sas_task_abort() should simply abort the upper-level SCSI command and wait
    until the error handler to send the actual ABORT TASK command.  By
    deferring things to the EH we simplify the concurrency coordination and
    eliminate some race conditions.  Note that sas_task_abort has a few hooks
    to handle libsas internal commands properly too.
    
    Also rename do_sas_task_abort to __sas_task_abort just in case we really
    want to abort the task *right now* and we don't have a scsi_cmnd attached
    to the command.  This is a hook for libata internal commands to abort.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 75df71f08ce1..c83426344e8f 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -650,6 +650,7 @@ void sas_unregister_dev(struct domain_device *);
 
 void sas_init_dev(struct domain_device *);
 
-void sas_task_abort(struct work_struct *);
+void sas_task_abort(struct sas_task *);
+int __sas_task_abort(struct sas_task *);
 
 #endif /* _SASLIB_H_ */

commit 3ebf6922b0833807e54c73f4794c74baf9945fc8
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Thu Jan 11 14:15:17 2007 -0800

    [SCSI] libsas: Enable the EH strategy handler to reset a phy after a command
    
    When a SAS LLDD needs to request a device port reset, it needs to have all
    commands aborted before it can reset the port.  Since commands are put on
    the EH's list in the order that they were queued, the LLDD can set a "need
    reset" flag in the last task to be aborted so that the EH can reset the
    port after all commands are aborted.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 1d394855b366..75df71f08ce1 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -553,6 +553,7 @@ struct sas_task {
 #define SAS_TASK_STATE_PENDING      1
 #define SAS_TASK_STATE_DONE         2
 #define SAS_TASK_STATE_ABORTED      4
+#define SAS_TASK_NEED_DEV_RESET     8
 #define SAS_TASK_AT_INITIATOR       16
 
 static inline struct sas_task *sas_alloc_task(gfp_t flags)

commit 37958fb040cf6f88b354b9fa7e846014ffbd3b73
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Thu Jan 11 14:15:15 2007 -0800

    [SCSI] libsas: Remove SAS_TASK_INITIATOR_ABORTED flag
    
    This flag is no longer necessary because we push tasks to be aborted into
    the EH as soon as we possibly can, and let the SCSI EH code take care of
    the coordination for which this flag was used.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 0689d6682aa3..1d394855b366 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -553,7 +553,6 @@ struct sas_task {
 #define SAS_TASK_STATE_PENDING      1
 #define SAS_TASK_STATE_DONE         2
 #define SAS_TASK_STATE_ABORTED      4
-#define SAS_TASK_INITIATOR_ABORTED  8
 #define SAS_TASK_AT_INITIATOR       16
 
 static inline struct sas_task *sas_alloc_task(gfp_t flags)

commit acbf167d4ad8c27f9743a4b539d51ae9535bf21c
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Thu Jan 11 14:14:57 2007 -0800

    [SCSI] libsas: Add a sysfs knob to enable/disable a phy
    
    This patch lets a user arbitrarily enable or disable a phy via sysfs.
    Potential applications include shutting down a phy to replace one
    lane of wide port, and (more importantly) providing a method for the
    libata SATL to control the phy.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index da96bcfb9e46..0689d6682aa3 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -614,6 +614,9 @@ struct sas_domain_function_template {
 extern int sas_register_ha(struct sas_ha_struct *);
 extern int sas_unregister_ha(struct sas_ha_struct *);
 
+int sas_set_phy_speed(struct sas_phy *phy,
+		      struct sas_phy_linkrates *rates);
+int sas_phy_enable(struct sas_phy *phy, int enabled);
 int sas_phy_reset(struct sas_phy *phy, int hard_reset);
 extern int sas_queuecommand(struct scsi_cmnd *,
 		     void (*scsi_done)(struct scsi_cmnd *));

commit b218a0d8e250e0ae8fd4d4e45bd66a588b380752
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Thu Jan 11 14:14:55 2007 -0800

    [SCSI] libsas: Don't give scsi_cmnds to the EH if they never made it to the SAS LLDD or have already returned
    
    On a system with many SAS targets, it appears possible that a scsi_cmnd
    can time out without ever making it to the SAS LLDD or at the same time
    that a completion is occurring.  In both of these cases, telling the
    LLDD to abort the sas_task makes no sense because the LLDD won't know
    about the sas_task; what we really want to do is to increase the timer.
    Note that this involves creating another sas_task bit to indicate
    whether or not the task has been sent to the LLDD; I could have
    implemented this by slightly redefining SAS_TASK_STATE_PENDING, but
    this way seems cleaner.
    
    This second version amends the aic94xx portion to set the
    TASK_AT_INITIATOR flag for all sas_tasks that were passed to
    lldd_execute_task.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 0c775fceb675..da96bcfb9e46 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -554,6 +554,7 @@ struct sas_task {
 #define SAS_TASK_STATE_DONE         2
 #define SAS_TASK_STATE_ABORTED      4
 #define SAS_TASK_INITIATOR_ABORTED  8
+#define SAS_TASK_AT_INITIATOR       16
 
 static inline struct sas_task *sas_alloc_task(gfp_t flags)
 {

commit e18b890bb0881bbab6f4f1a6cd20d9c60d66b003
Author: Christoph Lameter <clameter@sgi.com>
Date:   Wed Dec 6 20:33:20 2006 -0800

    [PATCH] slab: remove kmem_cache_t
    
    Replace all uses of kmem_cache_t with struct kmem_cache.
    
    The patch was generated using the following script:
    
            #!/bin/sh
            #
            # Replace one string by another in all the kernel sources.
            #
    
            set -e
    
            for file in `find * -name "*.c" -o -name "*.h"|xargs grep -l $1`; do
                    quilt add $file
                    sed -e "1,\$s/$1/$2/g" $file >/tmp/$$
                    mv /tmp/$$ $file
                    quilt refresh
            done
    
    The script was run like this
    
            sh replace kmem_cache_t "struct kmem_cache"
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 9233ed5de664..0c775fceb675 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -557,7 +557,7 @@ struct sas_task {
 
 static inline struct sas_task *sas_alloc_task(gfp_t flags)
 {
-	extern kmem_cache_t *sas_task_cache;
+	extern struct kmem_cache *sas_task_cache;
 	struct sas_task *task = kmem_cache_alloc(sas_task_cache, flags);
 
 	if (task) {
@@ -575,7 +575,7 @@ static inline struct sas_task *sas_alloc_task(gfp_t flags)
 static inline void sas_free_task(struct sas_task *task)
 {
 	if (task) {
-		extern kmem_cache_t *sas_task_cache;
+		extern struct kmem_cache *sas_task_cache;
 		BUG_ON(!list_empty(&task->list));
 		kmem_cache_free(sas_task_cache, task);
 	}

commit 06328b4f7919e9d2169d45cadc5a37b828a78eda
Author: David Howells <dhowells@redhat.com>
Date:   Wed Dec 6 15:02:26 2006 +0000

    Actually update the fixed up compile failures.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index b09bdd8c3394..9233ed5de664 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -646,6 +646,6 @@ void sas_unregister_dev(struct domain_device *);
 
 void sas_init_dev(struct domain_device *);
 
-void sas_task_abort(struct sas_task *task);
+void sas_task_abort(struct work_struct *);
 
 #endif /* _SASLIB_H_ */

commit 4796b71fbb907ce6b8a9acf1852d3646a80b4576
Merge: 6d5aefb8eaa3 ec0bf39a471b
Author: David Howells <dhowells@redhat.com>
Date:   Wed Dec 6 15:01:18 2006 +0000

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            drivers/pcmcia/ds.c
    
    Fix up merge failures with Linus's head and fix new compile failures.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

commit ec0bf39a471bf6fcd01def2bd677128cea940b73
Merge: bf83c2a31563 d32adcb85c74
Author: Linus Torvalds <torvalds@woody.osdl.org>
Date:   Tue Dec 5 16:09:46 2006 -0800

    Merge master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (73 commits)
      [SCSI] aic79xx: Add ASC-29320LPE ids to driver
      [SCSI] stex: version update
      [SCSI] stex: change wait loop code
      [SCSI] stex: add new device type support
      [SCSI] stex: update device id info
      [SCSI] stex: adjust default queue length
      [SCSI] stex: add value check in hard reset routine
      [SCSI] stex: fix controller_info command handling
      [SCSI] stex: fix biosparam calculation
      [SCSI] megaraid: fix MMIO casts
      [SCSI] tgt: fix undefined flush_dcache_page() problem
      [SCSI] libsas: better error handling in sas_expander.c
      [SCSI] lpfc 8.1.11 : Change version number to 8.1.11
      [SCSI] lpfc 8.1.11 : Misc Fixes
      [SCSI] lpfc 8.1.11 : Add soft_wwnn sysfs attribute, rename soft_wwn_enable
      [SCSI] lpfc 8.1.11 : Removed decoding of PCI Subsystem Id
      [SCSI] lpfc 8.1.11 : Add MSI (Message Signalled Interrupts) support
      [SCSI] lpfc 8.1.11 : Adjust LOG_FCP logging
      [SCSI] lpfc 8.1.11 : Fix Memory leaks
      [SCSI] lpfc 8.1.11 : Fix lpfc_multi_ring_support
      ...

commit 4c1ac1b49122b805adfa4efc620592f68dccf5db
Merge: c4028958b6ec d916faace3ef
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 5 14:37:56 2006 +0000

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            drivers/infiniband/core/iwcm.c
            drivers/net/chelsio/cxgb2.c
            drivers/net/wireless/bcm43xx/bcm43xx_main.c
            drivers/net/wireless/prism54/islpci_eth.c
            drivers/usb/core/hub.h
            drivers/usb/input/hid-core.c
            net/core/netpoll.c
    
    Fix up merge failures with Linus's head and fix new compilation failures.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

commit 4195bdbea42151c04485b0d131eed6dd97309cee
Author: Dave Jones <davej@redhat.com>
Date:   Mon Nov 27 23:58:11 2006 -0500

    [PATCH] add missing libsas include to fix s390 compilation.
    
    include/scsi/libsas.h:479: error: field 'smp_req' has incomplete type
    include/scsi/libsas.h:480: error: field 'smp_resp' has incomplete type
    
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 9582e8401669..1d77b63c5ea4 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -35,6 +35,7 @@
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_transport_sas.h>
+#include <asm/scatterlist.h>
 
 struct block_device;
 

commit dea22214790d1306f3a3444db13d2c726037b189
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Tue Nov 7 17:28:55 2006 -0800

    [PATCH] aic94xx: handle REQ_DEVICE_RESET
    
    This patch implements a REQ_DEVICE_RESET handler for the aic94xx
    driver.  Like the earlier REQ_TASK_ABORT patch, this patch defers the
    device reset to the Scsi_Host's workqueue, which has the added benefit
    of ensuring that the device reset does not happen at the same time
    that the abort tmfs are being processed.  After the phy reset, the
    busted drive should go away and be re-detected later, which is indeed
    what I've seen on both a x260 and a x206m.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index a1fc20a47c50..29f6e1af1bf9 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -597,6 +597,7 @@ struct sas_domain_function_template {
 extern int sas_register_ha(struct sas_ha_struct *);
 extern int sas_unregister_ha(struct sas_ha_struct *);
 
+int sas_phy_reset(struct sas_phy *phy, int hard_reset);
 extern int sas_queuecommand(struct scsi_cmnd *,
 		     void (*scsi_done)(struct scsi_cmnd *));
 extern int sas_target_alloc(struct scsi_target *);

commit c4028958b6ecad064b1a6303a6a5906d4fe48d73
Author: David Howells <dhowells@redhat.com>
Date:   Wed Nov 22 14:57:56 2006 +0000

    WorkStruct: make allyesconfig
    
    Fix up for make allyesconfig.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 9582e8401669..9ccc0365aa89 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -200,9 +200,14 @@ struct domain_device {
         void *lldd_dev;
 };
 
+struct sas_discovery_event {
+	struct work_struct work;
+	struct asd_sas_port *port;
+};
+
 struct sas_discovery {
 	spinlock_t disc_event_lock;
-	struct work_struct disc_work[DISC_NUM_EVENTS];
+	struct sas_discovery_event disc_work[DISC_NUM_EVENTS];
 	unsigned long    pending;
 	u8     fanout_sas_addr[8];
 	u8     eeds_a[8];
@@ -248,14 +253,19 @@ struct asd_sas_port {
 	void *lldd_port;	  /* not touched by the sas class code */
 };
 
+struct asd_sas_event {
+	struct work_struct work;
+	struct asd_sas_phy *phy;
+};
+
 /* The phy pretty much is controlled by the LLDD.
  * The class only reads those fields.
  */
 struct asd_sas_phy {
 /* private: */
 	/* protected by ha->event_lock */
-	struct work_struct   port_events[PORT_NUM_EVENTS];
-	struct work_struct   phy_events[PHY_NUM_EVENTS];
+	struct asd_sas_event   port_events[PORT_NUM_EVENTS];
+	struct asd_sas_event   phy_events[PHY_NUM_EVENTS];
 
 	unsigned long port_events_pending;
 	unsigned long phy_events_pending;
@@ -307,10 +317,15 @@ struct scsi_core {
 	int               queue_thread_kill;
 };
 
+struct sas_ha_event {
+	struct work_struct work;
+	struct sas_ha_struct *ha;
+};
+
 struct sas_ha_struct {
 /* private: */
 	spinlock_t       event_lock;
-	struct work_struct ha_events[HA_NUM_EVENTS];
+	struct sas_ha_event ha_events[HA_NUM_EVENTS];
 	unsigned long	 pending;
 
 	struct scsi_core core;

commit 79a5eb609b74e7b3638861c41b98eafa74920a1f
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Mon Oct 30 15:18:50 2006 -0800

    [SCSI] libsas: add sas_abort_task
    
    This patch adds an external function, sas_abort_task, to enable LLDDs
    to abort sas_tasks.  It also adds a work_struct so that the actual
    work of aborting a task can be shifted from tasklet context (in the
    LLDD) onto the scsi_host's workqueue.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 7bf2e8b9903c..a1fc20a47c50 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -528,6 +528,8 @@ struct sas_task {
 
 	void   *lldd_task;	  /* for use by LLDDs */
 	void   *uldd_task;
+
+	struct work_struct abort_work;
 };
 
 
@@ -627,4 +629,6 @@ void sas_unregister_dev(struct domain_device *);
 
 void sas_init_dev(struct domain_device *);
 
+void sas_task_abort(struct sas_task *task);
+
 #endif /* _SASLIB_H_ */

commit f456393e195e0aa16029985f63cd93b601a0d315
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Mon Oct 30 15:18:39 2006 -0800

    [SCSI] libsas: modify error handler to use scsi_eh_* functions
    
    This patch adds an EH done queue to sas_ha, converts the error handling
    strategy function and the sas_scsi_task_done functions in libsas to use
    the scsi_eh_* commands for error'd commands, and adds checks for the
    INITIATOR_ABORTED flag so that we do the right thing if a sas_task has
    been aborted by the initiator.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 9582e8401669..7bf2e8b9903c 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -338,6 +338,8 @@ struct sas_ha_struct {
 	void (*notify_phy_event)(struct asd_sas_phy *, enum phy_event);
 
 	void *lldd_ha;		  /* not touched by sas class code */
+
+	struct list_head eh_done_q;
 };
 
 #define SHOST_TO_SAS_HA(_shost) (*(struct sas_ha_struct **)(_shost)->hostdata)
@@ -530,9 +532,10 @@ struct sas_task {
 
 
 
-#define SAS_TASK_STATE_PENDING  1
-#define SAS_TASK_STATE_DONE     2
-#define SAS_TASK_STATE_ABORTED  4
+#define SAS_TASK_STATE_PENDING      1
+#define SAS_TASK_STATE_DONE         2
+#define SAS_TASK_STATE_ABORTED      4
+#define SAS_TASK_INITIATOR_ABORTED  8
 
 static inline struct sas_task *sas_alloc_task(gfp_t flags)
 {

commit 3cc27547d6ee2d50ecdd11e9127bc3cd1947e8dd
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Mon Sep 25 02:55:40 2006 +0100

    [PATCH] SCSI gfp_t annotations
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 8e39982fc3db..9582e8401669 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -534,7 +534,7 @@ struct sas_task {
 #define SAS_TASK_STATE_DONE     2
 #define SAS_TASK_STATE_ABORTED  4
 
-static inline struct sas_task *sas_alloc_task(unsigned long flags)
+static inline struct sas_task *sas_alloc_task(gfp_t flags)
 {
 	extern kmem_cache_t *sas_task_cache;
 	struct sas_task *task = kmem_cache_alloc(sas_task_cache, flags);
@@ -570,7 +570,7 @@ struct sas_domain_function_template {
 	void (*lldd_dev_gone)(struct domain_device *);
 
 	int (*lldd_execute_task)(struct sas_task *, int num,
-				 unsigned long gfp_flags);
+				 gfp_t gfp_flags);
 
 	/* Task Management Functions. Must be called from process context. */
 	int (*lldd_abort_task)(struct sas_task *);

commit a01e70e570a72b8a8c9a58062e4f5bdcd3986222
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Wed Sep 6 19:28:07 2006 -0500

    [SCSI] aci94xx: implement link rate setting
    
    This patch implements the ability to set the minimum and maximum
    linkrates for both libsas (for expanders) and aic94xx (for the host
    phys).  It also tidies up the setting of the hardware min and max to
    make sure they're updated when the expander emits a change broadcast.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 8d91313dd888..8e39982fc3db 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -586,7 +586,7 @@ struct sas_domain_function_template {
 	int (*lldd_clear_nexus_ha)(struct sas_ha_struct *);
 
 	/* Phy management */
-	int (*lldd_control_phy)(struct asd_sas_phy *, enum phy_func);
+	int (*lldd_control_phy)(struct asd_sas_phy *, enum phy_func, void *);
 };
 
 extern int sas_register_ha(struct sas_ha_struct *);

commit 88edf74610bd894b93438f389688bc8b4a2d3414
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Wed Sep 6 17:36:13 2006 -0500

    [SCSI] SAS: consolidate linkspeed definitions
    
    At the moment we have two separate linkspeed enumerations covering
    roughly the same values.  This patch consolidates on a single one enum
    sas_linkspeed in scsi_transport_sas.h and uses it everywhere in the
    aic94xx driver.  Eventually I'll get around to removing the duplicated
    fields in asd_sas_phy and sas_phy ...
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
index 72acdabe7f80..8d91313dd888 100644
--- a/include/scsi/libsas.h
+++ b/include/scsi/libsas.h
@@ -114,7 +114,7 @@ struct ex_phy {
 	enum ex_phy_state phy_state;
 
 	enum sas_dev_type attached_dev_type;
-	enum sas_phy_linkrate linkrate;
+	enum sas_linkrate linkrate;
 
 	u8   attached_sata_host:1;
 	u8   attached_sata_dev:1;
@@ -170,9 +170,9 @@ struct sata_device {
 struct domain_device {
         enum sas_dev_type dev_type;
 
-        enum sas_phy_linkrate linkrate;
-        enum sas_phy_linkrate min_linkrate;
-        enum sas_phy_linkrate max_linkrate;
+        enum sas_linkrate linkrate;
+        enum sas_linkrate min_linkrate;
+        enum sas_linkrate max_linkrate;
 
         int  pathways;
 
@@ -220,7 +220,7 @@ struct asd_sas_port {
 	struct domain_device *port_dev;
 	spinlock_t dev_list_lock;
 	struct list_head dev_list;
-	enum   sas_phy_linkrate linkrate;
+	enum   sas_linkrate linkrate;
 
 	struct sas_phy *phy;
 	struct work_struct work;
@@ -276,7 +276,7 @@ struct asd_sas_phy {
 	enum sas_phy_type  type;
 	enum sas_phy_role  role;
 	enum sas_oob_mode  oob_mode;
-	enum sas_phy_linkrate linkrate;
+	enum sas_linkrate linkrate;
 
 	u8   *sas_addr;		  /* must be set */
 	u8   attached_sas_addr[SAS_ADDR_SIZE]; /* class:RO, driver: R/W */
@@ -368,7 +368,7 @@ void sas_hash_addr(u8 *hashed, const u8 *sas_addr);
 static inline void sas_phy_disconnected(struct asd_sas_phy *phy)
 {
 	phy->oob_mode = OOB_NOT_CONNECTED;
-	phy->linkrate = PHY_LINKRATE_NONE;
+	phy->linkrate = SAS_LINK_RATE_UNKNOWN;
 }
 
 /* ---------- Tasks ---------- */

commit 2908d778ab3e244900c310974e1fc1c69066e450
Author: James Bottomley <James.Bottomley@SteelEye.com>
Date:   Tue Aug 29 09:22:51 2006 -0500

    [SCSI] aic94xx: new driver
    
    This is the end point of the separate aic94xx driver based on the
    original driver and transport class from Luben Tuikov
    <ltuikov@yahoo.com>
    
    The log of the separate development is:
    
    Alexis Bruemmer:
      o aic94xx: fix hotplug/unplug for expanderless systems
      o aic94xx: disable split completion timer/setting by default
      o aic94xx: wide port off expander support
      o aic94xx: remove various inline functions
      o aic94xx: use bitops
      o aic94xx: remove queue comment
      o aic94xx: remove sas_common.c
      o aic94xx: sas remove depot's
      o aic94xx: use available list_for_each_entry_safe_reverse()
      o aic94xx: sas header file merge
    
    James Bottomley:
      o aic94xx: fix TF_TMF_NO_CTX processing
      o aic94xx: convert to request_firmware interface
      o aic94xx: fix hotplug/unplug
      o aic94xx: add link error counts to the expander phys
      o aic94xx: add transport class phy reset capability
      o aic94xx: remove local_attached flag
      o Remove README
      o Fixup Makefile variable for libsas rename
      o Rename sas->libsas
      o aic94xx: correct return code for sas_discover_event
      o aic94xx: use parent backlink port
      o aic94xx: remove channel abstraction
      o aic94xx: fix routing algorithms
      o aic94xx: add backlink port
      o aic94xx: fix cascaded expander properties
      o aic94xx: fix sleep under lock
      o aic94xx: fix panic on module removal in complex topology
      o aic94xx: make use of the new sas_port
      o rename sas_port to asd_sas_port
      o Fix for eh_strategy_handler move
      o aic94xx: move entirely over to correct transport class formulation
      o remove last vestages of sas_rphy_alloc()
      o update for eh_timed_out move
      o Preliminary expander support for aic94xx
      o sas: remove event thread
      o minor warning cleanups
      o remove last vestiges of id mapping arrays
      o Further updates
      o Convert aic94xx over entirely to the transport class end device and
      o update aic94xx/sas to use the new sas transport class end device
      o [PATCH] aic94xx: attaching to the sas transport class
      o Add missing completion removal from prior patch
      o [PATCH] aic94xx: attaching to the sas transport class
      o Build fixes from akpm
    
    Jeff Garzik:
      o [scsi aic94xx] Remove ->owner from PCI info table
    
    Luben Tuikov:
      o initial aic94xx driver
    
    Mike Anderson:
      o aic94xx: fix panic on module insertion
      o aic94xx: stub out SATA_DEV case
      o aic94xx: compile warning cleanups
      o aic94xx: sas_alloc_task
      o aic94xx: ref count update
      o aic94xx nexus loss time value
      o [PATCH] aic94xx: driver assertion in non-x86 BIOS env
    
    Randy Dunlap:
      o libsas: externs not needed
    
    Robert Tarte:
      o aic94xx: sequence patch - fixes SATA support
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h
new file mode 100644
index 000000000000..72acdabe7f80
--- /dev/null
+++ b/include/scsi/libsas.h
@@ -0,0 +1,627 @@
+/*
+ * SAS host prototypes and structures header file
+ *
+ * Copyright (C) 2005 Adaptec, Inc.  All rights reserved.
+ * Copyright (C) 2005 Luben Tuikov <luben_tuikov@adaptec.com>
+ *
+ * This file is licensed under GPLv2.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ *
+ */
+
+#ifndef _LIBSAS_H_
+#define _LIBSAS_H_
+
+
+#include <linux/timer.h>
+#include <linux/pci.h>
+#include <scsi/sas.h>
+#include <linux/list.h>
+#include <asm/semaphore.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_transport_sas.h>
+
+struct block_device;
+
+enum sas_class {
+	SAS,
+	EXPANDER
+};
+
+enum sas_phy_role {
+	PHY_ROLE_NONE = 0,
+	PHY_ROLE_TARGET = 0x40,
+	PHY_ROLE_INITIATOR = 0x80,
+};
+
+enum sas_phy_type {
+        PHY_TYPE_PHYSICAL,
+        PHY_TYPE_VIRTUAL
+};
+
+/* The events are mnemonically described in sas_dump.c
+ * so when updating/adding events here, please also
+ * update the other file too.
+ */
+enum ha_event {
+	HAE_RESET             = 0U,
+	HA_NUM_EVENTS         = 1,
+};
+
+enum port_event {
+	PORTE_BYTES_DMAED     = 0U,
+	PORTE_BROADCAST_RCVD  = 1,
+	PORTE_LINK_RESET_ERR  = 2,
+	PORTE_TIMER_EVENT     = 3,
+	PORTE_HARD_RESET      = 4,
+	PORT_NUM_EVENTS       = 5,
+};
+
+enum phy_event {
+	PHYE_LOSS_OF_SIGNAL   = 0U,
+	PHYE_OOB_DONE         = 1,
+	PHYE_OOB_ERROR        = 2,
+	PHYE_SPINUP_HOLD      = 3, /* hot plug SATA, no COMWAKE sent */
+	PHY_NUM_EVENTS        = 4,
+};
+
+enum discover_event {
+	DISCE_DISCOVER_DOMAIN   = 0U,
+	DISCE_REVALIDATE_DOMAIN = 1,
+	DISCE_PORT_GONE         = 2,
+	DISC_NUM_EVENTS 	= 3,
+};
+
+/* ---------- Expander Devices ---------- */
+
+#define ETASK 0xFA
+
+#define to_dom_device(_obj) container_of(_obj, struct domain_device, dev_obj)
+#define to_dev_attr(_attr)  container_of(_attr, struct domain_dev_attribute,\
+                                         attr)
+
+enum routing_attribute {
+	DIRECT_ROUTING,
+	SUBTRACTIVE_ROUTING,
+	TABLE_ROUTING,
+};
+
+enum ex_phy_state {
+	PHY_EMPTY,
+	PHY_VACANT,
+	PHY_NOT_PRESENT,
+	PHY_DEVICE_DISCOVERED
+};
+
+struct ex_phy {
+	int    phy_id;
+
+	enum ex_phy_state phy_state;
+
+	enum sas_dev_type attached_dev_type;
+	enum sas_phy_linkrate linkrate;
+
+	u8   attached_sata_host:1;
+	u8   attached_sata_dev:1;
+	u8   attached_sata_ps:1;
+
+	enum sas_proto attached_tproto;
+	enum sas_proto attached_iproto;
+
+	u8   attached_sas_addr[SAS_ADDR_SIZE];
+	u8   attached_phy_id;
+
+	u8   phy_change_count;
+	enum routing_attribute routing_attr;
+	u8   virtual:1;
+
+	int  last_da_index;
+
+	struct sas_phy *phy;
+	struct sas_port *port;
+};
+
+struct expander_device {
+	struct list_head children;
+
+	u16    ex_change_count;
+	u16    max_route_indexes;
+	u8     num_phys;
+	u8     configuring:1;
+	u8     conf_route_table:1;
+	u8     enclosure_logical_id[8];
+
+	struct ex_phy *ex_phy;
+	struct sas_port *parent_port;
+};
+
+/* ---------- SATA device ---------- */
+enum ata_command_set {
+        ATA_COMMAND_SET   = 0,
+        ATAPI_COMMAND_SET = 1,
+};
+
+struct sata_device {
+        enum   ata_command_set command_set;
+        struct smp_resp        rps_resp; /* report_phy_sata_resp */
+        __le16 *identify_device;
+        __le16 *identify_packet_device;
+
+        u8     port_no;        /* port number, if this is a PM (Port) */
+        struct list_head children; /* PM Ports if this is a PM */
+};
+
+/* ---------- Domain device ---------- */
+struct domain_device {
+        enum sas_dev_type dev_type;
+
+        enum sas_phy_linkrate linkrate;
+        enum sas_phy_linkrate min_linkrate;
+        enum sas_phy_linkrate max_linkrate;
+
+        int  pathways;
+
+        struct domain_device *parent;
+        struct list_head siblings; /* devices on the same level */
+        struct asd_sas_port *port;        /* shortcut to root of the tree */
+
+        struct list_head dev_list_node;
+
+        enum sas_proto    iproto;
+        enum sas_proto    tproto;
+
+        struct sas_rphy *rphy;
+
+        u8  sas_addr[SAS_ADDR_SIZE];
+        u8  hashed_sas_addr[HASHED_SAS_ADDR_SIZE];
+
+        u8  frame_rcvd[32];
+
+        union {
+                struct expander_device ex_dev;
+                struct sata_device     sata_dev; /* STP & directly attached */
+        };
+
+        void *lldd_dev;
+};
+
+struct sas_discovery {
+	spinlock_t disc_event_lock;
+	struct work_struct disc_work[DISC_NUM_EVENTS];
+	unsigned long    pending;
+	u8     fanout_sas_addr[8];
+	u8     eeds_a[8];
+	u8     eeds_b[8];
+	int    max_level;
+};
+
+
+/* The port struct is Class:RW, driver:RO */
+struct asd_sas_port {
+/* private: */
+	struct completion port_gone_completion;
+
+	struct sas_discovery disc;
+	struct domain_device *port_dev;
+	spinlock_t dev_list_lock;
+	struct list_head dev_list;
+	enum   sas_phy_linkrate linkrate;
+
+	struct sas_phy *phy;
+	struct work_struct work;
+
+/* public: */
+	int id;
+
+	enum sas_class   class;
+	u8               sas_addr[SAS_ADDR_SIZE];
+	u8               attached_sas_addr[SAS_ADDR_SIZE];
+	enum sas_proto   iproto;
+	enum sas_proto   tproto;
+
+	enum sas_oob_mode oob_mode;
+
+	spinlock_t       phy_list_lock;
+	struct list_head phy_list;
+	int              num_phys;
+	u32              phy_mask;
+
+	struct sas_ha_struct *ha;
+
+	struct sas_port	*port;
+
+	void *lldd_port;	  /* not touched by the sas class code */
+};
+
+/* The phy pretty much is controlled by the LLDD.
+ * The class only reads those fields.
+ */
+struct asd_sas_phy {
+/* private: */
+	/* protected by ha->event_lock */
+	struct work_struct   port_events[PORT_NUM_EVENTS];
+	struct work_struct   phy_events[PHY_NUM_EVENTS];
+
+	unsigned long port_events_pending;
+	unsigned long phy_events_pending;
+
+	int error;
+
+	struct sas_phy *phy;
+
+/* public: */
+	/* The following are class:RO, driver:R/W */
+	int            enabled;	  /* must be set */
+
+	int            id;	  /* must be set */
+	enum sas_class class;
+	enum sas_proto iproto;
+	enum sas_proto tproto;
+
+	enum sas_phy_type  type;
+	enum sas_phy_role  role;
+	enum sas_oob_mode  oob_mode;
+	enum sas_phy_linkrate linkrate;
+
+	u8   *sas_addr;		  /* must be set */
+	u8   attached_sas_addr[SAS_ADDR_SIZE]; /* class:RO, driver: R/W */
+
+	spinlock_t     frame_rcvd_lock;
+	u8             *frame_rcvd; /* must be set */
+	int            frame_rcvd_size;
+
+	spinlock_t     sas_prim_lock;
+	u32            sas_prim;
+
+	struct list_head port_phy_el; /* driver:RO */
+	struct asd_sas_port      *port; /* Class:RW, driver: RO */
+
+	struct sas_ha_struct *ha; /* may be set; the class sets it anyway */
+
+	void *lldd_phy;		  /* not touched by the sas_class_code */
+};
+
+struct scsi_core {
+	struct Scsi_Host *shost;
+
+	spinlock_t        task_queue_lock;
+	struct list_head  task_queue;
+	int               task_queue_size;
+
+	struct semaphore  queue_thread_sema;
+	int               queue_thread_kill;
+};
+
+struct sas_ha_struct {
+/* private: */
+	spinlock_t       event_lock;
+	struct work_struct ha_events[HA_NUM_EVENTS];
+	unsigned long	 pending;
+
+	struct scsi_core core;
+
+/* public: */
+	char *sas_ha_name;
+	struct pci_dev *pcidev;	  /* should be set */
+	struct module *lldd_module; /* should be set */
+
+	u8 *sas_addr;		  /* must be set */
+	u8 hashed_sas_addr[HASHED_SAS_ADDR_SIZE];
+
+	spinlock_t      phy_port_lock;
+	struct asd_sas_phy  **sas_phy; /* array of valid pointers, must be set */
+	struct asd_sas_port **sas_port; /* array of valid pointers, must be set */
+	int             num_phys; /* must be set, gt 0, static */
+
+	/* The class calls this to send a task for execution. */
+	int lldd_max_execute_num;
+	int lldd_queue_size;
+
+	/* LLDD calls these to notify the class of an event. */
+	void (*notify_ha_event)(struct sas_ha_struct *, enum ha_event);
+	void (*notify_port_event)(struct asd_sas_phy *, enum port_event);
+	void (*notify_phy_event)(struct asd_sas_phy *, enum phy_event);
+
+	void *lldd_ha;		  /* not touched by sas class code */
+};
+
+#define SHOST_TO_SAS_HA(_shost) (*(struct sas_ha_struct **)(_shost)->hostdata)
+
+static inline struct domain_device *
+starget_to_domain_dev(struct scsi_target *starget) {
+	return starget->hostdata;
+}
+
+static inline struct domain_device *
+sdev_to_domain_dev(struct scsi_device *sdev) {
+	return starget_to_domain_dev(sdev->sdev_target);
+}
+
+static inline struct domain_device *
+cmd_to_domain_dev(struct scsi_cmnd *cmd)
+{
+	return sdev_to_domain_dev(cmd->device);
+}
+
+void sas_hash_addr(u8 *hashed, const u8 *sas_addr);
+
+/* Before calling a notify event, LLDD should use this function
+ * when the link is severed (possibly from its tasklet).
+ * The idea is that the Class only reads those, while the LLDD,
+ * can R/W these (thus avoiding a race).
+ */
+static inline void sas_phy_disconnected(struct asd_sas_phy *phy)
+{
+	phy->oob_mode = OOB_NOT_CONNECTED;
+	phy->linkrate = PHY_LINKRATE_NONE;
+}
+
+/* ---------- Tasks ---------- */
+/*
+      service_response |  SAS_TASK_COMPLETE  |  SAS_TASK_UNDELIVERED |
+  exec_status          |                     |                       |
+  ---------------------+---------------------+-----------------------+
+       SAM_...         |         X           |                       |
+       DEV_NO_RESPONSE |         X           |           X           |
+       INTERRUPTED     |         X           |                       |
+       QUEUE_FULL      |                     |           X           |
+       DEVICE_UNKNOWN  |                     |           X           |
+       SG_ERR          |                     |           X           |
+  ---------------------+---------------------+-----------------------+
+ */
+
+enum service_response {
+	SAS_TASK_COMPLETE,
+	SAS_TASK_UNDELIVERED = -1,
+};
+
+enum exec_status {
+	SAM_GOOD         = 0,
+	SAM_CHECK_COND   = 2,
+	SAM_COND_MET     = 4,
+	SAM_BUSY         = 8,
+	SAM_INTERMEDIATE = 0x10,
+	SAM_IM_COND_MET  = 0x12,
+	SAM_RESV_CONFLICT= 0x14,
+	SAM_TASK_SET_FULL= 0x28,
+	SAM_ACA_ACTIVE   = 0x30,
+	SAM_TASK_ABORTED = 0x40,
+
+	SAS_DEV_NO_RESPONSE = 0x80,
+	SAS_DATA_UNDERRUN,
+	SAS_DATA_OVERRUN,
+	SAS_INTERRUPTED,
+	SAS_QUEUE_FULL,
+	SAS_DEVICE_UNKNOWN,
+	SAS_SG_ERR,
+	SAS_OPEN_REJECT,
+	SAS_OPEN_TO,
+	SAS_PROTO_RESPONSE,
+	SAS_PHY_DOWN,
+	SAS_NAK_R_ERR,
+	SAS_PENDING,
+	SAS_ABORTED_TASK,
+};
+
+/* When a task finishes with a response, the LLDD examines the
+ * response:
+ * 	- For an ATA task task_status_struct::stat is set to
+ * SAS_PROTO_RESPONSE, and the task_status_struct::buf is set to the
+ * contents of struct ata_task_resp.
+ * 	- For SSP tasks, if no data is present or status/TMF response
+ * is valid, task_status_struct::stat is set.  If data is present
+ * (SENSE data), the LLDD copies up to SAS_STATUS_BUF_SIZE, sets
+ * task_status_struct::buf_valid_size, and task_status_struct::stat is
+ * set to SAM_CHECK_COND.
+ *
+ * "buf" has format SCSI Sense for SSP task, or struct ata_task_resp
+ * for ATA task.
+ *
+ * "frame_len" is the total frame length, which could be more or less
+ * than actually copied.
+ *
+ * Tasks ending with response, always set the residual field.
+ */
+struct ata_task_resp {
+	u16  frame_len;
+	u8   ending_fis[24];	  /* dev to host or data-in */
+	u32  sstatus;
+	u32  serror;
+	u32  scontrol;
+	u32  sactive;
+};
+
+#define SAS_STATUS_BUF_SIZE 96
+
+struct task_status_struct {
+	enum service_response resp;
+	enum exec_status      stat;
+	int  buf_valid_size;
+
+	u8   buf[SAS_STATUS_BUF_SIZE];
+
+	u32  residual;
+	enum sas_open_rej_reason open_rej_reason;
+};
+
+/* ATA and ATAPI task queuable to a SAS LLDD.
+ */
+struct sas_ata_task {
+	struct host_to_dev_fis fis;
+	u8     atapi_packet[16];  /* 0 if not ATAPI task */
+
+	u8     retry_count;	  /* hardware retry, should be > 0 */
+
+	u8     dma_xfer:1;	  /* PIO:0 or DMA:1 */
+	u8     use_ncq:1;
+	u8     set_affil_pol:1;
+	u8     stp_affil_pol:1;
+
+	u8     device_control_reg_update:1;
+};
+
+struct sas_smp_task {
+	struct scatterlist smp_req;
+	struct scatterlist smp_resp;
+};
+
+enum task_attribute {
+	TASK_ATTR_SIMPLE = 0,
+	TASK_ATTR_HOQ    = 1,
+	TASK_ATTR_ORDERED= 2,
+	TASK_ATTR_ACA    = 4,
+};
+
+struct sas_ssp_task {
+	u8     retry_count;	  /* hardware retry, should be > 0 */
+
+	u8     LUN[8];
+	u8     enable_first_burst:1;
+	enum   task_attribute task_attr;
+	u8     task_prio;
+	u8     cdb[16];
+};
+
+struct sas_task {
+	struct domain_device *dev;
+	struct list_head      list;
+
+	spinlock_t   task_state_lock;
+	unsigned     task_state_flags;
+
+	enum   sas_proto      task_proto;
+
+	/* Used by the discovery code. */
+	struct timer_list     timer;
+	struct completion     completion;
+
+	union {
+		struct sas_ata_task ata_task;
+		struct sas_smp_task smp_task;
+		struct sas_ssp_task ssp_task;
+	};
+
+	struct scatterlist *scatter;
+	int    num_scatter;
+	u32    total_xfer_len;
+	u8     data_dir:2;	  /* Use PCI_DMA_... */
+
+	struct task_status_struct task_status;
+	void   (*task_done)(struct sas_task *);
+
+	void   *lldd_task;	  /* for use by LLDDs */
+	void   *uldd_task;
+};
+
+
+
+#define SAS_TASK_STATE_PENDING  1
+#define SAS_TASK_STATE_DONE     2
+#define SAS_TASK_STATE_ABORTED  4
+
+static inline struct sas_task *sas_alloc_task(unsigned long flags)
+{
+	extern kmem_cache_t *sas_task_cache;
+	struct sas_task *task = kmem_cache_alloc(sas_task_cache, flags);
+
+	if (task) {
+		memset(task, 0, sizeof(*task));
+		INIT_LIST_HEAD(&task->list);
+		spin_lock_init(&task->task_state_lock);
+		task->task_state_flags = SAS_TASK_STATE_PENDING;
+		init_timer(&task->timer);
+		init_completion(&task->completion);
+	}
+
+	return task;
+}
+
+static inline void sas_free_task(struct sas_task *task)
+{
+	if (task) {
+		extern kmem_cache_t *sas_task_cache;
+		BUG_ON(!list_empty(&task->list));
+		kmem_cache_free(sas_task_cache, task);
+	}
+}
+
+struct sas_domain_function_template {
+	/* The class calls these to notify the LLDD of an event. */
+	void (*lldd_port_formed)(struct asd_sas_phy *);
+	void (*lldd_port_deformed)(struct asd_sas_phy *);
+
+	/* The class calls these when a device is found or gone. */
+	int  (*lldd_dev_found)(struct domain_device *);
+	void (*lldd_dev_gone)(struct domain_device *);
+
+	int (*lldd_execute_task)(struct sas_task *, int num,
+				 unsigned long gfp_flags);
+
+	/* Task Management Functions. Must be called from process context. */
+	int (*lldd_abort_task)(struct sas_task *);
+	int (*lldd_abort_task_set)(struct domain_device *, u8 *lun);
+	int (*lldd_clear_aca)(struct domain_device *, u8 *lun);
+	int (*lldd_clear_task_set)(struct domain_device *, u8 *lun);
+	int (*lldd_I_T_nexus_reset)(struct domain_device *);
+	int (*lldd_lu_reset)(struct domain_device *, u8 *lun);
+	int (*lldd_query_task)(struct sas_task *);
+
+	/* Port and Adapter management */
+	int (*lldd_clear_nexus_port)(struct asd_sas_port *);
+	int (*lldd_clear_nexus_ha)(struct sas_ha_struct *);
+
+	/* Phy management */
+	int (*lldd_control_phy)(struct asd_sas_phy *, enum phy_func);
+};
+
+extern int sas_register_ha(struct sas_ha_struct *);
+extern int sas_unregister_ha(struct sas_ha_struct *);
+
+extern int sas_queuecommand(struct scsi_cmnd *,
+		     void (*scsi_done)(struct scsi_cmnd *));
+extern int sas_target_alloc(struct scsi_target *);
+extern int sas_slave_alloc(struct scsi_device *);
+extern int sas_slave_configure(struct scsi_device *);
+extern void sas_slave_destroy(struct scsi_device *);
+extern int sas_change_queue_depth(struct scsi_device *, int new_depth);
+extern int sas_change_queue_type(struct scsi_device *, int qt);
+extern int sas_bios_param(struct scsi_device *,
+			  struct block_device *,
+			  sector_t capacity, int *hsc);
+extern struct scsi_transport_template *
+sas_domain_attach_transport(struct sas_domain_function_template *);
+extern void sas_domain_release_transport(struct scsi_transport_template *);
+
+int  sas_discover_root_expander(struct domain_device *);
+
+void sas_init_ex_attr(void);
+
+int  sas_ex_revalidate_domain(struct domain_device *);
+
+void sas_unregister_domain_devices(struct asd_sas_port *port);
+void sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *);
+int  sas_discover_event(struct asd_sas_port *, enum discover_event ev);
+
+int  sas_discover_sata(struct domain_device *);
+int  sas_discover_end_dev(struct domain_device *);
+
+void sas_unregister_dev(struct domain_device *);
+
+void sas_init_dev(struct domain_device *);
+
+#endif /* _SASLIB_H_ */
