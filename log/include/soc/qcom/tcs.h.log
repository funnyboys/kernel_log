commit 6311b6521bcc804e4d2fd45a5640562a7b8b5241
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Mon Aug 5 14:33:46 2019 -0600

    drivers: qcom: Add BCM vote macro to header
    
    The macro to generate a Bus Controller Manager (BCM) TCS command is used
    by the interconnect driver but might also be interesting to other
    drivers that need to construct TCS commands for sub processors so move
    it out of the sdm845 specific file and into the header.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Acked-by: Stephen Boyd <sboyd@kernel.org>
    Acked-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>

diff --git a/include/soc/qcom/tcs.h b/include/soc/qcom/tcs.h
index 262876a59e86..7a2a055ba6b0 100644
--- a/include/soc/qcom/tcs.h
+++ b/include/soc/qcom/tcs.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (c) 2016-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef __SOC_QCOM_TCS_H__
@@ -53,4 +53,22 @@ struct tcs_request {
 	struct tcs_cmd *cmds;
 };
 
+#define BCM_TCS_CMD_COMMIT_SHFT		30
+#define BCM_TCS_CMD_COMMIT_MASK		0x40000000
+#define BCM_TCS_CMD_VALID_SHFT		29
+#define BCM_TCS_CMD_VALID_MASK		0x20000000
+#define BCM_TCS_CMD_VOTE_X_SHFT		14
+#define BCM_TCS_CMD_VOTE_MASK		0x3fff
+#define BCM_TCS_CMD_VOTE_Y_SHFT		0
+#define BCM_TCS_CMD_VOTE_Y_MASK		0xfffc000
+
+/* Construct a Bus Clock Manager (BCM) specific TCS command */
+#define BCM_TCS_CMD(commit, valid, vote_x, vote_y)		\
+	(((commit) << BCM_TCS_CMD_COMMIT_SHFT) |		\
+	((valid) << BCM_TCS_CMD_VALID_SHFT) |			\
+	((cpu_to_le32(vote_x) &					\
+	BCM_TCS_CMD_VOTE_MASK) << BCM_TCS_CMD_VOTE_X_SHFT) |	\
+	((cpu_to_le32(vote_y) &					\
+	BCM_TCS_CMD_VOTE_MASK) << BCM_TCS_CMD_VOTE_Y_SHFT))
+
 #endif /* __SOC_QCOM_TCS_H__ */

commit 658628e7ef78e875cfe13064387c1a7a287d6338
Author: Lina Iyer <ilina@codeaurora.org>
Date:   Wed Jun 20 18:56:58 2018 +0530

    drivers: qcom: rpmh-rsc: add RPMH controller for QCOM SoCs
    
    Add controller driver for QCOM SoCs that have hardware based shared
    resource management. The hardware IP known as RSC (Resource State
    Coordinator) houses multiple Direct Resource Voter (DRV) for different
    execution levels. A DRV is a unique voter on the state of a shared
    resource. A Trigger Control Set (TCS) is a bunch of slots that can house
    multiple resource state requests, that when triggered will issue those
    requests through an internal bus to the Resource Power Manager Hardened
    (RPMH) blocks. These hardware blocks are capable of adjusting clocks,
    voltages, etc. The resource state request from a DRV are aggregated
    along with state requests from other processors in the SoC and the
    aggregate value is applied on the resource.
    
    Some important aspects of the RPMH communication -
    - Requests are <addr, value> with some header information
    - Multiple requests (upto 16) may be sent through a TCS, at a time
    - Requests in a TCS are sent in sequence
    - Requests may be fire-n-forget or completion (response expected)
    - Multiple TCS from the same DRV may be triggered simultaneously
    - Cannot send a request if another request for the same addr is in
      progress from the same DRV
    - When all the requests from a TCS are complete, an IRQ is raised
    - The IRQ handler needs to clear the TCS before it is available for
      reuse
    - TCS configuration is specific to a DRV
    - Platform drivers may use DRV from different RSCs to make requests
    
    Resource state requests made when CPUs are active are called 'active'
    state requests. Requests made when all the CPUs are powered down (idle
    state) are called 'sleep' state requests. They are matched by a
    corresponding 'wake' state requests which puts the resources back in to
    previously requested active state before resuming any CPU. TCSes are
    dedicated for each type of requests. Active mode TCSes (AMC) are used to
    send requests immediately to the resource, while control TCS are used to
    provide specific information to the controller. Sleep and Wake TCS send
    sleep and wake requests, after and before the system halt respectively.
    
    Signed-off-by: Lina Iyer <ilina@codeaurora.org>
    Signed-off-by: Raju P.L.S.S.S.N <rplsssn@codeaurora.org>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/include/soc/qcom/tcs.h b/include/soc/qcom/tcs.h
new file mode 100644
index 000000000000..262876a59e86
--- /dev/null
+++ b/include/soc/qcom/tcs.h
@@ -0,0 +1,56 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2016-2018, The Linux Foundation. All rights reserved.
+ */
+
+#ifndef __SOC_QCOM_TCS_H__
+#define __SOC_QCOM_TCS_H__
+
+#define MAX_RPMH_PAYLOAD	16
+
+/**
+ * rpmh_state: state for the request
+ *
+ * RPMH_SLEEP_STATE:       State of the resource when the processor subsystem
+ *                         is powered down. There is no client using the
+ *                         resource actively.
+ * RPMH_WAKE_ONLY_STATE:   Resume resource state to the value previously
+ *                         requested before the processor was powered down.
+ * RPMH_ACTIVE_ONLY_STATE: Active or AMC mode requests. Resource state
+ *                         is aggregated immediately.
+ */
+enum rpmh_state {
+	RPMH_SLEEP_STATE,
+	RPMH_WAKE_ONLY_STATE,
+	RPMH_ACTIVE_ONLY_STATE,
+};
+
+/**
+ * struct tcs_cmd: an individual request to RPMH.
+ *
+ * @addr: the address of the resource slv_id:18:16 | offset:0:15
+ * @data: the resource state request
+ * @wait: wait for this request to be complete before sending the next
+ */
+struct tcs_cmd {
+	u32 addr;
+	u32 data;
+	u32 wait;
+};
+
+/**
+ * struct tcs_request: A set of tcs_cmds sent together in a TCS
+ *
+ * @state:          state for the request.
+ * @wait_for_compl: wait until we get a response from the h/w accelerator
+ * @num_cmds:       the number of @cmds in this request
+ * @cmds:           an array of tcs_cmds
+ */
+struct tcs_request {
+	enum rpmh_state state;
+	u32 wait_for_compl;
+	u32 num_cmds;
+	struct tcs_cmd *cmds;
+};
+
+#endif /* __SOC_QCOM_TCS_H__ */
