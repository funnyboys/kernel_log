commit 3793faad7b5b730941b2efbc252d14374b60843a
Merge: ae1804de93f6 a811c1fa0a02
Author: David S. Miller <davem@davemloft.net>
Date:   Wed May 6 22:10:13 2020 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net
    
    Conflicts were all overlapping changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 21ce7f3e16fbf89faaf149cfe0f730edfc553914
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Mon May 4 01:20:26 2020 +0300

    net: dsa: ocelot: the MAC table on Felix is twice as large
    
    When running 'bridge fdb dump' on Felix, sometimes learnt and static MAC
    addresses would appear, sometimes they wouldn't.
    
    Turns out, the MAC table has 4096 entries on VSC7514 (Ocelot) and 8192
    entries on VSC9959 (Felix), so the existing code from the Ocelot common
    library only dumped half of Felix's MAC table. They are both organized
    as a 4-way set-associative TCAM, so we just need a single variable
    indicating the correct number of rows.
    
    Fixes: 56051948773e ("net: dsa: ocelot: add driver for Felix switch family")
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 6d6a3947c8b7..efc8b613d486 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -502,6 +502,7 @@ struct ocelot {
 	unsigned int			num_stats;
 
 	int				shared_queue_sz;
+	int				num_mact_rows;
 
 	struct net_device		*hw_bridge_dev;
 	u16				bridge_mask;

commit cc2d87bb83407c7dfb0900d63b3fcfbf6a59202f
Author: Yangbo Lu <yangbo.lu@nxp.com>
Date:   Mon Apr 20 10:46:49 2020 +0800

    net: mscc: ocelot: support 4 PTP programmable pins
    
    Support 4 PTP programmable pins with only PTP_PF_PEROUT function
    for now. The PTP_PF_EXTTS function will be supported in the
    future, and it should be implemented separately for Felix and
    Ocelot, because of different hardware interrupt implementation
    in them.
    
    Since the hardware is not able to support absolute start time,
    the periodic clock request only allows start time 0 0. But nsec
    could be accepted for PPS case for phase adjustment.
    
    Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 31193ad3a545..a025fb798164 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -92,6 +92,8 @@
 #define OCELOT_SPEED_100		2
 #define OCELOT_SPEED_10			3
 
+#define OCELOT_PTP_PINS_NUM		4
+
 #define TARGET_OFFSET			24
 #define REG_MASK			GENMASK(TARGET_OFFSET - 1, 0)
 #define REG(reg, offset)		[reg & REG_MASK] = offset
@@ -552,6 +554,7 @@ struct ocelot {
 	struct mutex			ptp_lock;
 	/* Protects the PTP clock */
 	spinlock_t			ptp_clock_lock;
+	struct ptp_pin_desc		ptp_pins[OCELOT_PTP_PINS_NUM];
 };
 
 struct ocelot_policer {

commit 94aca0824443d32987b31e656044ff7da425c523
Author: Yangbo Lu <yangbo.lu@nxp.com>
Date:   Mon Apr 20 10:46:48 2020 +0800

    net: mscc: ocelot: add wave programming registers definitions
    
    Add wave programming registers definitions for Ocelot platforms.
    
    Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 7d44d3508869..31193ad3a545 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -385,6 +385,8 @@ enum ocelot_reg {
 	PTP_PIN_TOD_SEC_MSB,
 	PTP_PIN_TOD_SEC_LSB,
 	PTP_PIN_TOD_NSEC,
+	PTP_PIN_WF_HIGH_PERIOD,
+	PTP_PIN_WF_LOW_PERIOD,
 	PTP_CFG_MISC,
 	PTP_CLK_CFG_ADJ_CFG,
 	PTP_CLK_CFG_ADJ_FREQ,

commit 3007bc7321e3c37de9d7d965cb9fb95aaa00113b
Author: Yangbo Lu <yangbo.lu@nxp.com>
Date:   Mon Apr 20 10:46:47 2020 +0800

    net: mscc: ocelot: redefine PTP pins
    
    There are 5 PTP_PINS register groups on Ocelot switch.
    Except the one used for TOD operations, there are still
    4 register groups for programmable pins. So redefine the
    4 programmable pins.
    
    Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 6fd88ee622cf..7d44d3508869 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -440,10 +440,11 @@ enum ocelot_regfield {
 	REGFIELD_MAX
 };
 
-enum ocelot_clk_pins {
-	ALT_PPS_PIN	= 1,
-	EXT_CLK_PIN,
-	ALT_LDST_PIN,
+enum ocelot_ptp_pins {
+	PTP_PIN_0,
+	PTP_PIN_1,
+	PTP_PIN_2,
+	PTP_PIN_3,
 	TOD_ACC_PIN
 };
 

commit 2b49d128b3f8d8fff8972afcbc603802e5e40c6a
Author: Yangbo Lu <yangbo.lu@nxp.com>
Date:   Mon Apr 20 10:46:45 2020 +0800

    net: mscc: ocelot: move ocelot ptp clock code out of ocelot.c
    
    The Ocelot PTP clock driver had been embedded into ocelot.c driver.
    It had supported basic gettime64/settime64/adjtime/adjfine functions
    by now which were used by both Ocelot switch and Felix switch.
    
    This patch is to move current ptp clock code out of ocelot.c driver
    maintaining as a single ocelot_ptp.c.
    For futher new features implementation, the common code could be put
    in ocelot_ptp.c and the switch specific code should be in specific
    switch driver. The interrupt implementation in SoC is different
    between Ocelot and Felix.
    
    Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 6d6a3947c8b7..6fd88ee622cf 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -620,7 +620,6 @@ int ocelot_vlan_add(struct ocelot *ocelot, int port, u16 vid, bool pvid,
 int ocelot_vlan_del(struct ocelot *ocelot, int port, u16 vid);
 int ocelot_hwstamp_get(struct ocelot *ocelot, int port, struct ifreq *ifr);
 int ocelot_hwstamp_set(struct ocelot *ocelot, int port, struct ifreq *ifr);
-int ocelot_ptp_gettime64(struct ptp_clock_info *ptp, struct timespec64 *ts);
 int ocelot_port_add_txtstamp_skb(struct ocelot_port *ocelot_port,
 				 struct sk_buff *skb);
 void ocelot_get_txtstamp(struct ocelot *ocelot);

commit 87b0f983f66f23762921129fd35966eddc3f2dae
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue Apr 14 22:36:15 2020 +0300

    net: mscc: ocelot: fix untagged packet drops when enslaving to vlan aware bridge
    
    To rehash a previous explanation given in commit 1c44ce560b4d ("net:
    mscc: ocelot: fix vlan_filtering when enslaving to bridge before link is
    up"), the switch driver operates the in a mode where a single VLAN can
    be transmitted as untagged on a particular egress port. That is the
    "native VLAN on trunk port" use case.
    
    The configuration for this native VLAN is driven in 2 ways:
     - Set the egress port rewriter to strip the VLAN tag for the native
       VID (as it is egress-untagged, after all).
     - Configure the ingress port to drop untagged and priority-tagged
       traffic, if there is no native VLAN. The intention of this setting is
       that a trunk port with no native VLAN should not accept untagged
       traffic.
    
    Since both of the above configurations for the native VLAN should only
    be done if VLAN awareness is requested, they are actually done from the
    ocelot_port_vlan_filtering function, after the basic procedure of
    toggling the VLAN awareness flag of the port.
    
    But there's a problem with that simplistic approach: we are trying to
    juggle with 2 independent variables from a single function:
     - Native VLAN of the port - its value is held in port->vid.
     - VLAN awareness state of the port - currently there are some issues
       here, more on that later*.
    The actual problem can be seen when enslaving the switch ports to a VLAN
    filtering bridge:
     0. The driver configures a pvid of zero for each port, when in
        standalone mode. While the bridge configures a default_pvid of 1 for
        each port that gets added as a slave to it.
     1. The bridge calls ocelot_port_vlan_filtering with vlan_aware=true.
        The VLAN-filtering-dependent portion of the native VLAN
        configuration is done, considering that the native VLAN is 0.
     2. The bridge calls ocelot_vlan_add with vid=1, pvid=true,
        untagged=true. The native VLAN changes to 1 (change which gets
        propagated to hardware).
     3. ??? - nobody calls ocelot_port_vlan_filtering again, to reapply the
        VLAN-filtering-dependent portion of the native VLAN configuration,
        for the new native VLAN of 1. One can notice that after toggling "ip
        link set dev br0 type bridge vlan_filtering 0 && ip link set dev br0
        type bridge vlan_filtering 1", the new native VLAN finally makes it
        through and untagged traffic finally starts flowing again. But
        obviously that shouldn't be needed.
    
    So it is clear that 2 independent variables need to both re-trigger the
    native VLAN configuration. So we introduce the second variable as
    ocelot_port->vlan_aware.
    
    *Actually both the DSA Felix driver and the Ocelot driver already had
    each its own variable:
     - Ocelot: ocelot_port_private->vlan_aware
     - Felix: dsa_port->vlan_filtering
    but the common Ocelot library needs to work with a single, common,
    variable, so there is some refactoring done to move the vlan_aware
    property from the private structure into the common ocelot_port
    structure.
    
    Fixes: 97bb69e1e36e ("net: mscc: ocelot: break apart ocelot_vlan_port_apply")
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Horatiu Vultur <horatiu.vultur@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index ebffcb36a7e3..6d6a3947c8b7 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -476,6 +476,8 @@ struct ocelot_port {
 
 	void __iomem			*regs;
 
+	bool				vlan_aware;
+
 	/* Ingress default VLAN (pvid) */
 	u16				pvid;
 
@@ -610,7 +612,7 @@ int ocelot_port_bridge_leave(struct ocelot *ocelot, int port,
 int ocelot_fdb_dump(struct ocelot *ocelot, int port,
 		    dsa_fdb_dump_cb_t *cb, void *data);
 int ocelot_fdb_add(struct ocelot *ocelot, int port,
-		   const unsigned char *addr, u16 vid, bool vlan_aware);
+		   const unsigned char *addr, u16 vid);
 int ocelot_fdb_del(struct ocelot *ocelot, int port,
 		   const unsigned char *addr, u16 vid);
 int ocelot_vlan_add(struct ocelot *ocelot, int port, u16 vid, bool pvid,

commit fc411eaac8db7bd2cf3d9b67fd4b5651345a2cef
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Sun Mar 29 14:52:00 2020 +0300

    net: dsa: felix: add port policers
    
    This patch is a trivial passthrough towards the ocelot library, which
    support port policers since commit 2c1d029a017f ("net: mscc: ocelot:
    Implement port policers via tc command").
    
    Some data structure conversion between the DSA core and the Ocelot
    library is necessary, for policer parameters.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index b5d61af9f743..ebffcb36a7e3 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -549,6 +549,11 @@ struct ocelot {
 	spinlock_t			ptp_clock_lock;
 };
 
+struct ocelot_policer {
+	u32 rate; /* kilobit per second */
+	u32 burst; /* bytes */
+};
+
 #define ocelot_read_ix(ocelot, reg, gi, ri) __ocelot_read_ix(ocelot, reg, reg##_GSZ * (gi) + reg##_RSZ * (ri))
 #define ocelot_read_gix(ocelot, reg, gi) __ocelot_read_ix(ocelot, reg, reg##_GSZ * (gi))
 #define ocelot_read_rix(ocelot, reg, ri) __ocelot_read_ix(ocelot, reg, reg##_RSZ * (ri))
@@ -619,6 +624,9 @@ int ocelot_port_add_txtstamp_skb(struct ocelot_port *ocelot_port,
 void ocelot_get_txtstamp(struct ocelot *ocelot);
 void ocelot_port_set_maxlen(struct ocelot *ocelot, int port, size_t sdu);
 int ocelot_get_max_mtu(struct ocelot *ocelot, int port);
+int ocelot_port_policer_add(struct ocelot *ocelot, int port,
+			    struct ocelot_policer *pol);
+int ocelot_port_policer_del(struct ocelot *ocelot, int port);
 int ocelot_cls_flower_replace(struct ocelot *ocelot, int port,
 			      struct flow_cls_offload *f, bool ingress);
 int ocelot_cls_flower_destroy(struct ocelot *ocelot, int port,

commit c9a7fe1238e5fb3d26cb541a12083f2e1f3b2356
Author: Xiaoliang Yang <xiaoliang.yang_1@nxp.com>
Date:   Sun Mar 29 14:51:57 2020 +0300

    net: mscc: ocelot: add action of police on vcap_is2
    
    Ocelot has 384 policers that can be allocated to ingress ports,
    QoS classes per port, and VCAP IS2 entries. ocelot_police.c
    supports to set policers which can be allocated to police action
    of VCAP IS2. We allocate policers from maximum pol_id, and
    decrease the pol_id when add a new vcap_is2 entry which is
    police action.
    
    Signed-off-by: Xiaoliang Yang <xiaoliang.yang_1@nxp.com>
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index eadbc2ddfcb5..b5d61af9f743 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -468,6 +468,7 @@ struct ocelot_ops {
 struct ocelot_acl_block {
 	struct list_head rules;
 	int count;
+	int pol_lpr;
 };
 
 struct ocelot_port {

commit 0b912fc93a680ab6105a63c36222923fbe09065e
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Fri Mar 27 21:55:47 2020 +0200

    net: dsa: felix: support changing the MTU
    
    Changing the MTU for this switch means altering the
    DEV_GMII:MAC_CFG_STATUS:MAC_MAXLEN_CFG field MAX_LEN, which in turn
    limits the size of frames that can be received.
    
    Special accounting needs to be done for the DSA CPU port (NPI port in
    hardware terms). The NPI port configuration needs to be held inside the
    private ocelot structure, since it is now accessed from multiple places.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 007b584cc431..eadbc2ddfcb5 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -517,6 +517,11 @@ struct ocelot {
 	 */
 	u8				num_phys_ports;
 
+	int				npi;
+
+	enum ocelot_tag_prefix		inj_prefix;
+	enum ocelot_tag_prefix		xtr_prefix;
+
 	u32				*lags;
 
 	struct list_head		multicast;
@@ -611,6 +616,8 @@ int ocelot_ptp_gettime64(struct ptp_clock_info *ptp, struct timespec64 *ts);
 int ocelot_port_add_txtstamp_skb(struct ocelot_port *ocelot_port,
 				 struct sk_buff *skb);
 void ocelot_get_txtstamp(struct ocelot *ocelot);
+void ocelot_port_set_maxlen(struct ocelot *ocelot, int port, size_t sdu);
+int ocelot_get_max_mtu(struct ocelot *ocelot, int port);
 int ocelot_cls_flower_replace(struct ocelot *ocelot, int port,
 			      struct flow_cls_offload *f, bool ingress);
 int ocelot_cls_flower_destroy(struct ocelot *ocelot, int port,

commit 1cf3299b038b9083cb62012d6050ac565d277f59
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Sat Feb 29 16:50:03 2020 +0200

    net: dsa: felix: Allow unknown unicast traffic towards the CPU port module
    
    Compared to other DSA switches, in the Ocelot cores, the RX filtering is
    a much more important concern.
    
    Firstly, the primary use case for Ocelot is non-DSA, so there isn't any
    secondary Ethernet MAC [the DSA master's one] to implicitly drop frames
    having a DMAC we are not interested in.  So the switch driver itself
    needs to install FDB entries towards the CPU port module (PGID_CPU) for
    the MAC address of each switch port, in each VLAN installed on the port.
    Every address that is not whitelisted is implicitly dropped. This is in
    order to achieve a behavior similar to N standalone net devices.
    
    Secondly, even in the secondary use case of DSA, such as illustrated by
    Felix with the NPI port mode, that secondary Ethernet MAC is present,
    but its RX filter is bypassed. This is because the DSA tags themselves
    are placed before Ethernet, so the DMAC that the switch ports see is
    not seen by the DSA master too (since it's shifter to the right).
    
    So RX filtering is pretty important. A good RX filter won't bother the
    CPU in case the switch port receives a frame that it's not interested
    in, and there exists no other line of defense.
    
    Ocelot is pretty strict when it comes to RX filtering: non-IP multicast
    and broadcast traffic is allowed to go to the CPU port module, but
    unknown unicast isn't. This means that traffic reception for any other
    MAC addresses than the ones configured on each switch port net device
    won't work. This includes use cases such as macvlan or bridging with a
    non-Ocelot (so-called "foreign") interface. But this seems to be fine
    for the scenarios that the Linux system embedded inside an Ocelot switch
    is intended for - it is simply not interested in unknown unicast
    traffic, as explained in Allan Nielsen's presentation [0].
    
    On the other hand, the Felix DSA switch is integrated in more
    general-purpose Linux systems, so it can't afford to drop that sort of
    traffic in hardware, even if it will end up doing so later, in software.
    
    Actually, unknown unicast means more for Felix than it does for Ocelot.
    Felix doesn't attempt to perform the whitelisting of switch port MAC
    addresses towards PGID_CPU at all, mainly because it is too complicated
    to be feasible: while the MAC addresses are unique in Ocelot, by default
    in DSA all ports are equal and inherited from the DSA master. This adds
    into account the question of reference counting MAC addresses (delayed
    ocelot_mact_forget), not to mention reference counting for the VLAN IDs
    that those MAC addresses are installed in. This reference counting
    should be done in the DSA core, and the fact that it wasn't needed so
    far is due to the fact that the other DSA switches don't have the DSA
    tag placed before Ethernet, so the DSA master is able to whitelist the
    MAC addresses in hardware.
    
    So this means that even regular traffic termination on a Felix switch
    port happens through flooding (because neither Felix nor Ocelot learn
    source MAC addresses from CPU-injected frames).
    
    So far we've explained that whitelisting towards PGID_CPU:
    - helps to reduce the likelihood of spamming the CPU with frames it
      won't process very far anyway
    - is implemented in the ocelot driver
    - is sufficient for the ocelot use cases
    - is not feasible in DSA
    - breaks use cases in DSA, in the current status (whitelisting enabled
      but no MAC address whitelisted)
    
    So the proposed patch allows unknown unicast frames to be sent to the
    CPU port module. This is done for the Felix DSA driver only, as Ocelot
    seems to be happy without it.
    
    [0]: https://www.youtube.com/watch?v=B1HhxEcU7Jg
    
    Suggested-by: Allan W. Nielsen <allan.nielsen@microchip.com>
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Allan W. Nielsen <allan.nielsen@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 23dd4ad31a32..007b584cc431 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -11,6 +11,66 @@
 #include <linux/regmap.h>
 #include <net/dsa.h>
 
+/* Port Group IDs (PGID) are masks of destination ports.
+ *
+ * For L2 forwarding, the switch performs 3 lookups in the PGID table for each
+ * frame, and forwards the frame to the ports that are present in the logical
+ * AND of all 3 PGIDs.
+ *
+ * These PGID lookups are:
+ * - In one of PGID[0-63]: for the destination masks. There are 2 paths by
+ *   which the switch selects a destination PGID:
+ *     - The {DMAC, VID} is present in the MAC table. In that case, the
+ *       destination PGID is given by the DEST_IDX field of the MAC table entry
+ *       that matched.
+ *     - The {DMAC, VID} is not present in the MAC table (it is unknown). The
+ *       frame is disseminated as being either unicast, multicast or broadcast,
+ *       and according to that, the destination PGID is chosen as being the
+ *       value contained by ANA_FLOODING_FLD_UNICAST,
+ *       ANA_FLOODING_FLD_MULTICAST or ANA_FLOODING_FLD_BROADCAST.
+ *   The destination PGID can be an unicast set: the first PGIDs, 0 to
+ *   ocelot->num_phys_ports - 1, or a multicast set: the PGIDs from
+ *   ocelot->num_phys_ports to 63. By convention, a unicast PGID corresponds to
+ *   a physical port and has a single bit set in the destination ports mask:
+ *   that corresponding to the port number itself. In contrast, a multicast
+ *   PGID will have potentially more than one single bit set in the destination
+ *   ports mask.
+ * - In one of PGID[64-79]: for the aggregation mask. The switch classifier
+ *   dissects each frame and generates a 4-bit Link Aggregation Code which is
+ *   used for this second PGID table lookup. The goal of link aggregation is to
+ *   hash multiple flows within the same LAG on to different destination ports.
+ *   The first lookup will result in a PGID with all the LAG members present in
+ *   the destination ports mask, and the second lookup, by Link Aggregation
+ *   Code, will ensure that each flow gets forwarded only to a single port out
+ *   of that mask (there are no duplicates).
+ * - In one of PGID[80-90]: for the source mask. The third time, the PGID table
+ *   is indexed with the ingress port (plus 80). These PGIDs answer the
+ *   question "is port i allowed to forward traffic to port j?" If yes, then
+ *   BIT(j) of PGID 80+i will be found set. The third PGID lookup can be used
+ *   to enforce the L2 forwarding matrix imposed by e.g. a Linux bridge.
+ */
+
+/* Reserve some destination PGIDs at the end of the range:
+ * PGID_CPU: used for whitelisting certain MAC addresses, such as the addresses
+ *           of the switch port net devices, towards the CPU port module.
+ * PGID_UC: the flooding destinations for unknown unicast traffic.
+ * PGID_MC: the flooding destinations for broadcast and non-IP multicast
+ *          traffic.
+ * PGID_MCIPV4: the flooding destinations for IPv4 multicast traffic.
+ * PGID_MCIPV6: the flooding destinations for IPv6 multicast traffic.
+ */
+#define PGID_CPU			59
+#define PGID_UC				60
+#define PGID_MC				61
+#define PGID_MCIPV4			62
+#define PGID_MCIPV6			63
+
+/* Aggregation PGIDs, one per Link Aggregation Code */
+#define PGID_AGGR			64
+
+/* Source PGIDs, one per physical port */
+#define PGID_SRC			80
+
 #define IFH_INJ_BYPASS			BIT(31)
 #define IFH_INJ_POP_CNT_DISABLE		(3 << 28)
 

commit 69df578c5f4b1f9d9b649e5fb06b5d337c25d27f
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Sat Feb 29 16:50:02 2020 +0200

    net: mscc: ocelot: eliminate confusion between CPU and NPI port
    
    Ocelot has the concept of a CPU port. The CPU port is represented in the
    forwarding and the queueing system, but it is not a physical device. The
    CPU port can either be accessed via register-based injection/extraction
    (which is the case of Ocelot), via Frame-DMA (similar to the first one),
    or "connected" to a physical Ethernet port (called NPI in the datasheet)
    which is the case of the Felix DSA switch.
    
    In Ocelot the CPU port is at index 11.
    In Felix the CPU port is at index 6.
    
    The CPU bit is treated special in the forwarding, as it is never cleared
    from the forwarding port mask (once added to it). Other than that, it is
    treated the same as a normal front port.
    
    Both Felix and Ocelot should use the CPU port in the same way. This
    means that Felix should not use the NPI port directly when forwarding to
    the CPU, but instead use the CPU port.
    
    This patch is fixing this such that Felix will use port 6 as its CPU
    port, and just use the NPI port to carry the traffic.
    
    Therefore, eliminate the "ocelot->cpu" variable which was holding the
    index of the NPI port for Felix, and the index of the CPU port module
    for Ocelot, so the variable was actually configuring different things
    for different drivers and causing at least part of the confusion.
    
    Also remove the "ocelot->num_cpu_ports" variable, which is the result of
    another confusion. The 2 CPU ports mentioned in the datasheet are
    because there are two frame extraction channels (register based or DMA
    based). This is of no relevance to the driver at the moment, and
    invisible to the analyzer module.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Suggested-by: Allan W. Nielsen <allan.nielsen@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 5b037f976245..23dd4ad31a32 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -451,9 +451,11 @@ struct ocelot {
 	/* Keep track of the vlan port masks */
 	u32				vlan_mask[VLAN_N_VID];
 
+	/* In tables like ANA:PORT and the ANA:PGID:PGID mask,
+	 * the CPU is located after the physical ports (at the
+	 * num_phys_ports index).
+	 */
 	u8				num_phys_ports;
-	u8				num_cpu_ports;
-	u8				cpu;
 
 	u32				*lags;
 
@@ -508,9 +510,9 @@ void __ocelot_rmw_ix(struct ocelot *ocelot, u32 val, u32 mask, u32 reg,
 int ocelot_regfields_init(struct ocelot *ocelot,
 			  const struct reg_field *const regfields);
 struct regmap *ocelot_regmap_init(struct ocelot *ocelot, struct resource *res);
-void ocelot_set_cpu_port(struct ocelot *ocelot, int cpu,
-			 enum ocelot_tag_prefix injection,
-			 enum ocelot_tag_prefix extraction);
+void ocelot_configure_cpu(struct ocelot *ocelot, int npi,
+			  enum ocelot_tag_prefix injection,
+			  enum ocelot_tag_prefix extraction);
 int ocelot_init(struct ocelot *ocelot);
 void ocelot_deinit(struct ocelot *ocelot);
 void ocelot_init_port(struct ocelot *ocelot, int port);

commit 07d985eef07348345870f1062797852cb4489b83
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Sat Feb 29 16:31:14 2020 +0200

    net: dsa: felix: Wire up the ocelot cls_flower methods
    
    Export the cls_flower methods from the ocelot driver and hook them up to
    the DSA passthrough layer.
    
    Tables for the VCAP IS2 parameters, as well as half key packing (field
    offsets and lengths) need to be defined for the VSC9959 core, as they
    are different from Ocelot, mainly due to the different port count.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 30270571fb71..5b037f976245 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -549,5 +549,11 @@ int ocelot_ptp_gettime64(struct ptp_clock_info *ptp, struct timespec64 *ts);
 int ocelot_port_add_txtstamp_skb(struct ocelot_port *ocelot_port,
 				 struct sk_buff *skb);
 void ocelot_get_txtstamp(struct ocelot *ocelot);
+int ocelot_cls_flower_replace(struct ocelot *ocelot, int port,
+			      struct flow_cls_offload *f, bool ingress);
+int ocelot_cls_flower_destroy(struct ocelot *ocelot, int port,
+			      struct flow_cls_offload *f, bool ingress);
+int ocelot_cls_flower_stats(struct ocelot *ocelot, int port,
+			    struct flow_cls_offload *f, bool ingress);
 
 #endif

commit 8551cdeb2ad1711e3ae85799ad9cc41c0bc64e0b
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Sat Feb 29 16:31:12 2020 +0200

    net: mscc: ocelot: parameterize the vcap_is2 properties
    
    Remove the definitions for the VCAP IS2 table from ocelot_ace.c, since
    it is specific to VSC7514.
    
    The VSC9959 VCAP IS2 table supports more rules (1024 instead of 64) and
    has a different width for the action (89 bits instead of 99).
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 45630bee8ed2..30270571fb71 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -463,6 +463,7 @@ struct ocelot {
 
 	const struct vcap_field		*vcap_is2_keys;
 	const struct vcap_field		*vcap_is2_actions;
+	const struct vcap_props		*vcap;
 
 	/* Workqueue to check statistics for overflow with its lock */
 	struct mutex			stats_lock;

commit 1ba8f6561a3ba3a4ac4becadb691667645fe73d2
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Sat Feb 29 16:31:11 2020 +0200

    net: mscc: ocelot: remove port_pcs_init indirection for VSC7514
    
    The Felix driver is now using its own PHYLINK instance, not calling into
    ocelot_adjust_link. So the port_pcs_init function pointer is an
    unnecessary indirection. Remove it.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Tested-by: Horatiu Vultur <horatiu.vultur@microchip.com>
    Reviewed-by: Allan W. Nielsen <allan.nielsen@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 3da8285d4cd8..45630bee8ed2 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -402,7 +402,6 @@ enum ocelot_tag_prefix {
 struct ocelot;
 
 struct ocelot_ops {
-	void (*pcs_init)(struct ocelot *ocelot, int port);
 	int (*reset)(struct ocelot *ocelot);
 };
 
@@ -479,8 +478,6 @@ struct ocelot {
 	struct mutex			ptp_lock;
 	/* Protects the PTP clock */
 	spinlock_t			ptp_clock_lock;
-
-	void (*port_pcs_init)(struct ocelot_port *port);
 };
 
 #define ocelot_read_ix(ocelot, reg, gi, ri) __ocelot_read_ix(ocelot, reg, reg##_GSZ * (gi) + reg##_RSZ * (ri))

commit e0632940bc4c986f2dc9c8ee6aba65c14e30c762
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Sat Feb 29 16:31:10 2020 +0200

    net: mscc: ocelot: don't rely on preprocessor for vcap key/action packing
    
    The IGR_PORT_MASK key width is different between the 11-port VSC7514 and
    the 6-port VSC9959 switches. And since IGR_PORT_MASK is one of the first
    fields of a VCAP key entry, it means that all further field
    offset/length pairs are shifted between the 2.
    
    The ocelot driver performs packing of VCAP half keys with the help of
    some preprocessor macros:
    
    - A set of macros for defining the HKO (Half Key Offset) and HKL (Half
      Key Length) of each possible key field. The offset of each field is
      defined as the sum between the offset and the sum of the previous
      field.
    
    - A set of accessors on top of vcap_key_set for shorter (aka less
      typing) access to the HKO and HKL of each key field.
    
    Since the field offsets and lengths are different between switches,
    defining them through the preprocessor isn't going to fly. So introduce
    a structure holding (offset, length) pairs and instantiate it in
    ocelot_board.c for VSC7514. In a future patch, a similar structure will
    be instantiated in felix_vsc9959.c for NXP LS1028A.
    
    The accessors also need to go. They are based on macro name
    concatenation, which is horrible to understand and follow.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Tested-by: Horatiu Vultur <horatiu.vultur@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 74e7c63adad4..3da8285d4cd8 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -462,6 +462,9 @@ struct ocelot {
 
 	struct ocelot_acl_block		acl_block;
 
+	const struct vcap_field		*vcap_is2_keys;
+	const struct vcap_field		*vcap_is2_actions;
+
 	/* Workqueue to check statistics for overflow with its lock */
 	struct mutex			stats_lock;
 	u64				*stats;

commit a56d7a345dd67995ba415a26a0164a72780f2d02
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Sat Feb 29 16:31:06 2020 +0200

    net: mscc: ocelot: simplify tc-flower offload structures
    
    The ocelot tc-flower offload binds a second flow block callback (apart
    from the one for matchall) just because it uses a different block
    private structure (ocelot_port_private for matchall, ocelot_port_block
    for flower).
    
    But ocelot_port_block just appears to be boilerplate, and doesn't help
    with anything in particular at all, it's just useless glue between the
    (global!) struct ocelot_acl_block *block pointer, and a per-netdevice
    struct ocelot_port_private *priv.
    
    So let's just simplify that, and make struct ocelot_port_private be the
    private structure for the block offload. This makes us able to use the
    same flow callback as in the case of matchall.
    
    This also reveals that the struct ocelot_acl_block *block is used rather
    strangely, as mentioned above: it is defined globally, allocated at
    probe time, and freed at unbind time. So just move the structure to the
    main ocelot structure, which gives further opportunity for
    simplification.
    
    Also get rid of backpointers from struct ocelot_acl_block and struct
    ocelot_ace_rule back to struct ocelot, by reworking the function
    prototypes, where necessary, to use a more DSA-friendly "struct ocelot
    *ocelot, int port" format.
    
    And finally, remove the debugging prints that were added during
    development, since they provide no useful information at this point.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Tested-by: Horatiu Vultur <horatiu.vultur@microchip.com>
    Reviewed-by: Allan W. Nielsen <allan.nielsen@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 068f96b1a83e..74e7c63adad4 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -406,6 +406,11 @@ struct ocelot_ops {
 	int (*reset)(struct ocelot *ocelot);
 };
 
+struct ocelot_acl_block {
+	struct list_head rules;
+	int count;
+};
+
 struct ocelot_port {
 	struct ocelot			*ocelot;
 
@@ -455,6 +460,8 @@ struct ocelot {
 
 	struct list_head		multicast;
 
+	struct ocelot_acl_block		acl_block;
+
 	/* Workqueue to check statistics for overflow with its lock */
 	struct mutex			stats_lock;
 	u64				*stats;

commit ee50d07c9fc8155b5a3c6c29eae1459a12cf2fb4
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Mon Jan 6 03:34:15 2020 +0200

    net: mscc: ocelot: make phy_mode a member of the common struct ocelot_port
    
    The Ocelot switchdev driver and the Felix DSA one need it for different
    reasons. Felix (or at least the VSC9959 instantiation in NXP LS1028A) is
    integrated with the traditional NXP Layerscape PCS design which does not
    support runtime configuration of SerDes protocol. So it needs to
    pre-validate the phy-mode from the device tree and prevent PHYLINK from
    attempting to change it. For this, it needs to cache it in a private
    variable.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 64cbbbe74a36..068f96b1a83e 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -420,6 +420,8 @@ struct ocelot_port {
 	u8				ptp_cmd;
 	struct sk_buff_head		tx_skbs;
 	u8				ts_id;
+
+	phy_interface_t			phy_mode;
 };
 
 struct ocelot {

commit b049da1338082714262034a8c8b87022623dc106
Author: Yangbo Lu <yangbo.lu@nxp.com>
Date:   Wed Nov 27 15:27:57 2019 +0800

    net: mscc: ocelot: use skb queue instead of skbs list
    
    Convert to use skb queue instead of the list of skbs.
    The skb queue could provide protection with lock.
    
    Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index e1108a5f4f17..64cbbbe74a36 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -406,13 +406,6 @@ struct ocelot_ops {
 	int (*reset)(struct ocelot *ocelot);
 };
 
-struct ocelot_skb {
-	struct list_head head;
-	struct sk_buff *skb;
-	u8 id;
-};
-
-
 struct ocelot_port {
 	struct ocelot			*ocelot;
 
@@ -425,7 +418,7 @@ struct ocelot_port {
 	u16				vid;
 
 	u8				ptp_cmd;
-	struct list_head		skbs;
+	struct sk_buff_head		tx_skbs;
 	u8				ts_id;
 };
 

commit 400928bf928be153cddd76d9ac4e39978cb43fd3
Author: Yangbo Lu <yangbo.lu@nxp.com>
Date:   Wed Nov 20 16:23:16 2019 +0800

    net: mscc: ocelot: convert to use ocelot_port_add_txtstamp_skb()
    
    Convert to use ocelot_port_add_txtstamp_skb() for adding skbs which
    require TX timestamp into list. Export it so that DSA Felix driver
    could reuse it too.
    
    Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 1a5cb1b2ac5d..e1108a5f4f17 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -543,6 +543,8 @@ int ocelot_vlan_del(struct ocelot *ocelot, int port, u16 vid);
 int ocelot_hwstamp_get(struct ocelot *ocelot, int port, struct ifreq *ifr);
 int ocelot_hwstamp_set(struct ocelot *ocelot, int port, struct ifreq *ifr);
 int ocelot_ptp_gettime64(struct ptp_clock_info *ptp, struct timespec64 *ts);
+int ocelot_port_add_txtstamp_skb(struct ocelot_port *ocelot_port,
+				 struct sk_buff *skb);
 void ocelot_get_txtstamp(struct ocelot *ocelot);
 
 #endif

commit e23a7b3e8daa4be3d91544d8ba210f96d2266de9
Author: Yangbo Lu <yangbo.lu@nxp.com>
Date:   Wed Nov 20 16:23:15 2019 +0800

    net: mscc: ocelot: convert to use ocelot_get_txtstamp()
    
    The method getting TX timestamp by reading timestamp FIFO and
    matching skbs list is common for DSA Felix driver too.
    So move code out of ocelot_board.c, convert to use
    ocelot_get_txtstamp() function and export it.
    
    Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 2bac4bc34cf6..1a5cb1b2ac5d 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -406,6 +406,13 @@ struct ocelot_ops {
 	int (*reset)(struct ocelot *ocelot);
 };
 
+struct ocelot_skb {
+	struct list_head head;
+	struct sk_buff *skb;
+	u8 id;
+};
+
+
 struct ocelot_port {
 	struct ocelot			*ocelot;
 
@@ -536,6 +543,6 @@ int ocelot_vlan_del(struct ocelot *ocelot, int port, u16 vid);
 int ocelot_hwstamp_get(struct ocelot *ocelot, int port, struct ifreq *ifr);
 int ocelot_hwstamp_set(struct ocelot *ocelot, int port, struct ifreq *ifr);
 int ocelot_ptp_gettime64(struct ptp_clock_info *ptp, struct timespec64 *ts);
-void ocelot_get_hwtimestamp(struct ocelot *ocelot, struct timespec64 *ts);
+void ocelot_get_txtstamp(struct ocelot *ocelot);
 
 #endif

commit f145922ddcaa1cb9688b3d053622c98d9f9a7fff
Author: Yangbo Lu <yangbo.lu@nxp.com>
Date:   Wed Nov 20 16:23:14 2019 +0800

    net: mscc: ocelot: export ocelot_hwstamp_get/set functions
    
    Export ocelot_hwstamp_get/set functions so that DSA driver
    is able to reuse them.
    
    Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index a836afe8f68e..2bac4bc34cf6 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -533,6 +533,8 @@ int ocelot_fdb_del(struct ocelot *ocelot, int port,
 int ocelot_vlan_add(struct ocelot *ocelot, int port, u16 vid, bool pvid,
 		    bool untagged);
 int ocelot_vlan_del(struct ocelot *ocelot, int port, u16 vid);
+int ocelot_hwstamp_get(struct ocelot *ocelot, int port, struct ifreq *ifr);
+int ocelot_hwstamp_set(struct ocelot *ocelot, int port, struct ifreq *ifr);
 int ocelot_ptp_gettime64(struct ptp_clock_info *ptp, struct timespec64 *ts);
 void ocelot_get_hwtimestamp(struct ocelot *ocelot, struct timespec64 *ts);
 

commit 5e2563650232a4d998a60b10d3679f65dd4c02fb
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Thu Nov 14 17:03:27 2019 +0200

    net: mscc: ocelot: publish structure definitions to include/soc/mscc/ocelot.h
    
    We will be registering another switch driver based on ocelot, which
    lives under drivers/net/dsa.
    
    Make sure the Felix DSA front-end has the necessary abstractions to
    implement a new Ocelot driver instantiation. This includes the function
    prototypes for implementing DSA callbacks.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
new file mode 100644
index 000000000000..a836afe8f68e
--- /dev/null
+++ b/include/soc/mscc/ocelot.h
@@ -0,0 +1,539 @@
+/* SPDX-License-Identifier: (GPL-2.0 OR MIT) */
+/* Copyright (c) 2017 Microsemi Corporation
+ */
+
+#ifndef _SOC_MSCC_OCELOT_H
+#define _SOC_MSCC_OCELOT_H
+
+#include <linux/ptp_clock_kernel.h>
+#include <linux/net_tstamp.h>
+#include <linux/if_vlan.h>
+#include <linux/regmap.h>
+#include <net/dsa.h>
+
+#define IFH_INJ_BYPASS			BIT(31)
+#define IFH_INJ_POP_CNT_DISABLE		(3 << 28)
+
+#define IFH_TAG_TYPE_C			0
+#define IFH_TAG_TYPE_S			1
+
+#define IFH_REW_OP_NOOP			0x0
+#define IFH_REW_OP_DSCP			0x1
+#define IFH_REW_OP_ONE_STEP_PTP		0x2
+#define IFH_REW_OP_TWO_STEP_PTP		0x3
+#define IFH_REW_OP_ORIGIN_PTP		0x5
+
+#define OCELOT_TAG_LEN			16
+#define OCELOT_SHORT_PREFIX_LEN		4
+#define OCELOT_LONG_PREFIX_LEN		16
+
+#define OCELOT_SPEED_2500		0
+#define OCELOT_SPEED_1000		1
+#define OCELOT_SPEED_100		2
+#define OCELOT_SPEED_10			3
+
+#define TARGET_OFFSET			24
+#define REG_MASK			GENMASK(TARGET_OFFSET - 1, 0)
+#define REG(reg, offset)		[reg & REG_MASK] = offset
+
+#define REG_RESERVED_ADDR		0xffffffff
+#define REG_RESERVED(reg)		REG(reg, REG_RESERVED_ADDR)
+
+enum ocelot_target {
+	ANA = 1,
+	QS,
+	QSYS,
+	REW,
+	SYS,
+	S2,
+	HSIO,
+	PTP,
+	GCB,
+	TARGET_MAX,
+};
+
+enum ocelot_reg {
+	ANA_ADVLEARN = ANA << TARGET_OFFSET,
+	ANA_VLANMASK,
+	ANA_PORT_B_DOMAIN,
+	ANA_ANAGEFIL,
+	ANA_ANEVENTS,
+	ANA_STORMLIMIT_BURST,
+	ANA_STORMLIMIT_CFG,
+	ANA_ISOLATED_PORTS,
+	ANA_COMMUNITY_PORTS,
+	ANA_AUTOAGE,
+	ANA_MACTOPTIONS,
+	ANA_LEARNDISC,
+	ANA_AGENCTRL,
+	ANA_MIRRORPORTS,
+	ANA_EMIRRORPORTS,
+	ANA_FLOODING,
+	ANA_FLOODING_IPMC,
+	ANA_SFLOW_CFG,
+	ANA_PORT_MODE,
+	ANA_CUT_THRU_CFG,
+	ANA_PGID_PGID,
+	ANA_TABLES_ANMOVED,
+	ANA_TABLES_MACHDATA,
+	ANA_TABLES_MACLDATA,
+	ANA_TABLES_STREAMDATA,
+	ANA_TABLES_MACACCESS,
+	ANA_TABLES_MACTINDX,
+	ANA_TABLES_VLANACCESS,
+	ANA_TABLES_VLANTIDX,
+	ANA_TABLES_ISDXACCESS,
+	ANA_TABLES_ISDXTIDX,
+	ANA_TABLES_ENTRYLIM,
+	ANA_TABLES_PTP_ID_HIGH,
+	ANA_TABLES_PTP_ID_LOW,
+	ANA_TABLES_STREAMACCESS,
+	ANA_TABLES_STREAMTIDX,
+	ANA_TABLES_SEQ_HISTORY,
+	ANA_TABLES_SEQ_MASK,
+	ANA_TABLES_SFID_MASK,
+	ANA_TABLES_SFIDACCESS,
+	ANA_TABLES_SFIDTIDX,
+	ANA_MSTI_STATE,
+	ANA_OAM_UPM_LM_CNT,
+	ANA_SG_ACCESS_CTRL,
+	ANA_SG_CONFIG_REG_1,
+	ANA_SG_CONFIG_REG_2,
+	ANA_SG_CONFIG_REG_3,
+	ANA_SG_CONFIG_REG_4,
+	ANA_SG_CONFIG_REG_5,
+	ANA_SG_GCL_GS_CONFIG,
+	ANA_SG_GCL_TI_CONFIG,
+	ANA_SG_STATUS_REG_1,
+	ANA_SG_STATUS_REG_2,
+	ANA_SG_STATUS_REG_3,
+	ANA_PORT_VLAN_CFG,
+	ANA_PORT_DROP_CFG,
+	ANA_PORT_QOS_CFG,
+	ANA_PORT_VCAP_CFG,
+	ANA_PORT_VCAP_S1_KEY_CFG,
+	ANA_PORT_VCAP_S2_CFG,
+	ANA_PORT_PCP_DEI_MAP,
+	ANA_PORT_CPU_FWD_CFG,
+	ANA_PORT_CPU_FWD_BPDU_CFG,
+	ANA_PORT_CPU_FWD_GARP_CFG,
+	ANA_PORT_CPU_FWD_CCM_CFG,
+	ANA_PORT_PORT_CFG,
+	ANA_PORT_POL_CFG,
+	ANA_PORT_PTP_CFG,
+	ANA_PORT_PTP_DLY1_CFG,
+	ANA_PORT_PTP_DLY2_CFG,
+	ANA_PORT_SFID_CFG,
+	ANA_PFC_PFC_CFG,
+	ANA_PFC_PFC_TIMER,
+	ANA_IPT_OAM_MEP_CFG,
+	ANA_IPT_IPT,
+	ANA_PPT_PPT,
+	ANA_FID_MAP_FID_MAP,
+	ANA_AGGR_CFG,
+	ANA_CPUQ_CFG,
+	ANA_CPUQ_CFG2,
+	ANA_CPUQ_8021_CFG,
+	ANA_DSCP_CFG,
+	ANA_DSCP_REWR_CFG,
+	ANA_VCAP_RNG_TYPE_CFG,
+	ANA_VCAP_RNG_VAL_CFG,
+	ANA_VRAP_CFG,
+	ANA_VRAP_HDR_DATA,
+	ANA_VRAP_HDR_MASK,
+	ANA_DISCARD_CFG,
+	ANA_FID_CFG,
+	ANA_POL_PIR_CFG,
+	ANA_POL_CIR_CFG,
+	ANA_POL_MODE_CFG,
+	ANA_POL_PIR_STATE,
+	ANA_POL_CIR_STATE,
+	ANA_POL_STATE,
+	ANA_POL_FLOWC,
+	ANA_POL_HYST,
+	ANA_POL_MISC_CFG,
+	QS_XTR_GRP_CFG = QS << TARGET_OFFSET,
+	QS_XTR_RD,
+	QS_XTR_FRM_PRUNING,
+	QS_XTR_FLUSH,
+	QS_XTR_DATA_PRESENT,
+	QS_XTR_CFG,
+	QS_INJ_GRP_CFG,
+	QS_INJ_WR,
+	QS_INJ_CTRL,
+	QS_INJ_STATUS,
+	QS_INJ_ERR,
+	QS_INH_DBG,
+	QSYS_PORT_MODE = QSYS << TARGET_OFFSET,
+	QSYS_SWITCH_PORT_MODE,
+	QSYS_STAT_CNT_CFG,
+	QSYS_EEE_CFG,
+	QSYS_EEE_THRES,
+	QSYS_IGR_NO_SHARING,
+	QSYS_EGR_NO_SHARING,
+	QSYS_SW_STATUS,
+	QSYS_EXT_CPU_CFG,
+	QSYS_PAD_CFG,
+	QSYS_CPU_GROUP_MAP,
+	QSYS_QMAP,
+	QSYS_ISDX_SGRP,
+	QSYS_TIMED_FRAME_ENTRY,
+	QSYS_TFRM_MISC,
+	QSYS_TFRM_PORT_DLY,
+	QSYS_TFRM_TIMER_CFG_1,
+	QSYS_TFRM_TIMER_CFG_2,
+	QSYS_TFRM_TIMER_CFG_3,
+	QSYS_TFRM_TIMER_CFG_4,
+	QSYS_TFRM_TIMER_CFG_5,
+	QSYS_TFRM_TIMER_CFG_6,
+	QSYS_TFRM_TIMER_CFG_7,
+	QSYS_TFRM_TIMER_CFG_8,
+	QSYS_RED_PROFILE,
+	QSYS_RES_QOS_MODE,
+	QSYS_RES_CFG,
+	QSYS_RES_STAT,
+	QSYS_EGR_DROP_MODE,
+	QSYS_EQ_CTRL,
+	QSYS_EVENTS_CORE,
+	QSYS_QMAXSDU_CFG_0,
+	QSYS_QMAXSDU_CFG_1,
+	QSYS_QMAXSDU_CFG_2,
+	QSYS_QMAXSDU_CFG_3,
+	QSYS_QMAXSDU_CFG_4,
+	QSYS_QMAXSDU_CFG_5,
+	QSYS_QMAXSDU_CFG_6,
+	QSYS_QMAXSDU_CFG_7,
+	QSYS_PREEMPTION_CFG,
+	QSYS_CIR_CFG,
+	QSYS_EIR_CFG,
+	QSYS_SE_CFG,
+	QSYS_SE_DWRR_CFG,
+	QSYS_SE_CONNECT,
+	QSYS_SE_DLB_SENSE,
+	QSYS_CIR_STATE,
+	QSYS_EIR_STATE,
+	QSYS_SE_STATE,
+	QSYS_HSCH_MISC_CFG,
+	QSYS_TAG_CONFIG,
+	QSYS_TAS_PARAM_CFG_CTRL,
+	QSYS_PORT_MAX_SDU,
+	QSYS_PARAM_CFG_REG_1,
+	QSYS_PARAM_CFG_REG_2,
+	QSYS_PARAM_CFG_REG_3,
+	QSYS_PARAM_CFG_REG_4,
+	QSYS_PARAM_CFG_REG_5,
+	QSYS_GCL_CFG_REG_1,
+	QSYS_GCL_CFG_REG_2,
+	QSYS_PARAM_STATUS_REG_1,
+	QSYS_PARAM_STATUS_REG_2,
+	QSYS_PARAM_STATUS_REG_3,
+	QSYS_PARAM_STATUS_REG_4,
+	QSYS_PARAM_STATUS_REG_5,
+	QSYS_PARAM_STATUS_REG_6,
+	QSYS_PARAM_STATUS_REG_7,
+	QSYS_PARAM_STATUS_REG_8,
+	QSYS_PARAM_STATUS_REG_9,
+	QSYS_GCL_STATUS_REG_1,
+	QSYS_GCL_STATUS_REG_2,
+	REW_PORT_VLAN_CFG = REW << TARGET_OFFSET,
+	REW_TAG_CFG,
+	REW_PORT_CFG,
+	REW_DSCP_CFG,
+	REW_PCP_DEI_QOS_MAP_CFG,
+	REW_PTP_CFG,
+	REW_PTP_DLY1_CFG,
+	REW_RED_TAG_CFG,
+	REW_DSCP_REMAP_DP1_CFG,
+	REW_DSCP_REMAP_CFG,
+	REW_STAT_CFG,
+	REW_REW_STICKY,
+	REW_PPT,
+	SYS_COUNT_RX_OCTETS = SYS << TARGET_OFFSET,
+	SYS_COUNT_RX_UNICAST,
+	SYS_COUNT_RX_MULTICAST,
+	SYS_COUNT_RX_BROADCAST,
+	SYS_COUNT_RX_SHORTS,
+	SYS_COUNT_RX_FRAGMENTS,
+	SYS_COUNT_RX_JABBERS,
+	SYS_COUNT_RX_CRC_ALIGN_ERRS,
+	SYS_COUNT_RX_SYM_ERRS,
+	SYS_COUNT_RX_64,
+	SYS_COUNT_RX_65_127,
+	SYS_COUNT_RX_128_255,
+	SYS_COUNT_RX_256_1023,
+	SYS_COUNT_RX_1024_1526,
+	SYS_COUNT_RX_1527_MAX,
+	SYS_COUNT_RX_PAUSE,
+	SYS_COUNT_RX_CONTROL,
+	SYS_COUNT_RX_LONGS,
+	SYS_COUNT_RX_CLASSIFIED_DROPS,
+	SYS_COUNT_TX_OCTETS,
+	SYS_COUNT_TX_UNICAST,
+	SYS_COUNT_TX_MULTICAST,
+	SYS_COUNT_TX_BROADCAST,
+	SYS_COUNT_TX_COLLISION,
+	SYS_COUNT_TX_DROPS,
+	SYS_COUNT_TX_PAUSE,
+	SYS_COUNT_TX_64,
+	SYS_COUNT_TX_65_127,
+	SYS_COUNT_TX_128_511,
+	SYS_COUNT_TX_512_1023,
+	SYS_COUNT_TX_1024_1526,
+	SYS_COUNT_TX_1527_MAX,
+	SYS_COUNT_TX_AGING,
+	SYS_RESET_CFG,
+	SYS_SR_ETYPE_CFG,
+	SYS_VLAN_ETYPE_CFG,
+	SYS_PORT_MODE,
+	SYS_FRONT_PORT_MODE,
+	SYS_FRM_AGING,
+	SYS_STAT_CFG,
+	SYS_SW_STATUS,
+	SYS_MISC_CFG,
+	SYS_REW_MAC_HIGH_CFG,
+	SYS_REW_MAC_LOW_CFG,
+	SYS_TIMESTAMP_OFFSET,
+	SYS_CMID,
+	SYS_PAUSE_CFG,
+	SYS_PAUSE_TOT_CFG,
+	SYS_ATOP,
+	SYS_ATOP_TOT_CFG,
+	SYS_MAC_FC_CFG,
+	SYS_MMGT,
+	SYS_MMGT_FAST,
+	SYS_EVENTS_DIF,
+	SYS_EVENTS_CORE,
+	SYS_CNT,
+	SYS_PTP_STATUS,
+	SYS_PTP_TXSTAMP,
+	SYS_PTP_NXT,
+	SYS_PTP_CFG,
+	SYS_RAM_INIT,
+	SYS_CM_ADDR,
+	SYS_CM_DATA_WR,
+	SYS_CM_DATA_RD,
+	SYS_CM_OP,
+	SYS_CM_DATA,
+	S2_CORE_UPDATE_CTRL = S2 << TARGET_OFFSET,
+	S2_CORE_MV_CFG,
+	S2_CACHE_ENTRY_DAT,
+	S2_CACHE_MASK_DAT,
+	S2_CACHE_ACTION_DAT,
+	S2_CACHE_CNT_DAT,
+	S2_CACHE_TG_DAT,
+	PTP_PIN_CFG = PTP << TARGET_OFFSET,
+	PTP_PIN_TOD_SEC_MSB,
+	PTP_PIN_TOD_SEC_LSB,
+	PTP_PIN_TOD_NSEC,
+	PTP_CFG_MISC,
+	PTP_CLK_CFG_ADJ_CFG,
+	PTP_CLK_CFG_ADJ_FREQ,
+	GCB_SOFT_RST = GCB << TARGET_OFFSET,
+};
+
+enum ocelot_regfield {
+	ANA_ADVLEARN_VLAN_CHK,
+	ANA_ADVLEARN_LEARN_MIRROR,
+	ANA_ANEVENTS_FLOOD_DISCARD,
+	ANA_ANEVENTS_MSTI_DROP,
+	ANA_ANEVENTS_ACLKILL,
+	ANA_ANEVENTS_ACLUSED,
+	ANA_ANEVENTS_AUTOAGE,
+	ANA_ANEVENTS_VS2TTL1,
+	ANA_ANEVENTS_STORM_DROP,
+	ANA_ANEVENTS_LEARN_DROP,
+	ANA_ANEVENTS_AGED_ENTRY,
+	ANA_ANEVENTS_CPU_LEARN_FAILED,
+	ANA_ANEVENTS_AUTO_LEARN_FAILED,
+	ANA_ANEVENTS_LEARN_REMOVE,
+	ANA_ANEVENTS_AUTO_LEARNED,
+	ANA_ANEVENTS_AUTO_MOVED,
+	ANA_ANEVENTS_DROPPED,
+	ANA_ANEVENTS_CLASSIFIED_DROP,
+	ANA_ANEVENTS_CLASSIFIED_COPY,
+	ANA_ANEVENTS_VLAN_DISCARD,
+	ANA_ANEVENTS_FWD_DISCARD,
+	ANA_ANEVENTS_MULTICAST_FLOOD,
+	ANA_ANEVENTS_UNICAST_FLOOD,
+	ANA_ANEVENTS_DEST_KNOWN,
+	ANA_ANEVENTS_BUCKET3_MATCH,
+	ANA_ANEVENTS_BUCKET2_MATCH,
+	ANA_ANEVENTS_BUCKET1_MATCH,
+	ANA_ANEVENTS_BUCKET0_MATCH,
+	ANA_ANEVENTS_CPU_OPERATION,
+	ANA_ANEVENTS_DMAC_LOOKUP,
+	ANA_ANEVENTS_SMAC_LOOKUP,
+	ANA_ANEVENTS_SEQ_GEN_ERR_0,
+	ANA_ANEVENTS_SEQ_GEN_ERR_1,
+	ANA_TABLES_MACACCESS_B_DOM,
+	ANA_TABLES_MACTINDX_BUCKET,
+	ANA_TABLES_MACTINDX_M_INDEX,
+	QSYS_TIMED_FRAME_ENTRY_TFRM_VLD,
+	QSYS_TIMED_FRAME_ENTRY_TFRM_FP,
+	QSYS_TIMED_FRAME_ENTRY_TFRM_PORTNO,
+	QSYS_TIMED_FRAME_ENTRY_TFRM_TM_SEL,
+	QSYS_TIMED_FRAME_ENTRY_TFRM_TM_T,
+	SYS_RESET_CFG_CORE_ENA,
+	SYS_RESET_CFG_MEM_ENA,
+	SYS_RESET_CFG_MEM_INIT,
+	GCB_SOFT_RST_SWC_RST,
+	REGFIELD_MAX
+};
+
+enum ocelot_clk_pins {
+	ALT_PPS_PIN	= 1,
+	EXT_CLK_PIN,
+	ALT_LDST_PIN,
+	TOD_ACC_PIN
+};
+
+struct ocelot_stat_layout {
+	u32 offset;
+	char name[ETH_GSTRING_LEN];
+};
+
+enum ocelot_tag_prefix {
+	OCELOT_TAG_PREFIX_DISABLED	= 0,
+	OCELOT_TAG_PREFIX_NONE,
+	OCELOT_TAG_PREFIX_SHORT,
+	OCELOT_TAG_PREFIX_LONG,
+};
+
+struct ocelot;
+
+struct ocelot_ops {
+	void (*pcs_init)(struct ocelot *ocelot, int port);
+	int (*reset)(struct ocelot *ocelot);
+};
+
+struct ocelot_port {
+	struct ocelot			*ocelot;
+
+	void __iomem			*regs;
+
+	/* Ingress default VLAN (pvid) */
+	u16				pvid;
+
+	/* Egress default VLAN (vid) */
+	u16				vid;
+
+	u8				ptp_cmd;
+	struct list_head		skbs;
+	u8				ts_id;
+};
+
+struct ocelot {
+	struct device			*dev;
+
+	const struct ocelot_ops		*ops;
+	struct regmap			*targets[TARGET_MAX];
+	struct regmap_field		*regfields[REGFIELD_MAX];
+	const u32 *const		*map;
+	const struct ocelot_stat_layout	*stats_layout;
+	unsigned int			num_stats;
+
+	int				shared_queue_sz;
+
+	struct net_device		*hw_bridge_dev;
+	u16				bridge_mask;
+	u16				bridge_fwd_mask;
+
+	struct ocelot_port		**ports;
+
+	u8				base_mac[ETH_ALEN];
+
+	/* Keep track of the vlan port masks */
+	u32				vlan_mask[VLAN_N_VID];
+
+	u8				num_phys_ports;
+	u8				num_cpu_ports;
+	u8				cpu;
+
+	u32				*lags;
+
+	struct list_head		multicast;
+
+	/* Workqueue to check statistics for overflow with its lock */
+	struct mutex			stats_lock;
+	u64				*stats;
+	struct delayed_work		stats_work;
+	struct workqueue_struct		*stats_queue;
+
+	u8				ptp:1;
+	struct ptp_clock		*ptp_clock;
+	struct ptp_clock_info		ptp_info;
+	struct hwtstamp_config		hwtstamp_config;
+	/* Protects the PTP interface state */
+	struct mutex			ptp_lock;
+	/* Protects the PTP clock */
+	spinlock_t			ptp_clock_lock;
+
+	void (*port_pcs_init)(struct ocelot_port *port);
+};
+
+#define ocelot_read_ix(ocelot, reg, gi, ri) __ocelot_read_ix(ocelot, reg, reg##_GSZ * (gi) + reg##_RSZ * (ri))
+#define ocelot_read_gix(ocelot, reg, gi) __ocelot_read_ix(ocelot, reg, reg##_GSZ * (gi))
+#define ocelot_read_rix(ocelot, reg, ri) __ocelot_read_ix(ocelot, reg, reg##_RSZ * (ri))
+#define ocelot_read(ocelot, reg) __ocelot_read_ix(ocelot, reg, 0)
+
+#define ocelot_write_ix(ocelot, val, reg, gi, ri) __ocelot_write_ix(ocelot, val, reg, reg##_GSZ * (gi) + reg##_RSZ * (ri))
+#define ocelot_write_gix(ocelot, val, reg, gi) __ocelot_write_ix(ocelot, val, reg, reg##_GSZ * (gi))
+#define ocelot_write_rix(ocelot, val, reg, ri) __ocelot_write_ix(ocelot, val, reg, reg##_RSZ * (ri))
+#define ocelot_write(ocelot, val, reg) __ocelot_write_ix(ocelot, val, reg, 0)
+
+#define ocelot_rmw_ix(ocelot, val, m, reg, gi, ri) __ocelot_rmw_ix(ocelot, val, m, reg, reg##_GSZ * (gi) + reg##_RSZ * (ri))
+#define ocelot_rmw_gix(ocelot, val, m, reg, gi) __ocelot_rmw_ix(ocelot, val, m, reg, reg##_GSZ * (gi))
+#define ocelot_rmw_rix(ocelot, val, m, reg, ri) __ocelot_rmw_ix(ocelot, val, m, reg, reg##_RSZ * (ri))
+#define ocelot_rmw(ocelot, val, m, reg) __ocelot_rmw_ix(ocelot, val, m, reg, 0)
+
+/* I/O */
+u32 ocelot_port_readl(struct ocelot_port *port, u32 reg);
+void ocelot_port_writel(struct ocelot_port *port, u32 val, u32 reg);
+u32 __ocelot_read_ix(struct ocelot *ocelot, u32 reg, u32 offset);
+void __ocelot_write_ix(struct ocelot *ocelot, u32 val, u32 reg, u32 offset);
+void __ocelot_rmw_ix(struct ocelot *ocelot, u32 val, u32 mask, u32 reg,
+		     u32 offset);
+
+/* Hardware initialization */
+int ocelot_regfields_init(struct ocelot *ocelot,
+			  const struct reg_field *const regfields);
+struct regmap *ocelot_regmap_init(struct ocelot *ocelot, struct resource *res);
+void ocelot_set_cpu_port(struct ocelot *ocelot, int cpu,
+			 enum ocelot_tag_prefix injection,
+			 enum ocelot_tag_prefix extraction);
+int ocelot_init(struct ocelot *ocelot);
+void ocelot_deinit(struct ocelot *ocelot);
+void ocelot_init_port(struct ocelot *ocelot, int port);
+
+/* DSA callbacks */
+void ocelot_port_enable(struct ocelot *ocelot, int port,
+			struct phy_device *phy);
+void ocelot_port_disable(struct ocelot *ocelot, int port);
+void ocelot_get_strings(struct ocelot *ocelot, int port, u32 sset, u8 *data);
+void ocelot_get_ethtool_stats(struct ocelot *ocelot, int port, u64 *data);
+int ocelot_get_sset_count(struct ocelot *ocelot, int port, int sset);
+int ocelot_get_ts_info(struct ocelot *ocelot, int port,
+		       struct ethtool_ts_info *info);
+void ocelot_set_ageing_time(struct ocelot *ocelot, unsigned int msecs);
+void ocelot_adjust_link(struct ocelot *ocelot, int port,
+			struct phy_device *phydev);
+void ocelot_port_vlan_filtering(struct ocelot *ocelot, int port,
+				bool vlan_aware);
+void ocelot_bridge_stp_state_set(struct ocelot *ocelot, int port, u8 state);
+int ocelot_port_bridge_join(struct ocelot *ocelot, int port,
+			    struct net_device *bridge);
+int ocelot_port_bridge_leave(struct ocelot *ocelot, int port,
+			     struct net_device *bridge);
+int ocelot_fdb_dump(struct ocelot *ocelot, int port,
+		    dsa_fdb_dump_cb_t *cb, void *data);
+int ocelot_fdb_add(struct ocelot *ocelot, int port,
+		   const unsigned char *addr, u16 vid, bool vlan_aware);
+int ocelot_fdb_del(struct ocelot *ocelot, int port,
+		   const unsigned char *addr, u16 vid);
+int ocelot_vlan_add(struct ocelot *ocelot, int port, u16 vid, bool pvid,
+		    bool untagged);
+int ocelot_vlan_del(struct ocelot *ocelot, int port, u16 vid);
+int ocelot_ptp_gettime64(struct ptp_clock_info *ptp, struct timespec64 *ts);
+void ocelot_get_hwtimestamp(struct ocelot *ocelot, struct timespec64 *ts);
+
+#endif
