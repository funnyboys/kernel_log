commit 174ae4e96e0f54958cbe3fd3090a3cefeb63af4d
Author: Mischa Jonker <Mischa.Jonker@synopsys.com>
Date:   Wed Jul 24 14:04:34 2019 +0200

    ARCv2: IDU-intc: Add support for edge-triggered interrupts
    
    This adds support for an optional extra interrupt cell to specify edge
    vs level triggered. It is backward compatible with dts files with only
    one cell, and will default to level-triggered in such a case.
    
    Note that I had to make a change to idu_irq_set_affinity as well, as
    this function was setting the interrupt type to "level" unconditionally,
    since this was the only type supported previously.
    
    Signed-off-by: Mischa Jonker <mischa.jonker@synopsys.com>
    Reviewed-by: Vineet Gupta <vgupta@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/include/soc/arc/mcip.h b/include/soc/arc/mcip.h
index 50f49e043668..d1a93c73f006 100644
--- a/include/soc/arc/mcip.h
+++ b/include/soc/arc/mcip.h
@@ -46,7 +46,9 @@ struct mcip_cmd {
 #define CMD_IDU_ENABLE			0x71
 #define CMD_IDU_DISABLE			0x72
 #define CMD_IDU_SET_MODE		0x74
+#define CMD_IDU_READ_MODE		0x75
 #define CMD_IDU_SET_DEST		0x76
+#define CMD_IDU_ACK_CIRQ		0x79
 #define CMD_IDU_SET_MASK		0x7C
 
 #define IDU_M_TRIG_LEVEL		0x0
@@ -119,4 +121,13 @@ static inline void __mcip_cmd_data(unsigned int cmd, unsigned int param,
 	__mcip_cmd(cmd, param);
 }
 
+/*
+ * Read MCIP register
+ */
+static inline unsigned int __mcip_cmd_read(unsigned int cmd, unsigned int param)
+{
+	__mcip_cmd(cmd, param);
+	return read_aux_reg(ARC_REG_MCIP_READBACK);
+}
+
 #endif

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/soc/arc/mcip.h b/include/soc/arc/mcip.h
index a91f25151a5b..50f49e043668 100644
--- a/include/soc/arc/mcip.h
+++ b/include/soc/arc/mcip.h
@@ -1,11 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * ARConnect IP Support (Multi core enabler: Cross core IPI, RTC ...)
  *
  * Copyright (C) 2014-15 Synopsys, Inc. (www.synopsys.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef __SOC_ARC_MCIP_H

commit f3205de98db2fc8083796dd5ad81b191e436fab8
Author: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
Date:   Fri Feb 23 19:41:53 2018 +0300

    ARC: mcip: update MCIP debug mask when the new cpu came online
    
    As of today we use hardcoded MCIP debug mask, so if we launch
    kernel via debugger and kick fever cores than HW has all cpus
    hang at the momemt of setup MCIP debug mask.
    
    So update MCIP debug mask when the new cpu came online, instead of
    use hardcoded MCIP debug mask.
    
    Signed-off-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/include/soc/arc/mcip.h b/include/soc/arc/mcip.h
index 1138da57baaf..a91f25151a5b 100644
--- a/include/soc/arc/mcip.h
+++ b/include/soc/arc/mcip.h
@@ -37,7 +37,9 @@ struct mcip_cmd {
 #define CMD_SEMA_RELEASE		0x12
 
 #define CMD_DEBUG_SET_MASK		0x34
+#define CMD_DEBUG_READ_MASK		0x35
 #define CMD_DEBUG_SET_SELECT		0x36
+#define CMD_DEBUG_READ_SELECT		0x37
 
 #define CMD_GFRC_READ_LO		0x42
 #define CMD_GFRC_READ_HI		0x43

commit 07423d00a2b2a71a97e4287d9262cb83c4c4c89f
Author: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
Date:   Fri Feb 23 19:41:52 2018 +0300

    ARC: mcip: halt GFRC counter when ARC cores halt
    
    In SMP systems, GFRC is used for clocksource. However by default the
    counter keeps running even when core is halted (say when debugging via a
    JTAG debugger). This confuses Linux timekeeping and triggers flase RCU stall
    splat such as below:
    
    | [ARCLinux]# while true; do ./shm_open_23-1.run-test ; done
    | Running with 1000 processes for 1000 objects
    | hrtimer: interrupt took 485060 ns
    |
    | create_cnt: 1000
    | Running with 1000 processes for 1000 objects
    | [ARCLinux]# INFO: rcu_preempt self-detected stall on CPU
    |       2-...: (1 GPs behind) idle=a01/1/0 softirq=135770/135773 fqs=0
    | INFO: rcu_preempt detected stalls on CPUs/tasks:
    |       0-...: (1 GPs behind) idle=71e/0/0 softirq=135264/135264 fqs=0
    |       2-...: (1 GPs behind) idle=a01/1/0 softirq=135770/135773 fqs=0
    |       3-...: (1 GPs behind) idle=4e0/0/0 softirq=134304/134304 fqs=0
    |       (detected by 1, t=13648 jiffies, g=31493, c=31492, q=1)
    
    Starting from ARC HS v3.0 it's possible to tie GFRC to state of up-to 4
    ARC cores with help of GFRC's CORE register where we set a mask for
    cores which state we need to rely on.
    
    We update cpu mask every time new cpu came online instead of using
    hardcoded one or using mask generated from "possible_cpus" as we
    want it set correctly even if we run kernel on HW which has fewer cores
    than expected (or we launch kernel via debugger and kick fever cores
    than HW has)
    
    Note that GFRC halts when all cores have halted and thus relies on
    programming of Inter-Core-dEbug register to halt all cores when one
    halts.
    
    Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
    Signed-off-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    [vgupta: rewrote changelog]

diff --git a/include/soc/arc/mcip.h b/include/soc/arc/mcip.h
index c2d1b15da136..1138da57baaf 100644
--- a/include/soc/arc/mcip.h
+++ b/include/soc/arc/mcip.h
@@ -15,6 +15,7 @@
 
 #define ARC_REG_MCIP_BCR	0x0d0
 #define ARC_REG_MCIP_IDU_BCR	0x0D5
+#define ARC_REG_GFRC_BUILD	0x0D6
 #define ARC_REG_MCIP_CMD	0x600
 #define ARC_REG_MCIP_WDATA	0x601
 #define ARC_REG_MCIP_READBACK	0x602
@@ -40,6 +41,8 @@ struct mcip_cmd {
 
 #define CMD_GFRC_READ_LO		0x42
 #define CMD_GFRC_READ_HI		0x43
+#define CMD_GFRC_SET_CORE		0x47
+#define CMD_GFRC_READ_CORE		0x48
 
 #define CMD_IDU_ENABLE			0x71
 #define CMD_IDU_DISABLE			0x72

commit 6f0310a126f1a46cac366327751bb7eb8941bdde
Author: Yuriy Kolerov <yuriy.kolerov@synopsys.com>
Date:   Tue Jan 31 14:45:23 2017 +0300

    ARCv2: IDU-intc: Use build registers for getting numbers of interrupts
    
    This enhancement is needed to allow masking all available common interrupts
    in IDU interrupt controller in boot time since the kernel can
    discover a number of them from the build register. Also now there
    is no need to specify in device tree a list of used core interrupts
    by IDU. E.g. before:
    
        idu_intc: idu-interrupt-controller {
            compatible = "snps,archs-idu-intc";
            interrupt-controller;
            interrupt-parent = <&core_intc>;
            #interrupt-cells = <2>;
            interrupts = <24 25 26 27 28 29 30 31>;
        };
    
    and after:
    
        idu_intc: idu-interrupt-controller {
            compatible = "snps,archs-idu-intc";
            interrupt-controller;
            interrupt-parent = <&core_intc>;
            #interrupt-cells = <2>;
        };
    
    Signed-off-by: Yuriy Kolerov <yuriy.kolerov@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/include/soc/arc/mcip.h b/include/soc/arc/mcip.h
index 4b6b489a8d7c..c2d1b15da136 100644
--- a/include/soc/arc/mcip.h
+++ b/include/soc/arc/mcip.h
@@ -14,6 +14,7 @@
 #include <soc/arc/aux.h>
 
 #define ARC_REG_MCIP_BCR	0x0d0
+#define ARC_REG_MCIP_IDU_BCR	0x0D5
 #define ARC_REG_MCIP_CMD	0x600
 #define ARC_REG_MCIP_WDATA	0x601
 #define ARC_REG_MCIP_READBACK	0x602
@@ -69,6 +70,22 @@ struct mcip_bcr {
 #endif
 };
 
+struct mcip_idu_bcr {
+#ifdef CONFIG_CPU_BIG_ENDIAN
+	unsigned int pad:21, cirqnum:3, ver:8;
+#else
+	unsigned int ver:8, cirqnum:3, pad:21;
+#endif
+};
+
+
+/*
+ * Build register for IDU contains not an actual number of supported common
+ * interrupts but an exponent of 2 which must be multiplied by 4 to
+ * get a number of supported common interrupts.
+ */
+#define mcip_idu_bcr_to_nr_irqs(bcr) (4 * (1 << (bcr).cirqnum))
+
 /*
  * MCIP programming model
  *

commit 517e7610d2ce04d1b8d8b6c6d1a36dcce5cac6ab
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Thu Jan 19 17:05:00 2017 -0800

    ARCv2: MCIP: update the BCR per current changes
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/include/soc/arc/mcip.h b/include/soc/arc/mcip.h
index 6902c2a8bd23..4b6b489a8d7c 100644
--- a/include/soc/arc/mcip.h
+++ b/include/soc/arc/mcip.h
@@ -55,17 +55,17 @@ struct mcip_cmd {
 
 struct mcip_bcr {
 #ifdef CONFIG_CPU_BIG_ENDIAN
-		unsigned int pad3:8,
-			     idu:1, llm:1, num_cores:6,
-			     iocoh:1,  gfrc:1, dbg:1, pad2:1,
-			     msg:1, sem:1, ipi:1, pad:1,
+		unsigned int pad4:6, pw_dom:1, pad3:1,
+			     idu:1, pad2:1, num_cores:6,
+			     pad:1,  gfrc:1, dbg:1, pw:1,
+			     msg:1, sem:1, ipi:1, slv:1,
 			     ver:8;
 #else
 		unsigned int ver:8,
-			     pad:1, ipi:1, sem:1, msg:1,
-			     pad2:1, dbg:1, gfrc:1, iocoh:1,
-			     num_cores:6, llm:1, idu:1,
-			     pad3:8;
+			     slv:1, ipi:1, sem:1, msg:1,
+			     pw:1, dbg:1, gfrc:1, pad:1,
+			     num_cores:6, pad2:1, idu:1,
+			     pad3:1, pw_dom:1, pad4:6;
 #endif
 };
 

commit 2d7f5c48c03ee53ad649cbf803dc33730f955234
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Mon Oct 31 11:27:08 2016 -0700

    ARC: move mcip.h into include/soc and adjust the includes
    
    Also remove the dependency on ARCv2, to increase compile coverage for
    !ARCV2 builds
    
    Acked-by: Daniel Lezcano <daniel.lezcnao@linaro.org>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/include/soc/arc/mcip.h b/include/soc/arc/mcip.h
new file mode 100644
index 000000000000..6902c2a8bd23
--- /dev/null
+++ b/include/soc/arc/mcip.h
@@ -0,0 +1,103 @@
+/*
+ * ARConnect IP Support (Multi core enabler: Cross core IPI, RTC ...)
+ *
+ * Copyright (C) 2014-15 Synopsys, Inc. (www.synopsys.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __SOC_ARC_MCIP_H
+#define __SOC_ARC_MCIP_H
+
+#include <soc/arc/aux.h>
+
+#define ARC_REG_MCIP_BCR	0x0d0
+#define ARC_REG_MCIP_CMD	0x600
+#define ARC_REG_MCIP_WDATA	0x601
+#define ARC_REG_MCIP_READBACK	0x602
+
+struct mcip_cmd {
+#ifdef CONFIG_CPU_BIG_ENDIAN
+	unsigned int pad:8, param:16, cmd:8;
+#else
+	unsigned int cmd:8, param:16, pad:8;
+#endif
+
+#define CMD_INTRPT_GENERATE_IRQ		0x01
+#define CMD_INTRPT_GENERATE_ACK		0x02
+#define CMD_INTRPT_READ_STATUS		0x03
+#define CMD_INTRPT_CHECK_SOURCE		0x04
+
+/* Semaphore Commands */
+#define CMD_SEMA_CLAIM_AND_READ		0x11
+#define CMD_SEMA_RELEASE		0x12
+
+#define CMD_DEBUG_SET_MASK		0x34
+#define CMD_DEBUG_SET_SELECT		0x36
+
+#define CMD_GFRC_READ_LO		0x42
+#define CMD_GFRC_READ_HI		0x43
+
+#define CMD_IDU_ENABLE			0x71
+#define CMD_IDU_DISABLE			0x72
+#define CMD_IDU_SET_MODE		0x74
+#define CMD_IDU_SET_DEST		0x76
+#define CMD_IDU_SET_MASK		0x7C
+
+#define IDU_M_TRIG_LEVEL		0x0
+#define IDU_M_TRIG_EDGE			0x1
+
+#define IDU_M_DISTRI_RR			0x0
+#define IDU_M_DISTRI_DEST		0x2
+};
+
+struct mcip_bcr {
+#ifdef CONFIG_CPU_BIG_ENDIAN
+		unsigned int pad3:8,
+			     idu:1, llm:1, num_cores:6,
+			     iocoh:1,  gfrc:1, dbg:1, pad2:1,
+			     msg:1, sem:1, ipi:1, pad:1,
+			     ver:8;
+#else
+		unsigned int ver:8,
+			     pad:1, ipi:1, sem:1, msg:1,
+			     pad2:1, dbg:1, gfrc:1, iocoh:1,
+			     num_cores:6, llm:1, idu:1,
+			     pad3:8;
+#endif
+};
+
+/*
+ * MCIP programming model
+ *
+ * - Simple commands write {cmd:8,param:16} to MCIP_CMD aux reg
+ *   (param could be irq, common_irq, core_id ...)
+ * - More involved commands setup MCIP_WDATA with cmd specific data
+ *   before invoking the simple command
+ */
+static inline void __mcip_cmd(unsigned int cmd, unsigned int param)
+{
+	struct mcip_cmd buf;
+
+	buf.pad = 0;
+	buf.cmd = cmd;
+	buf.param = param;
+
+	WRITE_AUX(ARC_REG_MCIP_CMD, buf);
+}
+
+/*
+ * Setup additional data for a cmd
+ * Callers need to lock to ensure atomicity
+ */
+static inline void __mcip_cmd_data(unsigned int cmd, unsigned int param,
+				   unsigned int data)
+{
+	write_aux_reg(ARC_REG_MCIP_WDATA, data);
+
+	__mcip_cmd(cmd, param);
+}
+
+#endif
