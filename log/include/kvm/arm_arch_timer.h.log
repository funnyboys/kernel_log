commit 4505153954fdb1465d2b178288a9bf646f2a2166
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:47 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 333
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 136 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.384967451@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 05a18dd265b5..d120e6c323e7 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -1,19 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2012 ARM Ltd.
  * Author: Marc Zyngier <marc.zyngier@arm.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
 #ifndef __ASM_ARM_KVM_ARCH_TIMER_H

commit bee038a67487598ebbe995f85bf60c3a5b2e9099
Author: Christoffer Dall <christoffer.dall@arm.com>
Date:   Fri Jan 4 13:31:22 2019 +0100

    KVM: arm/arm64: Rework the timer code to use a timer_map
    
    We are currently emulating two timers in two different ways.  When we
    add support for nested virtualization in the future, we are going to be
    emulating either two timers in two diffferent ways, or four timers in a
    single way.
    
    We need a unified data structure to keep track of how we map virtual
    state to physical state and we need to cleanup some of the timer code to
    operate more independently on a struct arch_timer_context instead of
    trying to consider the global state of the VCPU and recomputing all
    state.
    
    Co-written with Marc Zyngier <marc.zyngier@arm.com>
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 6d4a33a9c45a..05a18dd265b5 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -51,11 +51,24 @@ struct arch_timer_context {
 	/* Emulated Timer (may be unused) */
 	struct hrtimer			hrtimer;
 
+	/*
+	 * We have multiple paths which can save/restore the timer state onto
+	 * the hardware, so we need some way of keeping track of where the
+	 * latest state is.
+	 */
+	bool				loaded;
+
 	/* Duplicated state from arch_timer.c for convenience */
 	u32				host_timer_irq;
 	u32				host_timer_irq_flags;
 };
 
+struct timer_map {
+	struct arch_timer_context *direct_vtimer;
+	struct arch_timer_context *direct_ptimer;
+	struct arch_timer_context *emul_ptimer;
+};
+
 struct arch_timer_cpu {
 	struct arch_timer_context timers[NR_KVM_TIMERS];
 
@@ -64,16 +77,6 @@ struct arch_timer_cpu {
 
 	/* Is the timer enabled */
 	bool			enabled;
-
-	/*
-	 * We have multiple paths which can save/restore the timer state
-	 * onto the hardware, so we need some way of keeping track of
-	 * where the latest state is.
-	 *
-	 * loaded == true:  State is loaded on the hardware registers.
-	 * loaded == false: State is stored in memory.
-	 */
-	bool			loaded;
 };
 
 int kvm_timer_hyp_init(bool);

commit 9e01dc76be6a3b5768cb02130d2ff0055a68809a
Author: Christoffer Dall <christoffer.dall@arm.com>
Date:   Tue Feb 19 14:04:30 2019 +0100

    KVM: arm/arm64: arch_timer: Assign the phys timer on VHE systems
    
    VHE systems don't have to emulate the physical timer, we can simply
    assign the EL1 physical timer directly to the VM as the host always
    uses the EL2 timers.
    
    In order to minimize the amount of cruft, AArch32 gets definitions for
    the physical timer too, but is should be generally unused on this
    architecture.
    
    Co-written with Marc Zyngier <marc.zyngier@arm.com>
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index ab835112204d..6d4a33a9c45a 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -50,6 +50,10 @@ struct arch_timer_context {
 
 	/* Emulated Timer (may be unused) */
 	struct hrtimer			hrtimer;
+
+	/* Duplicated state from arch_timer.c for convenience */
+	u32				host_timer_irq;
+	u32				host_timer_irq_flags;
 };
 
 struct arch_timer_cpu {
@@ -104,6 +108,8 @@ bool kvm_arch_timer_get_input_level(int vintid);
 #define vcpu_vtimer(v)	(&(v)->arch.timer_cpu.timers[TIMER_VTIMER])
 #define vcpu_ptimer(v)	(&(v)->arch.timer_cpu.timers[TIMER_PTIMER])
 
+#define arch_timer_ctx_index(ctx)	((ctx) - vcpu_timer((ctx)->vcpu)->timers)
+
 u64 kvm_arm_timer_read_sysreg(struct kvm_vcpu *vcpu,
 			      enum kvm_arch_timers tmr,
 			      enum kvm_arch_timer_regs treg);

commit e604dd5d45c75c2112424dec74853efb708f4fa6
Author: Christoffer Dall <christoffer.dall@arm.com>
Date:   Tue Sep 18 10:08:18 2018 -0700

    KVM: arm/arm64: timer: Rework data structures for multiple timers
    
    Prepare for having 4 timer data structures (2 for now).
    
    Move loaded to the cpu data structure and not the individual timer
    structure, in preparation for assigning the EL1 phys timer as well.
    
    Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index d26b7fde9935..ab835112204d 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -36,6 +36,8 @@ enum kvm_arch_timer_regs {
 };
 
 struct arch_timer_context {
+	struct kvm_vcpu			*vcpu;
+
 	/* Registers: control register, timer value */
 	u32				cnt_ctl;
 	u64				cnt_cval;
@@ -43,32 +45,31 @@ struct arch_timer_context {
 	/* Timer IRQ */
 	struct kvm_irq_level		irq;
 
-	/*
-	 * We have multiple paths which can save/restore the timer state
-	 * onto the hardware, so we need some way of keeping track of
-	 * where the latest state is.
-	 *
-	 * loaded == true:  State is loaded on the hardware registers.
-	 * loaded == false: State is stored in memory.
-	 */
-	bool			loaded;
-
 	/* Virtual offset */
-	u64			cntvoff;
+	u64				cntvoff;
+
+	/* Emulated Timer (may be unused) */
+	struct hrtimer			hrtimer;
 };
 
 struct arch_timer_cpu {
-	struct arch_timer_context	vtimer;
-	struct arch_timer_context	ptimer;
+	struct arch_timer_context timers[NR_KVM_TIMERS];
 
 	/* Background timer used when the guest is not running */
 	struct hrtimer			bg_timer;
 
-	/* Physical timer emulation */
-	struct hrtimer			phys_timer;
-
 	/* Is the timer enabled */
 	bool			enabled;
+
+	/*
+	 * We have multiple paths which can save/restore the timer state
+	 * onto the hardware, so we need some way of keeping track of
+	 * where the latest state is.
+	 *
+	 * loaded == true:  State is loaded on the hardware registers.
+	 * loaded == false: State is stored in memory.
+	 */
+	bool			loaded;
 };
 
 int kvm_timer_hyp_init(bool);
@@ -98,10 +99,10 @@ void kvm_timer_init_vhe(void);
 
 bool kvm_arch_timer_get_input_level(int vintid);
 
-#define vcpu_vtimer(v)	(&(v)->arch.timer_cpu.vtimer)
-#define vcpu_ptimer(v)	(&(v)->arch.timer_cpu.ptimer)
-#define vcpu_get_timer(v,t)					\
-	(t == TIMER_VTIMER ? vcpu_vtimer(v) : vcpu_ptimer(v))
+#define vcpu_timer(v)	(&(v)->arch.timer_cpu)
+#define vcpu_get_timer(v,t)	(&vcpu_timer(v)->timers[(t)])
+#define vcpu_vtimer(v)	(&(v)->arch.timer_cpu.timers[TIMER_VTIMER])
+#define vcpu_ptimer(v)	(&(v)->arch.timer_cpu.timers[TIMER_PTIMER])
 
 u64 kvm_arm_timer_read_sysreg(struct kvm_vcpu *vcpu,
 			      enum kvm_arch_timers tmr,

commit 84135d3d18da2ff17d3ad1a609b2818cc3049552
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Thu Jul 5 16:48:23 2018 +0100

    KVM: arm/arm64: consolidate arch timer trap handlers
    
    At the moment we have separate system register emulation handlers for
    each timer register. Actually they are quite similar, and we rely on
    kvm_arm_timer_[gs]et_reg() for the actual emulation anyways, so let's
    just merge all of those handlers into one function, which just marshalls
    the arguments and then hands off to a set of common accessors.
    This makes extending the emulation to include EL2 timers much easier.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    [Fixed 32-bit VM breakage and reduced to reworking existing code]
    Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>
    [Fixed 32bit host, general cleanup]
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index d6e6a45d1d24..d26b7fde9935 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -22,6 +22,19 @@
 #include <linux/clocksource.h>
 #include <linux/hrtimer.h>
 
+enum kvm_arch_timers {
+	TIMER_PTIMER,
+	TIMER_VTIMER,
+	NR_KVM_TIMERS
+};
+
+enum kvm_arch_timer_regs {
+	TIMER_REG_CNT,
+	TIMER_REG_CVAL,
+	TIMER_REG_TVAL,
+	TIMER_REG_CTL,
+};
+
 struct arch_timer_context {
 	/* Registers: control register, timer value */
 	u32				cnt_ctl;
@@ -87,5 +100,15 @@ bool kvm_arch_timer_get_input_level(int vintid);
 
 #define vcpu_vtimer(v)	(&(v)->arch.timer_cpu.vtimer)
 #define vcpu_ptimer(v)	(&(v)->arch.timer_cpu.ptimer)
+#define vcpu_get_timer(v,t)					\
+	(t == TIMER_VTIMER ? vcpu_vtimer(v) : vcpu_ptimer(v))
+
+u64 kvm_arm_timer_read_sysreg(struct kvm_vcpu *vcpu,
+			      enum kvm_arch_timers tmr,
+			      enum kvm_arch_timer_regs treg);
+void kvm_arm_timer_write_sysreg(struct kvm_vcpu *vcpu,
+				enum kvm_arch_timers tmr,
+				enum kvm_arch_timer_regs treg,
+				u64 val);
 
 #endif

commit accb99bcd0ca6d3ee412557b0c3f583a3abc0eb6
Author: Christoffer Dall <christoffer.dall@arm.com>
Date:   Mon Nov 26 18:21:22 2018 +0100

    KVM: arm/arm64: Simplify bg_timer programming
    
    Instead of calling into kvm_timer_[un]schedule from the main kvm
    blocking path, test if the VCPU is on the wait queue from the load/put
    path and perform the background timer setup/cancel in this path.
    
    This has the distinct advantage that we no longer race between load/put
    and schedule/unschedule and programming and canceling of the bg_timer
    always happens when the timer state is not loaded.
    
    Note that we must now remove the checks in kvm_timer_blocking that do
    not schedule a background timer if one of the timers can fire, because
    we no longer have a guarantee that kvm_vcpu_check_block() will be called
    before kvm_timer_blocking.
    
    Reported-by: Andre Przywara <andre.przywara@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 33771352dcd6..d6e6a45d1d24 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -76,9 +76,6 @@ int kvm_arm_timer_has_attr(struct kvm_vcpu *vcpu, struct kvm_device_attr *attr);
 
 bool kvm_timer_is_pending(struct kvm_vcpu *vcpu);
 
-void kvm_timer_schedule(struct kvm_vcpu *vcpu);
-void kvm_timer_unschedule(struct kvm_vcpu *vcpu);
-
 u64 kvm_phys_timer_read(void);
 
 void kvm_timer_vcpu_load(struct kvm_vcpu *vcpu);

commit 8a411b060f820140e9894239fde5819bb213bef0
Author: Christoffer Dall <christoffer.dall@arm.com>
Date:   Tue Nov 27 13:48:08 2018 +0100

    KVM: arm/arm64: Remove arch timer workqueue
    
    The use of a work queue in the hrtimer expire function for the bg_timer
    is a leftover from the time when we would inject interrupts when the
    bg_timer expired.
    
    Since we are no longer doing that, we can instead call
    kvm_vcpu_wake_up() directly from the hrtimer function and remove all
    workqueue functionality from the arch timer code.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 6502feb9524b..33771352dcd6 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -21,7 +21,6 @@
 
 #include <linux/clocksource.h>
 #include <linux/hrtimer.h>
-#include <linux/workqueue.h>
 
 struct arch_timer_context {
 	/* Registers: control register, timer value */
@@ -52,9 +51,6 @@ struct arch_timer_cpu {
 	/* Background timer used when the guest is not running */
 	struct hrtimer			bg_timer;
 
-	/* Work queued with the above timer expires */
-	struct work_struct		expired;
-
 	/* Physical timer emulation */
 	struct hrtimer			phys_timer;
 

commit 7bf14c28ee776be567855bd39ed8ff795ea19f55
Merge: 87cedc6be559 5fa4ec9cb2e6
Author: Radim Krčmář <rkrcmar@redhat.com>
Date:   Thu Feb 1 15:04:17 2018 +0100

    Merge branch 'x86/hyperv' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Topic branch for stable KVM clockource under Hyper-V.
    
    Thanks to Christoffer Dall for resolving the ARM conflict.

commit 4c60e360d6dfa4d9c3586b687f348eeb3fd675dd
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Fri Oct 27 19:34:30 2017 +0200

    KVM: arm/arm64: Provide a get_input_level for the arch timer
    
    The VGIC can now support the life-cycle of mapped level-triggered
    interrupts, and we no longer have to read back the timer state on every
    exit from the VM if we had an asserted timer interrupt signal, because
    the VGIC already knows if we hit the unlikely case where the guest
    disables the timer without ACKing the virtual timer interrupt.
    
    This means we rework a bit of the code to factor out the functionality
    to snapshot the timer state from vtimer_save_state(), and we can reuse
    this functionality in the sync path when we have an irqchip in
    userspace, and also to support our implementation of the
    get_input_level() function for the timer.
    
    This change also means that we can no longer rely on the timer's view of
    the interrupt line to set the active state, because we no longer
    maintain this state for mapped interrupts when exiting from the guest.
    Instead, we only set the active state if the virtual interrupt is
    active, and otherwise we simply let the timer fire again and raise the
    virtual interrupt from the ISR.
    
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 6e45608b2399..b1dcfde0a3ef 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -90,6 +90,8 @@ void kvm_timer_vcpu_put(struct kvm_vcpu *vcpu);
 
 void kvm_timer_init_vhe(void);
 
+bool kvm_arch_timer_get_input_level(int vintid);
+
 #define vcpu_vtimer(v)	(&(v)->arch.timer_cpu.vtimer)
 #define vcpu_ptimer(v)	(&(v)->arch.timer_cpu.ptimer)
 

commit f384dcfe4d918c1d80477d290c22ce0093823771
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu Dec 7 11:46:15 2017 +0000

    KVM: arm/arm64: timer: Don't set irq as forwarded if no usable GIC
    
    If we don't have a usable GIC, do not try to set the vcpu affinity
    as this is guaranteed to fail.
    
    Reported-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Andre Przywara <andre.przywara@arm.com>
    Tested-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 6e45608b2399..9da6ce22803f 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -62,7 +62,7 @@ struct arch_timer_cpu {
 	bool			enabled;
 };
 
-int kvm_timer_hyp_init(void);
+int kvm_timer_hyp_init(bool);
 int kvm_timer_enable(struct kvm_vcpu *vcpu);
 int kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu);
 void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu);

commit ec6449a9c2296b1c04f6219f7473e0c2fedecfed
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Mon Nov 20 12:10:15 2017 +0100

    KVM: arm/arm64: Don't enable/disable physical timer access on VHE
    
    After the timer optimization rework we accidentally end up calling
    physical timer enable/disable functions on VHE systems, which is neither
    needed nor correct, since the CNTHCTL_EL2 register format is
    different when HCR_EL2.E2H is set.
    
    The CNTHCTL_EL2 is initialized when CPUs become online in
    kvm_timer_init_vhe() and we don't have to call these functions on VHE
    systems, which also allows us to inline the non-VHE functionality.
    
    Reported-by: Jintack Lim <jintack@cs.columbia.edu>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 01ee473517e2..6e45608b2399 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -93,7 +93,4 @@ void kvm_timer_init_vhe(void);
 #define vcpu_vtimer(v)	(&(v)->arch.timer_cpu.vtimer)
 #define vcpu_ptimer(v)	(&(v)->arch.timer_cpu.ptimer)
 
-void enable_el1_phys_timer_access(void);
-void disable_el1_phys_timer_access(void);
-
 #endif

commit 1c88ab7ec8c53c4d806bb2b6871ddafdebbffa8b
Author: Christoffer Dall <cdall@linaro.org>
Date:   Fri Jan 6 16:07:48 2017 +0100

    KVM: arm/arm64: Rework kvm_timer_should_fire
    
    kvm_timer_should_fire() can be called in two different situations from
    the kvm_vcpu_block().
    
    The first case is before calling kvm_timer_schedule(), used for wait
    polling, and in this case the VCPU thread is running and the timer state
    is loaded onto the hardware so all we have to do is check if the virtual
    interrupt lines are asserted, becasue the timer interrupt handler
    functions will raise those lines as appropriate.
    
    The second case is inside the wait loop of kvm_vcpu_block(), where we
    have already called kvm_timer_schedule() and therefore the hardware will
    be disabled and the software view of the timer state is up to date
    (timer->loaded is false), and so we can simply check if the timer should
    fire by looking at the software state.
    
    Signed-off-by: Christoffer Dall <cdall@linaro.org>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 2352f3a4e88b..01ee473517e2 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -78,7 +78,8 @@ int kvm_arm_timer_set_attr(struct kvm_vcpu *vcpu, struct kvm_device_attr *attr);
 int kvm_arm_timer_get_attr(struct kvm_vcpu *vcpu, struct kvm_device_attr *attr);
 int kvm_arm_timer_has_attr(struct kvm_vcpu *vcpu, struct kvm_device_attr *attr);
 
-bool kvm_timer_should_fire(struct arch_timer_context *timer_ctx);
+bool kvm_timer_is_pending(struct kvm_vcpu *vcpu);
+
 void kvm_timer_schedule(struct kvm_vcpu *vcpu);
 void kvm_timer_unschedule(struct kvm_vcpu *vcpu);
 

commit 7e90c8e5704cbb299d48e7debb1e61614cb12f41
Author: Christoffer Dall <cdall@linaro.org>
Date:   Tue Jun 20 07:56:20 2017 -0700

    KVM: arm/arm64: Get rid of kvm_timer_flush_hwstate
    
    Now when both the vtimer and the ptimer when using both the in-kernel
    vgic emulation and a userspace IRQ chip are driven by the timer signals
    and at the vcpu load/put boundaries, instead of recomputing the timer
    state at every entry/exit to/from the guest, we can get entirely rid of
    the flush hwstate function.
    
    Signed-off-by: Christoffer Dall <cdall@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index c538f707e1c1..2352f3a4e88b 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -66,7 +66,6 @@ int kvm_timer_hyp_init(void);
 int kvm_timer_enable(struct kvm_vcpu *vcpu);
 int kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu);
 void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu);
-void kvm_timer_flush_hwstate(struct kvm_vcpu *vcpu);
 void kvm_timer_sync_hwstate(struct kvm_vcpu *vcpu);
 bool kvm_timer_should_notify_user(struct kvm_vcpu *vcpu);
 void kvm_timer_update_run(struct kvm_vcpu *vcpu);

commit b103cc3f10c06fb81faacd4ee6f88bbd21246073
Author: Christoffer Dall <cdall@linaro.org>
Date:   Sun Oct 16 20:30:38 2016 +0200

    KVM: arm/arm64: Avoid timer save/restore in vcpu entry/exit
    
    We don't need to save and restore the hardware timer state and examine
    if it generates interrupts on on every entry/exit to the guest.  The
    timer hardware is perfectly capable of telling us when it has expired
    by signaling interrupts.
    
    When taking a vtimer interrupt in the host, we don't want to mess with
    the timer configuration, we just want to forward the physical interrupt
    to the guest as a virtual interrupt.  We can use the split priority drop
    and deactivate feature of the GIC to do this, which leaves an EOI'ed
    interrupt active on the physical distributor, making sure we don't keep
    taking timer interrupts which would prevent the guest from running.  We
    can then forward the physical interrupt to the VM using the HW bit in
    the LR of the GIC, like we do already, which lets the guest directly
    deactivate both the physical and virtual timer simultaneously, allowing
    the timer hardware to exit the VM and generate a new physical interrupt
    when the timer output is again asserted later on.
    
    We do need to capture this state when migrating VCPUs between physical
    CPUs, however, which we use the vcpu put/load functions for, which are
    called through preempt notifiers whenever the thread is scheduled away
    from the CPU or called directly if we return from the ioctl to
    userspace.
    
    One caveat is that we have to save and restore the timer state in both
    kvm_timer_vcpu_[put/load] and kvm_timer_[schedule/unschedule], because
    we can have the following flows:
    
      1. kvm_vcpu_block
      2. kvm_timer_schedule
      3. schedule
      4. kvm_timer_vcpu_put (preempt notifier)
      5. schedule (vcpu thread gets scheduled back)
      6. kvm_timer_vcpu_load (preempt notifier)
      7. kvm_timer_unschedule
    
    And a version where we don't actually call schedule:
    
      1. kvm_vcpu_block
      2. kvm_timer_schedule
      7. kvm_timer_unschedule
    
    Since kvm_timer_[schedule/unschedule] may not be followed by put/load,
    but put/load also may be called independently, we call the timer
    save/restore functions from both paths.  Since they rely on the loaded
    flag to never save/restore when unnecessary, this doesn't cause any
    harm, and we ensure that all invokations of either set of functions work
    as intended.
    
    An added benefit beyond not having to read and write the timer sysregs
    on every entry and exit is that we no longer have to actively write the
    active state to the physical distributor, because we configured the
    irq for the vtimer to only get a priority drop when handling the
    interrupt in the GIC driver (we called irq_set_vcpu_affinity()), and
    the interrupt stays active after firing on the host.
    
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <cdall@linaro.org>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 184c3ef2df93..c538f707e1c1 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -31,8 +31,15 @@ struct arch_timer_context {
 	/* Timer IRQ */
 	struct kvm_irq_level		irq;
 
-	/* Active IRQ state caching */
-	bool				active_cleared_last;
+	/*
+	 * We have multiple paths which can save/restore the timer state
+	 * onto the hardware, so we need some way of keeping track of
+	 * where the latest state is.
+	 *
+	 * loaded == true:  State is loaded on the hardware registers.
+	 * loaded == false: State is stored in memory.
+	 */
+	bool			loaded;
 
 	/* Virtual offset */
 	u64			cntvoff;
@@ -78,10 +85,15 @@ void kvm_timer_unschedule(struct kvm_vcpu *vcpu);
 
 u64 kvm_phys_timer_read(void);
 
+void kvm_timer_vcpu_load(struct kvm_vcpu *vcpu);
 void kvm_timer_vcpu_put(struct kvm_vcpu *vcpu);
 
 void kvm_timer_init_vhe(void);
 
 #define vcpu_vtimer(v)	(&(v)->arch.timer_cpu.vtimer)
 #define vcpu_ptimer(v)	(&(v)->arch.timer_cpu.ptimer)
+
+void enable_el1_phys_timer_access(void);
+void disable_el1_phys_timer_access(void);
+
 #endif

commit f2a2129e0ac8d8fa79c3f85425c36f6e3368f022
Author: Christoffer Dall <cdall@linaro.org>
Date:   Sun Jun 18 00:32:08 2017 -0700

    KVM: arm/arm64: Use separate timer for phys timer emulation
    
    We were using the same hrtimer for emulating the physical timer and for
    making sure a blocking VCPU thread would be eventually woken up.  That
    worked fine in the previous arch timer design, but as we are about to
    actually use the soft timer expire function for the physical timer
    emulation, change the logic to use a dedicated hrtimer.
    
    This has the added benefit of not having to cancel any work in the sync
    path, which in turn allows us to run the flush and sync with IRQs
    disabled.
    
    Note that the hrtimer used to program the host kernel's timer to
    generate an exit from the guest when the emulated physical timer fires
    never has to inject any work, and to share the soft_timer_cancel()
    function with the bg_timer, we change the function to only cancel any
    pending work if the pointer to the work struct is not null.
    
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <cdall@linaro.org>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 0eed5bc9fd5e..184c3ef2df93 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -48,6 +48,9 @@ struct arch_timer_cpu {
 	/* Work queued with the above timer expires */
 	struct work_struct		expired;
 
+	/* Physical timer emulation */
+	struct hrtimer			phys_timer;
+
 	/* Is the timer enabled */
 	bool			enabled;
 };

commit 14d61fa98f03cb01f3aea7e3069fdf460caf5587
Author: Christoffer Dall <cdall@linaro.org>
Date:   Sat Jun 17 07:33:02 2017 -0700

    KVM: arm/arm64: Rename soft timer to bg_timer
    
    As we are about to introduce a separate hrtimer for the physical timer,
    call this timer bg_timer, because we refer to this timer as the
    background timer in the code and comments elsewhere.
    
    Signed-off-by: Christoffer Dall <cdall@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index d0beae98f755..0eed5bc9fd5e 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -43,7 +43,7 @@ struct arch_timer_cpu {
 	struct arch_timer_context	ptimer;
 
 	/* Background timer used when the guest is not running */
-	struct hrtimer			timer;
+	struct hrtimer			bg_timer;
 
 	/* Work queued with the above timer expires */
 	struct work_struct		expired;

commit 8409a06f2a2c0baeb6e6ff020b2c5a4592b3078d
Author: Christoffer Dall <cdall@linaro.org>
Date:   Sat Jun 17 01:09:19 2017 -0700

    KVM: arm/arm64: Make timer_arm and timer_disarm helpers more generic
    
    We are about to add an additional soft timer to the arch timer state for
    a VCPU and would like to be able to reuse the functions to program and
    cancel a timer, so we make them slightly more generic and rename to make
    it more clear that these functions work on soft timers and not the
    hardware resource that this code is managing.
    
    The armed flag on the timer state is only used to assert a condition,
    and we don't rely on this assertion in any meaningful way, so we can
    simply get rid of this flack and slightly reduce complexity.
    
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <cdall@linaro.org>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index f0053f884b4a..d0beae98f755 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -48,9 +48,6 @@ struct arch_timer_cpu {
 	/* Work queued with the above timer expires */
 	struct work_struct		expired;
 
-	/* Background timer active */
-	bool				armed;
-
 	/* Is the timer enabled */
 	bool			enabled;
 };

commit 99a1db7a2c9b2ecb9a801cee3f6a7a71945a2fca
Author: Christoffer Dall <cdall@linaro.org>
Date:   Tue May 2 20:19:15 2017 +0200

    KVM: arm/arm64: Allow setting the timer IRQ numbers from userspace
    
    First we define an ABI using the vcpu devices that lets userspace set
    the interrupt numbers for the various timers on both the 32-bit and
    64-bit KVM/ARM implementations.
    
    Second, we add the definitions for the groups and attributes introduced
    by the above ABI.  (We add the PMU define on the 32-bit side as well for
    symmetry and it may get used some day.)
    
    Third, we set up the arch-specific vcpu device operation handlers to
    call into the timer code for anything related to the
    KVM_ARM_VCPU_TIMER_CTRL group.
    
    Fourth, we implement support for getting and setting the timer interrupt
    numbers using the above defined ABI in the arch timer code.
    
    Fifth, we introduce error checking upon enabling the arch timer (which
    is called when first running a VCPU) to check that all VCPUs are
    configured to use the same PPI for the timer (as mandated by the
    architecture) and that the virtual and physical timers are not
    configured to use the same IRQ number.
    
    Signed-off-by: Christoffer Dall <cdall@linaro.org>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index f1c967a4f603..f0053f884b4a 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -68,6 +68,10 @@ void kvm_timer_vcpu_terminate(struct kvm_vcpu *vcpu);
 u64 kvm_arm_timer_get_reg(struct kvm_vcpu *, u64 regid);
 int kvm_arm_timer_set_reg(struct kvm_vcpu *, u64 regid, u64 value);
 
+int kvm_arm_timer_set_attr(struct kvm_vcpu *vcpu, struct kvm_device_attr *attr);
+int kvm_arm_timer_get_attr(struct kvm_vcpu *vcpu, struct kvm_device_attr *attr);
+int kvm_arm_timer_has_attr(struct kvm_vcpu *vcpu, struct kvm_device_attr *attr);
+
 bool kvm_timer_should_fire(struct arch_timer_context *timer_ctx);
 void kvm_timer_schedule(struct kvm_vcpu *vcpu);
 void kvm_timer_unschedule(struct kvm_vcpu *vcpu);

commit 85e69ad7f2cc6dd829987a70cf32785b1d8c8b27
Author: Christoffer Dall <cdall@linaro.org>
Date:   Tue May 2 20:14:06 2017 +0200

    KVM: arm/arm64: Move timer IRQ default init to arch_timer.c
    
    We currently initialize the arch timer IRQ numbers from the reset code,
    presumably because we once intended to model multiple CPU or SoC types
    from within the kernel and have hard-coded reset values in the reset
    code.
    
    As we are moving towards userspace being in charge of more fine-grained
    CPU emulation and stitching together the pieces needed to emulate a
    particular type of CPU, we should no longer have a tight coupling
    between resetting a VCPU and setting IRQ numbers.
    
    Therefore, move the logic to define and use the default IRQ numbers to
    the timer code and set the IRQ number immediately when creating the
    VCPU.
    
    Signed-off-by: Christoffer Dall <cdall@linaro.org>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 295584f31a4e..f1c967a4f603 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -57,9 +57,7 @@ struct arch_timer_cpu {
 
 int kvm_timer_hyp_init(void);
 int kvm_timer_enable(struct kvm_vcpu *vcpu);
-int kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu,
-			 const struct kvm_irq_level *virt_irq,
-			 const struct kvm_irq_level *phys_irq);
+int kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu);
 void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu);
 void kvm_timer_flush_hwstate(struct kvm_vcpu *vcpu);
 void kvm_timer_sync_hwstate(struct kvm_vcpu *vcpu);

commit d9e1397783765a275c3a7930250dcdb7e9480d7d
Author: Alexander Graf <agraf@suse.de>
Date:   Tue Sep 27 21:08:06 2016 +0200

    KVM: arm/arm64: Support arch timers with a userspace gic
    
    If you're running with a userspace gic or other interrupt controller
    (that is no vgic in the kernel), then you have so far not been able to
    use the architected timers, because the output of the architected
    timers, which are driven inside the kernel, was a kernel-only construct
    between the arch timer code and the vgic.
    
    This patch implements the new KVM_CAP_ARM_USER_IRQ feature, where we use a
    side channel on the kvm_run structure, run->s.regs.device_irq_level, to
    always notify userspace of the timer output levels when using a userspace
    irqchip.
    
    This works by ensuring that before we enter the guest, if the timer
    output level has changed compared to what we last told userspace, we
    don't enter the guest, but instead return to userspace to notify it of
    the new level.  If we are exiting, because of an MMIO for example, and
    the level changed at the same time, the value is also updated and
    userspace can sample the line as it needs.  This is nicely achieved
    simply always updating the timer_irq_level field after the main run
    loop.
    
    Note that the kvm_timer_update_irq trace event is changed to show the
    host IRQ number for the timer instead of the guest IRQ number, because
    the kernel no longer know which IRQ userspace wires up the timer signal
    to.
    
    Also note that this patch implements all required functionality but does
    not yet advertise the capability.
    
    Reviewed-by: Alexander Graf <agraf@suse.de>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Alexander Graf <agraf@suse.de>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index fe797d6ef89d..295584f31a4e 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -63,6 +63,8 @@ int kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu,
 void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu);
 void kvm_timer_flush_hwstate(struct kvm_vcpu *vcpu);
 void kvm_timer_sync_hwstate(struct kvm_vcpu *vcpu);
+bool kvm_timer_should_notify_user(struct kvm_vcpu *vcpu);
+void kvm_timer_update_run(struct kvm_vcpu *vcpu);
 void kvm_timer_vcpu_terminate(struct kvm_vcpu *vcpu);
 
 u64 kvm_arm_timer_get_reg(struct kvm_vcpu *, u64 regid);

commit 7b6b46311a8562fb3a9e035ed6ffab6d49c28886
Author: Jintack Lim <jintack@cs.columbia.edu>
Date:   Fri Feb 3 10:20:08 2017 -0500

    KVM: arm/arm64: Emulate the EL1 phys timer registers
    
    Emulate read and write operations to CNTP_TVAL, CNTP_CVAL and CNTP_CTL.
    Now VMs are able to use the EL1 physical timer.
    
    Signed-off-by: Jintack Lim <jintack@cs.columbia.edu>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index f1d2fba0b9c6..fe797d6ef89d 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -72,6 +72,8 @@ bool kvm_timer_should_fire(struct arch_timer_context *timer_ctx);
 void kvm_timer_schedule(struct kvm_vcpu *vcpu);
 void kvm_timer_unschedule(struct kvm_vcpu *vcpu);
 
+u64 kvm_phys_timer_read(void);
+
 void kvm_timer_vcpu_put(struct kvm_vcpu *vcpu);
 
 void kvm_timer_init_vhe(void);

commit a91d18551e7b35e34a04b6fd199ca8568e7e9315
Author: Jintack Lim <jintack@cs.columbia.edu>
Date:   Fri Feb 3 10:20:03 2017 -0500

    KVM: arm/arm64: Initialize the emulated EL1 physical timer
    
    Initialize the emulated EL1 physical timer with the default irq number.
    
    Signed-off-by: Jintack Lim <jintack@cs.columbia.edu>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 6445a3d9a6e2..f1d2fba0b9c6 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -58,7 +58,8 @@ struct arch_timer_cpu {
 int kvm_timer_hyp_init(void);
 int kvm_timer_enable(struct kvm_vcpu *vcpu);
 int kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu,
-			 const struct kvm_irq_level *irq);
+			 const struct kvm_irq_level *virt_irq,
+			 const struct kvm_irq_level *phys_irq);
 void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu);
 void kvm_timer_flush_hwstate(struct kvm_vcpu *vcpu);
 void kvm_timer_sync_hwstate(struct kvm_vcpu *vcpu);

commit 009a5701bb2d166073f75643bc9237fe014c6bf5
Author: Jintack Lim <jintack@cs.columbia.edu>
Date:   Fri Feb 3 10:20:02 2017 -0500

    KVM: arm/arm64: Add the EL1 physical timer context
    
    Add the EL1 physical timer context.
    
    Signed-off-by: Jintack Lim <jintack@cs.columbia.edu>
    Acked-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index f46fa3b62b06..6445a3d9a6e2 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -40,6 +40,7 @@ struct arch_timer_context {
 
 struct arch_timer_cpu {
 	struct arch_timer_context	vtimer;
+	struct arch_timer_context	ptimer;
 
 	/* Background timer used when the guest is not running */
 	struct hrtimer			timer;
@@ -75,4 +76,5 @@ void kvm_timer_vcpu_put(struct kvm_vcpu *vcpu);
 void kvm_timer_init_vhe(void);
 
 #define vcpu_vtimer(v)	(&(v)->arch.timer_cpu.vtimer)
+#define vcpu_ptimer(v)	(&(v)->arch.timer_cpu.ptimer)
 #endif

commit 9171fa2e0951b0cb6c443e0dce2c4620de3b1dfe
Author: Jintack Lim <jintack@cs.columbia.edu>
Date:   Fri Feb 3 10:20:01 2017 -0500

    KVM: arm/arm64: Decouple kvm timer functions from virtual timer
    
    Now that we have a separate structure for timer context, make functions
    generic so that they can work with any timer context, not just the
    virtual timer context.  This does not change the virtual timer
    functionality.
    
    Signed-off-by: Jintack Lim <jintack@cs.columbia.edu>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 2c8560b4642a..f46fa3b62b06 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -66,7 +66,7 @@ void kvm_timer_vcpu_terminate(struct kvm_vcpu *vcpu);
 u64 kvm_arm_timer_get_reg(struct kvm_vcpu *, u64 regid);
 int kvm_arm_timer_set_reg(struct kvm_vcpu *, u64 regid, u64 value);
 
-bool kvm_timer_should_fire(struct kvm_vcpu *vcpu);
+bool kvm_timer_should_fire(struct arch_timer_context *timer_ctx);
 void kvm_timer_schedule(struct kvm_vcpu *vcpu);
 void kvm_timer_unschedule(struct kvm_vcpu *vcpu);
 

commit 90de943a430028ee389b22bf4a7ae5867c32ce0c
Author: Jintack Lim <jintack@cs.columbia.edu>
Date:   Fri Feb 3 10:20:00 2017 -0500

    KVM: arm/arm64: Move cntvoff to each timer context
    
    Make cntvoff per each timer context. This is helpful to abstract kvm
    timer functions to work with timer context without considering timer
    types (e.g. physical timer or virtual timer).
    
    This also would pave the way for ever doing adjustments of the cntvoff
    on a per-CPU basis if that should ever make sense.
    
    Signed-off-by: Jintack Lim <jintack@cs.columbia.edu>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index daad3c133b9f..2c8560b4642a 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -23,11 +23,6 @@
 #include <linux/hrtimer.h>
 #include <linux/workqueue.h>
 
-struct arch_timer_kvm {
-	/* Virtual offset */
-	u64			cntvoff;
-};
-
 struct arch_timer_context {
 	/* Registers: control register, timer value */
 	u32				cnt_ctl;
@@ -38,6 +33,9 @@ struct arch_timer_context {
 
 	/* Active IRQ state caching */
 	bool				active_cleared_last;
+
+	/* Virtual offset */
+	u64			cntvoff;
 };
 
 struct arch_timer_cpu {
@@ -58,7 +56,6 @@ struct arch_timer_cpu {
 
 int kvm_timer_hyp_init(void);
 int kvm_timer_enable(struct kvm_vcpu *vcpu);
-void kvm_timer_init(struct kvm *kvm);
 int kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu,
 			 const struct kvm_irq_level *irq);
 void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu);

commit fbb4aeec5fc2ab47615b2a0cbabc503e1eef4c60
Author: Jintack Lim <jintack@cs.columbia.edu>
Date:   Fri Feb 3 10:19:59 2017 -0500

    KVM: arm/arm64: Abstract virtual timer context into separate structure
    
    Abstract virtual timer context into a separate structure and change all
    callers referring to timer registers, irq state and so on. No change in
    functionality.
    
    This is about to become very handy when adding the EL1 physical timer.
    
    Signed-off-by: Jintack Lim <jintack@cs.columbia.edu>
    Acked-by: Christoffer Dall <christoffer.dall@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 5c970ce67949..daad3c133b9f 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -28,15 +28,20 @@ struct arch_timer_kvm {
 	u64			cntvoff;
 };
 
-struct arch_timer_cpu {
+struct arch_timer_context {
 	/* Registers: control register, timer value */
-	u32				cntv_ctl;	/* Saved/restored */
-	u64				cntv_cval;	/* Saved/restored */
+	u32				cnt_ctl;
+	u64				cnt_cval;
+
+	/* Timer IRQ */
+	struct kvm_irq_level		irq;
+
+	/* Active IRQ state caching */
+	bool				active_cleared_last;
+};
 
-	/*
-	 * Anything that is not used directly from assembly code goes
-	 * here.
-	 */
+struct arch_timer_cpu {
+	struct arch_timer_context	vtimer;
 
 	/* Background timer used when the guest is not running */
 	struct hrtimer			timer;
@@ -47,12 +52,6 @@ struct arch_timer_cpu {
 	/* Background timer active */
 	bool				armed;
 
-	/* Timer IRQ */
-	struct kvm_irq_level		irq;
-
-	/* Active IRQ state caching */
-	bool				active_cleared_last;
-
 	/* Is the timer enabled */
 	bool			enabled;
 };
@@ -77,4 +76,6 @@ void kvm_timer_unschedule(struct kvm_vcpu *vcpu);
 void kvm_timer_vcpu_put(struct kvm_vcpu *vcpu);
 
 void kvm_timer_init_vhe(void);
+
+#define vcpu_vtimer(v)	(&(v)->arch.timer_cpu.vtimer)
 #endif

commit 488f94d7212b00a2ec72fb886b155f1b04c5aa98
Author: Jintack Lim <jintack@cs.columbia.edu>
Date:   Thu Dec 1 14:32:05 2016 -0500

    KVM: arm64: Access CNTHCTL_EL2 bit fields correctly on VHE systems
    
    Current KVM world switch code is unintentionally setting wrong bits to
    CNTHCTL_EL2 when E2H == 1, which may allow guest OS to access physical
    timer.  Bit positions of CNTHCTL_EL2 are changing depending on
    HCR_EL2.E2H bit.  EL1PCEN and EL1PCTEN are 1st and 0th bits when E2H is
    not set, but they are 11th and 10th bits respectively when E2H is set.
    
    In fact, on VHE we only need to set those bits once, not for every world
    switch. This is because the host kernel runs in EL2 with HCR_EL2.TGE ==
    1, which makes those bits have no effect for the host kernel execution.
    So we just set those bits once for guests, and that's it.
    
    Signed-off-by: Jintack Lim <jintack@cs.columbia.edu>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index b717ed9d2b75..5c970ce67949 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -76,4 +76,5 @@ void kvm_timer_unschedule(struct kvm_vcpu *vcpu);
 
 void kvm_timer_vcpu_put(struct kvm_vcpu *vcpu);
 
+void kvm_timer_init_vhe(void);
 #endif

commit a5a1d1c2914b5316924c7893eb683a5420ebd3be
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Dec 21 20:32:01 2016 +0100

    clocksource: Use a plain u64 instead of cycle_t
    
    There is no point in having an extra type for extra confusion. u64 is
    unambiguous.
    
    Conversion was done with the following coccinelle script:
    
    @rem@
    @@
    -typedef u64 cycle_t;
    
    @fix@
    typedef cycle_t;
    @@
    -cycle_t
    +u64
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index dda39d8fa189..b717ed9d2b75 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -25,13 +25,13 @@
 
 struct arch_timer_kvm {
 	/* Virtual offset */
-	cycle_t			cntvoff;
+	u64			cntvoff;
 };
 
 struct arch_timer_cpu {
 	/* Registers: control register, timer value */
 	u32				cntv_ctl;	/* Saved/restored */
-	cycle_t				cntv_cval;	/* Saved/restored */
+	u64				cntv_cval;	/* Saved/restored */
 
 	/*
 	 * Anything that is not used directly from assembly code goes

commit 41a54482c010d8806cf56e1501bb3b61fac14cf9
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Wed May 18 16:26:00 2016 +0100

    KVM: arm/arm64: Move timer IRQ map to latest possible time
    
    We are about to modify the VGIC to allocate all data structures
    dynamically and store mapped IRQ information on a per-IRQ struct, which
    is indeed allocated dynamically at init time.
    
    Therefore, we cannot record the mapped IRQ info from the timer at timer
    reset time like it's done now, because VCPU reset happens before timer
    init.
    
    A possible later time to do this is on the first run of a per VCPU, it
    just requires us to move the enable state to be a per-VCPU state and do
    the lookup of the physical IRQ number when we are about to run the VCPU.
    
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index a47b7dee434d..dda39d8fa189 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -24,9 +24,6 @@
 #include <linux/workqueue.h>
 
 struct arch_timer_kvm {
-	/* Is the timer enabled */
-	bool			enabled;
-
 	/* Virtual offset */
 	cycle_t			cntvoff;
 };
@@ -55,10 +52,13 @@ struct arch_timer_cpu {
 
 	/* Active IRQ state caching */
 	bool				active_cleared_last;
+
+	/* Is the timer enabled */
+	bool			enabled;
 };
 
 int kvm_timer_hyp_init(void);
-void kvm_timer_enable(struct kvm *kvm);
+int kvm_timer_enable(struct kvm_vcpu *vcpu);
 void kvm_timer_init(struct kvm *kvm);
 int kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu,
 			 const struct kvm_irq_level *irq);

commit a7e33ad9b25552b75a2523cc598db8bcd218ede5
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Wed Apr 13 11:03:02 2016 +0100

    KVM: arm/arm64: arch_timer: Remove irq_phys_map
    
    Now that the interface between the arch timer and the VGIC does not
    require passing the irq_phys_map entry pointer anymore, let's remove
    it from the virtual arch timer and use the virtual IRQ number instead
    directly.
    The remaining pointer returned by kvm_vgic_map_phys_irq() will be
    removed in the following patch.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Eric Auger <eric.auger@linaro.org>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index b651aed9dc6b..a47b7dee434d 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -53,9 +53,6 @@ struct arch_timer_cpu {
 	/* Timer IRQ */
 	struct kvm_irq_level		irq;
 
-	/* VGIC mapping */
-	struct irq_phys_map		*map;
-
 	/* Active IRQ state caching */
 	bool				active_cleared_last;
 };

commit 9b4a3004439d5be680faf41f4267968ca11bb9f6
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Jan 29 19:04:48 2016 +0000

    KVM: arm/arm64: timer: Add active state caching
    
    Programming the active state in the (re)distributor can be an
    expensive operation so it makes some sense to try and reduce
    the number of accesses as much as possible. So far, we
    program the active state on each VM entry, but there is some
    opportunity to do less.
    
    An obvious solution is to cache the active state in memory,
    and only program it in the HW when conditions change. But
    because the HW can also change things under our feet (the active
    state can transition from 1 to 0 when the guest does an EOI),
    some precautions have to be taken, which amount to only caching
    an "inactive" state, and always programing it otherwise.
    
    With this in place, we observe a reduction of around 700 cycles
    on a 2GHz GICv2 platform for a NULL hypercall.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 1800227af9d6..b651aed9dc6b 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -55,6 +55,9 @@ struct arch_timer_cpu {
 
 	/* VGIC mapping */
 	struct irq_phys_map		*map;
+
+	/* Active IRQ state caching */
+	bool				active_cleared_last;
 };
 
 int kvm_timer_hyp_init(void);
@@ -74,4 +77,6 @@ bool kvm_timer_should_fire(struct kvm_vcpu *vcpu);
 void kvm_timer_schedule(struct kvm_vcpu *vcpu);
 void kvm_timer_unschedule(struct kvm_vcpu *vcpu);
 
+void kvm_timer_vcpu_put(struct kvm_vcpu *vcpu);
+
 #endif

commit 4b4b4512da2a844b8da2585609b67fae1ce4f4db
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Sun Aug 30 15:01:27 2015 +0200

    arm/arm64: KVM: Rework the arch timer to use level-triggered semantics
    
    The arch timer currently uses edge-triggered semantics in the sense that
    the line is never sampled by the vgic and lowering the line from the
    timer to the vgic doesn't have any effect on the pending state of
    virtual interrupts in the vgic.  This means that we do not support a
    guest with the otherwise valid behavior of (1) disable interrupts (2)
    enable the timer (3) disable the timer (4) enable interrupts.  Such a
    guest would validly not expect to see any interrupts on real hardware,
    but will see interrupts on KVM.
    
    This patch fixes this shortcoming through the following series of
    changes.
    
    First, we change the flow of the timer/vgic sync/flush operations.  Now
    the timer is always flushed/synced before the vgic, because the vgic
    samples the state of the timer output.  This has the implication that we
    move the timer operations in to non-preempible sections, but that is
    fine after the previous commit getting rid of hrtimer schedules on every
    entry/exit.
    
    Second, we change the internal behavior of the timer, letting the timer
    keep track of its previous output state, and only lower/raise the line
    to the vgic when the state changes.  Note that in theory this could have
    been accomplished more simply by signalling the vgic every time the
    state *potentially* changed, but we don't want to be hitting the vgic
    more often than necessary.
    
    Third, we get rid of the use of the map->active field in the vgic and
    instead simply set the interrupt as active on the physical distributor
    whenever the input to the GIC is asserted and conversely clear the
    physical active state when the input to the GIC is deasserted.
    
    Fourth, and finally, we now initialize the timer PPIs (and all the other
    unused PPIs for now), to be level-triggered, and modify the sync code to
    sample the line state on HW sync and re-inject a new interrupt if it is
    still pending at that time.
    
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index ef14cc1f1f26..1800227af9d6 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -51,7 +51,7 @@ struct arch_timer_cpu {
 	bool				armed;
 
 	/* Timer IRQ */
-	const struct kvm_irq_level	*irq;
+	struct kvm_irq_level		irq;
 
 	/* VGIC mapping */
 	struct irq_phys_map		*map;

commit d35268da66870d733ae763fd7f9b06a1f63f395e
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Tue Aug 25 19:48:21 2015 +0200

    arm/arm64: KVM: arch_timer: Only schedule soft timer on vcpu_block
    
    We currently schedule a soft timer every time we exit the guest if the
    timer did not expire while running the guest.  This is really not
    necessary, because the only work we do in the timer work function is to
    kick the vcpu.
    
    Kicking the vcpu does two things:
    (1) If the vpcu thread is on a waitqueue, make it runnable and remove it
    from the waitqueue.
    (2) If the vcpu is running on a different physical CPU from the one
    doing the kick, it sends a reschedule IPI.
    
    The second case cannot happen, because the soft timer is only ever
    scheduled when the vcpu is not running.  The first case is only relevant
    when the vcpu thread is on a waitqueue, which is only the case when the
    vcpu thread has called kvm_vcpu_block().
    
    Therefore, we only need to make sure a timer is scheduled for
    kvm_vcpu_block(), which we do by encapsulating all calls to
    kvm_vcpu_block() with kvm_timer_{un}schedule calls.
    
    Additionally, we only schedule a soft timer if the timer is enabled and
    unmasked, since it is useless otherwise.
    
    Note that theoretically userspace can use the SET_ONE_REG interface to
    change registers that should cause the timer to fire, even if the vcpu
    is blocked without a scheduled timer, but this case was not supported
    before this patch and we leave it for future work for now.
    
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index e1e4d7c38dda..ef14cc1f1f26 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -71,5 +71,7 @@ u64 kvm_arm_timer_get_reg(struct kvm_vcpu *, u64 regid);
 int kvm_arm_timer_set_reg(struct kvm_vcpu *, u64 regid, u64 value);
 
 bool kvm_timer_should_fire(struct kvm_vcpu *vcpu);
+void kvm_timer_schedule(struct kvm_vcpu *vcpu);
+void kvm_timer_unschedule(struct kvm_vcpu *vcpu);
 
 #endif

commit f120cd6533d21075ab103ae6c225b1697853660d
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Jun 23 13:59:13 2014 +0100

    KVM: arm/arm64: timer: Allow the timer to control the active state
    
    In order to remove the crude hack where we sneak the masked bit
    into the timer's control register, make use of the phys_irq_map
    API control the active state of the interrupt.
    
    This causes some limited changes to allow for potential error
    propagation.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index e5966758c093..e1e4d7c38dda 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -52,13 +52,16 @@ struct arch_timer_cpu {
 
 	/* Timer IRQ */
 	const struct kvm_irq_level	*irq;
+
+	/* VGIC mapping */
+	struct irq_phys_map		*map;
 };
 
 int kvm_timer_hyp_init(void);
 void kvm_timer_enable(struct kvm *kvm);
 void kvm_timer_init(struct kvm *kvm);
-void kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu,
-			  const struct kvm_irq_level *irq);
+int kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu,
+			 const struct kvm_irq_level *irq);
 void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu);
 void kvm_timer_flush_hwstate(struct kvm_vcpu *vcpu);
 void kvm_timer_sync_hwstate(struct kvm_vcpu *vcpu);

commit 1a74847885cc87857d631f91cca4d83924f75674
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Fri Mar 13 17:02:55 2015 +0000

    arm/arm64: KVM: Fix migration race in the arch timer
    
    When a VCPU is no longer running, we currently check to see if it has a
    timer scheduled in the future, and if it does, we schedule a host
    hrtimer to notify is in case the timer expires while the VCPU is still
    not running.  When the hrtimer fires, we mask the guest's timer and
    inject the timer IRQ (still relying on the guest unmasking the time when
    it receives the IRQ).
    
    This is all good and fine, but when migration a VM (checkpoint/restore)
    this introduces a race.  It is unlikely, but possible, for the following
    sequence of events to happen:
    
     1. Userspace stops the VM
     2. Hrtimer for VCPU is scheduled
     3. Userspace checkpoints the VGIC state (no pending timer interrupts)
     4. The hrtimer fires, schedules work in a workqueue
     5. Workqueue function runs, masks the timer and injects timer interrupt
     6. Userspace checkpoints the timer state (timer masked)
    
    At restore time, you end up with a masked timer without any timer
    interrupts and your guest halts never receiving timer interrupts.
    
    Fix this by only kicking the VCPU in the workqueue function, and sample
    the expired state of the timer when entering the guest again and inject
    the interrupt and mask the timer only then.
    
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Alex Bennée <alex.bennee@linaro.org>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index a74e4c2bf188..e5966758c093 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -67,4 +67,6 @@ void kvm_timer_vcpu_terminate(struct kvm_vcpu *vcpu);
 u64 kvm_arm_timer_get_reg(struct kvm_vcpu *, u64 regid);
 int kvm_arm_timer_set_reg(struct kvm_vcpu *, u64 regid, u64 value);
 
+bool kvm_timer_should_fire(struct kvm_vcpu *vcpu);
+
 #endif

commit 662d9715840aef44dcb573b0f9fab9e8319c868a
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Wed Mar 11 14:21:31 2015 +0100

    arm/arm64: KVM: Kill CONFIG_KVM_ARM_{VGIC,TIMER}
    
    We can definitely decide at run-time whether to use the GIC and timers
    or not, and the extra code and data structures that we allocate space
    for is really negligable with this config option, so I don't think it's
    worth the extra complexity of always having to define stub static
    inlines.  The !CONFIG_KVM_ARM_VGIC/TIMER case is pretty much an untested
    code path anyway, so we're better off just getting rid of it.
    
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index b3f45a578344..a74e4c2bf188 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -24,17 +24,14 @@
 #include <linux/workqueue.h>
 
 struct arch_timer_kvm {
-#ifdef CONFIG_KVM_ARM_TIMER
 	/* Is the timer enabled */
 	bool			enabled;
 
 	/* Virtual offset */
 	cycle_t			cntvoff;
-#endif
 };
 
 struct arch_timer_cpu {
-#ifdef CONFIG_KVM_ARM_TIMER
 	/* Registers: control register, timer value */
 	u32				cntv_ctl;	/* Saved/restored */
 	cycle_t				cntv_cval;	/* Saved/restored */
@@ -55,10 +52,8 @@ struct arch_timer_cpu {
 
 	/* Timer IRQ */
 	const struct kvm_irq_level	*irq;
-#endif
 };
 
-#ifdef CONFIG_KVM_ARM_TIMER
 int kvm_timer_hyp_init(void);
 void kvm_timer_enable(struct kvm *kvm);
 void kvm_timer_init(struct kvm *kvm);
@@ -72,30 +67,4 @@ void kvm_timer_vcpu_terminate(struct kvm_vcpu *vcpu);
 u64 kvm_arm_timer_get_reg(struct kvm_vcpu *, u64 regid);
 int kvm_arm_timer_set_reg(struct kvm_vcpu *, u64 regid, u64 value);
 
-#else
-static inline int kvm_timer_hyp_init(void)
-{
-	return 0;
-};
-
-static inline void kvm_timer_enable(struct kvm *kvm) {}
-static inline void kvm_timer_init(struct kvm *kvm) {}
-static inline void kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu,
-					const struct kvm_irq_level *irq) {}
-static inline void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu) {}
-static inline void kvm_timer_flush_hwstate(struct kvm_vcpu *vcpu) {}
-static inline void kvm_timer_sync_hwstate(struct kvm_vcpu *vcpu) {}
-static inline void kvm_timer_vcpu_terminate(struct kvm_vcpu *vcpu) {}
-
-static inline int kvm_arm_timer_set_reg(struct kvm_vcpu *vcpu, u64 regid, u64 value)
-{
-	return 0;
-}
-
-static inline u64 kvm_arm_timer_get_reg(struct kvm_vcpu *vcpu, u64 regid)
-{
-	return 0;
-}
-#endif
-
 #endif

commit 05971120fca43e0357789a14b3386bb56eef2201
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Fri Dec 12 21:19:23 2014 +0100

    arm/arm64: KVM: Require in-kernel vgic for the arch timers
    
    It is curently possible to run a VM with architected timers support
    without creating an in-kernel VGIC, which will result in interrupts from
    the virtual timer going nowhere.
    
    To address this issue, move the architected timers initialization to the
    time when we run a VCPU for the first time, and then only initialize
    (and enable) the architected timers if we have a properly created and
    initialized in-kernel VGIC.
    
    When injecting interrupts from the virtual timer to the vgic, the
    current setup should ensure that this never calls an on-demand init of
    the VGIC, which is the only call path that could return an error from
    kvm_vgic_inject_irq(), so capture the return value and raise a warning
    if there's an error there.
    
    We also change the kvm_timer_init() function from returning an int to be
    a void function, since the function always succeeds.
    
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index ad9db6045b2f..b3f45a578344 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -60,7 +60,8 @@ struct arch_timer_cpu {
 
 #ifdef CONFIG_KVM_ARM_TIMER
 int kvm_timer_hyp_init(void);
-int kvm_timer_init(struct kvm *kvm);
+void kvm_timer_enable(struct kvm *kvm);
+void kvm_timer_init(struct kvm *kvm);
 void kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu,
 			  const struct kvm_irq_level *irq);
 void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu);
@@ -77,11 +78,8 @@ static inline int kvm_timer_hyp_init(void)
 	return 0;
 };
 
-static inline int kvm_timer_init(struct kvm *kvm)
-{
-	return 0;
-}
-
+static inline void kvm_timer_enable(struct kvm *kvm) {}
+static inline void kvm_timer_init(struct kvm *kvm) {}
 static inline void kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu,
 					const struct kvm_irq_level *irq) {}
 static inline void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu) {}

commit 1df08ba0aa95f1a8832b7162eec51069bd9be7ae
Author: Alex Bennée <alex.bennee@linaro.org>
Date:   Fri Jul 4 15:54:14 2014 +0100

    arm64: KVM: allow export and import of generic timer regs
    
    For correct guest suspend/resume behaviour we need to ensure we include
    the generic timer registers for 64 bit guests. As CONFIG_KVM_ARM_TIMER is
    always set for arm64 we don't need to worry about null implementations.
    However I have re-jigged the kvm_arm_timer_set/get_reg declarations to
    be in the common include/kvm/arm_arch_timer.h headers.
    
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Alex Bennée <alex.bennee@linaro.org>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 6d9aeddc09bf..ad9db6045b2f 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -67,6 +67,10 @@ void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu);
 void kvm_timer_flush_hwstate(struct kvm_vcpu *vcpu);
 void kvm_timer_sync_hwstate(struct kvm_vcpu *vcpu);
 void kvm_timer_vcpu_terminate(struct kvm_vcpu *vcpu);
+
+u64 kvm_arm_timer_get_reg(struct kvm_vcpu *, u64 regid);
+int kvm_arm_timer_set_reg(struct kvm_vcpu *, u64 regid, u64 value);
+
 #else
 static inline int kvm_timer_hyp_init(void)
 {
@@ -84,6 +88,16 @@ static inline void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu) {}
 static inline void kvm_timer_flush_hwstate(struct kvm_vcpu *vcpu) {}
 static inline void kvm_timer_sync_hwstate(struct kvm_vcpu *vcpu) {}
 static inline void kvm_timer_vcpu_terminate(struct kvm_vcpu *vcpu) {}
+
+static inline int kvm_arm_timer_set_reg(struct kvm_vcpu *vcpu, u64 regid, u64 value)
+{
+	return 0;
+}
+
+static inline u64 kvm_arm_timer_get_reg(struct kvm_vcpu *vcpu, u64 regid)
+{
+	return 0;
+}
 #endif
 
 #endif

commit 5ae7f87a56fab10b8f9b135a8377c144397293ca
Author: Anup Patel <anup.patel@linaro.org>
Date:   Tue Apr 30 12:02:15 2013 +0530

    ARM: KVM: Allow host virt timer irq to be different from guest timer virt irq
    
    The arch_timer irq numbers (or PPI numbers) are implementation dependent,
    so the host virtual timer irq number can be different from guest virtual
    timer irq number.
    
    This patch ensures that host virtual timer irq number is read from DTB and
    guest virtual timer irq is determined based on vcpu target type.
    
    Signed-off-by: Anup Patel <anup.patel@linaro.org>
    Signed-off-by: Pranavkumar Sawargaonkar <pranavkumar@linaro.org>
    Signed-off-by: Christoffer Dall <cdall@cs.columbia.edu>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
index 68cb9e1dfb81..6d9aeddc09bf 100644
--- a/include/kvm/arm_arch_timer.h
+++ b/include/kvm/arm_arch_timer.h
@@ -61,6 +61,8 @@ struct arch_timer_cpu {
 #ifdef CONFIG_KVM_ARM_TIMER
 int kvm_timer_hyp_init(void);
 int kvm_timer_init(struct kvm *kvm);
+void kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu,
+			  const struct kvm_irq_level *irq);
 void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu);
 void kvm_timer_flush_hwstate(struct kvm_vcpu *vcpu);
 void kvm_timer_sync_hwstate(struct kvm_vcpu *vcpu);
@@ -76,6 +78,8 @@ static inline int kvm_timer_init(struct kvm *kvm)
 	return 0;
 }
 
+static inline void kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu,
+					const struct kvm_irq_level *irq) {}
 static inline void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu) {}
 static inline void kvm_timer_flush_hwstate(struct kvm_vcpu *vcpu) {}
 static inline void kvm_timer_sync_hwstate(struct kvm_vcpu *vcpu) {}

commit 7275acdfe29ba03ad2f6e150386900c4e2d43fb1
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue May 14 14:31:01 2013 +0100

    ARM: KVM: move GIC/timer code to a common location
    
    As KVM/arm64 is looming on the horizon, it makes sense to move some
    of the common code to a single location in order to reduce duplication.
    
    The code could live anywhere. Actually, most of KVM is already built
    with a bunch of ugly ../../.. hacks in the various Makefiles, so we're
    not exactly talking about style here. But maybe it is time to start
    moving into a less ugly direction.
    
    The include files must be in a "public" location, as they are accessed
    from non-KVM files (arch/arm/kernel/asm-offsets.c).
    
    For this purpose, introduce two new locations:
    - virt/kvm/arm/ : x86 and ia64 already share the ioapic code in
      virt/kvm, so this could be seen as a (very ugly) precedent.
    - include/kvm/  : there is already an include/xen, and while the
      intent is slightly different, this seems as good a location as
      any
    
    Eventually, we should probably have independant Makefiles at every
    levels (just like everywhere else in the kernel), but this is just
    the first step.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Gleb Natapov <gleb@redhat.com>

diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h
new file mode 100644
index 000000000000..68cb9e1dfb81
--- /dev/null
+++ b/include/kvm/arm_arch_timer.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2012 ARM Ltd.
+ * Author: Marc Zyngier <marc.zyngier@arm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARM_KVM_ARCH_TIMER_H
+#define __ASM_ARM_KVM_ARCH_TIMER_H
+
+#include <linux/clocksource.h>
+#include <linux/hrtimer.h>
+#include <linux/workqueue.h>
+
+struct arch_timer_kvm {
+#ifdef CONFIG_KVM_ARM_TIMER
+	/* Is the timer enabled */
+	bool			enabled;
+
+	/* Virtual offset */
+	cycle_t			cntvoff;
+#endif
+};
+
+struct arch_timer_cpu {
+#ifdef CONFIG_KVM_ARM_TIMER
+	/* Registers: control register, timer value */
+	u32				cntv_ctl;	/* Saved/restored */
+	cycle_t				cntv_cval;	/* Saved/restored */
+
+	/*
+	 * Anything that is not used directly from assembly code goes
+	 * here.
+	 */
+
+	/* Background timer used when the guest is not running */
+	struct hrtimer			timer;
+
+	/* Work queued with the above timer expires */
+	struct work_struct		expired;
+
+	/* Background timer active */
+	bool				armed;
+
+	/* Timer IRQ */
+	const struct kvm_irq_level	*irq;
+#endif
+};
+
+#ifdef CONFIG_KVM_ARM_TIMER
+int kvm_timer_hyp_init(void);
+int kvm_timer_init(struct kvm *kvm);
+void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu);
+void kvm_timer_flush_hwstate(struct kvm_vcpu *vcpu);
+void kvm_timer_sync_hwstate(struct kvm_vcpu *vcpu);
+void kvm_timer_vcpu_terminate(struct kvm_vcpu *vcpu);
+#else
+static inline int kvm_timer_hyp_init(void)
+{
+	return 0;
+};
+
+static inline int kvm_timer_init(struct kvm *kvm)
+{
+	return 0;
+}
+
+static inline void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu) {}
+static inline void kvm_timer_flush_hwstate(struct kvm_vcpu *vcpu) {}
+static inline void kvm_timer_sync_hwstate(struct kvm_vcpu *vcpu) {}
+static inline void kvm_timer_vcpu_terminate(struct kvm_vcpu *vcpu) {}
+#endif
+
+#endif
