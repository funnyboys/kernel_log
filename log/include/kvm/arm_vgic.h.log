commit fc5d1f1a42fba6266ab95dc3b84937933a9b5a66
Author: Christoffer Dall <christoffer.dall@arm.com>
Date:   Sat Dec 1 08:41:28 2018 -0800

    KVM: arm64: vgic-v3: Take cpu_if pointer directly instead of vcpu
    
    If we move the used_lrs field to the version-specific cpu interface
    structure, the following functions only operate on the struct
    vgic_v3_cpu_if and not the full vcpu:
    
      __vgic_v3_save_state
      __vgic_v3_restore_state
      __vgic_v3_activate_traps
      __vgic_v3_deactivate_traps
      __vgic_v3_save_aprs
      __vgic_v3_restore_aprs
    
    This is going to be very useful for nested virt, so move the used_lrs
    field and change the prototypes and implementations of these functions to
    take the cpu_if parameter directly.
    
    No functional change.
    
    Reviewed-by: James Morse <james.morse@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 69f4164d6477..a8d8fdcd3723 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -274,6 +274,8 @@ struct vgic_v2_cpu_if {
 	u32		vgic_vmcr;
 	u32		vgic_apr;
 	u32		vgic_lr[VGIC_V2_MAX_LRS];
+
+	unsigned int used_lrs;
 };
 
 struct vgic_v3_cpu_if {
@@ -291,6 +293,8 @@ struct vgic_v3_cpu_if {
 	 * linking the Linux IRQ subsystem and the ITS together.
 	 */
 	struct its_vpe	its_vpe;
+
+	unsigned int used_lrs;
 };
 
 struct vgic_cpu {
@@ -300,7 +304,6 @@ struct vgic_cpu {
 		struct vgic_v3_cpu_if	vgic_v3;
 	};
 
-	unsigned int used_lrs;
 	struct vgic_irq private_irqs[VGIC_NR_PRIVATE_IRQS];
 
 	raw_spinlock_t ap_list_lock;	/* Protects the ap_list */

commit bacf2c60548befa8a31c2f19ef65bf2177fda33f
Author: Marc Zyngier <maz@kernel.org>
Date:   Wed Mar 4 20:33:26 2020 +0000

    KVM: arm64: GICv4.1: Allow SGIs to switch between HW and SW interrupts
    
    In order to let a guest buy in the new, active-less SGIs, we
    need to be able to switch between the two modes.
    
    Handle this by stopping all guest activity, transfer the state
    from one mode to the other, and resume the guest. Nothing calls
    this code so far, but a later patch will plug it into the MMIO
    emulation.
    
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Reviewed-by: Zenghui Yu <yuzenghui@huawei.com>
    Link: https://lore.kernel.org/r/20200304203330.4967-20-maz@kernel.org

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 63457908c9c4..69f4164d6477 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -231,6 +231,9 @@ struct vgic_dist {
 	/* distributor enabled */
 	bool			enabled;
 
+	/* Wants SGIs without active state */
+	bool			nassgireq;
+
 	struct vgic_irq		*spis;
 
 	struct vgic_io_device	dist_iodev;

commit ae699ad348cdcd416cbf28e8a02fc468780161f7
Author: Marc Zyngier <maz@kernel.org>
Date:   Wed Mar 4 20:33:20 2020 +0000

    irqchip/gic-v4.1: Move doorbell management to the GICv4 abstraction layer
    
    In order to hide some of the differences between v4.0 and v4.1, move
    the doorbell management out of the KVM code, and into the GICv4-specific
    layer. This allows the calling code to ask for the doorbell when blocking,
    and otherwise to leave the doorbell permanently disabled.
    
    This matches the v4.1 code perfectly, and only results in a minor
    refactoring of the v4.0 code.
    
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Reviewed-by: Zenghui Yu <yuzenghui@huawei.com>
    Link: https://lore.kernel.org/r/20200304203330.4967-14-maz@kernel.org

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 9d53f545a3d5..63457908c9c4 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -70,6 +70,7 @@ struct vgic_global {
 
 	/* Hardware has GICv4? */
 	bool			has_gicv4;
+	bool			has_gicv4_1;
 
 	/* GIC system register CPU interface */
 	struct static_key_false gicv3_cpuif;

commit bad36e4e8cdc9048948490293efefdbd85c40ecc
Author: Zenghui Yu <yuzenghui@huawei.com>
Date:   Tue Oct 29 15:19:18 2019 +0800

    KVM: arm/arm64: vgic: Fix some comments typo
    
    Fix various comments, including wrong function names, grammar mistakes
    and specification references.
    
    Signed-off-by: Zenghui Yu <yuzenghui@huawei.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Link: https://lore.kernel.org/r/20191029071919.177-3-yuzenghui@huawei.com

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index f66a02dac8b0..9d53f545a3d5 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -240,7 +240,7 @@ struct vgic_dist {
 	 * Contains the attributes and gpa of the LPI configuration table.
 	 * Since we report GICR_TYPER.CommonLPIAff as 0b00, we can share
 	 * one address across all redistributors.
-	 * GICv3 spec: 6.1.2 "LPI Configuration tables"
+	 * GICv3 spec: IHI 0069E 6.1.1 "LPI Configuration tables"
 	 */
 	u64			propbaser;
 

commit 9ff624cdbff4466a356892500699aea9318d584e
Author: Zenghui Yu <yuzenghui@huawei.com>
Date:   Tue Oct 29 15:19:17 2019 +0800

    KVM: arm/arm64: vgic: Remove the declaration of kvm_send_userspace_msi()
    
    The callsite of kvm_send_userspace_msi() is currently arch agnostic.
    There seems no reason to keep an extra declaration of it in arm_vgic.h
    (we already have one in include/linux/kvm_host.h).
    
    Remove it.
    
    Signed-off-by: Zenghui Yu <yuzenghui@huawei.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Link: https://lore.kernel.org/r/20191029071919.177-2-yuzenghui@huawei.com

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 4dc58d7a0010..f66a02dac8b0 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -378,8 +378,6 @@ static inline int kvm_vgic_get_max_vcpus(void)
 	return kvm_vgic_global_state.max_gic_vcpus;
 }
 
-int kvm_send_userspace_msi(struct kvm *kvm, struct kvm_msi *msi);
-
 /**
  * kvm_vgic_setup_default_irq_routing:
  * Setup a default flat gsi routing table mapping all SPIs

commit 8e01d9a396e6db153d94a6004e6473d9ff251a6a
Author: Marc Zyngier <maz@kernel.org>
Date:   Sun Oct 27 14:41:59 2019 +0000

    KVM: arm64: vgic-v4: Move the GICv4 residency flow to be driven by vcpu_load/put
    
    When the VHE code was reworked, a lot of the vgic stuff was moved around,
    but the GICv4 residency code did stay untouched, meaning that we come
    in and out of residency on each flush/sync, which is obviously suboptimal.
    
    To address this, let's move things around a bit:
    
    - Residency entry (flush) moves to vcpu_load
    - Residency exit (sync) moves to vcpu_put
    - On blocking (entry to WFI), we "put"
    - On unblocking (exit from WFI), we "load"
    
    Because these can nest (load/block/put/load/unblock/put, for example),
    we now have per-VPE tracking of the residency state.
    
    Additionally, vgic_v4_put gains a "need doorbell" parameter, which only
    gets set to true when blocking because of a WFI. This allows a finer
    control of the doorbell, which now also gets disabled as soon as
    it gets signaled.
    
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Link: https://lore.kernel.org/r/20191027144234.8395-2-maz@kernel.org

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index af4f09c02bf1..4dc58d7a0010 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -396,7 +396,7 @@ int kvm_vgic_v4_set_forwarding(struct kvm *kvm, int irq,
 int kvm_vgic_v4_unset_forwarding(struct kvm *kvm, int irq,
 				 struct kvm_kernel_irq_routing_entry *irq_entry);
 
-void kvm_vgic_v4_enable_doorbell(struct kvm_vcpu *vcpu);
-void kvm_vgic_v4_disable_doorbell(struct kvm_vcpu *vcpu);
+int vgic_v4_load(struct kvm_vcpu *vcpu);
+int vgic_v4_put(struct kvm_vcpu *vcpu, bool need_db);
 
 #endif /* __KVM_ARM_VGIC_H */

commit 3109741a8d773b91eec4a1f7764c97a1176ec32d
Author: Eric Auger <eric.auger@redhat.com>
Date:   Fri Aug 23 19:33:30 2019 +0200

    KVM: arm/arm64: vgic: Use a single IO device per redistributor
    
    At the moment we use 2 IO devices per GICv3 redistributor: one
    one for the RD_base frame and one for the SGI_base frame.
    
    Instead we can use a single IO device per redistributor (the 2
    frames are contiguous). This saves slots on the KVM_MMIO_BUS
    which is currently limited to NR_IOBUS_DEVS (1000).
    
    This change allows to instantiate up to 512 redistributors and may
    speed the guest boot with a large number of VCPUs.
    
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index ded50a30e2d5..af4f09c02bf1 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -314,7 +314,6 @@ struct vgic_cpu {
 	 * parts of the redistributor.
 	 */
 	struct vgic_io_device	rd_iodev;
-	struct vgic_io_device	sgi_iodev;
 	struct vgic_redist_region *rdreg;
 
 	/* Contains the attributes and gpa of the LPI pending tables. */

commit 24cab82c34aa6f3ede3de1d8621624cb5ef33feb
Author: Marc Zyngier <maz@kernel.org>
Date:   Mon Mar 18 10:13:01 2019 +0000

    KVM: arm/arm64: vgic: Add LPI translation cache definition
    
    Add the basic data structure that expresses an MSI to LPI
    translation as well as the allocation/release hooks.
    
    The size of the cache is arbitrarily defined as 16*nr_vcpus.
    
    Tested-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 7a30524a80ee..ded50a30e2d5 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -249,6 +249,9 @@ struct vgic_dist {
 	struct list_head	lpi_list_head;
 	int			lpi_list_count;
 
+	/* LPI translation cache */
+	struct list_head	lpi_translation_cache;
+
 	/* used by vgic-debug */
 	struct vgic_state_iter *iter;
 

commit 5eeaf10eec394b28fad2c58f1f5c3a5da0e87d1c
Author: Marc Zyngier <maz@kernel.org>
Date:   Fri Aug 2 10:28:32 2019 +0100

    KVM: arm/arm64: Sync ICH_VMCR_EL2 back when about to block
    
    Since commit commit 328e56647944 ("KVM: arm/arm64: vgic: Defer
    touching GICH_VMCR to vcpu_load/put"), we leave ICH_VMCR_EL2 (or
    its GICv2 equivalent) loaded as long as we can, only syncing it
    back when we're scheduled out.
    
    There is a small snag with that though: kvm_vgic_vcpu_pending_irq(),
    which is indirectly called from kvm_vcpu_check_block(), needs to
    evaluate the guest's view of ICC_PMR_EL1. At the point were we
    call kvm_vcpu_check_block(), the vcpu is still loaded, and whatever
    changes to PMR is not visible in memory until we do a vcpu_put().
    
    Things go really south if the guest does the following:
    
            mov x0, #0      // or any small value masking interrupts
            msr ICC_PMR_EL1, x0
    
            [vcpu preempted, then rescheduled, VMCR sampled]
    
            mov x0, #ff     // allow all interrupts
            msr ICC_PMR_EL1, x0
            wfi             // traps to EL2, so samping of VMCR
    
            [interrupt arrives just after WFI]
    
    Here, the hypervisor's view of PMR is zero, while the guest has enabled
    its interrupts. kvm_vgic_vcpu_pending_irq() will then say that no
    interrupts are pending (despite an interrupt being received) and we'll
    block for no reason. If the guest doesn't have a periodic interrupt
    firing once it has blocked, it will stay there forever.
    
    To avoid this unfortuante situation, let's resync VMCR from
    kvm_arch_vcpu_blocking(), ensuring that a following kvm_vcpu_check_block()
    will observe the latest value of PMR.
    
    This has been found by booting an arm64 Linux guest with the pseudo NMI
    feature, and thus using interrupt priorities to mask interrupts instead
    of the usual PSTATE masking.
    
    Cc: stable@vger.kernel.org # 4.12
    Fixes: 328e56647944 ("KVM: arm/arm64: vgic: Defer touching GICH_VMCR to vcpu_load/put")
    Signed-off-by: Marc Zyngier <maz@kernel.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 46bbc949c20a..7a30524a80ee 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -350,6 +350,7 @@ int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
 
 void kvm_vgic_load(struct kvm_vcpu *vcpu);
 void kvm_vgic_put(struct kvm_vcpu *vcpu);
+void kvm_vgic_vmcr_sync(struct kvm_vcpu *vcpu);
 
 #define irqchip_in_kernel(k)	(!!((k)->arch.vgic.in_kernel))
 #define vgic_initialized(k)	((k)->arch.vgic.initialized)

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index c36c86f1ec9a..46bbc949c20a 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -1,17 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2015, 2016 ARM Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 #ifndef __KVM_ARM_VGIC_H
 #define __KVM_ARM_VGIC_H

commit e08d8d296079e8fd7eefd53f73dcafebd3a5bf9f
Author: Julien Thierry <julien.thierry@arm.com>
Date:   Mon Jan 7 15:06:17 2019 +0000

    KVM: arm/arm64: vgic: Make vgic_cpu->ap_list_lock a raw_spinlock
    
    vgic_cpu->ap_list_lock must always be taken with interrupts disabled as
    it is used in interrupt context.
    
    For configurations such as PREEMPT_RT_FULL, this means that it should
    be a raw_spinlock since RT spinlocks are interruptible.
    
    Signed-off-by: Julien Thierry <julien.thierry@arm.com>
    Acked-by: Christoffer Dall <christoffer.dall@arm.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 32954e115796..c36c86f1ec9a 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -307,7 +307,7 @@ struct vgic_cpu {
 	unsigned int used_lrs;
 	struct vgic_irq private_irqs[VGIC_NR_PRIVATE_IRQS];
 
-	spinlock_t ap_list_lock;	/* Protects the ap_list */
+	raw_spinlock_t ap_list_lock;	/* Protects the ap_list */
 
 	/*
 	 * List of IRQs that this VCPU should consider because they are either

commit fc3bc475231e12e9c0142f60100cf84d077c79e1
Author: Julien Thierry <julien.thierry@arm.com>
Date:   Mon Jan 7 15:06:16 2019 +0000

    KVM: arm/arm64: vgic: Make vgic_dist->lpi_list_lock a raw_spinlock
    
    vgic_dist->lpi_list_lock must always be taken with interrupts disabled as
    it is used in interrupt context.
    
    For configurations such as PREEMPT_RT_FULL, this means that it should
    be a raw_spinlock since RT spinlocks are interruptible.
    
    Signed-off-by: Julien Thierry <julien.thierry@arm.com>
    Acked-by: Christoffer Dall <christoffer.dall@arm.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index b5426052152e..32954e115796 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -256,7 +256,7 @@ struct vgic_dist {
 	u64			propbaser;
 
 	/* Protects the lpi_list and the count value below. */
-	spinlock_t		lpi_list_lock;
+	raw_spinlock_t		lpi_list_lock;
 	struct list_head	lpi_list_head;
 	int			lpi_list_count;
 

commit 8fa3adb8c6beee4af079ac90b9575ab92951de3f
Author: Julien Thierry <julien.thierry@arm.com>
Date:   Mon Jan 7 15:06:15 2019 +0000

    KVM: arm/arm64: vgic: Make vgic_irq->irq_lock a raw_spinlock
    
    vgic_irq->irq_lock must always be taken with interrupts disabled as
    it is used in interrupt context.
    
    For configurations such as PREEMPT_RT_FULL, this means that it should
    be a raw_spinlock since RT spinlocks are interruptible.
    
    Signed-off-by: Julien Thierry <julien.thierry@arm.com>
    Acked-by: Christoffer Dall <christoffer.dall@arm.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 4f31f96bbfab..b5426052152e 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -100,7 +100,7 @@ enum vgic_irq_config {
 };
 
 struct vgic_irq {
-	spinlock_t irq_lock;		/* Protects the content of the struct */
+	raw_spinlock_t irq_lock;	/* Protects the content of the struct */
 	struct list_head lpi_list;	/* Used to link all LPIs together */
 	struct list_head ap_list;
 

commit 6249f2a479268702f7259aeee3671db2be3b922c
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Aug 6 12:51:19 2018 +0100

    KVM: arm/arm64: vgic-v3: Add core support for Group0 SGIs
    
    Although vgic-v3 now supports Group0 interrupts, it still doesn't
    deal with Group0 SGIs. As usually with the GIC, nothing is simple:
    
    - ICC_SGI1R can signal SGIs of both groups, since GICD_CTLR.DS==1
      with KVM (as per 8.1.10, Non-secure EL1 access)
    
    - ICC_SGI0R can only generate Group0 SGIs
    
    - ICC_ASGI1R sees its scope refocussed to generate only Group0
      SGIs (as per the note at the bottom of Table 8-14)
    
    We only support Group1 SGIs so far, so no material change.
    
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index c134790be32c..4f31f96bbfab 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -373,7 +373,7 @@ void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu);
 void kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu);
 void kvm_vgic_reset_mapped_irq(struct kvm_vcpu *vcpu, u32 vintid);
 
-void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg);
+void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg, bool allow_group1);
 
 /**
  * kvm_vgic_get_max_vcpus - Get the maximum number of VCPUs allowed by HW

commit 32f8777ed92d73e504840a955a9dc92617826b69
Author: Christoffer Dall <christoffer.dall@arm.com>
Date:   Mon Jul 16 15:06:26 2018 +0200

    KVM: arm/arm64: vgic: Let userspace opt-in to writable v2 IGROUPR
    
    Simply letting IGROUPR be writable from userspace would break
    migration from old kernels to newer kernels, because old kernels
    incorrectly report interrupt groups as group 1.  This would not be a big
    problem if userspace wrote GICD_IIDR as read from the kernel, because we
    could detect the incompatibility and return an error to userspace.
    Unfortunately, this is not the case with current userspace
    implementations and simply letting IGROUPR be writable from userspace for
    an emulated GICv2 silently breaks migration and causes the destination
    VM to no longer run after migration.
    
    We now encourage userspace to write the read and expected value of
    GICD_IIDR as the first part of a GIC register restore, and if we observe
    a write to GICD_IIDR we know that userspace has been updated and has had
    a chance to cope with older kernels (VGICv2 IIDR.Revision == 0)
    incorrectly reporting interrupts as group 1, and therefore we now allow
    groups to be user writable.
    
    Reviewed-by: Andrew Jones <drjones@redhat.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index c661d0ee6628..c134790be32c 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -221,6 +221,9 @@ struct vgic_dist {
 	/* Implementation revision as reported in the GICD_IIDR */
 	u32			implementation_rev;
 
+	/* Userspace can write to GICv2 IGROUPR */
+	bool			v2_groups_user_writable;
+
 	/* Do injected MSIs require an additional device ID? */
 	bool			msis_require_devid;
 

commit 8df3c8f33f46adbaa811c0d57fb1d7eb421b88a9
Author: Christoffer Dall <christoffer.dall@arm.com>
Date:   Mon Jul 16 15:06:21 2018 +0200

    KVM: arm/arm64: vgic: Add group field to struct irq
    
    In preparation for proper group 0 and group 1 support in the vgic, we
    add a field in the struct irq to store the group of all interrupts.
    
    We initialize the group to group 0 when emulating GICv2 and to group 1
    when emulating GICv3, just like we treat them today.  LPIs are always
    group 1.  We also continue to ignore writes from the guest, preserving
    existing functionality, for now.
    
    Finally, we also add this field to the vgic debug logic to show the
    group for all interrupts.
    
    Reviewed-by: Andrew Jones <drjones@redhat.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 7e64c463ab4d..c661d0ee6628 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -133,6 +133,7 @@ struct vgic_irq {
 	u8 source;			/* GICv2 SGIs only */
 	u8 active_source;		/* GICv2 SGIs only */
 	u8 priority;
+	u8 group;			/* 0 == group 0, 1 == group 1 */
 	enum vgic_irq_config config;	/* Level or edge */
 
 	/*

commit aa075b0f30b53e397fd4d4162ebf4a3a236b9206
Author: Christoffer Dall <christoffer.dall@arm.com>
Date:   Mon Jul 16 15:06:19 2018 +0200

    KVM: arm/arm64: vgic: Keep track of implementation revision
    
    As we are about to tweak implementation aspects of the VGIC emulation,
    while still preserving some level of backwards compatibility support,
    add a field to keep track of the implementation revision field which is
    reported to the VM and to userspace.
    
    Reviewed-by: Andrew Jones <drjones@redhat.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index cfdd2484cc42..7e64c463ab4d 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -217,6 +217,9 @@ struct vgic_dist {
 	/* vGIC model the kernel emulates for the guest (GICv2 or GICv3) */
 	u32			vgic_model;
 
+	/* Implementation revision as reported in the GICD_IIDR */
+	u32			implementation_rev;
+
 	/* Do injected MSIs require an additional device ID? */
 	bool			msis_require_devid;
 

commit e25028c8ded011d19f9a11164807507c94febc01
Author: Eric Auger <eric.auger@redhat.com>
Date:   Tue May 22 09:55:18 2018 +0200

    KVM: arm/arm64: Bump VGIC_V3_MAX_CPUS to 512
    
    Let's raise the number of supported vcpus along with
    vgic v3 now that HW is looming with more physical CPUs.
    
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Acked-by: Christoffer Dall <christoffer.dall@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 08ccbe37dcda..cfdd2484cc42 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -28,7 +28,7 @@
 
 #include <linux/irqchip/arm-gic-v4.h>
 
-#define VGIC_V3_MAX_CPUS	255
+#define VGIC_V3_MAX_CPUS	512
 #define VGIC_V2_MAX_CPUS	8
 #define VGIC_NR_IRQS_LEGACY     256
 #define VGIC_NR_SGIS		16

commit 5ec17fbac6713be82b90f54d5a31251803fd8de5
Author: Eric Auger <eric.auger@redhat.com>
Date:   Tue May 22 09:55:13 2018 +0200

    KVM: arm/arm64: Remove kvm_vgic_vcpu_early_init
    
    kvm_vgic_vcpu_early_init gets called after kvm_vgic_cpu_init which
    is confusing. The call path is as follows:
    kvm_vm_ioctl_create_vcpu
    |_ kvm_arch_cpu_create
       |_ kvm_vcpu_init
          |_ kvm_arch_vcpu_init
             |_ kvm_vgic_vcpu_init
    |_ kvm_arch_vcpu_postcreate
       |_ kvm_vgic_vcpu_early_init
    
    Static initialization currently done in kvm_vgic_vcpu_early_init()
    can be moved to kvm_vgic_vcpu_init(). So let's move the code and
    remove kvm_vgic_vcpu_early_init(). kvm_arch_vcpu_postcreate() does
    nothing.
    
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 90e489f685ae..08ccbe37dcda 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -338,7 +338,6 @@ void kvm_vgic_early_init(struct kvm *kvm);
 int kvm_vgic_vcpu_init(struct kvm_vcpu *vcpu);
 int kvm_vgic_create(struct kvm *kvm, u32 type);
 void kvm_vgic_destroy(struct kvm *kvm);
-void kvm_vgic_vcpu_early_init(struct kvm_vcpu *vcpu);
 void kvm_vgic_vcpu_destroy(struct kvm_vcpu *vcpu);
 int kvm_vgic_map_resources(struct kvm *kvm);
 int kvm_vgic_hyp_init(void);

commit dbd9733ab6742dfb7d4f6c49e7d412d4e792d8be
Author: Eric Auger <eric.auger@redhat.com>
Date:   Tue May 22 09:55:08 2018 +0200

    KVM: arm/arm64: Replace the single rdist region by a list
    
    At the moment KVM supports a single rdist region. We want to
    support several separate rdist regions so let's introduce a list
    of them. This patch currently only cares about a single
    entry in this list as the functionality to register several redist
    regions is not yet there. So this only translates the existing code
    into something functionally similar using that new data struct.
    
    The redistributor region handle is stored in the vgic_cpu structure
    to allow later computation of the TYPER last bit.
    
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index e7efe12a81bd..90e489f685ae 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -201,6 +201,14 @@ struct vgic_its {
 
 struct vgic_state_iter;
 
+struct vgic_redist_region {
+	u32 index;
+	gpa_t base;
+	u32 count; /* number of redistributors or 0 if single region */
+	u32 free_index; /* index of the next free redistributor */
+	struct list_head list;
+};
+
 struct vgic_dist {
 	bool			in_kernel;
 	bool			ready;
@@ -220,10 +228,7 @@ struct vgic_dist {
 		/* either a GICv2 CPU interface */
 		gpa_t			vgic_cpu_base;
 		/* or a number of GICv3 redistributor regions */
-		struct {
-			gpa_t		vgic_redist_base;
-			gpa_t		vgic_redist_free_offset;
-		};
+		struct list_head rd_regions;
 	};
 
 	/* distributor enabled */
@@ -311,6 +316,7 @@ struct vgic_cpu {
 	 */
 	struct vgic_io_device	rd_iodev;
 	struct vgic_io_device	sgi_iodev;
+	struct vgic_redist_region *rdreg;
 
 	/* Contains the attributes and gpa of the LPI pending tables. */
 	u64 pendbaser;

commit 53692908b0f594285aba18ab848318262332ed25
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed Apr 18 10:39:04 2018 +0100

    KVM: arm/arm64: vgic: Fix source vcpu issues for GICv2 SGI
    
    Now that we make sure we don't inject multiple instances of the
    same GICv2 SGI at the same time, we've made another bug more
    obvious:
    
    If we exit with an active SGI, we completely lose track of which
    vcpu it came from. On the next entry, we restore it with 0 as a
    source, and if that wasn't the right one, too bad. While this
    doesn't seem to trouble GIC-400, the architectural model gets
    offended and doesn't deactivate the interrupt on EOI.
    
    Another connected issue is that we will happilly make pending
    an interrupt from another vcpu, overriding the above zero with
    something that is just as inconsistent. Don't do that.
    
    The final issue is that we signal a maintenance interrupt when
    no pending interrupts are present in the LR. Assuming we've fixed
    the two issues above, we end-up in a situation where we keep
    exiting as soon as we've reached the active state, and not be
    able to inject the following pending.
    
    The fix comes in 3 parts:
    - GICv2 SGIs have their source vcpu saved if they are active on
      exit, and restored on entry
    - Multi-SGIs cannot go via the Pending+Active state, as this would
      corrupt the source field
    - Multi-SGIs are converted to using MI on EOI instead of NPIE
    
    Fixes: 16ca6a607d84bef0 ("KVM: arm/arm64: vgic: Don't populate multiple LRs with the same vintid")
    Reported-by: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Mark Rutland <mark.rutland@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 24f03941ada8..e7efe12a81bd 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -131,6 +131,7 @@ struct vgic_irq {
 		u32 mpidr;			/* GICv3 target VCPU */
 	};
 	u8 source;			/* GICv2 SGIs only */
+	u8 active_source;		/* GICv2 SGIs only */
 	u8 priority;
 	enum vgic_irq_config config;	/* Level or edge */
 

commit 5fbb0df6f68e31a586b947433e93ba9654c8080f
Merge: 4b472ffd1513 27e91ad1e746
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Mar 19 17:43:01 2018 +0000

    Merge tag 'kvm-arm-fixes-for-v4.16-2' into HEAD
    
    Resolve conflicts with current mainline

commit 1bb32a44aea1fe73c6f84e466a45ae559ef74559
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Dec 4 16:43:23 2017 +0000

    KVM: arm/arm64: Keep GICv2 HYP VAs in kvm_vgic_global_state
    
    As we're about to change the way we map devices at HYP, we need
    to move away from kern_hyp_va on an IO address.
    
    One way of achieving this is to store the VAs in kvm_vgic_global_state,
    and use that directly from the HYP code. This requires a small change
    to create_hyp_io_mappings so that it can also return a HYP VA.
    
    We take this opportunity to nuke the vctrl_base field in the emulated
    distributor, as it is not used anymore.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index ac98ae46bfb7..87d2ad0a4292 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -57,11 +57,15 @@ struct vgic_global {
 	/* Physical address of vgic virtual cpu interface */
 	phys_addr_t		vcpu_base;
 
-	/* GICV mapping */
+	/* GICV mapping, kernel VA */
 	void __iomem		*vcpu_base_va;
+	/* GICV mapping, HYP VA */
+	void __iomem		*vcpu_hyp_va;
 
-	/* virtual control interface mapping */
+	/* virtual control interface mapping, kernel VA */
 	void __iomem		*vctrl_base;
+	/* virtual control interface mapping, HYP VA */
+	void __iomem		*vctrl_hyp;
 
 	/* Number of implemented list registers */
 	int			nr_lr;
@@ -209,10 +213,6 @@ struct vgic_dist {
 
 	int			nr_spis;
 
-	/* TODO: Consider moving to global state */
-	/* Virtual control interface mapping */
-	void __iomem		*vctrl_base;
-
 	/* base addresses in guest physical address space: */
 	gpa_t			vgic_dist_base;		/* distributor */
 	union {

commit bb5ed7035918d265189e2623d71c8f458713d3e9
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Thu Oct 5 00:02:41 2017 +0200

    KVM: arm/arm64: Get rid of vgic_elrsr
    
    There is really no need to store the vgic_elrsr on the VGIC data
    structures as the only need we have for the elrsr is to figure out if an
    LR is inactive when we save the VGIC state upon returning from the
    guest.  We can might as well store this in a temporary local variable.
    
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index cdbd142ca7f2..ac98ae46bfb7 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -263,7 +263,6 @@ struct vgic_dist {
 struct vgic_v2_cpu_if {
 	u32		vgic_hcr;
 	u32		vgic_vmcr;
-	u64		vgic_elrsr;	/* Saved only */
 	u32		vgic_apr;
 	u32		vgic_lr[VGIC_V2_MAX_LRS];
 };
@@ -272,7 +271,6 @@ struct vgic_v3_cpu_if {
 	u32		vgic_hcr;
 	u32		vgic_vmcr;
 	u32		vgic_sre;	/* Restored only, change ignored */
-	u32		vgic_elrsr;	/* Saved only */
 	u32		vgic_ap0r[4];
 	u32		vgic_ap1r[4];
 	u64		vgic_lr[VGIC_V3_MAX_LRS];

commit 413aa807ae39fed7e387c175d2d0ae9fcf6c0c9d
Author: Christoffer Dall <cdall@kernel.org>
Date:   Mon Mar 5 11:36:38 2018 +0100

    KVM: arm/arm64: Reset mapped IRQs on VM reset
    
    We currently don't allow resetting mapped IRQs from userspace, because
    their state is controlled by the hardware.  But we do need to reset the
    state when the VM is reset, so we provide a function for the 'owner' of
    the mapped interrupt to reset the interrupt state.
    
    Currently only the timer uses mapped interrupts, so we call this
    function from the timer reset logic.
    
    Cc: stable@vger.kernel.org
    Fixes: 4c60e360d6df ("KVM: arm/arm64: Provide a get_input_level for the arch timer")
    Signed-off-by: Christoffer Dall <cdall@kernel.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index cdbd142ca7f2..02924ae2527e 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -360,6 +360,7 @@ void kvm_vgic_put(struct kvm_vcpu *vcpu);
 bool kvm_vcpu_has_pending_irqs(struct kvm_vcpu *vcpu);
 void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu);
 void kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu);
+void kvm_vgic_reset_mapped_irq(struct kvm_vcpu *vcpu, u32 vintid);
 
 void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg);
 

commit b6909a659f8d5de2df36cabb1c0505d262996a24
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Fri Oct 27 19:30:09 2017 +0200

    KVM: arm/arm64: Support a vgic interrupt line level sample function
    
    The GIC sometimes need to sample the physical line of a mapped
    interrupt.  As we know this to be notoriously slow, provide a callback
    function for devices (such as the timer) which can do this much faster
    than talking to the distributor, for example by comparing a few
    in-memory values.  Fall back to the good old method of poking the
    physical GIC if no callback is provided.
    
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 8c896540a72c..cdbd142ca7f2 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -130,6 +130,17 @@ struct vgic_irq {
 	u8 priority;
 	enum vgic_irq_config config;	/* Level or edge */
 
+	/*
+	 * Callback function pointer to in-kernel devices that can tell us the
+	 * state of the input level of mapped level-triggered IRQ faster than
+	 * peaking into the physical GIC.
+	 *
+	 * Always called in non-preemptible section and the functions can use
+	 * kvm_arm_get_running_vcpu() to get the vcpu pointer for private
+	 * IRQs.
+	 */
+	bool (*get_input_level)(int vintid);
+
 	void *owner;			/* Opaque pointer to reserve an interrupt
 					   for in-kernel devices. */
 };
@@ -331,7 +342,7 @@ void kvm_vgic_init_cpu_hardware(void);
 int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int intid,
 			bool level, void *owner);
 int kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu, unsigned int host_irq,
-			  u32 vintid);
+			  u32 vintid, bool (*get_input_level)(int vindid));
 int kvm_vgic_unmap_phys_irq(struct kvm_vcpu *vcpu, unsigned int vintid);
 bool kvm_vgic_map_is_active(struct kvm_vcpu *vcpu, unsigned int vintid);
 

commit df9ba95993b9d59e077aa4613f7a4edd20a4064c
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Oct 27 15:28:49 2017 +0100

    KVM: arm/arm64: GICv4: Use the doorbell interrupt as an unblocking source
    
    The doorbell interrupt is only useful if the vcpu is blocked on WFI.
    In all other cases, recieving a doorbell interrupt is just a waste
    of cycles.
    
    So let's only enable the doorbell if a vcpu is getting blocked,
    and disable it when it is unblocked. This is very similar to
    what we're doing for the background timer.
    
    Reviewed-by: Christoffer Dall <cdall@linaro.org>
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 2f750c770bf2..8c896540a72c 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -381,4 +381,7 @@ int kvm_vgic_v4_set_forwarding(struct kvm *kvm, int irq,
 int kvm_vgic_v4_unset_forwarding(struct kvm *kvm, int irq,
 				 struct kvm_kernel_irq_routing_entry *irq_entry);
 
+void kvm_vgic_v4_enable_doorbell(struct kvm_vcpu *vcpu);
+void kvm_vgic_v4_disable_doorbell(struct kvm_vcpu *vcpu);
+
 #endif /* __KVM_ARM_VGIC_H */

commit 196b136498b35f1cd787b84465f235e69dbc757c
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Oct 27 15:28:39 2017 +0100

    KVM: arm/arm64: GICv4: Wire mapping/unmapping of VLPIs in VFIO irq bypass
    
    Let's use the irq bypass mechanism also used for x86 posted interrupts
    to intercept the virtual PCIe endpoint configuration and establish our
    LPI->VLPI mapping.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 7eeb6c2a2f9c..2f750c770bf2 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -373,4 +373,12 @@ int kvm_vgic_setup_default_irq_routing(struct kvm *kvm);
 
 int kvm_vgic_set_owner(struct kvm_vcpu *vcpu, unsigned int intid, void *owner);
 
+struct kvm_kernel_irq_routing_entry;
+
+int kvm_vgic_v4_set_forwarding(struct kvm *kvm, int irq,
+			       struct kvm_kernel_irq_routing_entry *irq_entry);
+
+int kvm_vgic_v4_unset_forwarding(struct kvm *kvm, int irq,
+				 struct kvm_kernel_irq_routing_entry *irq_entry);
+
 #endif /* __KVM_ARM_VGIC_H */

commit 74fe55dc9ab77142e3c4783ecc5b87d494164452
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Oct 27 15:28:38 2017 +0100

    KVM: arm/arm64: GICv4: Add init/teardown of the per-VM vPE irq domain
    
    In order to control the GICv4 view of virtual CPUs, we rely
    on an irqdomain allocated for that purpose. Let's add a couple
    of helpers to that effect.
    
    At the same time, the vgic data structures gain new fields to
    track all this... erm... wonderful stuff.
    
    The way we hook into the vgic init is slightly convoluted. We
    need the vgic to be initialized (in order to guarantee that
    the number of vcpus is now fixed), and we must have a vITS
    (otherwise this is all very pointless). So we end-up calling
    the init from both vgic_init and vgic_its_create.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index ba9fb450aa1b..7eeb6c2a2f9c 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -26,6 +26,8 @@
 #include <linux/list.h>
 #include <linux/jump_label.h>
 
+#include <linux/irqchip/arm-gic-v4.h>
+
 #define VGIC_V3_MAX_CPUS	255
 #define VGIC_V2_MAX_CPUS	8
 #define VGIC_NR_IRQS_LEGACY     256
@@ -236,6 +238,15 @@ struct vgic_dist {
 
 	/* used by vgic-debug */
 	struct vgic_state_iter *iter;
+
+	/*
+	 * GICv4 ITS per-VM data, containing the IRQ domain, the VPE
+	 * array, the property table pointer as well as allocation
+	 * data. This essentially ties the Linux IRQ core and ITS
+	 * together, and avoids leaking KVM's data structures anywhere
+	 * else.
+	 */
+	struct its_vm		its_vm;
 };
 
 struct vgic_v2_cpu_if {
@@ -254,6 +265,14 @@ struct vgic_v3_cpu_if {
 	u32		vgic_ap0r[4];
 	u32		vgic_ap1r[4];
 	u64		vgic_lr[VGIC_V3_MAX_LRS];
+
+	/*
+	 * GICv4 ITS per-VPE data, containing the doorbell IRQ, the
+	 * pending table pointer, the its_vm pointer and a few other
+	 * HW specific things. As for the its_vm structure, this is
+	 * linking the Linux IRQ subsystem and the ITS together.
+	 */
+	struct its_vpe	its_vpe;
 };
 
 struct vgic_cpu {

commit e7c48059248e013772d8da69351ac8b262d8fce2
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Oct 27 15:28:37 2017 +0100

    KVM: arm/arm64: GICv4: Add property field and per-VM predicate
    
    Add a new has_gicv4 field in the global VGIC state that indicates
    whether the HW is GICv4 capable, as a per-VM predicate indicating
    if there is a possibility for a VM to support direct injection
    (the above being true and the VM having an ITS).
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 53f631bdec75..ba9fb450aa1b 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -73,6 +73,9 @@ struct vgic_global {
 	/* Only needed for the legacy KVM_CREATE_IRQCHIP */
 	bool			can_emulate_gicv2;
 
+	/* Hardware has GICv4? */
+	bool			has_gicv4;
+
 	/* GIC system register CPU interface */
 	struct static_key_false gicv3_cpuif;
 

commit 47bbd31f740c4e693d01766f367ad3366fb49a6d
Author: Eric Auger <eric.auger@redhat.com>
Date:   Fri Oct 27 15:28:32 2017 +0100

    KVM: arm/arm64: vgic: restructure kvm_vgic_(un)map_phys_irq
    
    We want to reuse the core of the map/unmap functions for IRQ
    forwarding. Let's move the computation of the hwirq in
    kvm_vgic_map_phys_irq and pass the linux IRQ as parameter.
    the host_irq is added to struct vgic_irq.
    
    We introduce kvm_vgic_map/unmap_irq which take a struct vgic_irq
    handle as a parameter.
    
    Acked-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 34dba516ef24..53f631bdec75 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -116,6 +116,7 @@ struct vgic_irq {
 	bool hw;			/* Tied to HW IRQ */
 	struct kref refcount;		/* Used for LPIs */
 	u32 hwintid;			/* HW INTID number */
+	unsigned int host_irq;		/* linux irq corresponding to hwintid */
 	union {
 		u8 targets;			/* GICv2 target VCPUs mask */
 		u32 mpidr;			/* GICv3 target VCPU */
@@ -307,9 +308,10 @@ void kvm_vgic_init_cpu_hardware(void);
 
 int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int intid,
 			bool level, void *owner);
-int kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu, u32 virt_irq, u32 phys_irq);
-int kvm_vgic_unmap_phys_irq(struct kvm_vcpu *vcpu, unsigned int virt_irq);
-bool kvm_vgic_map_is_active(struct kvm_vcpu *vcpu, unsigned int virt_irq);
+int kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu, unsigned int host_irq,
+			  u32 vintid);
+int kvm_vgic_unmap_phys_irq(struct kvm_vcpu *vcpu, unsigned int vintid);
+bool kvm_vgic_map_is_active(struct kvm_vcpu *vcpu, unsigned int vintid);
 
 int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
 

commit 59da1cbfd840d69bd7a310249924da3fc202c417
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Jun 9 12:49:33 2017 +0100

    KVM: arm64: vgic-v3: Add hook to handle guest GICv3 sysreg accesses at EL2
    
    In order to start handling guest access to GICv3 system registers,
    let's add a hook that will get called when we trap a system register
    access. This is gated by a new static key (vgic_v3_cpuif_trap).
    
    Tested-by: Alexander Graf <agraf@suse.de>
    Acked-by: David Daney <david.daney@cavium.com>
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Reviewed-by: Christoffer Dall <cdall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <cdall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 2d923a6b2175..34dba516ef24 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -292,6 +292,7 @@ struct vgic_cpu {
 };
 
 extern struct static_key_false vgic_v2_cpuif_trap;
+extern struct static_key_false vgic_v3_cpuif_trap;
 
 int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr, bool write);
 void kvm_vgic_early_init(struct kvm *kvm);

commit 6f2f10cabe73944488a62df16695c86e20d4c3f9
Merge: ebb127f2d6f3 33b5c38852b2
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu Jun 15 09:35:15 2017 +0100

    Merge branch 'kvmarm-master/master' into HEAD

commit ebb127f2d6f32665643165289151bd20929d9931
Author: Christoffer Dall <cdall@linaro.org>
Date:   Tue May 16 19:53:50 2017 +0200

    KVM: arm/arm64: Don't assume initialized vgic when setting PMU IRQ
    
    The PMU IRQ number is set through the VCPU device's KVM_SET_DEVICE_ATTR
    ioctl handler for the KVM_ARM_VCPU_PMU_V3_IRQ attribute, but there is no
    enforced or stated requirement that this must happen after initializing
    the VGIC.  As a result, calling vgic_valid_spi() which relies on the
    nr_spis being set during the VGIC init can incorrectly fail.
    
    Introduce irq_is_spi, which determines if an IRQ number is within the
    SPI range without verifying it against the actual VGIC properties.
    
    Signed-off-by: Christoffer Dall <cdall@linaro.org>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 131668f8599c..a2ae9d2de21f 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -39,6 +39,8 @@
 #define KVM_IRQCHIP_NUM_PINS	(1020 - 32)
 
 #define irq_is_ppi(irq) ((irq) >= VGIC_NR_SGIS && (irq) < VGIC_NR_PRIVATE_IRQS)
+#define irq_is_spi(irq) ((irq) >= VGIC_NR_PRIVATE_IRQS && \
+			 (irq) <= VGIC_MAX_SPI)
 
 enum vgic_type {
 	VGIC_V2,		/* Good ol' GICv2 */

commit cb3f0ad881a6cee39c6a652b4aa4f12f341d98f0
Author: Christoffer Dall <cdall@linaro.org>
Date:   Tue May 16 12:41:18 2017 +0200

    KVM: arm/arm64: Disallow userspace control of in-kernel IRQ lines
    
    When injecting an IRQ to the VGIC, you now have to present an owner
    token for that IRQ line to show that you are the owner of that line.
    
    IRQ lines driven from userspace or via an irqfd do not have an owner and
    will simply pass a NULL pointer.
    
    Also get rid of the unused kvm_vgic_inject_mapped_irq prototype.
    
    Signed-off-by: Christoffer Dall <cdall@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 5d5b34534ce9..131668f8599c 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -300,9 +300,7 @@ int kvm_vgic_hyp_init(void);
 void kvm_vgic_init_cpu_hardware(void);
 
 int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int intid,
-			bool level);
-int kvm_vgic_inject_mapped_irq(struct kvm *kvm, int cpuid, unsigned int intid,
-			       bool level);
+			bool level, void *owner);
 int kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu, u32 virt_irq, u32 phys_irq);
 int kvm_vgic_unmap_phys_irq(struct kvm_vcpu *vcpu, unsigned int virt_irq);
 bool kvm_vgic_map_is_active(struct kvm_vcpu *vcpu, unsigned int virt_irq);

commit c6ccd30e0de384f506449474ca780ff680ad4217
Author: Christoffer Dall <cdall@linaro.org>
Date:   Thu May 4 13:24:20 2017 +0200

    KVM: arm/arm64: Introduce an allocator for in-kernel irq lines
    
    Having multiple devices being able to signal the same interrupt line is
    very confusing and almost certainly guarantees a configuration error.
    
    Therefore, introduce a very simple allocator which allows a device to
    claim an interrupt line from the vgic for a given VM.
    
    Signed-off-by: Christoffer Dall <cdall@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index dde59fbc5f80..5d5b34534ce9 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -121,6 +121,9 @@ struct vgic_irq {
 	u8 source;			/* GICv2 SGIs only */
 	u8 priority;
 	enum vgic_irq_config config;	/* Level or edge */
+
+	void *owner;			/* Opaque pointer to reserve an interrupt
+					   for in-kernel devices. */
 };
 
 struct vgic_register_region;
@@ -340,4 +343,6 @@ int kvm_send_userspace_msi(struct kvm *kvm, struct kvm_msi *msi);
  */
 int kvm_vgic_setup_default_irq_routing(struct kvm *kvm);
 
+int kvm_vgic_set_owner(struct kvm_vcpu *vcpu, unsigned int intid, void *owner);
+
 #endif /* __KVM_ARM_VGIC_H */

commit 3cba4af31c61fc9420fdcf083f509a6c20a6d8e5
Author: Christoffer Dall <cdall@linaro.org>
Date:   Tue May 2 20:11:49 2017 +0200

    KVM: arm/arm64: Move irq_is_ppi() to header file
    
    We are about to need this define in the arch timer code as well so move
    it to a common location.
    
    Signed-off-by: Christoffer Dall <cdall@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 97b8d3728b31..dde59fbc5f80 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -38,6 +38,8 @@
 #define VGIC_MIN_LPI		8192
 #define KVM_IRQCHIP_NUM_PINS	(1020 - 32)
 
+#define irq_is_ppi(irq) ((irq) >= VGIC_NR_SGIS && (irq) < VGIC_NR_PRIVATE_IRQS)
+
 enum vgic_type {
 	VGIC_V2,		/* Good ol' GICv2 */
 	VGIC_V3,		/* New fancy GICv3 */

commit 552c9f47f8d451830a6b47151c6d2db77f77cc3e
Author: Christoffer Dall <cdall@linaro.org>
Date:   Wed May 17 13:12:51 2017 +0200

    KVM: arm/arm64: Fix bug when registering redist iodevs
    
    If userspace creates the VCPUs after initializing the VGIC, then we end
    up in a situation where we trigger a bug in kvm_vcpu_get_idx(), because
    it is called prior to adding the VCPU into the vcpus array on the VM.
    
    There is no tight coupling between the VCPU index and the area of the
    redistributor region used for the VCPU, so we can simply ensure that all
    creations of redistributors are serialized per VM, and increment an
    offset when we successfully add a redistributor.
    
    The vgic_register_redist_iodev() function can be called from two paths:
    vgic_redister_all_redist_iodev() which is called via the kvm_vgic_addr()
    device attribute handler.  This patch already holds the kvm->lock mutex.
    
    The other path is via kvm_vgic_vcpu_init, which is called through a
    longer chain from kvm_vm_ioctl_create_vcpu(), which releases the
    kvm->lock mutex just before calling kvm_arch_vcpu_create(), so we can
    simply take this mutex again later for our purposes.
    
    Fixes: ab6f468c10 ("KVM: arm/arm64: Register iodevs when setting redist base and creating VCPUs")
    Signed-off-by: Christoffer Dall <cdall@linaro.org>
    Tested-by: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
    Reviewed-by: Eric Auger <eric.auger@redhat.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 97b8d3728b31..ef718586321c 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -195,7 +195,10 @@ struct vgic_dist {
 		/* either a GICv2 CPU interface */
 		gpa_t			vgic_cpu_base;
 		/* or a number of GICv3 redistributor regions */
-		gpa_t			vgic_redist_base;
+		struct {
+			gpa_t		vgic_redist_base;
+			gpa_t		vgic_redist_free_offset;
+		};
 	};
 
 	/* distributor enabled */

commit 36c344f3f1ffc0b1b20abd237b7401dc6687ee8f
Merge: 03efce6f935f a2b19e6e2d4b
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Tue May 9 12:51:49 2017 +0200

    Merge tag 'kvm-arm-for-v4.12-round2' of git://git.kernel.org/pub/scm/linux/kernel/git/kvmarm/kvmarm into HEAD
    
    Second round of KVM/ARM Changes for v4.12.
    
    Changes include:
     - A fix related to the 32-bit idmap stub
     - A fix to the bitmask used to deode the operands of an AArch32 CP
       instruction
     - We have moved the files shared between arch/arm/kvm and
       arch/arm64/kvm to virt/kvm/arm
     - We add support for saving/restoring the virtual ITS state to
       userspace

commit 6cc40f273b30ef8f7b37f95cd2e6456d652808c0
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon May 8 18:15:40 2017 +0100

    KVM: arm/arm64: Get rid of its->initialized field
    
    The its->initialized doesn't bring much to the table, and creates
    unnecessary ordering between setting the address and initializing it
    (which amounts to exactly nothing).
    
    Let's kill it altogether, making KVM_DEV_ARM_VGIC_CTRL_INIT the no-op
    it deserves to be.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <cdall@linaro.org>
    Reviewed-by: Eric Auger <eric.auger@redhat.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 4ff65efcfebd..bfde6fb78e8a 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -148,7 +148,6 @@ struct vgic_its {
 	gpa_t			vgic_its_base;
 
 	bool			enabled;
-	bool			initialized;
 	struct vgic_io_device	iodev;
 	struct kvm_device	*dev;
 

commit 1aab6f468c10a1ec3977fb6f7bc12869174d516e
Author: Christoffer Dall <cdall@linaro.org>
Date:   Mon May 8 12:30:24 2017 +0200

    KVM: arm/arm64: Register iodevs when setting redist base and creating VCPUs
    
    Instead of waiting with registering KVM iodevs until the first VCPU is
    run, we can actually create the iodevs when the redist base address is
    set.  The only downside is that we must now also check if we need to do
    this for VCPUs which are created after creating the VGIC, because there
    is no enforced ordering between creating the VGIC (and setting its base
    addresses) and creating the VCPUs.
    
    Signed-off-by: Christoffer Dall <cdall@linaro.org>
    Reviewed-by: Eric Auger <eric.auger@redhat.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index fabcc649e2ce..4ff65efcfebd 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -286,6 +286,7 @@ extern struct static_key_false vgic_v2_cpuif_trap;
 
 int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr, bool write);
 void kvm_vgic_early_init(struct kvm *kvm);
+int kvm_vgic_vcpu_init(struct kvm_vcpu *vcpu);
 int kvm_vgic_create(struct kvm *kvm, u32 type);
 void kvm_vgic_destroy(struct kvm *kvm);
 void kvm_vgic_vcpu_early_init(struct kvm_vcpu *vcpu);

commit 2d3e4866dea96b0506395b47bfefb234f2088dac
Merge: 9c6ee01ed5bb 2e5b0bd9cc61
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 8 12:37:56 2017 -0700

    Merge tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm
    
    Pull KVM updates from Paolo Bonzini:
     "ARM:
       - HYP mode stub supports kexec/kdump on 32-bit
       - improved PMU support
       - virtual interrupt controller performance improvements
       - support for userspace virtual interrupt controller (slower, but
         necessary for KVM on the weird Broadcom SoCs used by the Raspberry
         Pi 3)
    
      MIPS:
       - basic support for hardware virtualization (ImgTec P5600/P6600/I6400
         and Cavium Octeon III)
    
      PPC:
       - in-kernel acceleration for VFIO
    
      s390:
       - support for guests without storage keys
       - adapter interruption suppression
    
      x86:
       - usual range of nVMX improvements, notably nested EPT support for
         accessed and dirty bits
       - emulation of CPL3 CPUID faulting
    
      generic:
       - first part of VCPU thread request API
       - kvm_stat improvements"
    
    * tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm: (227 commits)
      kvm: nVMX: Don't validate disabled secondary controls
      KVM: put back #ifndef CONFIG_S390 around kvm_vcpu_kick
      Revert "KVM: Support vCPU-based gfn->hva cache"
      tools/kvm: fix top level makefile
      KVM: x86: don't hold kvm->lock in KVM_SET_GSI_ROUTING
      KVM: Documentation: remove VM mmap documentation
      kvm: nVMX: Remove superfluous VMX instruction fault checks
      KVM: x86: fix emulation of RSM and IRET instructions
      KVM: mark requests that need synchronization
      KVM: return if kvm_vcpu_wake_up() did wake up the VCPU
      KVM: add explicit barrier to kvm_vcpu_kick
      KVM: perform a wake_up in kvm_make_all_cpus_request
      KVM: mark requests that do not need a wakeup
      KVM: remove #ifndef CONFIG_S390 around kvm_vcpu_wake_up
      KVM: x86: always use kvm_make_request instead of set_bit
      KVM: add kvm_{test,clear}_request to replace {test,clear}_bit
      s390: kvm: Cpu model support for msa6, msa7 and msa8
      KVM: x86: remove irq disablement around KVM_SET_CLOCK/KVM_GET_CLOCK
      kvm: better MWAIT emulation for guests
      KVM: x86: virtualize cpuid faulting
      ...

commit 71afe470e20db133b30730cfa856e5d6854312e9
Author: Eric Auger <eric.auger@redhat.com>
Date:   Thu Apr 13 09:06:20 2017 +0200

    KVM: arm64: vgic-its: Introduce migration ABI infrastructure
    
    We plan to support different migration ABIs, ie. characterizing
    the ITS table layout format in guest RAM. For example, a new ABI
    will be needed if vLPIs get supported for nested use case.
    
    So let's introduce an array of supported ABIs (at the moment a single
    ABI is supported though). The following characteristics are foreseen
    to vary with the ABI: size of table entries, save/restore operation,
    the way abi settings are applied.
    
    By default the MAX_ABI_REV is applied on its creation. In subsequent
    patches we will introduce a way for the userspace to change the ABI
    in use.
    
    The entry sizes now are set according to the ABI version and not
    hardcoded anymore.
    
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Reviewed-by: Christoffer Dall <cdall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 26ed4fb896bb..fabcc649e2ce 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -162,6 +162,9 @@ struct vgic_its {
 	u32			creadr;
 	u32			cwriter;
 
+	/* migration ABI revision in use */
+	u32			abi_rev;
+
 	/* Protects the device and collection lists */
 	struct mutex		its_lock;
 	struct list_head	device_list;

commit 096f31c4360f6bab130e3f68513719ec6890128c
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Thu Dec 29 15:57:31 2016 +0100

    KVM: arm/arm64: vgic: Get rid of MISR and EISR fields
    
    We don't use these fields anymore so let's nuke them completely.
    
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index ea940dbb5dba..26ed4fb896bb 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -225,8 +225,6 @@ struct vgic_dist {
 struct vgic_v2_cpu_if {
 	u32		vgic_hcr;
 	u32		vgic_vmcr;
-	u32		vgic_misr;	/* Saved only */
-	u64		vgic_eisr;	/* Saved only */
 	u64		vgic_elrsr;	/* Saved only */
 	u32		vgic_apr;
 	u32		vgic_lr[VGIC_V2_MAX_LRS];
@@ -236,8 +234,6 @@ struct vgic_v3_cpu_if {
 	u32		vgic_hcr;
 	u32		vgic_vmcr;
 	u32		vgic_sre;	/* Restored only, change ignored */
-	u32		vgic_misr;	/* Saved only */
-	u32		vgic_eisr;	/* Saved only */
 	u32		vgic_elrsr;	/* Saved only */
 	u32		vgic_ap0r[4];
 	u32		vgic_ap1r[4];

commit 00dafa0fcfe9fb1d863f08dc45d6f05ac9505d46
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Fri Dec 23 00:04:59 2016 +0100

    KVM: arm/arm64: vgic: Get rid of live_lrs
    
    There is no need to calculate and maintain live_lrs when we always
    populate the lowest numbered LRs first on every entry and clear all LRs
    on every exit.
    
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index f7a2e31eb4c1..ea940dbb5dba 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -264,8 +264,6 @@ struct vgic_cpu {
 	 */
 	struct list_head ap_list_head;
 
-	u64 live_lrs;
-
 	/*
 	 * Members below are used with GICv3 emulation only and represent
 	 * parts of the redistributor.

commit 328e566479449194979d64685ae6d74c989599bb
Author: Christoffer Dall <cdall@cs.columbia.edu>
Date:   Thu Mar 24 11:21:04 2016 +0100

    KVM: arm/arm64: vgic: Defer touching GICH_VMCR to vcpu_load/put
    
    We don't have to save/restore the VMCR on every entry to/from the guest,
    since on GICv2 we can access the control interface from EL1 and on VHE
    systems with GICv3 we can access the control interface from KVM running
    in EL2.
    
    GICv3 systems without VHE becomes the rare case, which has to
    save/restore the register on each round trip.
    
    Note that userspace accesses may see out-of-date values if the VCPU is
    running while accessing the VGIC state via the KVM device API, but this
    is already the case and it is up to userspace to quiesce the CPUs before
    reading the CPU registers from the GIC for an up-to-date view.
    
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <cdall@cs.columbia.edu>
    Signed-off-by: Christoffer Dall <cdall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index b72dd2ad5f44..f7a2e31eb4c1 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -306,6 +306,9 @@ bool kvm_vgic_map_is_active(struct kvm_vcpu *vcpu, unsigned int virt_irq);
 
 int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
 
+void kvm_vgic_load(struct kvm_vcpu *vcpu);
+void kvm_vgic_put(struct kvm_vcpu *vcpu);
+
 #define irqchip_in_kernel(k)	(!!((k)->arch.vgic.in_kernel))
 #define vgic_initialized(k)	((k)->arch.vgic.initialized)
 #define vgic_ready(k)		((k)->arch.vgic.ready)

commit 5b0d2cc2805897c14257f6dbb949639c499c3c25
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Sat Mar 18 13:56:56 2017 +0100

    KVM: arm64: Ensure LRs are clear when they should be
    
    We currently have some code to clear the list registers on GICv3, but we
    never call this code, because the caller got nuked when removing the old
    vgic.  We also used to have a similar GICv2 part, but that got lost in
    the process too.
    
    Let's reintroduce the logic for GICv2 and call the logic when we
    initialize the use of hypervisors on the CPU, for example when first
    loading KVM or when exiting a low power state.
    
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index b72dd2ad5f44..c0b3d999c266 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -295,6 +295,7 @@ void kvm_vgic_vcpu_early_init(struct kvm_vcpu *vcpu);
 void kvm_vgic_vcpu_destroy(struct kvm_vcpu *vcpu);
 int kvm_vgic_map_resources(struct kvm *kvm);
 int kvm_vgic_hyp_init(void);
+void kvm_vgic_init_cpu_hardware(void);
 
 int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int intid,
 			bool level);

commit d017d7b0bd7ab32644d35666a6c4412daa0b0a1d
Author: Vijaya Kumar K <Vijaya.Kumar@cavium.com>
Date:   Thu Jan 26 19:50:51 2017 +0530

    KVM: arm/arm64: vgic: Implement VGICv3 CPU interface access
    
    VGICv3 CPU interface registers are accessed using
    KVM_DEV_ARM_VGIC_CPU_SYSREGS ioctl. These registers are accessed
    as 64-bit. The cpu MPIDR value is passed along with register id.
    It is used to identify the cpu for registers access.
    
    The VM that supports SEIs expect it on destination machine to handle
    guest aborts and hence checked for ICC_CTLR_EL1.SEIS compatibility.
    Similarly, VM that supports Affinity Level 3 that is required for AArch64
    mode, is required to be supported on destination machine. Hence checked
    for ICC_CTLR_EL1.A3V compatibility.
    
    The arch/arm64/kvm/vgic-sys-reg-v3.c handles read and write of VGIC
    CPU registers for AArch64.
    
    For AArch32 mode, arch/arm/kvm/vgic-v3-coproc.c file is created but
    APIs are not implemented.
    
    Updated arch/arm/include/uapi/asm/kvm.h with new definitions
    required to compile for AArch32.
    
    The version of VGIC v3 specification is defined here
    Documentation/virtual/kvm/devices/arm-vgic-v3.txt
    
    Acked-by: Christoffer Dall <christoffer.dall@linaro.org>
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Pavel Fedin <p.fedin@samsung.com>
    Signed-off-by: Vijaya Kumar K <Vijaya.Kumar@cavium.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 0af1477cfe8d..b72dd2ad5f44 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -71,6 +71,8 @@ struct vgic_global {
 
 	/* GIC system register CPU interface */
 	struct static_key_false gicv3_cpuif;
+
+	u32			ich_vtr_el2;
 };
 
 extern struct vgic_global kvm_vgic_global_state;
@@ -275,6 +277,12 @@ struct vgic_cpu {
 	u64 pendbaser;
 
 	bool lpis_enabled;
+
+	/* Cache guest priority bits */
+	u32 num_pri_bits;
+
+	/* Cache guest interrupt ID bits */
+	u32 num_id_bits;
 };
 
 extern struct static_key_false vgic_v2_cpuif_trap;

commit 10f92c4c537794f4e2b5f545a8953790c5445d0f
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Tue Jan 17 23:09:13 2017 +0100

    KVM: arm/arm64: vgic: Add debugfs vgic-state file
    
    Add a file to debugfs to read the in-kernel state of the vgic.  We don't
    do any locking of the entire VGIC state while traversing all the IRQs,
    so if the VM is running the user/developer may not see a quiesced state,
    but should take care to pause the VM using facilities in user space for
    that purpose.
    
    We also don't support LPIs yet, but they can be added easily if needed.
    
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Tested-by: Eric Auger <eric.auger@redhat.com>
    Tested-by: Andre Przywara <andre.przywara@arm.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index da2ce086ce31..0af1477cfe8d 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -166,6 +166,8 @@ struct vgic_its {
 	struct list_head	collection_list;
 };
 
+struct vgic_state_iter;
+
 struct vgic_dist {
 	bool			in_kernel;
 	bool			ready;
@@ -213,6 +215,9 @@ struct vgic_dist {
 	spinlock_t		lpi_list_lock;
 	struct list_head	lpi_list_head;
 	int			lpi_list_count;
+
+	/* used by vgic-debug */
+	struct vgic_state_iter *iter;
 };
 
 struct vgic_v2_cpu_if {

commit 8694e4da66a636665f51b94a6a7a40c9fc0dc5ec
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Mon Jan 23 14:07:18 2017 +0100

    KVM: arm/arm64: Remove struct vgic_irq pending field
    
    One of the goals behind the VGIC redesign was to get rid of cached or
    intermediate state in the data structures, but we decided to allow
    ourselves to precompute the pending value of an IRQ based on the line
    level and pending latch state.  However, this has now become difficult
    to base proper GICv3 save/restore on, because there is a potential to
    modify the pending state without knowing if an interrupt is edge or
    level configured.
    
    See the following post and related message for more background:
    https://lists.cs.columbia.edu/pipermail/kvmarm/2017-January/023195.html
    
    This commit gets rid of the precomputed pending field in favor of a
    function that calculates the value when needed, irq_is_pending().
    
    The soft_pending field is renamed to pending_latch to represent that
    this latch is the equivalent hardware latch which gets manipulated by
    the input signal for edge-triggered interrupts and when writing to the
    SPENDR/CPENDR registers.
    
    After this commit save/restore code should be able to simply restore the
    pending_latch state, line_level state, and config state in any order and
    get the desired result.
    
    Reviewed-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Andre Przywara <andre.przywara@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 002f0922cd92..da2ce086ce31 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -101,9 +101,10 @@ struct vgic_irq {
 					 */
 
 	u32 intid;			/* Guest visible INTID */
-	bool pending;
 	bool line_level;		/* Level only */
-	bool soft_pending;		/* Level only */
+	bool pending_latch;		/* The pending latch state used to calculate
+					 * the pending state for both level
+					 * and edge triggered IRQs. */
 	bool active;			/* not used for LPIs */
 	bool enabled;
 	bool hw;			/* Tied to HW IRQ */

commit acda5430bee4621f218391d0bcfbe4412adb3554
Author: Vladimir Murzin <vladimir.murzin@arm.com>
Date:   Mon Sep 12 15:49:24 2016 +0100

    ARM: KVM: Support vgic-v3
    
    This patch allows to build and use vgic-v3 in 32-bit mode.
    
    Unfortunately, it can not be split in several steps without extra
    stubs to keep patches independent and bisectable.  For instance,
    virt/kvm/arm/vgic/vgic-v3.c uses function from vgic-v3-sr.c, handling
    access to GICv3 cpu interface from the guest requires vgic_v3.vgic_sre
    to be already defined.
    
    It is how support has been done:
    
    * handle SGI requests from the guest
    
    * report configured SRE on access to GICv3 cpu interface from the guest
    
    * required vgic-v3 macros are provided via uapi.h
    
    * static keys are used to select GIC backend
    
    * to make vgic-v3 build KVM_ARM_VGIC_V3 guard is removed along with
      the static inlines
    
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Vladimir Murzin <vladimir.murzin@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 8d22adcfe522..002f0922cd92 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -225,7 +225,6 @@ struct vgic_v2_cpu_if {
 };
 
 struct vgic_v3_cpu_if {
-#ifdef CONFIG_KVM_ARM_VGIC_V3
 	u32		vgic_hcr;
 	u32		vgic_vmcr;
 	u32		vgic_sre;	/* Restored only, change ignored */
@@ -235,7 +234,6 @@ struct vgic_v3_cpu_if {
 	u32		vgic_ap0r[4];
 	u32		vgic_ap1r[4];
 	u64		vgic_lr[VGIC_V3_MAX_LRS];
-#endif
 };
 
 struct vgic_cpu {
@@ -304,13 +302,7 @@ bool kvm_vcpu_has_pending_irqs(struct kvm_vcpu *vcpu);
 void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu);
 void kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu);
 
-#ifdef CONFIG_KVM_ARM_VGIC_V3
 void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg);
-#else
-static inline void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg)
-{
-}
-#endif
 
 /**
  * kvm_vgic_get_max_vcpus - Get the maximum number of VCPUs allowed by HW

commit 5a7a8426b2ac004b064e4106911769e0a55e7c4b
Author: Vladimir Murzin <vladimir.murzin@arm.com>
Date:   Mon Sep 12 15:49:15 2016 +0100

    arm64: KVM: Use static keys for selecting the GIC backend
    
    Currently GIC backend is selected via alternative framework and this
    is fine. We are going to introduce vgic-v3 to 32-bit world and there
    we don't have patching framework in hand, so we can either check
    support for GICv3 every time we need to choose which backend to use or
    try to optimise it by using static keys. The later looks quite
    promising because we can share logic involved in selecting GIC backend
    between architectures if both uses static keys.
    
    This patch moves arm64 from alternative to static keys framework for
    selecting GIC backend. For that we embed static key into vgic_global
    and enable the key during vgic initialisation based on what has
    already been exposed by the host GIC driver.
    
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Vladimir Murzin <vladimir.murzin@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index bb46c03eb3c7..8d22adcfe522 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -24,6 +24,7 @@
 #include <linux/types.h>
 #include <kvm/iodev.h>
 #include <linux/list.h>
+#include <linux/jump_label.h>
 
 #define VGIC_V3_MAX_CPUS	255
 #define VGIC_V2_MAX_CPUS	8
@@ -67,6 +68,9 @@ struct vgic_global {
 
 	/* Only needed for the legacy KVM_CREATE_IRQCHIP */
 	bool			can_emulate_gicv2;
+
+	/* GIC system register CPU interface */
+	struct static_key_false gicv3_cpuif;
 };
 
 extern struct vgic_global kvm_vgic_global_state;

commit bf8feb39642b4c71c644e2d534ce53029bd2219b
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Sep 6 09:28:46 2016 +0100

    arm64: KVM: vgic-v2: Add GICV access from HYP
    
    Now that we have the necessary infrastructure to handle MMIO accesses
    in HYP, perform the GICV access on behalf of the guest. This requires
    checking that the access is strictly 32bit, properly aligned, and
    falls within the expected range.
    
    When all condition are satisfied, we perform the access and tell
    the rest of the HYP code that the instruction has been correctly
    emulated.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 8eb1501fc1d0..bb46c03eb3c7 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -50,6 +50,9 @@ struct vgic_global {
 	/* Physical address of vgic virtual cpu interface */
 	phys_addr_t		vcpu_base;
 
+	/* GICV mapping */
+	void __iomem		*vcpu_base_va;
+
 	/* virtual control interface mapping */
 	void __iomem		*vctrl_base;
 

commit fb5ee369ccd3986b28adc20d43d73a2b2c141977
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Sep 6 09:28:45 2016 +0100

    arm64: KVM: vgic-v2: Add the GICV emulation infrastructure
    
    In order to efficiently perform the GICV access on behalf of the
    guest, we need to be able to avoid going back all the way to
    the host kernel.
    
    For this, we introduce a new hook in the world switch code,
    conveniently placed just after populating the fault info.
    At that point, we only have saved/restored the GP registers,
    and we can quickly perform all the required checks (data abort,
    translation fault, valid faulting syndrome, not an external
    abort, not a PTW).
    
    Coming back from the emulation code, we need to skip the emulated
    instruction. This involves an additional bit of save/restore in
    order to be able to access the guest's PC (and possibly CPSR if
    this is a 32bit guest).
    
    At this stage, no emulation code is provided.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 19b698ef3336..8eb1501fc1d0 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -20,6 +20,7 @@
 #include <linux/kvm.h>
 #include <linux/irqreturn.h>
 #include <linux/spinlock.h>
+#include <linux/static_key.h>
 #include <linux/types.h>
 #include <kvm/iodev.h>
 #include <linux/list.h>
@@ -265,6 +266,8 @@ struct vgic_cpu {
 	bool lpis_enabled;
 };
 
+extern struct static_key_false vgic_v2_cpuif_trap;
+
 int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr, bool write);
 void kvm_vgic_early_init(struct kvm *kvm);
 int kvm_vgic_create(struct kvm *kvm, u32 type);

commit 180ae7b1182344ca617d8b5200306b02a6b5075d
Author: Eric Auger <eric.auger@redhat.com>
Date:   Fri Jul 22 16:20:41 2016 +0000

    KVM: arm/arm64: Enable irqchip routing
    
    This patch adds compilation and link against irqchip.
    
    Main motivation behind using irqchip code is to enable MSI
    routing code. In the future irqchip routing may also be useful
    when targeting multiple irqchips.
    
    Routing standard callbacks now are implemented in vgic-irqfd:
    - kvm_set_routing_entry
    - kvm_set_irq
    - kvm_set_msi
    
    They only are supported with new_vgic code.
    
    Both HAVE_KVM_IRQCHIP and HAVE_KVM_IRQ_ROUTING are defined.
    KVM_CAP_IRQ_ROUTING is advertised and KVM_SET_GSI_ROUTING is allowed.
    
    So from now on IRQCHIP routing is enabled and a routing table entry
    must exist for irqfd injection to succeed for a given SPI. This patch
    builds a default flat irqchip routing table (gsi=irqchip.pin) covering
    all the VGIC SPI indexes. This routing table is overwritten by the
    first first user-space call to KVM_SET_GSI_ROUTING ioctl.
    
    MSI routing setup is not yet allowed.
    
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 540da5149ba7..19b698ef3336 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -34,6 +34,7 @@
 #define VGIC_MAX_SPI		1019
 #define VGIC_MAX_RESERVED	1023
 #define VGIC_MIN_LPI		8192
+#define KVM_IRQCHIP_NUM_PINS	(1020 - 32)
 
 enum vgic_type {
 	VGIC_V2,		/* Good ol' GICv2 */
@@ -314,4 +315,10 @@ static inline int kvm_vgic_get_max_vcpus(void)
 
 int kvm_send_userspace_msi(struct kvm *kvm, struct kvm_msi *msi);
 
+/**
+ * kvm_vgic_setup_default_irq_routing:
+ * Setup a default flat gsi routing table mapping all SPIs
+ */
+int kvm_vgic_setup_default_irq_routing(struct kvm *kvm);
+
 #endif /* __KVM_ARM_VGIC_H */

commit bb7176449f6da27534a0faf3a67997bf2c3172aa
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Sun Jul 17 21:35:07 2016 +0100

    KVM: arm64: vgic-its: Add pointer to corresponding kvm_device
    
    Going from the ITS structure to the corresponding KVM structure
    would be quite handy at times. The kvm_device pointer that is
    passed at create time is quite convenient for this, so let's
    keep a copy of it in the vgic_its structure.
    
    This will be put to a good use in subsequent patches.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 4e63a07b9001..540da5149ba7 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -138,6 +138,7 @@ struct vgic_its {
 	bool			enabled;
 	bool			initialized;
 	struct vgic_io_device	iodev;
+	struct kvm_device	*dev;
 
 	/* These registers correspond to GITS_BASER{0,1} */
 	u64			baser_device_table;

commit 0e4e82f154e387969ea7ecd2c8876689fb68f710
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Fri Jul 15 12:43:38 2016 +0100

    KVM: arm64: vgic-its: Enable ITS emulation as a virtual MSI controller
    
    Now that all ITS emulation functionality is in place, we advertise
    MSI functionality to userland and also the ITS device to the guest - if
    userland has configured that.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index a6ca326055cf..4e63a07b9001 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -163,6 +163,9 @@ struct vgic_dist {
 	/* vGIC model the kernel emulates for the guest (GICv2 or GICv3) */
 	u32			vgic_model;
 
+	/* Do injected MSIs require an additional device ID? */
+	bool			msis_require_devid;
+
 	int			nr_spis;
 
 	/* TODO: Consider moving to global state */
@@ -308,4 +311,6 @@ static inline int kvm_vgic_get_max_vcpus(void)
 	return kvm_vgic_global_state.max_gic_vcpus;
 }
 
+int kvm_send_userspace_msi(struct kvm *kvm, struct kvm_msi *msi);
+
 #endif /* __KVM_ARM_VGIC_H */

commit 3802411d01880c4283426d22653e011159b1c947
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Fri Jul 15 12:43:33 2016 +0100

    KVM: arm64: vgic-its: Connect LPIs to the VGIC emulation
    
    LPIs are dynamically created (mapped) at guest runtime and their
    actual number can be quite high, but is mostly assigned using a very
    sparse allocation scheme. So arrays are not an ideal data structure
    to hold the information.
    We use a spin-lock protected linked list to hold all mapped LPIs,
    represented by their struct vgic_irq. This lock is grouped between the
    ap_list_lock and the vgic_irq lock in our locking order.
    Also we store a pointer to that struct vgic_irq in our struct its_itte,
    so we can easily access it.
    Eventually we call our new vgic_get_lpi() from vgic_get_irq(), so
    the VGIC code gets transparently access to LPIs.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 61867492d361..a6ca326055cf 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -77,6 +77,7 @@ enum vgic_irq_config {
 
 struct vgic_irq {
 	spinlock_t irq_lock;		/* Protects the content of the struct */
+	struct list_head lpi_list;	/* Used to link all LPIs together */
 	struct list_head ap_list;
 
 	struct kvm_vcpu *vcpu;		/* SGIs and PPIs: The VCPU
@@ -193,6 +194,11 @@ struct vgic_dist {
 	 * GICv3 spec: 6.1.2 "LPI Configuration tables"
 	 */
 	u64			propbaser;
+
+	/* Protects the lpi_list and the count value below. */
+	spinlock_t		lpi_list_lock;
+	struct list_head	lpi_list_head;
+	int			lpi_list_count;
 };
 
 struct vgic_v2_cpu_if {

commit 424c33830f53f248a68da125e70d9a4d95a8e010
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Fri Jul 15 12:43:32 2016 +0100

    KVM: arm64: vgic-its: Implement basic ITS register handlers
    
    Add emulation for some basic MMIO registers used in the ITS emulation.
    This includes:
    - GITS_{CTLR,TYPER,IIDR}
    - ID registers
    - GITS_{CBASER,CREADR,CWRITER}
      (which implement the ITS command buffer handling)
    - GITS_BASER<n>
    
    Most of the handlers are pretty straight forward, only the CWRITER
    handler is a bit more involved by taking the new its_cmd mutex and
    then iterating over the command buffer.
    The registers holding base addresses and attributes are sanitised before
    storing them.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 8609faced83e..61867492d361 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -22,6 +22,7 @@
 #include <linux/spinlock.h>
 #include <linux/types.h>
 #include <kvm/iodev.h>
+#include <linux/list.h>
 
 #define VGIC_V3_MAX_CPUS	255
 #define VGIC_V2_MAX_CPUS	8
@@ -136,6 +137,21 @@ struct vgic_its {
 	bool			enabled;
 	bool			initialized;
 	struct vgic_io_device	iodev;
+
+	/* These registers correspond to GITS_BASER{0,1} */
+	u64			baser_device_table;
+	u64			baser_coll_table;
+
+	/* Protects the command queue */
+	struct mutex		cmd_lock;
+	u64			cbaser;
+	u32			creadr;
+	u32			cwriter;
+
+	/* Protects the device and collection lists */
+	struct mutex		its_lock;
+	struct list_head	device_list;
+	struct list_head	collection_list;
 };
 
 struct vgic_dist {

commit 1085fdc68c6097244627a02a56bd2d8fe58a1a9c
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Fri Jul 15 12:43:31 2016 +0100

    KVM: arm64: vgic-its: Introduce new KVM ITS device
    
    Introduce a new KVM device that represents an ARM Interrupt Translation
    Service (ITS) controller. Since there can be multiple of this per guest,
    we can't piggy back on the existing GICv3 distributor device, but create
    a new type of KVM device.
    On the KVM_CREATE_DEVICE ioctl we allocate and initialize the ITS data
    structure and store the pointer in the kvm_device data.
    Upon an explicit init ioctl from userland (after having setup the MMIO
    address) we register the handlers with the kvm_io_bus framework.
    Any reference to an ITS thus has to go via this interface.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 685f33975ce4..8609faced83e 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -134,6 +134,7 @@ struct vgic_its {
 	gpa_t			vgic_its_base;
 
 	bool			enabled;
+	bool			initialized;
 	struct vgic_io_device	iodev;
 };
 
@@ -167,6 +168,8 @@ struct vgic_dist {
 
 	struct vgic_io_device	dist_iodev;
 
+	bool			has_its;
+
 	/*
 	 * Contains the attributes and gpa of the LPI configuration table.
 	 * Since we report GICR_TYPER.CommonLPIAff as 0b00, we can share

commit 59c5ab40989afa5aba9c4a0918a5ed910a917422
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Fri Jul 15 12:43:30 2016 +0100

    KVM: arm64: vgic-its: Introduce ITS emulation file with MMIO framework
    
    The ARM GICv3 ITS emulation code goes into a separate file, but needs
    to be connected to the GICv3 emulation, of which it is an option.
    The ITS MMIO handlers require the respective ITS pointer to be passed in,
    so we amend the existing VGIC MMIO framework to let it cope with that.
    Also we introduce the basic ITS data structure and initialize it, but
    don't return any success yet, as we are not yet ready for the show.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index df2dec5ef620..685f33975ce4 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -108,15 +108,35 @@ struct vgic_irq {
 };
 
 struct vgic_register_region;
+struct vgic_its;
+
+enum iodev_type {
+	IODEV_CPUIF,
+	IODEV_DIST,
+	IODEV_REDIST,
+	IODEV_ITS
+};
 
 struct vgic_io_device {
 	gpa_t base_addr;
-	struct kvm_vcpu *redist_vcpu;
+	union {
+		struct kvm_vcpu *redist_vcpu;
+		struct vgic_its *its;
+	};
 	const struct vgic_register_region *regions;
+	enum iodev_type iodev_type;
 	int nr_regions;
 	struct kvm_io_device dev;
 };
 
+struct vgic_its {
+	/* The base address of the ITS control register frame */
+	gpa_t			vgic_its_base;
+
+	bool			enabled;
+	struct vgic_io_device	iodev;
+};
+
 struct vgic_dist {
 	bool			in_kernel;
 	bool			ready;

commit 0aa1de57319c4e023187aca0d59dd593a96459a8
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Fri Jul 15 12:43:29 2016 +0100

    KVM: arm64: vgic: Handle ITS related GICv3 redistributor registers
    
    In the GICv3 redistributor there are the PENDBASER and PROPBASER
    registers which we did not emulate so far, as they only make sense
    when having an ITS. In preparation for that emulate those MMIO
    accesses by storing the 64-bit data written into it into a variable
    which we later read in the ITS emulation.
    We also sanitise the registers, making sure RES0 regions are respected
    and checking for valid memory attributes.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 450b4dab9a9f..df2dec5ef620 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -146,6 +146,14 @@ struct vgic_dist {
 	struct vgic_irq		*spis;
 
 	struct vgic_io_device	dist_iodev;
+
+	/*
+	 * Contains the attributes and gpa of the LPI configuration table.
+	 * Since we report GICR_TYPER.CommonLPIAff as 0b00, we can share
+	 * one address across all redistributors.
+	 * GICv3 spec: 6.1.2 "LPI Configuration tables"
+	 */
+	u64			propbaser;
 };
 
 struct vgic_v2_cpu_if {
@@ -200,6 +208,11 @@ struct vgic_cpu {
 	 */
 	struct vgic_io_device	rd_iodev;
 	struct vgic_io_device	sgi_iodev;
+
+	/* Contains the attributes and gpa of the LPI pending tables. */
+	u64 pendbaser;
+
+	bool lpis_enabled;
 };
 
 int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr, bool write);

commit 5dd4b924e390af426e424d5e52c1b4d1566af817
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Fri Jul 15 12:43:27 2016 +0100

    KVM: arm/arm64: vgic: Add refcounting for IRQs
    
    In the moment our struct vgic_irq's are statically allocated at guest
    creation time. So getting a pointer to an IRQ structure is trivial and
    safe. LPIs are more dynamic, they can be mapped and unmapped at any time
    during the guest's _runtime_.
    In preparation for supporting LPIs we introduce reference counting for
    those structures using the kernel's kref infrastructure.
    Since private IRQs and SPIs are statically allocated, we avoid actually
    refcounting them, since they would never be released anyway.
    But we take provisions to increase the refcount when an IRQ gets onto a
    VCPU list and decrease it when it gets removed. Also this introduces
    vgic_put_irq(), which wraps kref_put and hides the release function from
    the callers.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 5142e2ab9f5e..450b4dab9a9f 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -96,6 +96,7 @@ struct vgic_irq {
 	bool active;			/* not used for LPIs */
 	bool enabled;
 	bool hw;			/* Tied to HW IRQ */
+	struct kref refcount;		/* Used for LPIs */
 	u32 hwintid;			/* HW INTID number */
 	union {
 		u8 targets;			/* GICv2 target VCPUs mask */

commit 8f6cdc1c2eec20c3bbf3a83ad0e1db165f709917
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Fri Jul 15 12:43:22 2016 +0100

    KVM: arm/arm64: vgic: Move redistributor kvm_io_devices
    
    Logically a GICv3 redistributor is assigned to a (v)CPU, so we should
    aim to keep redistributor related variables out of our struct vgic_dist.
    
    Let's start by replacing the redistributor related kvm_io_device array
    with two members in our existing struct vgic_cpu, which are naturally
    per-VCPU and thus don't require any allocation / freeing.
    So apart from the better fit with the redistributor design this saves
    some code as well.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 12640378db98..5142e2ab9f5e 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -145,7 +145,6 @@ struct vgic_dist {
 	struct vgic_irq		*spis;
 
 	struct vgic_io_device	dist_iodev;
-	struct vgic_io_device	*redist_iodevs;
 };
 
 struct vgic_v2_cpu_if {
@@ -193,6 +192,13 @@ struct vgic_cpu {
 	struct list_head ap_list_head;
 
 	u64 live_lrs;
+
+	/*
+	 * Members below are used with GICv3 emulation only and represent
+	 * parts of the redistributor.
+	 */
+	struct vgic_io_device	rd_iodev;
+	struct vgic_io_device	sgi_iodev;
 };
 
 int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr, bool write);

commit 50926d82fa271fa76d5717b546a66f7b5703ff05
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Sat May 28 11:27:11 2016 +0100

    KVM: arm/arm64: The GIC is dead, long live the GIC
    
    I don't think any single piece of the KVM/ARM code ever generated
    as much hatred as the GIC emulation.
    
    It was written by someone who had zero experience in modeling
    hardware (me), was riddled with design flaws, should have been
    scrapped and rewritten from scratch long before having a remote
    chance of reaching mainline, and yet we supported it for a good
    three years. No need to mention the names of those who suffered,
    the git log is singing their praises.
    
    Thankfully, we now have a much more maintainable implementation,
    and we can safely put the grumpy old GIC to rest.
    
    Fellow hackers, please raise your glass in memory of the GIC:
    
            The GIC is dead, long live the GIC!
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index da0a524802cb..12640378db98 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -1,6 +1,5 @@
 /*
- * Copyright (C) 2012 ARM Ltd.
- * Author: Marc Zyngier <marc.zyngier@arm.com>
+ * Copyright (C) 2015, 2016 ARM Ltd.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -12,16 +11,10 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
-
-#ifndef __ASM_ARM_KVM_VGIC_H
-#define __ASM_ARM_KVM_VGIC_H
-
-#ifdef CONFIG_KVM_NEW_VGIC
-#include <kvm/vgic/vgic.h>
-#else
+#ifndef __KVM_ARM_VGIC_H
+#define __KVM_ARM_VGIC_H
 
 #include <linux/kernel.h>
 #include <linux/kvm.h>
@@ -29,248 +22,130 @@
 #include <linux/spinlock.h>
 #include <linux/types.h>
 #include <kvm/iodev.h>
-#include <linux/irqchip/arm-gic-common.h>
 
-#define VGIC_NR_IRQS_LEGACY	256
+#define VGIC_V3_MAX_CPUS	255
+#define VGIC_V2_MAX_CPUS	8
+#define VGIC_NR_IRQS_LEGACY     256
 #define VGIC_NR_SGIS		16
 #define VGIC_NR_PPIS		16
 #define VGIC_NR_PRIVATE_IRQS	(VGIC_NR_SGIS + VGIC_NR_PPIS)
+#define VGIC_MAX_PRIVATE	(VGIC_NR_PRIVATE_IRQS - 1)
+#define VGIC_MAX_SPI		1019
+#define VGIC_MAX_RESERVED	1023
+#define VGIC_MIN_LPI		8192
 
-#define VGIC_V2_MAX_LRS		(1 << 6)
-#define VGIC_V3_MAX_LRS		16
-#define VGIC_MAX_IRQS		1024
-#define VGIC_V2_MAX_CPUS	8
-#define VGIC_V3_MAX_CPUS	255
-
-#if (VGIC_NR_IRQS_LEGACY & 31)
-#error "VGIC_NR_IRQS must be a multiple of 32"
-#endif
+enum vgic_type {
+	VGIC_V2,		/* Good ol' GICv2 */
+	VGIC_V3,		/* New fancy GICv3 */
+};
 
-#if (VGIC_NR_IRQS_LEGACY > VGIC_MAX_IRQS)
-#error "VGIC_NR_IRQS must be <= 1024"
-#endif
+/* same for all guests, as depending only on the _host's_ GIC model */
+struct vgic_global {
+	/* type of the host GIC */
+	enum vgic_type		type;
 
-/*
- * The GIC distributor registers describing interrupts have two parts:
- * - 32 per-CPU interrupts (SGI + PPI)
- * - a bunch of shared interrupts (SPI)
- */
-struct vgic_bitmap {
-	/*
-	 * - One UL per VCPU for private interrupts (assumes UL is at
-	 *   least 32 bits)
-	 * - As many UL as necessary for shared interrupts.
-	 *
-	 * The private interrupts are accessed via the "private"
-	 * field, one UL per vcpu (the state for vcpu n is in
-	 * private[n]). The shared interrupts are accessed via the
-	 * "shared" pointer (IRQn state is at bit n-32 in the bitmap).
-	 */
-	unsigned long *private;
-	unsigned long *shared;
-};
+	/* Physical address of vgic virtual cpu interface */
+	phys_addr_t		vcpu_base;
 
-struct vgic_bytemap {
-	/*
-	 * - 8 u32 per VCPU for private interrupts
-	 * - As many u32 as necessary for shared interrupts.
-	 *
-	 * The private interrupts are accessed via the "private"
-	 * field, (the state for vcpu n is in private[n*8] to
-	 * private[n*8 + 7]). The shared interrupts are accessed via
-	 * the "shared" pointer (IRQn state is at byte (n-32)%4 of the
-	 * shared[(n-32)/4] word).
-	 */
-	u32 *private;
-	u32 *shared;
-};
+	/* virtual control interface mapping */
+	void __iomem		*vctrl_base;
 
-struct kvm_vcpu;
+	/* Number of implemented list registers */
+	int			nr_lr;
 
-enum vgic_type {
-	VGIC_V2,		/* Good ol' GICv2 */
-	VGIC_V3,		/* New fancy GICv3 */
-};
+	/* Maintenance IRQ number */
+	unsigned int		maint_irq;
 
-#define LR_STATE_PENDING	(1 << 0)
-#define LR_STATE_ACTIVE		(1 << 1)
-#define LR_STATE_MASK		(3 << 0)
-#define LR_EOI_INT		(1 << 2)
-#define LR_HW			(1 << 3)
+	/* maximum number of VCPUs allowed (GICv2 limits us to 8) */
+	int			max_gic_vcpus;
 
-struct vgic_lr {
-	unsigned irq:10;
-	union {
-		unsigned hwirq:10;
-		unsigned source:3;
-	};
-	unsigned state:4;
+	/* Only needed for the legacy KVM_CREATE_IRQCHIP */
+	bool			can_emulate_gicv2;
 };
 
-struct vgic_vmcr {
-	u32	ctlr;
-	u32	abpr;
-	u32	bpr;
-	u32	pmr;
-};
+extern struct vgic_global kvm_vgic_global_state;
 
-struct vgic_ops {
-	struct vgic_lr	(*get_lr)(const struct kvm_vcpu *, int);
-	void	(*set_lr)(struct kvm_vcpu *, int, struct vgic_lr);
-	u64	(*get_elrsr)(const struct kvm_vcpu *vcpu);
-	u64	(*get_eisr)(const struct kvm_vcpu *vcpu);
-	void	(*clear_eisr)(struct kvm_vcpu *vcpu);
-	u32	(*get_interrupt_status)(const struct kvm_vcpu *vcpu);
-	void	(*enable_underflow)(struct kvm_vcpu *vcpu);
-	void	(*disable_underflow)(struct kvm_vcpu *vcpu);
-	void	(*get_vmcr)(struct kvm_vcpu *vcpu, struct vgic_vmcr *vmcr);
-	void	(*set_vmcr)(struct kvm_vcpu *vcpu, struct vgic_vmcr *vmcr);
-	void	(*enable)(struct kvm_vcpu *vcpu);
-};
+#define VGIC_V2_MAX_LRS		(1 << 6)
+#define VGIC_V3_MAX_LRS		16
+#define VGIC_V3_LR_INDEX(lr)	(VGIC_V3_MAX_LRS - 1 - lr)
 
-struct vgic_params {
-	/* vgic type */
-	enum vgic_type	type;
-	/* Physical address of vgic virtual cpu interface */
-	phys_addr_t	vcpu_base;
-	/* Number of list registers */
-	u32		nr_lr;
-	/* Interrupt number */
-	unsigned int	maint_irq;
-	/* Virtual control interface base address */
-	void __iomem	*vctrl_base;
-	int		max_gic_vcpus;
-	/* Only needed for the legacy KVM_CREATE_IRQCHIP */
-	bool		can_emulate_gicv2;
+enum vgic_irq_config {
+	VGIC_CONFIG_EDGE = 0,
+	VGIC_CONFIG_LEVEL
 };
 
-struct vgic_vm_ops {
-	bool	(*queue_sgi)(struct kvm_vcpu *, int irq);
-	void	(*add_sgi_source)(struct kvm_vcpu *, int irq, int source);
-	int	(*init_model)(struct kvm *);
-	int	(*map_resources)(struct kvm *, const struct vgic_params *);
+struct vgic_irq {
+	spinlock_t irq_lock;		/* Protects the content of the struct */
+	struct list_head ap_list;
+
+	struct kvm_vcpu *vcpu;		/* SGIs and PPIs: The VCPU
+					 * SPIs and LPIs: The VCPU whose ap_list
+					 * this is queued on.
+					 */
+
+	struct kvm_vcpu *target_vcpu;	/* The VCPU that this interrupt should
+					 * be sent to, as a result of the
+					 * targets reg (v2) or the
+					 * affinity reg (v3).
+					 */
+
+	u32 intid;			/* Guest visible INTID */
+	bool pending;
+	bool line_level;		/* Level only */
+	bool soft_pending;		/* Level only */
+	bool active;			/* not used for LPIs */
+	bool enabled;
+	bool hw;			/* Tied to HW IRQ */
+	u32 hwintid;			/* HW INTID number */
+	union {
+		u8 targets;			/* GICv2 target VCPUs mask */
+		u32 mpidr;			/* GICv3 target VCPU */
+	};
+	u8 source;			/* GICv2 SGIs only */
+	u8 priority;
+	enum vgic_irq_config config;	/* Level or edge */
 };
 
+struct vgic_register_region;
+
 struct vgic_io_device {
-	gpa_t addr;
-	int len;
-	const struct vgic_io_range *reg_ranges;
+	gpa_t base_addr;
 	struct kvm_vcpu *redist_vcpu;
+	const struct vgic_register_region *regions;
+	int nr_regions;
 	struct kvm_io_device dev;
 };
 
-struct irq_phys_map {
-	u32			virt_irq;
-	u32			phys_irq;
-};
-
-struct irq_phys_map_entry {
-	struct list_head	entry;
-	struct rcu_head		rcu;
-	struct irq_phys_map	map;
-};
-
 struct vgic_dist {
-	spinlock_t		lock;
 	bool			in_kernel;
 	bool			ready;
+	bool			initialized;
 
 	/* vGIC model the kernel emulates for the guest (GICv2 or GICv3) */
 	u32			vgic_model;
 
-	int			nr_cpus;
-	int			nr_irqs;
+	int			nr_spis;
 
+	/* TODO: Consider moving to global state */
 	/* Virtual control interface mapping */
 	void __iomem		*vctrl_base;
 
-	/* Distributor and vcpu interface mapping in the guest */
-	phys_addr_t		vgic_dist_base;
-	/* GICv2 and GICv3 use different mapped register blocks */
+	/* base addresses in guest physical address space: */
+	gpa_t			vgic_dist_base;		/* distributor */
 	union {
-		phys_addr_t		vgic_cpu_base;
-		phys_addr_t		vgic_redist_base;
+		/* either a GICv2 CPU interface */
+		gpa_t			vgic_cpu_base;
+		/* or a number of GICv3 redistributor regions */
+		gpa_t			vgic_redist_base;
 	};
 
-	/* Distributor enabled */
-	u32			enabled;
-
-	/* Interrupt enabled (one bit per IRQ) */
-	struct vgic_bitmap	irq_enabled;
-
-	/* Level-triggered interrupt external input is asserted */
-	struct vgic_bitmap	irq_level;
-
-	/*
-	 * Interrupt state is pending on the distributor
-	 */
-	struct vgic_bitmap	irq_pending;
-
-	/*
-	 * Tracks writes to GICD_ISPENDRn and GICD_ICPENDRn for level-triggered
-	 * interrupts.  Essentially holds the state of the flip-flop in
-	 * Figure 4-10 on page 4-101 in ARM IHI 0048B.b.
-	 * Once set, it is only cleared for level-triggered interrupts on
-	 * guest ACKs (when we queue it) or writes to GICD_ICPENDRn.
-	 */
-	struct vgic_bitmap	irq_soft_pend;
-
-	/* Level-triggered interrupt queued on VCPU interface */
-	struct vgic_bitmap	irq_queued;
-
-	/* Interrupt was active when unqueue from VCPU interface */
-	struct vgic_bitmap	irq_active;
+	/* distributor enabled */
+	bool			enabled;
 
-	/* Interrupt priority. Not used yet. */
-	struct vgic_bytemap	irq_priority;
+	struct vgic_irq		*spis;
 
-	/* Level/edge triggered */
-	struct vgic_bitmap	irq_cfg;
-
-	/*
-	 * Source CPU per SGI and target CPU:
-	 *
-	 * Each byte represent a SGI observable on a VCPU, each bit of
-	 * this byte indicating if the corresponding VCPU has
-	 * generated this interrupt. This is a GICv2 feature only.
-	 *
-	 * For VCPUn (n < 8), irq_sgi_sources[n*16] to [n*16 + 15] are
-	 * the SGIs observable on VCPUn.
-	 */
-	u8			*irq_sgi_sources;
-
-	/*
-	 * Target CPU for each SPI:
-	 *
-	 * Array of available SPI, each byte indicating the target
-	 * VCPU for SPI. IRQn (n >=32) is at irq_spi_cpu[n-32].
-	 */
-	u8			*irq_spi_cpu;
-
-	/*
-	 * Reverse lookup of irq_spi_cpu for faster compute pending:
-	 *
-	 * Array of bitmaps, one per VCPU, describing if IRQn is
-	 * routed to a particular VCPU.
-	 */
-	struct vgic_bitmap	*irq_spi_target;
-
-	/* Target MPIDR for each IRQ (needed for GICv3 IROUTERn) only */
-	u32			*irq_spi_mpidr;
-
-	/* Bitmap indicating which CPU has something pending */
-	unsigned long		*irq_pending_on_cpu;
-
-	/* Bitmap indicating which CPU has active IRQs */
-	unsigned long		*irq_active_on_cpu;
-
-	struct vgic_vm_ops	vm_ops;
 	struct vgic_io_device	dist_iodev;
 	struct vgic_io_device	*redist_iodevs;
-
-	/* Virtual irq to hwirq mapping */
-	spinlock_t		irq_phys_map_lock;
-	struct list_head	irq_phys_map_list;
 };
 
 struct vgic_v2_cpu_if {
@@ -298,78 +173,74 @@ struct vgic_v3_cpu_if {
 };
 
 struct vgic_cpu {
-	/* Pending/active/both interrupts on this VCPU */
-	DECLARE_BITMAP(pending_percpu, VGIC_NR_PRIVATE_IRQS);
-	DECLARE_BITMAP(active_percpu, VGIC_NR_PRIVATE_IRQS);
-	DECLARE_BITMAP(pend_act_percpu, VGIC_NR_PRIVATE_IRQS);
-
-	/* Pending/active/both shared interrupts, dynamically sized */
-	unsigned long	*pending_shared;
-	unsigned long   *active_shared;
-	unsigned long   *pend_act_shared;
-
 	/* CPU vif control registers for world switch */
 	union {
 		struct vgic_v2_cpu_if	vgic_v2;
 		struct vgic_v3_cpu_if	vgic_v3;
 	};
 
-	/* Protected by the distributor's irq_phys_map_lock */
-	struct list_head	irq_phys_map_list;
-
-	u64		live_lrs;
-};
+	unsigned int used_lrs;
+	struct vgic_irq private_irqs[VGIC_NR_PRIVATE_IRQS];
 
-#define LR_EMPTY	0xff
+	spinlock_t ap_list_lock;	/* Protects the ap_list */
 
-#define INT_STATUS_EOI		(1 << 0)
-#define INT_STATUS_UNDERFLOW	(1 << 1)
+	/*
+	 * List of IRQs that this VCPU should consider because they are either
+	 * Active or Pending (hence the name; AP list), or because they recently
+	 * were one of the two and need to be migrated off this list to another
+	 * VCPU.
+	 */
+	struct list_head ap_list_head;
 
-struct kvm;
-struct kvm_vcpu;
+	u64 live_lrs;
+};
 
 int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr, bool write);
-int kvm_vgic_hyp_init(void);
-int kvm_vgic_map_resources(struct kvm *kvm);
-int kvm_vgic_get_max_vcpus(void);
 void kvm_vgic_early_init(struct kvm *kvm);
 int kvm_vgic_create(struct kvm *kvm, u32 type);
 void kvm_vgic_destroy(struct kvm *kvm);
 void kvm_vgic_vcpu_early_init(struct kvm_vcpu *vcpu);
 void kvm_vgic_vcpu_destroy(struct kvm_vcpu *vcpu);
-void kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu);
-void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu);
-int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int irq_num,
+int kvm_vgic_map_resources(struct kvm *kvm);
+int kvm_vgic_hyp_init(void);
+
+int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int intid,
 			bool level);
-int kvm_vgic_inject_mapped_irq(struct kvm *kvm, int cpuid,
-			       unsigned int virt_irq, bool level);
-void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg);
-int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
-int kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu, int virt_irq, int phys_irq);
+int kvm_vgic_inject_mapped_irq(struct kvm *kvm, int cpuid, unsigned int intid,
+			       bool level);
+int kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu, u32 virt_irq, u32 phys_irq);
 int kvm_vgic_unmap_phys_irq(struct kvm_vcpu *vcpu, unsigned int virt_irq);
 bool kvm_vgic_map_is_active(struct kvm_vcpu *vcpu, unsigned int virt_irq);
 
+int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
+
 #define irqchip_in_kernel(k)	(!!((k)->arch.vgic.in_kernel))
-#define vgic_initialized(k)	(!!((k)->arch.vgic.nr_cpus))
+#define vgic_initialized(k)	((k)->arch.vgic.initialized)
 #define vgic_ready(k)		((k)->arch.vgic.ready)
 #define vgic_valid_spi(k, i)	(((i) >= VGIC_NR_PRIVATE_IRQS) && \
-				 ((i) < (k)->arch.vgic.nr_irqs))
+			((i) < (k)->arch.vgic.nr_spis + VGIC_NR_PRIVATE_IRQS))
+
+bool kvm_vcpu_has_pending_irqs(struct kvm_vcpu *vcpu);
+void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu);
+void kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu);
 
-int vgic_v2_probe(const struct gic_kvm_info *gic_kvm_info,
-		  const struct vgic_ops **ops,
-		  const struct vgic_params **params);
 #ifdef CONFIG_KVM_ARM_VGIC_V3
-int vgic_v3_probe(const struct gic_kvm_info *gic_kvm_info,
-		  const struct vgic_ops **ops,
-		  const struct vgic_params **params);
+void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg);
 #else
-static inline int vgic_v3_probe(const struct gic_kvm_info *gic_kvm_info,
-				const struct vgic_ops **ops,
-				const struct vgic_params **params)
+static inline void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg)
 {
-	return -ENODEV;
 }
 #endif
 
-#endif	/* old VGIC include */
-#endif
+/**
+ * kvm_vgic_get_max_vcpus - Get the maximum number of VCPUs allowed by HW
+ *
+ * The host's GIC naturally limits the maximum amount of VCPUs a guest
+ * can use.
+ */
+static inline int kvm_vgic_get_max_vcpus(void)
+{
+	return kvm_vgic_global_state.max_gic_vcpus;
+}
+
+#endif /* __KVM_ARM_VGIC_H */

commit b18b57787f5e469b2825784ae3c522fc14472e97
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Mon Nov 23 07:20:05 2015 -0800

    KVM: arm/arm64: vgic-new: Add data structure definitions
    
    Add a new header file for the new and improved GIC implementation.
    The big change is that we now have a struct vgic_irq per IRQ instead
    of spreading all the information over various bitmaps.
    
    We include this new header conditionally from within the old header
    file for the time being to avoid touching all the users.
    
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index ade70056cbd6..da0a524802cb 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -19,6 +19,10 @@
 #ifndef __ASM_ARM_KVM_VGIC_H
 #define __ASM_ARM_KVM_VGIC_H
 
+#ifdef CONFIG_KVM_NEW_VGIC
+#include <kvm/vgic/vgic.h>
+#else
+
 #include <linux/kernel.h>
 #include <linux/kvm.h>
 #include <linux/irqreturn.h>
@@ -367,4 +371,5 @@ static inline int vgic_v3_probe(const struct gic_kvm_info *gic_kvm_info,
 }
 #endif
 
+#endif	/* old VGIC include */
 #endif

commit 2defaff48aaf16072a6eac4cf8234917197dfa72
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Mon Mar 7 17:32:29 2016 +0700

    KVM: arm/arm64: pmu: abstract access to number of SPIs
    
    Currently the PMU uses a member of the struct vgic_dist directly,
    which not only breaks abstraction, but will fail with the new VGIC.
    Abstract this access in the VGIC header file and refactor the validity
    check in the PMU code.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 67a66371356d..ade70056cbd6 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -348,6 +348,8 @@ bool kvm_vgic_map_is_active(struct kvm_vcpu *vcpu, unsigned int virt_irq);
 #define irqchip_in_kernel(k)	(!!((k)->arch.vgic.in_kernel))
 #define vgic_initialized(k)	(!!((k)->arch.vgic.nr_cpus))
 #define vgic_ready(k)		((k)->arch.vgic.ready)
+#define vgic_valid_spi(k, i)	(((i) >= VGIC_NR_PRIVATE_IRQS) && \
+				 ((i) < (k)->arch.vgic.nr_irqs))
 
 int vgic_v2_probe(const struct gic_kvm_info *gic_kvm_info,
 		  const struct vgic_ops **ops,

commit 2db4c104fa2a9af12c07433642e2e4fee37fe2fd
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Wed Apr 6 14:48:53 2016 +0200

    KVM: arm/arm64: Get rid of vgic_cpu->nr_lr
    
    The number of list registers is a property of the underlying system, not
    of emulated VGIC CPU interface.
    
    As we are about to move this variable to global state in the new vgic
    for clarity, move it from the legacy implementation as well to make the
    merge of the new code easier.
    
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Andre Przywara <andre.przywara@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 3e17fb4e64b7..67a66371356d 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -304,9 +304,6 @@ struct vgic_cpu {
 	unsigned long   *active_shared;
 	unsigned long   *pend_act_shared;
 
-	/* Number of list registers on this CPU */
-	int		nr_lr;
-
 	/* CPU vif control registers for world switch */
 	union {
 		struct vgic_v2_cpu_if	vgic_v2;

commit c8eb3f6b9bc31abc0ab3230737fde1639c8b1ea6
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Wed Apr 13 11:49:07 2016 +0100

    KVM: arm/arm64: vgic: Remove irq_phys_map from interface
    
    Now that the virtual arch timer does not care about the irq_phys_map
    anymore, let's rework kvm_vgic_map_phys_irq() to return an error
    value instead. Any reference to that mapping can later be done by
    passing the correct combination of VCPU and virtual IRQ number.
    This makes the irq_phys_map handling completely private to the
    VGIC code.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Eric Auger <eric.auger@linaro.org>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 9ad7625c0e79..3e17fb4e64b7 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -344,8 +344,7 @@ int kvm_vgic_inject_mapped_irq(struct kvm *kvm, int cpuid,
 			       unsigned int virt_irq, bool level);
 void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg);
 int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
-struct irq_phys_map *kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu,
-					   int virt_irq, int phys_irq);
+int kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu, int virt_irq, int phys_irq);
 int kvm_vgic_unmap_phys_irq(struct kvm_vcpu *vcpu, unsigned int virt_irq);
 bool kvm_vgic_map_is_active(struct kvm_vcpu *vcpu, unsigned int virt_irq);
 

commit b452cb52072d21f026e38ac7af36a969bab2ed22
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Sat Jun 4 15:41:00 2016 +0100

    KVM: arm/arm64: Remove the IRQ field from struct irq_phys_map
    
    The communication of a Linux IRQ number from outside the VGIC to the
    vgic was a leftover from the day when the vgic code cared about how a
    particular device injects virtual interrupts mapped to a physical
    interrupt.
    
    We can safely remove this notion, leaving all physical IRQ handling to
    be done in the device driver (the arch timer in this case), which makes
    room for a saner API for the new VGIC.
    
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Eric Auger <eric.auger@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index c7bb184c79eb..9ad7625c0e79 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -158,7 +158,6 @@ struct vgic_io_device {
 struct irq_phys_map {
 	u32			virt_irq;
 	u32			phys_irq;
-	u32			irq;
 };
 
 struct irq_phys_map_entry {
@@ -346,7 +345,7 @@ int kvm_vgic_inject_mapped_irq(struct kvm *kvm, int cpuid,
 void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg);
 int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
 struct irq_phys_map *kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu,
-					   int virt_irq, int irq);
+					   int virt_irq, int phys_irq);
 int kvm_vgic_unmap_phys_irq(struct kvm_vcpu *vcpu, unsigned int virt_irq);
 bool kvm_vgic_map_is_active(struct kvm_vcpu *vcpu, unsigned int virt_irq);
 

commit 63306c28ac92bdf9e41aef367708d762f9f725f2
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Wed Apr 13 10:04:06 2016 +0100

    KVM: arm/arm64: vgic: avoid map in kvm_vgic_unmap_phys_irq()
    
    kvm_vgic_unmap_phys_irq() only needs the virtual IRQ number, so let's
    just pass that between the arch timer and the VGIC to get rid of
    the irq_phys_map pointer.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Eric Auger <eric.auger@linaro.org>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 9830232c453b..c7bb184c79eb 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -347,7 +347,7 @@ void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg);
 int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
 struct irq_phys_map *kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu,
 					   int virt_irq, int irq);
-int kvm_vgic_unmap_phys_irq(struct kvm_vcpu *vcpu, struct irq_phys_map *map);
+int kvm_vgic_unmap_phys_irq(struct kvm_vcpu *vcpu, unsigned int virt_irq);
 bool kvm_vgic_map_is_active(struct kvm_vcpu *vcpu, unsigned int virt_irq);
 
 #define irqchip_in_kernel(k)	(!!((k)->arch.vgic.in_kernel))

commit e262f4193638fff2de458f0c70284f0cb50926a7
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Wed Apr 13 10:03:49 2016 +0100

    KVM: arm/arm64: vgic: avoid map in kvm_vgic_map_is_active()
    
    For getting the active state of a mapped IRQ, we actually only need
    the virtual IRQ number, not the pointer to the mapping entry.
    Pass the virtual IRQ number from the arch timer to the VGIC directly.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Eric Auger <eric.auger@linaro.org>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index e22f01507e2b..9830232c453b 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -348,7 +348,7 @@ int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
 struct irq_phys_map *kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu,
 					   int virt_irq, int irq);
 int kvm_vgic_unmap_phys_irq(struct kvm_vcpu *vcpu, struct irq_phys_map *map);
-bool kvm_vgic_map_is_active(struct kvm_vcpu *vcpu, struct irq_phys_map *map);
+bool kvm_vgic_map_is_active(struct kvm_vcpu *vcpu, unsigned int virt_irq);
 
 #define irqchip_in_kernel(k)	(!!((k)->arch.vgic.in_kernel))
 #define vgic_initialized(k)	(!!((k)->arch.vgic.nr_cpus))

commit 4f551a3d96a2de85a041ee60e806bda1d5b06255
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Wed Apr 13 09:48:02 2016 +0100

    KVM: arm/arm64: vgic: avoid map in kvm_vgic_inject_mapped_irq()
    
    When we want to inject a hardware mapped IRQ into a guest, we actually
    only need the virtual IRQ number from the irq_phys_map.
    So let's pass this number directly from the arch timer to the VGIC
    to avoid using the map as a parameter.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Eric Auger <eric.auger@linaro.org>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index be6037aa703d..e22f01507e2b 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -342,7 +342,7 @@ void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu);
 int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int irq_num,
 			bool level);
 int kvm_vgic_inject_mapped_irq(struct kvm *kvm, int cpuid,
-			       struct irq_phys_map *map, bool level);
+			       unsigned int virt_irq, bool level);
 void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg);
 int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
 struct irq_phys_map *kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu,

commit 503a62862e8fc08b2d4c0db06ba3adae3bbd61bc
Author: Julien Grall <julien.grall@arm.com>
Date:   Mon Apr 11 16:32:59 2016 +0100

    KVM: arm/arm64: vgic: Rely on the GIC driver to parse the firmware tables
    
    Currently, the firmware tables are parsed 2 times: once in the GIC
    drivers, the other time when initializing the vGIC. It means code
    duplication and make more tedious to add the support for another
    firmware table (like ACPI).
    
    Use the recently introduced helper gic_get_kvm_info() to get
    information about the virtual GIC.
    
    With this change, the virtual GIC becomes agnostic to the firmware
    table and KVM will be able to initialize the vGIC on ACPI.
    
    Signed-off-by: Julien Grall <julien.grall@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 281caf847fad..be6037aa703d 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -25,6 +25,7 @@
 #include <linux/spinlock.h>
 #include <linux/types.h>
 #include <kvm/iodev.h>
+#include <linux/irqchip/arm-gic-common.h>
 
 #define VGIC_NR_IRQS_LEGACY	256
 #define VGIC_NR_SGIS		16
@@ -353,15 +354,15 @@ bool kvm_vgic_map_is_active(struct kvm_vcpu *vcpu, struct irq_phys_map *map);
 #define vgic_initialized(k)	(!!((k)->arch.vgic.nr_cpus))
 #define vgic_ready(k)		((k)->arch.vgic.ready)
 
-int vgic_v2_probe(struct device_node *vgic_node,
+int vgic_v2_probe(const struct gic_kvm_info *gic_kvm_info,
 		  const struct vgic_ops **ops,
 		  const struct vgic_params **params);
 #ifdef CONFIG_KVM_ARM_VGIC_V3
-int vgic_v3_probe(struct device_node *vgic_node,
+int vgic_v3_probe(const struct gic_kvm_info *gic_kvm_info,
 		  const struct vgic_ops **ops,
 		  const struct vgic_params **params);
 #else
-static inline int vgic_v3_probe(struct device_node *vgic_node,
+static inline int vgic_v3_probe(const struct gic_kvm_info *gic_kvm_info,
 				const struct vgic_ops **ops,
 				const struct vgic_params **params)
 {

commit 1b8e83c04ee2c05c0cd0d304c4b389adf24ebe7f
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed Feb 17 10:25:05 2016 +0000

    arm64: KVM: vgic-v3: Avoid accessing ICH registers
    
    Just like on GICv2, we're a bit hammer-happy with GICv3, and access
    them more often than we should.
    
    Adopt a policy similar to what we do for GICv2, only save/restoring
    the minimal set of registers. As we don't access the registers
    linearly anymore (we may skip some), the convoluted accessors become
    slightly simpler, and we can drop the ugly indexing macro that
    tended to confuse the reviewers.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index f473fd65fab5..281caf847fad 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -279,12 +279,6 @@ struct vgic_v2_cpu_if {
 	u32		vgic_lr[VGIC_V2_MAX_LRS];
 };
 
-/*
- * LRs are stored in reverse order in memory. make sure we index them
- * correctly.
- */
-#define VGIC_V3_LR_INDEX(lr)		(VGIC_V3_MAX_LRS - 1 - lr)
-
 struct vgic_v3_cpu_if {
 #ifdef CONFIG_KVM_ARM_VGIC_V3
 	u32		vgic_hcr;

commit 59f00ff9afc028053fa9281407627e95008ebd5c
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Feb 2 19:35:34 2016 +0000

    KVM: arm/arm64: vgic-v2: Avoid accessing GICH registers
    
    GICv2 registers are *slow*. As in "terrifyingly slow". Which is bad.
    But we're equaly bad, as we make a point in accessing them even if
    we don't have any interrupt in flight.
    
    A good solution is to first find out if we have anything useful to
    write into the GIC, and if we don't, to simply not do it. This
    involves tracking which LRs actually have something valid there.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 13a3d537811b..f473fd65fab5 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -321,6 +321,8 @@ struct vgic_cpu {
 
 	/* Protected by the distributor's irq_phys_map_lock */
 	struct list_head	irq_phys_map_list;
+
+	u64		live_lrs;
 };
 
 #define LR_EMPTY	0xff

commit 3c13b8f435acb452eac62d966148a8b6fa92151f
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Dec 1 13:48:56 2015 +0000

    KVM: arm/arm64: vgic-v3: Make the LR indexing macro public
    
    We store GICv3 LRs in reverse order so that the CPU can save/restore
    them in rever order as well (don't ask why, the design is crazy),
    and yet generate memory traffic that doesn't completely suck.
    
    We need this macro to be available to the C version of save/restore.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index d2f41477f8ae..13a3d537811b 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -279,6 +279,12 @@ struct vgic_v2_cpu_if {
 	u32		vgic_lr[VGIC_V2_MAX_LRS];
 };
 
+/*
+ * LRs are stored in reverse order in memory. make sure we index them
+ * correctly.
+ */
+#define VGIC_V3_LR_INDEX(lr)		(VGIC_V3_MAX_LRS - 1 - lr)
+
 struct vgic_v3_cpu_if {
 #ifdef CONFIG_KVM_ARM_VGIC_V3
 	u32		vgic_hcr;

commit 0e3dfda91d9fe8e2c4d0b5d21434b173a241eeaf
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Tue Nov 24 16:23:05 2015 +0100

    KVM: arm/arm64: arch_timer: Preserve physical dist. active state on LR.active
    
    We were incorrectly removing the active state from the physical
    distributor on the timer interrupt when the timer output level was
    deasserted.  We shouldn't be doing this without considering the virtual
    interrupt's active state, because the architecture requires that when an
    LR has the HW bit set and the pending or active bits set, then the
    physical interrupt must also have the corresponding bits set.
    
    This addresses an issue where we have been observing an inconsistency
    between the LR state and the physical distributor state where the LR
    state was active and the physical distributor was not active, which
    shouldn't happen.
    
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 9c747cb14ad8..d2f41477f8ae 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -342,10 +342,10 @@ int kvm_vgic_inject_mapped_irq(struct kvm *kvm, int cpuid,
 			       struct irq_phys_map *map, bool level);
 void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg);
 int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
-int kvm_vgic_vcpu_active_irq(struct kvm_vcpu *vcpu);
 struct irq_phys_map *kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu,
 					   int virt_irq, int irq);
 int kvm_vgic_unmap_phys_irq(struct kvm_vcpu *vcpu, struct irq_phys_map *map);
+bool kvm_vgic_map_is_active(struct kvm_vcpu *vcpu, struct irq_phys_map *map);
 
 #define irqchip_in_kernel(k)	(!!((k)->arch.vgic.in_kernel))
 #define vgic_initialized(k)	(!!((k)->arch.vgic.nr_cpus))

commit 933425fb0010bd02bd459b41e63082756818ffce
Merge: a3e7531535a0 a3eaa8649e4c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 5 16:26:26 2015 -0800

    Merge tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm
    
    Pull KVM updates from Paolo Bonzini:
     "First batch of KVM changes for 4.4.
    
      s390:
         A bunch of fixes and optimizations for interrupt and time handling.
    
      PPC:
         Mostly bug fixes.
    
      ARM:
         No big features, but many small fixes and prerequisites including:
    
          - a number of fixes for the arch-timer
    
          - introducing proper level-triggered semantics for the arch-timers
    
          - a series of patches to synchronously halt a guest (prerequisite
            for IRQ forwarding)
    
          - some tracepoint improvements
    
          - a tweak for the EL2 panic handlers
    
          - some more VGIC cleanups getting rid of redundant state
    
      x86:
         Quite a few changes:
    
          - support for VT-d posted interrupts (i.e. PCI devices can inject
            interrupts directly into vCPUs).  This introduces a new
            component (in virt/lib/) that connects VFIO and KVM together.
            The same infrastructure will be used for ARM interrupt
            forwarding as well.
    
          - more Hyper-V features, though the main one Hyper-V synthetic
            interrupt controller will have to wait for 4.5.  These will let
            KVM expose Hyper-V devices.
    
          - nested virtualization now supports VPID (same as PCID but for
            vCPUs) which makes it quite a bit faster
    
          - for future hardware that supports NVDIMM, there is support for
            clflushopt, clwb, pcommit
    
          - support for "split irqchip", i.e.  LAPIC in kernel +
            IOAPIC/PIC/PIT in userspace, which reduces the attack surface of
            the hypervisor
    
          - obligatory smattering of SMM fixes
    
          - on the guest side, stable scheduler clock support was rewritten
            to not require help from the hypervisor"
    
    * tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm: (123 commits)
      KVM: VMX: Fix commit which broke PML
      KVM: x86: obey KVM_X86_QUIRK_CD_NW_CLEARED in kvm_set_cr0()
      KVM: x86: allow RSM from 64-bit mode
      KVM: VMX: fix SMEP and SMAP without EPT
      KVM: x86: move kvm_set_irq_inatomic to legacy device assignment
      KVM: device assignment: remove pointless #ifdefs
      KVM: x86: merge kvm_arch_set_irq with kvm_set_msi_inatomic
      KVM: x86: zero apic_arb_prio on reset
      drivers/hv: share Hyper-V SynIC constants with userspace
      KVM: x86: handle SMBASE as physical address in RSM
      KVM: x86: add read_phys to x86_emulate_ops
      KVM: x86: removing unused variable
      KVM: don't pointlessly leave KVM_COMPAT=y in non-KVM configs
      KVM: arm/arm64: Merge vgic_set_lr() and vgic_sync_lr_elrsr()
      KVM: arm/arm64: Clean up vgic_retire_lr() and surroundings
      KVM: arm/arm64: Optimize away redundant LR tracking
      KVM: s390: use simple switch statement as multiplexer
      KVM: s390: drop useless newline in debugging data
      KVM: s390: SCA must not cross page boundaries
      KVM: arm: Do not indent the arguments of DECLARE_BITMAP
      ...

commit 26caea7693cb99833fe4ecc544c842289d6b3f69
Author: Pavel Fedin <p.fedin@samsung.com>
Date:   Tue Oct 27 11:37:31 2015 +0300

    KVM: arm/arm64: Merge vgic_set_lr() and vgic_sync_lr_elrsr()
    
    Now we see that vgic_set_lr() and vgic_sync_lr_elrsr() are always used
    together. Merge them into one function, saving from second vgic_ops
    dereferencing every time.
    
    Signed-off-by: Pavel Fedin <p.fedin@samsung.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 3936bf802e1d..f62addc17dcf 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -112,7 +112,6 @@ struct vgic_vmcr {
 struct vgic_ops {
 	struct vgic_lr	(*get_lr)(const struct kvm_vcpu *, int);
 	void	(*set_lr)(struct kvm_vcpu *, int, struct vgic_lr);
-	void	(*sync_lr_elrsr)(struct kvm_vcpu *, int, struct vgic_lr);
 	u64	(*get_elrsr)(const struct kvm_vcpu *vcpu);
 	u64	(*get_eisr)(const struct kvm_vcpu *vcpu);
 	void	(*clear_eisr)(struct kvm_vcpu *vcpu);

commit c4cd4c168b81dad53e659d18cdae653bc0ec2384
Author: Pavel Fedin <p.fedin@samsung.com>
Date:   Tue Oct 27 11:37:29 2015 +0300

    KVM: arm/arm64: Optimize away redundant LR tracking
    
    Currently we use vgic_irq_lr_map in order to track which LRs hold which
    IRQs, and lr_used bitmap in order to track which LRs are used or free.
    
    vgic_irq_lr_map is actually used only for piggy-back optimization, and
    can be easily replaced by iteration over lr_used. This is good because in
    future, when LPI support is introduced, number of IRQs will grow up to at
    least 16384, while numbers from 1024 to 8192 are never going to be used.
    This would be a huge memory waste.
    
    In its turn, lr_used is also completely redundant since
    ae705930fca6322600690df9dc1c7d0516145a93 ("arm/arm64: KVM: Keep elrsr/aisr
    in sync with software model"), because together with lr_used we also update
    elrsr. This allows to easily replace lr_used with elrsr, inverting all
    conditions (because in elrsr '1' means 'free').
    
    Signed-off-by: Pavel Fedin <p.fedin@samsung.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 8065801a1847..3936bf802e1d 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -295,9 +295,6 @@ struct vgic_v3_cpu_if {
 };
 
 struct vgic_cpu {
-	/* per IRQ to LR mapping */
-	u8		*vgic_irq_lr_map;
-
 	/* Pending/active/both interrupts on this VCPU */
 	DECLARE_BITMAP(pending_percpu, VGIC_NR_PRIVATE_IRQS);
 	DECLARE_BITMAP(active_percpu, VGIC_NR_PRIVATE_IRQS);
@@ -308,9 +305,6 @@ struct vgic_cpu {
 	unsigned long   *active_shared;
 	unsigned long   *pend_act_shared;
 
-	/* Bitmap of used/free list registers */
-	DECLARE_BITMAP(lr_used, VGIC_V2_MAX_LRS);
-
 	/* Number of list registers on this CPU */
 	int		nr_lr;
 

commit 5fdf876d30ce7c9b63045b3db8374912ab9b262c
Author: Michal Marek <mmarek@suse.com>
Date:   Thu Oct 15 22:16:28 2015 +0200

    KVM: arm: Do not indent the arguments of DECLARE_BITMAP
    
    Besides being a coding style issue, it confuses make tags:
    
    ctags: Warning: include/kvm/arm_vgic.h:307: null expansion of name pattern "\1"
    ctags: Warning: include/kvm/arm_vgic.h:308: null expansion of name pattern "\1"
    ctags: Warning: include/kvm/arm_vgic.h:309: null expansion of name pattern "\1"
    ctags: Warning: include/kvm/arm_vgic.h:317: null expansion of name pattern "\1"
    
    Cc: kvmarm@lists.cs.columbia.edu
    Signed-off-by: Michal Marek <mmarek@suse.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 7bc5d0224ab0..8065801a1847 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -299,9 +299,9 @@ struct vgic_cpu {
 	u8		*vgic_irq_lr_map;
 
 	/* Pending/active/both interrupts on this VCPU */
-	DECLARE_BITMAP(	pending_percpu, VGIC_NR_PRIVATE_IRQS);
-	DECLARE_BITMAP(	active_percpu, VGIC_NR_PRIVATE_IRQS);
-	DECLARE_BITMAP(	pend_act_percpu, VGIC_NR_PRIVATE_IRQS);
+	DECLARE_BITMAP(pending_percpu, VGIC_NR_PRIVATE_IRQS);
+	DECLARE_BITMAP(active_percpu, VGIC_NR_PRIVATE_IRQS);
+	DECLARE_BITMAP(pend_act_percpu, VGIC_NR_PRIVATE_IRQS);
 
 	/* Pending/active/both shared interrupts, dynamically sized */
 	unsigned long	*pending_shared;
@@ -309,7 +309,7 @@ struct vgic_cpu {
 	unsigned long   *pend_act_shared;
 
 	/* Bitmap of used/free list registers */
-	DECLARE_BITMAP(	lr_used, VGIC_V2_MAX_LRS);
+	DECLARE_BITMAP(lr_used, VGIC_V2_MAX_LRS);
 
 	/* Number of list registers on this CPU */
 	int		nr_lr;

commit 4b4b4512da2a844b8da2585609b67fae1ce4f4db
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Sun Aug 30 15:01:27 2015 +0200

    arm/arm64: KVM: Rework the arch timer to use level-triggered semantics
    
    The arch timer currently uses edge-triggered semantics in the sense that
    the line is never sampled by the vgic and lowering the line from the
    timer to the vgic doesn't have any effect on the pending state of
    virtual interrupts in the vgic.  This means that we do not support a
    guest with the otherwise valid behavior of (1) disable interrupts (2)
    enable the timer (3) disable the timer (4) enable interrupts.  Such a
    guest would validly not expect to see any interrupts on real hardware,
    but will see interrupts on KVM.
    
    This patch fixes this shortcoming through the following series of
    changes.
    
    First, we change the flow of the timer/vgic sync/flush operations.  Now
    the timer is always flushed/synced before the vgic, because the vgic
    samples the state of the timer output.  This has the implication that we
    move the timer operations in to non-preempible sections, but that is
    fine after the previous commit getting rid of hrtimer schedules on every
    entry/exit.
    
    Second, we change the internal behavior of the timer, letting the timer
    keep track of its previous output state, and only lower/raise the line
    to the vgic when the state changes.  Note that in theory this could have
    been accomplished more simply by signalling the vgic every time the
    state *potentially* changed, but we don't want to be hitting the vgic
    more often than necessary.
    
    Third, we get rid of the use of the map->active field in the vgic and
    instead simply set the interrupt as active on the physical distributor
    whenever the input to the GIC is asserted and conversely clear the
    physical active state when the input to the GIC is deasserted.
    
    Fourth, and finally, we now initialize the timer PPIs (and all the other
    unused PPIs for now), to be level-triggered, and modify the sync code to
    sample the line state on HW sync and re-inject a new interrupt if it is
    still pending at that time.
    
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 4e14dac282bb..7bc5d0224ab0 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -159,7 +159,6 @@ struct irq_phys_map {
 	u32			virt_irq;
 	u32			phys_irq;
 	u32			irq;
-	bool			active;
 };
 
 struct irq_phys_map_entry {
@@ -354,8 +353,6 @@ int kvm_vgic_vcpu_active_irq(struct kvm_vcpu *vcpu);
 struct irq_phys_map *kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu,
 					   int virt_irq, int irq);
 int kvm_vgic_unmap_phys_irq(struct kvm_vcpu *vcpu, struct irq_phys_map *map);
-bool kvm_vgic_get_phys_irq_active(struct irq_phys_map *map);
-void kvm_vgic_set_phys_irq_active(struct irq_phys_map *map, bool active);
 
 #define irqchip_in_kernel(k)	(!!((k)->arch.vgic.in_kernel))
 #define vgic_initialized(k)	(!!((k)->arch.vgic.nr_cpus))

commit 4f64cb65bf76fbd89c62d8e69c7bf75091950739
Author: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
Date:   Thu Oct 1 13:47:19 2015 +0100

    arm/arm64: KVM: Only allow 64bit hosts to build VGICv3
    
    Hardware virtualisation of GICv3 is only supported by 64bit hosts for
    the moment. Some VGICv3 bits are missing from the 32bit side, and this
    patch allows to still be able to build 32bit hosts when CONFIG_ARM_GIC_V3
    is selected.
    
    To this end, we introduce a new option, CONFIG_KVM_ARM_VGIC_V3, that is
    only enabled on the 64bit side. The selection is done unconditionally
    because CONFIG_ARM_GIC_V3 is always enabled on arm64.
    
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 4e14dac282bb..6a3538ef7275 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -282,7 +282,7 @@ struct vgic_v2_cpu_if {
 };
 
 struct vgic_v3_cpu_if {
-#ifdef CONFIG_ARM_GIC_V3
+#ifdef CONFIG_KVM_ARM_VGIC_V3
 	u32		vgic_hcr;
 	u32		vgic_vmcr;
 	u32		vgic_sre;	/* Restored only, change ignored */
@@ -364,7 +364,7 @@ void kvm_vgic_set_phys_irq_active(struct irq_phys_map *map, bool active);
 int vgic_v2_probe(struct device_node *vgic_node,
 		  const struct vgic_ops **ops,
 		  const struct vgic_params **params);
-#ifdef CONFIG_ARM_GIC_V3
+#ifdef CONFIG_KVM_ARM_VGIC_V3
 int vgic_v3_probe(struct device_node *vgic_node,
 		  const struct vgic_ops **ops,
 		  const struct vgic_params **params);

commit ef748917b529847277f07c98c55e1c0ce416449f
Author: Ming Lei <ming.lei@canonical.com>
Date:   Wed Sep 2 14:31:21 2015 +0800

    arm/arm64: KVM: Remove 'config KVM_ARM_MAX_VCPUS'
    
    This patch removes config option of KVM_ARM_MAX_VCPUS,
    and like other ARCHs, just choose the maximum allowed
    value from hardware, and follows the reasons:
    
    1) from distribution view, the option has to be
    defined as the max allowed value because it need to
    meet all kinds of virtulization applications and
    need to support most of SoCs;
    
    2) using a bigger value doesn't introduce extra memory
    consumption, and the help text in Kconfig isn't accurate
    because kvm_vpu structure isn't allocated until request
    of creating VCPU is sent from QEMU;
    
    3) the main effect is that the field of vcpus[] in 'struct kvm'
    becomes a bit bigger(sizeof(void *) per vcpu) and need more cache
    lines to hold the structure, but 'struct kvm' is one generic struct,
    and it has worked well on other ARCHs already in this way. Also,
    the world switch frequecy is often low, for example, it is ~2000
    when running kernel building load in VM from APM xgene KVM host,
    so the effect is very small, and the difference can't be observed
    in my test at all.
    
    Cc: Dann Frazier <dann.frazier@canonical.com>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index d901f1a47be6..4e14dac282bb 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -35,11 +35,7 @@
 #define VGIC_V3_MAX_LRS		16
 #define VGIC_MAX_IRQS		1024
 #define VGIC_V2_MAX_CPUS	8
-
-/* Sanity checks... */
-#if (KVM_MAX_VCPUS > 255)
-#error Too many KVM VCPUs, the VGIC only supports up to 255 VCPUs for now
-#endif
+#define VGIC_V3_MAX_CPUS	255
 
 #if (VGIC_NR_IRQS_LEGACY & 31)
 #error "VGIC_NR_IRQS must be a multiple of 32"

commit 773299a570725d1f253d6046cd6475209b0dcd55
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Jul 24 11:30:43 2015 +0100

    KVM: arm/arm64: vgic: Prevent userspace injection of a mapped interrupt
    
    Virtual interrupts mapped to a HW interrupt should only be triggered
    from inside the kernel. Otherwise, you could end up confusing the
    kernel (and the GIC's) state machine.
    
    Rearrange the injection path so that kvm_vgic_inject_irq is
    used for non-mapped interrupts, and kvm_vgic_inject_mapped_irq is
    used for mapped interrupts. The latter should only be called from
    inside the kernel (timer, irqfd).
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index e789e4721139..d901f1a47be6 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -350,6 +350,8 @@ void kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu);
 void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu);
 int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int irq_num,
 			bool level);
+int kvm_vgic_inject_mapped_irq(struct kvm *kvm, int cpuid,
+			       struct irq_phys_map *map, bool level);
 void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg);
 int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
 int kvm_vgic_vcpu_active_irq(struct kvm_vcpu *vcpu);

commit 6e84e0e0677281b4e7fc634c7e9d085fbcf41b10
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Jun 8 16:13:30 2015 +0100

    KVM: arm/arm64: vgic: Add vgic_{get,set}_phys_irq_active
    
    In order to control the active state of an interrupt, introduce
    a pair of accessors allowing the state to be set/queried.
    
    This only affects the logical state, and the HW state will only be
    applied at world-switch time.
    
    Acked-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index c0e6354bcd06..e789e4721139 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -356,6 +356,8 @@ int kvm_vgic_vcpu_active_irq(struct kvm_vcpu *vcpu);
 struct irq_phys_map *kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu,
 					   int virt_irq, int irq);
 int kvm_vgic_unmap_phys_irq(struct kvm_vcpu *vcpu, struct irq_phys_map *map);
+bool kvm_vgic_get_phys_irq_active(struct irq_phys_map *map);
+void kvm_vgic_set_phys_irq_active(struct irq_phys_map *map, bool active);
 
 #define irqchip_in_kernel(k)	(!!((k)->arch.vgic.in_kernel))
 #define vgic_initialized(k)	(!!((k)->arch.vgic.nr_cpus))

commit 6c3d63c9a26ba56e2ca63a9f68d52f77ae551d91
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Jun 23 17:37:18 2014 +0100

    KVM: arm/arm64: vgic: Allow dynamic mapping of physical/virtual interrupts
    
    In order to be able to feed physical interrupts to a guest, we need
    to be able to establish the virtual-physical mapping between the two
    worlds.
    
    The mappings are kept in a set of RCU lists, indexed by virtual interrupts.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index a881e398d3e5..c0e6354bcd06 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -159,6 +159,19 @@ struct vgic_io_device {
 	struct kvm_io_device dev;
 };
 
+struct irq_phys_map {
+	u32			virt_irq;
+	u32			phys_irq;
+	u32			irq;
+	bool			active;
+};
+
+struct irq_phys_map_entry {
+	struct list_head	entry;
+	struct rcu_head		rcu;
+	struct irq_phys_map	map;
+};
+
 struct vgic_dist {
 	spinlock_t		lock;
 	bool			in_kernel;
@@ -256,6 +269,10 @@ struct vgic_dist {
 	struct vgic_vm_ops	vm_ops;
 	struct vgic_io_device	dist_iodev;
 	struct vgic_io_device	*redist_iodevs;
+
+	/* Virtual irq to hwirq mapping */
+	spinlock_t		irq_phys_map_lock;
+	struct list_head	irq_phys_map_list;
 };
 
 struct vgic_v2_cpu_if {
@@ -307,6 +324,9 @@ struct vgic_cpu {
 		struct vgic_v2_cpu_if	vgic_v2;
 		struct vgic_v3_cpu_if	vgic_v3;
 	};
+
+	/* Protected by the distributor's irq_phys_map_lock */
+	struct list_head	irq_phys_map_list;
 };
 
 #define LR_EMPTY	0xff
@@ -321,8 +341,10 @@ int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr, bool write);
 int kvm_vgic_hyp_init(void);
 int kvm_vgic_map_resources(struct kvm *kvm);
 int kvm_vgic_get_max_vcpus(void);
+void kvm_vgic_early_init(struct kvm *kvm);
 int kvm_vgic_create(struct kvm *kvm, u32 type);
 void kvm_vgic_destroy(struct kvm *kvm);
+void kvm_vgic_vcpu_early_init(struct kvm_vcpu *vcpu);
 void kvm_vgic_vcpu_destroy(struct kvm_vcpu *vcpu);
 void kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu);
 void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu);
@@ -331,6 +353,9 @@ int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int irq_num,
 void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg);
 int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
 int kvm_vgic_vcpu_active_irq(struct kvm_vcpu *vcpu);
+struct irq_phys_map *kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu,
+					   int virt_irq, int irq);
+int kvm_vgic_unmap_phys_irq(struct kvm_vcpu *vcpu, struct irq_phys_map *map);
 
 #define irqchip_in_kernel(k)	(!!((k)->arch.vgic.in_kernel))
 #define vgic_initialized(k)	(!!((k)->arch.vgic.nr_cpus))

commit 32d2d8010cd7080a0f1712f1084b92657858428e
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Jun 8 15:21:32 2015 +0100

    KVM: arm/arm64: vgic: Convert struct vgic_lr to use bitfields
    
    As we're about to cram more information in the vgic_lr structure
    (HW interrupt number and additional state information), we switch
    to a layout similar to the HW's:
    
    - use bitfields to save space (we don't need more than 10 bits
      to represent the irq numbers)
    - source CPU and HW interrupt can share the same field, as
      a SGI doesn't have a physical line.
    
    Reviewed-by: Alex Benne <alex.bennee@linaro.org>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 133ea00aa83b..a881e398d3e5 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -95,11 +95,15 @@ enum vgic_type {
 #define LR_STATE_ACTIVE		(1 << 1)
 #define LR_STATE_MASK		(3 << 0)
 #define LR_EOI_INT		(1 << 2)
+#define LR_HW			(1 << 3)
 
 struct vgic_lr {
-	u16	irq;
-	u8	source;
-	u8	state;
+	unsigned irq:10;
+	union {
+		unsigned hwirq:10;
+		unsigned source:3;
+	};
+	unsigned state:4;
 };
 
 struct vgic_vmcr {

commit bf0fb67cf957fc8ecfaaa2819b7d6a0f795e2ef2
Merge: 8999602d08a8 d44758c0dfc5
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Tue Apr 7 18:09:20 2015 +0200

    Merge tag 'kvm-arm-for-4.1' of git://git.kernel.org/pub/scm/linux/kernel/git/kvmarm/kvmarm into 'kvm-next'
    
    KVM/ARM changes for v4.1:
    
    - fixes for live migration
    - irqfd support
    - kvm-io-bus & vgic rework to enable ioeventfd
    - page ageing for stage-2 translation
    - various cleanups

commit 950324ab81bf006542f30a1d1ab3d65fcf15cbc1
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Sat Mar 28 01:13:13 2015 +0000

    KVM: arm/arm64: rework MMIO abort handling to use KVM MMIO bus
    
    Currently we have struct kvm_exit_mmio for encapsulating MMIO abort
    data to be passed on from syndrome decoding all the way down to the
    VGIC register handlers. Now as we switch the MMIO handling to be
    routed through the KVM MMIO bus, it does not make sense anymore to
    use that structure already from the beginning. So we keep the data in
    local variables until we put them into the kvm_io_bus framework.
    Then we fill kvm_exit_mmio in the VGIC only, making it a VGIC private
    structure. On that way we replace the data buffer in that structure
    with a pointer pointing to a single location in a local variable, so
    we get rid of some copying on the way.
    With all of the virtual GIC emulation code now being registered with
    the kvm_io_bus, we can remove all of the old MMIO handling code and
    its dispatching functionality.
    
    I didn't bother to rename kvm_exit_mmio (to vgic_mmio or something),
    because that touches a lot of code lines without any good reason.
    
    This is based on an original patch by Nikolay.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Cc: Nikolay Nikolaev <n.nikolaev@virtualopensystems.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index d6705f447c28..16ec2c8b784d 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -140,8 +140,6 @@ struct vgic_params {
 };
 
 struct vgic_vm_ops {
-	bool	(*handle_mmio)(struct kvm_vcpu *, struct kvm_run *,
-			       struct kvm_exit_mmio *);
 	bool	(*queue_sgi)(struct kvm_vcpu *, int irq);
 	void	(*add_sgi_source)(struct kvm_vcpu *, int irq, int source);
 	int	(*init_model)(struct kvm *);
@@ -313,8 +311,6 @@ struct vgic_cpu {
 
 struct kvm;
 struct kvm_vcpu;
-struct kvm_run;
-struct kvm_exit_mmio;
 
 int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr, bool write);
 int kvm_vgic_hyp_init(void);
@@ -330,8 +326,6 @@ int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int irq_num,
 void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg);
 int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
 int kvm_vgic_vcpu_active_irq(struct kvm_vcpu *vcpu);
-bool vgic_handle_mmio(struct kvm_vcpu *vcpu, struct kvm_run *run,
-		      struct kvm_exit_mmio *mmio);
 
 #define irqchip_in_kernel(k)	(!!((k)->arch.vgic.in_kernel))
 #define vgic_initialized(k)	(!!((k)->arch.vgic.nr_cpus))

commit fb8f61abab48467ef670ef165ff664cdc94f742e
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Thu Mar 26 14:39:37 2015 +0000

    KVM: arm/arm64: prepare GICv3 emulation to use kvm_io_bus MMIO handling
    
    Using the framework provided by the recent vgic.c changes, we
    register a kvm_io_bus device on mapping the virtual GICv3 resources.
    The distributor mapping is pretty straight forward, but the
    redistributors need some more love, since they need to be tagged with
    the respective redistributor (read: VCPU) they are connected with.
    We use the kvm_io_bus framework to register one devices per VCPU.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 4523984bd217..d6705f447c28 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -252,6 +252,7 @@ struct vgic_dist {
 
 	struct vgic_vm_ops	vm_ops;
 	struct vgic_io_device	dist_iodev;
+	struct vgic_io_device	*redist_iodevs;
 };
 
 struct vgic_v2_cpu_if {

commit a9cf86f62b785202684c3ba92895946f03d910c8
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Thu Mar 26 14:39:35 2015 +0000

    KVM: arm/arm64: prepare GICv2 emulation to be handled by kvm_io_bus
    
    Using the framework provided by the recent vgic.c changes we register
    a kvm_io_bus device when initializing the virtual GICv2.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index f90140caed8f..4523984bd217 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -251,6 +251,7 @@ struct vgic_dist {
 	unsigned long		*irq_active_on_cpu;
 
 	struct vgic_vm_ops	vm_ops;
+	struct vgic_io_device	dist_iodev;
 };
 
 struct vgic_v2_cpu_if {

commit 6777f77f0f544f686ee3158ff0db6a7d81b7d3a2
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Thu Mar 26 14:39:34 2015 +0000

    KVM: arm/arm64: implement kvm_io_bus MMIO handling for the VGIC
    
    Currently we use a lot of VGIC specific code to do the MMIO
    dispatching.
    Use the previous reworks to add kvm_io_bus style MMIO handlers.
    
    Those are not yet called by the MMIO abort handler, also the actual
    VGIC emulator function do not make use of it yet, but will be enabled
    with the following patches.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 9092fad3c141..f90140caed8f 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -24,6 +24,7 @@
 #include <linux/irqreturn.h>
 #include <linux/spinlock.h>
 #include <linux/types.h>
+#include <kvm/iodev.h>
 
 #define VGIC_NR_IRQS_LEGACY	256
 #define VGIC_NR_SGIS		16
@@ -147,6 +148,14 @@ struct vgic_vm_ops {
 	int	(*map_resources)(struct kvm *, const struct vgic_params *);
 };
 
+struct vgic_io_device {
+	gpa_t addr;
+	int len;
+	const struct vgic_io_range *reg_ranges;
+	struct kvm_vcpu *redist_vcpu;
+	struct kvm_io_device dev;
+};
+
 struct vgic_dist {
 	spinlock_t		lock;
 	bool			in_kernel;

commit 47a98b15ba7cf6a13bd94ab8455d3f586b16420b
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Fri Mar 13 17:02:54 2015 +0000

    arm/arm64: KVM: support for un-queuing active IRQs
    
    Migrating active interrupts causes the active state to be lost
    completely. This implements some additional bitmaps to track the active
    state on the distributor and export this to user space.
    
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Alex Benne <alex.bennee@linaro.org>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index b81630b1da85..9092fad3c141 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -195,6 +195,9 @@ struct vgic_dist {
 	/* Level-triggered interrupt queued on VCPU interface */
 	struct vgic_bitmap	irq_queued;
 
+	/* Interrupt was active when unqueue from VCPU interface */
+	struct vgic_bitmap	irq_active;
+
 	/* Interrupt priority. Not used yet. */
 	struct vgic_bytemap	irq_priority;
 
@@ -235,6 +238,9 @@ struct vgic_dist {
 	/* Bitmap indicating which CPU has something pending */
 	unsigned long		*irq_pending_on_cpu;
 
+	/* Bitmap indicating which CPU has active IRQs */
+	unsigned long		*irq_active_on_cpu;
+
 	struct vgic_vm_ops	vm_ops;
 };
 
@@ -266,9 +272,15 @@ struct vgic_cpu {
 	/* per IRQ to LR mapping */
 	u8		*vgic_irq_lr_map;
 
-	/* Pending interrupts on this VCPU */
+	/* Pending/active/both interrupts on this VCPU */
 	DECLARE_BITMAP(	pending_percpu, VGIC_NR_PRIVATE_IRQS);
+	DECLARE_BITMAP(	active_percpu, VGIC_NR_PRIVATE_IRQS);
+	DECLARE_BITMAP(	pend_act_percpu, VGIC_NR_PRIVATE_IRQS);
+
+	/* Pending/active/both shared interrupts, dynamically sized */
 	unsigned long	*pending_shared;
+	unsigned long   *active_shared;
+	unsigned long   *pend_act_shared;
 
 	/* Bitmap of used/free list registers */
 	DECLARE_BITMAP(	lr_used, VGIC_V2_MAX_LRS);
@@ -306,6 +318,7 @@ int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int irq_num,
 			bool level);
 void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg);
 int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
+int kvm_vgic_vcpu_active_irq(struct kvm_vcpu *vcpu);
 bool vgic_handle_mmio(struct kvm_vcpu *vcpu, struct kvm_run *run,
 		      struct kvm_exit_mmio *mmio);
 

commit ae705930fca6322600690df9dc1c7d0516145a93
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Fri Mar 13 17:02:56 2015 +0000

    arm/arm64: KVM: Keep elrsr/aisr in sync with software model
    
    There is an interesting bug in the vgic code, which manifests itself
    when the KVM run loop has a signal pending or needs a vmid generation
    rollover after having disabled interrupts but before actually switching
    to the guest.
    
    In this case, we flush the vgic as usual, but we sync back the vgic
    state and exit to userspace before entering the guest.  The consequence
    is that we will be syncing the list registers back to the software model
    using the GICH_ELRSR and GICH_EISR from the last execution of the guest,
    potentially overwriting a list register containing an interrupt.
    
    This showed up during migration testing where we would capture a state
    where the VM has masked the arch timer but there were no interrupts,
    resulting in a hung test.
    
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Reported-by: Alex Bennee <alex.bennee@linaro.org>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Alex Benne <alex.bennee@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 7c55dd5dd2c9..66203b268984 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -114,6 +114,7 @@ struct vgic_ops {
 	void	(*sync_lr_elrsr)(struct kvm_vcpu *, int, struct vgic_lr);
 	u64	(*get_elrsr)(const struct kvm_vcpu *vcpu);
 	u64	(*get_eisr)(const struct kvm_vcpu *vcpu);
+	void	(*clear_eisr)(struct kvm_vcpu *vcpu);
 	u32	(*get_interrupt_status)(const struct kvm_vcpu *vcpu);
 	void	(*enable_underflow)(struct kvm_vcpu *vcpu);
 	void	(*disable_underflow)(struct kvm_vcpu *vcpu);

commit 662d9715840aef44dcb573b0f9fab9e8319c868a
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Wed Mar 11 14:21:31 2015 +0100

    arm/arm64: KVM: Kill CONFIG_KVM_ARM_{VGIC,TIMER}
    
    We can definitely decide at run-time whether to use the GIC and timers
    or not, and the extra code and data structures that we allocate space
    for is really negligable with this config option, so I don't think it's
    worth the extra complexity of always having to define stub static
    inlines.  The !CONFIG_KVM_ARM_VGIC/TIMER case is pretty much an untested
    code path anyway, so we're better off just getting rid of it.
    
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 7c55dd5dd2c9..b81630b1da85 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -148,7 +148,6 @@ struct vgic_vm_ops {
 };
 
 struct vgic_dist {
-#ifdef CONFIG_KVM_ARM_VGIC
 	spinlock_t		lock;
 	bool			in_kernel;
 	bool			ready;
@@ -237,7 +236,6 @@ struct vgic_dist {
 	unsigned long		*irq_pending_on_cpu;
 
 	struct vgic_vm_ops	vm_ops;
-#endif
 };
 
 struct vgic_v2_cpu_if {
@@ -265,7 +263,6 @@ struct vgic_v3_cpu_if {
 };
 
 struct vgic_cpu {
-#ifdef CONFIG_KVM_ARM_VGIC
 	/* per IRQ to LR mapping */
 	u8		*vgic_irq_lr_map;
 
@@ -284,7 +281,6 @@ struct vgic_cpu {
 		struct vgic_v2_cpu_if	vgic_v2;
 		struct vgic_v3_cpu_if	vgic_v3;
 	};
-#endif
 };
 
 #define LR_EMPTY	0xff
@@ -297,7 +293,6 @@ struct kvm_vcpu;
 struct kvm_run;
 struct kvm_exit_mmio;
 
-#ifdef CONFIG_KVM_ARM_VGIC
 int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr, bool write);
 int kvm_vgic_hyp_init(void);
 int kvm_vgic_map_resources(struct kvm *kvm);
@@ -334,84 +329,4 @@ static inline int vgic_v3_probe(struct device_node *vgic_node,
 }
 #endif
 
-#else
-static inline int kvm_vgic_hyp_init(void)
-{
-	return 0;
-}
-
-static inline int kvm_vgic_set_addr(struct kvm *kvm, unsigned long type, u64 addr)
-{
-	return 0;
-}
-
-static inline int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr, bool write)
-{
-	return -ENXIO;
-}
-
-static inline int kvm_vgic_map_resources(struct kvm *kvm)
-{
-	return 0;
-}
-
-static inline int kvm_vgic_create(struct kvm *kvm, u32 type)
-{
-	return 0;
-}
-
-static inline void kvm_vgic_destroy(struct kvm *kvm)
-{
-}
-
-static inline void kvm_vgic_vcpu_destroy(struct kvm_vcpu *vcpu)
-{
-}
-
-static inline int kvm_vgic_vcpu_init(struct kvm_vcpu *vcpu)
-{
-	return 0;
-}
-
-static inline void kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu) {}
-static inline void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu) {}
-
-static inline int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid,
-				      unsigned int irq_num, bool level)
-{
-	return 0;
-}
-
-static inline int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu)
-{
-	return 0;
-}
-
-static inline bool vgic_handle_mmio(struct kvm_vcpu *vcpu, struct kvm_run *run,
-				    struct kvm_exit_mmio *mmio)
-{
-	return false;
-}
-
-static inline int irqchip_in_kernel(struct kvm *kvm)
-{
-	return 0;
-}
-
-static inline bool vgic_initialized(struct kvm *kvm)
-{
-	return true;
-}
-
-static inline bool vgic_ready(struct kvm *kvm)
-{
-	return true;
-}
-
-static inline int kvm_vgic_get_max_vcpus(void)
-{
-	return KVM_MAX_VCPUS;
-}
-#endif
-
 #endif

commit ac3d373564d9744068d867a0eb16da2ff8d5ee9d
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Tue Jun 3 10:26:30 2014 +0200

    arm/arm64: KVM: allow userland to request a virtual GICv3
    
    With all of the GICv3 code in place now we allow userland to ask the
    kernel for using a virtual GICv3 in the guest.
    Also we provide the necessary support for guests setting the memory
    addresses for the virtual distributor and redistributors.
    This requires some userland code to make use of that feature and
    explicitly ask for a virtual GICv3.
    Document that KVM_CREATE_IRQCHIP only works for GICv2, but is
    considered legacy and using KVM_CREATE_DEVICE is preferred.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 39039d5f09a8..7c55dd5dd2c9 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -36,8 +36,8 @@
 #define VGIC_V2_MAX_CPUS	8
 
 /* Sanity checks... */
-#if (KVM_MAX_VCPUS > 8)
-#error	Invalid number of CPU interfaces
+#if (KVM_MAX_VCPUS > 255)
+#error Too many KVM VCPUs, the VGIC only supports up to 255 VCPUs for now
 #endif
 
 #if (VGIC_NR_IRQS_LEGACY & 31)

commit b5d84ff600a244b655bd4f657f5350f29b0ce611
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Tue Jun 3 10:26:03 2014 +0200

    arm/arm64: KVM: enable kernel side of GICv3 emulation
    
    With all the necessary GICv3 emulation code in place, we can now
    connect the code to the GICv3 backend in the kernel.
    The LR register handling is different depending on the emulated GIC
    model, so provide different implementations for each.
    Also allow non-v2-compatible GICv3 implementations (which don't
    provide MMIO regions for the virtual CPU interface in the DT), but
    restrict those hosts to support GICv3 guests only.
    If the device tree provides a GICv2 compatible GICV resource entry,
    but that one is faulty, just disable the GICv2 emulation and let the
    user use at least the GICv3 emulation for guests.
    To provide proper support for the legacy KVM_CREATE_IRQCHIP ioctl,
    note virtual GICv2 compatibility in struct vgic_params and use it
    on creating a VGICv2.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index b9b2e05a39ef..39039d5f09a8 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -134,6 +134,8 @@ struct vgic_params {
 	/* Virtual control interface base address */
 	void __iomem	*vctrl_base;
 	int		max_gic_vcpus;
+	/* Only needed for the legacy KVM_CREATE_IRQCHIP */
+	bool		can_emulate_gicv2;
 };
 
 struct vgic_vm_ops {

commit 6d52f35af10cf24d59b43f3fd8c938ad23cab543
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Tue Jun 3 10:13:13 2014 +0200

    arm64: KVM: add SGI generation register emulation
    
    While the generation of a (virtual) inter-processor interrupt (SGI)
    on a GICv2 works by writing to a MMIO register, GICv3 uses the system
    register ICC_SGI1R_EL1 to trigger them.
    Add a trap handler function that calls the new SGI register handler
    in the GICv3 code. As ICC_SRE_EL1.SRE at this point is still always 0,
    this will not trap yet, but will only be used later when all the data
    structures have been initialized properly.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 98c30168bce4..b9b2e05a39ef 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -307,6 +307,7 @@ void kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu);
 void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu);
 int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int irq_num,
 			bool level);
+void vgic_v3_dispatch_sgi(struct kvm_vcpu *vcpu, u64 reg);
 int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
 bool vgic_handle_mmio(struct kvm_vcpu *vcpu, struct kvm_run *run,
 		      struct kvm_exit_mmio *mmio);

commit a0675c25d6392c2197b796a60c4a2a0138c86355
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Sat Jun 7 00:54:51 2014 +0200

    arm/arm64: KVM: add virtual GICv3 distributor emulation
    
    With everything separated and prepared, we implement a model of a
    GICv3 distributor and redistributors by using the existing framework
    to provide handler functions for each register group.
    
    Currently we limit the emulation to a model enforcing a single
    security state, with SRE==1 (forcing system register access) and
    ARE==1 (allowing more than 8 VCPUs).
    
    We share some of the functions provided for GICv2 emulation, but take
    the different ways of addressing (v)CPUs into account.
    Save and restore is currently not implemented.
    
    Similar to the split-off of the GICv2 specific code, the new emulation
    code goes into a new file (vgic-v3-emul.c).
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index ff04afd0d901..98c30168bce4 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -162,7 +162,11 @@ struct vgic_dist {
 
 	/* Distributor and vcpu interface mapping in the guest */
 	phys_addr_t		vgic_dist_base;
-	phys_addr_t		vgic_cpu_base;
+	/* GICv2 and GICv3 use different mapped register blocks */
+	union {
+		phys_addr_t		vgic_cpu_base;
+		phys_addr_t		vgic_redist_base;
+	};
 
 	/* Distributor enabled */
 	u32			enabled;
@@ -224,6 +228,9 @@ struct vgic_dist {
 	 */
 	struct vgic_bitmap	*irq_spi_target;
 
+	/* Target MPIDR for each IRQ (needed for GICv3 IROUTERn) only */
+	u32			*irq_spi_mpidr;
+
 	/* Bitmap indicating which CPU has something pending */
 	unsigned long		*irq_pending_on_cpu;
 

commit 2f5fa41a7a7f47f3109a6596b0ec96258dbf06e6
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Tue Jun 3 08:58:15 2014 +0200

    arm/arm64: KVM: make the value of ICC_SRE_EL1 a per-VM variable
    
    ICC_SRE_EL1 is a system register allowing msr/mrs accesses to the
    GIC CPU interface for EL1 (guests). Currently we force it to 0, but
    for proper GICv3 support we have to allow guests to use it (depending
    on their selected virtual GIC model).
    So add ICC_SRE_EL1 to the list of saved/restored registers on a
    world switch, but actually disallow a guest to change it by only
    restoring a fixed, once-initialized value.
    This value depends on the GIC model userland has chosen for a guest.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 1c0e9dbabe6d..ff04afd0d901 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -245,6 +245,7 @@ struct vgic_v3_cpu_if {
 #ifdef CONFIG_ARM_GIC_V3
 	u32		vgic_hcr;
 	u32		vgic_vmcr;
+	u32		vgic_sre;	/* Restored only, change ignored */
 	u32		vgic_misr;	/* Saved only */
 	u32		vgic_eisr;	/* Saved only */
 	u32		vgic_elrsr;	/* Saved only */

commit 3caa2d8c3b2d80f5e342fe8cec07c03c8147dcab
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Mon Jun 2 16:26:01 2014 +0200

    arm/arm64: KVM: make the maximum number of vCPUs a per-VM value
    
    Currently the maximum number of vCPUs supported is a global value
    limited by the used GIC model. GICv3 will lift this limit, but we
    still need to observe it for guests using GICv2.
    So the maximum number of vCPUs is per-VM value, depending on the
    GIC model the guest uses.
    Store and check the value in struct kvm_arch, but keep it down to
    8 for now.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index dd243969bfc3..1c0e9dbabe6d 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -33,6 +33,7 @@
 #define VGIC_V2_MAX_LRS		(1 << 6)
 #define VGIC_V3_MAX_LRS		16
 #define VGIC_MAX_IRQS		1024
+#define VGIC_V2_MAX_CPUS	8
 
 /* Sanity checks... */
 #if (KVM_MAX_VCPUS > 8)
@@ -132,6 +133,7 @@ struct vgic_params {
 	unsigned int	maint_irq;
 	/* Virtual control interface base address */
 	void __iomem	*vctrl_base;
+	int		max_gic_vcpus;
 };
 
 struct vgic_vm_ops {
@@ -289,6 +291,7 @@ struct kvm_exit_mmio;
 int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr, bool write);
 int kvm_vgic_hyp_init(void);
 int kvm_vgic_map_resources(struct kvm *kvm);
+int kvm_vgic_get_max_vcpus(void);
 int kvm_vgic_create(struct kvm *kvm, u32 type);
 void kvm_vgic_destroy(struct kvm *kvm);
 void kvm_vgic_vcpu_destroy(struct kvm_vcpu *vcpu);
@@ -393,6 +396,11 @@ static inline bool vgic_ready(struct kvm *kvm)
 {
 	return true;
 }
+
+static inline int kvm_vgic_get_max_vcpus(void)
+{
+	return KVM_MAX_VCPUS;
+}
 #endif
 
 #endif

commit b26e5fdac43c1b7c394502917e42e3b91f3aa1a3
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Mon Jun 2 16:19:12 2014 +0200

    arm/arm64: KVM: introduce per-VM ops
    
    Currently we only have one virtual GIC model supported, so all guests
    use the same emulation code. With the addition of another model we
    end up with different guests using potentially different vGIC models,
    so we have to split up some functions to be per VM.
    Introduce a vgic_vm_ops struct to hold function pointers for those
    functions that are different and provide the necessary code to
    initialize them.
    Also split up the vgic_init() function to separate out VGIC model
    specific functionality into a separate function, which will later be
    different for a GICv3 model.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 525ce4228495..dd243969bfc3 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -134,6 +134,15 @@ struct vgic_params {
 	void __iomem	*vctrl_base;
 };
 
+struct vgic_vm_ops {
+	bool	(*handle_mmio)(struct kvm_vcpu *, struct kvm_run *,
+			       struct kvm_exit_mmio *);
+	bool	(*queue_sgi)(struct kvm_vcpu *, int irq);
+	void	(*add_sgi_source)(struct kvm_vcpu *, int irq, int source);
+	int	(*init_model)(struct kvm *);
+	int	(*map_resources)(struct kvm *, const struct vgic_params *);
+};
+
 struct vgic_dist {
 #ifdef CONFIG_KVM_ARM_VGIC
 	spinlock_t		lock;
@@ -215,6 +224,8 @@ struct vgic_dist {
 
 	/* Bitmap indicating which CPU has something pending */
 	unsigned long		*irq_pending_on_cpu;
+
+	struct vgic_vm_ops	vm_ops;
 #endif
 };
 

commit 59892136c40d6735e627dcea6a056380dfd6721d
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Tue Jun 3 09:33:10 2014 +0200

    arm/arm64: KVM: pass down user space provided GIC type into vGIC code
    
    With the introduction of a second emulated GIC model we need to let
    userspace specify the GIC model to use for each VM. Pass the
    userspace provided value down into the vGIC code and store it there
    to differentiate later.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Acked-by: Christoffer Dall <christoffer.dall@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index ac4888dc86bc..525ce4228495 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -140,6 +140,9 @@ struct vgic_dist {
 	bool			in_kernel;
 	bool			ready;
 
+	/* vGIC model the kernel emulates for the guest (GICv2 or GICv3) */
+	u32			vgic_model;
+
 	int			nr_cpus;
 	int			nr_irqs;
 
@@ -275,7 +278,7 @@ struct kvm_exit_mmio;
 int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr, bool write);
 int kvm_vgic_hyp_init(void);
 int kvm_vgic_map_resources(struct kvm *kvm);
-int kvm_vgic_create(struct kvm *kvm);
+int kvm_vgic_create(struct kvm *kvm, u32 type);
 void kvm_vgic_destroy(struct kvm *kvm);
 void kvm_vgic_vcpu_destroy(struct kvm_vcpu *vcpu);
 void kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu);
@@ -327,7 +330,7 @@ static inline int kvm_vgic_map_resources(struct kvm *kvm)
 	return 0;
 }
 
-static inline int kvm_vgic_create(struct kvm *kvm)
+static inline int kvm_vgic_create(struct kvm *kvm, u32 type)
 {
 	return 0;
 }

commit 1f57be289571d514b9412da2af25a64a81b8dd89
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Tue Dec 9 14:30:36 2014 +0100

    arm/arm64: KVM: Add (new) vgic_initialized macro
    
    Some code paths will need to check to see if the internal state of the
    vgic has been initialized (such as when creating new VCPUs), so
    introduce such a macro that checks the nr_cpus field which is set when
    the vgic has been initialized.
    
    Also set nr_cpus = 0 in kvm_vgic_destroy, because the error path in
    vgic_init() will call this function, and code should never errornously
    assume the vgic to be properly initialized after an error.
    
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Eric Auger <eric.auger@linaro.org>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 3e262b9bbddf..ac4888dc86bc 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -287,6 +287,7 @@ bool vgic_handle_mmio(struct kvm_vcpu *vcpu, struct kvm_run *run,
 		      struct kvm_exit_mmio *mmio);
 
 #define irqchip_in_kernel(k)	(!!((k)->arch.vgic.in_kernel))
+#define vgic_initialized(k)	(!!((k)->arch.vgic.nr_cpus))
 #define vgic_ready(k)		((k)->arch.vgic.ready)
 
 int vgic_v2_probe(struct device_node *vgic_node,
@@ -369,6 +370,11 @@ static inline int irqchip_in_kernel(struct kvm *kvm)
 	return 0;
 }
 
+static inline bool vgic_initialized(struct kvm *kvm)
+{
+	return true;
+}
+
 static inline bool vgic_ready(struct kvm *kvm)
 {
 	return true;

commit c52edf5f8caff878afc93c1b1e9a3d9490a9932f
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Tue Dec 9 14:28:09 2014 +0100

    arm/arm64: KVM: Rename vgic_initialized to vgic_ready
    
    The vgic_initialized() macro currently returns the state of the
    vgic->ready flag, which indicates if the vgic is ready to be used when
    running a VM, not specifically if its internal state has been
    initialized.
    
    Rename the macro accordingly in preparation for a more nuanced
    initialization flow.
    
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Eric Auger <eric.auger@linaro.org>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index fe9783ba924c..3e262b9bbddf 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -287,7 +287,7 @@ bool vgic_handle_mmio(struct kvm_vcpu *vcpu, struct kvm_run *run,
 		      struct kvm_exit_mmio *mmio);
 
 #define irqchip_in_kernel(k)	(!!((k)->arch.vgic.in_kernel))
-#define vgic_initialized(k)	((k)->arch.vgic.ready)
+#define vgic_ready(k)		((k)->arch.vgic.ready)
 
 int vgic_v2_probe(struct device_node *vgic_node,
 		  const struct vgic_ops **ops,
@@ -369,7 +369,7 @@ static inline int irqchip_in_kernel(struct kvm *kvm)
 	return 0;
 }
 
-static inline bool vgic_initialized(struct kvm *kvm)
+static inline bool vgic_ready(struct kvm *kvm)
 {
 	return true;
 }

commit 6d3cfbe21bef5b66530b50ad16c88fdc71a04c35
Author: Peter Maydell <peter.maydell@linaro.org>
Date:   Thu Dec 4 15:02:24 2014 +0000

    arm/arm64: KVM: vgic: move reset initialization into vgic_init_maps()
    
    VGIC initialization currently happens in three phases:
     (1) kvm_vgic_create() (triggered by userspace GIC creation)
     (2) vgic_init_maps() (triggered by userspace GIC register read/write
         requests, or from kvm_vgic_init() if not already run)
     (3) kvm_vgic_init() (triggered by first VM run)
    
    We were doing initialization of some state to correspond with the
    state of a freshly-reset GIC in kvm_vgic_init(); this is too late,
    since it will overwrite changes made by userspace using the
    register access APIs before the VM is run. Move this initialization
    earlier, into the vgic_init_maps() phase.
    
    This fixes a bug where QEMU could successfully restore a saved
    VM state snapshot into a VM that had already been run, but could
    not restore it "from cold" using the -loadvm command line option
    (the symptoms being that the restored VM would run but interrupts
    were ignored).
    
    Finally rename vgic_init_maps to vgic_init and renamed kvm_vgic_init to
    kvm_vgic_map_resources.
    
      [ This patch is originally written by Peter Maydell, but I have
        modified it somewhat heavily, renaming various bits and moving code
        around.  If something is broken, I am to be blamed. - Christoffer ]
    
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Eric Auger <eric.auger@linaro.org>
    Signed-off-by: Peter Maydell <peter.maydell@linaro.org>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 206dcc3b3f7a..fe9783ba924c 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -274,7 +274,7 @@ struct kvm_exit_mmio;
 #ifdef CONFIG_KVM_ARM_VGIC
 int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr, bool write);
 int kvm_vgic_hyp_init(void);
-int kvm_vgic_init(struct kvm *kvm);
+int kvm_vgic_map_resources(struct kvm *kvm);
 int kvm_vgic_create(struct kvm *kvm);
 void kvm_vgic_destroy(struct kvm *kvm);
 void kvm_vgic_vcpu_destroy(struct kvm_vcpu *vcpu);
@@ -321,7 +321,7 @@ static inline int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr,
 	return -ENXIO;
 }
 
-static inline int kvm_vgic_init(struct kvm *kvm)
+static inline int kvm_vgic_map_resources(struct kvm *kvm)
 {
 	return 0;
 }

commit 2df36a5dd6792870bef48f63bfca42055ea5b79c
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Sun Sep 28 16:04:26 2014 +0200

    arm/arm64: KVM: Fix BE accesses to GICv2 EISR and ELRSR regs
    
    The EIRSR and ELRSR registers are 32-bit registers on GICv2, and we
    store these as an array of two such registers on the vgic vcpu struct.
    However, we access them as a single 64-bit value or as a bitmap pointer
    in the generic vgic code, which breaks BE support.
    
    Instead, store them as u64 values on the vgic structure and do the
    word-swapping in the assembly code, which already handles the byte order
    for BE systems.
    
    Tested-by: Victor Kamensky <victor.kamensky@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index ec559d3264cc..206dcc3b3f7a 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -219,8 +219,8 @@ struct vgic_v2_cpu_if {
 	u32		vgic_hcr;
 	u32		vgic_vmcr;
 	u32		vgic_misr;	/* Saved only */
-	u32		vgic_eisr[2];	/* Saved only */
-	u32		vgic_elrsr[2];	/* Saved only */
+	u64		vgic_eisr;	/* Saved only */
+	u64		vgic_elrsr;	/* Saved only */
 	u32		vgic_apr;
 	u32		vgic_lr[VGIC_V2_MAX_LRS];
 };

commit b5e7a955a3515bf6b568050533fa9b1b72460a95
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Sep 30 13:38:20 2014 +0200

    ARM: KVM: fix vgic-disabled build
    
    The vgic code can be disabled in Kconfig and there are dummy implementations
    of most of the provided API functions for the disabled case.
    
    However, the newly introduced kvm_vgic_destroy/kvm_vgic_vcpu_destroy
    functions are lacking those dummies, resulting in this build error:
    
    arch/arm/kvm/arm.c: In function 'kvm_arch_destroy_vm':
    arch/arm/kvm/arm.c:165:2: error: implicit declaration of function 'kvm_vgic_destroy' [-Werror=implicit-function-declaration]
      kvm_vgic_destroy(kvm);
      ^
    arch/arm/kvm/arm.c: In function 'kvm_arch_vcpu_free':
    arch/arm/kvm/arm.c:248:2: error: implicit declaration of function 'kvm_vgic_vcpu_destroy' [-Werror=implicit-function-declaration]
      kvm_vgic_vcpu_destroy(vcpu);
      ^
    
    This adds two inline helpers to get it to build again in this configuration.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: c1bfb577add ("arm/arm64: KVM: vgic: switch to dynamic allocation")
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 2f2aac8448a4..ec559d3264cc 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -331,6 +331,14 @@ static inline int kvm_vgic_create(struct kvm *kvm)
 	return 0;
 }
 
+static inline void kvm_vgic_destroy(struct kvm *kvm)
+{
+}
+
+static inline void kvm_vgic_vcpu_destroy(struct kvm_vcpu *vcpu)
+{
+}
+
 static inline int kvm_vgic_vcpu_init(struct kvm_vcpu *vcpu)
 {
 	return 0;

commit 4956f2bc1fdee4bc336532f3f34635a8534cedfd
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jul 8 12:09:06 2014 +0100

    arm/arm64: KVM: vgic: delay vgic allocation until init time
    
    It is now quite easy to delay the allocation of the vgic tables
    until we actually require it to be up and running (when the first
    vcpu is kicking around, or someones tries to access the GIC registers).
    
    This allow us to allocate memory for the exact number of CPUs we
    have. As nobody configures the number of interrupts just yet,
    use a fallback to VGIC_NR_IRQS_LEGACY.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index aa20d4a7242f..2f2aac8448a4 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -277,7 +277,6 @@ int kvm_vgic_hyp_init(void);
 int kvm_vgic_init(struct kvm *kvm);
 int kvm_vgic_create(struct kvm *kvm);
 void kvm_vgic_destroy(struct kvm *kvm);
-int kvm_vgic_vcpu_init(struct kvm_vcpu *vcpu);
 void kvm_vgic_vcpu_destroy(struct kvm_vcpu *vcpu);
 void kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu);
 void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu);

commit 5fb66da64064d0cb8dcce4cc8bf4cb1b921b13a0
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jul 8 12:09:05 2014 +0100

    arm/arm64: KVM: vgic: kill VGIC_NR_IRQS
    
    Nuke VGIC_NR_IRQS entierly, now that the distributor instance
    contains the number of IRQ allocated to this GIC.
    
    Also add VGIC_NR_IRQS_LEGACY to preserve the current API.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 2767f939f47c..aa20d4a7242f 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -25,7 +25,7 @@
 #include <linux/spinlock.h>
 #include <linux/types.h>
 
-#define VGIC_NR_IRQS		256
+#define VGIC_NR_IRQS_LEGACY	256
 #define VGIC_NR_SGIS		16
 #define VGIC_NR_PPIS		16
 #define VGIC_NR_PRIVATE_IRQS	(VGIC_NR_SGIS + VGIC_NR_PPIS)
@@ -39,11 +39,11 @@
 #error	Invalid number of CPU interfaces
 #endif
 
-#if (VGIC_NR_IRQS & 31)
+#if (VGIC_NR_IRQS_LEGACY & 31)
 #error "VGIC_NR_IRQS must be a multiple of 32"
 #endif
 
-#if (VGIC_NR_IRQS > VGIC_MAX_IRQS)
+#if (VGIC_NR_IRQS_LEGACY > VGIC_MAX_IRQS)
 #error "VGIC_NR_IRQS must be <= 1024"
 #endif
 

commit c3c918361adcceb816c92b21dd95d2b46fb96a8f
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jul 8 12:09:04 2014 +0100

    arm/arm64: KVM: vgic: handle out-of-range MMIO accesses
    
    Now that we can (almost) dynamically size the number of interrupts,
    we're facing an interesting issue:
    
    We have to evaluate at runtime whether or not an access hits a valid
    register, based on the sizing of this particular instance of the
    distributor. Furthermore, the GIC spec says that accessing a reserved
    register is RAZ/WI.
    
    For this, add a new field to our range structure, indicating the number
    of bits a single interrupts uses. That allows us to find out whether or
    not the access is in range.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 3b73d7845124..2767f939f47c 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -32,6 +32,7 @@
 
 #define VGIC_V2_MAX_LRS		(1 << 6)
 #define VGIC_V3_MAX_LRS		16
+#define VGIC_MAX_IRQS		1024
 
 /* Sanity checks... */
 #if (KVM_MAX_VCPUS > 8)
@@ -42,7 +43,7 @@
 #error "VGIC_NR_IRQS must be a multiple of 32"
 #endif
 
-#if (VGIC_NR_IRQS > 1024)
+#if (VGIC_NR_IRQS > VGIC_MAX_IRQS)
 #error "VGIC_NR_IRQS must be <= 1024"
 #endif
 

commit fc675e355e705a046df7b635d3f3330c0ad94569
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jul 8 12:09:03 2014 +0100

    arm/arm64: KVM: vgic: kill VGIC_MAX_CPUS
    
    We now have the information about the number of CPU interfaces in
    the distributor itself. Let's get rid of VGIC_MAX_CPUS, and just
    rely on KVM_MAX_VCPUS where we don't have the choice. Yet.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index b2f9936df319..3b73d7845124 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -29,13 +29,12 @@
 #define VGIC_NR_SGIS		16
 #define VGIC_NR_PPIS		16
 #define VGIC_NR_PRIVATE_IRQS	(VGIC_NR_SGIS + VGIC_NR_PPIS)
-#define VGIC_MAX_CPUS		KVM_MAX_VCPUS
 
 #define VGIC_V2_MAX_LRS		(1 << 6)
 #define VGIC_V3_MAX_LRS		16
 
 /* Sanity checks... */
-#if (VGIC_MAX_CPUS > 8)
+#if (KVM_MAX_VCPUS > 8)
 #error	Invalid number of CPU interfaces
 #endif
 

commit fb65ab63b8cae510ea1e43e68b5da2f9980aa6d5
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jul 8 12:09:02 2014 +0100

    arm/arm64: KVM: vgic: Parametrize VGIC_NR_SHARED_IRQS
    
    Having a dynamic number of supported interrupts means that we
    cannot relly on VGIC_NR_SHARED_IRQS being fixed anymore.
    
    Instead, make it take the distributor structure as a parameter,
    so it can return the right value.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index fd1b8f252da1..b2f9936df319 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -29,7 +29,6 @@
 #define VGIC_NR_SGIS		16
 #define VGIC_NR_PPIS		16
 #define VGIC_NR_PRIVATE_IRQS	(VGIC_NR_SGIS + VGIC_NR_PPIS)
-#define VGIC_NR_SHARED_IRQS	(VGIC_NR_IRQS - VGIC_NR_PRIVATE_IRQS)
 #define VGIC_MAX_CPUS		KVM_MAX_VCPUS
 
 #define VGIC_V2_MAX_LRS		(1 << 6)

commit c1bfb577addd4867a82c4f235824a315d5afb94a
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jul 8 12:09:01 2014 +0100

    arm/arm64: KVM: vgic: switch to dynamic allocation
    
    So far, all the VGIC data structures are statically defined by the
    *maximum* number of vcpus and interrupts it supports. It means that
    we always have to oversize it to cater for the worse case.
    
    Start by changing the data structures to be dynamically sizeable,
    and allocate them at runtime.
    
    The sizes are still very static though.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index f074539c6ac5..fd1b8f252da1 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -54,19 +54,33 @@
  * - a bunch of shared interrupts (SPI)
  */
 struct vgic_bitmap {
-	union {
-		u32 reg[VGIC_NR_PRIVATE_IRQS / 32];
-		DECLARE_BITMAP(reg_ul, VGIC_NR_PRIVATE_IRQS);
-	} percpu[VGIC_MAX_CPUS];
-	union {
-		u32 reg[VGIC_NR_SHARED_IRQS / 32];
-		DECLARE_BITMAP(reg_ul, VGIC_NR_SHARED_IRQS);
-	} shared;
+	/*
+	 * - One UL per VCPU for private interrupts (assumes UL is at
+	 *   least 32 bits)
+	 * - As many UL as necessary for shared interrupts.
+	 *
+	 * The private interrupts are accessed via the "private"
+	 * field, one UL per vcpu (the state for vcpu n is in
+	 * private[n]). The shared interrupts are accessed via the
+	 * "shared" pointer (IRQn state is at bit n-32 in the bitmap).
+	 */
+	unsigned long *private;
+	unsigned long *shared;
 };
 
 struct vgic_bytemap {
-	u32 percpu[VGIC_MAX_CPUS][VGIC_NR_PRIVATE_IRQS / 4];
-	u32 shared[VGIC_NR_SHARED_IRQS  / 4];
+	/*
+	 * - 8 u32 per VCPU for private interrupts
+	 * - As many u32 as necessary for shared interrupts.
+	 *
+	 * The private interrupts are accessed via the "private"
+	 * field, (the state for vcpu n is in private[n*8] to
+	 * private[n*8 + 7]). The shared interrupts are accessed via
+	 * the "shared" pointer (IRQn state is at byte (n-32)%4 of the
+	 * shared[(n-32)/4] word).
+	 */
+	u32 *private;
+	u32 *shared;
 };
 
 struct kvm_vcpu;
@@ -127,6 +141,9 @@ struct vgic_dist {
 	bool			in_kernel;
 	bool			ready;
 
+	int			nr_cpus;
+	int			nr_irqs;
+
 	/* Virtual control interface mapping */
 	void __iomem		*vctrl_base;
 
@@ -166,15 +183,36 @@ struct vgic_dist {
 	/* Level/edge triggered */
 	struct vgic_bitmap	irq_cfg;
 
-	/* Source CPU per SGI and target CPU */
-	u8			irq_sgi_sources[VGIC_MAX_CPUS][VGIC_NR_SGIS];
+	/*
+	 * Source CPU per SGI and target CPU:
+	 *
+	 * Each byte represent a SGI observable on a VCPU, each bit of
+	 * this byte indicating if the corresponding VCPU has
+	 * generated this interrupt. This is a GICv2 feature only.
+	 *
+	 * For VCPUn (n < 8), irq_sgi_sources[n*16] to [n*16 + 15] are
+	 * the SGIs observable on VCPUn.
+	 */
+	u8			*irq_sgi_sources;
 
-	/* Target CPU for each IRQ */
-	u8			irq_spi_cpu[VGIC_NR_SHARED_IRQS];
-	struct vgic_bitmap	irq_spi_target[VGIC_MAX_CPUS];
+	/*
+	 * Target CPU for each SPI:
+	 *
+	 * Array of available SPI, each byte indicating the target
+	 * VCPU for SPI. IRQn (n >=32) is at irq_spi_cpu[n-32].
+	 */
+	u8			*irq_spi_cpu;
+
+	/*
+	 * Reverse lookup of irq_spi_cpu for faster compute pending:
+	 *
+	 * Array of bitmaps, one per VCPU, describing if IRQn is
+	 * routed to a particular VCPU.
+	 */
+	struct vgic_bitmap	*irq_spi_target;
 
 	/* Bitmap indicating which CPU has something pending */
-	unsigned long		irq_pending_on_cpu;
+	unsigned long		*irq_pending_on_cpu;
 #endif
 };
 
@@ -204,11 +242,11 @@ struct vgic_v3_cpu_if {
 struct vgic_cpu {
 #ifdef CONFIG_KVM_ARM_VGIC
 	/* per IRQ to LR mapping */
-	u8		vgic_irq_lr_map[VGIC_NR_IRQS];
+	u8		*vgic_irq_lr_map;
 
 	/* Pending interrupts on this VCPU */
 	DECLARE_BITMAP(	pending_percpu, VGIC_NR_PRIVATE_IRQS);
-	DECLARE_BITMAP(	pending_shared, VGIC_NR_SHARED_IRQS);
+	unsigned long	*pending_shared;
 
 	/* Bitmap of used/free list registers */
 	DECLARE_BITMAP(	lr_used, VGIC_V2_MAX_LRS);
@@ -239,7 +277,9 @@ int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr, bool write);
 int kvm_vgic_hyp_init(void);
 int kvm_vgic_init(struct kvm *kvm);
 int kvm_vgic_create(struct kvm *kvm);
+void kvm_vgic_destroy(struct kvm *kvm);
 int kvm_vgic_vcpu_init(struct kvm_vcpu *vcpu);
+void kvm_vgic_vcpu_destroy(struct kvm_vcpu *vcpu);
 void kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu);
 void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu);
 int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int irq_num,

commit faa1b46c3e9f4d40359aee04ff275eea5f4cae3a
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Sat Jun 14 21:54:51 2014 +0200

    arm/arm64: KVM: vgic: Improve handling of GICD_I{CS}PENDRn
    
    Writes to GICD_ISPENDRn and GICD_ICPENDRn are currently not handled
    correctly for level-triggered interrupts.  The spec states that for
    level-triggered interrupts, writes to the GICD_ISPENDRn activate the
    output of a flip-flop which is in turn or'ed with the actual input
    interrupt signal.  Correspondingly, writes to GICD_ICPENDRn simply
    deactivates the output of that flip-flop, but does not (of course) affect
    the external input signal.  Reads from GICC_IAR will also deactivate the
    flip-flop output.
    
    This requires us to track the state of the level-input separately from
    the state in the flip-flop.  We therefore introduce two new variables on
    the distributor struct to track these two states.  Astute readers may
    notice that this is introducing more state than required (because an OR
    of the two states gives you the pending state), but the remaining vgic
    code uses the pending bitmap for optimized operations to figure out, at
    the end of the day, if an interrupt is pending or not on the distributor
    side.  Refactoring the code to consider the two state variables all the
    places where we currently access the precomputed pending value, did not
    look pretty.
    
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 7d8e61fa9928..f074539c6ac5 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -140,9 +140,23 @@ struct vgic_dist {
 	/* Interrupt enabled (one bit per IRQ) */
 	struct vgic_bitmap	irq_enabled;
 
-	/* Interrupt state is pending on the distributor */
+	/* Level-triggered interrupt external input is asserted */
+	struct vgic_bitmap	irq_level;
+
+	/*
+	 * Interrupt state is pending on the distributor
+	 */
 	struct vgic_bitmap	irq_pending;
 
+	/*
+	 * Tracks writes to GICD_ISPENDRn and GICD_ICPENDRn for level-triggered
+	 * interrupts.  Essentially holds the state of the flip-flop in
+	 * Figure 4-10 on page 4-101 in ARM IHI 0048B.b.
+	 * Once set, it is only cleared for level-triggered interrupts on
+	 * guest ACKs (when we queue it) or writes to GICD_ICPENDRn.
+	 */
+	struct vgic_bitmap	irq_soft_pend;
+
 	/* Level-triggered interrupt queued on VCPU interface */
 	struct vgic_bitmap	irq_queued;
 

commit dbf20f9d8105cca531614c8bff9a74351e8e67e7
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Mon Jun 9 12:55:13 2014 +0200

    arm/arm64: KVM: Rename irq_active to irq_queued
    
    We have a special bitmap on the distributor struct to keep track of when
    level-triggered interrupts are queued on the list registers.  This was
    named irq_active, which is confusing, because the active state of an
    interrupt as per the GIC spec is a different thing, not specifically
    related to edge-triggered/level-triggered configurations but rather
    indicates an interrupt which has been ack'ed but not yet eoi'ed.
    
    Rename the bitmap and the corresponding accessor functions to irq_queued
    to clarify what this is actually used for.
    
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 388d442eecb5..7d8e61fa9928 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -143,8 +143,8 @@ struct vgic_dist {
 	/* Interrupt state is pending on the distributor */
 	struct vgic_bitmap	irq_pending;
 
-	/* Level-triggered interrupt in progress */
-	struct vgic_bitmap	irq_active;
+	/* Level-triggered interrupt queued on VCPU interface */
+	struct vgic_bitmap	irq_queued;
 
 	/* Interrupt priority. Not used yet. */
 	struct vgic_bytemap	irq_priority;

commit 227844f53864077ccaefe01d0960fcccc03445ce
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Mon Jun 9 12:27:18 2014 +0200

    arm/arm64: KVM: Rename irq_state to irq_pending
    
    The irq_state field on the distributor struct is ambiguous in its
    meaning; the comment says it's the level of the input put, but that
    doesn't make much sense for edge-triggered interrupts.  The code
    actually uses this state variable to check if the interrupt is in the
    pending state on the distributor so clarify the comment and rename the
    actual variable and accessor methods.
    
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 35b0c121bb65..388d442eecb5 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -140,8 +140,8 @@ struct vgic_dist {
 	/* Interrupt enabled (one bit per IRQ) */
 	struct vgic_bitmap	irq_enabled;
 
-	/* Interrupt 'pin' level */
-	struct vgic_bitmap	irq_state;
+	/* Interrupt state is pending on the distributor */
+	struct vgic_bitmap	irq_pending;
 
 	/* Level-triggered interrupt in progress */
 	struct vgic_bitmap	irq_active;

commit b2fb1c0d378399e1427a91bb991c094f2ca09a2f
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Jul 12 15:15:23 2013 +0100

    KVM: ARM: vgic: add the GICv3 backend
    
    Introduce the support code for emulating a GICv2 on top of GICv3
    hardware.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 65f1121a3beb..35b0c121bb65 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -33,6 +33,7 @@
 #define VGIC_MAX_CPUS		KVM_MAX_VCPUS
 
 #define VGIC_V2_MAX_LRS		(1 << 6)
+#define VGIC_V3_MAX_LRS		16
 
 /* Sanity checks... */
 #if (VGIC_MAX_CPUS > 8)
@@ -72,6 +73,7 @@ struct kvm_vcpu;
 
 enum vgic_type {
 	VGIC_V2,		/* Good ol' GICv2 */
+	VGIC_V3,		/* New fancy GICv3 */
 };
 
 #define LR_STATE_PENDING	(1 << 0)
@@ -172,6 +174,19 @@ struct vgic_v2_cpu_if {
 	u32		vgic_lr[VGIC_V2_MAX_LRS];
 };
 
+struct vgic_v3_cpu_if {
+#ifdef CONFIG_ARM_GIC_V3
+	u32		vgic_hcr;
+	u32		vgic_vmcr;
+	u32		vgic_misr;	/* Saved only */
+	u32		vgic_eisr;	/* Saved only */
+	u32		vgic_elrsr;	/* Saved only */
+	u32		vgic_ap0r[4];
+	u32		vgic_ap1r[4];
+	u64		vgic_lr[VGIC_V3_MAX_LRS];
+#endif
+};
+
 struct vgic_cpu {
 #ifdef CONFIG_KVM_ARM_VGIC
 	/* per IRQ to LR mapping */
@@ -190,6 +205,7 @@ struct vgic_cpu {
 	/* CPU vif control registers for world switch */
 	union {
 		struct vgic_v2_cpu_if	vgic_v2;
+		struct vgic_v3_cpu_if	vgic_v3;
 	};
 #endif
 };
@@ -224,6 +240,18 @@ bool vgic_handle_mmio(struct kvm_vcpu *vcpu, struct kvm_run *run,
 int vgic_v2_probe(struct device_node *vgic_node,
 		  const struct vgic_ops **ops,
 		  const struct vgic_params **params);
+#ifdef CONFIG_ARM_GIC_V3
+int vgic_v3_probe(struct device_node *vgic_node,
+		  const struct vgic_ops **ops,
+		  const struct vgic_params **params);
+#else
+static inline int vgic_v3_probe(struct device_node *vgic_node,
+				const struct vgic_ops **ops,
+				const struct vgic_params **params)
+{
+	return -ENODEV;
+}
+#endif
 
 #else
 static inline int kvm_vgic_hyp_init(void)

commit 1a9b13056dde7e3092304d6041ccc60a913042ea
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Jun 21 11:57:56 2013 +0100

    arm64: KVM: split GICv2 world switch from hyp code
    
    Move the GICv2 world switch code into its own file, and add the
    necessary indirection to the arm64 switch code.
    
    Also introduce a new type field to the vgic_params structure.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index f6b9fec6fcac..65f1121a3beb 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -24,7 +24,6 @@
 #include <linux/irqreturn.h>
 #include <linux/spinlock.h>
 #include <linux/types.h>
-#include <linux/irqchip/arm-gic.h>
 
 #define VGIC_NR_IRQS		256
 #define VGIC_NR_SGIS		16
@@ -71,6 +70,10 @@ struct vgic_bytemap {
 
 struct kvm_vcpu;
 
+enum vgic_type {
+	VGIC_V2,		/* Good ol' GICv2 */
+};
+
 #define LR_STATE_PENDING	(1 << 0)
 #define LR_STATE_ACTIVE		(1 << 1)
 #define LR_STATE_MASK		(3 << 0)
@@ -104,6 +107,8 @@ struct vgic_ops {
 };
 
 struct vgic_params {
+	/* vgic type */
+	enum vgic_type	type;
 	/* Physical address of vgic virtual cpu interface */
 	phys_addr_t	vcpu_base;
 	/* Number of list registers */

commit f982cf4e9c37b19478c7bc6e0484a43a7e78cf57
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu May 15 10:03:25 2014 +0100

    KVM: ARM: vgic: revisit implementation of irqchip_in_kernel
    
    So far, irqchip_in_kernel() was implemented by testing the value of
    vctrl_base, which worked fine with GICv2.
    
    With GICv3, this field is useless, as we're using system registers
    instead of a emmory mapped interface. To solve this, add a boolean
    flag indicating if the we're using a vgic or not.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index d8d52a9ca6a1..f6b9fec6fcac 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -117,6 +117,7 @@ struct vgic_params {
 struct vgic_dist {
 #ifdef CONFIG_KVM_ARM_VGIC
 	spinlock_t		lock;
+	bool			in_kernel;
 	bool			ready;
 
 	/* Virtual control interface mapping */
@@ -212,7 +213,7 @@ int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
 bool vgic_handle_mmio(struct kvm_vcpu *vcpu, struct kvm_run *run,
 		      struct kvm_exit_mmio *mmio);
 
-#define irqchip_in_kernel(k)	(!!((k)->arch.vgic.vctrl_base))
+#define irqchip_in_kernel(k)	(!!((k)->arch.vgic.in_kernel))
 #define vgic_initialized(k)	((k)->arch.vgic.ready)
 
 int vgic_v2_probe(struct device_node *vgic_node,

commit 8f186d522c69bb18dd9b93a634da4953228c67d4
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Feb 4 18:13:03 2014 +0000

    KVM: ARM: vgic: split GICv2 backend from the main vgic code
    
    Brutally hack the innocent vgic code, and move the GICv2 specific code
    to its own file, using vgic_ops and vgic_params as a way to pass
    information between the two blocks.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index ce2e14226dbf..d8d52a9ca6a1 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -32,7 +32,8 @@
 #define VGIC_NR_PRIVATE_IRQS	(VGIC_NR_SGIS + VGIC_NR_PPIS)
 #define VGIC_NR_SHARED_IRQS	(VGIC_NR_IRQS - VGIC_NR_PRIVATE_IRQS)
 #define VGIC_MAX_CPUS		KVM_MAX_VCPUS
-#define VGIC_MAX_LRS		(1 << 6)
+
+#define VGIC_V2_MAX_LRS		(1 << 6)
 
 /* Sanity checks... */
 #if (VGIC_MAX_CPUS > 8)
@@ -162,7 +163,7 @@ struct vgic_v2_cpu_if {
 	u32		vgic_eisr[2];	/* Saved only */
 	u32		vgic_elrsr[2];	/* Saved only */
 	u32		vgic_apr;
-	u32		vgic_lr[VGIC_MAX_LRS];
+	u32		vgic_lr[VGIC_V2_MAX_LRS];
 };
 
 struct vgic_cpu {
@@ -175,7 +176,7 @@ struct vgic_cpu {
 	DECLARE_BITMAP(	pending_shared, VGIC_NR_SHARED_IRQS);
 
 	/* Bitmap of used/free list registers */
-	DECLARE_BITMAP(	lr_used, VGIC_MAX_LRS);
+	DECLARE_BITMAP(	lr_used, VGIC_V2_MAX_LRS);
 
 	/* Number of list registers on this CPU */
 	int		nr_lr;
@@ -214,6 +215,10 @@ bool vgic_handle_mmio(struct kvm_vcpu *vcpu, struct kvm_run *run,
 #define irqchip_in_kernel(k)	(!!((k)->arch.vgic.vctrl_base))
 #define vgic_initialized(k)	((k)->arch.vgic.ready)
 
+int vgic_v2_probe(struct device_node *vgic_node,
+		  const struct vgic_ops **ops,
+		  const struct vgic_params **params);
+
 #else
 static inline int kvm_vgic_hyp_init(void)
 {

commit ca85f623e37d096206e092ef037a145a60fa7f85
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jun 18 19:17:28 2013 +0100

    KVM: ARM: introduce vgic_params structure
    
    Move all the data specific to a given GIC implementation into its own
    little structure.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 2228973ea8e4..ce2e14226dbf 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -102,6 +102,17 @@ struct vgic_ops {
 	void	(*enable)(struct kvm_vcpu *vcpu);
 };
 
+struct vgic_params {
+	/* Physical address of vgic virtual cpu interface */
+	phys_addr_t	vcpu_base;
+	/* Number of list registers */
+	u32		nr_lr;
+	/* Interrupt number */
+	unsigned int	maint_irq;
+	/* Virtual control interface base address */
+	void __iomem	*vctrl_base;
+};
+
 struct vgic_dist {
 #ifdef CONFIG_KVM_ARM_VGIC
 	spinlock_t		lock;

commit da8dafd1777cdd93091207952297d221a88e6479
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jun 4 11:36:38 2013 +0100

    KVM: ARM: vgic: introduce vgic_enable
    
    Move the code dealing with enabling the VGIC on to vgic_ops.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index f51580043170..2228973ea8e4 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -99,6 +99,7 @@ struct vgic_ops {
 	void	(*disable_underflow)(struct kvm_vcpu *vcpu);
 	void	(*get_vmcr)(struct kvm_vcpu *vcpu, struct vgic_vmcr *vmcr);
 	void	(*set_vmcr)(struct kvm_vcpu *vcpu, struct vgic_vmcr *vmcr);
+	void	(*enable)(struct kvm_vcpu *vcpu);
 };
 
 struct vgic_dist {

commit beee38b9d0c0ea6cf2a7f35c3108f7d8281d4545
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Feb 4 17:48:10 2014 +0000

    KVM: ARM: vgic: abstract VMCR access
    
    Instead of directly messing with with the GICH_VMCR bits for the CPU
    interface save/restore code, add accessors that encode/decode the
    entire set of registers exposed by VMCR.
    
    Not the most efficient thing, but given that this code is only used
    by the save/restore code, performance is far from being critical.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index cdfa5d9567c6..f51580043170 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -81,6 +81,13 @@ struct vgic_lr {
 	u8	state;
 };
 
+struct vgic_vmcr {
+	u32	ctlr;
+	u32	abpr;
+	u32	bpr;
+	u32	pmr;
+};
+
 struct vgic_ops {
 	struct vgic_lr	(*get_lr)(const struct kvm_vcpu *, int);
 	void	(*set_lr)(struct kvm_vcpu *, int, struct vgic_lr);
@@ -90,6 +97,8 @@ struct vgic_ops {
 	u32	(*get_interrupt_status)(const struct kvm_vcpu *vcpu);
 	void	(*enable_underflow)(struct kvm_vcpu *vcpu);
 	void	(*disable_underflow)(struct kvm_vcpu *vcpu);
+	void	(*get_vmcr)(struct kvm_vcpu *vcpu, struct vgic_vmcr *vmcr);
+	void	(*set_vmcr)(struct kvm_vcpu *vcpu, struct vgic_vmcr *vmcr);
 };
 
 struct vgic_dist {

commit 909d9b5025f149af6cfc304a76ad6218e6622cc0
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jun 4 11:24:17 2013 +0100

    KVM: ARM: vgic: move underflow handling to vgic_ops
    
    Move the code dealing with LR underflow handling to its own functions,
    and make them accessible through vgic_ops.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 4857508b12e7..cdfa5d9567c6 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -88,6 +88,8 @@ struct vgic_ops {
 	u64	(*get_elrsr)(const struct kvm_vcpu *vcpu);
 	u64	(*get_eisr)(const struct kvm_vcpu *vcpu);
 	u32	(*get_interrupt_status)(const struct kvm_vcpu *vcpu);
+	void	(*enable_underflow)(struct kvm_vcpu *vcpu);
+	void	(*disable_underflow)(struct kvm_vcpu *vcpu);
 };
 
 struct vgic_dist {

commit 495dd859f304689a7cd5ef413c439cb090dc25e6
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jun 4 11:02:10 2013 +0100

    KVM: ARM: vgic: abstract MISR decoding
    
    Instead of directly dealing with the GICH_MISR bits, move the code to
    its own function and use a couple of public flags to represent the
    actual state.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index ccb9b59818f4..4857508b12e7 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -87,6 +87,7 @@ struct vgic_ops {
 	void	(*sync_lr_elrsr)(struct kvm_vcpu *, int, struct vgic_lr);
 	u64	(*get_elrsr)(const struct kvm_vcpu *vcpu);
 	u64	(*get_eisr)(const struct kvm_vcpu *vcpu);
+	u32	(*get_interrupt_status)(const struct kvm_vcpu *vcpu);
 };
 
 struct vgic_dist {
@@ -165,6 +166,9 @@ struct vgic_cpu {
 
 #define LR_EMPTY	0xff
 
+#define INT_STATUS_EOI		(1 << 0)
+#define INT_STATUS_UNDERFLOW	(1 << 1)
+
 struct kvm;
 struct kvm_vcpu;
 struct kvm_run;

commit 8d6a0313c125c3c7b208b75695fe6ab00afab4c5
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jun 4 10:33:43 2013 +0100

    KVM: ARM: vgic: abstract EISR bitmap access
    
    Move the GICH_EISR access to its own function.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 38864f5e47bc..ccb9b59818f4 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -86,6 +86,7 @@ struct vgic_ops {
 	void	(*set_lr)(struct kvm_vcpu *, int, struct vgic_lr);
 	void	(*sync_lr_elrsr)(struct kvm_vcpu *, int, struct vgic_lr);
 	u64	(*get_elrsr)(const struct kvm_vcpu *vcpu);
+	u64	(*get_eisr)(const struct kvm_vcpu *vcpu);
 };
 
 struct vgic_dist {

commit 69bb2c9fbc11d9d4358fbb798db15c9092eb4d8c
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jun 4 10:29:39 2013 +0100

    KVM: ARM: vgic: abstract access to the ELRSR bitmap
    
    Move the GICH_ELRSR access to its own functions, and add them to
    the vgic_ops structure.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 17bbe51b79a1..38864f5e47bc 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -84,6 +84,8 @@ struct vgic_lr {
 struct vgic_ops {
 	struct vgic_lr	(*get_lr)(const struct kvm_vcpu *, int);
 	void	(*set_lr)(struct kvm_vcpu *, int, struct vgic_lr);
+	void	(*sync_lr_elrsr)(struct kvm_vcpu *, int, struct vgic_lr);
+	u64	(*get_elrsr)(const struct kvm_vcpu *vcpu);
 };
 
 struct vgic_dist {

commit 8d5c6b06a5d5f8ebcf40558e566781d572920740
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Jun 3 15:55:02 2013 +0100

    KVM: ARM: vgic: introduce vgic_ops and LR manipulation primitives
    
    In order to split the various register manipulation from the main vgic
    code, introduce a vgic_ops structure, and start by abstracting the
    LR manipulation code with a couple of accessors.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index f738e5a69ee9..17bbe51b79a1 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -68,6 +68,24 @@ struct vgic_bytemap {
 	u32 shared[VGIC_NR_SHARED_IRQS  / 4];
 };
 
+struct kvm_vcpu;
+
+#define LR_STATE_PENDING	(1 << 0)
+#define LR_STATE_ACTIVE		(1 << 1)
+#define LR_STATE_MASK		(3 << 0)
+#define LR_EOI_INT		(1 << 2)
+
+struct vgic_lr {
+	u16	irq;
+	u8	source;
+	u8	state;
+};
+
+struct vgic_ops {
+	struct vgic_lr	(*get_lr)(const struct kvm_vcpu *, int);
+	void	(*set_lr)(struct kvm_vcpu *, int, struct vgic_lr);
+};
+
 struct vgic_dist {
 #ifdef CONFIG_KVM_ARM_VGIC
 	spinlock_t		lock;

commit eede821dbfd58df89edb072da64e006321eaef58
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu May 30 10:20:36 2013 +0100

    KVM: arm/arm64: vgic: move GICv2 registers to their own structure
    
    In order to make way for the GICv3 registers, move the v2-specific
    registers to their own structure.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index f27000f55a83..f738e5a69ee9 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -110,6 +110,16 @@ struct vgic_dist {
 #endif
 };
 
+struct vgic_v2_cpu_if {
+	u32		vgic_hcr;
+	u32		vgic_vmcr;
+	u32		vgic_misr;	/* Saved only */
+	u32		vgic_eisr[2];	/* Saved only */
+	u32		vgic_elrsr[2];	/* Saved only */
+	u32		vgic_apr;
+	u32		vgic_lr[VGIC_MAX_LRS];
+};
+
 struct vgic_cpu {
 #ifdef CONFIG_KVM_ARM_VGIC
 	/* per IRQ to LR mapping */
@@ -126,13 +136,9 @@ struct vgic_cpu {
 	int		nr_lr;
 
 	/* CPU vif control registers for world switch */
-	u32		vgic_hcr;
-	u32		vgic_vmcr;
-	u32		vgic_misr;	/* Saved only */
-	u32		vgic_eisr[2];	/* Saved only */
-	u32		vgic_elrsr[2];	/* Saved only */
-	u32		vgic_apr;
-	u32		vgic_lr[VGIC_MAX_LRS];
+	union {
+		struct vgic_v2_cpu_if	vgic_v2;
+	};
 #endif
 };
 

commit 6cbde8253a8143ada18ec0d1711230747a7c1934
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu Mar 6 03:30:46 2014 +0000

    ARM: KVM: fix non-VGIC compilation
    
    Add a stub for kvm_vgic_addr when compiling without
    CONFIG_KVM_ARM_VGIC. The usefulness of this configurarion is extremely
    doubtful, but let's fix it anyway (until we decide that we'll always
    support a VGIC).
    
    Reported-by: Michele Paolino <m.paolino@virtualopensystems.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index be85127bfed3..f27000f55a83 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -171,6 +171,11 @@ static inline int kvm_vgic_set_addr(struct kvm *kvm, unsigned long type, u64 add
 	return 0;
 }
 
+static inline int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr, bool write)
+{
+	return -ENXIO;
+}
+
 static inline int kvm_vgic_init(struct kvm *kvm)
 {
 	return 0;

commit ce01e4e8874d410738f4b4733b26642d6611a331
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Mon Sep 23 14:55:56 2013 -0700

    KVM: arm-vgic: Set base addr through device API
    
    Support setting the distributor and cpu interface base addresses in the
    VM physical address space through the KVM_{SET,GET}_DEVICE_ATTR API
    in addition to the ARM specific API.
    
    This has the added benefit of being able to share more code in user
    space and do things in a uniform manner.
    
    Also deprecate the older API at the same time, but backwards
    compatibility will be maintained.
    
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 7e2d15837b02..be85127bfed3 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -144,7 +144,7 @@ struct kvm_run;
 struct kvm_exit_mmio;
 
 #ifdef CONFIG_KVM_ARM_VGIC
-int kvm_vgic_set_addr(struct kvm *kvm, unsigned long type, u64 addr);
+int kvm_vgic_addr(struct kvm *kvm, unsigned long type, u64 *addr, bool write);
 int kvm_vgic_hyp_init(void);
 int kvm_vgic_init(struct kvm *kvm);
 int kvm_vgic_create(struct kvm *kvm);

commit 9b2d2e0df8a49414b1e5bc89148c9984dd87782a
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Thu Aug 29 11:08:25 2013 +0100

    ARM: KVM: vgic: Bump VGIC_NR_IRQS to 256
    
    The Versatile Express TC2 board, which we use as our main emulated
    platform in QEMU, defines 160+32 == 192 interrupts, so limiting the
    number of interrupts to 128 is not quite going to cut it for real board
    emulation.
    
    Note that this didn't use to be a problem because QEMU was buggy and
    only defined 128 interrupts until recently.
    
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Gleb Natapov <gleb@redhat.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 343744e4809c..7e2d15837b02 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -26,7 +26,7 @@
 #include <linux/types.h>
 #include <linux/irqchip/arm-gic.h>
 
-#define VGIC_NR_IRQS		128
+#define VGIC_NR_IRQS		256
 #define VGIC_NR_SGIS		16
 #define VGIC_NR_PPIS		16
 #define VGIC_NR_PRIVATE_IRQS	(VGIC_NR_SGIS + VGIC_NR_PPIS)

commit 7275acdfe29ba03ad2f6e150386900c4e2d43fb1
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue May 14 14:31:01 2013 +0100

    ARM: KVM: move GIC/timer code to a common location
    
    As KVM/arm64 is looming on the horizon, it makes sense to move some
    of the common code to a single location in order to reduce duplication.
    
    The code could live anywhere. Actually, most of KVM is already built
    with a bunch of ugly ../../.. hacks in the various Makefiles, so we're
    not exactly talking about style here. But maybe it is time to start
    moving into a less ugly direction.
    
    The include files must be in a "public" location, as they are accessed
    from non-KVM files (arch/arm/kernel/asm-offsets.c).
    
    For this purpose, introduce two new locations:
    - virt/kvm/arm/ : x86 and ia64 already share the ioapic code in
      virt/kvm, so this could be seen as a (very ugly) precedent.
    - include/kvm/  : there is already an include/xen, and while the
      intent is slightly different, this seems as good a location as
      any
    
    Eventually, we should probably have independant Makefiles at every
    levels (just like everywhere else in the kernel), but this is just
    the first step.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Gleb Natapov <gleb@redhat.com>

diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
new file mode 100644
index 000000000000..343744e4809c
--- /dev/null
+++ b/include/kvm/arm_vgic.h
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2012 ARM Ltd.
+ * Author: Marc Zyngier <marc.zyngier@arm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARM_KVM_VGIC_H
+#define __ASM_ARM_KVM_VGIC_H
+
+#include <linux/kernel.h>
+#include <linux/kvm.h>
+#include <linux/irqreturn.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/irqchip/arm-gic.h>
+
+#define VGIC_NR_IRQS		128
+#define VGIC_NR_SGIS		16
+#define VGIC_NR_PPIS		16
+#define VGIC_NR_PRIVATE_IRQS	(VGIC_NR_SGIS + VGIC_NR_PPIS)
+#define VGIC_NR_SHARED_IRQS	(VGIC_NR_IRQS - VGIC_NR_PRIVATE_IRQS)
+#define VGIC_MAX_CPUS		KVM_MAX_VCPUS
+#define VGIC_MAX_LRS		(1 << 6)
+
+/* Sanity checks... */
+#if (VGIC_MAX_CPUS > 8)
+#error	Invalid number of CPU interfaces
+#endif
+
+#if (VGIC_NR_IRQS & 31)
+#error "VGIC_NR_IRQS must be a multiple of 32"
+#endif
+
+#if (VGIC_NR_IRQS > 1024)
+#error "VGIC_NR_IRQS must be <= 1024"
+#endif
+
+/*
+ * The GIC distributor registers describing interrupts have two parts:
+ * - 32 per-CPU interrupts (SGI + PPI)
+ * - a bunch of shared interrupts (SPI)
+ */
+struct vgic_bitmap {
+	union {
+		u32 reg[VGIC_NR_PRIVATE_IRQS / 32];
+		DECLARE_BITMAP(reg_ul, VGIC_NR_PRIVATE_IRQS);
+	} percpu[VGIC_MAX_CPUS];
+	union {
+		u32 reg[VGIC_NR_SHARED_IRQS / 32];
+		DECLARE_BITMAP(reg_ul, VGIC_NR_SHARED_IRQS);
+	} shared;
+};
+
+struct vgic_bytemap {
+	u32 percpu[VGIC_MAX_CPUS][VGIC_NR_PRIVATE_IRQS / 4];
+	u32 shared[VGIC_NR_SHARED_IRQS  / 4];
+};
+
+struct vgic_dist {
+#ifdef CONFIG_KVM_ARM_VGIC
+	spinlock_t		lock;
+	bool			ready;
+
+	/* Virtual control interface mapping */
+	void __iomem		*vctrl_base;
+
+	/* Distributor and vcpu interface mapping in the guest */
+	phys_addr_t		vgic_dist_base;
+	phys_addr_t		vgic_cpu_base;
+
+	/* Distributor enabled */
+	u32			enabled;
+
+	/* Interrupt enabled (one bit per IRQ) */
+	struct vgic_bitmap	irq_enabled;
+
+	/* Interrupt 'pin' level */
+	struct vgic_bitmap	irq_state;
+
+	/* Level-triggered interrupt in progress */
+	struct vgic_bitmap	irq_active;
+
+	/* Interrupt priority. Not used yet. */
+	struct vgic_bytemap	irq_priority;
+
+	/* Level/edge triggered */
+	struct vgic_bitmap	irq_cfg;
+
+	/* Source CPU per SGI and target CPU */
+	u8			irq_sgi_sources[VGIC_MAX_CPUS][VGIC_NR_SGIS];
+
+	/* Target CPU for each IRQ */
+	u8			irq_spi_cpu[VGIC_NR_SHARED_IRQS];
+	struct vgic_bitmap	irq_spi_target[VGIC_MAX_CPUS];
+
+	/* Bitmap indicating which CPU has something pending */
+	unsigned long		irq_pending_on_cpu;
+#endif
+};
+
+struct vgic_cpu {
+#ifdef CONFIG_KVM_ARM_VGIC
+	/* per IRQ to LR mapping */
+	u8		vgic_irq_lr_map[VGIC_NR_IRQS];
+
+	/* Pending interrupts on this VCPU */
+	DECLARE_BITMAP(	pending_percpu, VGIC_NR_PRIVATE_IRQS);
+	DECLARE_BITMAP(	pending_shared, VGIC_NR_SHARED_IRQS);
+
+	/* Bitmap of used/free list registers */
+	DECLARE_BITMAP(	lr_used, VGIC_MAX_LRS);
+
+	/* Number of list registers on this CPU */
+	int		nr_lr;
+
+	/* CPU vif control registers for world switch */
+	u32		vgic_hcr;
+	u32		vgic_vmcr;
+	u32		vgic_misr;	/* Saved only */
+	u32		vgic_eisr[2];	/* Saved only */
+	u32		vgic_elrsr[2];	/* Saved only */
+	u32		vgic_apr;
+	u32		vgic_lr[VGIC_MAX_LRS];
+#endif
+};
+
+#define LR_EMPTY	0xff
+
+struct kvm;
+struct kvm_vcpu;
+struct kvm_run;
+struct kvm_exit_mmio;
+
+#ifdef CONFIG_KVM_ARM_VGIC
+int kvm_vgic_set_addr(struct kvm *kvm, unsigned long type, u64 addr);
+int kvm_vgic_hyp_init(void);
+int kvm_vgic_init(struct kvm *kvm);
+int kvm_vgic_create(struct kvm *kvm);
+int kvm_vgic_vcpu_init(struct kvm_vcpu *vcpu);
+void kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu);
+void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu);
+int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int irq_num,
+			bool level);
+int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu);
+bool vgic_handle_mmio(struct kvm_vcpu *vcpu, struct kvm_run *run,
+		      struct kvm_exit_mmio *mmio);
+
+#define irqchip_in_kernel(k)	(!!((k)->arch.vgic.vctrl_base))
+#define vgic_initialized(k)	((k)->arch.vgic.ready)
+
+#else
+static inline int kvm_vgic_hyp_init(void)
+{
+	return 0;
+}
+
+static inline int kvm_vgic_set_addr(struct kvm *kvm, unsigned long type, u64 addr)
+{
+	return 0;
+}
+
+static inline int kvm_vgic_init(struct kvm *kvm)
+{
+	return 0;
+}
+
+static inline int kvm_vgic_create(struct kvm *kvm)
+{
+	return 0;
+}
+
+static inline int kvm_vgic_vcpu_init(struct kvm_vcpu *vcpu)
+{
+	return 0;
+}
+
+static inline void kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu) {}
+static inline void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu) {}
+
+static inline int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid,
+				      unsigned int irq_num, bool level)
+{
+	return 0;
+}
+
+static inline int kvm_vgic_vcpu_pending_irq(struct kvm_vcpu *vcpu)
+{
+	return 0;
+}
+
+static inline bool vgic_handle_mmio(struct kvm_vcpu *vcpu, struct kvm_run *run,
+				    struct kvm_exit_mmio *mmio)
+{
+	return false;
+}
+
+static inline int irqchip_in_kernel(struct kvm *kvm)
+{
+	return 0;
+}
+
+static inline bool vgic_initialized(struct kvm *kvm)
+{
+	return true;
+}
+#endif
+
+#endif
