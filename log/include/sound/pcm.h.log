commit 3c22baeab40b2f8e75907cfd7aa69147d5343d2c
Merge: aa21c3d4b941 1c521d7e6226
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 30 13:43:00 2020 +0200

    Merge tag 'asoc-v5.7' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v5.7
    
    This is a very big update for the core since Morimoto-san has been
    rather busy continuing his refactorings to clean up a lot of the cruft
    that we have accumilated over the years.  We've also gained several new
    drivers, including initial (but still not complete) parts of the Intel
    SoundWire support.
    
     - Lots of refactorings to modernize the code from Morimoto-san.
     - Conversion of SND_SOC_ALL_CODECS to use imply from Geert Uytterhoeven.
     - Continued refactoring and fixing of the Intel support.
     - Soundwire and more advanced clocking support for Realtek RT5682.
     - Support for amlogic GX, Meson 8, Meson 8B and T9015 DAC, Broadcom
       DSL/PON, Ingenic JZ4760 and JZ4770, Realtek RL6231, and TI TAS2563 and
       TLV320ADCX140.

commit 4769bfb9dada678b31a2ec275372624dbfeed9d1
Author: Samuel Holland <samuel@sholland.org>
Date:   Wed Mar 4 23:11:41 2020 -0600

    ALSA: pcm: Add a standalone version of snd_pcm_limit_hw_rates
    
    It can be useful to derive min/max rates of a snd_pcm_hardware without
    having a snd_pcm_runtime, such as before constructing an ASoC DAI link.
    
    Create a new helper that takes a pointer to a snd_pcm_hardware directly,
    and refactor the original function as a wrapper around it, to avoid
    needing to update any call sites.
    
    Signed-off-by: Samuel Holland <samuel@sholland.org>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Link: https://lore.kernel.org/r/20200305051143.60691-2-samuel@sholland.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 2628246b76fa..f7a95b711100 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1127,7 +1127,14 @@ snd_pcm_kernel_readv(struct snd_pcm_substream *substream,
 	return __snd_pcm_lib_xfer(substream, bufs, false, frames, true);
 }
 
-int snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime);
+int snd_pcm_hw_limit_rates(struct snd_pcm_hardware *hw);
+
+static inline int
+snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime)
+{
+	return snd_pcm_hw_limit_rates(&runtime->hw);
+}
+
 unsigned int snd_pcm_rate_to_rate_bit(unsigned int rate);
 unsigned int snd_pcm_rate_bit_to_rate(unsigned int rate_bit);
 unsigned int snd_pcm_rate_mask_intersect(unsigned int rates_a,

commit 3193abd26b515ccac65e1c323533cb7f53d06176
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Feb 17 17:28:19 2020 +0900

    ALSA: pcm.h: add for_each_pcm_streams()
    
    ALSA code has SNDRV_PCM_STREAM_PLAYBACK/CAPTURE everywhere.
    Having for_each_xxxx macro is useful.
    This patch adds for_each_pcm_streams() for it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Link: https://lore.kernel.org/r/874kvpbotq.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index f657ff08f317..2628246b76fa 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -644,6 +644,11 @@ void snd_pcm_stream_unlock_irqrestore(struct snd_pcm_substream *substream,
 #define snd_pcm_group_for_each_entry(s, substream) \
 	list_for_each_entry(s, &substream->group->substreams, link_list)
 
+#define for_each_pcm_streams(stream)			\
+	for (stream  = SNDRV_PCM_STREAM_PLAYBACK;	\
+	     stream <= SNDRV_PCM_STREAM_LAST;		\
+	     stream++)
+
 /**
  * snd_pcm_running - Check whether the substream is in a running state
  * @substream: substream to check

commit b9c7d41087bc1755e01f9584f0bdbce0bb8b195d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 6 17:39:39 2020 +0100

    ALSA: pcm: More helper macros for reducing snd_pcm_format_t cast
    
    snd_pcm_format_t is a strong-typed integer and requires the explicit
    cast with __force if converted or compared with a normal integer
    value.  Since most of use cases do iterate over all formats and test /
    set the mask, provide a couple of new helper macros that do the
    explicit cast.
    
    Link: https://lore.kernel.org/r/20200206163945.6797-3-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index f657ff08f317..31a4b300e4c9 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1415,6 +1415,15 @@ static inline u64 pcm_format_to_bits(snd_pcm_format_t pcm_format)
 	return 1ULL << (__force int) pcm_format;
 }
 
+/**
+ * pcm_for_each_format - helper to iterate for each format type
+ * @f: the iterator variable in snd_pcm_format_t type
+ */
+#define pcm_for_each_format(f)						\
+	for ((f) = SNDRV_PCM_FORMAT_FIRST;				\
+	     (__force int)(f) <= (__force int)SNDRV_PCM_FORMAT_LAST;	\
+	     (f) = (__force snd_pcm_format_t)((__force int)(f) + 1))
+
 /* printk helpers */
 #define pcm_err(pcm, fmt, args...) \
 	dev_err((pcm)->card->dev, fmt, ##args)

commit cb639a420e2e74dba5432e8ebcfb3559ce925148
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 31 16:22:14 2020 +0100

    ALSA: pcm: Fix sparse warnings wrt snd_pcm_state_t
    
    Since we have a bitwise definition of snd_pcm_state_t and use it for
    certain struct fields, a few new (and years old) sparse warnings came
    up.  This patch is an attempt to cover them.
    
    - The state fields in snd_pcm_mmap_status* and co are all defined as
      snd_pcm_state_t type now
    
    - The PCM action callbacks take snd_pcm_state_t argument as well;
      some actions taking special values got the explicit cast and
      comments
    
    - For the PCM action that doesn't need an extra argument receives
      ACTION_ARG_IGNORE instead of ambiguous 0
    
    While we're at it, the boolean argument is also properly changed to
    bool and true/false, as well as a slight refactoring of PCM pause
    helper function to make easier to read.
    
    No functional changes, just shutting up chatty sparse.
    
    Fixes: 46b770f720bd ("ALSA: uapi: Fix sparse warning")
    Reported-by: kbuild test robot <lkp@intel.com>
    Link: https://lore.kernel.org/r/20200131152214.11698-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 5a31525e2df6..f657ff08f317 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1450,7 +1450,7 @@ struct snd_pcm_status64 {
 #define SNDRV_PCM_IOCTL_STATUS_EXT64	_IOWR('A', 0x24, struct snd_pcm_status64)
 
 struct snd_pcm_status32 {
-	s32 state;		/* stream state */
+	snd_pcm_state_t state;		/* stream state */
 	s32 trigger_tstamp_sec;	/* time when stream was started/stopped/paused */
 	s32 trigger_tstamp_nsec;
 	s32 tstamp_sec;		/* reference timestamp */
@@ -1461,7 +1461,7 @@ struct snd_pcm_status32 {
 	u32 avail;		/* number of frames available */
 	u32 avail_max;		/* max frames available on hw since last status */
 	u32 overrange;		/* count of ADC (capture) overrange detections from last status */
-	s32 suspended_state;	/* suspended stream state */
+	snd_pcm_state_t suspended_state;	/* suspended stream state */
 	u32 audio_tstamp_data;	/* needed for 64-bit alignment, used for configs/report to/from userspace */
 	s32 audio_tstamp_sec;	/* sample counter, wall clock, PHC or on-demand sync'ed */
 	s32 audio_tstamp_nsec;

commit 3ddee7f88aaf2dee38f7016ac8fd48dd9fdb43e3
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Tue Apr 24 20:06:11 2018 +0800

    ALSA: Avoid using timespec for struct snd_pcm_status
    
    The struct snd_pcm_status will use 'timespec' type variables to record
    timestamp, which is not year 2038 safe on 32bits system.
    
    Userspace will use SNDRV_PCM_IOCTL_STATUS and SNDRV_PCM_IOCTL_STATUS_EXT
    as commands to issue ioctl() to fill the 'snd_pcm_status' structure in
    userspace. The command number is always defined through _IOR/_IOW/IORW,
    so when userspace changes the definition of 'struct timespec' to use
    64-bit types, the command number also changes.
    
    Thus in the kernel, we now need to define two versions of each such ioctl
    and corresponding ioctl commands to handle 32bit time_t and 64bit time_t
    in native mode:
    struct snd_pcm_status32 {
            ......
    
            s32 trigger_tstamp_sec;
            s32 trigger_tstamp_nsec;
    
            ......
    
            s32 audio_tstamp_sec;
            s32 audio_tstamp_nsec;
    
            ......
    };
    
    struct snd_pcm_status64 {
            ......
    
            s32 trigger_tstamp_sec;
            s32 trigger_tstamp_nsec;
    
            ......
    
            s32 audio_tstamp_sec;
            s32 audio_tstamp_nsec;
    
            ......
    };
    
    Moreover in compat file, we renamed or introduced new structures to handle
    32bit/64bit time_t in compatible mode. The 'struct snd_pcm_status32' and
    snd_pcm_status_user32() are used to handle 32bit time_t in compat mode.
    'struct compat_snd_pcm_status64' and snd_pcm_status_user_compat64() are used
    to handle 64bit time_t.
    
    The implicit padding before timespec is made explicit to avoid incompatible
    structure layout between 32-bit and 64-bit x86 due to the different
    alignment requirements, and the snd_pcm_status structure is now hidden
    from the kernel to avoid relying on the timespec definitio definitionn
    
    Finally we can replace SNDRV_PCM_IOCTL_STATUS and SNDRV_PCM_IOCTL_STATUS_EXT
    with new commands and introduce new functions to fill new 'struct snd_pcm_status64'
    instead of using unsafe 'struct snd_pcm_status'. Then in future, the new
    commands can be matched when userspace changes 'timespec' to 64bit type
    to make a size change of 'struct snd_pcm_status'. When glibc changes time_t
    to 64-bit, any recompiled program will issue ioctl commands that the kernel
    does not understand without this patch.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index cb407fade933..5a31525e2df6 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -44,6 +44,7 @@ struct snd_pcm_hardware {
 	size_t fifo_size;		/* fifo size in bytes */
 };
 
+struct snd_pcm_status64;
 struct snd_pcm_substream;
 
 struct snd_pcm_audio_tstamp_config; /* definitions further down */
@@ -558,8 +559,8 @@ int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree);
 int snd_pcm_info(struct snd_pcm_substream *substream, struct snd_pcm_info *info);
 int snd_pcm_info_user(struct snd_pcm_substream *substream,
 		      struct snd_pcm_info __user *info);
-int snd_pcm_status(struct snd_pcm_substream *substream,
-		   struct snd_pcm_status *status);
+int snd_pcm_status64(struct snd_pcm_substream *substream,
+		     struct snd_pcm_status64 *status);
 int snd_pcm_start(struct snd_pcm_substream *substream);
 int snd_pcm_stop(struct snd_pcm_substream *substream, snd_pcm_state_t status);
 int snd_pcm_drain_done(struct snd_pcm_substream *substream);
@@ -1422,4 +1423,55 @@ static inline u64 pcm_format_to_bits(snd_pcm_format_t pcm_format)
 #define pcm_dbg(pcm, fmt, args...) \
 	dev_dbg((pcm)->card->dev, fmt, ##args)
 
+struct snd_pcm_status64 {
+	snd_pcm_state_t state;		/* stream state */
+	u8 rsvd[4];
+	s64 trigger_tstamp_sec;		/* time when stream was started/stopped/paused */
+	s64 trigger_tstamp_nsec;
+	s64 tstamp_sec;			/* reference timestamp */
+	s64 tstamp_nsec;
+	snd_pcm_uframes_t appl_ptr;	/* appl ptr */
+	snd_pcm_uframes_t hw_ptr;	/* hw ptr */
+	snd_pcm_sframes_t delay;	/* current delay in frames */
+	snd_pcm_uframes_t avail;	/* number of frames available */
+	snd_pcm_uframes_t avail_max;	/* max frames available on hw since last status */
+	snd_pcm_uframes_t overrange;	/* count of ADC (capture) overrange detections from last status */
+	snd_pcm_state_t suspended_state; /* suspended stream state */
+	__u32 audio_tstamp_data;	 /* needed for 64-bit alignment, used for configs/report to/from userspace */
+	s64 audio_tstamp_sec;		/* sample counter, wall clock, PHC or on-demand sync'ed */
+	s64 audio_tstamp_nsec;
+	s64 driver_tstamp_sec;		/* useful in case reference system tstamp is reported with delay */
+	s64 driver_tstamp_nsec;
+	__u32 audio_tstamp_accuracy;	/* in ns units, only valid if indicated in audio_tstamp_data */
+	unsigned char reserved[52-4*sizeof(s64)]; /* must be filled with zero */
+};
+
+#define SNDRV_PCM_IOCTL_STATUS64	_IOR('A', 0x20, struct snd_pcm_status64)
+#define SNDRV_PCM_IOCTL_STATUS_EXT64	_IOWR('A', 0x24, struct snd_pcm_status64)
+
+struct snd_pcm_status32 {
+	s32 state;		/* stream state */
+	s32 trigger_tstamp_sec;	/* time when stream was started/stopped/paused */
+	s32 trigger_tstamp_nsec;
+	s32 tstamp_sec;		/* reference timestamp */
+	s32 tstamp_nsec;
+	u32 appl_ptr;		/* appl ptr */
+	u32 hw_ptr;		/* hw ptr */
+	s32 delay;		/* current delay in frames */
+	u32 avail;		/* number of frames available */
+	u32 avail_max;		/* max frames available on hw since last status */
+	u32 overrange;		/* count of ADC (capture) overrange detections from last status */
+	s32 suspended_state;	/* suspended stream state */
+	u32 audio_tstamp_data;	/* needed for 64-bit alignment, used for configs/report to/from userspace */
+	s32 audio_tstamp_sec;	/* sample counter, wall clock, PHC or on-demand sync'ed */
+	s32 audio_tstamp_nsec;
+	s32 driver_tstamp_sec;	/* useful in case reference system tstamp is reported with delay */
+	s32 driver_tstamp_nsec;
+	u32 audio_tstamp_accuracy;	/* in ns units, only valid if indicated in audio_tstamp_data */
+	unsigned char reserved[52-4*sizeof(s32)]; /* must be filled with zero */
+};
+
+#define SNDRV_PCM_IOCTL_STATUS32	_IOR('A', 0x20, struct snd_pcm_status32)
+#define SNDRV_PCM_IOCTL_STATUS_EXT32	_IOWR('A', 0x24, struct snd_pcm_status32)
+
 #endif /* __SOUND_PCM_H */

commit fcae40c99fb3d09f4407f549a7f17761abe5e1bc
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Tue Apr 24 20:06:08 2018 +0800

    ALSA: Replace timespec with timespec64
    
    Since timespec is not year 2038 safe on 32bit system, and we need to
    convert all timespec variables to timespec64 type for sound subsystem.
    
    This patch is used to do preparation for following patches, that will
    convert all structures defined in uapi/sound/asound.h to use 64-bit
    time_t.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 8a89fa6fdd5e..cb407fade933 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -62,7 +62,7 @@ struct snd_pcm_ops {
 	int (*sync_stop)(struct snd_pcm_substream *substream);
 	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream);
 	int (*get_time_info)(struct snd_pcm_substream *substream,
-			struct timespec *system_ts, struct timespec *audio_ts,
+			struct timespec64 *system_ts, struct timespec64 *audio_ts,
 			struct snd_pcm_audio_tstamp_config *audio_tstamp_config,
 			struct snd_pcm_audio_tstamp_report *audio_tstamp_report);
 	int (*fill_silence)(struct snd_pcm_substream *substream, int channel,
@@ -343,7 +343,7 @@ static inline void snd_pcm_pack_audio_tstamp_report(__u32 *data, __u32 *accuracy
 struct snd_pcm_runtime {
 	/* -- Status -- */
 	struct snd_pcm_substream *trigger_master;
-	struct timespec trigger_tstamp;	/* trigger timestamp */
+	struct timespec64 trigger_tstamp;	/* trigger timestamp */
 	bool trigger_tstamp_latched;     /* trigger timestamp latched in low-level driver/hardware */
 	int overrange;
 	snd_pcm_uframes_t avail_max;
@@ -421,7 +421,7 @@ struct snd_pcm_runtime {
 	/* -- audio timestamp config -- */
 	struct snd_pcm_audio_tstamp_config audio_tstamp_config;
 	struct snd_pcm_audio_tstamp_report audio_tstamp_report;
-	struct timespec driver_tstamp;
+	struct timespec64 driver_tstamp;
 
 #if IS_ENABLED(CONFIG_SND_PCM_OSS)
 	/* -- OSS things -- */
@@ -1155,22 +1155,22 @@ static inline void snd_pcm_set_runtime_buffer(struct snd_pcm_substream *substrea
 }
 
 /**
- * snd_pcm_gettime - Fill the timespec depending on the timestamp mode
+ * snd_pcm_gettime - Fill the timespec64 depending on the timestamp mode
  * @runtime: PCM runtime instance
- * @tv: timespec to fill
+ * @tv: timespec64 to fill
  */
 static inline void snd_pcm_gettime(struct snd_pcm_runtime *runtime,
-				   struct timespec *tv)
+				   struct timespec64 *tv)
 {
 	switch (runtime->tstamp_type) {
 	case SNDRV_PCM_TSTAMP_TYPE_MONOTONIC:
-		ktime_get_ts(tv);
+		ktime_get_ts64(tv);
 		break;
 	case SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW:
-		getrawmonotonic(tv);
+		ktime_get_raw_ts64(tv);
 		break;
 	default:
-		getnstimeofday(tv);
+		ktime_get_real_ts64(tv);
 		break;
 	}
 }

commit 1e850beea2781d30418743dd99250291cef37919
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Nov 17 09:53:06 2019 +0100

    ALSA: pcm: Add the support for sync-stop operation
    
    The standard programming model of a PCM sound driver is to process
    snd_pcm_period_elapsed() from an interrupt handler.  When a running
    stream is stopped, PCM core calls the trigger-STOP PCM ops, sets the
    stream state to SETUP, and moves on to the next step.  This is
    performed in an atomic manner -- this could be called from the interrupt
    context, after all.
    
    The problem is that, if the stream goes further and reaches to the
    CLOSE state immediately, the stream might be still being processed in
    snd_pcm_period_elapsed() in the interrupt context, and hits a NULL
    dereference.  Such a crash happens because of the atomic operation,
    and we can't wait until the stream-stop finishes.
    
    For addressing such a problem, this commit adds a new PCM ops,
    sync_stop.  This gets called at the appropriate places that need a
    sync with the stream-stop, i.e. at hw_params, prepare and hw_free.
    
    Some drivers already have a similar mechanism implemented locally, and
    we'll refactor the code later.
    
    Link: https://lore.kernel.org/r/20191117085308.23915-7-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 25563317782c..8a89fa6fdd5e 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -59,6 +59,7 @@ struct snd_pcm_ops {
 	int (*hw_free)(struct snd_pcm_substream *substream);
 	int (*prepare)(struct snd_pcm_substream *substream);
 	int (*trigger)(struct snd_pcm_substream *substream, int cmd);
+	int (*sync_stop)(struct snd_pcm_substream *substream);
 	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream);
 	int (*get_time_info)(struct snd_pcm_substream *substream,
 			struct timespec *system_ts, struct timespec *audio_ts,
@@ -395,6 +396,7 @@ struct snd_pcm_runtime {
 	wait_queue_head_t sleep;	/* poll sleep */
 	wait_queue_head_t tsleep;	/* transfer sleep */
 	struct fasync_struct *fasync;
+	bool stop_operating;		/* sync_stop will be called */
 
 	/* -- private section -- */
 	void *private_data;

commit 0821fd77a1129cf4848d82d9275fb4e90e02edf8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Nov 17 11:05:12 2019 +0100

    ALSA: pcm: Move PCM_RUNTIME_CHECK() macro into local header
    
    It should be used only in the PCM core code locally.
    
    Link: https://lore.kernel.org/r/20191117085308.23915-6-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 253d15c61ce2..25563317782c 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1336,8 +1336,6 @@ static inline void snd_pcm_limit_isa_dma_size(int dma, size_t *max)
 					 (IEC958_AES1_CON_PCM_CODER<<8)|\
 					 (IEC958_AES3_CON_FS_48000<<24))
 
-#define PCM_RUNTIME_CHECK(sub) snd_BUG_ON(!(sub) || !(sub)->runtime)
-
 const char *snd_pcm_format_name(snd_pcm_format_t format);
 
 /**

commit 0dba808eae2627f40024872d2f02f75f0d2b0790
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Nov 17 09:53:01 2019 +0100

    ALSA: pcm: Introduce managed buffer allocation mode
    
    This patch adds the support for the feature to automatically allocate
    and free PCM buffers, so called "managed buffer allocation" mode.
    It's set up via new PCM helpers, snd_pcm_set_managed_buffer() and
    snd_pcm_set_managed_buffer_all(), both of which correspond to the
    existing preallocator helpers, snd_pcm_lib_preallocate_pages() and
    snd_pcm_lib_preallocate_pages_for_all().  When the new helper is used,
    it not only performs the pre-allocation of buffers, but also it
    manages to call snd_pcm_lib_malloc_pages() before the PCM hw_params
    ops and snd_lib_pcm_free() after the PCM hw_free ops inside PCM core,
    respectively.  This allows drivers to drop the explicit calls of the
    memory allocation / release functions, and it will be a good amount of
    code reduction in the end of this patch series.
    
    When the PCM substream is set to the managed buffer allocation mode,
    the managed_buffer_alloc flag is set in the substream object.  Since
    some drivers want to know when a buffer is newly allocated or
    re-allocated at hw_params callback (e.g. want to set up the additional
    stuff for the given buffer only at allocation time), now PCM core
    turns on buffer_changed flag when the buffer has changed.
    
    The standard conversions to use the new API will be straightforward:
    - Replace snd_pcm_lib_preallocate*() calls with the corresponding
      snd_pcm_set_managed_buffer*(); the arguments should be unchanged
    - Drop superfluous snd_pcm_lib_malloc() and snd_pcm_lib_free() calls;
      the check of snd_pcm_lib_malloc() returns should be replaced with
      the check of runtime->buffer_changed flag.
    - If hw_params or hw_free becomes empty, drop them from PCM ops
    
    Link: https://lore.kernel.org/r/20191117085308.23915-2-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 2c0aa884f5f1..253d15c61ce2 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -414,6 +414,7 @@ struct snd_pcm_runtime {
 	size_t dma_bytes;		/* size of DMA area */
 
 	struct snd_dma_buffer *dma_buffer_p;	/* allocated buffer */
+	unsigned int buffer_changed:1;	/* buffer allocation changed; set only in managed mode */
 
 	/* -- audio timestamp config -- */
 	struct snd_pcm_audio_tstamp_config audio_tstamp_config;
@@ -475,6 +476,7 @@ struct snd_pcm_substream {
 #endif /* CONFIG_SND_VERBOSE_PROCFS */
 	/* misc flags */
 	unsigned int hw_opened: 1;
+	unsigned int managed_buffer_alloc:1;
 };
 
 #define SUBSTREAM_BUSY(substream) ((substream)->ref_count > 0)
@@ -1186,6 +1188,12 @@ void snd_pcm_lib_preallocate_pages_for_all(struct snd_pcm *pcm,
 int snd_pcm_lib_malloc_pages(struct snd_pcm_substream *substream, size_t size);
 int snd_pcm_lib_free_pages(struct snd_pcm_substream *substream);
 
+void snd_pcm_set_managed_buffer(struct snd_pcm_substream *substream, int type,
+				struct device *data, size_t size, size_t max);
+void snd_pcm_set_managed_buffer_all(struct snd_pcm *pcm, int type,
+				    struct device *data,
+				    size_t size, size_t max);
+
 int _snd_pcm_lib_alloc_vmalloc_buffer(struct snd_pcm_substream *substream,
 				      size_t size, gfp_t gfp_flags);
 int snd_pcm_lib_free_vmalloc_buffer(struct snd_pcm_substream *substream);

commit fc7af6bc2707e32d73c639d63f1543d890a00db4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 8 10:46:41 2019 +0100

    ALSA: pcm: Unexport snd_pcm_sgbuf_ops_page
    
    The helper is no longer referred after the recent code refactoring.
    Drop the export for saving some bits and future misuse.
    
    Acked-by: Mark Brown <broonie@kernel.org>
    Link: https://lore.kernel.org/r/20191108094641.20086-9-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index bbe6eb1ff5d2..2c0aa884f5f1 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1236,14 +1236,6 @@ static inline int snd_pcm_lib_alloc_vmalloc_32_buffer
  */
 #define snd_pcm_substream_sgbuf(substream) \
 	snd_pcm_get_dma_buf(substream)->private_data
-
-struct page *snd_pcm_sgbuf_ops_page(struct snd_pcm_substream *substream,
-				    unsigned long offset);
-#else /* !SND_DMA_SGBUF */
-/*
- * fake using a continuous buffer
- */
-#define snd_pcm_sgbuf_ops_page	NULL
 #endif /* SND_DMA_SGBUF */
 
 /**

commit 4cc4531c310e592cf624148ae59c64f930f12e39
Author: Vidyakumar Athota <vathota@codeaurora.org>
Date:   Thu Aug 22 10:56:50 2019 +0100

    ALSA: pcm: add support for 352.8KHz and 384KHz sample rate
    
    Most of the modern codecs supports 352.8KHz and 384KHz sample rates.
    Currenlty HW params fails to set 352.8Kz and 384KHz sample rate
    as these are not in known rates list.
    Add these new rates to known list to allow them.
    
    This patch also adds defines in pcm.h so that drivers can use it.
    
    Signed-off-by: Vidyakumar Athota <vathota@codeaurora.org>
    Signed-off-by: Banajit Goswami <bgoswami@codeaurora.org>
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Link: https://lore.kernel.org/r/20190822095653.7200-2-srinivas.kandagatla@linaro.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 1e9bb1c91770..bbe6eb1ff5d2 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -117,6 +117,8 @@ struct snd_pcm_ops {
 #define SNDRV_PCM_RATE_96000		(1<<10)		/* 96000Hz */
 #define SNDRV_PCM_RATE_176400		(1<<11)		/* 176400Hz */
 #define SNDRV_PCM_RATE_192000		(1<<12)		/* 192000Hz */
+#define SNDRV_PCM_RATE_352800		(1<<13)		/* 352800Hz */
+#define SNDRV_PCM_RATE_384000		(1<<14)		/* 384000Hz */
 
 #define SNDRV_PCM_RATE_CONTINUOUS	(1<<30)		/* continuous range */
 #define SNDRV_PCM_RATE_KNOT		(1<<31)		/* supports more non-continuos rates */
@@ -129,6 +131,9 @@ struct snd_pcm_ops {
 					 SNDRV_PCM_RATE_88200|SNDRV_PCM_RATE_96000)
 #define SNDRV_PCM_RATE_8000_192000	(SNDRV_PCM_RATE_8000_96000|SNDRV_PCM_RATE_176400|\
 					 SNDRV_PCM_RATE_192000)
+#define SNDRV_PCM_RATE_8000_384000	(SNDRV_PCM_RATE_8000_192000|\
+					 SNDRV_PCM_RATE_352800|\
+					 SNDRV_PCM_RATE_384000)
 #define _SNDRV_PCM_FMTBIT(fmt)		(1ULL << (__force int)SNDRV_PCM_FORMAT_##fmt)
 #define SNDRV_PCM_FMTBIT_S8		_SNDRV_PCM_FMTBIT(S8)
 #define SNDRV_PCM_FMTBIT_U8		_SNDRV_PCM_FMTBIT(U8)

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 18bd8c3ea605..1e9bb1c91770 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 #ifndef __SOUND_PCM_H
 #define __SOUND_PCM_H
 
@@ -5,22 +6,6 @@
  *  Digital Audio (PCM) abstract layer
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *                   Abramo Bagnara <abramo@alsa-project.org>
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <sound/asound.h>

commit c24a1269652006b401bda29fea15a0e42b7870d1
Author: Ricardo Biehl Pasquali <pasqualirb@gmail.com>
Date:   Wed Mar 13 16:06:48 2019 -0300

    ALSA: pcm: Fix function name in kernel-doc comment
    
    Signed-off-by: Ricardo Biehl Pasquali <pasqualirb@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 465d7d033c4c..18bd8c3ea605 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -750,7 +750,7 @@ static inline snd_pcm_uframes_t snd_pcm_playback_avail(struct snd_pcm_runtime *r
 }
 
 /**
- * snd_pcm_playback_avail - Get the available (readable) space for capture
+ * snd_pcm_capture_avail - Get the available (readable) space for capture
  * @runtime: PCM runtime instance
  *
  * Result is between 0 ... (boundary - 1)

commit bb580602f3924976d8bc36c171266de73e92cbf7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:42:24 2019 +0100

    ALSA: pcm: Define snd_pcm_lib_preallocate_*() as returning void
    
    Now all callers no longer check the return value from
    snd_pcm_lib_preallocate_pages() and co, let's make them to return
    void, so that any new code won't fall into the same pitfall.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index ca20f80f8976..465d7d033c4c 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1185,12 +1185,12 @@ static inline void snd_pcm_gettime(struct snd_pcm_runtime *runtime,
  *  Memory
  */
 
-int snd_pcm_lib_preallocate_free(struct snd_pcm_substream *substream);
-int snd_pcm_lib_preallocate_free_for_all(struct snd_pcm *pcm);
-int snd_pcm_lib_preallocate_pages(struct snd_pcm_substream *substream,
+void snd_pcm_lib_preallocate_free(struct snd_pcm_substream *substream);
+void snd_pcm_lib_preallocate_free_for_all(struct snd_pcm *pcm);
+void snd_pcm_lib_preallocate_pages(struct snd_pcm_substream *substream,
 				  int type, struct device *data,
 				  size_t size, size_t max);
-int snd_pcm_lib_preallocate_pages_for_all(struct snd_pcm *pcm,
+void snd_pcm_lib_preallocate_pages_for_all(struct snd_pcm *pcm,
 					  int type, void *data,
 					  size_t size, size_t max);
 int snd_pcm_lib_malloc_pages(struct snd_pcm_substream *substream, size_t size);

commit 205d6bcf9bb896903248cd8d600f23cf4d3886d2
Merge: 3a55437141a1 ef2056b8f394
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 24 14:46:17 2019 +0100

    Merge branch 'topic/pcm-lock-refactor' into for-next
    
    Pull PCM lock refactoring.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 480e32ebd524ffdf3d50cc5cac179fb9e44a552d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 23 16:44:38 2019 +0100

    ALSA: pcm: Simplify proc file destruction
    
    The proc files are recursively freed by calling with the root
    snd_info_entry object, so we don't have to keep each object for
    releasing one by one.  Move the release of the PCM stream proc root at
    the beginning, so that we can remove the redundant code and resource.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index a20d3a48df00..eae6d2b82d7a 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -481,15 +481,6 @@ struct snd_pcm_substream {
 #endif
 #ifdef CONFIG_SND_VERBOSE_PROCFS
 	struct snd_info_entry *proc_root;
-	struct snd_info_entry *proc_info_entry;
-	struct snd_info_entry *proc_hw_params_entry;
-	struct snd_info_entry *proc_sw_params_entry;
-	struct snd_info_entry *proc_status_entry;
-	struct snd_info_entry *proc_prealloc_entry;
-	struct snd_info_entry *proc_prealloc_max_entry;
-#ifdef CONFIG_SND_PCM_XRUN_DEBUG
-	struct snd_info_entry *proc_xrun_injection_entry;
-#endif
 #endif /* CONFIG_SND_VERBOSE_PROCFS */
 	/* misc flags */
 	unsigned int hw_opened: 1;
@@ -511,10 +502,8 @@ struct snd_pcm_str {
 #endif
 #ifdef CONFIG_SND_VERBOSE_PROCFS
 	struct snd_info_entry *proc_root;
-	struct snd_info_entry *proc_info_entry;
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
 	unsigned int xrun_debug;	/* 0 = disabled, 1 = verbose, 2 = stacktrace */
-	struct snd_info_entry *proc_xrun_debug_entry;
 #endif
 #endif
 	struct snd_kcontrol *chmap_kctl; /* channel-mapping controls */

commit de89750c56f4bf2f04492c6ce298911381a7597a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 23 12:47:34 2019 +0100

    ALSA: pcm: Drop unused snd_pcm_substream.file field
    
    It's assigned but nowhere used.  Let's remove it.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 2c30c1ad1b0d..a20d3a48df00 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -470,7 +470,6 @@ struct snd_pcm_substream {
 	struct snd_pcm_group self_group;	/* fake group for non linked substream (with substream lock inside) */
 	struct snd_pcm_group *group;		/* pointer to current group */
 	/* -- assigned files -- */
-	void *file;
 	int ref_count;
 	atomic_t mmap_count;
 	unsigned int f_flags;

commit f57f3df03a8e6010e321fa0258d3e054713c3cb7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 13 09:50:33 2019 +0100

    ALSA: pcm: More fine-grained PCM link locking
    
    We have currently two global locks, a rwlock and a rwsem, that are
    used for managing linking the PCM streams.  Due to these global locks,
    once when a linked stream is used, the lock granularity suffers a
    lot.
    
    This patch attempts to eliminate the former global lock for atomic
    ops.  The latter rwsem needs remaining because of the loosy way of the
    loop calls in snd_pcm_action_nonatomic(), as well as for avoiding the
    deadlock at linking.  However, these are used far rarely, actually
    only by two actions (prepare and  reset), where both are no timing
    critical ones.  So this can be still seen as a good improvement.
    
    The basic strategy to eliminate the rwlock is to assure group->lock at
    adding or removing a stream to / from the group.  Since we already
    takes the group lock whenever taking the all substream locks under the
    group, this shouldn't be a big problem.  The reference to group
    pointer in snd_pcm_substream object is protected by the stream lock
    itself.
    
    However, there are still pitfalls: a race window at re-locking and the
    lifecycle of group object.  The former is a small race window for
    dereferencing the substream group object opened while snd_pcm_action()
    performs re-locking to avoid ABBA deadlocks.  This includes the unlink
    of group during that window, too.  And the latter is the kfree
    performed after all streams are removed from the group while it's
    still dereferenced.
    
    For addressing these corner cases, two new tricks are introduced:
    - After re-locking, the group assigned to the stream is checked again;
      if the group is changed, we retry the whole procedure.
    - Introduce a refcount to snd_pcm_group object, so that it's freed
      only when it's empty and really no one refers to it.
    
    (Some readers might wonder why not RCU for the latter.  RCU in this
    case would cost more than refcounting, unfortunately.  We take the
    group lock sooner or later, hence the performance improvement by RCU
    would be negligible.  Meanwhile, because we need to deal with
    schedulable context depending on the pcm->nonatomic flag, it'll become
    dynamic RCU/SRCU switch, and the grace period may become too long.)
    
    Along with these changes, there are a significant amount of code
    refactoring.  The complex group re-lock & ref code is factored out to
    snd_pcm_stream_group_ref() function, for example.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index e1c747c70883..3bde24575a99 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -30,6 +30,7 @@
 #include <linux/mm.h>
 #include <linux/bitops.h>
 #include <linux/pm_qos.h>
+#include <linux/refcount.h>
 
 #define snd_pcm_substream_chip(substream) ((substream)->private_data)
 #define snd_pcm_chip(pcm) ((pcm)->private_data)
@@ -439,6 +440,7 @@ struct snd_pcm_group {		/* keep linked substreams */
 	spinlock_t lock;
 	struct mutex mutex;
 	struct list_head substreams;
+	refcount_t refs;
 };
 
 struct pid;

commit a41c4cb913b53bf74f1ec66a4b96057626c87009
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 13 09:40:21 2019 +0100

    ALSA: pcm: Make PCM linked list consistent while re-grouping
    
    Make a common helper to re-assign the PCM link using list_move() instead
    of open code with manual list_del() and list_add_tail().  This assures
    the consistency and we can get rid of snd_pcm_group.count field -- its
    purpose is only to check whether the list is singular, and we can know
    it by list_is_singular() call now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index d6bd3caf6878..e1c747c70883 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -439,7 +439,6 @@ struct snd_pcm_group {		/* keep linked substreams */
 	spinlock_t lock;
 	struct mutex mutex;
 	struct list_head substreams;
-	int count;
 };
 
 struct pid;

commit ce7f93e2bd6f649980846914e4a04ad6ba141fa6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 15 10:54:02 2019 +0100

    ALSA: pcm: Make snd_pcm_suspend() local static
    
    snd_pcm_suspend() is no longer called from outside, so let's make it
    local static.  Also drop a superfluous NULL check there.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 04e97564949c..2c30c1ad1b0d 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -582,13 +582,8 @@ int snd_pcm_stop(struct snd_pcm_substream *substream, snd_pcm_state_t status);
 int snd_pcm_drain_done(struct snd_pcm_substream *substream);
 int snd_pcm_stop_xrun(struct snd_pcm_substream *substream);
 #ifdef CONFIG_PM
-int snd_pcm_suspend(struct snd_pcm_substream *substream);
 int snd_pcm_suspend_all(struct snd_pcm *pcm);
 #else
-static inline int snd_pcm_suspend(struct snd_pcm_substream *substream)
-{
-	return 0;
-}
 static inline int snd_pcm_suspend_all(struct snd_pcm *pcm)
 {
 	return 0;

commit 3d21ef0b49f84d3341984caafc5c658739674927
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 15:58:39 2019 +0100

    ALSA: pcm: Suspend streams globally via device type PM ops
    
    Until now we rely on each driver calling snd_pcm_suspend*() explicitly
    at its own PM handling.  However, this can be done far more easily by
    setting the PM ops to each actual snd_pcm device object.
    
    This patch adds the device_type object for PCM stream and assigns to
    each PCM stream object.  The type contains only the PM ops for system
    suspend; we don't need to deal with the resume in general.
    
    The suspend hook simply calls snd_pcm_suspend_all() for the given PCM
    streams.  This implies that the PM order is correctly put, i.e. PCM is
    suspended before the main (or codec) driver, which should be true in
    general.  If a special ordering is needed, you'd need to adjust the
    device PM order manually later.
    
    This patch introduces a new flag, snd_pcm.no_device_suspend, too.
    With this flag set, the PCM device object won't invoke
    snd_pcm_suspend_all() by itself.  This is needed for ASoC who wants to
    manage the PM call orders in its serialized way, and the flag is set
    in soc_new_pcm() as default.
    
    For the non-ASoC world, we can get rid of the manual snd_pcm_suspend
    calls.  This will be done in the later patches.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index d6bd3caf6878..04e97564949c 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -538,6 +538,7 @@ struct snd_pcm {
 	void (*private_free) (struct snd_pcm *pcm);
 	bool internal; /* pcm is for internal use only */
 	bool nonatomic; /* whole PCM operations are in non-atomic context */
+	bool no_device_suspend; /* don't invoke device PM suspend */
 #if IS_ENABLED(CONFIG_SND_PCM_OSS)
 	struct snd_pcm_oss oss;
 #endif

commit 95a48b7d4459948b6bacf809809cf01a7dc06d1d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 25 23:00:54 2018 +0200

    ALSA: pcm: Add __force to cast in snd_pcm_lib_read/write()
    
    The snd_pcm_lib_read() and snd_pcm_lib_write() inline functions have
    the explicit cast from a user pointer to a kernel pointer, but they
    lacks of __force prefix.
    
    This fixes sparse warnings like:
      ./include/sound/pcm.h:1093:47: warning: cast removes address space of expression
    
    Fixes: 68541213720d ("ALSA: pcm: Direct in-kernel read/write support")
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 1206045ccf03..d6bd3caf6878 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1090,14 +1090,14 @@ static inline snd_pcm_sframes_t
 snd_pcm_lib_write(struct snd_pcm_substream *substream,
 		  const void __user *buf, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, (void *)buf, true, frames, false);
+	return __snd_pcm_lib_xfer(substream, (void __force *)buf, true, frames, false);
 }
 
 static inline snd_pcm_sframes_t
 snd_pcm_lib_read(struct snd_pcm_substream *substream,
 		 void __user *buf, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, (void *)buf, true, frames, false);
+	return __snd_pcm_lib_xfer(substream, (void __force *)buf, true, frames, false);
 }
 
 static inline snd_pcm_sframes_t

commit fa84cf094ef9667e2b91c104b0a788fd1896f482
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 18 07:40:53 2018 +0200

    ALSA: pcm: Nuke snd_pcm_lib_mmap_vmalloc()
    
    snd_pcm_lib_mmap_vmalloc() was supposed to be implemented with
    somewhat special for vmalloc handling, but in the end, this turned to
    just the default handler, i.e. NULL.  As the situation has never
    changed over decades, let's rip it off.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index fcdf358a25f0..1206045ccf03 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1342,8 +1342,6 @@ int snd_pcm_lib_mmap_iomem(struct snd_pcm_substream *substream, struct vm_area_s
 #define snd_pcm_lib_mmap_iomem	NULL
 #endif
 
-#define snd_pcm_lib_mmap_vmalloc NULL
-
 /**
  * snd_pcm_limit_isa_dma_size - Get the max size fitting with ISA DMA transfer
  * @dma: DMA number

commit d64c5cf8e89d124355924c513a42b16f0d7d3a03
Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date:   Fri Jul 6 13:50:36 2018 +0100

    ALSA: pcm: Allow drivers to set R/W wait time.
    
    Currently ALSA core blocks userspace for about 10 seconds for PCM R/W IO.
    This needs to be configurable for modern hardware like DSPs where no
    pointer update in milliseconds can indicate terminal DSP errors.
    
    Add a substream variable to set the wait time in ms. This allows userspace
    and drivers to recover more quickly from terminal DSP errors.
    
    Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index e054c583d3b3..fcdf358a25f0 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -462,6 +462,7 @@ struct snd_pcm_substream {
         /* -- timer section -- */
 	struct snd_timer *timer;		/* timer */
 	unsigned timer_running: 1;	/* time is running */
+	long wait_time;	/* time in ms for R/W to wait for avail */
 	/* -- next substream -- */
 	struct snd_pcm_substream *next;
 	/* -- linked substreams -- */

commit 823dbb6eb08a2865bcd236b4f52b1b9de216418a
Author: Maciej S. Szmigiero <mail@maciej.szmigiero.name>
Date:   Mon Nov 27 23:33:29 2017 +0100

    ALSA: pcm: add SNDRV_PCM_FORMAT_{S,U}20
    
    This format is similar to existing SNDRV_PCM_FORMAT_{S,U}20_3 that keep
    20-bit PCM samples in 3 bytes, however i.MX6 platform SSI FIFO does not
    allow 3-byte accesses (including DMA) so a 4-byte (more conventional)
    format is needed for it.
    
    Signed-off-by: Maciej S. Szmigiero <mail@maciej.szmigiero.name>
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 24febf9e177c..e054c583d3b3 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -169,6 +169,10 @@ struct snd_pcm_ops {
 #define SNDRV_PCM_FMTBIT_IMA_ADPCM	_SNDRV_PCM_FMTBIT(IMA_ADPCM)
 #define SNDRV_PCM_FMTBIT_MPEG		_SNDRV_PCM_FMTBIT(MPEG)
 #define SNDRV_PCM_FMTBIT_GSM		_SNDRV_PCM_FMTBIT(GSM)
+#define SNDRV_PCM_FMTBIT_S20_LE	_SNDRV_PCM_FMTBIT(S20_LE)
+#define SNDRV_PCM_FMTBIT_U20_LE	_SNDRV_PCM_FMTBIT(U20_LE)
+#define SNDRV_PCM_FMTBIT_S20_BE	_SNDRV_PCM_FMTBIT(S20_BE)
+#define SNDRV_PCM_FMTBIT_U20_BE	_SNDRV_PCM_FMTBIT(U20_BE)
 #define SNDRV_PCM_FMTBIT_SPECIAL	_SNDRV_PCM_FMTBIT(SPECIAL)
 #define SNDRV_PCM_FMTBIT_S24_3LE	_SNDRV_PCM_FMTBIT(S24_3LE)
 #define SNDRV_PCM_FMTBIT_U24_3LE	_SNDRV_PCM_FMTBIT(U24_3LE)
@@ -202,6 +206,8 @@ struct snd_pcm_ops {
 #define SNDRV_PCM_FMTBIT_FLOAT		SNDRV_PCM_FMTBIT_FLOAT_LE
 #define SNDRV_PCM_FMTBIT_FLOAT64	SNDRV_PCM_FMTBIT_FLOAT64_LE
 #define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE
+#define SNDRV_PCM_FMTBIT_S20		SNDRV_PCM_FMTBIT_S20_LE
+#define SNDRV_PCM_FMTBIT_U20		SNDRV_PCM_FMTBIT_U20_LE
 #endif
 #ifdef SNDRV_BIG_ENDIAN
 #define SNDRV_PCM_FMTBIT_S16		SNDRV_PCM_FMTBIT_S16_BE
@@ -213,6 +219,8 @@ struct snd_pcm_ops {
 #define SNDRV_PCM_FMTBIT_FLOAT		SNDRV_PCM_FMTBIT_FLOAT_BE
 #define SNDRV_PCM_FMTBIT_FLOAT64	SNDRV_PCM_FMTBIT_FLOAT64_BE
 #define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_BE
+#define SNDRV_PCM_FMTBIT_S20		SNDRV_PCM_FMTBIT_S20_BE
+#define SNDRV_PCM_FMTBIT_U20		SNDRV_PCM_FMTBIT_U20_BE
 #endif
 
 struct snd_pcm_file {

commit 4b671f57747468d7c810caaf955f79ff1aece4d4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jun 19 23:11:54 2017 +0200

    ALSA: pcm: Add an ioctl to specify the supported protocol version
    
    We have an ioctl to inform the PCM protocol version the running kernel
    supports, but there is no way to know which protocol version the
    user-space can understand.  This lack of information caused headaches
    in the past when we tried to extend the ABI.  For example, because we
    couldn't guarantee the validity of the reserved bytes, we had to
    introduce a new ioctl SNDRV_PCM_IOCTL_STATUS_EXT for assigning a few
    new fields in the formerly reserved bits.  If we could know that it's
    a new alsa-lib, we could assume the availability of the new fields,
    thus we could have reused the existing SNDRV_PCM_IOCTL_STATUS.
    
    In order to improve the ABI extensibility, this patch adds a new ioctl
    for user-space to inform its supporting protocol version to the
    kernel.  By reporting the supported protocol from user-space, the
    kernel can judge which feature should be provided and which not.
    
    With the addition of the new ioctl, the PCM protocol version is bumped
    to 2.0.14, too.  User-space checks the kernel protocol version via
    SNDRV_PCM_INFO_PVERSION, then it sets the supported version back via
    SNDRV_PCM_INFO_USER_PVERSION.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 5a22075c5fcf..24febf9e177c 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -218,6 +218,7 @@ struct snd_pcm_ops {
 struct snd_pcm_file {
 	struct snd_pcm_substream *substream;
 	int no_compat_mmap;
+	unsigned int user_pversion;	/* supported protocol version */
 };
 
 struct snd_pcm_hw_rule;

commit ba61faf0d75df9537393b2b796df41c30dcfcce7
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 14 19:30:04 2017 +0900

    ALSA: pcm: remove SNDRV_PCM_IOCTL1_GSTATE internal command
    
    SNDRV_PCM_IOCTL1_GSTATE was firstly introduced in v0.9.0, however never
    be used and the purpose is missing.
    
    This commit removes the long-abandoned command, bye.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 48e3eecac86d..5a22075c5fcf 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -104,7 +104,7 @@ struct snd_pcm_ops {
 #define SNDRV_PCM_IOCTL1_RESET		0
 /* 1 is absent slot. */
 #define SNDRV_PCM_IOCTL1_CHANNEL_INFO	2
-#define SNDRV_PCM_IOCTL1_GSTATE		3
+/* 3 is absent slot. */
 #define SNDRV_PCM_IOCTL1_FIFO_SIZE	4
 
 #define SNDRV_PCM_TRIGGER_STOP		0

commit e11f0f90a626f93899687b1cc909ee37dd6c5809
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 14 19:30:03 2017 +0900

    ALSA: pcm: remove SNDRV_PCM_IOCTL1_INFO internal command
    
    Drivers can implement 'struct snd_pcm_ops.ioctl' to handle some requests
    from ALSA PCM core. These requests are internal purpose in kernel land.
    Usually common set of operations are used for it.
    
    SNDRV_PCM_IOCTL1_INFO is one of the requests. According to code comment,
    it has been obsoleted in the old days.
    
    We can see old releases in ftp.alsa-project.org. The command was firstly
    introduced in v0.5.0 release as SND_PCM_IOCTL1_INFO, to allow drivers to
    fill data of 'struct snd_pcm_channel_info' type. In v0.9.0 release,
    this was obsoleted by the other commands for ioctl(2) such as
    SNDRV_PCM_IOCTL_CHANNEL_INFO.
    
    This commit removes the long-abandoned command, bye.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index c24f85f12b71..48e3eecac86d 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -102,7 +102,7 @@ struct snd_pcm_ops {
 #endif
 
 #define SNDRV_PCM_IOCTL1_RESET		0
-#define SNDRV_PCM_IOCTL1_INFO		1
+/* 1 is absent slot. */
 #define SNDRV_PCM_IOCTL1_CHANNEL_INFO	2
 #define SNDRV_PCM_IOCTL1_GSTATE		3
 #define SNDRV_PCM_IOCTL1_FIFO_SIZE	4

commit 68541213720df9bb7904cc1fecab563d424849ae
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 24 18:23:20 2017 +0200

    ALSA: pcm: Direct in-kernel read/write support
    
    Now all materials are ready, let's allow the direct in-kernel
    read/write, i.e. a kernel-space buffer is passed for read or write,
    instead of the normal user-space buffer.  This feature is used by OSS
    layer and UAC1 driver, for example.
    
    The __snd_pcm_lib_xfer() takes in_kernel argument that indicates the
    in-kernel buffer copy.  When this flag is set, another transfer code
    is used.  It's either via copy_kernel PCM ops or the normal memcpy(),
    depending on the driver setup.
    
    As external API, snd_pcm_kernel_read(), *_write() and other variants
    are provided.
    
    That's all.  This support is really simple because of the code
    refactoring until now.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index db649083c76d..c24f85f12b71 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1074,34 +1074,62 @@ int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,
 void snd_pcm_period_elapsed(struct snd_pcm_substream *substream);
 snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 				     void *buf, bool interleaved,
-				     snd_pcm_uframes_t frames);
+				     snd_pcm_uframes_t frames, bool in_kernel);
 
 static inline snd_pcm_sframes_t
 snd_pcm_lib_write(struct snd_pcm_substream *substream,
 		  const void __user *buf, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, (void *)buf, true, frames);
+	return __snd_pcm_lib_xfer(substream, (void *)buf, true, frames, false);
 }
 
 static inline snd_pcm_sframes_t
 snd_pcm_lib_read(struct snd_pcm_substream *substream,
 		 void __user *buf, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, (void *)buf, true, frames);
+	return __snd_pcm_lib_xfer(substream, (void *)buf, true, frames, false);
 }
 
 static inline snd_pcm_sframes_t
 snd_pcm_lib_writev(struct snd_pcm_substream *substream,
 		   void __user **bufs, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames);
+	return __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames, false);
 }
 
 static inline snd_pcm_sframes_t
 snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 		  void __user **bufs, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames);
+	return __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames, false);
+}
+
+static inline snd_pcm_sframes_t
+snd_pcm_kernel_write(struct snd_pcm_substream *substream,
+		     const void *buf, snd_pcm_uframes_t frames)
+{
+	return __snd_pcm_lib_xfer(substream, (void *)buf, true, frames, true);
+}
+
+static inline snd_pcm_sframes_t
+snd_pcm_kernel_read(struct snd_pcm_substream *substream,
+		    void *buf, snd_pcm_uframes_t frames)
+{
+	return __snd_pcm_lib_xfer(substream, buf, true, frames, true);
+}
+
+static inline snd_pcm_sframes_t
+snd_pcm_kernel_writev(struct snd_pcm_substream *substream,
+		      void **bufs, snd_pcm_uframes_t frames)
+{
+	return __snd_pcm_lib_xfer(substream, bufs, false, frames, true);
+}
+
+static inline snd_pcm_sframes_t
+snd_pcm_kernel_readv(struct snd_pcm_substream *substream,
+		     void **bufs, snd_pcm_uframes_t frames)
+{
+	return __snd_pcm_lib_xfer(substream, bufs, false, frames, true);
 }
 
 int snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime);

commit 5c7264cfbb209efea04bbbd69b8b4f5f2fc5f86d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 24 22:36:23 2017 +0200

    ALSA: pcm: Unify read/write loop
    
    Both __snd_pcm_lib_read() and __snd_pcm_write() functions have almost
    the same code to loop over samples.  For simplification, this patch
    unifies both as the single helper, __snd_pcm_lib_xfer().
    
    Other than that, there should be no functional change by this patch.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 0fac948bb053..db649083c76d 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1072,10 +1072,7 @@ void snd_pcm_set_sync(struct snd_pcm_substream *substream);
 int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,
 		      unsigned int cmd, void *arg);                      
 void snd_pcm_period_elapsed(struct snd_pcm_substream *substream);
-snd_pcm_sframes_t __snd_pcm_lib_write(struct snd_pcm_substream *substream,
-				      void *buf, bool interleaved,
-				      snd_pcm_uframes_t frames);
-snd_pcm_sframes_t __snd_pcm_lib_read(struct snd_pcm_substream *substream,
+snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 				     void *buf, bool interleaved,
 				     snd_pcm_uframes_t frames);
 
@@ -1083,28 +1080,28 @@ static inline snd_pcm_sframes_t
 snd_pcm_lib_write(struct snd_pcm_substream *substream,
 		  const void __user *buf, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_write(substream, (void *)buf, true, frames);
+	return __snd_pcm_lib_xfer(substream, (void *)buf, true, frames);
 }
 
 static inline snd_pcm_sframes_t
 snd_pcm_lib_read(struct snd_pcm_substream *substream,
 		 void __user *buf, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_read(substream, (void *)buf, true, frames);
+	return __snd_pcm_lib_xfer(substream, (void *)buf, true, frames);
 }
 
 static inline snd_pcm_sframes_t
 snd_pcm_lib_writev(struct snd_pcm_substream *substream,
 		   void __user **bufs, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_write(substream, (void *)bufs, false, frames);
+	return __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames);
 }
 
 static inline snd_pcm_sframes_t
 snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 		  void __user **bufs, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_read(substream, (void *)bufs, false, frames);
+	return __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames);
 }
 
 int snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime);

commit c48f12ee0acbd431d6c3ed249f79a6d68b757058
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun May 21 09:35:21 2017 +0200

    ALSA: pcm: Call directly the common read/write helpers
    
    Make snd_pcm_lib_read() and *_write() static inline functions that
    call the common helper functions directly.  This reduces a slight
    amount of codes, and at the same time, it's a preparation for the
    further cleanups / fixes.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 0da5117636ec..0fac948bb053 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1072,15 +1072,40 @@ void snd_pcm_set_sync(struct snd_pcm_substream *substream);
 int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,
 		      unsigned int cmd, void *arg);                      
 void snd_pcm_period_elapsed(struct snd_pcm_substream *substream);
-snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream,
-				    const void __user *buf,
-				    snd_pcm_uframes_t frames);
-snd_pcm_sframes_t snd_pcm_lib_read(struct snd_pcm_substream *substream,
-				   void __user *buf, snd_pcm_uframes_t frames);
-snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,
-				     void __user **bufs, snd_pcm_uframes_t frames);
-snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
-				    void __user **bufs, snd_pcm_uframes_t frames);
+snd_pcm_sframes_t __snd_pcm_lib_write(struct snd_pcm_substream *substream,
+				      void *buf, bool interleaved,
+				      snd_pcm_uframes_t frames);
+snd_pcm_sframes_t __snd_pcm_lib_read(struct snd_pcm_substream *substream,
+				     void *buf, bool interleaved,
+				     snd_pcm_uframes_t frames);
+
+static inline snd_pcm_sframes_t
+snd_pcm_lib_write(struct snd_pcm_substream *substream,
+		  const void __user *buf, snd_pcm_uframes_t frames)
+{
+	return __snd_pcm_lib_write(substream, (void *)buf, true, frames);
+}
+
+static inline snd_pcm_sframes_t
+snd_pcm_lib_read(struct snd_pcm_substream *substream,
+		 void __user *buf, snd_pcm_uframes_t frames)
+{
+	return __snd_pcm_lib_read(substream, (void *)buf, true, frames);
+}
+
+static inline snd_pcm_sframes_t
+snd_pcm_lib_writev(struct snd_pcm_substream *substream,
+		   void __user **bufs, snd_pcm_uframes_t frames)
+{
+	return __snd_pcm_lib_write(substream, (void *)bufs, false, frames);
+}
+
+static inline snd_pcm_sframes_t
+snd_pcm_lib_readv(struct snd_pcm_substream *substream,
+		  void __user **bufs, snd_pcm_uframes_t frames)
+{
+	return __snd_pcm_lib_read(substream, (void *)bufs, false, frames);
+}
 
 int snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime);
 unsigned int snd_pcm_rate_to_rate_bit(unsigned int rate);

commit 2ae48354a1a7afbec0c61280e6410a90894a21e7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 10 22:21:52 2017 +0200

    ALSA: pcm: Drop the old copy and silence ops
    
    Now that all users of old copy and silence ops have been converted to
    the new PCM ops, the old stuff can be retired and go away.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 86b126be49a2..0da5117636ec 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -78,11 +78,6 @@ struct snd_pcm_ops {
 			struct timespec *system_ts, struct timespec *audio_ts,
 			struct snd_pcm_audio_tstamp_config *audio_tstamp_config,
 			struct snd_pcm_audio_tstamp_report *audio_tstamp_report);
-	int (*copy)(struct snd_pcm_substream *substream, int channel,
-		    snd_pcm_uframes_t pos,
-		    void __user *buf, snd_pcm_uframes_t count);
-	int (*silence)(struct snd_pcm_substream *substream, int channel, 
-		       snd_pcm_uframes_t pos, snd_pcm_uframes_t count);
 	int (*fill_silence)(struct snd_pcm_substream *substream, int channel,
 			    unsigned long pos, unsigned long bytes);
 	int (*copy_user)(struct snd_pcm_substream *substream, int channel,

commit 29d1a873de542cbb46d0641037d2601cb76be5b1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 10 20:02:35 2017 +0200

    ALSA: pcm: Introduce copy_user, copy_kernel and fill_silence ops
    
    For supporting the explicit in-kernel copy of PCM buffer data, and
    also for further code refactoring, three new PCM ops, copy_user,
    copy_kernel and fill_silence, are introduced.  The old copy and
    silence ops will be deprecated and removed later once when all callers
    are converted.
    
    The copy_kernel ops is the new one, and it's supposed to transfer the
    PCM data from the given kernel buffer to the hardware ring-buffer (or
    vice-versa depending on the stream direction), while the copy_user ops
    is equivalent with the former copy ops, to transfer the data from the
    user-space buffer.
    
    The major difference of the new copy_* and fill_silence ops from the
    previous ops is that the new ops take bytes instead of frames for size
    and position arguments.  It has two merits: first, it allows the
    callback implementation often simpler (just call directly memcpy() &
    co), and second, it may unify the implementations of both interleaved
    and non-interleaved cases, as we'll see in the later patch.
    
    As of this stage, copy_kernel ops isn't referred yet, but only
    copy_user is used.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 79fedf517070..86b126be49a2 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -83,6 +83,13 @@ struct snd_pcm_ops {
 		    void __user *buf, snd_pcm_uframes_t count);
 	int (*silence)(struct snd_pcm_substream *substream, int channel, 
 		       snd_pcm_uframes_t pos, snd_pcm_uframes_t count);
+	int (*fill_silence)(struct snd_pcm_substream *substream, int channel,
+			    unsigned long pos, unsigned long bytes);
+	int (*copy_user)(struct snd_pcm_substream *substream, int channel,
+			 unsigned long pos, void __user *buf,
+			 unsigned long bytes);
+	int (*copy_kernel)(struct snd_pcm_substream *substream, int channel,
+			   unsigned long pos, void *buf, unsigned long bytes);
 	struct page *(*page)(struct snd_pcm_substream *substream,
 			     unsigned long offset);
 	int (*mmap)(struct snd_pcm_substream *substream, struct vm_area_struct *vma);

commit 2c4842d3b6b3cf6db0f21e487da7e9bd3aa23090
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri May 26 09:30:46 2017 +0900

    ALSA: pcm: add local header file for snd-pcm module
    
    Several files are used to construct PCM core module, a.k.a snd-pcm.
    Although available APIs are described in 'include/sound/pcm.h', some of
    them are not exported as symbols in kernel space. Such APIs are just for
    module local usage.
    
    This commit adds module local header file and move some function prototypes
    into it so that scopes of them are controlled properly and developers
    get no confusion from unavailable symbols.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index c609b891c4c2..79fedf517070 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -969,12 +969,6 @@ static inline unsigned int params_buffer_bytes(const struct snd_pcm_hw_params *p
 }
 
 int snd_interval_refine(struct snd_interval *i, const struct snd_interval *v);
-void snd_interval_mul(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c);
-void snd_interval_div(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c);
-void snd_interval_muldivk(const struct snd_interval *a, const struct snd_interval *b, 
-			  unsigned int k, struct snd_interval *c);
-void snd_interval_mulkdiv(const struct snd_interval *a, unsigned int k,
-			  const struct snd_interval *b, struct snd_interval *c);
 int snd_interval_list(struct snd_interval *i, unsigned int count,
 		      const unsigned int *list, unsigned int mask);
 int snd_interval_ranges(struct snd_interval *i, unsigned int count,
@@ -985,15 +979,9 @@ int snd_interval_ratnum(struct snd_interval *i,
 
 void _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params);
 void _snd_pcm_hw_param_setempty(struct snd_pcm_hw_params *params, snd_pcm_hw_param_t var);
-int snd_pcm_hw_params_choose(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params);
 
 int snd_pcm_hw_refine(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params);
 
-int snd_pcm_hw_constraints_init(struct snd_pcm_substream *substream);
-int snd_pcm_hw_constraints_complete(struct snd_pcm_substream *substream);
-
-int snd_pcm_hw_constraint_mask(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
-			       u_int32_t mask);
 int snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
 				 u_int64_t mask);
 int snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
@@ -1081,10 +1069,6 @@ void snd_pcm_set_ops(struct snd_pcm * pcm, int direction,
 void snd_pcm_set_sync(struct snd_pcm_substream *substream);
 int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,
 		      unsigned int cmd, void *arg);                      
-int snd_pcm_update_state(struct snd_pcm_substream *substream,
-			 struct snd_pcm_runtime *runtime);
-int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream);
-void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_uframes_t new_hw_ptr);
 void snd_pcm_period_elapsed(struct snd_pcm_substream *substream);
 snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream,
 				    const void __user *buf,
@@ -1096,8 +1080,6 @@ snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,
 snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 				    void __user **bufs, snd_pcm_uframes_t frames);
 
-extern const struct snd_pcm_hw_constraint_list snd_pcm_known_rates;
-
 int snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime);
 unsigned int snd_pcm_rate_to_rate_bit(unsigned int rate);
 unsigned int snd_pcm_rate_bit_to_rate(unsigned int rate_bit);
@@ -1131,20 +1113,6 @@ static inline void snd_pcm_set_runtime_buffer(struct snd_pcm_substream *substrea
 	}
 }
 
-/*
- *  Timer interface
- */
-
-#ifdef CONFIG_SND_PCM_TIMER
-void snd_pcm_timer_resolution_change(struct snd_pcm_substream *substream);
-void snd_pcm_timer_init(struct snd_pcm_substream *substream);
-void snd_pcm_timer_done(struct snd_pcm_substream *substream);
-#else
-static inline void
-snd_pcm_timer_resolution_change(struct snd_pcm_substream *substream) {}
-static inline void snd_pcm_timer_init(struct snd_pcm_substream *substream) {}
-static inline void snd_pcm_timer_done(struct snd_pcm_substream *substream) {}
-#endif
 /**
  * snd_pcm_gettime - Fill the timespec depending on the timestamp mode
  * @runtime: PCM runtime instance

commit 52204718b1f04a84feadd86f3eab5b4da365306f
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sun May 14 12:38:44 2017 -0300

    ALSA: pcm: fix the comments that refers to kernel-doc
    
    The markup inside the #if 0 comment actually refers to a
    kernel-doc markup. As we're getting rid of DocBook update it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 3f084486868f..c609b891c4c2 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1055,7 +1055,7 @@ int snd_pcm_format_unsigned(snd_pcm_format_t format);
 int snd_pcm_format_linear(snd_pcm_format_t format);
 int snd_pcm_format_little_endian(snd_pcm_format_t format);
 int snd_pcm_format_big_endian(snd_pcm_format_t format);
-#if 0 /* just for DocBook */
+#if 0 /* just for kernel-doc */
 /**
  * snd_pcm_format_cpu_endian - Check the PCM format is CPU-endian
  * @format: the format to check

commit 6d2412b80aabf5d77400fbb960ee041475df86aa
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 12 11:44:03 2017 +0200

    ALSA: Use IS_ENABLED() in common headers
    
    Simplify the ifdef conditions with IS_ENABLED() macro in the common
    sound headers.  No functional changes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index eb16912d6046..3f084486868f 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -34,7 +34,7 @@
 #define snd_pcm_substream_chip(substream) ((substream)->private_data)
 #define snd_pcm_chip(pcm) ((pcm)->private_data)
 
-#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+#if IS_ENABLED(CONFIG_SND_PCM_OSS)
 #include <sound/pcm_oss.h>
 #endif
 
@@ -418,7 +418,7 @@ struct snd_pcm_runtime {
 	struct snd_pcm_audio_tstamp_report audio_tstamp_report;
 	struct timespec driver_tstamp;
 
-#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+#if IS_ENABLED(CONFIG_SND_PCM_OSS)
 	/* -- OSS things -- */
 	struct snd_pcm_oss_runtime oss;
 #endif
@@ -464,7 +464,7 @@ struct snd_pcm_substream {
 	unsigned int f_flags;
 	void (*pcm_release)(struct snd_pcm_substream *);
 	struct pid *pid;
-#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+#if IS_ENABLED(CONFIG_SND_PCM_OSS)
 	/* -- OSS things -- */
 	struct snd_pcm_oss_substream oss;
 #endif
@@ -494,7 +494,7 @@ struct snd_pcm_str {
 	unsigned int substream_count;
 	unsigned int substream_opened;
 	struct snd_pcm_substream *substream;
-#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+#if IS_ENABLED(CONFIG_SND_PCM_OSS)
 	/* -- OSS things -- */
 	struct snd_pcm_oss_stream oss;
 #endif
@@ -526,7 +526,7 @@ struct snd_pcm {
 	void (*private_free) (struct snd_pcm *pcm);
 	bool internal; /* pcm is for internal use only */
 	bool nonatomic; /* whole PCM operations are in non-atomic context */
-#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+#if IS_ENABLED(CONFIG_SND_PCM_OSS)
 	struct snd_pcm_oss oss;
 #endif
 };

commit 58f30d650c7f5275d4d57e62862970e1078af462
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 12 11:35:17 2017 +0200

    ALSA: pcm: Build pcm notifier code conditionally
    
    The PCM notifier code is used only by OSS emulation layer, so we can
    build it conditionally for reducing the size.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 361749e60799..eb16912d6046 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -531,13 +531,6 @@ struct snd_pcm {
 #endif
 };
 
-struct snd_pcm_notify {
-	int (*n_register) (struct snd_pcm * pcm);
-	int (*n_disconnect) (struct snd_pcm * pcm);
-	int (*n_unregister) (struct snd_pcm * pcm);
-	struct list_head list;
-};
-
 /*
  *  Registering
  */
@@ -552,7 +545,15 @@ int snd_pcm_new_internal(struct snd_card *card, const char *id, int device,
 		struct snd_pcm **rpcm);
 int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count);
 
+#if IS_ENABLED(CONFIG_SND_PCM_OSS)
+struct snd_pcm_notify {
+	int (*n_register) (struct snd_pcm * pcm);
+	int (*n_disconnect) (struct snd_pcm * pcm);
+	int (*n_unregister) (struct snd_pcm * pcm);
+	struct list_head list;
+};
 int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree);
+#endif
 
 /*
  *  Native I/O

commit 1cf05ba2cafa079a943c2cbae51b2f2c2e247466
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Feb 5 08:58:46 2017 +0100

    ALSA: pcm: Define dummy snd_pcm_suspend() for CONFIG_PM=n
    
    ... so that the driver can avoid ifdef's for the dead PM callbacks.
    The compiler should optimize them out in anyway.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index af1fb37c6b26..361749e60799 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -570,6 +570,15 @@ int snd_pcm_stop_xrun(struct snd_pcm_substream *substream);
 #ifdef CONFIG_PM
 int snd_pcm_suspend(struct snd_pcm_substream *substream);
 int snd_pcm_suspend_all(struct snd_pcm *pcm);
+#else
+static inline int snd_pcm_suspend(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+static inline int snd_pcm_suspend_all(struct snd_pcm *pcm)
+{
+	return 0;
+}
 #endif
 int snd_pcm_kernel_ioctl(struct snd_pcm_substream *substream, unsigned int cmd, void *arg);
 int snd_pcm_open_substream(struct snd_pcm *pcm, int stream, struct file *file,

commit 3bdff244a2bcbde37ec33bf3cdde4638049c6c38
Author: Mengdong Lin <mengdong.lin@linux.intel.com>
Date:   Fri Jan 15 16:13:10 2016 +0800

    ALSA: pcm: Add snd_pcm_rate_range_to_bits()
    
    This helper function can convert a given sample rate range to
    SNDRV_PCM_RATE_xxx bits.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index b0be09279943..af1fb37c6b26 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1093,6 +1093,8 @@ unsigned int snd_pcm_rate_to_rate_bit(unsigned int rate);
 unsigned int snd_pcm_rate_bit_to_rate(unsigned int rate_bit);
 unsigned int snd_pcm_rate_mask_intersect(unsigned int rates_a,
 					 unsigned int rates_b);
+unsigned int snd_pcm_rate_range_to_bits(unsigned int rate_min,
+					unsigned int rate_max);
 
 /**
  * snd_pcm_set_runtime_buffer - Set the PCM runtime buffer

commit e5e113cf0d19392f26c6b63e63ad4680ee4ec5da
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Oct 28 11:37:53 2015 +0100

    ALSA: Constify ratden/ratnum constraints
    
    The ALSA core does not modify the constraints provided by a driver. Most
    constraint helper functions already take a const pointer to the constraint
    description, the exception at the moment being the ratden and ratnum
    constraints. Make those const as well, this allows a driver to declare them
    as const.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 4e6ad74fd8a2..b0be09279943 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -265,12 +265,12 @@ struct snd_ratden {
 
 struct snd_pcm_hw_constraint_ratnums {
 	int nrats;
-	struct snd_ratnum *rats;
+	const struct snd_ratnum *rats;
 };
 
 struct snd_pcm_hw_constraint_ratdens {
 	int nrats;
-	struct snd_ratden *rats;
+	const struct snd_ratden *rats;
 };
 
 struct snd_pcm_hw_constraint_list {
@@ -970,7 +970,7 @@ int snd_interval_list(struct snd_interval *i, unsigned int count,
 int snd_interval_ranges(struct snd_interval *i, unsigned int count,
 			const struct snd_interval *list, unsigned int mask);
 int snd_interval_ratnum(struct snd_interval *i,
-			unsigned int rats_count, struct snd_ratnum *rats,
+			unsigned int rats_count, const struct snd_ratnum *rats,
 			unsigned int *nump, unsigned int *denp);
 
 void _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params);
@@ -1000,11 +1000,11 @@ int snd_pcm_hw_constraint_ranges(struct snd_pcm_runtime *runtime,
 int snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime, 
 				  unsigned int cond,
 				  snd_pcm_hw_param_t var,
-				  struct snd_pcm_hw_constraint_ratnums *r);
+				  const struct snd_pcm_hw_constraint_ratnums *r);
 int snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime, 
 				  unsigned int cond,
 				  snd_pcm_hw_param_t var,
-				  struct snd_pcm_hw_constraint_ratdens *r);
+				  const struct snd_pcm_hw_constraint_ratdens *r);
 int snd_pcm_hw_constraint_msbits(struct snd_pcm_runtime *runtime, 
 				 unsigned int cond,
 				 unsigned int width,

commit 274035751e25ee15a064e43cde7b4e7a9b75d921
Merge: 53e597b1d194 a5be88f63eaf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Oct 23 06:57:50 2015 +0200

    Merge branch 'topic/hw-constraint-single' into for-next

commit 53e597b1d194910bef53ed0632da329fef497904
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Oct 22 13:11:56 2015 +0200

    ALSA: Remove transfer_ack_{begin,end} callbacks from struct snd_pcm_runtime
    
    While there is nothing wrong with the transfer_ack_begin and
    transfer_ack_end callbacks per-se, the last documented user was part of the
    alsa-driver 0.5.12a package, which was released 14 years ago and even
    predates the upstream integration of the ALSA core and has subsequently
    been superseded by newer alsa-driver releases.
    
    This seems to indicate that there is no need for having these callbacks and
    they are just cruft that can be removed.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 2882dddfc91c..3e0ffd21901f 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -402,10 +402,6 @@ struct snd_pcm_runtime {
 	struct snd_pcm_hardware hw;
 	struct snd_pcm_hw_constraints hw_constraints;
 
-	/* -- interrupt callbacks -- */
-	void (*transfer_ack_begin)(struct snd_pcm_substream *substream);
-	void (*transfer_ack_end)(struct snd_pcm_substream *substream);
-
 	/* -- timer -- */
 	unsigned int timer_resolution;	/* timer resolution */
 	int tstamp_type;		/* timestamp type */

commit bc1043cdcd84cb441d80cfd79ae4325218f6f9ba
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Oct 18 15:39:16 2015 +0200

    ALSA: Add helper function to add single value constraint
    
    The recommended and most efficient way to constraint a configuration
    parameter to a single value is to set the minimum and maximum allowed
    values to the same value, i.e. calling snd_pcm_hw_constraint_minmax() with
    the same value for min and max.
    
    It is not necessarily obvious though that this is the approach that should
    be taken and some drivers have come up with other ways of solving this
    problem, e.g. installing a list constraint with a single item. List
    constraints are dynamic constraints though and hence less efficient than
    the static min-max constraint.
    
    This patch introduces a new helper function called
    snd_pcm_hw_constraint_single() which only takes a single value has the same
    effect as calling snd_pcm_hw_constraint_minmax() with the same values for
    min and max. But it is hopefully semantically more expressive, making it
    clear that this is the preferred way of setting a single value constraint.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 691e7ee0a510..04fbcba9290b 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1034,6 +1034,22 @@ int snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime,
 			snd_pcm_hw_rule_func_t func, void *private,
 			int dep, ...);
 
+/**
+ * snd_pcm_hw_constraint_single() - Constrain parameter to a single value
+ * @runtime: PCM runtime instance
+ * @var: The hw_params variable to constrain
+ * @val: The value to constrain to
+ *
+ * Return: Positive if the value is changed, zero if it's not changed, or a
+ * negative error code.
+ */
+static inline int snd_pcm_hw_constraint_single(
+	struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
+	unsigned int val)
+{
+	return snd_pcm_hw_constraint_minmax(runtime, var, val, val);
+}
+
 int snd_pcm_format_signed(snd_pcm_format_t format);
 int snd_pcm_format_unsigned(snd_pcm_format_t format);
 int snd_pcm_format_linear(snd_pcm_format_t format);

commit 90bbaf66ee7b946952f1e82a0069639dea5fd893
Author: Jie Yang <yang.jie@intel.com>
Date:   Fri Oct 16 17:57:46 2015 +0800

    ALSA: timer: add config item to export PCM timer disabling for expert
    
    PCM timer is not always used. For embedded device, we need an interface
    to disable it when it is not needed, to shrink the kernel size and
    memory footprint, here add CONFIG_SND_PCM_TIMER for it.
    
    When both CONFIG_SND_PCM_TIMER and CONFIG_SND_TIMER is unselected,
    about 25KB saving bonus we can get.
    
    Please be noted that when disabled, those stubs who using pcm timer
    (e.g. dmix, dsnoop & co) may work incorrectlly.
    
    Suggested-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jie Yang <yang.jie@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index a4fcc9456194..2882dddfc91c 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1111,10 +1111,16 @@ static inline void snd_pcm_set_runtime_buffer(struct snd_pcm_substream *substrea
  *  Timer interface
  */
 
+#ifdef CONFIG_SND_PCM_TIMER
 void snd_pcm_timer_resolution_change(struct snd_pcm_substream *substream);
 void snd_pcm_timer_init(struct snd_pcm_substream *substream);
 void snd_pcm_timer_done(struct snd_pcm_substream *substream);
-
+#else
+static inline void
+snd_pcm_timer_resolution_change(struct snd_pcm_substream *substream) {}
+static inline void snd_pcm_timer_init(struct snd_pcm_substream *substream) {}
+static inline void snd_pcm_timer_done(struct snd_pcm_substream *substream) {}
+#endif
 /**
  * snd_pcm_gettime - Fill the timespec depending on the timestamp mode
  * @runtime: PCM runtime instance

commit 0052b7dcf9d9ec6be4fc3fe815a2ceda623bb9d1
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Sep 13 19:00:05 2015 +0900

    ALSA: pcm: remove structure member of 'struct snd_pcm_hwptr_log *' type because this structure had been removed
    
    This structure was added by 4d96eb255c53 ('ALSA: pcm_lib - add possibility
    to log last 10 DMA ring buffer positions') to store PCM pointers
    information of latest 10 pointer movements (=XRUN_LOG_CNT). When
    CONFIG_SND_PCM_XRUN_DEBUG is configured, 'struct snd_pcm_runtime' has
    'hwptr_log' member with a pointer to the structure. When calling
    xrun_log() in pcm_lib.c, the structure was allocated to the pointer.
    When calling snd_pcm_detach_substream() in pcm.c, the allocated pointer
    is released.
    
    In f5914908a5b7 ('ALSA: pcm: Replace PCM hwptr tracking with tracepoints'),
    the pointer logging is replaced with using Linux Kernel Tracepoints. The
    structure was also removed, while it's just declared. The member and kfree
    still remains.
    
    This commit removes the member and related codes. I think this was
    overlooked because it brings no errors/warnings to C compilers.
    
    Fixes: f5914908a5b7 ('ALSA: pcm: Replace PCM hwptr tracking with tracepoints')
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 691e7ee0a510..a4fcc9456194 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -285,8 +285,6 @@ struct snd_pcm_hw_constraint_ranges {
 	unsigned int mask;
 };
 
-struct snd_pcm_hwptr_log;
-
 /*
  * userspace-provided audio timestamp config to kernel,
  * structure is for internal use only and filled with dedicated unpack routine
@@ -428,10 +426,6 @@ struct snd_pcm_runtime {
 	/* -- OSS things -- */
 	struct snd_pcm_oss_runtime oss;
 #endif
-
-#ifdef CONFIG_SND_PCM_XRUN_DEBUG
-	struct snd_pcm_hwptr_log *hwptr_log;
-#endif
 };
 
 struct snd_pcm_group {		/* keep linked substreams */

commit 782e50e0b38ff284dead13265f1c3e04004e507d
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Apr 27 12:20:29 2015 +0200

    ALSA: Close holes in struct snd_pcm_constraint_list
    
    On a 64-bit system there is a 32-bit hole in struct snd_pcm_constraint_list
    and then 32-bit padding at the end. Reordering things slightly gets rid of
    the hole and padding, reducing the size of the struct by 50% from its
    original size.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index d632809d9425..691e7ee0a510 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -274,8 +274,8 @@ struct snd_pcm_hw_constraint_ratdens {
 };
 
 struct snd_pcm_hw_constraint_list {
-	unsigned int count;
 	const unsigned int *list;
+	unsigned int count;
 	unsigned int mask;
 };
 

commit d16efa0626bfd11157d4a622a24aaae98435f26d
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Apr 27 12:20:28 2015 +0200

    ALSA: Close holes in struct snd_pcm_hw_rule
    
    On a 64-bit system there are two 32-bit holes due to the alignment of 64-bit
    fields. Reordering things slightly gets rid of those holes, reducing the
    size of the struct by 17% percent of its original size.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 0cb7f3f5df7b..d632809d9425 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -224,9 +224,10 @@ typedef int (*snd_pcm_hw_rule_func_t)(struct snd_pcm_hw_params *params,
 
 struct snd_pcm_hw_rule {
 	unsigned int cond;
-	snd_pcm_hw_rule_func_t func;
 	int var;
 	int deps[4];
+
+	snd_pcm_hw_rule_func_t func;
 	void *private;
 };
 

commit 2d52a5abd5be35340296a251092c8a594679df54
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Fri Feb 13 15:14:08 2015 -0600

    ALSA: core: remove .wall_clock
    
    can be removed without breaking git-bisect now
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 04f2d492ae57..0cb7f3f5df7b 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -74,8 +74,6 @@ struct snd_pcm_ops {
 	int (*prepare)(struct snd_pcm_substream *substream);
 	int (*trigger)(struct snd_pcm_substream *substream, int cmd);
 	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream);
-	int (*wall_clock)(struct snd_pcm_substream *substream,
-			  struct timespec *audio_ts);
 	int (*get_time_info)(struct snd_pcm_substream *substream,
 			struct timespec *system_ts, struct timespec *audio_ts,
 			struct snd_pcm_audio_tstamp_config *audio_tstamp_config,

commit 3179f62001880e588e229db3006a59ad87b7792a
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Fri Feb 13 15:14:06 2015 -0600

    ALSA: core: add .get_time_info
    
    Introduce more generic .get_time_info to retrieve
    system timestamp and audio timestamp in single routine.
    Backwards compatibility is preserved with same functionality
    as with .wall_clock method (to be removed in following commits
    to avoid breaking git bisect)
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 60f0e48f7905..04f2d492ae57 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -76,6 +76,10 @@ struct snd_pcm_ops {
 	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream);
 	int (*wall_clock)(struct snd_pcm_substream *substream,
 			  struct timespec *audio_ts);
+	int (*get_time_info)(struct snd_pcm_substream *substream,
+			struct timespec *system_ts, struct timespec *audio_ts,
+			struct snd_pcm_audio_tstamp_config *audio_tstamp_config,
+			struct snd_pcm_audio_tstamp_report *audio_tstamp_report);
 	int (*copy)(struct snd_pcm_substream *substream, int channel,
 		    snd_pcm_uframes_t pos,
 		    void __user *buf, snd_pcm_uframes_t count);

commit 229d043096ea8e58829d37d35767afeac15997f5
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Fri Feb 13 15:14:03 2015 -0600

    ALSA: core: selection of audio_tstamp type and accuracy reports
    
    Audio timestamps can be extracted from sample counters, wall clocks,
    PHC clocks (Ethernet AVB), on-demand synchronized snapshots. This
    patch provides the ability to report timestamping capabilities, select
    timestamp types and retrieve timestamp accuracy, if supported.
    Details can be found in Documentations/sound/alsa/timestamping.txt
    
    This functionality is introduced by reclaiming the reserved_aligned
    field introduced by commit9c7066aef4a5eb8e4063de28f06c508bf6f2963a
    in snd_pcm_status to provide userspace with selection/query capabilities.
    Additional driver_tstamp and audio_tstamp_accuracy fields are also added.
    
    snd_pcm_mmap_status remains a read-only structure with only
    the audio timestamp value accessible from user space. The selection
    of audio timestamp type is done through snd_pcm_status only
    
    This commit does not impact ABI and does not impact the default
    behavior. By default audio timestamp is aligned with hw_pointer and
    reports the DMA position. Backwards compatibility is handled by using
    the HDAudio wall clock for playback and the hw_ptr for all other
    cases.
    
    For timestamp selection a new STATUS_EXT ioctl is introduced with
    read/write parameters. Alsa-lib will be modified to make use of
    STATUS_EXT.
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index c0ddb7e69c28..60f0e48f7905 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -60,6 +60,9 @@ struct snd_pcm_hardware {
 
 struct snd_pcm_substream;
 
+struct snd_pcm_audio_tstamp_config; /* definitions further down */
+struct snd_pcm_audio_tstamp_report;
+
 struct snd_pcm_ops {
 	int (*open)(struct snd_pcm_substream *substream);
 	int (*close)(struct snd_pcm_substream *substream);
@@ -281,6 +284,58 @@ struct snd_pcm_hw_constraint_ranges {
 
 struct snd_pcm_hwptr_log;
 
+/*
+ * userspace-provided audio timestamp config to kernel,
+ * structure is for internal use only and filled with dedicated unpack routine
+ */
+struct snd_pcm_audio_tstamp_config {
+	/* 5 of max 16 bits used */
+	u32 type_requested:4;
+	u32 report_delay:1; /* add total delay to A/D or D/A */
+};
+
+static inline void snd_pcm_unpack_audio_tstamp_config(__u32 data,
+						struct snd_pcm_audio_tstamp_config *config)
+{
+	config->type_requested = data & 0xF;
+	config->report_delay = (data >> 4) & 1;
+}
+
+/*
+ * kernel-provided audio timestamp report to user-space
+ * structure is for internal use only and read by dedicated pack routine
+ */
+struct snd_pcm_audio_tstamp_report {
+	/* 6 of max 16 bits used for bit-fields */
+
+	/* for backwards compatibility */
+	u32 valid:1;
+
+	/* actual type if hardware could not support requested timestamp */
+	u32 actual_type:4;
+
+	/* accuracy represented in ns units */
+	u32 accuracy_report:1; /* 0 if accuracy unknown, 1 if accuracy field is valid */
+	u32 accuracy; /* up to 4.29s, will be packed in separate field  */
+};
+
+static inline void snd_pcm_pack_audio_tstamp_report(__u32 *data, __u32 *accuracy,
+						const struct snd_pcm_audio_tstamp_report *report)
+{
+	u32 tmp;
+
+	tmp = report->accuracy_report;
+	tmp <<= 4;
+	tmp |= report->actual_type;
+	tmp <<= 1;
+	tmp |= report->valid;
+
+	*data &= 0xffff; /* zero-clear MSBs */
+	*data |= (tmp << 16);
+	*accuracy = report->accuracy;
+}
+
+
 struct snd_pcm_runtime {
 	/* -- Status -- */
 	struct snd_pcm_substream *trigger_master;
@@ -361,6 +416,11 @@ struct snd_pcm_runtime {
 
 	struct snd_dma_buffer *dma_buffer_p;	/* allocated buffer */
 
+	/* -- audio timestamp config -- */
+	struct snd_pcm_audio_tstamp_config audio_tstamp_config;
+	struct snd_pcm_audio_tstamp_report audio_tstamp_report;
+	struct timespec driver_tstamp;
+
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	/* -- OSS things -- */
 	struct snd_pcm_oss_runtime oss;

commit 2b79d7a6bf341ebeffb85fc2b3577d0cfa810c49
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Fri Feb 6 15:55:51 2015 -0600

    ALSA: pcm: allow for trigger_tstamp snapshot in .trigger
    
    Don't use generic snapshot of trigger_tstamp if low-level driver or
    hardware can get a more precise value for better audio/system time
    synchronization.
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 07299b295233..c0ddb7e69c28 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -285,6 +285,7 @@ struct snd_pcm_runtime {
 	/* -- Status -- */
 	struct snd_pcm_substream *trigger_master;
 	struct timespec trigger_tstamp;	/* trigger timestamp */
+	bool trigger_tstamp_latched;     /* trigger timestamp latched in low-level driver/hardware */
 	int overrange;
 	snd_pcm_uframes_t avail_max;
 	snd_pcm_uframes_t hw_ptr_base;	/* Position at buffer restart */

commit a3ae255e3729c1bb4507412ea29be804f703d44c
Merge: 3fe9cf390f6d 16ca41c6cc90
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 07:08:35 2015 +0100

    Merge tag 'asoc-v3.20-2' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-next
    
    ASoC: Updates for v3.20
    
    More updates for v3.20:
    
     - Lots of refactoring from Lars-Peter Clausen, moving drivers to more
       data driven initialization and rationalizing a lot of DAPM usage.
     - Much improved handling of CDCLK clocks on Samsung I2S controllers.
     - Lots of driver specific cleanups and feature improvements.
     - CODEC support for TI PCM514x and TLV320AIC3104 devices.
     - Board support for Tegra systems with Realtek RT5677.
    
    Conflicts:
            sound/soc/intel/sst-mfld-platform-pcm.c

commit 7d590e462315f40f821599bcc0b2b6b7f62142a8
Merge: 3223d9c62c53 9c7da1a57bb5
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Feb 4 20:57:06 2015 +0000

    Merge remote-tracking branch 'asoc/topic/pcm512x' into asoc-next

commit 3fe9cf390f6dc84f76b112b0a660967a84f9a81b
Merge: 6ccd93bdb989 830953c0724b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 3 17:57:16 2015 +0100

    Merge branch 'topic/snd-device' into for-next

commit ef46c7af93f98d07cd0ed891f93a26d135785526
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 29 17:32:26 2015 +0100

    ALSA: pcm: Embed struct device
    
    Like previous patches, at this time we embed the struct device into
    PCM object.  However, this needs a bit more caution: struct snd_pcm
    doesn't own one device but two, for both playback and capture!  Thus
    not struct snd_pcm but struct snd_pcm_str object contains the device.
    
    Along with this change, pcm->dev field is dropped for avoiding
    confusion.  It was meant to point to a non-standard parent.  But,
    since now we can touch each struct device directly, we can manipulate
    the parent field easily there, too.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index b429b73e875e..735bd0cc7347 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -449,6 +449,7 @@ struct snd_pcm_str {
 #endif
 #endif
 	struct snd_kcontrol *chmap_kctl; /* channel-mapping controls */
+	struct device dev;
 };
 
 struct snd_pcm {
@@ -465,7 +466,6 @@ struct snd_pcm {
 	wait_queue_head_t open_wait;
 	void *private_data;
 	void (*private_free) (struct snd_pcm *pcm);
-	struct device *dev; /* actual hw device this belongs to */
 	bool internal; /* pcm is for internal use only */
 	bool nonatomic; /* whole PCM operations are in non-atomic context */
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)

commit f66f898e953d56779367a6cbc39cbb4808b208c0
Author: Peter Rosin <peda@axentia.se>
Date:   Wed Jan 28 15:16:06 2015 +0100

    ALSA: pcm: Add snd_interval_ranges() and snd_pcm_hw_constraint_ranges()
    
    Add helper functions to allow drivers to specify several disjoint
    ranges for a variable. In particular, there is a codec (PCM512x) that
    has a hole in its supported range of rates, due to PLL and divider
    restrictions.
    
    This is like snd_pcm_hw_constraint_list(), but for ranges instead of
    points.
    
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 1e7f74acc2ec..04fc037e0555 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -275,6 +275,12 @@ struct snd_pcm_hw_constraint_list {
 	unsigned int mask;
 };
 
+struct snd_pcm_hw_constraint_ranges {
+	unsigned int count;
+	const struct snd_interval *ranges;
+	unsigned int mask;
+};
+
 struct snd_pcm_hwptr_log;
 
 struct snd_pcm_runtime {
@@ -910,6 +916,8 @@ void snd_interval_mulkdiv(const struct snd_interval *a, unsigned int k,
 			  const struct snd_interval *b, struct snd_interval *c);
 int snd_interval_list(struct snd_interval *i, unsigned int count,
 		      const unsigned int *list, unsigned int mask);
+int snd_interval_ranges(struct snd_interval *i, unsigned int count,
+			const struct snd_interval *list, unsigned int mask);
 int snd_interval_ratnum(struct snd_interval *i,
 			unsigned int rats_count, struct snd_ratnum *rats,
 			unsigned int *nump, unsigned int *denp);
@@ -934,6 +942,10 @@ int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime,
 			       unsigned int cond,
 			       snd_pcm_hw_param_t var,
 			       const struct snd_pcm_hw_constraint_list *l);
+int snd_pcm_hw_constraint_ranges(struct snd_pcm_runtime *runtime,
+				 unsigned int cond,
+				 snd_pcm_hw_param_t var,
+				 const struct snd_pcm_hw_constraint_ranges *r);
 int snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime, 
 				  unsigned int cond,
 				  snd_pcm_hw_param_t var,

commit adc2ae0bb6daa2287d1a6567d18be01da546f7a7
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Jan 3 17:56:14 2015 +0100

    ALSA: pcm: Remove unused functions declaration
    
    Remove function declarations for functions that don't have a matching
    implementation.
    
    For snd_pcm_build_linear_format the implementation was removed in
    64d27f96cb719cf8 ("[ALSA] Support 3-bytes 24bit format in PCM OSS
    emulation"). All the others never had one (as far as git history goes).
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index bf32cea2202e..cd09c1b05c24 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -518,7 +518,6 @@ void snd_pcm_release_substream(struct snd_pcm_substream *substream);
 int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream, struct file *file,
 			     struct snd_pcm_substream **rsubstream);
 void snd_pcm_detach_substream(struct snd_pcm_substream *substream);
-void snd_pcm_vma_notify_data(void *client, void *data);
 int snd_pcm_mmap_data(struct snd_pcm_substream *substream, struct file *file, struct vm_area_struct *area);
 
 
@@ -984,21 +983,15 @@ int snd_pcm_format_physical_width(snd_pcm_format_t format);		/* in bits */
 ssize_t snd_pcm_format_size(snd_pcm_format_t format, size_t samples);
 const unsigned char *snd_pcm_format_silence_64(snd_pcm_format_t format);
 int snd_pcm_format_set_silence(snd_pcm_format_t format, void *buf, unsigned int frames);
-snd_pcm_format_t snd_pcm_build_linear_format(int width, int unsigned, int big_endian);
 
 void snd_pcm_set_ops(struct snd_pcm * pcm, int direction,
 		     const struct snd_pcm_ops *ops);
 void snd_pcm_set_sync(struct snd_pcm_substream *substream);
-int snd_pcm_lib_interleave_len(struct snd_pcm_substream *substream);
 int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,
 		      unsigned int cmd, void *arg);                      
 int snd_pcm_update_state(struct snd_pcm_substream *substream,
 			 struct snd_pcm_runtime *runtime);
 int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream);
-int snd_pcm_playback_xrun_check(struct snd_pcm_substream *substream);
-int snd_pcm_capture_xrun_check(struct snd_pcm_substream *substream);
-int snd_pcm_playback_xrun_asap(struct snd_pcm_substream *substream);
-int snd_pcm_capture_xrun_asap(struct snd_pcm_substream *substream);
 void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_uframes_t new_hw_ptr);
 void snd_pcm_period_elapsed(struct snd_pcm_substream *substream);
 snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream,

commit 48d882978eb0a15547093b4542a82b5c22548041
Author: Libin Yang <libin.yang@intel.com>
Date:   Wed Dec 31 22:09:54 2014 +0800

    ALSA: pcm: add SNDRV_PCM_TRIGGER_DRAIN trigger
    
    Add SNDRV_PCM_TRIGGER_DRAIN trigger for pcm drain.
    
    Some audio devices require notification of drain events
    in order to properly drain and shutdown an audio stream.
    
    Signed-off-by: Libin Yang <libin.yang@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 3652c9439af9..bf32cea2202e 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -106,6 +106,7 @@ struct snd_pcm_ops {
 #define SNDRV_PCM_TRIGGER_PAUSE_RELEASE	4
 #define SNDRV_PCM_TRIGGER_SUSPEND	5
 #define SNDRV_PCM_TRIGGER_RESUME	6
+#define SNDRV_PCM_TRIGGER_DRAIN		7
 
 #define SNDRV_PCM_POS_XRUN		((snd_pcm_uframes_t)-1)
 

commit b3a8c862cd33b97c920122248ed9931af546de54
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Dec 29 19:41:39 2014 +0100

    ALSA: pcm: Remove unused SNDRV_PCM_IOCTL1_{FALSE,TRUE} defines
    
    Both SNDRV_PCM_IOCTL1_FALSE and SNDRV_PCM_IOCTL1_TRUE are unused and have in
    fact never been used (at least as far as the git history goes).
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index b429b73e875e..3652c9439af9 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -94,9 +94,6 @@ struct snd_pcm_ops {
 #define SNDRV_PCM_DEVICES	8
 #endif
 
-#define SNDRV_PCM_IOCTL1_FALSE		((void *)0)
-#define SNDRV_PCM_IOCTL1_TRUE		((void *)1)
-
 #define SNDRV_PCM_IOCTL1_RESET		0
 #define SNDRV_PCM_IOCTL1_INFO		1
 #define SNDRV_PCM_IOCTL1_CHANNEL_INFO	2

commit 62f64a880af2e82d1b41cb02cb43b88d30413993
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Dec 29 19:41:40 2014 +0100

    ALSA: pcm: Fix kerneldoc for params_*() functions
    
    Fix a copy and paste error in the kernel doc description for the params_*()
    functions.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 1e7f74acc2ec..b429b73e875e 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -857,7 +857,7 @@ static inline unsigned int params_channels(const struct snd_pcm_hw_params *p)
 }
 
 /**
- * params_channels - Get the sample rate from the hw params
+ * params_rate - Get the sample rate from the hw params
  * @p: hw params
  */
 static inline unsigned int params_rate(const struct snd_pcm_hw_params *p)
@@ -866,7 +866,7 @@ static inline unsigned int params_rate(const struct snd_pcm_hw_params *p)
 }
 
 /**
- * params_channels - Get the period size (in frames) from the hw params
+ * params_period_size - Get the period size (in frames) from the hw params
  * @p: hw params
  */
 static inline unsigned int params_period_size(const struct snd_pcm_hw_params *p)
@@ -875,7 +875,7 @@ static inline unsigned int params_period_size(const struct snd_pcm_hw_params *p)
 }
 
 /**
- * params_channels - Get the number of periods from the hw params
+ * params_periods - Get the number of periods from the hw params
  * @p: hw params
  */
 static inline unsigned int params_periods(const struct snd_pcm_hw_params *p)
@@ -884,7 +884,7 @@ static inline unsigned int params_periods(const struct snd_pcm_hw_params *p)
 }
 
 /**
- * params_channels - Get the buffer size (in frames) from the hw params
+ * params_buffer_size - Get the buffer size (in frames) from the hw params
  * @p: hw params
  */
 static inline unsigned int params_buffer_size(const struct snd_pcm_hw_params *p)
@@ -893,7 +893,7 @@ static inline unsigned int params_buffer_size(const struct snd_pcm_hw_params *p)
 }
 
 /**
- * params_channels - Get the buffer size (in bytes) from the hw params
+ * params_buffer_bytes - Get the buffer size (in bytes) from the hw params
  * @p: hw params
  */
 static inline unsigned int params_buffer_bytes(const struct snd_pcm_hw_params *p)

commit 50314663877b3c5f08b2573c0bb161b6a2c63c3e
Merge: 6874daad4b0f d42472ecffd7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 28 18:30:19 2014 +0100

    Merge branch 'for-linus' into for-next
    
    The commit [7a2e9ddc: ALSA: usb-audio: Add native DSD support for
    Denon/Marantz DACs] requires the new format definition that has
    landed only in for-next branch.

commit d42472ecffd7c42086c6e5b1335c99a3adf58a09
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Fri Nov 21 16:04:46 2014 +0200

    ALSA: pcm: Add big-endian DSD sample formats and fix XMOS DSD sample format
    
    This patch fixes XMOS DSD sample format to DSD_U32_BE and also adds
    DSD_U16_BE and DSD_U32_BE sample formats.
    
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Acked-by: Jurgen Kramer <gtmkramer@xs4all.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index e862497f7556..8bb00a27e219 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -184,6 +184,8 @@ struct snd_pcm_ops {
 #define SNDRV_PCM_FMTBIT_DSD_U8		_SNDRV_PCM_FMTBIT(DSD_U8)
 #define SNDRV_PCM_FMTBIT_DSD_U16_LE	_SNDRV_PCM_FMTBIT(DSD_U16_LE)
 #define SNDRV_PCM_FMTBIT_DSD_U32_LE	_SNDRV_PCM_FMTBIT(DSD_U32_LE)
+#define SNDRV_PCM_FMTBIT_DSD_U16_BE	_SNDRV_PCM_FMTBIT(DSD_U16_BE)
+#define SNDRV_PCM_FMTBIT_DSD_U32_BE	_SNDRV_PCM_FMTBIT(DSD_U32_BE)
 
 #ifdef SNDRV_LITTLE_ENDIAN
 #define SNDRV_PCM_FMTBIT_S16		SNDRV_PCM_FMTBIT_S16_LE

commit 1fb8510cdb5b7befe8a59f533c7fc12ef0dac73e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 7 17:08:28 2014 +0100

    ALSA: pcm: Add snd_pcm_stop_xrun() helper
    
    Add a new helper function snd_pcm_stop_xrun() to the standard sequnce
    lock/snd_pcm_stop(XRUN)/unlock by a single call, and replace the
    existing open codes with this helper.
    
    The function checks the PCM running state to prevent setting the wrong
    state, too, for more safety.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 0b8daeed0a33..40289ec2451c 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -506,6 +506,7 @@ int snd_pcm_status(struct snd_pcm_substream *substream,
 int snd_pcm_start(struct snd_pcm_substream *substream);
 int snd_pcm_stop(struct snd_pcm_substream *substream, snd_pcm_state_t status);
 int snd_pcm_drain_done(struct snd_pcm_substream *substream);
+int snd_pcm_stop_xrun(struct snd_pcm_substream *substream);
 #ifdef CONFIG_PM
 int snd_pcm_suspend(struct snd_pcm_substream *substream);
 int snd_pcm_suspend_all(struct snd_pcm *pcm);

commit 2b30d411dbc6eddfb5b4f9afd5a2c57b6f4dd96c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 4 14:02:40 2014 +0100

    ALSA: pcm: Add xrun_injection proc entry
    
    This patch adds a new proc entry for PCM substreams to inject an
    XRUN.  When a PCM substream is running and any value is written to its
    xrun_injection proc file, the driver triggers XRUN.  This is a useful
    feature for debugging XRUN and error handling code paths.
    
    Note that this entry is enabled only when CONFIG_SND_PCM_XRUN_DEBUG is
    set.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 29eb09ef2969..0b8daeed0a33 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -416,7 +416,10 @@ struct snd_pcm_substream {
 	struct snd_info_entry *proc_status_entry;
 	struct snd_info_entry *proc_prealloc_entry;
 	struct snd_info_entry *proc_prealloc_max_entry;
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
+	struct snd_info_entry *proc_xrun_injection_entry;
 #endif
+#endif /* CONFIG_SND_VERBOSE_PROCFS */
 	/* misc flags */
 	unsigned int hw_opened: 1;
 };

commit 85926e0fe8b48fe6227614ddc3a1cb41c0a3c51a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 30 15:06:13 2014 +0100

    ALSA: pcm: Convert params_*() with static inline functions
    
    ... and add proper kerneldoc comments.
    There is no big reason to keep them as macros.  Static inline
    functions are safer in general, and suitable for kerneldoc, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index f78a5722f5cc..29eb09ef2969 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -841,18 +841,59 @@ static inline const struct snd_interval *hw_param_interval_c(const struct snd_pc
 	return &params->intervals[var - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL];
 }
 
-#define params_channels(p) \
-	(hw_param_interval_c((p), SNDRV_PCM_HW_PARAM_CHANNELS)->min)
-#define params_rate(p) \
-	(hw_param_interval_c((p), SNDRV_PCM_HW_PARAM_RATE)->min)
-#define params_period_size(p) \
-	(hw_param_interval_c((p), SNDRV_PCM_HW_PARAM_PERIOD_SIZE)->min)
-#define params_periods(p) \
-	(hw_param_interval_c((p), SNDRV_PCM_HW_PARAM_PERIODS)->min)
-#define params_buffer_size(p) \
-	(hw_param_interval_c((p), SNDRV_PCM_HW_PARAM_BUFFER_SIZE)->min)
-#define params_buffer_bytes(p) \
-	(hw_param_interval_c((p), SNDRV_PCM_HW_PARAM_BUFFER_BYTES)->min)
+/**
+ * params_channels - Get the number of channels from the hw params
+ * @p: hw params
+ */
+static inline unsigned int params_channels(const struct snd_pcm_hw_params *p)
+{
+	return hw_param_interval_c(p, SNDRV_PCM_HW_PARAM_CHANNELS)->min;
+}
+
+/**
+ * params_channels - Get the sample rate from the hw params
+ * @p: hw params
+ */
+static inline unsigned int params_rate(const struct snd_pcm_hw_params *p)
+{
+	return hw_param_interval_c(p, SNDRV_PCM_HW_PARAM_RATE)->min;
+}
+
+/**
+ * params_channels - Get the period size (in frames) from the hw params
+ * @p: hw params
+ */
+static inline unsigned int params_period_size(const struct snd_pcm_hw_params *p)
+{
+	return hw_param_interval_c(p, SNDRV_PCM_HW_PARAM_PERIOD_SIZE)->min;
+}
+
+/**
+ * params_channels - Get the number of periods from the hw params
+ * @p: hw params
+ */
+static inline unsigned int params_periods(const struct snd_pcm_hw_params *p)
+{
+	return hw_param_interval_c(p, SNDRV_PCM_HW_PARAM_PERIODS)->min;
+}
+
+/**
+ * params_channels - Get the buffer size (in frames) from the hw params
+ * @p: hw params
+ */
+static inline unsigned int params_buffer_size(const struct snd_pcm_hw_params *p)
+{
+	return hw_param_interval_c(p, SNDRV_PCM_HW_PARAM_BUFFER_SIZE)->min;
+}
+
+/**
+ * params_channels - Get the buffer size (in bytes) from the hw params
+ * @p: hw params
+ */
+static inline unsigned int params_buffer_bytes(const struct snd_pcm_hw_params *p)
+{
+	return hw_param_interval_c(p, SNDRV_PCM_HW_PARAM_BUFFER_BYTES)->min;
+}
 
 int snd_interval_refine(struct snd_interval *i, const struct snd_interval *v);
 void snd_interval_mul(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c);

commit 30b771cf8c3120c5c946811ecc5a9b87a34003a2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 30 15:02:50 2014 +0100

    ALSA: pcm: More kerneldoc updates
    
    Add proper kerneldoc comments to the exported functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 5c3310d7d4b8..f78a5722f5cc 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -533,6 +533,12 @@ snd_pcm_debug_name(struct snd_pcm_substream *substream, char *buf, size_t size)
  *  PCM library
  */
 
+/**
+ * snd_pcm_stream_linked - Check whether the substream is linked with others
+ * @substream: substream to check
+ *
+ * Returns true if the given substream is being linked with others.
+ */
 static inline int snd_pcm_stream_linked(struct snd_pcm_substream *substream)
 {
 	return substream->group != &substream->self_group;
@@ -543,6 +549,16 @@ void snd_pcm_stream_unlock(struct snd_pcm_substream *substream);
 void snd_pcm_stream_lock_irq(struct snd_pcm_substream *substream);
 void snd_pcm_stream_unlock_irq(struct snd_pcm_substream *substream);
 unsigned long _snd_pcm_stream_lock_irqsave(struct snd_pcm_substream *substream);
+
+/**
+ * snd_pcm_stream_lock_irqsave - Lock the PCM stream
+ * @substream: PCM substream
+ * @flags: irq flags
+ *
+ * This locks the PCM stream like snd_pcm_stream_lock() but with the local
+ * IRQ (only when nonatomic is false).  In nonatomic case, this is identical
+ * as snd_pcm_stream_lock().
+ */
 #define snd_pcm_stream_lock_irqsave(substream, flags)		 \
 	do {							 \
 		typecheck(unsigned long, flags);		 \
@@ -551,9 +567,25 @@ unsigned long _snd_pcm_stream_lock_irqsave(struct snd_pcm_substream *substream);
 void snd_pcm_stream_unlock_irqrestore(struct snd_pcm_substream *substream,
 				      unsigned long flags);
 
+/**
+ * snd_pcm_group_for_each_entry - iterate over the linked substreams
+ * @s: the iterator
+ * @substream: the substream
+ *
+ * Iterate over the all linked substreams to the given @substream.
+ * When @substream isn't linked with any others, this gives returns @substream
+ * itself once.
+ */
 #define snd_pcm_group_for_each_entry(s, substream) \
 	list_for_each_entry(s, &substream->group->substreams, link_list)
 
+/**
+ * snd_pcm_running - Check whether the substream is in a running state
+ * @substream: substream to check
+ *
+ * Returns true if the given substream is in the state RUNNING, or in the
+ * state DRAINING for playback.
+ */
 static inline int snd_pcm_running(struct snd_pcm_substream *substream)
 {
 	return (substream->runtime->status->state == SNDRV_PCM_STATE_RUNNING ||
@@ -561,45 +593,81 @@ static inline int snd_pcm_running(struct snd_pcm_substream *substream)
 		 substream->stream == SNDRV_PCM_STREAM_PLAYBACK));
 }
 
+/**
+ * bytes_to_samples - Unit conversion of the size from bytes to samples
+ * @runtime: PCM runtime instance
+ * @size: size in bytes
+ */
 static inline ssize_t bytes_to_samples(struct snd_pcm_runtime *runtime, ssize_t size)
 {
 	return size * 8 / runtime->sample_bits;
 }
 
+/**
+ * bytes_to_frames - Unit conversion of the size from bytes to frames
+ * @runtime: PCM runtime instance
+ * @size: size in bytes
+ */
 static inline snd_pcm_sframes_t bytes_to_frames(struct snd_pcm_runtime *runtime, ssize_t size)
 {
 	return size * 8 / runtime->frame_bits;
 }
 
+/**
+ * samples_to_bytes - Unit conversion of the size from samples to bytes
+ * @runtime: PCM runtime instance
+ * @size: size in samples
+ */
 static inline ssize_t samples_to_bytes(struct snd_pcm_runtime *runtime, ssize_t size)
 {
 	return size * runtime->sample_bits / 8;
 }
 
+/**
+ * frames_to_bytes - Unit conversion of the size from frames to bytes
+ * @runtime: PCM runtime instance
+ * @size: size in frames
+ */
 static inline ssize_t frames_to_bytes(struct snd_pcm_runtime *runtime, snd_pcm_sframes_t size)
 {
 	return size * runtime->frame_bits / 8;
 }
 
+/**
+ * frame_aligned - Check whether the byte size is aligned to frames
+ * @runtime: PCM runtime instance
+ * @bytes: size in bytes
+ */
 static inline int frame_aligned(struct snd_pcm_runtime *runtime, ssize_t bytes)
 {
 	return bytes % runtime->byte_align == 0;
 }
 
+/**
+ * snd_pcm_lib_buffer_bytes - Get the buffer size of the current PCM in bytes
+ * @substream: PCM substream
+ */
 static inline size_t snd_pcm_lib_buffer_bytes(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	return frames_to_bytes(runtime, runtime->buffer_size);
 }
 
+/**
+ * snd_pcm_lib_period_bytes - Get the period size of the current PCM in bytes
+ * @substream: PCM substream
+ */
 static inline size_t snd_pcm_lib_period_bytes(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	return frames_to_bytes(runtime, runtime->period_size);
 }
 
-/*
- *  result is: 0 ... (boundary - 1)
+/**
+ * snd_pcm_playback_avail - Get the available (writable) space for playback
+ * @runtime: PCM runtime instance
+ *
+ * Result is between 0 ... (boundary - 1)
  */
 static inline snd_pcm_uframes_t snd_pcm_playback_avail(struct snd_pcm_runtime *runtime)
 {
@@ -611,8 +679,11 @@ static inline snd_pcm_uframes_t snd_pcm_playback_avail(struct snd_pcm_runtime *r
 	return avail;
 }
 
-/*
- *  result is: 0 ... (boundary - 1)
+/**
+ * snd_pcm_playback_avail - Get the available (readable) space for capture
+ * @runtime: PCM runtime instance
+ *
+ * Result is between 0 ... (boundary - 1)
  */
 static inline snd_pcm_uframes_t snd_pcm_capture_avail(struct snd_pcm_runtime *runtime)
 {
@@ -622,11 +693,19 @@ static inline snd_pcm_uframes_t snd_pcm_capture_avail(struct snd_pcm_runtime *ru
 	return avail;
 }
 
+/**
+ * snd_pcm_playback_hw_avail - Get the queued space for playback
+ * @runtime: PCM runtime instance
+ */
 static inline snd_pcm_sframes_t snd_pcm_playback_hw_avail(struct snd_pcm_runtime *runtime)
 {
 	return runtime->buffer_size - snd_pcm_playback_avail(runtime);
 }
 
+/**
+ * snd_pcm_capture_hw_avail - Get the free space for capture
+ * @runtime: PCM runtime instance
+ */
 static inline snd_pcm_sframes_t snd_pcm_capture_hw_avail(struct snd_pcm_runtime *runtime)
 {
 	return runtime->buffer_size - snd_pcm_capture_avail(runtime);
@@ -706,6 +785,20 @@ static inline int snd_pcm_capture_empty(struct snd_pcm_substream *substream)
 	return snd_pcm_capture_avail(runtime) == 0;
 }
 
+/**
+ * snd_pcm_trigger_done - Mark the master substream
+ * @substream: the pcm substream instance
+ * @master: the linked master substream
+ *
+ * When multiple substreams of the same card are linked and the hardware
+ * supports the single-shot operation, the driver calls this in the loop
+ * in snd_pcm_group_for_each_entry() for marking the substream as "done".
+ * Then most of trigger operations are performed only to the given master
+ * substream.
+ *
+ * The trigger_master mark is cleared at timestamp updates at the end
+ * of trigger operations.
+ */
 static inline void snd_pcm_trigger_done(struct snd_pcm_substream *substream, 
 					struct snd_pcm_substream *master)
 {
@@ -881,6 +974,14 @@ unsigned int snd_pcm_rate_bit_to_rate(unsigned int rate_bit);
 unsigned int snd_pcm_rate_mask_intersect(unsigned int rates_a,
 					 unsigned int rates_b);
 
+/**
+ * snd_pcm_set_runtime_buffer - Set the PCM runtime buffer
+ * @substream: PCM substream to set
+ * @bufp: the buffer information, NULL to clear
+ *
+ * Copy the buffer information to runtime->dma_buffer when @bufp is non-NULL.
+ * Otherwise it clears the current buffer information.
+ */
 static inline void snd_pcm_set_runtime_buffer(struct snd_pcm_substream *substream,
 					      struct snd_dma_buffer *bufp)
 {
@@ -906,6 +1007,11 @@ void snd_pcm_timer_resolution_change(struct snd_pcm_substream *substream);
 void snd_pcm_timer_init(struct snd_pcm_substream *substream);
 void snd_pcm_timer_done(struct snd_pcm_substream *substream);
 
+/**
+ * snd_pcm_gettime - Fill the timespec depending on the timestamp mode
+ * @runtime: PCM runtime instance
+ * @tv: timespec to fill
+ */
 static inline void snd_pcm_gettime(struct snd_pcm_runtime *runtime,
 				   struct timespec *tv)
 {
@@ -997,18 +1103,35 @@ struct page *snd_pcm_sgbuf_ops_page(struct snd_pcm_substream *substream,
 #define snd_pcm_sgbuf_ops_page	NULL
 #endif /* SND_DMA_SGBUF */
 
+/**
+ * snd_pcm_sgbuf_get_addr - Get the DMA address at the corresponding offset
+ * @substream: PCM substream
+ * @ofs: byte offset
+ */
 static inline dma_addr_t
 snd_pcm_sgbuf_get_addr(struct snd_pcm_substream *substream, unsigned int ofs)
 {
 	return snd_sgbuf_get_addr(snd_pcm_get_dma_buf(substream), ofs);
 }
 
+/**
+ * snd_pcm_sgbuf_get_ptr - Get the virtual address at the corresponding offset
+ * @substream: PCM substream
+ * @ofs: byte offset
+ */
 static inline void *
 snd_pcm_sgbuf_get_ptr(struct snd_pcm_substream *substream, unsigned int ofs)
 {
 	return snd_sgbuf_get_ptr(snd_pcm_get_dma_buf(substream), ofs);
 }
 
+/**
+ * snd_pcm_sgbuf_chunk_size - Compute the max size that fits within the contig.
+ * page from the given size
+ * @substream: PCM substream
+ * @ofs: byte offset
+ * @size: byte size to examine
+ */
 static inline unsigned int
 snd_pcm_sgbuf_get_chunk_size(struct snd_pcm_substream *substream,
 			     unsigned int ofs, unsigned int size)
@@ -1016,13 +1139,24 @@ snd_pcm_sgbuf_get_chunk_size(struct snd_pcm_substream *substream,
 	return snd_sgbuf_get_chunk_size(snd_pcm_get_dma_buf(substream), ofs, size);
 }
 
-/* handle mmap counter - PCM mmap callback should handle this counter properly */
+/**
+ * snd_pcm_mmap_data_open - increase the mmap counter
+ * @area: VMA
+ *
+ * PCM mmap callback should handle this counter properly
+ */
 static inline void snd_pcm_mmap_data_open(struct vm_area_struct *area)
 {
 	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)area->vm_private_data;
 	atomic_inc(&substream->mmap_count);
 }
 
+/**
+ * snd_pcm_mmap_data_close - decrease the mmap counter
+ * @area: VMA
+ *
+ * PCM mmap callback should handle this counter properly
+ */
 static inline void snd_pcm_mmap_data_close(struct vm_area_struct *area)
 {
 	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)area->vm_private_data;
@@ -1042,6 +1176,11 @@ int snd_pcm_lib_mmap_iomem(struct snd_pcm_substream *substream, struct vm_area_s
 
 #define snd_pcm_lib_mmap_vmalloc NULL
 
+/**
+ * snd_pcm_limit_isa_dma_size - Get the max size fitting with ISA DMA transfer
+ * @dma: DMA number
+ * @max: pointer to store the max size
+ */
 static inline void snd_pcm_limit_isa_dma_size(int dma, size_t *max)
 {
 	*max = dma < 4 ? 64 * 1024 : 128 * 1024;
@@ -1094,7 +1233,11 @@ struct snd_pcm_chmap {
 	void *private_data;	/* optional: private data pointer */
 };
 
-/* get the PCM substream assigned to the given chmap info */
+/**
+ * snd_pcm_chmap_substream - get the PCM substream assigned to the given chmap info
+ * @info: chmap information
+ * @idx: the substream number index
+ */
 static inline struct snd_pcm_substream *
 snd_pcm_chmap_substream(struct snd_pcm_chmap *info, unsigned int idx)
 {
@@ -1121,7 +1264,10 @@ int snd_pcm_add_chmap_ctls(struct snd_pcm *pcm, int stream,
 			   unsigned long private_value,
 			   struct snd_pcm_chmap **info_ret);
 
-/* Strong-typed conversion of pcm_format to bitwise */
+/**
+ * pcm_format_to_bits - Strong-typed conversion of pcm_format to bitwise
+ * @pcm_format: PCM format
+ */
 static inline u64 pcm_format_to_bits(snd_pcm_format_t pcm_format)
 {
 	return 1ULL << (__force int) pcm_format;

commit f213d8f79a3928eaa2e2936f8ab40761aac04b95
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 30 13:45:58 2014 +0100

    ALSA: pcm: Use static inline for snd_pcm_lib_alloc_vmalloc_buffer()
    
    ... instead of #if 0 hack.  It's more straightforward and obvious.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index e862497f7556..5c3310d7d4b8 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -942,7 +942,6 @@ int _snd_pcm_lib_alloc_vmalloc_buffer(struct snd_pcm_substream *substream,
 int snd_pcm_lib_free_vmalloc_buffer(struct snd_pcm_substream *substream);
 struct page *snd_pcm_lib_get_vmalloc_page(struct snd_pcm_substream *substream,
 					  unsigned long offset);
-#if 0 /* for kernel-doc */
 /**
  * snd_pcm_lib_alloc_vmalloc_buffer - allocate virtual DMA buffer
  * @substream: the substream to allocate the buffer to
@@ -955,8 +954,13 @@ struct page *snd_pcm_lib_get_vmalloc_page(struct snd_pcm_substream *substream,
  * Return: 1 if the buffer was changed, 0 if not changed, or a negative error
  * code.
  */
-static int snd_pcm_lib_alloc_vmalloc_buffer
-			(struct snd_pcm_substream *substream, size_t size);
+static inline int snd_pcm_lib_alloc_vmalloc_buffer
+			(struct snd_pcm_substream *substream, size_t size)
+{
+	return _snd_pcm_lib_alloc_vmalloc_buffer(substream, size,
+						 GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO);
+}
+
 /**
  * snd_pcm_lib_alloc_vmalloc_32_buffer - allocate 32-bit-addressable buffer
  * @substream: the substream to allocate the buffer to
@@ -968,15 +972,12 @@ static int snd_pcm_lib_alloc_vmalloc_buffer
  * Return: 1 if the buffer was changed, 0 if not changed, or a negative error
  * code.
  */
-static int snd_pcm_lib_alloc_vmalloc_32_buffer
-			(struct snd_pcm_substream *substream, size_t size);
-#endif
-#define snd_pcm_lib_alloc_vmalloc_buffer(subs, size) \
-	_snd_pcm_lib_alloc_vmalloc_buffer \
-			(subs, size, GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO)
-#define snd_pcm_lib_alloc_vmalloc_32_buffer(subs, size) \
-	_snd_pcm_lib_alloc_vmalloc_buffer \
-			(subs, size, GFP_KERNEL | GFP_DMA32 | __GFP_ZERO)
+static inline int snd_pcm_lib_alloc_vmalloc_32_buffer
+			(struct snd_pcm_substream *substream, size_t size)
+{
+	return _snd_pcm_lib_alloc_vmalloc_buffer(substream, size,
+						 GFP_KERNEL | GFP_DMA32 | __GFP_ZERO);
+}
 
 #define snd_pcm_get_dma_buf(substream) ((substream)->runtime->dma_buffer_p)
 

commit d4288d3fac18bbc31cb6d369679b1fa1d9321ae9
Author: Jurgen Kramer <gtmkramer@xs4all.nl>
Date:   Fri Sep 5 10:47:56 2014 +0200

    ALSA: pcm: add new DSD sampleformat for native DSD playback on XMOS based devices
    
    XMOS based USB DACs with native DSD support expose this feature via a USB
    alternate setting. The audio format is either 32-bit raw or a 32-bit PCM format.
    To utilize this feature on linux this patch introduces a new 32-bit DSD
    sampleformat DSD_U32_LE.
    A follow up patch will add a quirk for XMOS based devices to utilize the new format.
    Further patches will add support to alsa-lib.
    
    Signed-off-by: Jurgen Kramer <gtmkramer@xs4all.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 67e0bdb9f0fa..e862497f7556 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -183,6 +183,7 @@ struct snd_pcm_ops {
 #define SNDRV_PCM_FMTBIT_G723_40_1B	_SNDRV_PCM_FMTBIT(G723_40_1B)
 #define SNDRV_PCM_FMTBIT_DSD_U8		_SNDRV_PCM_FMTBIT(DSD_U8)
 #define SNDRV_PCM_FMTBIT_DSD_U16_LE	_SNDRV_PCM_FMTBIT(DSD_U16_LE)
+#define SNDRV_PCM_FMTBIT_DSD_U32_LE	_SNDRV_PCM_FMTBIT(DSD_U32_LE)
 
 #ifdef SNDRV_LITTLE_ENDIAN
 #define SNDRV_PCM_FMTBIT_S16		SNDRV_PCM_FMTBIT_S16_LE

commit 7af142f752116e86adbe2073f2922d8265a77709
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 1 11:19:37 2014 +0200

    ALSA: pcm: Uninline snd_pcm_stream_lock() and _unlock()
    
    The previous commit for the non-atomic PCM ops added more codes to
    snd_pcm_stream_lock() and its variants.  Since they are inlined
    functions, it resulted in a significant code size bloat.  For reducing
    the size bloat, this patch changes the inline functions to the normal
    function calls.  The export of rwlock and rwsem are removed as well,
    since they are referred only in pcm_native.c now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index bc79962f4aa6..67e0bdb9f0fa 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -494,9 +494,6 @@ int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree);
  *  Native I/O
  */
 
-extern rwlock_t snd_pcm_link_rwlock;
-extern struct rw_semaphore snd_pcm_link_rwsem;
-
 int snd_pcm_info(struct snd_pcm_substream *substream, struct snd_pcm_info *info);
 int snd_pcm_info_user(struct snd_pcm_substream *substream,
 		      struct snd_pcm_info __user *info);
@@ -540,72 +537,18 @@ static inline int snd_pcm_stream_linked(struct snd_pcm_substream *substream)
 	return substream->group != &substream->self_group;
 }
 
-static inline void snd_pcm_stream_lock(struct snd_pcm_substream *substream)
-{
-	if (substream->pcm->nonatomic) {
-		down_read(&snd_pcm_link_rwsem);
-		mutex_lock(&substream->self_group.mutex);
-	} else {
-		read_lock(&snd_pcm_link_rwlock);
-		spin_lock(&substream->self_group.lock);
-	}
-}
-
-static inline void snd_pcm_stream_unlock(struct snd_pcm_substream *substream)
-{
-	if (substream->pcm->nonatomic) {
-		mutex_unlock(&substream->self_group.mutex);
-		up_read(&snd_pcm_link_rwsem);
-	} else {
-		spin_unlock(&substream->self_group.lock);
-		read_unlock(&snd_pcm_link_rwlock);
-	}
-}
-
-static inline void snd_pcm_stream_lock_irq(struct snd_pcm_substream *substream)
-{
-	if (substream->pcm->nonatomic) {
-		down_read(&snd_pcm_link_rwsem);
-		mutex_lock(&substream->self_group.mutex);
-	} else {
-		read_lock_irq(&snd_pcm_link_rwlock);
-		spin_lock(&substream->self_group.lock);
-	}
-}
-
-static inline void snd_pcm_stream_unlock_irq(struct snd_pcm_substream *substream)
-{
-	if (substream->pcm->nonatomic) {
-		mutex_unlock(&substream->self_group.mutex);
-		up_read(&snd_pcm_link_rwsem);
-	} else {
-		spin_unlock(&substream->self_group.lock);
-		read_unlock_irq(&snd_pcm_link_rwlock);
-	}
-}
-
-#define snd_pcm_stream_lock_irqsave(substream, flags) \
-do { \
-	if ((substream)->pcm->nonatomic) {			  \
-		(flags) = 0; /* XXX for avoid warning */	  \
-		down_read(&snd_pcm_link_rwsem);			  \
-		mutex_lock(&(substream)->self_group.mutex);	  \
-	} else {						  \
-		read_lock_irqsave(&snd_pcm_link_rwlock, (flags)); \
-		spin_lock(&(substream)->self_group.lock);	  \
-	}							  \
-} while (0)
-
-#define snd_pcm_stream_unlock_irqrestore(substream, flags) \
-do { \
-	if ((substream)->pcm->nonatomic) {			       \
-		mutex_unlock(&(substream)->self_group.mutex);	       \
-		up_read(&snd_pcm_link_rwsem);			       \
-	} else {						       \
-		spin_unlock(&(substream)->self_group.lock);	       \
-		read_unlock_irqrestore(&snd_pcm_link_rwlock, (flags)); \
-	}							       \
-} while (0)
+void snd_pcm_stream_lock(struct snd_pcm_substream *substream);
+void snd_pcm_stream_unlock(struct snd_pcm_substream *substream);
+void snd_pcm_stream_lock_irq(struct snd_pcm_substream *substream);
+void snd_pcm_stream_unlock_irq(struct snd_pcm_substream *substream);
+unsigned long _snd_pcm_stream_lock_irqsave(struct snd_pcm_substream *substream);
+#define snd_pcm_stream_lock_irqsave(substream, flags)		 \
+	do {							 \
+		typecheck(unsigned long, flags);		 \
+		flags = _snd_pcm_stream_lock_irqsave(substream); \
+	} while (0)
+void snd_pcm_stream_unlock_irqrestore(struct snd_pcm_substream *substream,
+				      unsigned long flags);
 
 #define snd_pcm_group_for_each_entry(s, substream) \
 	list_for_each_entry(s, &substream->group->substreams, link_list)

commit 257f8cce5d40b811d229ed71602882baa0012808
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 29 15:32:29 2014 +0200

    ALSA: pcm: Allow nonatomic trigger operations
    
    Currently, many PCM operations are performed in a critical section
    protected by spinlock, typically the trigger and pointer callbacks are
    assumed to be atomic.  This is basically because some trigger action
    (e.g. PCM stop after drain or xrun) is done in the interrupt handler.
    If a driver runs in a threaded irq, however, this doesn't have to be
    atomic.  And many devices want to handle trigger in a non-atomic
    context due to lengthy communications.
    
    This patch tries all PCM calls operational in non-atomic context.
    What it does is very simple: replaces the substream spinlock with the
    corresponding substream mutex when pcm->nonatomic flag is set.  The
    driver that wants to use the non-atomic PCM ops just needs to set the
    flag and keep the rest as is.  (Of course, it must not handle any PCM
    ops in irq context.)
    
    Note that the code doesn't check whether it's atomic-safe or not, but
    trust in 100% that the driver sets pcm->nonatomic correctly.
    
    One possible problem is the case where linked PCM substreams have
    inconsistent nonatomic states.  For avoiding this, snd_pcm_link()
    returns an error if one tries to link an inconsistent PCM substream.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 6f3e10ca0e32..bc79962f4aa6 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -365,6 +365,7 @@ struct snd_pcm_runtime {
 
 struct snd_pcm_group {		/* keep linked substreams */
 	spinlock_t lock;
+	struct mutex mutex;
 	struct list_head substreams;
 	int count;
 };
@@ -460,6 +461,7 @@ struct snd_pcm {
 	void (*private_free) (struct snd_pcm *pcm);
 	struct device *dev; /* actual hw device this belongs to */
 	bool internal; /* pcm is for internal use only */
+	bool nonatomic; /* whole PCM operations are in non-atomic context */
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	struct snd_pcm_oss oss;
 #endif
@@ -493,6 +495,7 @@ int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree);
  */
 
 extern rwlock_t snd_pcm_link_rwlock;
+extern struct rw_semaphore snd_pcm_link_rwsem;
 
 int snd_pcm_info(struct snd_pcm_substream *substream, struct snd_pcm_info *info);
 int snd_pcm_info_user(struct snd_pcm_substream *substream,
@@ -539,38 +542,69 @@ static inline int snd_pcm_stream_linked(struct snd_pcm_substream *substream)
 
 static inline void snd_pcm_stream_lock(struct snd_pcm_substream *substream)
 {
-	read_lock(&snd_pcm_link_rwlock);
-	spin_lock(&substream->self_group.lock);
+	if (substream->pcm->nonatomic) {
+		down_read(&snd_pcm_link_rwsem);
+		mutex_lock(&substream->self_group.mutex);
+	} else {
+		read_lock(&snd_pcm_link_rwlock);
+		spin_lock(&substream->self_group.lock);
+	}
 }
 
 static inline void snd_pcm_stream_unlock(struct snd_pcm_substream *substream)
 {
-	spin_unlock(&substream->self_group.lock);
-	read_unlock(&snd_pcm_link_rwlock);
+	if (substream->pcm->nonatomic) {
+		mutex_unlock(&substream->self_group.mutex);
+		up_read(&snd_pcm_link_rwsem);
+	} else {
+		spin_unlock(&substream->self_group.lock);
+		read_unlock(&snd_pcm_link_rwlock);
+	}
 }
 
 static inline void snd_pcm_stream_lock_irq(struct snd_pcm_substream *substream)
 {
-	read_lock_irq(&snd_pcm_link_rwlock);
-	spin_lock(&substream->self_group.lock);
+	if (substream->pcm->nonatomic) {
+		down_read(&snd_pcm_link_rwsem);
+		mutex_lock(&substream->self_group.mutex);
+	} else {
+		read_lock_irq(&snd_pcm_link_rwlock);
+		spin_lock(&substream->self_group.lock);
+	}
 }
 
 static inline void snd_pcm_stream_unlock_irq(struct snd_pcm_substream *substream)
 {
-	spin_unlock(&substream->self_group.lock);
-	read_unlock_irq(&snd_pcm_link_rwlock);
+	if (substream->pcm->nonatomic) {
+		mutex_unlock(&substream->self_group.mutex);
+		up_read(&snd_pcm_link_rwsem);
+	} else {
+		spin_unlock(&substream->self_group.lock);
+		read_unlock_irq(&snd_pcm_link_rwlock);
+	}
 }
 
 #define snd_pcm_stream_lock_irqsave(substream, flags) \
 do { \
-	read_lock_irqsave(&snd_pcm_link_rwlock, (flags)); \
-	spin_lock(&substream->self_group.lock); \
+	if ((substream)->pcm->nonatomic) {			  \
+		(flags) = 0; /* XXX for avoid warning */	  \
+		down_read(&snd_pcm_link_rwsem);			  \
+		mutex_lock(&(substream)->self_group.mutex);	  \
+	} else {						  \
+		read_lock_irqsave(&snd_pcm_link_rwlock, (flags)); \
+		spin_lock(&(substream)->self_group.lock);	  \
+	}							  \
 } while (0)
 
 #define snd_pcm_stream_unlock_irqrestore(substream, flags) \
 do { \
-	spin_unlock(&substream->self_group.lock); \
-	read_unlock_irqrestore(&snd_pcm_link_rwlock, (flags)); \
+	if ((substream)->pcm->nonatomic) {			       \
+		mutex_unlock(&(substream)->self_group.mutex);	       \
+		up_read(&snd_pcm_link_rwsem);			       \
+	} else {						       \
+		spin_unlock(&(substream)->self_group.lock);	       \
+		read_unlock_irqrestore(&snd_pcm_link_rwlock, (flags)); \
+	}							       \
 } while (0)
 
 #define snd_pcm_group_for_each_entry(s, substream) \

commit 0ac8a52d4541adc284a4f3e8a1f6847236de1d8a
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Jul 8 16:51:49 2014 +0200

    ALSA: Provide a CLOCK_MONOTONIC_RAW timestamp type
    
    For applications which need to synchronise with external timebases such
    as broadcast TV applications the kernel monotonic time is not optimal as
    it includes adjustments from NTP and so may still include discontinuities
    due to that. A raw monotonic time which does not include any adjustments
    is available in the kernel from getrawmonotonic() so provide userspace with
    a new timestamp type SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW which provides
    timestamps based on this as an option.
    
    [dropped tstamp_type assignment code, as it's no longer needed -- tiwai]
    
    Reported-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index d854fb31c000..6f3e10ca0e32 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -931,10 +931,17 @@ void snd_pcm_timer_done(struct snd_pcm_substream *substream);
 static inline void snd_pcm_gettime(struct snd_pcm_runtime *runtime,
 				   struct timespec *tv)
 {
-	if (runtime->tstamp_type == SNDRV_PCM_TSTAMP_TYPE_MONOTONIC)
+	switch (runtime->tstamp_type) {
+	case SNDRV_PCM_TSTAMP_TYPE_MONOTONIC:
 		ktime_get_ts(tv);
-	else
+		break;
+	case SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW:
+		getrawmonotonic(tv);
+		break;
+	default:
 		getnstimeofday(tv);
+		break;
+	}
 }
 
 /*

commit 26204e048d2ee0c65e0539f7cc2b66f845a19a41
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jun 11 23:59:14 2014 +0000

    ALSA: core: Use ktime_get_ts()
    
    do_posix_clock_monotonic_gettime() is a leftover from the initial
    posix timer implementation which maps to ktime_get_ts().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index b4d6697085fe..d854fb31c000 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -932,7 +932,7 @@ static inline void snd_pcm_gettime(struct snd_pcm_runtime *runtime,
 				   struct timespec *tv)
 {
 	if (runtime->tstamp_type == SNDRV_PCM_TSTAMP_TYPE_MONOTONIC)
-		do_posix_clock_monotonic_gettime(tv);
+		ktime_get_ts(tv);
 	else
 		getnstimeofday(tv);
 }

commit 09e56df8b37f5e751614a0d140b8bf8250812912
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:19:48 2014 +0100

    ALSA: pcm: Use standard printk helpers
    
    Use dev_err() & co as much as possible.  If not available (no device
    assigned at the calling point), use pr_xxx() helpers instead.
    
    For simplicity, introduce new helpers for pcm stream, pcm_err(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 4883499ab38b..b4d6697085fe 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1141,4 +1141,12 @@ static inline u64 pcm_format_to_bits(snd_pcm_format_t pcm_format)
 	return 1ULL << (__force int) pcm_format;
 }
 
+/* printk helpers */
+#define pcm_err(pcm, fmt, args...) \
+	dev_err((pcm)->card->dev, fmt, ##args)
+#define pcm_warn(pcm, fmt, args...) \
+	dev_warn((pcm)->card->dev, fmt, ##args)
+#define pcm_dbg(pcm, fmt, args...) \
+	dev_dbg((pcm)->card->dev, fmt, ##args)
+
 #endif /* __SOUND_PCM_H */

commit 2f43a23ab9ea1865a663e100b0af20198decb4f1
Merge: 7cfa7b547337 55dcdb505193
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jan 16 12:42:57 2014 +0000

    Merge remote-tracking branch 'asoc/topic/pcm' into for-tiwai

commit e3a9269f874067fcefc5eb8037466161fb0fe3f4
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Jan 11 10:24:43 2014 +0100

    ALSA: Add helper function for intersecting two rate masks
    
    A bit of special care is necessary when creating the intersection of two rate
    masks. This comes from the special meaning of the SNDRV_PCM_RATE_CONTINUOUS and
    SNDRV_PCM_RATE_KNOT bits, which needs special handling when intersecting two
    rate masks. SNDRV_PCM_RATE_CONTINUOUS means the hardware supports all rates in a
    specific interval. SNDRV_PCM_RATE_KNOT means the hardware supports a set of
    discrete rates specified by a list constraint. For all other cases the supported
    rates are specified directly in the rate mask.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 84b10f9a2832..d0170913374d 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -901,6 +901,8 @@ extern const struct snd_pcm_hw_constraint_list snd_pcm_known_rates;
 int snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime);
 unsigned int snd_pcm_rate_to_rate_bit(unsigned int rate);
 unsigned int snd_pcm_rate_bit_to_rate(unsigned int rate_bit);
+unsigned int snd_pcm_rate_mask_intersect(unsigned int rates_a,
+					 unsigned int rates_b);
 
 static inline void snd_pcm_set_runtime_buffer(struct snd_pcm_substream *substream,
 					      struct snd_dma_buffer *bufp)

commit 47d98c026ef9a9888c36f3c4f26b81f548a0ca86
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 8 16:12:25 2014 +0100

    ALSA: Remove memory reservation code from memalloc helper
    
    Nowadays we have CMA for obtaining the contiguous memory pages
    efficiently.  Let's kill the old kludge for reserving the memory pages
    for large buffers.  It was rarely useful (only for preserving pages
    among module reloading or a little help by an early boot scripting),
    used only by a couple of drivers, and yet it gives too much ugliness
    than its benefit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 84b10f9a2832..fe6ca400b9ad 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -381,7 +381,6 @@ struct snd_pcm_substream {
 	struct pm_qos_request latency_pm_qos_req; /* pm_qos request */
 	size_t buffer_bytes_max;	/* limit ring buffer size */
 	struct snd_dma_buffer dma_buffer;
-	unsigned int dma_buf_id;
 	size_t dma_max;
 	/* -- hardware operations -- */
 	const struct snd_pcm_ops *ops;

commit e6c2e7eb27fc512af6875d7f2cf313e29c61be0b
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri May 24 15:18:10 2013 +0200

    ALSA: Constify the snd_pcm_substream struct ops field
    
    The ops field of the snd_pcm_substream struct is never modified inside the ALSA
    core. Making it const allows drivers to declare their snd_pcm_ops struct as
    const.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index b48792fe386b..84b10f9a2832 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -384,7 +384,7 @@ struct snd_pcm_substream {
 	unsigned int dma_buf_id;
 	size_t dma_max;
 	/* -- hardware operations -- */
-	struct snd_pcm_ops *ops;
+	const struct snd_pcm_ops *ops;
 	/* -- runtime information -- */
 	struct snd_pcm_runtime *runtime;
         /* -- timer section -- */
@@ -871,7 +871,8 @@ const unsigned char *snd_pcm_format_silence_64(snd_pcm_format_t format);
 int snd_pcm_format_set_silence(snd_pcm_format_t format, void *buf, unsigned int frames);
 snd_pcm_format_t snd_pcm_build_linear_format(int width, int unsigned, int big_endian);
 
-void snd_pcm_set_ops(struct snd_pcm * pcm, int direction, struct snd_pcm_ops *ops);
+void snd_pcm_set_ops(struct snd_pcm * pcm, int direction,
+		     const struct snd_pcm_ops *ops);
 void snd_pcm_set_sync(struct snd_pcm_substream *substream);
 int snd_pcm_lib_interleave_len(struct snd_pcm_substream *substream);
 int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,

commit 9992ba72327fa0d8bdc9fb624e80f5cce338a711
Merge: 00fdffb51311 4ca231b2e6ed
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 3 09:10:23 2013 -0700

    Merge tag 'sound-3.10' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "Mostly many small changes spread as seen in diffstat in sound/*
      directory by this update.  A significant change in the subsystem level
      is the introduction of snd_soc_component, which will help more generic
      handling of SoC and off-SoC components.
    
      Also, snd_BUG_ON() macro is enabled unconditionally now due to its
      misuses, so people might hit kernel warnings (it's a good thing for
      us).
    
       - compress-offload: support for capture by Charles Keepax
       - HD-audio: codec delay support by Dylan Reid
       - HD-audio: improvements/fixes in generic parser: better headphone
         mic and headset mic support, jack_modes hint consolidation, proper
         beep attach/detachment, generalized power filter controls by David
         Henningsson, et al
       - HD-audio: Improved management of HDMI codec pins/converters
       - HD-audio: Better pin/DAC assignment for VIA codecs
       - HD-audio: Haswell HDMI workarounds
       - HD-audio: ALC268 codec support, a few new quirks for Chromebooks
       - USB: regression fixes: USB-MIDI autopm fix, the recent ISO latency
         fix by Clemens Ladisch
       - USB: support for DSD formats by Daniel Mack
       - USB: A few UAC2 device endian/cock fixes by Eldad Zack
       - USB: quirks for Emu 192kHz support, Novation Twitch DJ controller,
         Yamaha THRxx devices
       - HDSPM: updates for TCO controls by Adrian Knoth
       - ASoC: Add a snd_soc_component object type for generic handling of
         SoC and off-SoC components by Kuninori Morimoto,
       - dmaengine: a large set of cleanups and conversions by Lars-Peter
         Clausen
       - ASoC DAPM: performance optimizations from Ryo Tsutsui
       - ASoC DAPM: support for mixer control sharing by Stephen Warren
       - ASoC: multiplatform ARM cleanups from Arnd Bergmann
       - ASoC: new codec drivers for AK5385 and TAS5086 from Daniel Mack"
    
    * tag 'sound-3.10' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (315 commits)
      ALSA: usb-audio: caiaq: fix endianness bug in snd_usb_caiaq_maschine_dispatch
      ALSA: asihpi: add format support check in snd_card_asihpi_capture_formats
      ALSA: pcm_format_to_bits strong-typed conversion
      ALSA: compress: fix the states to check for allowing read
      ALSA: hda - Move Thinkpad X220 to use auto parser
      ALSA: USB: adjust for changed 3.8 USB API
      ALSA: usb - Avoid unnecessary sample rate changes on USB 2.0 clock sources
      sound: oss/dmabuf: use dma_map_single
      ALSA: ali5451: use mdelay instead of large udelay constants
      ALSA: hda - Add the support for ALC286 codec
      ALSA: usb-audio: USB quirk for Yamaha THR10C
      ALSA: usb-audio: USB quirk for Yamaha THR5A
      ALSA: usb-audio: USB quirk for Yamaha THR10
      ALSA: usb-audio: Fix autopm error during probing
      ALSA: snd-usb: try harder to find USB_DT_CS_ENDPOINT
      ALSA: sound kconfig typo
      ALSA: emu10k1: Fix dock firmware loading
      ASoC: ux500: forward declare msp_i2s_platform_data
      ASoC: davinci-mcasp: Add Support BCLK-to-LRCLK ratio for TDM modes
      ASoC: davinci-pcm, davinci-mcasp: Clean up active_serializers
      ...

commit 74c34ca1cc12884703c70d34ed333517d978c2e7
Author: Eldad Zack <eldad@fogrefinery.com>
Date:   Tue Apr 23 01:00:41 2013 +0200

    ALSA: pcm_format_to_bits strong-typed conversion
    
    Add a function to handle conversion from snd_pcm_format_t
    to bitwise with proper typing.
    
    Change such conversions to use this function and silence sparse
    warnings.
    
    Signed-off-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 1b0c6484e71a..5357ecbecc48 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1133,4 +1133,10 @@ int snd_pcm_add_chmap_ctls(struct snd_pcm *pcm, int stream,
 			   unsigned long private_value,
 			   struct snd_pcm_chmap **info_ret);
 
+/* Strong-typed conversion of pcm_format to bitwise */
+static inline u64 pcm_format_to_bits(snd_pcm_format_t pcm_format)
+{
+	return 1ULL << (__force int) pcm_format;
+}
+
 #endif /* __SOUND_PCM_H */

commit b23f7a09f93516f90c8e51d3e2d822f67d809d8b
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Thu Apr 18 00:12:55 2013 +0900

    treewide: Fix typo in printk and comments
    
    Fix typo in printk and comments within various drivers.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 45c1981c9ca2..5ec42dbd2308 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -867,7 +867,7 @@ int snd_pcm_format_physical_width(snd_pcm_format_t format);		/* in bits */
 ssize_t snd_pcm_format_size(snd_pcm_format_t format, size_t samples);
 const unsigned char *snd_pcm_format_silence_64(snd_pcm_format_t format);
 int snd_pcm_format_set_silence(snd_pcm_format_t format, void *buf, unsigned int frames);
-snd_pcm_format_t snd_pcm_build_linear_format(int width, int unsignd, int big_endian);
+snd_pcm_format_t snd_pcm_build_linear_format(int width, int unsigned, int big_endian);
 
 void snd_pcm_set_ops(struct snd_pcm * pcm, int direction, struct snd_pcm_ops *ops);
 void snd_pcm_set_sync(struct snd_pcm_substream *substream);

commit ef7a4f979bd8201324b2bcd30277c14aba889f50
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Apr 17 00:01:36 2013 +0800

    ALSA: add DSD formats
    
    This patch adds two formats for Direct Stream Digital (DSD), a
    pulse-density encoding format which is described here:
    https://en.wikipedia.org/wiki/Direct_Stream_Digital
    
    DSD operates on 2.8, 5.6 or 11.2MHz sample rates and as a 1-bit
    stream.
    
    The two new types added by this patch describe streams that are capable
    of handling DSD samples in DOP format as 8-bit or in 16-bit (or at a x8
    or x16 data rate, respectively).
    
    DSD itself specifies samples in *bit*, while DOP and ALSA handle them
    as *bytes*. Hence, a factor of 8 or 16 has to be applied for the sample
    rare configuration, according to the following table:
    
                                                      configured hardware
            176.4KHz   352.8kHz   705.6KHz     <----       sample rate
    
    8-bit                2.8MHz     5.6MHz
    16-bit    2.8Mhz     5.6MHz    11.2MHz
    
             `-----------------------------'
                 actual DSD sample rates
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index aa7b0a8385cb..1b0c6484e71a 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -181,6 +181,8 @@ struct snd_pcm_ops {
 #define SNDRV_PCM_FMTBIT_G723_24_1B	_SNDRV_PCM_FMTBIT(G723_24_1B)
 #define SNDRV_PCM_FMTBIT_G723_40	_SNDRV_PCM_FMTBIT(G723_40)
 #define SNDRV_PCM_FMTBIT_G723_40_1B	_SNDRV_PCM_FMTBIT(G723_40_1B)
+#define SNDRV_PCM_FMTBIT_DSD_U8		_SNDRV_PCM_FMTBIT(DSD_U8)
+#define SNDRV_PCM_FMTBIT_DSD_U16_LE	_SNDRV_PCM_FMTBIT(DSD_U16_LE)
 
 #ifdef SNDRV_LITTLE_ENDIAN
 #define SNDRV_PCM_FMTBIT_S16		SNDRV_PCM_FMTBIT_S16_LE

commit eb7c06e8e9c93b495e355421cffd3c43c266d7d2
Author: Yacine Belkadi <yacine.belkadi.1@gmail.com>
Date:   Mon Mar 11 22:05:14 2013 +0100

    ALSA: add/change some comments describing function return values
    
    script/kernel-doc reports the following type of warnings (when run in verbose
    mode):
    
    Warning(sound/core/init.c:152): No description found for return value of
    'snd_card_create'
    
    To fix that:
    - add missing descriptions of function return values
    - use "Return:" sections to describe those return values
    
    Along the way:
    - complete some descriptions
    - fix some typos
    
    Signed-off-by: Yacine Belkadi <yacine.belkadi.1@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 45c1981c9ca2..aa7b0a8385cb 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -659,7 +659,7 @@ static inline snd_pcm_sframes_t snd_pcm_capture_hw_avail(struct snd_pcm_runtime
  *
  * Checks whether enough free space is available on the playback buffer.
  *
- * Returns non-zero if available, or zero if not.
+ * Return: Non-zero if available, or zero if not.
  */
 static inline int snd_pcm_playback_ready(struct snd_pcm_substream *substream)
 {
@@ -673,7 +673,7 @@ static inline int snd_pcm_playback_ready(struct snd_pcm_substream *substream)
  *
  * Checks whether enough capture data is available on the capture buffer.
  *
- * Returns non-zero if available, or zero if not.
+ * Return: Non-zero if available, or zero if not.
  */
 static inline int snd_pcm_capture_ready(struct snd_pcm_substream *substream)
 {
@@ -685,10 +685,10 @@ static inline int snd_pcm_capture_ready(struct snd_pcm_substream *substream)
  * snd_pcm_playback_data - check whether any data exists on the playback buffer
  * @substream: the pcm substream instance
  *
- * Checks whether any data exists on the playback buffer. If stop_threshold
- * is bigger or equal to boundary, then this function returns always non-zero.
+ * Checks whether any data exists on the playback buffer.
  *
- * Returns non-zero if exists, or zero if not.
+ * Return: Non-zero if any data exists, or zero if not. If stop_threshold
+ * is bigger or equal to boundary, then this function returns always non-zero.
  */
 static inline int snd_pcm_playback_data(struct snd_pcm_substream *substream)
 {
@@ -705,7 +705,7 @@ static inline int snd_pcm_playback_data(struct snd_pcm_substream *substream)
  *
  * Checks whether the playback buffer is empty.
  *
- * Returns non-zero if empty, or zero if not.
+ * Return: Non-zero if empty, or zero if not.
  */
 static inline int snd_pcm_playback_empty(struct snd_pcm_substream *substream)
 {
@@ -719,7 +719,7 @@ static inline int snd_pcm_playback_empty(struct snd_pcm_substream *substream)
  *
  * Checks whether the capture buffer is empty.
  *
- * Returns non-zero if empty, or zero if not.
+ * Return: Non-zero if empty, or zero if not.
  */
 static inline int snd_pcm_capture_empty(struct snd_pcm_substream *substream)
 {
@@ -852,7 +852,7 @@ int snd_pcm_format_big_endian(snd_pcm_format_t format);
  * snd_pcm_format_cpu_endian - Check the PCM format is CPU-endian
  * @format: the format to check
  *
- * Returns 1 if the given PCM format is CPU-endian, 0 if
+ * Return: 1 if the given PCM format is CPU-endian, 0 if
  * opposite, or a negative error code if endian not specified.
  */
 int snd_pcm_format_cpu_endian(snd_pcm_format_t format);
@@ -963,7 +963,7 @@ struct page *snd_pcm_lib_get_vmalloc_page(struct snd_pcm_substream *substream,
  * contiguous in kernel virtual space, but not in physical memory.  Use this
  * if the buffer is accessed by kernel code but not by device DMA.
  *
- * Returns 1 if the buffer was changed, 0 if not changed, or a negative error
+ * Return: 1 if the buffer was changed, 0 if not changed, or a negative error
  * code.
  */
 static int snd_pcm_lib_alloc_vmalloc_buffer
@@ -975,6 +975,9 @@ static int snd_pcm_lib_alloc_vmalloc_buffer
  *
  * This function works like snd_pcm_lib_alloc_vmalloc_buffer(), but uses
  * vmalloc_32(), i.e., the pages are allocated from 32-bit-addressable memory.
+ *
+ * Return: 1 if the buffer was changed, 0 if not changed, or a negative error
+ * code.
  */
 static int snd_pcm_lib_alloc_vmalloc_32_buffer
 			(struct snd_pcm_substream *substream, size_t size);
@@ -1070,6 +1073,8 @@ const char *snd_pcm_format_name(snd_pcm_format_t format);
 /**
  * snd_pcm_stream_str - Get a string naming the direction of a stream
  * @substream: the pcm substream instance
+ *
+ * Return: A string naming the direction of the stream.
  */
 static inline const char *snd_pcm_stream_str(struct snd_pcm_substream *substream)
 {

commit 4eeaaeaea1cec60a25979678182720dc91308550
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Mon Oct 22 16:42:15 2012 -0500

    ALSA: core: add hooks for audio timestamps
    
    ALSA did not provide any direct means to infer the audio time for A/V
    sync and system/audio time correlations (eg. PulseAudio).
    Applications had to track the number of samples read/written and
    add/subtract the number of samples queued in the ring buffer.  This
    accounting led to small errors, typically several samples, due to the
    two-step process.  Computing the audio time in the kernel is more
    direct, as all the information is available in the same routines.
    
    Also add new .audio_wallclock routine to enable fine-grain synchronization
    between monotonic system time and audio hardware time.
    Using the wallclock, if supported in hardware, allows for a
    much better sub-microsecond precision and a common drift tracking for
    all devices sharing the same wall clock (master clock).
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 28fd9f95f9ba..45c1981c9ca2 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -71,6 +71,8 @@ struct snd_pcm_ops {
 	int (*prepare)(struct snd_pcm_substream *substream);
 	int (*trigger)(struct snd_pcm_substream *substream, int cmd);
 	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream);
+	int (*wall_clock)(struct snd_pcm_substream *substream,
+			  struct timespec *audio_ts);
 	int (*copy)(struct snd_pcm_substream *substream, int channel,
 		    snd_pcm_uframes_t pos,
 		    void __user *buf, snd_pcm_uframes_t count);

commit 0e8014d772a7639f48d234b23dc4ce97335cce7f
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Mon Oct 22 16:42:14 2012 -0500

    ALSA: core: keep track of boundary wrap-around
    
    Keep track of boundary crossing when hw_ptr
    exceeds boundary limit and wraps-around. This
    will help keep track of total number
    of frames played/received at the kernel level
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 6268a4192d5c..28fd9f95f9ba 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -281,6 +281,7 @@ struct snd_pcm_runtime {
 	unsigned long hw_ptr_jiffies;	/* Time when hw_ptr is updated */
 	unsigned long hw_ptr_buffer_jiffies; /* buffer time in jiffies */
 	snd_pcm_sframes_t delay;	/* extra delay; typically FIFO size */
+	u64 hw_ptr_wrap;                /* offset for hw_ptr due to boundary wrap-around */
 
 	/* -- HW params -- */
 	snd_pcm_access_t access;	/* access mode */

commit f5a246eab9a268f51ba8189ea5b098a1bfff200e
Merge: d5bbd43d5f45 7ff34ad80b70
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 9 07:07:14 2012 +0900

    Merge tag 'sound-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "This contains pretty many small commits covering fairly large range of
      files in sound/ directory.  Partly because of additional API support
      and partly because of constantly developed ASoC and ARM stuff.
    
      Some highlights:
    
       - Introduced the helper function and documentation for exposing the
         channel map via control API, as discussed in Plumbers; most of PCI
         drivers are covered, will follow more drivers later
    
       - Most of drivers have been replaced with the new PM callbacks (if
         the bus is supported)
    
       - HD-audio controller got the support of runtime PM and the support
         of D3 clock-stop.  Also changing the power_save option in sysfs
         kicks off immediately to enable / disable the power-save mode.
    
       - Another significant code change in HD-audio is the rewrite of
         firmware loading code.  Other than that, most of changes in
         HD-audio are continued cleanups and standardization for the generic
         auto parser and bug fixes (HBR, device-specific fixups), in
         addition to the support of channel-map API.
    
       - Addition of ASoC bindings for the compressed API, used by the
         mid-x86 drivers.
    
       - Lots of cleanups and API refreshes for ASoC codec drivers and
         DaVinci.
    
       - Conversion of OMAP to dmaengine.
    
       - New machine driver for Wolfson Microelectronics Bells.
    
       - New CODEC driver for Wolfson Microelectronics WM0010.
    
       - Enhancements to the ux500 and wm2000 drivers
    
       - A new driver for DA9055 and the support for regulator bypass mode."
    
    Fix up various arm soc header file reorg conflicts.
    
    * tag 'sound-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (339 commits)
      ALSA: hda - Add new codec ALC283 ALC290 support
      ALSA: hda - avoid unneccesary indices on "Headphone Jack" controls
      ALSA: hda - fix indices on boost volume on Conexant
      ALSA: aloop - add locking to timer access
      ALSA: hda - Fix hang caused by race during suspend.
      sound: Remove unnecessary semicolon
      ALSA: hda/realtek - Fix detection of ALC271X codec
      ALSA: hda - Add inverted internal mic quirk for Lenovo IdeaPad U310
      ALSA: hda - make Realtek/Sigmatel/Conexant use the generic unsol event
      ALSA: hda - make a generic unsol event handler
      ASoC: codecs: Add DA9055 codec driver
      ASoC: eukrea-tlv320: Convert it to platform driver
      ALSA: ASoC: add DT bindings for CS4271
      ASoC: wm_hubs: Ensure volume updates are handled during class W startup
      ASoC: wm5110: Adding missing volume update bits
      ASoC: wm5110: Add OUT3R support
      ASoC: wm5110: Add AEC loopback support
      ASoC: wm5110: Rename EPOUT to HPOUT3
      ASoC: arizona: Add more clock rates
      ASoC: arizona: Add more DSP options for mixer input muxes
      ...

commit a1ce39288e6fbefdd8d607021d02384eb4a20b99
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 2 18:01:25 2012 +0100

    UAPI: (Scripted) Convert #include "..." to #include <path/...> in kernel system headers
    
    Convert #include "..." to #include <path/...> in kernel system headers.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index cdca2ab1e711..d0711bc8c914 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -35,7 +35,7 @@
 #define snd_pcm_chip(pcm) ((pcm)->private_data)
 
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
-#include "pcm_oss.h"
+#include <sound/pcm_oss.h>
 #endif
 
 /*

commit 9d069dc00b02b886abe3cab5e369140f7cd78965
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 20 20:29:12 2012 -0700

    ALSA: Make snd_sgbuf_get_{ptr|addr}() available for non-SG cases
    
    Passing struct snd_dma_buffer pointer instead, so that they work no
    matter whether real SG buffer is used or not.
    
    This is a preliminary work for the HD-audio DSP loader code.
    
    Signed-off-by: Ian Minett <ian_minett@creativelabs.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 669c85a7fb03..7e4e4e380106 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -983,53 +983,42 @@ static int snd_pcm_lib_alloc_vmalloc_32_buffer
 	_snd_pcm_lib_alloc_vmalloc_buffer \
 			(subs, size, GFP_KERNEL | GFP_DMA32 | __GFP_ZERO)
 
+#define snd_pcm_get_dma_buf(substream) ((substream)->runtime->dma_buffer_p)
+
 #ifdef CONFIG_SND_DMA_SGBUF
 /*
  * SG-buffer handling
  */
 #define snd_pcm_substream_sgbuf(substream) \
-	((substream)->runtime->dma_buffer_p->private_data)
-
-static inline dma_addr_t
-snd_pcm_sgbuf_get_addr(struct snd_pcm_substream *substream, unsigned int ofs)
-{
-	struct snd_sg_buf *sg = snd_pcm_substream_sgbuf(substream);
-	return snd_sgbuf_get_addr(sg, ofs);
-}
-
-static inline void *
-snd_pcm_sgbuf_get_ptr(struct snd_pcm_substream *substream, unsigned int ofs)
-{
-	struct snd_sg_buf *sg = snd_pcm_substream_sgbuf(substream);
-	return snd_sgbuf_get_ptr(sg, ofs);
-}
+	snd_pcm_get_dma_buf(substream)->private_data
 
 struct page *snd_pcm_sgbuf_ops_page(struct snd_pcm_substream *substream,
 				    unsigned long offset);
-unsigned int snd_pcm_sgbuf_get_chunk_size(struct snd_pcm_substream *substream,
-					  unsigned int ofs, unsigned int size);
-
 #else /* !SND_DMA_SGBUF */
 /*
  * fake using a continuous buffer
  */
+#define snd_pcm_sgbuf_ops_page	NULL
+#endif /* SND_DMA_SGBUF */
+
 static inline dma_addr_t
 snd_pcm_sgbuf_get_addr(struct snd_pcm_substream *substream, unsigned int ofs)
 {
-	return substream->runtime->dma_addr + ofs;
+	return snd_sgbuf_get_addr(snd_pcm_get_dma_buf(substream), ofs);
 }
 
 static inline void *
 snd_pcm_sgbuf_get_ptr(struct snd_pcm_substream *substream, unsigned int ofs)
 {
-	return substream->runtime->dma_area + ofs;
+	return snd_sgbuf_get_ptr(snd_pcm_get_dma_buf(substream), ofs);
 }
 
-#define snd_pcm_sgbuf_ops_page	NULL
-
-#define snd_pcm_sgbuf_get_chunk_size(subs, ofs, size)	(size)
-
-#endif /* SND_DMA_SGBUF */
+static inline unsigned int
+snd_pcm_sgbuf_get_chunk_size(struct snd_pcm_substream *substream,
+			     unsigned int ofs, unsigned int size)
+{
+	return snd_sgbuf_get_chunk_size(snd_pcm_get_dma_buf(substream), ofs, size);
+}
 
 /* handle mmap counter - PCM mmap callback should handle this counter properly */
 static inline void snd_pcm_mmap_data_open(struct vm_area_struct *area)

commit 2d3391ec0ecca37efb6bc995906292f47522b471
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jul 27 18:27:00 2012 +0200

    ALSA: PCM: channel mapping API implementation
    
    This patch implements the basic data types for the standard channel
    mapping API handling.
    
    - The definitions of the channel positions and the new TLV types are
      added in sound/asound.h and sound/tlv.h, so that they can be
      referred from user-space.
    
    - Introduced a new helper function snd_pcm_add_chmap_ctls() to create
      control elements representing the channel maps for each PCM
      (sub)stream.
    
    - Some standard pre-defined channel maps are provided for
      convenience.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index cdca2ab1e711..669c85a7fb03 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -437,6 +437,7 @@ struct snd_pcm_str {
 	struct snd_info_entry *proc_xrun_debug_entry;
 #endif
 #endif
+	struct snd_kcontrol *chmap_kctl; /* channel-mapping controls */
 };
 
 struct snd_pcm {
@@ -1086,4 +1087,51 @@ static inline const char *snd_pcm_stream_str(struct snd_pcm_substream *substream
 		return "Capture";
 }
 
+/*
+ * PCM channel-mapping control API
+ */
+/* array element of channel maps */
+struct snd_pcm_chmap_elem {
+	unsigned char channels;
+	unsigned char map[15];
+};
+
+/* channel map information; retrieved via snd_kcontrol_chip() */
+struct snd_pcm_chmap {
+	struct snd_pcm *pcm;	/* assigned PCM instance */
+	int stream;		/* PLAYBACK or CAPTURE */
+	struct snd_kcontrol *kctl;
+	const struct snd_pcm_chmap_elem *chmap;
+	unsigned int max_channels;
+	unsigned int channel_mask;	/* optional: active channels bitmask */
+	void *private_data;	/* optional: private data pointer */
+};
+
+/* get the PCM substream assigned to the given chmap info */
+static inline struct snd_pcm_substream *
+snd_pcm_chmap_substream(struct snd_pcm_chmap *info, unsigned int idx)
+{
+	struct snd_pcm_substream *s;
+	for (s = info->pcm->streams[info->stream].substream; s; s = s->next)
+		if (s->number == idx)
+			return s;
+	return NULL;
+}
+
+/* ALSA-standard channel maps (RL/RR prior to C/LFE) */
+extern const struct snd_pcm_chmap_elem snd_pcm_std_chmaps[];
+/* Other world's standard channel maps (C/LFE prior to RL/RR) */
+extern const struct snd_pcm_chmap_elem snd_pcm_alt_chmaps[];
+
+/* bit masks to be passed to snd_pcm_chmap.channel_mask field */
+#define SND_PCM_CHMAP_MASK_24	((1U << 2) | (1U << 4))
+#define SND_PCM_CHMAP_MASK_246	(SND_PCM_CHMAP_MASK_24 | (1U << 6))
+#define SND_PCM_CHMAP_MASK_2468	(SND_PCM_CHMAP_MASK_246 | (1U << 8))
+
+int snd_pcm_add_chmap_ctls(struct snd_pcm *pcm, int stream,
+			   const struct snd_pcm_chmap_elem *chmap,
+			   int max_channels,
+			   unsigned long private_value,
+			   struct snd_pcm_chmap **info_ret);
+
 #endif /* __SOUND_PCM_H */

commit 8513915accc611e576dbebb93422c257e7e68be8
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sat Aug 18 17:43:05 2012 -0700

    ALSA: fix pcm.h kernel-doc warning and notation
    
    Fix kernel-doc warning in <sound/pcm.h> and add function name to make
    the kernel-doc notation complete.
    
    Warning(include/sound/pcm.h:1081): No description found for parameter 'substream'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index c75c0d1a85e2..cdca2ab1e711 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1075,7 +1075,8 @@ static inline void snd_pcm_limit_isa_dma_size(int dma, size_t *max)
 const char *snd_pcm_format_name(snd_pcm_format_t format);
 
 /**
- * Get a string naming the direction of a stream
+ * snd_pcm_stream_str - Get a string naming the direction of a stream
+ * @substream: the pcm substream instance
  */
 static inline const char *snd_pcm_stream_str(struct snd_pcm_substream *substream)
 {

commit 4609ed6b1f0ab9f11a9d0361573b53d9d057c440
Merge: 639aa4bd5858 409b78cc17a4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jul 19 08:03:20 2012 +0200

    Merge tag 'asoc-3.6' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-next
    
    ASoC: Updates for 3.6
    
    This has been a pretty quiet release - very little activity in framework
    terms, mostly just a few new drivers and updates:
    
    - Added the ability to add and remove DAPM paths dynamically, mostly for
      reparenting on clock changes.
    - New machine drivers for Marvell Brownstone, ST-Ericsson Ux500
      reference platform and ttc-dkp.
    - New CPU drivers for Blackfin BF6xx SPORTs in I2S mode, Marvell MMP,
      Synopsis Designware I2S controllers, and SPEAr DMA and S/PDIF
    - New CODEC drivers for Dialog DA732x, ST STA529, ST-Ericsson AB8500, TI
      Isabelle and Wolfson Microelectronics WM5102 and WM5110

commit 1464189f8c2a5341722437ef916786afaf241c44
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jul 5 12:15:01 2012 +0100

    ALSA: pcm: Make constraints lists const
    
    They aren't modified by the core so the drivers can declare them const.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 68372bc1e11b..e91e6047ca6f 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -810,7 +810,7 @@ int snd_pcm_hw_constraint_integer(struct snd_pcm_runtime *runtime, snd_pcm_hw_pa
 int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime, 
 			       unsigned int cond,
 			       snd_pcm_hw_param_t var,
-			       struct snd_pcm_hw_constraint_list *l);
+			       const struct snd_pcm_hw_constraint_list *l);
 int snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime, 
 				  unsigned int cond,
 				  snd_pcm_hw_param_t var,

commit 4be77a530be1ea62574f31c20dd9848e7e2ab0f6
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Fri Jun 15 16:35:28 2012 +0100

    ALSA: pcm: Add snd_pcm_rate_bit_to_rate()
    
    This is essentially the reverse of snd_pcm_rate_to_rate_bit().
    
    This is generally useful as the Compress API uses the rate bit
    directly and it helps to be able to map back to the actual sample
    rate.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 0d1112815be3..68372bc1e11b 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -893,6 +893,7 @@ extern const struct snd_pcm_hw_constraint_list snd_pcm_known_rates;
 
 int snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime);
 unsigned int snd_pcm_rate_to_rate_bit(unsigned int rate);
+unsigned int snd_pcm_rate_bit_to_rate(unsigned int rate_bit);
 
 static inline void snd_pcm_set_runtime_buffer(struct snd_pcm_substream *substream,
 					      struct snd_dma_buffer *bufp)

commit 1aad779fccdbb4d79af7b9de93dfd2bfe807e052
Author: Ola Lilja <ola.o.lilja@stericsson.com>
Date:   Thu May 24 15:26:03 2012 +0200

    ALSA: pcm: Add debug-print helper function
    
    Adds a function getting the stream-name as a string for
    a specific stream.
    
    Signed-off-by: Ola Lilja <ola.o.lilja@stericsson.com>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 0d1112815be3..a55d5db7eb5a 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1073,4 +1073,15 @@ static inline void snd_pcm_limit_isa_dma_size(int dma, size_t *max)
 
 const char *snd_pcm_format_name(snd_pcm_format_t format);
 
+/**
+ * Get a string naming the direction of a stream
+ */
+static inline const char *snd_pcm_stream_str(struct snd_pcm_substream *substream)
+{
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		return "Playback";
+	else
+		return "Capture";
+}
+
 #endif /* __SOUND_PCM_H */

commit cb3f2adc03ab055b19c677a6283523861fafebdd
Merge: 44c76a960a62 828006de1bdd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Mar 18 18:22:37 2012 +0100

    Merge branch 'topic/asoc' into for-linus

commit 4af87a939ef7092fdca267fba473cf8407d6d8e2
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 14 19:48:43 2012 +0000

    ALSA: pcm: Constify the list in snd_pcm_hw_constraint_list
    
    Allows the constraint lists to be declared const by drivers which seems
    reasonable; there's plenty of other constification we could do if we were
    being complete but this was easy and quick.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 0cf91b2f08ca..4ae9e22c4827 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -264,7 +264,7 @@ struct snd_pcm_hw_constraint_ratdens {
 
 struct snd_pcm_hw_constraint_list {
 	unsigned int count;
-	unsigned int *list;
+	const unsigned int *list;
 	unsigned int mask;
 };
 
@@ -781,7 +781,8 @@ void snd_interval_muldivk(const struct snd_interval *a, const struct snd_interva
 			  unsigned int k, struct snd_interval *c);
 void snd_interval_mulkdiv(const struct snd_interval *a, unsigned int k,
 			  const struct snd_interval *b, struct snd_interval *c);
-int snd_interval_list(struct snd_interval *i, unsigned int count, unsigned int *list, unsigned int mask);
+int snd_interval_list(struct snd_interval *i, unsigned int count,
+		      const unsigned int *list, unsigned int mask);
 int snd_interval_ratnum(struct snd_interval *i,
 			unsigned int rats_count, struct snd_ratnum *rats,
 			unsigned int *nump, unsigned int *denp);

commit 945e5038455fef18e73914c149717878d78cb4c0
Author: Liam Girdwood <lrg@ti.com>
Date:   Wed Feb 8 20:33:31 2012 +0000

    ALSA: PCM - Add PCM creation API for internal PCMs.
    
    The new ASoC dynamic PCM core needs to create PCMs and substreams that are
    for use by internal ASoC drivers only and not visible to userspace for
    direct IO. These new PCMs are similar to regular PCMs expect they have no
    device nodes or procfs entries. The ASoC component drivers use them in exactly
    the same way as regular PCMs for PCM and DAI operations.
    
    The intention is that a dynamic PCM based driver will register both regular
    PCMs and internal PCMs. The regular PCMs will be used for all IO with userspace
    however the internal PCMs will be used by the driver to route digital audio
    through numerous back end DAI links (with potentially a DSP providing different
    hw_params, DAI formats based on the regular front end PCM params) to devices
    like CODECs, MODEMs, Bluetooth, FM, DMICs, etc
    
    This patch adds a new snd_pcm_new_internal() API call to create the internal PCM
    without device nodes or procfs. It also adds adds a new internal flag to snd_pcm.
    
    [fixed minor coding-style issues by tiwai]
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 0cf91b2f08ca..1d58d7957390 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -454,6 +454,7 @@ struct snd_pcm {
 	void *private_data;
 	void (*private_free) (struct snd_pcm *pcm);
 	struct device *dev; /* actual hw device this belongs to */
+	bool internal; /* pcm is for internal use only */
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	struct snd_pcm_oss oss;
 #endif
@@ -475,6 +476,9 @@ extern const struct file_operations snd_pcm_f_ops[2];
 int snd_pcm_new(struct snd_card *card, const char *id, int device,
 		int playback_count, int capture_count,
 		struct snd_pcm **rpcm);
+int snd_pcm_new_internal(struct snd_card *card, const char *id, int device,
+		int playback_count, int capture_count,
+		struct snd_pcm **rpcm);
 int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count);
 
 int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree);

commit 68d99b2c8efcb6ed3807a55569300c53b5f88be5
Merge: 0e59e7e7feb5 8128c9f21509
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 28 14:25:01 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (549 commits)
      ALSA: hda - Fix ADC input-amp handling for Cx20549 codec
      ALSA: hda - Keep EAPD turned on for old Conexant chips
      ALSA: hda/realtek - Fix missing volume controls with ALC260
      ASoC: wm8940: Properly set codec->dapm.bias_level
      ALSA: hda - Fix pin-config for ASUS W90V
      ALSA: hda - Fix surround/CLFE headphone and speaker pins order
      ALSA: hda - Fix typo
      ALSA: Update the sound git tree URL
      ALSA: HDA: Add new revision for ALC662
      ASoC: max98095: Convert codec->hw_write to snd_soc_write
      ASoC: keep pointer to resource so it can be freed
      ASoC: sgtl5000: Fix wrong mask in some snd_soc_update_bits calls
      ASoC: wm8996: Fix wrong mask for setting WM8996_AIF_CLOCKING_2
      ASoC: da7210: Add support for line out and DAC
      ASoC: da7210: Add support for DAPM
      ALSA: hda/realtek - Fix DAC assignments of multiple speakers
      ASoC: Use SGTL5000_LINREG_VDDD_MASK instead of hardcoded mask value
      ASoC: Set sgtl5000->ldo in ldo_regulator_register
      ASoC: wm8996: Use SND_SOC_DAPM_AIF_OUT for AIF2 Capture
      ASoC: wm8994: Use SND_SOC_DAPM_AIF_OUT for AIF3 Capture
      ...

commit d22665702226e9c40bc331098559e3d55e7cd43d
Merge: 5cdf745ebae0 dde7ad8dee27
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 26 23:51:43 2011 +0200

    Merge branch 'topic/misc' into for-linus

commit 18a2b9623370479d1646b9b94e3528683f3b74de
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 28 17:12:59 2011 +0200

    ALSA: pcm - Export snd_pcm_lib_default_mmap() helper
    
    Export the default mmap function, snd_pcm_lib_default_mmap().
    The upcoming non-snooping support in HD-audio driver will use this
    to override the mmap method.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 57e71fa33f7c..249d98838d90 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1035,6 +1035,8 @@ static inline void snd_pcm_mmap_data_close(struct vm_area_struct *area)
 	atomic_dec(&substream->mmap_count);
 }
 
+int snd_pcm_lib_default_mmap(struct snd_pcm_substream *substream,
+			     struct vm_area_struct *area);
 /* mmap for io-memory area */
 #if defined(CONFIG_X86) || defined(CONFIG_PPC) || defined(CONFIG_ALPHA)
 #define SNDRV_PCM_INFO_MMAP_IOMEM	SNDRV_PCM_INFO_MMAP

commit d5b702a64b4c273c8eed7e4e721364493d01fdc9
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Sep 16 23:03:02 2011 +0200

    ALSA: pcm: add snd_pcm_hw_rule_noresample()
    
    Add a helper function to allow drivers to disable hardware resampling
    when the application has specified the SNDRV_PCM_HW_PARAMS_NORESAMPLE
    flag.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 57e71fa33f7c..dc36f756fe8d 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -825,6 +825,8 @@ int snd_pcm_hw_constraint_step(struct snd_pcm_runtime *runtime,
 int snd_pcm_hw_constraint_pow2(struct snd_pcm_runtime *runtime,
 			       unsigned int cond,
 			       snd_pcm_hw_param_t var);
+int snd_pcm_hw_rule_noresample(struct snd_pcm_runtime *runtime,
+			       unsigned int base_rate);
 int snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime,
 			unsigned int cond,
 			int var,

commit cc74998618a66d34651c784dd02412614c3e81cc
Author: Jean Pihet <j-pihet@ti.com>
Date:   Thu Aug 25 15:35:12 2011 +0200

    PM QoS: Minor clean-ups
    
     - Misc fixes to improve code readability:
      * rename struct pm_qos_request_list to struct pm_qos_request,
      * rename pm_qos_req parameter to req in internal code,
        consistenly use req in the API parameters,
      * update the in-kernel API callers to the new parameters names,
      * rename of fields names (requests, list, node, constraints)
    
    Signed-off-by: Jean Pihet <j-pihet@ti.com>
    Acked-by: markgross <markgross@thegnar.org>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 666ee91e8a2e..54cb079b7bf1 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -373,7 +373,7 @@ struct snd_pcm_substream {
 	int number;
 	char name[32];			/* substream name */
 	int stream;			/* stream (direction) */
-	struct pm_qos_request_list latency_pm_qos_req; /* pm_qos request */
+	struct pm_qos_request latency_pm_qos_req; /* pm_qos request */
 	size_t buffer_bytes_max;	/* limit ring buffer size */
 	struct snd_dma_buffer dma_buffer;
 	unsigned int dma_buf_id;

commit e8db0be1245de16a6cc6365506abc392c3c212d4
Author: Jean Pihet <j-pihet@ti.com>
Date:   Thu Aug 25 15:35:03 2011 +0200

    PM QoS: Move and rename the implementation files
    
    The PM QoS implementation files are better named
    kernel/power/qos.c and include/linux/pm_qos.h.
    
    The PM QoS support is compiled under the CONFIG_PM option.
    
    Signed-off-by: Jean Pihet <j-pihet@ti.com>
    Acked-by: markgross <markgross@thegnar.org>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 57e71fa33f7c..666ee91e8a2e 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -29,7 +29,7 @@
 #include <linux/poll.h>
 #include <linux/mm.h>
 #include <linux/bitops.h>
-#include <linux/pm_qos_params.h>
+#include <linux/pm_qos.h>
 
 #define snd_pcm_substream_chip(substream) ((substream)->private_data)
 #define snd_pcm_chip(pcm) ((pcm)->private_data)

commit b51beb756aaf0770e4fa8bb2cb142888051aa356
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jul 26 12:02:56 2011 +0200

    ALSA: Make pcm.h self-contained
    
    Move the macros depending on snd_mask_min() and co out of pcm.h into
    pcm_params.h.  Otherwise using some params_*() macros will give comiple
    errors without inclusion of pcm_params.h.
    
    Also use hw_param_interval_c() and hw_param_mask_c() for const pointer.
    
    Reported-by: Tim Blechmann <tim@klingt.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index ccf3a6e14f9f..57e71fa33f7c 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -761,17 +761,18 @@ static inline const struct snd_interval *hw_param_interval_c(const struct snd_pc
 	return &params->intervals[var - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL];
 }
 
-#define params_access(p) ((__force snd_pcm_access_t)snd_mask_min(hw_param_mask((p), SNDRV_PCM_HW_PARAM_ACCESS)))
-#define params_format(p) ((__force snd_pcm_format_t)snd_mask_min(hw_param_mask((p), SNDRV_PCM_HW_PARAM_FORMAT)))
-#define params_subformat(p) snd_mask_min(hw_param_mask((p), SNDRV_PCM_HW_PARAM_SUBFORMAT))
-#define params_channels(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_CHANNELS)->min
-#define params_rate(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_RATE)->min
-#define params_period_size(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_PERIOD_SIZE)->min
-#define params_period_bytes(p) ((params_period_size(p)*snd_pcm_format_physical_width(params_format(p))*params_channels(p))/8)
-#define params_periods(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_PERIODS)->min
-#define params_buffer_size(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_BUFFER_SIZE)->min
-#define params_buffer_bytes(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_BUFFER_BYTES)->min
-
+#define params_channels(p) \
+	(hw_param_interval_c((p), SNDRV_PCM_HW_PARAM_CHANNELS)->min)
+#define params_rate(p) \
+	(hw_param_interval_c((p), SNDRV_PCM_HW_PARAM_RATE)->min)
+#define params_period_size(p) \
+	(hw_param_interval_c((p), SNDRV_PCM_HW_PARAM_PERIOD_SIZE)->min)
+#define params_periods(p) \
+	(hw_param_interval_c((p), SNDRV_PCM_HW_PARAM_PERIODS)->min)
+#define params_buffer_size(p) \
+	(hw_param_interval_c((p), SNDRV_PCM_HW_PARAM_BUFFER_SIZE)->min)
+#define params_buffer_bytes(p) \
+	(hw_param_interval_c((p), SNDRV_PCM_HW_PARAM_BUFFER_BYTES)->min)
 
 int snd_interval_refine(struct snd_interval *i, const struct snd_interval *v);
 void snd_interval_mul(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c);

commit acb03d440b8a723181e1d45e3517e43cb0792f8a
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Sat Jul 23 12:36:25 2011 +1200

    ALSA: Make snd_pcm_debug_name usable outside pcm_lib
    
    Formatting a PCM name is useful for module debug too.
    Add snd_prefix when making function public.
    
    [minor coding-style fixes by tiwai]
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index e1bad1130616..ccf3a6e14f9f 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -507,6 +507,18 @@ void snd_pcm_detach_substream(struct snd_pcm_substream *substream);
 void snd_pcm_vma_notify_data(void *client, void *data);
 int snd_pcm_mmap_data(struct snd_pcm_substream *substream, struct file *file, struct vm_area_struct *area);
 
+
+#ifdef CONFIG_SND_DEBUG
+void snd_pcm_debug_name(struct snd_pcm_substream *substream,
+			   char *name, size_t len);
+#else
+static inline void
+snd_pcm_debug_name(struct snd_pcm_substream *substream, char *buf, size_t size)
+{
+	*buf = 0;
+}
+#endif
+
 /*
  *  PCM library
  */

commit 3674f19dabd15f9541079a588149a370d888f4e6
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Mar 25 17:51:54 2011 +1100

    ALSA: vmalloc buffers should use normal mmap
    
    It's a big no-no to use pgprot_noncached() when mmap'ing such buffers
    into userspace since they are mapped cachable in kernel space.
    
    This can cause all sort of interesting things ranging from to garbled
    sound to lockups on various architectures. I've observed that usb-audio
    is broken on powerpc 4xx for example because of that.
    
    Also remove the now unused snd_pcm_lib_mmap_noncached(). It's
    an arch business to know when to use uncached mappings, there's
    already hacks for MIPS inside snd_pcm_default_mmap() and other
    archs are supposed to use dma_mmap_coherent().
    
    (See my separate patch that adds dma_mmap_coherent() to powerpc)
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 430a9cc045e2..e1bad1130616 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1031,9 +1031,7 @@ int snd_pcm_lib_mmap_iomem(struct snd_pcm_substream *substream, struct vm_area_s
 #define snd_pcm_lib_mmap_iomem	NULL
 #endif
 
-int snd_pcm_lib_mmap_noncached(struct snd_pcm_substream *substream,
-			       struct vm_area_struct *area);
-#define snd_pcm_lib_mmap_vmalloc	snd_pcm_lib_mmap_noncached
+#define snd_pcm_lib_mmap_vmalloc NULL
 
 static inline void snd_pcm_limit_isa_dma_size(int dma, size_t *max)
 {

commit fea952e5cc23ea94b4677ca20774cdc3cea014e2
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Feb 14 11:00:47 2011 +0100

    ALSA: core: sparse cleanups
    
    Change the core code where sparse complains.  In most cases, this means
    just adding annotations to confirm that we indeed want to do the dirty
    things we're doing.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index e731f8d71934..430a9cc045e2 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -136,48 +136,49 @@ struct snd_pcm_ops {
 					 SNDRV_PCM_RATE_88200|SNDRV_PCM_RATE_96000)
 #define SNDRV_PCM_RATE_8000_192000	(SNDRV_PCM_RATE_8000_96000|SNDRV_PCM_RATE_176400|\
 					 SNDRV_PCM_RATE_192000)
-#define SNDRV_PCM_FMTBIT_S8		(1ULL << SNDRV_PCM_FORMAT_S8)
-#define SNDRV_PCM_FMTBIT_U8		(1ULL << SNDRV_PCM_FORMAT_U8)
-#define SNDRV_PCM_FMTBIT_S16_LE		(1ULL << SNDRV_PCM_FORMAT_S16_LE)
-#define SNDRV_PCM_FMTBIT_S16_BE		(1ULL << SNDRV_PCM_FORMAT_S16_BE)
-#define SNDRV_PCM_FMTBIT_U16_LE		(1ULL << SNDRV_PCM_FORMAT_U16_LE)
-#define SNDRV_PCM_FMTBIT_U16_BE		(1ULL << SNDRV_PCM_FORMAT_U16_BE)
-#define SNDRV_PCM_FMTBIT_S24_LE		(1ULL << SNDRV_PCM_FORMAT_S24_LE)
-#define SNDRV_PCM_FMTBIT_S24_BE		(1ULL << SNDRV_PCM_FORMAT_S24_BE)
-#define SNDRV_PCM_FMTBIT_U24_LE		(1ULL << SNDRV_PCM_FORMAT_U24_LE)
-#define SNDRV_PCM_FMTBIT_U24_BE		(1ULL << SNDRV_PCM_FORMAT_U24_BE)
-#define SNDRV_PCM_FMTBIT_S32_LE		(1ULL << SNDRV_PCM_FORMAT_S32_LE)
-#define SNDRV_PCM_FMTBIT_S32_BE		(1ULL << SNDRV_PCM_FORMAT_S32_BE)
-#define SNDRV_PCM_FMTBIT_U32_LE		(1ULL << SNDRV_PCM_FORMAT_U32_LE)
-#define SNDRV_PCM_FMTBIT_U32_BE		(1ULL << SNDRV_PCM_FORMAT_U32_BE)
-#define SNDRV_PCM_FMTBIT_FLOAT_LE	(1ULL << SNDRV_PCM_FORMAT_FLOAT_LE)
-#define SNDRV_PCM_FMTBIT_FLOAT_BE	(1ULL << SNDRV_PCM_FORMAT_FLOAT_BE)
-#define SNDRV_PCM_FMTBIT_FLOAT64_LE	(1ULL << SNDRV_PCM_FORMAT_FLOAT64_LE)
-#define SNDRV_PCM_FMTBIT_FLOAT64_BE	(1ULL << SNDRV_PCM_FORMAT_FLOAT64_BE)
-#define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE (1ULL << SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE)
-#define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_BE (1ULL << SNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE)
-#define SNDRV_PCM_FMTBIT_MU_LAW		(1ULL << SNDRV_PCM_FORMAT_MU_LAW)
-#define SNDRV_PCM_FMTBIT_A_LAW		(1ULL << SNDRV_PCM_FORMAT_A_LAW)
-#define SNDRV_PCM_FMTBIT_IMA_ADPCM	(1ULL << SNDRV_PCM_FORMAT_IMA_ADPCM)
-#define SNDRV_PCM_FMTBIT_MPEG		(1ULL << SNDRV_PCM_FORMAT_MPEG)
-#define SNDRV_PCM_FMTBIT_GSM		(1ULL << SNDRV_PCM_FORMAT_GSM)
-#define SNDRV_PCM_FMTBIT_SPECIAL	(1ULL << SNDRV_PCM_FORMAT_SPECIAL)
-#define SNDRV_PCM_FMTBIT_S24_3LE	(1ULL << SNDRV_PCM_FORMAT_S24_3LE)
-#define SNDRV_PCM_FMTBIT_U24_3LE	(1ULL << SNDRV_PCM_FORMAT_U24_3LE)
-#define SNDRV_PCM_FMTBIT_S24_3BE	(1ULL << SNDRV_PCM_FORMAT_S24_3BE)
-#define SNDRV_PCM_FMTBIT_U24_3BE	(1ULL << SNDRV_PCM_FORMAT_U24_3BE)
-#define SNDRV_PCM_FMTBIT_S20_3LE	(1ULL << SNDRV_PCM_FORMAT_S20_3LE)
-#define SNDRV_PCM_FMTBIT_U20_3LE	(1ULL << SNDRV_PCM_FORMAT_U20_3LE)
-#define SNDRV_PCM_FMTBIT_S20_3BE	(1ULL << SNDRV_PCM_FORMAT_S20_3BE)
-#define SNDRV_PCM_FMTBIT_U20_3BE	(1ULL << SNDRV_PCM_FORMAT_U20_3BE)
-#define SNDRV_PCM_FMTBIT_S18_3LE	(1ULL << SNDRV_PCM_FORMAT_S18_3LE)
-#define SNDRV_PCM_FMTBIT_U18_3LE	(1ULL << SNDRV_PCM_FORMAT_U18_3LE)
-#define SNDRV_PCM_FMTBIT_S18_3BE	(1ULL << SNDRV_PCM_FORMAT_S18_3BE)
-#define SNDRV_PCM_FMTBIT_U18_3BE	(1ULL << SNDRV_PCM_FORMAT_U18_3BE)
-#define SNDRV_PCM_FMTBIT_G723_24	(1ULL << SNDRV_PCM_FORMAT_G723_24)
-#define SNDRV_PCM_FMTBIT_G723_24_1B	(1ULL << SNDRV_PCM_FORMAT_G723_24_1B)
-#define SNDRV_PCM_FMTBIT_G723_40	(1ULL << SNDRV_PCM_FORMAT_G723_40)
-#define SNDRV_PCM_FMTBIT_G723_40_1B	(1ULL << SNDRV_PCM_FORMAT_G723_40_1B)
+#define _SNDRV_PCM_FMTBIT(fmt)		(1ULL << (__force int)SNDRV_PCM_FORMAT_##fmt)
+#define SNDRV_PCM_FMTBIT_S8		_SNDRV_PCM_FMTBIT(S8)
+#define SNDRV_PCM_FMTBIT_U8		_SNDRV_PCM_FMTBIT(U8)
+#define SNDRV_PCM_FMTBIT_S16_LE		_SNDRV_PCM_FMTBIT(S16_LE)
+#define SNDRV_PCM_FMTBIT_S16_BE		_SNDRV_PCM_FMTBIT(S16_BE)
+#define SNDRV_PCM_FMTBIT_U16_LE		_SNDRV_PCM_FMTBIT(U16_LE)
+#define SNDRV_PCM_FMTBIT_U16_BE		_SNDRV_PCM_FMTBIT(U16_BE)
+#define SNDRV_PCM_FMTBIT_S24_LE		_SNDRV_PCM_FMTBIT(S24_LE)
+#define SNDRV_PCM_FMTBIT_S24_BE		_SNDRV_PCM_FMTBIT(S24_BE)
+#define SNDRV_PCM_FMTBIT_U24_LE		_SNDRV_PCM_FMTBIT(U24_LE)
+#define SNDRV_PCM_FMTBIT_U24_BE		_SNDRV_PCM_FMTBIT(U24_BE)
+#define SNDRV_PCM_FMTBIT_S32_LE		_SNDRV_PCM_FMTBIT(S32_LE)
+#define SNDRV_PCM_FMTBIT_S32_BE		_SNDRV_PCM_FMTBIT(S32_BE)
+#define SNDRV_PCM_FMTBIT_U32_LE		_SNDRV_PCM_FMTBIT(U32_LE)
+#define SNDRV_PCM_FMTBIT_U32_BE		_SNDRV_PCM_FMTBIT(U32_BE)
+#define SNDRV_PCM_FMTBIT_FLOAT_LE	_SNDRV_PCM_FMTBIT(FLOAT_LE)
+#define SNDRV_PCM_FMTBIT_FLOAT_BE	_SNDRV_PCM_FMTBIT(FLOAT_BE)
+#define SNDRV_PCM_FMTBIT_FLOAT64_LE	_SNDRV_PCM_FMTBIT(FLOAT64_LE)
+#define SNDRV_PCM_FMTBIT_FLOAT64_BE	_SNDRV_PCM_FMTBIT(FLOAT64_BE)
+#define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE _SNDRV_PCM_FMTBIT(IEC958_SUBFRAME_LE)
+#define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_BE _SNDRV_PCM_FMTBIT(IEC958_SUBFRAME_BE)
+#define SNDRV_PCM_FMTBIT_MU_LAW		_SNDRV_PCM_FMTBIT(MU_LAW)
+#define SNDRV_PCM_FMTBIT_A_LAW		_SNDRV_PCM_FMTBIT(A_LAW)
+#define SNDRV_PCM_FMTBIT_IMA_ADPCM	_SNDRV_PCM_FMTBIT(IMA_ADPCM)
+#define SNDRV_PCM_FMTBIT_MPEG		_SNDRV_PCM_FMTBIT(MPEG)
+#define SNDRV_PCM_FMTBIT_GSM		_SNDRV_PCM_FMTBIT(GSM)
+#define SNDRV_PCM_FMTBIT_SPECIAL	_SNDRV_PCM_FMTBIT(SPECIAL)
+#define SNDRV_PCM_FMTBIT_S24_3LE	_SNDRV_PCM_FMTBIT(S24_3LE)
+#define SNDRV_PCM_FMTBIT_U24_3LE	_SNDRV_PCM_FMTBIT(U24_3LE)
+#define SNDRV_PCM_FMTBIT_S24_3BE	_SNDRV_PCM_FMTBIT(S24_3BE)
+#define SNDRV_PCM_FMTBIT_U24_3BE	_SNDRV_PCM_FMTBIT(U24_3BE)
+#define SNDRV_PCM_FMTBIT_S20_3LE	_SNDRV_PCM_FMTBIT(S20_3LE)
+#define SNDRV_PCM_FMTBIT_U20_3LE	_SNDRV_PCM_FMTBIT(U20_3LE)
+#define SNDRV_PCM_FMTBIT_S20_3BE	_SNDRV_PCM_FMTBIT(S20_3BE)
+#define SNDRV_PCM_FMTBIT_U20_3BE	_SNDRV_PCM_FMTBIT(U20_3BE)
+#define SNDRV_PCM_FMTBIT_S18_3LE	_SNDRV_PCM_FMTBIT(S18_3LE)
+#define SNDRV_PCM_FMTBIT_U18_3LE	_SNDRV_PCM_FMTBIT(U18_3LE)
+#define SNDRV_PCM_FMTBIT_S18_3BE	_SNDRV_PCM_FMTBIT(S18_3BE)
+#define SNDRV_PCM_FMTBIT_U18_3BE	_SNDRV_PCM_FMTBIT(U18_3BE)
+#define SNDRV_PCM_FMTBIT_G723_24	_SNDRV_PCM_FMTBIT(G723_24)
+#define SNDRV_PCM_FMTBIT_G723_24_1B	_SNDRV_PCM_FMTBIT(G723_24_1B)
+#define SNDRV_PCM_FMTBIT_G723_40	_SNDRV_PCM_FMTBIT(G723_40)
+#define SNDRV_PCM_FMTBIT_G723_40_1B	_SNDRV_PCM_FMTBIT(G723_40_1B)
 
 #ifdef SNDRV_LITTLE_ENDIAN
 #define SNDRV_PCM_FMTBIT_S16		SNDRV_PCM_FMTBIT_S16_LE
@@ -490,7 +491,7 @@ int snd_pcm_info_user(struct snd_pcm_substream *substream,
 int snd_pcm_status(struct snd_pcm_substream *substream,
 		   struct snd_pcm_status *status);
 int snd_pcm_start(struct snd_pcm_substream *substream);
-int snd_pcm_stop(struct snd_pcm_substream *substream, int status);
+int snd_pcm_stop(struct snd_pcm_substream *substream, snd_pcm_state_t status);
 int snd_pcm_drain_done(struct snd_pcm_substream *substream);
 #ifdef CONFIG_PM
 int snd_pcm_suspend(struct snd_pcm_substream *substream);
@@ -748,8 +749,8 @@ static inline const struct snd_interval *hw_param_interval_c(const struct snd_pc
 	return &params->intervals[var - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL];
 }
 
-#define params_access(p) snd_mask_min(hw_param_mask((p), SNDRV_PCM_HW_PARAM_ACCESS))
-#define params_format(p) snd_mask_min(hw_param_mask((p), SNDRV_PCM_HW_PARAM_FORMAT))
+#define params_access(p) ((__force snd_pcm_access_t)snd_mask_min(hw_param_mask((p), SNDRV_PCM_HW_PARAM_ACCESS)))
+#define params_format(p) ((__force snd_pcm_format_t)snd_mask_min(hw_param_mask((p), SNDRV_PCM_HW_PARAM_FORMAT)))
 #define params_subformat(p) snd_mask_min(hw_param_mask((p), SNDRV_PCM_HW_PARAM_SUBFORMAT))
 #define params_channels(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_CHANNELS)->min
 #define params_rate(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_RATE)->min

commit ab69a4904b5dd4d7cd6996587ba066bca8d13838
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Nov 15 10:46:23 2010 +0100

    ALSA: pcm: support for period wakeup disabling
    
    This patch allows to disable period interrupts which are
    not needed when the application relies on a system timer
    to wake-up and refill the ring buffer. The behavior of
    the driver is left unchanged, and interrupts are only
    disabled if the application requests this configuration.
    The behavior in case of underruns is slightly different,
    instead of being detected during the period interrupts the
    underruns are detected when the application calls
    snd_pcm_update_avail, which in turns forces a refresh of the
    hw pointer and shows the buffer is empty.
    
    More specifically this patch makes a lot of sense when
    PulseAudio relies on timer-based scheduling to access audio
    devices such as HDAudio or Intel SST. Disabling interrupts
    removes two unwanted wake-ups due to period elapsed events
    in low-power playback modes. It also simplifies PulseAudio
    voice modules used for speech calls.
    
    To quote Lennart "This patch looks very interesting and
    desirable. This is something have long been waiting for."
    
    Support for this in hardware drivers is optional.
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@intel.com>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index dfd9b76b1853..e731f8d71934 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -297,6 +297,7 @@ struct snd_pcm_runtime {
 	unsigned int info;
 	unsigned int rate_num;
 	unsigned int rate_den;
+	unsigned int no_period_wakeup: 1;
 
 	/* -- SW params -- */
 	int tstamp_mode;		/* mmap timestamp is updated */

commit bd76af0f87f7a1815b311bde269a3f18305b3169
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Wed Aug 18 14:16:54 2010 +0200

    ALSA: pcm midlevel code - add time check for double interrupt acknowledge
    
    The current code in pcm_lib.c do all checks using only the position
    in the ring buffer. Unfortunately, where the interrupts gets delayed or
    merged into one, we need another timing source to check when the
    buffer size boundary overlaps to avoid the wrong updating of the
    ring buffer pointers.
    
    This code uses jiffies to check the right time window without any
    performance impact.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 85f1c6bf8566..dfd9b76b1853 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -278,6 +278,7 @@ struct snd_pcm_runtime {
 	snd_pcm_uframes_t hw_ptr_base;	/* Position at buffer restart */
 	snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time */
 	unsigned long hw_ptr_jiffies;	/* Time when hw_ptr is updated */
+	unsigned long hw_ptr_buffer_jiffies; /* buffer time in jiffies */
 	snd_pcm_sframes_t delay;	/* extra delay; typically FIFO size */
 
 	/* -- HW params -- */

commit faa38b5e0e092914764cdba9f83d31a3f794d182
Merge: 78417334b5cb 74bf40f0793f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 7 17:07:31 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6: (214 commits)
      ALSA: hda - Add pin-fix for HP dc5750
      ALSA: als4000: Fix potentially invalid DMA mode setup
      ALSA: als4000: enable burst mode
      ALSA: hda - Fix initial capsrc selection in patch_alc269()
      ASoC: TWL4030: Capture route runtime DAPM ordering fix
      ALSA: hda - Add PC-beep whitelist for an Intel board
      ALSA: hda - More relax for pending period handling
      ALSA: hda - Define AC_FMT_* constants
      ALSA: hda - Fix beep frequency on IDT 92HD73xx and 92HD71Bxx codecs
      ALSA: hda - Add support for HDMI HBR passthrough
      ALSA: hda - Set Stream Type in Stream Format according to AES0
      ALSA: hda - Fix Thinkpad X300 so SPDIF is not exposed
      ALSA: hda - FIX to not expose SPDIF on Thinkpad X301, since it does not have the ability to use SPDIF
      ASoC: wm9081: fix resource reclaim in wm9081_register error path
      ASoC: wm8978: fix a memory leak if a wm8978_register fail
      ASoC: wm8974: fix a memory leak if another WM8974 is registered
      ASoC: wm8961: fix resource reclaim in wm8961_register error path
      ASoC: wm8955: fix resource reclaim in wm8955_register error path
      ASoC: wm8940: fix a memory leak if wm8940_register return error
      ASoC: wm8904: fix resource reclaim in wm8904_register error path
      ...

commit 82f682514a5df89ffb3890627eebf0897b7a84ec
Author: James Bottomley <James.Bottomley@suse.de>
Date:   Mon Jul 5 22:53:06 2010 +0200

    pm_qos: Get rid of the allocation in pm_qos_add_request()
    
    All current users of pm_qos_add_request() have the ability to supply
    the memory required by the pm_qos routines, so make them do this and
    eliminate the kmalloc() with pm_qos_add_request().  This has the
    double benefit of making the call never fail and allowing it to be
    called from atomic context.
    
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: mark gross <markgross@thegnar.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index dd76cdede64d..6e3a29732dc4 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -366,7 +366,7 @@ struct snd_pcm_substream {
 	int number;
 	char name[32];			/* substream name */
 	int stream;			/* stream (direction) */
-	struct pm_qos_request_list *latency_pm_qos_req; /* pm_qos request */
+	struct pm_qos_request_list latency_pm_qos_req; /* pm_qos request */
 	size_t buffer_bytes_max;	/* limit ring buffer size */
 	struct snd_dma_buffer dma_buffer;
 	unsigned int dma_buf_id;

commit 65ee2ba3105f6ca3b8814d993682d4f21a1f0d8d
Merge: b415ec704142 08b450988905
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 5 15:37:27 2010 +0200

    Merge branch 'devel' of git://git.alsa-project.org/alsa-kernel into topic/misc

commit 5daeba34d2aab669aea07abee13d53cd116578fb
Author: David Dillow <dave@thedillows.org>
Date:   Sun Jun 27 00:13:20 2010 +0200

    ALSA: pcm_lib: avoid timing jitter in snd_pcm_read/write()
    
    When using poll() to wait for the next period -- or avail_min samples --
    one gets a consistent delay for each system call that is usually just a
    little short of the selected period time. However, When using
    snd_pcm_read/write(), one gets a jittery delay that alternates between
    less than a millisecond and approximately two period times. This is
    caused by snd_pcm_lib_{read,write}1() transferring any available samples
    to the user's buffer and adjusting the application pointer prior to
    sleeping to the end of the current period. When the next period
    interrupt occurs, there is then less than avail_min samples remaining to
    be transferred in the period, so we end up sleeping until a second
    period occurs.
    
    This is solved by using runtime->twake as the number of samples needed
    for a wakeup in addition to selecting the proper wait queue to wake in
    snd_pcm_update_state(). This requires twake to be non-zero when used
    by snd_pcm_lib_{read,write}1() even if avail_min is zero.
    
    Signed-off-by: Dave Dillow <dave@thedillows.org>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index dd76cdede64d..83c6fa6aac43 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -313,7 +313,7 @@ struct snd_pcm_runtime {
 	struct snd_pcm_mmap_control *control;
 
 	/* -- locking / scheduling -- */
-	unsigned int twake: 1;		/* do transfer (!poll) wakeup */
+	snd_pcm_uframes_t twake; 	/* do transfer (!poll) wakeup if non-zero */
 	wait_queue_head_t sleep;	/* poll sleep */
 	wait_queue_head_t tsleep;	/* transfer sleep */
 	struct fasync_struct *fasync;

commit 15c0cee6c809a137e0fc7f1d2b0867cc03473c0c
Author: Ben Collins <bcollins@bluecherry.net>
Date:   Fri May 28 11:43:45 2010 -0400

    ALSA: pcm: Define G723 3-bit and 5-bit formats
    
    This defines the 24bps and 40bps (8khz sample rate) G.723 codec
    formats. They are going to be used once I submit the driver for
    an mpeg4/g723 compression card.
    
    I've updated the signed value to -1 as per Takashi's comments
    since these are non-linear formats.
    
    Signed-off-by: Ben Collins <bcollins@bluecherry.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index dd76cdede64d..07fd630db88d 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -174,6 +174,10 @@ struct snd_pcm_ops {
 #define SNDRV_PCM_FMTBIT_U18_3LE	(1ULL << SNDRV_PCM_FORMAT_U18_3LE)
 #define SNDRV_PCM_FMTBIT_S18_3BE	(1ULL << SNDRV_PCM_FORMAT_S18_3BE)
 #define SNDRV_PCM_FMTBIT_U18_3BE	(1ULL << SNDRV_PCM_FORMAT_U18_3BE)
+#define SNDRV_PCM_FMTBIT_G723_24	(1ULL << SNDRV_PCM_FORMAT_G723_24)
+#define SNDRV_PCM_FMTBIT_G723_24_1B	(1ULL << SNDRV_PCM_FORMAT_G723_24_1B)
+#define SNDRV_PCM_FMTBIT_G723_40	(1ULL << SNDRV_PCM_FORMAT_G723_40)
+#define SNDRV_PCM_FMTBIT_G723_40_1B	(1ULL << SNDRV_PCM_FORMAT_G723_40_1B)
 
 #ifdef SNDRV_LITTLE_ENDIAN
 #define SNDRV_PCM_FMTBIT_S16		SNDRV_PCM_FMTBIT_S16_LE

commit ed77134bfccf5e75b6cbadab268e559dbe6a4ebb
Author: Mark Gross <mgross@linux.intel.com>
Date:   Thu May 6 01:59:26 2010 +0200

    PM QOS update
    
    This patch changes the string based list management to a handle base
    implementation to help with the hot path use of pm-qos, it also renames
    much of the API to use "request" as opposed to "requirement" that was
    used in the initial implementation.  I did this because request more
    accurately represents what it actually does.
    
    Also, I added a string based ABI for users wanting to use a string
    interface.  So if the user writes 0xDDDDDDDD formatted hex it will be
    accepted by the interface.  (someone asked me for it and I don't think
    it hurts anything.)
    
    This patch updates some documentation input I got from Randy.
    
    Signed-off-by: markgross <mgross@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 8b611a561985..dd76cdede64d 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -29,6 +29,7 @@
 #include <linux/poll.h>
 #include <linux/mm.h>
 #include <linux/bitops.h>
+#include <linux/pm_qos_params.h>
 
 #define snd_pcm_substream_chip(substream) ((substream)->private_data)
 #define snd_pcm_chip(pcm) ((pcm)->private_data)
@@ -365,7 +366,7 @@ struct snd_pcm_substream {
 	int number;
 	char name[32];			/* substream name */
 	int stream;			/* stream (direction) */
-	char latency_id[20];		/* latency identifier */
+	struct pm_qos_request_list *latency_pm_qos_req; /* pm_qos request */
 	size_t buffer_bytes_max;	/* limit ring buffer size */
 	struct snd_dma_buffer dma_buffer;
 	unsigned int dma_buf_id;

commit d0d2c38e3963f4f86a9e62d74f45a371458f2787
Merge: cf944ee55cc3 e7636925789b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 26 18:13:04 2010 +0100

    Merge remote branch 'alsa/devel' into topic/misc

commit e7636925789b042ff9d98c51d48392e8c5549480
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Tue Jan 26 17:08:24 2010 +0100

    ALSA: pcm_lib - return back hw_ptr_interrupt
    
    Clemens Ladisch noted for hw_ptr_removal in "cleanup & merge hw_ptr
    update functions" commit:
    
    "It is possible for the status/delay ioctls to be called when the sound
    card's pointer register alreay shows a position at the beginning of the
    new period, but immediately before the interrupt is actually executed.
    (This happens regularly on a SMP machine with mplayer.)  When that
    happens, the code thinks that the position must be at least one period
    ahead of the current position and drops an entire buffer of data."
    
    Return back the hw_ptr_interrupt variable. The last interrupt pointer
    is always computed from the latest hw_ptr instead of tracking it
    separately (in this case all hw_ptr checks and modifications might
    influence also hw_ptr_interrupt and it is difficult to keep it
    consistent).
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 3bc9bca771ec..13bc83ca35fb 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -271,6 +271,7 @@ struct snd_pcm_runtime {
 	int overrange;
 	snd_pcm_uframes_t avail_max;
 	snd_pcm_uframes_t hw_ptr_base;	/* Position at buffer restart */
+	snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time */
 	unsigned long hw_ptr_jiffies;	/* Time when hw_ptr is updated */
 	snd_pcm_sframes_t delay;	/* extra delay; typically FIFO size */
 

commit 6250b9ced23032789ca9739d6a53949637f9c836
Merge: 8b296c8f9f66 c32d977b8157
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 21 15:27:28 2010 +0100

    Merge branch 'topic/noncached-mmap' into topic/misc

commit 8b296c8f9f660b70e958e6e6b9b4293e6ae854f2
Merge: 88501ce18eaa c91a988dc655
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 21 14:27:14 2010 +0100

    Merge remote branch 'alsa/devel' into topic/misc

commit c91a988dc6551c66418690e36b2a23cdb0255da8
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Thu Jan 21 10:32:15 2010 +0100

    ALSA: pcm_core: Fix wake_up() optimization
    
    This change fixes the "ALSA: pcm_lib - optimize wake_up() calls for PCM I/O"
    commit. New sleeping queue is introduced to separate user space and kernel
    space wake_ups. runtime->nowake is renamed to twake (transfer wake).
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index e26fb3c58037..3bc9bca771ec 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -311,8 +311,9 @@ struct snd_pcm_runtime {
 	struct snd_pcm_mmap_control *control;
 
 	/* -- locking / scheduling -- */
-	unsigned int nowake: 1;		/* no wakeup (data-copy in progress) */
-	wait_queue_head_t sleep;
+	unsigned int twake: 1;		/* do transfer (!poll) wakeup */
+	wait_queue_head_t sleep;	/* poll sleep */
+	wait_queue_head_t tsleep;	/* transfer sleep */
 	struct fasync_struct *fasync;
 
 	/* -- private section -- */

commit c32d977b8157bf67cdf47729ce7dd054a26eb534
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 18 14:58:57 2010 +0100

    ALSA: pcm - Call pgprot_noncached() for vmalloc'ed buffers
    
    pgprot_noncached() can be set for vmalloc'ed buffers safely, and we'd
    need non-cached behavior more or less, even for the intermediate ring-
    buffers.
    
    Now snd_pcm_lib_mmap_vmalloc() is added as the common PCM mmap callback
    that is coupled with snd_pcm_lib_alloc_vmalloc_buffer() & co.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 1d4ca2aae50d..aabf48bb8ee6 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1021,6 +1021,10 @@ int snd_pcm_lib_mmap_iomem(struct snd_pcm_substream *substream, struct vm_area_s
 #define snd_pcm_lib_mmap_iomem	NULL
 #endif
 
+int snd_pcm_lib_mmap_noncached(struct snd_pcm_substream *substream,
+			       struct vm_area_struct *area);
+#define snd_pcm_lib_mmap_vmalloc	snd_pcm_lib_mmap_noncached
+
 static inline void snd_pcm_limit_isa_dma_size(int dma, size_t *max)
 {
 	*max = dma < 4 ? 64 * 1024 : 128 * 1024;

commit a29fb94ff48cba620e1ac1317f5eef5920ead3ff
Merge: 52a7a5835173 dd3533eca859
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 12 09:40:08 2010 +0100

    Merge commit alsa/devel into topic/misc
    
    Conflicts:
            include/sound/version.h

commit 1250932e48d3b698415b1f04775433cf1da688d6
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Thu Jan 7 15:36:31 2010 +0100

    ALSA: pcm_lib - optimize wake_up() calls for PCM I/O
    
    As noted by pl bossart <bossart.nospam@gmail.com>, the PCM I/O routines
    (snd_pcm_lib_write1, snd_pcm_lib_read1) should block wake_up() calls
    until all samples are not processed.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index fe1b131842be..e26fb3c58037 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -311,6 +311,7 @@ struct snd_pcm_runtime {
 	struct snd_pcm_mmap_control *control;
 
 	/* -- locking / scheduling -- */
+	unsigned int nowake: 1;		/* no wakeup (data-copy in progress) */
 	wait_queue_head_t sleep;
 	struct fasync_struct *fasync;
 
@@ -839,6 +840,8 @@ void snd_pcm_set_sync(struct snd_pcm_substream *substream);
 int snd_pcm_lib_interleave_len(struct snd_pcm_substream *substream);
 int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,
 		      unsigned int cmd, void *arg);                      
+int snd_pcm_update_state(struct snd_pcm_substream *substream,
+			 struct snd_pcm_runtime *runtime);
 int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream);
 int snd_pcm_playback_xrun_check(struct snd_pcm_substream *substream);
 int snd_pcm_capture_xrun_check(struct snd_pcm_substream *substream);

commit f240406babfe1526998e10583ea5eccc2676a433
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Tue Jan 5 17:19:34 2010 +0100

    ALSA: pcm_lib - cleanup & merge hw_ptr update functions
    
    Do general cleanup in snd_pcm_update_hw_ptr*() routines and merge them.
    The main change is hw_ptr_interrupt variable removal to simplify code
    logic. This variable can be computed directly from hw_ptr.
    
    Ensure that updated hw_ptr is not lower than previous one (it was possible
    with old code in some obscure situations when interrupt was delayed or
    the lowlevel driver returns wrong ring buffer position value).
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 4e18a6dbe690..fe1b131842be 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -271,7 +271,6 @@ struct snd_pcm_runtime {
 	int overrange;
 	snd_pcm_uframes_t avail_max;
 	snd_pcm_uframes_t hw_ptr_base;	/* Position at buffer restart */
-	snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time */
 	unsigned long hw_ptr_jiffies;	/* Time when hw_ptr is updated */
 	snd_pcm_sframes_t delay;	/* extra delay; typically FIFO size */
 

commit 4d96eb255c53ab5e39b37fd4d484ea3dc39ab456
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Sun Dec 20 11:47:57 2009 +0100

    ALSA: pcm_lib - add possibility to log last 10 DMA ring buffer positions
    
    In some debug cases, it might be usefull to see previous ring buffer
    positions to determine position problems from the lowlevel drivers.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index c83a4a79f16b..4e18a6dbe690 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -262,6 +262,8 @@ struct snd_pcm_hw_constraint_list {
 	unsigned int mask;
 };
 
+struct snd_pcm_hwptr_log;
+
 struct snd_pcm_runtime {
 	/* -- Status -- */
 	struct snd_pcm_substream *trigger_master;
@@ -340,6 +342,10 @@ struct snd_pcm_runtime {
 	/* -- OSS things -- */
 	struct snd_pcm_oss_runtime oss;
 #endif
+
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
+	struct snd_pcm_hwptr_log *hwptr_log;
+#endif
 };
 
 struct snd_pcm_group {		/* keep linked substreams */

commit 681b84e17747e1c208e8e1acc54cc5e612da84d1
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Dec 18 09:29:00 2009 +0100

    sound: pcm: add vmalloc buffer helper functions
    
    There are now five copies of the code to allocate a PCM buffer using
    vmalloc().  Add a sixth in the core so that the others can be removed.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index c83a4a79f16b..0ad2d28f2360 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -905,6 +905,44 @@ int snd_pcm_lib_preallocate_pages_for_all(struct snd_pcm *pcm,
 int snd_pcm_lib_malloc_pages(struct snd_pcm_substream *substream, size_t size);
 int snd_pcm_lib_free_pages(struct snd_pcm_substream *substream);
 
+int _snd_pcm_lib_alloc_vmalloc_buffer(struct snd_pcm_substream *substream,
+				      size_t size, gfp_t gfp_flags);
+int snd_pcm_lib_free_vmalloc_buffer(struct snd_pcm_substream *substream);
+struct page *snd_pcm_lib_get_vmalloc_page(struct snd_pcm_substream *substream,
+					  unsigned long offset);
+#if 0 /* for kernel-doc */
+/**
+ * snd_pcm_lib_alloc_vmalloc_buffer - allocate virtual DMA buffer
+ * @substream: the substream to allocate the buffer to
+ * @size: the requested buffer size, in bytes
+ *
+ * Allocates the PCM substream buffer using vmalloc(), i.e., the memory is
+ * contiguous in kernel virtual space, but not in physical memory.  Use this
+ * if the buffer is accessed by kernel code but not by device DMA.
+ *
+ * Returns 1 if the buffer was changed, 0 if not changed, or a negative error
+ * code.
+ */
+static int snd_pcm_lib_alloc_vmalloc_buffer
+			(struct snd_pcm_substream *substream, size_t size);
+/**
+ * snd_pcm_lib_alloc_vmalloc_32_buffer - allocate 32-bit-addressable buffer
+ * @substream: the substream to allocate the buffer to
+ * @size: the requested buffer size, in bytes
+ *
+ * This function works like snd_pcm_lib_alloc_vmalloc_buffer(), but uses
+ * vmalloc_32(), i.e., the pages are allocated from 32-bit-addressable memory.
+ */
+static int snd_pcm_lib_alloc_vmalloc_32_buffer
+			(struct snd_pcm_substream *substream, size_t size);
+#endif
+#define snd_pcm_lib_alloc_vmalloc_buffer(subs, size) \
+	_snd_pcm_lib_alloc_vmalloc_buffer \
+			(subs, size, GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO)
+#define snd_pcm_lib_alloc_vmalloc_32_buffer(subs, size) \
+	_snd_pcm_lib_alloc_vmalloc_buffer \
+			(subs, size, GFP_KERNEL | GFP_DMA32 | __GFP_ZERO)
+
 #ifdef CONFIG_SND_DMA_SGBUF
 /*
  * SG-buffer handling

commit e7373b702f6eab35f315e016a4159860a7a4d686
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Nov 10 10:13:30 2009 +0100

    sound: pcm: record a substream's owner process
    
    Record the pid of the task that opened a PCM substream. For sound
    cards with hardware mixing, this allows determining which process
    is associated with a specific substream's volume control.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index de6d981de5d6..c83a4a79f16b 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -348,6 +348,8 @@ struct snd_pcm_group {		/* keep linked substreams */
 	int count;
 };
 
+struct pid;
+
 struct snd_pcm_substream {
 	struct snd_pcm *pcm;
 	struct snd_pcm_str *pstr;
@@ -379,6 +381,7 @@ struct snd_pcm_substream {
 	atomic_t mmap_count;
 	unsigned int f_flags;
 	void (*pcm_release)(struct snd_pcm_substream *);
+	struct pid *pid;
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	/* -- OSS things -- */
 	struct snd_pcm_oss_substream oss;

commit 6a0f4021469727675b83d85ac91d106bfae0e2c3
Merge: f9892a52e240 b888d1ce82eb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 10 15:32:51 2009 +0200

    Merge branch 'topic/dummy' into for-linus
    
    * topic/dummy:
      ALSA: dummy - Increase MAX_PCM_SUBSTREAMS to 128
      ALSA: dummy - Add debug proc file
      ALSA: Add const prefix to proc helper functions
      ALSA: Re-export snd_pcm_format_name() function
      ALSA: dummy - Fake buffer allocations
      ALSA: dummy - Fix the timer calculation in systimer mode
      ALSA: dummy - Add more description
      ALSA: dummy - Better jiffies handling
      ALSA: dummy - Support high-res timer mode

commit 6e5265ec34d3b9578973841ddec8b925e986136a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 8 14:26:51 2009 +0200

    ALSA: Re-export snd_pcm_format_name() function
    
    Re-export snd_pcm_format_name() function to be used outside the PCM core.
    As a first example, usbaudio is changed to use it now again.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 23893523dc8c..4d5b2407514e 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -965,4 +965,6 @@ static inline void snd_pcm_limit_isa_dma_size(int dma, size_t *max)
 
 #define PCM_RUNTIME_CHECK(sub) snd_BUG_ON(!(sub) || !(sub)->runtime)
 
+const char *snd_pcm_format_name(snd_pcm_format_t format);
+
 #endif /* __SOUND_PCM_H */

commit cc6a8acdeee932f6911d8b236d2c7d6bcc4616f6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jun 17 16:39:06 2008 +0200

    ALSA: Fix SG-buffer DMA with non-coherent architectures
    
    Using SG-buffers with dma_alloc_coherent() is often very inefficient
    on non-coherent architectures because a tracking record could be
    allocated in addition for each dma_alloc_coherent() call.
    Instead, simply disable SG-buffers but just allocate normal continuous
    buffers on non-supported (currently all but x86) architectures.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 23893523dc8c..1691c7fe35af 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -902,6 +902,7 @@ int snd_pcm_lib_preallocate_pages_for_all(struct snd_pcm *pcm,
 int snd_pcm_lib_malloc_pages(struct snd_pcm_substream *substream, size_t size);
 int snd_pcm_lib_free_pages(struct snd_pcm_substream *substream);
 
+#ifdef CONFIG_SND_DMA_SGBUF
 /*
  * SG-buffer handling
  */
@@ -927,6 +928,28 @@ struct page *snd_pcm_sgbuf_ops_page(struct snd_pcm_substream *substream,
 unsigned int snd_pcm_sgbuf_get_chunk_size(struct snd_pcm_substream *substream,
 					  unsigned int ofs, unsigned int size);
 
+#else /* !SND_DMA_SGBUF */
+/*
+ * fake using a continuous buffer
+ */
+static inline dma_addr_t
+snd_pcm_sgbuf_get_addr(struct snd_pcm_substream *substream, unsigned int ofs)
+{
+	return substream->runtime->dma_addr + ofs;
+}
+
+static inline void *
+snd_pcm_sgbuf_get_ptr(struct snd_pcm_substream *substream, unsigned int ofs)
+{
+	return substream->runtime->dma_area + ofs;
+}
+
+#define snd_pcm_sgbuf_ops_page	NULL
+
+#define snd_pcm_sgbuf_get_chunk_size(subs, ofs, size)	(size)
+
+#endif /* SND_DMA_SGBUF */
+
 /* handle mmap counter - PCM mmap callback should handle this counter properly */
 static inline void snd_pcm_mmap_data_open(struct vm_area_struct *area)
 {

commit 3b88bc522986ae853670fcba71bb3761c84f7867
Merge: eabaf0634a90 c00701101b82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 10 07:26:41 2009 +0200

    Merge branch 'topic/pcm-jiffies-check' into for-linus
    
    * topic/pcm-jiffies-check:
      ALSA: pcm - A helper function to compose PCM stream name for debug prints
      ALSA: pcm - Fix update of runtime->hw_ptr_interrupt
      ALSA: pcm - Fix a typo in hw_ptr update check
      ALSA: PCM midlevel: lower jiffies check margin using runtime->delay value
      ALSA: PCM midlevel: Do not update hw_ptr_jiffies when hw_ptr is not changed
      ALSA: PCM midlevel: introduce mask for xrun_debug() macro
      ALSA: PCM midlevel: improve fifo_size handling

commit eabaf0634a9034f2e487b0be347edc1460c026a4
Merge: 9dea75c70965 ae1ec5e1e97f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 10 07:26:40 2009 +0200

    Merge branch 'topic/pcm-delay' into for-linus
    
    * topic/pcm-delay:
      ALSA: usbaudio - Add delay account
      ALSA: Add extra delay count in PCM

commit 3f7440a6b771169e1f11fa582e53a4259b682809
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 5 17:40:04 2009 +0200

    ALSA: Clean up 64bit division functions
    
    Replace the house-made div64_32() with the standard div_u64*() functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index c17296891617..0caf71e16944 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -486,80 +486,6 @@ void snd_pcm_detach_substream(struct snd_pcm_substream *substream);
 void snd_pcm_vma_notify_data(void *client, void *data);
 int snd_pcm_mmap_data(struct snd_pcm_substream *substream, struct file *file, struct vm_area_struct *area);
 
-#if BITS_PER_LONG >= 64
-
-static inline void div64_32(u_int64_t *n, u_int32_t div, u_int32_t *rem)
-{
-	*rem = *n % div;
-	*n /= div;
-}
-
-#elif defined(i386)
-
-static inline void div64_32(u_int64_t *n, u_int32_t div, u_int32_t *rem)
-{
-	u_int32_t low, high;
-	low = *n & 0xffffffff;
-	high = *n >> 32;
-	if (high) {
-		u_int32_t high1 = high % div;
-		high /= div;
-		asm("divl %2":"=a" (low), "=d" (*rem):"rm" (div), "a" (low), "d" (high1));
-		*n = (u_int64_t)high << 32 | low;
-	} else {
-		*n = low / div;
-		*rem = low % div;
-	}
-}
-#else
-
-static inline void divl(u_int32_t high, u_int32_t low,
-			u_int32_t div,
-			u_int32_t *q, u_int32_t *r)
-{
-	u_int64_t n = (u_int64_t)high << 32 | low;
-	u_int64_t d = (u_int64_t)div << 31;
-	u_int32_t q1 = 0;
-	int c = 32;
-	while (n > 0xffffffffU) {
-		q1 <<= 1;
-		if (n >= d) {
-			n -= d;
-			q1 |= 1;
-		}
-		d >>= 1;
-		c--;
-	}
-	q1 <<= c;
-	if (n) {
-		low = n;
-		*q = q1 | (low / div);
-		*r = low % div;
-	} else {
-		*r = 0;
-		*q = q1;
-	}
-	return;
-}
-
-static inline void div64_32(u_int64_t *n, u_int32_t div, u_int32_t *rem)
-{
-	u_int32_t low, high;
-	low = *n & 0xffffffff;
-	high = *n >> 32;
-	if (high) {
-		u_int32_t high1 = high % div;
-		u_int32_t low1 = low;
-		high /= div;
-		divl(high1, low1, div, &low, rem);
-		*n = (u_int64_t)high << 32 | low;
-	} else {
-		*n = low / div;
-		*rem = low % div;
-	}
-}
-#endif
-
 /*
  *  PCM library
  */

commit 8bea869c5e56234990e6bad92a543437115bfc18
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Apr 27 09:44:40 2009 +0200

    ALSA: PCM midlevel: improve fifo_size handling
    
    Move the fifo_size assignment to hw->ioctl callback to allow lowlevel
    drivers overwrite the default behaviour.
    
    fifo_size is in frames not bytes as specified in asound.h and alsa-lib's
    documentation, but most hardware have fixed byte based FIFOs. Introduce
    internal SNDRV_PCM_INFO_FIFO_IN_FRAMES.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 267effddb070..8a69b5c1e1c4 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -98,6 +98,7 @@ struct snd_pcm_ops {
 #define SNDRV_PCM_IOCTL1_INFO		1
 #define SNDRV_PCM_IOCTL1_CHANNEL_INFO	2
 #define SNDRV_PCM_IOCTL1_GSTATE		3
+#define SNDRV_PCM_IOCTL1_FIFO_SIZE	4
 
 #define SNDRV_PCM_TRIGGER_STOP		0
 #define SNDRV_PCM_TRIGGER_START		1

commit 4bbe1ddf89a5ba3ec30fe5980912d8bda3a3cbb2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 13 03:07:14 2008 +0200

    ALSA: Add extra delay count in PCM
    
    Added runtime->delay field to adjust the delayed samples for snd_pcm_delay().
    Typically a hardware FIFO length is stored in this field, so that the
    extra delay between hwptr and applptr can be computed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index c17296891617..267effddb070 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -270,6 +270,7 @@ struct snd_pcm_runtime {
 	snd_pcm_uframes_t hw_ptr_base;	/* Position at buffer restart */
 	snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time */
 	unsigned long hw_ptr_jiffies;	/* Time when hw_ptr is updated */
+	snd_pcm_sframes_t delay;	/* extra delay; typically FIFO size */
 
 	/* -- HW params -- */
 	snd_pcm_access_t access;	/* access mode */

commit bbf6ad1399e9516b0a95de3ad58ffbaed670e4cc
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Fri Apr 10 12:28:58 2009 +0200

    [ALSA] pcm-midlevel: Add more strict buffer position checks based on jiffies
    
    Some drivers like Intel8x0 or Intel HDA are broken for some hardware variants.
    This patch adds more strict buffer position checks based on jiffies when
    internal hw_ptr is updated. Enable xrun_debug to see mangling of wrong
    positions.
    
    As a side effect, the hw_ptr interrupt update routine might do slightly better
    job when many interrupts are lost.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 8904b1900d7f..c17296891617 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -268,7 +268,8 @@ struct snd_pcm_runtime {
 	int overrange;
 	snd_pcm_uframes_t avail_max;
 	snd_pcm_uframes_t hw_ptr_base;	/* Position at buffer restart */
-	snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time*/
+	snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time */
+	unsigned long hw_ptr_jiffies;	/* Time when hw_ptr is updated */
 
 	/* -- HW params -- */
 	snd_pcm_access_t access;	/* access mode */

commit e0d2054fd3cf167395390dc1758644486c782707
Merge: d807500a2472 c468ac29e63b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 24 00:35:50 2009 +0100

    Merge branch 'topic/misc' into for-linus

commit 85122ea40c4fc82af5b66b8683f525c2c4a36d1a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Mar 6 16:30:07 2009 +0100

    ALSA: Remove unneeded snd_pcm_substream.timer_lock
    
    The timer callbacks are called in the protected status by the lock
    of the timer instance, so there is no need for an extra lock in the
    PCM substream.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 40c5a6fa6bcd..e4f60076e6c4 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -364,7 +364,6 @@ struct snd_pcm_substream {
         /* -- timer section -- */
 	struct snd_timer *timer;		/* timer */
 	unsigned timer_running: 1;	/* time is running */
-	spinlock_t timer_lock;
 	/* -- next substream -- */
 	struct snd_pcm_substream *next;
 	/* -- linked substreams -- */

commit e6161653094f14b1add10efe3493a2e526fe9538
Author: Tim Blechmann <tim@klingt.org>
Date:   Thu Feb 5 13:01:54 2009 +0100

    ALSA: snd_pcm_new api cleanup
    
    Impact: cleanup
    
    snd_pcm_new takes a char *id argument, although it is not modifying
    the string. it can therefore be declared as const char *id.
    
    Signed-off-by: Tim Blechmann <tim@klingt.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 40c5a6fa6bcd..ee0e887e49d4 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -451,7 +451,7 @@ struct snd_pcm_notify {
 
 extern const struct file_operations snd_pcm_f_ops[2];
 
-int snd_pcm_new(struct snd_card *card, char *id, int device,
+int snd_pcm_new(struct snd_card *card, const char *id, int device,
 		int playback_count, int capture_count,
 		struct snd_pcm **rpcm);
 int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count);

commit 51e9f2e665bf2b6a01be275d64c336d942c59a66
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 30 15:13:33 2008 +0200

    ALSA: Allocate larger pages in sgbuf
    
    Most hardwares have limited buffer-descriptor table length.  This
    also restricts the max buffer size of the sound driver.
    For example, snd-hda-intel has 1MB buffer size limit, and this is
    because it can have at most 256 BDL entries.  For supporting larger
    buffers, we need to allocate larger pages even for sg-buffers.
    
    This patch changes the sgbuf allocation code to try to allocate
    larger pages first.  At each head of the allocated pages, the
    number of allocated pages is stored in the lowest bits of the
    corresponding entry of the table addr field.  This change isn't
    visible as long as the driver uses snd_sgbuf_get_addr() helper.
    
    Also, the patch adds a new function, snd_pcm_sgbuf_get_chunk_size().
    This returns the size of the chunk on continuous pages starting at
    the given position offset.  If the chunk reaches to a non-continuous
    page, it returns the size to the boundary.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 8db89630c821..40c5a6fa6bcd 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -996,7 +996,8 @@ snd_pcm_sgbuf_get_ptr(struct snd_pcm_substream *substream, unsigned int ofs)
 
 struct page *snd_pcm_sgbuf_ops_page(struct snd_pcm_substream *substream,
 				    unsigned long offset);
-
+unsigned int snd_pcm_sgbuf_get_chunk_size(struct snd_pcm_substream *substream,
+					  unsigned int ofs, unsigned int size);
 
 /* handle mmap counter - PCM mmap callback should handle this counter properly */
 static inline void snd_pcm_mmap_data_open(struct vm_area_struct *area)

commit 77a23f2695bb2de0cd74599400dc55109c531b72
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 21 13:00:13 2008 +0200

    ALSA: Clean up SG-buffer helper functions and macros
    
    Clean up SG-buffer helper functions and macros.  Helpers take substream
    as arguments now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 9ce74633e6ff..8db89630c821 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -974,10 +974,29 @@ int snd_pcm_lib_preallocate_pages_for_all(struct snd_pcm *pcm,
 int snd_pcm_lib_malloc_pages(struct snd_pcm_substream *substream, size_t size);
 int snd_pcm_lib_free_pages(struct snd_pcm_substream *substream);
 
-#define snd_pcm_substream_sgbuf(substream) ((substream)->runtime->dma_buffer_p->private_data)
-#define snd_pcm_sgbuf_pages(size) snd_sgbuf_aligned_pages(size)
-#define snd_pcm_sgbuf_get_addr(sgbuf,ofs) snd_sgbuf_get_addr(sgbuf,ofs)
-struct page *snd_pcm_sgbuf_ops_page(struct snd_pcm_substream *substream, unsigned long offset);
+/*
+ * SG-buffer handling
+ */
+#define snd_pcm_substream_sgbuf(substream) \
+	((substream)->runtime->dma_buffer_p->private_data)
+
+static inline dma_addr_t
+snd_pcm_sgbuf_get_addr(struct snd_pcm_substream *substream, unsigned int ofs)
+{
+	struct snd_sg_buf *sg = snd_pcm_substream_sgbuf(substream);
+	return snd_sgbuf_get_addr(sg, ofs);
+}
+
+static inline void *
+snd_pcm_sgbuf_get_ptr(struct snd_pcm_substream *substream, unsigned int ofs)
+{
+	struct snd_sg_buf *sg = snd_pcm_substream_sgbuf(substream);
+	return snd_sgbuf_get_ptr(sg, ofs);
+}
+
+struct page *snd_pcm_sgbuf_ops_page(struct snd_pcm_substream *substream,
+				    unsigned long offset);
+
 
 /* handle mmap counter - PCM mmap callback should handle this counter properly */
 static inline void snd_pcm_mmap_data_open(struct vm_area_struct *area)

commit 7eaa943c8ed8e91e05d0f5d0dc7a18e3319b45cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:09:09 2008 +0200

    ALSA: Kill snd_assert() in sound/core/*
    
    Kill snd_assert() in sound/core/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 5dd8ea4a8c4b..9ce74633e6ff 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1015,4 +1015,6 @@ static inline void snd_pcm_limit_isa_dma_size(int dma, size_t *max)
 					 (IEC958_AES1_CON_PCM_CODER<<8)|\
 					 (IEC958_AES3_CON_FS_48000<<24))
 
+#define PCM_RUNTIME_CHECK(sub) snd_BUG_ON(!(sub) || !(sub)->runtime)
+
 #endif /* __SOUND_PCM_H */

commit f90c06a2b613eea24a77d56f24b084745c43713d
Author: Pawel MOLL <pawel.moll@st.com>
Date:   Wed Jul 30 12:46:40 2008 +0100

    ALSA: Fix limit of 8 PCM devices in SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE
    
    When compiled with CONFIG_SND_DYNAMIC_MINORS the ALSA core is fine
    to have more than 8 PCM devices per card, except one place - the
    SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE ioctl, which will not enumerate
    devices > 7. This patch fixes the issue, changing the devices list
    organisation.
    
    Instead of adding new device to the tail, the list is now kept always
    ordered (by card number, then device number). Thus, during enumeration,
    it is easy to discover the fact that there is no more given card's
    devices.
    
    Additionally the device field of struct snd_pcm had to be changed to int,
    as its "unsignednity" caused a lot of problems when comparing it to
    potentially negative signed values. (-1 is 0xffffffff or even more then ;-)
    
    Signed-off-by: Pawel Moll <pawel.moll@st.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 51d58ccda2d8..5dd8ea4a8c4b 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -25,6 +25,7 @@
 
 #include <sound/asound.h>
 #include <sound/memalloc.h>
+#include <sound/minors.h>
 #include <linux/poll.h>
 #include <linux/mm.h>
 #include <linux/bitops.h>
@@ -84,7 +85,11 @@ struct snd_pcm_ops {
  *
  */
 
-#define SNDRV_PCM_DEVICES		8
+#if defined(CONFIG_SND_DYNAMIC_MINORS)
+#define SNDRV_PCM_DEVICES	(SNDRV_OS_MINORS-2)
+#else
+#define SNDRV_PCM_DEVICES	8
+#endif
 
 #define SNDRV_PCM_IOCTL1_FALSE		((void *)0)
 #define SNDRV_PCM_IOCTL1_TRUE		((void *)1)
@@ -416,7 +421,7 @@ struct snd_pcm_str {
 struct snd_pcm {
 	struct snd_card *card;
 	struct list_head list;
-	unsigned int device;	/* device number */
+	int device; /* device number */
 	unsigned int info_flags;
 	unsigned short dev_class;
 	unsigned short dev_subclass;

commit 896e6cc20e67038af12e1a7711eef32647e62f23
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Fri Aug 1 13:36:04 2008 +0200

    sound: Revert "ALSA: Fix limit of 8 PCM devices in SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE"
    
    This reverts commit fb3d6f2b77bdec75d45aa9d4464287ed87927866.
    
    New, updated patch with same subject replaces this commit.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index bfc096ac82e5..51d58ccda2d8 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -84,6 +84,8 @@ struct snd_pcm_ops {
  *
  */
 
+#define SNDRV_PCM_DEVICES		8
+
 #define SNDRV_PCM_IOCTL1_FALSE		((void *)0)
 #define SNDRV_PCM_IOCTL1_TRUE		((void *)1)
 
@@ -414,7 +416,7 @@ struct snd_pcm_str {
 struct snd_pcm {
 	struct snd_card *card;
 	struct list_head list;
-	int device; /* device number */
+	unsigned int device;	/* device number */
 	unsigned int info_flags;
 	unsigned short dev_class;
 	unsigned short dev_subclass;

commit 9423969005586e6e27ca380e01b4a8c50698e2af
Author: Pawel MOLL <pawel.moll@st.com>
Date:   Tue Jul 29 17:34:26 2008 +0100

    ALSA: Fix limit of 8 PCM devices in SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE
    
    When compiled with CONFIG_SND_DYNAMIC_MINORS the ALSA core is fine
    to have more than 8 PCM devices per card, except one place - the
    SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE ioctl, which will not enumerate
    devices > 7. This patch fixes the issue, changing the devices list
    organisation.
    
    Instead of adding new device to the tail, the list is now kept always
    ordered (by card number, then device number). Thus, during enumeration,
    it is easy to discover the fact that there is no more given card's
    devices. The same limit was present in OSS emulation code. It has
    been fixed as well.
    
    Additionally the device field of struct snd_pcm is now int, instead of
    unsigned int, as there is no obvious reason for keeping it unsigned.
    This caused a lot of problems with comparing this value with other
    (almost always signed) variables. There is just one more place where
    device number is unsigned - in struct snd_pcm_info, which should be
    also sorted out in future.
    
    Signed-off-by: Pawel MOLL <pawel.moll@st.com>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 51d58ccda2d8..bfc096ac82e5 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -84,8 +84,6 @@ struct snd_pcm_ops {
  *
  */
 
-#define SNDRV_PCM_DEVICES		8
-
 #define SNDRV_PCM_IOCTL1_FALSE		((void *)0)
 #define SNDRV_PCM_IOCTL1_TRUE		((void *)1)
 
@@ -416,7 +414,7 @@ struct snd_pcm_str {
 struct snd_pcm {
 	struct snd_card *card;
 	struct list_head list;
-	unsigned int device;	/* device number */
+	int device; /* device number */
 	unsigned int info_flags;
 	unsigned short dev_class;
 	unsigned short dev_subclass;

commit 31e8960b35975ed235d283d6fb95d0e28dffded0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:09:57 2008 +0100

    [ALSA] Remove PCM sleep_min and tick
    
    The 'tick' in PCM is set (again) via sw_params.  And, nobody uses
    this feature at all except for a command line option of aplay.
    (This is literally 'nobody', as I checked alsa-lib API calls in all
     programs in major distros.)
    Above all, if we need finer wake-ups for the position update, it's
    basically an issue that the driver should solve, not tuned by each
    application.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 1270cbce776a..51d58ccda2d8 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -274,7 +274,6 @@ struct snd_pcm_runtime {
 	snd_pcm_uframes_t period_size;	/* period size */
 	unsigned int periods;		/* periods */
 	snd_pcm_uframes_t buffer_size;	/* buffer size */
-	unsigned int tick_time;		/* tick time */
 	snd_pcm_uframes_t min_align;	/* Min alignment for the format */
 	size_t byte_align;
 	unsigned int frame_bits;
@@ -286,7 +285,6 @@ struct snd_pcm_runtime {
 	/* -- SW params -- */
 	int tstamp_mode;		/* mmap timestamp is updated */
   	unsigned int period_step;
-	unsigned int sleep_min;		/* min ticks to sleep */
 	snd_pcm_uframes_t start_threshold;
 	snd_pcm_uframes_t stop_threshold;
 	snd_pcm_uframes_t silence_threshold; /* Silence filling happens when
@@ -305,7 +303,6 @@ struct snd_pcm_runtime {
 
 	/* -- locking / scheduling -- */
 	wait_queue_head_t sleep;
-	struct timer_list tick_timer;
 	struct fasync_struct *fasync;
 
 	/* -- private section -- */
@@ -810,7 +807,6 @@ static inline const struct snd_interval *hw_param_interval_c(const struct snd_pc
 #define params_periods(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_PERIODS)->min
 #define params_buffer_size(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_BUFFER_SIZE)->min
 #define params_buffer_bytes(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_BUFFER_BYTES)->min
-#define params_tick_time(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_TICK_TIME)->min
 
 
 int snd_interval_refine(struct snd_interval *i, const struct snd_interval *v);
@@ -908,9 +904,6 @@ int snd_pcm_capture_xrun_check(struct snd_pcm_substream *substream);
 int snd_pcm_playback_xrun_asap(struct snd_pcm_substream *substream);
 int snd_pcm_capture_xrun_asap(struct snd_pcm_substream *substream);
 void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_uframes_t new_hw_ptr);
-void snd_pcm_tick_prepare(struct snd_pcm_substream *substream);
-void snd_pcm_tick_set(struct snd_pcm_substream *substream, unsigned long ticks);
-void snd_pcm_tick_elapsed(struct snd_pcm_substream *substream);
 void snd_pcm_period_elapsed(struct snd_pcm_substream *substream);
 snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream,
 				    const void __user *buf,

commit d948035a928400ae127c873fbf771389bee18949
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:05:26 2008 +0100

    [ALSA] Remove PCM xfer_align sw params
    
    The xfer_align sw_params parameter has never been used in a sane manner,
    and no one understands what this does exactly.  The current
    implementation looks also buggy because it allows write of shorter size
    than xfer_align.  So, if you do partial writes, the write isn't actually
    aligned at all.
    Removing this parameter will make some pcm_lib_* code more readable
    (and less buggy).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 65f636223d39..1270cbce776a 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -287,7 +287,6 @@ struct snd_pcm_runtime {
 	int tstamp_mode;		/* mmap timestamp is updated */
   	unsigned int period_step;
 	unsigned int sleep_min;		/* min ticks to sleep */
-	snd_pcm_uframes_t xfer_align;	/* xfer size need to be a multiple */
 	snd_pcm_uframes_t start_threshold;
 	snd_pcm_uframes_t stop_threshold;
 	snd_pcm_uframes_t silence_threshold; /* Silence filling happens when

commit b751eef1fdffca5532344285f2fad0c60d2f0158
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Thu Dec 13 10:19:42 2007 +0100

    [ALSA] Use posix clock monotonic for PCM and timer timestamps
    
    We need an accurate and continuous (monotonic) time sources to do
    accurate synchronization among more timing sources. This patch allows
    to enable monotonic timestamps for ALSA PCM devices and enables monotonic
    timestamps for ALSA timer devices.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 5e9cc460075e..65f636223d39 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -323,6 +323,7 @@ struct snd_pcm_runtime {
 
 	/* -- timer -- */
 	unsigned int timer_resolution;	/* timer resolution */
+	int tstamp_type;		/* timestamp type */
 
 	/* -- DMA -- */           
 	unsigned char *dma_area;	/* DMA area */
@@ -952,6 +953,15 @@ void snd_pcm_timer_resolution_change(struct snd_pcm_substream *substream);
 void snd_pcm_timer_init(struct snd_pcm_substream *substream);
 void snd_pcm_timer_done(struct snd_pcm_substream *substream);
 
+static inline void snd_pcm_gettime(struct snd_pcm_runtime *runtime,
+				   struct timespec *tv)
+{
+	if (runtime->tstamp_type == SNDRV_PCM_TSTAMP_TYPE_MONOTONIC)
+		do_posix_clock_monotonic_gettime(tv);
+	else
+		getnstimeofday(tv);
+}
+
 /*
  *  Memory
  */

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 805d7207f08b..5e9cc460075e 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -3,7 +3,7 @@
 
 /*
  *  Digital Audio (PCM) abstract layer
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *                   Abramo Bagnara <abramo@alsa-project.org>
  *
  *

commit 503fc85a3b15b0e939ad9672e376ffc9c4840591
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 11 00:35:06 2007 +0200

    [ALSA] Kill useless volatile in pcm.h
    
    The volatile prefix is just useless there.  Let's kill them, and then
    gcc will be happier, too.
       sound/acore/pcm.c:867: warning: passing argument 1 of __constant_c_and_count_memset discards qualifiers from pointer target type
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 76b34b5841eb..805d7207f08b 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -301,8 +301,8 @@ struct snd_pcm_runtime {
 	union snd_pcm_sync_id sync;	/* hardware synchronization ID */
 
 	/* -- mmap -- */
-	volatile struct snd_pcm_mmap_status *status;
-	volatile struct snd_pcm_mmap_control *control;
+	struct snd_pcm_mmap_status *status;
+	struct snd_pcm_mmap_control *control;
 
 	/* -- locking / scheduling -- */
 	wait_queue_head_t sleep;

commit b9f09a485937d9c3fb524b2fa140fee1d94856d0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 11 00:33:48 2007 +0200

    [ALSA] Fix 'discards qualifiers' compile warnings in pcm.h
    
    Fixed cast messes in pcm.h.
        include/sound/pcm.h: In function hw_param_interval_c:
        include/sound/pcm.h:800: warning: passing argument 1 of hw_param_interval discards qualifiers from pointer target type
    Simply redefine the inline functions again for const pointers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 27f8ef48b5ec..76b34b5841eb 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -791,13 +791,13 @@ static inline struct snd_interval *hw_param_interval(struct snd_pcm_hw_params *p
 static inline const struct snd_mask *hw_param_mask_c(const struct snd_pcm_hw_params *params,
 					     snd_pcm_hw_param_t var)
 {
-	return (const struct snd_mask *)hw_param_mask((struct snd_pcm_hw_params*) params, var);
+	return &params->masks[var - SNDRV_PCM_HW_PARAM_FIRST_MASK];
 }
 
 static inline const struct snd_interval *hw_param_interval_c(const struct snd_pcm_hw_params *params,
 						     snd_pcm_hw_param_t var)
 {
-	return (const struct snd_interval *)hw_param_interval((struct snd_pcm_hw_params*) params, var);
+	return &params->intervals[var - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL];
 }
 
 #define params_access(p) snd_mask_min(hw_param_mask((p), SNDRV_PCM_HW_PARAM_ACCESS))

commit 918f3a0e8cf67b5db966516f255eaf24d814fac0
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Aug 13 17:40:54 2007 +0200

    [ALSA] pcm: add snd_pcm_rate_to_rate_bit() helper
    
    Add a snd_pcm_rate_to_rate_bit() function to factor out common code used
    by several drivers.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 2d5dee2fcb64..27f8ef48b5ec 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -925,6 +925,7 @@ snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 extern const struct snd_pcm_hw_constraint_list snd_pcm_known_rates;
 
 int snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime);
+unsigned int snd_pcm_rate_to_rate_bit(unsigned int rate);
 
 static inline void snd_pcm_set_runtime_buffer(struct snd_pcm_substream *substream,
 					      struct snd_dma_buffer *bufp)

commit 7653d557606c7cae921557a6a0ebb7c510e458eb
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Aug 13 17:38:54 2007 +0200

    [ALSA] pcm: merge rates[] from pcm_misc.c and pcm_native.c
    
    Merge the rates[] arrays from pcm_misc.c and pcm_native.c because they
    are both the same.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 73334e0f823f..2d5dee2fcb64 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -922,6 +922,8 @@ snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,
 snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 				    void __user **bufs, snd_pcm_uframes_t frames);
 
+extern const struct snd_pcm_hw_constraint_list snd_pcm_known_rates;
+
 int snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime);
 
 static inline void snd_pcm_set_runtime_buffer(struct snd_pcm_substream *substream,

commit ef991b95aa1351a5782cfaccb9aefba76ca8b990
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 22 12:52:53 2007 +0100

    [ALSA] Add snd_pcm_group_for_each_entry() for code cleanup
    
    Added a new macro snd_pcm_group_for_each_entry() just for code cleanup.
    Old macros, snd_pcm_group_for_each() and snd_pcm_group_substream_entry(),
    are removed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index deff5a92efa6..73334e0f823f 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -603,11 +603,8 @@ do { \
 	read_unlock_irqrestore(&snd_pcm_link_rwlock, (flags)); \
 } while (0)
 
-#define snd_pcm_group_for_each(pos, substream) \
-	list_for_each(pos, &substream->group->substreams)
-
-#define snd_pcm_group_substream_entry(pos) \
-	list_entry(pos, struct snd_pcm_substream, link_list)
+#define snd_pcm_group_for_each_entry(s, substream) \
+	list_for_each_entry(s, &substream->group->substreams, link_list)
 
 static inline int snd_pcm_running(struct snd_pcm_substream *substream)
 {

commit 540473208f8ac71c25a87e1a2670c3c18dd4d6db
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:28 2007 -0800

    [PATCH] mark struct file_operations const 1
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index ee6bc2d06803..deff5a92efa6 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -447,7 +447,7 @@ struct snd_pcm_notify {
  *  Registering
  */
 
-extern struct file_operations snd_pcm_f_ops[2];
+extern const struct file_operations snd_pcm_f_ops[2];
 
 int snd_pcm_new(struct snd_card *card, char *id, int device,
 		int playback_count, int capture_count,

commit e0e6ce0380e0c4de35371372bc5b6c2b02458597
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Thu Dec 7 08:22:50 2006 +0100

    [ALSA] add struct snd_pcm_substream forward declaration
    
    fixes: include/sound/pcm.h:62: warning: 'struct snd_pcm_substream' declared
    inside parameter list
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index ec006ed8cd59..ee6bc2d06803 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -56,6 +56,8 @@ struct snd_pcm_hardware {
 	size_t fifo_size;		/* fifo size in bytes */
 };
 
+struct snd_pcm_substream;
+
 struct snd_pcm_ops {
 	int (*open)(struct snd_pcm_substream *substream);
 	int (*close)(struct snd_pcm_substream *substream);

commit c7132aeb72ad1106dc76279de4d005f9e1c5815c
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Fri Oct 6 15:12:29 2006 +0200

    [ALSA] pcm core: add prealloc_max file to substream directory to show maximum DMA size
    
    Users ask us many times about the maximum DMA size for PCM devices. This
    file gives them a hint in KB.
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 016c41893b06..ec006ed8cd59 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -384,6 +384,7 @@ struct snd_pcm_substream {
 	struct snd_info_entry *proc_sw_params_entry;
 	struct snd_info_entry *proc_status_entry;
 	struct snd_info_entry *proc_prealloc_entry;
+	struct snd_info_entry *proc_prealloc_max_entry;
 #endif
 	/* misc flags */
 	unsigned int hw_opened: 1;

commit c78085fcd2ce7cd036e1488472eb41a64d70949a
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Oct 5 15:06:34 2006 +0200

    [ALSA] alsa core: add struct device pointer to struct snd_pcm
    
    This patch adds a struct device pointer to struct snd_pcm in order to be
    able to give it a different device than the card. It defaults to the card's
    device, however, so it should behave identically for drivers not touching
    the field.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 2f645dfd7f70..016c41893b06 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -427,6 +427,7 @@ struct snd_pcm {
 	wait_queue_head_t open_wait;
 	void *private_data;
 	void (*private_free) (struct snd_pcm *pcm);
+	struct device *dev; /* actual hw device this belongs to */
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	struct snd_pcm_oss oss;
 #endif

commit f23f6e08c47acbdd20e9c49a79da8c404ea168e1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 20 15:17:02 2006 -0400

    [PATCH] severing poll.h -> mm.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index afaf3e88e086..2f645dfd7f70 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -26,6 +26,7 @@
 #include <sound/asound.h>
 #include <sound/memalloc.h>
 #include <linux/poll.h>
+#include <linux/mm.h>
 #include <linux/bitops.h>
 
 #define snd_pcm_substream_chip(substream) ((substream)->private_data)

commit 9442e691e4aec85eba43ac60a3e77c77fd2e73a4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat Sep 30 23:27:19 2006 -0700

    [PATCH] maximum latency tracking: ALSA support
    
    Add maximum latency tracking to the ALSA subsystem for PCM playback.  In
    ALSA, the playback application controls the buffer size and thus indirectly
    the period of latency that it can deal with.  This patch uses 75% of the
    total available latency as threshold to announce to the latency subsystem;
    While 75% is a crude heuristic it's a quite reasonable one; the remaining
    25% can be used for all driver processing for the next samples which is
    also proportional to the size of the buffer.
    
    With ogg123 a latency setting of about 4msec was seen (at 44Khz), while
    with the "play" command a much longer maximum tolerable latency was seen.
    Other, more multimedia oriented players as well as games, will have a lot
    smaller buffers to allow better synchronization and those will actually get
    into the latency domains where there is impact on the power management
    rules.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 60d40b34efc0..afaf3e88e086 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -347,6 +347,7 @@ struct snd_pcm_substream {
 	int number;
 	char name[32];			/* substream name */
 	int stream;			/* stream (direction) */
+	char latency_id[20];		/* latency identifier */
 	size_t buffer_bytes_max;	/* limit ring buffer size */
 	struct snd_dma_buffer dma_buffer;
 	unsigned int dma_buf_id;

commit 548a648b98318e4b843b636dd2c7f42377e19a00
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 31 16:51:51 2006 +0200

    [ALSA] Fix control/status mmap with shared PCM substream
    
    The flag to avoid 32bit-incompatible mmap for control/status records
    should be outside the pcm substream instance since a substream can be
    shared among multiple opens.  Now it's flagged in pcm_file list that
    is directly assigned to file->private_data.
    Also, removed snd_pcm_add_file() and remove_file() functions and
    substream.files field that are not really used in the code.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index f84d84993a31..60d40b34efc0 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -190,7 +190,7 @@ struct snd_pcm_ops {
 
 struct snd_pcm_file {
 	struct snd_pcm_substream *substream;
-	struct snd_pcm_file *next;
+	int no_compat_mmap;
 };
 
 struct snd_pcm_hw_rule;
@@ -384,7 +384,6 @@ struct snd_pcm_substream {
 	struct snd_info_entry *proc_prealloc_entry;
 #endif
 	/* misc flags */
-	unsigned int no_mmap_ctrl: 1;
 	unsigned int hw_opened: 1;
 };
 
@@ -402,7 +401,6 @@ struct snd_pcm_str {
 	/* -- OSS things -- */
 	struct snd_pcm_oss_stream oss;
 #endif
-	struct snd_pcm_file *files;
 #ifdef CONFIG_SND_VERBOSE_PROCFS
 	struct snd_info_entry *proc_root;
 	struct snd_info_entry *proc_info_entry;

commit 9c323fcbc51493f79f9700cb20830d0857c72d99
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Fix mmap_count with O_APPEND opened streams
    
    Move mmap_count to snd_pcm_substream instead of runtime struct
    so that multiplly opened substreams via O_APPEND can be handled
    correctly.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index cebf0310a8dc..f84d84993a31 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -300,7 +300,6 @@ struct snd_pcm_runtime {
 	/* -- mmap -- */
 	volatile struct snd_pcm_mmap_status *status;
 	volatile struct snd_pcm_mmap_control *control;
-	atomic_t mmap_count;
 
 	/* -- locking / scheduling -- */
 	wait_queue_head_t sleep;
@@ -369,6 +368,7 @@ struct snd_pcm_substream {
 	/* -- assigned files -- */
 	void *file;
 	int ref_count;
+	atomic_t mmap_count;
 	unsigned int f_flags;
 	void (*pcm_release)(struct snd_pcm_substream *);
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
@@ -972,13 +972,13 @@ struct page *snd_pcm_sgbuf_ops_page(struct snd_pcm_substream *substream, unsigne
 static inline void snd_pcm_mmap_data_open(struct vm_area_struct *area)
 {
 	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)area->vm_private_data;
-	atomic_inc(&substream->runtime->mmap_count);
+	atomic_inc(&substream->mmap_count);
 }
 
 static inline void snd_pcm_mmap_data_close(struct vm_area_struct *area)
 {
 	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)area->vm_private_data;
-	atomic_dec(&substream->runtime->mmap_count);
+	atomic_dec(&substream->mmap_count);
 }
 
 /* mmap for io-memory area */

commit 0df63e44c3e315ec0fe427ae62558231864108bd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Add O_APPEND flag support to PCM
    
    Added O_APPEND flag support to PCM to enable shared substreams
    among multiple processes.  This mechanism is used by dmix and
    dsnoop plugins.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 998bacefc8f8..cebf0310a8dc 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -368,7 +368,8 @@ struct snd_pcm_substream {
 	struct snd_pcm_group *group;		/* pointer to current group */
 	/* -- assigned files -- */
 	void *file;
-	struct file *ffile;
+	int ref_count;
+	unsigned int f_flags;
 	void (*pcm_release)(struct snd_pcm_substream *);
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	/* -- OSS things -- */
@@ -387,7 +388,7 @@ struct snd_pcm_substream {
 	unsigned int hw_opened: 1;
 };
 
-#define SUBSTREAM_BUSY(substream) ((substream)->file != NULL)
+#define SUBSTREAM_BUSY(substream) ((substream)->ref_count > 0)
 
 
 struct snd_pcm_str {

commit e88e8ae639a4908b903d9406c54e99a729b01a28
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:40 2006 +0200

    [ALSA] Move OSS-specific hw_params helper to snd-pcm-oss module
    
    Move EXPORT_SYMBOL()s to places adjacent to functions/variables.
    Also move OSS-specific hw_params helper functions to pcm_oss.c.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 373425895faa..998bacefc8f8 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -825,14 +825,6 @@ int snd_interval_ratnum(struct snd_interval *i,
 
 void _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params);
 void _snd_pcm_hw_param_setempty(struct snd_pcm_hw_params *params, snd_pcm_hw_param_t var);
-int snd_pcm_hw_param_near(struct snd_pcm_substream *substream, 
-			  struct snd_pcm_hw_params *params,
-			  snd_pcm_hw_param_t var, 
-			  unsigned int val, int *dir);
-int snd_pcm_hw_param_set(struct snd_pcm_substream *pcm,
-			 struct snd_pcm_hw_params *params,
-			 snd_pcm_hw_param_t var,
-			 unsigned int val, int dir);
 int snd_pcm_hw_params_choose(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params);
 
 int snd_pcm_hw_refine(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params);

commit b7d90a356a43f4609bd6290fc2e1ca4ef79d4458
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 25 12:56:04 2006 +0200

    [ALSA] Fix Oops at rmmod with CONFIG_SND_VERBOSE_PROCFS=n
    
    Fixed Oops at rmmod with CONFIG_SND_VERBOSE_PROCFS=n.
    Add ifdef to struct fields for optimization and better compile
    checks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index df70e7592ab5..373425895faa 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -374,12 +374,14 @@ struct snd_pcm_substream {
 	/* -- OSS things -- */
 	struct snd_pcm_oss_substream oss;
 #endif
+#ifdef CONFIG_SND_VERBOSE_PROCFS
 	struct snd_info_entry *proc_root;
 	struct snd_info_entry *proc_info_entry;
 	struct snd_info_entry *proc_hw_params_entry;
 	struct snd_info_entry *proc_sw_params_entry;
 	struct snd_info_entry *proc_status_entry;
 	struct snd_info_entry *proc_prealloc_entry;
+#endif
 	/* misc flags */
 	unsigned int no_mmap_ctrl: 1;
 	unsigned int hw_opened: 1;
@@ -400,12 +402,14 @@ struct snd_pcm_str {
 	struct snd_pcm_oss_stream oss;
 #endif
 	struct snd_pcm_file *files;
+#ifdef CONFIG_SND_VERBOSE_PROCFS
 	struct snd_info_entry *proc_root;
 	struct snd_info_entry *proc_info_entry;
-#ifdef CONFIG_SND_DEBUG
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
 	unsigned int xrun_debug;	/* 0 = disabled, 1 = verbose, 2 = stacktrace */
 	struct snd_info_entry *proc_xrun_debug_entry;
 #endif
+#endif
 };
 
 struct snd_pcm {

commit 12831c15f35dcc9f55fa63d50fd4892c7c6a0a1c
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Apr 11 11:12:46 2006 +0200

    [ALSA] sound/core/pcm.c: make snd_pcm_format_name() static
    
    Modules: PCM Midlevel
    
    This patch makes the needlessly global snd_pcm_format_name() static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index e9ab45556afa..df70e7592ab5 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -898,7 +898,6 @@ ssize_t snd_pcm_format_size(snd_pcm_format_t format, size_t samples);
 const unsigned char *snd_pcm_format_silence_64(snd_pcm_format_t format);
 int snd_pcm_format_set_silence(snd_pcm_format_t format, void *buf, unsigned int frames);
 snd_pcm_format_t snd_pcm_build_linear_format(int width, int unsignd, int big_endian);
-const char *snd_pcm_format_name(snd_pcm_format_t format);
 
 void snd_pcm_set_ops(struct snd_pcm * pcm, int direction, struct snd_pcm_ops *ops);
 void snd_pcm_set_sync(struct snd_pcm_substream *substream);

commit 1576274d30286dd048967176dc8e75e192051ff5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 6 19:47:42 2006 +0200

    [ALSA] Fix Oops of PCM OSS emulation
    
    Modules: PCM Midlevel,ALSA<-OSS emulation
    
    Fix Oops of PCM OSS emulation occuring when multiple playback is used.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 66b1f08b42b9..e9ab45556afa 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -367,7 +367,7 @@ struct snd_pcm_substream {
 	struct snd_pcm_group self_group;	/* fake group for non linked substream (with substream lock inside) */
 	struct snd_pcm_group *group;		/* pointer to current group */
 	/* -- assigned files -- */
-	struct snd_pcm_file *file;
+	void *file;
 	struct file *ffile;
 	void (*pcm_release)(struct snd_pcm_substream *);
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)

commit 3bf75f9b90c981f18f27a0d35a44f488ab68c8ea
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 27 16:40:49 2006 +0200

    [ALSA] Clean up PCM codes (take 2)
    
    - Clean up initialization and destruction of substream instance
      Now snd_pcm_open_substream() alone does most initialization jobs.
      Add pcm_release callback for cleaning up at snd_pcm_release_substream()
    - Tidy up PCM oss code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 7cf6a30c1526..66b1f08b42b9 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -369,6 +369,7 @@ struct snd_pcm_substream {
 	/* -- assigned files -- */
 	struct snd_pcm_file *file;
 	struct file *ffile;
+	void (*pcm_release)(struct snd_pcm_substream *);
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	/* -- OSS things -- */
 	struct snd_pcm_oss_substream oss;
@@ -381,13 +382,10 @@ struct snd_pcm_substream {
 	struct snd_info_entry *proc_prealloc_entry;
 	/* misc flags */
 	unsigned int no_mmap_ctrl: 1;
+	unsigned int hw_opened: 1;
 };
 
-#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
-#define SUBSTREAM_BUSY(substream) ((substream)->file != NULL || ((substream)->oss.file != NULL))
-#else
 #define SUBSTREAM_BUSY(substream) ((substream)->file != NULL)
-#endif
 
 
 struct snd_pcm_str {
@@ -468,8 +466,12 @@ int snd_pcm_suspend(struct snd_pcm_substream *substream);
 int snd_pcm_suspend_all(struct snd_pcm *pcm);
 #endif
 int snd_pcm_kernel_ioctl(struct snd_pcm_substream *substream, unsigned int cmd, void *arg);
-int snd_pcm_open_substream(struct snd_pcm *pcm, int stream, struct snd_pcm_substream **rsubstream);
+int snd_pcm_open_substream(struct snd_pcm *pcm, int stream, struct file *file,
+			   struct snd_pcm_substream **rsubstream);
 void snd_pcm_release_substream(struct snd_pcm_substream *substream);
+int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream, struct file *file,
+			     struct snd_pcm_substream **rsubstream);
+void snd_pcm_detach_substream(struct snd_pcm_substream *substream);
 void snd_pcm_vma_notify_data(void *client, void *data);
 int snd_pcm_mmap_data(struct snd_pcm_substream *substream, struct file *file, struct vm_area_struct *area);
 

commit bf1bbb5a49eec51c30d341606885507b501b37e8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 27 16:22:45 2006 +0200

    [ALSA] Tiny clean up of PCM codes
    
    - Make snd_pcm_prepare() static
    - Clean up snd_pcm_kernel_*_ioctl() functions, reduce exports
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 15b885660bf0..7cf6a30c1526 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -460,7 +460,6 @@ int snd_pcm_info_user(struct snd_pcm_substream *substream,
 		      struct snd_pcm_info __user *info);
 int snd_pcm_status(struct snd_pcm_substream *substream,
 		   struct snd_pcm_status *status);
-int snd_pcm_prepare(struct snd_pcm_substream *substream);
 int snd_pcm_start(struct snd_pcm_substream *substream);
 int snd_pcm_stop(struct snd_pcm_substream *substream, int status);
 int snd_pcm_drain_done(struct snd_pcm_substream *substream);
@@ -468,8 +467,6 @@ int snd_pcm_drain_done(struct snd_pcm_substream *substream);
 int snd_pcm_suspend(struct snd_pcm_substream *substream);
 int snd_pcm_suspend_all(struct snd_pcm *pcm);
 #endif
-int snd_pcm_kernel_playback_ioctl(struct snd_pcm_substream *substream, unsigned int cmd, void *arg);
-int snd_pcm_kernel_capture_ioctl(struct snd_pcm_substream *substream, unsigned int cmd, void *arg);
 int snd_pcm_kernel_ioctl(struct snd_pcm_substream *substream, unsigned int cmd, void *arg);
 int snd_pcm_open_substream(struct snd_pcm *pcm, int stream, struct snd_pcm_substream **rsubstream);
 void snd_pcm_release_substream(struct snd_pcm_substream *substream);

commit 1a60d4c5a0c4028559585a74e48593b16e1ca9b2
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:29:08 2006 +0100

    [ALSA] semaphore -> mutex (core part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 314268a11048..15b885660bf0 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -420,7 +420,7 @@ struct snd_pcm {
 	char id[64];
 	char name[80];
 	struct snd_pcm_str streams[2];
-	struct semaphore open_mutex;
+	struct mutex open_mutex;
 	wait_queue_head_t open_wait;
 	void *private_data;
 	void (*private_free) (struct snd_pcm *pcm);

commit f87135f56cb266e031f5ec081dfbde7e43f55e80
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:06:59 2005 +0100

    [ALSA] dynamic minors (3/6): store device-specific object pointers dynamically
    
    Instead of storing the pointers to the device-specific structures in an
    array, put them into the struct snd_minor, and look them up dynamically.
    
    This makes the device type modules independent of the minor number
    encoding.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 5e29b0e0f214..314268a11048 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -412,6 +412,7 @@ struct snd_pcm_str {
 
 struct snd_pcm {
 	struct snd_card *card;
+	struct list_head list;
 	unsigned int device;	/* device number */
 	unsigned int info_flags;
 	unsigned short dev_class;
@@ -439,7 +440,6 @@ struct snd_pcm_notify {
  *  Registering
  */
 
-extern struct snd_pcm *snd_pcm_devices[];
 extern struct file_operations snd_pcm_f_ops[2];
 
 int snd_pcm_new(struct snd_card *card, char *id, int device,

commit 2af677fc884fc6dc79e65c99050ea607ac8bab9b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:03:48 2005 +0100

    [ALSA] dynamic minors (1/6): store device type in struct snd_minor
    
    Instead of a comment string, store the device type in the snd_minor
    structure.  This makes snd_minor more flexible, and has the nice side
    effect that we don't need anymore to create a separate snd_minor
    template for registering a device but can pass the file_operations
    directly to snd_register_device().
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 7e77c0add80a..5e29b0e0f214 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -402,7 +402,6 @@ struct snd_pcm_str {
 	struct snd_pcm_oss_stream oss;
 #endif
 	struct snd_pcm_file *files;
-	struct snd_minor *reg;
 	struct snd_info_entry *proc_root;
 	struct snd_info_entry *proc_info_entry;
 #ifdef CONFIG_SND_DEBUG
@@ -441,7 +440,7 @@ struct snd_pcm_notify {
  */
 
 extern struct snd_pcm *snd_pcm_devices[];
-extern struct snd_minor snd_pcm_reg[2];
+extern struct file_operations snd_pcm_f_ops[2];
 
 int snd_pcm_new(struct snd_card *card, char *id, int device,
 		int playback_count, int capture_count,

commit 877211f5e1b1196179ba1290e8e1a3dc00427c55
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 13:59:38 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCM
    
    Modules: PCM Midlevel
    
    Remove xxx_t typedefs from the core PCM codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index acc4fa9d5abe..7e77c0add80a 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -28,36 +28,9 @@
 #include <linux/poll.h>
 #include <linux/bitops.h>
 
-typedef sndrv_pcm_uframes_t snd_pcm_uframes_t;
-typedef sndrv_pcm_sframes_t snd_pcm_sframes_t;
-typedef enum sndrv_pcm_class snd_pcm_class_t;
-typedef enum sndrv_pcm_subclass snd_pcm_subclass_t;
-typedef enum sndrv_pcm_stream snd_pcm_stream_t;
-typedef enum sndrv_pcm_access snd_pcm_access_t;
-typedef enum sndrv_pcm_format snd_pcm_format_t;
-typedef enum sndrv_pcm_subformat snd_pcm_subformat_t;
-typedef enum sndrv_pcm_state snd_pcm_state_t;
-typedef union sndrv_pcm_sync_id snd_pcm_sync_id_t;
-typedef struct sndrv_pcm_info snd_pcm_info_t;
-typedef enum sndrv_pcm_hw_param snd_pcm_hw_param_t;
-typedef struct sndrv_pcm_hw_params snd_pcm_hw_params_t;
-typedef enum sndrv_pcm_start snd_pcm_start_t;
-typedef enum sndrv_pcm_xrun snd_pcm_xrun_t;
-typedef enum sndrv_pcm_tstamp snd_pcm_tstamp_t;
-typedef struct sndrv_pcm_sw_params snd_pcm_sw_params_t;
-typedef struct sndrv_pcm_channel_info snd_pcm_channel_info_t;
-typedef struct sndrv_pcm_status snd_pcm_status_t;
-typedef struct sndrv_pcm_mmap_status snd_pcm_mmap_status_t;
-typedef struct sndrv_pcm_mmap_control snd_pcm_mmap_control_t;
-typedef struct sndrv_mask snd_mask_t;
-typedef struct snd_sg_buf snd_pcm_sgbuf_t;
-
 #define snd_pcm_substream_chip(substream) ((substream)->private_data)
 #define snd_pcm_chip(pcm) ((pcm)->private_data)
 
-typedef struct _snd_pcm_file snd_pcm_file_t;
-typedef struct _snd_pcm_runtime snd_pcm_runtime_t;
-
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 #include "pcm_oss.h"
 #endif
@@ -66,7 +39,7 @@ typedef struct _snd_pcm_runtime snd_pcm_runtime_t;
  *  Hardware (lowlevel) section
  */
 
-typedef struct _snd_pcm_hardware {
+struct snd_pcm_hardware {
 	unsigned int info;		/* SNDRV_PCM_INFO_* */
 	u64 formats;			/* SNDRV_PCM_FMTBIT_* */
 	unsigned int rates;		/* SNDRV_PCM_RATE_* */
@@ -80,26 +53,29 @@ typedef struct _snd_pcm_hardware {
 	unsigned int periods_min;	/* min # of periods */
 	unsigned int periods_max;	/* max # of periods */
 	size_t fifo_size;		/* fifo size in bytes */
-} snd_pcm_hardware_t;
+};
 
-typedef struct _snd_pcm_ops {
-	int (*open)(snd_pcm_substream_t *substream);
-	int (*close)(snd_pcm_substream_t *substream);
-	int (*ioctl)(snd_pcm_substream_t * substream,
+struct snd_pcm_ops {
+	int (*open)(struct snd_pcm_substream *substream);
+	int (*close)(struct snd_pcm_substream *substream);
+	int (*ioctl)(struct snd_pcm_substream * substream,
 		     unsigned int cmd, void *arg);
-	int (*hw_params)(snd_pcm_substream_t * substream, snd_pcm_hw_params_t * params);
-	int (*hw_free)(snd_pcm_substream_t *substream);
-	int (*prepare)(snd_pcm_substream_t * substream);
-	int (*trigger)(snd_pcm_substream_t * substream, int cmd);
-	snd_pcm_uframes_t (*pointer)(snd_pcm_substream_t * substream);
-	int (*copy)(snd_pcm_substream_t *substream, int channel, snd_pcm_uframes_t pos,
+	int (*hw_params)(struct snd_pcm_substream *substream,
+			 struct snd_pcm_hw_params *params);
+	int (*hw_free)(struct snd_pcm_substream *substream);
+	int (*prepare)(struct snd_pcm_substream *substream);
+	int (*trigger)(struct snd_pcm_substream *substream, int cmd);
+	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream);
+	int (*copy)(struct snd_pcm_substream *substream, int channel,
+		    snd_pcm_uframes_t pos,
 		    void __user *buf, snd_pcm_uframes_t count);
-	int (*silence)(snd_pcm_substream_t *substream, int channel, 
+	int (*silence)(struct snd_pcm_substream *substream, int channel, 
 		       snd_pcm_uframes_t pos, snd_pcm_uframes_t count);
-	struct page *(*page)(snd_pcm_substream_t *substream, unsigned long offset);
-	int (*mmap)(snd_pcm_substream_t *substream, struct vm_area_struct *vma);
-	int (*ack)(snd_pcm_substream_t *substream);
-} snd_pcm_ops_t;
+	struct page *(*page)(struct snd_pcm_substream *substream,
+			     unsigned long offset);
+	int (*mmap)(struct snd_pcm_substream *substream, struct vm_area_struct *vma);
+	int (*ack)(struct snd_pcm_substream *substream);
+};
 
 /*
  *
@@ -212,17 +188,16 @@ typedef struct _snd_pcm_ops {
 #define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_BE
 #endif
 
-struct _snd_pcm_file {
-	snd_pcm_substream_t * substream;
-	struct _snd_pcm_file * next;
+struct snd_pcm_file {
+	struct snd_pcm_substream *substream;
+	struct snd_pcm_file *next;
 };
 
-typedef struct _snd_pcm_hw_rule snd_pcm_hw_rule_t;
+struct snd_pcm_hw_rule;
+typedef int (*snd_pcm_hw_rule_func_t)(struct snd_pcm_hw_params *params,
+				      struct snd_pcm_hw_rule *rule);
 
-typedef int (*snd_pcm_hw_rule_func_t)(snd_pcm_hw_params_t *params,
-				      snd_pcm_hw_rule_t *rule);
-
-struct _snd_pcm_hw_rule {
+struct snd_pcm_hw_rule {
 	unsigned int cond;
 	snd_pcm_hw_rule_func_t func;
 	int var;
@@ -230,57 +205,57 @@ struct _snd_pcm_hw_rule {
 	void *private;
 };
 
-typedef struct _snd_pcm_hw_constraints {
-	snd_mask_t masks[SNDRV_PCM_HW_PARAM_LAST_MASK - 
+struct snd_pcm_hw_constraints {
+	struct snd_mask masks[SNDRV_PCM_HW_PARAM_LAST_MASK - 
 			 SNDRV_PCM_HW_PARAM_FIRST_MASK + 1];
-	snd_interval_t intervals[SNDRV_PCM_HW_PARAM_LAST_INTERVAL -
+	struct snd_interval intervals[SNDRV_PCM_HW_PARAM_LAST_INTERVAL -
 			     SNDRV_PCM_HW_PARAM_FIRST_INTERVAL + 1];
 	unsigned int rules_num;
 	unsigned int rules_all;
-	snd_pcm_hw_rule_t *rules;
-} snd_pcm_hw_constraints_t;
+	struct snd_pcm_hw_rule *rules;
+};
 
-static inline snd_mask_t *constrs_mask(snd_pcm_hw_constraints_t *constrs,
-				       snd_pcm_hw_param_t var)
+static inline struct snd_mask *constrs_mask(struct snd_pcm_hw_constraints *constrs,
+					    snd_pcm_hw_param_t var)
 {
 	return &constrs->masks[var - SNDRV_PCM_HW_PARAM_FIRST_MASK];
 }
 
-static inline snd_interval_t *constrs_interval(snd_pcm_hw_constraints_t *constrs,
-					  snd_pcm_hw_param_t var)
+static inline struct snd_interval *constrs_interval(struct snd_pcm_hw_constraints *constrs,
+						    snd_pcm_hw_param_t var)
 {
 	return &constrs->intervals[var - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL];
 }
 
-typedef struct {
+struct snd_ratnum {
 	unsigned int num;
 	unsigned int den_min, den_max, den_step;
-} ratnum_t;
+};
 
-typedef struct {
+struct snd_ratden {
 	unsigned int num_min, num_max, num_step;
 	unsigned int den;
-} ratden_t;
+};
 
-typedef struct {
+struct snd_pcm_hw_constraint_ratnums {
 	int nrats;
-	ratnum_t *rats;
-} snd_pcm_hw_constraint_ratnums_t;
+	struct snd_ratnum *rats;
+};
 
-typedef struct {
+struct snd_pcm_hw_constraint_ratdens {
 	int nrats;
-	ratden_t *rats;
-} snd_pcm_hw_constraint_ratdens_t;
+	struct snd_ratden *rats;
+};
 
-typedef struct {
+struct snd_pcm_hw_constraint_list {
 	unsigned int count;
 	unsigned int *list;
 	unsigned int mask;
-} snd_pcm_hw_constraint_list_t;
+};
 
-struct _snd_pcm_runtime {
+struct snd_pcm_runtime {
 	/* -- Status -- */
-	snd_pcm_substream_t *trigger_master;
+	struct snd_pcm_substream *trigger_master;
 	struct timespec trigger_tstamp;	/* trigger timestamp */
 	int overrange;
 	snd_pcm_uframes_t avail_max;
@@ -306,7 +281,7 @@ struct _snd_pcm_runtime {
 	unsigned int rate_den;
 
 	/* -- SW params -- */
-	snd_pcm_tstamp_t tstamp_mode;	/* mmap timestamp is updated */
+	int tstamp_mode;		/* mmap timestamp is updated */
   	unsigned int period_step;
 	unsigned int sleep_min;		/* min ticks to sleep */
 	snd_pcm_uframes_t xfer_align;	/* xfer size need to be a multiple */
@@ -320,11 +295,11 @@ struct _snd_pcm_runtime {
 	snd_pcm_uframes_t silence_start; /* starting pointer to silence area */
 	snd_pcm_uframes_t silence_filled; /* size filled with silence */
 
-	snd_pcm_sync_id_t sync;		/* hardware synchronization ID */
+	union snd_pcm_sync_id sync;	/* hardware synchronization ID */
 
 	/* -- mmap -- */
-	volatile snd_pcm_mmap_status_t *status;
-	volatile snd_pcm_mmap_control_t *control;
+	volatile struct snd_pcm_mmap_status *status;
+	volatile struct snd_pcm_mmap_control *control;
 	atomic_t mmap_count;
 
 	/* -- locking / scheduling -- */
@@ -334,15 +309,15 @@ struct _snd_pcm_runtime {
 
 	/* -- private section -- */
 	void *private_data;
-	void (*private_free)(snd_pcm_runtime_t *runtime);
+	void (*private_free)(struct snd_pcm_runtime *runtime);
 
 	/* -- hardware description -- */
-	snd_pcm_hardware_t hw;
-	snd_pcm_hw_constraints_t hw_constraints;
+	struct snd_pcm_hardware hw;
+	struct snd_pcm_hw_constraints hw_constraints;
 
 	/* -- interrupt callbacks -- */
-	void (*transfer_ack_begin)(snd_pcm_substream_t *substream);
-	void (*transfer_ack_end)(snd_pcm_substream_t *substream);
+	void (*transfer_ack_begin)(struct snd_pcm_substream *substream);
+	void (*transfer_ack_end)(struct snd_pcm_substream *substream);
 
 	/* -- timer -- */
 	unsigned int timer_resolution;	/* timer resolution */
@@ -356,19 +331,19 @@ struct _snd_pcm_runtime {
 
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	/* -- OSS things -- */
-	snd_pcm_oss_runtime_t oss;
+	struct snd_pcm_oss_runtime oss;
 #endif
 };
 
-typedef struct _snd_pcm_group {		/* keep linked substreams */
+struct snd_pcm_group {		/* keep linked substreams */
 	spinlock_t lock;
 	struct list_head substreams;
 	int count;
-} snd_pcm_group_t;
+};
 
-struct _snd_pcm_substream {
-	snd_pcm_t *pcm;
-	snd_pcm_str_t *pstr;
+struct snd_pcm_substream {
+	struct snd_pcm *pcm;
+	struct snd_pcm_str *pstr;
 	void *private_data;		/* copied from pcm->private_data */
 	int number;
 	char name[32];			/* substream name */
@@ -378,32 +353,32 @@ struct _snd_pcm_substream {
 	unsigned int dma_buf_id;
 	size_t dma_max;
 	/* -- hardware operations -- */
-	snd_pcm_ops_t *ops;
+	struct snd_pcm_ops *ops;
 	/* -- runtime information -- */
-	snd_pcm_runtime_t *runtime;
+	struct snd_pcm_runtime *runtime;
         /* -- timer section -- */
-	snd_timer_t *timer;		/* timer */
+	struct snd_timer *timer;		/* timer */
 	unsigned timer_running: 1;	/* time is running */
 	spinlock_t timer_lock;
 	/* -- next substream -- */
-	snd_pcm_substream_t *next;
+	struct snd_pcm_substream *next;
 	/* -- linked substreams -- */
 	struct list_head link_list;	/* linked list member */
-	snd_pcm_group_t self_group;	/* fake group for non linked substream (with substream lock inside) */
-	snd_pcm_group_t *group;		/* pointer to current group */
+	struct snd_pcm_group self_group;	/* fake group for non linked substream (with substream lock inside) */
+	struct snd_pcm_group *group;		/* pointer to current group */
 	/* -- assigned files -- */
-	snd_pcm_file_t *file;
+	struct snd_pcm_file *file;
 	struct file *ffile;
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	/* -- OSS things -- */
-	snd_pcm_oss_substream_t oss;
+	struct snd_pcm_oss_substream oss;
 #endif
-	snd_info_entry_t *proc_root;
-	snd_info_entry_t *proc_info_entry;
-	snd_info_entry_t *proc_hw_params_entry;
-	snd_info_entry_t *proc_sw_params_entry;
-	snd_info_entry_t *proc_status_entry;
-	snd_info_entry_t *proc_prealloc_entry;
+	struct snd_info_entry *proc_root;
+	struct snd_info_entry *proc_info_entry;
+	struct snd_info_entry *proc_hw_params_entry;
+	struct snd_info_entry *proc_sw_params_entry;
+	struct snd_info_entry *proc_status_entry;
+	struct snd_info_entry *proc_prealloc_entry;
 	/* misc flags */
 	unsigned int no_mmap_ctrl: 1;
 };
@@ -415,65 +390,65 @@ struct _snd_pcm_substream {
 #endif
 
 
-struct _snd_pcm_str {
+struct snd_pcm_str {
 	int stream;				/* stream (direction) */
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	/* -- substreams -- */
 	unsigned int substream_count;
 	unsigned int substream_opened;
-	snd_pcm_substream_t *substream;
+	struct snd_pcm_substream *substream;
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	/* -- OSS things -- */
-	snd_pcm_oss_stream_t oss;
+	struct snd_pcm_oss_stream oss;
 #endif
-	snd_pcm_file_t *files;
-	snd_minor_t *reg;
-	snd_info_entry_t *proc_root;
-	snd_info_entry_t *proc_info_entry;
+	struct snd_pcm_file *files;
+	struct snd_minor *reg;
+	struct snd_info_entry *proc_root;
+	struct snd_info_entry *proc_info_entry;
 #ifdef CONFIG_SND_DEBUG
 	unsigned int xrun_debug;	/* 0 = disabled, 1 = verbose, 2 = stacktrace */
-	snd_info_entry_t *proc_xrun_debug_entry;
+	struct snd_info_entry *proc_xrun_debug_entry;
 #endif
 };
 
-struct _snd_pcm {
-	snd_card_t *card;
+struct snd_pcm {
+	struct snd_card *card;
 	unsigned int device;	/* device number */
 	unsigned int info_flags;
 	unsigned short dev_class;
 	unsigned short dev_subclass;
 	char id[64];
 	char name[80];
-	snd_pcm_str_t streams[2];
+	struct snd_pcm_str streams[2];
 	struct semaphore open_mutex;
 	wait_queue_head_t open_wait;
 	void *private_data;
-	void (*private_free) (snd_pcm_t *pcm);
+	void (*private_free) (struct snd_pcm *pcm);
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
-	snd_pcm_oss_t oss;
+	struct snd_pcm_oss oss;
 #endif
 };
 
-typedef struct _snd_pcm_notify {
-	int (*n_register) (snd_pcm_t * pcm);
-	int (*n_disconnect) (snd_pcm_t * pcm);
-	int (*n_unregister) (snd_pcm_t * pcm);
+struct snd_pcm_notify {
+	int (*n_register) (struct snd_pcm * pcm);
+	int (*n_disconnect) (struct snd_pcm * pcm);
+	int (*n_unregister) (struct snd_pcm * pcm);
 	struct list_head list;
-} snd_pcm_notify_t;
+};
 
 /*
  *  Registering
  */
 
-extern snd_pcm_t *snd_pcm_devices[];
-extern snd_minor_t snd_pcm_reg[2];
+extern struct snd_pcm *snd_pcm_devices[];
+extern struct snd_minor snd_pcm_reg[2];
 
-int snd_pcm_new(snd_card_t * card, char *id, int device,
+int snd_pcm_new(struct snd_card *card, char *id, int device,
 		int playback_count, int capture_count,
-		snd_pcm_t **rpcm);
-int snd_pcm_new_stream(snd_pcm_t *pcm, int stream, int substream_count);
+		struct snd_pcm **rpcm);
+int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count);
 
-int snd_pcm_notify(snd_pcm_notify_t *notify, int nfree);
+int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree);
 
 /*
  *  Native I/O
@@ -481,24 +456,26 @@ int snd_pcm_notify(snd_pcm_notify_t *notify, int nfree);
 
 extern rwlock_t snd_pcm_link_rwlock;
 
-int snd_pcm_info(snd_pcm_substream_t * substream, snd_pcm_info_t *info);
-int snd_pcm_info_user(snd_pcm_substream_t * substream, snd_pcm_info_t __user *info);
-int snd_pcm_status(snd_pcm_substream_t * substream, snd_pcm_status_t *status);
-int snd_pcm_prepare(snd_pcm_substream_t *substream);
-int snd_pcm_start(snd_pcm_substream_t *substream);
-int snd_pcm_stop(snd_pcm_substream_t *substream, int status);
-int snd_pcm_drain_done(snd_pcm_substream_t *substream);
+int snd_pcm_info(struct snd_pcm_substream *substream, struct snd_pcm_info *info);
+int snd_pcm_info_user(struct snd_pcm_substream *substream,
+		      struct snd_pcm_info __user *info);
+int snd_pcm_status(struct snd_pcm_substream *substream,
+		   struct snd_pcm_status *status);
+int snd_pcm_prepare(struct snd_pcm_substream *substream);
+int snd_pcm_start(struct snd_pcm_substream *substream);
+int snd_pcm_stop(struct snd_pcm_substream *substream, int status);
+int snd_pcm_drain_done(struct snd_pcm_substream *substream);
 #ifdef CONFIG_PM
-int snd_pcm_suspend(snd_pcm_substream_t *substream);
-int snd_pcm_suspend_all(snd_pcm_t *pcm);
+int snd_pcm_suspend(struct snd_pcm_substream *substream);
+int snd_pcm_suspend_all(struct snd_pcm *pcm);
 #endif
-int snd_pcm_kernel_playback_ioctl(snd_pcm_substream_t *substream, unsigned int cmd, void *arg);
-int snd_pcm_kernel_capture_ioctl(snd_pcm_substream_t *substream, unsigned int cmd, void *arg);
-int snd_pcm_kernel_ioctl(snd_pcm_substream_t *substream, unsigned int cmd, void *arg);
-int snd_pcm_open_substream(snd_pcm_t *pcm, int stream, snd_pcm_substream_t **rsubstream);
-void snd_pcm_release_substream(snd_pcm_substream_t *substream);
+int snd_pcm_kernel_playback_ioctl(struct snd_pcm_substream *substream, unsigned int cmd, void *arg);
+int snd_pcm_kernel_capture_ioctl(struct snd_pcm_substream *substream, unsigned int cmd, void *arg);
+int snd_pcm_kernel_ioctl(struct snd_pcm_substream *substream, unsigned int cmd, void *arg);
+int snd_pcm_open_substream(struct snd_pcm *pcm, int stream, struct snd_pcm_substream **rsubstream);
+void snd_pcm_release_substream(struct snd_pcm_substream *substream);
 void snd_pcm_vma_notify_data(void *client, void *data);
-int snd_pcm_mmap_data(snd_pcm_substream_t *substream, struct file *file, struct vm_area_struct *area);
+int snd_pcm_mmap_data(struct snd_pcm_substream *substream, struct file *file, struct vm_area_struct *area);
 
 #if BITS_PER_LONG >= 64
 
@@ -578,30 +555,30 @@ static inline void div64_32(u_int64_t *n, u_int32_t div, u_int32_t *rem)
  *  PCM library
  */
 
-static inline int snd_pcm_stream_linked(snd_pcm_substream_t *substream)
+static inline int snd_pcm_stream_linked(struct snd_pcm_substream *substream)
 {
 	return substream->group != &substream->self_group;
 }
 
-static inline void snd_pcm_stream_lock(snd_pcm_substream_t *substream)
+static inline void snd_pcm_stream_lock(struct snd_pcm_substream *substream)
 {
 	read_lock(&snd_pcm_link_rwlock);
 	spin_lock(&substream->self_group.lock);
 }
 
-static inline void snd_pcm_stream_unlock(snd_pcm_substream_t *substream)
+static inline void snd_pcm_stream_unlock(struct snd_pcm_substream *substream)
 {
 	spin_unlock(&substream->self_group.lock);
 	read_unlock(&snd_pcm_link_rwlock);
 }
 
-static inline void snd_pcm_stream_lock_irq(snd_pcm_substream_t *substream)
+static inline void snd_pcm_stream_lock_irq(struct snd_pcm_substream *substream)
 {
 	read_lock_irq(&snd_pcm_link_rwlock);
 	spin_lock(&substream->self_group.lock);
 }
 
-static inline void snd_pcm_stream_unlock_irq(snd_pcm_substream_t *substream)
+static inline void snd_pcm_stream_unlock_irq(struct snd_pcm_substream *substream)
 {
 	spin_unlock(&substream->self_group.lock);
 	read_unlock_irq(&snd_pcm_link_rwlock);
@@ -623,56 +600,56 @@ do { \
 	list_for_each(pos, &substream->group->substreams)
 
 #define snd_pcm_group_substream_entry(pos) \
-	list_entry(pos, snd_pcm_substream_t, link_list)
+	list_entry(pos, struct snd_pcm_substream, link_list)
 
-static inline int snd_pcm_running(snd_pcm_substream_t *substream)
+static inline int snd_pcm_running(struct snd_pcm_substream *substream)
 {
 	return (substream->runtime->status->state == SNDRV_PCM_STATE_RUNNING ||
 		(substream->runtime->status->state == SNDRV_PCM_STATE_DRAINING &&
 		 substream->stream == SNDRV_PCM_STREAM_PLAYBACK));
 }
 
-static inline ssize_t bytes_to_samples(snd_pcm_runtime_t *runtime, ssize_t size)
+static inline ssize_t bytes_to_samples(struct snd_pcm_runtime *runtime, ssize_t size)
 {
 	return size * 8 / runtime->sample_bits;
 }
 
-static inline snd_pcm_sframes_t bytes_to_frames(snd_pcm_runtime_t *runtime, ssize_t size)
+static inline snd_pcm_sframes_t bytes_to_frames(struct snd_pcm_runtime *runtime, ssize_t size)
 {
 	return size * 8 / runtime->frame_bits;
 }
 
-static inline ssize_t samples_to_bytes(snd_pcm_runtime_t *runtime, ssize_t size)
+static inline ssize_t samples_to_bytes(struct snd_pcm_runtime *runtime, ssize_t size)
 {
 	return size * runtime->sample_bits / 8;
 }
 
-static inline ssize_t frames_to_bytes(snd_pcm_runtime_t *runtime, snd_pcm_sframes_t size)
+static inline ssize_t frames_to_bytes(struct snd_pcm_runtime *runtime, snd_pcm_sframes_t size)
 {
 	return size * runtime->frame_bits / 8;
 }
 
-static inline int frame_aligned(snd_pcm_runtime_t *runtime, ssize_t bytes)
+static inline int frame_aligned(struct snd_pcm_runtime *runtime, ssize_t bytes)
 {
 	return bytes % runtime->byte_align == 0;
 }
 
-static inline size_t snd_pcm_lib_buffer_bytes(snd_pcm_substream_t *substream)
+static inline size_t snd_pcm_lib_buffer_bytes(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	return frames_to_bytes(runtime, runtime->buffer_size);
 }
 
-static inline size_t snd_pcm_lib_period_bytes(snd_pcm_substream_t *substream)
+static inline size_t snd_pcm_lib_period_bytes(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	return frames_to_bytes(runtime, runtime->period_size);
 }
 
 /*
  *  result is: 0 ... (boundary - 1)
  */
-static inline snd_pcm_uframes_t snd_pcm_playback_avail(snd_pcm_runtime_t *runtime)
+static inline snd_pcm_uframes_t snd_pcm_playback_avail(struct snd_pcm_runtime *runtime)
 {
 	snd_pcm_sframes_t avail = runtime->status->hw_ptr + runtime->buffer_size - runtime->control->appl_ptr;
 	if (avail < 0)
@@ -685,7 +662,7 @@ static inline snd_pcm_uframes_t snd_pcm_playback_avail(snd_pcm_runtime_t *runtim
 /*
  *  result is: 0 ... (boundary - 1)
  */
-static inline snd_pcm_uframes_t snd_pcm_capture_avail(snd_pcm_runtime_t *runtime)
+static inline snd_pcm_uframes_t snd_pcm_capture_avail(struct snd_pcm_runtime *runtime)
 {
 	snd_pcm_sframes_t avail = runtime->status->hw_ptr - runtime->control->appl_ptr;
 	if (avail < 0)
@@ -693,12 +670,12 @@ static inline snd_pcm_uframes_t snd_pcm_capture_avail(snd_pcm_runtime_t *runtime
 	return avail;
 }
 
-static inline snd_pcm_sframes_t snd_pcm_playback_hw_avail(snd_pcm_runtime_t *runtime)
+static inline snd_pcm_sframes_t snd_pcm_playback_hw_avail(struct snd_pcm_runtime *runtime)
 {
 	return runtime->buffer_size - snd_pcm_playback_avail(runtime);
 }
 
-static inline snd_pcm_sframes_t snd_pcm_capture_hw_avail(snd_pcm_runtime_t *runtime)
+static inline snd_pcm_sframes_t snd_pcm_capture_hw_avail(struct snd_pcm_runtime *runtime)
 {
 	return runtime->buffer_size - snd_pcm_capture_avail(runtime);
 }
@@ -711,9 +688,9 @@ static inline snd_pcm_sframes_t snd_pcm_capture_hw_avail(snd_pcm_runtime_t *runt
  *
  * Returns non-zero if available, or zero if not.
  */
-static inline int snd_pcm_playback_ready(snd_pcm_substream_t *substream)
+static inline int snd_pcm_playback_ready(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	return snd_pcm_playback_avail(runtime) >= runtime->control->avail_min;
 }
 
@@ -725,9 +702,9 @@ static inline int snd_pcm_playback_ready(snd_pcm_substream_t *substream)
  *
  * Returns non-zero if available, or zero if not.
  */
-static inline int snd_pcm_capture_ready(snd_pcm_substream_t *substream)
+static inline int snd_pcm_capture_ready(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	return snd_pcm_capture_avail(runtime) >= runtime->control->avail_min;
 }
 
@@ -740,9 +717,9 @@ static inline int snd_pcm_capture_ready(snd_pcm_substream_t *substream)
  *
  * Returns non-zero if exists, or zero if not.
  */
-static inline int snd_pcm_playback_data(snd_pcm_substream_t *substream)
+static inline int snd_pcm_playback_data(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	
 	if (runtime->stop_threshold >= runtime->boundary)
 		return 1;
@@ -757,9 +734,9 @@ static inline int snd_pcm_playback_data(snd_pcm_substream_t *substream)
  *
  * Returns non-zero if empty, or zero if not.
  */
-static inline int snd_pcm_playback_empty(snd_pcm_substream_t *substream)
+static inline int snd_pcm_playback_empty(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	return snd_pcm_playback_avail(runtime) >= runtime->buffer_size;
 }
 
@@ -771,14 +748,14 @@ static inline int snd_pcm_playback_empty(snd_pcm_substream_t *substream)
  *
  * Returns non-zero if empty, or zero if not.
  */
-static inline int snd_pcm_capture_empty(snd_pcm_substream_t *substream)
+static inline int snd_pcm_capture_empty(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	return snd_pcm_capture_avail(runtime) == 0;
 }
 
-static inline void snd_pcm_trigger_done(snd_pcm_substream_t *substream, 
-					snd_pcm_substream_t *master)
+static inline void snd_pcm_trigger_done(struct snd_pcm_substream *substream, 
+					struct snd_pcm_substream *master)
 {
 	substream->runtime->trigger_master = master;
 }
@@ -795,28 +772,28 @@ static inline int hw_is_interval(int var)
 		var <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL;
 }
 
-static inline snd_mask_t *hw_param_mask(snd_pcm_hw_params_t *params,
+static inline struct snd_mask *hw_param_mask(struct snd_pcm_hw_params *params,
 				     snd_pcm_hw_param_t var)
 {
 	return &params->masks[var - SNDRV_PCM_HW_PARAM_FIRST_MASK];
 }
 
-static inline snd_interval_t *hw_param_interval(snd_pcm_hw_params_t *params,
+static inline struct snd_interval *hw_param_interval(struct snd_pcm_hw_params *params,
 					     snd_pcm_hw_param_t var)
 {
 	return &params->intervals[var - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL];
 }
 
-static inline const snd_mask_t *hw_param_mask_c(const snd_pcm_hw_params_t *params,
+static inline const struct snd_mask *hw_param_mask_c(const struct snd_pcm_hw_params *params,
 					     snd_pcm_hw_param_t var)
 {
-	return (const snd_mask_t *)hw_param_mask((snd_pcm_hw_params_t*) params, var);
+	return (const struct snd_mask *)hw_param_mask((struct snd_pcm_hw_params*) params, var);
 }
 
-static inline const snd_interval_t *hw_param_interval_c(const snd_pcm_hw_params_t *params,
+static inline const struct snd_interval *hw_param_interval_c(const struct snd_pcm_hw_params *params,
 						     snd_pcm_hw_param_t var)
 {
-	return (const snd_interval_t *)hw_param_interval((snd_pcm_hw_params_t*) params, var);
+	return (const struct snd_interval *)hw_param_interval((struct snd_pcm_hw_params*) params, var);
 }
 
 #define params_access(p) snd_mask_min(hw_param_mask((p), SNDRV_PCM_HW_PARAM_ACCESS))
@@ -832,66 +809,66 @@ static inline const snd_interval_t *hw_param_interval_c(const snd_pcm_hw_params_
 #define params_tick_time(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_TICK_TIME)->min
 
 
-int snd_interval_refine(snd_interval_t *i, const snd_interval_t *v);
-void snd_interval_mul(const snd_interval_t *a, const snd_interval_t *b, snd_interval_t *c);
-void snd_interval_div(const snd_interval_t *a, const snd_interval_t *b, snd_interval_t *c);
-void snd_interval_muldivk(const snd_interval_t *a, const snd_interval_t *b, 
-			  unsigned int k, snd_interval_t *c);
-void snd_interval_mulkdiv(const snd_interval_t *a, unsigned int k,
-			  const snd_interval_t *b, snd_interval_t *c);
-int snd_interval_list(snd_interval_t *i, unsigned int count, unsigned int *list, unsigned int mask);
-int snd_interval_ratnum(snd_interval_t *i,
-			unsigned int rats_count, ratnum_t *rats,
+int snd_interval_refine(struct snd_interval *i, const struct snd_interval *v);
+void snd_interval_mul(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c);
+void snd_interval_div(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c);
+void snd_interval_muldivk(const struct snd_interval *a, const struct snd_interval *b, 
+			  unsigned int k, struct snd_interval *c);
+void snd_interval_mulkdiv(const struct snd_interval *a, unsigned int k,
+			  const struct snd_interval *b, struct snd_interval *c);
+int snd_interval_list(struct snd_interval *i, unsigned int count, unsigned int *list, unsigned int mask);
+int snd_interval_ratnum(struct snd_interval *i,
+			unsigned int rats_count, struct snd_ratnum *rats,
 			unsigned int *nump, unsigned int *denp);
 
-void _snd_pcm_hw_params_any(snd_pcm_hw_params_t *params);
-void _snd_pcm_hw_param_setempty(snd_pcm_hw_params_t *params, snd_pcm_hw_param_t var);
-int snd_pcm_hw_param_near(snd_pcm_substream_t *substream, 
-			  snd_pcm_hw_params_t *params,
+void _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params);
+void _snd_pcm_hw_param_setempty(struct snd_pcm_hw_params *params, snd_pcm_hw_param_t var);
+int snd_pcm_hw_param_near(struct snd_pcm_substream *substream, 
+			  struct snd_pcm_hw_params *params,
 			  snd_pcm_hw_param_t var, 
 			  unsigned int val, int *dir);
-int snd_pcm_hw_param_set(snd_pcm_substream_t *pcm,
-			 snd_pcm_hw_params_t *params,
+int snd_pcm_hw_param_set(struct snd_pcm_substream *pcm,
+			 struct snd_pcm_hw_params *params,
 			 snd_pcm_hw_param_t var,
 			 unsigned int val, int dir);
-int snd_pcm_hw_params_choose(snd_pcm_substream_t *substream, snd_pcm_hw_params_t *params);
+int snd_pcm_hw_params_choose(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params);
 
-int snd_pcm_hw_refine(snd_pcm_substream_t *substream, snd_pcm_hw_params_t *params);
+int snd_pcm_hw_refine(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params);
 
-int snd_pcm_hw_constraints_init(snd_pcm_substream_t *substream);
-int snd_pcm_hw_constraints_complete(snd_pcm_substream_t *substream);
+int snd_pcm_hw_constraints_init(struct snd_pcm_substream *substream);
+int snd_pcm_hw_constraints_complete(struct snd_pcm_substream *substream);
 
-int snd_pcm_hw_constraint_mask(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var,
+int snd_pcm_hw_constraint_mask(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
 			       u_int32_t mask);
-int snd_pcm_hw_constraint_mask64(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var,
+int snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
 				 u_int64_t mask);
-int snd_pcm_hw_constraint_minmax(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var,
+int snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
 				 unsigned int min, unsigned int max);
-int snd_pcm_hw_constraint_integer(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var);
-int snd_pcm_hw_constraint_list(snd_pcm_runtime_t *runtime, 
+int snd_pcm_hw_constraint_integer(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var);
+int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime, 
 			       unsigned int cond,
 			       snd_pcm_hw_param_t var,
-			       snd_pcm_hw_constraint_list_t *l);
-int snd_pcm_hw_constraint_ratnums(snd_pcm_runtime_t *runtime, 
+			       struct snd_pcm_hw_constraint_list *l);
+int snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime, 
 				  unsigned int cond,
 				  snd_pcm_hw_param_t var,
-				  snd_pcm_hw_constraint_ratnums_t *r);
-int snd_pcm_hw_constraint_ratdens(snd_pcm_runtime_t *runtime, 
+				  struct snd_pcm_hw_constraint_ratnums *r);
+int snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime, 
 				  unsigned int cond,
 				  snd_pcm_hw_param_t var,
-				  snd_pcm_hw_constraint_ratdens_t *r);
-int snd_pcm_hw_constraint_msbits(snd_pcm_runtime_t *runtime, 
+				  struct snd_pcm_hw_constraint_ratdens *r);
+int snd_pcm_hw_constraint_msbits(struct snd_pcm_runtime *runtime, 
 				 unsigned int cond,
 				 unsigned int width,
 				 unsigned int msbits);
-int snd_pcm_hw_constraint_step(snd_pcm_runtime_t *runtime,
+int snd_pcm_hw_constraint_step(struct snd_pcm_runtime *runtime,
 			       unsigned int cond,
 			       snd_pcm_hw_param_t var,
 			       unsigned long step);
-int snd_pcm_hw_constraint_pow2(snd_pcm_runtime_t *runtime,
+int snd_pcm_hw_constraint_pow2(struct snd_pcm_runtime *runtime,
 			       unsigned int cond,
 			       snd_pcm_hw_param_t var);
-int snd_pcm_hw_rule_add(snd_pcm_runtime_t *runtime,
+int snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime,
 			unsigned int cond,
 			int var,
 			snd_pcm_hw_rule_func_t func, void *private,
@@ -925,37 +902,37 @@ int snd_pcm_format_set_silence(snd_pcm_format_t format, void *buf, unsigned int
 snd_pcm_format_t snd_pcm_build_linear_format(int width, int unsignd, int big_endian);
 const char *snd_pcm_format_name(snd_pcm_format_t format);
 
-void snd_pcm_set_ops(snd_pcm_t * pcm, int direction, snd_pcm_ops_t *ops);
-void snd_pcm_set_sync(snd_pcm_substream_t * substream);
-int snd_pcm_lib_interleave_len(snd_pcm_substream_t *substream);
-int snd_pcm_lib_ioctl(snd_pcm_substream_t *substream,
+void snd_pcm_set_ops(struct snd_pcm * pcm, int direction, struct snd_pcm_ops *ops);
+void snd_pcm_set_sync(struct snd_pcm_substream *substream);
+int snd_pcm_lib_interleave_len(struct snd_pcm_substream *substream);
+int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,
 		      unsigned int cmd, void *arg);                      
-int snd_pcm_update_hw_ptr(snd_pcm_substream_t *substream);
-int snd_pcm_playback_xrun_check(snd_pcm_substream_t *substream);
-int snd_pcm_capture_xrun_check(snd_pcm_substream_t *substream);
-int snd_pcm_playback_xrun_asap(snd_pcm_substream_t *substream);
-int snd_pcm_capture_xrun_asap(snd_pcm_substream_t *substream);
-void snd_pcm_playback_silence(snd_pcm_substream_t *substream, snd_pcm_uframes_t new_hw_ptr);
-void snd_pcm_tick_prepare(snd_pcm_substream_t *substream);
-void snd_pcm_tick_set(snd_pcm_substream_t *substream, unsigned long ticks);
-void snd_pcm_tick_elapsed(snd_pcm_substream_t *substream);
-void snd_pcm_period_elapsed(snd_pcm_substream_t *substream);
-snd_pcm_sframes_t snd_pcm_lib_write(snd_pcm_substream_t *substream,
+int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream);
+int snd_pcm_playback_xrun_check(struct snd_pcm_substream *substream);
+int snd_pcm_capture_xrun_check(struct snd_pcm_substream *substream);
+int snd_pcm_playback_xrun_asap(struct snd_pcm_substream *substream);
+int snd_pcm_capture_xrun_asap(struct snd_pcm_substream *substream);
+void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_uframes_t new_hw_ptr);
+void snd_pcm_tick_prepare(struct snd_pcm_substream *substream);
+void snd_pcm_tick_set(struct snd_pcm_substream *substream, unsigned long ticks);
+void snd_pcm_tick_elapsed(struct snd_pcm_substream *substream);
+void snd_pcm_period_elapsed(struct snd_pcm_substream *substream);
+snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream,
 				    const void __user *buf,
 				    snd_pcm_uframes_t frames);
-snd_pcm_sframes_t snd_pcm_lib_read(snd_pcm_substream_t *substream,
+snd_pcm_sframes_t snd_pcm_lib_read(struct snd_pcm_substream *substream,
 				   void __user *buf, snd_pcm_uframes_t frames);
-snd_pcm_sframes_t snd_pcm_lib_writev(snd_pcm_substream_t *substream,
+snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,
 				     void __user **bufs, snd_pcm_uframes_t frames);
-snd_pcm_sframes_t snd_pcm_lib_readv(snd_pcm_substream_t *substream,
+snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 				    void __user **bufs, snd_pcm_uframes_t frames);
 
-int snd_pcm_limit_hw_rates(snd_pcm_runtime_t *runtime);
+int snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime);
 
-static inline void snd_pcm_set_runtime_buffer(snd_pcm_substream_t *substream,
+static inline void snd_pcm_set_runtime_buffer(struct snd_pcm_substream *substream,
 					      struct snd_dma_buffer *bufp)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	if (bufp) {
 		runtime->dma_buffer_p = bufp;
 		runtime->dma_area = bufp->area;
@@ -973,47 +950,47 @@ static inline void snd_pcm_set_runtime_buffer(snd_pcm_substream_t *substream,
  *  Timer interface
  */
 
-void snd_pcm_timer_resolution_change(snd_pcm_substream_t *substream);
-void snd_pcm_timer_init(snd_pcm_substream_t * substream);
-void snd_pcm_timer_done(snd_pcm_substream_t * substream);
+void snd_pcm_timer_resolution_change(struct snd_pcm_substream *substream);
+void snd_pcm_timer_init(struct snd_pcm_substream *substream);
+void snd_pcm_timer_done(struct snd_pcm_substream *substream);
 
 /*
  *  Memory
  */
 
-int snd_pcm_lib_preallocate_free(snd_pcm_substream_t *substream);
-int snd_pcm_lib_preallocate_free_for_all(snd_pcm_t *pcm);
-int snd_pcm_lib_preallocate_pages(snd_pcm_substream_t *substream,
+int snd_pcm_lib_preallocate_free(struct snd_pcm_substream *substream);
+int snd_pcm_lib_preallocate_free_for_all(struct snd_pcm *pcm);
+int snd_pcm_lib_preallocate_pages(struct snd_pcm_substream *substream,
 				  int type, struct device *data,
 				  size_t size, size_t max);
-int snd_pcm_lib_preallocate_pages_for_all(snd_pcm_t *pcm,
+int snd_pcm_lib_preallocate_pages_for_all(struct snd_pcm *pcm,
 					  int type, void *data,
 					  size_t size, size_t max);
-int snd_pcm_lib_malloc_pages(snd_pcm_substream_t *substream, size_t size);
-int snd_pcm_lib_free_pages(snd_pcm_substream_t *substream);
+int snd_pcm_lib_malloc_pages(struct snd_pcm_substream *substream, size_t size);
+int snd_pcm_lib_free_pages(struct snd_pcm_substream *substream);
 
 #define snd_pcm_substream_sgbuf(substream) ((substream)->runtime->dma_buffer_p->private_data)
 #define snd_pcm_sgbuf_pages(size) snd_sgbuf_aligned_pages(size)
 #define snd_pcm_sgbuf_get_addr(sgbuf,ofs) snd_sgbuf_get_addr(sgbuf,ofs)
-struct page *snd_pcm_sgbuf_ops_page(snd_pcm_substream_t *substream, unsigned long offset);
+struct page *snd_pcm_sgbuf_ops_page(struct snd_pcm_substream *substream, unsigned long offset);
 
 /* handle mmap counter - PCM mmap callback should handle this counter properly */
 static inline void snd_pcm_mmap_data_open(struct vm_area_struct *area)
 {
-	snd_pcm_substream_t *substream = (snd_pcm_substream_t *)area->vm_private_data;
+	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)area->vm_private_data;
 	atomic_inc(&substream->runtime->mmap_count);
 }
 
 static inline void snd_pcm_mmap_data_close(struct vm_area_struct *area)
 {
-	snd_pcm_substream_t *substream = (snd_pcm_substream_t *)area->vm_private_data;
+	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)area->vm_private_data;
 	atomic_dec(&substream->runtime->mmap_count);
 }
 
 /* mmap for io-memory area */
 #if defined(CONFIG_X86) || defined(CONFIG_PPC) || defined(CONFIG_ALPHA)
 #define SNDRV_PCM_INFO_MMAP_IOMEM	SNDRV_PCM_INFO_MMAP
-int snd_pcm_lib_mmap_iomem(snd_pcm_substream_t *substream, struct vm_area_struct *area);
+int snd_pcm_lib_mmap_iomem(struct snd_pcm_substream *substream, struct vm_area_struct *area);
 #else
 #define SNDRV_PCM_INFO_MMAP_IOMEM	0
 #define snd_pcm_lib_mmap_iomem	NULL

commit 07799e756c76ecd52cb01a812ba48b7d8ac67633
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:49:49 2005 +0200

    [ALSA] Use getnstimeofday()
    
    Modules: Documentation,PCM Midlevel,Timer Midlevel,ALSA Core
    
    Use the standard getnstimeofday() function instead of ALSA's own one.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 2b23a5967071..acc4fa9d5abe 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -281,7 +281,7 @@ typedef struct {
 struct _snd_pcm_runtime {
 	/* -- Status -- */
 	snd_pcm_substream_t *trigger_master;
-	snd_timestamp_t trigger_tstamp;	/* trigger timestamp */
+	struct timespec trigger_tstamp;	/* trigger timestamp */
 	int overrange;
 	snd_pcm_uframes_t avail_max;
 	snd_pcm_uframes_t hw_ptr_base;	/* Position at buffer restart */
@@ -306,7 +306,6 @@ struct _snd_pcm_runtime {
 	unsigned int rate_den;
 
 	/* -- SW params -- */
-	int tstamp_timespec;		/* use timeval (0) or timespec (1) */
 	snd_pcm_tstamp_t tstamp_mode;	/* mmap timestamp is updated */
   	unsigned int period_step;
 	unsigned int sleep_min;		/* min ticks to sleep */

commit 1b44c28dc180f4d0ea109e1fe4339b3403c2d530
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 15:05:33 2005 +0200

    [ALSA] Another fix for DocBook
    
    PCM Midlevel
    Revive snd_pcm_format_cpu_endian() document.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 7a7f7287288c..2b23a5967071 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -903,7 +903,8 @@ int snd_pcm_format_unsigned(snd_pcm_format_t format);
 int snd_pcm_format_linear(snd_pcm_format_t format);
 int snd_pcm_format_little_endian(snd_pcm_format_t format);
 int snd_pcm_format_big_endian(snd_pcm_format_t format);
-/*
+#if 0 /* just for DocBook */
+/**
  * snd_pcm_format_cpu_endian - Check the PCM format is CPU-endian
  * @format: the format to check
  *
@@ -911,6 +912,7 @@ int snd_pcm_format_big_endian(snd_pcm_format_t format);
  * opposite, or a negative error code if endian not specified.
  */
 int snd_pcm_format_cpu_endian(snd_pcm_format_t format);
+#endif /* DocBook */
 #ifdef SNDRV_LITTLE_ENDIAN
 #define snd_pcm_format_cpu_endian(format) snd_pcm_format_little_endian(format)
 #else

commit 8cdfd2519c6c9a1e6057dc5970b2542b35895738
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 7 14:08:11 2005 +0200

    [ALSA] Remove superfluous PCI ID definitions
    
    CS46xx driver,EMU10K1/EMU10K2 driver,PCM Midlevel,Trident driver
    YMFPCI driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,RME32 driver,RME96 driver
    SonicVibes driver,VIA82xx driver,ALI5451 driver,ICE1712 driver
    ICE1724 driver,NM256 driver,RME HDSP driver,RME9652 driver
    Remove superfluous PCI ID definitions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index d6361dab0370..7a7f7287288c 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -910,6 +910,7 @@ int snd_pcm_format_big_endian(snd_pcm_format_t format);
  * Returns 1 if the given PCM format is CPU-endian, 0 if
  * opposite, or a negative error code if endian not specified.
  */
+int snd_pcm_format_cpu_endian(snd_pcm_format_t format);
 #ifdef SNDRV_LITTLE_ENDIAN
 #define snd_pcm_format_cpu_endian(format) snd_pcm_format_little_endian(format)
 #else

commit 9d01a82e46a8dd18233121a6bc140e5576649583
Author: Martin Waitz <tali@admingilde.org>
Date:   Fri Sep 9 13:10:17 2005 -0700

    [PATCH] DocBook: fix kernel-api documentation generation
    
    This patch changes a macro definition so that kernel-doc can understand it.
    
    Signed-off-by: Martin Waitz <tali@admingilde.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 389e8ebe9c19..d6361dab0370 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -910,11 +910,10 @@ int snd_pcm_format_big_endian(snd_pcm_format_t format);
  * Returns 1 if the given PCM format is CPU-endian, 0 if
  * opposite, or a negative error code if endian not specified.
  */
-/* int snd_pcm_format_cpu_endian(snd_pcm_format_t format); */
 #ifdef SNDRV_LITTLE_ENDIAN
-#define snd_pcm_format_cpu_endian	snd_pcm_format_little_endian
+#define snd_pcm_format_cpu_endian(format) snd_pcm_format_little_endian(format)
 #else
-#define snd_pcm_format_cpu_endian	snd_pcm_format_big_endian
+#define snd_pcm_format_cpu_endian(format) snd_pcm_format_big_endian(format)
 #endif
 int snd_pcm_format_width(snd_pcm_format_t format);			/* in bits */
 int snd_pcm_format_physical_width(snd_pcm_format_t format);		/* in bits */

commit 344babaa9d39b10b85cadec4e5335d43b52b4ec0
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Wed Sep 7 01:15:17 2005 -0400

    [kernel-doc] fix various DocBook build problems/warnings
    
    Most serious is fixing include/sound/pcm.h, which breaks the DocBook
    build.
    
    The other stuff is just filling in things that cause warnings.

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index fa23ebfb857a..389e8ebe9c19 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -903,7 +903,7 @@ int snd_pcm_format_unsigned(snd_pcm_format_t format);
 int snd_pcm_format_linear(snd_pcm_format_t format);
 int snd_pcm_format_little_endian(snd_pcm_format_t format);
 int snd_pcm_format_big_endian(snd_pcm_format_t format);
-/**
+/*
  * snd_pcm_format_cpu_endian - Check the PCM format is CPU-endian
  * @format: the format to check
  *

commit 443feb882679e21ba5d1e0ff9eff067ac26d9461
Author: Karsten Wiese <annabellesgarden@yahoo.de>
Date:   Wed Aug 10 11:18:19 2005 +0200

    [ALSA] ALSA's struct _snd_pcm_substream: Obsolete open_flag
    
    PCM Midlevel,ALSA<-OSS emulation,USB USX2Y
    This patch removes open_flag from struct _snd_pcm_substream.
    All of its uses are substituted by querying struct _snd_pcm_substream's
    member ffile instead.
    
    Signed-off-by: Karsten Wiese <annabellesgarden@yahoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index d935417575b5..fa23ebfb857a 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -379,7 +379,6 @@ struct _snd_pcm_substream {
 	unsigned int dma_buf_id;
 	size_t dma_max;
 	/* -- hardware operations -- */
-	unsigned int open_flag: 1;	/* lowlevel device has been opened */
 	snd_pcm_ops_t *ops;
 	/* -- runtime information -- */
 	snd_pcm_runtime_t *runtime;

commit 123992f728785e05f385d23893bd5ec69871aeb4
Author: Adrian Bunk <bunk@stusta.de>
Date:   Wed May 18 18:02:04 2005 +0200

    [ALSA] sound/core/: possible cleanups
    
    PCM Midlevel,ALSA Core,Timer Midlevel,ALSA sequencer,Virtual Midi
    This patch contains the following possible cleanups:
    - make needlessly global code static
    - #if 0 the following unused global functions
    - remove the following unneeded EXPORT_SYMBOL's
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 50a6ee1aeab2..d935417575b5 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -848,23 +848,6 @@ int snd_interval_ratnum(snd_interval_t *i,
 
 void _snd_pcm_hw_params_any(snd_pcm_hw_params_t *params);
 void _snd_pcm_hw_param_setempty(snd_pcm_hw_params_t *params, snd_pcm_hw_param_t var);
-int snd_pcm_hw_param_min(snd_pcm_substream_t *substream, 
-			 snd_pcm_hw_params_t *params,
-			 snd_pcm_hw_param_t var,
-			 unsigned int val, int *dir);
-int snd_pcm_hw_param_max(snd_pcm_substream_t *substream, 
-			 snd_pcm_hw_params_t *params,
-			 snd_pcm_hw_param_t var,
-			 unsigned int val, int *dir);
-int snd_pcm_hw_param_setinteger(snd_pcm_substream_t *substream, 
-				snd_pcm_hw_params_t *params,
-				snd_pcm_hw_param_t var);
-int snd_pcm_hw_param_first(snd_pcm_substream_t *substream, 
-			   snd_pcm_hw_params_t *params,
-			   snd_pcm_hw_param_t var, int *dir);
-int snd_pcm_hw_param_last(snd_pcm_substream_t *substream, 
-			  snd_pcm_hw_params_t *params,
-			  snd_pcm_hw_param_t var, int *dir);
 int snd_pcm_hw_param_near(snd_pcm_substream_t *substream, 
 			  snd_pcm_hw_params_t *params,
 			  snd_pcm_hw_param_t var, 
@@ -876,7 +859,6 @@ int snd_pcm_hw_param_set(snd_pcm_substream_t *pcm,
 int snd_pcm_hw_params_choose(snd_pcm_substream_t *substream, snd_pcm_hw_params_t *params);
 
 int snd_pcm_hw_refine(snd_pcm_substream_t *substream, snd_pcm_hw_params_t *params);
-int snd_pcm_hw_params(snd_pcm_substream_t *substream, snd_pcm_hw_params_t *params);
 
 int snd_pcm_hw_constraints_init(snd_pcm_substream_t *substream);
 int snd_pcm_hw_constraints_complete(snd_pcm_substream_t *substream);

commit 9502dcad6c1138a3ce2bae23ccd4be44c718d2a9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 18 16:25:46 2005 +0200

    [ALSA] Export missing snd_pcm_format_*()
    
    PCM Midlevel
    Export snd_pcm_format_size().  This function is used by some out-of-kernel
    drivers.
    
    Make snd_pcm_format_cpu_endian() macro for optimization.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 53fc04d75bad..50a6ee1aeab2 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -922,8 +922,22 @@ int snd_pcm_format_unsigned(snd_pcm_format_t format);
 int snd_pcm_format_linear(snd_pcm_format_t format);
 int snd_pcm_format_little_endian(snd_pcm_format_t format);
 int snd_pcm_format_big_endian(snd_pcm_format_t format);
+/**
+ * snd_pcm_format_cpu_endian - Check the PCM format is CPU-endian
+ * @format: the format to check
+ *
+ * Returns 1 if the given PCM format is CPU-endian, 0 if
+ * opposite, or a negative error code if endian not specified.
+ */
+/* int snd_pcm_format_cpu_endian(snd_pcm_format_t format); */
+#ifdef SNDRV_LITTLE_ENDIAN
+#define snd_pcm_format_cpu_endian	snd_pcm_format_little_endian
+#else
+#define snd_pcm_format_cpu_endian	snd_pcm_format_big_endian
+#endif
 int snd_pcm_format_width(snd_pcm_format_t format);			/* in bits */
 int snd_pcm_format_physical_width(snd_pcm_format_t format);		/* in bits */
+ssize_t snd_pcm_format_size(snd_pcm_format_t format, size_t samples);
 const unsigned char *snd_pcm_format_silence_64(snd_pcm_format_t format);
 int snd_pcm_format_set_silence(snd_pcm_format_t format, void *buf, unsigned int frames);
 snd_pcm_format_t snd_pcm_build_linear_format(int width, int unsignd, int big_endian);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/sound/pcm.h b/include/sound/pcm.h
new file mode 100644
index 000000000000..53fc04d75bad
--- /dev/null
+++ b/include/sound/pcm.h
@@ -0,0 +1,1040 @@
+#ifndef __SOUND_PCM_H
+#define __SOUND_PCM_H
+
+/*
+ *  Digital Audio (PCM) abstract layer
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *                   Abramo Bagnara <abramo@alsa-project.org>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/asound.h>
+#include <sound/memalloc.h>
+#include <linux/poll.h>
+#include <linux/bitops.h>
+
+typedef sndrv_pcm_uframes_t snd_pcm_uframes_t;
+typedef sndrv_pcm_sframes_t snd_pcm_sframes_t;
+typedef enum sndrv_pcm_class snd_pcm_class_t;
+typedef enum sndrv_pcm_subclass snd_pcm_subclass_t;
+typedef enum sndrv_pcm_stream snd_pcm_stream_t;
+typedef enum sndrv_pcm_access snd_pcm_access_t;
+typedef enum sndrv_pcm_format snd_pcm_format_t;
+typedef enum sndrv_pcm_subformat snd_pcm_subformat_t;
+typedef enum sndrv_pcm_state snd_pcm_state_t;
+typedef union sndrv_pcm_sync_id snd_pcm_sync_id_t;
+typedef struct sndrv_pcm_info snd_pcm_info_t;
+typedef enum sndrv_pcm_hw_param snd_pcm_hw_param_t;
+typedef struct sndrv_pcm_hw_params snd_pcm_hw_params_t;
+typedef enum sndrv_pcm_start snd_pcm_start_t;
+typedef enum sndrv_pcm_xrun snd_pcm_xrun_t;
+typedef enum sndrv_pcm_tstamp snd_pcm_tstamp_t;
+typedef struct sndrv_pcm_sw_params snd_pcm_sw_params_t;
+typedef struct sndrv_pcm_channel_info snd_pcm_channel_info_t;
+typedef struct sndrv_pcm_status snd_pcm_status_t;
+typedef struct sndrv_pcm_mmap_status snd_pcm_mmap_status_t;
+typedef struct sndrv_pcm_mmap_control snd_pcm_mmap_control_t;
+typedef struct sndrv_mask snd_mask_t;
+typedef struct snd_sg_buf snd_pcm_sgbuf_t;
+
+#define snd_pcm_substream_chip(substream) ((substream)->private_data)
+#define snd_pcm_chip(pcm) ((pcm)->private_data)
+
+typedef struct _snd_pcm_file snd_pcm_file_t;
+typedef struct _snd_pcm_runtime snd_pcm_runtime_t;
+
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+#include "pcm_oss.h"
+#endif
+
+/*
+ *  Hardware (lowlevel) section
+ */
+
+typedef struct _snd_pcm_hardware {
+	unsigned int info;		/* SNDRV_PCM_INFO_* */
+	u64 formats;			/* SNDRV_PCM_FMTBIT_* */
+	unsigned int rates;		/* SNDRV_PCM_RATE_* */
+	unsigned int rate_min;		/* min rate */
+	unsigned int rate_max;		/* max rate */
+	unsigned int channels_min;	/* min channels */
+	unsigned int channels_max;	/* max channels */
+	size_t buffer_bytes_max;	/* max buffer size */
+	size_t period_bytes_min;	/* min period size */
+	size_t period_bytes_max;	/* max period size */
+	unsigned int periods_min;	/* min # of periods */
+	unsigned int periods_max;	/* max # of periods */
+	size_t fifo_size;		/* fifo size in bytes */
+} snd_pcm_hardware_t;
+
+typedef struct _snd_pcm_ops {
+	int (*open)(snd_pcm_substream_t *substream);
+	int (*close)(snd_pcm_substream_t *substream);
+	int (*ioctl)(snd_pcm_substream_t * substream,
+		     unsigned int cmd, void *arg);
+	int (*hw_params)(snd_pcm_substream_t * substream, snd_pcm_hw_params_t * params);
+	int (*hw_free)(snd_pcm_substream_t *substream);
+	int (*prepare)(snd_pcm_substream_t * substream);
+	int (*trigger)(snd_pcm_substream_t * substream, int cmd);
+	snd_pcm_uframes_t (*pointer)(snd_pcm_substream_t * substream);
+	int (*copy)(snd_pcm_substream_t *substream, int channel, snd_pcm_uframes_t pos,
+		    void __user *buf, snd_pcm_uframes_t count);
+	int (*silence)(snd_pcm_substream_t *substream, int channel, 
+		       snd_pcm_uframes_t pos, snd_pcm_uframes_t count);
+	struct page *(*page)(snd_pcm_substream_t *substream, unsigned long offset);
+	int (*mmap)(snd_pcm_substream_t *substream, struct vm_area_struct *vma);
+	int (*ack)(snd_pcm_substream_t *substream);
+} snd_pcm_ops_t;
+
+/*
+ *
+ */
+
+#define SNDRV_PCM_DEVICES		8
+
+#define SNDRV_PCM_IOCTL1_FALSE		((void *)0)
+#define SNDRV_PCM_IOCTL1_TRUE		((void *)1)
+
+#define SNDRV_PCM_IOCTL1_RESET		0
+#define SNDRV_PCM_IOCTL1_INFO		1
+#define SNDRV_PCM_IOCTL1_CHANNEL_INFO	2
+#define SNDRV_PCM_IOCTL1_GSTATE		3
+
+#define SNDRV_PCM_TRIGGER_STOP		0
+#define SNDRV_PCM_TRIGGER_START		1
+#define SNDRV_PCM_TRIGGER_PAUSE_PUSH	3
+#define SNDRV_PCM_TRIGGER_PAUSE_RELEASE	4
+#define SNDRV_PCM_TRIGGER_SUSPEND	5
+#define SNDRV_PCM_TRIGGER_RESUME	6
+
+#define SNDRV_PCM_POS_XRUN		((snd_pcm_uframes_t)-1)
+
+/* If you change this don't forget to change rates[] table in pcm_native.c */
+#define SNDRV_PCM_RATE_5512		(1<<0)		/* 5512Hz */
+#define SNDRV_PCM_RATE_8000		(1<<1)		/* 8000Hz */
+#define SNDRV_PCM_RATE_11025		(1<<2)		/* 11025Hz */
+#define SNDRV_PCM_RATE_16000		(1<<3)		/* 16000Hz */
+#define SNDRV_PCM_RATE_22050		(1<<4)		/* 22050Hz */
+#define SNDRV_PCM_RATE_32000		(1<<5)		/* 32000Hz */
+#define SNDRV_PCM_RATE_44100		(1<<6)		/* 44100Hz */
+#define SNDRV_PCM_RATE_48000		(1<<7)		/* 48000Hz */
+#define SNDRV_PCM_RATE_64000		(1<<8)		/* 64000Hz */
+#define SNDRV_PCM_RATE_88200		(1<<9)		/* 88200Hz */
+#define SNDRV_PCM_RATE_96000		(1<<10)		/* 96000Hz */
+#define SNDRV_PCM_RATE_176400		(1<<11)		/* 176400Hz */
+#define SNDRV_PCM_RATE_192000		(1<<12)		/* 192000Hz */
+
+#define SNDRV_PCM_RATE_CONTINUOUS	(1<<30)		/* continuous range */
+#define SNDRV_PCM_RATE_KNOT		(1<<31)		/* supports more non-continuos rates */
+
+#define SNDRV_PCM_RATE_8000_44100	(SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_11025|\
+					 SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_22050|\
+					 SNDRV_PCM_RATE_32000|SNDRV_PCM_RATE_44100)
+#define SNDRV_PCM_RATE_8000_48000	(SNDRV_PCM_RATE_8000_44100|SNDRV_PCM_RATE_48000)
+#define SNDRV_PCM_RATE_8000_96000	(SNDRV_PCM_RATE_8000_48000|SNDRV_PCM_RATE_64000|\
+					 SNDRV_PCM_RATE_88200|SNDRV_PCM_RATE_96000)
+#define SNDRV_PCM_RATE_8000_192000	(SNDRV_PCM_RATE_8000_96000|SNDRV_PCM_RATE_176400|\
+					 SNDRV_PCM_RATE_192000)
+#define SNDRV_PCM_FMTBIT_S8		(1ULL << SNDRV_PCM_FORMAT_S8)
+#define SNDRV_PCM_FMTBIT_U8		(1ULL << SNDRV_PCM_FORMAT_U8)
+#define SNDRV_PCM_FMTBIT_S16_LE		(1ULL << SNDRV_PCM_FORMAT_S16_LE)
+#define SNDRV_PCM_FMTBIT_S16_BE		(1ULL << SNDRV_PCM_FORMAT_S16_BE)
+#define SNDRV_PCM_FMTBIT_U16_LE		(1ULL << SNDRV_PCM_FORMAT_U16_LE)
+#define SNDRV_PCM_FMTBIT_U16_BE		(1ULL << SNDRV_PCM_FORMAT_U16_BE)
+#define SNDRV_PCM_FMTBIT_S24_LE		(1ULL << SNDRV_PCM_FORMAT_S24_LE)
+#define SNDRV_PCM_FMTBIT_S24_BE		(1ULL << SNDRV_PCM_FORMAT_S24_BE)
+#define SNDRV_PCM_FMTBIT_U24_LE		(1ULL << SNDRV_PCM_FORMAT_U24_LE)
+#define SNDRV_PCM_FMTBIT_U24_BE		(1ULL << SNDRV_PCM_FORMAT_U24_BE)
+#define SNDRV_PCM_FMTBIT_S32_LE		(1ULL << SNDRV_PCM_FORMAT_S32_LE)
+#define SNDRV_PCM_FMTBIT_S32_BE		(1ULL << SNDRV_PCM_FORMAT_S32_BE)
+#define SNDRV_PCM_FMTBIT_U32_LE		(1ULL << SNDRV_PCM_FORMAT_U32_LE)
+#define SNDRV_PCM_FMTBIT_U32_BE		(1ULL << SNDRV_PCM_FORMAT_U32_BE)
+#define SNDRV_PCM_FMTBIT_FLOAT_LE	(1ULL << SNDRV_PCM_FORMAT_FLOAT_LE)
+#define SNDRV_PCM_FMTBIT_FLOAT_BE	(1ULL << SNDRV_PCM_FORMAT_FLOAT_BE)
+#define SNDRV_PCM_FMTBIT_FLOAT64_LE	(1ULL << SNDRV_PCM_FORMAT_FLOAT64_LE)
+#define SNDRV_PCM_FMTBIT_FLOAT64_BE	(1ULL << SNDRV_PCM_FORMAT_FLOAT64_BE)
+#define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE (1ULL << SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE)
+#define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_BE (1ULL << SNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE)
+#define SNDRV_PCM_FMTBIT_MU_LAW		(1ULL << SNDRV_PCM_FORMAT_MU_LAW)
+#define SNDRV_PCM_FMTBIT_A_LAW		(1ULL << SNDRV_PCM_FORMAT_A_LAW)
+#define SNDRV_PCM_FMTBIT_IMA_ADPCM	(1ULL << SNDRV_PCM_FORMAT_IMA_ADPCM)
+#define SNDRV_PCM_FMTBIT_MPEG		(1ULL << SNDRV_PCM_FORMAT_MPEG)
+#define SNDRV_PCM_FMTBIT_GSM		(1ULL << SNDRV_PCM_FORMAT_GSM)
+#define SNDRV_PCM_FMTBIT_SPECIAL	(1ULL << SNDRV_PCM_FORMAT_SPECIAL)
+#define SNDRV_PCM_FMTBIT_S24_3LE	(1ULL << SNDRV_PCM_FORMAT_S24_3LE)
+#define SNDRV_PCM_FMTBIT_U24_3LE	(1ULL << SNDRV_PCM_FORMAT_U24_3LE)
+#define SNDRV_PCM_FMTBIT_S24_3BE	(1ULL << SNDRV_PCM_FORMAT_S24_3BE)
+#define SNDRV_PCM_FMTBIT_U24_3BE	(1ULL << SNDRV_PCM_FORMAT_U24_3BE)
+#define SNDRV_PCM_FMTBIT_S20_3LE	(1ULL << SNDRV_PCM_FORMAT_S20_3LE)
+#define SNDRV_PCM_FMTBIT_U20_3LE	(1ULL << SNDRV_PCM_FORMAT_U20_3LE)
+#define SNDRV_PCM_FMTBIT_S20_3BE	(1ULL << SNDRV_PCM_FORMAT_S20_3BE)
+#define SNDRV_PCM_FMTBIT_U20_3BE	(1ULL << SNDRV_PCM_FORMAT_U20_3BE)
+#define SNDRV_PCM_FMTBIT_S18_3LE	(1ULL << SNDRV_PCM_FORMAT_S18_3LE)
+#define SNDRV_PCM_FMTBIT_U18_3LE	(1ULL << SNDRV_PCM_FORMAT_U18_3LE)
+#define SNDRV_PCM_FMTBIT_S18_3BE	(1ULL << SNDRV_PCM_FORMAT_S18_3BE)
+#define SNDRV_PCM_FMTBIT_U18_3BE	(1ULL << SNDRV_PCM_FORMAT_U18_3BE)
+
+#ifdef SNDRV_LITTLE_ENDIAN
+#define SNDRV_PCM_FMTBIT_S16		SNDRV_PCM_FMTBIT_S16_LE
+#define SNDRV_PCM_FMTBIT_U16		SNDRV_PCM_FMTBIT_U16_LE
+#define SNDRV_PCM_FMTBIT_S24		SNDRV_PCM_FMTBIT_S24_LE
+#define SNDRV_PCM_FMTBIT_U24		SNDRV_PCM_FMTBIT_U24_LE
+#define SNDRV_PCM_FMTBIT_S32		SNDRV_PCM_FMTBIT_S32_LE
+#define SNDRV_PCM_FMTBIT_U32		SNDRV_PCM_FMTBIT_U32_LE
+#define SNDRV_PCM_FMTBIT_FLOAT		SNDRV_PCM_FMTBIT_FLOAT_LE
+#define SNDRV_PCM_FMTBIT_FLOAT64	SNDRV_PCM_FMTBIT_FLOAT64_LE
+#define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE
+#endif
+#ifdef SNDRV_BIG_ENDIAN
+#define SNDRV_PCM_FMTBIT_S16		SNDRV_PCM_FMTBIT_S16_BE
+#define SNDRV_PCM_FMTBIT_U16		SNDRV_PCM_FMTBIT_U16_BE
+#define SNDRV_PCM_FMTBIT_S24		SNDRV_PCM_FMTBIT_S24_BE
+#define SNDRV_PCM_FMTBIT_U24		SNDRV_PCM_FMTBIT_U24_BE
+#define SNDRV_PCM_FMTBIT_S32		SNDRV_PCM_FMTBIT_S32_BE
+#define SNDRV_PCM_FMTBIT_U32		SNDRV_PCM_FMTBIT_U32_BE
+#define SNDRV_PCM_FMTBIT_FLOAT		SNDRV_PCM_FMTBIT_FLOAT_BE
+#define SNDRV_PCM_FMTBIT_FLOAT64	SNDRV_PCM_FMTBIT_FLOAT64_BE
+#define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_BE
+#endif
+
+struct _snd_pcm_file {
+	snd_pcm_substream_t * substream;
+	struct _snd_pcm_file * next;
+};
+
+typedef struct _snd_pcm_hw_rule snd_pcm_hw_rule_t;
+
+typedef int (*snd_pcm_hw_rule_func_t)(snd_pcm_hw_params_t *params,
+				      snd_pcm_hw_rule_t *rule);
+
+struct _snd_pcm_hw_rule {
+	unsigned int cond;
+	snd_pcm_hw_rule_func_t func;
+	int var;
+	int deps[4];
+	void *private;
+};
+
+typedef struct _snd_pcm_hw_constraints {
+	snd_mask_t masks[SNDRV_PCM_HW_PARAM_LAST_MASK - 
+			 SNDRV_PCM_HW_PARAM_FIRST_MASK + 1];
+	snd_interval_t intervals[SNDRV_PCM_HW_PARAM_LAST_INTERVAL -
+			     SNDRV_PCM_HW_PARAM_FIRST_INTERVAL + 1];
+	unsigned int rules_num;
+	unsigned int rules_all;
+	snd_pcm_hw_rule_t *rules;
+} snd_pcm_hw_constraints_t;
+
+static inline snd_mask_t *constrs_mask(snd_pcm_hw_constraints_t *constrs,
+				       snd_pcm_hw_param_t var)
+{
+	return &constrs->masks[var - SNDRV_PCM_HW_PARAM_FIRST_MASK];
+}
+
+static inline snd_interval_t *constrs_interval(snd_pcm_hw_constraints_t *constrs,
+					  snd_pcm_hw_param_t var)
+{
+	return &constrs->intervals[var - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL];
+}
+
+typedef struct {
+	unsigned int num;
+	unsigned int den_min, den_max, den_step;
+} ratnum_t;
+
+typedef struct {
+	unsigned int num_min, num_max, num_step;
+	unsigned int den;
+} ratden_t;
+
+typedef struct {
+	int nrats;
+	ratnum_t *rats;
+} snd_pcm_hw_constraint_ratnums_t;
+
+typedef struct {
+	int nrats;
+	ratden_t *rats;
+} snd_pcm_hw_constraint_ratdens_t;
+
+typedef struct {
+	unsigned int count;
+	unsigned int *list;
+	unsigned int mask;
+} snd_pcm_hw_constraint_list_t;
+
+struct _snd_pcm_runtime {
+	/* -- Status -- */
+	snd_pcm_substream_t *trigger_master;
+	snd_timestamp_t trigger_tstamp;	/* trigger timestamp */
+	int overrange;
+	snd_pcm_uframes_t avail_max;
+	snd_pcm_uframes_t hw_ptr_base;	/* Position at buffer restart */
+	snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time*/
+
+	/* -- HW params -- */
+	snd_pcm_access_t access;	/* access mode */
+	snd_pcm_format_t format;	/* SNDRV_PCM_FORMAT_* */
+	snd_pcm_subformat_t subformat;	/* subformat */
+	unsigned int rate;		/* rate in Hz */
+	unsigned int channels;		/* channels */
+	snd_pcm_uframes_t period_size;	/* period size */
+	unsigned int periods;		/* periods */
+	snd_pcm_uframes_t buffer_size;	/* buffer size */
+	unsigned int tick_time;		/* tick time */
+	snd_pcm_uframes_t min_align;	/* Min alignment for the format */
+	size_t byte_align;
+	unsigned int frame_bits;
+	unsigned int sample_bits;
+	unsigned int info;
+	unsigned int rate_num;
+	unsigned int rate_den;
+
+	/* -- SW params -- */
+	int tstamp_timespec;		/* use timeval (0) or timespec (1) */
+	snd_pcm_tstamp_t tstamp_mode;	/* mmap timestamp is updated */
+  	unsigned int period_step;
+	unsigned int sleep_min;		/* min ticks to sleep */
+	snd_pcm_uframes_t xfer_align;	/* xfer size need to be a multiple */
+	snd_pcm_uframes_t start_threshold;
+	snd_pcm_uframes_t stop_threshold;
+	snd_pcm_uframes_t silence_threshold; /* Silence filling happens when
+						noise is nearest than this */
+	snd_pcm_uframes_t silence_size;	/* Silence filling size */
+	snd_pcm_uframes_t boundary;	/* pointers wrap point */
+
+	snd_pcm_uframes_t silence_start; /* starting pointer to silence area */
+	snd_pcm_uframes_t silence_filled; /* size filled with silence */
+
+	snd_pcm_sync_id_t sync;		/* hardware synchronization ID */
+
+	/* -- mmap -- */
+	volatile snd_pcm_mmap_status_t *status;
+	volatile snd_pcm_mmap_control_t *control;
+	atomic_t mmap_count;
+
+	/* -- locking / scheduling -- */
+	wait_queue_head_t sleep;
+	struct timer_list tick_timer;
+	struct fasync_struct *fasync;
+
+	/* -- private section -- */
+	void *private_data;
+	void (*private_free)(snd_pcm_runtime_t *runtime);
+
+	/* -- hardware description -- */
+	snd_pcm_hardware_t hw;
+	snd_pcm_hw_constraints_t hw_constraints;
+
+	/* -- interrupt callbacks -- */
+	void (*transfer_ack_begin)(snd_pcm_substream_t *substream);
+	void (*transfer_ack_end)(snd_pcm_substream_t *substream);
+
+	/* -- timer -- */
+	unsigned int timer_resolution;	/* timer resolution */
+
+	/* -- DMA -- */           
+	unsigned char *dma_area;	/* DMA area */
+	dma_addr_t dma_addr;		/* physical bus address (not accessible from main CPU) */
+	size_t dma_bytes;		/* size of DMA area */
+
+	struct snd_dma_buffer *dma_buffer_p;	/* allocated buffer */
+
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+	/* -- OSS things -- */
+	snd_pcm_oss_runtime_t oss;
+#endif
+};
+
+typedef struct _snd_pcm_group {		/* keep linked substreams */
+	spinlock_t lock;
+	struct list_head substreams;
+	int count;
+} snd_pcm_group_t;
+
+struct _snd_pcm_substream {
+	snd_pcm_t *pcm;
+	snd_pcm_str_t *pstr;
+	void *private_data;		/* copied from pcm->private_data */
+	int number;
+	char name[32];			/* substream name */
+	int stream;			/* stream (direction) */
+	size_t buffer_bytes_max;	/* limit ring buffer size */
+	struct snd_dma_buffer dma_buffer;
+	unsigned int dma_buf_id;
+	size_t dma_max;
+	/* -- hardware operations -- */
+	unsigned int open_flag: 1;	/* lowlevel device has been opened */
+	snd_pcm_ops_t *ops;
+	/* -- runtime information -- */
+	snd_pcm_runtime_t *runtime;
+        /* -- timer section -- */
+	snd_timer_t *timer;		/* timer */
+	unsigned timer_running: 1;	/* time is running */
+	spinlock_t timer_lock;
+	/* -- next substream -- */
+	snd_pcm_substream_t *next;
+	/* -- linked substreams -- */
+	struct list_head link_list;	/* linked list member */
+	snd_pcm_group_t self_group;	/* fake group for non linked substream (with substream lock inside) */
+	snd_pcm_group_t *group;		/* pointer to current group */
+	/* -- assigned files -- */
+	snd_pcm_file_t *file;
+	struct file *ffile;
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+	/* -- OSS things -- */
+	snd_pcm_oss_substream_t oss;
+#endif
+	snd_info_entry_t *proc_root;
+	snd_info_entry_t *proc_info_entry;
+	snd_info_entry_t *proc_hw_params_entry;
+	snd_info_entry_t *proc_sw_params_entry;
+	snd_info_entry_t *proc_status_entry;
+	snd_info_entry_t *proc_prealloc_entry;
+	/* misc flags */
+	unsigned int no_mmap_ctrl: 1;
+};
+
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+#define SUBSTREAM_BUSY(substream) ((substream)->file != NULL || ((substream)->oss.file != NULL))
+#else
+#define SUBSTREAM_BUSY(substream) ((substream)->file != NULL)
+#endif
+
+
+struct _snd_pcm_str {
+	int stream;				/* stream (direction) */
+	snd_pcm_t *pcm;
+	/* -- substreams -- */
+	unsigned int substream_count;
+	unsigned int substream_opened;
+	snd_pcm_substream_t *substream;
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+	/* -- OSS things -- */
+	snd_pcm_oss_stream_t oss;
+#endif
+	snd_pcm_file_t *files;
+	snd_minor_t *reg;
+	snd_info_entry_t *proc_root;
+	snd_info_entry_t *proc_info_entry;
+#ifdef CONFIG_SND_DEBUG
+	unsigned int xrun_debug;	/* 0 = disabled, 1 = verbose, 2 = stacktrace */
+	snd_info_entry_t *proc_xrun_debug_entry;
+#endif
+};
+
+struct _snd_pcm {
+	snd_card_t *card;
+	unsigned int device;	/* device number */
+	unsigned int info_flags;
+	unsigned short dev_class;
+	unsigned short dev_subclass;
+	char id[64];
+	char name[80];
+	snd_pcm_str_t streams[2];
+	struct semaphore open_mutex;
+	wait_queue_head_t open_wait;
+	void *private_data;
+	void (*private_free) (snd_pcm_t *pcm);
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+	snd_pcm_oss_t oss;
+#endif
+};
+
+typedef struct _snd_pcm_notify {
+	int (*n_register) (snd_pcm_t * pcm);
+	int (*n_disconnect) (snd_pcm_t * pcm);
+	int (*n_unregister) (snd_pcm_t * pcm);
+	struct list_head list;
+} snd_pcm_notify_t;
+
+/*
+ *  Registering
+ */
+
+extern snd_pcm_t *snd_pcm_devices[];
+extern snd_minor_t snd_pcm_reg[2];
+
+int snd_pcm_new(snd_card_t * card, char *id, int device,
+		int playback_count, int capture_count,
+		snd_pcm_t **rpcm);
+int snd_pcm_new_stream(snd_pcm_t *pcm, int stream, int substream_count);
+
+int snd_pcm_notify(snd_pcm_notify_t *notify, int nfree);
+
+/*
+ *  Native I/O
+ */
+
+extern rwlock_t snd_pcm_link_rwlock;
+
+int snd_pcm_info(snd_pcm_substream_t * substream, snd_pcm_info_t *info);
+int snd_pcm_info_user(snd_pcm_substream_t * substream, snd_pcm_info_t __user *info);
+int snd_pcm_status(snd_pcm_substream_t * substream, snd_pcm_status_t *status);
+int snd_pcm_prepare(snd_pcm_substream_t *substream);
+int snd_pcm_start(snd_pcm_substream_t *substream);
+int snd_pcm_stop(snd_pcm_substream_t *substream, int status);
+int snd_pcm_drain_done(snd_pcm_substream_t *substream);
+#ifdef CONFIG_PM
+int snd_pcm_suspend(snd_pcm_substream_t *substream);
+int snd_pcm_suspend_all(snd_pcm_t *pcm);
+#endif
+int snd_pcm_kernel_playback_ioctl(snd_pcm_substream_t *substream, unsigned int cmd, void *arg);
+int snd_pcm_kernel_capture_ioctl(snd_pcm_substream_t *substream, unsigned int cmd, void *arg);
+int snd_pcm_kernel_ioctl(snd_pcm_substream_t *substream, unsigned int cmd, void *arg);
+int snd_pcm_open_substream(snd_pcm_t *pcm, int stream, snd_pcm_substream_t **rsubstream);
+void snd_pcm_release_substream(snd_pcm_substream_t *substream);
+void snd_pcm_vma_notify_data(void *client, void *data);
+int snd_pcm_mmap_data(snd_pcm_substream_t *substream, struct file *file, struct vm_area_struct *area);
+
+#if BITS_PER_LONG >= 64
+
+static inline void div64_32(u_int64_t *n, u_int32_t div, u_int32_t *rem)
+{
+	*rem = *n % div;
+	*n /= div;
+}
+
+#elif defined(i386)
+
+static inline void div64_32(u_int64_t *n, u_int32_t div, u_int32_t *rem)
+{
+	u_int32_t low, high;
+	low = *n & 0xffffffff;
+	high = *n >> 32;
+	if (high) {
+		u_int32_t high1 = high % div;
+		high /= div;
+		asm("divl %2":"=a" (low), "=d" (*rem):"rm" (div), "a" (low), "d" (high1));
+		*n = (u_int64_t)high << 32 | low;
+	} else {
+		*n = low / div;
+		*rem = low % div;
+	}
+}
+#else
+
+static inline void divl(u_int32_t high, u_int32_t low,
+			u_int32_t div,
+			u_int32_t *q, u_int32_t *r)
+{
+	u_int64_t n = (u_int64_t)high << 32 | low;
+	u_int64_t d = (u_int64_t)div << 31;
+	u_int32_t q1 = 0;
+	int c = 32;
+	while (n > 0xffffffffU) {
+		q1 <<= 1;
+		if (n >= d) {
+			n -= d;
+			q1 |= 1;
+		}
+		d >>= 1;
+		c--;
+	}
+	q1 <<= c;
+	if (n) {
+		low = n;
+		*q = q1 | (low / div);
+		*r = low % div;
+	} else {
+		*r = 0;
+		*q = q1;
+	}
+	return;
+}
+
+static inline void div64_32(u_int64_t *n, u_int32_t div, u_int32_t *rem)
+{
+	u_int32_t low, high;
+	low = *n & 0xffffffff;
+	high = *n >> 32;
+	if (high) {
+		u_int32_t high1 = high % div;
+		u_int32_t low1 = low;
+		high /= div;
+		divl(high1, low1, div, &low, rem);
+		*n = (u_int64_t)high << 32 | low;
+	} else {
+		*n = low / div;
+		*rem = low % div;
+	}
+}
+#endif
+
+/*
+ *  PCM library
+ */
+
+static inline int snd_pcm_stream_linked(snd_pcm_substream_t *substream)
+{
+	return substream->group != &substream->self_group;
+}
+
+static inline void snd_pcm_stream_lock(snd_pcm_substream_t *substream)
+{
+	read_lock(&snd_pcm_link_rwlock);
+	spin_lock(&substream->self_group.lock);
+}
+
+static inline void snd_pcm_stream_unlock(snd_pcm_substream_t *substream)
+{
+	spin_unlock(&substream->self_group.lock);
+	read_unlock(&snd_pcm_link_rwlock);
+}
+
+static inline void snd_pcm_stream_lock_irq(snd_pcm_substream_t *substream)
+{
+	read_lock_irq(&snd_pcm_link_rwlock);
+	spin_lock(&substream->self_group.lock);
+}
+
+static inline void snd_pcm_stream_unlock_irq(snd_pcm_substream_t *substream)
+{
+	spin_unlock(&substream->self_group.lock);
+	read_unlock_irq(&snd_pcm_link_rwlock);
+}
+
+#define snd_pcm_stream_lock_irqsave(substream, flags) \
+do { \
+	read_lock_irqsave(&snd_pcm_link_rwlock, (flags)); \
+	spin_lock(&substream->self_group.lock); \
+} while (0)
+
+#define snd_pcm_stream_unlock_irqrestore(substream, flags) \
+do { \
+	spin_unlock(&substream->self_group.lock); \
+	read_unlock_irqrestore(&snd_pcm_link_rwlock, (flags)); \
+} while (0)
+
+#define snd_pcm_group_for_each(pos, substream) \
+	list_for_each(pos, &substream->group->substreams)
+
+#define snd_pcm_group_substream_entry(pos) \
+	list_entry(pos, snd_pcm_substream_t, link_list)
+
+static inline int snd_pcm_running(snd_pcm_substream_t *substream)
+{
+	return (substream->runtime->status->state == SNDRV_PCM_STATE_RUNNING ||
+		(substream->runtime->status->state == SNDRV_PCM_STATE_DRAINING &&
+		 substream->stream == SNDRV_PCM_STREAM_PLAYBACK));
+}
+
+static inline ssize_t bytes_to_samples(snd_pcm_runtime_t *runtime, ssize_t size)
+{
+	return size * 8 / runtime->sample_bits;
+}
+
+static inline snd_pcm_sframes_t bytes_to_frames(snd_pcm_runtime_t *runtime, ssize_t size)
+{
+	return size * 8 / runtime->frame_bits;
+}
+
+static inline ssize_t samples_to_bytes(snd_pcm_runtime_t *runtime, ssize_t size)
+{
+	return size * runtime->sample_bits / 8;
+}
+
+static inline ssize_t frames_to_bytes(snd_pcm_runtime_t *runtime, snd_pcm_sframes_t size)
+{
+	return size * runtime->frame_bits / 8;
+}
+
+static inline int frame_aligned(snd_pcm_runtime_t *runtime, ssize_t bytes)
+{
+	return bytes % runtime->byte_align == 0;
+}
+
+static inline size_t snd_pcm_lib_buffer_bytes(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	return frames_to_bytes(runtime, runtime->buffer_size);
+}
+
+static inline size_t snd_pcm_lib_period_bytes(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	return frames_to_bytes(runtime, runtime->period_size);
+}
+
+/*
+ *  result is: 0 ... (boundary - 1)
+ */
+static inline snd_pcm_uframes_t snd_pcm_playback_avail(snd_pcm_runtime_t *runtime)
+{
+	snd_pcm_sframes_t avail = runtime->status->hw_ptr + runtime->buffer_size - runtime->control->appl_ptr;
+	if (avail < 0)
+		avail += runtime->boundary;
+	else if ((snd_pcm_uframes_t) avail >= runtime->boundary)
+		avail -= runtime->boundary;
+	return avail;
+}
+
+/*
+ *  result is: 0 ... (boundary - 1)
+ */
+static inline snd_pcm_uframes_t snd_pcm_capture_avail(snd_pcm_runtime_t *runtime)
+{
+	snd_pcm_sframes_t avail = runtime->status->hw_ptr - runtime->control->appl_ptr;
+	if (avail < 0)
+		avail += runtime->boundary;
+	return avail;
+}
+
+static inline snd_pcm_sframes_t snd_pcm_playback_hw_avail(snd_pcm_runtime_t *runtime)
+{
+	return runtime->buffer_size - snd_pcm_playback_avail(runtime);
+}
+
+static inline snd_pcm_sframes_t snd_pcm_capture_hw_avail(snd_pcm_runtime_t *runtime)
+{
+	return runtime->buffer_size - snd_pcm_capture_avail(runtime);
+}
+
+/**
+ * snd_pcm_playback_ready - check whether the playback buffer is available
+ * @substream: the pcm substream instance
+ *
+ * Checks whether enough free space is available on the playback buffer.
+ *
+ * Returns non-zero if available, or zero if not.
+ */
+static inline int snd_pcm_playback_ready(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	return snd_pcm_playback_avail(runtime) >= runtime->control->avail_min;
+}
+
+/**
+ * snd_pcm_capture_ready - check whether the capture buffer is available
+ * @substream: the pcm substream instance
+ *
+ * Checks whether enough capture data is available on the capture buffer.
+ *
+ * Returns non-zero if available, or zero if not.
+ */
+static inline int snd_pcm_capture_ready(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	return snd_pcm_capture_avail(runtime) >= runtime->control->avail_min;
+}
+
+/**
+ * snd_pcm_playback_data - check whether any data exists on the playback buffer
+ * @substream: the pcm substream instance
+ *
+ * Checks whether any data exists on the playback buffer. If stop_threshold
+ * is bigger or equal to boundary, then this function returns always non-zero.
+ *
+ * Returns non-zero if exists, or zero if not.
+ */
+static inline int snd_pcm_playback_data(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	
+	if (runtime->stop_threshold >= runtime->boundary)
+		return 1;
+	return snd_pcm_playback_avail(runtime) < runtime->buffer_size;
+}
+
+/**
+ * snd_pcm_playback_empty - check whether the playback buffer is empty
+ * @substream: the pcm substream instance
+ *
+ * Checks whether the playback buffer is empty.
+ *
+ * Returns non-zero if empty, or zero if not.
+ */
+static inline int snd_pcm_playback_empty(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	return snd_pcm_playback_avail(runtime) >= runtime->buffer_size;
+}
+
+/**
+ * snd_pcm_capture_empty - check whether the capture buffer is empty
+ * @substream: the pcm substream instance
+ *
+ * Checks whether the capture buffer is empty.
+ *
+ * Returns non-zero if empty, or zero if not.
+ */
+static inline int snd_pcm_capture_empty(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	return snd_pcm_capture_avail(runtime) == 0;
+}
+
+static inline void snd_pcm_trigger_done(snd_pcm_substream_t *substream, 
+					snd_pcm_substream_t *master)
+{
+	substream->runtime->trigger_master = master;
+}
+
+static inline int hw_is_mask(int var)
+{
+	return var >= SNDRV_PCM_HW_PARAM_FIRST_MASK &&
+		var <= SNDRV_PCM_HW_PARAM_LAST_MASK;
+}
+
+static inline int hw_is_interval(int var)
+{
+	return var >= SNDRV_PCM_HW_PARAM_FIRST_INTERVAL &&
+		var <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL;
+}
+
+static inline snd_mask_t *hw_param_mask(snd_pcm_hw_params_t *params,
+				     snd_pcm_hw_param_t var)
+{
+	return &params->masks[var - SNDRV_PCM_HW_PARAM_FIRST_MASK];
+}
+
+static inline snd_interval_t *hw_param_interval(snd_pcm_hw_params_t *params,
+					     snd_pcm_hw_param_t var)
+{
+	return &params->intervals[var - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL];
+}
+
+static inline const snd_mask_t *hw_param_mask_c(const snd_pcm_hw_params_t *params,
+					     snd_pcm_hw_param_t var)
+{
+	return (const snd_mask_t *)hw_param_mask((snd_pcm_hw_params_t*) params, var);
+}
+
+static inline const snd_interval_t *hw_param_interval_c(const snd_pcm_hw_params_t *params,
+						     snd_pcm_hw_param_t var)
+{
+	return (const snd_interval_t *)hw_param_interval((snd_pcm_hw_params_t*) params, var);
+}
+
+#define params_access(p) snd_mask_min(hw_param_mask((p), SNDRV_PCM_HW_PARAM_ACCESS))
+#define params_format(p) snd_mask_min(hw_param_mask((p), SNDRV_PCM_HW_PARAM_FORMAT))
+#define params_subformat(p) snd_mask_min(hw_param_mask((p), SNDRV_PCM_HW_PARAM_SUBFORMAT))
+#define params_channels(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_CHANNELS)->min
+#define params_rate(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_RATE)->min
+#define params_period_size(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_PERIOD_SIZE)->min
+#define params_period_bytes(p) ((params_period_size(p)*snd_pcm_format_physical_width(params_format(p))*params_channels(p))/8)
+#define params_periods(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_PERIODS)->min
+#define params_buffer_size(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_BUFFER_SIZE)->min
+#define params_buffer_bytes(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_BUFFER_BYTES)->min
+#define params_tick_time(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_TICK_TIME)->min
+
+
+int snd_interval_refine(snd_interval_t *i, const snd_interval_t *v);
+void snd_interval_mul(const snd_interval_t *a, const snd_interval_t *b, snd_interval_t *c);
+void snd_interval_div(const snd_interval_t *a, const snd_interval_t *b, snd_interval_t *c);
+void snd_interval_muldivk(const snd_interval_t *a, const snd_interval_t *b, 
+			  unsigned int k, snd_interval_t *c);
+void snd_interval_mulkdiv(const snd_interval_t *a, unsigned int k,
+			  const snd_interval_t *b, snd_interval_t *c);
+int snd_interval_list(snd_interval_t *i, unsigned int count, unsigned int *list, unsigned int mask);
+int snd_interval_ratnum(snd_interval_t *i,
+			unsigned int rats_count, ratnum_t *rats,
+			unsigned int *nump, unsigned int *denp);
+
+void _snd_pcm_hw_params_any(snd_pcm_hw_params_t *params);
+void _snd_pcm_hw_param_setempty(snd_pcm_hw_params_t *params, snd_pcm_hw_param_t var);
+int snd_pcm_hw_param_min(snd_pcm_substream_t *substream, 
+			 snd_pcm_hw_params_t *params,
+			 snd_pcm_hw_param_t var,
+			 unsigned int val, int *dir);
+int snd_pcm_hw_param_max(snd_pcm_substream_t *substream, 
+			 snd_pcm_hw_params_t *params,
+			 snd_pcm_hw_param_t var,
+			 unsigned int val, int *dir);
+int snd_pcm_hw_param_setinteger(snd_pcm_substream_t *substream, 
+				snd_pcm_hw_params_t *params,
+				snd_pcm_hw_param_t var);
+int snd_pcm_hw_param_first(snd_pcm_substream_t *substream, 
+			   snd_pcm_hw_params_t *params,
+			   snd_pcm_hw_param_t var, int *dir);
+int snd_pcm_hw_param_last(snd_pcm_substream_t *substream, 
+			  snd_pcm_hw_params_t *params,
+			  snd_pcm_hw_param_t var, int *dir);
+int snd_pcm_hw_param_near(snd_pcm_substream_t *substream, 
+			  snd_pcm_hw_params_t *params,
+			  snd_pcm_hw_param_t var, 
+			  unsigned int val, int *dir);
+int snd_pcm_hw_param_set(snd_pcm_substream_t *pcm,
+			 snd_pcm_hw_params_t *params,
+			 snd_pcm_hw_param_t var,
+			 unsigned int val, int dir);
+int snd_pcm_hw_params_choose(snd_pcm_substream_t *substream, snd_pcm_hw_params_t *params);
+
+int snd_pcm_hw_refine(snd_pcm_substream_t *substream, snd_pcm_hw_params_t *params);
+int snd_pcm_hw_params(snd_pcm_substream_t *substream, snd_pcm_hw_params_t *params);
+
+int snd_pcm_hw_constraints_init(snd_pcm_substream_t *substream);
+int snd_pcm_hw_constraints_complete(snd_pcm_substream_t *substream);
+
+int snd_pcm_hw_constraint_mask(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var,
+			       u_int32_t mask);
+int snd_pcm_hw_constraint_mask64(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var,
+				 u_int64_t mask);
+int snd_pcm_hw_constraint_minmax(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var,
+				 unsigned int min, unsigned int max);
+int snd_pcm_hw_constraint_integer(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var);
+int snd_pcm_hw_constraint_list(snd_pcm_runtime_t *runtime, 
+			       unsigned int cond,
+			       snd_pcm_hw_param_t var,
+			       snd_pcm_hw_constraint_list_t *l);
+int snd_pcm_hw_constraint_ratnums(snd_pcm_runtime_t *runtime, 
+				  unsigned int cond,
+				  snd_pcm_hw_param_t var,
+				  snd_pcm_hw_constraint_ratnums_t *r);
+int snd_pcm_hw_constraint_ratdens(snd_pcm_runtime_t *runtime, 
+				  unsigned int cond,
+				  snd_pcm_hw_param_t var,
+				  snd_pcm_hw_constraint_ratdens_t *r);
+int snd_pcm_hw_constraint_msbits(snd_pcm_runtime_t *runtime, 
+				 unsigned int cond,
+				 unsigned int width,
+				 unsigned int msbits);
+int snd_pcm_hw_constraint_step(snd_pcm_runtime_t *runtime,
+			       unsigned int cond,
+			       snd_pcm_hw_param_t var,
+			       unsigned long step);
+int snd_pcm_hw_constraint_pow2(snd_pcm_runtime_t *runtime,
+			       unsigned int cond,
+			       snd_pcm_hw_param_t var);
+int snd_pcm_hw_rule_add(snd_pcm_runtime_t *runtime,
+			unsigned int cond,
+			int var,
+			snd_pcm_hw_rule_func_t func, void *private,
+			int dep, ...);
+
+int snd_pcm_format_signed(snd_pcm_format_t format);
+int snd_pcm_format_unsigned(snd_pcm_format_t format);
+int snd_pcm_format_linear(snd_pcm_format_t format);
+int snd_pcm_format_little_endian(snd_pcm_format_t format);
+int snd_pcm_format_big_endian(snd_pcm_format_t format);
+int snd_pcm_format_width(snd_pcm_format_t format);			/* in bits */
+int snd_pcm_format_physical_width(snd_pcm_format_t format);		/* in bits */
+const unsigned char *snd_pcm_format_silence_64(snd_pcm_format_t format);
+int snd_pcm_format_set_silence(snd_pcm_format_t format, void *buf, unsigned int frames);
+snd_pcm_format_t snd_pcm_build_linear_format(int width, int unsignd, int big_endian);
+const char *snd_pcm_format_name(snd_pcm_format_t format);
+
+void snd_pcm_set_ops(snd_pcm_t * pcm, int direction, snd_pcm_ops_t *ops);
+void snd_pcm_set_sync(snd_pcm_substream_t * substream);
+int snd_pcm_lib_interleave_len(snd_pcm_substream_t *substream);
+int snd_pcm_lib_ioctl(snd_pcm_substream_t *substream,
+		      unsigned int cmd, void *arg);                      
+int snd_pcm_update_hw_ptr(snd_pcm_substream_t *substream);
+int snd_pcm_playback_xrun_check(snd_pcm_substream_t *substream);
+int snd_pcm_capture_xrun_check(snd_pcm_substream_t *substream);
+int snd_pcm_playback_xrun_asap(snd_pcm_substream_t *substream);
+int snd_pcm_capture_xrun_asap(snd_pcm_substream_t *substream);
+void snd_pcm_playback_silence(snd_pcm_substream_t *substream, snd_pcm_uframes_t new_hw_ptr);
+void snd_pcm_tick_prepare(snd_pcm_substream_t *substream);
+void snd_pcm_tick_set(snd_pcm_substream_t *substream, unsigned long ticks);
+void snd_pcm_tick_elapsed(snd_pcm_substream_t *substream);
+void snd_pcm_period_elapsed(snd_pcm_substream_t *substream);
+snd_pcm_sframes_t snd_pcm_lib_write(snd_pcm_substream_t *substream,
+				    const void __user *buf,
+				    snd_pcm_uframes_t frames);
+snd_pcm_sframes_t snd_pcm_lib_read(snd_pcm_substream_t *substream,
+				   void __user *buf, snd_pcm_uframes_t frames);
+snd_pcm_sframes_t snd_pcm_lib_writev(snd_pcm_substream_t *substream,
+				     void __user **bufs, snd_pcm_uframes_t frames);
+snd_pcm_sframes_t snd_pcm_lib_readv(snd_pcm_substream_t *substream,
+				    void __user **bufs, snd_pcm_uframes_t frames);
+
+int snd_pcm_limit_hw_rates(snd_pcm_runtime_t *runtime);
+
+static inline void snd_pcm_set_runtime_buffer(snd_pcm_substream_t *substream,
+					      struct snd_dma_buffer *bufp)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	if (bufp) {
+		runtime->dma_buffer_p = bufp;
+		runtime->dma_area = bufp->area;
+		runtime->dma_addr = bufp->addr;
+		runtime->dma_bytes = bufp->bytes;
+	} else {
+		runtime->dma_buffer_p = NULL;
+		runtime->dma_area = NULL;
+		runtime->dma_addr = 0;
+		runtime->dma_bytes = 0;
+	}
+}
+
+/*
+ *  Timer interface
+ */
+
+void snd_pcm_timer_resolution_change(snd_pcm_substream_t *substream);
+void snd_pcm_timer_init(snd_pcm_substream_t * substream);
+void snd_pcm_timer_done(snd_pcm_substream_t * substream);
+
+/*
+ *  Memory
+ */
+
+int snd_pcm_lib_preallocate_free(snd_pcm_substream_t *substream);
+int snd_pcm_lib_preallocate_free_for_all(snd_pcm_t *pcm);
+int snd_pcm_lib_preallocate_pages(snd_pcm_substream_t *substream,
+				  int type, struct device *data,
+				  size_t size, size_t max);
+int snd_pcm_lib_preallocate_pages_for_all(snd_pcm_t *pcm,
+					  int type, void *data,
+					  size_t size, size_t max);
+int snd_pcm_lib_malloc_pages(snd_pcm_substream_t *substream, size_t size);
+int snd_pcm_lib_free_pages(snd_pcm_substream_t *substream);
+
+#define snd_pcm_substream_sgbuf(substream) ((substream)->runtime->dma_buffer_p->private_data)
+#define snd_pcm_sgbuf_pages(size) snd_sgbuf_aligned_pages(size)
+#define snd_pcm_sgbuf_get_addr(sgbuf,ofs) snd_sgbuf_get_addr(sgbuf,ofs)
+struct page *snd_pcm_sgbuf_ops_page(snd_pcm_substream_t *substream, unsigned long offset);
+
+/* handle mmap counter - PCM mmap callback should handle this counter properly */
+static inline void snd_pcm_mmap_data_open(struct vm_area_struct *area)
+{
+	snd_pcm_substream_t *substream = (snd_pcm_substream_t *)area->vm_private_data;
+	atomic_inc(&substream->runtime->mmap_count);
+}
+
+static inline void snd_pcm_mmap_data_close(struct vm_area_struct *area)
+{
+	snd_pcm_substream_t *substream = (snd_pcm_substream_t *)area->vm_private_data;
+	atomic_dec(&substream->runtime->mmap_count);
+}
+
+/* mmap for io-memory area */
+#if defined(CONFIG_X86) || defined(CONFIG_PPC) || defined(CONFIG_ALPHA)
+#define SNDRV_PCM_INFO_MMAP_IOMEM	SNDRV_PCM_INFO_MMAP
+int snd_pcm_lib_mmap_iomem(snd_pcm_substream_t *substream, struct vm_area_struct *area);
+#else
+#define SNDRV_PCM_INFO_MMAP_IOMEM	0
+#define snd_pcm_lib_mmap_iomem	NULL
+#endif
+
+static inline void snd_pcm_limit_isa_dma_size(int dma, size_t *max)
+{
+	*max = dma < 4 ? 64 * 1024 : 128 * 1024;
+}
+
+/*
+ *  Misc
+ */
+
+#define SNDRV_PCM_DEFAULT_CON_SPDIF	(IEC958_AES0_CON_EMPHASIS_NONE|\
+					 (IEC958_AES1_CON_ORIGINAL<<8)|\
+					 (IEC958_AES1_CON_PCM_CODER<<8)|\
+					 (IEC958_AES3_CON_FS_48000<<24))
+
+#endif /* __SOUND_PCM_H */
