commit b9c7d41087bc1755e01f9584f0bdbce0bb8b195d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 6 17:39:39 2020 +0100

    ALSA: pcm: More helper macros for reducing snd_pcm_format_t cast
    
    snd_pcm_format_t is a strong-typed integer and requires the explicit
    cast with __force if converted or compared with a normal integer
    value.  Since most of use cases do iterate over all formats and test /
    set the mask, provide a couple of new helper macros that do the
    explicit cast.
    
    Link: https://lore.kernel.org/r/20200206163945.6797-3-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index 661450a2095b..36f94735d23d 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -133,6 +133,13 @@ static inline int snd_mask_test(const struct snd_mask *mask, unsigned int val)
 	return mask->bits[MASK_OFS(val)] & MASK_BIT(val);
 }
 
+/* Most of drivers need only this one */
+static inline int snd_mask_test_format(const struct snd_mask *mask,
+				       snd_pcm_format_t format)
+{
+	return snd_mask_test(mask, (__force unsigned int)format);
+}
+
 static inline int snd_mask_single(const struct snd_mask *mask)
 {
 	int i, c = 0;

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index 888a833d3b00..661450a2095b 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -1,25 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 #ifndef __SOUND_PCM_PARAMS_H
 #define __SOUND_PCM_PARAMS_H
 
 /*
  *  PCM params helpers
  *  Copyright (c) by Abramo Bagnara <abramo@alsa-project.org>
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <sound/pcm.h>

commit 5363857b916c1f48027e9b96ee8be8376bf20811
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 29 12:05:19 2018 +0100

    ALSA: pcm: Fix interval evaluation with openmin/max
    
    As addressed in alsa-lib (commit b420056604f0), we need to fix the
    case where the evaluation of PCM interval "(x x+1]" leading to
    -EINVAL.  After applying rules, such an interval may be translated as
    "(x x+1)".
    
    Fixes: ff2d6acdf6f1 ("ALSA: pcm: Fix snd_interval_refine first/last with open min/max")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index 2dd37cada7c0..888a833d3b00 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -254,11 +254,13 @@ static inline int snd_interval_empty(const struct snd_interval *i)
 static inline int snd_interval_single(const struct snd_interval *i)
 {
 	return (i->min == i->max || 
-		(i->min + 1 == i->max && i->openmax));
+		(i->min + 1 == i->max && (i->openmin || i->openmax)));
 }
 
 static inline int snd_interval_value(const struct snd_interval *i)
 {
+	if (i->openmin && !i->openmax)
+		return i->max;
 	return i->min;
 }
 

commit 0b62834e73e332fea76a340d62aaf50c732b17e0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 25 23:17:17 2018 +0200

    ALSA: pcm: Add snd_mask_set_format() helper for standard usages
    
    Many drivers calling snd_mask_set() need to do ugly cast with __force
    for shutting up the sparse warnings.  Actually almost all of them are
    about setting the format, so it's far better to provide a common
    helper snd_mask_set_format() to pass SNDRV_PCM_FORMAT_* directly
    without the cast.
    
    There are a few other calls of snd_mask_set(), but they are in the PCM
    core code, so we leave them for now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index c704357775fc..2dd37cada7c0 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -87,6 +87,13 @@ static inline void snd_mask_set(struct snd_mask *mask, unsigned int val)
 	mask->bits[MASK_OFS(val)] |= MASK_BIT(val);
 }
 
+/* Most of drivers need only this one */
+static inline void snd_mask_set_format(struct snd_mask *mask,
+				       snd_pcm_format_t format)
+{
+	snd_mask_set(mask, (__force unsigned int)format);
+}
+
 static inline void snd_mask_reset(struct snd_mask *mask, unsigned int val)
 {
 	mask->bits[MASK_OFS(val)] &= ~MASK_BIT(val);
@@ -369,8 +376,7 @@ static inline int params_physical_width(const struct snd_pcm_hw_params *p)
 static inline void
 params_set_format(struct snd_pcm_hw_params *p, snd_pcm_format_t fmt)
 {
-	snd_mask_set(hw_param_mask(p, SNDRV_PCM_HW_PARAM_FORMAT),
-		(__force int)fmt);
+	snd_mask_set_format(hw_param_mask(p, SNDRV_PCM_HW_PARAM_FORMAT), fmt);
 }
 
 #endif /* __SOUND_PCM_PARAMS_H */

commit 052a9f698268e606ca01eb1ce2a672e548f2ce11
Author: Fang, Yang A <yang.a.fang@intel.com>
Date:   Mon Feb 9 00:18:11 2015 -0800

    ALSA: Add params_set_format helper
    
    Add a helper to set pcm format directly from params
    
    Signed-off-by: Fang, Yang A <yang.a.fang@intel.com>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index 3c45f3924ba7..c704357775fc 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -366,4 +366,11 @@ static inline int params_physical_width(const struct snd_pcm_hw_params *p)
 	return snd_pcm_format_physical_width(params_format(p));
 }
 
+static inline void
+params_set_format(struct snd_pcm_hw_params *p, snd_pcm_format_t fmt)
+{
+	snd_mask_set(hw_param_mask(p, SNDRV_PCM_HW_PARAM_FORMAT),
+		(__force int)fmt);
+}
+
 #endif /* __SOUND_PCM_PARAMS_H */

commit 757b037650c9ecca79a46ab744820b1b3c1bb49d
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Dec 29 19:41:46 2014 +0100

    ALSA: pcm: Replace custom ld2 function with __fls
    
    __fls has the same semantics as ld2, so there is no need to re-implement it.
    Furthermore a lot of architectures have custom implementations of __fls that
    are able to use special hardware instructions to compute the result. This
    makes the code slightly shorter and faster.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index c99e20b0c4c9..3c45f3924ba7 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -38,31 +38,6 @@ int snd_pcm_hw_param_value(const struct snd_pcm_hw_params *params,
 #define MASK_OFS(i)	((i) >> 5)
 #define MASK_BIT(i)	(1U << ((i) & 31))
 
-static inline unsigned int ld2(u_int32_t v)
-{
-        unsigned r = 0;
-
-        if (v >= 0x10000) {
-                v >>= 16;
-                r += 16;
-        }
-        if (v >= 0x100) {
-                v >>= 8;
-                r += 8;
-        }
-        if (v >= 0x10) {
-                v >>= 4;
-                r += 4;
-        }
-        if (v >= 4) {
-                v >>= 2;
-                r += 2;
-        }
-        if (v >= 2)
-                r++;
-        return r;
-}
-
 static inline size_t snd_mask_sizeof(void)
 {
 	return sizeof(struct snd_mask);
@@ -102,7 +77,7 @@ static inline unsigned int snd_mask_max(const struct snd_mask *mask)
 	int i;
 	for (i = SNDRV_MASK_SIZE - 1; i >= 0; i--) {
 		if (mask->bits[i])
-			return ld2(mask->bits[i]) + (i << 5);
+			return __fls(mask->bits[i]) + (i << 5);
 	}
 	return 0;
 }

commit 599ee3291ae88700749e2910a11d1c0f0532355e
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Dec 29 19:41:44 2014 +0100

    ALSA: pcm: Use __ffs() instead of ffs() in snd_mask_min()
    
    The difference between __ffs and ffs is that ffs will return a one based
    index whereas __ffs will return a zero based index. Furthermore ffs will
    check if the passed value is zero and return zero in that case, whereas
    __ffs behavior is undefined if the passed parameter is 0.
    
    Since we already check if the mask is 0 before calling ffs and also subtract
    1 from the result __ffs is the better choice.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index 042049bab0b9..c99e20b0c4c9 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -92,7 +92,7 @@ static inline unsigned int snd_mask_min(const struct snd_mask *mask)
 	int i;
 	for (i = 0; i < SNDRV_MASK_SIZE; i++) {
 		if (mask->bits[i])
-			return ffs(mask->bits[i]) - 1 + (i << 5);
+			return __ffs(mask->bits[i]) + (i << 5);
 	}
 	return 0;
 }

commit cd9978f1d3dbb9596a7ab9c652cb0d9b355489b5
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Dec 29 19:41:43 2014 +0100

    ALSA: pcm: Simplify params_period_bytes()
    
    The hw_params struct has a parameter that contains the period size in bytes.
    This can be used instead of deriving the value from other parameters. This
    is similar to e.g. params_buffer_bytes()
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index 2e2169e4985f..042049bab0b9 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -363,9 +363,7 @@ params_subformat(const struct snd_pcm_hw_params *p)
 static inline unsigned int
 params_period_bytes(const struct snd_pcm_hw_params *p)
 {
-	return (params_period_size(p) *
-		snd_pcm_format_physical_width(params_format(p)) *
-		params_channels(p)) / 8;
+	return hw_param_interval_c(p, SNDRV_PCM_HW_PARAM_PERIOD_BYTES)->min;
 }
 
 /**

commit 89827ca9dd6173da7dcc035653bea67fa6ac0cbf
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Dec 29 19:41:42 2014 +0100

    ALSA: pcm: Add kernel doc for params_*() functions
    
    Add kernel doc for the remaining undocumented params_*() functions.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index bf51f2285c49..2e2169e4985f 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -325,18 +325,30 @@ static inline int snd_interval_eq(const struct snd_interval *i1, const struct sn
 		i1->max == i2->max && i1->openmax == i2->openmax;
 }
 
+/**
+ * params_access - get the access type from the hw params
+ * @p: hw params
+ */
 static inline snd_pcm_access_t params_access(const struct snd_pcm_hw_params *p)
 {
 	return (__force snd_pcm_access_t)snd_mask_min(hw_param_mask_c(p,
 		SNDRV_PCM_HW_PARAM_ACCESS));
 }
 
+/**
+ * params_format - get the sample format from the hw params
+ * @p: hw params
+ */
 static inline snd_pcm_format_t params_format(const struct snd_pcm_hw_params *p)
 {
 	return (__force snd_pcm_format_t)snd_mask_min(hw_param_mask_c(p,
 		SNDRV_PCM_HW_PARAM_FORMAT));
 }
 
+/**
+ * params_subformat - get the sample subformat from the hw params
+ * @p: hw params
+ */
 static inline snd_pcm_subformat_t
 params_subformat(const struct snd_pcm_hw_params *p)
 {
@@ -344,6 +356,10 @@ params_subformat(const struct snd_pcm_hw_params *p)
 		SNDRV_PCM_HW_PARAM_SUBFORMAT));
 }
 
+/**
+ * params_period_bytes - get the period size (in bytes) from the hw params
+ * @p: hw params
+ */
 static inline unsigned int
 params_period_bytes(const struct snd_pcm_hw_params *p)
 {
@@ -352,14 +368,27 @@ params_period_bytes(const struct snd_pcm_hw_params *p)
 		params_channels(p)) / 8;
 }
 
-static inline int
-params_width(const struct snd_pcm_hw_params *p)
+/**
+ * params_width - get the number of bits of the sample format from the hw params
+ * @p: hw params
+ *
+ * This function returns the number of bits per sample that the selected sample
+ * format of the hw params has.
+ */
+static inline int params_width(const struct snd_pcm_hw_params *p)
 {
 	return snd_pcm_format_width(params_format(p));
 }
 
-static inline int
-params_physical_width(const struct snd_pcm_hw_params *p)
+/*
+ * params_physical_width - get the storage size of the sample format from the hw params
+ * @p: hw params
+ *
+ * This functions returns the number of bits per sample that the selected sample
+ * format of the hw params takes up in memory. This will be equal or larger than
+ * params_width().
+ */
+static inline int params_physical_width(const struct snd_pcm_hw_params *p)
 {
 	return snd_pcm_format_physical_width(params_format(p));
 }

commit 744c2ad2f98965473880ef85cac2f8a8ca95959f
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Dec 29 19:41:41 2014 +0100

    ALSA: pcm: Convert params_* mask helpers to static inline functions
    
    Use static inline functions instead of macros for the remaining params_*()
    helpers that have not been converted yet. This is slightly cleaner and
    offers better type safety.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index 15760f5f98ee..bf51f2285c49 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -325,12 +325,24 @@ static inline int snd_interval_eq(const struct snd_interval *i1, const struct sn
 		i1->max == i2->max && i1->openmax == i2->openmax;
 }
 
-#define params_access(p) ((__force snd_pcm_access_t)\
-		snd_mask_min(hw_param_mask_c((p), SNDRV_PCM_HW_PARAM_ACCESS)))
-#define params_format(p) ((__force snd_pcm_format_t)\
-		snd_mask_min(hw_param_mask_c((p), SNDRV_PCM_HW_PARAM_FORMAT)))
-#define params_subformat(p) \
-	snd_mask_min(hw_param_mask_c((p), SNDRV_PCM_HW_PARAM_SUBFORMAT))
+static inline snd_pcm_access_t params_access(const struct snd_pcm_hw_params *p)
+{
+	return (__force snd_pcm_access_t)snd_mask_min(hw_param_mask_c(p,
+		SNDRV_PCM_HW_PARAM_ACCESS));
+}
+
+static inline snd_pcm_format_t params_format(const struct snd_pcm_hw_params *p)
+{
+	return (__force snd_pcm_format_t)snd_mask_min(hw_param_mask_c(p,
+		SNDRV_PCM_HW_PARAM_FORMAT));
+}
+
+static inline snd_pcm_subformat_t
+params_subformat(const struct snd_pcm_hw_params *p)
+{
+	return (__force snd_pcm_subformat_t)snd_mask_min(hw_param_mask_c(p,
+		SNDRV_PCM_HW_PARAM_SUBFORMAT));
+}
 
 static inline unsigned int
 params_period_bytes(const struct snd_pcm_hw_params *p)

commit 26c0d8a415e5c4a01faf24165ec9dea821f6a908
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Dec 29 19:41:38 2014 +0100

    ALSA: pcm_params: Remove unused add/sub functions
    
    Those two functions are not used anywhere and also their name is a bit to
    generic to be in a global header, so remove them.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index 6b1c78f05fab..15760f5f98ee 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -325,20 +325,6 @@ static inline int snd_interval_eq(const struct snd_interval *i1, const struct sn
 		i1->max == i2->max && i1->openmax == i2->openmax;
 }
 
-static inline unsigned int add(unsigned int a, unsigned int b)
-{
-	if (a >= UINT_MAX - b)
-		return UINT_MAX;
-	return a + b;
-}
-
-static inline unsigned int sub(unsigned int a, unsigned int b)
-{
-	if (a > b)
-		return a - b;
-	return 0;
-}
-
 #define params_access(p) ((__force snd_pcm_access_t)\
 		snd_mask_min(hw_param_mask_c((p), SNDRV_PCM_HW_PARAM_ACCESS)))
 #define params_format(p) ((__force snd_pcm_format_t)\

commit 8c5178fca4ce5a57711ea14b807648e19b105d0e
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Dec 24 12:24:28 2013 +0000

    ALSA: Add params_width() helpers
    
    Add helpers for obtaining the width of a format directly from params
    since this is expected to become a common operation in ASoC.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index 37ae12e0ab06..6b1c78f05fab 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -354,4 +354,16 @@ params_period_bytes(const struct snd_pcm_hw_params *p)
 		params_channels(p)) / 8;
 }
 
+static inline int
+params_width(const struct snd_pcm_hw_params *p)
+{
+	return snd_pcm_format_width(params_format(p));
+}
+
+static inline int
+params_physical_width(const struct snd_pcm_hw_params *p)
+{
+	return snd_pcm_format_physical_width(params_format(p));
+}
+
 #endif /* __SOUND_PCM_PARAMS_H */

commit f3761c3950bd2ad813095a240d6a3dcb885d2431
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jun 19 19:31:48 2012 +0100

    ALSA: Add missing include of pcm.h to pcm_params.h
    
    There's a dependency but no #include.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index f494f1e3c900..37ae12e0ab06 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -22,6 +22,8 @@
  *
  */
 
+#include <sound/pcm.h>
+
 int snd_pcm_hw_param_first(struct snd_pcm_substream *pcm, 
 			   struct snd_pcm_hw_params *params,
 			   snd_pcm_hw_param_t var, int *dir);

commit b51beb756aaf0770e4fa8bb2cb142888051aa356
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jul 26 12:02:56 2011 +0200

    ALSA: Make pcm.h self-contained
    
    Move the macros depending on snd_mask_min() and co out of pcm.h into
    pcm_params.h.  Otherwise using some params_*() macros will give comiple
    errors without inclusion of pcm_params.h.
    
    Also use hw_param_interval_c() and hw_param_mask_c() for const pointer.
    
    Reported-by: Tim Blechmann <tim@klingt.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index 85cf1cf4f31a..f494f1e3c900 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -337,5 +337,19 @@ static inline unsigned int sub(unsigned int a, unsigned int b)
 	return 0;
 }
 
-#endif /* __SOUND_PCM_PARAMS_H */
+#define params_access(p) ((__force snd_pcm_access_t)\
+		snd_mask_min(hw_param_mask_c((p), SNDRV_PCM_HW_PARAM_ACCESS)))
+#define params_format(p) ((__force snd_pcm_format_t)\
+		snd_mask_min(hw_param_mask_c((p), SNDRV_PCM_HW_PARAM_FORMAT)))
+#define params_subformat(p) \
+	snd_mask_min(hw_param_mask_c((p), SNDRV_PCM_HW_PARAM_SUBFORMAT))
 
+static inline unsigned int
+params_period_bytes(const struct snd_pcm_hw_params *p)
+{
+	return (params_period_size(p) *
+		snd_pcm_format_physical_width(params_format(p)) *
+		params_channels(p)) / 8;
+}
+
+#endif /* __SOUND_PCM_PARAMS_H */

commit e88e8ae639a4908b903d9406c54e99a729b01a28
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:40 2006 +0200

    [ALSA] Move OSS-specific hw_params helper to snd-pcm-oss module
    
    Move EXPORT_SYMBOL()s to places adjacent to functions/variables.
    Also move OSS-specific hw_params helper functions to pcm_oss.c.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index e3bebd98e1ce..85cf1cf4f31a 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -22,18 +22,14 @@
  *
  */
 
-extern int snd_pcm_hw_param_mask(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params,
-				 snd_pcm_hw_param_t var, const struct snd_mask *val);
-extern unsigned int snd_pcm_hw_param_value_min(const struct snd_pcm_hw_params *params,
-					       snd_pcm_hw_param_t var, int *dir);
-extern unsigned int snd_pcm_hw_param_value_max(const struct snd_pcm_hw_params *params,
-					       snd_pcm_hw_param_t var, int *dir);
-extern int _snd_pcm_hw_param_min(struct snd_pcm_hw_params *params,
-				 snd_pcm_hw_param_t var, unsigned int val, int dir);
-extern int _snd_pcm_hw_param_setinteger(struct snd_pcm_hw_params *params,
-					snd_pcm_hw_param_t var);
-extern int _snd_pcm_hw_param_set(struct snd_pcm_hw_params *params,
-				 snd_pcm_hw_param_t var, unsigned int val, int dir);
+int snd_pcm_hw_param_first(struct snd_pcm_substream *pcm, 
+			   struct snd_pcm_hw_params *params,
+			   snd_pcm_hw_param_t var, int *dir);
+int snd_pcm_hw_param_last(struct snd_pcm_substream *pcm, 
+			  struct snd_pcm_hw_params *params,
+			  snd_pcm_hw_param_t var, int *dir);
+int snd_pcm_hw_param_value(const struct snd_pcm_hw_params *params,
+			   snd_pcm_hw_param_t var, int *dir);
 
 #define SNDRV_MASK_BITS	64	/* we use so far 64bits only */
 #define SNDRV_MASK_SIZE	(SNDRV_MASK_BITS / 32)

commit 9bb22e215c28204faee73dd7ac0ad98c075d6f7b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:39 2006 +0200

    [ALSA] Clean up ugly hacks in pcm_params.h
    
    Clean up ugly hacks for sync with alsa-lib in pcm_params.h.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index fb18aef77341..e3bebd98e1ce 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -35,16 +35,12 @@ extern int _snd_pcm_hw_param_setinteger(struct snd_pcm_hw_params *params,
 extern int _snd_pcm_hw_param_set(struct snd_pcm_hw_params *params,
 				 snd_pcm_hw_param_t var, unsigned int val, int dir);
 
-/* To share the same code we have  alsa-lib */
-#define INLINE static inline
-#define assert(a) (void)(a)
-
 #define SNDRV_MASK_BITS	64	/* we use so far 64bits only */
 #define SNDRV_MASK_SIZE	(SNDRV_MASK_BITS / 32)
 #define MASK_OFS(i)	((i) >> 5)
 #define MASK_BIT(i)	(1U << ((i) & 31))
 
-INLINE unsigned int ld2(u_int32_t v)
+static inline unsigned int ld2(u_int32_t v)
 {
         unsigned r = 0;
 
@@ -69,22 +65,22 @@ INLINE unsigned int ld2(u_int32_t v)
         return r;
 }
 
-INLINE size_t snd_mask_sizeof(void)
+static inline size_t snd_mask_sizeof(void)
 {
 	return sizeof(struct snd_mask);
 }
 
-INLINE void snd_mask_none(struct snd_mask *mask)
+static inline void snd_mask_none(struct snd_mask *mask)
 {
 	memset(mask, 0, sizeof(*mask));
 }
 
-INLINE void snd_mask_any(struct snd_mask *mask)
+static inline void snd_mask_any(struct snd_mask *mask)
 {
 	memset(mask, 0xff, SNDRV_MASK_SIZE * sizeof(u_int32_t));
 }
 
-INLINE int snd_mask_empty(const struct snd_mask *mask)
+static inline int snd_mask_empty(const struct snd_mask *mask)
 {
 	int i;
 	for (i = 0; i < SNDRV_MASK_SIZE; i++)
@@ -93,10 +89,9 @@ INLINE int snd_mask_empty(const struct snd_mask *mask)
 	return 1;
 }
 
-INLINE unsigned int snd_mask_min(const struct snd_mask *mask)
+static inline unsigned int snd_mask_min(const struct snd_mask *mask)
 {
 	int i;
-	assert(!snd_mask_empty(mask));
 	for (i = 0; i < SNDRV_MASK_SIZE; i++) {
 		if (mask->bits[i])
 			return ffs(mask->bits[i]) - 1 + (i << 5);
@@ -104,10 +99,9 @@ INLINE unsigned int snd_mask_min(const struct snd_mask *mask)
 	return 0;
 }
 
-INLINE unsigned int snd_mask_max(const struct snd_mask *mask)
+static inline unsigned int snd_mask_max(const struct snd_mask *mask)
 {
 	int i;
-	assert(!snd_mask_empty(mask));
 	for (i = SNDRV_MASK_SIZE - 1; i >= 0; i--) {
 		if (mask->bits[i])
 			return ld2(mask->bits[i]) + (i << 5);
@@ -115,70 +109,68 @@ INLINE unsigned int snd_mask_max(const struct snd_mask *mask)
 	return 0;
 }
 
-INLINE void snd_mask_set(struct snd_mask *mask, unsigned int val)
+static inline void snd_mask_set(struct snd_mask *mask, unsigned int val)
 {
-	assert(val <= SNDRV_MASK_BITS);
 	mask->bits[MASK_OFS(val)] |= MASK_BIT(val);
 }
 
-INLINE void snd_mask_reset(struct snd_mask *mask, unsigned int val)
+static inline void snd_mask_reset(struct snd_mask *mask, unsigned int val)
 {
-	assert(val <= SNDRV_MASK_BITS);
 	mask->bits[MASK_OFS(val)] &= ~MASK_BIT(val);
 }
 
-INLINE void snd_mask_set_range(struct snd_mask *mask, unsigned int from, unsigned int to)
+static inline void snd_mask_set_range(struct snd_mask *mask,
+				      unsigned int from, unsigned int to)
 {
 	unsigned int i;
-	assert(to <= SNDRV_MASK_BITS && from <= to);
 	for (i = from; i <= to; i++)
 		mask->bits[MASK_OFS(i)] |= MASK_BIT(i);
 }
 
-INLINE void snd_mask_reset_range(struct snd_mask *mask, unsigned int from, unsigned int to)
+static inline void snd_mask_reset_range(struct snd_mask *mask,
+					unsigned int from, unsigned int to)
 {
 	unsigned int i;
-	assert(to <= SNDRV_MASK_BITS && from <= to);
 	for (i = from; i <= to; i++)
 		mask->bits[MASK_OFS(i)] &= ~MASK_BIT(i);
 }
 
-INLINE void snd_mask_leave(struct snd_mask *mask, unsigned int val)
+static inline void snd_mask_leave(struct snd_mask *mask, unsigned int val)
 {
 	unsigned int v;
-	assert(val <= SNDRV_MASK_BITS);
 	v = mask->bits[MASK_OFS(val)] & MASK_BIT(val);
 	snd_mask_none(mask);
 	mask->bits[MASK_OFS(val)] = v;
 }
 
-INLINE void snd_mask_intersect(struct snd_mask *mask, const struct snd_mask *v)
+static inline void snd_mask_intersect(struct snd_mask *mask,
+				      const struct snd_mask *v)
 {
 	int i;
 	for (i = 0; i < SNDRV_MASK_SIZE; i++)
 		mask->bits[i] &= v->bits[i];
 }
 
-INLINE int snd_mask_eq(const struct snd_mask *mask, const struct snd_mask *v)
+static inline int snd_mask_eq(const struct snd_mask *mask,
+			      const struct snd_mask *v)
 {
 	return ! memcmp(mask, v, SNDRV_MASK_SIZE * sizeof(u_int32_t));
 }
 
-INLINE void snd_mask_copy(struct snd_mask *mask, const struct snd_mask *v)
+static inline void snd_mask_copy(struct snd_mask *mask,
+				 const struct snd_mask *v)
 {
 	*mask = *v;
 }
 
-INLINE int snd_mask_test(const struct snd_mask *mask, unsigned int val)
+static inline int snd_mask_test(const struct snd_mask *mask, unsigned int val)
 {
-	assert(val <= SNDRV_MASK_BITS);
 	return mask->bits[MASK_OFS(val)] & MASK_BIT(val);
 }
 
-INLINE int snd_mask_single(const struct snd_mask *mask)
+static inline int snd_mask_single(const struct snd_mask *mask)
 {
 	int i, c = 0;
-	assert(!snd_mask_empty(mask));
 	for (i = 0; i < SNDRV_MASK_SIZE; i++) {
 		if (! mask->bits[i])
 			continue;
@@ -191,10 +183,10 @@ INLINE int snd_mask_single(const struct snd_mask *mask)
 	return 1;
 }
 
-INLINE int snd_mask_refine(struct snd_mask *mask, const struct snd_mask *v)
+static inline int snd_mask_refine(struct snd_mask *mask,
+				  const struct snd_mask *v)
 {
 	struct snd_mask old;
-	assert(!snd_mask_empty(mask));
 	snd_mask_copy(&old, mask);
 	snd_mask_intersect(mask, v);
 	if (snd_mask_empty(mask))
@@ -202,27 +194,24 @@ INLINE int snd_mask_refine(struct snd_mask *mask, const struct snd_mask *v)
 	return !snd_mask_eq(mask, &old);
 }
 
-INLINE int snd_mask_refine_first(struct snd_mask *mask)
+static inline int snd_mask_refine_first(struct snd_mask *mask)
 {
-	assert(!snd_mask_empty(mask));
 	if (snd_mask_single(mask))
 		return 0;
 	snd_mask_leave(mask, snd_mask_min(mask));
 	return 1;
 }
 
-INLINE int snd_mask_refine_last(struct snd_mask *mask)
+static inline int snd_mask_refine_last(struct snd_mask *mask)
 {
-	assert(!snd_mask_empty(mask));
 	if (snd_mask_single(mask))
 		return 0;
 	snd_mask_leave(mask, snd_mask_max(mask));
 	return 1;
 }
 
-INLINE int snd_mask_refine_min(struct snd_mask *mask, unsigned int val)
+static inline int snd_mask_refine_min(struct snd_mask *mask, unsigned int val)
 {
-	assert(!snd_mask_empty(mask));
 	if (snd_mask_min(mask) >= val)
 		return 0;
 	snd_mask_reset_range(mask, 0, val - 1);
@@ -231,9 +220,8 @@ INLINE int snd_mask_refine_min(struct snd_mask *mask, unsigned int val)
 	return 1;
 }
 
-INLINE int snd_mask_refine_max(struct snd_mask *mask, unsigned int val)
+static inline int snd_mask_refine_max(struct snd_mask *mask, unsigned int val)
 {
-	assert(!snd_mask_empty(mask));
 	if (snd_mask_max(mask) <= val)
 		return 0;
 	snd_mask_reset_range(mask, val + 1, SNDRV_MASK_BITS);
@@ -242,10 +230,9 @@ INLINE int snd_mask_refine_max(struct snd_mask *mask, unsigned int val)
 	return 1;
 }
 
-INLINE int snd_mask_refine_set(struct snd_mask *mask, unsigned int val)
+static inline int snd_mask_refine_set(struct snd_mask *mask, unsigned int val)
 {
 	int changed;
-	assert(!snd_mask_empty(mask));
 	changed = !snd_mask_single(mask);
 	snd_mask_leave(mask, val);
 	if (snd_mask_empty(mask))
@@ -253,13 +240,12 @@ INLINE int snd_mask_refine_set(struct snd_mask *mask, unsigned int val)
 	return changed;
 }
 
-INLINE int snd_mask_value(const struct snd_mask *mask)
+static inline int snd_mask_value(const struct snd_mask *mask)
 {
-	assert(!snd_mask_empty(mask));
 	return snd_mask_min(mask);
 }
 
-INLINE void snd_interval_any(struct snd_interval *i)
+static inline void snd_interval_any(struct snd_interval *i)
 {
 	i->min = 0;
 	i->openmin = 0;
@@ -269,63 +255,59 @@ INLINE void snd_interval_any(struct snd_interval *i)
 	i->empty = 0;
 }
 
-INLINE void snd_interval_none(struct snd_interval *i)
+static inline void snd_interval_none(struct snd_interval *i)
 {
 	i->empty = 1;
 }
 
-INLINE int snd_interval_checkempty(const struct snd_interval *i)
+static inline int snd_interval_checkempty(const struct snd_interval *i)
 {
 	return (i->min > i->max ||
 		(i->min == i->max && (i->openmin || i->openmax)));
 }
 
-INLINE int snd_interval_empty(const struct snd_interval *i)
+static inline int snd_interval_empty(const struct snd_interval *i)
 {
 	return i->empty;
 }
 
-INLINE int snd_interval_single(const struct snd_interval *i)
+static inline int snd_interval_single(const struct snd_interval *i)
 {
-	assert(!snd_interval_empty(i));
 	return (i->min == i->max || 
 		(i->min + 1 == i->max && i->openmax));
 }
 
-INLINE int snd_interval_value(const struct snd_interval *i)
+static inline int snd_interval_value(const struct snd_interval *i)
 {
-	assert(snd_interval_single(i));
 	return i->min;
 }
 
-INLINE int snd_interval_min(const struct snd_interval *i)
+static inline int snd_interval_min(const struct snd_interval *i)
 {
-	assert(!snd_interval_empty(i));
 	return i->min;
 }
 
-INLINE int snd_interval_max(const struct snd_interval *i)
+static inline int snd_interval_max(const struct snd_interval *i)
 {
 	unsigned int v;
-	assert(!snd_interval_empty(i));
 	v = i->max;
 	if (i->openmax)
 		v--;
 	return v;
 }
 
-INLINE int snd_interval_test(const struct snd_interval *i, unsigned int val)
+static inline int snd_interval_test(const struct snd_interval *i, unsigned int val)
 {
 	return !((i->min > val || (i->min == val && i->openmin) ||
 		  i->max < val || (i->max == val && i->openmax)));
 }
 
-INLINE void snd_interval_copy(struct snd_interval *d, const struct snd_interval *s)
+static inline void snd_interval_copy(struct snd_interval *d, const struct snd_interval *s)
 {
 	*d = *s;
 }
 
-INLINE int snd_interval_setinteger(struct snd_interval *i)
+static inline int snd_interval_setinteger(struct snd_interval *i)
 {
 	if (i->integer)
 		return 0;
@@ -335,7 +317,7 @@ INLINE int snd_interval_setinteger(struct snd_interval *i)
 	return 1;
 }
 
-INLINE int snd_interval_eq(const struct snd_interval *i1, const struct snd_interval *i2)
+static inline int snd_interval_eq(const struct snd_interval *i1, const struct snd_interval *i2)
 {
 	if (i1->empty)
 		return i2->empty;
@@ -359,8 +341,5 @@ static inline unsigned int sub(unsigned int a, unsigned int b)
 	return 0;
 }
 
-#undef INLINE
-#undef assert
-
 #endif /* __SOUND_PCM_PARAMS_H */
 

commit 877211f5e1b1196179ba1290e8e1a3dc00427c55
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 13:59:38 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCM
    
    Modules: PCM Midlevel
    
    Remove xxx_t typedefs from the core PCM codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
index 60b0e92e26f3..fb18aef77341 100644
--- a/include/sound/pcm_params.h
+++ b/include/sound/pcm_params.h
@@ -22,17 +22,17 @@
  *
  */
 
-extern int snd_pcm_hw_param_mask(snd_pcm_substream_t *pcm, snd_pcm_hw_params_t *params,
-				 snd_pcm_hw_param_t var, const snd_mask_t *val);
-extern unsigned int snd_pcm_hw_param_value_min(const snd_pcm_hw_params_t *params,
+extern int snd_pcm_hw_param_mask(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params,
+				 snd_pcm_hw_param_t var, const struct snd_mask *val);
+extern unsigned int snd_pcm_hw_param_value_min(const struct snd_pcm_hw_params *params,
 					       snd_pcm_hw_param_t var, int *dir);
-extern unsigned int snd_pcm_hw_param_value_max(const snd_pcm_hw_params_t *params,
+extern unsigned int snd_pcm_hw_param_value_max(const struct snd_pcm_hw_params *params,
 					       snd_pcm_hw_param_t var, int *dir);
-extern int _snd_pcm_hw_param_min(snd_pcm_hw_params_t *params,
+extern int _snd_pcm_hw_param_min(struct snd_pcm_hw_params *params,
 				 snd_pcm_hw_param_t var, unsigned int val, int dir);
-extern int _snd_pcm_hw_param_setinteger(snd_pcm_hw_params_t *params,
+extern int _snd_pcm_hw_param_setinteger(struct snd_pcm_hw_params *params,
 					snd_pcm_hw_param_t var);
-extern int _snd_pcm_hw_param_set(snd_pcm_hw_params_t *params,
+extern int _snd_pcm_hw_param_set(struct snd_pcm_hw_params *params,
 				 snd_pcm_hw_param_t var, unsigned int val, int dir);
 
 /* To share the same code we have  alsa-lib */
@@ -71,20 +71,20 @@ INLINE unsigned int ld2(u_int32_t v)
 
 INLINE size_t snd_mask_sizeof(void)
 {
-	return sizeof(snd_mask_t);
+	return sizeof(struct snd_mask);
 }
 
-INLINE void snd_mask_none(snd_mask_t *mask)
+INLINE void snd_mask_none(struct snd_mask *mask)
 {
 	memset(mask, 0, sizeof(*mask));
 }
 
-INLINE void snd_mask_any(snd_mask_t *mask)
+INLINE void snd_mask_any(struct snd_mask *mask)
 {
 	memset(mask, 0xff, SNDRV_MASK_SIZE * sizeof(u_int32_t));
 }
 
-INLINE int snd_mask_empty(const snd_mask_t *mask)
+INLINE int snd_mask_empty(const struct snd_mask *mask)
 {
 	int i;
 	for (i = 0; i < SNDRV_MASK_SIZE; i++)
@@ -93,7 +93,7 @@ INLINE int snd_mask_empty(const snd_mask_t *mask)
 	return 1;
 }
 
-INLINE unsigned int snd_mask_min(const snd_mask_t *mask)
+INLINE unsigned int snd_mask_min(const struct snd_mask *mask)
 {
 	int i;
 	assert(!snd_mask_empty(mask));
@@ -104,7 +104,7 @@ INLINE unsigned int snd_mask_min(const snd_mask_t *mask)
 	return 0;
 }
 
-INLINE unsigned int snd_mask_max(const snd_mask_t *mask)
+INLINE unsigned int snd_mask_max(const struct snd_mask *mask)
 {
 	int i;
 	assert(!snd_mask_empty(mask));
@@ -115,19 +115,19 @@ INLINE unsigned int snd_mask_max(const snd_mask_t *mask)
 	return 0;
 }
 
-INLINE void snd_mask_set(snd_mask_t *mask, unsigned int val)
+INLINE void snd_mask_set(struct snd_mask *mask, unsigned int val)
 {
 	assert(val <= SNDRV_MASK_BITS);
 	mask->bits[MASK_OFS(val)] |= MASK_BIT(val);
 }
 
-INLINE void snd_mask_reset(snd_mask_t *mask, unsigned int val)
+INLINE void snd_mask_reset(struct snd_mask *mask, unsigned int val)
 {
 	assert(val <= SNDRV_MASK_BITS);
 	mask->bits[MASK_OFS(val)] &= ~MASK_BIT(val);
 }
 
-INLINE void snd_mask_set_range(snd_mask_t *mask, unsigned int from, unsigned int to)
+INLINE void snd_mask_set_range(struct snd_mask *mask, unsigned int from, unsigned int to)
 {
 	unsigned int i;
 	assert(to <= SNDRV_MASK_BITS && from <= to);
@@ -135,7 +135,7 @@ INLINE void snd_mask_set_range(snd_mask_t *mask, unsigned int from, unsigned int
 		mask->bits[MASK_OFS(i)] |= MASK_BIT(i);
 }
 
-INLINE void snd_mask_reset_range(snd_mask_t *mask, unsigned int from, unsigned int to)
+INLINE void snd_mask_reset_range(struct snd_mask *mask, unsigned int from, unsigned int to)
 {
 	unsigned int i;
 	assert(to <= SNDRV_MASK_BITS && from <= to);
@@ -143,7 +143,7 @@ INLINE void snd_mask_reset_range(snd_mask_t *mask, unsigned int from, unsigned i
 		mask->bits[MASK_OFS(i)] &= ~MASK_BIT(i);
 }
 
-INLINE void snd_mask_leave(snd_mask_t *mask, unsigned int val)
+INLINE void snd_mask_leave(struct snd_mask *mask, unsigned int val)
 {
 	unsigned int v;
 	assert(val <= SNDRV_MASK_BITS);
@@ -152,30 +152,30 @@ INLINE void snd_mask_leave(snd_mask_t *mask, unsigned int val)
 	mask->bits[MASK_OFS(val)] = v;
 }
 
-INLINE void snd_mask_intersect(snd_mask_t *mask, const snd_mask_t *v)
+INLINE void snd_mask_intersect(struct snd_mask *mask, const struct snd_mask *v)
 {
 	int i;
 	for (i = 0; i < SNDRV_MASK_SIZE; i++)
 		mask->bits[i] &= v->bits[i];
 }
 
-INLINE int snd_mask_eq(const snd_mask_t *mask, const snd_mask_t *v)
+INLINE int snd_mask_eq(const struct snd_mask *mask, const struct snd_mask *v)
 {
 	return ! memcmp(mask, v, SNDRV_MASK_SIZE * sizeof(u_int32_t));
 }
 
-INLINE void snd_mask_copy(snd_mask_t *mask, const snd_mask_t *v)
+INLINE void snd_mask_copy(struct snd_mask *mask, const struct snd_mask *v)
 {
 	*mask = *v;
 }
 
-INLINE int snd_mask_test(const snd_mask_t *mask, unsigned int val)
+INLINE int snd_mask_test(const struct snd_mask *mask, unsigned int val)
 {
 	assert(val <= SNDRV_MASK_BITS);
 	return mask->bits[MASK_OFS(val)] & MASK_BIT(val);
 }
 
-INLINE int snd_mask_single(const snd_mask_t *mask)
+INLINE int snd_mask_single(const struct snd_mask *mask)
 {
 	int i, c = 0;
 	assert(!snd_mask_empty(mask));
@@ -191,9 +191,9 @@ INLINE int snd_mask_single(const snd_mask_t *mask)
 	return 1;
 }
 
-INLINE int snd_mask_refine(snd_mask_t *mask, const snd_mask_t *v)
+INLINE int snd_mask_refine(struct snd_mask *mask, const struct snd_mask *v)
 {
-	snd_mask_t old;
+	struct snd_mask old;
 	assert(!snd_mask_empty(mask));
 	snd_mask_copy(&old, mask);
 	snd_mask_intersect(mask, v);
@@ -202,7 +202,7 @@ INLINE int snd_mask_refine(snd_mask_t *mask, const snd_mask_t *v)
 	return !snd_mask_eq(mask, &old);
 }
 
-INLINE int snd_mask_refine_first(snd_mask_t *mask)
+INLINE int snd_mask_refine_first(struct snd_mask *mask)
 {
 	assert(!snd_mask_empty(mask));
 	if (snd_mask_single(mask))
@@ -211,7 +211,7 @@ INLINE int snd_mask_refine_first(snd_mask_t *mask)
 	return 1;
 }
 
-INLINE int snd_mask_refine_last(snd_mask_t *mask)
+INLINE int snd_mask_refine_last(struct snd_mask *mask)
 {
 	assert(!snd_mask_empty(mask));
 	if (snd_mask_single(mask))
@@ -220,7 +220,7 @@ INLINE int snd_mask_refine_last(snd_mask_t *mask)
 	return 1;
 }
 
-INLINE int snd_mask_refine_min(snd_mask_t *mask, unsigned int val)
+INLINE int snd_mask_refine_min(struct snd_mask *mask, unsigned int val)
 {
 	assert(!snd_mask_empty(mask));
 	if (snd_mask_min(mask) >= val)
@@ -231,7 +231,7 @@ INLINE int snd_mask_refine_min(snd_mask_t *mask, unsigned int val)
 	return 1;
 }
 
-INLINE int snd_mask_refine_max(snd_mask_t *mask, unsigned int val)
+INLINE int snd_mask_refine_max(struct snd_mask *mask, unsigned int val)
 {
 	assert(!snd_mask_empty(mask));
 	if (snd_mask_max(mask) <= val)
@@ -242,7 +242,7 @@ INLINE int snd_mask_refine_max(snd_mask_t *mask, unsigned int val)
 	return 1;
 }
 
-INLINE int snd_mask_refine_set(snd_mask_t *mask, unsigned int val)
+INLINE int snd_mask_refine_set(struct snd_mask *mask, unsigned int val)
 {
 	int changed;
 	assert(!snd_mask_empty(mask));
@@ -253,13 +253,13 @@ INLINE int snd_mask_refine_set(snd_mask_t *mask, unsigned int val)
 	return changed;
 }
 
-INLINE int snd_mask_value(const snd_mask_t *mask)
+INLINE int snd_mask_value(const struct snd_mask *mask)
 {
 	assert(!snd_mask_empty(mask));
 	return snd_mask_min(mask);
 }
 
-INLINE void snd_interval_any(snd_interval_t *i)
+INLINE void snd_interval_any(struct snd_interval *i)
 {
 	i->min = 0;
 	i->openmin = 0;
@@ -269,42 +269,42 @@ INLINE void snd_interval_any(snd_interval_t *i)
 	i->empty = 0;
 }
 
-INLINE void snd_interval_none(snd_interval_t *i)
+INLINE void snd_interval_none(struct snd_interval *i)
 {
 	i->empty = 1;
 }
 
-INLINE int snd_interval_checkempty(const snd_interval_t *i)
+INLINE int snd_interval_checkempty(const struct snd_interval *i)
 {
 	return (i->min > i->max ||
 		(i->min == i->max && (i->openmin || i->openmax)));
 }
 
-INLINE int snd_interval_empty(const snd_interval_t *i)
+INLINE int snd_interval_empty(const struct snd_interval *i)
 {
 	return i->empty;
 }
 
-INLINE int snd_interval_single(const snd_interval_t *i)
+INLINE int snd_interval_single(const struct snd_interval *i)
 {
 	assert(!snd_interval_empty(i));
 	return (i->min == i->max || 
 		(i->min + 1 == i->max && i->openmax));
 }
 
-INLINE int snd_interval_value(const snd_interval_t *i)
+INLINE int snd_interval_value(const struct snd_interval *i)
 {
 	assert(snd_interval_single(i));
 	return i->min;
 }
 
-INLINE int snd_interval_min(const snd_interval_t *i)
+INLINE int snd_interval_min(const struct snd_interval *i)
 {
 	assert(!snd_interval_empty(i));
 	return i->min;
 }
 
-INLINE int snd_interval_max(const snd_interval_t *i)
+INLINE int snd_interval_max(const struct snd_interval *i)
 {
 	unsigned int v;
 	assert(!snd_interval_empty(i));
@@ -314,18 +314,18 @@ INLINE int snd_interval_max(const snd_interval_t *i)
 	return v;
 }
 
-INLINE int snd_interval_test(const snd_interval_t *i, unsigned int val)
+INLINE int snd_interval_test(const struct snd_interval *i, unsigned int val)
 {
 	return !((i->min > val || (i->min == val && i->openmin) ||
 		  i->max < val || (i->max == val && i->openmax)));
 }
 
-INLINE void snd_interval_copy(snd_interval_t *d, const snd_interval_t *s)
+INLINE void snd_interval_copy(struct snd_interval *d, const struct snd_interval *s)
 {
 	*d = *s;
 }
 
-INLINE int snd_interval_setinteger(snd_interval_t *i)
+INLINE int snd_interval_setinteger(struct snd_interval *i)
 {
 	if (i->integer)
 		return 0;
@@ -335,7 +335,7 @@ INLINE int snd_interval_setinteger(snd_interval_t *i)
 	return 1;
 }
 
-INLINE int snd_interval_eq(const snd_interval_t *i1, const snd_interval_t *i2)
+INLINE int snd_interval_eq(const struct snd_interval *i1, const struct snd_interval *i2)
 {
 	if (i1->empty)
 		return i2->empty;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/sound/pcm_params.h b/include/sound/pcm_params.h
new file mode 100644
index 000000000000..60b0e92e26f3
--- /dev/null
+++ b/include/sound/pcm_params.h
@@ -0,0 +1,366 @@
+#ifndef __SOUND_PCM_PARAMS_H
+#define __SOUND_PCM_PARAMS_H
+
+/*
+ *  PCM params helpers
+ *  Copyright (c) by Abramo Bagnara <abramo@alsa-project.org>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+extern int snd_pcm_hw_param_mask(snd_pcm_substream_t *pcm, snd_pcm_hw_params_t *params,
+				 snd_pcm_hw_param_t var, const snd_mask_t *val);
+extern unsigned int snd_pcm_hw_param_value_min(const snd_pcm_hw_params_t *params,
+					       snd_pcm_hw_param_t var, int *dir);
+extern unsigned int snd_pcm_hw_param_value_max(const snd_pcm_hw_params_t *params,
+					       snd_pcm_hw_param_t var, int *dir);
+extern int _snd_pcm_hw_param_min(snd_pcm_hw_params_t *params,
+				 snd_pcm_hw_param_t var, unsigned int val, int dir);
+extern int _snd_pcm_hw_param_setinteger(snd_pcm_hw_params_t *params,
+					snd_pcm_hw_param_t var);
+extern int _snd_pcm_hw_param_set(snd_pcm_hw_params_t *params,
+				 snd_pcm_hw_param_t var, unsigned int val, int dir);
+
+/* To share the same code we have  alsa-lib */
+#define INLINE static inline
+#define assert(a) (void)(a)
+
+#define SNDRV_MASK_BITS	64	/* we use so far 64bits only */
+#define SNDRV_MASK_SIZE	(SNDRV_MASK_BITS / 32)
+#define MASK_OFS(i)	((i) >> 5)
+#define MASK_BIT(i)	(1U << ((i) & 31))
+
+INLINE unsigned int ld2(u_int32_t v)
+{
+        unsigned r = 0;
+
+        if (v >= 0x10000) {
+                v >>= 16;
+                r += 16;
+        }
+        if (v >= 0x100) {
+                v >>= 8;
+                r += 8;
+        }
+        if (v >= 0x10) {
+                v >>= 4;
+                r += 4;
+        }
+        if (v >= 4) {
+                v >>= 2;
+                r += 2;
+        }
+        if (v >= 2)
+                r++;
+        return r;
+}
+
+INLINE size_t snd_mask_sizeof(void)
+{
+	return sizeof(snd_mask_t);
+}
+
+INLINE void snd_mask_none(snd_mask_t *mask)
+{
+	memset(mask, 0, sizeof(*mask));
+}
+
+INLINE void snd_mask_any(snd_mask_t *mask)
+{
+	memset(mask, 0xff, SNDRV_MASK_SIZE * sizeof(u_int32_t));
+}
+
+INLINE int snd_mask_empty(const snd_mask_t *mask)
+{
+	int i;
+	for (i = 0; i < SNDRV_MASK_SIZE; i++)
+		if (mask->bits[i])
+			return 0;
+	return 1;
+}
+
+INLINE unsigned int snd_mask_min(const snd_mask_t *mask)
+{
+	int i;
+	assert(!snd_mask_empty(mask));
+	for (i = 0; i < SNDRV_MASK_SIZE; i++) {
+		if (mask->bits[i])
+			return ffs(mask->bits[i]) - 1 + (i << 5);
+	}
+	return 0;
+}
+
+INLINE unsigned int snd_mask_max(const snd_mask_t *mask)
+{
+	int i;
+	assert(!snd_mask_empty(mask));
+	for (i = SNDRV_MASK_SIZE - 1; i >= 0; i--) {
+		if (mask->bits[i])
+			return ld2(mask->bits[i]) + (i << 5);
+	}
+	return 0;
+}
+
+INLINE void snd_mask_set(snd_mask_t *mask, unsigned int val)
+{
+	assert(val <= SNDRV_MASK_BITS);
+	mask->bits[MASK_OFS(val)] |= MASK_BIT(val);
+}
+
+INLINE void snd_mask_reset(snd_mask_t *mask, unsigned int val)
+{
+	assert(val <= SNDRV_MASK_BITS);
+	mask->bits[MASK_OFS(val)] &= ~MASK_BIT(val);
+}
+
+INLINE void snd_mask_set_range(snd_mask_t *mask, unsigned int from, unsigned int to)
+{
+	unsigned int i;
+	assert(to <= SNDRV_MASK_BITS && from <= to);
+	for (i = from; i <= to; i++)
+		mask->bits[MASK_OFS(i)] |= MASK_BIT(i);
+}
+
+INLINE void snd_mask_reset_range(snd_mask_t *mask, unsigned int from, unsigned int to)
+{
+	unsigned int i;
+	assert(to <= SNDRV_MASK_BITS && from <= to);
+	for (i = from; i <= to; i++)
+		mask->bits[MASK_OFS(i)] &= ~MASK_BIT(i);
+}
+
+INLINE void snd_mask_leave(snd_mask_t *mask, unsigned int val)
+{
+	unsigned int v;
+	assert(val <= SNDRV_MASK_BITS);
+	v = mask->bits[MASK_OFS(val)] & MASK_BIT(val);
+	snd_mask_none(mask);
+	mask->bits[MASK_OFS(val)] = v;
+}
+
+INLINE void snd_mask_intersect(snd_mask_t *mask, const snd_mask_t *v)
+{
+	int i;
+	for (i = 0; i < SNDRV_MASK_SIZE; i++)
+		mask->bits[i] &= v->bits[i];
+}
+
+INLINE int snd_mask_eq(const snd_mask_t *mask, const snd_mask_t *v)
+{
+	return ! memcmp(mask, v, SNDRV_MASK_SIZE * sizeof(u_int32_t));
+}
+
+INLINE void snd_mask_copy(snd_mask_t *mask, const snd_mask_t *v)
+{
+	*mask = *v;
+}
+
+INLINE int snd_mask_test(const snd_mask_t *mask, unsigned int val)
+{
+	assert(val <= SNDRV_MASK_BITS);
+	return mask->bits[MASK_OFS(val)] & MASK_BIT(val);
+}
+
+INLINE int snd_mask_single(const snd_mask_t *mask)
+{
+	int i, c = 0;
+	assert(!snd_mask_empty(mask));
+	for (i = 0; i < SNDRV_MASK_SIZE; i++) {
+		if (! mask->bits[i])
+			continue;
+		if (mask->bits[i] & (mask->bits[i] - 1))
+			return 0;
+		if (c)
+			return 0;
+		c++;
+	}
+	return 1;
+}
+
+INLINE int snd_mask_refine(snd_mask_t *mask, const snd_mask_t *v)
+{
+	snd_mask_t old;
+	assert(!snd_mask_empty(mask));
+	snd_mask_copy(&old, mask);
+	snd_mask_intersect(mask, v);
+	if (snd_mask_empty(mask))
+		return -EINVAL;
+	return !snd_mask_eq(mask, &old);
+}
+
+INLINE int snd_mask_refine_first(snd_mask_t *mask)
+{
+	assert(!snd_mask_empty(mask));
+	if (snd_mask_single(mask))
+		return 0;
+	snd_mask_leave(mask, snd_mask_min(mask));
+	return 1;
+}
+
+INLINE int snd_mask_refine_last(snd_mask_t *mask)
+{
+	assert(!snd_mask_empty(mask));
+	if (snd_mask_single(mask))
+		return 0;
+	snd_mask_leave(mask, snd_mask_max(mask));
+	return 1;
+}
+
+INLINE int snd_mask_refine_min(snd_mask_t *mask, unsigned int val)
+{
+	assert(!snd_mask_empty(mask));
+	if (snd_mask_min(mask) >= val)
+		return 0;
+	snd_mask_reset_range(mask, 0, val - 1);
+	if (snd_mask_empty(mask))
+		return -EINVAL;
+	return 1;
+}
+
+INLINE int snd_mask_refine_max(snd_mask_t *mask, unsigned int val)
+{
+	assert(!snd_mask_empty(mask));
+	if (snd_mask_max(mask) <= val)
+		return 0;
+	snd_mask_reset_range(mask, val + 1, SNDRV_MASK_BITS);
+	if (snd_mask_empty(mask))
+		return -EINVAL;
+	return 1;
+}
+
+INLINE int snd_mask_refine_set(snd_mask_t *mask, unsigned int val)
+{
+	int changed;
+	assert(!snd_mask_empty(mask));
+	changed = !snd_mask_single(mask);
+	snd_mask_leave(mask, val);
+	if (snd_mask_empty(mask))
+		return -EINVAL;
+	return changed;
+}
+
+INLINE int snd_mask_value(const snd_mask_t *mask)
+{
+	assert(!snd_mask_empty(mask));
+	return snd_mask_min(mask);
+}
+
+INLINE void snd_interval_any(snd_interval_t *i)
+{
+	i->min = 0;
+	i->openmin = 0;
+	i->max = UINT_MAX;
+	i->openmax = 0;
+	i->integer = 0;
+	i->empty = 0;
+}
+
+INLINE void snd_interval_none(snd_interval_t *i)
+{
+	i->empty = 1;
+}
+
+INLINE int snd_interval_checkempty(const snd_interval_t *i)
+{
+	return (i->min > i->max ||
+		(i->min == i->max && (i->openmin || i->openmax)));
+}
+
+INLINE int snd_interval_empty(const snd_interval_t *i)
+{
+	return i->empty;
+}
+
+INLINE int snd_interval_single(const snd_interval_t *i)
+{
+	assert(!snd_interval_empty(i));
+	return (i->min == i->max || 
+		(i->min + 1 == i->max && i->openmax));
+}
+
+INLINE int snd_interval_value(const snd_interval_t *i)
+{
+	assert(snd_interval_single(i));
+	return i->min;
+}
+
+INLINE int snd_interval_min(const snd_interval_t *i)
+{
+	assert(!snd_interval_empty(i));
+	return i->min;
+}
+
+INLINE int snd_interval_max(const snd_interval_t *i)
+{
+	unsigned int v;
+	assert(!snd_interval_empty(i));
+	v = i->max;
+	if (i->openmax)
+		v--;
+	return v;
+}
+
+INLINE int snd_interval_test(const snd_interval_t *i, unsigned int val)
+{
+	return !((i->min > val || (i->min == val && i->openmin) ||
+		  i->max < val || (i->max == val && i->openmax)));
+}
+
+INLINE void snd_interval_copy(snd_interval_t *d, const snd_interval_t *s)
+{
+	*d = *s;
+}
+
+INLINE int snd_interval_setinteger(snd_interval_t *i)
+{
+	if (i->integer)
+		return 0;
+	if (i->openmin && i->openmax && i->min == i->max)
+		return -EINVAL;
+	i->integer = 1;
+	return 1;
+}
+
+INLINE int snd_interval_eq(const snd_interval_t *i1, const snd_interval_t *i2)
+{
+	if (i1->empty)
+		return i2->empty;
+	if (i2->empty)
+		return i1->empty;
+	return i1->min == i2->min && i1->openmin == i2->openmin &&
+		i1->max == i2->max && i1->openmax == i2->openmax;
+}
+
+static inline unsigned int add(unsigned int a, unsigned int b)
+{
+	if (a >= UINT_MAX - b)
+		return UINT_MAX;
+	return a + b;
+}
+
+static inline unsigned int sub(unsigned int a, unsigned int b)
+{
+	if (a > b)
+		return a - b;
+	return 0;
+}
+
+#undef INLINE
+#undef assert
+
+#endif /* __SOUND_PCM_PARAMS_H */
+
