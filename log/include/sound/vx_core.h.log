commit f8ae2d2919481817d2e942617c203fc792687c66
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:46 2020 +0100

    ALSA: vx: Constify snd_vx_hardware and snd_vx_ops definitions
    
    Both snd_vx_hardware and snd_vx_ops are only referred without
    modification, hence they can be constified gracefully for further
    optimizations.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-31-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/vx_core.h b/include/sound/vx_core.h
index 84569ddf85e1..1ddd3036bdfc 100644
--- a/include/sound/vx_core.h
+++ b/include/sound/vx_core.h
@@ -147,8 +147,8 @@ struct vx_core {
 	/* ports are defined externally */
 
 	/* low-level functions */
-	struct snd_vx_hardware *hw;
-	struct snd_vx_ops *ops;
+	const struct snd_vx_hardware *hw;
+	const struct snd_vx_ops *ops;
 
 	struct mutex lock;
 
@@ -193,8 +193,9 @@ struct vx_core {
 /*
  * constructor
  */
-struct vx_core *snd_vx_create(struct snd_card *card, struct snd_vx_hardware *hw,
-			      struct snd_vx_ops *ops, int extra_size);
+struct vx_core *snd_vx_create(struct snd_card *card,
+			      const struct snd_vx_hardware *hw,
+			      const struct snd_vx_ops *ops, int extra_size);
 int snd_vx_setup_firmware(struct vx_core *chip);
 int snd_vx_load_boot_image(struct vx_core *chip, const struct firmware *dsp);
 int snd_vx_dsp_boot(struct vx_core *chip, const struct firmware *dsp);

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/sound/vx_core.h b/include/sound/vx_core.h
index cae9c9d4ef22..84569ddf85e1 100644
--- a/include/sound/vx_core.h
+++ b/include/sound/vx_core.h
@@ -1,23 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Driver for Digigram VX soundcards
  *
  * Hardware core part
  *
  * Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #ifndef __SOUND_VX_COMMON_H

commit db0a5214b8d6cc7a90ce3336d24a85b90cbb4e67
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 9 17:17:20 2014 +0200

    ALSA: vx: Use nonatomic PCM ops
    
    Rewrite VXpocket and VX222 drivers to use the new PCM nonatomic ops.
    The former irq tasklet is replaced with a threaded irq handler, and
    the tasklet for the PCM delayed start is simply merged into the normal
    PCM trigger, as well as the replacement of spinlock with mutex.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/vx_core.h b/include/sound/vx_core.h
index f634f8f85db5..cae9c9d4ef22 100644
--- a/include/sound/vx_core.h
+++ b/include/sound/vx_core.h
@@ -80,8 +80,6 @@ struct vx_pipe {
 
 	unsigned int references;     /* an output pipe may be used for monitoring and/or playback */
 	struct vx_pipe *monitoring_pipe;  /* pointer to the monitoring pipe (capture pipe only)*/
-
-	struct tasklet_struct start_tq;
 };
 
 struct vx_core;
@@ -165,9 +163,7 @@ struct vx_core {
 	struct snd_vx_hardware *hw;
 	struct snd_vx_ops *ops;
 
-	spinlock_t lock;
-	spinlock_t irq_lock;
-	struct tasklet_struct tq;
+	struct mutex lock;
 
 	unsigned int chip_status;
 	unsigned int pcm_running;
@@ -223,6 +219,7 @@ void snd_vx_free_firmware(struct vx_core *chip);
  * interrupt handler; exported for pcmcia
  */
 irqreturn_t snd_vx_irq_handler(int irq, void *dev);
+irqreturn_t snd_vx_threaded_irq_handler(int irq, void *dev);
 
 /*
  * lowlevel functions

commit 0d144de9af28f23d28e4cdf28a08e25e9ad3b41c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 22 16:14:55 2012 +0100

    ALSA: vx: hard dependency on the standard fw loader
    
    Yet again like previous two commits, drop the old hwdep user-space
    firmware code from vx driver (snd-vxpocket and snd-vx222).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/vx_core.h b/include/sound/vx_core.h
index 4f67c762cd74..f634f8f85db5 100644
--- a/include/sound/vx_core.h
+++ b/include/sound/vx_core.h
@@ -27,12 +27,6 @@
 #include <sound/hwdep.h>
 #include <linux/interrupt.h>
 
-#if defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE)
-#if !defined(CONFIG_USE_VXLOADER) && !defined(CONFIG_SND_VX_LIB) /* built-in kernel */
-#define SND_VX_FW_LOADER	/* use the standard firmware loader */
-#endif
-#endif
-
 struct firmware;
 struct device;
 

commit 68cb2b559278858ef9f3a7722f95df88797c7840
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 15:20:37 2012 +0200

    ALSA: Convert to new pm_ops for PCI drivers
    
    Straightforward conversion to the new pm_ops from the legacy
    suspend/resume ops.
    
    Since we change vx222, vx_core and vxpocket have to be converted,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/vx_core.h b/include/sound/vx_core.h
index 5456343ebe4c..4f67c762cd74 100644
--- a/include/sound/vx_core.h
+++ b/include/sound/vx_core.h
@@ -341,7 +341,7 @@ int vx_change_frequency(struct vx_core *chip);
 /*
  * PM
  */
-int snd_vx_suspend(struct vx_core *card, pm_message_t state);
+int snd_vx_suspend(struct vx_core *card);
 int snd_vx_resume(struct vx_core *card);
 
 /*

commit 5e246b850df563224be26f1d409cf66fd6c968df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:47 2008 +0200

    ALSA: Kill snd_assert() in other places
    
    Kill snd_assert() in other places, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/include/sound/vx_core.h b/include/sound/vx_core.h
index 4830651cc4cf..5456343ebe4c 100644
--- a/include/sound/vx_core.h
+++ b/include/sound/vx_core.h
@@ -235,37 +235,31 @@ irqreturn_t snd_vx_irq_handler(int irq, void *dev);
  */
 static inline int vx_test_and_ack(struct vx_core *chip)
 {
-	snd_assert(chip->ops->test_and_ack, return -ENXIO);
 	return chip->ops->test_and_ack(chip);
 }
 
 static inline void vx_validate_irq(struct vx_core *chip, int enable)
 {
-	snd_assert(chip->ops->validate_irq, return);
 	chip->ops->validate_irq(chip, enable);
 }
 
 static inline unsigned char snd_vx_inb(struct vx_core *chip, int reg)
 {
-	snd_assert(chip->ops->in8, return 0);
 	return chip->ops->in8(chip, reg);
 }
 
 static inline unsigned int snd_vx_inl(struct vx_core *chip, int reg)
 {
-	snd_assert(chip->ops->in32, return 0);
 	return chip->ops->in32(chip, reg);
 }
 
 static inline void snd_vx_outb(struct vx_core *chip, int reg, unsigned char val)
 {
-	snd_assert(chip->ops->out8, return);
 	chip->ops->out8(chip, reg, val);
 }
 
 static inline void snd_vx_outl(struct vx_core *chip, int reg, unsigned int val)
 {
-	snd_assert(chip->ops->out32, return);
 	chip->ops->out32(chip, reg, val);
 }
 
@@ -276,7 +270,6 @@ static inline void snd_vx_outl(struct vx_core *chip, int reg, unsigned int val)
 
 static inline void vx_reset_dsp(struct vx_core *chip)
 {
-	snd_assert(chip->ops->reset_dsp, return);
 	chip->ops->reset_dsp(chip);
 }
 
@@ -304,14 +297,12 @@ int snd_vx_check_reg_bit(struct vx_core *chip, int reg, int mask, int bit, int t
 static inline void vx_pseudo_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 				       struct vx_pipe *pipe, int count)
 {
-	snd_assert(chip->ops->dma_write, return);
 	chip->ops->dma_write(chip, runtime, pipe, count);
 }
 
 static inline void vx_pseudo_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 				      struct vx_pipe *pipe, int count)
 {
-	snd_assert(chip->ops->dma_read, return);
 	chip->ops->dma_read(chip, runtime, pipe, count);
 }
 

commit 0cb29ea0d449d7c0ecc9649a08ab63476389701d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 29 15:33:49 2007 +0100

    [ALSA] Add even more 'const' to everything related to TLV
    
    Mark TLV data as 'const'
    Signed-of-by: Philipp Matthias Hahn <pmhahn@pmhahn.de>
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/include/sound/vx_core.h b/include/sound/vx_core.h
index 217394652090..4830651cc4cf 100644
--- a/include/sound/vx_core.h
+++ b/include/sound/vx_core.h
@@ -128,7 +128,7 @@ struct snd_vx_hardware {
 	unsigned int num_ins;
 	unsigned int num_outs;
 	unsigned int output_level_max;
-	unsigned int *output_level_db_scale;
+	const unsigned int *output_level_db_scale;
 };
 
 /* hwdep id string */

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/include/sound/vx_core.h b/include/sound/vx_core.h
index dbca14170615..217394652090 100644
--- a/include/sound/vx_core.h
+++ b/include/sound/vx_core.h
@@ -228,7 +228,7 @@ void snd_vx_free_firmware(struct vx_core *chip);
 /*
  * interrupt handler; exported for pcmcia
  */
-irqreturn_t snd_vx_irq_handler(int irq, void *dev, struct pt_regs *regs);
+irqreturn_t snd_vx_irq_handler(int irq, void *dev);
 
 /*
  * lowlevel functions

commit 1186ed8c7dc9c0185e783beddf241509cc224f1a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 23 19:53:28 2006 +0200

    [ALSA] Add dB scale information to vxpocket and vx222 drivers
    
    Added the dB scale information to vxpocket and vx222 drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/include/sound/vx_core.h b/include/sound/vx_core.h
index 9821a6194caa..dbca14170615 100644
--- a/include/sound/vx_core.h
+++ b/include/sound/vx_core.h
@@ -128,6 +128,7 @@ struct snd_vx_hardware {
 	unsigned int num_ins;
 	unsigned int num_outs;
 	unsigned int output_level_max;
+	unsigned int *output_level_db_scale;
 };
 
 /* hwdep id string */

commit ef9f0a42db987e7e2df72289fb4522d24027786b
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:31:42 2006 +0100

    [ALSA] semaphore -> mutex (driver part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/vx_core.h b/include/sound/vx_core.h
index 5fd6f3305e0d..9821a6194caa 100644
--- a/include/sound/vx_core.h
+++ b/include/sound/vx_core.h
@@ -206,7 +206,7 @@ struct vx_core {
 	int audio_monitor[4];			/* playback hw-monitor level */
 	unsigned char audio_monitor_active[4];	/* playback hw-monitor mute/unmute */
 
-	struct semaphore mixer_mutex;
+	struct mutex mixer_mutex;
 
 	const struct firmware *firmware[4]; /* loaded firmware data */
 };

commit 0ed1cad172176a4595f82e8cd9055938ad54bd4b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 16:06:05 2005 +0100

    [ALSA] vx-driver - Fix PM support
    
    Fix PM support on VX drivers (vxpocket and vx222).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/vx_core.h b/include/sound/vx_core.h
index 0a85c37d1bc7..5fd6f3305e0d 100644
--- a/include/sound/vx_core.h
+++ b/include/sound/vx_core.h
@@ -346,6 +346,12 @@ void vx_set_internal_clock(struct vx_core *chip, unsigned int freq);
 int vx_change_frequency(struct vx_core *chip);
 
 
+/*
+ * PM
+ */
+int snd_vx_suspend(struct vx_core *card, pm_message_t state);
+int snd_vx_resume(struct vx_core *card);
+
 /*
  * hardware constants
  */

commit af26367f69a474ed809e4a59abb5855b47daaff4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:46:59 2005 +0100

    [ALSA] Remove xxx_t typedefs: VXdriver
    
    Remove xxx_t typedefs from the VXdriver codes
    (vx_core support, vx222 and vxpocket).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/vx_core.h b/include/sound/vx_core.h
index 43c901bf7c1f..0a85c37d1bc7 100644
--- a/include/sound/vx_core.h
+++ b/include/sound/vx_core.h
@@ -36,9 +36,6 @@
 struct firmware;
 struct device;
 
-typedef struct snd_vx_core vx_core_t;
-typedef struct vx_pipe vx_pipe_t;
-
 #define VX_DRIVER_VERSION	0x010000	/* 1.0.0 */
 
 /*
@@ -76,7 +73,7 @@ struct vx_pipe {
 	int channels;
 	unsigned int differed_type;
 	pcx_time_t pcx_time;
-	snd_pcm_substream_t *substream;
+	struct snd_pcm_substream *substream;
 
 	int hbuf_size;		/* H-buffer size in bytes */
 	int buffer_bytes;	/* the ALSA pcm buffer size in bytes */
@@ -88,36 +85,38 @@ struct vx_pipe {
 	u64 cur_count;		/* current sample position (for playback) */
 
 	unsigned int references;     /* an output pipe may be used for monitoring and/or playback */
-	vx_pipe_t *monitoring_pipe;  /* pointer to the monitoring pipe (capture pipe only)*/
+	struct vx_pipe *monitoring_pipe;  /* pointer to the monitoring pipe (capture pipe only)*/
 
 	struct tasklet_struct start_tq;
 };
 
+struct vx_core;
+
 struct snd_vx_ops {
 	/* low-level i/o */
-	unsigned char (*in8)(vx_core_t *chip, int reg);
-	unsigned int (*in32)(vx_core_t *chip, int reg);
-	void (*out8)(vx_core_t *chip, int reg, unsigned char val);
-	void (*out32)(vx_core_t *chip, int reg, unsigned int val);
+	unsigned char (*in8)(struct vx_core *chip, int reg);
+	unsigned int (*in32)(struct vx_core *chip, int reg);
+	void (*out8)(struct vx_core *chip, int reg, unsigned char val);
+	void (*out32)(struct vx_core *chip, int reg, unsigned int val);
 	/* irq */
-	int (*test_and_ack)(vx_core_t *chip);
-	void (*validate_irq)(vx_core_t *chip, int enable);
+	int (*test_and_ack)(struct vx_core *chip);
+	void (*validate_irq)(struct vx_core *chip, int enable);
 	/* codec */
-	void (*write_codec)(vx_core_t *chip, int codec, unsigned int data);
-	void (*akm_write)(vx_core_t *chip, int reg, unsigned int data);
-	void (*reset_codec)(vx_core_t *chip);
-	void (*change_audio_source)(vx_core_t *chip, int src);
-	void (*set_clock_source)(vx_core_t *chp, int src);
+	void (*write_codec)(struct vx_core *chip, int codec, unsigned int data);
+	void (*akm_write)(struct vx_core *chip, int reg, unsigned int data);
+	void (*reset_codec)(struct vx_core *chip);
+	void (*change_audio_source)(struct vx_core *chip, int src);
+	void (*set_clock_source)(struct vx_core *chp, int src);
 	/* chip init */
-	int (*load_dsp)(vx_core_t *chip, int idx, const struct firmware *fw);
-	void (*reset_dsp)(vx_core_t *chip);
-	void (*reset_board)(vx_core_t *chip, int cold_reset);
-	int (*add_controls)(vx_core_t *chip);
+	int (*load_dsp)(struct vx_core *chip, int idx, const struct firmware *fw);
+	void (*reset_dsp)(struct vx_core *chip);
+	void (*reset_board)(struct vx_core *chip, int cold_reset);
+	int (*add_controls)(struct vx_core *chip);
 	/* pcm */
-	void (*dma_write)(vx_core_t *chip, snd_pcm_runtime_t *runtime,
-			  vx_pipe_t *pipe, int count);
-	void (*dma_read)(vx_core_t *chip, snd_pcm_runtime_t *runtime,
-			  vx_pipe_t *pipe, int count);
+	void (*dma_write)(struct vx_core *chip, struct snd_pcm_runtime *runtime,
+			  struct vx_pipe *pipe, int count);
+	void (*dma_read)(struct vx_core *chip, struct snd_pcm_runtime *runtime,
+			  struct vx_pipe *pipe, int count);
 };
 
 struct snd_vx_hardware {
@@ -158,10 +157,10 @@ enum {
 /* min/max values for analog output for old codecs */
 #define VX_ANALOG_OUT_LEVEL_MAX		0xe3
 
-struct snd_vx_core {
+struct vx_core {
 	/* ALSA stuff */
-	snd_card_t *card;
-	snd_pcm_t *pcm[VX_MAX_CODECS];
+	struct snd_card *card;
+	struct snd_pcm *pcm[VX_MAX_CODECS];
 	int type;	/* VX_TYPE_XXX */
 
 	int irq;
@@ -179,7 +178,7 @@ struct snd_vx_core {
 	unsigned int pcm_running;
 
 	struct device *dev;
-	snd_hwdep_t *hwdep;
+	struct snd_hwdep *hwdep;
 
 	struct vx_rmh irq_rmh;	/* RMH used in interrupts */
 
@@ -216,14 +215,14 @@ struct snd_vx_core {
 /*
  * constructor
  */
-vx_core_t *snd_vx_create(snd_card_t *card, struct snd_vx_hardware *hw,
-			 struct snd_vx_ops *ops, int extra_size);
-int snd_vx_setup_firmware(vx_core_t *chip);
-int snd_vx_load_boot_image(vx_core_t *chip, const struct firmware *dsp);
-int snd_vx_dsp_boot(vx_core_t *chip, const struct firmware *dsp);
-int snd_vx_dsp_load(vx_core_t *chip, const struct firmware *dsp);
+struct vx_core *snd_vx_create(struct snd_card *card, struct snd_vx_hardware *hw,
+			      struct snd_vx_ops *ops, int extra_size);
+int snd_vx_setup_firmware(struct vx_core *chip);
+int snd_vx_load_boot_image(struct vx_core *chip, const struct firmware *dsp);
+int snd_vx_dsp_boot(struct vx_core *chip, const struct firmware *dsp);
+int snd_vx_dsp_load(struct vx_core *chip, const struct firmware *dsp);
 
-void snd_vx_free_firmware(vx_core_t *chip);
+void snd_vx_free_firmware(struct vx_core *chip);
 
 /*
  * interrupt handler; exported for pcmcia
@@ -233,37 +232,37 @@ irqreturn_t snd_vx_irq_handler(int irq, void *dev, struct pt_regs *regs);
 /*
  * lowlevel functions
  */
-static inline int vx_test_and_ack(vx_core_t *chip)
+static inline int vx_test_and_ack(struct vx_core *chip)
 {
 	snd_assert(chip->ops->test_and_ack, return -ENXIO);
 	return chip->ops->test_and_ack(chip);
 }
 
-static inline void vx_validate_irq(vx_core_t *chip, int enable)
+static inline void vx_validate_irq(struct vx_core *chip, int enable)
 {
 	snd_assert(chip->ops->validate_irq, return);
 	chip->ops->validate_irq(chip, enable);
 }
 
-static inline unsigned char snd_vx_inb(vx_core_t *chip, int reg)
+static inline unsigned char snd_vx_inb(struct vx_core *chip, int reg)
 {
 	snd_assert(chip->ops->in8, return 0);
 	return chip->ops->in8(chip, reg);
 }
 
-static inline unsigned int snd_vx_inl(vx_core_t *chip, int reg)
+static inline unsigned int snd_vx_inl(struct vx_core *chip, int reg)
 {
 	snd_assert(chip->ops->in32, return 0);
 	return chip->ops->in32(chip, reg);
 }
 
-static inline void snd_vx_outb(vx_core_t *chip, int reg, unsigned char val)
+static inline void snd_vx_outb(struct vx_core *chip, int reg, unsigned char val)
 {
 	snd_assert(chip->ops->out8, return);
 	chip->ops->out8(chip, reg, val);
 }
 
-static inline void snd_vx_outl(vx_core_t *chip, int reg, unsigned int val)
+static inline void snd_vx_outl(struct vx_core *chip, int reg, unsigned int val)
 {
 	snd_assert(chip->ops->out32, return);
 	chip->ops->out32(chip, reg, val);
@@ -274,25 +273,25 @@ static inline void snd_vx_outl(vx_core_t *chip, int reg, unsigned int val)
 #define vx_inl(chip,reg)	snd_vx_inl(chip, VX_##reg)
 #define vx_outl(chip,reg,val)	snd_vx_outl(chip, VX_##reg,val)
 
-static inline void vx_reset_dsp(vx_core_t *chip)
+static inline void vx_reset_dsp(struct vx_core *chip)
 {
 	snd_assert(chip->ops->reset_dsp, return);
 	chip->ops->reset_dsp(chip);
 }
 
-int vx_send_msg(vx_core_t *chip, struct vx_rmh *rmh);
-int vx_send_msg_nolock(vx_core_t *chip, struct vx_rmh *rmh);
-int vx_send_rih(vx_core_t *chip, int cmd);
-int vx_send_rih_nolock(vx_core_t *chip, int cmd);
+int vx_send_msg(struct vx_core *chip, struct vx_rmh *rmh);
+int vx_send_msg_nolock(struct vx_core *chip, struct vx_rmh *rmh);
+int vx_send_rih(struct vx_core *chip, int cmd);
+int vx_send_rih_nolock(struct vx_core *chip, int cmd);
 
-void vx_reset_codec(vx_core_t *chip, int cold_reset);
+void vx_reset_codec(struct vx_core *chip, int cold_reset);
 
 /*
  * check the bit on the specified register
  * returns zero if a bit matches, or a negative error code.
  * exported for vxpocket driver
  */
-int snd_vx_check_reg_bit(vx_core_t *chip, int reg, int mask, int bit, int time);
+int snd_vx_check_reg_bit(struct vx_core *chip, int reg, int mask, int bit, int time);
 #define vx_check_isr(chip,mask,bit,time) snd_vx_check_reg_bit(chip, VX_ISR, mask, bit, time)
 #define vx_wait_isr_bit(chip,bit) vx_check_isr(chip, bit, bit, 200)
 #define vx_wait_for_rx_full(chip) vx_wait_isr_bit(chip, ISR_RX_FULL)
@@ -301,15 +300,15 @@ int snd_vx_check_reg_bit(vx_core_t *chip, int reg, int mask, int bit, int time);
 /*
  * pseudo-DMA transfer
  */
-static inline void vx_pseudo_dma_write(vx_core_t *chip, snd_pcm_runtime_t *runtime,
-				       vx_pipe_t *pipe, int count)
+static inline void vx_pseudo_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,
+				       struct vx_pipe *pipe, int count)
 {
 	snd_assert(chip->ops->dma_write, return);
 	chip->ops->dma_write(chip, runtime, pipe, count);
 }
 
-static inline void vx_pseudo_dma_read(vx_core_t *chip, snd_pcm_runtime_t *runtime,
-				      vx_pipe_t *pipe, int count)
+static inline void vx_pseudo_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,
+				      struct vx_pipe *pipe, int count)
 {
 	snd_assert(chip->ops->dma_read, return);
 	chip->ops->dma_read(chip, runtime, pipe, count);
@@ -327,24 +326,24 @@ static inline void vx_pseudo_dma_read(vx_core_t *chip, snd_pcm_runtime_t *runtim
 /*
  * pcm stuff
  */
-int snd_vx_pcm_new(vx_core_t *chip);
-void vx_pcm_update_intr(vx_core_t *chip, unsigned int events);
+int snd_vx_pcm_new(struct vx_core *chip);
+void vx_pcm_update_intr(struct vx_core *chip, unsigned int events);
 
 /*
  * mixer stuff
  */
-int snd_vx_mixer_new(vx_core_t *chip);
-void vx_toggle_dac_mute(vx_core_t *chip, int mute);
-int vx_sync_audio_source(vx_core_t *chip);
-int vx_set_monitor_level(vx_core_t *chip, int audio, int level, int active);
+int snd_vx_mixer_new(struct vx_core *chip);
+void vx_toggle_dac_mute(struct vx_core *chip, int mute);
+int vx_sync_audio_source(struct vx_core *chip);
+int vx_set_monitor_level(struct vx_core *chip, int audio, int level, int active);
 
 /*
  * IEC958 & clock stuff
  */
-void vx_set_iec958_status(vx_core_t *chip, unsigned int bits);
-int vx_set_clock(vx_core_t *chip, unsigned int freq);
-void vx_set_internal_clock(vx_core_t *chip, unsigned int freq);
-int vx_change_frequency(vx_core_t *chip);
+void vx_set_iec958_status(struct vx_core *chip, unsigned int bits);
+int vx_set_clock(struct vx_core *chip, unsigned int freq);
+void vx_set_internal_clock(struct vx_core *chip, unsigned int freq);
+int vx_change_frequency(struct vx_core *chip);
 
 
 /*

commit bdbae7e62837c22c5399df0789a24e9d8a1d675f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 10:21:19 2005 +0100

    [ALSA] Remove snd_vx_delay() function
    
    Replace snd_vx_delay() with appropriate delay/sleep functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/vx_core.h b/include/sound/vx_core.h
index 7a60a3888667..43c901bf7c1f 100644
--- a/include/sound/vx_core.h
+++ b/include/sound/vx_core.h
@@ -274,8 +274,6 @@ static inline void snd_vx_outl(vx_core_t *chip, int reg, unsigned int val)
 #define vx_inl(chip,reg)	snd_vx_inl(chip, VX_##reg)
 #define vx_outl(chip,reg,val)	snd_vx_outl(chip, VX_##reg,val)
 
-void snd_vx_delay(vx_core_t *chip, int msec);
-
 static inline void vx_reset_dsp(vx_core_t *chip)
 {
 	snd_assert(chip->ops->reset_dsp, return);

commit 77933d7276ee8fa0e2947641941a6f7a100a327b
Author: Jesper Juhl <juhl@dif.dk>
Date:   Wed Jul 27 11:46:09 2005 -0700

    [PATCH] clean up inline static vs static inline
    
    `gcc -W' likes to complain if the static keyword is not at the beginning of
    the declaration.  This patch fixes all remaining occurrences of "inline
    static" up with "static inline" in the entire kernel tree (140 occurrences in
    47 files).
    
    While making this change I came across a few lines with trailing whitespace
    that I also fixed up, I have also added or removed a blank line or two here
    and there, but there are no functional changes in the patch.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/sound/vx_core.h b/include/sound/vx_core.h
index a7e29933f2d0..7a60a3888667 100644
--- a/include/sound/vx_core.h
+++ b/include/sound/vx_core.h
@@ -233,37 +233,37 @@ irqreturn_t snd_vx_irq_handler(int irq, void *dev, struct pt_regs *regs);
 /*
  * lowlevel functions
  */
-inline static int vx_test_and_ack(vx_core_t *chip)
+static inline int vx_test_and_ack(vx_core_t *chip)
 {
 	snd_assert(chip->ops->test_and_ack, return -ENXIO);
 	return chip->ops->test_and_ack(chip);
 }
 
-inline static void vx_validate_irq(vx_core_t *chip, int enable)
+static inline void vx_validate_irq(vx_core_t *chip, int enable)
 {
 	snd_assert(chip->ops->validate_irq, return);
 	chip->ops->validate_irq(chip, enable);
 }
 
-inline static unsigned char snd_vx_inb(vx_core_t *chip, int reg)
+static inline unsigned char snd_vx_inb(vx_core_t *chip, int reg)
 {
 	snd_assert(chip->ops->in8, return 0);
 	return chip->ops->in8(chip, reg);
 }
 
-inline static unsigned int snd_vx_inl(vx_core_t *chip, int reg)
+static inline unsigned int snd_vx_inl(vx_core_t *chip, int reg)
 {
 	snd_assert(chip->ops->in32, return 0);
 	return chip->ops->in32(chip, reg);
 }
 
-inline static void snd_vx_outb(vx_core_t *chip, int reg, unsigned char val)
+static inline void snd_vx_outb(vx_core_t *chip, int reg, unsigned char val)
 {
 	snd_assert(chip->ops->out8, return);
 	chip->ops->out8(chip, reg, val);
 }
 
-inline static void snd_vx_outl(vx_core_t *chip, int reg, unsigned int val)
+static inline void snd_vx_outl(vx_core_t *chip, int reg, unsigned int val)
 {
 	snd_assert(chip->ops->out32, return);
 	chip->ops->out32(chip, reg, val);
@@ -303,14 +303,14 @@ int snd_vx_check_reg_bit(vx_core_t *chip, int reg, int mask, int bit, int time);
 /*
  * pseudo-DMA transfer
  */
-inline static void vx_pseudo_dma_write(vx_core_t *chip, snd_pcm_runtime_t *runtime,
+static inline void vx_pseudo_dma_write(vx_core_t *chip, snd_pcm_runtime_t *runtime,
 				       vx_pipe_t *pipe, int count)
 {
 	snd_assert(chip->ops->dma_write, return);
 	chip->ops->dma_write(chip, runtime, pipe, count);
 }
 
-inline static void vx_pseudo_dma_read(vx_core_t *chip, snd_pcm_runtime_t *runtime,
+static inline void vx_pseudo_dma_read(vx_core_t *chip, snd_pcm_runtime_t *runtime,
 				      vx_pipe_t *pipe, int count)
 {
 	snd_assert(chip->ops->dma_read, return);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/sound/vx_core.h b/include/sound/vx_core.h
new file mode 100644
index 000000000000..a7e29933f2d0
--- /dev/null
+++ b/include/sound/vx_core.h
@@ -0,0 +1,562 @@
+/*
+ * Driver for Digigram VX soundcards
+ *
+ * Hardware core part
+ *
+ * Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef __SOUND_VX_COMMON_H
+#define __SOUND_VX_COMMON_H
+
+#include <sound/pcm.h>
+#include <sound/hwdep.h>
+#include <linux/interrupt.h>
+
+#if defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE)
+#if !defined(CONFIG_USE_VXLOADER) && !defined(CONFIG_SND_VX_LIB) /* built-in kernel */
+#define SND_VX_FW_LOADER	/* use the standard firmware loader */
+#endif
+#endif
+
+struct firmware;
+struct device;
+
+typedef struct snd_vx_core vx_core_t;
+typedef struct vx_pipe vx_pipe_t;
+
+#define VX_DRIVER_VERSION	0x010000	/* 1.0.0 */
+
+/*
+ */
+#define SIZE_MAX_CMD    0x10
+#define SIZE_MAX_STATUS 0x10
+
+struct vx_rmh {
+	u16	LgCmd;		/* length of the command to send (WORDs) */
+	u16	LgStat;		/* length of the status received (WORDs) */
+	u32	Cmd[SIZE_MAX_CMD];
+	u32	Stat[SIZE_MAX_STATUS];
+	u16	DspStat;	/* status type, RMP_SSIZE_XXX */
+};
+	
+typedef u64 pcx_time_t;
+
+#define VX_MAX_PIPES	16
+#define VX_MAX_PERIODS	32
+#define VX_MAX_CODECS	2
+
+struct vx_ibl_info {
+	int size;	/* the current IBL size (0 = query) in bytes */
+	int max_size;	/* max. IBL size in bytes */
+	int min_size;	/* min. IBL size in bytes */
+	int granularity;	/* granularity */
+};
+
+struct vx_pipe {
+	int number;
+	unsigned int is_capture: 1;
+	unsigned int data_mode: 1;
+	unsigned int running: 1;
+	unsigned int prepared: 1;
+	int channels;
+	unsigned int differed_type;
+	pcx_time_t pcx_time;
+	snd_pcm_substream_t *substream;
+
+	int hbuf_size;		/* H-buffer size in bytes */
+	int buffer_bytes;	/* the ALSA pcm buffer size in bytes */
+	int period_bytes;	/* the ALSA pcm period size in bytes */
+	int hw_ptr;		/* the current hardware pointer in bytes */
+	int position;		/* the current position in frames (playback only) */
+	int transferred;	/* the transferred size (per period) in frames */
+	int align;		/* size of alignment */
+	u64 cur_count;		/* current sample position (for playback) */
+
+	unsigned int references;     /* an output pipe may be used for monitoring and/or playback */
+	vx_pipe_t *monitoring_pipe;  /* pointer to the monitoring pipe (capture pipe only)*/
+
+	struct tasklet_struct start_tq;
+};
+
+struct snd_vx_ops {
+	/* low-level i/o */
+	unsigned char (*in8)(vx_core_t *chip, int reg);
+	unsigned int (*in32)(vx_core_t *chip, int reg);
+	void (*out8)(vx_core_t *chip, int reg, unsigned char val);
+	void (*out32)(vx_core_t *chip, int reg, unsigned int val);
+	/* irq */
+	int (*test_and_ack)(vx_core_t *chip);
+	void (*validate_irq)(vx_core_t *chip, int enable);
+	/* codec */
+	void (*write_codec)(vx_core_t *chip, int codec, unsigned int data);
+	void (*akm_write)(vx_core_t *chip, int reg, unsigned int data);
+	void (*reset_codec)(vx_core_t *chip);
+	void (*change_audio_source)(vx_core_t *chip, int src);
+	void (*set_clock_source)(vx_core_t *chp, int src);
+	/* chip init */
+	int (*load_dsp)(vx_core_t *chip, int idx, const struct firmware *fw);
+	void (*reset_dsp)(vx_core_t *chip);
+	void (*reset_board)(vx_core_t *chip, int cold_reset);
+	int (*add_controls)(vx_core_t *chip);
+	/* pcm */
+	void (*dma_write)(vx_core_t *chip, snd_pcm_runtime_t *runtime,
+			  vx_pipe_t *pipe, int count);
+	void (*dma_read)(vx_core_t *chip, snd_pcm_runtime_t *runtime,
+			  vx_pipe_t *pipe, int count);
+};
+
+struct snd_vx_hardware {
+	const char *name;
+	int type;	/* VX_TYPE_XXX */
+
+	/* hardware specs */
+	unsigned int num_codecs;
+	unsigned int num_ins;
+	unsigned int num_outs;
+	unsigned int output_level_max;
+};
+
+/* hwdep id string */
+#define SND_VX_HWDEP_ID		"VX Loader"
+
+/* hardware type */
+enum {
+	/* VX222 PCI */
+	VX_TYPE_BOARD,		/* old VX222 PCI */
+	VX_TYPE_V2,		/* VX222 V2 PCI */
+	VX_TYPE_MIC,		/* VX222 Mic PCI */
+	/* VX-pocket */
+	VX_TYPE_VXPOCKET,	/* VXpocket V2 */
+	VX_TYPE_VXP440,		/* VXpocket 440 */
+	VX_TYPE_NUMS
+};
+
+/* chip status */
+enum {
+	VX_STAT_XILINX_LOADED	= (1 << 0),	/* devices are registered */
+	VX_STAT_DEVICE_INIT	= (1 << 1),	/* devices are registered */
+	VX_STAT_CHIP_INIT	= (1 << 2),	/* all operational */
+	VX_STAT_IN_SUSPEND	= (1 << 10),	/* in suspend phase */
+	VX_STAT_IS_STALE	= (1 << 15)	/* device is stale */
+};
+
+/* min/max values for analog output for old codecs */
+#define VX_ANALOG_OUT_LEVEL_MAX		0xe3
+
+struct snd_vx_core {
+	/* ALSA stuff */
+	snd_card_t *card;
+	snd_pcm_t *pcm[VX_MAX_CODECS];
+	int type;	/* VX_TYPE_XXX */
+
+	int irq;
+	/* ports are defined externally */
+
+	/* low-level functions */
+	struct snd_vx_hardware *hw;
+	struct snd_vx_ops *ops;
+
+	spinlock_t lock;
+	spinlock_t irq_lock;
+	struct tasklet_struct tq;
+
+	unsigned int chip_status;
+	unsigned int pcm_running;
+
+	struct device *dev;
+	snd_hwdep_t *hwdep;
+
+	struct vx_rmh irq_rmh;	/* RMH used in interrupts */
+
+	unsigned int audio_info; /* see VX_AUDIO_INFO */
+	unsigned int audio_ins;
+	unsigned int audio_outs;
+	struct vx_pipe **playback_pipes;
+	struct vx_pipe **capture_pipes;
+
+	/* clock and audio sources */
+	unsigned int audio_source;	/* current audio input source */
+	unsigned int audio_source_target;
+	unsigned int clock_mode;	/* clock mode (VX_CLOCK_MODE_XXX) */
+	unsigned int clock_source;	/* current clock source (INTERNAL_QUARTZ or UER_SYNC) */
+	unsigned int freq;		/* current frequency */
+	unsigned int freq_detected;	/* detected frequency from digital in */
+	unsigned int uer_detected;	/* VX_UER_MODE_XXX */
+	unsigned int uer_bits;	/* IEC958 status bits */
+	struct vx_ibl_info ibl;	/* IBL information */
+
+	/* mixer setting */
+	int output_level[VX_MAX_CODECS][2];	/* analog output level */
+	int audio_gain[2][4];			/* digital audio level (playback/capture) */
+	unsigned char audio_active[4];		/* mute/unmute on digital playback */
+	int audio_monitor[4];			/* playback hw-monitor level */
+	unsigned char audio_monitor_active[4];	/* playback hw-monitor mute/unmute */
+
+	struct semaphore mixer_mutex;
+
+	const struct firmware *firmware[4]; /* loaded firmware data */
+};
+
+
+/*
+ * constructor
+ */
+vx_core_t *snd_vx_create(snd_card_t *card, struct snd_vx_hardware *hw,
+			 struct snd_vx_ops *ops, int extra_size);
+int snd_vx_setup_firmware(vx_core_t *chip);
+int snd_vx_load_boot_image(vx_core_t *chip, const struct firmware *dsp);
+int snd_vx_dsp_boot(vx_core_t *chip, const struct firmware *dsp);
+int snd_vx_dsp_load(vx_core_t *chip, const struct firmware *dsp);
+
+void snd_vx_free_firmware(vx_core_t *chip);
+
+/*
+ * interrupt handler; exported for pcmcia
+ */
+irqreturn_t snd_vx_irq_handler(int irq, void *dev, struct pt_regs *regs);
+
+/*
+ * lowlevel functions
+ */
+inline static int vx_test_and_ack(vx_core_t *chip)
+{
+	snd_assert(chip->ops->test_and_ack, return -ENXIO);
+	return chip->ops->test_and_ack(chip);
+}
+
+inline static void vx_validate_irq(vx_core_t *chip, int enable)
+{
+	snd_assert(chip->ops->validate_irq, return);
+	chip->ops->validate_irq(chip, enable);
+}
+
+inline static unsigned char snd_vx_inb(vx_core_t *chip, int reg)
+{
+	snd_assert(chip->ops->in8, return 0);
+	return chip->ops->in8(chip, reg);
+}
+
+inline static unsigned int snd_vx_inl(vx_core_t *chip, int reg)
+{
+	snd_assert(chip->ops->in32, return 0);
+	return chip->ops->in32(chip, reg);
+}
+
+inline static void snd_vx_outb(vx_core_t *chip, int reg, unsigned char val)
+{
+	snd_assert(chip->ops->out8, return);
+	chip->ops->out8(chip, reg, val);
+}
+
+inline static void snd_vx_outl(vx_core_t *chip, int reg, unsigned int val)
+{
+	snd_assert(chip->ops->out32, return);
+	chip->ops->out32(chip, reg, val);
+}
+
+#define vx_inb(chip,reg)	snd_vx_inb(chip, VX_##reg)
+#define vx_outb(chip,reg,val)	snd_vx_outb(chip, VX_##reg,val)
+#define vx_inl(chip,reg)	snd_vx_inl(chip, VX_##reg)
+#define vx_outl(chip,reg,val)	snd_vx_outl(chip, VX_##reg,val)
+
+void snd_vx_delay(vx_core_t *chip, int msec);
+
+static inline void vx_reset_dsp(vx_core_t *chip)
+{
+	snd_assert(chip->ops->reset_dsp, return);
+	chip->ops->reset_dsp(chip);
+}
+
+int vx_send_msg(vx_core_t *chip, struct vx_rmh *rmh);
+int vx_send_msg_nolock(vx_core_t *chip, struct vx_rmh *rmh);
+int vx_send_rih(vx_core_t *chip, int cmd);
+int vx_send_rih_nolock(vx_core_t *chip, int cmd);
+
+void vx_reset_codec(vx_core_t *chip, int cold_reset);
+
+/*
+ * check the bit on the specified register
+ * returns zero if a bit matches, or a negative error code.
+ * exported for vxpocket driver
+ */
+int snd_vx_check_reg_bit(vx_core_t *chip, int reg, int mask, int bit, int time);
+#define vx_check_isr(chip,mask,bit,time) snd_vx_check_reg_bit(chip, VX_ISR, mask, bit, time)
+#define vx_wait_isr_bit(chip,bit) vx_check_isr(chip, bit, bit, 200)
+#define vx_wait_for_rx_full(chip) vx_wait_isr_bit(chip, ISR_RX_FULL)
+
+
+/*
+ * pseudo-DMA transfer
+ */
+inline static void vx_pseudo_dma_write(vx_core_t *chip, snd_pcm_runtime_t *runtime,
+				       vx_pipe_t *pipe, int count)
+{
+	snd_assert(chip->ops->dma_write, return);
+	chip->ops->dma_write(chip, runtime, pipe, count);
+}
+
+inline static void vx_pseudo_dma_read(vx_core_t *chip, snd_pcm_runtime_t *runtime,
+				      vx_pipe_t *pipe, int count)
+{
+	snd_assert(chip->ops->dma_read, return);
+	chip->ops->dma_read(chip, runtime, pipe, count);
+}
+
+
+
+/* error with hardware code,
+ * the return value is -(VX_ERR_MASK | actual-hw-error-code)
+ */
+#define VX_ERR_MASK	0x1000000
+#define vx_get_error(err)	(-(err) & ~VX_ERR_MASK)
+
+
+/*
+ * pcm stuff
+ */
+int snd_vx_pcm_new(vx_core_t *chip);
+void vx_pcm_update_intr(vx_core_t *chip, unsigned int events);
+
+/*
+ * mixer stuff
+ */
+int snd_vx_mixer_new(vx_core_t *chip);
+void vx_toggle_dac_mute(vx_core_t *chip, int mute);
+int vx_sync_audio_source(vx_core_t *chip);
+int vx_set_monitor_level(vx_core_t *chip, int audio, int level, int active);
+
+/*
+ * IEC958 & clock stuff
+ */
+void vx_set_iec958_status(vx_core_t *chip, unsigned int bits);
+int vx_set_clock(vx_core_t *chip, unsigned int freq);
+void vx_set_internal_clock(vx_core_t *chip, unsigned int freq);
+int vx_change_frequency(vx_core_t *chip);
+
+
+/*
+ * hardware constants
+ */
+
+#define vx_has_new_dsp(chip)	((chip)->type != VX_TYPE_BOARD)
+#define vx_is_pcmcia(chip)	((chip)->type >= VX_TYPE_VXPOCKET)
+
+/* audio input source */
+enum {
+	VX_AUDIO_SRC_DIGITAL,
+	VX_AUDIO_SRC_LINE,
+	VX_AUDIO_SRC_MIC
+};
+
+/* clock source */
+enum {
+	INTERNAL_QUARTZ,
+	UER_SYNC
+};
+
+/* clock mode */
+enum {
+	VX_CLOCK_MODE_AUTO,	/* depending on the current audio source */
+	VX_CLOCK_MODE_INTERNAL,	/* fixed to internal quartz */
+	VX_CLOCK_MODE_EXTERNAL	/* fixed to UER sync */
+};
+
+/* SPDIF/UER type */
+enum {
+	VX_UER_MODE_CONSUMER,
+	VX_UER_MODE_PROFESSIONAL,
+	VX_UER_MODE_NOT_PRESENT,
+};
+
+/* register indices */
+enum {
+	VX_ICR,
+	VX_CVR,
+	VX_ISR,
+	VX_IVR,
+	VX_RXH,
+	VX_TXH = VX_RXH,
+	VX_RXM,
+	VX_TXM = VX_RXM,
+	VX_RXL,
+	VX_TXL = VX_RXL,
+	VX_DMA,
+	VX_CDSP,
+	VX_RFREQ,
+	VX_RUER_V2,
+	VX_GAIN,
+	VX_DATA = VX_GAIN,
+	VX_MEMIRQ,
+	VX_ACQ,
+	VX_BIT0,
+	VX_BIT1,
+	VX_MIC0,
+	VX_MIC1,
+	VX_MIC2,
+	VX_MIC3,
+	VX_PLX0,
+	VX_PLX1,
+	VX_PLX2,
+
+	VX_LOFREQ,  // V2: ACQ, VP: RFREQ
+	VX_HIFREQ,  // V2: BIT0, VP: RUER_V2
+	VX_CSUER,   // V2: BIT1, VP: BIT0
+	VX_RUER,    // V2: RUER_V2, VP: BIT1
+
+	VX_REG_MAX,
+
+	/* aliases for VX board */
+	VX_RESET_DMA = VX_ISR,
+	VX_CFG = VX_RFREQ,
+	VX_STATUS = VX_MEMIRQ,
+	VX_SELMIC = VX_MIC0,
+	VX_COMPOT = VX_MIC1,
+	VX_SCOMPR = VX_MIC2,
+	VX_GLIMIT = VX_MIC3,
+	VX_INTCSR = VX_PLX0,
+	VX_CNTRL = VX_PLX1,
+	VX_GPIOC = VX_PLX2,
+
+	/* aliases for VXPOCKET board */
+	VX_MICRO = VX_MEMIRQ,
+	VX_CODEC2 = VX_MEMIRQ,
+	VX_DIALOG = VX_ACQ,
+
+};
+
+/* RMH status type */
+enum {
+	RMH_SSIZE_FIXED = 0,	/* status size given by the driver (in LgStat) */
+	RMH_SSIZE_ARG = 1,	/* status size given in the LSB byte */
+	RMH_SSIZE_MASK = 2,	/* status size given in bitmask */
+};
+
+
+/* bits for ICR register */
+#define ICR_HF1		0x10
+#define ICR_HF0		0x08
+#define ICR_TREQ	0x02	/* Interrupt mode + HREQ set on for transfer (->DSP) request */
+#define ICR_RREQ	0x01	/* Interrupt mode + RREQ set on for transfer (->PC) request */
+
+/* bits for CVR register */
+#define CVR_HC		0x80
+
+/* bits for ISR register */
+#define ISR_HF3		0x10
+#define ISR_HF2		0x08
+#define ISR_CHK		0x10
+#define ISR_ERR		0x08
+#define ISR_TX_READY	0x04
+#define ISR_TX_EMPTY	0x02
+#define ISR_RX_FULL	0x01
+
+/* Constants used to access the DATA register */
+#define VX_DATA_CODEC_MASK	0x80
+#define VX_DATA_XICOR_MASK	0x80
+
+/* Constants used to access the CSUER register (both for VX2 and VXP) */
+#define VX_SUER_FREQ_MASK		0x0c
+#define VX_SUER_FREQ_32KHz_MASK		0x0c
+#define VX_SUER_FREQ_44KHz_MASK		0x00
+#define VX_SUER_FREQ_48KHz_MASK		0x04
+#define VX_SUER_DATA_PRESENT_MASK	0x02
+#define VX_SUER_CLOCK_PRESENT_MASK	0x01
+
+#define VX_CUER_HH_BITC_SEL_MASK	0x08
+#define VX_CUER_MH_BITC_SEL_MASK	0x04
+#define VX_CUER_ML_BITC_SEL_MASK	0x02
+#define VX_CUER_LL_BITC_SEL_MASK	0x01
+
+#define XX_UER_CBITS_OFFSET_MASK	0x1f
+
+
+/* bits for audio_info */
+#define VX_AUDIO_INFO_REAL_TIME	(1<<0)	/* real-time processing available */
+#define VX_AUDIO_INFO_OFFLINE	(1<<1)	/* offline processing available */
+#define VX_AUDIO_INFO_MPEG1	(1<<5)
+#define VX_AUDIO_INFO_MPEG2	(1<<6)
+#define VX_AUDIO_INFO_LINEAR_8	(1<<7)
+#define VX_AUDIO_INFO_LINEAR_16	(1<<8)
+#define VX_AUDIO_INFO_LINEAR_24	(1<<9)
+
+/* DSP Interrupt Request values */
+#define VXP_IRQ_OFFSET		0x40 /* add 0x40 offset for vxpocket and vx222/v2 */
+/* call with vx_send_irq_dsp() */
+#define IRQ_MESS_WRITE_END          0x30
+#define IRQ_MESS_WRITE_NEXT         0x32
+#define IRQ_MESS_READ_NEXT          0x34
+#define IRQ_MESS_READ_END           0x36
+#define IRQ_MESSAGE                 0x38
+#define IRQ_RESET_CHK               0x3A
+#define IRQ_CONNECT_STREAM_NEXT     0x26
+#define IRQ_CONNECT_STREAM_END      0x28
+#define IRQ_PAUSE_START_CONNECT     0x2A
+#define IRQ_END_CONNECTION          0x2C
+
+/* Is there async. events pending ( IT Source Test ) */
+#define ASYNC_EVENTS_PENDING            0x008000
+#define HBUFFER_EVENTS_PENDING          0x004000   // Not always accurate
+#define NOTIF_EVENTS_PENDING            0x002000
+#define TIME_CODE_EVENT_PENDING         0x001000
+#define FREQUENCY_CHANGE_EVENT_PENDING  0x000800
+#define END_OF_BUFFER_EVENTS_PENDING    0x000400
+#define FATAL_DSP_ERROR                 0xff0000
+
+/* Stream Format Header Defines */ 
+#define HEADER_FMT_BASE			0xFED00000
+#define HEADER_FMT_MONO			0x000000C0
+#define HEADER_FMT_INTEL		0x00008000
+#define HEADER_FMT_16BITS		0x00002000
+#define HEADER_FMT_24BITS		0x00004000
+#define HEADER_FMT_UPTO11		0x00000200	/* frequency is less or equ. to 11k.*/
+#define HEADER_FMT_UPTO32		0x00000100	/* frequency is over 11k and less then 32k.*/
+
+/* Constants used to access the Codec */
+#define XX_CODEC_SELECTOR               0x20
+/* codec commands */
+#define XX_CODEC_ADC_CONTROL_REGISTER   0x01
+#define XX_CODEC_DAC_CONTROL_REGISTER   0x02
+#define XX_CODEC_LEVEL_LEFT_REGISTER    0x03
+#define XX_CODEC_LEVEL_RIGHT_REGISTER   0x04
+#define XX_CODEC_PORT_MODE_REGISTER     0x05
+#define XX_CODEC_STATUS_REPORT_REGISTER 0x06
+#define XX_CODEC_CLOCK_CONTROL_REGISTER 0x07
+
+/*
+ * Audio-level control values
+ */
+#define CVAL_M110DB		0x000	/* -110dB */
+#define CVAL_M99DB		0x02C
+#define CVAL_M21DB		0x163
+#define CVAL_M18DB		0x16F
+#define CVAL_M10DB		0x18F
+#define CVAL_0DB		0x1B7
+#define CVAL_18DB		0x1FF	/* +18dB */
+#define CVAL_MAX		0x1FF
+
+#define AUDIO_IO_HAS_MUTE_LEVEL			0x400000
+#define AUDIO_IO_HAS_MUTE_MONITORING_1		0x200000
+#define AUDIO_IO_HAS_MUTE_MONITORING_2		0x100000
+#define VALID_AUDIO_IO_DIGITAL_LEVEL		0x01
+#define VALID_AUDIO_IO_MONITORING_LEVEL		0x02
+#define VALID_AUDIO_IO_MUTE_LEVEL		0x04
+#define VALID_AUDIO_IO_MUTE_MONITORING_1	0x08
+#define VALID_AUDIO_IO_MUTE_MONITORING_2	0x10
+
+
+#endif /* __SOUND_VX_COMMON_H */
