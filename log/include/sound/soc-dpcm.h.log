commit f17a14789e55f45514d1d72a4e51dcc6bdd8d463
Author: Guennadi Liakhovetski <guennadi.liakhovetski@linux.intel.com>
Date:   Thu Mar 12 10:52:14 2020 +0100

    ASoC: export DPCM runtime update functions
    
    This makes DPCM runtime update functions available for external
    calling. As an example, virtualised ASoC component drivers may need
    to call these when managing shared DAPM routes that are used by more
    than one driver (i.e. when host driver and guest drivers have a DAPM
    path from guest PCM to host DAI where some parts are owned by host
    driver and others by guest driver).
    
    Signed-off-by: Guennadi Liakhovetski <guennadi.liakhovetski@linux.intel.com>
    Link: https://lore.kernel.org/r/20200312095214.15126-3-guennadi.liakhovetski@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index 40223577ec4a..0f6c50b17bba 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -132,8 +132,8 @@ int snd_soc_dpcm_be_can_update(struct snd_soc_pcm_runtime *fe,
 struct snd_pcm_substream *
 	snd_soc_dpcm_get_substream(struct snd_soc_pcm_runtime *be, int stream);
 
-/* internal use only */
-int soc_dpcm_runtime_update(struct snd_soc_card *);
+/* update audio routing between PCMs and any DAI links */
+int snd_soc_dpcm_runtime_update(struct snd_soc_card *card);
 
 #ifdef CONFIG_DEBUG_FS
 void soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd);

commit 52645e332d227a3d3cd345e97a10d99b7e80fae4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Feb 19 15:56:52 2020 +0900

    ASoC: soc-pcm: move dpcm_path_put() to soc-pcm.c
    
    dpcm_path_put() (A) is calling kfree(*list).
    The freed list is created by dapm_widget_list_create() (B) which is called
    from snd_soc_dapm_dai_get_connected_widgets() (C) which is called from
    dpcm_path_get() (D).
    
    (B)     dapm_widget_list_create(**list, ...)
            {
                    ...
    =>              *list = kzalloc();
                    ...
            }
    
    (C)     snd_soc_dapm_dai_get_connected_widgets(..., **list, ...)
            {
                    ...
                    dapm_widget_list_create(list, ...);
                    ...
            }
    
    (D)     dpcm_path_get(..., **list)
            {
                    ...
                    snd_soc_dapm_dai_get_connected_widgets(..., list, ...);
                    ...
            }
    
    (A)     dpcm_path_put(**list)
            {
    =>              kfree(*list);
            }
    
    This kind of unbalance code is very difficult to read/understand.
    To avoid this issue, this patch adds each missing paired function
    dapm_widget_list_free()         for dapm_widget_list_create() (B), and
    snd_soc_dapm_dai_free_widgets() for snd_soc_dapm_dai_get_connected_widgets() (C).
    
    This patch uses these, and moves dpcm_path_put() next to dpcm_path_get().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87a75fjc9q.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index 3e7819d2a6aa..40223577ec4a 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -145,6 +145,7 @@ static inline void soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd)
 
 int dpcm_path_get(struct snd_soc_pcm_runtime *fe,
 	int stream, struct snd_soc_dapm_widget_list **list_);
+void dpcm_path_put(struct snd_soc_dapm_widget_list **list);
 int dpcm_process_paths(struct snd_soc_pcm_runtime *fe,
 	int stream, struct snd_soc_dapm_widget_list **list, int new);
 int dpcm_be_dai_startup(struct snd_soc_pcm_runtime *fe, int stream);
@@ -158,10 +159,4 @@ int dpcm_be_dai_prepare(struct snd_soc_pcm_runtime *fe, int stream);
 int dpcm_dapm_stream_event(struct snd_soc_pcm_runtime *fe, int dir,
 	int event);
 
-static inline void dpcm_path_put(struct snd_soc_dapm_widget_list **list)
-{
-	kfree(*list);
-}
-
-
 #endif

commit 289a7e64f8583aaa45847c7fa3b7fabf8d48fd6b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Feb 17 17:28:04 2020 +0900

    ASoC: soc-pcm: remove snd_soc_dpcm_be_get/set_state()
    
    No one is using snd_soc_dpcm_be_get/set_state().
    If it exists only by assumption that "it may be necessary someday",
    let's remove it now. Otherwise code maintenance will be difficult.
    We can revive it when we really needed it.
    Let's remove it, so far.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87a75hbou7.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index 665516387671..3e7819d2a6aa 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -132,14 +132,6 @@ int snd_soc_dpcm_be_can_update(struct snd_soc_pcm_runtime *fe,
 struct snd_pcm_substream *
 	snd_soc_dpcm_get_substream(struct snd_soc_pcm_runtime *be, int stream);
 
-/* get the BE runtime state */
-enum snd_soc_dpcm_state
-	snd_soc_dpcm_be_get_state(struct snd_soc_pcm_runtime *be, int stream);
-
-/* set the BE runtime state */
-void snd_soc_dpcm_be_set_state(struct snd_soc_pcm_runtime *be, int stream,
-	enum snd_soc_dpcm_state state);
-
 /* internal use only */
 int soc_dpcm_runtime_update(struct snd_soc_card *);
 

commit c9645d2a952b7925b6708b24242cd5ed04975648
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Feb 17 17:27:57 2020 +0900

    ASoC: soc-pcm: remove soc_dpcm_be_digital_mute()
    
    No one is using soc_dpcm_be_digital_mute().
    If it exists only by assumption that "it may be necessary someday",
    let's remove it now. Otherwise code maintenance will be difficult.
    We can revive it when we really needed it.
    Let's remove it, so far.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87blpxbouc.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index b654ebfc8766..665516387671 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -141,7 +141,6 @@ void snd_soc_dpcm_be_set_state(struct snd_soc_pcm_runtime *be, int stream,
 	enum snd_soc_dpcm_state state);
 
 /* internal use only */
-int soc_dpcm_be_digital_mute(struct snd_soc_pcm_runtime *fe, int mute);
 int soc_dpcm_runtime_update(struct snd_soc_card *);
 
 #ifdef CONFIG_DEBUG_FS

commit 4baabbf932ed4f97df8e18cf546d39b7c2138020
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Oct 25 09:56:10 2019 +0900

    ASoC: soc-dpcm: tidyup for_each_dpcm_xx() macro
    
    for_each_dpcm_xx() macro is using "dpcm" as parameter (1),
    but, it is also struct member (2).
    
            #define for_each_dpcm_fe(be, stream, dpcm) \
            list_for_each_entry(dpcm, &(be)->dpcm[stream]...)
                                ^^^^(1)      ^^^^(2)
    
    Thus, it will be compile error if user not used "dpcm" as parameter
    
            for_each_dpcm_fe(be, stream, dp)
                                         ^^
    This patch fixup it.
    
    Reported-by: Pavel Machek <pavel@denx.de>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87tv7x7idx.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index e55aeb00ce2d..b654ebfc8766 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -103,15 +103,15 @@ struct snd_soc_dpcm_runtime {
 	int trigger_pending; /* trigger cmd + 1 if pending, 0 if not */
 };
 
-#define for_each_dpcm_fe(be, stream, dpcm)				\
-	list_for_each_entry(dpcm, &(be)->dpcm[stream].fe_clients, list_fe)
-
-#define for_each_dpcm_be(fe, stream, dpcm)				\
-	list_for_each_entry(dpcm, &(fe)->dpcm[stream].be_clients, list_be)
-#define for_each_dpcm_be_safe(fe, stream, dpcm, _dpcm)			\
-	list_for_each_entry_safe(dpcm, _dpcm, &(fe)->dpcm[stream].be_clients, list_be)
-#define for_each_dpcm_be_rollback(fe, stream, dpcm)			\
-	list_for_each_entry_continue_reverse(dpcm, &(fe)->dpcm[stream].be_clients, list_be)
+#define for_each_dpcm_fe(be, stream, _dpcm)				\
+	list_for_each_entry(_dpcm, &(be)->dpcm[stream].fe_clients, list_fe)
+
+#define for_each_dpcm_be(fe, stream, _dpcm)				\
+	list_for_each_entry(_dpcm, &(fe)->dpcm[stream].be_clients, list_be)
+#define for_each_dpcm_be_safe(fe, stream, _dpcm, __dpcm)			\
+	list_for_each_entry_safe(_dpcm, __dpcm, &(fe)->dpcm[stream].be_clients, list_be)
+#define for_each_dpcm_be_rollback(fe, stream, _dpcm)			\
+	list_for_each_entry_continue_reverse(_dpcm, &(fe)->dpcm[stream].be_clients, list_be)
 
 /* can this BE stop and free */
 int snd_soc_dpcm_can_be_free_stop(struct snd_soc_pcm_runtime *fe,

commit ee5b3f11416d1ba69e919b2fe86aae0b46f9a83e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 7 10:31:31 2019 +0900

    ASoC: soc-core: define soc_dpcm_debugfs_add() for non CONFIG_DEBUG_FS
    
    soc_dpcm_debugfs_add() is implemented at soc-pcm.c under CONFIG_DEBUG_FS.
    Thus, soc-core.c which is only user of it need to use CONFIG_DEBUG_FS, too.
    
    This patch defines soc_dpcm_debugfs_add() for non CONFIG_DEBUG_FS case.
    Then, we can remove #ifdef CONFIG_DEBUG_FS from soc-core.c
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/875zn9ahnv.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index 4be3a2b7c106..e55aeb00ce2d 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -142,9 +142,16 @@ void snd_soc_dpcm_be_set_state(struct snd_soc_pcm_runtime *be, int stream,
 
 /* internal use only */
 int soc_dpcm_be_digital_mute(struct snd_soc_pcm_runtime *fe, int mute);
-void soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd);
 int soc_dpcm_runtime_update(struct snd_soc_card *);
 
+#ifdef CONFIG_DEBUG_FS
+void soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd);
+#else
+static inline void soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd)
+{
+}
+#endif
+
 int dpcm_path_get(struct snd_soc_pcm_runtime *fe,
 	int stream, struct snd_soc_dapm_widget_list **list_);
 int dpcm_process_paths(struct snd_soc_pcm_runtime *fe,

commit 8d6258a4dd267838e2f10643c3d91b79fe75ef6e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 18 01:31:09 2018 +0000

    ASoC: add for_each_dpcm_be() macro
    
    To be more readable code, this patch adds
    new for_each_dpcm_be() macro, and replace existing code to it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index f130de6cfe8e..4be3a2b7c106 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -106,6 +106,13 @@ struct snd_soc_dpcm_runtime {
 #define for_each_dpcm_fe(be, stream, dpcm)				\
 	list_for_each_entry(dpcm, &(be)->dpcm[stream].fe_clients, list_fe)
 
+#define for_each_dpcm_be(fe, stream, dpcm)				\
+	list_for_each_entry(dpcm, &(fe)->dpcm[stream].be_clients, list_be)
+#define for_each_dpcm_be_safe(fe, stream, dpcm, _dpcm)			\
+	list_for_each_entry_safe(dpcm, _dpcm, &(fe)->dpcm[stream].be_clients, list_be)
+#define for_each_dpcm_be_rollback(fe, stream, dpcm)			\
+	list_for_each_entry_continue_reverse(dpcm, &(fe)->dpcm[stream].be_clients, list_be)
+
 /* can this BE stop and free */
 int snd_soc_dpcm_can_be_free_stop(struct snd_soc_pcm_runtime *fe,
 		struct snd_soc_pcm_runtime *be, int stream);

commit d2e24d64652bf9d272e5496ae8a562bc64facff3
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 18 01:30:54 2018 +0000

    ASoC: add for_each_dpcm_fe() macro
    
    To be more readable code, this patch adds
    new for_each_dpcm_fe() macro, and replace existing code to it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index 9bb92f187af8..f130de6cfe8e 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -103,6 +103,9 @@ struct snd_soc_dpcm_runtime {
 	int trigger_pending; /* trigger cmd + 1 if pending, 0 if not */
 };
 
+#define for_each_dpcm_fe(be, stream, dpcm)				\
+	list_for_each_entry(dpcm, &(be)->dpcm[stream].fe_clients, list_fe)
+
 /* can this BE stop and free */
 int snd_soc_dpcm_can_be_free_stop(struct snd_soc_pcm_runtime *fe,
 		struct snd_soc_pcm_runtime *be, int stream);

commit b53c34b4b73eb65e6480ada6ec8ddbcc2d4e9817
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 2 06:22:58 2018 +0000

    ASoC: soc-dpcm.h: convert to SPDX identifiers
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index 806059052bfc..9bb92f187af8 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -1,11 +1,8 @@
-/*
+/* SPDX-License-Identifier: GPL-2.0
+ *
  * linux/sound/soc-dpcm.h -- ALSA SoC Dynamic PCM Support
  *
  * Author:		Liam Girdwood <lrg@ti.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef __LINUX_SND_SOC_DPCM_H

commit 2e55b90a5e234524f8195c657006ec4f71103dff
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Apr 9 10:52:37 2015 +0200

    ASoC: Make soc_dpcm_debugfs_add() non-fatal
    
    Failing to register the debugfs entries is not fatal and will not affect
    normal operation of the sound card. Don't abort the card registration if
    soc_dpcm_debugfs_add() fails.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index 98f2ade0266e..806059052bfc 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -135,7 +135,7 @@ void snd_soc_dpcm_be_set_state(struct snd_soc_pcm_runtime *be, int stream,
 
 /* internal use only */
 int soc_dpcm_be_digital_mute(struct snd_soc_pcm_runtime *fe, int mute);
-int soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd);
+void soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd);
 int soc_dpcm_runtime_update(struct snd_soc_card *);
 
 int dpcm_path_get(struct snd_soc_pcm_runtime *fe,

commit ea9d0d771fcd32cd56070819749477d511ec9117
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 4 16:52:28 2014 +0100

    ASoC: dpcm: Fix race between FE/BE updates and trigger
    
    DPCM can update the FE/BE connection states totally asynchronously
    from the FE's PCM state.  Most of FE/BE state changes are protected by
    mutex, so that they won't race, but there are still some actions that
    are uncovered.  For example, suppose to switch a BE while a FE's
    stream is running.  This would call soc_dpcm_runtime_update(), which
    sets FE's runtime_update flag, then sets up and starts BEs, and clears
    FE's runtime_update flag again.
    
    When a device emits XRUN during this operation, the PCM core triggers
    snd_pcm_stop(XRUN).  Since the trigger action is an atomic ops, this
    isn't blocked by the mutex, thus it kicks off DPCM's trigger action.
    It eventually updates and clears FE's runtime_update flag while
    soc_dpcm_runtime_update() is running concurrently, and it results in
    confusion.
    
    Usually, for avoiding such a race, we take a lock.  There is a PCM
    stream lock for that purpose.  However, as already mentioned, the
    trigger action is atomic, and we can't take the lock for the whole
    soc_dpcm_runtime_update() or other operations that include the lengthy
    jobs like hw_params or prepare.
    
    This patch provides an alternative solution.  This adds a way to defer
    the conflicting trigger callback to be executed at the end of FE/BE
    state changes.  For doing it, two things are introduced:
    
    - Each runtime_update state change of FEs is protected via PCM stream
      lock.
    - The FE's trigger callback checks the runtime_update flag.  If it's
      not set, the trigger action is executed there.  If set, mark the
      pending trigger action and returns immediately.
    - At the exit of runtime_update state change, it checks whether the
      pending trigger is present.  If yes, it executes the trigger action
      at this point.
    
    Reported-and-tested-by: Qiao Zhou <zhouqiao@marvell.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index 2883a7a6f9f3..98f2ade0266e 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -102,6 +102,8 @@ struct snd_soc_dpcm_runtime {
 	/* state and update */
 	enum snd_soc_dpcm_update runtime_update;
 	enum snd_soc_dpcm_state state;
+
+	int trigger_pending; /* trigger cmd + 1 if pending, 0 if not */
 };
 
 /* can this BE stop and free */

commit 23607025303af6e84bc2cd4cabe89c21f6a22a3f
Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date:   Fri Jan 17 17:03:55 2014 +0000

    ASoC: DPCM: make some DPCM API calls non static for compressed usage
    
    The ASoC compressed code needs to call the internal DPCM APIs in order to
    dynamically route compressed data to different DAIs.
    
    Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index 047d657c331c..2883a7a6f9f3 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -11,6 +11,7 @@
 #ifndef __LINUX_SND_SOC_DPCM_H
 #define __LINUX_SND_SOC_DPCM_H
 
+#include <linux/slab.h>
 #include <linux/list.h>
 #include <sound/pcm.h>
 
@@ -135,4 +136,25 @@ int soc_dpcm_be_digital_mute(struct snd_soc_pcm_runtime *fe, int mute);
 int soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd);
 int soc_dpcm_runtime_update(struct snd_soc_card *);
 
+int dpcm_path_get(struct snd_soc_pcm_runtime *fe,
+	int stream, struct snd_soc_dapm_widget_list **list_);
+int dpcm_process_paths(struct snd_soc_pcm_runtime *fe,
+	int stream, struct snd_soc_dapm_widget_list **list, int new);
+int dpcm_be_dai_startup(struct snd_soc_pcm_runtime *fe, int stream);
+int dpcm_be_dai_shutdown(struct snd_soc_pcm_runtime *fe, int stream);
+void dpcm_be_disconnect(struct snd_soc_pcm_runtime *fe, int stream);
+void dpcm_clear_pending_state(struct snd_soc_pcm_runtime *fe, int stream);
+int dpcm_be_dai_hw_free(struct snd_soc_pcm_runtime *fe, int stream);
+int dpcm_be_dai_hw_params(struct snd_soc_pcm_runtime *fe, int tream);
+int dpcm_be_dai_trigger(struct snd_soc_pcm_runtime *fe, int stream, int cmd);
+int dpcm_be_dai_prepare(struct snd_soc_pcm_runtime *fe, int stream);
+int dpcm_dapm_stream_event(struct snd_soc_pcm_runtime *fe, int dir,
+	int event);
+
+static inline void dpcm_path_put(struct snd_soc_dapm_widget_list **list)
+{
+	kfree(*list);
+}
+
+
 #endif

commit c3f48ae6fd5a1ebdcaff5efe35f88f31daaee225
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Jul 24 15:27:36 2013 +0200

    ASoC: dapm: Pass snd_soc_card directly to soc_dpcm_runtime_update()
    
    soc_dpcm_runtime_update() operates on a ASoC card as a whole. Currently it takes
    a snd_soc_dapm_widget as its only parameter though. The widget is then used to
    look up the card and is otherwise unused. This patch changes the function to
    take a pointer to the card directly. This makes it possible to to call
    soc_dpcm_runtime_update() for updates which are not related to one specific
    widget.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index 04598f1efd77..047d657c331c 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -133,6 +133,6 @@ void snd_soc_dpcm_be_set_state(struct snd_soc_pcm_runtime *be, int stream,
 /* internal use only */
 int soc_dpcm_be_digital_mute(struct snd_soc_pcm_runtime *fe, int mute);
 int soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd);
-int soc_dpcm_runtime_update(struct snd_soc_dapm_widget *);
+int soc_dpcm_runtime_update(struct snd_soc_card *);
 
 #endif

commit 07bf84aaf736781a283b1bd36eaa911453b14574
Author: Liam Girdwood <lrg@ti.com>
Date:   Wed Apr 25 12:12:52 2012 +0100

    ASoC: dpcm: Add bespoke trigger()
    
    Some on SoC DSP HW is very tightly coupled with DMA and DAI drivers. It's
    necessary to allow some flexability wrt to PCM operations here so that we
    can define a bespoke DPCM trigger() PCM operation for such HW.
    
    A bespoke DPCM trigger() allows exact ordering and timing of component
    triggering by allowing a component driver to manage the final enable
    and disable configurations without adding extra complexity to other
    component drivers. e.g. The McPDM DAI and ABE are tightly coupled on
    OMAP4 so we have a bespoke trigger to manage the trigger to improve
    performance and reduce complexity when triggering new McPDM BEs.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index d1a4b50018d2..04598f1efd77 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -60,6 +60,7 @@ enum snd_soc_dpcm_state {
 enum snd_soc_dpcm_trigger {
 	SND_SOC_DPCM_TRIGGER_PRE		= 0,
 	SND_SOC_DPCM_TRIGGER_POST,
+	SND_SOC_DPCM_TRIGGER_BESPOKE,
 };
 
 /*

commit 618dae11f809aaccd05710aa8cee8c46a9cef1a7
Author: Liam Girdwood <lrg@ti.com>
Date:   Wed Apr 25 12:12:51 2012 +0100

    ASoC: dpcm: Add runtime dynamic route update
    
    This patch allows DPCM to dynamically alter the FE to BE PCM links
    at runtime based on mixer setting updates. DAPM is looked up after
    every mixer update and we perform a DPCM runtime update if the
    mixer has a change of value.
    
    This patchs adds/changes the following :-
    
     o Adds DPCM runtime update core.
     o Changes soc_dapm_mixer_update_power() and soc_dapm_mux_update_power()
       to return if a change has occured rather than 0. No other users check
       atm.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index e307fa30231a..d1a4b50018d2 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -132,5 +132,6 @@ void snd_soc_dpcm_be_set_state(struct snd_soc_pcm_runtime *be, int stream,
 /* internal use only */
 int soc_dpcm_be_digital_mute(struct snd_soc_pcm_runtime *fe, int mute);
 int soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd);
+int soc_dpcm_runtime_update(struct snd_soc_dapm_widget *);
 
 #endif

commit f86dcef87b771935c223334324a93c1d71f7a84c
Author: Liam Girdwood <lrg@ti.com>
Date:   Wed Apr 25 12:12:50 2012 +0100

    ASoC: dpcm: Add debugFS support for DPCM
    
    Add debugFS files for DPCM link management information.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index cd72c1090586..e307fa30231a 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -81,6 +81,9 @@ struct snd_soc_dpcm {
 
 	/* hw params for this link - may be different for each link */
 	struct snd_pcm_hw_params hw_params;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *debugfs_state;
+#endif
 };
 
 /*
@@ -128,5 +131,6 @@ void snd_soc_dpcm_be_set_state(struct snd_soc_pcm_runtime *be, int stream,
 
 /* internal use only */
 int soc_dpcm_be_digital_mute(struct snd_soc_pcm_runtime *fe, int mute);
+int soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd);
 
 #endif

commit 01d7584cd2e5a93a2b959c9dddaa0d93ec205404
Author: Liam Girdwood <lrg@ti.com>
Date:   Wed Apr 25 12:12:49 2012 +0100

    ASoC: dpcm: Add Dynamic PCM core operations.
    
    The Dynamic PCM core allows digital audio data to be dynamically
    routed between different ALSA PCMs and DAI links on SoC CPUs with
    on chip DSP devices. e.g. audio data could be played on pcm:0,0 and
    routed to any (or all) SoC DAI links.
    
    Dynamic PCM introduces the concept of Front End (FE) PCMs and Back
    End (BE) PCMs. The FE PCMs are normal ALSA PCM devices except that
    they can dynamically route digital audio data to any supported BE
    PCM. A BE PCM has no ALSA device, but represents a DAI link and it's
    substream and audio HW parameters.
    
    e.g. pcm:0,0 routing digital data to 2 external codecs.
    
    FE pcm:0,0  ----> BE (McBSP.0) ----> CODEC 0
                 +--> BE (McPDM.0) ----> CODEC 1
    
    e.g. pcm:0,0 and pcm:0,1 routing digital data to 1 external codec.
    
    FE pcm:0,0 ---
                 +--> BE (McBSP.0) ----> CODEC
    FE pcm:0,1 ---
    
    The digital audio routing is controlled by the usual ALSA method
    of mixer kcontrols. Dynamic PCM uses a DAPM graph to work out the
    routing based upon the mixer settings and configures the BE PCMs
    based on routing and the FE HW params.
    
    DPCM is designed so that most ASoC component drivers will need no
    modification at all. It's intended that existing CODEC, DAI and
    platform drivers can be used in DPCM based audio devices without
    any changes. However, there will be some cases where minor changes
    are required (e.g. for very tightly coupled HW) and there are
    helpers to support this too.
    
    Somethimes the HW params of a FE and BE do not match or are
    incompatible, so in these cases the machine driver can reconfigure
    any hw_params and make any DSP perform sample rate / format conversion.
    
    This patch adds the core DPCM code and contains :-
    
     o The FE and BE PCM operations.
     o FE and BE DAI link support.
     o FE and BE PCM creation.
     o BE support API.
     o BE and FE link management.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
new file mode 100644
index 000000000000..cd72c1090586
--- /dev/null
+++ b/include/sound/soc-dpcm.h
@@ -0,0 +1,132 @@
+/*
+ * linux/sound/soc-dpcm.h -- ALSA SoC Dynamic PCM Support
+ *
+ * Author:		Liam Girdwood <lrg@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_SND_SOC_DPCM_H
+#define __LINUX_SND_SOC_DPCM_H
+
+#include <linux/list.h>
+#include <sound/pcm.h>
+
+struct snd_soc_pcm_runtime;
+
+/*
+ * Types of runtime_update to perform. e.g. originated from FE PCM ops
+ * or audio route changes triggered by muxes/mixers.
+ */
+enum snd_soc_dpcm_update {
+	SND_SOC_DPCM_UPDATE_NO	= 0,
+	SND_SOC_DPCM_UPDATE_BE,
+	SND_SOC_DPCM_UPDATE_FE,
+};
+
+/*
+ * Dynamic PCM Frontend -> Backend link management states.
+ */
+enum snd_soc_dpcm_link_state {
+	SND_SOC_DPCM_LINK_STATE_NEW	= 0,	/* newly created link */
+	SND_SOC_DPCM_LINK_STATE_FREE,		/* link to be dismantled */
+};
+
+/*
+ * Dynamic PCM Frontend -> Backend link PCM states.
+ */
+enum snd_soc_dpcm_state {
+	SND_SOC_DPCM_STATE_NEW	= 0,
+	SND_SOC_DPCM_STATE_OPEN,
+	SND_SOC_DPCM_STATE_HW_PARAMS,
+	SND_SOC_DPCM_STATE_PREPARE,
+	SND_SOC_DPCM_STATE_START,
+	SND_SOC_DPCM_STATE_STOP,
+	SND_SOC_DPCM_STATE_PAUSED,
+	SND_SOC_DPCM_STATE_SUSPEND,
+	SND_SOC_DPCM_STATE_HW_FREE,
+	SND_SOC_DPCM_STATE_CLOSE,
+};
+
+/*
+ * Dynamic PCM trigger ordering. Triggering flexibility is required as some
+ * DSPs require triggering before/after their CPU platform and DAIs.
+ *
+ * i.e. some clients may want to manually order this call in their PCM
+ * trigger() whilst others will just use the regular core ordering.
+ */
+enum snd_soc_dpcm_trigger {
+	SND_SOC_DPCM_TRIGGER_PRE		= 0,
+	SND_SOC_DPCM_TRIGGER_POST,
+};
+
+/*
+ * Dynamic PCM link
+ * This links together a FE and BE DAI at runtime and stores the link
+ * state information and the hw_params configuration.
+ */
+struct snd_soc_dpcm {
+	/* FE and BE DAIs*/
+	struct snd_soc_pcm_runtime *be;
+	struct snd_soc_pcm_runtime *fe;
+
+	/* link state */
+	enum snd_soc_dpcm_link_state state;
+
+	/* list of BE and FE for this DPCM link */
+	struct list_head list_be;
+	struct list_head list_fe;
+
+	/* hw params for this link - may be different for each link */
+	struct snd_pcm_hw_params hw_params;
+};
+
+/*
+ * Dynamic PCM runtime data.
+ */
+struct snd_soc_dpcm_runtime {
+	struct list_head be_clients;
+	struct list_head fe_clients;
+
+	int users;
+	struct snd_pcm_runtime *runtime;
+	struct snd_pcm_hw_params hw_params;
+
+	/* state and update */
+	enum snd_soc_dpcm_update runtime_update;
+	enum snd_soc_dpcm_state state;
+};
+
+/* can this BE stop and free */
+int snd_soc_dpcm_can_be_free_stop(struct snd_soc_pcm_runtime *fe,
+		struct snd_soc_pcm_runtime *be, int stream);
+
+/* can this BE perform a hw_params() */
+int snd_soc_dpcm_can_be_params(struct snd_soc_pcm_runtime *fe,
+		struct snd_soc_pcm_runtime *be, int stream);
+
+/* is the current PCM operation for this FE ? */
+int snd_soc_dpcm_fe_can_update(struct snd_soc_pcm_runtime *fe, int stream);
+
+/* is the current PCM operation for this BE ? */
+int snd_soc_dpcm_be_can_update(struct snd_soc_pcm_runtime *fe,
+		struct snd_soc_pcm_runtime *be, int stream);
+
+/* get the substream for this BE */
+struct snd_pcm_substream *
+	snd_soc_dpcm_get_substream(struct snd_soc_pcm_runtime *be, int stream);
+
+/* get the BE runtime state */
+enum snd_soc_dpcm_state
+	snd_soc_dpcm_be_get_state(struct snd_soc_pcm_runtime *be, int stream);
+
+/* set the BE runtime state */
+void snd_soc_dpcm_be_set_state(struct snd_soc_pcm_runtime *be, int stream,
+	enum snd_soc_dpcm_state state);
+
+/* internal use only */
+int soc_dpcm_be_digital_mute(struct snd_soc_pcm_runtime *fe, int mute);
+
+#endif
