commit b9f2d35f05308813c4c887d5c530004f01e1829c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat May 16 08:28:54 2020 +0200

    ALSA: hda: Unexport some local helper functions
    
    snd_hdac_bus_queue_event() and snd_hdac_bus_exec_verb() are used only
    internally in HD-audio core.  Let's drop the exports and move the
    declarations into local.h.
    
    Link: https://lore.kernel.org/r/20200516062854.22141-3-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 10945963d727..c1f78d9a6e47 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -372,11 +372,8 @@ struct hdac_bus {
 int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,
 		      const struct hdac_bus_ops *ops);
 void snd_hdac_bus_exit(struct hdac_bus *bus);
-int snd_hdac_bus_exec_verb(struct hdac_bus *bus, unsigned int addr,
-			   unsigned int cmd, unsigned int *res);
 int snd_hdac_bus_exec_verb_unlocked(struct hdac_bus *bus, unsigned int addr,
 				    unsigned int cmd, unsigned int *res);
-void snd_hdac_bus_queue_event(struct hdac_bus *bus, u32 res, u32 res_ex);
 
 static inline void snd_hdac_codec_link_up(struct hdac_device *codec)
 {

commit 79263c3bceb738567ba96bef4940ac58c07a415c
Author: Jason Yan <yanaijie@huawei.com>
Date:   Wed May 6 14:17:16 2020 +0800

    ALSA: hda: Return true,false for return type bool
    
    Fix the following coccicheck warning:
    
    include/sound/hdaudio.h:210:73-74: WARNING: return of 0/1 in function
    'snd_hdac_is_in_pm' with return type bool
    include/sound/hdaudio.h:211:76-77: WARNING: return of 0/1 in function
    'snd_hdac_is_power_on' with return type bool
    
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    Link: https://lore.kernel.org/r/20200506061716.19209-1-yanaijie@huawei.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index d365297b3698..10945963d727 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -207,8 +207,8 @@ static inline int snd_hdac_power_down_pm(struct hdac_device *codec) { return 0;
 static inline int snd_hdac_keep_power_up(struct hdac_device *codec) { return 0; }
 static inline void snd_hdac_enter_pm(struct hdac_device *codec) {}
 static inline void snd_hdac_leave_pm(struct hdac_device *codec) {}
-static inline bool snd_hdac_is_in_pm(struct hdac_device *codec) { return 0; }
-static inline bool snd_hdac_is_power_on(struct hdac_device *codec) { return 1; }
+static inline bool snd_hdac_is_in_pm(struct hdac_device *codec) { return false; }
+static inline bool snd_hdac_is_power_on(struct hdac_device *codec) { return true; }
 #endif
 
 /*

commit 67ae482a59e951c346b5a55a756504bc58ce7cfa
Author: Sameer Pujar <spujar@nvidia.com>
Date:   Mon May 4 13:46:15 2020 +0530

    ALSA: hda: add member to store ratio for stripe control
    
    Stripe control programming is governed by following formula, which is
    referenced from the HD Audio specification(Revision 1.0a).
      { ((num_channels * bits_per_sample) / number of SDOs) >= 8 }
    
    Currently above is implemented in snd_hdac_get_stream_stripe_ctl().
    This patch introduces a structure member to store the default factor
    of '8'. If any HW wants to use a different value, this member can be
    easily updated.
    
    Signed-off-by: Sameer Pujar <spujar@nvidia.com>
    Link: https://lore.kernel.org/r/1588580176-2801-3-git-send-email-spujar@nvidia.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index affedc2801c4..d365297b3698 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -364,6 +364,9 @@ struct hdac_bus {
 	/* link management */
 	struct list_head hlink_list;
 	bool cmd_dma_state;
+
+	/* factor used to derive STRIPE control value */
+	unsigned int sdo_limit;
 };
 
 int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,

commit 4a9ce6e4d9fb9c4acc44f647a68e59ea50ff1caf
Author: Cezary Rojewski <cezary.rojewski@intel.com>
Date:   Tue Feb 18 15:39:18 2020 +0100

    ASoC: SOF: Intel: Account for compress streams when servicing IRQs
    
    Update stream irq handler definition to correctly set hdac_stream
    current position when servicing stream interrupts for compress streams.
    
    Signed-off-by: Cezary Rojewski <cezary.rojewski@intel.com>
    Acked-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/20200218143924.10565-4-cezary.rojewski@intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index d4299e146d95..affedc2801c4 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -513,6 +513,7 @@ struct hdac_stream {
 	struct snd_pcm_substream *substream;	/* assigned substream,
 						 * set in PCM open
 						 */
+	struct snd_compr_stream *cstream;
 	unsigned int format_val;	/* format value to be set in the
 					 * controller and the codec
 					 */
@@ -527,6 +528,7 @@ struct hdac_stream {
 	bool locked:1;
 	bool stripe:1;			/* apply stripe control */
 
+	u64 curr_pos;
 	/* timestamp */
 	unsigned long start_wallclk;	/* start + minimum wallclk */
 	unsigned long period_wallclk;	/* wallclk for period */

commit 9d0af44c2ed036c663832f3b764ffd1109c8b79e
Merge: 5af29028fd6d 4d024fe8f806
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 20 11:44:35 2020 +0100

    Merge branch 'for-linus' into for-next
    
    Resolved the merge conflict in HD-audio Tegra driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 4d024fe8f806e20e577cc934204c5784c7063293
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 20 11:41:27 2020 +0100

    ALSA: hda: Apply aligned MMIO access only conditionally
    
    It turned out that the recent simplification of HD-audio bus access
    helpers caused a regression on the virtual HD-audio device on QEMU
    with ARM platforms.  The driver got a CORB/RIRB timeout and couldn't
    probe any codecs.
    
    The essential difference that caused a problem was the enforced
    aligned MMIO accesses by simplification.  Since snd-hda-tegra driver
    is enabled on ARM, it enables CONFIG_SND_HDA_ALIGNED_MMIO, which makes
    the all HD-audio drivers using the aligned MMIO accesses.  While this
    is mandatory for snd-hda-tegra, it seems that snd-hda-intel on ARM
    gets broken by this access pattern.
    
    For addressing the regression, this patch introduces a new flag,
    aligned_mmio, to hdac_bus object, and applies the aligned MMIO only
    when this flag is set.  This change affects only platforms with
    CONFIG_SND_HDA_ALIGNED_MMIO set, i.e. mostly only for ARM platforms.
    
    Unfortunately the patch became a big bigger than it should be, just
    because the former calls didn't take hdac_bus object in the argument,
    hence we had to extend the call patterns.
    
    Fixes: 19abfefd4c76 ("ALSA: hda: Direct MMIO accesses")
    BugLink: https://bugzilla.opensuse.org/show_bug.cgi?id=1161152
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200120104127.28985-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index e05b95e83d5a..fb9dce4c6928 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -8,6 +8,7 @@
 
 #include <linux/device.h>
 #include <linux/interrupt.h>
+#include <linux/io.h>
 #include <linux/pm_runtime.h>
 #include <linux/timecounter.h>
 #include <sound/core.h>
@@ -330,6 +331,7 @@ struct hdac_bus {
 	bool chip_init:1;		/* h/w initialized */
 
 	/* behavior flags */
+	bool aligned_mmio:1;		/* aligned MMIO access */
 	bool sync_write:1;		/* sync after verb write */
 	bool use_posbuf:1;		/* use position buffer */
 	bool snoop:1;			/* enable snooping */
@@ -405,34 +407,61 @@ void snd_hdac_bus_free_stream_pages(struct hdac_bus *bus);
 unsigned int snd_hdac_aligned_read(void __iomem *addr, unsigned int mask);
 void snd_hdac_aligned_write(unsigned int val, void __iomem *addr,
 			    unsigned int mask);
-#define snd_hdac_reg_writeb(v, addr)	snd_hdac_aligned_write(v, addr, 0xff)
-#define snd_hdac_reg_writew(v, addr)	snd_hdac_aligned_write(v, addr, 0xffff)
-#define snd_hdac_reg_readb(addr)	snd_hdac_aligned_read(addr, 0xff)
-#define snd_hdac_reg_readw(addr)	snd_hdac_aligned_read(addr, 0xffff)
-#else /* CONFIG_SND_HDA_ALIGNED_MMIO */
-#define snd_hdac_reg_writeb(val, addr)	writeb(val, addr)
-#define snd_hdac_reg_writew(val, addr)	writew(val, addr)
-#define snd_hdac_reg_readb(addr)	readb(addr)
-#define snd_hdac_reg_readw(addr)	readw(addr)
-#endif /* CONFIG_SND_HDA_ALIGNED_MMIO */
-#define snd_hdac_reg_writel(val, addr)	writel(val, addr)
-#define snd_hdac_reg_readl(addr)	readl(addr)
+#define snd_hdac_aligned_mmio(bus)	(bus)->aligned_mmio
+#else
+#define snd_hdac_aligned_mmio(bus)	false
+#define snd_hdac_aligned_read(addr, mask)	0
+#define snd_hdac_aligned_write(val, addr, mask) do {} while (0)
+#endif
+
+static inline void snd_hdac_reg_writeb(struct hdac_bus *bus, void __iomem *addr,
+				       u8 val)
+{
+	if (snd_hdac_aligned_mmio(bus))
+		snd_hdac_aligned_write(val, addr, 0xff);
+	else
+		writeb(val, addr);
+}
+
+static inline void snd_hdac_reg_writew(struct hdac_bus *bus, void __iomem *addr,
+				       u16 val)
+{
+	if (snd_hdac_aligned_mmio(bus))
+		snd_hdac_aligned_write(val, addr, 0xffff);
+	else
+		writew(val, addr);
+}
+
+static inline u8 snd_hdac_reg_readb(struct hdac_bus *bus, void __iomem *addr)
+{
+	return snd_hdac_aligned_mmio(bus) ?
+		snd_hdac_aligned_read(addr, 0xff) : readb(addr);
+}
+
+static inline u16 snd_hdac_reg_readw(struct hdac_bus *bus, void __iomem *addr)
+{
+	return snd_hdac_aligned_mmio(bus) ?
+		snd_hdac_aligned_read(addr, 0xffff) : readw(addr);
+}
+
+#define snd_hdac_reg_writel(bus, addr, val)	writel(val, addr)
+#define snd_hdac_reg_readl(bus, addr)	readl(addr)
 
 /*
  * macros for easy use
  */
 #define _snd_hdac_chip_writeb(chip, reg, value) \
-	snd_hdac_reg_writeb(value, (chip)->remap_addr + (reg))
+	snd_hdac_reg_writeb(chip, (chip)->remap_addr + (reg), value)
 #define _snd_hdac_chip_readb(chip, reg) \
-	snd_hdac_reg_readb((chip)->remap_addr + (reg))
+	snd_hdac_reg_readb(chip, (chip)->remap_addr + (reg))
 #define _snd_hdac_chip_writew(chip, reg, value) \
-	snd_hdac_reg_writew(value, (chip)->remap_addr + (reg))
+	snd_hdac_reg_writew(chip, (chip)->remap_addr + (reg), value)
 #define _snd_hdac_chip_readw(chip, reg) \
-	snd_hdac_reg_readw((chip)->remap_addr + (reg))
+	snd_hdac_reg_readw(chip, (chip)->remap_addr + (reg))
 #define _snd_hdac_chip_writel(chip, reg, value) \
-	snd_hdac_reg_writel(value, (chip)->remap_addr + (reg))
+	snd_hdac_reg_writel(chip, (chip)->remap_addr + (reg), value)
 #define _snd_hdac_chip_readl(chip, reg) \
-	snd_hdac_reg_readl((chip)->remap_addr + (reg))
+	snd_hdac_reg_readl(chip, (chip)->remap_addr + (reg))
 
 /* read/write a register, pass without AZX_REG_ prefix */
 #define snd_hdac_chip_writel(chip, reg, value) \
@@ -540,17 +569,17 @@ int snd_hdac_get_stream_stripe_ctl(struct hdac_bus *bus,
  */
 /* read/write a register, pass without AZX_REG_ prefix */
 #define snd_hdac_stream_writel(dev, reg, value) \
-	snd_hdac_reg_writel(value, (dev)->sd_addr + AZX_REG_ ## reg)
+	snd_hdac_reg_writel((dev)->bus, (dev)->sd_addr + AZX_REG_ ## reg, value)
 #define snd_hdac_stream_writew(dev, reg, value) \
-	snd_hdac_reg_writew(value, (dev)->sd_addr + AZX_REG_ ## reg)
+	snd_hdac_reg_writew((dev)->bus, (dev)->sd_addr + AZX_REG_ ## reg, value)
 #define snd_hdac_stream_writeb(dev, reg, value) \
-	snd_hdac_reg_writeb(value, (dev)->sd_addr + AZX_REG_ ## reg)
+	snd_hdac_reg_writeb((dev)->bus, (dev)->sd_addr + AZX_REG_ ## reg, value)
 #define snd_hdac_stream_readl(dev, reg) \
-	snd_hdac_reg_readl((dev)->sd_addr + AZX_REG_ ## reg)
+	snd_hdac_reg_readl((dev)->bus, (dev)->sd_addr + AZX_REG_ ## reg)
 #define snd_hdac_stream_readw(dev, reg) \
-	snd_hdac_reg_readw((dev)->sd_addr + AZX_REG_ ## reg)
+	snd_hdac_reg_readw((dev)->bus, (dev)->sd_addr + AZX_REG_ ## reg)
 #define snd_hdac_stream_readb(dev, reg) \
-	snd_hdac_reg_readb((dev)->sd_addr + AZX_REG_ ## reg)
+	snd_hdac_reg_readb((dev)->bus, (dev)->sd_addr + AZX_REG_ ## reg)
 
 /* update a register, pass without AZX_REG_ prefix */
 #define snd_hdac_stream_updatel(dev, reg, mask, val) \

commit 1a462be52f4505a2719631fb5aa7bfdbd37bfd8d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 9 10:01:04 2020 +0100

    ALSA: hda: Manage concurrent reg access more properly
    
    In the commit 8e85def5723e ("ALSA: hda: enable regmap internal
    locking"), we re-enabled the regmap lock due to the reported
    regression that showed the possible concurrent accesses.  It was a
    temporary workaround, and there are still a few opened races even
    after the revert.  In this patch, we cover those still opened windows
    with a proper mutex lock and disable the regmap internal lock again.
    
    First off, the patch introduces a new snd_hdac_device.regmap_lock
    mutex that is applied for each snd_hdac_regmap_*() call, including
    read, write and update helpers.  The mutex is applied carefully so
    that it won't block the self-power-up procedure in the helper
    function.  Also, this assures the protection for the accesses without
    regmap, too.
    
    The snd_hdac_regmap_update_raw() is refactored to use the standard
    regmap_update_bits_check() function instead of the open-code.  The
    non-regmap case is still open-coded but it's an easy part.  The all
    read and write operations are in the single mutex protection, so it's
    now race-free.
    
    In addition, a couple of new helper functions are added:
    snd_hdac_regmap_update_raw_once() and snd_hdac_regmap_sync().  Both
    are called from HD-audio legacy driver.  The former is to initialize
    the given verb bits but only once when it's not initialized yet.  Due
    to this condition, the function invokes regcache_cache_only(), and
    it's now performed inside the regmap_lock (formerly it was racy) too.
    The latter function is for simply invoking regcache_sync() inside the
    regmap_lock, which is called from the codec resume call path.
    Along with that, the HD-audio codec driver code is slightly modified /
    simplified to adapt those new functions.
    
    And finally, snd_hdac_regmap_read_raw(), *_write_raw(), etc are
    rewritten with the helper macro.  It's just for simplification because
    the code logic is identical among all those functions.
    
    Tested-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
    Link: https://lore.kernel.org/r/20200109090104.26073-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index bc2f77a6f17b..541ca99b154b 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -86,6 +86,7 @@ struct hdac_device {
 
 	/* regmap */
 	struct regmap *regmap;
+	struct mutex regmap_lock;
 	struct snd_array vendor_verbs;
 	bool lazy_cache:1;	/* don't wake up for writes */
 	bool caps_overwriting:1; /* caps overwrite being in process */

commit 5f2cb361d798fb39adb79fab4e5235e307c70e9a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 12 20:11:01 2019 +0100

    ALSA: hda: Unify get_response handling
    
    Now most of the get_response handling became quite similar between
    HDA-core and legacy drivers, and the only differences are:
    
    - the handling of extra-long polling delay for some codecs
    - the debug message for the stalled communication
    
    and both are worth to share in the common code.
    
    This patch unifies the code into snd_hdac_bus_get_response(), and use
    this from the legacy get_response callback.  It results in a good
    amount of code reduction in the end.
    
    Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
    Link: https://lore.kernel.org/r/20191212191101.19517-3-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 81373a2efd96..bc2f77a6f17b 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -338,6 +338,7 @@ struct hdac_bus {
 	bool reverse_assign:1;		/* assign devices in reverse order */
 	bool corbrp_self_clear:1;	/* CORBRP clears itself after reset */
 	bool polling_mode:1;
+	bool needs_damn_long_delay:1;
 
 	int poll_count;
 

commit 88452da92ba2b264a3922218c2cec13aac51c502
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 15:57:27 2019 +0100

    ALSA: hda: Use standard waitqueue for RIRB wakeup
    
    The HD-audio CORB/RIRB communication was programmed in a way that was
    documented in the reference in decades ago, which is essentially a
    polling in the waiter side.  It's working fine but costs CPU cycles on
    some platforms that support only slow communications.  Also, for some
    platforms that had unreliable communications, we put longer wait time
    (2 ms), which accumulate quite long time if you execute many verbs in
    a shot (e.g. at the initialization or resume phase).
    
    This patch attempts to improve the situation by introducing the
    standard waitqueue in the RIRB waiter side instead of polling.  The
    test results on my machine show significant improvements.  The time
    spent for "cat /proc/asound/card*/codec#*" were changed like:
    
    * Intel SKL + Realtek codec
      before the patch:
       0.00user 0.04system 0:00.10elapsed 40.0%CPU
      after the patch:
       0.00user 0.01system 0:00.10elapsed 10.0%CPU
    
    * Nvidia GP107GL + Nvidia HDMI codec
      before the patch:
       0.00user 0.00system 0:02.76elapsed 0.0%CPU
      after the patch:
       0.00user 0.00system 0:00.01elapsed 17.0%CPU
    
    So, for Intel chips, the total time is same, while the total time is
    greatly reduced (from 2.76 to 0.01s) for Nvidia chips.
    The only negative data here is the increase of CPU time for Nvidia,
    but this is the unavoidable cost for faster wakeups, supposedly.
    
    Link: https://lore.kernel.org/r/20191210145727.22054-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index e05b95e83d5a..81373a2efd96 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -317,6 +317,7 @@ struct hdac_bus {
 	struct hdac_rb corb;
 	struct hdac_rb rirb;
 	unsigned int last_cmd[HDA_MAX_CODECS];	/* last sent command */
+	wait_queue_head_t rirb_wq;
 
 	/* CORB/RIRB and position buffers */
 	struct snd_dma_buffer rb;

commit e38e486d66e2a3b902768fd71c32dbf10f77e1cb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 2 08:49:47 2019 +0100

    ALSA: hda: Modify stream stripe mask only when needed
    
    The recent commit in HD-audio stream management for changing the
    stripe control seems causing a regression on some platforms.  The
    stripe control is currently used only by HDMI codec, and applying the
    stripe mask unconditionally may lead to scratchy and static noises as
    seen on some MacBooks.
    
    For addressing the regression, this patch changes the stream
    management code to apply the stripe mask conditionally only when the
    codec driver requested.
    
    Fixes: 9b6f7e7a296e ("ALSA: hda: program stripe bits for controller")
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=204477
    Tested-by: Michael Pobega <mpobega@neverware.com>
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20191202074947.1617-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index b260c5fd2337..e05b95e83d5a 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -493,6 +493,7 @@ struct hdac_stream {
 	bool prepared:1;
 	bool no_period_wakeup:1;
 	bool locked:1;
+	bool stripe:1;			/* apply stripe control */
 
 	/* timestamp */
 	unsigned long start_wallclk;	/* start + minimum wallclk */

commit ddf7cb83b0f45feb94ad89a987f600c766c463ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 14 19:59:44 2019 +0200

    ALSA: hda: Unexport a few more stuff
    
    Drop EXPORT_SYMBOL*() from a few more stuff in HD-audio core that
    aren't used outside.  Particular the unsol event handler can be
    staticized now because the recent change removed all external
    callers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index edb176a265c7..b260c5fd2337 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -122,10 +122,6 @@ int snd_hdac_codec_modalias(struct hdac_device *hdac, char *buf, size_t size);
 
 int snd_hdac_refresh_widgets(struct hdac_device *codec);
 
-unsigned int snd_hdac_make_cmd(struct hdac_device *codec, hda_nid_t nid,
-			       unsigned int verb, unsigned int parm);
-int snd_hdac_exec_verb(struct hdac_device *codec, unsigned int cmd,
-		       unsigned int flags, unsigned int *res);
 int snd_hdac_read(struct hdac_device *codec, hda_nid_t nid,
 		  unsigned int verb, unsigned int parm, unsigned int *res);
 int _snd_hdac_read_parm(struct hdac_device *codec, hda_nid_t nid, int parm,
@@ -374,8 +370,6 @@ int snd_hdac_bus_exec_verb_unlocked(struct hdac_bus *bus, unsigned int addr,
 				    unsigned int cmd, unsigned int *res);
 void snd_hdac_bus_queue_event(struct hdac_bus *bus, u32 res, u32 res_ex);
 
-void snd_hdac_bus_process_unsol_events(struct work_struct *work);
-
 static inline void snd_hdac_codec_link_up(struct hdac_device *codec)
 {
 	set_bit(codec->addr, &codec->bus->codec_powered);

commit 53eff75e5f4dd4b9bc489955fdc60fde48d85e93
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 14 18:27:08 2019 +0200

    ALSA: hda: Drop export of snd_hdac_bus_add/remove_device()
    
    snd_hdac_bus_add_device() and snd_hdac_remove_device() are called only
    internally in hda-core.  Let's drop the exports of them and move the
    declarations into local.h.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 4af4af55e854..edb176a265c7 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -374,9 +374,6 @@ int snd_hdac_bus_exec_verb_unlocked(struct hdac_bus *bus, unsigned int addr,
 				    unsigned int cmd, unsigned int *res);
 void snd_hdac_bus_queue_event(struct hdac_bus *bus, u32 res, u32 res_ex);
 
-int snd_hdac_bus_add_device(struct hdac_bus *bus, struct hdac_device *codec);
-void snd_hdac_bus_remove_device(struct hdac_bus *bus,
-				struct hdac_device *codec);
 void snd_hdac_bus_process_unsol_events(struct work_struct *work);
 
 static inline void snd_hdac_codec_link_up(struct hdac_device *codec)

commit 19abfefd4c7604993d1c31e098a3f48bdafe334d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 7 20:32:08 2019 +0200

    ALSA: hda: Direct MMIO accesses
    
    HD-audio drivers access to the mmio registers indirectly via the
    corresponding bus->io_ops callbacks.  This is because some platform
    (notably Tegra SoC) requires the word-aligned access.  But it's rather
    a rare case, and other platforms suffer from the penalties by indirect
    calls unnecessarily.
    
    This patch is an attempt to optimize and cleanup for this situation.
    Now the special aligned access is used only when a new kconfig
    CONFIG_SND_HDA_ALIGNED_MMIO is set.  And the HD-audio core itself
    provides the aligned MMIO access helpers instead of the driver side.
    If Kconfig isn't set (as default), the standard helpers like readl()
    or writel() are used directly.
    
    A couple of places in ASoC Intel drivers have the access via io_ops
    reg_writel(), and they are replaced with the direct writel() calls.
    
    And now with this patch, the whole bus->io_ops becomes empty, so it's
    dropped completely.  The bus initialization functions are changed
    accordingly as well to drop the whole bus->io_ops.
    
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 20549def0a27..4af4af55e854 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -253,19 +253,6 @@ struct hdac_ext_bus_ops {
 	int (*hdev_detach)(struct hdac_device *hdev);
 };
 
-/*
- * Lowlevel I/O operators
- */
-struct hdac_io_ops {
-	/* mapped register accesses */
-	void (*reg_writel)(u32 value, u32 __iomem *addr);
-	u32 (*reg_readl)(u32 __iomem *addr);
-	void (*reg_writew)(u16 value, u16 __iomem *addr);
-	u16 (*reg_readw)(u16 __iomem *addr);
-	void (*reg_writeb)(u8 value, u8 __iomem *addr);
-	u8 (*reg_readb)(u8 __iomem *addr);
-};
-
 #define HDA_UNSOL_QUEUE_SIZE	64
 #define HDA_MAX_CODECS		8	/* limit by controller side */
 
@@ -299,7 +286,6 @@ struct hdac_rb {
 struct hdac_bus {
 	struct device *dev;
 	const struct hdac_bus_ops *ops;
-	const struct hdac_io_ops *io_ops;
 	const struct hdac_ext_bus_ops *ext_ops;
 
 	/* h/w resources */
@@ -380,8 +366,7 @@ struct hdac_bus {
 };
 
 int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,
-		      const struct hdac_bus_ops *ops,
-		      const struct hdac_io_ops *io_ops);
+		      const struct hdac_bus_ops *ops);
 void snd_hdac_bus_exit(struct hdac_bus *bus);
 int snd_hdac_bus_exec_verb(struct hdac_bus *bus, unsigned int addr,
 			   unsigned int cmd, unsigned int *res);
@@ -425,21 +410,38 @@ int snd_hdac_bus_handle_stream_irq(struct hdac_bus *bus, unsigned int status,
 int snd_hdac_bus_alloc_stream_pages(struct hdac_bus *bus);
 void snd_hdac_bus_free_stream_pages(struct hdac_bus *bus);
 
+#ifdef CONFIG_SND_HDA_ALIGNED_MMIO
+unsigned int snd_hdac_aligned_read(void __iomem *addr, unsigned int mask);
+void snd_hdac_aligned_write(unsigned int val, void __iomem *addr,
+			    unsigned int mask);
+#define snd_hdac_reg_writeb(v, addr)	snd_hdac_aligned_write(v, addr, 0xff)
+#define snd_hdac_reg_writew(v, addr)	snd_hdac_aligned_write(v, addr, 0xffff)
+#define snd_hdac_reg_readb(addr)	snd_hdac_aligned_read(addr, 0xff)
+#define snd_hdac_reg_readw(addr)	snd_hdac_aligned_read(addr, 0xffff)
+#else /* CONFIG_SND_HDA_ALIGNED_MMIO */
+#define snd_hdac_reg_writeb(val, addr)	writeb(val, addr)
+#define snd_hdac_reg_writew(val, addr)	writew(val, addr)
+#define snd_hdac_reg_readb(addr)	readb(addr)
+#define snd_hdac_reg_readw(addr)	readw(addr)
+#endif /* CONFIG_SND_HDA_ALIGNED_MMIO */
+#define snd_hdac_reg_writel(val, addr)	writel(val, addr)
+#define snd_hdac_reg_readl(addr)	readl(addr)
+
 /*
  * macros for easy use
  */
 #define _snd_hdac_chip_writeb(chip, reg, value) \
-	((chip)->io_ops->reg_writeb(value, (chip)->remap_addr + (reg)))
+	snd_hdac_reg_writeb(value, (chip)->remap_addr + (reg))
 #define _snd_hdac_chip_readb(chip, reg) \
-	((chip)->io_ops->reg_readb((chip)->remap_addr + (reg)))
+	snd_hdac_reg_readb((chip)->remap_addr + (reg))
 #define _snd_hdac_chip_writew(chip, reg, value) \
-	((chip)->io_ops->reg_writew(value, (chip)->remap_addr + (reg)))
+	snd_hdac_reg_writew(value, (chip)->remap_addr + (reg))
 #define _snd_hdac_chip_readw(chip, reg) \
-	((chip)->io_ops->reg_readw((chip)->remap_addr + (reg)))
+	snd_hdac_reg_readw((chip)->remap_addr + (reg))
 #define _snd_hdac_chip_writel(chip, reg, value) \
-	((chip)->io_ops->reg_writel(value, (chip)->remap_addr + (reg)))
+	snd_hdac_reg_writel(value, (chip)->remap_addr + (reg))
 #define _snd_hdac_chip_readl(chip, reg) \
-	((chip)->io_ops->reg_readl((chip)->remap_addr + (reg)))
+	snd_hdac_reg_readl((chip)->remap_addr + (reg))
 
 /* read/write a register, pass without AZX_REG_ prefix */
 #define snd_hdac_chip_writel(chip, reg, value) \
@@ -544,24 +546,19 @@ int snd_hdac_get_stream_stripe_ctl(struct hdac_bus *bus,
 /*
  * macros for easy use
  */
-#define _snd_hdac_stream_write(type, dev, reg, value)			\
-	((dev)->bus->io_ops->reg_write ## type(value, (dev)->sd_addr + (reg)))
-#define _snd_hdac_stream_read(type, dev, reg)				\
-	((dev)->bus->io_ops->reg_read ## type((dev)->sd_addr + (reg)))
-
 /* read/write a register, pass without AZX_REG_ prefix */
 #define snd_hdac_stream_writel(dev, reg, value) \
-	_snd_hdac_stream_write(l, dev, AZX_REG_ ## reg, value)
+	snd_hdac_reg_writel(value, (dev)->sd_addr + AZX_REG_ ## reg)
 #define snd_hdac_stream_writew(dev, reg, value) \
-	_snd_hdac_stream_write(w, dev, AZX_REG_ ## reg, value)
+	snd_hdac_reg_writew(value, (dev)->sd_addr + AZX_REG_ ## reg)
 #define snd_hdac_stream_writeb(dev, reg, value) \
-	_snd_hdac_stream_write(b, dev, AZX_REG_ ## reg, value)
+	snd_hdac_reg_writeb(value, (dev)->sd_addr + AZX_REG_ ## reg)
 #define snd_hdac_stream_readl(dev, reg) \
-	_snd_hdac_stream_read(l, dev, AZX_REG_ ## reg)
+	snd_hdac_reg_readl((dev)->sd_addr + AZX_REG_ ## reg)
 #define snd_hdac_stream_readw(dev, reg) \
-	_snd_hdac_stream_read(w, dev, AZX_REG_ ## reg)
+	snd_hdac_reg_readw((dev)->sd_addr + AZX_REG_ ## reg)
 #define snd_hdac_stream_readb(dev, reg) \
-	_snd_hdac_stream_read(b, dev, AZX_REG_ ## reg)
+	snd_hdac_reg_readb((dev)->sd_addr + AZX_REG_ ## reg)
 
 /* update a register, pass without AZX_REG_ prefix */
 #define snd_hdac_stream_updatel(dev, reg, mask, val) \

commit 619a1f195f93276dc8c6e33fe057e007adc9c288
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 7 20:02:31 2019 +0200

    ALSA: hda: Remove page allocation redirection
    
    The HD-audio core allocates and releases pages via driver's specific
    dma_alloc_pages and dma_free_pages ops defined in bus->io_ops.  This
    was because some platforms require the uncached pages and the handling
    of page flags had to be done locally in the driver code.
    
    Since the recent change in ALSA core memory allocator, we can simply
    pass SNDRV_DMA_TYPE_DEV_UC for the uncached pages, and the only
    difference became about this type to be passed to the core allocator.
    That is, it's good time for cleaning up the mess.
    
    This patch changes the allocation code in HD-audio core to call the
    core allocator directly so that we get rid of dma_alloc_pages and
    dma_free_pages io_ops.  If a driver needs the uncached pages, it has
    to set bus->dma_type right after the bus initialization.
    
    This is merely a code refactoring and shouldn't bring any behavior
    changes.
    
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 612a17e375d0..20549def0a27 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -264,11 +264,6 @@ struct hdac_io_ops {
 	u16 (*reg_readw)(u16 __iomem *addr);
 	void (*reg_writeb)(u8 value, u8 __iomem *addr);
 	u8 (*reg_readb)(u8 __iomem *addr);
-	/* Allocation ops */
-	int (*dma_alloc_pages)(struct hdac_bus *bus, int type, size_t size,
-			       struct snd_dma_buffer *buf);
-	void (*dma_free_pages)(struct hdac_bus *bus,
-			       struct snd_dma_buffer *buf);
 };
 
 #define HDA_UNSOL_QUEUE_SIZE	64
@@ -344,6 +339,7 @@ struct hdac_bus {
 	/* CORB/RIRB and position buffers */
 	struct snd_dma_buffer rb;
 	struct snd_dma_buffer posbuf;
+	int dma_type;			/* SNDRV_DMA_TYPE_XXX for CORB/RIRB */
 
 	/* hdac_stream linked list */
 	struct list_head stream_list;

commit b89b889a326a7abf1c9ceef7ddbe06dbaf8c2520
Merge: d4bd30532688 774a075ab514
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jul 7 11:29:03 2019 +0200

    Merge branch 'topic/hda-refresh-cleanup' into for-next
    
    Merge a cleanup for HD-audio widget refresh code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 774a075ab5140bb4504e6026bf327021926c3e65
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 3 14:35:12 2019 +0200

    ALSA: hda: Simplify snd_hdac_refresh_widgets()
    
    Along with the recent fix for the races of snd_hdac_refresh_widgets()
    it turned out that the instantiation of widgets sysfs at
    snd_hdac_sysfs_reinit() could cause a race.  The race itself was
    already covered later by extending the mutex protection range, the
    commit 98482377dc72 ("ALSA: hda: Fix widget_mutex incomplete
    protection"), but this also indicated that the call of *_reinit() is
    basically superfluous, as the widgets shall be created sooner or later
    from snd_hdac_device_register().
    
    This patch removes the redundant call of snd_hdac_sysfs_reinit() at
    first.  By this removal, the sysfs argument itself in
    snd_hdac_refresh_widgets() becomes superfluous, too, because the only
    case sysfs=false is always with codec->widgets=NULL.  So, we drop this
    redundant argument as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index e8346784cf3f..f475293d0668 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -120,7 +120,7 @@ void snd_hdac_device_unregister(struct hdac_device *codec);
 int snd_hdac_device_set_chip_name(struct hdac_device *codec, const char *name);
 int snd_hdac_codec_modalias(struct hdac_device *hdac, char *buf, size_t size);
 
-int snd_hdac_refresh_widgets(struct hdac_device *codec, bool sysfs);
+int snd_hdac_refresh_widgets(struct hdac_device *codec);
 
 unsigned int snd_hdac_make_cmd(struct hdac_device *codec, hda_nid_t nid,
 			       unsigned int verb, unsigned int parm);

commit 8af42130b50c4d38f48fa82f3f7be4606d01f595
Author: Bard Liao <yung-chuan.liao@linux.intel.com>
Date:   Mon May 27 00:58:34 2019 +0800

    ALSA: hda: move polling_mode flag to struct hdac_bus
    
    polling mode is a useful function in the get_response function. Move
    polling_mode flag from struct azx to struct hdac_bus so people can
    implement polling mode in their own get_response function without
    adding a polling_mode flag in their local chip structure.
    
    Signed-off-by: Bard Liao <yung-chuan.liao@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index e8346784cf3f..f49af557bdb0 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -358,6 +358,9 @@ struct hdac_bus {
 	bool align_bdle_4k:1;		/* BDLE align 4K boundary */
 	bool reverse_assign:1;		/* assign devices in reverse order */
 	bool corbrp_self_clear:1;	/* CORBRP clears itself after reset */
+	bool polling_mode:1;
+
+	int poll_count;
 
 	int bdl_pos_adj;		/* BDL position adjustment */
 

commit 72cf0b07418a9c8349aa9137194b1ccba6e54a9d
Merge: 0ef0fd351550 56df90b631fc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 17 13:57:54 2019 -0700

    Merge tag 'sound-fix-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound fixes from Takashi Iwai:
     "Just a few HD-audio fixes, most of which are specific to Realtek
      codecs"
    
    * tag 'sound-fix-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound:
      ALSA: hda/realtek - Fix for Lenovo B50-70 inverted internal microphone bug
      ALSA: hda: Fix race between creating and refreshing sysfs entries
      ALSA: hda/realtek - Corrected fixup for System76 Gazelle (gaze14)
      ALSA: hda/realtek - Avoid superfluous COEF EAPD setups
      ALSA: hda/realtek - Fixup headphone noise via runtime suspend

commit ed180abba7f1fc3cf04ffa27767b1bcc8e8c842a
Author: Amadeusz Sławiński <amadeuszx.slawinski@linux.intel.com>
Date:   Mon May 13 11:18:01 2019 +0200

    ALSA: hda: Fix race between creating and refreshing sysfs entries
    
    hda_widget_sysfs_reinit() can free underlying codec->widgets structure
    on which widget_tree_create() operates. Add locking to prevent such
    issues from happening.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=110382
    Signed-off-by: Amadeusz Sławiński <amadeuszx.slawinski@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index ca1d9a70d026..5a9315af2d37 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -81,6 +81,7 @@ struct hdac_device {
 	atomic_t in_pm;		/* suspend/resume being performed */
 
 	/* sysfs */
+	struct mutex widget_lock;
 	struct hdac_widget_tree *widgets;
 
 	/* regmap */

commit e57ccca1ba33e1d92cc3bbf8b6304a46948844b0
Merge: a2d635decbfa ed97c988bdc6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 9 08:26:55 2019 -0700

    Merge tag 'sound-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "The most significant changes at this cycle are the Sound Open Firmware
      support from Intel for the common DSP framework along with its support
      for Intel platforms. It's a door opened to a real "free" firmware (in
      the sense of FOSS), and other parties show interests in it.
    
      In addition to SOF, we've got a bunch of updates and fixes as usual.
      Some highlights are below.
    
      ALSA core:
       - Cleanups and fixes in ALSA timer code to cover some races spotted
         by syzkaller
       - Cleanups and fixes in ALSA sequencer code to cover some races,
         again unsurprisingly, spotted by syzkaller
       - Optimize the common page allocation helper with alloc_pages_exact()
    
      ASoC:
       - Add SOF core support, as well as Intel SOF platform support
       - Generic card driver improvements: support for MCLK/sample rate
         ratio and pin switches
       - A big set of improvements to TLV320AIC32x4 drivers
       - New drivers for Freescale audio mixers, several Intel machines,
         several Mediatek machines, Meson G12A, Spreadtrum compressed audio
         and DMA devices
    
      HD-audio:
       - A few Realtek codec fixes for reducing pop noises
       - Quirks for Chromebooks
       - Workaround for faulty connection report on AMD/Nvidia HDMI
    
      Others:
       - A quirk for Focusrite Scarlett Solo USB-audio
       - Add support for MOTU 8pre FireWire
       - 24bit sample format support in aloop
       - GUS patch format support (finally, over a decade) in native emux
         synth code"
    
    * tag 'sound-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (375 commits)
      ASoC: SOF: Fix unused variable warnings
      ALSA: line6: toneport: Fix broken usage of timer for delayed execution
      ALSA: aica: Fix a long-time build breakage
      ALSA: hda/realtek - Support low power consumption for ALC256
      ASoC: stm32: i2s: update pcm hardware constraints
      ASoC: codec: hdac_hdmi: no checking monitor in hw_params
      ASoC: mediatek: mt6358: save PGA for mixer control
      ASoC: mediatek: mt6358: save output volume for mixer controls
      ASoC: mediatek: mt6358: initialize setting when ramping volume
      ASoC: SOF: core: fix undefined nocodec reference
      ASoC: SOF: xtensa: fix undefined references
      ASoC: SOF: Propagate sof_get_ctrl_copy_params() error properly
      ALSA: hdea/realtek - Headset fixup for System76 Gazelle (gaze14)
      ALSA: hda/intel: add CometLake PCI IDs
      ALSA: hda/realtek - Support low power consumption for ALC295
      ASoC: rockchip: Fix an uninitialized variable compile warning
      ASoC: SOF: Fix a compile warning with CONFIG_PCI=n
      ASoC: da7219: Fix a compile warning at CONFIG_COMMON_CLK=n
      ASoC: sound/soc/sof/: fix kconfig dependency warning
      ASoC: stm32: spdifrx: change trace level on iec control
      ...

commit e61ab9f017493ef42f0374a578b2758c30f41f74
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 10 16:00:54 2019 +0200

    ALSA: hda: Initialize ext-bus-specific fields in snd_hdac_bus_init(), too
    
    Some fields in snd_hdac_bus are ext-bus specific, but they still
    should be initialized in snd_hdac_bus_init() for consistency, at
    least, for the ones that do need the explicit initialization like the
    list head.
    
    Also move the lock field to the more appropriate place and correct the
    comment to reflect the recent change where it serves for both the
    display power and the link management.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 45f944d57982..ca1d9a70d026 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -297,7 +297,7 @@ struct hdac_rb {
  * @num_streams: streams supported
  * @idx: HDA link index
  * @hlink_list: link list of HDA links
- * @lock: lock for link mgmt
+ * @lock: lock for link and display power mgmt
  * @cmd_dma_state: state of cmd DMAs: CORB and RIRB
  */
 struct hdac_bus {
@@ -363,6 +363,7 @@ struct hdac_bus {
 	/* locks */
 	spinlock_t reg_lock;
 	struct mutex cmd_mutex;
+	struct mutex lock;
 
 	/* DRM component interface */
 	struct drm_audio_component *audio_component;
@@ -373,11 +374,9 @@ struct hdac_bus {
 	int num_streams;
 	int idx;
 
+	/* link management */
 	struct list_head hlink_list;
-
-	struct mutex lock;
 	bool cmd_dma_state;
-
 };
 
 int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,

commit f144e67b0e683cbb2c476b20a93e27aa1cd9d458
Merge: 0bec6219e5a0 1284ec985572
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Mar 26 06:15:27 2019 +1000

    Merge tag 'drm-intel-next-2019-03-20' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    UAPI Changes:
    - Report an error early instead of SIGBUS later when mmap beyond BO size
    
    Core Changes:
    - This includes backmerge of drm-next and two merges of Maarten's
      topic/hdr-formats
    
    Driver Changes:
    - Add Comet Lake (Gen9) PCI IDs to Coffee Lake ID list (Anusha)
    - Add missing ICL PCI ID (Jose)
    - Fix legacy gamma mode for ICL (Ville)
    - Assume eDP is present on port A when there is no VBT (Thomas)
    - Corrections to eDP training patterns (Jose)
    - Fix PSR2 selective update corruption after PSR1 setup (Jose)
    - Fix CRC mismatch error for DP link layer compliance (Aditya)
    - Fix CNL DPLL readout and clean up code (Ville)
    - Turn off the CUS when turning off a HDR plane (Ville)
    - Avoid a race with execlist tasklet during race (Chris)
    - Add missing CSC readout and clean up code (Ville)
    - Avoid unnecessary wakeref during debugfs/drop_caches/set (Chris, Caz)
    - Hold references to ring/HW context/context explicitly when used (Chris)
    
    - Assume next platforms inherit old platform (Rodrigo)
    - Use HWS indices rather than addresses for breadcrumbs (Chris)
    - Add REG_BIT/REG_GENMASK and REG_FIELD_PREP macros (Jani)
    - Convert crept in C99 types to kernel fixed size types (Jani)
    - Avoid passing full dev_priv in forcewake functions (Daniele)
    - Reset GuC on GPU reset (Sujaritha)
    - Rework MG and Combo PLLs to vfuncs (Lucas)
    - Explicitly track ppGTT size (Chris, Bob)
    - Coding style improvements and code modularization (Ville)
    - Selftest and debugging improvements (Chris)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    # Conflicts:
    #       drivers/gpu/drm/i915/intel_hdmi.c
    From: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190325124925.GA12726@jlahtine-desk.ger.corp.intel.com

commit d31c85fc864269ab8e6fb6ed36c87f2fc33a9430
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Feb 13 15:21:09 2019 +0000

    snd/hda, drm/i915: Track the display_power_status using a cookie
    
    drm/i915 is tracking all wakeref owners with a cookie in order to
    identify leaks. To that end, each rpm acquisition ops->get_power is
    assigned a cookie which should be passed to ops->put_power to signify
    its release (and removal from the list of wakeref owners). As snd/hda is
    already using a bool to track current status of display_power extending
    that to an unsigned long to hold the boolean cookie is a trivial
    extension, and will quell all doubt that snd/hda is the cause of the
    device runtime pm leaks.
    
    v2: Keep using the power abstraction for local wakeref tracking.
    v3: BUILD_BUG_ON impedance mismatch
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190213152109.16997-1-chris@chris-wilson.co.uk

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index b4fa1c775251..a438ec8e535b 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -367,7 +367,7 @@ struct hdac_bus {
 	/* DRM component interface */
 	struct drm_audio_component *audio_component;
 	long display_power_status;
-	bool display_power_active;
+	unsigned long display_power_active;
 
 	/* parameters required for enhanced capabilities */
 	int num_streams;

commit 5dd3d271320d888bb708ca6252b8a9e416a7fe64
Author: Sameer Pujar <spujar@nvidia.com>
Date:   Mon Jan 14 23:51:09 2019 +0530

    ALSA: hda: Add api to program stripe control bits
    
    Controllers and codecs can support striping of audio out across
    multiple SDO lines. The number of supported SDO lines can be
    specific to chip. GCAP register can be read to know the maximum
    supported SDO lines.
    
    snd_hdac_get_stream_stripe_ctl() is exposed to program stripe bits
    on controller and codec side.
    stripe value: 0 for 1SDO, 1 for 2SDO, 2 for 4SDO lines, etc.,
    
    Signed-off-by: Sameer Pujar <spujar@nvidia.com>
    Reviewed-by: Mohan Kumar D <mkumard@nvidia.com>
    Reviewed-by: Ravindra Lokhande <rlokhande@nvidia.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index b4fa1c775251..45f944d57982 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -539,6 +539,9 @@ void snd_hdac_stream_sync(struct hdac_stream *azx_dev, bool start,
 			  unsigned int streams);
 void snd_hdac_stream_timecounter_init(struct hdac_stream *azx_dev,
 				      unsigned int streams);
+int snd_hdac_get_stream_stripe_ctl(struct hdac_bus *bus,
+				struct snd_pcm_substream *substream);
+
 /*
  * macros for easy use
  */

commit d82b51c855a20eb456ac09f2f40ea98312373263
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Sat Dec 15 14:07:23 2018 -0600

    ALSA: HD-Audio: SKL+: force HDaudio legacy or SKL+ driver selection
    
    For HDaudio and Skylake drivers, add module parameter "pci_binding"
    
    When pci_binding == 0 (AUTO), the PCI class/subclass info is used to
    select drivers based on the presence of the DSP.
    
    pci_binding == 1 (LEGACY) forces the use of the HDAudio legacy driver,
    even if the DSP is present.
    
    pci_binding == 2 (ASOC) forces the use of the ASOC driver. The
    information on the DSP presence is bypassed.
    
    The value for the module parameter needs to be identical for both
    drivers. This parameter is intended as a back-up solution if the
    automatic detection fails or when the DSP usage fails. Such cases
    should be reported on the alsa-devel mailing list for analysis.
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index f9b2b6330d27..b4fa1c775251 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -98,6 +98,12 @@ enum {
 	HDA_DEV_ASOC,
 };
 
+enum {
+	SND_SKL_PCI_BIND_AUTO,	/* automatic selection based on pci class */
+	SND_SKL_PCI_BIND_LEGACY,/* bind only with legacy driver */
+	SND_SKL_PCI_BIND_ASOC	/* bind only with ASoC driver */
+};
+
 /* direction */
 enum {
 	HDA_INPUT, HDA_OUTPUT

commit 18d43c9b88eb335440c5e769eb6c2d5bc908dc61
Author: Keyon Jie <yang.jie@linux.intel.com>
Date:   Tue Dec 11 15:30:27 2018 -0600

    ALSA: HDA: export process_unsol_events()
    
    The SOF implementation does not rely on the hdac_bus library, however
    for HDMI and HDaudio codec support it does need to deal with
    unsolicited events. Instead of re-inventing the wheel, export this
    symbol to reuse this part of the library directly.
    
    Signed-off-by: Keyon Jie <yang.jie@linux.intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 940e2b282133..f9b2b6330d27 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -387,6 +387,7 @@ void snd_hdac_bus_queue_event(struct hdac_bus *bus, u32 res, u32 res_ex);
 int snd_hdac_bus_add_device(struct hdac_bus *bus, struct hdac_device *codec);
 void snd_hdac_bus_remove_device(struct hdac_bus *bus,
 				struct hdac_device *codec);
+void snd_hdac_bus_process_unsol_events(struct work_struct *work);
 
 static inline void snd_hdac_codec_link_up(struct hdac_device *codec)
 {

commit 029d92c289bdad08ed08e61bf31b17cdc9ee61cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat Dec 8 17:31:49 2018 +0100

    ALSA: hda: Refactor display power management
    
    The current HD-audio code manages the DRM audio power via too complex
    redirections, and this seems even still unbalanced in a corner case as
    Intel DRM CI has been intermittently reporting.  This patch is a big
    surgery for addressing the complexity and the possible unbalance.
    
    Basically the patch changes the display PM in the following ways:
    
    - Both HD-audio controller and codec drivers call a single helper,
      snd_hdac_display_power().  (Formerly, the display power control from
      a codec was done indirectly via link_power bus ops.)
    
    - snd_hdac_display_power() receives the codec address index.  For
      turning on/off from the controller, pass HDA_CODEC_IDX_CONTROLLER.
    
    - snd_hdac_display_power() doesn't manage refcounts any longer, but
      keeps the power status in bitmap.  If any of controller or codecs is
      turned on, the function updates the DRM power state via get_power()
      or put_power().
    
    Also this refactor allows us more cleanup:
    
    - The link_power bus ops is dropped, so there is no longer indirect
      management, as mentioned in the above.
    
    - hdac_device link_power_control flag is moved to hda_codec
      display_power_control flag, as it's only for HDA legacy.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=106525
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index cd1773d0e08f..940e2b282133 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -79,7 +79,6 @@ struct hdac_device {
 
 	/* misc flags */
 	atomic_t in_pm;		/* suspend/resume being performed */
-	bool  link_power_control:1;
 
 	/* sysfs */
 	struct hdac_widget_tree *widgets;
@@ -237,8 +236,6 @@ struct hdac_bus_ops {
 	/* get a response from the last command */
 	int (*get_response)(struct hdac_bus *bus, unsigned int addr,
 			    unsigned int *res);
-	/* control the link power  */
-	int (*link_power)(struct hdac_bus *bus, bool enable);
 };
 
 /*
@@ -363,7 +360,8 @@ struct hdac_bus {
 
 	/* DRM component interface */
 	struct drm_audio_component *audio_component;
-	int drm_power_refcount;
+	long display_power_status;
+	bool display_power_active;
 
 	/* parameters required for enhanced capabilities */
 	int num_streams;
@@ -404,7 +402,6 @@ int snd_hdac_bus_send_cmd(struct hdac_bus *bus, unsigned int val);
 int snd_hdac_bus_get_response(struct hdac_bus *bus, unsigned int addr,
 			      unsigned int *res);
 int snd_hdac_bus_parse_capabilities(struct hdac_bus *bus);
-int snd_hdac_link_power(struct hdac_device *codec, bool enable);
 
 bool snd_hdac_bus_init_chip(struct hdac_bus *bus, bool full_reset);
 void snd_hdac_bus_stop_chip(struct hdac_bus *bus);

commit 196f4eeeb78f53e0a598db8f9408b6f8b270c355
Merge: c3b55e2ec9c7 75383f8d39d4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 17 18:59:21 2018 +0200

    Merge tag 'asoc-v4.19-rc4' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Fixes for v4.19
    
    This is the usual set of small fixes scatterd around various drivers,
    plus one fix for DAPM and a UAPI build fix.  There's not a huge amount
    that stands out here relative to anything else.

commit 75383f8d39d4c0fb96083dd460b7b139fbdac492
Author: Yu Zhao <yuzhao@google.com>
Date:   Tue Sep 11 15:15:16 2018 -0600

    sound: don't call skl_init_chip() to reset intel skl soc
    
    Internally, skl_init_chip() calls snd_hdac_bus_init_chip() which
    1) sets bus->chip_init to prevent multiple entrances before device
    is stopped; 2) enables interrupt.
    
    We shouldn't use it for the purpose of resetting device only because
    1) when we really want to initialize device, we won't be able to do
    so; 2) we are ready to handle interrupt yet, and kernel crashes when
    interrupt comes in.
    
    Rename azx_reset() to snd_hdac_bus_reset_link(), and use it to reset
    device properly.
    
    Fixes: 60767abcea3d ("ASoC: Intel: Skylake: Reset the controller in probe")
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Yu Zhao <yuzhao@google.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index ab5ee3ef2198..207e816ce6e1 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -384,6 +384,7 @@ void snd_hdac_bus_init_cmd_io(struct hdac_bus *bus);
 void snd_hdac_bus_stop_cmd_io(struct hdac_bus *bus);
 void snd_hdac_bus_enter_link_reset(struct hdac_bus *bus);
 void snd_hdac_bus_exit_link_reset(struct hdac_bus *bus);
+int snd_hdac_bus_reset_link(struct hdac_bus *bus, bool full_reset);
 
 void snd_hdac_bus_update_rirb(struct hdac_bus *bus);
 int snd_hdac_bus_handle_stream_irq(struct hdac_bus *bus, unsigned int status,

commit a6ea5fe95ab4a1a7af6d57429fe3ecde9acf5b5a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 25 23:19:36 2018 +0200

    ALSA: hda: Fix implicit PCM format type conversion
    
    The PCM format type is defined with __bitwise, hence it can't be
    passed as integer but needs an explicit cast.  In this patch, instead
    of the messy cast flood, define the format argument of
    snd_hdac_calc_stream_format() to be the proper snd_pcm_format_t type.
    
    This fixes sparse warnings like:
      sound/hda/hdac_device.c:760:38: warning: incorrect type in argument 1 (different base types)
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 8305e7971035..6f1e1f3b3063 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -11,6 +11,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/timecounter.h>
 #include <sound/core.h>
+#include <sound/pcm.h>
 #include <sound/memalloc.h>
 #include <sound/hda_verbs.h>
 #include <drm/i915_component.h>
@@ -133,7 +134,7 @@ int snd_hdac_get_sub_nodes(struct hdac_device *codec, hda_nid_t nid,
 			   hda_nid_t *start_id);
 unsigned int snd_hdac_calc_stream_format(unsigned int rate,
 					 unsigned int channels,
-					 unsigned int format,
+					 snd_pcm_format_t format,
 					 unsigned int maxbps,
 					 unsigned short spdif_ctls);
 int snd_hdac_query_supported_pcm(struct hdac_device *codec, hda_nid_t nid,

commit 7abeb64da6deeffa52f74e3b1e19d2c9e2c3ae6b
Merge: 58cabe8715f2 a57942bfdd61
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jul 19 20:48:06 2018 +0200

    Merge branch 'topic/drm_audio_component' into for-next
    
    Pull the generic drm_audio_component support, which will be used later
    for AMD/ATI and other HD-audio HDMI codec drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit ae891abe7c2ccf75b69ca8330225e37ecc06924e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 11 15:17:22 2018 +0200

    drm/i915: Split audio component to a generic type
    
    For allowing other drivers to use the DRM audio component, rename the
    i915_audio_component_* with drm_audio_component_*, and split the
    generic part into drm_audio_component.h.  The i915 specific stuff
    remains in struct i915_audio_component, which contains
    drm_audio_component as the base.
    
    The license of drm_audio_component.h is kept to MIT as same as the the
    original i915_component.h.
    
    This is a preliminary change for further development, and no
    functional changes by this patch itself, merely code-split and
    renames.
    
    v1->v2: Use SPDX for drm_audio_component.h, fix remaining i915
            argument in drm_audio_component.h
    
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index f1baaa88e766..ab5ee3ef2198 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -333,9 +333,9 @@ struct hdac_bus {
 	spinlock_t reg_lock;
 	struct mutex cmd_mutex;
 
-	/* i915 component interface */
-	struct i915_audio_component *audio_component;
-	int i915_power_refcount;
+	/* DRM component interface */
+	struct drm_audio_component *audio_component;
+	int drm_power_refcount;
 
 	/* parameters required for enhanced capabilities */
 	int num_streams;

commit 51d7d35817aad6f4dd0f60b80063206f1761b69b
Merge: 1259d239799b cb04ba33187c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jul 3 12:51:26 2018 +0200

    Merge branch 'topic/hda-core-intel' into for-next
    
    Merge the development branch for HD-audio ext bus refactoring.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit cb04ba33187ca571142b67c2fb60d0a8c24994c8
Author: Rakesh Ughreja <rakesh.a.ughreja@intel.com>
Date:   Fri Jun 1 22:53:58 2018 -0500

    ALSA: hdac: add extended ops in the hdac_bus
    
    Add extended ops in the hdac_bus to allow calling the ASoC HDAC library
    ops to reuse the legacy HDA codec drivers with ASoC framework.
    Extended ops are used by the legacy codec drivers to call into
    hdac_hda library, in the subsequent patches..
    
    Signed-off-by: Rakesh Ughreja <rakesh.a.ughreja@intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 59ffe63cf194..f1baaa88e766 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -213,6 +213,14 @@ struct hdac_bus_ops {
 	int (*link_power)(struct hdac_bus *bus, bool enable);
 };
 
+/*
+ * ops used for ASoC HDA codec drivers
+ */
+struct hdac_ext_bus_ops {
+	int (*hdev_attach)(struct hdac_device *hdev);
+	int (*hdev_detach)(struct hdac_device *hdev);
+};
+
 /*
  * Lowlevel I/O operators
  */
@@ -265,6 +273,7 @@ struct hdac_bus {
 	struct device *dev;
 	const struct hdac_bus_ops *ops;
 	const struct hdac_io_ops *io_ops;
+	const struct hdac_ext_bus_ops *ext_ops;
 
 	/* h/w resources */
 	unsigned long addr;

commit e1df9317cbb192582ed7aa88c5f294c2336a3c75
Author: Rakesh Ughreja <rakesh.a.ughreja@intel.com>
Date:   Fri Jun 1 22:53:51 2018 -0500

    ALSA: hdac: Remove usage of struct hdac_ext_driver, use hdac_driver instead
    
    This patch removes the hdac_ext_driver structure. The legacy and
    enhanced HDaudio capabilities can be handled in a backward-compatible
    way without separate definitions.
    
    Signed-off-by: Rakesh Ughreja <rakesh.a.ughreja@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 9735b51aef08..59ffe63cf194 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -188,6 +188,11 @@ struct hdac_driver {
 	const struct hda_device_id *id_table;
 	int (*match)(struct hdac_device *dev, struct hdac_driver *drv);
 	void (*unsol_event)(struct hdac_device *dev, unsigned int event);
+
+	/* fields used by ext bus APIs */
+	int (*probe)(struct hdac_device *dev);
+	int (*remove)(struct hdac_device *dev);
+	void (*shutdown)(struct hdac_device *dev);
 };
 
 #define drv_to_hdac_driver(_drv) container_of(_drv, struct hdac_driver, driver)

commit 76f56fae1cf9040325a58d1375291baf71dfaf03
Author: Rakesh Ughreja <rakesh.a.ughreja@intel.com>
Date:   Fri Jun 1 22:53:50 2018 -0500

    ALSA: hdac: Remove usage of struct hdac_ext_bus and use hdac_bus instead
    
    This patch removes the hdac_ext_bus structure. The legacy and
    enhanced HDaudio capabilities can be handled in a backward-compatible
    way without separate definitions.
    
    Follow-up patches in this series handle the driver definition.
    
    Signed-off-by: Rakesh Ughreja <rakesh.a.ughreja@intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index c052afc27547..9735b51aef08 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -250,6 +250,11 @@ struct hdac_rb {
  * @mlcap: MultiLink capabilities pointer
  * @gtscap: gts capabilities pointer
  * @drsmcap: dma resume capabilities pointer
+ * @num_streams: streams supported
+ * @idx: HDA link index
+ * @hlink_list: link list of HDA links
+ * @lock: lock for link mgmt
+ * @cmd_dma_state: state of cmd DMAs: CORB and RIRB
  */
 struct hdac_bus {
 	struct device *dev;
@@ -317,6 +322,16 @@ struct hdac_bus {
 	/* i915 component interface */
 	struct i915_audio_component *audio_component;
 	int i915_power_refcount;
+
+	/* parameters required for enhanced capabilities */
+	int num_streams;
+	int idx;
+
+	struct list_head hlink_list;
+
+	struct mutex lock;
+	bool cmd_dma_state;
+
 };
 
 int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,

commit feb20faec73ba0b30f949d54c4153cf0ad3807c8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 27 09:03:51 2018 +0200

    ALSA: hda - Move in_pm accessors to HDA core
    
    The in_pm atomic in hdac_device is an important field used as a flag
    as well as a refcount for PM.  The existing snd_hdac_power_up/down
    helpers already refer to it in the HD-audio core code, while the code
    to actually setting the value (atomic_inc() / _dec()) is open-coded in
    HDA legacy side, which is hard to find.
    
    This patch adds the helper functions to set/reset the in_pm counter to
    HDA core and use them in HDA legacy side, for making it clearer who /
    where the PM is managed.
    
    There is no functional changes, just code refactoring.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index c052afc27547..294a5a21937b 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -8,6 +8,7 @@
 
 #include <linux/device.h>
 #include <linux/interrupt.h>
+#include <linux/pm_runtime.h>
 #include <linux/timecounter.h>
 #include <sound/core.h>
 #include <sound/memalloc.h>
@@ -171,12 +172,38 @@ int snd_hdac_power_down(struct hdac_device *codec);
 int snd_hdac_power_up_pm(struct hdac_device *codec);
 int snd_hdac_power_down_pm(struct hdac_device *codec);
 int snd_hdac_keep_power_up(struct hdac_device *codec);
+
+/* call this at entering into suspend/resume callbacks in codec driver */
+static inline void snd_hdac_enter_pm(struct hdac_device *codec)
+{
+	atomic_inc(&codec->in_pm);
+}
+
+/* call this at leaving from suspend/resume callbacks in codec driver */
+static inline void snd_hdac_leave_pm(struct hdac_device *codec)
+{
+	atomic_dec(&codec->in_pm);
+}
+
+static inline bool snd_hdac_is_in_pm(struct hdac_device *codec)
+{
+	return atomic_read(&codec->in_pm);
+}
+
+static inline bool snd_hdac_is_power_on(struct hdac_device *codec)
+{
+	return !pm_runtime_suspended(&codec->dev);
+}
 #else
 static inline int snd_hdac_power_up(struct hdac_device *codec) { return 0; }
 static inline int snd_hdac_power_down(struct hdac_device *codec) { return 0; }
 static inline int snd_hdac_power_up_pm(struct hdac_device *codec) { return 0; }
 static inline int snd_hdac_power_down_pm(struct hdac_device *codec) { return 0; }
 static inline int snd_hdac_keep_power_up(struct hdac_device *codec) { return 0; }
+static inline void snd_hdac_enter_pm(struct hdac_device *codec) {}
+static inline void snd_hdac_leave_pm(struct hdac_device *codec) {}
+static inline bool snd_hdac_is_in_pm(struct hdac_device *codec) { return 0; }
+static inline bool snd_hdac_is_power_on(struct hdac_device *codec) { return 1; }
 #endif
 
 /*

commit a9c2dfc8527318a27db045cd7ea51e8ecab8c884
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 23 17:24:56 2018 +0200

    ALSA: hda - Use a macro for snd_array iteration loops
    
    Introduce a new helper macro, snd_array_for_each(), to iterate for
    each snd_array element.  It slightly improves the readability than
    lengthy open codes at each place.
    
    Along with it, add const prefix to some obvious places.
    
    There should be no functional changes by this.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 06536e01ed94..c052afc27547 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -571,4 +571,9 @@ static inline unsigned int snd_array_index(struct snd_array *array, void *ptr)
 	return (unsigned long)(ptr - array->list) / array->elem_size;
 }
 
+/* a helper macro to iterate for each snd_array element */
+#define snd_array_for_each(array, idx, ptr) \
+	for ((idx) = 0, (ptr) = (array)->list; (idx) < (array)->used; \
+	     (ptr) = snd_array_elem(array, ++(idx)))
+
 #endif /* __SOUND_HDAUDIO_H */

commit e02d37bf55a9a36f22427fd6dd733fe104d817b6
Merge: 652ede37cec0 a820ccbe21e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 5 10:42:07 2018 -0700

    Merge tag 'sound-4.17-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "This became a large update. The changes are scattered widely, and the
      majority of them are attributed to ASoC componentization. The gitk
      output made me dizzy, but it's slightly better than London tube.
    
      OK, below are some highlights:
    
       - Continued hardening works in ALSA PCM core; most of the existing
         syzkaller reports should have been covered.
    
       - USB-audio got the initial USB Audio Class 3 support, as well as
         UAC2 jack detection support and more DSD-device support.
    
       - ASoC componentization: finally each individual driver was converted
         to components framework, which is more future-proof for further
         works. Most of conversations were systematic.
    
       - Lots of fixes for Intel Baytrail / Cherrytrail devices with Realtek
         codecs, typically tablets and small PCs.
    
       - Fixes / cleanups for Samsung Odroid systems
    
       - Cleanups in Freescale SSI driver
    
       - New ASoC drivers:
          * AKM AK4458 and AK5558 codecs
          * A few AMD based machine drivers
          * Intel Kabylake machine drivers
          * Maxim MAX9759 codec
          * Motorola CPCAP codec
          * Socionext Uniphier SoCs
          * TI PCM1789 and TDA7419 codecs
    
       - Retirement of Blackfin drivers along with architecture removal"
    
    * tag 'sound-4.17-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (497 commits)
      ALSA: pcm: Fix UAF at PCM release via PCM timer access
      ALSA: usb-audio: silence a static checker warning
      ASoC: tscs42xx: Remove owner assignment from i2c_driver
      ASoC: mediatek: remove "simple-mfd" in the example
      ASoC: cpcap: replace codec to component
      ASoC: Intel: bytcr_rt5651: don't use codec anymore
      ASoC: amd: don't use codec anymore
      ALSA: usb-audio: fix memory leak on cval
      ALSA: pcm: Fix mutex unbalance in OSS emulation ioctls
      ASoC: topology: Fix kcontrol name string handling
      ALSA: aloop: Mark paused device as inactive
      ALSA: usb-audio: update clock valid control
      ALSA: usb-audio: UAC2 jack detection
      ALSA: pcm: Return -EBUSY for OSS ioctls changing busy streams
      ALSA: pcm: Avoid potential races between OSS ioctls and read/write
      ALSA: usb-audio: Integrate native DSD support for ITF-USB based DACs.
      ALSA: usb-audio: FIX native DSD support for TEAC UD-501 DAC
      ALSA: usb-audio: Add native DSD support for Luxman DA-06
      ALSA: usb-audio: fix uac control query argument
      ASoC: nau8824: recover system clock when device changes
      ...

commit 07f4f97d7b4bf325d9f558c5b58230387e4e57e0
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Mar 3 10:53:24 2018 +0100

    vga_switcheroo: Use device link for HDA controller
    
    Back in 2013, runtime PM for GPUs with integrated HDA controller was
    introduced with commits 0d69704ae348 ("gpu/vga_switcheroo: add driver
    control power feature. (v3)") and 246efa4a072f ("snd/hda: add runtime
    suspend/resume on optimus support (v4)").
    
    Briefly, the idea was that the HDA controller is forced on and off in
    unison with the GPU.
    
    The original code is mostly still in place even though it was never a
    100% perfect solution:  E.g. on access to the HDA controller, the GPU
    is powered up via vga_switcheroo_runtime_resume_hdmi_audio() but there
    are no provisions to keep it resumed until access to the HDA controller
    has ceased:  The GPU autosuspends after 5 seconds, rendering the HDA
    controller inaccessible.
    
    Additionally, a kludge is required when hda_intel.c probes:  It has to
    check whether the GPU is powered down (check_hdmi_disabled()) and defer
    probing if so.
    
    However in the meantime (in v4.10) the driver core has gained a feature
    called device links which promises to solve such issues in a clean way:
    It allows us to declare a dependency from the HDA controller (consumer)
    to the GPU (supplier).  The PM core then automagically ensures that the
    GPU is runtime resumed as long as the HDA controller's ->probe hook is
    executed and whenever the HDA controller is accessed.
    
    By default, the HDA controller has a dependency on its parent, a PCIe
    Root Port.  Adding a device link creates another dependency on its
    sibling:
    
                                PCIe Root Port
                                 ^          ^
                                 |          |
                                 |          |
                                HDA  ===>  GPU
    
    The device link is not only used for runtime PM, it also guarantees that
    on system sleep, the HDA controller suspends before the GPU and resumes
    after the GPU, and on system shutdown the HDA controller's ->shutdown
    hook is executed before the one of the GPU.  It is a complete solution.
    
    Using this functionality is as simple as calling device_link_add(),
    which results in a dmesg entry like this:
    
            pci 0000:01:00.1: Linked as a consumer to 0000:01:00.0
    
    The code for the GPU-governed audio power management can thus be removed
    (except where it's still needed for legacy manual power control).
    
    The device link is added in a PCI quirk rather than in hda_intel.c.
    It is therefore legal for the GPU to runtime suspend to D3cold even if
    the HDA controller is not bound to a driver or if CONFIG_SND_HDA_INTEL
    is not enabled, for accesses to the HDA controller will cause the GPU to
    wake up regardless if they're occurring outside of hda_intel.c (think
    config space readout via sysfs).
    
    Contrary to the previous implementation, the HDA controller's power
    state is now self-governed, rather than GPU-governed, whereas the GPU's
    power state is no longer fully self-governed.  (The HDA controller needs
    to runtime suspend before the GPU can.)
    
    It is thus crucial that runtime PM is always activated on the HDA
    controller even if CONFIG_SND_HDA_POWER_SAVE_DEFAULT is set to 0 (which
    is the default), lest the GPU stays awake.  This is achieved by setting
    the auto_runtime_pm flag on every codec and the AZX_DCAPS_PM_RUNTIME
    flag on the HDA controller.
    
    A side effect is that power consumption might be reduced if the GPU is
    in use but the HDA controller is not, because the HDA controller is now
    allowed to go to D3hot.  Before, it was forced to stay in D0 as long as
    the GPU was in use.  (There is no reduction in power consumption on my
    Nvidia GK107, but there might be on other chips.)
    
    The code paths for legacy manual power control are adjusted such that
    runtime PM is disabled during power off, thereby preventing the PM core
    from resuming the HDA controller.
    
    Note that the device link is not only added on vga_switcheroo capable
    systems, but for *any* GPU with integrated HDA controller.  The idea is
    that the HDA controller streams audio via connectors located on the GPU,
    so the GPU needs to be on for the HDA controller to do anything useful.
    
    This commit implicitly fixes an unbalanced runtime PM ref upon unbind of
    hda_intel.c:  On ->probe, a runtime PM ref was previously released under
    the condition "azx_has_pm_runtime(chip) || hda->use_vga_switcheroo", but
    on ->remove a runtime PM ref was only acquired under the first of those
    conditions.  Thus, binding and unbinding the driver twice on a
    vga_switcheroo capable system caused the runtime PM refcount to drop
    below zero.  The issue is resolved because the AZX_DCAPS_PM_RUNTIME flag
    is now always set if use_vga_switcheroo is true.
    
    For more information on device links please refer to:
    https://www.kernel.org/doc/html/latest/driver-api/device_link.html
    Documentation/driver-api/device_link.rst
    
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Reviewed-by: Peter Wu <peter@lekensteyn.nl>
    Tested-by: Kai Heng Feng <kai.heng.feng@canonical.com> # AMD PowerXpress
    Tested-by: Mike Lothian <mike@fireburn.co.uk>          # AMD PowerXpress
    Tested-by: Denis Lisov <dennis.lissov@gmail.com>       # Nvidia Optimus
    Tested-by: Peter Wu <peter@lekensteyn.nl>              # Nvidia Optimus
    Tested-by: Lukas Wunner <lukas@wunner.de>              # MacBook Pro
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/51bd38360ff502a8c42b1ebf4405ee1d3f27118d.1520068884.git.lukas@wunner.de

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 68169e3749de..5b2ed12f58ce 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -227,9 +227,6 @@ struct hdac_io_ops {
 #define HDA_UNSOL_QUEUE_SIZE	64
 #define HDA_MAX_CODECS		8	/* limit by controller side */
 
-/* HD Audio class code */
-#define PCI_CLASS_MULTIMEDIA_HD_AUDIO	0x0403
-
 /*
  * CORB/RIRB
  *

commit 09787492537462e3c7b8f67b30ff9704062f97cc
Author: Abhijeet Kumar <abhijeet.kumar@intel.com>
Date:   Tue Jan 23 23:00:51 2018 +0530

    ALSA: hda: Copying sync power state helper to core
    
    The current sync_power_state is local to hda code, moving it
    core so that other users apart from hda legacy can use it.
    The helper function ensures the actual state reaches the target state.
    
    Signed-off-by: Abhijeet Kumar <abhijeet.kumar@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 68169e3749de..4c93ff5301bd 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -146,6 +146,8 @@ int snd_hdac_codec_write(struct hdac_device *hdac, hda_nid_t nid,
 			int flags, unsigned int verb, unsigned int parm);
 bool snd_hdac_check_power_state(struct hdac_device *hdac,
 		hda_nid_t nid, unsigned int target_state);
+unsigned int snd_hdac_sync_power_state(struct hdac_device *hdac,
+		      hda_nid_t nid, unsigned int target_state);
 /**
  * snd_hdac_read_parm - read a codec parameter
  * @codec: the codec object

commit 76727c2c3bf4a5e58dff8cca23d0147ba08fb2c8
Merge: c429bda21ffa df6a3e245541
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 13 15:45:57 2017 +0100

    Merge tag 'asoc-v4.15' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v4.15
    
    The biggest thing this release has been the conversion of the AC98 bus
    to the driver model, that's been a long time coming so thanks to Robert
    Jarzmik for his dedication there.  Due to there being some AC97 MFD
    there's a few fairly large changes in input and the MFD layer, mainly to
    the wm97xx driver.
    
    There's also some drivers/drm changes to support the new AMD Stoney
    platform, these are shared with the DRM subsystem and should be being
    merged via both.
    
    Within the subsystem the overwhelming bulk of the changes is in the
    Intel drivers which continue to need lots of cleanups and fixes, this
    release they've also gained support for their open source firmware.
    There's also some large changs in the core as Morimoto-san continues to
    mirror operations into the component level in preparation for conversion
    of drivers to that.
    
     - The AC97 bus has finally caught up with the driver model thanks to
       some dedicated and persistent work from Robert Jarzmik.
     - Continued work from Morimoto-san on moving us towards being able to
       use components for everything.
     - Lots of cleanups for the Intel platform code, including support for
       their open source audio firmware.
     - Support for scaling MCLK with sample rate in simple-card.
     - Support for AMD Stoney platform.

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 96546b30e900..d8afd8a5bd76 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * HD-audio core stuff
  */

commit 9780ded39bef5d22a84bdc39112df93f70a58bdd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 18 15:51:59 2017 +0200

    ALSA: hda: Avoid racy recreation of widget kobjects
    
    The refresh of HD-audio widget sysfs kobjects via
    snd_hdac_refresh_widget_sysfs() is slightly racy.
    The driver recreates the whole tree from scratch after deleting the
    whole.  When CONFIG_DEBUG_KOBJECT_RELEASE option is used, kobject
    release doesn't happen immediately but delayed, while the re-creation
    of the same named kobject happens soon after invoking kobject_put().
    This may end up with the conflicts of duplicated kobjects, as found in
    the bug report below.
    
    In this patch, we take another approach to refresh the tree: instead
    of recreating the whole tree, just add the new nodes and delete the
    non-existing nodes.  Since the refresh happens only once at
    initialization, no longer race would happen.
    
    Along with the code change, merge snd_hdac_refresh_widget_sysfs() with
    the existing snd_hdac_refresh_widgets() with an additional bool flag
    for simplifying the code.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=197307
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 96546b30e900..6f1118545bb8 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -111,8 +111,7 @@ void snd_hdac_device_unregister(struct hdac_device *codec);
 int snd_hdac_device_set_chip_name(struct hdac_device *codec, const char *name);
 int snd_hdac_codec_modalias(struct hdac_device *hdac, char *buf, size_t size);
 
-int snd_hdac_refresh_widgets(struct hdac_device *codec);
-int snd_hdac_refresh_widget_sysfs(struct hdac_device *codec);
+int snd_hdac_refresh_widgets(struct hdac_device *codec, bool sysfs);
 
 unsigned int snd_hdac_make_cmd(struct hdac_device *codec, hda_nid_t nid,
 			       unsigned int verb, unsigned int parm);

commit 2c1f81381eadc6dd3c288ec4477b2fe572cf86dc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 29 08:27:15 2017 +0200

    ALSA: hda - Avoid tricky macros
    
    The macros _snd_hdac_chip_read() and *_write() expand to different
    types (b,w,l) per their argument.  They were thought to be used only
    internally for other snd_hdac_chip_*() macros, but in some situations
    we need to call these directly, and they are way too ugly.
    
    Instead of saving a few lines, we just write these macros explicitly
    with the types, so that they can be used in a saner way.
    
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 56004ec8d441..96546b30e900 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -368,24 +368,32 @@ void snd_hdac_bus_free_stream_pages(struct hdac_bus *bus);
 /*
  * macros for easy use
  */
-#define _snd_hdac_chip_write(type, chip, reg, value) \
-	((chip)->io_ops->reg_write ## type(value, (chip)->remap_addr + (reg)))
-#define _snd_hdac_chip_read(type, chip, reg) \
-	((chip)->io_ops->reg_read ## type((chip)->remap_addr + (reg)))
+#define _snd_hdac_chip_writeb(chip, reg, value) \
+	((chip)->io_ops->reg_writeb(value, (chip)->remap_addr + (reg)))
+#define _snd_hdac_chip_readb(chip, reg) \
+	((chip)->io_ops->reg_readb((chip)->remap_addr + (reg)))
+#define _snd_hdac_chip_writew(chip, reg, value) \
+	((chip)->io_ops->reg_writew(value, (chip)->remap_addr + (reg)))
+#define _snd_hdac_chip_readw(chip, reg) \
+	((chip)->io_ops->reg_readw((chip)->remap_addr + (reg)))
+#define _snd_hdac_chip_writel(chip, reg, value) \
+	((chip)->io_ops->reg_writel(value, (chip)->remap_addr + (reg)))
+#define _snd_hdac_chip_readl(chip, reg) \
+	((chip)->io_ops->reg_readl((chip)->remap_addr + (reg)))
 
 /* read/write a register, pass without AZX_REG_ prefix */
 #define snd_hdac_chip_writel(chip, reg, value) \
-	_snd_hdac_chip_write(l, chip, AZX_REG_ ## reg, value)
+	_snd_hdac_chip_writel(chip, AZX_REG_ ## reg, value)
 #define snd_hdac_chip_writew(chip, reg, value) \
-	_snd_hdac_chip_write(w, chip, AZX_REG_ ## reg, value)
+	_snd_hdac_chip_writew(chip, AZX_REG_ ## reg, value)
 #define snd_hdac_chip_writeb(chip, reg, value) \
-	_snd_hdac_chip_write(b, chip, AZX_REG_ ## reg, value)
+	_snd_hdac_chip_writeb(chip, AZX_REG_ ## reg, value)
 #define snd_hdac_chip_readl(chip, reg) \
-	_snd_hdac_chip_read(l, chip, AZX_REG_ ## reg)
+	_snd_hdac_chip_readl(chip, AZX_REG_ ## reg)
 #define snd_hdac_chip_readw(chip, reg) \
-	_snd_hdac_chip_read(w, chip, AZX_REG_ ## reg)
+	_snd_hdac_chip_readw(chip, AZX_REG_ ## reg)
 #define snd_hdac_chip_readb(chip, reg) \
-	_snd_hdac_chip_read(b, chip, AZX_REG_ ## reg)
+	_snd_hdac_chip_readb(chip, AZX_REG_ ## reg)
 
 /* update a register, pass without AZX_REG_ prefix */
 #define snd_hdac_chip_updatel(chip, reg, mask, val) \

commit 6720b38420a01d40dbeb8ee575eb601d612de691
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Thu Aug 4 15:46:00 2016 +0530

    ALSA: hda - move bus_parse_capabilities to core
    
    HDA capability introduced recently are move to hdac core so that it can
    be used by legacy driver as well. Also move the capability pointers up
    to hdac_bus object.
    
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 93e63c56f48f..56004ec8d441 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -245,6 +245,12 @@ struct hdac_rb {
 
 /*
  * HD-audio bus base driver
+ *
+ * @ppcap: pp capabilities pointer
+ * @spbcap: SPIB capabilities pointer
+ * @mlcap: MultiLink capabilities pointer
+ * @gtscap: gts capabilities pointer
+ * @drsmcap: dma resume capabilities pointer
  */
 struct hdac_bus {
 	struct device *dev;
@@ -256,6 +262,12 @@ struct hdac_bus {
 	void __iomem *remap_addr;
 	int irq;
 
+	void __iomem *ppcap;
+	void __iomem *spbcap;
+	void __iomem *mlcap;
+	void __iomem *gtscap;
+	void __iomem *drsmcap;
+
 	/* codec linked list */
 	struct list_head codec_list;
 	unsigned int num_codecs;
@@ -335,6 +347,7 @@ static inline void snd_hdac_codec_link_down(struct hdac_device *codec)
 int snd_hdac_bus_send_cmd(struct hdac_bus *bus, unsigned int val);
 int snd_hdac_bus_get_response(struct hdac_bus *bus, unsigned int addr,
 			      unsigned int *res);
+int snd_hdac_bus_parse_capabilities(struct hdac_bus *bus);
 int snd_hdac_link_power(struct hdac_device *codec, bool enable);
 
 bool snd_hdac_bus_init_chip(struct hdac_bus *bus, bool full_reset);

commit fc4f000bf8c0cbf38f44de6bd5e225574e572ed4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Mar 4 11:34:18 2016 +0100

    ALSA: hda - Fix unexpected resume through regmap code path
    
    HD-audio driver has a mechanism to trigger the runtime resume
    automatically at accessing the verbs.  This auto-resume, however,
    causes the mutex deadlock when invoked from the regmap handler since
    the regmap keeps the mutex while auto-resuming.  For avoiding that,
    there is some tricky check in the HDA regmap handler to return -EAGAIN
    error to back-off when the codec is powered down.  Then the caller of
    regmap r/w will retry after properly turning on the codec power.
    
    This works in most cases, but there seems a slight race between the
    codec power check and the actual on-demand auto-resume trigger.  This
    resulted in the lockdep splat, eventually leading to a real deadlock.
    
    This patch tries to address the race window by getting the runtime PM
    refcount at the check time using pm_runtime_get_if_in_use().  With
    this call, we can keep the power on only when the codec has been
    already turned on, and back off if not.
    
    For keeping the code consistency, the code touching the runtime PM is
    stored in hdac_device.c although it's used only locally in
    hdac_regmap.c.
    
    Reported-by: Jiri Slaby <jslaby@suse.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index c21c38ce7450..93e63c56f48f 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -168,11 +168,13 @@ int snd_hdac_power_up(struct hdac_device *codec);
 int snd_hdac_power_down(struct hdac_device *codec);
 int snd_hdac_power_up_pm(struct hdac_device *codec);
 int snd_hdac_power_down_pm(struct hdac_device *codec);
+int snd_hdac_keep_power_up(struct hdac_device *codec);
 #else
 static inline int snd_hdac_power_up(struct hdac_device *codec) { return 0; }
 static inline int snd_hdac_power_down(struct hdac_device *codec) { return 0; }
 static inline int snd_hdac_power_up_pm(struct hdac_device *codec) { return 0; }
 static inline int snd_hdac_power_down_pm(struct hdac_device *codec) { return 0; }
+static inline int snd_hdac_keep_power_up(struct hdac_device *codec) { return 0; }
 #endif
 
 /*

commit 473f414564528a819f0c2bb6b4bf26366b64c9ab
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 23 15:54:47 2016 +0100

    ALSA: hda - Loop interrupt handling until really cleared
    
    Currently the interrupt handler of HD-audio driver assumes that no irq
    update is needed while processing the irq.  But in reality, it has
    been confirmed that the HW irq is issued even during the irq
    handling.  Since we clear the irq status at the beginning, process the
    interrupt, then exits from the handler, the lately issued interrupt is
    left untouched without being properly processed.
    
    This patch changes the interrupt handler code to loop over the
    check-and-process.  The handler tries repeatedly as long as the IRQ
    status are turned on, and either stream or CORB/RIRB is handled.
    
    For checking the stream handling, snd_hdac_bus_handle_stream_irq()
    returns a value indicating the stream indices bits.  Other than that,
    the change is only in the irq handler itself.
    
    Reported-by: Libin Yang <libin.yang@linux.intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index e2b712c90d3f..c21c38ce7450 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -343,7 +343,7 @@ void snd_hdac_bus_enter_link_reset(struct hdac_bus *bus);
 void snd_hdac_bus_exit_link_reset(struct hdac_bus *bus);
 
 void snd_hdac_bus_update_rirb(struct hdac_bus *bus);
-void snd_hdac_bus_handle_stream_irq(struct hdac_bus *bus, unsigned int status,
+int snd_hdac_bus_handle_stream_irq(struct hdac_bus *bus, unsigned int status,
 				    void (*ack)(struct hdac_bus *,
 						struct hdac_stream *));
 

commit 4f9e0c38c5e991e2d050d13e28be74b93ab704c0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Oct 16 11:35:49 2015 +0200

    ALSA: hda - Add a common helper to give the codec modalias string
    
    This patch provide a new common helper function,
    snd_hdac_codec_modalias(), to give the codec modalias name string.
    This function will be used by multiple places in the later patches.
    
    Reviewed-by: Vinod Koul <vinod.koul@intel.com>
    Tested-by: Subhransu S Prusty <subhransu.s.prusty@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index ddca48eb02e0..e2b712c90d3f 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -109,6 +109,7 @@ void snd_hdac_device_exit(struct hdac_device *dev);
 int snd_hdac_device_register(struct hdac_device *codec);
 void snd_hdac_device_unregister(struct hdac_device *codec);
 int snd_hdac_device_set_chip_name(struct hdac_device *codec, const char *name);
+int snd_hdac_codec_modalias(struct hdac_device *hdac, char *buf, size_t size);
 
 int snd_hdac_refresh_widgets(struct hdac_device *codec);
 int snd_hdac_refresh_widget_sysfs(struct hdac_device *codec);

commit da23ac1e40ce844d1a9553906bdacce160af76f6
Author: Subhransu S. Prusty <subhransu.s.prusty@intel.com>
Date:   Tue Sep 29 13:56:10 2015 +0530

    ALSA: hda - Add hduadio support to DEVTABLE
    
    For generating modalias entries automatically, move the definition of
    struct hda_device_id to linux/mod_devicetable.h and add the handling
    of this record in file2alias helper.  The new modalias is represented
    with combination of vendor id, device id, and api version as
    "hdaudio:vNrNaN".
    
    This patch itself doesn't convert the existing modaliases.  Since they
    were added manually, this patch won't give any regression by itself at
    this point.
    
    [Modified the modalias format to adapt the api_version field, and drop
     invalid ANY_ID definition by tiwai]
    
    Signed-off-by: Subhransu S. Prusty <subhransu.s.prusty@intel.com>
    Reviewed-by: Vinod Koul <vinod.koul@intel.com>
    Tested-by: Subhransu S Prusty <subhransu.s.prusty@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index b35bf59a1ecc..ddca48eb02e0 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -21,23 +21,13 @@ struct hdac_stream;
 struct hdac_device;
 struct hdac_driver;
 struct hdac_widget_tree;
+struct hda_device_id;
 
 /*
  * exported bus type
  */
 extern struct bus_type snd_hda_bus_type;
 
-/*
- * HDA device table
- */
-struct hda_device_id {
-	__u32 vendor_id;
-	__u32 rev_id;
-	__u8 api_version;
-	const char *name;
-	unsigned long driver_data;
-};
-
 /*
  * generic arrays
  */

commit 93ed8560e98afc486df94f5a6238c1f0894b38b8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 15 21:35:53 2015 +0200

    ALSA: hda - Add api_version to hda_device_id struct
    
    For distinguishing the difference between HDA legacy and ext codec
    driver entries, we need to expose the value corresponding to type
    field.  This patch adds a new field, api_version, to hda_device_id
    struct, so that this information is embedded in modalias string.
    
    Although the information is basically redundant (struct hdac_device
    already has type field), the helper that extracts from
    MODULE_DEVICE_TABLE() won't take it account except for the exported
    table entries themselves.  So we need to put the same information in
    the table, too.
    
    Reviewed-by: Vinod Koul <vinod.koul@intel.com>
    Tested-by: Subhransu S Prusty <subhransu.s.prusty@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 49df61c7afdc..b35bf59a1ecc 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -33,6 +33,7 @@ extern struct bus_type snd_hda_bus_type;
 struct hda_device_id {
 	__u32 vendor_id;
 	__u32 rev_id;
+	__u8 api_version;
 	const char *name;
 	unsigned long driver_data;
 };

commit ded255be2276d365a91af2de7c7f8e2c233d4fa2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 1 17:59:43 2015 +0200

    ALSA: hda - consolidate chip rename functions
    
    A few multiple codec drivers do renaming the chip_name string but all
    these are open-coded and some of them have even no error check.  Let's
    make common helpers to do it properly.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 26e956f4b7c6..49df61c7afdc 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -117,6 +117,7 @@ int snd_hdac_device_init(struct hdac_device *dev, struct hdac_bus *bus,
 void snd_hdac_device_exit(struct hdac_device *dev);
 int snd_hdac_device_register(struct hdac_device *codec);
 void snd_hdac_device_unregister(struct hdac_device *codec);
+int snd_hdac_device_set_chip_name(struct hdac_device *codec, const char *name);
 
 int snd_hdac_refresh_widgets(struct hdac_device *codec);
 int snd_hdac_refresh_widget_sysfs(struct hdac_device *codec);

commit 1b5e6167c27e1d3be33155baf9660768ac74aae0
Author: Subhransu S. Prusty <subhransu.s.prusty@intel.com>
Date:   Thu Oct 8 09:48:05 2015 +0100

    ALSA: hdac: Copy codec helpers to core
    
    The current codec helpers are local to hda code and needs to be moved to
    core so that other users can use it.
    The helpers to read/write the codec and to check the
    power state of widgets is copied
    
    Signed-off-by: Subhransu S. Prusty <subhransu.s.prusty@intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 49bc836fcd84..26e956f4b7c6 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -147,6 +147,12 @@ int snd_hdac_query_supported_pcm(struct hdac_device *codec, hda_nid_t nid,
 bool snd_hdac_is_supported_format(struct hdac_device *codec, hda_nid_t nid,
 				  unsigned int format);
 
+int snd_hdac_codec_read(struct hdac_device *hdac, hda_nid_t nid,
+			int flags, unsigned int verb, unsigned int parm);
+int snd_hdac_codec_write(struct hdac_device *hdac, hda_nid_t nid,
+			int flags, unsigned int verb, unsigned int parm);
+bool snd_hdac_check_power_state(struct hdac_device *hdac,
+		hda_nid_t nid, unsigned int target_state);
 /**
  * snd_hdac_read_parm - read a codec parameter
  * @codec: the codec object

commit 4308c9b083fbab1a442e68a03de099841791df27
Author: Jeeja KP <jeeja.kp@intel.com>
Date:   Sun Aug 23 11:52:51 2015 +0530

    ALSA: hdac: Add snd_hdac_get_hdac_stream()
    
    Add a helper to find the stream using stream tag and direction.
    This is useful for drivers to query stream based on stream tag
    and direction, fox example while downloading FW thru DSP loader
    code
    
    Signed-off-by: Jeeja KP <jeeja.kp@intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 23a44c39c51c..49bc836fcd84 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -438,6 +438,8 @@ void snd_hdac_stream_init(struct hdac_bus *bus, struct hdac_stream *azx_dev,
 struct hdac_stream *snd_hdac_stream_assign(struct hdac_bus *bus,
 					   struct snd_pcm_substream *substream);
 void snd_hdac_stream_release(struct hdac_stream *azx_dev);
+struct hdac_stream *snd_hdac_get_stream(struct hdac_bus *bus,
+					int dir, int stream_tag);
 
 int snd_hdac_stream_setup(struct hdac_stream *azx_dev);
 void snd_hdac_stream_cleanup(struct hdac_stream *azx_dev);

commit 18dfd79d92e5292611ac4944a67bd837dd7632c9
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Fri Aug 21 15:47:43 2015 +0530

    ALSA: hdac: add snd_hdac_refresh_widget_sysfs()
    
    Some codecs like Intel HDMI by default do not show up all the pins, they
    have to be manually enabled, so we need to refresh the codec widgets and
    then recreate the sysfs tree. So add new API snd_hdac_refresh_widget_sysfs()
    to do this. It should be be used by codec driver after sending magic verbs
    to codec
    
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 288c7fa509d8..23a44c39c51c 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -119,6 +119,7 @@ int snd_hdac_device_register(struct hdac_device *codec);
 void snd_hdac_device_unregister(struct hdac_device *codec);
 
 int snd_hdac_refresh_widgets(struct hdac_device *codec);
+int snd_hdac_refresh_widget_sysfs(struct hdac_device *codec);
 
 unsigned int snd_hdac_make_cmd(struct hdac_device *codec, hda_nid_t nid,
 			       unsigned int verb, unsigned int parm);

commit fbce23a0b95763dfc4961ce6240e055c39f497ed
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jul 17 16:27:33 2015 +0200

    ALSA: hda - Check the return value from pm_runtime_get/put*()
    
    This patch changes the return type of snd_hdac_power_up/down() and
    variants to pass the error code from the underlying
    pm_runtime_get/put() calls.  Currently they are ignored, but in most
    places, these should be handled properly.
    
    As an example, the regmap handler is updated to check the return value
    and accesses the register only when the wakeup succeeds.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 4caf1fde8a4f..288c7fa509d8 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -164,15 +164,15 @@ static inline int snd_hdac_read_parm(struct hdac_device *codec, hda_nid_t nid,
 }
 
 #ifdef CONFIG_PM
-void snd_hdac_power_up(struct hdac_device *codec);
-void snd_hdac_power_down(struct hdac_device *codec);
-void snd_hdac_power_up_pm(struct hdac_device *codec);
-void snd_hdac_power_down_pm(struct hdac_device *codec);
+int snd_hdac_power_up(struct hdac_device *codec);
+int snd_hdac_power_down(struct hdac_device *codec);
+int snd_hdac_power_up_pm(struct hdac_device *codec);
+int snd_hdac_power_down_pm(struct hdac_device *codec);
 #else
-static inline void snd_hdac_power_up(struct hdac_device *codec) {}
-static inline void snd_hdac_power_down(struct hdac_device *codec) {}
-static inline void snd_hdac_power_up_pm(struct hdac_device *codec) {}
-static inline void snd_hdac_power_down_pm(struct hdac_device *codec) {}
+static inline int snd_hdac_power_up(struct hdac_device *codec) { return 0; }
+static inline int snd_hdac_power_down(struct hdac_device *codec) { return 0; }
+static inline int snd_hdac_power_up_pm(struct hdac_device *codec) { return 0; }
+static inline int snd_hdac_power_down_pm(struct hdac_device *codec) { return 0; }
 #endif
 
 /*

commit ec71efc9aaa53b8944b119f8bedd0559c8ed5453
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Wed Jun 3 12:24:31 2015 +0530

    ALSA: hda - add HDA default codec match function
    
    HDA codec drivers can be matched using vendor id and revision id typically.
    So provide a match function which does this and is loaded when driver hasn't
    provided one (default behaviour)
    
    Signed-off-by: Jeeja KP <jeeja.kp@intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 64fff4db81bb..4caf1fde8a4f 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -27,6 +27,16 @@ struct hdac_widget_tree;
  */
 extern struct bus_type snd_hda_bus_type;
 
+/*
+ * HDA device table
+ */
+struct hda_device_id {
+	__u32 vendor_id;
+	__u32 rev_id;
+	const char *name;
+	unsigned long driver_data;
+};
+
 /*
  * generic arrays
  */
@@ -171,12 +181,16 @@ static inline void snd_hdac_power_down_pm(struct hdac_device *codec) {}
 struct hdac_driver {
 	struct device_driver driver;
 	int type;
+	const struct hda_device_id *id_table;
 	int (*match)(struct hdac_device *dev, struct hdac_driver *drv);
 	void (*unsol_event)(struct hdac_device *dev, unsigned int event);
 };
 
 #define drv_to_hdac_driver(_drv) container_of(_drv, struct hdac_driver, driver)
 
+const struct hda_device_id *
+hdac_get_device_id(struct hdac_device *hdev, struct hdac_driver *drv);
+
 /*
  * Bus verb operators
  */

commit 98d8fc6c5d3652e91c61d78941e0fa6f94771d67
Author: Mengdong Lin <mengdong.lin@intel.com>
Date:   Tue May 19 22:29:30 2015 +0800

    ALSA: hda - Move hda_i915.c from sound/pci/hda to sound/hda
    
    The file is moved to hda core and renamed to hdac_i915.c, so can be used
    by both legacy HDA driver and new Skylake audio driver.
    
    - Add snd_hdac_ prefix to the public APIs.
    - The i915 audio component is moved to core bus and dynamically allocated.
    - A static pointer hdac_acomp is used to help bind/unbind callbacks to get
      this component, because the sound card's private_data is used by the azx
      chip pointer, which is a legacy structure. It could be removed if private
      _data changes to some core structure which can be extended to find the
      bus.
    - snd_hdac_get_display_clk() is added to get the display core clock for
      HSW/BDW.
    - haswell_set_bclk() is moved to hda_intel.c because it needs to write the
      controller registers EM4/EM5, and only legacy HD-A needs it for HSW/BDW.
    - Move definition of HSW/BDW-specific registers EM4/EM5 to hda_register.h
      and rename them to HSW_EM4/HSW_EM5, because other HD-A controllers have
      different layout for the extended mode registers.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index b97c59eab7ab..64fff4db81bb 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -11,6 +11,7 @@
 #include <sound/core.h>
 #include <sound/memalloc.h>
 #include <sound/hda_verbs.h>
+#include <drm/i915_component.h>
 
 /* codec node id */
 typedef u16 hda_nid_t;
@@ -285,6 +286,10 @@ struct hdac_bus {
 	/* locks */
 	spinlock_t reg_lock;
 	struct mutex cmd_mutex;
+
+	/* i915 component interface */
+	struct i915_audio_component *audio_component;
+	int i915_power_refcount;
 };
 
 int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,

commit a5e7e07c264bb76d0b7c782766989c491833de05
Author: Mengdong Lin <mengdong.lin@intel.com>
Date:   Wed Apr 29 17:43:20 2015 +0800

    ALSA: hda - allow a codec to control the link power
    
    A flag "link_power_control" is added to indicate whether a codec needs to
    control the link power.  And a new bus ops link_power() is defined for the
    codec to request to enable/disable the link power.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 6a2e030c836c..b97c59eab7ab 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -74,6 +74,7 @@ struct hdac_device {
 
 	/* misc flags */
 	atomic_t in_pm;		/* suspend/resume being performed */
+	bool  link_power_control:1;
 
 	/* sysfs */
 	struct hdac_widget_tree *widgets;
@@ -184,6 +185,8 @@ struct hdac_bus_ops {
 	/* get a response from the last command */
 	int (*get_response)(struct hdac_bus *bus, unsigned int addr,
 			    unsigned int *res);
+	/* control the link power  */
+	int (*link_power)(struct hdac_bus *bus, bool enable);
 };
 
 /*
@@ -311,6 +314,7 @@ static inline void snd_hdac_codec_link_down(struct hdac_device *codec)
 int snd_hdac_bus_send_cmd(struct hdac_bus *bus, unsigned int val);
 int snd_hdac_bus_get_response(struct hdac_bus *bus, unsigned int addr,
 			      unsigned int *res);
+int snd_hdac_link_power(struct hdac_device *codec, bool enable);
 
 bool snd_hdac_bus_init_chip(struct hdac_bus *bus, bool full_reset);
 void snd_hdac_bus_stop_chip(struct hdac_bus *bus);

commit 86f6501bf4c13e805e48497aaffab86ad7a98c44
Author: Jeeja KP <jeeja.kp@intel.com>
Date:   Fri Apr 17 17:58:58 2015 +0530

    ALSA: hda - add generic functions to set hdac stream params
    
    This will be used by hda controller driver to
    setup stream params in prepare. This function will
    setup the bdl and periods.
    
    Signed-off-by: Jeeja KP <jeeja.kp@intel.com>
    Signed-off-by: Subhransu S. Prusty <subhransu.s.prusty@intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index d05931fc6f28..6a2e030c836c 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -418,6 +418,8 @@ void snd_hdac_stream_release(struct hdac_stream *azx_dev);
 int snd_hdac_stream_setup(struct hdac_stream *azx_dev);
 void snd_hdac_stream_cleanup(struct hdac_stream *azx_dev);
 int snd_hdac_stream_setup_periods(struct hdac_stream *azx_dev);
+int snd_hdac_stream_set_params(struct hdac_stream *azx_dev,
+				unsigned int format_val);
 void snd_hdac_stream_start(struct hdac_stream *azx_dev, bool fresh_start);
 void snd_hdac_stream_clear(struct hdac_stream *azx_dev);
 void snd_hdac_stream_stop(struct hdac_stream *azx_dev);

commit c1cc18b1ca01530a40ace0c9ec48124ff1340125
Author: Ramesh Babu <ramesh.babu@intel.com>
Date:   Fri Apr 17 17:58:57 2015 +0530

    ALSA: hda - add ASoC device type for hda core
    
    Add HDA_DEV_ASOC device/driver type to support
    ASoC HDA drivers.
    
    Signed-off-by: Ramesh Babu <ramesh.babu@intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index dbeb195eb4e8..d05931fc6f28 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -90,6 +90,7 @@ struct hdac_device {
 enum {
 	HDA_DEV_CORE,
 	HDA_DEV_LEGACY,
+	HDA_DEV_ASOC,
 };
 
 /* direction */

commit 6d23c8f5440e33cb854e394d38b8c19315f21428
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 17 13:34:30 2015 +0200

    ALSA: hda - Move prepared flag into struct hdac_stream
    
    This flag seems used commonly, so deserves to be located there.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 15bc039de78d..dbeb195eb4e8 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -390,6 +390,7 @@ struct hdac_stream {
 
 	bool opened:1;
 	bool running:1;
+	bool prepared:1;
 	bool no_period_wakeup:1;
 	bool locked:1;
 

commit b7d023e11434131e5a7ceb4be33c3afa2c855e89
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 16 08:19:06 2015 +0200

    ALSA: hda - Move PCM format and rate handling code to core library
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 59d21848a472..15bc039de78d 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -123,6 +123,15 @@ int snd_hdac_get_connections(struct hdac_device *codec, hda_nid_t nid,
 			     hda_nid_t *conn_list, int max_conns);
 int snd_hdac_get_sub_nodes(struct hdac_device *codec, hda_nid_t nid,
 			   hda_nid_t *start_id);
+unsigned int snd_hdac_calc_stream_format(unsigned int rate,
+					 unsigned int channels,
+					 unsigned int format,
+					 unsigned int maxbps,
+					 unsigned short spdif_ctls);
+int snd_hdac_query_supported_pcm(struct hdac_device *codec, hda_nid_t nid,
+				u32 *ratesp, u64 *formatsp, unsigned int *bpsp);
+bool snd_hdac_is_supported_format(struct hdac_device *codec, hda_nid_t nid,
+				  unsigned int format);
 
 /**
  * snd_hdac_read_parm - read a codec parameter

commit 304dad30388d017544bc2e90fe4fefcca94263d3
Author: Jeeja KP <jeeja.kp@intel.com>
Date:   Sun Apr 12 18:06:13 2015 +0530

    ALSA: hda - moved alloc/free stream pages function to controller library
    
    Moved azx_alloc_stream_pages and azx_free_stream_pages
    to controller library.
    
    Signed-off-by: Jeeja KP <jeeja.kp@intel.com>
    Signed-off-by: Subhransu S. Prusty <subhransu.s.prusty@intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 69f27bc49eb4..59d21848a472 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -314,6 +314,9 @@ void snd_hdac_bus_handle_stream_irq(struct hdac_bus *bus, unsigned int status,
 				    void (*ack)(struct hdac_bus *,
 						struct hdac_stream *));
 
+int snd_hdac_bus_alloc_stream_pages(struct hdac_bus *bus);
+void snd_hdac_bus_free_stream_pages(struct hdac_bus *bus);
+
 /*
  * macros for easy use
  */

commit 8f3f600b52b100f254fc16a60af1261d2e4dc239
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 14 12:53:28 2015 +0200

    ALSA: hda - Add DSP loader to core library code
    
    Copied from the legacy driver code, no transition done yet.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 9349ccf15a36..69f27bc49eb4 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -187,6 +187,11 @@ struct hdac_io_ops {
 	u16 (*reg_readw)(u16 __iomem *addr);
 	void (*reg_writeb)(u8 value, u8 __iomem *addr);
 	u8 (*reg_readb)(u8 __iomem *addr);
+	/* Allocation ops */
+	int (*dma_alloc_pages)(struct hdac_bus *bus, int type, size_t size,
+			       struct snd_dma_buffer *buf);
+	void (*dma_free_pages)(struct hdac_bus *bus,
+			       struct snd_dma_buffer *buf);
 };
 
 #define HDA_UNSOL_QUEUE_SIZE	64
@@ -374,6 +379,7 @@ struct hdac_stream {
 	bool opened:1;
 	bool running:1;
 	bool no_period_wakeup:1;
+	bool locked:1;
 
 	/* timestamp */
 	unsigned long start_wallclk;	/* start + minimum wallclk */
@@ -383,6 +389,10 @@ struct hdac_stream {
 	int delay_negative_threshold;
 
 	struct list_head list;
+#ifdef CONFIG_SND_HDA_DSP_LOADER
+	/* DSP access mutex */
+	struct mutex dsp_mutex;
+#endif
 };
 
 void snd_hdac_stream_init(struct hdac_bus *bus, struct hdac_stream *azx_dev,
@@ -440,6 +450,42 @@ void snd_hdac_stream_timecounter_init(struct hdac_stream *azx_dev,
 			       (snd_hdac_stream_readb(dev, reg) & \
 				~(mask)) | (val))
 
+#ifdef CONFIG_SND_HDA_DSP_LOADER
+/* DSP lock helpers */
+#define snd_hdac_dsp_lock_init(dev)	mutex_init(&(dev)->dsp_mutex)
+#define snd_hdac_dsp_lock(dev)		mutex_lock(&(dev)->dsp_mutex)
+#define snd_hdac_dsp_unlock(dev)	mutex_unlock(&(dev)->dsp_mutex)
+#define snd_hdac_stream_is_locked(dev)	((dev)->locked)
+/* DSP loader helpers */
+int snd_hdac_dsp_prepare(struct hdac_stream *azx_dev, unsigned int format,
+			 unsigned int byte_size, struct snd_dma_buffer *bufp);
+void snd_hdac_dsp_trigger(struct hdac_stream *azx_dev, bool start);
+void snd_hdac_dsp_cleanup(struct hdac_stream *azx_dev,
+			  struct snd_dma_buffer *dmab);
+#else /* CONFIG_SND_HDA_DSP_LOADER */
+#define snd_hdac_dsp_lock_init(dev)	do {} while (0)
+#define snd_hdac_dsp_lock(dev)		do {} while (0)
+#define snd_hdac_dsp_unlock(dev)	do {} while (0)
+#define snd_hdac_stream_is_locked(dev)	0
+
+static inline int
+snd_hdac_dsp_prepare(struct hdac_stream *azx_dev, unsigned int format,
+		     unsigned int byte_size, struct snd_dma_buffer *bufp)
+{
+	return 0;
+}
+
+static inline void snd_hdac_dsp_trigger(struct hdac_stream *azx_dev, bool start)
+{
+}
+
+static inline void snd_hdac_dsp_cleanup(struct hdac_stream *azx_dev,
+					struct snd_dma_buffer *dmab)
+{
+}
+#endif /* CONFIG_SND_HDA_DSP_LOADER */
+
+
 /*
  * generic array helpers
  */

commit 14752412721c61d9ac1e8d8fb51d7148cb15f85b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 14 12:15:47 2015 +0200

    ALSA: hda - Add the controller helper codes to hda-core module
    
    This patch adds the controller helper codes to hda-core library.
    The I/O access ops are added to the bus ops.  The CORB/RIRB, the basic
    attributes like irq# and iomap address, some locks and the list of
    streams are added to the bus object, together with the stream object
    and its helpers.
    
    Currently the codes are just copied from the legacy driver, so you can
    find duplicated codes in both directories.  Only constants are removed
    from the original hda_controller.h.  More integration work will follow
    in the later patches.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 2a8aa9dfb83d..9349ccf15a36 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -6,12 +6,17 @@
 #define __SOUND_HDAUDIO_H
 
 #include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/timecounter.h>
+#include <sound/core.h>
+#include <sound/memalloc.h>
 #include <sound/hda_verbs.h>
 
 /* codec node id */
 typedef u16 hda_nid_t;
 
 struct hdac_bus;
+struct hdac_stream;
 struct hdac_device;
 struct hdac_driver;
 struct hdac_widget_tree;
@@ -161,7 +166,7 @@ struct hdac_driver {
 #define drv_to_hdac_driver(_drv) container_of(_drv, struct hdac_driver, driver)
 
 /*
- * HD-audio bus base driver
+ * Bus verb operators
  */
 struct hdac_bus_ops {
 	/* send a single command */
@@ -171,11 +176,50 @@ struct hdac_bus_ops {
 			    unsigned int *res);
 };
 
+/*
+ * Lowlevel I/O operators
+ */
+struct hdac_io_ops {
+	/* mapped register accesses */
+	void (*reg_writel)(u32 value, u32 __iomem *addr);
+	u32 (*reg_readl)(u32 __iomem *addr);
+	void (*reg_writew)(u16 value, u16 __iomem *addr);
+	u16 (*reg_readw)(u16 __iomem *addr);
+	void (*reg_writeb)(u8 value, u8 __iomem *addr);
+	u8 (*reg_readb)(u8 __iomem *addr);
+};
+
 #define HDA_UNSOL_QUEUE_SIZE	64
+#define HDA_MAX_CODECS		8	/* limit by controller side */
+
+/* HD Audio class code */
+#define PCI_CLASS_MULTIMEDIA_HD_AUDIO	0x0403
+
+/*
+ * CORB/RIRB
+ *
+ * Each CORB entry is 4byte, RIRB is 8byte
+ */
+struct hdac_rb {
+	__le32 *buf;		/* virtual address of CORB/RIRB buffer */
+	dma_addr_t addr;	/* physical address of CORB/RIRB buffer */
+	unsigned short rp, wp;	/* RIRB read/write pointers */
+	int cmds[HDA_MAX_CODECS];	/* number of pending requests */
+	u32 res[HDA_MAX_CODECS];	/* last read value */
+};
 
+/*
+ * HD-audio bus base driver
+ */
 struct hdac_bus {
 	struct device *dev;
 	const struct hdac_bus_ops *ops;
+	const struct hdac_io_ops *io_ops;
+
+	/* h/w resources */
+	unsigned long addr;
+	void __iomem *remap_addr;
+	int irq;
 
 	/* codec linked list */
 	struct list_head codec_list;
@@ -189,18 +233,45 @@ struct hdac_bus {
 	unsigned int unsol_rp, unsol_wp;
 	struct work_struct unsol_work;
 
+	/* bit flags of detected codecs */
+	unsigned long codec_mask;
+
 	/* bit flags of powered codecs */
 	unsigned long codec_powered;
 
-	/* flags */
+	/* CORB/RIRB */
+	struct hdac_rb corb;
+	struct hdac_rb rirb;
+	unsigned int last_cmd[HDA_MAX_CODECS];	/* last sent command */
+
+	/* CORB/RIRB and position buffers */
+	struct snd_dma_buffer rb;
+	struct snd_dma_buffer posbuf;
+
+	/* hdac_stream linked list */
+	struct list_head stream_list;
+
+	/* operation state */
+	bool chip_init:1;		/* h/w initialized */
+
+	/* behavior flags */
 	bool sync_write:1;		/* sync after verb write */
+	bool use_posbuf:1;		/* use position buffer */
+	bool snoop:1;			/* enable snooping */
+	bool align_bdle_4k:1;		/* BDLE align 4K boundary */
+	bool reverse_assign:1;		/* assign devices in reverse order */
+	bool corbrp_self_clear:1;	/* CORBRP clears itself after reset */
+
+	int bdl_pos_adj;		/* BDL position adjustment */
 
 	/* locks */
+	spinlock_t reg_lock;
 	struct mutex cmd_mutex;
 };
 
 int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,
-		      const struct hdac_bus_ops *ops);
+		      const struct hdac_bus_ops *ops,
+		      const struct hdac_io_ops *io_ops);
 void snd_hdac_bus_exit(struct hdac_bus *bus);
 int snd_hdac_bus_exec_verb(struct hdac_bus *bus, unsigned int addr,
 			   unsigned int cmd, unsigned int *res);
@@ -222,6 +293,153 @@ static inline void snd_hdac_codec_link_down(struct hdac_device *codec)
 	clear_bit(codec->addr, &codec->bus->codec_powered);
 }
 
+int snd_hdac_bus_send_cmd(struct hdac_bus *bus, unsigned int val);
+int snd_hdac_bus_get_response(struct hdac_bus *bus, unsigned int addr,
+			      unsigned int *res);
+
+bool snd_hdac_bus_init_chip(struct hdac_bus *bus, bool full_reset);
+void snd_hdac_bus_stop_chip(struct hdac_bus *bus);
+void snd_hdac_bus_init_cmd_io(struct hdac_bus *bus);
+void snd_hdac_bus_stop_cmd_io(struct hdac_bus *bus);
+void snd_hdac_bus_enter_link_reset(struct hdac_bus *bus);
+void snd_hdac_bus_exit_link_reset(struct hdac_bus *bus);
+
+void snd_hdac_bus_update_rirb(struct hdac_bus *bus);
+void snd_hdac_bus_handle_stream_irq(struct hdac_bus *bus, unsigned int status,
+				    void (*ack)(struct hdac_bus *,
+						struct hdac_stream *));
+
+/*
+ * macros for easy use
+ */
+#define _snd_hdac_chip_write(type, chip, reg, value) \
+	((chip)->io_ops->reg_write ## type(value, (chip)->remap_addr + (reg)))
+#define _snd_hdac_chip_read(type, chip, reg) \
+	((chip)->io_ops->reg_read ## type((chip)->remap_addr + (reg)))
+
+/* read/write a register, pass without AZX_REG_ prefix */
+#define snd_hdac_chip_writel(chip, reg, value) \
+	_snd_hdac_chip_write(l, chip, AZX_REG_ ## reg, value)
+#define snd_hdac_chip_writew(chip, reg, value) \
+	_snd_hdac_chip_write(w, chip, AZX_REG_ ## reg, value)
+#define snd_hdac_chip_writeb(chip, reg, value) \
+	_snd_hdac_chip_write(b, chip, AZX_REG_ ## reg, value)
+#define snd_hdac_chip_readl(chip, reg) \
+	_snd_hdac_chip_read(l, chip, AZX_REG_ ## reg)
+#define snd_hdac_chip_readw(chip, reg) \
+	_snd_hdac_chip_read(w, chip, AZX_REG_ ## reg)
+#define snd_hdac_chip_readb(chip, reg) \
+	_snd_hdac_chip_read(b, chip, AZX_REG_ ## reg)
+
+/* update a register, pass without AZX_REG_ prefix */
+#define snd_hdac_chip_updatel(chip, reg, mask, val) \
+	snd_hdac_chip_writel(chip, reg, \
+			     (snd_hdac_chip_readl(chip, reg) & ~(mask)) | (val))
+#define snd_hdac_chip_updatew(chip, reg, mask, val) \
+	snd_hdac_chip_writew(chip, reg, \
+			     (snd_hdac_chip_readw(chip, reg) & ~(mask)) | (val))
+#define snd_hdac_chip_updateb(chip, reg, mask, val) \
+	snd_hdac_chip_writeb(chip, reg, \
+			     (snd_hdac_chip_readb(chip, reg) & ~(mask)) | (val))
+
+/*
+ * HD-audio stream
+ */
+struct hdac_stream {
+	struct hdac_bus *bus;
+	struct snd_dma_buffer bdl; /* BDL buffer */
+	__le32 *posbuf;		/* position buffer pointer */
+	int direction;		/* playback / capture (SNDRV_PCM_STREAM_*) */
+
+	unsigned int bufsize;	/* size of the play buffer in bytes */
+	unsigned int period_bytes; /* size of the period in bytes */
+	unsigned int frags;	/* number for period in the play buffer */
+	unsigned int fifo_size;	/* FIFO size */
+
+	void __iomem *sd_addr;	/* stream descriptor pointer */
+
+	u32 sd_int_sta_mask;	/* stream int status mask */
+
+	/* pcm support */
+	struct snd_pcm_substream *substream;	/* assigned substream,
+						 * set in PCM open
+						 */
+	unsigned int format_val;	/* format value to be set in the
+					 * controller and the codec
+					 */
+	unsigned char stream_tag;	/* assigned stream */
+	unsigned char index;		/* stream index */
+	int assigned_key;		/* last device# key assigned to */
+
+	bool opened:1;
+	bool running:1;
+	bool no_period_wakeup:1;
+
+	/* timestamp */
+	unsigned long start_wallclk;	/* start + minimum wallclk */
+	unsigned long period_wallclk;	/* wallclk for period */
+	struct timecounter  tc;
+	struct cyclecounter cc;
+	int delay_negative_threshold;
+
+	struct list_head list;
+};
+
+void snd_hdac_stream_init(struct hdac_bus *bus, struct hdac_stream *azx_dev,
+			  int idx, int direction, int tag);
+struct hdac_stream *snd_hdac_stream_assign(struct hdac_bus *bus,
+					   struct snd_pcm_substream *substream);
+void snd_hdac_stream_release(struct hdac_stream *azx_dev);
+
+int snd_hdac_stream_setup(struct hdac_stream *azx_dev);
+void snd_hdac_stream_cleanup(struct hdac_stream *azx_dev);
+int snd_hdac_stream_setup_periods(struct hdac_stream *azx_dev);
+void snd_hdac_stream_start(struct hdac_stream *azx_dev, bool fresh_start);
+void snd_hdac_stream_clear(struct hdac_stream *azx_dev);
+void snd_hdac_stream_stop(struct hdac_stream *azx_dev);
+void snd_hdac_stream_reset(struct hdac_stream *azx_dev);
+void snd_hdac_stream_sync_trigger(struct hdac_stream *azx_dev, bool set,
+				  unsigned int streams, unsigned int reg);
+void snd_hdac_stream_sync(struct hdac_stream *azx_dev, bool start,
+			  unsigned int streams);
+void snd_hdac_stream_timecounter_init(struct hdac_stream *azx_dev,
+				      unsigned int streams);
+/*
+ * macros for easy use
+ */
+#define _snd_hdac_stream_write(type, dev, reg, value)			\
+	((dev)->bus->io_ops->reg_write ## type(value, (dev)->sd_addr + (reg)))
+#define _snd_hdac_stream_read(type, dev, reg)				\
+	((dev)->bus->io_ops->reg_read ## type((dev)->sd_addr + (reg)))
+
+/* read/write a register, pass without AZX_REG_ prefix */
+#define snd_hdac_stream_writel(dev, reg, value) \
+	_snd_hdac_stream_write(l, dev, AZX_REG_ ## reg, value)
+#define snd_hdac_stream_writew(dev, reg, value) \
+	_snd_hdac_stream_write(w, dev, AZX_REG_ ## reg, value)
+#define snd_hdac_stream_writeb(dev, reg, value) \
+	_snd_hdac_stream_write(b, dev, AZX_REG_ ## reg, value)
+#define snd_hdac_stream_readl(dev, reg) \
+	_snd_hdac_stream_read(l, dev, AZX_REG_ ## reg)
+#define snd_hdac_stream_readw(dev, reg) \
+	_snd_hdac_stream_read(w, dev, AZX_REG_ ## reg)
+#define snd_hdac_stream_readb(dev, reg) \
+	_snd_hdac_stream_read(b, dev, AZX_REG_ ## reg)
+
+/* update a register, pass without AZX_REG_ prefix */
+#define snd_hdac_stream_updatel(dev, reg, mask, val) \
+	snd_hdac_stream_writel(dev, reg, \
+			       (snd_hdac_stream_readl(dev, reg) & \
+				~(mask)) | (val))
+#define snd_hdac_stream_updatew(dev, reg, mask, val) \
+	snd_hdac_stream_writew(dev, reg, \
+			       (snd_hdac_stream_readw(dev, reg) & \
+				~(mask)) | (val))
+#define snd_hdac_stream_updateb(dev, reg, mask, val) \
+	snd_hdac_stream_writeb(dev, reg, \
+			       (snd_hdac_stream_readb(dev, reg) & \
+				~(mask)) | (val))
+
 /*
  * generic array helpers
  */

commit c3aeda62878f09da91329693a60a1f08ec97e0b8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 13 11:01:14 2015 +0200

    ALSA: hda - Fix another race in runtime PM refcounting
    
    Although some races in runtime PM refcount was fixed by the commit
    [664c715573c2: ALSA: hda - Work around races of power up/down with
    runtime PM], there is still a race in the following case:
    
    CPU0:                   CPU1 :
    runtime suspend:
      codec->in_pm = 1
                            snd_hdac_power_up_pm():
                              pm_runtime_get_sync() skipped
    suspend finished:
      codec->in_pm = 0
                            snd_hdac_power_down_pm():
                              pm_runtime_put_*() is called!
    
    For avoiding this situation, increment in_pm flag atomically when it's
    non-zero, and decrement accordingly, to ensure that in_pm is set
    consistently for the whole concurrent operations.
    
    Also, since atomic_inc_not_zero() and atomic_dec_if_positive() are
    lengthy inline functions, move snd_hdac_power_up_pm() and _down_pm()
    to sound/hda/hdac_device.c as no inline functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 30446f17c6a6..2a8aa9dfb83d 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -139,39 +139,15 @@ static inline int snd_hdac_read_parm(struct hdac_device *codec, hda_nid_t nid,
 #ifdef CONFIG_PM
 void snd_hdac_power_up(struct hdac_device *codec);
 void snd_hdac_power_down(struct hdac_device *codec);
+void snd_hdac_power_up_pm(struct hdac_device *codec);
+void snd_hdac_power_down_pm(struct hdac_device *codec);
 #else
 static inline void snd_hdac_power_up(struct hdac_device *codec) {}
 static inline void snd_hdac_power_down(struct hdac_device *codec) {}
+static inline void snd_hdac_power_up_pm(struct hdac_device *codec) {}
+static inline void snd_hdac_power_down_pm(struct hdac_device *codec) {}
 #endif
 
-/**
- * snd_hdac_power_up_pm - power up the codec
- * @codec: the codec object
- *
- * This function can be called in a recursive code path like init code
- * which may be called by PM suspend/resume again.  OTOH, if a power-up
- * call must wake up the sleeper (e.g. in a kctl callback), use
- * snd_hdac_power_up() instead.
- */
-static inline void snd_hdac_power_up_pm(struct hdac_device *codec)
-{
-	if (!atomic_read(&codec->in_pm))
-		snd_hdac_power_up(codec);
-}
-
-/**
- * snd_hdac_power_down_pm - power down the codec
- * @codec: the codec object
- *
- * Like snd_hdac_power_up_pm(), this function is used in a recursive
- * code path like init code which may be called by PM suspend/resume again.
- */
-static inline void snd_hdac_power_down_pm(struct hdac_device *codec)
-{
-	if (!atomic_read(&codec->in_pm))
-		snd_hdac_power_down(codec);
-}
-
 /*
  * HD-audio codec base driver
  */

commit 664c715573c2c116c2d8f5de7d59ce85a98a1751
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 8 11:43:14 2015 +0200

    ALSA: hda - Work around races of power up/down with runtime PM
    
    Currently, snd_hdac_power_up()/down() helpers checks whether the codec
    is being in pm (suspend/resume), and skips the call of runtime get/put
    during it.  This is needed as there are lots of power up/down
    sequences called in the paths that are also used in the PM itself.  An
    example is found in hda_codec.c::codec_exec_verb(), where this can
    power up the codec while it may be called again in its power up
    sequence, too.
    
    The above works in most cases, but sometimes we really want to wait
    for the real power up.  For example, the control element get/put may
    want explicit power up so that the value change is assured to reach to
    the hardware.   Using the current snd_hdac_power_up(), however,
    results in a race, e.g. when it's called during the runtime suspend is
    being performed.  In the worst case, as found in patch_ca0132.c, it
    can even lead to the deadlock because the code assumes the power up
    while it was skipped due to the check above.
    
    For dealing with such cases, this patch makes snd_hdac_power_up() and
    _down() to two variants: with and without in_pm flag check.  The
    version with pm flag check is named as snd_hdac_power_up_pm() while
    the version without pm flag check is still kept as
    snd_hdac_power_up().  (Just because the usage of the former is fewer.)
    
    Then finally, the patch replaces each call potentially done in PM with
    the new _pm() variant.
    
    In theory, we can implement a unified version -- if we can distinguish
    the current context whether it's in the pm path.  But such an
    implementation is cumbersome, so leave the code like this a bit messy
    way for now...
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=96271
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 95acc337aea5..30446f17c6a6 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -144,6 +144,34 @@ static inline void snd_hdac_power_up(struct hdac_device *codec) {}
 static inline void snd_hdac_power_down(struct hdac_device *codec) {}
 #endif
 
+/**
+ * snd_hdac_power_up_pm - power up the codec
+ * @codec: the codec object
+ *
+ * This function can be called in a recursive code path like init code
+ * which may be called by PM suspend/resume again.  OTOH, if a power-up
+ * call must wake up the sleeper (e.g. in a kctl callback), use
+ * snd_hdac_power_up() instead.
+ */
+static inline void snd_hdac_power_up_pm(struct hdac_device *codec)
+{
+	if (!atomic_read(&codec->in_pm))
+		snd_hdac_power_up(codec);
+}
+
+/**
+ * snd_hdac_power_down_pm - power down the codec
+ * @codec: the codec object
+ *
+ * Like snd_hdac_power_up_pm(), this function is used in a recursive
+ * code path like init code which may be called by PM suspend/resume again.
+ */
+static inline void snd_hdac_power_down_pm(struct hdac_device *codec)
+{
+	if (!atomic_read(&codec->in_pm))
+		snd_hdac_power_down(codec);
+}
+
 /*
  * HD-audio codec base driver
  */

commit 40ba66a702b83f46c53456eaaac692fc12f82cb0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Mar 13 15:56:25 2015 +0100

    ALSA: hda - Add cache support for COEF read/write
    
    The 16bit COEF read/write is pretty standard for many codecs, and they
    can be cached in most cases -- more importantly, they need to be
    restored at resume.  For making this easier, add the cache support to
    regmap.  If the codec driver wants to cache the COEF access, set
    codec->cache_coef flag and issue AC_VERB_GET_PROC_COEF with the coef
    index in LSB 8 bits.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 702032598bea..95acc337aea5 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -78,6 +78,7 @@ struct hdac_device {
 	struct snd_array vendor_verbs;
 	bool lazy_cache:1;	/* don't wake up for writes */
 	bool caps_overwriting:1; /* caps overwrite being in process */
+	bool cache_coef:1;	/* cache COEF read/write too */
 };
 
 /* device/driver type used for matching */

commit 5e56bcea5017b7b7808df60f21ef01738b6e1a25
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 26 12:29:03 2015 +0100

    ALSA: hda - Allow driver to add vendor-specific verbs for regmap
    
    Codecs may have own vendor-specific verbs, and we need to allow each
    driver to give such verbs for cached accesses.  Here a verb can be put
    into a single array and looked through it at readable and writeable
    callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index ce7d8d1f59c6..702032598bea 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -75,6 +75,7 @@ struct hdac_device {
 
 	/* regmap */
 	struct regmap *regmap;
+	struct snd_array vendor_verbs;
 	bool lazy_cache:1;	/* don't wake up for writes */
 	bool caps_overwriting:1; /* caps overwrite being in process */
 };

commit faa75f8a2edf005a5caf43be4875ffeeb9bcb498
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 26 08:54:56 2015 +0100

    ALSA: hda - Use regmap for parameter caches, too
    
    The amp hash table was used for recording the cached reads of some
    capability values like pin caps or amp caps.  Now all these are moved
    to regmap as well.
    
    One addition to the regmap helper is codec->caps_overwriting flag.
    This is set in snd_hdac_override_parm(), and the regmap helper accepts
    any register while this flag is set, so that it can overwrite even the
    read-only verb like AC_VERB_PARAMETERS.  The flag is cleared
    immediately in snd_hdac_override_parm(), as it's a once-off flag.
    
    Along with these changes, the no longer needed amp hash and relevant
    fields are removed from hda_codec struct now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 65ea6429f3a7..ce7d8d1f59c6 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -76,6 +76,7 @@ struct hdac_device {
 	/* regmap */
 	struct regmap *regmap;
 	bool lazy_cache:1;	/* don't wake up for writes */
+	bool caps_overwriting:1; /* caps overwrite being in process */
 };
 
 /* device/driver type used for matching */
@@ -109,6 +110,8 @@ int _snd_hdac_read_parm(struct hdac_device *codec, hda_nid_t nid, int parm,
 			unsigned int *res);
 int snd_hdac_read_parm_uncached(struct hdac_device *codec, hda_nid_t nid,
 				int parm);
+int snd_hdac_override_parm(struct hdac_device *codec, hda_nid_t nid,
+			   unsigned int parm, unsigned int val);
 int snd_hdac_get_connections(struct hdac_device *codec, hda_nid_t nid,
 			     hda_nid_t *conn_list, int max_conns);
 int snd_hdac_get_sub_nodes(struct hdac_device *codec, hda_nid_t nid,

commit 9ba17b4d132f56a680fa1ba0bc2a8f98b6263d93
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 3 23:29:47 2015 +0100

    ALSA: hda - Implement uncached version of parameter reads
    
    Sometimes we need the uncached reads, e.g. for refreshing the tree.
    This patch provides the helper function for that and uses it for
    refreshing widgets, reading subtrees and the whole proc reads.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index ddfcc44970fa..65ea6429f3a7 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -107,6 +107,8 @@ int snd_hdac_read(struct hdac_device *codec, hda_nid_t nid,
 		  unsigned int verb, unsigned int parm, unsigned int *res);
 int _snd_hdac_read_parm(struct hdac_device *codec, hda_nid_t nid, int parm,
 			unsigned int *res);
+int snd_hdac_read_parm_uncached(struct hdac_device *codec, hda_nid_t nid,
+				int parm);
 int snd_hdac_get_connections(struct hdac_device *codec, hda_nid_t nid,
 			     hda_nid_t *conn_list, int max_conns);
 int snd_hdac_get_sub_nodes(struct hdac_device *codec, hda_nid_t nid,

commit 01ed3c06c6d5e7e861650ae76117dd4194d87316
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 26 13:57:47 2015 +0100

    ALSA: hda - Use regmap for codec parameter reads
    
    Let's start converting the access functions to regmap.
    The first one is the simplest, just converting the codec parameter
    read helper function snd_hda_param_read().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 47e20b741c51..ddfcc44970fa 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -105,12 +105,30 @@ int snd_hdac_exec_verb(struct hdac_device *codec, unsigned int cmd,
 		       unsigned int flags, unsigned int *res);
 int snd_hdac_read(struct hdac_device *codec, hda_nid_t nid,
 		  unsigned int verb, unsigned int parm, unsigned int *res);
-int snd_hdac_read_parm(struct hdac_device *codec, hda_nid_t nid, int parm);
+int _snd_hdac_read_parm(struct hdac_device *codec, hda_nid_t nid, int parm,
+			unsigned int *res);
 int snd_hdac_get_connections(struct hdac_device *codec, hda_nid_t nid,
 			     hda_nid_t *conn_list, int max_conns);
 int snd_hdac_get_sub_nodes(struct hdac_device *codec, hda_nid_t nid,
 			   hda_nid_t *start_id);
 
+/**
+ * snd_hdac_read_parm - read a codec parameter
+ * @codec: the codec object
+ * @nid: NID to read a parameter
+ * @parm: parameter to read
+ *
+ * Returns -1 for error.  If you need to distinguish the error more
+ * strictly, use _snd_hdac_read_parm() directly.
+ */
+static inline int snd_hdac_read_parm(struct hdac_device *codec, hda_nid_t nid,
+				     int parm)
+{
+	unsigned int val;
+
+	return _snd_hdac_read_parm(codec, nid, parm, &val) < 0 ? -1 : val;
+}
+
 #ifdef CONFIG_PM
 void snd_hdac_power_up(struct hdac_device *codec);
 void snd_hdac_power_down(struct hdac_device *codec);

commit 4d75faa0448a6bb2fd6d56051a3675a3937cbada
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 25 14:42:38 2015 +0100

    ALSA: hda - Add regmap support
    
    This patch adds an infrastructure to support regmap-based verb
    accesses.  Because o the asymmetric nature of HD-audio verbs,
    especially the amp verbs, we need to translate the verbs as a sort of
    pseudo registers to be mapped uniquely in regmap.
    
    In this patch, a pseudo register is built from the NID, the
    AC_VERB_GET_* and 8bit parameters, i.e. almost in the form to be sent
    to HD-audio bus but without codec address field.  OTOH, for writing,
    the same pseudo register is translated to AC_VERB_SET_* automatically.
    The AC_VERB_SET_AMP_* verb is re-encoded from the corresponding
    AC_VERB_GET_AMP_* verb and parameter at writing.
    
    Some verbs has a single command for read but multiple for writes.  A
    write for such a verb is split automatically to multiple verbs.
    
    The patch provides also a few handy helper functions.  They are
    designed to be accessible even without regmap.  When no regmap is set
    up (e.g. before the codec device instantiation), the direct hardware
    access is used.  Also, it tries to avoid the unnecessary power-up.
    The power up/down sequence is performed only on demand.
    
    The codec driver needs to call snd_hdac_regmap_exit() and
    snd_hdac_regmap_exit() at probe and remove if it wants the regmap
    access.
    
    There is one flag added to hdac_device.  When the flag lazy_cache is
    set, regmap helper ignores a write for a suspended device and returns
    as if it was actually written.  It reduces the hardware access pretty
    much, e.g. when adjusting the mixer volume while in idle.  This
    assumes that the driver will sync the cache later at resume properly,
    so use it carefully.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 3abdd3f16528..47e20b741c51 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -72,6 +72,10 @@ struct hdac_device {
 
 	/* sysfs */
 	struct hdac_widget_tree *widgets;
+
+	/* regmap */
+	struct regmap *regmap;
+	bool lazy_cache:1;	/* don't wake up for writes */
 };
 
 /* device/driver type used for matching */

commit 71fc4c7ef5ef2d0ddd22f0545ede4c135b554b84
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 3 17:33:10 2015 +0100

    ALSA: hda - Move generic array helpers to core lib
    
    This will be used by the regmap support.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 675614dc2b88..3abdd3f16528 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -21,6 +21,17 @@ struct hdac_widget_tree;
  */
 extern struct bus_type snd_hda_bus_type;
 
+/*
+ * generic arrays
+ */
+struct snd_array {
+	unsigned int used;
+	unsigned int alloced;
+	unsigned int elem_size;
+	unsigned int alloc_align;
+	void *list;
+};
+
 /*
  * HD-audio codec base device
  */
@@ -178,4 +189,26 @@ static inline void snd_hdac_codec_link_down(struct hdac_device *codec)
 	clear_bit(codec->addr, &codec->bus->codec_powered);
 }
 
+/*
+ * generic array helpers
+ */
+void *snd_array_new(struct snd_array *array);
+void snd_array_free(struct snd_array *array);
+static inline void snd_array_init(struct snd_array *array, unsigned int size,
+				  unsigned int align)
+{
+	array->elem_size = size;
+	array->alloc_align = align;
+}
+
+static inline void *snd_array_elem(struct snd_array *array, unsigned int idx)
+{
+	return array->list + idx * array->elem_size;
+}
+
+static inline unsigned int snd_array_index(struct snd_array *array, void *ptr)
+{
+	return (unsigned long)(ptr - array->list) / array->elem_size;
+}
+
 #endif /* __SOUND_HDAUDIO_H */

commit 05852448690d7d810175f8ceccefba083525aa89
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 3 15:40:08 2015 +0100

    ALSA: hda - Support indirect execution of verbs
    
    Add an overriding exec_verb op to struct hdac_device so that the call
    via snd_hdac_exec_verb() can switch to a different route depending on
    the setup.  The codec driver sets this field so that it can handle the
    errors or applying quirks appropriately.  Furthermore, this mechanism
    will be used for smooth transition for the regmap support in later
    patches.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 6ed2b421e29e..675614dc2b88 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -48,6 +48,10 @@ struct hdac_device {
 	const char *vendor_name;	/* codec vendor name */
 	const char *chip_name;		/* codec chip name */
 
+	/* verb exec op override */
+	int (*exec_verb)(struct hdac_device *dev, unsigned int cmd,
+			 unsigned int flags, unsigned int *res);
+
 	/* widgets */
 	unsigned int num_nodes;
 	hda_nid_t start_nid, end_nid;
@@ -82,6 +86,8 @@ int snd_hdac_refresh_widgets(struct hdac_device *codec);
 
 unsigned int snd_hdac_make_cmd(struct hdac_device *codec, hda_nid_t nid,
 			       unsigned int verb, unsigned int parm);
+int snd_hdac_exec_verb(struct hdac_device *codec, unsigned int cmd,
+		       unsigned int flags, unsigned int *res);
 int snd_hdac_read(struct hdac_device *codec, hda_nid_t nid,
 		  unsigned int verb, unsigned int parm, unsigned int *res);
 int snd_hdac_read_parm(struct hdac_device *codec, hda_nid_t nid, int parm);

commit 3256be6537751f65c76b3ecfbb4e667f87525a2f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 24 14:59:42 2015 +0100

    ALSA: hda - Add widget sysfs tree
    
    This patch changes the sysfs files assigned to the codec device on the
    bus which were formerly identical with hwdep sysfs files.  Now it
    shows only a few core parameter, vendor_id, subsystem_id, revision_id,
    afg, mfg, vendor_name and chip_name.
    
    In addition, now a widget tree is added to the bus device sysfs
    directory for showing the widget topology and attributes.  It's just a
    flat tree consisting of subdirectories named as the widget NID
    including various attributes like widget capability bits.  The AFG
    (usually NID 0x01) is always found there, and it contains always
    amp_in_caps, amp_out_caps and power_caps files.  Each of these
    attributes show a single value.  The rest are the widget nodes
    belonging to that AFG.  Note that the child node might not start from
    0x02 but from another value like 0x0a.
    
    Each child node may contain caps, pin_caps, amp_in_caps, amp_out_caps,
    power_caps and connections files.  The caps (representing the widget
    capability bits) always contain a value.  The rest may contain
    value(s) if the attribute exists on the node.  Only connections file
    show multiple values while other attributes have zero or one single
    value.
    
    An example of ls -R output is like below:
    % ls -R /sys/bus/hdaudio/devices/hdaudioC0D0/
    /sys/bus/hdaudio/devices/hdaudioC0D0/widgets/:
    01/  04/  07/  0a/  0d/  10/  13/  16/  19/  1c/  1f/  22/
    02/  05/  08/  0b/  0e/  11/  14/  17/  1a/  1d/  20/  23/
    03/  06/  09/  0c/  0f/  12/  15/  18/  1b/  1e/  21/
    
    /sys/bus/hdaudio/devices/hdaudioC0D0/widgets/01:
    amp_in_caps  amp_out_caps  power_caps
    
    /sys/bus/hdaudio/devices/hdaudioC0D0/widgets/02:
    amp_in_caps  amp_out_caps  caps  connections  pin_caps  pin_cfg
    power_caps
    
    /sys/bus/hdaudio/devices/hdaudioC0D0/widgets/03:
    .....
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index b81b4bec6f05..6ed2b421e29e 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -14,6 +14,7 @@ typedef u16 hda_nid_t;
 struct hdac_bus;
 struct hdac_device;
 struct hdac_driver;
+struct hdac_widget_tree;
 
 /*
  * exported bus type
@@ -53,6 +54,9 @@ struct hdac_device {
 
 	/* misc flags */
 	atomic_t in_pm;		/* suspend/resume being performed */
+
+	/* sysfs */
+	struct hdac_widget_tree *widgets;
 };
 
 /* device/driver type used for matching */
@@ -71,6 +75,8 @@ enum {
 int snd_hdac_device_init(struct hdac_device *dev, struct hdac_bus *bus,
 			 const char *name, unsigned int addr);
 void snd_hdac_device_exit(struct hdac_device *dev);
+int snd_hdac_device_register(struct hdac_device *codec);
+void snd_hdac_device_unregister(struct hdac_device *codec);
 
 int snd_hdac_refresh_widgets(struct hdac_device *codec);
 

commit 7639a06c23c7d4cda34c2546bd7290d8753849ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 3 10:07:24 2015 +0100

    ALSA: hda - Move a part of hda_codec stuff into hdac_device
    
    Now some codes and functionalities of hda_codec struct are moved to
    hdac_device struct.  A few basic attributes like the codec address,
    vendor ID number, FG numbers, etc are moved to hdac_device, and they
    are accessed like codec->core.addr.  The basic verb exec functions are
    moved, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 848ab6e68099..b81b4bec6f05 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -8,6 +8,9 @@
 #include <linux/device.h>
 #include <sound/hda_verbs.h>
 
+/* codec node id */
+typedef u16 hda_nid_t;
+
 struct hdac_bus;
 struct hdac_device;
 struct hdac_driver;
@@ -26,6 +29,30 @@ struct hdac_device {
 	struct hdac_bus *bus;
 	unsigned int addr;		/* codec address */
 	struct list_head list;		/* list point for bus codec_list */
+
+	hda_nid_t afg;			/* AFG node id */
+	hda_nid_t mfg;			/* MFG node id */
+
+	/* ids */
+	unsigned int vendor_id;
+	unsigned int subsystem_id;
+	unsigned int revision_id;
+	unsigned int afg_function_id;
+	unsigned int mfg_function_id;
+	unsigned int afg_unsol:1;
+	unsigned int mfg_unsol:1;
+
+	unsigned int power_caps;	/* FG power caps */
+
+	const char *vendor_name;	/* codec vendor name */
+	const char *chip_name;		/* codec chip name */
+
+	/* widgets */
+	unsigned int num_nodes;
+	hda_nid_t start_nid, end_nid;
+
+	/* misc flags */
+	atomic_t in_pm;		/* suspend/resume being performed */
 };
 
 /* device/driver type used for matching */
@@ -34,8 +61,37 @@ enum {
 	HDA_DEV_LEGACY,
 };
 
+/* direction */
+enum {
+	HDA_INPUT, HDA_OUTPUT
+};
+
 #define dev_to_hdac_dev(_dev)	container_of(_dev, struct hdac_device, dev)
 
+int snd_hdac_device_init(struct hdac_device *dev, struct hdac_bus *bus,
+			 const char *name, unsigned int addr);
+void snd_hdac_device_exit(struct hdac_device *dev);
+
+int snd_hdac_refresh_widgets(struct hdac_device *codec);
+
+unsigned int snd_hdac_make_cmd(struct hdac_device *codec, hda_nid_t nid,
+			       unsigned int verb, unsigned int parm);
+int snd_hdac_read(struct hdac_device *codec, hda_nid_t nid,
+		  unsigned int verb, unsigned int parm, unsigned int *res);
+int snd_hdac_read_parm(struct hdac_device *codec, hda_nid_t nid, int parm);
+int snd_hdac_get_connections(struct hdac_device *codec, hda_nid_t nid,
+			     hda_nid_t *conn_list, int max_conns);
+int snd_hdac_get_sub_nodes(struct hdac_device *codec, hda_nid_t nid,
+			   hda_nid_t *start_id);
+
+#ifdef CONFIG_PM
+void snd_hdac_power_up(struct hdac_device *codec);
+void snd_hdac_power_down(struct hdac_device *codec);
+#else
+static inline void snd_hdac_power_up(struct hdac_device *codec) {}
+static inline void snd_hdac_power_down(struct hdac_device *codec) {}
+#endif
+
 /*
  * HD-audio codec base driver
  */
@@ -100,4 +156,14 @@ int snd_hdac_bus_add_device(struct hdac_bus *bus, struct hdac_device *codec);
 void snd_hdac_bus_remove_device(struct hdac_bus *bus,
 				struct hdac_device *codec);
 
+static inline void snd_hdac_codec_link_up(struct hdac_device *codec)
+{
+	set_bit(codec->addr, &codec->bus->codec_powered);
+}
+
+static inline void snd_hdac_codec_link_down(struct hdac_device *codec)
+{
+	clear_bit(codec->addr, &codec->bus->codec_powered);
+}
+
 #endif /* __SOUND_HDAUDIO_H */

commit d068ebc25e6e1360510ad8023fe7bca3dacd204e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 2 23:22:59 2015 +0100

    ALSA: hda - Move some codes up to hdac_bus struct
    
    A few basic codes for communicating over HD-audio bus are moved to
    struct hdac_bus now.  It has only command and get_response ops in
    addition to the unsolicited event handling.
    
    Note that the codec-side tracing support is disabled temporarily
    during this transition due to the code shuffling.  It will be
    re-enabled later once when all pieces are settled down.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
index 2381509bee9f..848ab6e68099 100644
--- a/include/sound/hdaudio.h
+++ b/include/sound/hdaudio.h
@@ -6,6 +6,11 @@
 #define __SOUND_HDAUDIO_H
 
 #include <linux/device.h>
+#include <sound/hda_verbs.h>
+
+struct hdac_bus;
+struct hdac_device;
+struct hdac_driver;
 
 /*
  * exported bus type
@@ -18,6 +23,9 @@ extern struct bus_type snd_hda_bus_type;
 struct hdac_device {
 	struct device dev;
 	int type;
+	struct hdac_bus *bus;
+	unsigned int addr;		/* codec address */
+	struct list_head list;		/* list point for bus codec_list */
 };
 
 /* device/driver type used for matching */
@@ -35,8 +43,61 @@ struct hdac_driver {
 	struct device_driver driver;
 	int type;
 	int (*match)(struct hdac_device *dev, struct hdac_driver *drv);
+	void (*unsol_event)(struct hdac_device *dev, unsigned int event);
 };
 
 #define drv_to_hdac_driver(_drv) container_of(_drv, struct hdac_driver, driver)
 
+/*
+ * HD-audio bus base driver
+ */
+struct hdac_bus_ops {
+	/* send a single command */
+	int (*command)(struct hdac_bus *bus, unsigned int cmd);
+	/* get a response from the last command */
+	int (*get_response)(struct hdac_bus *bus, unsigned int addr,
+			    unsigned int *res);
+};
+
+#define HDA_UNSOL_QUEUE_SIZE	64
+
+struct hdac_bus {
+	struct device *dev;
+	const struct hdac_bus_ops *ops;
+
+	/* codec linked list */
+	struct list_head codec_list;
+	unsigned int num_codecs;
+
+	/* link caddr -> codec */
+	struct hdac_device *caddr_tbl[HDA_MAX_CODEC_ADDRESS + 1];
+
+	/* unsolicited event queue */
+	u32 unsol_queue[HDA_UNSOL_QUEUE_SIZE * 2]; /* ring buffer */
+	unsigned int unsol_rp, unsol_wp;
+	struct work_struct unsol_work;
+
+	/* bit flags of powered codecs */
+	unsigned long codec_powered;
+
+	/* flags */
+	bool sync_write:1;		/* sync after verb write */
+
+	/* locks */
+	struct mutex cmd_mutex;
+};
+
+int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,
+		      const struct hdac_bus_ops *ops);
+void snd_hdac_bus_exit(struct hdac_bus *bus);
+int snd_hdac_bus_exec_verb(struct hdac_bus *bus, unsigned int addr,
+			   unsigned int cmd, unsigned int *res);
+int snd_hdac_bus_exec_verb_unlocked(struct hdac_bus *bus, unsigned int addr,
+				    unsigned int cmd, unsigned int *res);
+void snd_hdac_bus_queue_event(struct hdac_bus *bus, u32 res, u32 res_ex);
+
+int snd_hdac_bus_add_device(struct hdac_bus *bus, struct hdac_device *codec);
+void snd_hdac_bus_remove_device(struct hdac_bus *bus,
+				struct hdac_device *codec);
+
 #endif /* __SOUND_HDAUDIO_H */

commit e3d280fc6d42017b2379503fbda83655a05294fe
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 17 21:46:37 2015 +0100

    ALSA: hda - Make snd_hda_bus_type public
    
    Define the common hd-audio driver and device types to bind over
    snd_hda_bus_type publicly.  This allows to implement other type of
    device and driver code over hd-audio bus.
    
    Now both struct hda_codec and struct hda_codec_driver inherit these
    new struct hdac_device and struct hdac_driver, respectively.
    
    The bus registration is done in subsys_initcall() to assure it
    before any other driver registrations.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/sound/hdaudio.h b/include/sound/hdaudio.h
new file mode 100644
index 000000000000..2381509bee9f
--- /dev/null
+++ b/include/sound/hdaudio.h
@@ -0,0 +1,42 @@
+/*
+ * HD-audio core stuff
+ */
+
+#ifndef __SOUND_HDAUDIO_H
+#define __SOUND_HDAUDIO_H
+
+#include <linux/device.h>
+
+/*
+ * exported bus type
+ */
+extern struct bus_type snd_hda_bus_type;
+
+/*
+ * HD-audio codec base device
+ */
+struct hdac_device {
+	struct device dev;
+	int type;
+};
+
+/* device/driver type used for matching */
+enum {
+	HDA_DEV_CORE,
+	HDA_DEV_LEGACY,
+};
+
+#define dev_to_hdac_dev(_dev)	container_of(_dev, struct hdac_device, dev)
+
+/*
+ * HD-audio codec base driver
+ */
+struct hdac_driver {
+	struct device_driver driver;
+	int type;
+	int (*match)(struct hdac_device *dev, struct hdac_driver *drv);
+};
+
+#define drv_to_hdac_driver(_drv) container_of(_drv, struct hdac_driver, driver)
+
+#endif /* __SOUND_HDAUDIO_H */
