commit 451787d3e2ac3a25abae91792b7154ee533b65c6
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Feb 21 10:00:05 2020 -0600

    video: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200221160005.GA13552@embeddedor

diff --git a/include/video/mmp_disp.h b/include/video/mmp_disp.h
index 1f9bc133e230..77252cb46361 100644
--- a/include/video/mmp_disp.h
+++ b/include/video/mmp_disp.h
@@ -231,7 +231,7 @@ struct mmp_path {
 
 	/* layers */
 	int overlay_num;
-	struct mmp_overlay overlays[0];
+	struct mmp_overlay overlays[];
 };
 
 extern struct mmp_path *mmp_get_path(const char *name);

commit 1ccea77e2a2687cae171b7987eb44730ec8c6d5f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:43 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 13
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not see http www gnu org licenses
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details [based]
      [from] [clk] [highbank] [c] you should have received a copy of the
      gnu general public license along with this program if not see http
      www gnu org licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 355 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154041.837383322@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/video/mmp_disp.h b/include/video/mmp_disp.h
index 9fd9398368d5..1f9bc133e230 100644
--- a/include/video/mmp_disp.h
+++ b/include/video/mmp_disp.h
@@ -1,23 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * linux/include/video/mmp_disp.h
  * Header file for Marvell MMP Display Controller
  *
  * Copyright (C) 2012 Marvell Technology Group Ltd.
  * Authors: Zhou Zhu <zzhu3@marvell.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
- *
  */
 
 #ifndef _MMP_DISP_H_

commit 24586d8342ab27bc75e4560d71e98f3e5dc67d8e
Author: Jing Xiang <jxiang@marvell.com>
Date:   Fri Sep 13 14:59:49 2013 +0800

    video: mmp: add pitch info in mmp_win structure
    
    Add pitch length info of graphics/video layer, pitch is used
    to represent line length in byte, the usage depends on pix_fmt.
    If the fmt is YUV, the pitch[0] will be Y length,pitch[1]
    will be U length, pitch[2] will be V lenth.
    If the fmt is RGB, the picth[0] will be line lenth, and
    pitch[1]/pitch[2] will be 0 and not be used.
    
    Signed-off-by: Jing Xiang <jxiang@marvell.com>
    Signed-off-by: Jett.Zhou <jtzhou@marvell.com>
    Signed-off-by: Zhou Zhu <zzhu3@marvell.com>
    Reviewed-by: Daniel Drake <dsd@laptop.org>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/include/video/mmp_disp.h b/include/video/mmp_disp.h
index 32094c052deb..9fd9398368d5 100644
--- a/include/video/mmp_disp.h
+++ b/include/video/mmp_disp.h
@@ -91,6 +91,11 @@ struct mmp_win {
 	u16	up_crop;
 	u16	bottom_crop;
 	int	pix_fmt;
+	/*
+	 * pitch[0]: graphics/video layer line length or y pitch
+	 * pitch[1]/pitch[2]: video u/v pitch if non-zero
+	 */
+	u32	pitch[3];
 };
 
 struct mmp_addr {

commit 9a27d5916b1d0338f76a4a8cb6fabc5320664453
Author: Guoqing Li <ligq@marvell.com>
Date:   Fri Sep 13 14:59:45 2013 +0800

    video: mmp: rb swap setting update for mmp display
    
    We could set rb swap in two modules: DMA controler input part and
    dsi interface output part.
    DMA input part is based on pix_fmt to set rbswap, dsi output interface
    part will set rbswap based on platform dsi_rbswap configuration.
    
    This patch include below change and enhancement:
    
    1) The input format which support rbswap is based on RGB format,
    eg. RGB565 indicates the source data in memory is that Red is [15~11],
    Green is [10~5], Blue is [4:0], Red is MSB, Blue is LSB, but for the
    display dma input default setting(rbswap = 0), it only support Blue
    is [15~11], Green is [10~5], Red is [4:0], Red is LSB, Blue is MSB,
    so for this format(RGB565), display controller need to set rbswap
     = 1 and it can support the MSB/LSB correctly.
    BGR/YUV format will not set it in mmp display driver.
    
    2) The dsi output part of rbswap is depend on dsi_rbswap which is
    defined in specific platfrom. For output dsi interface, it has this
    feature to do rbswap again if it needs specifc byte sequence of RGB
    byte for DSI panel.
    eg. If display content is set RGB565 in memory and DMA input part set
    rbswap in driver to support Red as MSB , Blue LSB, but dsi panel only
    support Red as LSB, Blue as MSB, then it can use this feature.
    If there is no this requirement of panel, this dsi output part is not
    needed.
    
    Signed-off-by: Guoqing Li <ligq@marvell.com>
    Signed-off-by: Jett.Zhou <jtzhou@marvell.com>
    Signed-off-by: Zhou Zhu <zzhu3@marvell.com>
    Reviewed-by: Daniel Drake <dsd@laptop.org>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/include/video/mmp_disp.h b/include/video/mmp_disp.h
index b9dd1fbb0082..32094c052deb 100644
--- a/include/video/mmp_disp.h
+++ b/include/video/mmp_disp.h
@@ -334,6 +334,7 @@ struct mmp_mach_path_config {
 	int output_type;
 	u32 path_config;
 	u32 link_config;
+	u32 dsi_rbswap;
 };
 
 struct mmp_mach_plat_info {

commit 59393bb94c103fca48c29348d2415cc67d772045
Author: Zhou Zhu <zzhu3@marvell.com>
Date:   Thu Feb 21 16:42:11 2013 -0800

    video: mmp display subsystem
    
    Add mmp display subsystem to support Marvell MMP display controllers.
    
    This subsystem contains 4 parts:
    --fb folder
    --core.c
    --hw folder
    --panel folder
    
    1. fb folder contains implementation of fb.  fb get path and overlay
       from common interface and operates on these structures.
    
    2. core.c provides common interface for a hardware abstraction.  Major
       parts of this interface are:
    
       a) Path: path is a output device connected to a panel or HDMI TV.  Main
          operations of the path is set/get timing/output color.  fb operates
          output device through path structure.
    
       b) Ovly: Ovly is a buffer shown on the path.
    
          Ovly describes frame buffer and its source/destination size, offset,
          input color, buffer address, z-order, and so on.  Each fb device maps
          to one overlay.
    
    3. hw folder contains implementation of hardware operations defined by
       core.c.  It registers paths for fb use.
    
    4. panel folder contains implementation of panels.  It's connected to
       path.  Panel drivers would also regiester panels and linked to path
       when probe.
    
    Signed-off-by: Zhou Zhu <zzhu3@marvell.com>
    Signed-off-by: Lisa Du <cldu@marvell.com>
    Cc: Guoqing Li <ligq@marvell.com>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: Florian Tobias Schandinat <FlorianSchandinat@gmx.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/video/mmp_disp.h b/include/video/mmp_disp.h
new file mode 100644
index 000000000000..b9dd1fbb0082
--- /dev/null
+++ b/include/video/mmp_disp.h
@@ -0,0 +1,352 @@
+/*
+ * linux/include/video/mmp_disp.h
+ * Header file for Marvell MMP Display Controller
+ *
+ * Copyright (C) 2012 Marvell Technology Group Ltd.
+ * Authors: Zhou Zhu <zzhu3@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef _MMP_DISP_H_
+#define _MMP_DISP_H_
+#include <linux/kthread.h>
+
+enum {
+	PIXFMT_UYVY = 0,
+	PIXFMT_VYUY,
+	PIXFMT_YUYV,
+	PIXFMT_YUV422P,
+	PIXFMT_YVU422P,
+	PIXFMT_YUV420P,
+	PIXFMT_YVU420P,
+	PIXFMT_RGB565 = 0x100,
+	PIXFMT_BGR565,
+	PIXFMT_RGB1555,
+	PIXFMT_BGR1555,
+	PIXFMT_RGB888PACK,
+	PIXFMT_BGR888PACK,
+	PIXFMT_RGB888UNPACK,
+	PIXFMT_BGR888UNPACK,
+	PIXFMT_RGBA888,
+	PIXFMT_BGRA888,
+	PIXFMT_RGB666, /* for output usage */
+	PIXFMT_PSEUDOCOLOR = 0x200,
+};
+
+static inline int pixfmt_to_stride(int pix_fmt)
+{
+	switch (pix_fmt) {
+	case PIXFMT_RGB565:
+	case PIXFMT_BGR565:
+	case PIXFMT_RGB1555:
+	case PIXFMT_BGR1555:
+	case PIXFMT_UYVY:
+	case PIXFMT_VYUY:
+	case PIXFMT_YUYV:
+		return 2;
+	case PIXFMT_RGB888UNPACK:
+	case PIXFMT_BGR888UNPACK:
+	case PIXFMT_RGBA888:
+	case PIXFMT_BGRA888:
+		return 4;
+	case PIXFMT_RGB888PACK:
+	case PIXFMT_BGR888PACK:
+		return 3;
+	case PIXFMT_YUV422P:
+	case PIXFMT_YVU422P:
+	case PIXFMT_YUV420P:
+	case PIXFMT_YVU420P:
+	case PIXFMT_PSEUDOCOLOR:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+/* parameters used by path/overlay */
+/* overlay related para: win/addr */
+struct mmp_win {
+	/* position/size of window */
+	u16	xsrc;
+	u16	ysrc;
+	u16	xdst;
+	u16	ydst;
+	u16	xpos;
+	u16	ypos;
+	u16	left_crop;
+	u16	right_crop;
+	u16	up_crop;
+	u16	bottom_crop;
+	int	pix_fmt;
+};
+
+struct mmp_addr {
+	/* phys address */
+	u32	phys[6];
+};
+
+/* path related para: mode */
+struct mmp_mode {
+	const char *name;
+	u32 refresh;
+	u32 xres;
+	u32 yres;
+	u32 left_margin;
+	u32 right_margin;
+	u32 upper_margin;
+	u32 lower_margin;
+	u32 hsync_len;
+	u32 vsync_len;
+	u32 hsync_invert;
+	u32 vsync_invert;
+	u32 invert_pixclock;
+	u32 pixclock_freq;
+	int pix_fmt_out;
+};
+
+/* main structures */
+struct mmp_path;
+struct mmp_overlay;
+struct mmp_panel;
+
+/* status types */
+enum {
+	MMP_OFF = 0,
+	MMP_ON,
+};
+
+static inline const char *stat_name(int stat)
+{
+	switch (stat) {
+	case MMP_OFF:
+		return "OFF";
+	case MMP_ON:
+		return "ON";
+	default:
+		return "UNKNOWNSTAT";
+	}
+}
+
+struct mmp_overlay_ops {
+	/* should be provided by driver */
+	void (*set_fetch)(struct mmp_overlay *overlay, int fetch_id);
+	void (*set_onoff)(struct mmp_overlay *overlay, int status);
+	void (*set_win)(struct mmp_overlay *overlay, struct mmp_win *win);
+	int (*set_addr)(struct mmp_overlay *overlay, struct mmp_addr *addr);
+};
+
+/* overlay describes a z-order indexed slot in each path. */
+struct mmp_overlay {
+	int id;
+	const char *name;
+	struct mmp_path *path;
+
+	/* overlay info: private data */
+	int dmafetch_id;
+	struct mmp_addr addr;
+	struct mmp_win win;
+
+	/* state */
+	int open_count;
+	int status;
+	struct mutex access_ok;
+
+	struct mmp_overlay_ops *ops;
+};
+
+/* panel type */
+enum {
+	PANELTYPE_ACTIVE = 0,
+	PANELTYPE_SMART,
+	PANELTYPE_TV,
+	PANELTYPE_DSI_CMD,
+	PANELTYPE_DSI_VIDEO,
+};
+
+struct mmp_panel {
+	/* use node to register to list */
+	struct list_head node;
+	const char *name;
+	/* path name used to connect to proper path configed */
+	const char *plat_path_name;
+	struct device *dev;
+	int panel_type;
+	void *plat_data;
+	int (*get_modelist)(struct mmp_panel *panel,
+			struct mmp_mode **modelist);
+	void (*set_mode)(struct mmp_panel *panel,
+			struct mmp_mode *mode);
+	void (*set_onoff)(struct mmp_panel *panel,
+			int status);
+};
+
+struct mmp_path_ops {
+	int (*check_status)(struct mmp_path *path);
+	struct mmp_overlay *(*get_overlay)(struct mmp_path *path,
+			int overlay_id);
+	int (*get_modelist)(struct mmp_path *path,
+			struct mmp_mode **modelist);
+
+	/* follow ops should be provided by driver */
+	void (*set_mode)(struct mmp_path *path, struct mmp_mode *mode);
+	void (*set_onoff)(struct mmp_path *path, int status);
+	/* todo: add query */
+};
+
+/* path output types */
+enum {
+	PATH_OUT_PARALLEL,
+	PATH_OUT_DSI,
+	PATH_OUT_HDMI,
+};
+
+/* path is main part of mmp-disp */
+struct mmp_path {
+	/* use node to register to list */
+	struct list_head node;
+
+	/* init data */
+	struct device *dev;
+
+	int id;
+	const char *name;
+	int output_type;
+	struct mmp_panel *panel;
+	void *plat_data;
+
+	/* dynamic use */
+	struct mmp_mode mode;
+
+	/* state */
+	int open_count;
+	int status;
+	struct mutex access_ok;
+
+	struct mmp_path_ops ops;
+
+	/* layers */
+	int overlay_num;
+	struct mmp_overlay overlays[0];
+};
+
+extern struct mmp_path *mmp_get_path(const char *name);
+static inline void mmp_path_set_mode(struct mmp_path *path,
+		struct mmp_mode *mode)
+{
+	if (path)
+		path->ops.set_mode(path, mode);
+}
+static inline void mmp_path_set_onoff(struct mmp_path *path, int status)
+{
+	if (path)
+		path->ops.set_onoff(path, status);
+}
+static inline int mmp_path_get_modelist(struct mmp_path *path,
+		struct mmp_mode **modelist)
+{
+	if (path)
+		return path->ops.get_modelist(path, modelist);
+	return 0;
+}
+static inline struct mmp_overlay *mmp_path_get_overlay(
+		struct mmp_path *path, int overlay_id)
+{
+	if (path)
+		return path->ops.get_overlay(path, overlay_id);
+	return NULL;
+}
+static inline void mmp_overlay_set_fetch(struct mmp_overlay *overlay,
+		int fetch_id)
+{
+	if (overlay)
+		overlay->ops->set_fetch(overlay, fetch_id);
+}
+static inline void mmp_overlay_set_onoff(struct mmp_overlay *overlay,
+		int status)
+{
+	if (overlay)
+		overlay->ops->set_onoff(overlay, status);
+}
+static inline void mmp_overlay_set_win(struct mmp_overlay *overlay,
+		struct mmp_win *win)
+{
+	if (overlay)
+		overlay->ops->set_win(overlay, win);
+}
+static inline int mmp_overlay_set_addr(struct mmp_overlay *overlay,
+		struct mmp_addr *addr)
+{
+	if (overlay)
+		return overlay->ops->set_addr(overlay, addr);
+	return 0;
+}
+
+/*
+ * driver data is set from each detailed ctrl driver for path usage
+ * it defined a common interface that plat driver need to implement
+ */
+struct mmp_path_info {
+	/* driver data, set when registed*/
+	const char *name;
+	struct device *dev;
+	int id;
+	int output_type;
+	int overlay_num;
+	void (*set_mode)(struct mmp_path *path, struct mmp_mode *mode);
+	void (*set_onoff)(struct mmp_path *path, int status);
+	struct mmp_overlay_ops *overlay_ops;
+	void *plat_data;
+};
+
+extern struct mmp_path *mmp_register_path(
+		struct mmp_path_info *info);
+extern void mmp_unregister_path(struct mmp_path *path);
+extern void mmp_register_panel(struct mmp_panel *panel);
+extern void mmp_unregister_panel(struct mmp_panel *panel);
+
+/* defintions for platform data */
+/* interface for buffer driver */
+struct mmp_buffer_driver_mach_info {
+	const char	*name;
+	const char	*path_name;
+	int	overlay_id;
+	int	dmafetch_id;
+	int	default_pixfmt;
+};
+
+/* interface for controllers driver */
+struct mmp_mach_path_config {
+	const char *name;
+	int overlay_num;
+	int output_type;
+	u32 path_config;
+	u32 link_config;
+};
+
+struct mmp_mach_plat_info {
+	const char *name;
+	const char *clk_name;
+	int path_num;
+	struct mmp_mach_path_config *paths;
+};
+
+/* interface for panel drivers */
+struct mmp_mach_panel_info {
+	const char *name;
+	void (*plat_set_onoff)(int status);
+	const char *plat_path_name;
+};
+#endif	/* _MMP_DISP_H_ */
