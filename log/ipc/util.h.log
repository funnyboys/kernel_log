commit fb377eb80c80339b580831a3c0fcce34a4c9d1ad
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Sep 5 16:48:38 2019 +0200

    ipc: fix sparc64 ipc() wrapper
    
    Matt bisected a sparc64 specific issue with semctl, shmctl and msgctl
    to a commit from my y2038 series in linux-5.1, as I missed the custom
    sys_ipc() wrapper that sparc64 uses in place of the generic version that
    I patched.
    
    The problem is that the sys_{sem,shm,msg}ctl() functions in the kernel
    now do not allow being called with the IPC_64 flag any more, resulting
    in a -EINVAL error when they don't recognize the command.
    
    Instead, the correct way to do this now is to call the internal
    ksys_old_{sem,shm,msg}ctl() functions to select the API version.
    
    As we generally move towards these functions anyway, change all of
    sparc_ipc() to consistently use those in place of the sys_*() versions,
    and move the required ksys_*() declarations into linux/syscalls.h
    
    The IS_ENABLED(CONFIG_SYSVIPC) check is required to avoid link
    errors when ipc is disabled.
    
    Reported-by: Matt Turner <mattst88@gmail.com>
    Fixes: 275f22148e87 ("ipc: rename old-style shmctl/semctl/msgctl syscalls")
    Cc: stable@vger.kernel.org
    Tested-by: Matt Turner <mattst88@gmail.com>
    Tested-by: Anatoly Pugachev <matorola@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/ipc/util.h b/ipc/util.h
index 0fcf8e719b76..5766c61aed0e 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -276,29 +276,7 @@ static inline int compat_ipc_parse_version(int *cmd)
 	*cmd &= ~IPC_64;
 	return version;
 }
-#endif
 
-/* for __ARCH_WANT_SYS_IPC */
-long ksys_semtimedop(int semid, struct sembuf __user *tsops,
-		     unsigned int nsops,
-		     const struct __kernel_timespec __user *timeout);
-long ksys_semget(key_t key, int nsems, int semflg);
-long ksys_old_semctl(int semid, int semnum, int cmd, unsigned long arg);
-long ksys_msgget(key_t key, int msgflg);
-long ksys_old_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);
-long ksys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz,
-		 long msgtyp, int msgflg);
-long ksys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz,
-		 int msgflg);
-long ksys_shmget(key_t key, size_t size, int shmflg);
-long ksys_shmdt(char __user *shmaddr);
-long ksys_old_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);
-
-/* for CONFIG_ARCH_WANT_OLD_COMPAT_IPC */
-long compat_ksys_semtimedop(int semid, struct sembuf __user *tsems,
-			    unsigned int nsops,
-			    const struct old_timespec32 __user *timeout);
-#ifdef CONFIG_COMPAT
 long compat_ksys_old_semctl(int semid, int semnum, int cmd, int arg);
 long compat_ksys_old_msgctl(int msqid, int cmd, void __user *uptr);
 long compat_ksys_msgrcv(int msqid, compat_uptr_t msgp, compat_ssize_t msgsz,
@@ -306,6 +284,7 @@ long compat_ksys_msgrcv(int msqid, compat_uptr_t msgp, compat_ssize_t msgsz,
 long compat_ksys_msgsnd(int msqid, compat_uptr_t msgp,
 		       compat_ssize_t msgsz, int msgflg);
 long compat_ksys_old_shmctl(int shmid, int cmd, void __user *uptr);
-#endif /* CONFIG_COMPAT */
+
+#endif
 
 #endif

commit 99db46ea292780cd978d56932d9445b1e8bdafe8
Author: Manfred Spraul <manfred@colorfullife.com>
Date:   Tue May 14 15:46:36 2019 -0700

    ipc: do cyclic id allocation for the ipc object.
    
    For ipcmni_extend mode, the sequence number space is only 7 bits.  So
    the chance of id reuse is relatively high compared with the non-extended
    mode.
    
    To alleviate this id reuse problem, this patch enables cyclic allocation
    for the index to the radix tree (idx).  The disadvantage is that this
    can cause a slight slow-down of the fast path, as the radix tree could
    be higher than necessary.
    
    To limit the radix tree height, I have chosen the following limits:
     1) The cycling is done over in_use*1.5.
     2) At least, the cycling is done over
       "normal" ipcnmi mode: RADIX_TREE_MAP_SIZE elements
       "ipcmni_extended": 4096 elements
    
    Result:
    - for normal mode:
            No change for <= 42 active ipc elements. With more than 42
            active ipc elements, a 2nd level would be added to the radix
            tree.
            Without cyclic allocation, a 2nd level would be added only with
            more than 63 active elements.
    
    - for extended mode:
            Cycling creates always at least a 2-level radix tree.
            With more than 2730 active objects, a 3rd level would be
            added, instead of > 4095 active objects until the 3rd level
            is added without cyclic allocation.
    
    For a 2-level radix tree compared to a 1-level radix tree, I have
    observed < 1% performance impact.
    
    Notes:
    1) Normal "x=semget();y=semget();" is unaffected: Then the idx
      is e.g. a and a+1, regardless if idr_alloc() or idr_alloc_cyclic()
      is used.
    
    2) The -1% happens in a microbenchmark after this situation:
            x=semget();
            for(i=0;i<4000;i++) {t=semget();semctl(t,0,IPC_RMID);}
            y=semget();
            Now perform semget calls on x and y that do not sleep.
    
    3) The worst-case reuse cycle time is unfortunately unaffected:
       If you have 2^24-1 ipc objects allocated, and get/remove the last
       possible element in a loop, then the id is reused after 128
       get/remove pairs.
    
    Performance check:
    A microbenchmark that performes no-op semop() randomly on two IDs,
    with only these two IDs allocated.
    The IDs were set using /proc/sys/kernel/sem_next_id.
    The test was run 5 times, averages are shown.
    
    1 & 2: Base (6.22 seconds for 10.000.000 semops)
    1 & 40: -0.2%
    1 & 3348: - 0.8%
    1 & 27348: - 1.6%
    1 & 15777204: - 3.2%
    
    Or: ~12.6 cpu cycles per additional radix tree level.
    The cpu is an Intel I3-5010U. ~1300 cpu cycles/syscall is slower
    than what I remember (spectre impact?).
    
    V2 of the patch:
    - use "min" and "max"
    - use RADIX_TREE_MAP_SIZE * RADIX_TREE_MAP_SIZE instead of
            (2<<12).
    
    [akpm@linux-foundation.org: fix max() warning]
    Link: http://lkml.kernel.org/r/20190329204930.21620-3-longman@redhat.com
    Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
    Acked-by: Waiman Long <longman@redhat.com>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: "Eric W . Biederman" <ebiederm@xmission.com>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 8c834ed39012..0fcf8e719b76 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -27,12 +27,14 @@
  */
 #define IPCMNI_SHIFT		15
 #define IPCMNI_EXTEND_SHIFT	24
+#define IPCMNI_EXTEND_MIN_CYCLE	(RADIX_TREE_MAP_SIZE * RADIX_TREE_MAP_SIZE)
 #define IPCMNI			(1 << IPCMNI_SHIFT)
 #define IPCMNI_EXTEND		(1 << IPCMNI_EXTEND_SHIFT)
 
 #ifdef CONFIG_SYSVIPC_SYSCTL
 extern int ipc_mni;
 extern int ipc_mni_shift;
+extern int ipc_min_cycle;
 
 #define ipcmni_seq_shift()	ipc_mni_shift
 #define IPCMNI_IDX_MASK		((1 << ipc_mni_shift) - 1)
@@ -40,6 +42,7 @@ extern int ipc_mni_shift;
 #else /* CONFIG_SYSVIPC_SYSCTL */
 
 #define ipc_mni			IPCMNI
+#define ipc_min_cycle		((int)RADIX_TREE_MAP_SIZE)
 #define ipcmni_seq_shift()	IPCMNI_SHIFT
 #define IPCMNI_IDX_MASK		((1 << IPCMNI_SHIFT) - 1)
 #endif /* CONFIG_SYSVIPC_SYSCTL */

commit 3278a2c20cb302d27e6f6ee45a3f57361176e426
Author: Manfred Spraul <manfred@colorfullife.com>
Date:   Tue May 14 15:46:33 2019 -0700

    ipc: conserve sequence numbers in ipcmni_extend mode
    
    Rewrite, based on the patch from Waiman Long:
    
    The mixing in of a sequence number into the IPC IDs is probably to avoid
    ID reuse in userspace as much as possible.  With ipcmni_extend mode, the
    number of usable sequence numbers is greatly reduced leading to higher
    chance of ID reuse.
    
    To address this issue, we need to conserve the sequence number space as
    much as possible.  Right now, the sequence number is incremented for
    every new ID created.  In reality, we only need to increment the
    sequence number when new allocated ID is not greater than the last one
    allocated.  It is in such case that the new ID may collide with an
    existing one.  This is being done irrespective of the ipcmni mode.
    
    In order to avoid any races, the index is first allocated and then the
    pointer is replaced.
    
    Changes compared to the initial patch:
     - Handle failures from idr_alloc().
     - Avoid that concurrent operations can see the wrong sequence number.
       (This is achieved by using idr_replace()).
     - IPCMNI_SEQ_SHIFT is not a constant, thus renamed to
       ipcmni_seq_shift().
     - IPCMNI_SEQ_MAX is not a constant, thus renamed to ipcmni_seq_max().
    
    Link: http://lkml.kernel.org/r/20190329204930.21620-2-longman@redhat.com
    Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
    Signed-off-by: Waiman Long <longman@redhat.com>
    Suggested-by: Matthew Wilcox <willy@infradead.org>
    Acked-by: Waiman Long <longman@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: "Eric W . Biederman" <ebiederm@xmission.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 9746886757de..8c834ed39012 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -34,13 +34,13 @@
 extern int ipc_mni;
 extern int ipc_mni_shift;
 
-#define IPCMNI_SEQ_SHIFT	ipc_mni_shift
+#define ipcmni_seq_shift()	ipc_mni_shift
 #define IPCMNI_IDX_MASK		((1 << ipc_mni_shift) - 1)
 
 #else /* CONFIG_SYSVIPC_SYSCTL */
 
 #define ipc_mni			IPCMNI
-#define IPCMNI_SEQ_SHIFT	IPCMNI_SHIFT
+#define ipcmni_seq_shift()	IPCMNI_SHIFT
 #define IPCMNI_IDX_MASK		((1 << IPCMNI_SHIFT) - 1)
 #endif /* CONFIG_SYSVIPC_SYSCTL */
 
@@ -123,8 +123,8 @@ struct pid_namespace *ipc_seq_pid_ns(struct seq_file *);
 #define IPC_SHM_IDS	2
 
 #define ipcid_to_idx(id)  ((id) & IPCMNI_IDX_MASK)
-#define ipcid_to_seqx(id) ((id) >> IPCMNI_SEQ_SHIFT)
-#define IPCID_SEQ_MAX	  (INT_MAX >> IPCMNI_SEQ_SHIFT)
+#define ipcid_to_seqx(id) ((id) >> ipcmni_seq_shift())
+#define ipcid_seq_max()	  (INT_MAX >> ipcmni_seq_shift())
 
 /* must be called with ids->rwsem acquired for writing */
 int ipc_addid(struct ipc_ids *, struct kern_ipc_perm *, int);

commit 5ac893b8cb10fe2a47a77780d37f9bf5b142854b
Author: Waiman Long <longman@redhat.com>
Date:   Tue May 14 15:46:29 2019 -0700

    ipc: allow boot time extension of IPCMNI from 32k to 16M
    
    The maximum number of unique System V IPC identifiers was limited to
    32k.  That limit should be big enough for most use cases.
    
    However, there are some users out there requesting for more, especially
    those that are migrating from Solaris which uses 24 bits for unique
    identifiers.  To satisfy the need of those users, a new boot time kernel
    option "ipcmni_extend" is added to extend the IPCMNI value to 16M.  This
    is a 512X increase which should be big enough for users out there that
    need a large number of unique IPC identifier.
    
    The use of this new option will change the pattern of the IPC
    identifiers returned by functions like shmget(2).  An application that
    depends on such pattern may not work properly.  So it should only be
    used if the users really need more than 32k of unique IPC numbers.
    
    This new option does have the side effect of reducing the maximum number
    of unique sequence numbers from 64k down to 128.  So it is a trade-off.
    
    The computation of a new IPC id is not done in the performance critical
    path.  So a little bit of additional overhead shouldn't have any real
    performance impact.
    
    Link: http://lkml.kernel.org/r/20190329204930.21620-1-longman@redhat.com
    Signed-off-by: Waiman Long <longman@redhat.com>
    Acked-by: Manfred Spraul <manfred@colorfullife.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: "Eric W . Biederman" <ebiederm@xmission.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index e272be622ae7..9746886757de 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -15,8 +15,34 @@
 #include <linux/err.h>
 #include <linux/ipc_namespace.h>
 
-#define IPCMNI 32768  /* <= MAX_INT limit for ipc arrays (including sysctl changes) */
-#define SEQ_MULTIPLIER	(IPCMNI)
+/*
+ * The IPC ID contains 2 separate numbers - index and sequence number.
+ * By default,
+ *   bits  0-14: index (32k, 15 bits)
+ *   bits 15-30: sequence number (64k, 16 bits)
+ *
+ * When IPCMNI extension mode is turned on, the composition changes:
+ *   bits  0-23: index (16M, 24 bits)
+ *   bits 24-30: sequence number (128, 7 bits)
+ */
+#define IPCMNI_SHIFT		15
+#define IPCMNI_EXTEND_SHIFT	24
+#define IPCMNI			(1 << IPCMNI_SHIFT)
+#define IPCMNI_EXTEND		(1 << IPCMNI_EXTEND_SHIFT)
+
+#ifdef CONFIG_SYSVIPC_SYSCTL
+extern int ipc_mni;
+extern int ipc_mni_shift;
+
+#define IPCMNI_SEQ_SHIFT	ipc_mni_shift
+#define IPCMNI_IDX_MASK		((1 << ipc_mni_shift) - 1)
+
+#else /* CONFIG_SYSVIPC_SYSCTL */
+
+#define ipc_mni			IPCMNI
+#define IPCMNI_SEQ_SHIFT	IPCMNI_SHIFT
+#define IPCMNI_IDX_MASK		((1 << IPCMNI_SHIFT) - 1)
+#endif /* CONFIG_SYSVIPC_SYSCTL */
 
 void sem_init(void);
 void msg_init(void);
@@ -96,9 +122,9 @@ struct pid_namespace *ipc_seq_pid_ns(struct seq_file *);
 #define IPC_MSG_IDS	1
 #define IPC_SHM_IDS	2
 
-#define ipcid_to_idx(id) ((id) % SEQ_MULTIPLIER)
-#define ipcid_to_seqx(id) ((id) / SEQ_MULTIPLIER)
-#define IPCID_SEQ_MAX min_t(int, INT_MAX/SEQ_MULTIPLIER, USHRT_MAX)
+#define ipcid_to_idx(id)  ((id) & IPCMNI_IDX_MASK)
+#define ipcid_to_seqx(id) ((id) >> IPCMNI_SEQ_SHIFT)
+#define IPCID_SEQ_MAX	  (INT_MAX >> IPCMNI_SEQ_SHIFT)
 
 /* must be called with ids->rwsem acquired for writing */
 int ipc_addid(struct ipc_ids *, struct kern_ipc_perm *, int);
@@ -123,8 +149,8 @@ static inline int ipc_get_maxidx(struct ipc_ids *ids)
 	if (ids->in_use == 0)
 		return -1;
 
-	if (ids->in_use == IPCMNI)
-		return IPCMNI - 1;
+	if (ids->in_use == ipc_mni)
+		return ipc_mni - 1;
 
 	return ids->max_idx;
 }
@@ -216,10 +242,10 @@ void free_ipcs(struct ipc_namespace *ns, struct ipc_ids *ids,
 
 static inline int sem_check_semmni(struct ipc_namespace *ns) {
 	/*
-	 * Check semmni range [0, IPCMNI]
+	 * Check semmni range [0, ipc_mni]
 	 * semmni is the last element of sem_ctls[4] array
 	 */
-	return ((ns->sem_ctls[3] < 0) || (ns->sem_ctls[3] > IPCMNI))
+	return ((ns->sem_ctls[3] < 0) || (ns->sem_ctls[3] > ipc_mni))
 		? -ERANGE : 0;
 }
 

commit 275f22148e8720e84b180d9e0cdf8abfd69bac5b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Dec 31 22:22:40 2018 +0100

    ipc: rename old-style shmctl/semctl/msgctl syscalls
    
    The behavior of these system calls is slightly different between
    architectures, as determined by the CONFIG_ARCH_WANT_IPC_PARSE_VERSION
    symbol. Most architectures that implement the split IPC syscalls don't set
    that symbol and only get the modern version, but alpha, arm, microblaze,
    mips-n32, mips-n64 and xtensa expect the caller to pass the IPC_64 flag.
    
    For the architectures that so far only implement sys_ipc(), i.e. m68k,
    mips-o32, powerpc, s390, sh, sparc, and x86-32, we want the new behavior
    when adding the split syscalls, so we need to distinguish between the
    two groups of architectures.
    
    The method I picked for this distinction is to have a separate system call
    entry point: sys_old_*ctl() now uses ipc_parse_version, while sys_*ctl()
    does not. The system call tables of the five architectures are changed
    accordingly.
    
    As an additional benefit, we no longer need the configuration specific
    definition for ipc_parse_version(), it always does the same thing now,
    but simply won't get called on architectures with the modern interface.
    
    A small downside is that on architectures that do set
    ARCH_WANT_IPC_PARSE_VERSION, we now have an extra set of entry points
    that are never called. They only add a few bytes of bloat, so it seems
    better to keep them compared to adding yet another Kconfig symbol.
    I considered adding new syscall numbers for the IPC_64 variants for
    consistency, but decided against that for now.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/ipc/util.h b/ipc/util.h
index d768fdbed515..e272be622ae7 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -160,10 +160,7 @@ static inline void ipc_update_pid(struct pid **pos, struct pid *pid)
 	}
 }
 
-#ifndef CONFIG_ARCH_WANT_IPC_PARSE_VERSION
-/* On IA-64, we always use the "64-bit version" of the IPC structures.  */
-# define ipc_parse_version(cmd)	IPC_64
-#else
+#ifdef CONFIG_ARCH_WANT_IPC_PARSE_VERSION
 int ipc_parse_version(int *cmd);
 #endif
 
@@ -246,13 +243,9 @@ int get_compat_ipc64_perm(struct ipc64_perm *,
 
 static inline int compat_ipc_parse_version(int *cmd)
 {
-#ifdef	CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION
 	int version = *cmd & IPC_64;
 	*cmd &= ~IPC_64;
 	return version;
-#else
-	return IPC_64;
-#endif
 }
 #endif
 
@@ -261,29 +254,29 @@ long ksys_semtimedop(int semid, struct sembuf __user *tsops,
 		     unsigned int nsops,
 		     const struct __kernel_timespec __user *timeout);
 long ksys_semget(key_t key, int nsems, int semflg);
-long ksys_semctl(int semid, int semnum, int cmd, unsigned long arg);
+long ksys_old_semctl(int semid, int semnum, int cmd, unsigned long arg);
 long ksys_msgget(key_t key, int msgflg);
-long ksys_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);
+long ksys_old_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);
 long ksys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz,
 		 long msgtyp, int msgflg);
 long ksys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz,
 		 int msgflg);
 long ksys_shmget(key_t key, size_t size, int shmflg);
 long ksys_shmdt(char __user *shmaddr);
-long ksys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);
+long ksys_old_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);
 
 /* for CONFIG_ARCH_WANT_OLD_COMPAT_IPC */
 long compat_ksys_semtimedop(int semid, struct sembuf __user *tsems,
 			    unsigned int nsops,
 			    const struct old_timespec32 __user *timeout);
 #ifdef CONFIG_COMPAT
-long compat_ksys_semctl(int semid, int semnum, int cmd, int arg);
-long compat_ksys_msgctl(int msqid, int cmd, void __user *uptr);
+long compat_ksys_old_semctl(int semid, int semnum, int cmd, int arg);
+long compat_ksys_old_msgctl(int msqid, int cmd, void __user *uptr);
 long compat_ksys_msgrcv(int msqid, compat_uptr_t msgp, compat_ssize_t msgsz,
 			compat_long_t msgtyp, int msgflg);
 long compat_ksys_msgsnd(int msqid, compat_uptr_t msgp,
 		       compat_ssize_t msgsz, int msgflg);
-long compat_ksys_shmctl(int shmid, int cmd, void __user *uptr);
+long compat_ksys_old_shmctl(int shmid, int cmd, void __user *uptr);
 #endif /* CONFIG_COMPAT */
 
 #endif

commit 8c81ddd2acd2c10979f5a64f6784ce7c6717495e
Author: Waiman Long <longman@redhat.com>
Date:   Tue Oct 30 15:07:24 2018 -0700

    ipc: IPCMNI limit check for semmni
    
    For SysV semaphores, the semmni value is the last part of the 4-element
    sem number array.  To make semmni behave in a similar way to msgmni and
    shmmni, we can't directly use the _minmax handler.  Instead, a special sem
    specific handler is added to check the last argument to make sure that it
    is limited to the [0, IPCMNI] range.  An error will be returned if this is
    not the case.
    
    Link: http://lkml.kernel.org/r/1536352137-12003-3-git-send-email-longman@redhat.com
    Signed-off-by: Waiman Long <longman@redhat.com>
    Reviewed-by: Davidlohr Bueso <dave@stgolabs.net>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Luis R. Rodriguez <mcgrof@kernel.org>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 1ee81bce25e9..d768fdbed515 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -217,6 +217,15 @@ int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
 void free_ipcs(struct ipc_namespace *ns, struct ipc_ids *ids,
 		void (*free)(struct ipc_namespace *, struct kern_ipc_perm *));
 
+static inline int sem_check_semmni(struct ipc_namespace *ns) {
+	/*
+	 * Check semmni range [0, IPCMNI]
+	 * semmni is the last element of sem_ctls[4] array
+	 */
+	return ((ns->sem_ctls[3] < 0) || (ns->sem_ctls[3] > IPCMNI))
+		? -ERANGE : 0;
+}
+
 #ifdef CONFIG_COMPAT
 #include <linux/compat.h>
 struct compat_ipc_perm {

commit 9afc5eee65ca7d717a99d6fe8f4adfe32a40940a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jul 13 12:52:28 2018 +0200

    y2038: globally rename compat_time to old_time32
    
    Christoph Hellwig suggested a slightly different path for handling
    backwards compatibility with the 32-bit time_t based system calls:
    
    Rather than simply reusing the compat_sys_* entry points on 32-bit
    architectures unchanged, we get rid of those entry points and the
    compat_time types by renaming them to something that makes more sense
    on 32-bit architectures (which don't have a compat mode otherwise),
    and then share the entry points under the new name with the 64-bit
    architectures that use them for implementing the compatibility.
    
    The following types and interfaces are renamed here, and moved
    from linux/compat_time.h to linux/time32.h:
    
    old                             new
    ---                             ---
    compat_time_t                   old_time32_t
    struct compat_timeval           struct old_timeval32
    struct compat_timespec          struct old_timespec32
    struct compat_itimerspec        struct old_itimerspec32
    ns_to_compat_timeval()          ns_to_old_timeval32()
    get_compat_itimerspec64()       get_old_itimerspec32()
    put_compat_itimerspec64()       put_old_itimerspec32()
    compat_get_timespec64()         get_old_timespec32()
    compat_put_timespec64()         put_old_timespec32()
    
    As we already have aliases in place, this patch addresses only the
    instances that are relevant to the system call interface in particular,
    not those that occur in device drivers and other modules. Those
    will get handled separately, while providing the 64-bit version
    of the respective interfaces.
    
    I'm not renaming the timex, rusage and itimerval structures, as we are
    still debating what the new interface will look like, and whether we
    will need a replacement at all.
    
    This also doesn't change the names of the syscall entry points, which can
    be done more easily when we actually switch over the 32-bit architectures
    to use them, at that point we need to change COMPAT_SYSCALL_DEFINEx to
    SYSCALL_DEFINEx with a new name, e.g. with a _time32 suffix.
    
    Suggested-by: Christoph Hellwig <hch@infradead.org>
    Link: https://lore.kernel.org/lkml/20180705222110.GA5698@infradead.org/
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/ipc/util.h b/ipc/util.h
index 0a159f69b3bb..1ee81bce25e9 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -266,7 +266,7 @@ long ksys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);
 /* for CONFIG_ARCH_WANT_OLD_COMPAT_IPC */
 long compat_ksys_semtimedop(int semid, struct sembuf __user *tsems,
 			    unsigned int nsops,
-			    const struct compat_timespec __user *timeout);
+			    const struct old_timespec32 __user *timeout);
 #ifdef CONFIG_COMPAT
 long compat_ksys_semctl(int semid, int semnum, int cmd, int arg);
 long compat_ksys_msgctl(int msqid, int cmd, void __user *uptr);

commit 2a9d6481004215da8e93edb588cf448f2af80303
Author: Manfred Spraul <manfred@colorfullife.com>
Date:   Tue Aug 21 22:02:04 2018 -0700

    ipc/util.c: update return value of ipc_getref from int to bool
    
    ipc_getref has still a return value of type "int", matching the atomic_t
    interface of atomic_inc_not_zero()/atomic_add_unless().
    
    ipc_getref now uses refcount_inc_not_zero, which has a return value of
    type "bool".
    
    Therefore, update the return code to avoid implicit conversions.
    
    Link: http://lkml.kernel.org/r/20180712185241.4017-13-manfred@colorfullife.com
    Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index e74564fe3375..0a159f69b3bb 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -138,7 +138,7 @@ static inline int ipc_get_maxidx(struct ipc_ids *ids)
  * refcount is initialized by ipc_addid(), before that point call_rcu()
  * must be used.
  */
-int ipc_rcu_getref(struct kern_ipc_perm *ptr);
+bool ipc_rcu_getref(struct kern_ipc_perm *ptr);
 void ipc_rcu_putref(struct kern_ipc_perm *ptr,
 			void (*func)(struct rcu_head *head));
 

commit 27c331a174614208d0b539019583990967ad9479
Author: Manfred Spraul <manfred@colorfullife.com>
Date:   Tue Aug 21 22:02:00 2018 -0700

    ipc/util.c: further variable name cleanups
    
    The varable names got a mess, thus standardize them again:
    
    id: user space id. Called semid, shmid, msgid if the type is known.
        Most functions use "id" already.
    idx: "index" for the idr lookup
        Right now, some functions use lid, ipc_addid() already uses idx as
        the variable name.
    seq: sequence number, to avoid quick collisions of the user space id
    key: user space key, used for the rhash tree
    
    Link: http://lkml.kernel.org/r/20180712185241.4017-12-manfred@colorfullife.com
    Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 6c5c77c61f85..e74564fe3375 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -113,12 +113,12 @@ void ipc_set_key_private(struct ipc_ids *, struct kern_ipc_perm *);
 int ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flg);
 
 /**
- * ipc_get_maxid - get the last assigned id
+ * ipc_get_maxidx - get the highest assigned index
  * @ids: ipc identifier set
  *
  * Called with ipc_ids.rwsem held for reading.
  */
-static inline int ipc_get_maxid(struct ipc_ids *ids)
+static inline int ipc_get_maxidx(struct ipc_ids *ids)
 {
 	if (ids->in_use == 0)
 		return -1;
@@ -126,7 +126,7 @@ static inline int ipc_get_maxid(struct ipc_ids *ids)
 	if (ids->in_use == IPCMNI)
 		return IPCMNI - 1;
 
-	return ids->max_id;
+	return ids->max_idx;
 }
 
 /*
@@ -172,9 +172,9 @@ extern struct msg_msg *load_msg(const void __user *src, size_t len);
 extern struct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst);
 extern int store_msg(void __user *dest, struct msg_msg *msg, size_t len);
 
-static inline int ipc_checkid(struct kern_ipc_perm *ipcp, int uid)
+static inline int ipc_checkid(struct kern_ipc_perm *ipcp, int id)
 {
-	return uid / SEQ_MULTIPLIER != ipcp->seq;
+	return ipcid_to_seqx(id) != ipcp->seq;
 }
 
 static inline void ipc_lock_object(struct kern_ipc_perm *perm)

commit eae04d25a713304c978d7c45dcab01b0e0811c74
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Tue Aug 21 22:01:56 2018 -0700

    ipc: simplify ipc initialization
    
    Now that we know that rhashtable_init() will not fail, we can get rid of a
    lot of the unnecessary cleanup paths when the call errored out.
    
    [manfred@colorfullife.com: variable name added to util.h to resolve checkpatch warning]
    Link: http://lkml.kernel.org/r/20180712185241.4017-11-manfred@colorfullife.com
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index e3c47b21db93..6c5c77c61f85 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -18,8 +18,8 @@
 #define IPCMNI 32768  /* <= MAX_INT limit for ipc arrays (including sysctl changes) */
 #define SEQ_MULTIPLIER	(IPCMNI)
 
-int sem_init(void);
-int msg_init(void);
+void sem_init(void);
+void msg_init(void);
 void shm_init(void);
 
 struct ipc_namespace;
@@ -34,17 +34,17 @@ static inline void mq_put_mnt(struct ipc_namespace *ns) { }
 #endif
 
 #ifdef CONFIG_SYSVIPC
-int sem_init_ns(struct ipc_namespace *ns);
-int msg_init_ns(struct ipc_namespace *ns);
-int shm_init_ns(struct ipc_namespace *ns);
+void sem_init_ns(struct ipc_namespace *ns);
+void msg_init_ns(struct ipc_namespace *ns);
+void shm_init_ns(struct ipc_namespace *ns);
 
 void sem_exit_ns(struct ipc_namespace *ns);
 void msg_exit_ns(struct ipc_namespace *ns);
 void shm_exit_ns(struct ipc_namespace *ns);
 #else
-static inline int sem_init_ns(struct ipc_namespace *ns) { return 0; }
-static inline int msg_init_ns(struct ipc_namespace *ns) { return 0; }
-static inline int shm_init_ns(struct ipc_namespace *ns) { return 0; }
+static inline void sem_init_ns(struct ipc_namespace *ns) { }
+static inline void msg_init_ns(struct ipc_namespace *ns) { }
+static inline void shm_init_ns(struct ipc_namespace *ns) { }
 
 static inline void sem_exit_ns(struct ipc_namespace *ns) { }
 static inline void msg_exit_ns(struct ipc_namespace *ns) { }
@@ -83,7 +83,7 @@ struct ipc_ops {
 struct seq_file;
 struct ipc_ids;
 
-int ipc_init_ids(struct ipc_ids *);
+void ipc_init_ids(struct ipc_ids *ids);
 #ifdef CONFIG_PROC_FS
 void __init ipc_init_proc_interface(const char *path, const char *header,
 		int ids, int (*show)(struct seq_file *, void *));

commit 82061c57ce93caa50fd01c11f8eb30ddc4c4bd75
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Tue Aug 21 22:01:41 2018 -0700

    ipc: drop ipc_lock()
    
    ipc/util.c contains multiple functions to get the ipc object pointer given
    an id number.
    
    There are two sets of function: One set verifies the sequence counter part
    of the id number, other functions do not check the sequence counter.
    
    The standard for function names in ipc/util.c is
    - ..._check() functions verify the sequence counter
    - ..._idr() functions do not verify the sequence counter
    
    ipc_lock() is an exception: It does not verify the sequence counter value,
    but this is not obvious from the function name.
    
    Furthermore, shm.c is the only user of this helper.  Thus, we can simply
    move the logic into shm_lock() and get rid of the function altogether.
    
    [manfred@colorfullife.com: most of changelog]
    Link: http://lkml.kernel.org/r/20180712185241.4017-7-manfred@colorfullife.com
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index fcf81425ae98..e3c47b21db93 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -142,7 +142,6 @@ int ipc_rcu_getref(struct kern_ipc_perm *ptr);
 void ipc_rcu_putref(struct kern_ipc_perm *ptr,
 			void (*func)(struct rcu_head *head));
 
-struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);
 struct kern_ipc_perm *ipc_obtain_object_idr(struct ipc_ids *ids, int id);
 
 void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);

commit 4241c1a304078569f544d51eeaf8bc270b6e377a
Author: Manfred Spraul <manfred@colorfullife.com>
Date:   Tue Aug 21 22:01:34 2018 -0700

    ipc: rename ipcctl_pre_down_nolock()
    
    Both the comment and the name of ipcctl_pre_down_nolock() are misleading:
    The function must be called while holdling the rw semaphore.
    
    Therefore the patch renames the function to ipcctl_obtain_check(): This
    name matches the other names used in util.c:
    
    - "obtain" function look up a pointer in the idr, without
      acquiring the object lock.
    - The caller is responsible for locking.
    - _check means that the sequence number is checked.
    
    Link: http://lkml.kernel.org/r/20180712185241.4017-5-manfred@colorfullife.com
    Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
    Reviewed-by: Davidlohr Bueso <dbueso@suse.de>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 0aba3230d007..fcf81425ae98 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -148,7 +148,7 @@ struct kern_ipc_perm *ipc_obtain_object_idr(struct ipc_ids *ids, int id);
 void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);
 void ipc64_perm_to_ipc_perm(struct ipc64_perm *in, struct ipc_perm *out);
 int ipc_update_perm(struct ipc64_perm *in, struct kern_ipc_perm *out);
-struct kern_ipc_perm *ipcctl_pre_down_nolock(struct ipc_namespace *ns,
+struct kern_ipc_perm *ipcctl_obtain_check(struct ipc_namespace *ns,
 					     struct ipc_ids *ids, int id, int cmd,
 					     struct ipc64_perm *perm, int extra_perm);
 

commit b0d175781ab275576429fe379ba8e98e1c60f362
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Apr 13 13:58:23 2018 +0200

    y2038: ipc: Enable COMPAT_32BIT_TIME
    
    Three ipc syscalls (mq_timedsend, mq_timedreceive and and semtimedop)
    take a timespec argument. After we move 32-bit architectures over to
    useing 64-bit time_t based syscalls, we need seperate entry points for
    the old 32-bit based interfaces.
    
    This changes the #ifdef guards for the existing 32-bit compat syscalls
    to check for CONFIG_COMPAT_32BIT_TIME instead, which will then be
    enabled on all existing 32-bit architectures.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/ipc/util.h b/ipc/util.h
index 975c6de2df9d..0aba3230d007 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -265,10 +265,10 @@ long ksys_shmdt(char __user *shmaddr);
 long ksys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);
 
 /* for CONFIG_ARCH_WANT_OLD_COMPAT_IPC */
-#ifdef CONFIG_COMPAT
 long compat_ksys_semtimedop(int semid, struct sembuf __user *tsems,
 			    unsigned int nsops,
 			    const struct compat_timespec __user *timeout);
+#ifdef CONFIG_COMPAT
 long compat_ksys_semctl(int semid, int semnum, int cmd, int arg);
 long compat_ksys_msgctl(int msqid, int cmd, void __user *uptr);
 long compat_ksys_msgrcv(int msqid, compat_uptr_t msgp, compat_ssize_t msgsz,

commit 21fc538d817ce671f1a28a03996c715247c2ac89
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Apr 13 13:58:00 2018 +0200

    y2038: ipc: Use __kernel_timespec
    
    This is a preparatation for changing over __kernel_timespec to 64-bit
    times, which involves assigning new system call numbers for mq_timedsend(),
    mq_timedreceive() and semtimedop() for compatibility with future y2038
    proof user space.
    
    The existing ABIs will remain available through compat code.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/ipc/util.h b/ipc/util.h
index acc5159e96d0..975c6de2df9d 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -251,7 +251,7 @@ static inline int compat_ipc_parse_version(int *cmd)
 /* for __ARCH_WANT_SYS_IPC */
 long ksys_semtimedop(int semid, struct sembuf __user *tsops,
 		     unsigned int nsops,
-		     const struct timespec __user *timeout);
+		     const struct __kernel_timespec __user *timeout);
 long ksys_semget(key_t key, int nsems, int semflg);
 long ksys_semctl(int semid, int semnum, int cmd, unsigned long arg);
 long ksys_msgget(key_t key, int msgflg);

commit 17dec0a949153d9ac00760ba2f5b78cb583e995f
Merge: d92cd810e64a 2236d4d39035
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 3 19:15:32 2018 -0700

    Merge branch 'userns-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull namespace updates from Eric Biederman:
     "There was a lot of work this cycle fixing bugs that were discovered
      after the merge window and getting everything ready where we can
      reasonably support fully unprivileged fuse. The bug fixes you already
      have and much of the unprivileged fuse work is coming in via other
      trees.
    
      Still left for fully unprivileged fuse is figuring out how to cleanly
      handle .set_acl and .get_acl in the legacy case, and properly handling
      of evm xattrs on unprivileged mounts.
    
      Included in the tree is a cleanup from Alexely that replaced a linked
      list with a statically allocated fix sized array for the pid caches,
      which simplifies and speeds things up.
    
      Then there is are some cleanups and fixes for the ipc namespace. The
      motivation was that in reviewing other code it was discovered that
      access ipc objects from different pid namespaces recorded pids in such
      a way that when asked the wrong pids were returned. In the worst case
      there has been a measured 30% performance impact for sysvipc
      semaphores. Other test cases showed no measurable performance impact.
      Manfred Spraul and Davidlohr Bueso who tend to work on sysvipc
      performance both gave the nod that this is good enough.
    
      Casey Schaufler and James Morris have given their approval to the LSM
      side of the changes.
    
      I simplified the types and the code dealing with sysvipc to pass just
      kern_ipc_perm for all three types of ipc. Which reduced the header
      dependencies throughout the kernel and simplified the lsm code.
    
      Which let me work on the pid fixes without having to worry about
      trivial changes causing complete kernel recompiles"
    
    * 'userns-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace:
      ipc/shm: Fix pid freeing.
      ipc/shm: fix up for struct file no longer being available in shm.h
      ipc/smack: Tidy up from the change in type of the ipc security hooks
      ipc: Directly call the security hook in ipc_ops.associate
      ipc/sem: Fix semctl(..., GETPID, ...) between pid namespaces
      ipc/msg: Fix msgctl(..., IPC_STAT, ...) between pid namespaces
      ipc/shm: Fix shmctl(..., IPC_STAT, ...) between pid namespaces.
      ipc/util: Helpers for making the sysvipc operations pid namespace aware
      ipc: Move IPCMNI from include/ipc.h into ipc/util.h
      msg: Move struct msg_queue into ipc/msg.c
      shm: Move struct shmid_kernel into ipc/shm.c
      sem: Move struct sem and struct sem_array into ipc/sem.c
      msg/security: Pass kern_ipc_perm not msg_queue into the msg_queue security hooks
      shm/security: Pass kern_ipc_perm not shmid_kernel into the shm security hooks
      sem/security: Pass kern_ipc_perm not sem_array into the sem security hooks
      pidns: simpler allocation of pid_* caches

commit 31c213f2106b7ea06f7fdc94ef8b785ed5342cf7
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Mar 20 21:29:00 2018 +0100

    ipc: add msgsnd syscall/compat_syscall wrappers
    
    Provide ksys_msgsnd() and compat_ksys_msgsnd() wrappers to avoid in-kernel
    calls to these syscalls. The ksys_ prefix denotes that these functions are
    meant as a drop-in replacement for the syscalls. In particular, they use
    the same calling convention as sys_msgsnd() and compat_sys_msgsnd().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/ipc/util.h b/ipc/util.h
index c16aceb1bdec..51853dc2f340 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -246,6 +246,8 @@ long ksys_msgget(key_t key, int msgflg);
 long ksys_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);
 long ksys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz,
 		 long msgtyp, int msgflg);
+long ksys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz,
+		 int msgflg);
 long ksys_shmget(key_t key, size_t size, int shmflg);
 long ksys_shmdt(char __user *shmaddr);
 long ksys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);
@@ -259,6 +261,8 @@ long compat_ksys_semctl(int semid, int semnum, int cmd, int arg);
 long compat_ksys_msgctl(int msqid, int cmd, void __user *uptr);
 long compat_ksys_msgrcv(int msqid, compat_uptr_t msgp, compat_ssize_t msgsz,
 			compat_long_t msgtyp, int msgflg);
+long compat_ksys_msgsnd(int msqid, compat_uptr_t msgp,
+		       compat_ssize_t msgsz, int msgflg);
 long compat_ksys_shmctl(int shmid, int cmd, void __user *uptr);
 #endif /* CONFIG_COMPAT */
 

commit 078faac9e8b6c8124bc012bbf97cca59caf6d4ea
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Mar 20 21:25:57 2018 +0100

    ipc: add msgrcv syscall/compat_syscall wrappers
    
    Provide ksys_msgrcv() and compat_ksys_msgrcv() wrappers to avoid in-kernel
    calls to these syscalls. The ksys_ prefix denotes that these functions are
    meant as a drop-in replacement for the syscalls. In particular, they use
    the same calling convention as sys_msgrcv() and compat_sys_msgrcv().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/ipc/util.h b/ipc/util.h
index 47837b4af3f2..c16aceb1bdec 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -244,6 +244,8 @@ long ksys_semget(key_t key, int nsems, int semflg);
 long ksys_semctl(int semid, int semnum, int cmd, unsigned long arg);
 long ksys_msgget(key_t key, int msgflg);
 long ksys_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);
+long ksys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz,
+		 long msgtyp, int msgflg);
 long ksys_shmget(key_t key, size_t size, int shmflg);
 long ksys_shmdt(char __user *shmaddr);
 long ksys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);
@@ -255,6 +257,8 @@ long compat_ksys_semtimedop(int semid, struct sembuf __user *tsems,
 			    const struct compat_timespec __user *timeout);
 long compat_ksys_semctl(int semid, int semnum, int cmd, int arg);
 long compat_ksys_msgctl(int msqid, int cmd, void __user *uptr);
+long compat_ksys_msgrcv(int msqid, compat_uptr_t msgp, compat_ssize_t msgsz,
+			compat_long_t msgtyp, int msgflg);
 long compat_ksys_shmctl(int shmid, int cmd, void __user *uptr);
 #endif /* CONFIG_COMPAT */
 

commit e340db56483b6e10bd5e5f281071876808801a41
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Mar 20 20:15:28 2018 +0100

    ipc: add msgctl syscall/compat_syscall wrappers
    
    Provide ksys_msgctl() and compat_ksys_msgctl() wrappers to avoid in-kernel
    calls to these syscalls. The ksys_ prefix denotes that these functions are
    meant as a drop-in replacement for the syscalls. In particular, they use
    the same calling convention as sys_msgctl() and compat_sys_msgctl().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/ipc/util.h b/ipc/util.h
index 16e8b5b8c416..47837b4af3f2 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -243,6 +243,7 @@ long ksys_semtimedop(int semid, struct sembuf __user *tsops,
 long ksys_semget(key_t key, int nsems, int semflg);
 long ksys_semctl(int semid, int semnum, int cmd, unsigned long arg);
 long ksys_msgget(key_t key, int msgflg);
+long ksys_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);
 long ksys_shmget(key_t key, size_t size, int shmflg);
 long ksys_shmdt(char __user *shmaddr);
 long ksys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);
@@ -253,6 +254,7 @@ long compat_ksys_semtimedop(int semid, struct sembuf __user *tsems,
 			    unsigned int nsops,
 			    const struct compat_timespec __user *timeout);
 long compat_ksys_semctl(int semid, int semnum, int cmd, int arg);
+long compat_ksys_msgctl(int msqid, int cmd, void __user *uptr);
 long compat_ksys_shmctl(int shmid, int cmd, void __user *uptr);
 #endif /* CONFIG_COMPAT */
 

commit c84d0791dfa7fe8f051082c09a558eb3e2d01931
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Mar 20 20:12:33 2018 +0100

    ipc: add shmctl syscall/compat_syscall wrappers
    
    Provide ksys_shmctl() and compat_ksys_shmctl() wrappers to avoid in-kernel
    calls to these syscalls. The ksys_ prefix denotes that these functions are
    meant as a drop-in replacement for the syscalls. In particular, they use
    the same calling convention as sys_shmctl() and compat_sys_shmctl().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/ipc/util.h b/ipc/util.h
index 7770bcad1168..16e8b5b8c416 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -245,6 +245,7 @@ long ksys_semctl(int semid, int semnum, int cmd, unsigned long arg);
 long ksys_msgget(key_t key, int msgflg);
 long ksys_shmget(key_t key, size_t size, int shmflg);
 long ksys_shmdt(char __user *shmaddr);
+long ksys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);
 
 /* for CONFIG_ARCH_WANT_OLD_COMPAT_IPC */
 #ifdef CONFIG_COMPAT
@@ -252,6 +253,7 @@ long compat_ksys_semtimedop(int semid, struct sembuf __user *tsems,
 			    unsigned int nsops,
 			    const struct compat_timespec __user *timeout);
 long compat_ksys_semctl(int semid, int semnum, int cmd, int arg);
+long compat_ksys_shmctl(int shmid, int cmd, void __user *uptr);
 #endif /* CONFIG_COMPAT */
 
 #endif

commit da1e2744341542e404c172bcf6a321f509408b14
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Mar 20 20:09:48 2018 +0100

    ipc: add shmdt syscall wrapper
    
    Provide ksys_shmdt() wrapper to avoid in-kernel calls to this syscall.
    The ksys_ prefix denotes that this function is meant as a drop-in
    replacement for the syscall. In particular, it uses the same calling
    convention as sys_shmdt().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/ipc/util.h b/ipc/util.h
index 51002c0b2a21..7770bcad1168 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -244,6 +244,7 @@ long ksys_semget(key_t key, int nsems, int semflg);
 long ksys_semctl(int semid, int semnum, int cmd, unsigned long arg);
 long ksys_msgget(key_t key, int msgflg);
 long ksys_shmget(key_t key, size_t size, int shmflg);
+long ksys_shmdt(char __user *shmaddr);
 
 /* for CONFIG_ARCH_WANT_OLD_COMPAT_IPC */
 #ifdef CONFIG_COMPAT

commit 65749e0bb5e7de876ee43d3f601e32afe17e9248
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Mar 20 20:07:53 2018 +0100

    ipc: add shmget syscall wrapper
    
    Provide ksys_shmget() wrapper to avoid in-kernel calls to this syscall.
    The ksys_ prefix denotes that this function is meant as a drop-in
    replacement for the syscall. In particular, it uses the same calling
    convention as sys_shmget().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/ipc/util.h b/ipc/util.h
index b35c0dfe3bc3..51002c0b2a21 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -243,6 +243,7 @@ long ksys_semtimedop(int semid, struct sembuf __user *tsops,
 long ksys_semget(key_t key, int nsems, int semflg);
 long ksys_semctl(int semid, int semnum, int cmd, unsigned long arg);
 long ksys_msgget(key_t key, int msgflg);
+long ksys_shmget(key_t key, size_t size, int shmflg);
 
 /* for CONFIG_ARCH_WANT_OLD_COMPAT_IPC */
 #ifdef CONFIG_COMPAT

commit 3d65661a494a11266500c2532b4f163537c379db
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Mar 20 20:06:04 2018 +0100

    ipc: add msgget syscall wrapper
    
    Provide ksys_msgget() wrapper to avoid in-kernel calls to this syscall.
    The ksys_ prefix denotes that this function is meant as a drop-in
    replacement for the syscall. In particular, it uses the same calling
    convention as sys_msgget().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/ipc/util.h b/ipc/util.h
index 1f1109b83437..b35c0dfe3bc3 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -242,6 +242,7 @@ long ksys_semtimedop(int semid, struct sembuf __user *tsops,
 		     const struct timespec __user *timeout);
 long ksys_semget(key_t key, int nsems, int semflg);
 long ksys_semctl(int semid, int semnum, int cmd, unsigned long arg);
+long ksys_msgget(key_t key, int msgflg);
 
 /* for CONFIG_ARCH_WANT_OLD_COMPAT_IPC */
 #ifdef CONFIG_COMPAT

commit d969c6fa7263c8fc1928f528bb68587872350b6c
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Mar 20 20:00:39 2018 +0100

    ipc: add semctl syscall/compat_syscall wrappers
    
    Provide ksys_semctl() and compat_ksys_semctl() wrappers to avoid in-kernel
    calls to these syscalls. The ksys_ prefix denotes that these functions are
    meant as a drop-in replacement for the syscalls. In particular, they use
    the same calling convention as sys_semctl() and compat_sys_semctl().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/ipc/util.h b/ipc/util.h
index 0f07056e5a73..1f1109b83437 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -241,12 +241,14 @@ long ksys_semtimedop(int semid, struct sembuf __user *tsops,
 		     unsigned int nsops,
 		     const struct timespec __user *timeout);
 long ksys_semget(key_t key, int nsems, int semflg);
+long ksys_semctl(int semid, int semnum, int cmd, unsigned long arg);
 
 /* for CONFIG_ARCH_WANT_OLD_COMPAT_IPC */
 #ifdef CONFIG_COMPAT
 long compat_ksys_semtimedop(int semid, struct sembuf __user *tsems,
 			    unsigned int nsops,
 			    const struct compat_timespec __user *timeout);
+long compat_ksys_semctl(int semid, int semnum, int cmd, int arg);
 #endif /* CONFIG_COMPAT */
 
 #endif

commit 69894718a515fef7ff633cf354fcd7ed73a88891
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Mar 20 19:53:58 2018 +0100

    ipc: add semget syscall wrapper
    
    Provide ksys_semget() wrapper to avoid in-kernel calls to this syscall.
    The ksys_ prefix denotes that this function is meant as a drop-in
    replacement for the syscall. In particular, it uses the same calling
    convention as sys_semget().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/ipc/util.h b/ipc/util.h
index 6deadf77547e..0f07056e5a73 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -240,6 +240,7 @@ static inline int compat_ipc_parse_version(int *cmd)
 long ksys_semtimedop(int semid, struct sembuf __user *tsops,
 		     unsigned int nsops,
 		     const struct timespec __user *timeout);
+long ksys_semget(key_t key, int nsems, int semflg);
 
 /* for CONFIG_ARCH_WANT_OLD_COMPAT_IPC */
 #ifdef CONFIG_COMPAT

commit 41f4f0e2f5f4cd060885405c04214851ffe7b299
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Mar 20 19:48:14 2018 +0100

    ipc: add semtimedop syscall/compat_syscall wrappers
    
    Provide ksys_semtimedop() and compat_ksys_semtimedop() wrappers to avoid
    in-kernel calls to these syscalls. The ksys_ prefix denotes that these
    functions are meant as a drop-in replacement for the syscalls. In
    particular, they use the same calling convention as sys_semtimedop() and
    compat_sys_semtimedop().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/ipc/util.h b/ipc/util.h
index 89b8ec176fc4..6deadf77547e 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -235,4 +235,17 @@ static inline int compat_ipc_parse_version(int *cmd)
 #endif
 }
 #endif
+
+/* for __ARCH_WANT_SYS_IPC */
+long ksys_semtimedop(int semid, struct sembuf __user *tsops,
+		     unsigned int nsops,
+		     const struct timespec __user *timeout);
+
+/* for CONFIG_ARCH_WANT_OLD_COMPAT_IPC */
+#ifdef CONFIG_COMPAT
+long compat_ksys_semtimedop(int semid, struct sembuf __user *tsems,
+			    unsigned int nsops,
+			    const struct compat_timespec __user *timeout);
+#endif /* CONFIG_COMPAT */
+
 #endif

commit 03f1fc09180b345582889a344b012d069b3a6dbe
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Mar 23 00:22:05 2018 -0500

    ipc/util: Helpers for making the sysvipc operations pid namespace aware
    
    Capture the pid namespace when /proc/sysvipc/msg /proc/sysvipc/shm
    and /proc/sysvipc/sem are opened, and make it available through
    the new helper ipc_seq_pid_ns.
    
    This makes it possible to report the pids in these files in the
    pid namespace of the opener of the files.
    
    Implement ipc_update_pid.  A simple impline helper that will only update
    a struct pid pointer if the new value does not equal the old value.  This
    removes the need for wordy code sequences like:
    
            old = object->pid;
            object->pid = new;
            put_pid(old);
    
    and
    
            old = object->pid;
            if (old != new) {
                    object->pid = new;
                    put_pid(old);
            }
    
    Allowing the following to be written instead:
    
            ipc_update_pid(&object->pid, new);
    
    Which is easier to read and ensures that the pid reference count is
    not touched the old and the new values are the same.  Not touching
    the reference count in this case is important to help avoid issues
    like af_unix experienced, where multiple threads of the same
    process managed to bounce the struct pid between cpu cache lines,
    but updating the pids reference count.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/ipc/util.h b/ipc/util.h
index 959c10eb9cc1..e39ed9705f99 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -23,6 +23,7 @@ int msg_init(void);
 void shm_init(void);
 
 struct ipc_namespace;
+struct pid_namespace;
 
 #ifdef CONFIG_POSIX_MQUEUE
 extern void mq_clear_sbinfo(struct ipc_namespace *ns);
@@ -86,6 +87,7 @@ int ipc_init_ids(struct ipc_ids *);
 #ifdef CONFIG_PROC_FS
 void __init ipc_init_proc_interface(const char *path, const char *header,
 		int ids, int (*show)(struct seq_file *, void *));
+struct pid_namespace *ipc_seq_pid_ns(struct seq_file *);
 #else
 #define ipc_init_proc_interface(path, header, ids, show) do {} while (0)
 #endif
@@ -150,6 +152,15 @@ struct kern_ipc_perm *ipcctl_pre_down_nolock(struct ipc_namespace *ns,
 					     struct ipc_ids *ids, int id, int cmd,
 					     struct ipc64_perm *perm, int extra_perm);
 
+static inline void ipc_update_pid(struct pid **pos, struct pid *pid)
+{
+	struct pid *old = *pos;
+	if (old != pid) {
+		*pos = get_pid(pid);
+		put_pid(old);
+	}
+}
+
 #ifndef CONFIG_ARCH_WANT_IPC_PARSE_VERSION
 /* On IA-64, we always use the "64-bit version" of the IPC structures.  */
 # define ipc_parse_version(cmd)	IPC_64

commit f83a396d06d499029fe6d32e326605a2b5ca4eff
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Mar 22 21:45:50 2018 -0500

    ipc: Move IPCMNI from include/ipc.h into ipc/util.h
    
    The definition IPCMNI is only used in ipc/util.h and ipc/util.c.  So
    there is no reason to keep it in a header file that the whole kernel
    can see.  Move it into util.h to simplify future maintenance.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/ipc/util.h b/ipc/util.h
index 89b8ec176fc4..959c10eb9cc1 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -15,6 +15,7 @@
 #include <linux/err.h>
 #include <linux/ipc_namespace.h>
 
+#define IPCMNI 32768  /* <= MAX_INT limit for ipc arrays (including sysctl changes) */
 #define SEQ_MULTIPLIER	(IPCMNI)
 
 int sem_init(void);

commit 15df03c87983660a4d1eedb4541778592bd97684
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Fri Nov 17 15:31:18 2017 -0800

    sysvipc: make get_maxid O(1) again
    
    For a custom microbenchmark on a 3.30GHz Xeon SandyBridge, which calls
    IPC_STAT over and over, it was calculated that, on avg the cost of
    ipc_get_maxid() for increasing amounts of keys was:
    
     10 keys: ~900 cycles
     100 keys: ~15000 cycles
     1000 keys: ~150000 cycles
     10000 keys: ~2100000 cycles
    
    This is unsurprising as maxid is currently O(n).
    
    By having the max_id available in O(1) we save all those cycles for each
    semctl(_STAT) command, the idr_find can be expensive -- which some real
    (customer) workloads actually poll on.
    
    Note that this used to be the case, until commit 7ca7e564e04 ("ipc:
    store ipcs into IDRs").  The cost is the extra idr_find when doing
    RMIDs, but we simply go backwards, and should not take too many
    iterations to find the new value.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Link: http://lkml.kernel.org/r/20170831172049.14576-5-dave@stgolabs.net
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 0cd6201fe63a..89b8ec176fc4 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -13,6 +13,7 @@
 
 #include <linux/unistd.h>
 #include <linux/err.h>
+#include <linux/ipc_namespace.h>
 
 #define SEQ_MULTIPLIER	(IPCMNI)
 
@@ -99,9 +100,6 @@ void __init ipc_init_proc_interface(const char *path, const char *header,
 /* must be called with ids->rwsem acquired for writing */
 int ipc_addid(struct ipc_ids *, struct kern_ipc_perm *, int);
 
-/* must be called with ids->rwsem acquired for reading */
-int ipc_get_maxid(struct ipc_ids *);
-
 /* must be called with both locks acquired. */
 void ipc_rmid(struct ipc_ids *, struct kern_ipc_perm *);
 
@@ -111,6 +109,23 @@ void ipc_set_key_private(struct ipc_ids *, struct kern_ipc_perm *);
 /* must be called with ipcp locked */
 int ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flg);
 
+/**
+ * ipc_get_maxid - get the last assigned id
+ * @ids: ipc identifier set
+ *
+ * Called with ipc_ids.rwsem held for reading.
+ */
+static inline int ipc_get_maxid(struct ipc_ids *ids)
+{
+	if (ids->in_use == 0)
+		return -1;
+
+	if (ids->in_use == IPCMNI)
+		return IPCMNI - 1;
+
+	return ids->max_id;
+}
+
 /*
  * For allocation that need to be freed by RCU.
  * Objects are reference counted, they start with reference count 1.

commit b8fd99838435f9b420c3e848192bd43abc648b7f
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Fri Nov 17 15:31:08 2017 -0800

    sysvipc: unteach ids->next_id for !CHECKPOINT_RESTORE
    
    Patch series "sysvipc: ipc-key management improvements".
    
    Here are a few improvements I spotted while eyeballing Guillaume's
    rhashtable implementation for ipc keys.  The first and fourth patches
    are the interesting ones, the middle two are trivial.
    
    This patch (of 4):
    
    The next_id object-allocation functionality was introduced in commit
    03f595668017 ("ipc: add sysctl to specify desired next object id").
    
    Given that these new entries are _only_ exported under the
    CONFIG_CHECKPOINT_RESTORE option, there is no point for the common case
    to even know about ->next_id.  As such rewrite ipc_buildid() such that
    it can do away with the field as well as unnecessary branches when
    adding a new identifier.  The end result also better differentiates both
    cases, so the code ends up being cleaner; albeit the small duplications
    regarding the default case.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Link: http://lkml.kernel.org/r/20170831172049.14576-2-dave@stgolabs.net
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 579112d90016..0cd6201fe63a 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -146,11 +146,6 @@ extern struct msg_msg *load_msg(const void __user *src, size_t len);
 extern struct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst);
 extern int store_msg(void __user *dest, struct msg_msg *msg, size_t len);
 
-static inline int ipc_buildid(int id, int seq)
-{
-	return SEQ_MULTIPLIER * seq + id;
-}
-
 static inline int ipc_checkid(struct kern_ipc_perm *ipcp, int uid)
 {
 	return uid / SEQ_MULTIPLIER != ipcp->seq;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index b21297bc11eb..579112d90016 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * linux/ipc/util.h
  * Copyright (C) 1999 Christoph Rohland

commit cc73fee0bae2d66594d1fa2df92bbd783aa98e04
Merge: e7cdb60fd28b aaed2dd8a313
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 14 17:37:26 2017 -0700

    Merge branch 'work.ipc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull ipc compat cleanup and 64-bit time_t from Al Viro:
     "IPC copyin/copyout sanitizing, including 64bit time_t work from Deepa
      Dinamani"
    
    * 'work.ipc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      utimes: Make utimes y2038 safe
      ipc: shm: Make shmid_kernel timestamps y2038 safe
      ipc: sem: Make sem_array timestamps y2038 safe
      ipc: msg: Make msg_queue timestamps y2038 safe
      ipc: mqueue: Replace timespec with timespec64
      ipc: Make sys_semtimedop() y2038 safe
      get rid of SYSVIPC_COMPAT on ia64
      semtimedop(): move compat to native
      shmat(2): move compat to native
      msgrcv(2), msgsnd(2): move compat to native
      ipc(2): move compat to native
      ipc: make use of compat ipc_perm helpers
      semctl(): move compat to native
      semctl(): separate all layout-dependent copyin/copyout
      msgctl(): move compat to native
      msgctl(): split the actual work from copyin/copyout
      ipc: move compat shmctl to native
      shmctl: split the work from copyin/copyout

commit 0cfb6aee70bddbef6ec796b255f588ce0e126766
Author: Guillaume Knispel <guillaume.knispel@supersonicimagine.com>
Date:   Fri Sep 8 16:17:55 2017 -0700

    ipc: optimize semget/shmget/msgget for lots of keys
    
    ipc_findkey() used to scan all objects to look for the wanted key.  This
    is slow when using a high number of keys.  This change adds an rhashtable
    of kern_ipc_perm objects in ipc_ids, so that one lookup cease to be O(n).
    
    This change gives a 865% improvement of benchmark reaim.jobs_per_min on a
    56 threads Intel(R) Xeon(R) CPU E5-2695 v3 @ 2.30GHz with 256G memory [1]
    
    Other (more micro) benchmark results, by the author: On an i5 laptop, the
    following loop executed right after a reboot took, without and with this
    change:
    
        for (int i = 0, k=0x424242; i < KEYS; ++i)
            semget(k++, 1, IPC_CREAT | 0600);
    
                     total       total          max single  max single
       KEYS        without        with        call without   call with
    
          1            3.5         4.9   Âµs            3.5         4.9
         10            7.6         8.6   Âµs            3.7         4.7
         32           16.2        15.9   Âµs            4.3         5.3
        100           72.9        41.8   Âµs            3.7         4.7
       1000        5,630.0       502.0   Âµs             *           *
      10000    1,340,000.0     7,240.0   Âµs             *           *
      31900   17,600,000.0    22,200.0   Âµs             *           *
    
     *: unreliable measure: high variance
    
    The duration for a lookup-only usage was obtained by the same loop once
    the keys are present:
    
                     total       total          max single  max single
       KEYS        without        with        call without   call with
    
          1            2.1         2.5   Âµs            2.1         2.5
         10            4.5         4.8   Âµs            2.2         2.3
         32           13.0        10.8   Âµs            2.3         2.8
        100           82.9        25.1   Âµs             *          2.3
       1000        5,780.0       217.0   Âµs             *           *
      10000    1,470,000.0     2,520.0   Âµs             *           *
      31900   17,400,000.0     7,810.0   Âµs             *           *
    
    Finally, executing each semget() in a new process gave, when still
    summing only the durations of these syscalls:
    
    creation:
                     total       total
       KEYS        without        with
    
          1            3.7         5.0   Âµs
         10           32.9        36.7   Âµs
         32          125.0       109.0   Âµs
        100          523.0       353.0   Âµs
       1000       20,300.0     3,280.0   Âµs
      10000    2,470,000.0    46,700.0   Âµs
      31900   27,800,000.0   219,000.0   Âµs
    
    lookup-only:
                     total       total
       KEYS        without        with
    
          1            2.5         2.7   Âµs
         10           25.4        24.4   Âµs
         32          106.0        72.6   Âµs
        100          591.0       352.0   Âµs
       1000       22,400.0     2,250.0   Âµs
      10000    2,510,000.0    25,700.0   Âµs
      31900   28,200,000.0   115,000.0   Âµs
    
    [1] http://lkml.kernel.org/r/20170814060507.GE23258@yexl-desktop
    
    Link: http://lkml.kernel.org/r/20170815194954.ck32ta2z35yuzpwp@debix
    Signed-off-by: Guillaume Knispel <guillaume.knispel@supersonicimagine.com>
    Reviewed-by: Marc Pardo <marc.pardo@supersonicimagine.com>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: "Peter Zijlstra (Intel)" <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Serge Hallyn <serge@hallyn.com>
    Cc: Andrey Vagin <avagin@openvz.org>
    Cc: Guillaume Knispel <guillaume.knispel@supersonicimagine.com>
    Cc: Marc Pardo <marc.pardo@supersonicimagine.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index c692010e6f0a..80c9f51c3f07 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -15,8 +15,8 @@
 
 #define SEQ_MULTIPLIER	(IPCMNI)
 
-void sem_init(void);
-void msg_init(void);
+int sem_init(void);
+int msg_init(void);
 void shm_init(void);
 
 struct ipc_namespace;
@@ -30,17 +30,17 @@ static inline void mq_put_mnt(struct ipc_namespace *ns) { }
 #endif
 
 #ifdef CONFIG_SYSVIPC
-void sem_init_ns(struct ipc_namespace *ns);
-void msg_init_ns(struct ipc_namespace *ns);
-void shm_init_ns(struct ipc_namespace *ns);
+int sem_init_ns(struct ipc_namespace *ns);
+int msg_init_ns(struct ipc_namespace *ns);
+int shm_init_ns(struct ipc_namespace *ns);
 
 void sem_exit_ns(struct ipc_namespace *ns);
 void msg_exit_ns(struct ipc_namespace *ns);
 void shm_exit_ns(struct ipc_namespace *ns);
 #else
-static inline void sem_init_ns(struct ipc_namespace *ns) { }
-static inline void msg_init_ns(struct ipc_namespace *ns) { }
-static inline void shm_init_ns(struct ipc_namespace *ns) { }
+static inline int sem_init_ns(struct ipc_namespace *ns) { return 0; }
+static inline int msg_init_ns(struct ipc_namespace *ns) { return 0; }
+static inline int shm_init_ns(struct ipc_namespace *ns) { return 0; }
 
 static inline void sem_exit_ns(struct ipc_namespace *ns) { }
 static inline void msg_exit_ns(struct ipc_namespace *ns) { }
@@ -79,7 +79,7 @@ struct ipc_ops {
 struct seq_file;
 struct ipc_ids;
 
-void ipc_init_ids(struct ipc_ids *);
+int ipc_init_ids(struct ipc_ids *);
 #ifdef CONFIG_PROC_FS
 void __init ipc_init_proc_interface(const char *path, const char *header,
 		int ids, int (*show)(struct seq_file *, void *));
@@ -104,6 +104,9 @@ int ipc_get_maxid(struct ipc_ids *);
 /* must be called with both locks acquired. */
 void ipc_rmid(struct ipc_ids *, struct kern_ipc_perm *);
 
+/* must be called with both locks acquired. */
+void ipc_set_key_private(struct ipc_ids *, struct kern_ipc_perm *);
+
 /* must be called with ipcp locked */
 int ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flg);
 

commit c0ebccb6fa1e2c9c3377fa8136e6d8bc006fca64
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 9 10:03:23 2017 -0400

    semctl(): move compat to native
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/ipc/util.h b/ipc/util.h
index 3a3dfe137bee..c7b7a5ff1f0b 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -204,6 +204,12 @@ struct compat_ipc_perm {
 	unsigned short seq;
 };
 
+void to_compat_ipc_perm(struct compat_ipc_perm *, struct ipc64_perm *);
+void to_compat_ipc64_perm(struct compat_ipc64_perm *, struct ipc64_perm *);
+int get_compat_ipc_perm(struct ipc64_perm *, struct compat_ipc_perm __user *);
+int get_compat_ipc64_perm(struct ipc64_perm *,
+			  struct compat_ipc64_perm __user *);
+
 static inline int compat_ipc_parse_version(int *cmd)
 {
 #ifdef	CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION

commit 553f770ef71b27ee053bd241bef0998a15f43467
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 8 22:52:47 2017 -0400

    ipc: move compat shmctl to native
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/ipc/util.h b/ipc/util.h
index c692010e6f0a..3a3dfe137bee 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -191,4 +191,28 @@ int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
 			const struct ipc_ops *ops, struct ipc_params *params);
 void free_ipcs(struct ipc_namespace *ns, struct ipc_ids *ids,
 		void (*free)(struct ipc_namespace *, struct kern_ipc_perm *));
+
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+struct compat_ipc_perm {
+	key_t key;
+	__compat_uid_t uid;
+	__compat_gid_t gid;
+	__compat_uid_t cuid;
+	__compat_gid_t cgid;
+	compat_mode_t mode;
+	unsigned short seq;
+};
+
+static inline int compat_ipc_parse_version(int *cmd)
+{
+#ifdef	CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION
+	int version = *cmd & IPC_64;
+	*cmd &= ~IPC_64;
+	return version;
+#else
+	return IPC_64;
+#endif
+}
+#endif
 #endif

commit 62b49c9908bcee88347efe8b4ed1b4f53c60ee66
Author: Manfred Spraul <manfred@colorfullife.com>
Date:   Wed Jul 12 14:35:34 2017 -0700

    ipc/util.h: update documentation for ipc_getref() and ipc_putref()
    
    Now that ipc_rcu_alloc() and ipc_rcu_free() are removed, document when
    it is valid to use ipc_getref() and ipc_putref().
    
    Link: http://lkml.kernel.org/r/20170525185107.12869-21-manfred@colorfullife.com
    Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Kees Cook <keescook@chromium.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 77336c2bdb9c..c692010e6f0a 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -112,6 +112,9 @@ int ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flg);
  * Objects are reference counted, they start with reference count 1.
  * getref increases the refcount, the putref call that reduces the recount
  * to 0 schedules the rcu destruction. Caller must guarantee locking.
+ *
+ * refcount is initialized by ipc_addid(), before that point call_rcu()
+ * must be used.
  */
 int ipc_rcu_getref(struct kern_ipc_perm *ptr);
 void ipc_rcu_putref(struct kern_ipc_perm *ptr,

commit c3f6fb6fe4e638a58eae558cb209c463cd46c2fc
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jul 12 14:35:10 2017 -0700

    ipc/util: drop ipc_rcu_alloc()
    
    No callers remain for ipc_rcu_alloc().  Drop the function.
    
    [manfred@colorfullife.com: Rediff because the memset was temporarily inside ipc_rcu_free()]
    Link: http://lkml.kernel.org/r/20170525185107.12869-13-manfred@colorfullife.com
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
    Cc: Kees Cook <keescook@chromium.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 44efbc0b635b..77336c2bdb9c 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -112,10 +112,7 @@ int ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flg);
  * Objects are reference counted, they start with reference count 1.
  * getref increases the refcount, the putref call that reduces the recount
  * to 0 schedules the rcu destruction. Caller must guarantee locking.
- *
- * struct kern_ipc_perm must be the first member in the allocated structure.
  */
-struct kern_ipc_perm *ipc_rcu_alloc(int size);
 int ipc_rcu_getref(struct kern_ipc_perm *ptr);
 void ipc_rcu_putref(struct kern_ipc_perm *ptr,
 			void (*func)(struct rcu_head *head));

commit 5ccc8fb54f1c083f1dc7e073150ec18d43457872
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jul 12 14:34:59 2017 -0700

    ipc/util: drop ipc_rcu_free()
    
    There are no more callers of ipc_rcu_free(), so remove it.
    
    Link: http://lkml.kernel.org/r/20170525185107.12869-9-manfred@colorfullife.com
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 2578fd9be835..44efbc0b635b 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -119,7 +119,6 @@ struct kern_ipc_perm *ipc_rcu_alloc(int size);
 int ipc_rcu_getref(struct kern_ipc_perm *ptr);
 void ipc_rcu_putref(struct kern_ipc_perm *ptr,
 			void (*func)(struct rcu_head *head));
-void ipc_rcu_free(struct rcu_head *h);
 
 struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);
 struct kern_ipc_perm *ipc_obtain_object_idr(struct ipc_ids *ids, int id);

commit f8dbe8d290637ac3f68600e30d092393fe9b40a5
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jul 12 14:34:47 2017 -0700

    ipc: drop non-RCU allocation
    
    The only users of ipc_alloc() were ipc_rcu_alloc() and the on-heap
    sem_io fall-back memory.  Better to just open-code these to make things
    easier to read.
    
    [manfred@colorfullife.com: Rediff due to inclusion of memset() into ipc_rcu_alloc()]
    Link: http://lkml.kernel.org/r/20170525185107.12869-5-manfred@colorfullife.com
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 09d0f918c3e2..2578fd9be835 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -107,12 +107,6 @@ void ipc_rmid(struct ipc_ids *, struct kern_ipc_perm *);
 /* must be called with ipcp locked */
 int ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flg);
 
-/* for rare, potentially huge allocations.
- * both function can sleep
- */
-void *ipc_alloc(int size);
-void ipc_free(void *ptr);
-
 /*
  * For allocation that need to be freed by RCU.
  * Objects are reference counted, they start with reference count 1.

commit dba4cdd39e698d8dcdad0656825423052ac90ccd
Author: Manfred Spraul <manfred@colorfullife.com>
Date:   Wed Jul 12 14:34:41 2017 -0700

    ipc: merge ipc_rcu and kern_ipc_perm
    
    ipc has two management structures that exist for every id:
     - struct kern_ipc_perm, it contains e.g. the permissions.
     - struct ipc_rcu, it contains the rcu head for rcu handling and the
       refcount.
    
    The patch merges both structures.
    
    As a bonus, we may save one cacheline, because both structures are
    cacheline aligned.  In addition, it reduces the number of casts, instead
    most codepaths can use container_of.
    
    To simplify code, the ipc_rcu_alloc initializes the allocation to 0.
    
    [manfred@colorfullife.com: really include the memset() into ipc_alloc_rcu()]
      Link: http://lkml.kernel.org/r/564f8612-0601-b267-514f-a9f650ec9b32@colorfullife.com
    Link: http://lkml.kernel.org/r/20170525185107.12869-3-manfred@colorfullife.com
    Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Kees Cook <keescook@chromium.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 60ddccca464d..09d0f918c3e2 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -47,13 +47,6 @@ static inline void msg_exit_ns(struct ipc_namespace *ns) { }
 static inline void shm_exit_ns(struct ipc_namespace *ns) { }
 #endif
 
-struct ipc_rcu {
-	struct rcu_head rcu;
-	atomic_t refcount;
-} ____cacheline_aligned_in_smp;
-
-#define ipc_rcu_to_struct(p)  ((void *)(p+1))
-
 /*
  * Structure that holds the parameters needed by the ipc operations
  * (see after)
@@ -125,11 +118,14 @@ void ipc_free(void *ptr);
  * Objects are reference counted, they start with reference count 1.
  * getref increases the refcount, the putref call that reduces the recount
  * to 0 schedules the rcu destruction. Caller must guarantee locking.
+ *
+ * struct kern_ipc_perm must be the first member in the allocated structure.
  */
-void *ipc_rcu_alloc(int size);
-int ipc_rcu_getref(void *ptr);
-void ipc_rcu_putref(void *ptr, void (*func)(struct rcu_head *head));
-void ipc_rcu_free(struct rcu_head *head);
+struct kern_ipc_perm *ipc_rcu_alloc(int size);
+int ipc_rcu_getref(struct kern_ipc_perm *ptr);
+void ipc_rcu_putref(struct kern_ipc_perm *ptr,
+			void (*func)(struct rcu_head *head));
+void ipc_rcu_free(struct rcu_head *h);
 
 struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);
 struct kern_ipc_perm *ipc_obtain_object_idr(struct ipc_ids *ids, int id);

commit 2bcb9883664590867c87c19667e8738a0f675bf2
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Aug 8 09:34:24 2016 -0500

    ipc: Remove unused declaration of recompute_msgmni
    
    The function recompute_msgmni was removed a while ago
    but it is still declared in a header file remove it.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/ipc/util.h b/ipc/util.h
index 51f7ca58ac67..60ddccca464d 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -153,8 +153,6 @@ extern struct msg_msg *load_msg(const void __user *src, size_t len);
 extern struct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst);
 extern int store_msg(void __user *dest, struct msg_msg *msg, size_t len);
 
-extern void recompute_msgmni(struct ipc_namespace *);
-
 static inline int ipc_buildid(int id, int seq)
 {
 	return SEQ_MULTIPLIER * seq + id;

commit 1d5cfdb076288df5eb95545a547a39905e95c930
Author: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
Date:   Fri Jan 22 15:11:02 2016 -0800

    tree wide: use kvfree() than conditional kfree()/vfree()
    
    There are many locations that do
    
      if (memory_was_allocated_by_vmalloc)
        vfree(ptr);
      else
        kfree(ptr);
    
    but kvfree() can handle both kmalloc()ed memory and vmalloc()ed memory
    using is_vmalloc_addr().  Unless callers have special reasons, we can
    replace this branch with kvfree().  Please check and reply if you found
    problems.
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Jan Kara <jack@suse.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Reviewed-by: Andreas Dilger <andreas.dilger@intel.com>
    Acked-by: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Acked-by: David Rientjes <rientjes@google.com>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Oleg Drokin <oleg.drokin@intel.com>
    Cc: Boris Petkov <bp@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 3a8a5a0eca62..51f7ca58ac67 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -118,7 +118,7 @@ int ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flg);
  * both function can sleep
  */
 void *ipc_alloc(int size);
-void ipc_free(void *ptr, int size);
+void ipc_free(void *ptr);
 
 /*
  * For allocation that need to be freed by RCU.

commit 55b7ae50167efc9b1c4f8fb60a99478cd46a82f7
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Tue Jun 30 14:58:42 2015 -0700

    ipc: rename ipc_obtain_object
    
    ...  to ipc_obtain_object_idr, which is more meaningful and makes the code
    slightly easier to follow.
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 1a5a0fcd099c..3a8a5a0eca62 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -132,7 +132,7 @@ void ipc_rcu_putref(void *ptr, void (*func)(struct rcu_head *head));
 void ipc_rcu_free(struct rcu_head *head);
 
 struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);
-struct kern_ipc_perm *ipc_obtain_object(struct ipc_ids *ids, int id);
+struct kern_ipc_perm *ipc_obtain_object_idr(struct ipc_ids *ids, int id);
 
 void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);
 void ipc64_perm_to_ipc_perm(struct ipc64_perm *in, struct ipc_perm *out);

commit 46c0a8ca3e841b14a1d981e2116eaf2d1c7f2235
Author: Paul McQuade <paulmcquad@gmail.com>
Date:   Fri Jun 6 14:37:37 2014 -0700

    ipc, kernel: clear whitespace
    
    trailing whitespace
    
    Signed-off-by: Paul McQuade <paulmcquad@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index e1153ad574b7..1a5a0fcd099c 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -78,9 +78,9 @@ struct ipc_params {
  *      . routine to call for an extra check if needed
  */
 struct ipc_ops {
-	int (*getnew) (struct ipc_namespace *, struct ipc_params *);
-	int (*associate) (struct kern_ipc_perm *, int);
-	int (*more_checks) (struct kern_ipc_perm *, struct ipc_params *);
+	int (*getnew)(struct ipc_namespace *, struct ipc_params *);
+	int (*associate)(struct kern_ipc_perm *, int);
+	int (*more_checks)(struct kern_ipc_perm *, struct ipc_params *);
 };
 
 struct seq_file;
@@ -142,7 +142,7 @@ struct kern_ipc_perm *ipcctl_pre_down_nolock(struct ipc_namespace *ns,
 					     struct ipc64_perm *perm, int extra_perm);
 
 #ifndef CONFIG_ARCH_WANT_IPC_PARSE_VERSION
-  /* On IA-64, we always use the "64-bit version" of the IPC structures.  */ 
+/* On IA-64, we always use the "64-bit version" of the IPC structures.  */
 # define ipc_parse_version(cmd)	IPC_64
 #else
 int ipc_parse_version(int *cmd);

commit eb66ec44f867834de054544b09b573de3a7ae456
Author: Mathias Krause <minipli@googlemail.com>
Date:   Fri Jun 6 14:37:36 2014 -0700

    ipc: constify ipc_ops
    
    There is no need to recreate the very same ipc_ops structure on every
    kernel entry for msgget/semget/shmget.  Just declare it static and be
    done with it.  While at it, constify it as we don't modify the structure
    at runtime.
    
    Found in the PaX patch, written by the PaX Team.
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Cc: PaX Team <pageexec@freemail.hu>
    Cc: Davidlohr Bueso <davidlohr@hp.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 9c47d6f6c7b4..e1153ad574b7 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -201,7 +201,7 @@ static inline bool ipc_valid_object(struct kern_ipc_perm *perm)
 
 struct kern_ipc_perm *ipc_obtain_object_check(struct ipc_ids *ids, int id);
 int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
-			struct ipc_ops *ops, struct ipc_params *params);
+			const struct ipc_ops *ops, struct ipc_params *params);
 void free_ipcs(struct ipc_namespace *ns, struct ipc_ids *ids,
 		void (*free)(struct ipc_namespace *, struct kern_ipc_perm *));
 #endif

commit daf948c7d1a080041ae19aca07625efec670695a
Author: Davidlohr Bueso <davidlohr@hp.com>
Date:   Mon Jan 27 17:07:09 2014 -0800

    ipc: delete seq_max field in struct ipc_ids
    
    This field is only used to reset the ids seq number if it exceeds the
    smaller of INT_MAX/SEQ_MULTIPLIER and USHRT_MAX, and can therefore be
    moved out of the structure and into its own macro.  Since each
    ipc_namespace contains a table of 3 pointers to struct ipc_ids we can
    save space in instruction text:
    
       text    data     bss     dec     hex filename
      56232    2348      24   58604    e4ec ipc/built-in.o
      56216    2348      24   58588    e4dc ipc/built-in.o-after
    
    Signed-off-by: Davidlohr Bueso <davidlohr@hp.com>
    Reviewed-by: Jonathan Gonzalez <jgonzalez@linets.cl>
    Cc: Aswin Chandramouleeswaran <aswin@hp.com>
    Cc: Rik van Riel <riel@redhat.com>
    Acked-by: Manfred Spraul <manfred@colorfullife.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index d64db3e56f7d..9c47d6f6c7b4 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -100,6 +100,7 @@ void __init ipc_init_proc_interface(const char *path, const char *header,
 
 #define ipcid_to_idx(id) ((id) % SEQ_MULTIPLIER)
 #define ipcid_to_seqx(id) ((id) / SEQ_MULTIPLIER)
+#define IPCID_SEQ_MAX min_t(int, INT_MAX/SEQ_MULTIPLIER, USHRT_MAX)
 
 /* must be called with ids->rwsem acquired for writing */
 int ipc_addid(struct ipc_ids *, struct kern_ipc_perm *, int);

commit 239521f31d7496a5322ee664ed8bbd1027b98c4b
Author: Manfred Spraul <manfred@colorfullife.com>
Date:   Mon Jan 27 17:07:04 2014 -0800

    ipc: whitespace cleanup
    
    The ipc code does not adhere the typical linux coding style.
    This patch fixes lots of simple whitespace errors.
    
    - mostly autogenerated by
      scripts/checkpatch.pl -f --fix \
            --types=pointer_location,spacing,space_before_tab
    - one manual fixup (keep structure members tab-aligned)
    - removal of additional space_before_tab that were not found by --fix
    
    Tested with some of my msg and sem test apps.
    
    Andrew: Could you include it in -mm and move it towards Linus' tree?
    
    Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
    Suggested-by: Li Bin <huawei.libin@huawei.com>
    Cc: Joe Perches <joe@perches.com>
    Acked-by: Rafael Aquini <aquini@redhat.com>
    Cc: Davidlohr Bueso <davidlohr@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index a1cbc3aaf25a..d64db3e56f7d 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -15,9 +15,9 @@
 
 #define SEQ_MULTIPLIER	(IPCMNI)
 
-void sem_init (void);
-void msg_init (void);
-void shm_init (void);
+void sem_init(void);
+void msg_init(void);
+void shm_init(void);
 
 struct ipc_namespace;
 
@@ -116,8 +116,8 @@ int ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flg);
 /* for rare, potentially huge allocations.
  * both function can sleep
  */
-void* ipc_alloc(int size);
-void ipc_free(void* ptr, int size);
+void *ipc_alloc(int size);
+void ipc_free(void *ptr, int size);
 
 /*
  * For allocation that need to be freed by RCU.
@@ -125,7 +125,7 @@ void ipc_free(void* ptr, int size);
  * getref increases the refcount, the putref call that reduces the recount
  * to 0 schedules the rcu destruction. Caller must guarantee locking.
  */
-void* ipc_rcu_alloc(int size);
+void *ipc_rcu_alloc(int size);
 int ipc_rcu_getref(void *ptr);
 void ipc_rcu_putref(void *ptr, void (*func)(struct rcu_head *head));
 void ipc_rcu_free(struct rcu_head *head);
@@ -144,7 +144,7 @@ struct kern_ipc_perm *ipcctl_pre_down_nolock(struct ipc_namespace *ns,
   /* On IA-64, we always use the "64-bit version" of the IPC structures.  */ 
 # define ipc_parse_version(cmd)	IPC_64
 #else
-int ipc_parse_version (int *cmd);
+int ipc_parse_version(int *cmd);
 #endif
 
 extern void free_msg(struct msg_msg *msg);

commit 72a8ff2f9245128c254387c58f948f1f0152ea46
Author: Rafael Aquini <aquini@redhat.com>
Date:   Mon Jan 27 17:07:02 2014 -0800

    ipc: change kern_ipc_perm.deleted type to bool
    
    struct kern_ipc_perm.deleted is meant to be used as a boolean toggle, and
    the changes introduced by this patch are just to make the case explicit.
    
    Signed-off-by: Rafael Aquini <aquini@redhat.com>
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Cc: Greg Thelen <gthelen@google.com>
    Acked-by: Davidlohr Bueso <davidlohr@hp.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index d05b7085a887..a1cbc3aaf25a 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -195,7 +195,7 @@ static inline void ipc_unlock(struct kern_ipc_perm *perm)
  */
 static inline bool ipc_valid_object(struct kern_ipc_perm *perm)
 {
-	return perm->deleted == 0;
+	return !perm->deleted;
 }
 
 struct kern_ipc_perm *ipc_obtain_object_check(struct ipc_ids *ids, int id);

commit 0f3d2b0135f4bdbfe47a99753923a64efd373d11
Author: Rafael Aquini <aquini@redhat.com>
Date:   Mon Jan 27 17:07:01 2014 -0800

    ipc: introduce ipc_valid_object() helper to sort out IPC_RMID races
    
    After the locking semantics for the SysV IPC API got improved, a couple
    of IPC_RMID race windows were opened because we ended up dropping the
    'kern_ipc_perm.deleted' check performed way down in ipc_lock().  The
    spotted races got sorted out by re-introducing the old test within the
    racy critical sections.
    
    This patch introduces ipc_valid_object() to consolidate the way we cope
    with IPC_RMID races by using the same abstraction across the API
    implementation.
    
    Signed-off-by: Rafael Aquini <aquini@redhat.com>
    Acked-by: Rik van Riel <riel@redhat.com>
    Acked-by: Greg Thelen <gthelen@google.com>
    Reviewed-by: Davidlohr Bueso <davidlohr@hp.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 59d78aa94987..d05b7085a887 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -185,6 +185,19 @@ static inline void ipc_unlock(struct kern_ipc_perm *perm)
 	rcu_read_unlock();
 }
 
+/*
+ * ipc_valid_object() - helper to sort out IPC_RMID races for codepaths
+ * where the respective ipc_ids.rwsem is not being held down.
+ * Checks whether the ipc object is still around or if it's gone already, as
+ * ipc_rmid() may have already freed the ID while the ipc lock was spinning.
+ * Needs to be called with kern_ipc_perm.lock held -- exception made for one
+ * checkpoint case at sys_semtimedop() as noted in code commentary.
+ */
+static inline bool ipc_valid_object(struct kern_ipc_perm *perm)
+{
+	return perm->deleted == 0;
+}
+
 struct kern_ipc_perm *ipc_obtain_object_check(struct ipc_ids *ids, int id);
 int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
 			struct ipc_ops *ops, struct ipc_params *params);

commit 4e9b45a19241354daec281d7a785739829b52359
Author: Mathias Krause <minipli@googlemail.com>
Date:   Tue Nov 12 15:11:47 2013 -0800

    ipc, msg: fix message length check for negative values
    
    On 64 bit systems the test for negative message sizes is bogus as the
    size, which may be positive when evaluated as a long, will get truncated
    to an int when passed to load_msg().  So a long might very well contain a
    positive value but when truncated to an int it would become negative.
    
    That in combination with a small negative value of msg_ctlmax (which will
    be promoted to an unsigned type for the comparison against msgsz, making
    it a big positive value and therefore make it pass the check) will lead to
    two problems: 1/ The kmalloc() call in alloc_msg() will allocate a too
    small buffer as the addition of alen is effectively a subtraction.  2/ The
    copy_from_user() call in load_msg() will first overflow the buffer with
    userland data and then, when the userland access generates an access
    violation, the fixup handler copy_user_handle_tail() will try to fill the
    remainder with zeros -- roughly 4GB.  That almost instantly results in a
    system crash or reset.
    
      ,-[ Reproducer (needs to be run as root) ]--
      | #include <sys/stat.h>
      | #include <sys/msg.h>
      | #include <unistd.h>
      | #include <fcntl.h>
      |
      | int main(void) {
      |     long msg = 1;
      |     int fd;
      |
      |     fd = open("/proc/sys/kernel/msgmax", O_WRONLY);
      |     write(fd, "-1", 2);
      |     close(fd);
      |
      |     msgsnd(0, &msg, 0xfffffff0, IPC_NOWAIT);
      |
      |     return 0;
      | }
      '---
    
    Fix the issue by preventing msgsz from getting truncated by consistently
    using size_t for the message length.  This way the size checks in
    do_msgsnd() could still be passed with a negative value for msg_ctlmax but
    we would fail on the buffer allocation in that case and error out.
    
    Also change the type of m_ts from int to size_t to avoid similar nastiness
    in other code paths -- it is used in similar constructs, i.e.  signed vs.
    unsigned checks.  It should never become negative under normal
    circumstances, though.
    
    Setting msg_ctlmax to a negative value is an odd configuration and should
    be prevented.  As that might break existing userland, it will be handled
    in a separate commit so it could easily be reverted and reworked without
    reintroducing the above described bug.
    
    Hardening mechanisms for user copy operations would have catched that bug
    early -- e.g.  checking slab object sizes on user copy operations as the
    usercopy feature of the PaX patch does.  Or, for that matter, detect the
    long vs.  int sign change due to truncation, as the size overflow plugin
    of the very same patch does.
    
    [akpm@linux-foundation.org: fix i386 min() warnings]
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Cc: Pax Team <pageexec@freemail.hu>
    Cc: Davidlohr Bueso <davidlohr@hp.com>
    Cc: Brad Spengler <spender@grsecurity.net>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Cc: <stable@vger.kernel.org>    [ v2.3.27+ -- yes, that old ;) ]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index f2f5036f2eed..59d78aa94987 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -148,9 +148,9 @@ int ipc_parse_version (int *cmd);
 #endif
 
 extern void free_msg(struct msg_msg *msg);
-extern struct msg_msg *load_msg(const void __user *src, int len);
+extern struct msg_msg *load_msg(const void __user *src, size_t len);
 extern struct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst);
-extern int store_msg(void __user *dest, struct msg_msg *msg, int len);
+extern int store_msg(void __user *dest, struct msg_msg *msg, size_t len);
 
 extern void recompute_msgmni(struct ipc_namespace *);
 

commit 53dad6d3a8e5ac1af8bacc6ac2134ae1a8b085f1
Author: Davidlohr Bueso <davidlohr@hp.com>
Date:   Mon Sep 23 17:04:45 2013 -0700

    ipc: fix race with LSMs
    
    Currently, IPC mechanisms do security and auditing related checks under
    RCU.  However, since security modules can free the security structure,
    for example, through selinux_[sem,msg_queue,shm]_free_security(), we can
    race if the structure is freed before other tasks are done with it,
    creating a use-after-free condition.  Manfred illustrates this nicely,
    for instance with shared mem and selinux:
    
     -> do_shmat calls rcu_read_lock()
     -> do_shmat calls shm_object_check().
         Checks that the object is still valid - but doesn't acquire any locks.
         Then it returns.
     -> do_shmat calls security_shm_shmat (e.g. selinux_shm_shmat)
     -> selinux_shm_shmat calls ipc_has_perm()
     -> ipc_has_perm accesses ipc_perms->security
    
    shm_close()
     -> shm_close acquires rw_mutex & shm_lock
     -> shm_close calls shm_destroy
     -> shm_destroy calls security_shm_free (e.g. selinux_shm_free_security)
     -> selinux_shm_free_security calls ipc_free_security(&shp->shm_perm)
     -> ipc_free_security calls kfree(ipc_perms->security)
    
    This patch delays the freeing of the security structures after all RCU
    readers are done.  Furthermore it aligns the security life cycle with
    that of the rest of IPC - freeing them based on the reference counter.
    For situations where we need not free security, the current behavior is
    kept.  Linus states:
    
     "... the old behavior was suspect for another reason too: having the
      security blob go away from under a user sounds like it could cause
      various other problems anyway, so I think the old code was at least
      _prone_ to bugs even if it didn't have catastrophic behavior."
    
    I have tested this patch with IPC testcases from LTP on both my
    quad-core laptop and on a 64 core NUMA server.  In both cases selinux is
    enabled, and tests pass for both voluntary and forced preemption models.
    While the mentioned races are theoretical (at least no one as reported
    them), I wanted to make sure that this new logic doesn't break anything
    we weren't aware of.
    
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Davidlohr Bueso <davidlohr@hp.com>
    Acked-by: Manfred Spraul <manfred@colorfullife.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index c5f3338ba1fa..f2f5036f2eed 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -47,6 +47,13 @@ static inline void msg_exit_ns(struct ipc_namespace *ns) { }
 static inline void shm_exit_ns(struct ipc_namespace *ns) { }
 #endif
 
+struct ipc_rcu {
+	struct rcu_head rcu;
+	atomic_t refcount;
+} ____cacheline_aligned_in_smp;
+
+#define ipc_rcu_to_struct(p)  ((void *)(p+1))
+
 /*
  * Structure that holds the parameters needed by the ipc operations
  * (see after)
@@ -120,7 +127,8 @@ void ipc_free(void* ptr, int size);
  */
 void* ipc_rcu_alloc(int size);
 int ipc_rcu_getref(void *ptr);
-void ipc_rcu_putref(void *ptr);
+void ipc_rcu_putref(void *ptr, void (*func)(struct rcu_head *head));
+void ipc_rcu_free(struct rcu_head *head);
 
 struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);
 struct kern_ipc_perm *ipc_obtain_object(struct ipc_ids *ids, int id);

commit 20b8875abcf2daa1dda5cf70bd6369df5e85d4c1
Author: Davidlohr Bueso <davidlohr.bueso@hp.com>
Date:   Wed Sep 11 14:26:31 2013 -0700

    ipc: drop ipc_lock_check
    
    No remaining users, we now use ipc_obtain_object_check().
    
    Signed-off-by: Davidlohr Bueso <davidlohr.bueso@hp.com>
    Cc: Sedat Dilek <sedat.dilek@gmail.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 14b0a2adba08..c5f3338ba1fa 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -177,7 +177,6 @@ static inline void ipc_unlock(struct kern_ipc_perm *perm)
 	rcu_read_unlock();
 }
 
-struct kern_ipc_perm *ipc_lock_check(struct ipc_ids *ids, int id);
 struct kern_ipc_perm *ipc_obtain_object_check(struct ipc_ids *ids, int id);
 int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
 			struct ipc_ops *ops, struct ipc_params *params);

commit 32a2750010981216fb788c5190fb0e646abfab30
Author: Davidlohr Bueso <davidlohr.bueso@hp.com>
Date:   Wed Sep 11 14:26:29 2013 -0700

    ipc: drop ipc_lock_by_ptr
    
    After previous cleanups and optimizations, this function is no longer
    heavily used and we don't have a good reason to keep it.  Update the few
    remaining callers and get rid of it.
    
    Signed-off-by: Davidlohr Bueso <davidlohr.bueso@hp.com>
    Cc: Sedat Dilek <sedat.dilek@gmail.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 0a362ffca972..14b0a2adba08 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -171,12 +171,6 @@ static inline void ipc_assert_locked_object(struct kern_ipc_perm *perm)
 	assert_spin_locked(&perm->lock);
 }
 
-static inline void ipc_lock_by_ptr(struct kern_ipc_perm *perm)
-{
-	rcu_read_lock();
-	ipc_lock_object(perm);
-}
-
 static inline void ipc_unlock(struct kern_ipc_perm *perm)
 {
 	ipc_unlock_object(perm);

commit d9a605e40b1376eb02b067d7690580255a0df68f
Author: Davidlohr Bueso <davidlohr.bueso@hp.com>
Date:   Wed Sep 11 14:26:24 2013 -0700

    ipc: rename ids->rw_mutex
    
    Since in some situations the lock can be shared for readers, we shouldn't
    be calling it a mutex, rename it to rwsem.
    
    Signed-off-by: Davidlohr Bueso <davidlohr.bueso@hp.com>
    Tested-by: Sedat Dilek <sedat.dilek@gmail.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 41a6c4d26399..0a362ffca972 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -94,10 +94,10 @@ void __init ipc_init_proc_interface(const char *path, const char *header,
 #define ipcid_to_idx(id) ((id) % SEQ_MULTIPLIER)
 #define ipcid_to_seqx(id) ((id) / SEQ_MULTIPLIER)
 
-/* must be called with ids->rw_mutex acquired for writing */
+/* must be called with ids->rwsem acquired for writing */
 int ipc_addid(struct ipc_ids *, struct kern_ipc_perm *, int);
 
-/* must be called with ids->rw_mutex acquired for reading */
+/* must be called with ids->rwsem acquired for reading */
 int ipc_get_maxid(struct ipc_ids *);
 
 /* must be called with both locks acquired. */

commit 3b1c4ad37741e53804ffe0a30dd01e08b2ab6241
Author: Davidlohr Bueso <davidlohr.bueso@hp.com>
Date:   Wed Sep 11 14:26:17 2013 -0700

    ipc: drop ipcctl_pre_down
    
    Now that sem, msgque and shm, through *_down(), all use the lockless
    variant of ipcctl_pre_down(), go ahead and delete it.
    
    [akpm@linux-foundation.org: fix function name in kerneldoc, cleanups]
    Signed-off-by: Davidlohr Bueso <davidlohr.bueso@hp.com>
    Tested-by: Sedat Dilek <sedat.dilek@gmail.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index b6a6a88f3002..41a6c4d26399 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -131,9 +131,6 @@ int ipc_update_perm(struct ipc64_perm *in, struct kern_ipc_perm *out);
 struct kern_ipc_perm *ipcctl_pre_down_nolock(struct ipc_namespace *ns,
 					     struct ipc_ids *ids, int id, int cmd,
 					     struct ipc64_perm *perm, int extra_perm);
-struct kern_ipc_perm *ipcctl_pre_down(struct ipc_namespace *ns,
-				      struct ipc_ids *ids, int id, int cmd,
-				      struct ipc64_perm *perm, int extra_perm);
 
 #ifndef CONFIG_ARCH_WANT_IPC_PARSE_VERSION
   /* On IA-64, we always use the "64-bit version" of the IPC structures.  */ 

commit cf9d5d78d05bca96df7618dfc3a5ee4414dcae58
Author: Davidlohr Bueso <davidlohr.bueso@hp.com>
Date:   Mon Jul 8 16:01:11 2013 -0700

    ipc: close open coded spin lock calls
    
    Signed-off-by: Davidlohr Bueso <davidlohr.bueso@hp.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Rik van Riel <riel@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index da65e8afb8f4..b6a6a88f3002 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -177,12 +177,12 @@ static inline void ipc_assert_locked_object(struct kern_ipc_perm *perm)
 static inline void ipc_lock_by_ptr(struct kern_ipc_perm *perm)
 {
 	rcu_read_lock();
-	spin_lock(&perm->lock);
+	ipc_lock_object(perm);
 }
 
 static inline void ipc_unlock(struct kern_ipc_perm *perm)
 {
-	spin_unlock(&perm->lock);
+	ipc_unlock_object(perm);
 	rcu_read_unlock();
 }
 

commit 1ca7003ab41152d673d9e359632283d05294f3d6
Author: Davidlohr Bueso <davidlohr.bueso@hp.com>
Date:   Mon Jul 8 16:01:10 2013 -0700

    ipc: introduce ipc object locking helpers
    
    Simple helpers around the (kern_ipc_perm *)->lock spinlock.
    
    Signed-off-by: Davidlohr Bueso <davidlohr.bueso@hp.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Rik van Riel <riel@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 2b0bdd5d92ce..da65e8afb8f4 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -159,23 +159,33 @@ static inline int ipc_checkid(struct kern_ipc_perm *ipcp, int uid)
 	return uid / SEQ_MULTIPLIER != ipcp->seq;
 }
 
-static inline void ipc_lock_by_ptr(struct kern_ipc_perm *perm)
+static inline void ipc_lock_object(struct kern_ipc_perm *perm)
 {
-	rcu_read_lock();
 	spin_lock(&perm->lock);
 }
 
-static inline void ipc_unlock(struct kern_ipc_perm *perm)
+static inline void ipc_unlock_object(struct kern_ipc_perm *perm)
 {
 	spin_unlock(&perm->lock);
-	rcu_read_unlock();
 }
 
-static inline void ipc_lock_object(struct kern_ipc_perm *perm)
+static inline void ipc_assert_locked_object(struct kern_ipc_perm *perm)
 {
+	assert_spin_locked(&perm->lock);
+}
+
+static inline void ipc_lock_by_ptr(struct kern_ipc_perm *perm)
+{
+	rcu_read_lock();
 	spin_lock(&perm->lock);
 }
 
+static inline void ipc_unlock(struct kern_ipc_perm *perm)
+{
+	spin_unlock(&perm->lock);
+	rcu_read_unlock();
+}
+
 struct kern_ipc_perm *ipc_lock_check(struct ipc_ids *ids, int id);
 struct kern_ipc_perm *ipc_obtain_object_check(struct ipc_ids *ids, int id);
 int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,

commit 6062a8dc0517bce23e3c2f7d2fea5e22411269a3
Author: Rik van Riel <riel@surriel.com>
Date:   Tue Apr 30 19:15:44 2013 -0700

    ipc,sem: fine grained locking for semtimedop
    
    Introduce finer grained locking for semtimedop, to handle the common case
    of a program wanting to manipulate one semaphore from an array with
    multiple semaphores.
    
    If the call is a semop manipulating just one semaphore in an array with
    multiple semaphores, only take the lock for that semaphore itself.
    
    If the call needs to manipulate multiple semaphores, or another caller is
    in a transaction that manipulates multiple semaphores, the sem_array lock
    is taken, as well as all the locks for the individual semaphores.
    
    On a 24 CPU system, performance numbers with the semop-multi
    test with N threads and N semaphores, look like this:
    
            vanilla         Davidlohr's     Davidlohr's +   Davidlohr's +
    threads                 patches         rwlock patches  v3 patches
    10      610652          726325          1783589         2142206
    20      341570          365699          1520453         1977878
    30      288102          307037          1498167         2037995
    40      290714          305955          1612665         2256484
    50      288620          312890          1733453         2650292
    60      289987          306043          1649360         2388008
    70      291298          306347          1723167         2717486
    80      290948          305662          1729545         2763582
    90      290996          306680          1736021         2757524
    100     292243          306700          1773700         3059159
    
    [davidlohr.bueso@hp.com: do not call sem_lock when bogus sma]
    [davidlohr.bueso@hp.com: make refcounter atomic]
    Signed-off-by: Rik van Riel <riel@redhat.com>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Acked-by: Davidlohr Bueso <davidlohr.bueso@hp.com>
    Cc: Chegu Vinod <chegu_vinod@hp.com>
    Cc: Jason Low <jason.low2@hp.com>
    Reviewed-by: Michel Lespinasse <walken@google.com>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Tested-by: Emmanuel Benisty <benisty.e@gmail.com>
    Tested-by: Sedat Dilek <sedat.dilek@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index c36b9977c957..2b0bdd5d92ce 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -119,7 +119,7 @@ void ipc_free(void* ptr, int size);
  * to 0 schedules the rcu destruction. Caller must guarantee locking.
  */
 void* ipc_rcu_alloc(int size);
-void ipc_rcu_getref(void *ptr);
+int ipc_rcu_getref(void *ptr);
 void ipc_rcu_putref(void *ptr);
 
 struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);

commit 16df3674efe39f3ab63e7052f1244dd3d50e7f84
Author: Davidlohr Bueso <davidlohr.bueso@hp.com>
Date:   Tue Apr 30 19:15:29 2013 -0700

    ipc,sem: do not hold ipc lock more than necessary
    
    Instead of holding the ipc lock for permissions and security checks, among
    others, only acquire it when necessary.
    
    Some numbers....
    
    1) With Rik's semop-multi.c microbenchmark we can see the following
       results:
    
    Baseline (3.9-rc1):
    cpus 4, threads: 256, semaphores: 128, test duration: 30 secs
    total operations: 151452270, ops/sec 5048409
    
    +  59.40%            a.out  [kernel.kallsyms]  [k] _raw_spin_lock
    +   6.14%            a.out  [kernel.kallsyms]  [k] sys_semtimedop
    +   3.84%            a.out  [kernel.kallsyms]  [k] avc_has_perm_flags
    +   3.64%            a.out  [kernel.kallsyms]  [k] __audit_syscall_exit
    +   2.06%            a.out  [kernel.kallsyms]  [k] copy_user_enhanced_fast_string
    +   1.86%            a.out  [kernel.kallsyms]  [k] ipc_lock
    
    With this patchset:
    cpus 4, threads: 256, semaphores: 128, test duration: 30 secs
    total operations: 273156400, ops/sec 9105213
    
    +  18.54%            a.out  [kernel.kallsyms]  [k] _raw_spin_lock
    +  11.72%            a.out  [kernel.kallsyms]  [k] sys_semtimedop
    +   7.70%            a.out  [kernel.kallsyms]  [k] ipc_has_perm.isra.21
    +   6.58%            a.out  [kernel.kallsyms]  [k] avc_has_perm_flags
    +   6.54%            a.out  [kernel.kallsyms]  [k] __audit_syscall_exit
    +   4.71%            a.out  [kernel.kallsyms]  [k] ipc_obtain_object_check
    
    2) While on an Oracle swingbench DSS (data mining) workload the
       improvements are not as exciting as with Rik's benchmark, we can see
       some positive numbers.  For an 8 socket machine the following are the
       percentages of %sys time incurred in the ipc lock:
    
    Baseline (3.9-rc1):
    100 swingbench users: 8,74%
    400 swingbench users: 21,86%
    800 swingbench users: 84,35%
    
    With this patchset:
    100 swingbench users: 8,11%
    400 swingbench users: 19,93%
    800 swingbench users: 77,69%
    
    [riel@redhat.com: fix two locking bugs]
    [sasha.levin@oracle.com: prevent releasing RCU read lock twice in semctl_main]
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Davidlohr Bueso <davidlohr.bueso@hp.com>
    Signed-off-by: Rik van Riel <riel@redhat.com>
    Reviewed-by: Chegu Vinod <chegu_vinod@hp.com>
    Acked-by: Michel Lespinasse <walken@google.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Jason Low <jason.low2@hp.com>
    Cc: Emmanuel Benisty <benisty.e@gmail.com>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Tested-by: Sedat Dilek <sedat.dilek@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 13d92fea15a3..c36b9977c957 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -171,6 +171,11 @@ static inline void ipc_unlock(struct kern_ipc_perm *perm)
 	rcu_read_unlock();
 }
 
+static inline void ipc_lock_object(struct kern_ipc_perm *perm)
+{
+	spin_lock(&perm->lock);
+}
+
 struct kern_ipc_perm *ipc_lock_check(struct ipc_ids *ids, int id);
 struct kern_ipc_perm *ipc_obtain_object_check(struct ipc_ids *ids, int id);
 int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,

commit 444d0f621b64716f7868dcbde448e0c66ece4e61
Author: Davidlohr Bueso <davidlohr.bueso@hp.com>
Date:   Tue Apr 30 19:15:24 2013 -0700

    ipc: introduce lockless pre_down ipcctl
    
    Various forms of ipc use ipcctl_pre_down() to retrieve an ipc object and
    check permissions, mostly for IPC_RMID and IPC_SET commands.
    
    Introduce ipcctl_pre_down_nolock(), a lockless version of this function.
    The locking version is retained, yet modified to call the nolock version
    without affecting its semantics, thus transparent to all ipc callers.
    
    Signed-off-by: Davidlohr Bueso <davidlohr.bueso@hp.com>
    Signed-off-by: Rik van Riel <riel@redhat.com>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Chegu Vinod <chegu_vinod@hp.com>
    Cc: Emmanuel Benisty <benisty.e@gmail.com>
    Cc: Jason Low <jason.low2@hp.com>
    Cc: Michel Lespinasse <walken@google.com>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Tested-by: Sedat Dilek <sedat.dilek@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index bfc8d4ea6e46..13d92fea15a3 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -128,6 +128,9 @@ struct kern_ipc_perm *ipc_obtain_object(struct ipc_ids *ids, int id);
 void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);
 void ipc64_perm_to_ipc_perm(struct ipc64_perm *in, struct ipc_perm *out);
 int ipc_update_perm(struct ipc64_perm *in, struct kern_ipc_perm *out);
+struct kern_ipc_perm *ipcctl_pre_down_nolock(struct ipc_namespace *ns,
+					     struct ipc_ids *ids, int id, int cmd,
+					     struct ipc64_perm *perm, int extra_perm);
 struct kern_ipc_perm *ipcctl_pre_down(struct ipc_namespace *ns,
 				      struct ipc_ids *ids, int id, int cmd,
 				      struct ipc64_perm *perm, int extra_perm);

commit 4d2bff5eb86e8d7b4a20934cccb93bdeebed3558
Author: Davidlohr Bueso <davidlohr.bueso@hp.com>
Date:   Tue Apr 30 19:15:19 2013 -0700

    ipc: introduce obtaining a lockless ipc object
    
    Through ipc_lock() and therefore ipc_lock_check() we currently return the
    locked ipc object.  This is not necessary for all situations and can,
    therefore, cause unnecessary ipc lock contention.
    
    Introduce analogous ipc_obtain_object() and ipc_obtain_object_check()
    functions that only lookup and return the ipc object.
    
    Both these functions must be called within the RCU read critical section.
    
    [akpm@linux-foundation.org: propagate the ipc_obtain_object() errno from ipc_lock()]
    Signed-off-by: Davidlohr Bueso <davidlohr.bueso@hp.com>
    Signed-off-by: Rik van Riel <riel@redhat.com>
    Reviewed-by: Chegu Vinod <chegu_vinod@hp.com>
    Acked-by: Michel Lespinasse <walken@google.com>
    Cc: Emmanuel Benisty <benisty.e@gmail.com>
    Cc: Jason Low <jason.low2@hp.com>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Tested-by: Sedat Dilek <sedat.dilek@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index ac1480a4efd1..bfc8d4ea6e46 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -123,6 +123,7 @@ void ipc_rcu_getref(void *ptr);
 void ipc_rcu_putref(void *ptr);
 
 struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);
+struct kern_ipc_perm *ipc_obtain_object(struct ipc_ids *ids, int id);
 
 void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);
 void ipc64_perm_to_ipc_perm(struct ipc64_perm *in, struct ipc_perm *out);
@@ -168,6 +169,7 @@ static inline void ipc_unlock(struct kern_ipc_perm *perm)
 }
 
 struct kern_ipc_perm *ipc_lock_check(struct ipc_ids *ids, int id);
+struct kern_ipc_perm *ipc_obtain_object_check(struct ipc_ids *ids, int id);
 int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
 			struct ipc_ops *ops, struct ipc_params *params);
 void free_ipcs(struct ipc_namespace *ns, struct ipc_ids *ids,

commit 7bb4deff61bdab3338534841cb6d0508314a41d6
Author: Davidlohr Bueso <davidlohr.bueso@hp.com>
Date:   Tue Apr 30 19:15:14 2013 -0700

    ipc: remove bogus lock comment for ipc_checkid
    
    This series makes the sysv semaphore code more scalable, by reducing the
    time the semaphore lock is held, and making the locking more scalable for
    semaphore arrays with multiple semaphores.
    
    The first four patches were written by Davidlohr Buesso, and reduce the
    hold time of the semaphore lock.
    
    The last three patches change the sysv semaphore code locking to be more
    fine grained, providing a performance boost when multiple semaphores in a
    semaphore array are being manipulated simultaneously.
    
    On a 24 CPU system, performance numbers with the semop-multi
    test with N threads and N semaphores, look like this:
    
            vanilla         Davidlohr's     Davidlohr's +   Davidlohr's +
            threads                 patches         rwlock patches  v3 patches
            10      610652          726325          1783589         2142206
            20      341570          365699          1520453         1977878
            30      288102          307037          1498167         2037995
            40      290714          305955          1612665         2256484
            50      288620          312890          1733453         2650292
            60      289987          306043          1649360         2388008
            70      291298          306347          1723167         2717486
            80      290948          305662          1729545         2763582
            90      290996          306680          1736021         2757524
            100     292243          306700          1773700         3059159
    
    This patch:
    
    There is no reason to be holding the ipc lock while reading ipcp->seq,
    hence remove misleading comment.
    
    Also simplify the return value for the function.
    
    Signed-off-by: Davidlohr Bueso <davidlohr.bueso@hp.com>
    Signed-off-by: Rik van Riel <riel@redhat.com>
    Cc: Chegu Vinod <chegu_vinod@hp.com>
    Cc: Emmanuel Benisty <benisty.e@gmail.com>
    Cc: Jason Low <jason.low2@hp.com>
    Cc: Michel Lespinasse <walken@google.com>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Tested-by: Sedat Dilek <sedat.dilek@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index eeb79a1fbd83..ac1480a4efd1 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -150,14 +150,9 @@ static inline int ipc_buildid(int id, int seq)
 	return SEQ_MULTIPLIER * seq + id;
 }
 
-/*
- * Must be called with ipcp locked
- */
 static inline int ipc_checkid(struct kern_ipc_perm *ipcp, int uid)
 {
-	if (uid / SEQ_MULTIPLIER != ipcp->seq)
-		return 1;
-	return 0;
+	return uid / SEQ_MULTIPLIER != ipcp->seq;
 }
 
 static inline void ipc_lock_by_ptr(struct kern_ipc_perm *perm)

commit 4a674f34ba04a002244edaf891b5da7fc1473ae8
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Fri Jan 4 15:34:55 2013 -0800

    ipc: introduce message queue copy feature
    
    This patch is required for checkpoint/restore in userspace.
    
    c/r requires some way to get all pending IPC messages without deleting
    them from the queue (checkpoint can fail and in this case tasks will be
    resumed, so queue have to be valid).
    
    To achive this, new operation flag MSG_COPY for sys_msgrcv() system call
    was introduced.  If this flag was specified, then mtype is interpreted as
    number of the message to copy.
    
    If MSG_COPY is set, then kernel will allocate dummy message with passed
    size, and then use new copy_msg() helper function to copy desired message
    (instead of unlinking it from the queue).
    
    Notes:
    
    1) Return -ENOSYS if MSG_COPY is specified, but
       CONFIG_CHECKPOINT_RESTORE is not set.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Cc: Serge Hallyn <serge.hallyn@canonical.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Pavel Emelyanov <xemul@parallels.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index a61e0ca2bffd..eeb79a1fbd83 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -140,6 +140,7 @@ int ipc_parse_version (int *cmd);
 
 extern void free_msg(struct msg_msg *msg);
 extern struct msg_msg *load_msg(const void __user *src, int len);
+extern struct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst);
 extern int store_msg(void __user *dest, struct msg_msg *msg, int len);
 
 extern void recompute_msgmni(struct ipc_namespace *);

commit 03f595668017f1a1fb971c02fc37140bc6e7bb1c
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Fri Jan 4 15:34:50 2013 -0800

    ipc: add sysctl to specify desired next object id
    
    Add 3 new variables and sysctls to tune them (by one "next_id" variable
    for messages, semaphores and shared memory respectively).  This variable
    can be used to set desired id for next allocated IPC object.  By default
    it's equal to -1 and old behaviour is preserved.  If this variable is
    non-negative, then desired idr will be extracted from it and used as a
    start value to search for free IDR slot.
    
    Notes:
    
    1) this patch doesn't guarantee that the new object will have desired
       id.  So it's up to user space how to handle new object with wrong id.
    
    2) After a sucessful id allocation attempt, "next_id" will be set back
       to -1 (if it was non-negative).
    
    [akpm@linux-foundation.org: checkpatch fixes]
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Cc: Serge Hallyn <serge.hallyn@canonical.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Pavel Emelyanov <xemul@parallels.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index c8fe2f7631e9..a61e0ca2bffd 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -92,6 +92,7 @@ void __init ipc_init_proc_interface(const char *path, const char *header,
 #define IPC_SHM_IDS	2
 
 #define ipcid_to_idx(id) ((id) % SEQ_MULTIPLIER)
+#define ipcid_to_seqx(id) ((id) / SEQ_MULTIPLIER)
 
 /* must be called with ids->rw_mutex acquired for writing */
 int ipc_addid(struct ipc_ids *, struct kern_ipc_perm *, int);

commit 1efdb69b0bb41dec8ee3e2cac0a0f167837d0919
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Feb 7 16:54:11 2012 -0800

    userns: Convert ipc to use kuid and kgid where appropriate
    
    - Store the ipc owner and creator with a kuid
    - Store the ipc group and the crators group with a kgid.
    - Add error handling to ipc_update_perms, allowing it to
      fail if the uids and gids can not be converted to kuids
      or kgids.
    - Modify the proc files to display the ipc creator and
      owner in the user namespace of the opener of the proc file.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/ipc/util.h b/ipc/util.h
index 850ef3e962cb..c8fe2f7631e9 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -125,7 +125,7 @@ struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);
 
 void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);
 void ipc64_perm_to_ipc_perm(struct ipc64_perm *in, struct ipc_perm *out);
-void ipc_update_perm(struct ipc64_perm *in, struct kern_ipc_perm *out);
+int ipc_update_perm(struct ipc64_perm *in, struct kern_ipc_perm *out);
 struct kern_ipc_perm *ipcctl_pre_down(struct ipc_namespace *ns,
 				      struct ipc_ids *ids, int id, int cmd,
 				      struct ipc64_perm *perm, int extra_perm);

commit c1d7e01d7877a397655277a920aeaa3830ed9461
Author: Will Deacon <will.deacon@arm.com>
Date:   Mon Jul 30 14:42:46 2012 -0700

    ipc: use Kconfig options for __ARCH_WANT_[COMPAT_]IPC_PARSE_VERSION
    
    Rather than #define the options manually in the architecture code, add
    Kconfig options for them and select them there instead.  This also allows
    us to select the compat IPC version parsing automatically for platforms
    using the old compat IPC interface.
    
    Reported-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 6f5c20bedaab..850ef3e962cb 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -130,7 +130,7 @@ struct kern_ipc_perm *ipcctl_pre_down(struct ipc_namespace *ns,
 				      struct ipc_ids *ids, int id, int cmd,
 				      struct ipc64_perm *perm, int extra_perm);
 
-#ifndef __ARCH_WANT_IPC_PARSE_VERSION
+#ifndef CONFIG_ARCH_WANT_IPC_PARSE_VERSION
   /* On IA-64, we always use the "64-bit version" of the IPC structures.  */ 
 # define ipc_parse_version(cmd)	IPC_64
 #else

commit b0e77598f87107001a00b8a4ece9c95e4254ccc4
Author: Serge E. Hallyn <serge@hallyn.com>
Date:   Wed Mar 23 16:43:24 2011 -0700

    userns: user namespaces: convert several capable() calls
    
    CAP_IPC_OWNER and CAP_IPC_LOCK can be checked against current_user_ns(),
    because the resource comes from current's own ipc namespace.
    
    setuid/setgid are to uids in own namespace, so again checks can be against
    current_user_ns().
    
    Changelog:
            Jan 11: Use task_ns_capable() in place of sched_capable().
            Jan 11: Use nsown_capable() as suggested by Bastian Blank.
            Jan 11: Clarify (hopefully) some logic in futex and sched.c
            Feb 15: use ns_capable for ipc, not nsown_capable
            Feb 23: let copy_ipcs handle setting ipc_ns->user_ns
            Feb 23: pass ns down rather than taking it from current
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Serge E. Hallyn <serge.hallyn@canonical.com>
    Acked-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@free.fr>
    Acked-by: David Howells <dhowells@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 764b51a37a6a..6f5c20bedaab 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -103,7 +103,7 @@ int ipc_get_maxid(struct ipc_ids *);
 void ipc_rmid(struct ipc_ids *, struct kern_ipc_perm *);
 
 /* must be called with ipcp locked */
-int ipcperms(struct kern_ipc_perm *ipcp, short flg);
+int ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flg);
 
 /* for rare, potentially huge allocations.
  * both function can sleep
@@ -126,7 +126,8 @@ struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);
 void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);
 void ipc64_perm_to_ipc_perm(struct ipc64_perm *in, struct ipc_perm *out);
 void ipc_update_perm(struct ipc64_perm *in, struct kern_ipc_perm *out);
-struct kern_ipc_perm *ipcctl_pre_down(struct ipc_ids *ids, int id, int cmd,
+struct kern_ipc_perm *ipcctl_pre_down(struct ipc_namespace *ns,
+				      struct ipc_ids *ids, int id, int cmd,
 				      struct ipc64_perm *perm, int extra_perm);
 
 #ifndef __ARCH_WANT_IPC_PARSE_VERSION

commit 232086b19964d0e13359d30d74b11ca31b0751cb
Author: Johannes Weiner <hannes@cmpxchg.org>
Date:   Sat Jun 20 02:23:29 2009 +0200

    ipc: unbreak 32-bit shmctl/semctl/msgctl
    
    31a985f "ipc: use __ARCH_WANT_IPC_PARSE_VERSION in ipc/util.h" would
    choose the implementation of ipc_parse_version() based on a symbol
    defined in <asm/unistd.h>.
    
    But it failed to also include this header and thus broke
    IPC_64-passing 32-bit userspace because the flag wasn't masked out
    properly anymore and the command not understood.
    
    Include <linux/unistd.h> to give the architecture a chance to ask for
    the no-no-op ipc_parse_version().
    
    Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index ab3ebf2621b9..764b51a37a6a 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -10,6 +10,7 @@
 #ifndef _IPC_UTIL_H
 #define _IPC_UTIL_H
 
+#include <linux/unistd.h>
 #include <linux/err.h>
 
 #define SEQ_MULTIPLIER	(IPCMNI)

commit 665c7741fb63c7ceeb515f1d1ed8b016efe65bf3
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Jun 17 16:27:57 2009 -0700

    ipcns: move free_ipcs() proto
    
    Function is really private to ipc/ and avoid struct kern_ipc_perm
    forward declaration.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Reviewed-by: WANG Cong <xiyou.wangcong@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index f9fe90e48861..ab3ebf2621b9 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -171,5 +171,6 @@ static inline void ipc_unlock(struct kern_ipc_perm *perm)
 struct kern_ipc_perm *ipc_lock_check(struct ipc_ids *ids, int id);
 int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
 			struct ipc_ops *ops, struct ipc_params *params);
-
+void free_ipcs(struct ipc_namespace *ns, struct ipc_ids *ids,
+		void (*free)(struct ipc_namespace *, struct kern_ipc_perm *));
 #endif

commit 31a985fbb18c1600955124a1efd2343efa867549
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jun 17 16:27:46 2009 -0700

    ipc: use __ARCH_WANT_IPC_PARSE_VERSION in ipc/util.h
    
    The definition of ipc_parse_version depends on
    __ARCH_WANT_IPC_PARSE_VERSION, but the header file declares it
    conditionally based on the architecture.
    
    Use the macro consistently to make it easier to add new architectures.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 1187332a89d2..f9fe90e48861 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -128,7 +128,7 @@ void ipc_update_perm(struct ipc64_perm *in, struct kern_ipc_perm *out);
 struct kern_ipc_perm *ipcctl_pre_down(struct ipc_ids *ids, int id, int cmd,
 				      struct ipc64_perm *perm, int extra_perm);
 
-#if defined(__ia64__) || defined(__x86_64__) || defined(__hppa__) || defined(__XTENSA__)
+#ifndef __ARCH_WANT_IPC_PARSE_VERSION
   /* On IA-64, we always use the "64-bit version" of the IPC structures.  */ 
 # define ipc_parse_version(cmd)	IPC_64
 #else

commit 7eafd7c74c3f2e67c27621b987b28397110d643f
Author: Serge E. Hallyn <serue@us.ibm.com>
Date:   Mon Apr 6 19:01:10 2009 -0700

    namespaces: ipc namespaces: implement support for posix msqueues
    
    Implement multiple mounts of the mqueue file system, and link it to usage
    of CLONE_NEWIPC.
    
    Each ipc ns has a corresponding mqueuefs superblock.  When a user does
    clone(CLONE_NEWIPC) or unshare(CLONE_NEWIPC), the unshare will cause an
    internal mount of a new mqueuefs sb linked to the new ipc ns.
    
    When a user does 'mount -t mqueue mqueue /dev/mqueue', he mounts the
    mqueuefs superblock.
    
    Posix message queues can be worked with both through the mq_* system calls
    (see mq_overview(7)), and through the VFS through the mqueue mount.  Any
    usage of mq_open() and friends will work with the acting task's ipc
    namespace.  Any actions through the VFS will work with the mqueuefs in
    which the file was created.  So if a user doesn't remount mqueuefs after
    unshare(CLONE_NEWIPC), mq_open("/ab") will not be reflected in "ls
    /dev/mqueue".
    
    If task a mounts mqueue for ipc_ns:1, then clones task b with a new ipcns,
    ipcns:2, and then task a is the last task in ipc_ns:1 to exit, then (1)
    ipc_ns:1 will be freed, (2) it's superblock will live on until task b
    umounts the corresponding mqueuefs, and vfs actions will continue to
    succeed, but (3) sb->s_fs_info will be NULL for the sb corresponding to
    the deceased ipc_ns:1.
    
    To make this happen, we must protect the ipc reference count when
    
    a) a task exits and drops its ipcns->count, since it might be dropping
       it to 0 and freeing the ipcns
    
    b) a task accesses the ipcns through its mqueuefs interface, since it
       bumps the ipcns refcount and might race with the last task in the ipcns
       exiting.
    
    So the kref is changed to an atomic_t so we can use
    atomic_dec_and_lock(&ns->count,mq_lock), and every access to the ipcns
    through ns = mqueuefs_sb->s_fs_info is protected by the same lock.
    
    Signed-off-by: Cedric Le Goater <clg@fr.ibm.com>
    Signed-off-by: Serge E. Hallyn <serue@us.ibm.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 0e7d9223acc1..1187332a89d2 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -21,9 +21,11 @@ void shm_init (void);
 struct ipc_namespace;
 
 #ifdef CONFIG_POSIX_MQUEUE
-void mq_exit_ns(struct ipc_namespace *ns);
+extern void mq_clear_sbinfo(struct ipc_namespace *ns);
+extern void mq_put_mnt(struct ipc_namespace *ns);
 #else
-static inline void mq_exit_ns(struct ipc_namespace *ns) { }
+static inline void mq_clear_sbinfo(struct ipc_namespace *ns) { }
+static inline void mq_put_mnt(struct ipc_namespace *ns) { }
 #endif
 
 #ifdef CONFIG_SYSVIPC

commit 614b84cf4e4a920d2af32b8f147ea1e3b8c27ea6
Author: Serge E. Hallyn <serue@us.ibm.com>
Date:   Mon Apr 6 19:01:08 2009 -0700

    namespaces: mqueue ns: move mqueue_mnt into struct ipc_namespace
    
    Move mqueue vfsmount plus a few tunables into the ipc_namespace struct.
    The CONFIG_IPC_NS boolean and the ipc_namespace struct will serve both the
    posix message queue namespaces and the SYSV ipc namespaces.
    
    The sysctl code will be fixed separately in patch 3.  After just this
    patch, making a change to posix mqueue tunables always changes the values
    in the initial ipc namespace.
    
    Signed-off-by: Cedric Le Goater <clg@fr.ibm.com>
    Signed-off-by: Serge E. Hallyn <serue@us.ibm.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 3646b45a03c9..0e7d9223acc1 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -20,6 +20,13 @@ void shm_init (void);
 
 struct ipc_namespace;
 
+#ifdef CONFIG_POSIX_MQUEUE
+void mq_exit_ns(struct ipc_namespace *ns);
+#else
+static inline void mq_exit_ns(struct ipc_namespace *ns) { }
+#endif
+
+#ifdef CONFIG_SYSVIPC
 void sem_init_ns(struct ipc_namespace *ns);
 void msg_init_ns(struct ipc_namespace *ns);
 void shm_init_ns(struct ipc_namespace *ns);
@@ -27,6 +34,15 @@ void shm_init_ns(struct ipc_namespace *ns);
 void sem_exit_ns(struct ipc_namespace *ns);
 void msg_exit_ns(struct ipc_namespace *ns);
 void shm_exit_ns(struct ipc_namespace *ns);
+#else
+static inline void sem_init_ns(struct ipc_namespace *ns) { }
+static inline void msg_init_ns(struct ipc_namespace *ns) { }
+static inline void shm_init_ns(struct ipc_namespace *ns) { }
+
+static inline void sem_exit_ns(struct ipc_namespace *ns) { }
+static inline void msg_exit_ns(struct ipc_namespace *ns) { }
+static inline void shm_exit_ns(struct ipc_namespace *ns) { }
+#endif
 
 /*
  * Structure that holds the parameters needed by the ipc operations

commit 00c2bf85d8febfcfddde63822043462b026134ff
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Fri Jul 25 01:48:03 2008 -0700

    ipc: get rid of ipc_lock_down()
    
    Remove the ipc_lock_down() routines: they used to call idr_find() locklessly
    (given that the ipc ids lock was already held), so they are not needed
    anymore.
    
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Acked-by: "Paul E. McKenney" <paulmck@us.ibm.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Cc: Jim Houston <jim.houston@comcast.net>
    Cc: Pierre Peiffer <peifferp@gmail.com>
    Acked-by: Rik van Riel <riel@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index cdb966aebe07..3646b45a03c9 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -102,11 +102,6 @@ void* ipc_rcu_alloc(int size);
 void ipc_rcu_getref(void *ptr);
 void ipc_rcu_putref(void *ptr);
 
-/*
- * ipc_lock_down: called with rw_mutex held
- * ipc_lock: called without that lock held
- */
-struct kern_ipc_perm *ipc_lock_down(struct ipc_ids *, int);
 struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);
 
 void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);
@@ -155,7 +150,6 @@ static inline void ipc_unlock(struct kern_ipc_perm *perm)
 	rcu_read_unlock();
 }
 
-struct kern_ipc_perm *ipc_lock_check_down(struct ipc_ids *ids, int id);
 struct kern_ipc_perm *ipc_lock_check(struct ipc_ids *ids, int id);
 int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
 			struct ipc_ops *ops, struct ipc_params *params);

commit 44f564a4bf6ac70f2a84806203045cf515bc9367
Author: Zhang, Yanmin <yanmin_zhang@linux.intel.com>
Date:   Tue Apr 29 01:00:55 2008 -0700

    ipc: add definitions of USHORT_MAX and others
    
    Add definitions of USHORT_MAX and others into kernel.  ipc uses it and slub
    implementation might also use it.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Zhang Yanmin <yanmin.zhang@intel.com>
    Reviewed-by: Christoph Lameter <clameter@sgi.com>
    Cc: Nadia Derbey <Nadia.Derbey@bull.net>
    Cc: "Pierre Peiffer" <peifferp@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 791c5c012718..cdb966aebe07 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -12,7 +12,6 @@
 
 #include <linux/err.h>
 
-#define USHRT_MAX 0xffff
 #define SEQ_MULTIPLIER	(IPCMNI)
 
 void sem_init (void);

commit a5f75e7f256f75759ec3d6dbef0ba932f1b397d2
Author: Pierre Peiffer <pierre.peiffer@bull.net>
Date:   Tue Apr 29 01:00:54 2008 -0700

    IPC: consolidate all xxxctl_down() functions
    
    semctl_down(), msgctl_down() and shmctl_down() are used to handle the same set
    of commands for each kind of IPC.  They all start to do the same job (they
    retrieve the ipc and do some permission checks) before handling the commands
    on their own.
    
    This patch proposes to consolidate this by moving these same pieces of code
    into one common function called ipcctl_pre_down().
    
    It simplifies a little these xxxctl_down() functions and increases a little
    the maintainability.
    
    Signed-off-by: Pierre Peiffer <pierre.peiffer@bull.net>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Cc: Nadia Derbey <Nadia.Derbey@bull.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 12966913ebc6..791c5c012718 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -113,6 +113,8 @@ struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);
 void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);
 void ipc64_perm_to_ipc_perm(struct ipc64_perm *in, struct ipc_perm *out);
 void ipc_update_perm(struct ipc64_perm *in, struct kern_ipc_perm *out);
+struct kern_ipc_perm *ipcctl_pre_down(struct ipc_ids *ids, int id, int cmd,
+				      struct ipc64_perm *perm, int extra_perm);
 
 #if defined(__ia64__) || defined(__x86_64__) || defined(__hppa__) || defined(__XTENSA__)
   /* On IA-64, we always use the "64-bit version" of the IPC structures.  */ 

commit 8f4a3809c18ff3107bdbb1fabe3f4e5d2a928321
Author: Pierre Peiffer <pierre.peiffer@bull.net>
Date:   Tue Apr 29 01:00:51 2008 -0700

    IPC: introduce ipc_update_perm()
    
    The IPC_SET command performs the same permission setting for all IPCs.  This
    patch introduces a common ipc_update_perm() function to update these
    permissions and makes use of it for all IPCs.
    
    Signed-off-by: Pierre Peiffer <pierre.peiffer@bull.net>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Cc: Nadia Derbey <Nadia.Derbey@bull.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 0e3d79037a2a..12966913ebc6 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -112,6 +112,7 @@ struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);
 
 void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);
 void ipc64_perm_to_ipc_perm(struct ipc64_perm *in, struct ipc_perm *out);
+void ipc_update_perm(struct ipc64_perm *in, struct kern_ipc_perm *out);
 
 #if defined(__ia64__) || defined(__x86_64__) || defined(__hppa__) || defined(__XTENSA__)
   /* On IA-64, we always use the "64-bit version" of the IPC structures.  */ 

commit b6b337ad1c1d6fe11b09b35d75464b84b3e11f07
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Tue Apr 29 01:00:42 2008 -0700

    ipc: recompute msgmni on memory add / remove
    
    Introduce the registration of a callback routine that recomputes msg_ctlmni
    upon memory add / remove.
    
    A single notifier block is registered in the hotplug memory chain for all the
    ipc namespaces.
    
    Since the ipc namespaces are not linked together, they have their own
    notification chain: one notifier_block is defined per ipc namespace.
    
    Each time an ipc namespace is created (removed) it registers (unregisters) its
    notifier block in (from) the ipcns chain.  The callback routine registered in
    the memory chain invokes the ipcns notifier chain with the IPCNS_LOWMEM event.
     Each callback routine registered in the ipcns namespace, in turn, recomputes
    msgmni for the owning namespace.
    
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Cc: Yasunori Goto <y-goto@jp.fujitsu.com>
    Cc: Matt Helsley <matthltc@us.ibm.com>
    Cc: Mingming Cao <cmm@us.ibm.com>
    Cc: Pierre Peiffer <pierre.peiffer@bull.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index f37d160c98fe..0e3d79037a2a 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -124,6 +124,8 @@ extern void free_msg(struct msg_msg *msg);
 extern struct msg_msg *load_msg(const void __user *src, int len);
 extern int store_msg(void __user *dest, struct msg_msg *msg, int len);
 
+extern void recompute_msgmni(struct ipc_namespace *);
+
 static inline int ipc_buildid(int id, int seq)
 {
 	return SEQ_MULTIPLIER * seq + id;

commit ed2ddbf88c0ddeeae4c78bb306a116dfd867c55c
Author: Pierre Peiffer <pierre.peiffer@bull.net>
Date:   Fri Feb 8 04:18:57 2008 -0800

    IPC: make struct ipc_ids static in ipc_namespace
    
    Each ipc_namespace contains a table of 3 pointers to struct ipc_ids (3 for
    msg, sem and shm, structure used to store all ipcs) These 'struct ipc_ids'
    are dynamically allocated for each icp_namespace as the ipc_namespace
    itself (for the init namespace, they are initialized with pointers to
    static variables instead)
    
    It is so for historical reason: in fact, before the use of idr to store the
    ipcs, the ipcs were stored in tables of variable length, depending of the
    maximum number of ipc allowed.  Now, these 'struct ipc_ids' have a fixed
    size.  As they are allocated in any cases for each new ipc_namespace, there
    is no gain of memory in having them allocated separately of the struct
    ipc_namespace.
    
    This patch proposes to make this table static in the struct ipc_namespace.
    Thus, we can allocate all in once and get rid of all the code needed to
    allocate and free these ipc_ids separately.
    
    Signed-off-by: Pierre Peiffer <pierre.peiffer@bull.net>
    Acked-by: Cedric Le Goater <clg@fr.ibm.com>
    Cc: Pavel Emelyanov <xemul@openvz.org>
    Cc: Nadia Derbey <Nadia.Derbey@bull.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index ca245fae2f98..f37d160c98fe 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -10,7 +10,6 @@
 #ifndef _IPC_UTIL_H
 #define _IPC_UTIL_H
 
-#include <linux/idr.h>
 #include <linux/err.h>
 
 #define USHRT_MAX 0xffff
@@ -22,22 +21,14 @@ void shm_init (void);
 
 struct ipc_namespace;
 
-int sem_init_ns(struct ipc_namespace *ns);
-int msg_init_ns(struct ipc_namespace *ns);
-int shm_init_ns(struct ipc_namespace *ns);
+void sem_init_ns(struct ipc_namespace *ns);
+void msg_init_ns(struct ipc_namespace *ns);
+void shm_init_ns(struct ipc_namespace *ns);
 
 void sem_exit_ns(struct ipc_namespace *ns);
 void msg_exit_ns(struct ipc_namespace *ns);
 void shm_exit_ns(struct ipc_namespace *ns);
 
-struct ipc_ids {
-	int in_use;
-	unsigned short seq;
-	unsigned short seq_max;
-	struct rw_semaphore rw_mutex;
-	struct idr ipcs_idr;
-};
-
 /*
  * Structure that holds the parameters needed by the ipc operations
  * (see after)
@@ -68,6 +59,7 @@ struct ipc_ops {
 };
 
 struct seq_file;
+struct ipc_ids;
 
 void ipc_init_ids(struct ipc_ids *);
 #ifdef CONFIG_PROC_FS

commit b2d75cddc83a349ef5633f609b9734b6b957f90f
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Fri Feb 8 04:18:54 2008 -0800

    ipc: uninline some code from util.h
    
    ipc_lock_check_down(), ipc_lock_check() and ipcget() seem too large to be
    inline.  Besides, they give no optimization being inline as they perform
    calls inside in any case.
    
    Moving them into ipc/util.c saves 500 bytes of vmlinux and shortens IPC
    internal API.
    
    $ ./scripts/bloat-o-meter vmlinux-orig vmlinux
    add/remove: 3/2 grow/shrink: 0/10 up/down: 490/-989 (-499)
    function                                     old     new   delta
    ipcget                                         -     392    +392
    ipc_lock_check_down                            -      49     +49
    ipc_lock_check                                 -      49     +49
    sys_semget                                   119     105     -14
    sys_shmget                                   108      86     -22
    sys_msgget                                   100      78     -22
    do_msgsnd                                    665     631     -34
    do_msgrcv                                    680     644     -36
    do_shmat                                     771     733     -38
    sys_msgctl                                  1302    1229     -73
    ipcget_new                                    80       -     -80
    sys_semtimedop                              1534    1452     -82
    sys_semctl                                  2034    1922    -112
    sys_shmctl                                  1919    1765    -154
    ipcget_public                                322       -    -322
    
    The ipcget() growth is the result of gcc inlining of currently static
    ipcget_new/_public.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: Nadia Derbey <Nadia.Derbey@bull.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index fc6b7294f764..ca245fae2f98 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -131,10 +131,6 @@ int ipc_parse_version (int *cmd);
 extern void free_msg(struct msg_msg *msg);
 extern struct msg_msg *load_msg(const void __user *src, int len);
 extern int store_msg(void __user *dest, struct msg_msg *msg, int len);
-extern int ipcget_new(struct ipc_namespace *, struct ipc_ids *,
-			struct ipc_ops *, struct ipc_params *);
-extern int ipcget_public(struct ipc_namespace *, struct ipc_ids *,
-			struct ipc_ops *, struct ipc_params *);
 
 static inline int ipc_buildid(int id, int seq)
 {
@@ -163,57 +159,9 @@ static inline void ipc_unlock(struct kern_ipc_perm *perm)
 	rcu_read_unlock();
 }
 
-static inline struct kern_ipc_perm *ipc_lock_check_down(struct ipc_ids *ids,
-						int id)
-{
-	struct kern_ipc_perm *out;
-
-	out = ipc_lock_down(ids, id);
-	if (IS_ERR(out))
-		return out;
-
-	if (ipc_checkid(out, id)) {
-		ipc_unlock(out);
-		return ERR_PTR(-EIDRM);
-	}
-
-	return out;
-}
-
-static inline struct kern_ipc_perm *ipc_lock_check(struct ipc_ids *ids,
-						int id)
-{
-	struct kern_ipc_perm *out;
-
-	out = ipc_lock(ids, id);
-	if (IS_ERR(out))
-		return out;
-
-	if (ipc_checkid(out, id)) {
-		ipc_unlock(out);
-		return ERR_PTR(-EIDRM);
-	}
-
-	return out;
-}
-
-/**
- * ipcget - Common sys_*get() code
- * @ns : namsepace
- * @ids : IPC identifier set
- * @ops : operations to be called on ipc object creation, permission checks
- *        and further checks
- * @params : the parameters needed by the previous operations.
- *
- * Common routine called by sys_msgget(), sys_semget() and sys_shmget().
- */
-static inline int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
-			struct ipc_ops *ops, struct ipc_params *params)
-{
-	if (params->key == IPC_PRIVATE)
-		return ipcget_new(ns, ids, ops, params);
-	else
-		return ipcget_public(ns, ids, ops, params);
-}
+struct kern_ipc_perm *ipc_lock_check_down(struct ipc_ids *ids, int id);
+struct kern_ipc_perm *ipc_lock_check(struct ipc_ids *ids, int id);
+int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
+			struct ipc_ops *ops, struct ipc_params *params);
 
 #endif

commit ae5e1b22f17983da929a0d0178896269e19da186
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Fri Feb 8 04:18:22 2008 -0800

    namespaces: move the IPC namespace under IPC_NS option
    
    Currently the IPC namespace management code is spread over the ipc/*.c files.
    I moved this code into ipc/namespace.c file which is compiled out when needed.
    
    The linux/ipc_namespace.h file is used to store the prototypes of the
    functions in namespace.c and the stubs for NAMESPACES=n case.  This is done
    so, because the stub for copy_ipc_namespace requires the knowledge of the
    CLONE_NEWIPC flag, which is in sched.h.  But the linux/ipc.h file itself in
    included into many many .c files via the sys.h->sem.h sequence so adding the
    sched.h into it will make all these .c depend on sched.h which is not that
    good.  On the other hand the knowledge about the namespaces stuff is required
    in 4 .c files only.
    
    Besides, this patch compiles out some auxiliary functions from ipc/sem.c,
    msg.c and shm.c files.  It turned out that moving these functions into
    namespaces.c is not that easy because they use many other calls and macros
    from the original file.  Moving them would make this patch complicated.  On
    the other hand all these functions can be consolidated, so I will send a
    separate patch doing this a bit later.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Cc: Cedric Le Goater <clg@fr.ibm.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Herbert Poetzl <herbert@13thfloor.at>
    Cc: Kirill Korotaev <dev@sw.ru>
    Cc: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 9ffea40457ce..fc6b7294f764 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -20,6 +20,8 @@ void sem_init (void);
 void msg_init (void);
 void shm_init (void);
 
+struct ipc_namespace;
+
 int sem_init_ns(struct ipc_namespace *ns);
 int msg_init_ns(struct ipc_namespace *ns);
 int shm_init_ns(struct ipc_namespace *ns);

commit 1b531f213661657d6e1c55cf5c97f649d630c227
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Thu Oct 18 23:40:55 2007 -0700

    ipc: remove unneeded parameters
    
    Remvoe the unneeded parameters from ipc_checkid() and ipc_buildid()
    interfaces.
    
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index bd47687077e0..9ffea40457ce 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -134,7 +134,7 @@ extern int ipcget_new(struct ipc_namespace *, struct ipc_ids *,
 extern int ipcget_public(struct ipc_namespace *, struct ipc_ids *,
 			struct ipc_ops *, struct ipc_params *);
 
-static inline int ipc_buildid(struct ipc_ids *ids, int id, int seq)
+static inline int ipc_buildid(int id, int seq)
 {
 	return SEQ_MULTIPLIER * seq + id;
 }
@@ -142,8 +142,7 @@ static inline int ipc_buildid(struct ipc_ids *ids, int id, int seq)
 /*
  * Must be called with ipcp locked
  */
-static inline int ipc_checkid(struct ipc_ids *ids, struct kern_ipc_perm *ipcp,
-				int uid)
+static inline int ipc_checkid(struct kern_ipc_perm *ipcp, int uid)
 {
 	if (uid / SEQ_MULTIPLIER != ipcp->seq)
 		return 1;
@@ -171,7 +170,7 @@ static inline struct kern_ipc_perm *ipc_lock_check_down(struct ipc_ids *ids,
 	if (IS_ERR(out))
 		return out;
 
-	if (ipc_checkid(ids, out, id)) {
+	if (ipc_checkid(out, id)) {
 		ipc_unlock(out);
 		return ERR_PTR(-EIDRM);
 	}
@@ -188,7 +187,7 @@ static inline struct kern_ipc_perm *ipc_lock_check(struct ipc_ids *ids,
 	if (IS_ERR(out))
 		return out;
 
-	if (ipc_checkid(ids, out, id)) {
+	if (ipc_checkid(out, id)) {
 		ipc_unlock(out);
 		return ERR_PTR(-EIDRM);
 	}

commit 3e148c79938aa39035669c1cfa3ff60722134535
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Thu Oct 18 23:40:54 2007 -0700

    fix idr_find() locking
    
    This is a patch that fixes the way idr_find() used to be called in ipc_lock():
    in all the paths that don't imply an update of the ipcs idr, it was called
    without the idr tree being locked.
    
    The changes are:
      . in ipc_ids, the mutex has been changed into a reader/writer semaphore.
      . ipc_lock() now takes the mutex as a reader during the idr_find().
      . a new routine ipc_lock_down() has been defined: it doesn't take the
        mutex, assuming that it is being held by the caller. This is the routine
        that is now called in all the update paths.
    
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Acked-by: Jarek Poplawski <jarkao2@o2.pl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 99414a36a250..bd47687077e0 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -32,7 +32,7 @@ struct ipc_ids {
 	int in_use;
 	unsigned short seq;
 	unsigned short seq_max;
-	struct mutex mutex;
+	struct rw_semaphore rw_mutex;
 	struct idr ipcs_idr;
 };
 
@@ -81,8 +81,10 @@ void __init ipc_init_proc_interface(const char *path, const char *header,
 
 #define ipcid_to_idx(id) ((id) % SEQ_MULTIPLIER)
 
-/* must be called with ids->mutex acquired.*/
+/* must be called with ids->rw_mutex acquired for writing */
 int ipc_addid(struct ipc_ids *, struct kern_ipc_perm *, int);
+
+/* must be called with ids->rw_mutex acquired for reading */
 int ipc_get_maxid(struct ipc_ids *);
 
 /* must be called with both locks acquired. */
@@ -107,6 +109,11 @@ void* ipc_rcu_alloc(int size);
 void ipc_rcu_getref(void *ptr);
 void ipc_rcu_putref(void *ptr);
 
+/*
+ * ipc_lock_down: called with rw_mutex held
+ * ipc_lock: called without that lock held
+ */
+struct kern_ipc_perm *ipc_lock_down(struct ipc_ids *, int);
 struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);
 
 void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);
@@ -155,6 +162,23 @@ static inline void ipc_unlock(struct kern_ipc_perm *perm)
 	rcu_read_unlock();
 }
 
+static inline struct kern_ipc_perm *ipc_lock_check_down(struct ipc_ids *ids,
+						int id)
+{
+	struct kern_ipc_perm *out;
+
+	out = ipc_lock_down(ids, id);
+	if (IS_ERR(out))
+		return out;
+
+	if (ipc_checkid(ids, out, id)) {
+		ipc_unlock(out);
+		return ERR_PTR(-EIDRM);
+	}
+
+	return out;
+}
+
 static inline struct kern_ipc_perm *ipc_lock_check(struct ipc_ids *ids,
 						int id)
 {

commit f4566f04854d78acfc74b9acb029744acde9d033
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Thu Oct 18 23:40:53 2007 -0700

    ipc: fix wrong comments
    
    This patch fixes the wrong / obsolete comments in the ipc code.  Also adds
    a missing lock around ipc_get_maxid() in shm_get_stat().
    
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 76f8a79902de..99414a36a250 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -54,7 +54,7 @@ struct ipc_params {
  * the calls to sys_msgget(), sys_semget(), sys_shmget()
  *      . routine to call to create a new ipc object. Can be one of newque,
  *        newary, newseg
- *      . routine to call to call to check permissions for a new ipc object.
+ *      . routine to call to check permissions for a new ipc object.
  *        Can be one of security_msg_associate, security_sem_associate,
  *        security_shm_associate
  *      . routine to call for an extra check if needed
@@ -88,7 +88,8 @@ int ipc_get_maxid(struct ipc_ids *);
 /* must be called with both locks acquired. */
 void ipc_rmid(struct ipc_ids *, struct kern_ipc_perm *);
 
-int ipcperms (struct kern_ipc_perm *ipcp, short flg);
+/* must be called with ipcp locked */
+int ipcperms(struct kern_ipc_perm *ipcp, short flg);
 
 /* for rare, potentially huge allocations.
  * both function can sleep
@@ -131,6 +132,9 @@ static inline int ipc_buildid(struct ipc_ids *ids, int id, int seq)
 	return SEQ_MULTIPLIER * seq + id;
 }
 
+/*
+ * Must be called with ipcp locked
+ */
 static inline int ipc_checkid(struct ipc_ids *ids, struct kern_ipc_perm *ipcp,
 				int uid)
 {
@@ -168,6 +172,16 @@ static inline struct kern_ipc_perm *ipc_lock_check(struct ipc_ids *ids,
 	return out;
 }
 
+/**
+ * ipcget - Common sys_*get() code
+ * @ns : namsepace
+ * @ids : IPC identifier set
+ * @ops : operations to be called on ipc object creation, permission checks
+ *        and further checks
+ * @params : the parameters needed by the previous operations.
+ *
+ * Common routine called by sys_msgget(), sys_semget() and sys_shmget().
+ */
 static inline int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
 			struct ipc_ops *ops, struct ipc_params *params)
 {

commit 28028313134e9f11e49f74a4beaa47c91e5ebf06
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Thu Oct 18 23:40:52 2007 -0700

    ipc: inline ipc_buildid()
    
    This is a trivial patch that changes the ipc_buildid() routine into a static
    inline.
    
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index fa7e7a07486e..76f8a79902de 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -107,7 +107,6 @@ void ipc_rcu_getref(void *ptr);
 void ipc_rcu_putref(void *ptr);
 
 struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);
-int ipc_buildid(struct ipc_ids* ids, int id, int seq);
 
 void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);
 void ipc64_perm_to_ipc_perm(struct ipc64_perm *in, struct ipc_perm *out);
@@ -127,6 +126,11 @@ extern int ipcget_new(struct ipc_namespace *, struct ipc_ids *,
 extern int ipcget_public(struct ipc_namespace *, struct ipc_ids *,
 			struct ipc_ops *, struct ipc_params *);
 
+static inline int ipc_buildid(struct ipc_ids *ids, int id, int seq)
+{
+	return SEQ_MULTIPLIER * seq + id;
+}
+
 static inline int ipc_checkid(struct ipc_ids *ids, struct kern_ipc_perm *ipcp,
 				int uid)
 {

commit ce621f5ba52f30dd59aef4fb50276faee04ef9cf
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Thu Oct 18 23:40:52 2007 -0700

    ipc: introduce the ipcid_to_idx macro
    
    This is a trivial patch that changes all the (id % SEQ_MULTIPLIER) into a call
    to the ipcid_to_idx(id) macro.
    
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 2a03d8cc6a01..fa7e7a07486e 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -79,6 +79,8 @@ void __init ipc_init_proc_interface(const char *path, const char *header,
 #define IPC_MSG_IDS	1
 #define IPC_SHM_IDS	2
 
+#define ipcid_to_idx(id) ((id) % SEQ_MULTIPLIER)
+
 /* must be called with ids->mutex acquired.*/
 int ipc_addid(struct ipc_ids *, struct kern_ipc_perm *, int);
 int ipc_get_maxid(struct ipc_ids *);

commit 03f02c7657f7948ab980280c54c9366f962b1474
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Thu Oct 18 23:40:51 2007 -0700

    Storing ipcs into IDRs
    
    This patch converts casts of struct kern_ipc_perm to
       . struct msg_queue
       . struct sem_array
       . struct shmid_kernel
    into the equivalent container_of() macro. It improves code maintenance
    because the code need not change if kern_ipc_perm is no longer at the
    beginning of the containing struct.
    
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index c4b0a9865bf5..2a03d8cc6a01 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -61,8 +61,8 @@ struct ipc_params {
  */
 struct ipc_ops {
 	int (*getnew) (struct ipc_namespace *, struct ipc_params *);
-	int (*associate) (void *, int);
-	int (*more_checks) (void *, struct ipc_params *);
+	int (*associate) (struct kern_ipc_perm *, int);
+	int (*more_checks) (struct kern_ipc_perm *, struct ipc_params *);
 };
 
 struct seq_file;

commit 023a53557ea0e987b002e9a844242ef0b0aa1eb3
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Thu Oct 18 23:40:51 2007 -0700

    ipc: integrate ipc_checkid() into ipc_lock()
    
    This patch introduces a new ipc_lock_check() routine interface:
       . each time ipc_checkid() is called, this is done after calling ipc_lock().
         ipc_checkid() is now called from inside ipc_lock_check().
    
    [akpm@linux-foundation.org: build fix]
    [akpm@linux-foundation.org: fix RCU locking]
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 1546eda7d99e..c4b0a9865bf5 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -11,6 +11,7 @@
 #define _IPC_UTIL_H
 
 #include <linux/idr.h>
+#include <linux/err.h>
 
 #define USHRT_MAX 0xffff
 #define SEQ_MULTIPLIER	(IPCMNI)
@@ -103,11 +104,8 @@ void* ipc_rcu_alloc(int size);
 void ipc_rcu_getref(void *ptr);
 void ipc_rcu_putref(void *ptr);
 
-struct kern_ipc_perm* ipc_lock(struct ipc_ids* ids, int id);
-void ipc_lock_by_ptr(struct kern_ipc_perm *ipcp);
-void ipc_unlock(struct kern_ipc_perm* perm);
+struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);
 int ipc_buildid(struct ipc_ids* ids, int id, int seq);
-int ipc_checkid(struct ipc_ids* ids, struct kern_ipc_perm* ipcp, int uid);
 
 void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);
 void ipc64_perm_to_ipc_perm(struct ipc64_perm *in, struct ipc_perm *out);
@@ -127,6 +125,43 @@ extern int ipcget_new(struct ipc_namespace *, struct ipc_ids *,
 extern int ipcget_public(struct ipc_namespace *, struct ipc_ids *,
 			struct ipc_ops *, struct ipc_params *);
 
+static inline int ipc_checkid(struct ipc_ids *ids, struct kern_ipc_perm *ipcp,
+				int uid)
+{
+	if (uid / SEQ_MULTIPLIER != ipcp->seq)
+		return 1;
+	return 0;
+}
+
+static inline void ipc_lock_by_ptr(struct kern_ipc_perm *perm)
+{
+	rcu_read_lock();
+	spin_lock(&perm->lock);
+}
+
+static inline void ipc_unlock(struct kern_ipc_perm *perm)
+{
+	spin_unlock(&perm->lock);
+	rcu_read_unlock();
+}
+
+static inline struct kern_ipc_perm *ipc_lock_check(struct ipc_ids *ids,
+						int id)
+{
+	struct kern_ipc_perm *out;
+
+	out = ipc_lock(ids, id);
+	if (IS_ERR(out))
+		return out;
+
+	if (ipc_checkid(ids, out, id)) {
+		ipc_unlock(out);
+		return ERR_PTR(-EIDRM);
+	}
+
+	return out;
+}
+
 static inline int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
 			struct ipc_ops *ops, struct ipc_params *params)
 {

commit 637c36634029e4e7c81112796dafc32d56355b4a
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Thu Oct 18 23:40:50 2007 -0700

    ipc: remove the ipc_get() routine
    
    This is a trivial patch that removes the ipc_get() routine: it is replaced
    by a call to idr_find().
    
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 30b2a6d7cbed..1546eda7d99e 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -103,7 +103,6 @@ void* ipc_rcu_alloc(int size);
 void ipc_rcu_getref(void *ptr);
 void ipc_rcu_putref(void *ptr);
 
-struct kern_ipc_perm* ipc_get(struct ipc_ids* ids, int id);
 struct kern_ipc_perm* ipc_lock(struct ipc_ids* ids, int id);
 void ipc_lock_by_ptr(struct kern_ipc_perm *ipcp);
 void ipc_unlock(struct kern_ipc_perm* perm);

commit 7748dbfaa010b12d5fb9ddf80199534c565c6bce
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Thu Oct 18 23:40:49 2007 -0700

    ipc: unify the syscalls code
    
    This patch introduces a change into the sys_msgget(), sys_semget() and
    sys_shmget() routines: they now share a common code, which is better for
    maintainability.
    
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index c9063267d4f8..30b2a6d7cbed 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -35,6 +35,35 @@ struct ipc_ids {
 	struct idr ipcs_idr;
 };
 
+/*
+ * Structure that holds the parameters needed by the ipc operations
+ * (see after)
+ */
+struct ipc_params {
+	key_t key;
+	int flg;
+	union {
+		size_t size;	/* for shared memories */
+		int nsems;	/* for semaphores */
+	} u;			/* holds the getnew() specific param */
+};
+
+/*
+ * Structure that holds some ipc operations. This structure is used to unify
+ * the calls to sys_msgget(), sys_semget(), sys_shmget()
+ *      . routine to call to create a new ipc object. Can be one of newque,
+ *        newary, newseg
+ *      . routine to call to call to check permissions for a new ipc object.
+ *        Can be one of security_msg_associate, security_sem_associate,
+ *        security_shm_associate
+ *      . routine to call for an extra check if needed
+ */
+struct ipc_ops {
+	int (*getnew) (struct ipc_namespace *, struct ipc_params *);
+	int (*associate) (void *, int);
+	int (*more_checks) (void *, struct ipc_params *);
+};
+
 struct seq_file;
 
 void ipc_init_ids(struct ipc_ids *);
@@ -50,7 +79,6 @@ void __init ipc_init_proc_interface(const char *path, const char *header,
 #define IPC_SHM_IDS	2
 
 /* must be called with ids->mutex acquired.*/
-struct kern_ipc_perm *ipc_findkey(struct ipc_ids *ids, key_t key);
 int ipc_addid(struct ipc_ids *, struct kern_ipc_perm *, int);
 int ipc_get_maxid(struct ipc_ids *);
 
@@ -95,5 +123,18 @@ int ipc_parse_version (int *cmd);
 extern void free_msg(struct msg_msg *msg);
 extern struct msg_msg *load_msg(const void __user *src, int len);
 extern int store_msg(void __user *dest, struct msg_msg *msg, int len);
+extern int ipcget_new(struct ipc_namespace *, struct ipc_ids *,
+			struct ipc_ops *, struct ipc_params *);
+extern int ipcget_public(struct ipc_namespace *, struct ipc_ids *,
+			struct ipc_ops *, struct ipc_params *);
+
+static inline int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
+			struct ipc_ops *ops, struct ipc_params *params)
+{
+	if (params->key == IPC_PRIVATE)
+		return ipcget_new(ns, ids, ops, params);
+	else
+		return ipcget_public(ns, ids, ops, params);
+}
 
 #endif

commit 7ca7e564e049d8b350ec9d958ff25eaa24226352
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Thu Oct 18 23:40:48 2007 -0700

    ipc: store ipcs into IDRs
    
    This patch introduces ipcs storage into IDRs. The main changes are:
      . This ipc_ids structure is changed: the entries array is changed into a
        root idr structure.
      . The grow_ary() routine is removed: it is not needed anymore when adding
        an ipc structure, since we are now using the IDR facility.
      . The ipc_rmid() routine interface is changed:
           . there is no need for this routine to return the pointer passed in as
             argument: it is now declared as a void
           . since the id is now part of the kern_ipc_perm structure, no need to
             have it as an argument to the routine
    
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index 333e891bcaca..c9063267d4f8 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -10,6 +10,8 @@
 #ifndef _IPC_UTIL_H
 #define _IPC_UTIL_H
 
+#include <linux/idr.h>
+
 #define USHRT_MAX 0xffff
 #define SEQ_MULTIPLIER	(IPCMNI)
 
@@ -25,24 +27,17 @@ void sem_exit_ns(struct ipc_namespace *ns);
 void msg_exit_ns(struct ipc_namespace *ns);
 void shm_exit_ns(struct ipc_namespace *ns);
 
-struct ipc_id_ary {
-	int size;
-	struct kern_ipc_perm *p[0];
-};
-
 struct ipc_ids {
 	int in_use;
-	int max_id;
 	unsigned short seq;
 	unsigned short seq_max;
 	struct mutex mutex;
-	struct ipc_id_ary nullentry;
-	struct ipc_id_ary* entries;
+	struct idr ipcs_idr;
 };
 
 struct seq_file;
 
-void ipc_init_ids(struct ipc_ids *ids, int size);
+void ipc_init_ids(struct ipc_ids *);
 #ifdef CONFIG_PROC_FS
 void __init ipc_init_proc_interface(const char *path, const char *header,
 		int ids, int (*show)(struct seq_file *, void *));
@@ -55,11 +50,12 @@ void __init ipc_init_proc_interface(const char *path, const char *header,
 #define IPC_SHM_IDS	2
 
 /* must be called with ids->mutex acquired.*/
-int ipc_findkey(struct ipc_ids* ids, key_t key);
-int ipc_addid(struct ipc_ids* ids, struct kern_ipc_perm* new, int size);
+struct kern_ipc_perm *ipc_findkey(struct ipc_ids *ids, key_t key);
+int ipc_addid(struct ipc_ids *, struct kern_ipc_perm *, int);
+int ipc_get_maxid(struct ipc_ids *);
 
 /* must be called with both locks acquired. */
-struct kern_ipc_perm* ipc_rmid(struct ipc_ids* ids, int id);
+void ipc_rmid(struct ipc_ids *, struct kern_ipc_perm *);
 
 int ipcperms (struct kern_ipc_perm *ipcp, short flg);
 
@@ -79,18 +75,6 @@ void* ipc_rcu_alloc(int size);
 void ipc_rcu_getref(void *ptr);
 void ipc_rcu_putref(void *ptr);
 
-static inline void __ipc_fini_ids(struct ipc_ids *ids,
-		struct ipc_id_ary *entries)
-{
-	if (entries != &ids->nullentry)
-		ipc_rcu_putref(entries);
-}
-
-static inline void ipc_fini_ids(struct ipc_ids *ids)
-{
-	__ipc_fini_ids(ids, ids->entries);
-}
-
 struct kern_ipc_perm* ipc_get(struct ipc_ids* ids, int id);
 struct kern_ipc_perm* ipc_lock(struct ipc_ids* ids, int id);
 void ipc_lock_by_ptr(struct kern_ipc_perm *ipcp);

commit 7d69a1f4a72b18876c99c697692b78339d491568
Author: Cedric Le Goater <clg@fr.ibm.com>
Date:   Sun Jul 15 23:40:58 2007 -0700

    remove CONFIG_UTS_NS and CONFIG_IPC_NS
    
    CONFIG_UTS_NS and CONFIG_IPC_NS have very little value as they only
    deactivate the unshare of the uts and ipc namespaces and do not improve
    performance.
    
    Signed-off-by: Cedric Le Goater <clg@fr.ibm.com>
    Acked-by: "Serge E. Hallyn" <serue@us.ibm.com>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Herbert Poetzl <herbert@13thfloor.at>
    Cc: Pavel Emelianov <xemul@openvz.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/util.h b/ipc/util.h
index e3aa2c5c97dc..333e891bcaca 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -41,12 +41,8 @@ struct ipc_ids {
 };
 
 struct seq_file;
-#ifdef CONFIG_IPC_NS
-#define __ipc_init
-#else
-#define __ipc_init	__init
-#endif
-void __ipc_init ipc_init_ids(struct ipc_ids *ids, int size);
+
+void ipc_init_ids(struct ipc_ids *ids, int size);
 #ifdef CONFIG_PROC_FS
 void __init ipc_init_proc_interface(const char *path, const char *header,
 		int ids, int (*show)(struct seq_file *, void *));

commit c7e12b838989b0e432c7a1cdf1e6c6fd936007f6
Author: Pavel Emelianov <xemul@openvz.org>
Date:   Thu Nov 2 22:07:03 2006 -0800

    [PATCH] Fix ipc entries removal
    
    Fix two issuses related to ipc_ids->entries freeing.
    
    1. When freeing ipc namespace we need to free entries allocated
       with ipc_init_ids().
    
    2. When removing old entries in grow_ary() ipc_rcu_putref()
       may be called on entries set to &ids->nullentry earlier in
       ipc_init_ids().
       This is almost impossible without namespaces, but with
       them this situation becomes possible.
    
    Found during OpenVZ testing after obvious leaks in beancounters.
    
    Signed-off-by: Pavel Emelianov <xemul@openvz.org>
    Cc: Kirill Korotaev <dev@openvz.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/ipc/util.h b/ipc/util.h
index c8fd6b9d77b5..e3aa2c5c97dc 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -83,6 +83,18 @@ void* ipc_rcu_alloc(int size);
 void ipc_rcu_getref(void *ptr);
 void ipc_rcu_putref(void *ptr);
 
+static inline void __ipc_fini_ids(struct ipc_ids *ids,
+		struct ipc_id_ary *entries)
+{
+	if (entries != &ids->nullentry)
+		ipc_rcu_putref(entries);
+}
+
+static inline void ipc_fini_ids(struct ipc_ids *ids)
+{
+	__ipc_fini_ids(ids, ids->entries);
+}
+
 struct kern_ipc_perm* ipc_get(struct ipc_ids* ids, int id);
 struct kern_ipc_perm* ipc_lock(struct ipc_ids* ids, int id);
 void ipc_lock_by_ptr(struct kern_ipc_perm *ipcp);

commit 73ea41302bab5e02c9e86ab15c509494a550f1db
Author: Kirill Korotaev <dev@openvz.org>
Date:   Mon Oct 2 02:18:20 2006 -0700

    [PATCH] IPC namespace - utils
    
    This patch adds basic IPC namespace functionality to
    IPC utils:
    - init_ipc_ns
    - copy/clone/unshare/free IPC ns
    - /proc preparations
    
    Signed-off-by: Pavel Emelianov <xemul@openvz.org>
    Signed-off-by: Kirill Korotaev <dev@openvz.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Cedric Le Goater <clg@fr.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/ipc/util.h b/ipc/util.h
index 0181553d31d8..c8fd6b9d77b5 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -3,6 +3,8 @@
  * Copyright (C) 1999 Christoph Rohland
  *
  * ipc helper functions (c) 1999 Manfred Spraul <manfred@colorfullife.com>
+ * namespaces support.      2006 OpenVZ, SWsoft Inc.
+ *                               Pavel Emelianov <xemul@openvz.org>
  */
 
 #ifndef _IPC_UTIL_H
@@ -15,6 +17,14 @@ void sem_init (void);
 void msg_init (void);
 void shm_init (void);
 
+int sem_init_ns(struct ipc_namespace *ns);
+int msg_init_ns(struct ipc_namespace *ns);
+int shm_init_ns(struct ipc_namespace *ns);
+
+void sem_exit_ns(struct ipc_namespace *ns);
+void msg_exit_ns(struct ipc_namespace *ns);
+void shm_exit_ns(struct ipc_namespace *ns);
+
 struct ipc_id_ary {
 	int size;
 	struct kern_ipc_perm *p[0];
@@ -31,15 +41,23 @@ struct ipc_ids {
 };
 
 struct seq_file;
-void __init ipc_init_ids(struct ipc_ids* ids, int size);
+#ifdef CONFIG_IPC_NS
+#define __ipc_init
+#else
+#define __ipc_init	__init
+#endif
+void __ipc_init ipc_init_ids(struct ipc_ids *ids, int size);
 #ifdef CONFIG_PROC_FS
 void __init ipc_init_proc_interface(const char *path, const char *header,
-				    struct ipc_ids *ids,
-				    int (*show)(struct seq_file *, void *));
+		int ids, int (*show)(struct seq_file *, void *));
 #else
 #define ipc_init_proc_interface(path, header, ids, show) do {} while (0)
 #endif
 
+#define IPC_SEM_IDS	0
+#define IPC_MSG_IDS	1
+#define IPC_SHM_IDS	2
+
 /* must be called with ids->mutex acquired.*/
 int ipc_findkey(struct ipc_ids* ids, key_t key);
 int ipc_addid(struct ipc_ids* ids, struct kern_ipc_perm* new, int size);

commit 5f921ae96f1529a55966f25cd5c70fab11d38be7
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Mar 26 01:37:17 2006 -0800

    [PATCH] sem2mutex: ipc, id.sem
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Signed-off-by: Lee Schermerhorn <lee.schermerhorn@hp.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/ipc/util.h b/ipc/util.h
index efaff3ee7de7..0181553d31d8 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -25,7 +25,7 @@ struct ipc_ids {
 	int max_id;
 	unsigned short seq;
 	unsigned short seq_max;
-	struct semaphore sem;	
+	struct mutex mutex;
 	struct ipc_id_ary nullentry;
 	struct ipc_id_ary* entries;
 };
@@ -40,7 +40,7 @@ void __init ipc_init_proc_interface(const char *path, const char *header,
 #define ipc_init_proc_interface(path, header, ids, show) do {} while (0)
 #endif
 
-/* must be called with ids->sem acquired.*/
+/* must be called with ids->mutex acquired.*/
 int ipc_findkey(struct ipc_ids* ids, key_t key);
 int ipc_addid(struct ipc_ids* ids, struct kern_ipc_perm* new, int size);
 

commit 624dffcbcf87b9c501b13256416a82487be962bc
Author: Christian Kujau <evil@g-house.de>
Date:   Sun Jan 15 02:43:54 2006 +0100

    correct email address of Manfred Spraul
    
    I  tried to send the forcedeth maintainer an email, but it came back with:
    
    "The mail address manfreds@colorfullife.com is not read anymore.
    Please resent your mail to manfred@ instead of manfreds@."
    
    This patch fixes this.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/ipc/util.h b/ipc/util.h
index fc9a28be0797..efaff3ee7de7 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -2,7 +2,7 @@
  * linux/ipc/util.h
  * Copyright (C) 1999 Christoph Rohland
  *
- * ipc helper functions (c) 1999 Manfred Spraul <manfreds@colorfullife.com>
+ * ipc helper functions (c) 1999 Manfred Spraul <manfred@colorfullife.com>
  */
 
 #ifndef _IPC_UTIL_H

commit ae7817745eef3b4ed3c2e36cb403e0c50f17d4e4
Author: Mike Waychison <mikew@google.com>
Date:   Tue Sep 6 15:17:09 2005 -0700

    [PATCH] ipc: add generic struct ipc_ids seq_file iteration
    
    The following two patches convert /proc/sysvipc/* to use seq_file.
    
    This gives us the following:
    
     - Self-consistent IPC records in proc.
     - O(n) reading of the files themselves.
    
    This patch:
    
    Add a generic method for ipc types to be displayed using seq_file.  This
    patch abstracts out seq_file iterating over struct ipc_ids into ipc/util.c
    
    Signed-off-by: Mike Waychison <mikew@google.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/ipc/util.h b/ipc/util.h
index 44348ca5a707..fc9a28be0797 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -30,7 +30,15 @@ struct ipc_ids {
 	struct ipc_id_ary* entries;
 };
 
+struct seq_file;
 void __init ipc_init_ids(struct ipc_ids* ids, int size);
+#ifdef CONFIG_PROC_FS
+void __init ipc_init_proc_interface(const char *path, const char *header,
+				    struct ipc_ids *ids,
+				    int (*show)(struct seq_file *, void *));
+#else
+#define ipc_init_proc_interface(path, header, ids, show) do {} while (0)
+#endif
 
 /* must be called with ids->sem acquired.*/
 int ipc_findkey(struct ipc_ids* ids, key_t key);

commit 813e6783647489a8481d256944b7fd75ff79e035
Author: Chris Zankel <czankel@tensilica.com>
Date:   Tue Jul 12 13:58:25 2005 -0700

    [PATCH] xtensa: remove old syscalls
    
    This patch fixes some minor bugs introduced by the previous patch (remove
    old syscalls).  Both patches remove the obsolete syscalls.  The changes in
    this patch were suggested by Arnd Bergmann.  The vmlinux.lds.S changes are
    required for the latest gcc/binutils.
    
    Signed-off-by: Chris Zankel <chris@zankel.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/ipc/util.h b/ipc/util.h
index 07d689452363..44348ca5a707 100644
--- a/ipc/util.h
+++ b/ipc/util.h
@@ -67,7 +67,7 @@ int ipc_checkid(struct ipc_ids* ids, struct kern_ipc_perm* ipcp, int uid);
 void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);
 void ipc64_perm_to_ipc_perm(struct ipc64_perm *in, struct ipc_perm *out);
 
-#if defined(__ia64__) || defined(__x86_64__) || defined(__hppa__)
+#if defined(__ia64__) || defined(__x86_64__) || defined(__hppa__) || defined(__XTENSA__)
   /* On IA-64, we always use the "64-bit version" of the IPC structures.  */ 
 # define ipc_parse_version(cmd)	IPC_64
 #else

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/ipc/util.h b/ipc/util.h
new file mode 100644
index 000000000000..07d689452363
--- /dev/null
+++ b/ipc/util.h
@@ -0,0 +1,81 @@
+/*
+ * linux/ipc/util.h
+ * Copyright (C) 1999 Christoph Rohland
+ *
+ * ipc helper functions (c) 1999 Manfred Spraul <manfreds@colorfullife.com>
+ */
+
+#ifndef _IPC_UTIL_H
+#define _IPC_UTIL_H
+
+#define USHRT_MAX 0xffff
+#define SEQ_MULTIPLIER	(IPCMNI)
+
+void sem_init (void);
+void msg_init (void);
+void shm_init (void);
+
+struct ipc_id_ary {
+	int size;
+	struct kern_ipc_perm *p[0];
+};
+
+struct ipc_ids {
+	int in_use;
+	int max_id;
+	unsigned short seq;
+	unsigned short seq_max;
+	struct semaphore sem;	
+	struct ipc_id_ary nullentry;
+	struct ipc_id_ary* entries;
+};
+
+void __init ipc_init_ids(struct ipc_ids* ids, int size);
+
+/* must be called with ids->sem acquired.*/
+int ipc_findkey(struct ipc_ids* ids, key_t key);
+int ipc_addid(struct ipc_ids* ids, struct kern_ipc_perm* new, int size);
+
+/* must be called with both locks acquired. */
+struct kern_ipc_perm* ipc_rmid(struct ipc_ids* ids, int id);
+
+int ipcperms (struct kern_ipc_perm *ipcp, short flg);
+
+/* for rare, potentially huge allocations.
+ * both function can sleep
+ */
+void* ipc_alloc(int size);
+void ipc_free(void* ptr, int size);
+
+/*
+ * For allocation that need to be freed by RCU.
+ * Objects are reference counted, they start with reference count 1.
+ * getref increases the refcount, the putref call that reduces the recount
+ * to 0 schedules the rcu destruction. Caller must guarantee locking.
+ */
+void* ipc_rcu_alloc(int size);
+void ipc_rcu_getref(void *ptr);
+void ipc_rcu_putref(void *ptr);
+
+struct kern_ipc_perm* ipc_get(struct ipc_ids* ids, int id);
+struct kern_ipc_perm* ipc_lock(struct ipc_ids* ids, int id);
+void ipc_lock_by_ptr(struct kern_ipc_perm *ipcp);
+void ipc_unlock(struct kern_ipc_perm* perm);
+int ipc_buildid(struct ipc_ids* ids, int id, int seq);
+int ipc_checkid(struct ipc_ids* ids, struct kern_ipc_perm* ipcp, int uid);
+
+void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);
+void ipc64_perm_to_ipc_perm(struct ipc64_perm *in, struct ipc_perm *out);
+
+#if defined(__ia64__) || defined(__x86_64__) || defined(__hppa__)
+  /* On IA-64, we always use the "64-bit version" of the IPC structures.  */ 
+# define ipc_parse_version(cmd)	IPC_64
+#else
+int ipc_parse_version (int *cmd);
+#endif
+
+extern void free_msg(struct msg_msg *msg);
+extern struct msg_msg *load_msg(const void __user *src, int len);
+extern int store_msg(void __user *dest, struct msg_msg *msg, int len);
+
+#endif
