commit ea3edd4dc23027083fbb4a73b65114d08fe73a76
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Mar 24 08:25:11 2020 +0100

    block: remove __bdevname
    
    There is no good reason for __bdevname to exist.  Just open code
    printing the string in the callers.  For three of them the format
    string can be trivially merged into existing printk statements,
    and in init/do_mounts.c we can at least do the scnprintf once at
    the start of the function, and unconditional of CONFIG_BLOCK to
    make the output for tiny configfs a little more helpful.
    
    Acked-by: Theodore Ts'o <tytso@mit.edu> # for ext4
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 0ae9cc22f2ae..29d326b6c29d 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -429,12 +429,10 @@ void __init mount_block_root(char *name, int flags)
 	struct page *page = alloc_page(GFP_KERNEL);
 	char *fs_names = page_address(page);
 	char *p;
-#ifdef CONFIG_BLOCK
 	char b[BDEVNAME_SIZE];
-#else
-	const char *b = name;
-#endif
 
+	scnprintf(b, BDEVNAME_SIZE, "unknown-block(%u,%u)",
+		  MAJOR(ROOT_DEV), MINOR(ROOT_DEV));
 	get_fs_names(fs_names);
 retry:
 	for (p = fs_names; *p; p += strlen(p)+1) {
@@ -451,9 +449,6 @@ void __init mount_block_root(char *name, int flags)
 		 * and bad superblock on root device.
 		 * and give them a list of the available devices
 		 */
-#ifdef CONFIG_BLOCK
-		__bdevname(ROOT_DEV, b);
-#endif
 		printk("VFS: Cannot open root device \"%s\" or %s: error %d\n",
 				root_device_name, b, err);
 		printk("Please append a correct \"root=\" boot option; here are the available partitions:\n");
@@ -476,9 +471,6 @@ void __init mount_block_root(char *name, int flags)
 	for (p = fs_names; *p; p += strlen(p)+1)
 		printk(" %s", p);
 	printk("\n");
-#ifdef CONFIG_BLOCK
-	__bdevname(ROOT_DEV, b);
-#endif
 	panic("VFS: Unable to mount root fs on %s", b);
 out:
 	put_page(page);

commit 7de7de7ca0ae0fc70515ee3154af33af75edae2c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 15 19:50:23 2019 -0800

    Fix root mounting with no mount options
    
    The "trivial conversion" in commit cccaa5e33525 ("init: use do_mount()
    instead of ksys_mount()") was totally broken, since it didn't handle the
    case of a NULL mount data pointer.  And while I had "tested" it (and
    presumably Dominik had too) that bug was hidden by me having options.
    
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Reported-by: Ondřej Jirman <megi@xff.cz>
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    Reported-by: Naresh Kamboju <naresh.kamboju@linaro.org>
    Reported-and-tested-by: Borislav Petkov <bp@suse.de>
    Tested-by: Chris Clayton <chris2553@googlemail.com>
    Tested-by: Eric Biggers <ebiggers@kernel.org>
    Tested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Tested-by: Guido Günther <agx@sigxcpu.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index f55cbd9cb818..0ae9cc22f2ae 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -391,17 +391,19 @@ static int __init do_mount_root(const char *name, const char *fs,
 				 const int flags, const void *data)
 {
 	struct super_block *s;
-	char *data_page;
-	struct page *p;
+	struct page *p = NULL;
+	char *data_page = NULL;
 	int ret;
 
-	/* do_mount() requires a full page as fifth argument */
-	p = alloc_page(GFP_KERNEL);
-	if (!p)
-		return -ENOMEM;
-
-	data_page = page_address(p);
-	strncpy(data_page, data, PAGE_SIZE - 1);
+	if (data) {
+		/* do_mount() requires a full page as fifth argument */
+		p = alloc_page(GFP_KERNEL);
+		if (!p)
+			return -ENOMEM;
+		data_page = page_address(p);
+		/* zero-pad. do_mount() will make sure it's terminated */
+		strncpy(data_page, data, PAGE_SIZE);
+	}
 
 	ret = do_mount(name, "/root", fs, flags, data_page);
 	if (ret)
@@ -417,7 +419,8 @@ static int __init do_mount_root(const char *name, const char *fs,
 	       MAJOR(ROOT_DEV), MINOR(ROOT_DEV));
 
 out:
-	put_page(p);
+	if (p)
+		put_page(p);
 	return ret;
 }
 

commit cccaa5e33525fc07f4a2ce0518e50b9ddf435e47
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Oct 23 22:41:09 2018 +0200

    init: use do_mount() instead of ksys_mount()
    
    In prepare_namespace(), do_mount() can be used instead of ksys_mount()
    as the first and third argument are const strings in the kernel, the
    second and fourth argument are passed through anyway, and the fifth
    argument is NULL.
    
    In do_mount_root(), ksys_mount() is called with the first and third
    argument being already kernelspace strings, which do not need to be
    copied over from userspace to kernelspace (again). The second and
    fourth arguments are passed through to do_mount() anyway. The fifth
    argument, while already residing in kernelspace, needs to be put into
    a page of its own. Then, do_mount() can be used instead of
    ksys_mount().
    
    Once this is done, there are no in-kernel users to ksys_mount() left,
    which can therefore be removed.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 43f6d098c880..f55cbd9cb818 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -387,12 +387,25 @@ static void __init get_fs_names(char *page)
 	*s = '\0';
 }
 
-static int __init do_mount_root(char *name, char *fs, int flags, void *data)
+static int __init do_mount_root(const char *name, const char *fs,
+				 const int flags, const void *data)
 {
 	struct super_block *s;
-	int err = ksys_mount(name, "/root", fs, flags, data);
-	if (err)
-		return err;
+	char *data_page;
+	struct page *p;
+	int ret;
+
+	/* do_mount() requires a full page as fifth argument */
+	p = alloc_page(GFP_KERNEL);
+	if (!p)
+		return -ENOMEM;
+
+	data_page = page_address(p);
+	strncpy(data_page, data, PAGE_SIZE - 1);
+
+	ret = do_mount(name, "/root", fs, flags, data_page);
+	if (ret)
+		goto out;
 
 	ksys_chdir("/root");
 	s = current->fs->pwd.dentry->d_sb;
@@ -402,7 +415,10 @@ static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 	       s->s_type->name,
 	       sb_rdonly(s) ? " readonly" : "",
 	       MAJOR(ROOT_DEV), MINOR(ROOT_DEV));
-	return 0;
+
+out:
+	put_page(p);
+	return ret;
 }
 
 void __init mount_block_root(char *name, int flags)
@@ -671,7 +687,7 @@ void __init prepare_namespace(void)
 	mount_root();
 out:
 	devtmpfs_mount();
-	ksys_mount(".", "/", NULL, MS_MOVE, NULL);
+	do_mount(".", "/", NULL, MS_MOVE, NULL);
 	ksys_chroot(".");
 }
 

commit 5e787dbf659fe77d56215be74044f85e01b3920f
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Oct 23 22:10:35 2018 +0200

    devtmpfs: use do_mount() instead of ksys_mount()
    
    In devtmpfs, do_mount() can be called directly instead of complex wrapping
    by ksys_mount():
    - the first and third arguments are const strings in the kernel,
      and do not need to be copied over from userspace;
    - the fifth argument is NULL, and therefore no page needs to be
      copied over from userspace;
    - the second and fourth argument are passed through anyway.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index af9cda887a23..43f6d098c880 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -670,7 +670,7 @@ void __init prepare_namespace(void)
 
 	mount_root();
 out:
-	devtmpfs_mount("dev");
+	devtmpfs_mount();
 	ksys_mount(".", "/", NULL, MS_MOVE, NULL);
 	ksys_chroot(".");
 }

commit 8902dd526020748ccf16f753befc287b534fdefd
Author: Paulo Alcantara (SUSE) <pc@cjr.nz>
Date:   Tue Oct 1 14:10:27 2019 -0300

    init: Support mounting root file systems over SMB
    
    Add a new virtual device named /dev/cifs (0xfe) to tell the kernel to
    mount the root file system over the network by using SMB protocol.
    
    cifs_root_data() will be responsible to retrieve the parsed
    information of the new command-line option (cifsroot=) and then call
    do_mount_root() with the appropriate mount options for cifs.ko.
    
    Signed-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 9634ecf3743d..af9cda887a23 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -212,6 +212,7 @@ static int match_dev_by_label(struct device *dev, const void *data)
  *	   a colon.
  *	9) PARTLABEL=<name> with name being the GPT partition label.
  *	   MSDOS partitions do not support labels!
+ *	10) /dev/cifs represents Root_CIFS (0xfe)
  *
  *	If name doesn't have fall into the categories above, we return (0,0).
  *	block_class is used to check if something is a disk name. If the disk
@@ -268,6 +269,9 @@ dev_t name_to_dev_t(const char *name)
 	res = Root_NFS;
 	if (strcmp(name, "nfs") == 0)
 		goto done;
+	res = Root_CIFS;
+	if (strcmp(name, "cifs") == 0)
+		goto done;
 	res = Root_RAM0;
 	if (strcmp(name, "ram") == 0)
 		goto done;
@@ -501,6 +505,42 @@ static int __init mount_nfs_root(void)
 }
 #endif
 
+#ifdef CONFIG_CIFS_ROOT
+
+extern int cifs_root_data(char **dev, char **opts);
+
+#define CIFSROOT_TIMEOUT_MIN	5
+#define CIFSROOT_TIMEOUT_MAX	30
+#define CIFSROOT_RETRY_MAX	5
+
+static int __init mount_cifs_root(void)
+{
+	char *root_dev, *root_data;
+	unsigned int timeout;
+	int try, err;
+
+	err = cifs_root_data(&root_dev, &root_data);
+	if (err != 0)
+		return 0;
+
+	timeout = CIFSROOT_TIMEOUT_MIN;
+	for (try = 1; ; try++) {
+		err = do_mount_root(root_dev, "cifs", root_mountflags,
+				    root_data);
+		if (err == 0)
+			return 1;
+		if (try > CIFSROOT_RETRY_MAX)
+			break;
+
+		ssleep(timeout);
+		timeout <<= 1;
+		if (timeout > CIFSROOT_TIMEOUT_MAX)
+			timeout = CIFSROOT_TIMEOUT_MAX;
+	}
+	return 0;
+}
+#endif
+
 #if defined(CONFIG_BLK_DEV_RAM) || defined(CONFIG_BLK_DEV_FD)
 void __init change_floppy(char *fmt, ...)
 {
@@ -542,6 +582,15 @@ void __init mount_root(void)
 		ROOT_DEV = Root_FD0;
 	}
 #endif
+#ifdef CONFIG_CIFS_ROOT
+	if (ROOT_DEV == Root_CIFS) {
+		if (mount_cifs_root())
+			return;
+
+		printk(KERN_ERR "VFS: Unable to mount root fs via SMB, trying floppy.\n");
+		ROOT_DEV = Root_FD0;
+	}
+#endif
 #ifdef CONFIG_BLK_DEV_FD
 	if (MAJOR(ROOT_DEV) == FLOPPY_MAJOR) {
 		/* rd_doload is 2 for a dual initrd/ramload setup */

commit f32356261d44d580649a7abce1156d15d49cf20f
Author: David Howells <dhowells@redhat.com>
Date:   Mon Mar 25 16:38:31 2019 +0000

    vfs: Convert ramfs, shmem, tmpfs, devtmpfs, rootfs to use the new mount API
    
    Convert the ramfs, shmem, tmpfs, devtmpfs and rootfs filesystems to the new
    internal mount API as the old one will be obsoleted and removed.  This
    allows greater flexibility in communication of mount parameters between
    userspace, the VFS and the filesystem.
    
    See Documentation/filesystems/mount_api.txt for more information.
    
    Note that tmpfs is slightly tricky as it can contain embedded commas, so it
    can't be trivially split up using strsep() to break on commas in
    generic_parse_monolithic().  Instead, tmpfs has to supply its own generic
    parser.
    
    However, if tmpfs changes, then devtmpfs and rootfs, which are wrappers
    around tmpfs or ramfs, must change too - and thus so must ramfs, so these
    had to be converted also.
    
    [AV: rewritten]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Hugh Dickins <hughd@google.com>
    cc: linux-mm@kvack.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 16c29e57f224..9634ecf3743d 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -627,18 +627,17 @@ void __init prepare_namespace(void)
 }
 
 static bool is_tmpfs;
-static struct dentry *rootfs_mount(struct file_system_type *fs_type,
-	int flags, const char *dev_name, void *data)
+static int rootfs_init_fs_context(struct fs_context *fc)
 {
 	if (IS_ENABLED(CONFIG_TMPFS) && is_tmpfs)
-		return shmem_mount(fs_type, flags, dev_name, data);
+		return shmem_init_fs_context(fc);
 
-	return ramfs_mount(fs_type, flags, dev_name, data);
+	return ramfs_init_fs_context(fc);
 }
 
 struct file_system_type rootfs_fs_type = {
 	.name		= "rootfs",
-	.mount		= rootfs_mount,
+	.init_fs_context = rootfs_init_fs_context,
 	.kill_sb	= kill_litter_super,
 };
 

commit 7e30d2a5eb0b2d5853f06cb8a2d44937d80a6bd6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jun 1 18:56:53 2019 -0400

    make shmem_fill_super() static
    
    ... have callers use shmem_mount()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index baedc2ef579e..16c29e57f224 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -631,7 +631,7 @@ static struct dentry *rootfs_mount(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data)
 {
 	if (IS_ENABLED(CONFIG_TMPFS) && is_tmpfs)
-		return mount_nodev(fs_type, flags, data, shmem_fill_super);
+		return shmem_mount(fs_type, flags, dev_name, data);
 
 	return ramfs_mount(fs_type, flags, dev_name, data);
 }

commit df02450217c98e01b8b22f805314470df71f2b9b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jun 1 18:51:15 2019 -0400

    make ramfs_fill_super() static
    
    all users should just call ramfs_mount()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 53cb37b66227..baedc2ef579e 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -630,12 +630,10 @@ static bool is_tmpfs;
 static struct dentry *rootfs_mount(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data)
 {
-	void *fill = ramfs_fill_super;
-
 	if (IS_ENABLED(CONFIG_TMPFS) && is_tmpfs)
-		fill = shmem_fill_super;
+		return mount_nodev(fs_type, flags, data, shmem_fill_super);
 
-	return mount_nodev(fs_type, flags, data, fill);
+	return ramfs_mount(fs_type, flags, dev_name, data);
 }
 
 struct file_system_type rootfs_fs_type = {

commit 933a90bf4f3505f8ec83bda21a3c7d70d7c2b426
Merge: 5f4fc6d440d7 037f11b4752f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 19 10:42:02 2019 -0700

    Merge branch 'work.mount0' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs mount updates from Al Viro:
     "The first part of mount updates.
    
      Convert filesystems to use the new mount API"
    
    * 'work.mount0' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (63 commits)
      mnt_init(): call shmem_init() unconditionally
      constify ksys_mount() string arguments
      don't bother with registering rootfs
      init_rootfs(): don't bother with init_ramfs_fs()
      vfs: Convert smackfs to use the new mount API
      vfs: Convert selinuxfs to use the new mount API
      vfs: Convert securityfs to use the new mount API
      vfs: Convert apparmorfs to use the new mount API
      vfs: Convert openpromfs to use the new mount API
      vfs: Convert xenfs to use the new mount API
      vfs: Convert gadgetfs to use the new mount API
      vfs: Convert oprofilefs to use the new mount API
      vfs: Convert ibmasmfs to use the new mount API
      vfs: Convert qib_fs/ipathfs to use the new mount API
      vfs: Convert efivarfs to use the new mount API
      vfs: Convert configfs to use the new mount API
      vfs: Convert binfmt_misc to use the new mount API
      convenience helper: get_tree_single()
      convenience helper get_tree_nodev()
      vfs: Kill sget_userns()
      ...

commit 037f11b4752f717201143a1dc5d6acf3cb71ddfa
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jun 1 18:09:44 2019 -0400

    mnt_init(): call shmem_init() unconditionally
    
    No point having two call sites (earlier in init_rootfs() from
    mnt_init() in case we are going to use shmem-style rootfs,
    later from do_basic_setup() unconditionally), along with the
    logics in shmem_init() itself to make the second call a no-op...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index e7f0b0f18cce..864c032e995d 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -643,14 +643,9 @@ struct file_system_type rootfs_fs_type = {
 	.kill_sb	= kill_litter_super,
 };
 
-int __init init_rootfs(void)
+void __init init_rootfs(void)
 {
-	int err = 0;
-
 	if (IS_ENABLED(CONFIG_TMPFS) && !saved_root_name[0] &&
-		(!root_fs_names || strstr(root_fs_names, "tmpfs"))) {
-		err = shmem_init();
+		(!root_fs_names || strstr(root_fs_names, "tmpfs")))
 		is_tmpfs = true;
-	}
-	return err;
 }

commit fd3e007f6c6a0f677e4ee8aca4b9bab8ad6cab9a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu May 30 17:48:35 2019 -0400

    don't bother with registering rootfs
    
    init_mount_tree() can get to rootfs_fs_type directly and that simplifies
    a lot of things.  We don't need to register it, we don't need to look
    it up *and* we don't need to bother with preventing subsequent userland
    mounts.  That's the way we should've done that from the very beginning.
    
    There is a user-visible change, namely the disappearance of "rootfs"
    from /proc/filesystems.  Note that it's been unmountable all along
    and it didn't show up in /proc/mounts; however, it *is* a user-visible
    change and theoretically some script might've been using its presence
    in /proc/filesystems to tell 2.4.11+ from earlier kernels.
    
    *IF* any complaints about behaviour change do show up, we could fake
    it in /proc/filesystems.  I very much doubt we'll have to, though.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index c170d8b309b1..e7f0b0f18cce 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -629,19 +629,15 @@ static bool is_tmpfs;
 static struct dentry *rootfs_mount(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data)
 {
-	static unsigned long once;
 	void *fill = ramfs_fill_super;
 
-	if (test_and_set_bit(0, &once))
-		return ERR_PTR(-ENODEV);
-
 	if (IS_ENABLED(CONFIG_TMPFS) && is_tmpfs)
 		fill = shmem_fill_super;
 
 	return mount_nodev(fs_type, flags, data, fill);
 }
 
-static struct file_system_type rootfs_fs_type = {
+struct file_system_type rootfs_fs_type = {
 	.name		= "rootfs",
 	.mount		= rootfs_mount,
 	.kill_sb	= kill_litter_super,
@@ -649,19 +645,12 @@ static struct file_system_type rootfs_fs_type = {
 
 int __init init_rootfs(void)
 {
-	int err = register_filesystem(&rootfs_fs_type);
-
-	if (err)
-		return err;
+	int err = 0;
 
 	if (IS_ENABLED(CONFIG_TMPFS) && !saved_root_name[0] &&
 		(!root_fs_names || strstr(root_fs_names, "tmpfs"))) {
 		err = shmem_init();
 		is_tmpfs = true;
 	}
-
-	if (err)
-		unregister_filesystem(&rootfs_fs_type);
-
 	return err;
 }

commit 14a253ce4210cd2ef133b392062477e9d656db4a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu May 30 15:59:57 2019 -0400

    init_rootfs(): don't bother with init_ramfs_fs()
    
    the only thing done by the latter is making ramfs visible
    to mount(2); we don't need it there - rootfs is separate
    and, in fact, made visible to mount(2) in the same init_rootfs().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index f8c230c77035..c170d8b309b1 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -658,8 +658,6 @@ int __init init_rootfs(void)
 		(!root_fs_names || strstr(root_fs_names, "tmpfs"))) {
 		err = shmem_init();
 		is_tmpfs = true;
-	} else {
-		err = init_ramfs_fs();
 	}
 
 	if (err)

commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index f8c230c77035..2d1ea3028454 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/ctype.h>

commit e262e32d6bde0f77fb0c95d977482fc872c51996
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:07:23 2018 +0000

    vfs: Suppress MS_* flag defs within the kernel unless explicitly enabled
    
    Only the mount namespace code that implements mount(2) should be using the
    MS_* flags.  Suppress them inside the kernel unless uapi/linux/mount.h is
    included.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Reviewed-by: David Howells <dhowells@redhat.com>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index a754e3ba9831..f8c230c77035 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -22,6 +22,7 @@
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>
 #include <linux/nfs_mount.h>
+#include <uapi/linux/mount.h>
 
 #include "do_mounts.h"
 

commit f027c34d844013d9d6c902af8fa01a82d6e5073d
Author: Nikolaus Voss <nikolaus.voss@loewensteinmedical.de>
Date:   Tue Oct 30 15:05:57 2018 -0700

    init/do_mounts.c: add root=PARTLABEL=<name> support
    
    Support referencing the root partition label from GPT as argument
    to the root= option on the kernel command line in analogy to
    referencing the partition uuid as root=PARTUUID=<uuid>.
    
    Specifying the partition label instead of the uuid is often much
    easier, e.g. in embedded environments when there is an
    A/B rootfs partition scheme for interruptible firmware updates
    (i.e. rootfsA/ rootfsB).
    
    The partition label can be queried with the blkid command.
    
    Link: http://lkml.kernel.org/r/20180822060904.828E510665E@pc-niv.weinmann.com
    Signed-off-by: Nikolaus Voss <nikolaus.voss@loewensteinmedical.de>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Sasha Levin <Alexander.Levin@microsoft.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index e1c9afa9d8c9..a754e3ba9831 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -167,6 +167,24 @@ static dev_t devt_from_partuuid(const char *uuid_str)
 	}
 	return res;
 }
+
+/**
+ * match_dev_by_label - callback for finding a partition using its label
+ * @dev:	device passed in by the caller
+ * @data:	opaque pointer to the label to match
+ *
+ * Returns 1 if the device matches, and 0 otherwise.
+ */
+static int match_dev_by_label(struct device *dev, const void *data)
+{
+	const char *label = data;
+	struct hd_struct *part = dev_to_part(dev);
+
+	if (part->info && !strcmp(label, part->info->volname))
+		return 1;
+
+	return 0;
+}
 #endif
 
 /*
@@ -190,6 +208,8 @@ static dev_t devt_from_partuuid(const char *uuid_str)
  *	   a partition with a known unique id.
  *	8) <major>:<minor> major and minor number of the device separated by
  *	   a colon.
+ *	9) PARTLABEL=<name> with name being the GPT partition label.
+ *	   MSDOS partitions do not support labels!
  *
  *	If name doesn't have fall into the categories above, we return (0,0).
  *	block_class is used to check if something is a disk name. If the disk
@@ -211,6 +231,17 @@ dev_t name_to_dev_t(const char *name)
 		if (!res)
 			goto fail;
 		goto done;
+	} else if (strncmp(name, "PARTLABEL=", 10) == 0) {
+		struct device *dev;
+
+		dev = class_find_device(&block_class, NULL, name + 10,
+					&match_dev_by_label);
+		if (!dev)
+			goto fail;
+
+		res = dev->devt;
+		put_device(dev);
+		goto done;
 	}
 #endif
 

commit 6ad018e3ca9efd80a724e32c02ae7552fd0829f2
Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Date:   Tue Aug 21 21:58:30 2018 -0700

    init/: remove ineffective sparse disabling
    
    Sparse checking used to be disabled on init/do_mounts.c and a few related
    files because "Many of the syscalls used in this file expect some of the
    arguments to be __user pointers not __kernel pointers".
    
    However since 28128c61e ("kconfig.h: Include compiler types to avoid
    missed struct attributes") the checks are, in fact, not disabled anymore
    because of the more early include of "linux/compiler_types.h"
    
    So remove the now ineffective #undefery that was done to disable these
    warnings, as well as the associated comment.
    
    Link: http://lkml.kernel.org/r/20180617115355.53799-1-luc.vanoostenryck@gmail.com
    Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Kees Cook <keescook@chromium.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 2c71dabe5626..e1c9afa9d8c9 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -1,13 +1,3 @@
-/*
- * Many of the syscalls used in this file expect some of the arguments
- * to be __user pointers not __kernel pointers.  To limit the sparse
- * noise, turn off sparse checking for this file.
- */
-#ifdef __CHECKER__
-#undef __CHECKER__
-#warning "Sparse checking disabled for this file"
-#endif
-
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/ctype.h>

commit 3ce4a7bf66263748194b77ccefd284be963c6304
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Mar 13 21:56:26 2018 +0100

    fs: add ksys_read() helper; remove in-kernel calls to sys_read()
    
    Using this helper allows us to avoid the in-kernel calls to the
    sys_read() syscall. The ksys_ prefix denotes that this function
    is meant as a drop-in replacement for the syscall. In particular, it
    uses the same calling convention as sys_read().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index b17e0095eb4e..2c71dabe5626 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -500,7 +500,7 @@ void __init change_floppy(char *fmt, ...)
 		ksys_ioctl(fd, TCGETS, (long)&termios);
 		termios.c_lflag &= ~ICANON;
 		ksys_ioctl(fd, TCSETSF, (long)&termios);
-		sys_read(fd, &c, 1);
+		ksys_read(fd, &c, 1);
 		termios.c_lflag |= ICANON;
 		ksys_ioctl(fd, TCSETSF, (long)&termios);
 		ksys_close(fd);

commit cbb60b924b9f3e4d7c67a1c9dcf981718f926e4e
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Mar 13 21:43:59 2018 +0100

    fs: add ksys_ioctl() helper; remove in-kernel calls to sys_ioctl()
    
    Using this helper allows us to avoid the in-kernel calls to the
    sys_ioctl() syscall. The ksys_ prefix denotes that this function
    is meant as a drop-in replacement for the syscall. In particular, it
    uses the same calling convention as sys_ioctl().
    
    After careful review, at least some of these calls could be converted
    to do_vfs_ioctl() in future.
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index cc1103477071..b17e0095eb4e 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -491,18 +491,18 @@ void __init change_floppy(char *fmt, ...)
 	va_end(args);
 	fd = ksys_open("/dev/root", O_RDWR | O_NDELAY, 0);
 	if (fd >= 0) {
-		sys_ioctl(fd, FDEJECT, 0);
+		ksys_ioctl(fd, FDEJECT, 0);
 		ksys_close(fd);
 	}
 	printk(KERN_NOTICE "VFS: Insert %s and press ENTER\n", buf);
 	fd = ksys_open("/dev/console", O_RDWR, 0);
 	if (fd >= 0) {
-		sys_ioctl(fd, TCGETS, (long)&termios);
+		ksys_ioctl(fd, TCGETS, (long)&termios);
 		termios.c_lflag &= ~ICANON;
-		sys_ioctl(fd, TCSETSF, (long)&termios);
+		ksys_ioctl(fd, TCSETSF, (long)&termios);
 		sys_read(fd, &c, 1);
 		termios.c_lflag |= ICANON;
-		sys_ioctl(fd, TCSETSF, (long)&termios);
+		ksys_ioctl(fd, TCSETSF, (long)&termios);
 		ksys_close(fd);
 	}
 }

commit bae217ea8c7e123ed3fb1064909a262924771bbb
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:56 2018 +0100

    fs: add ksys_open() wrapper; remove in-kernel calls to sys_open()
    
    Using this wrapper allows us to avoid the in-kernel calls to the
    sys_open() syscall. The ksys_ prefix denotes that this function is meant
    as a drop-in replacement for the syscall. In particular, it uses the
    same calling convention as sys_open().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index a28dd42d1f84..cc1103477071 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -489,13 +489,13 @@ void __init change_floppy(char *fmt, ...)
 	va_start(args, fmt);
 	vsprintf(buf, fmt, args);
 	va_end(args);
-	fd = sys_open("/dev/root", O_RDWR | O_NDELAY, 0);
+	fd = ksys_open("/dev/root", O_RDWR | O_NDELAY, 0);
 	if (fd >= 0) {
 		sys_ioctl(fd, FDEJECT, 0);
 		ksys_close(fd);
 	}
 	printk(KERN_NOTICE "VFS: Insert %s and press ENTER\n", buf);
-	fd = sys_open("/dev/console", O_RDWR, 0);
+	fd = ksys_open("/dev/console", O_RDWR, 0);
 	if (fd >= 0) {
 		sys_ioctl(fd, TCGETS, (long)&termios);
 		termios.c_lflag &= ~ICANON;

commit 2ca2a09d6215fd9621aa3e2db7cc9428a61f2911
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:55 2018 +0100

    fs: add ksys_close() wrapper; remove in-kernel calls to sys_close()
    
    Using the ksys_close() wrapper allows us to get rid of in-kernel calls
    to the sys_close() syscall. The ksys_ prefix denotes that this function
    is meant as a drop-in replacement for the syscall. In particular, it
    uses the same calling convention as sys_close(), with one subtle
    difference:
    
    The few places which checked the return value did not care about the return
    value re-writing in sys_close(), so simply use a wrapper around
    __close_fd().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 89f18985fa90..a28dd42d1f84 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -492,7 +492,7 @@ void __init change_floppy(char *fmt, ...)
 	fd = sys_open("/dev/root", O_RDWR | O_NDELAY, 0);
 	if (fd >= 0) {
 		sys_ioctl(fd, FDEJECT, 0);
-		sys_close(fd);
+		ksys_close(fd);
 	}
 	printk(KERN_NOTICE "VFS: Insert %s and press ENTER\n", buf);
 	fd = sys_open("/dev/console", O_RDWR, 0);
@@ -503,7 +503,7 @@ void __init change_floppy(char *fmt, ...)
 		sys_read(fd, &c, 1);
 		termios.c_lflag |= ICANON;
 		sys_ioctl(fd, TCSETSF, (long)&termios);
-		sys_close(fd);
+		ksys_close(fd);
 	}
 }
 #endif

commit 447016e9681965fda8dcd9e4fd3c55308a6fd166
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:46 2018 +0100

    fs: add ksys_chdir() helper; remove in-kernel calls to sys_chdir()
    
    Using this helper allows us to avoid the in-kernel calls to the sys_chdir()
    syscall. The ksys_ prefix denotes that this function is meant as a drop-in
    replacement for the syscall. In particular, it uses the same calling
    convention as sys_chdir().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 2f06f7827b0c..89f18985fa90 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -367,7 +367,7 @@ static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 	if (err)
 		return err;
 
-	sys_chdir("/root");
+	ksys_chdir("/root");
 	s = current->fs->pwd.dentry->d_sb;
 	ROOT_DEV = s->s_dev;
 	printk(KERN_INFO

commit a16fe33ab5572e52ef4cb9719d6eb49623b2528a
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:41 2018 +0100

    fs: add ksys_chroot() helper; remove-in kernel calls to sys_chroot()
    
    Using this helper allows us to avoid the in-kernel calls to the
    sys_chroot() syscall. The ksys_ prefix denotes that this function is
    meant as a drop-in replacement for the syscall. In particular, it uses the
    same calling convention as sys_chroot().
    
    In the near future, the fs-external callers of ksys_chroot() should be
    converted to use kern_path()/set_fs_root() directly. Then ksys_chroot()
    can be moved within sys_chroot() again.
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index eb768de43d84..2f06f7827b0c 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -600,7 +600,7 @@ void __init prepare_namespace(void)
 out:
 	devtmpfs_mount("dev");
 	ksys_mount(".", "/", NULL, MS_MOVE, NULL);
-	sys_chroot(".");
+	ksys_chroot(".");
 }
 
 static bool is_tmpfs;

commit 312db1aa1dc7bff133d95c92efcc5e42b57cefa6
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:39 2018 +0100

    fs: add ksys_mount() helper; remove in-kernel calls to sys_mount()
    
    Using this helper allows us to avoid the in-kernel calls to the sys_mount()
    syscall. The ksys_ prefix denotes that this function is meant as a drop-in
    replacement for the syscall. In particular, it uses the same calling
    convention as sys_mount().
    
    In the near future, all callers of ksys_mount() should be converted to call
    do_mount() directly.
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 7cf4f6dafd5f..eb768de43d84 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -363,7 +363,7 @@ static void __init get_fs_names(char *page)
 static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 {
 	struct super_block *s;
-	int err = sys_mount(name, "/root", fs, flags, data);
+	int err = ksys_mount(name, "/root", fs, flags, data);
 	if (err)
 		return err;
 
@@ -599,7 +599,7 @@ void __init prepare_namespace(void)
 	mount_root();
 out:
 	devtmpfs_mount("dev");
-	sys_mount(".", "/", NULL, MS_MOVE, NULL);
+	ksys_mount(".", "/", NULL, MS_MOVE, NULL);
 	sys_chroot(".");
 }
 

commit 75f296d93bcebcfe375884ddac79e30263a31766
Author: Levin, Alexander (Sasha Levin) <alexander.levin@verizon.com>
Date:   Wed Nov 15 17:35:54 2017 -0800

    kmemcheck: stop using GFP_NOTRACK and SLAB_NOTRACK
    
    Convert all allocations that used a NOTRACK flag to stop using it.
    
    Link: http://lkml.kernel.org/r/20171007030159.22241-3-alexander.levin@verizon.com
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Michal Hocko <mhocko@kernel.org>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Tim Hansen <devtimhansen@gmail.com>
    Cc: Vegard Nossum <vegardno@ifi.uio.no>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index f6d4dd764a52..7cf4f6dafd5f 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -380,8 +380,7 @@ static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 
 void __init mount_block_root(char *name, int flags)
 {
-	struct page *page = alloc_page(GFP_KERNEL |
-					__GFP_NOTRACK_FALSE_POSITIVE);
+	struct page *page = alloc_page(GFP_KERNEL);
 	char *fs_names = page_address(page);
 	char *p;
 #ifdef CONFIG_BLOCK

commit e462ec50cb5fad19f6003a3d8087f4a0945dd2b1
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jul 17 08:45:35 2017 +0100

    VFS: Differentiate mount flags (MS_*) from internal superblock flags
    
    Differentiate the MS_* flags passed to mount(2) from the internal flags set
    in the super_block's s_flags.  s_flags are now called SB_*, with the names
    and the values for the moment mirroring the MS_* flags that they're
    equivalent to.
    
    In this patch, just the headers are altered and some kernel code where
    blind automated conversion isn't necessarily correct.
    
    Note that this shows up some interesting issues:
    
     (1) Some MS_* flags get translated to MNT_* flags (such as MS_NODEV ->
         MNT_NODEV) without passing this on to the filesystem, but some
         filesystems set such flags anyway.
    
     (2) The ->remount_fs() methods of some filesystems adjust the *flags
         argument by setting MS_* flags in it, such as MS_NOATIME - but these
         flags are then scrubbed by do_remount_sb() (only the occupants of
         MS_RMT_MASK are permitted: MS_RDONLY, MS_SYNCHRONOUS, MS_MANDLOCK,
         MS_I_VERSION and MS_LAZYTIME)
    
    I'm not sure what's the best way to solve all these cases.
    
    Suggested-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index bf7ea36ca286..f6d4dd764a52 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -420,8 +420,8 @@ void __init mount_block_root(char *name, int flags)
 #endif
 		panic("VFS: Unable to mount root fs on %s", b);
 	}
-	if (!(flags & MS_RDONLY)) {
-		flags |= MS_RDONLY;
+	if (!(flags & SB_RDONLY)) {
+		flags |= SB_RDONLY;
 		goto retry;
 	}
 

commit bc98a42c1f7d0f886c0c1b75a92a004976a46d9f
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jul 17 08:45:34 2017 +0100

    VFS: Convert sb->s_flags & MS_RDONLY to sb_rdonly(sb)
    
    Firstly by applying the following with coccinelle's spatch:
    
            @@ expression SB; @@
            -SB->s_flags & MS_RDONLY
            +sb_rdonly(SB)
    
    to effect the conversion to sb_rdonly(sb), then by applying:
    
            @@ expression A, SB; @@
            (
            -(!sb_rdonly(SB)) && A
            +!sb_rdonly(SB) && A
            |
            -A != (sb_rdonly(SB))
            +A != sb_rdonly(SB)
            |
            -A == (sb_rdonly(SB))
            +A == sb_rdonly(SB)
            |
            -!(sb_rdonly(SB))
            +!sb_rdonly(SB)
            |
            -A && (sb_rdonly(SB))
            +A && sb_rdonly(SB)
            |
            -A || (sb_rdonly(SB))
            +A || sb_rdonly(SB)
            |
            -(sb_rdonly(SB)) != A
            +sb_rdonly(SB) != A
            |
            -(sb_rdonly(SB)) == A
            +sb_rdonly(SB) == A
            |
            -(sb_rdonly(SB)) && A
            +sb_rdonly(SB) && A
            |
            -(sb_rdonly(SB)) || A
            +sb_rdonly(SB) || A
            )
    
            @@ expression A, B, SB; @@
            (
            -(sb_rdonly(SB)) ? 1 : 0
            +sb_rdonly(SB)
            |
            -(sb_rdonly(SB)) ? A : B
            +sb_rdonly(SB) ? A : B
            )
    
    to remove left over excess bracketage and finally by applying:
    
            @@ expression A, SB; @@
            (
            -(A & MS_RDONLY) != sb_rdonly(SB)
            +(bool)(A & MS_RDONLY) != sb_rdonly(SB)
            |
            -(A & MS_RDONLY) == sb_rdonly(SB)
            +(bool)(A & MS_RDONLY) == sb_rdonly(SB)
            )
    
    to make comparisons against the result of sb_rdonly() (which is a bool)
    work correctly.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index c2de5104aad2..bf7ea36ca286 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -373,7 +373,7 @@ static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 	printk(KERN_INFO
 	       "VFS: Mounted root (%s filesystem)%s on device %u:%u.\n",
 	       s->s_type->name,
-	       s->s_flags & MS_RDONLY ?  " readonly" : "",
+	       sb_rdonly(s) ? " readonly" : "",
 	       MAJOR(ROOT_DEV), MINOR(ROOT_DEV));
 	return 0;
 }

commit 39a0e975c37dee93fa1b8ea5f7eacd1c4c8a586e
Author: Jungseung Lee <js07.lee@samsung.com>
Date:   Mon Dec 12 16:46:43 2016 -0800

    init: reduce rootwait polling interval time to 5ms
    
    For several devices, the rootwait time is sensitive because it directly
    affects booting time.  The polling interval of rootwait is currently
    100ms.  To save unnessesary waiting time, reduce the polling interval to
    5 ms.
    
    [akpm@linux-foundation.org: remove used-once #define]
    Link: http://lkml.kernel.org/r/20161207060743.1728-1-js07.lee@samsung.com
    Signed-off-by: Jungseung Lee <js07.lee@samsung.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index dea5de95c2dd..c2de5104aad2 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -588,7 +588,7 @@ void __init prepare_namespace(void)
 			saved_root_name);
 		while (driver_probe_done() != 0 ||
 			(ROOT_DEV = name_to_dev_t(saved_root_name)) == 0)
-			msleep(100);
+			msleep(5);
 		async_synchronize_full();
 	}
 

commit c69e3c3a0c014e86750e78b7e2ae823f7a9b2cb2
Author: Vishnu Pratap Singh <vishnu.ps@samsung.com>
Date:   Thu Jun 25 15:03:37 2015 -0700

    init/do_mounts.c: add create_dev() failure log
    
    If create_dev() function fails to create the root mount device
    (/dev/root), then it goes to panic as root device not found but there is
    no printk in this case.  So I have added the log in case it fails to
    create the root device.  It will help in debugging.
    
    [akpm@linux-foundation.org: simplify printk(), use pr_emerg(), display errno]
    Signed-off-by: Vishnu Pratap Singh <vishnu.ps@samsung.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Dan Ehrenberg <dehrenberg@chromium.org>
    Cc: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index a95bbdb2a502..dea5de95c2dd 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -533,8 +533,13 @@ void __init mount_root(void)
 	}
 #endif
 #ifdef CONFIG_BLOCK
-	create_dev("/dev/root", ROOT_DEV);
-	mount_block_root("/dev/root", root_mountflags);
+	{
+		int err = create_dev("/dev/root", ROOT_DEV);
+
+		if (err < 0)
+			pr_emerg("Failed to create /dev/root: %d\n", err);
+		mount_block_root("/dev/root", root_mountflags);
+	}
 #endif
 }
 

commit cb31ef485dd4c6a205d1064b42027f82076d00c8
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Sun May 3 22:35:05 2015 +0800

    init: fix regression by supporting devices with major:minor:offset format
    
    Commit 283e7ad02 ("init: stricter checking of major:minor root=
    values") was so strict that it exposed the fact that a previously
    unknown device format was being used.
    
    Distributions like Ubuntu uses klibc (rather than uswsusp) to resume
    system from hibernation.  klibc expressed the swap partition/file in
    the form of major:minor:offset.  For example, 8:3:0 represents a swap
    partition in klibc, and klibc's resume process in initrd will finally
    echo 8:3:0 to /sys/power/resume for manually resuming.  However, due
    to commit 283e7ad02's stricter checking, 8:3:0 will be treated as an
    invalid device format, and manual resuming from hibernation will fail.
    
    Fix this by adding support for devices with major:minor:offset format
    when resuming from hibernation.
    
    Reported-by: Prigent, Christophe <christophe.prigent@intel.com>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Acked-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Signed-off-by: Mike Snitzer <snitzer@redhat.com>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 8369ffa5f33d..a95bbdb2a502 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -225,10 +225,11 @@ dev_t name_to_dev_t(const char *name)
 #endif
 
 	if (strncmp(name, "/dev/", 5) != 0) {
-		unsigned maj, min;
+		unsigned maj, min, offset;
 		char dummy;
 
-		if (sscanf(name, "%u:%u%c", &maj, &min, &dummy) == 2) {
+		if ((sscanf(name, "%u:%u%c", &maj, &min, &dummy) == 2) ||
+		    (sscanf(name, "%u:%u:%u:%c", &maj, &min, &offset, &dummy) == 3)) {
 			res = MKDEV(maj, min);
 			if (maj != MAJOR(res) || min != MINOR(res))
 				goto fail;

commit 283e7ad0241155710f99a9f39d13313a53336926
Author: Dan Ehrenberg <dehrenberg@chromium.org>
Date:   Tue Feb 10 15:20:50 2015 -0800

    init: stricter checking of major:minor root= values
    
    In the kernel command-line, previously, root=1:2jakshflaksjdhfa would
    be accepted and interpreted just like root=1:2. This patch adds
    stricter checking so that additional characters after major:minor are
    rejected by root=.
    
    The goal of this change is to help in unifying DM's interpretation of
    its block device argument by using existing kernel code (name_to_dev_t).
    But DM rejects malformed major:minor pairs, it seems reasonable for
    root= to reject them as well.
    
    Signed-off-by: Dan Ehrenberg <dehrenberg@chromium.org>
    Signed-off-by: Mike Snitzer <snitzer@redhat.com>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index c16adfbe4ad6..8369ffa5f33d 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -226,8 +226,9 @@ dev_t name_to_dev_t(const char *name)
 
 	if (strncmp(name, "/dev/", 5) != 0) {
 		unsigned maj, min;
+		char dummy;
 
-		if (sscanf(name, "%u:%u", &maj, &min) == 2) {
+		if (sscanf(name, "%u:%u%c", &maj, &min, &dummy) == 2) {
 			res = MKDEV(maj, min);
 			if (maj != MAJOR(res) || min != MINOR(res))
 				goto fail;

commit e6e20a7a5f3f49bfee518d5c6849107398d83912
Author: Dan Ehrenberg <dehrenberg@chromium.org>
Date:   Tue Feb 10 15:20:49 2015 -0800

    init: export name_to_dev_t and mark name argument as const
    
    DM will switch its device lookup code to using name_to_dev_t() so it
    must be exported.  Also, the @name argument should be marked const.
    
    Signed-off-by: Dan Ehrenberg <dehrenberg@chromium.org>
    Signed-off-by: Mike Snitzer <snitzer@redhat.com>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index eb410083e8e0..c16adfbe4ad6 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -207,7 +207,7 @@ static dev_t devt_from_partuuid(const char *uuid_str)
  *	bangs.
  */
 
-dev_t name_to_dev_t(char *name)
+dev_t name_to_dev_t(const char *name)
 {
 	char s[32];
 	char *p;
@@ -286,6 +286,7 @@ dev_t name_to_dev_t(char *name)
 done:
 	return res;
 }
+EXPORT_SYMBOL_GPL(name_to_dev_t);
 
 static int __init root_dev_setup(char *line)
 {

commit 10975933da3d65f8833d4ce98dcc2ecc63a695d6
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Thu Nov 20 16:08:59 2014 +0100

    init: fix read-write root mount
    
    If mount flags don't have MS_RDONLY, iso9660 returns EACCES without actually
    checking if it's an iso image.
    
    This tricks mount_block_root() into retrying with MS_RDONLY.  This results
    in a read-only root despite the "rw" boot parameter if the actual
    filesystem was checked after iso9660.
    
    I believe the behavior of iso9660 is okay, while that of mount_block_root()
    is not.  It should rather try all types without MS_RDONLY and only then
    retry with MS_RDONLY.
    
    This change also makes the code more robust against the case when EACCES is
    returned despite MS_RDONLY, which would've resulted in a lockup.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 9b3565c41502..eb410083e8e0 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -395,8 +395,6 @@ void __init mount_block_root(char *name, int flags)
 			case 0:
 				goto out;
 			case -EACCES:
-				flags |= MS_RDONLY;
-				goto retry;
 			case -EINVAL:
 				continue;
 		}
@@ -419,6 +417,10 @@ void __init mount_block_root(char *name, int flags)
 #endif
 		panic("VFS: Unable to mount root fs on %s", b);
 	}
+	if (!(flags & MS_RDONLY)) {
+		flags |= MS_RDONLY;
+		goto retry;
+	}
 
 	printk("List of all partitions:\n");
 	printk_all_partitions();

commit 0bf37ae4c45a0463671a50b443e1bafec730dd4d
Author: Pavel Machek <pavel@ucw.cz>
Date:   Tue Aug 26 13:49:35 2014 +0200

    init/do_mounts: better syntax description
    
    Specify hex device number unambiquously.
    
    Signed-off-by: Pavel Machek <pavel@denx.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 82f22885c87e..9b3565c41502 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -182,7 +182,8 @@ static dev_t devt_from_partuuid(const char *uuid_str)
 /*
  *	Convert a name into device number.  We accept the following variants:
  *
- *	1) device number in hexadecimal	represents itself
+ *	1) <hex_major><hex_minor> device number in hexadecimal represents itself
+ *         no leading 0x, for example b302.
  *	2) /dev/nfs represents Root_NFS (0xff)
  *	3) /dev/<disk_name> represents the device number of disk
  *	4) /dev/<disk_name><decimal> represents the device number

commit a68b31080912dae377bee4994716b357dc74286d
Author: chishanmingshen <chishanmingshen@gmail.com>
Date:   Thu Apr 3 14:49:35 2014 -0700

    init/do_mounts.c: fix comment error
    
    Signed-off-by: chishanmingshen <chishanmingshen@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 8e5addc45874..82f22885c87e 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -102,13 +102,13 @@ static int match_dev_by_uuid(struct device *dev, const void *data)
 
 /**
  * devt_from_partuuid - looks up the dev_t of a partition by its UUID
- * @uuid:	char array containing ascii UUID
+ * @uuid_str:	char array containing ascii UUID
  *
  * The function will return the first partition which contains a matching
  * UUID value in its partition_meta_info struct.  This does not search
  * by filesystem UUIDs.
  *
- * If @uuid is followed by a "/PARTNROFF=%d", then the number will be
+ * If @uuid_str is followed by a "/PARTNROFF=%d", then the number will be
  * extracted and used as an offset from the partition identified by the UUID.
  *
  * Returns the matching dev_t on success or 0 on failure.

commit 6c251611ce68d80e0067aab80a0a3b6bc652d5f5
Author: Sebastian Capella <sebastian.capella@linaro.org>
Date:   Tue Nov 12 15:08:39 2013 -0800

    init/do_mounts.c: add maj:min syntax comment
    
    The name_to_dev_t function has a comment block which lists the supported
    syntaxes for the device name.  Add a bullet for the <major>:<minor>
    syntax, which is already supported in the code
    
    Signed-off-by: Sebastian Capella <sebastian.capella@linaro.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index a51cddc2ff8c..8e5addc45874 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -197,6 +197,8 @@ static dev_t devt_from_partuuid(const char *uuid_str)
  *	   is a zero-filled hex representation of the 1-based partition number.
  *	7) PARTUUID=<UUID>/PARTNROFF=<int> to select a partition in relation to
  *	   a partition with a known unique id.
+ *	8) <major>:<minor> major and minor number of the device separated by
+ *	   a colon.
  *
  *	If name doesn't have fall into the categories above, we return (0,0).
  *	block_class is used to check if something is a disk name. If the disk

commit 6e19eded3684dc184181093af3bff2ff440f5b53
Author: Rob Landley <rob@landley.net>
Date:   Wed Sep 11 14:26:13 2013 -0700

    initmpfs: use initramfs if rootfstype= or root= specified
    
    Command line option rootfstype=ramfs to obtain old initramfs behavior, and
    use ramfs instead of tmpfs for stub when root= defined (for cosmetic
    reasons).
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Rob Landley <rob@landley.net>
    Cc: Jeff Layton <jlayton@redhat.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Stephen Warren <swarren@nvidia.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Jim Cromie <jim.cromie@gmail.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index e27908b949d4..a51cddc2ff8c 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -591,16 +591,20 @@ void __init prepare_namespace(void)
 	sys_chroot(".");
 }
 
+static bool is_tmpfs;
 static struct dentry *rootfs_mount(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data)
 {
 	static unsigned long once;
+	void *fill = ramfs_fill_super;
 
 	if (test_and_set_bit(0, &once))
 		return ERR_PTR(-ENODEV);
 
-	return mount_nodev(fs_type, flags, data,
-		IS_ENABLED(CONFIG_TMPFS) ? shmem_fill_super : ramfs_fill_super);
+	if (IS_ENABLED(CONFIG_TMPFS) && is_tmpfs)
+		fill = shmem_fill_super;
+
+	return mount_nodev(fs_type, flags, data, fill);
 }
 
 static struct file_system_type rootfs_fs_type = {
@@ -616,10 +620,13 @@ int __init init_rootfs(void)
 	if (err)
 		return err;
 
-	if (IS_ENABLED(CONFIG_TMPFS))
+	if (IS_ENABLED(CONFIG_TMPFS) && !saved_root_name[0] &&
+		(!root_fs_names || strstr(root_fs_names, "tmpfs"))) {
 		err = shmem_init();
-	else
+		is_tmpfs = true;
+	} else {
 		err = init_ramfs_fs();
+	}
 
 	if (err)
 		unregister_filesystem(&rootfs_fs_type);

commit 16203a7a9422315bc929461503e3a046459ea5ff
Author: Rob Landley <rob@landley.net>
Date:   Wed Sep 11 14:26:12 2013 -0700

    initmpfs: make rootfs use tmpfs when CONFIG_TMPFS enabled
    
    Conditionally call the appropriate fs_init function and fill_super
    functions.  Add a use once guard to shmem_init() to simply succeed on a
    second call.
    
    (Note that IS_ENABLED() is a compile time constant so dead code
    elimination removes unused function calls when CONFIG_TMPFS is disabled.)
    
    Signed-off-by: Rob Landley <rob@landley.net>
    Cc: Jeff Layton <jlayton@redhat.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Stephen Warren <swarren@nvidia.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Jim Cromie <jim.cromie@gmail.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 5d8d48fd0ee4..e27908b949d4 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -27,6 +27,7 @@
 #include <linux/fs_struct.h>
 #include <linux/slab.h>
 #include <linux/ramfs.h>
+#include <linux/shmem_fs.h>
 
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>
@@ -598,7 +599,8 @@ static struct dentry *rootfs_mount(struct file_system_type *fs_type,
 	if (test_and_set_bit(0, &once))
 		return ERR_PTR(-ENODEV);
 
-	return mount_nodev(fs_type, flags, data, ramfs_fill_super);
+	return mount_nodev(fs_type, flags, data,
+		IS_ENABLED(CONFIG_TMPFS) ? shmem_fill_super : ramfs_fill_super);
 }
 
 static struct file_system_type rootfs_fs_type = {
@@ -614,7 +616,11 @@ int __init init_rootfs(void)
 	if (err)
 		return err;
 
-	err = init_ramfs_fs();
+	if (IS_ENABLED(CONFIG_TMPFS))
+		err = shmem_init();
+	else
+		err = init_ramfs_fs();
+
 	if (err)
 		unregister_filesystem(&rootfs_fs_type);
 

commit 57f150a58c40cda598c31af8bceb8598f43c3e5f
Author: Rob Landley <rob@landley.net>
Date:   Wed Sep 11 14:26:10 2013 -0700

    initmpfs: move rootfs code from fs/ramfs/ to init/
    
    When the rootfs code was a wrapper around ramfs, having them in the same
    file made sense.  Now that it can wrap another filesystem type, move it in
    with the init code instead.
    
    This also allows a subsequent patch to access rootfstype= command line
    arg.
    
    Signed-off-by: Rob Landley <rob@landley.net>
    Cc: Jeff Layton <jlayton@redhat.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Stephen Warren <swarren@nvidia.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Jim Cromie <jim.cromie@gmail.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 816014c4627e..5d8d48fd0ee4 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -26,6 +26,7 @@
 #include <linux/async.h>
 #include <linux/fs_struct.h>
 #include <linux/slab.h>
+#include <linux/ramfs.h>
 
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>
@@ -588,3 +589,34 @@ void __init prepare_namespace(void)
 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
 	sys_chroot(".");
 }
+
+static struct dentry *rootfs_mount(struct file_system_type *fs_type,
+	int flags, const char *dev_name, void *data)
+{
+	static unsigned long once;
+
+	if (test_and_set_bit(0, &once))
+		return ERR_PTR(-ENODEV);
+
+	return mount_nodev(fs_type, flags, data, ramfs_fill_super);
+}
+
+static struct file_system_type rootfs_fs_type = {
+	.name		= "rootfs",
+	.mount		= rootfs_mount,
+	.kill_sb	= kill_litter_super,
+};
+
+int __init init_rootfs(void)
+{
+	int err = register_filesystem(&rootfs_fs_type);
+
+	if (err)
+		return err;
+
+	err = init_ramfs_fs();
+	if (err)
+		unregister_filesystem(&rootfs_fs_type);
+
+	return err;
+}

commit ca75b4d8799d46842350596fdc5fce7711610326
Author: Toralf Förster <toralf.foerster@gmx.de>
Date:   Wed Jul 3 15:05:38 2013 -0700

    insert missing space in printk line of root_delay
    
    Trivial, but it really looks better.
    
    Signed-off-by: Toralf Förster <toralf.foerster@gmx.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index a2b49f2c1bd8..816014c4627e 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -536,7 +536,7 @@ void __init prepare_namespace(void)
 	int is_floppy;
 
 	if (root_delay) {
-		printk(KERN_INFO "Waiting %dsec before mounting root device...\n",
+		printk(KERN_INFO "Waiting %d sec before mounting root device...\n",
 		       root_delay);
 		ssleep(root_delay);
 	}

commit 9f3b795a626ee79574595e06d1437fe0c7d51d29
Author: Michał Mirosław <mirq-linux@rere.qmqm.pl>
Date:   Fri Feb 1 20:40:17 2013 +0100

    driver-core: constify data for class_find_device()
    
    All in-kernel users of class_find_device() don't really need mutable
    data for match callback.
    
    In two places (kernel/power/suspend_test.c, drivers/scsi/osd/osd_uld.c)
    this patch changes match callbacks to use const search data.
    
    The const is propagated to rtc_class_open() and power_supply_get_by_name()
    parameters.
    
    Note that there's a dev reference leak in suspend_test.c that's not
    touched in this patch.
    
    Signed-off-by: Michał Mirosław <mirq-linux@rere.qmqm.pl>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 1d1b6348f903..a2b49f2c1bd8 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -81,9 +81,9 @@ struct uuidcmp {
  *
  * Returns 1 if the device matches, and 0 otherwise.
  */
-static int match_dev_by_uuid(struct device *dev, void *data)
+static int match_dev_by_uuid(struct device *dev, const void *data)
 {
-	struct uuidcmp *cmp = data;
+	const struct uuidcmp *cmp = data;
 	struct hd_struct *part = dev_to_part(dev);
 
 	if (!part->info)

commit d33b98fc82b0908e91fb05ae081acaed7323f9d2
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Nov 8 16:12:28 2012 -0800

    block: partition: msdos: provide UUIDs for partitions
    
    The MSDOS/MBR partition table includes a 32-bit unique ID, often referred
    to as the NT disk signature.  When combined with a partition number within
    the table, this can form a unique ID similar in concept to EFI/GPT's
    partition UUID.  Constructing and recording this value in struct
    partition_meta_info allows MSDOS partitions to be referred to on the
    kernel command-line using the following syntax:
    
    root=PARTUUID=0002dd75-01
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Will Drewry <wad@chromium.org>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index c950d7c93f98..1d1b6348f903 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -189,6 +189,10 @@ static dev_t devt_from_partuuid(const char *uuid_str)
  *	   used when disk name of partitioned disk ends on a digit.
  *	6) PARTUUID=00112233-4455-6677-8899-AABBCCDDEEFF representing the
  *	   unique id of a partition if the partition table provides it.
+ *	   The UUID may be either an EFI/GPT UUID, or refer to an MSDOS
+ *	   partition using the format SSSSSSSS-PP, where SSSSSSSS is a zero-
+ *	   filled hex representation of the 32-bit "NT disk signature", and PP
+ *	   is a zero-filled hex representation of the 1-based partition number.
  *	7) PARTUUID=<UUID>/PARTNROFF=<int> to select a partition in relation to
  *	   a partition with a known unique id.
  *

commit 283f8fc03927b0ef42a2faa60a0df5ec8c612edb
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Nov 8 16:12:27 2012 -0800

    init: reduce PARTUUID min length to 1 from 36
    
    Reduce the minimum length for a root=PARTUUID= parameter to be considered
    valid from 36 to 1.  EFI/GPT partition UUIDs are always exactly 36
    characters long, hence the previous limit.  However, the next patch will
    support DOS/MBR UUIDs too, which have a different, shorter, format.
    Instead of validating any particular length, just ensure that at least
    some non-empty value was given by the user.
    
    Also, consider a missing UUID value to be a parsing error, in the same
    vein as if /PARTNROFF exists and can't be parsed.  As such, make both
    error cases print a message and disable rootwait.  Convert to pr_err while
    we're at it.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Will Drewry <wad@chromium.org>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index b28ec5819325..c950d7c93f98 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -119,27 +119,29 @@ static dev_t devt_from_partuuid(const char *uuid_str)
 	struct gendisk *disk;
 	struct hd_struct *part;
 	int offset = 0;
-
-	if (strlen(uuid_str) < 36)
-		goto done;
+	bool clear_root_wait = false;
+	char *slash;
 
 	cmp.uuid = uuid_str;
-	cmp.len = 36;
 
+	slash = strchr(uuid_str, '/');
 	/* Check for optional partition number offset attributes. */
-	if (uuid_str[36]) {
+	if (slash) {
 		char c = 0;
 		/* Explicitly fail on poor PARTUUID syntax. */
-		if (sscanf(&uuid_str[36],
-			   "/PARTNROFF=%d%c", &offset, &c) != 1) {
-			printk(KERN_ERR "VFS: PARTUUID= is invalid.\n"
-			 "Expected PARTUUID=<valid-uuid-id>[/PARTNROFF=%%d]\n");
-			if (root_wait)
-				printk(KERN_ERR
-				     "Disabling rootwait; root= is invalid.\n");
-			root_wait = 0;
+		if (sscanf(slash + 1,
+			   "PARTNROFF=%d%c", &offset, &c) != 1) {
+			clear_root_wait = true;
 			goto done;
 		}
+		cmp.len = slash - uuid_str;
+	} else {
+		cmp.len = strlen(uuid_str);
+	}
+
+	if (!cmp.len) {
+		clear_root_wait = true;
+		goto done;
 	}
 
 	dev = class_find_device(&block_class, NULL, &cmp,
@@ -164,6 +166,13 @@ static dev_t devt_from_partuuid(const char *uuid_str)
 no_offset:
 	put_device(dev);
 done:
+	if (clear_root_wait) {
+		pr_err("VFS: PARTUUID= is invalid.\n"
+		       "Expected PARTUUID=<valid-uuid-id>[/PARTNROFF=%%d]\n");
+		if (root_wait)
+			pr_err("Disabling rootwait; root= is invalid.\n");
+		root_wait = 0;
+	}
 	return res;
 }
 #endif

commit 1ad7e89940d5ac411928189e1a4a01901dbf590f
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Nov 8 16:12:25 2012 -0800

    block: store partition_meta_info.uuid as a string
    
    This will allow other types of UUID to be stored here, aside from true
    UUIDs.  This also simplifies code that uses this field, since it's usually
    constructed from a, used as a, or compared to other, strings.
    
    Note: A simplistic approach here would be to set uuid_str[36]=0 whenever a
    /PARTNROFF option was found to be present.  However, this modifies the
    input string, and causes subsequent calls to devt_from_partuuid() not to
    see the /PARTNROFF option, which causes different results.  In order to
    avoid misleading future maintainers, this parameter is marked const.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Will Drewry <wad@chromium.org>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index f8a66424360d..b28ec5819325 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -69,23 +69,28 @@ __setup("ro", readonly);
 __setup("rw", readwrite);
 
 #ifdef CONFIG_BLOCK
+struct uuidcmp {
+	const char *uuid;
+	int len;
+};
+
 /**
  * match_dev_by_uuid - callback for finding a partition using its uuid
  * @dev:	device passed in by the caller
- * @data:	opaque pointer to a 36 byte char array with a UUID
+ * @data:	opaque pointer to the desired struct uuidcmp to match
  *
  * Returns 1 if the device matches, and 0 otherwise.
  */
 static int match_dev_by_uuid(struct device *dev, void *data)
 {
-	u8 *uuid = data;
+	struct uuidcmp *cmp = data;
 	struct hd_struct *part = dev_to_part(dev);
 
 	if (!part->info)
 		goto no_match;
 
-	if (memcmp(uuid, part->info->uuid, sizeof(part->info->uuid)))
-			goto no_match;
+	if (strncasecmp(cmp->uuid, part->info->uuid, cmp->len))
+		goto no_match;
 
 	return 1;
 no_match:
@@ -95,7 +100,7 @@ static int match_dev_by_uuid(struct device *dev, void *data)
 
 /**
  * devt_from_partuuid - looks up the dev_t of a partition by its UUID
- * @uuid:	min 36 byte char array containing a hex ascii UUID
+ * @uuid:	char array containing ascii UUID
  *
  * The function will return the first partition which contains a matching
  * UUID value in its partition_meta_info struct.  This does not search
@@ -106,11 +111,11 @@ static int match_dev_by_uuid(struct device *dev, void *data)
  *
  * Returns the matching dev_t on success or 0 on failure.
  */
-static dev_t devt_from_partuuid(char *uuid_str)
+static dev_t devt_from_partuuid(const char *uuid_str)
 {
 	dev_t res = 0;
+	struct uuidcmp cmp;
 	struct device *dev = NULL;
-	u8 uuid[16];
 	struct gendisk *disk;
 	struct hd_struct *part;
 	int offset = 0;
@@ -118,6 +123,9 @@ static dev_t devt_from_partuuid(char *uuid_str)
 	if (strlen(uuid_str) < 36)
 		goto done;
 
+	cmp.uuid = uuid_str;
+	cmp.len = 36;
+
 	/* Check for optional partition number offset attributes. */
 	if (uuid_str[36]) {
 		char c = 0;
@@ -134,10 +142,8 @@ static dev_t devt_from_partuuid(char *uuid_str)
 		}
 	}
 
-	/* Pack the requested UUID in the expected format. */
-	part_pack_uuid(uuid_str, uuid);
-
-	dev = class_find_device(&block_class, NULL, uuid, &match_dev_by_uuid);
+	dev = class_find_device(&block_class, NULL, &cmp,
+				&match_dev_by_uuid);
 	if (!dev)
 		goto done;
 

commit a608ca21f58ee44df5a71ba140e98498f3ebc2cd
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 10 15:25:26 2012 -0400

    vfs: allocate page instead of names_cache buffer in mount_block_root
    
    First, it's incorrect to call putname() after __getname_gfp() since the
    bare __getname_gfp() call skips the auditing code, while putname()
    doesn't.
    
    mount_block_root allocates a PATH_MAX buffer via __getname_gfp, and then
    calls get_fs_names to fill the buffer. That function can call
    get_filesystem_list which assumes that that buffer is a full page in
    size. On arches where PAGE_SIZE != 4k, then this could potentially
    overrun.
    
    In practice, it's hard to imagine the list of filesystem names even
    approaching 4k, but it's best to be safe. Just allocate a page for this
    purpose instead.
    
    With this, we can also remove the __getname_gfp() definition since there
    are no more callers.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index d3f0aeed2d39..f8a66424360d 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -353,8 +353,9 @@ static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 
 void __init mount_block_root(char *name, int flags)
 {
-	char *fs_names = __getname_gfp(GFP_KERNEL
-		| __GFP_NOTRACK_FALSE_POSITIVE);
+	struct page *page = alloc_page(GFP_KERNEL |
+					__GFP_NOTRACK_FALSE_POSITIVE);
+	char *fs_names = page_address(page);
 	char *p;
 #ifdef CONFIG_BLOCK
 	char b[BDEVNAME_SIZE];
@@ -406,7 +407,7 @@ void __init mount_block_root(char *name, int flags)
 #endif
 	panic("VFS: Unable to mount root fs on %s", b);
 out:
-	putname(fs_names);
+	put_page(page);
 }
  
 #ifdef CONFIG_ROOT_NFS

commit c67e5382fb3f312c95d8d01db40fb398e6da454d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 31 16:26:10 2012 -0700

    init: disable sparse checking of the mount.o source files
    
    The init/mount.o source files produce a number of sparse warnings of the
    type:
    
    warning: incorrect type in argument 1 (different address spaces)
       expected char [noderef] <asn:1>*dev_name
       got char *name
    
    This is due to the syscalls expecting some of the arguments to be user
    pointers but they are being passed as kernel pointers.  This is harmless
    but adds a lot of noise to a sparse build.
    
    To limit the noise just disable the sparse checking in the relevant source
    files, but still display a warning so that the user knows this has been
    done.
    
    Since the sparse checking has been disabled we can also remove the __user
    __force casts that are scattered thru the source.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 42b0707c3481..d3f0aeed2d39 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -1,3 +1,13 @@
+/*
+ * Many of the syscalls used in this file expect some of the arguments
+ * to be __user pointers not __kernel pointers.  To limit the sparse
+ * noise, turn off sparse checking for this file.
+ */
+#ifdef __CHECKER__
+#undef __CHECKER__
+#warning "Sparse checking disabled for this file"
+#endif
+
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/ctype.h>
@@ -330,7 +340,7 @@ static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 	if (err)
 		return err;
 
-	sys_chdir((const char __user __force *)"/root");
+	sys_chdir("/root");
 	s = current->fs->pwd.dentry->d_sb;
 	ROOT_DEV = s->s_dev;
 	printk(KERN_INFO
@@ -556,5 +566,5 @@ void __init prepare_namespace(void)
 out:
 	devtmpfs_mount("dev");
 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
-	sys_chroot((const char __user __force *)".");
+	sys_chroot(".");
 }

commit 377485f6244af255b04d662cf19cddbbc4ae4310
Author: Sasha Levin <levinsasha928@gmail.com>
Date:   Sat May 5 17:06:35 2012 +0200

    init: don't try mounting device as nfs root unless type fully matches
    
    Currently, we'll try mounting any device who's major device number is
    UNNAMED_MAJOR as NFS root.  This would happen for non-NFS devices as
    well (such as 9p devices) but it wouldn't cause any issues since
    mounting the device as NFS would fail quickly and the code proceeded to
    doing the proper mount:
    
           [  101.522716] VFS: Unable to mount root fs via NFS, trying floppy.
           [  101.534499] VFS: Mounted root (9p filesystem) on device 0:18.
    
    Commit 6829a048102a ("NFS: Retry mounting NFSROOT") introduced retries
    when mounting NFS root, which means that now we don't immediately fail
    and instead it takes an additional 90+ seconds until we stop retrying,
    which has revealed the issue this patch fixes.
    
    This meant that it would take an additional 90 seconds to boot when
    we're not using a device type which gets detected in order before NFS.
    
    This patch modifies the NFS type check to require device type to be
    'Root_NFS' instead of requiring the device to have an UNNAMED_MAJOR
    major.  This makes boot process cleaner since we now won't go through
    the NFS mounting code at all when the device isn't an NFS root
    ("/dev/nfs").
    
    Signed-off-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 0e93f92a0345..42b0707c3481 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -472,7 +472,7 @@ void __init change_floppy(char *fmt, ...)
 void __init mount_root(void)
 {
 #ifdef CONFIG_ROOT_NFS
-	if (MAJOR(ROOT_DEV) == UNNAMED_MAJOR) {
+	if (ROOT_DEV == Root_NFS) {
 		if (mount_nfs_root())
 			return;
 

commit 0e0cb892a8dac7c76321c899934705e5f0812574
Author: Bernhard Walle <bernhard@bwalle.de>
Date:   Fri Mar 23 15:02:28 2012 -0700

    init/do_mounts.c: print error code on mount failure
    
    Printing the error code makes it easier to debug the cause of a mount
    failure.  For example I had the problem that the root file system could
    not be mounted read-writeable because my SD card was write-protected.
    Without an error code it looks like the SD card was not detected at all.
    
    Signed-off-by: Bernhard Walle <bernhard@bwalle.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 2974c8b3b351..0e93f92a0345 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -373,8 +373,8 @@ void __init mount_block_root(char *name, int flags)
 #ifdef CONFIG_BLOCK
 		__bdevname(ROOT_DEV, b);
 #endif
-		printk("VFS: Cannot open root device \"%s\" or %s\n",
-				root_device_name, b);
+		printk("VFS: Cannot open root device \"%s\" or %s: error %d\n",
+				root_device_name, b, err);
 		printk("Please append a correct \"root=\" boot option; here are the available partitions:\n");
 
 		printk_all_partitions();

commit 57eccf1c2acae2fcb748730881ba75643fc31c81
Merge: 5c395ae70330 074b1d12fe25
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 10 14:57:40 2012 -0800

    Merge branch 'nfs-for-3.3' of git://git.linux-nfs.org/projects/trondmy/linux-nfs
    
    * 'nfs-for-3.3' of git://git.linux-nfs.org/projects/trondmy/linux-nfs:
      NFSv4: Change the default setting of the nfs4_disable_idmapping parameter
      NFSv4: Save the owner/group name string when doing open
      NFS: Remove pNFS bloat from the generic write path
      pnfs-obj: Must return layout on IO error
      pnfs-obj: pNFS errors are communicated on iodata->pnfs_error
      NFS: Cache state owners after files are closed
      NFS: Clean up nfs4_find_state_owners_locked()
      NFSv4: include bitmap in nfsv4 get acl data
      nfs: fix a minor do_div portability issue
      NFSv4.1: cleanup comment and debug printk
      NFSv4.1: change nfs4_free_slot parameters for dynamic slots
      NFSv4.1: cleanup init and reset of session slot tables
      NFSv4.1: fix backchannel slotid off-by-one bug
      nfs: fix regression in handling of context= option in NFSv4
      NFS - fix recent breakage to NFS error handling.
      NFS: Retry mounting NFSROOT
      SUNRPC: Clean up the RPCSEC_GSS service ticket requests

commit d8c9584ea2a92879f471fd3a2be3af6c534fb035
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Dec 7 18:16:57 2011 -0500

    vfs: prefer ->dentry->d_sb to ->mnt->mnt_sb
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 0f6e1d985a3b..b2eee02e0f83 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -325,17 +325,19 @@ static void __init get_fs_names(char *page)
 
 static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 {
+	struct super_block *s;
 	int err = sys_mount(name, "/root", fs, flags, data);
 	if (err)
 		return err;
 
 	sys_chdir((const char __user __force *)"/root");
-	ROOT_DEV = current->fs->pwd.mnt->mnt_sb->s_dev;
+	s = current->fs->pwd.dentry->d_sb;
+	ROOT_DEV = s->s_dev;
 	printk(KERN_INFO
 	       "VFS: Mounted root (%s filesystem)%s on device %u:%u.\n",
-	       current->fs->pwd.mnt->mnt_sb->s_type->name,
-	       current->fs->pwd.mnt->mnt_sb->s_flags & MS_RDONLY ?
-	       " readonly" : "", MAJOR(ROOT_DEV), MINOR(ROOT_DEV));
+	       s->s_type->name,
+	       s->s_flags & MS_RDONLY ?  " readonly" : "",
+	       MAJOR(ROOT_DEV), MINOR(ROOT_DEV));
 	return 0;
 }
 

commit 43717c7daebf10b43f12e68512484b3095bb1ba5
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Dec 5 15:40:30 2011 -0500

    NFS: Retry mounting NFSROOT
    
    Lukas Razik <linux@razik.name> reports that on his SPARC system,
    booting with an NFS root file system stopped working after commit
    56463e50 "NFS: Use super.c for NFSROOT mount option parsing."
    
    We found that the network switch to which Lukas' client was attached
    was delaying access to the LAN after the client's NIC driver reported
    that its link was up.  The delay was longer than the timeouts used in
    the NFS client during mounting.
    
    NFSROOT worked for Lukas before commit 56463e50 because in those
    kernels, the client's first operation was an rpcbind request to
    determine which port the NFS server was listening on.  When that
    request failed after a long timeout, the client simply selected the
    default NFS port (2049).  By that time the switch was allowing access
    to the LAN, and the mount succeeded.
    
    Neither of these client behaviors is desirable, so reverting 56463e50
    is really not a choice.  Instead, introduce a mechanism that retries
    the NFSROOT mount request several times.  This is the same tactic that
    normal user space NFS mounts employ to overcome server and network
    delays.
    
    Signed-off-by: Lukas Razik <linux@razik.name>
    [ cel: match kernel coding style, add proper patch description ]
    [ cel: add exponential back-off ]
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Tested-by: Lukas Razik <linux@razik.name>
    Cc: stable@kernel.org # > 2.6.38
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 0f6e1d985a3b..db6e5ee0e1db 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -398,15 +398,42 @@ void __init mount_block_root(char *name, int flags)
 }
  
 #ifdef CONFIG_ROOT_NFS
+
+#define NFSROOT_TIMEOUT_MIN	5
+#define NFSROOT_TIMEOUT_MAX	30
+#define NFSROOT_RETRY_MAX	5
+
 static int __init mount_nfs_root(void)
 {
 	char *root_dev, *root_data;
+	unsigned int timeout;
+	int try, err;
 
-	if (nfs_root_data(&root_dev, &root_data) != 0)
-		return 0;
-	if (do_mount_root(root_dev, "nfs", root_mountflags, root_data) != 0)
+	err = nfs_root_data(&root_dev, &root_data);
+	if (err != 0)
 		return 0;
-	return 1;
+
+	/*
+	 * The server or network may not be ready, so try several
+	 * times.  Stop after a few tries in case the client wants
+	 * to fall back to other boot methods.
+	 */
+	timeout = NFSROOT_TIMEOUT_MIN;
+	for (try = 1; ; try++) {
+		err = do_mount_root(root_dev, "nfs",
+					root_mountflags, root_data);
+		if (err == 0)
+			return 1;
+		if (try > NFSROOT_RETRY_MAX)
+			break;
+
+		/* Wait, in case the server refused us immediately */
+		ssleep(timeout);
+		timeout <<= 1;
+		if (timeout > NFSROOT_TIMEOUT_MAX)
+			timeout = NFSROOT_TIMEOUT_MAX;
+	}
+	return 0;
 }
 #endif
 

commit 79975f1327850ef198ada994c2fc44b7d1ea8935
Author: Will Drewry <wad@chromium.org>
Date:   Wed Nov 2 13:38:59 2011 -0700

    init: add root=PARTUUID=UUID/PARTNROFF=%d support
    
    Expand root=PARTUUID=UUID syntax to support selecting a root partition by
    integer offset from a known, unique partition.  This approach provides
    similar properties to specifying a device and partition number, but using
    the UUID as the unique path prior to evaluating the offset.
    
    For example,
      root=PARTUUID=99DE9194-FC15-4223-9192-FC243948F88B/PARTNROFF=1
    selects the partition with UUID 99DE.. then select the next
    partition.
    
    This change is motivated by a particular usecase in Chromium OS where the
    bootloader can easily determine what partition it is on (by UUID) but
    doesn't perform general partition table walking.
    
    That said, support for this model provides a direct mechanism for the user
    to modify the root partition to boot without specifically needing to
    extract each UUID or update the bootloader explicitly when the root
    partition UUID is changed (if it is recreated to be larger, for instance).
     Pinning to a /boot-style partition UUID allows the arbitrary root
    partition reconfiguration/modifications with slightly less ambiguity than
    just [dev][partition] and less stringency than the specific root partition
    UUID.
    
    [sfr@canb.auug.org.au: fix init sections warning]
    Signed-off-by: Will Drewry <wad@chromium.org>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index c0851a8e030c..0f6e1d985a3b 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -28,7 +28,7 @@ int __initdata rd_doload;	/* 1 = load RAM disk, 0 = don't load */
 int root_mountflags = MS_RDONLY | MS_SILENT;
 static char * __initdata root_device_name;
 static char __initdata saved_root_name[64];
-static int __initdata root_wait;
+static int root_wait;
 
 dev_t ROOT_DEV;
 
@@ -85,12 +85,15 @@ static int match_dev_by_uuid(struct device *dev, void *data)
 
 /**
  * devt_from_partuuid - looks up the dev_t of a partition by its UUID
- * @uuid:	36 byte char array containing a hex ascii UUID
+ * @uuid:	min 36 byte char array containing a hex ascii UUID
  *
  * The function will return the first partition which contains a matching
  * UUID value in its partition_meta_info struct.  This does not search
  * by filesystem UUIDs.
  *
+ * If @uuid is followed by a "/PARTNROFF=%d", then the number will be
+ * extracted and used as an offset from the partition identified by the UUID.
+ *
  * Returns the matching dev_t on success or 0 on failure.
  */
 static dev_t devt_from_partuuid(char *uuid_str)
@@ -98,6 +101,28 @@ static dev_t devt_from_partuuid(char *uuid_str)
 	dev_t res = 0;
 	struct device *dev = NULL;
 	u8 uuid[16];
+	struct gendisk *disk;
+	struct hd_struct *part;
+	int offset = 0;
+
+	if (strlen(uuid_str) < 36)
+		goto done;
+
+	/* Check for optional partition number offset attributes. */
+	if (uuid_str[36]) {
+		char c = 0;
+		/* Explicitly fail on poor PARTUUID syntax. */
+		if (sscanf(&uuid_str[36],
+			   "/PARTNROFF=%d%c", &offset, &c) != 1) {
+			printk(KERN_ERR "VFS: PARTUUID= is invalid.\n"
+			 "Expected PARTUUID=<valid-uuid-id>[/PARTNROFF=%%d]\n");
+			if (root_wait)
+				printk(KERN_ERR
+				     "Disabling rootwait; root= is invalid.\n");
+			root_wait = 0;
+			goto done;
+		}
+	}
 
 	/* Pack the requested UUID in the expected format. */
 	part_pack_uuid(uuid_str, uuid);
@@ -107,8 +132,21 @@ static dev_t devt_from_partuuid(char *uuid_str)
 		goto done;
 
 	res = dev->devt;
-	put_device(dev);
 
+	/* Attempt to find the partition by offset. */
+	if (!offset)
+		goto no_offset;
+
+	res = 0;
+	disk = part_to_disk(dev_to_part(dev));
+	part = disk_get_part(disk, dev_to_part(dev)->partno + offset);
+	if (part) {
+		res = part_devt(part);
+		put_device(part_to_dev(part));
+	}
+
+no_offset:
+	put_device(dev);
 done:
 	return res;
 }
@@ -126,6 +164,8 @@ static dev_t devt_from_partuuid(char *uuid_str)
  *	   used when disk name of partitioned disk ends on a digit.
  *	6) PARTUUID=00112233-4455-6677-8899-AABBCCDDEEFF representing the
  *	   unique id of a partition if the partition table provides it.
+ *	7) PARTUUID=<UUID>/PARTNROFF=<int> to select a partition in relation to
+ *	   a partition with a known unique id.
  *
  *	If name doesn't have fall into the categories above, we return (0,0).
  *	block_class is used to check if something is a disk name. If the disk
@@ -143,8 +183,6 @@ dev_t name_to_dev_t(char *name)
 #ifdef CONFIG_BLOCK
 	if (strncmp(name, "PARTUUID=", 9) == 0) {
 		name += 9;
-		if (strlen(name) != 36)
-			goto fail;
 		res = devt_from_partuuid(name);
 		if (!res)
 			goto fail;

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 3e0112157795..c0851a8e030c 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -186,7 +186,7 @@ dev_t name_to_dev_t(char *name)
 		goto done;
 
 	/*
-	 * try non-existant, but valid partition, which may only exist
+	 * try non-existent, but valid partition, which may only exist
 	 * after revalidating the disk, like partitioned md devices
 	 */
 	while (p > s && isdigit(p[-1]))

commit 80cdc6dae76ea67d2b21bdca8df17ef47251eb8b
Author: Mandeep Singh Baines <msb@chromium.org>
Date:   Tue Mar 22 16:33:54 2011 -0700

    fs: use appropriate printk priority levels
    
    printk()s without a priority level default to KERN_WARNING.  To reduce
    noise at KERN_WARNING, this patch set the priority level appriopriately
    for unleveled printks()s.  This should be useful to folks that look at
    dmesg warnings closely.
    
    Signed-off-by: Mandeep Singh Baines <msb@chromium.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 2b54bef33b55..3e0112157795 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -293,7 +293,8 @@ static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 
 	sys_chdir((const char __user __force *)"/root");
 	ROOT_DEV = current->fs->pwd.mnt->mnt_sb->s_dev;
-	printk("VFS: Mounted root (%s filesystem)%s on device %u:%u.\n",
+	printk(KERN_INFO
+	       "VFS: Mounted root (%s filesystem)%s on device %u:%u.\n",
 	       current->fs->pwd.mnt->mnt_sb->s_type->name,
 	       current->fs->pwd.mnt->mnt_sb->s_flags & MS_RDONLY ?
 	       " readonly" : "", MAJOR(ROOT_DEV), MINOR(ROOT_DEV));

commit a1cf11d8f673a3ad91012c5da96beed06ecefde1
Author: Jan Beulich <JBeulich@novell.com>
Date:   Mon Jan 3 15:07:02 2011 +0000

    name_to_dev_t() must not call __init code
    
    The function can't be __init itself (being called from some sysfs
    handler), and hence none of the functions it calls can be either.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 830aaec9c7d5..2b54bef33b55 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -93,7 +93,7 @@ static int match_dev_by_uuid(struct device *dev, void *data)
  *
  * Returns the matching dev_t on success or 0 on failure.
  */
-static dev_t __init devt_from_partuuid(char *uuid_str)
+static dev_t devt_from_partuuid(char *uuid_str)
 {
 	dev_t res = 0;
 	struct device *dev = NULL;

commit 562f5e638de4ef451226552fe8dd7847bacea24e
Author: Namhyung Kim <namhyung@gmail.com>
Date:   Tue Oct 26 14:22:42 2010 -0700

    init: mark __user address space on string literals
    
    When calling syscall service routines in kernel, some of arguments should
    be user pointers but were missing __user markup on string literals.  Add
    it.  Removes some sparse warnings.
    
    Signed-off-by: Namhyung Kim <namhyung@gmail.com>
    Cc: Phillip Lougher <phillip@lougher.demon.co.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 62a47eafa8e9..830aaec9c7d5 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -291,7 +291,7 @@ static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 	if (err)
 		return err;
 
-	sys_chdir("/root");
+	sys_chdir((const char __user __force *)"/root");
 	ROOT_DEV = current->fs->pwd.mnt->mnt_sb->s_dev;
 	printk("VFS: Mounted root (%s filesystem)%s on device %u:%u.\n",
 	       current->fs->pwd.mnt->mnt_sb->s_type->name,
@@ -488,5 +488,5 @@ void __init prepare_namespace(void)
 out:
 	devtmpfs_mount("dev");
 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
-	sys_chroot(".");
+	sys_chroot((const char __user __force *)".");
 }

commit 74eb94b218d087798a52c0b4f1379b635287a4b8
Merge: 7b6181e06841 9a84d38031c2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 25 13:48:29 2010 -0700

    Merge branch 'nfs-for-2.6.37' of git://git.linux-nfs.org/projects/trondmy/nfs-2.6
    
    * 'nfs-for-2.6.37' of git://git.linux-nfs.org/projects/trondmy/nfs-2.6: (67 commits)
      SUNRPC: Cleanup duplicate assignment in rpcauth_refreshcred
      nfs: fix unchecked value
      Ask for time_delta during fsinfo probe
      Revalidate caches on lock
      SUNRPC: After calling xprt_release(), we must restart from call_reserve
      NFSv4: Fix up the 'dircount' hint in encode_readdir
      NFSv4: Clean up nfs4_decode_dirent
      NFSv4: nfs4_decode_dirent must clear entry->fattr->valid
      NFSv4: Fix a regression in decode_getfattr
      NFSv4: Fix up decode_attr_filehandle() to handle the case of empty fh pointer
      NFS: Ensure we check all allocation return values in new readdir code
      NFS: Readdir plus in v4
      NFS: introduce generic decode_getattr function
      NFS: check xdr_decode for errors
      NFS: nfs_readdir_filler catch all errors
      NFS: readdir with vmapped pages
      NFS: remove page size checking code
      NFS: decode_dirent should use an xdr_stream
      SUNRPC: Add a helper function xdr_inline_peek
      NFS: remove readdir plus limit
      ...

commit 56463e50d1fc3f070492434cea6303b35ea000de
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri Sep 17 10:54:37 2010 -0400

    NFS: Use super.c for NFSROOT mount option parsing
    
    Replace duplicate code in NFSROOT for mounting an NFS server on '/'
    with logic that uses the existing mainline text-based logic in the NFS
    client.
    
    Add documenting comments where appropriate.
    
    Note that this means NFSROOT mounts now use the same default settings
    as v2/v3 mounts done via mount(2) from user space.
    
      vers=3,tcp,rsize=<negotiated default>,wsize=<negotiated default>
    
    As before, however, no version/protocol negotiation with the server is
    done.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 02e3ca4fc527..52387f14f9b4 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -291,13 +291,13 @@ void __init mount_block_root(char *name, int flags)
 #ifdef CONFIG_ROOT_NFS
 static int __init mount_nfs_root(void)
 {
-	void *data = nfs_root_data();
+	char *root_dev, *root_data;
 
-	create_dev("/dev/root", ROOT_DEV);
-	if (data &&
-	    do_mount_root("/dev/root", "nfs", root_mountflags, data) == 0)
-		return 1;
-	return 0;
+	if (nfs_root_data(&root_dev, &root_data) != 0)
+		return 0;
+	if (do_mount_root(root_dev, "nfs", root_mountflags, root_data) != 0)
+		return 0;
+	return 1;
 }
 #endif
 

commit 6d0aed7a38d06284db2a0e46c0a072b0c1c3299b
Author: Jens Axboe <jaxboe@fusionio.com>
Date:   Fri Sep 17 10:00:46 2010 +0200

    do_mounts: only enable PARTUUID for CONFIG_BLOCK
    
    When CONFIG_BLOCK is not enabled:
    
    init/do_mounts.c:71: error: implicit declaration of function 'dev_to_part'
    init/do_mounts.c:71: warning: initialization makes pointer from integer without a cast
    init/do_mounts.c:73: error: dereferencing pointer to incomplete type
    init/do_mounts.c:76: error: dereferencing pointer to incomplete type
    init/do_mounts.c:76: error: dereferencing pointer to incomplete type
    init/do_mounts.c:102: error: implicit declaration of function 'part_pack_uuid'
    init/do_mounts.c:104: error: 'block_class' undeclared (first use in this function)
    
    Reported-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index b7fc83994f39..42db0551c3aa 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -58,6 +58,7 @@ static int __init readwrite(char *str)
 __setup("ro", readonly);
 __setup("rw", readwrite);
 
+#ifdef CONFIG_BLOCK
 /**
  * match_dev_by_uuid - callback for finding a partition using its uuid
  * @dev:	device passed in by the caller
@@ -111,6 +112,7 @@ static dev_t __init devt_from_partuuid(char *uuid_str)
 done:
 	return res;
 }
+#endif
 
 /*
  *	Convert a name into device number.  We accept the following variants:
@@ -138,6 +140,7 @@ dev_t name_to_dev_t(char *name)
 	dev_t res = 0;
 	int part;
 
+#ifdef CONFIG_BLOCK
 	if (strncmp(name, "PARTUUID=", 9) == 0) {
 		name += 9;
 		if (strlen(name) != 36)
@@ -147,6 +150,7 @@ dev_t name_to_dev_t(char *name)
 			goto fail;
 		goto done;
 	}
+#endif
 
 	if (strncmp(name, "/dev/", 5) != 0) {
 		unsigned maj, min;

commit 38b6f45a97bbb8536cc7d095b577f580bd4d643e
Author: Jens Axboe <jaxboe@fusionio.com>
Date:   Thu Sep 16 08:33:54 2010 +0200

    core: match_dev_by_uuid() should not be marked __init
    
    It is also called outside the scope of init functions. Stephen
    reports:
    
    WARNING: init/mounts.o(.text+0x21a): Section mismatch in reference from the function name_to_dev_t() to the function .init.text:match_dev_by_uuid()
    The function name_to_dev_t() references
    the function __init match_dev_by_uuid().
    This is often because name_to_dev_t lacks a __init
    annotation or the annotation of match_dev_by_uuid is wrong.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 804f9c6ba216..b7fc83994f39 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -65,7 +65,7 @@ __setup("rw", readwrite);
  *
  * Returns 1 if the device matches, and 0 otherwise.
  */
-static int __init match_dev_by_uuid(struct device *dev, void *data)
+static int match_dev_by_uuid(struct device *dev, void *data)
 {
 	u8 *uuid = data;
 	struct hd_struct *part = dev_to_part(dev);

commit b5af921ec02333e943efb59aca4f56b78fc0e100
Author: Will Drewry <wad@chromium.org>
Date:   Tue Aug 31 15:47:07 2010 -0500

    init: add support for root devices specified by partition UUID
    
    This is the third patch in a series which adds support for
    storing partition metadata, optionally, off of the hd_struct.
    
    One major use for that data is being able to resolve partition
    by other identities than just the index on a block device.  Device
    enumeration varies by platform and there's a benefit to being able
    to use something like EFI GPT's GUIDs to determine the correct
    block device and partition to mount as the root.
    
    This change adds that support to root= by adding support for
    the following syntax:
    
      root=PARTUUID=hex-uuid
    
    Signed-off-by: Will Drewry <wad@chromium.org>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 02e3ca4fc527..804f9c6ba216 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -58,6 +58,60 @@ static int __init readwrite(char *str)
 __setup("ro", readonly);
 __setup("rw", readwrite);
 
+/**
+ * match_dev_by_uuid - callback for finding a partition using its uuid
+ * @dev:	device passed in by the caller
+ * @data:	opaque pointer to a 36 byte char array with a UUID
+ *
+ * Returns 1 if the device matches, and 0 otherwise.
+ */
+static int __init match_dev_by_uuid(struct device *dev, void *data)
+{
+	u8 *uuid = data;
+	struct hd_struct *part = dev_to_part(dev);
+
+	if (!part->info)
+		goto no_match;
+
+	if (memcmp(uuid, part->info->uuid, sizeof(part->info->uuid)))
+			goto no_match;
+
+	return 1;
+no_match:
+	return 0;
+}
+
+
+/**
+ * devt_from_partuuid - looks up the dev_t of a partition by its UUID
+ * @uuid:	36 byte char array containing a hex ascii UUID
+ *
+ * The function will return the first partition which contains a matching
+ * UUID value in its partition_meta_info struct.  This does not search
+ * by filesystem UUIDs.
+ *
+ * Returns the matching dev_t on success or 0 on failure.
+ */
+static dev_t __init devt_from_partuuid(char *uuid_str)
+{
+	dev_t res = 0;
+	struct device *dev = NULL;
+	u8 uuid[16];
+
+	/* Pack the requested UUID in the expected format. */
+	part_pack_uuid(uuid_str, uuid);
+
+	dev = class_find_device(&block_class, NULL, uuid, &match_dev_by_uuid);
+	if (!dev)
+		goto done;
+
+	res = dev->devt;
+	put_device(dev);
+
+done:
+	return res;
+}
+
 /*
  *	Convert a name into device number.  We accept the following variants:
  *
@@ -68,6 +122,8 @@ __setup("rw", readwrite);
  *         of partition - device number of disk plus the partition number
  *	5) /dev/<disk_name>p<decimal> - same as the above, that form is
  *	   used when disk name of partitioned disk ends on a digit.
+ *	6) PARTUUID=00112233-4455-6677-8899-AABBCCDDEEFF representing the
+ *	   unique id of a partition if the partition table provides it.
  *
  *	If name doesn't have fall into the categories above, we return (0,0).
  *	block_class is used to check if something is a disk name. If the disk
@@ -82,6 +138,16 @@ dev_t name_to_dev_t(char *name)
 	dev_t res = 0;
 	int part;
 
+	if (strncmp(name, "PARTUUID=", 9) == 0) {
+		name += 9;
+		if (strlen(name) != 36)
+			goto fail;
+		res = devt_from_partuuid(name);
+		if (!res)
+			goto fail;
+		goto done;
+	}
+
 	if (strncmp(name, "/dev/", 5) != 0) {
 		unsigned maj, min;
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index bb008d064c1a..02e3ca4fc527 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -15,6 +15,7 @@
 #include <linux/initrd.h>
 #include <linux/async.h>
 #include <linux/fs_struct.h>
+#include <linux/slab.h>
 
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>

commit 2b2af54a5bb6f7e80ccf78f20084b93c398c3a8b
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Apr 30 15:23:42 2009 +0200

    Driver Core: devtmpfs - kernel-maintained tmpfs-based /dev
    
    Devtmpfs lets the kernel create a tmpfs instance called devtmpfs
    very early at kernel initialization, before any driver-core device
    is registered. Every device with a major/minor will provide a
    device node in devtmpfs.
    
    Devtmpfs can be changed and altered by userspace at any time,
    and in any way needed - just like today's udev-mounted tmpfs.
    Unmodified udev versions will run just fine on top of it, and will
    recognize an already existing kernel-created device node and use it.
    The default node permissions are root:root 0600. Proper permissions
    and user/group ownership, meaningful symlinks, all other policy still
    needs to be applied by userspace.
    
    If a node is created by devtmps, devtmpfs will remove the device node
    when the device goes away. If the device node was created by
    userspace, or the devtmpfs created node was replaced by userspace, it
    will no longer be removed by devtmpfs.
    
    If it is requested to auto-mount it, it makes init=/bin/sh work
    without any further userspace support. /dev will be fully populated
    and dynamic, and always reflect the current device state of the kernel.
    With the commonly used dynamic device numbers, it solves the problem
    where static devices nodes may point to the wrong devices.
    
    It is intended to make the initial bootup logic simpler and more robust,
    by de-coupling the creation of the inital environment, to reliably run
    userspace processes, from a complex userspace bootstrap logic to provide
    a working /dev.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Tested-By: Harald Hoyer <harald@redhat.com>
    Tested-By: Scott James Remnant <scott@ubuntu.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 093f65915501..bb008d064c1a 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -415,7 +415,7 @@ void __init prepare_namespace(void)
 
 	mount_root();
 out:
+	devtmpfs_mount("dev");
 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
 	sys_chroot(".");
 }
-

commit 3b5c760efcddf1ebdd39a2035b554e96febd7466
Author: Vegard Nossum <vegard.nossum@gmail.com>
Date:   Sat May 16 11:26:20 2009 +0200

    fs: fix do_mount_root() false positive kmemcheck warning
    
    This false positive is due to the fact that do_mount_root() fakes a
    mount option (which is normally read from userspace), and the kernel
    unconditionally reads a whole page for the mount option.
    
    Hide the false positive by using the new __getname_gfp() with the
    __GFP_NOTRACK_FALSE_POSITIVE flag.
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Vegard Nossum <vegard.nossum@gmail.com>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index dd7ee5f203f3..093f65915501 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -231,7 +231,8 @@ static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 
 void __init mount_block_root(char *name, int flags)
 {
-	char *fs_names = __getname();
+	char *fs_names = __getname_gfp(GFP_KERNEL
+		| __GFP_NOTRACK_FALSE_POSITIVE);
 	char *p;
 #ifdef CONFIG_BLOCK
 	char b[BDEVNAME_SIZE];

commit 5ad4e53bd5406ee214ddc5a41f03f779b8b2d526
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 29 19:50:06 2009 -0400

    Get rid of indirect include of fs_struct.h
    
    Don't pull it in sched.h; very few files actually need it and those
    can include directly.  sched.h itself only needs forward declaration
    of struct fs_struct;
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 8d4ff5afc1d8..dd7ee5f203f3 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -14,6 +14,7 @@
 #include <linux/fs.h>
 #include <linux/initrd.h>
 #include <linux/async.h>
+#include <linux/fs_struct.h>
 
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>

commit 216773a787c3c46ef26bf1742c1fdba37d26be45
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Sat Feb 14 01:59:06 2009 +0100

    Consolidate driver_probe_done() loops into one place
    
    there's a few places that currently loop over driver_probe_done(), and
    I'm about to add another one. This patch abstracts it into a helper
    to reduce duplication.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Len Brown <lenb@kernel.org>
    Acked-by: Greg KH <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 708105e163df..8d4ff5afc1d8 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -370,10 +370,14 @@ void __init prepare_namespace(void)
 		ssleep(root_delay);
 	}
 
-	/* wait for the known devices to complete their probing */
-	while (driver_probe_done() != 0)
-		msleep(100);
-	async_synchronize_full();
+	/*
+	 * wait for the known devices to complete their probing
+	 *
+	 * Note: this is a potential source of long boot delays.
+	 * For example, it is not atypical to wait 5 seconds here
+	 * for the touchpad of a laptop to initialize.
+	 */
+	wait_for_device_probe();
 
 	md_run_setup();
 
@@ -399,6 +403,7 @@ void __init prepare_namespace(void)
 		while (driver_probe_done() != 0 ||
 			(ROOT_DEV = name_to_dev_t(saved_root_name)) == 0)
 			msleep(100);
+		async_synchronize_full();
 	}
 
 	is_floppy = MAJOR(ROOT_DEV) == FLOPPY_MAJOR;

commit 22a9d645677feefd402befd02edd59b122289ef1
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Wed Jan 7 08:45:46 2009 -0800

    async: Asynchronous function calls to speed up kernel boot
    
    Right now, most of the kernel boot is strictly synchronous, such that
    various hardware delays are done sequentially.
    
    In order to make the kernel boot faster, this patch introduces
    infrastructure to allow doing some of the initialization steps
    asynchronously, which will hide significant portions of the hardware delays
    in practice.
    
    In order to not change device order and other similar observables, this
    patch does NOT do full parallel initialization.
    
    Rather, it operates more in the way an out of order CPU does; the work may
    be done out of order and asynchronous, but the observable effects
    (instruction retiring for the CPU) are still done in the original sequence.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 5efca73b39f9..708105e163df 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -13,6 +13,7 @@
 #include <linux/init.h>
 #include <linux/fs.h>
 #include <linux/initrd.h>
+#include <linux/async.h>
 
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>
@@ -372,6 +373,7 @@ void __init prepare_namespace(void)
 	/* wait for the known devices to complete their probing */
 	while (driver_probe_done() != 0)
 		msleep(100);
+	async_synchronize_full();
 
 	md_run_setup();
 

commit bca1033b092a6fab2ed00036e8a7f6e2df5d99a2
Author: Marton Balint <cus@fazekas.hu>
Date:   Tue Jan 6 14:40:43 2009 -0800

    do_mounts: add device info to mount message
    
    In the past, I used the root=...  command line parameter to specify the
    root filesystem to the kernel.  Now it seems that specifying it is not
    necessary.  The kernel detects the root filesystem even if the kernel
    command line is empty.  My root fs is on a raid1 device by the way, and I
    am not using initrd for the boot process.
    
    If the kernel detects the root filesystem somehow, I think it should print
    out the result of this detection, otherwise I will not know which device
    has the root filesystem.  Or is there an easy way to get this information
    on a running system?  I had a quick look at the /proc and /sys
    filesystems, but haven't found anything useful there.
    
    Signed-off-by: Marton Balint <cus@fazekas.hu>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index d055b1914c3d..5efca73b39f9 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -220,10 +220,10 @@ static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 
 	sys_chdir("/root");
 	ROOT_DEV = current->fs->pwd.mnt->mnt_sb->s_dev;
-	printk("VFS: Mounted root (%s filesystem)%s.\n",
+	printk("VFS: Mounted root (%s filesystem)%s on device %u:%u.\n",
 	       current->fs->pwd.mnt->mnt_sb->s_type->name,
 	       current->fs->pwd.mnt->mnt_sb->s_flags & MS_RDONLY ?
-	       " readonly" : "");
+	       " readonly" : "", MAJOR(ROOT_DEV), MINOR(ROOT_DEV));
 	return 0;
 }
 

commit 55dc7db70a73a3809a2334063c9b5b0d8ccebdaa
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Sep 1 13:44:35 2008 +0200

    init: DEBUG_BLOCK_EXT_DEVT requires explicit root= param
    
    DEBUG_BLOCK_EXT_DEVT shuffles SCSI and IDE device numbers and root
    device number set using rdev become meaningless.  Root devices should
    be explicitly specified using textual names.  Warn about it if root
    can't be found and DEBUG_BLOCK_EXT_DEVT is enabled.  Also, add warning
    to the help text.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 3715feb8446d..d055b1914c3d 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -263,6 +263,10 @@ void __init mount_block_root(char *name, int flags)
 		printk("Please append a correct \"root=\" boot option; here are the available partitions:\n");
 
 		printk_all_partitions();
+#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
+		printk("DEBUG_BLOCK_EXT_DEVT is enabled, you need to specify "
+		       "explicit textual name for \"root=\" boot option.\n");
+#endif
 		panic("VFS: Unable to mount root fs on %s", b);
 	}
 

commit f56f6d30c75984d0aba2656eaeb35f3806395191
Author: Adrian Bunk <bunk@kernel.org>
Date:   Fri Jul 25 19:46:25 2008 -0700

    make init/do_mounts.c:root_device_name static
    
    This patch makes the needlessly global root_device_name static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index f769fac4f4c0..3715feb8446d 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -23,7 +23,7 @@
 int __initdata rd_doload;	/* 1 = load RAM disk, 0 = don't load */
 
 int root_mountflags = MS_RDONLY | MS_SILENT;
-char * __initdata root_device_name;
+static char * __initdata root_device_name;
 static char __initdata saved_root_name[64];
 static int __initdata root_wait;
 

commit 82c8253ac27291d6c70114eb445c714359812a10
Author: Adrian Bunk <bunk@kernel.org>
Date:   Fri Jul 25 01:45:29 2008 -0700

    init/do_mounts.c should #include <linux/initrd.h>
    
    Every file should include the headers containing the externs for its
    global code (in this case for rd_doload).
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index a1de1bf3d6b9..f769fac4f4c0 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -12,6 +12,7 @@
 #include <linux/device.h>
 #include <linux/init.h>
 #include <linux/fs.h>
+#include <linux/initrd.h>
 
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>

commit 2d62f488585405bc9108c47cb06957397cfd1059
Author: Adrian Hunter <ext-adrian.hunter@nokia.com>
Date:   Thu Jan 31 17:25:00 2008 +0200

    do_mounts: allow UBI root device name
    
    Similarly to MTD devices, allow UBI devices.
    
    Signed-off-by: Adrian Hunter <ext-adrian.hunter@nokia.com>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 660c1e50c91b..a1de1bf3d6b9 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -372,7 +372,8 @@ void __init prepare_namespace(void)
 
 	if (saved_root_name[0]) {
 		root_device_name = saved_root_name;
-		if (!strncmp(root_device_name, "mtd", 3)) {
+		if (!strncmp(root_device_name, "mtd", 3) ||
+		    !strncmp(root_device_name, "ubi", 3)) {
 			mount_block_root(root_device_name, root_mountflags);
 			goto out;
 		}

commit 30f2f0eb4bd2c43d10a8b0d872c6e5ad8f31c9a0
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue May 6 22:31:33 2008 +0200

    block: do_mounts - accept root=<non-existant partition>
    
    Some devices, like md, may create partitions only at first access,
    so allow root= to be set to a valid non-existant partition of an
    existing disk. This applies only to non-initramfs root mounting.
    
    This fixes a regression from 2.6.24 which did allow this to happen and
    broke some users machines :(
    
    Acked-by: Neil Brown <neilb@suse.de>
    Tested-by: Joao Luis Meloni Assirati <assirati@nonada.if.usp.br>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 3885e70e7759..660c1e50c91b 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -76,6 +76,7 @@ dev_t name_to_dev_t(char *name)
 	char s[32];
 	char *p;
 	dev_t res = 0;
+	int part;
 
 	if (strncmp(name, "/dev/", 5) != 0) {
 		unsigned maj, min;
@@ -106,7 +107,31 @@ dev_t name_to_dev_t(char *name)
 	for (p = s; *p; p++)
 		if (*p == '/')
 			*p = '!';
-	res = blk_lookup_devt(s);
+	res = blk_lookup_devt(s, 0);
+	if (res)
+		goto done;
+
+	/*
+	 * try non-existant, but valid partition, which may only exist
+	 * after revalidating the disk, like partitioned md devices
+	 */
+	while (p > s && isdigit(p[-1]))
+		p--;
+	if (p == s || !*p || *p == '0')
+		goto fail;
+
+	/* try disk name without <part number> */
+	part = simple_strtoul(p, NULL, 10);
+	*p = '\0';
+	res = blk_lookup_devt(s, part);
+	if (res)
+		goto done;
+
+	/* try disk name without p<part number> */
+	if (p < s + 2 || !isdigit(p[-2]) || p[-1] != 'p')
+		goto fail;
+	p[-1] = '\0';
+	res = blk_lookup_devt(s, part);
 	if (res)
 		goto done;
 

commit 6ac08c39a16f72c2d3e845cb6849a1392fa03e80
Author: Jan Blunck <jblunck@suse.de>
Date:   Thu Feb 14 19:34:38 2008 -0800

    Use struct path in fs_struct
    
    * Use struct path in fs_struct.
    
    Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index f86573126f83..3885e70e7759 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -193,10 +193,10 @@ static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 		return err;
 
 	sys_chdir("/root");
-	ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
+	ROOT_DEV = current->fs->pwd.mnt->mnt_sb->s_dev;
 	printk("VFS: Mounted root (%s filesystem)%s.\n",
-	       current->fs->pwdmnt->mnt_sb->s_type->name,
-	       current->fs->pwdmnt->mnt_sb->s_flags & MS_RDONLY ? 
+	       current->fs->pwd.mnt->mnt_sb->s_type->name,
+	       current->fs->pwd.mnt->mnt_sb->s_flags & MS_RDONLY ?
 	       " readonly" : "");
 	return 0;
 }

commit 011e3fcd1e1f14ef54db30b93404ab7caa726477
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Feb 6 01:36:47 2008 -0800

    proper prototype for get_filesystem_list()
    
    Ad a proper prototype for migration_init() in include/linux/fs.h
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 1161dfd7b0d3..f86573126f83 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -11,6 +11,7 @@
 #include <linux/mount.h>
 #include <linux/device.h>
 #include <linux/init.h>
+#include <linux/fs.h>
 
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>
@@ -18,8 +19,6 @@
 
 #include "do_mounts.h"
 
-extern int get_filesystem_list(char * buf);
-
 int __initdata rd_doload;	/* 1 = load RAM disk, 0 = don't load */
 
 int root_mountflags = MS_RDONLY | MS_SILENT;

commit b47711bfbcd4eb77ca61ef0162487b20e023ae55
Merge: 7556afa0e0e4 2e08c0c1c397
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 25 08:44:29 2008 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/selinux-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/selinux-2.6:
      selinux: make mls_compute_sid always polyinstantiate
      security/selinux: constify function pointer tables and fields
      security: add a secctx_to_secid() hook
      security: call security_file_permission from rw_verify_area
      security: remove security_sb_post_mountroot hook
      Security: remove security.h include from mm.h
      Security: remove security_file_mmap hook sparse-warnings (NULL as 0).
      Security: add get, set, and cloning of superblock security information
      security/selinux: Add missing "space"

commit edfaa7c36574f1bf09c65ad602412db9da5f96bf
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Mon May 21 22:08:01 2007 +0200

    Driver core: convert block from raw kobjects to core devices
    
    This moves the block devices to /sys/class/block. It will create a
    flat list of all block devices, with the disks and partitions in one
    directory. For compatibility /sys/block is created and contains symlinks
    to the disks.
    
      /sys/class/block
      |-- sda -> ../../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda
      |-- sda1 -> ../../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda/sda1
      |-- sda10 -> ../../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda/sda10
      |-- sda5 -> ../../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda/sda5
      |-- sda6 -> ../../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda/sda6
      |-- sda7 -> ../../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda/sda7
      |-- sda8 -> ../../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda/sda8
      |-- sda9 -> ../../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda/sda9
      `-- sr0 -> ../../devices/pci0000:00/0000:00:1f.2/host1/target1:0:0/1:0:0:0/block/sr0
    
      /sys/block/
      |-- sda -> ../devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda
      `-- sr0 -> ../devices/pci0000:00/0000:00:1f.2/host1/target1:0:0/1:0:0:0/block/sr0
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 4efa1e5385e3..2ae5b8462399 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -55,69 +55,6 @@ static int __init readwrite(char *str)
 __setup("ro", readonly);
 __setup("rw", readwrite);
 
-static dev_t try_name(char *name, int part)
-{
-	char path[64];
-	char buf[32];
-	int range;
-	dev_t res;
-	char *s;
-	int len;
-	int fd;
-	unsigned int maj, min;
-
-	/* read device number from .../dev */
-
-	sprintf(path, "/sys/block/%s/dev", name);
-	fd = sys_open(path, 0, 0);
-	if (fd < 0)
-		goto fail;
-	len = sys_read(fd, buf, 32);
-	sys_close(fd);
-	if (len <= 0 || len == 32 || buf[len - 1] != '\n')
-		goto fail;
-	buf[len - 1] = '\0';
-	if (sscanf(buf, "%u:%u", &maj, &min) == 2) {
-		/*
-		 * Try the %u:%u format -- see print_dev_t()
-		 */
-		res = MKDEV(maj, min);
-		if (maj != MAJOR(res) || min != MINOR(res))
-			goto fail;
-	} else {
-		/*
-		 * Nope.  Try old-style "0321"
-		 */
-		res = new_decode_dev(simple_strtoul(buf, &s, 16));
-		if (*s)
-			goto fail;
-	}
-
-	/* if it's there and we are not looking for a partition - that's it */
-	if (!part)
-		return res;
-
-	/* otherwise read range from .../range */
-	sprintf(path, "/sys/block/%s/range", name);
-	fd = sys_open(path, 0, 0);
-	if (fd < 0)
-		goto fail;
-	len = sys_read(fd, buf, 32);
-	sys_close(fd);
-	if (len <= 0 || len == 32 || buf[len - 1] != '\n')
-		goto fail;
-	buf[len - 1] = '\0';
-	range = simple_strtoul(buf, &s, 10);
-	if (*s)
-		goto fail;
-
-	/* if partition is within range - we got it */
-	if (part < range)
-		return res + part;
-fail:
-	return 0;
-}
-
 /*
  *	Convert a name into device number.  We accept the following variants:
  *
@@ -129,12 +66,10 @@ static dev_t try_name(char *name, int part)
  *	5) /dev/<disk_name>p<decimal> - same as the above, that form is
  *	   used when disk name of partitioned disk ends on a digit.
  *
- *	If name doesn't have fall into the categories above, we return 0.
- *	Sysfs is used to check if something is a disk name - it has
- *	all known disks under bus/block/devices.  If the disk name
- *	contains slashes, name of sysfs node has them replaced with
- *	bangs.  try_name() does the actual checks, assuming that sysfs
- *	is mounted on rootfs /sys.
+ *	If name doesn't have fall into the categories above, we return (0,0).
+ *	block_class is used to check if something is a disk name. If the disk
+ *	name contains slashes, the device name has them replaced with
+ *	bangs.
  */
 
 dev_t name_to_dev_t(char *name)
@@ -142,13 +77,6 @@ dev_t name_to_dev_t(char *name)
 	char s[32];
 	char *p;
 	dev_t res = 0;
-	int part;
-
-#ifdef CONFIG_SYSFS
-	int mkdir_err = sys_mkdir("/sys", 0700);
-	if (sys_mount("sysfs", "/sys", "sysfs", 0, NULL) < 0)
-		goto out;
-#endif
 
 	if (strncmp(name, "/dev/", 5) != 0) {
 		unsigned maj, min;
@@ -164,6 +92,7 @@ dev_t name_to_dev_t(char *name)
 		}
 		goto done;
 	}
+
 	name += 5;
 	res = Root_NFS;
 	if (strcmp(name, "nfs") == 0)
@@ -178,35 +107,14 @@ dev_t name_to_dev_t(char *name)
 	for (p = s; *p; p++)
 		if (*p == '/')
 			*p = '!';
-	res = try_name(s, 0);
+	res = blk_lookup_devt(s);
 	if (res)
 		goto done;
 
-	while (p > s && isdigit(p[-1]))
-		p--;
-	if (p == s || !*p || *p == '0')
-		goto fail;
-	part = simple_strtoul(p, NULL, 10);
-	*p = '\0';
-	res = try_name(s, part);
-	if (res)
-		goto done;
-
-	if (p < s + 2 || !isdigit(p[-2]) || p[-1] != 'p')
-		goto fail;
-	p[-1] = '\0';
-	res = try_name(s, part);
+fail:
+	return 0;
 done:
-#ifdef CONFIG_SYSFS
-	sys_umount("/sys", 0);
-out:
-	if (!mkdir_err)
-		sys_rmdir("/sys");
-#endif
 	return res;
-fail:
-	res = 0;
-	goto done;
 }
 
 static int __init root_dev_setup(char *line)

commit bced95283e9434611cbad8f2ff903cd396eaea72
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Sat Dec 29 16:20:25 2007 -0800

    security: remove security_sb_post_mountroot hook
    
    The security_sb_post_mountroot() hook is long-since obsolete, and is
    fundamentally broken: it is never invoked if someone uses initramfs.
    This is particularly damaging, because the existence of this hook has
    been used as motivation for not using initramfs.
    
    Stephen Smalley confirmed on 2007-07-19 that this hook was originally
    used by SELinux but can now be safely removed:
    
         http://marc.info/?l=linux-kernel&m=118485683612916&w=2
    
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: James Morris <jmorris@namei.org>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 4efa1e5385e3..31b2185ce304 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -470,6 +470,5 @@ void __init prepare_namespace(void)
 out:
 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
 	sys_chroot(".");
-	security_sb_post_mountroot();
 }
 

commit cc1ed7542c8c26af0f501da8006b9fce03e9aaca
Author: Pierre Ossman <drzeus-list@drzeus.cx>
Date:   Sun Jul 15 23:40:35 2007 -0700

    init: wait for asynchronously scanned block devices
    
    Some buses (e.g.  USB and MMC) do their scanning of devices in the
    background, causing a race between them and prepare_namespace().  In order
    to be able to use these buses without an initrd, we now wait for the device
    specified in root= to actually show up.
    
    If the device never shows up than we will hang in an infinite loop.  In
    order to not mess with setups that reboot on panic, the feature must be
    turned on via the command line option "rootwait".
    
    [bunk@stusta.de: root_wait can become static]
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 46fe407fb03e..4efa1e5385e3 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -25,6 +25,7 @@ int __initdata rd_doload;	/* 1 = load RAM disk, 0 = don't load */
 int root_mountflags = MS_RDONLY | MS_SILENT;
 char * __initdata root_device_name;
 static char __initdata saved_root_name[64];
+static int __initdata root_wait;
 
 dev_t ROOT_DEV;
 
@@ -216,6 +217,16 @@ static int __init root_dev_setup(char *line)
 
 __setup("root=", root_dev_setup);
 
+static int __init rootwait_setup(char *str)
+{
+	if (*str)
+		return 0;
+	root_wait = 1;
+	return 1;
+}
+
+__setup("rootwait", rootwait_setup);
+
 static char * __initdata root_mount_data;
 static int __init root_data_setup(char *str)
 {
@@ -438,11 +449,20 @@ void __init prepare_namespace(void)
 			root_device_name += 5;
 	}
 
-	is_floppy = MAJOR(ROOT_DEV) == FLOPPY_MAJOR;
-
 	if (initrd_load())
 		goto out;
 
+	/* wait for any asynchronous scanning to complete */
+	if ((ROOT_DEV == 0) && root_wait) {
+		printk(KERN_INFO "Waiting for root device %s...\n",
+			saved_root_name);
+		while (driver_probe_done() != 0 ||
+			(ROOT_DEV = name_to_dev_t(saved_root_name)) == 0)
+			msleep(100);
+	}
+
+	is_floppy = MAJOR(ROOT_DEV) == FLOPPY_MAJOR;
+
 	if (is_floppy && rd_doload && rd_load_disk(0))
 		ROOT_DEV = Root_RAM0;
 

commit dd2a345f8f002845636dbf5d2d768bb5cd8a5f59
Author: Dave Gilbert <linux@treblig.org>
Date:   Wed May 9 02:33:24 2007 -0700

    Display all possible partitions when the root filesystem failed to mount
    
    Display all possible partitions when the root filesystem is not mounted.
    This helps to track spell'o's and missing drivers.
    
    Updated to work with newer kernels.
    
    Example output:
    
    VFS: Cannot open root device "foobar" or unknown-block(0,0)
    Please append a correct "root=" boot option; here are the available partitions:
    0800    8388608 sda driver: sd
      0801     192748 sda1
      0802    8193150 sda2
    0810    4194304 sdb driver: sd
    Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
    
    [akpm@linux-foundation.org: cleanups, fix printk warnings]
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Cc: Dave Gilbert <linux@treblig.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 3f57ed4599d6..46fe407fb03e 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -7,6 +7,7 @@
 #include <linux/root_dev.h>
 #include <linux/security.h>
 #include <linux/delay.h>
+#include <linux/genhd.h>
 #include <linux/mount.h>
 #include <linux/device.h>
 #include <linux/init.h>
@@ -308,17 +309,21 @@ void __init mount_block_root(char *name, int flags)
 	        /*
 		 * Allow the user to distinguish between failed sys_open
 		 * and bad superblock on root device.
+		 * and give them a list of the available devices
 		 */
 #ifdef CONFIG_BLOCK
 		__bdevname(ROOT_DEV, b);
 #endif
 		printk("VFS: Cannot open root device \"%s\" or %s\n",
 				root_device_name, b);
-		printk("Please append a correct \"root=\" boot option\n");
+		printk("Please append a correct \"root=\" boot option; here are the available partitions:\n");
 
+		printk_all_partitions();
 		panic("VFS: Unable to mount root fs on %s", b);
 	}
 
+	printk("List of all partitions:\n");
+	printk_all_partitions();
 	printk("No filesystem could mount root, tried: ");
 	for (p = fs_names; *p; p += strlen(p)+1)
 		printk(" %s", p);

commit 46595390e97b3ab2741a36f5ff69e8f6033fa9c0
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue May 8 00:24:47 2007 -0700

    init/do_mounts.c: proper prepare_namespace() prototype
    
    Add a proper protype for prepare_namespace() in include/linux/init.h.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index dc1ec0803ef9..3f57ed4599d6 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -9,6 +9,7 @@
 #include <linux/delay.h>
 #include <linux/mount.h>
 #include <linux/device.h>
+#include <linux/init.h>
 
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>

commit 9361401eb7619c033e2394e4f9f6d410d6719ac7
Author: David Howells <dhowells@redhat.com>
Date:   Sat Sep 30 20:45:40 2006 +0200

    [PATCH] BLOCK: Make it possible to disable the block layer [try #6]
    
    Make it possible to disable the block layer.  Not all embedded devices require
    it, some can make do with just JFFS2, NFS, ramfs, etc - none of which require
    the block layer to be present.
    
    This patch does the following:
    
     (*) Introduces CONFIG_BLOCK to disable the block layer, buffering and blockdev
         support.
    
     (*) Adds dependencies on CONFIG_BLOCK to any configuration item that controls
         an item that uses the block layer.  This includes:
    
         (*) Block I/O tracing.
    
         (*) Disk partition code.
    
         (*) All filesystems that are block based, eg: Ext3, ReiserFS, ISOFS.
    
         (*) The SCSI layer.  As far as I can tell, even SCSI chardevs use the
             block layer to do scheduling.  Some drivers that use SCSI facilities -
             such as USB storage - end up disabled indirectly from this.
    
         (*) Various block-based device drivers, such as IDE and the old CDROM
             drivers.
    
         (*) MTD blockdev handling and FTL.
    
         (*) JFFS - which uses set_bdev_super(), something it could avoid doing by
             taking a leaf out of JFFS2's book.
    
     (*) Makes most of the contents of linux/blkdev.h, linux/buffer_head.h and
         linux/elevator.h contingent on CONFIG_BLOCK being set.  sector_div() is,
         however, still used in places, and so is still available.
    
     (*) Also made contingent are the contents of linux/mpage.h, linux/genhd.h and
         parts of linux/fs.h.
    
     (*) Makes a number of files in fs/ contingent on CONFIG_BLOCK.
    
     (*) Makes mm/bounce.c (bounce buffering) contingent on CONFIG_BLOCK.
    
     (*) set_page_dirty() doesn't call __set_page_dirty_buffers() if CONFIG_BLOCK
         is not enabled.
    
     (*) fs/no-block.c is created to hold out-of-line stubs and things that are
         required when CONFIG_BLOCK is not set:
    
         (*) Default blockdev file operations (to give error ENODEV on opening).
    
     (*) Makes some /proc changes:
    
         (*) /proc/devices does not list any blockdevs.
    
         (*) /proc/diskstats and /proc/partitions are contingent on CONFIG_BLOCK.
    
     (*) Makes some compat ioctl handling contingent on CONFIG_BLOCK.
    
     (*) If CONFIG_BLOCK is not defined, makes sys_quotactl() return -ENODEV if
         given command other than Q_SYNC or if a special device is specified.
    
     (*) In init/do_mounts.c, no reference is made to the blockdev routines if
         CONFIG_BLOCK is not defined.  This does not prohibit NFS roots or JFFS2.
    
     (*) The bdflush, ioprio_set and ioprio_get syscalls can now be absent (return
         error ENOSYS by way of cond_syscall if so).
    
     (*) The seclvl_bd_claim() and seclvl_bd_release() security calls do nothing if
         CONFIG_BLOCK is not set, since they can't then happen.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index b290aadb1d3f..dc1ec0803ef9 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -285,7 +285,11 @@ void __init mount_block_root(char *name, int flags)
 {
 	char *fs_names = __getname();
 	char *p;
+#ifdef CONFIG_BLOCK
 	char b[BDEVNAME_SIZE];
+#else
+	const char *b = name;
+#endif
 
 	get_fs_names(fs_names);
 retry:
@@ -304,7 +308,9 @@ void __init mount_block_root(char *name, int flags)
 		 * Allow the user to distinguish between failed sys_open
 		 * and bad superblock on root device.
 		 */
+#ifdef CONFIG_BLOCK
 		__bdevname(ROOT_DEV, b);
+#endif
 		printk("VFS: Cannot open root device \"%s\" or %s\n",
 				root_device_name, b);
 		printk("Please append a correct \"root=\" boot option\n");
@@ -316,7 +322,10 @@ void __init mount_block_root(char *name, int flags)
 	for (p = fs_names; *p; p += strlen(p)+1)
 		printk(" %s", p);
 	printk("\n");
-	panic("VFS: Unable to mount root fs on %s", __bdevname(ROOT_DEV, b));
+#ifdef CONFIG_BLOCK
+	__bdevname(ROOT_DEV, b);
+#endif
+	panic("VFS: Unable to mount root fs on %s", b);
 out:
 	putname(fs_names);
 }
@@ -387,8 +396,10 @@ void __init mount_root(void)
 			change_floppy("root floppy");
 	}
 #endif
+#ifdef CONFIG_BLOCK
 	create_dev("/dev/root", ROOT_DEV);
 	mount_block_root("/dev/root", root_mountflags);
+#endif
 }
 
 /*

commit d779249ed4cb3b50690de6de8448829d65a1cd08
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jul 18 10:59:59 2006 -0700

    Driver Core: add ability for drivers to do a threaded probe
    
    This adds the infrastructure for drivers to do a threaded probe, and
    waits at init time for all currently outstanding probes to complete.
    
    A new kernel thread will be created when the probe() function for the
    driver is called, if the multithread_probe bit is set in the driver
    saying it can support this kind of operation.
    
    I have tested this with USB and PCI, and it works, and shaves off a lot
    of time in the boot process, but there are issues with finding root boot
    disks, and some USB drivers assume that this can never happen, so it is
    currently not enabled for any bus type.  Individual drivers can enable
    this right now if they wish, and bus authors can selectivly turn it on
    as well, once they determine that their subsystem will work properly
    with it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 94aeec7aa917..b290aadb1d3f 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -8,6 +8,7 @@
 #include <linux/security.h>
 #include <linux/delay.h>
 #include <linux/mount.h>
+#include <linux/device.h>
 
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>
@@ -403,6 +404,10 @@ void __init prepare_namespace(void)
 		ssleep(root_delay);
 	}
 
+	/* wait for the known devices to complete their probing */
+	while (driver_probe_done() != 0)
+		msleep(100);
+
 	md_run_setup();
 
 	if (saved_root_name[0]) {

commit bdaf8529385d5126ef791e8f1914afff8cd59bcf
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] devfs: Remove devfs from the init code
    
    This patch removes the devfs code from the init/ directory.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 21b3b8f33a72..94aeec7aa917 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -325,7 +325,7 @@ static int __init mount_nfs_root(void)
 {
 	void *data = nfs_root_data();
 
-	create_dev("/dev/root", ROOT_DEV, NULL);
+	create_dev("/dev/root", ROOT_DEV);
 	if (data &&
 	    do_mount_root("/dev/root", "nfs", root_mountflags, data) == 0)
 		return 1;
@@ -386,7 +386,7 @@ void __init mount_root(void)
 			change_floppy("root floppy");
 	}
 #endif
-	create_dev("/dev/root", ROOT_DEV, root_device_name);
+	create_dev("/dev/root", ROOT_DEV);
 	mount_block_root("/dev/root", root_mountflags);
 }
 
@@ -397,8 +397,6 @@ void __init prepare_namespace(void)
 {
 	int is_floppy;
 
-	mount_devfs();
-
 	if (root_delay) {
 		printk(KERN_INFO "Waiting %dsec before mounting root device...\n",
 		       root_delay);
@@ -428,10 +426,8 @@ void __init prepare_namespace(void)
 
 	mount_root();
 out:
-	umount_devfs("/dev");
 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
 	sys_chroot(".");
 	security_sb_post_mountroot();
-	mount_devfs_fs ();
 }
 

commit e9482b4374e2596e6f3f1ab30c4ea469f4ac6311
Author: Joern Engel <joern@wh.fh-wedel.de>
Date:   Tue May 30 14:25:46 2006 +0200

    [MTD] Allow alternate JFFS2 mount variant for root filesystem.
    
    With this patch, "root=mtd3" and "root=mtd:foo" work for a JFFS2 rootfs.
    
    Signed-off-by: Joern Engel <joern@wh.fh-wedel.de>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index f4b7b9d278cd..21b3b8f33a72 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -409,6 +409,10 @@ void __init prepare_namespace(void)
 
 	if (saved_root_name[0]) {
 		root_device_name = saved_root_name;
+		if (!strncmp(root_device_name, "mtd", 3)) {
+			mount_block_root(root_device_name, root_mountflags);
+			goto out;
+		}
 		ROOT_DEV = name_to_dev_t(root_device_name);
 		if (strncmp(root_device_name, "/dev/", 5) == 0)
 			root_device_name += 5;

commit be6e028b6422878df2e799a74609a03a553c7dad
Author: Andy Whitcroft <apw@shadowen.org>
Date:   Mon May 15 09:44:29 2006 -0700

    [PATCH] root mount failure: emit filesystems attempted
    
    When we fail to mount from a valid root device list out the filesystems we
    have tried to mount it with.  This gives the user vital diagnostics as to
    what is missing from their kernel.
    
    For example in the fragment below the kernel does not have CRAMFS compiled
    into the kernel and yet appears to recognise it at the RAMDISK detect
    stage.  Later the mount fails as we don't have the filesystem.
    
      RAMDISK: cramfs filesystem found at block 0
      RAMDISK: Loading 1604KiB [1 disk] into ram disk... done.
      XFS: bad magic number
      XFS: SB validate failed
      No filesystem could mount root, tried: reiserfs ext3 ext2 msdos vfat
        iso9660 jfs xfs
      Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(8,1)
    
    Signed-off-by: Andy Whitcroft <apw@shadowen.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index adb7cad3e6ee..f4b7b9d278cd 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -310,6 +310,11 @@ void __init mount_block_root(char *name, int flags)
 
 		panic("VFS: Unable to mount root fs on %s", b);
 	}
+
+	printk("No filesystem could mount root, tried: ");
+	for (p = fs_names; *p; p += strlen(p)+1)
+		printk(" %s", p);
+	printk("\n");
 	panic("VFS: Unable to mount root fs on %s", __bdevname(ROOT_DEV, b));
 out:
 	putname(fs_names);

commit 5ac35783f4a471d43c557db27928bc29f8a9c6d0
Author: Florin Malita <fmalita@gmail.com>
Date:   Sun Mar 26 18:53:34 2006 +0200

    do_mounts.c: Minor ROOT_DEV comment cleanup
    
    The ROOT_DEV comment is no longer accurate, it now seems to be
    initialized in init/do_mounts.c.
    
    Signed-off-by: Florin Malita <fmalita@gmail.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 8b671fe68afa..adb7cad3e6ee 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -23,7 +23,6 @@ int root_mountflags = MS_RDONLY | MS_SILENT;
 char * __initdata root_device_name;
 static char __initdata saved_root_name[64];
 
-/* this is initialized in init/main.c */
 dev_t ROOT_DEV;
 
 static int __init load_ramdisk(char *str)

commit 9b04c997b1120feefa1e6ee8e2902270bc055cd2
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Fri Mar 24 03:15:10 2006 -0800

    [PATCH] vfs: MS_VERBOSE should be MS_SILENT
    
    The meaning of MS_VERBOSE is backwards; if the bit is set, it really means,
    "don't be verbose".  This is confusing and counter-intuitive.
    
    In addition, there is also no way to set the MS_VERBOSE flag in the
    mount(8) program in util-linux, but interesting, it does define options
    which would do the right thing if MS_SILENT were defined, which
    unfortunately we do not:
    
    #ifdef MS_SILENT
      { "quiet",    0, 0, MS_SILENT    },   /* be quiet  */
      { "loud",     0, 1, MS_SILENT    },   /* print out messages. */
    #endif
    
    So the obvious fix is to deprecate the use of MS_VERBOSE and replace it
    with MS_SILENT.
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index b27c11064409..8b671fe68afa 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -19,7 +19,7 @@ extern int get_filesystem_list(char * buf);
 
 int __initdata rd_doload;	/* 1 = load RAM disk, 0 = don't load */
 
-int root_mountflags = MS_RDONLY | MS_VERBOSE;
+int root_mountflags = MS_RDONLY | MS_SILENT;
 char * __initdata root_device_name;
 static char __initdata saved_root_name[64];
 

commit 13ae6d81b963c7b22ab9c158ee5a392fb57579fe
Author: Rolf Eike Beer <eike-kernel@sf-tec.de>
Date:   Fri Sep 2 09:03:09 2005 +0200

    [PATCH] remove driverfs references from init/do_mounts.c
    
    This patch is against 2.6.10, but still applies cleanly. It's just
    s/driverfs/sysfs/ in this file.
    
    Signed-off-by: Rolf Eike Beer <eike-kernel@sf-tec.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 4e11a9aaf14a..b27c11064409 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -127,10 +127,10 @@ static dev_t try_name(char *name, int part)
  *	   used when disk name of partitioned disk ends on a digit.
  *
  *	If name doesn't have fall into the categories above, we return 0.
- *	Driverfs is used to check if something is a disk name - it has
+ *	Sysfs is used to check if something is a disk name - it has
  *	all known disks under bus/block/devices.  If the disk name
- *	contains slashes, name of driverfs node has them replaced with
- *	bangs.  try_name() does the actual checks, assuming that driverfs
+ *	contains slashes, name of sysfs node has them replaced with
+ *	bangs.  try_name() does the actual checks, assuming that sysfs
  *	is mounted on rootfs /sys.
  */
 

commit a2d2b5cb8e5d8787f009eeb3bbca52687bd42a77
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Thu Jul 14 00:33:44 2005 -0700

    [PATCH] remove EXPORT_SYMBOL for root_dev
    
    Remove ROOT_DEV after unexporting it in the previous patch, as requested time
    ago by Christoph Hellwig.
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index 1b02be734ccc..4e11a9aaf14a 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -26,8 +26,6 @@ static char __initdata saved_root_name[64];
 /* this is initialized in init/main.c */
 dev_t ROOT_DEV;
 
-EXPORT_SYMBOL(ROOT_DEV);
-
 static int __init load_ramdisk(char *str)
 {
 	rd_doload = simple_strtol(str,NULL,0) & 3;

commit d53d9f16ea95a91ad4aa114809dcde486ca4000d
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Jul 12 13:58:07 2005 -0700

    [PATCH] name_to_dev_t warning fix
    
    kernel/power/disk.c needs a declaration of name_to_dev_t() in scope.  mount.h
    seems like an appropriate choice.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/init/do_mounts.c b/init/do_mounts.c
index b7570c074d0f..1b02be734ccc 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -7,6 +7,7 @@
 #include <linux/root_dev.h>
 #include <linux/security.h>
 #include <linux/delay.h>
+#include <linux/mount.h>
 
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/init/do_mounts.c b/init/do_mounts.c
new file mode 100644
index 000000000000..b7570c074d0f
--- /dev/null
+++ b/init/do_mounts.c
@@ -0,0 +1,430 @@
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/ctype.h>
+#include <linux/fd.h>
+#include <linux/tty.h>
+#include <linux/suspend.h>
+#include <linux/root_dev.h>
+#include <linux/security.h>
+#include <linux/delay.h>
+
+#include <linux/nfs_fs.h>
+#include <linux/nfs_fs_sb.h>
+#include <linux/nfs_mount.h>
+
+#include "do_mounts.h"
+
+extern int get_filesystem_list(char * buf);
+
+int __initdata rd_doload;	/* 1 = load RAM disk, 0 = don't load */
+
+int root_mountflags = MS_RDONLY | MS_VERBOSE;
+char * __initdata root_device_name;
+static char __initdata saved_root_name[64];
+
+/* this is initialized in init/main.c */
+dev_t ROOT_DEV;
+
+EXPORT_SYMBOL(ROOT_DEV);
+
+static int __init load_ramdisk(char *str)
+{
+	rd_doload = simple_strtol(str,NULL,0) & 3;
+	return 1;
+}
+__setup("load_ramdisk=", load_ramdisk);
+
+static int __init readonly(char *str)
+{
+	if (*str)
+		return 0;
+	root_mountflags |= MS_RDONLY;
+	return 1;
+}
+
+static int __init readwrite(char *str)
+{
+	if (*str)
+		return 0;
+	root_mountflags &= ~MS_RDONLY;
+	return 1;
+}
+
+__setup("ro", readonly);
+__setup("rw", readwrite);
+
+static dev_t try_name(char *name, int part)
+{
+	char path[64];
+	char buf[32];
+	int range;
+	dev_t res;
+	char *s;
+	int len;
+	int fd;
+	unsigned int maj, min;
+
+	/* read device number from .../dev */
+
+	sprintf(path, "/sys/block/%s/dev", name);
+	fd = sys_open(path, 0, 0);
+	if (fd < 0)
+		goto fail;
+	len = sys_read(fd, buf, 32);
+	sys_close(fd);
+	if (len <= 0 || len == 32 || buf[len - 1] != '\n')
+		goto fail;
+	buf[len - 1] = '\0';
+	if (sscanf(buf, "%u:%u", &maj, &min) == 2) {
+		/*
+		 * Try the %u:%u format -- see print_dev_t()
+		 */
+		res = MKDEV(maj, min);
+		if (maj != MAJOR(res) || min != MINOR(res))
+			goto fail;
+	} else {
+		/*
+		 * Nope.  Try old-style "0321"
+		 */
+		res = new_decode_dev(simple_strtoul(buf, &s, 16));
+		if (*s)
+			goto fail;
+	}
+
+	/* if it's there and we are not looking for a partition - that's it */
+	if (!part)
+		return res;
+
+	/* otherwise read range from .../range */
+	sprintf(path, "/sys/block/%s/range", name);
+	fd = sys_open(path, 0, 0);
+	if (fd < 0)
+		goto fail;
+	len = sys_read(fd, buf, 32);
+	sys_close(fd);
+	if (len <= 0 || len == 32 || buf[len - 1] != '\n')
+		goto fail;
+	buf[len - 1] = '\0';
+	range = simple_strtoul(buf, &s, 10);
+	if (*s)
+		goto fail;
+
+	/* if partition is within range - we got it */
+	if (part < range)
+		return res + part;
+fail:
+	return 0;
+}
+
+/*
+ *	Convert a name into device number.  We accept the following variants:
+ *
+ *	1) device number in hexadecimal	represents itself
+ *	2) /dev/nfs represents Root_NFS (0xff)
+ *	3) /dev/<disk_name> represents the device number of disk
+ *	4) /dev/<disk_name><decimal> represents the device number
+ *         of partition - device number of disk plus the partition number
+ *	5) /dev/<disk_name>p<decimal> - same as the above, that form is
+ *	   used when disk name of partitioned disk ends on a digit.
+ *
+ *	If name doesn't have fall into the categories above, we return 0.
+ *	Driverfs is used to check if something is a disk name - it has
+ *	all known disks under bus/block/devices.  If the disk name
+ *	contains slashes, name of driverfs node has them replaced with
+ *	bangs.  try_name() does the actual checks, assuming that driverfs
+ *	is mounted on rootfs /sys.
+ */
+
+dev_t name_to_dev_t(char *name)
+{
+	char s[32];
+	char *p;
+	dev_t res = 0;
+	int part;
+
+#ifdef CONFIG_SYSFS
+	int mkdir_err = sys_mkdir("/sys", 0700);
+	if (sys_mount("sysfs", "/sys", "sysfs", 0, NULL) < 0)
+		goto out;
+#endif
+
+	if (strncmp(name, "/dev/", 5) != 0) {
+		unsigned maj, min;
+
+		if (sscanf(name, "%u:%u", &maj, &min) == 2) {
+			res = MKDEV(maj, min);
+			if (maj != MAJOR(res) || min != MINOR(res))
+				goto fail;
+		} else {
+			res = new_decode_dev(simple_strtoul(name, &p, 16));
+			if (*p)
+				goto fail;
+		}
+		goto done;
+	}
+	name += 5;
+	res = Root_NFS;
+	if (strcmp(name, "nfs") == 0)
+		goto done;
+	res = Root_RAM0;
+	if (strcmp(name, "ram") == 0)
+		goto done;
+
+	if (strlen(name) > 31)
+		goto fail;
+	strcpy(s, name);
+	for (p = s; *p; p++)
+		if (*p == '/')
+			*p = '!';
+	res = try_name(s, 0);
+	if (res)
+		goto done;
+
+	while (p > s && isdigit(p[-1]))
+		p--;
+	if (p == s || !*p || *p == '0')
+		goto fail;
+	part = simple_strtoul(p, NULL, 10);
+	*p = '\0';
+	res = try_name(s, part);
+	if (res)
+		goto done;
+
+	if (p < s + 2 || !isdigit(p[-2]) || p[-1] != 'p')
+		goto fail;
+	p[-1] = '\0';
+	res = try_name(s, part);
+done:
+#ifdef CONFIG_SYSFS
+	sys_umount("/sys", 0);
+out:
+	if (!mkdir_err)
+		sys_rmdir("/sys");
+#endif
+	return res;
+fail:
+	res = 0;
+	goto done;
+}
+
+static int __init root_dev_setup(char *line)
+{
+	strlcpy(saved_root_name, line, sizeof(saved_root_name));
+	return 1;
+}
+
+__setup("root=", root_dev_setup);
+
+static char * __initdata root_mount_data;
+static int __init root_data_setup(char *str)
+{
+	root_mount_data = str;
+	return 1;
+}
+
+static char * __initdata root_fs_names;
+static int __init fs_names_setup(char *str)
+{
+	root_fs_names = str;
+	return 1;
+}
+
+static unsigned int __initdata root_delay;
+static int __init root_delay_setup(char *str)
+{
+	root_delay = simple_strtoul(str, NULL, 0);
+	return 1;
+}
+
+__setup("rootflags=", root_data_setup);
+__setup("rootfstype=", fs_names_setup);
+__setup("rootdelay=", root_delay_setup);
+
+static void __init get_fs_names(char *page)
+{
+	char *s = page;
+
+	if (root_fs_names) {
+		strcpy(page, root_fs_names);
+		while (*s++) {
+			if (s[-1] == ',')
+				s[-1] = '\0';
+		}
+	} else {
+		int len = get_filesystem_list(page);
+		char *p, *next;
+
+		page[len] = '\0';
+		for (p = page-1; p; p = next) {
+			next = strchr(++p, '\n');
+			if (*p++ != '\t')
+				continue;
+			while ((*s++ = *p++) != '\n')
+				;
+			s[-1] = '\0';
+		}
+	}
+	*s = '\0';
+}
+
+static int __init do_mount_root(char *name, char *fs, int flags, void *data)
+{
+	int err = sys_mount(name, "/root", fs, flags, data);
+	if (err)
+		return err;
+
+	sys_chdir("/root");
+	ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
+	printk("VFS: Mounted root (%s filesystem)%s.\n",
+	       current->fs->pwdmnt->mnt_sb->s_type->name,
+	       current->fs->pwdmnt->mnt_sb->s_flags & MS_RDONLY ? 
+	       " readonly" : "");
+	return 0;
+}
+
+void __init mount_block_root(char *name, int flags)
+{
+	char *fs_names = __getname();
+	char *p;
+	char b[BDEVNAME_SIZE];
+
+	get_fs_names(fs_names);
+retry:
+	for (p = fs_names; *p; p += strlen(p)+1) {
+		int err = do_mount_root(name, p, flags, root_mount_data);
+		switch (err) {
+			case 0:
+				goto out;
+			case -EACCES:
+				flags |= MS_RDONLY;
+				goto retry;
+			case -EINVAL:
+				continue;
+		}
+	        /*
+		 * Allow the user to distinguish between failed sys_open
+		 * and bad superblock on root device.
+		 */
+		__bdevname(ROOT_DEV, b);
+		printk("VFS: Cannot open root device \"%s\" or %s\n",
+				root_device_name, b);
+		printk("Please append a correct \"root=\" boot option\n");
+
+		panic("VFS: Unable to mount root fs on %s", b);
+	}
+	panic("VFS: Unable to mount root fs on %s", __bdevname(ROOT_DEV, b));
+out:
+	putname(fs_names);
+}
+ 
+#ifdef CONFIG_ROOT_NFS
+static int __init mount_nfs_root(void)
+{
+	void *data = nfs_root_data();
+
+	create_dev("/dev/root", ROOT_DEV, NULL);
+	if (data &&
+	    do_mount_root("/dev/root", "nfs", root_mountflags, data) == 0)
+		return 1;
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_BLK_DEV_RAM) || defined(CONFIG_BLK_DEV_FD)
+void __init change_floppy(char *fmt, ...)
+{
+	struct termios termios;
+	char buf[80];
+	char c;
+	int fd;
+	va_list args;
+	va_start(args, fmt);
+	vsprintf(buf, fmt, args);
+	va_end(args);
+	fd = sys_open("/dev/root", O_RDWR | O_NDELAY, 0);
+	if (fd >= 0) {
+		sys_ioctl(fd, FDEJECT, 0);
+		sys_close(fd);
+	}
+	printk(KERN_NOTICE "VFS: Insert %s and press ENTER\n", buf);
+	fd = sys_open("/dev/console", O_RDWR, 0);
+	if (fd >= 0) {
+		sys_ioctl(fd, TCGETS, (long)&termios);
+		termios.c_lflag &= ~ICANON;
+		sys_ioctl(fd, TCSETSF, (long)&termios);
+		sys_read(fd, &c, 1);
+		termios.c_lflag |= ICANON;
+		sys_ioctl(fd, TCSETSF, (long)&termios);
+		sys_close(fd);
+	}
+}
+#endif
+
+void __init mount_root(void)
+{
+#ifdef CONFIG_ROOT_NFS
+	if (MAJOR(ROOT_DEV) == UNNAMED_MAJOR) {
+		if (mount_nfs_root())
+			return;
+
+		printk(KERN_ERR "VFS: Unable to mount root fs via NFS, trying floppy.\n");
+		ROOT_DEV = Root_FD0;
+	}
+#endif
+#ifdef CONFIG_BLK_DEV_FD
+	if (MAJOR(ROOT_DEV) == FLOPPY_MAJOR) {
+		/* rd_doload is 2 for a dual initrd/ramload setup */
+		if (rd_doload==2) {
+			if (rd_load_disk(1)) {
+				ROOT_DEV = Root_RAM1;
+				root_device_name = NULL;
+			}
+		} else
+			change_floppy("root floppy");
+	}
+#endif
+	create_dev("/dev/root", ROOT_DEV, root_device_name);
+	mount_block_root("/dev/root", root_mountflags);
+}
+
+/*
+ * Prepare the namespace - decide what/where to mount, load ramdisks, etc.
+ */
+void __init prepare_namespace(void)
+{
+	int is_floppy;
+
+	mount_devfs();
+
+	if (root_delay) {
+		printk(KERN_INFO "Waiting %dsec before mounting root device...\n",
+		       root_delay);
+		ssleep(root_delay);
+	}
+
+	md_run_setup();
+
+	if (saved_root_name[0]) {
+		root_device_name = saved_root_name;
+		ROOT_DEV = name_to_dev_t(root_device_name);
+		if (strncmp(root_device_name, "/dev/", 5) == 0)
+			root_device_name += 5;
+	}
+
+	is_floppy = MAJOR(ROOT_DEV) == FLOPPY_MAJOR;
+
+	if (initrd_load())
+		goto out;
+
+	if (is_floppy && rd_doload && rd_load_disk(0))
+		ROOT_DEV = Root_RAM0;
+
+	mount_root();
+out:
+	umount_devfs("/dev");
+	sys_mount(".", "/", NULL, MS_MOVE, NULL);
+	sys_chroot(".");
+	security_sb_post_mountroot();
+	mount_devfs_fs ();
+}
+
