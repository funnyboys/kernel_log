commit e99332e7b4cda6e60f5b5916cf9943a79dbef902
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat May 9 17:50:03 2020 -0700

    gcc-10: mark more functions __init to avoid section mismatch warnings
    
    It seems that for whatever reason, gcc-10 ends up not inlining a couple
    of functions that used to be inlined before.  Even if they only have one
    single callsite - it looks like gcc may have decided that the code was
    unlikely, and not worth inlining.
    
    The code generation difference is harmless, but caused a few new section
    mismatch errors, since the (now no longer inlined) function wasn't in
    the __init section, but called other init functions:
    
       Section mismatch in reference from the function kexec_free_initrd() to the function .init.text:free_initrd_mem()
       Section mismatch in reference from the function tpm2_calc_event_log_size() to the function .init.text:early_memremap()
       Section mismatch in reference from the function tpm2_calc_event_log_size() to the function .init.text:early_memunmap()
    
    So add the appropriate __init annotation to make modpost not complain.
    In both cases there were trivially just a single callsite from another
    __init function.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 8ec1be4d7d51..7a38012e1af7 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -542,7 +542,7 @@ void __weak free_initrd_mem(unsigned long start, unsigned long end)
 }
 
 #ifdef CONFIG_KEXEC_CORE
-static bool kexec_free_initrd(void)
+static bool __init kexec_free_initrd(void)
 {
 	unsigned long crashk_start = (unsigned long)__va(crashk_res.start);
 	unsigned long crashk_end   = (unsigned long)__va(crashk_res.end);

commit 899ee4afe5eb262236717188ccdaa0192c00dc5a
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Sat Sep 28 11:02:26 2019 +0300

    arm64: use generic free_initrd_mem()
    
    arm64 calls memblock_free() for the initrd area in its implementation of
    free_initrd_mem(), but this call has no actual effect that late in the boot
    process. By the time initrd is freed, all the reserved memory is managed by
    the page allocator and the memblock.reserved is unused, so the only purpose
    of the memblock_free() call is to keep track of initrd memory for debugging
    and accounting.
    
    Without the memblock_free() call the only difference between arm64 and the
    generic versions of free_initrd_mem() is the memory poisoning.
    
    Move memblock_free() call to the generic code, enable it there
    for the architectures that define ARCH_KEEP_MEMBLOCK and use the generic
    implementation of free_initrd_mem() on arm64.
    
    Tested-by: Anshuman Khandual <anshuman.khandual@arm.com>        #arm64
    Reviewed-by: Anshuman Khandual <anshuman.khandual@arm.com>
    Acked-by: Will Deacon <will@kernel.org>
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/init/initramfs.c b/init/initramfs.c
index c47dad0884f7..8ec1be4d7d51 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -10,6 +10,7 @@
 #include <linux/syscalls.h>
 #include <linux/utime.h>
 #include <linux/file.h>
+#include <linux/memblock.h>
 
 static ssize_t __init xwrite(int fd, const char *p, size_t count)
 {
@@ -529,6 +530,13 @@ extern unsigned long __initramfs_size;
 
 void __weak free_initrd_mem(unsigned long start, unsigned long end)
 {
+#ifdef CONFIG_ARCH_KEEP_MEMBLOCK
+	unsigned long aligned_start = ALIGN_DOWN(start, PAGE_SIZE);
+	unsigned long aligned_end = ALIGN(end, PAGE_SIZE);
+
+	memblock_free(__pa(aligned_start), aligned_end - aligned_start);
+#endif
+
 	free_reserved_area((void *)start, (void *)end, POISON_FREE_INITMEM,
 			"initrd");
 }

commit 4ada1e810038e9dbc20e40b524e05ee1a9d31f98
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Jun 28 12:07:03 2019 -0700

    initramfs: fix populate_initrd_image() section mismatch
    
    With gcc-4.6.3:
    
        WARNING: vmlinux.o(.text.unlikely+0x140): Section mismatch in reference from the function populate_initrd_image() to the variable .init.ramfs.info:__initramfs_size
        The function populate_initrd_image() references
        the variable __init __initramfs_size.
        This is often because populate_initrd_image lacks a __init
        annotation or the annotation of __initramfs_size is wrong.
    
        WARNING: vmlinux.o(.text.unlikely+0x14c): Section mismatch in reference from the function populate_initrd_image() to the function .init.text:unpack_to_rootfs()
        The function populate_initrd_image() references
        the function __init unpack_to_rootfs().
        This is often because populate_initrd_image lacks a __init
        annotation or the annotation of unpack_to_rootfs is wrong.
    
        WARNING: vmlinux.o(.text.unlikely+0x198): Section mismatch in reference from the function populate_initrd_image() to the function .init.text:xwrite()
        The function populate_initrd_image() references
        the function __init xwrite().
        This is often because populate_initrd_image lacks a __init
        annotation or the annotation of xwrite is wrong.
    
    Indeed, if the compiler decides not to inline populate_initrd_image(), a
    warning is generated.
    
    Fix this by adding the missing __init annotations.
    
    Link: http://lkml.kernel.org/r/20190617074340.12779-1-geert@linux-m68k.org
    Fixes: 7c184ecd262fe64f ("initramfs: factor out a helper to populate the initrd image")
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 178130fd61c2..c47dad0884f7 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -617,7 +617,7 @@ static inline void clean_rootfs(void)
 #endif /* CONFIG_BLK_DEV_RAM */
 
 #ifdef CONFIG_BLK_DEV_RAM
-static void populate_initrd_image(char *err)
+static void __init populate_initrd_image(char *err)
 {
 	ssize_t written;
 	int fd;
@@ -637,7 +637,7 @@ static void populate_initrd_image(char *err)
 	ksys_close(fd);
 }
 #else
-static void populate_initrd_image(char *err)
+static void __init populate_initrd_image(char *err)
 {
 	printk(KERN_EMERG "Initramfs unpacking failed: %s\n", err);
 }

commit 5d59aa8f9ce972b472201aed86e904bb75879ff0
Author: Steven Price <steven.price@arm.com>
Date:   Fri May 17 14:31:47 2019 -0700

    initramfs: don't free a non-existent initrd
    
    Since commit 54c7a8916a88 ("initramfs: free initrd memory if opening
    /initrd.image fails"), the kernel has unconditionally attempted to free
    the initrd even if it doesn't exist.
    
    In the non-existent case this causes a boot-time splat if
    CONFIG_DEBUG_VIRTUAL is enabled due to a call to virt_to_phys() with a
    NULL address.
    
    Instead we should check that the initrd actually exists and only attempt
    to free it if it does.
    
    Link: http://lkml.kernel.org/r/20190516143125.48948-1-steven.price@arm.com
    Fixes: 54c7a8916a88 ("initramfs: free initrd memory if opening /initrd.image fails")
    Signed-off-by: Steven Price <steven.price@arm.com>
    Reported-by: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Mark Rutland <mark.rutland@arm.com>
    Reviewed-by: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 435a428c2af1..178130fd61c2 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -669,7 +669,7 @@ static int __init populate_rootfs(void)
 	 * If the initrd region is overlapped with crashkernel reserved region,
 	 * free only memory that is not part of crashkernel region.
 	 */
-	if (!do_retain_initrd && !kexec_free_initrd())
+	if (!do_retain_initrd && initrd_start && !kexec_free_initrd())
 		free_initrd_mem(initrd_start, initrd_end);
 	initrd_start = 0;
 	initrd_end = 0;

commit f94f7434cbbb02f7eb55ed5ad66284023c47968f
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon May 13 17:18:37 2019 -0700

    initramfs: poison freed initrd memory
    
    Various architectures including x86 poison the freed initrd memory.  Do
    the same in the generic free_initrd_mem implementation and switch a few
    more architectures that are identical to the generic code over to it now.
    
    Link: http://lkml.kernel.org/r/20190213174621.29297-9-hch@lst.de
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>   [arm64]
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>   [m68k]
    Cc: Steven Price <steven.price@arm.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index fcb759a106be..435a428c2af1 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -529,7 +529,8 @@ extern unsigned long __initramfs_size;
 
 void __weak free_initrd_mem(unsigned long start, unsigned long end)
 {
-	free_reserved_area((void *)start, (void *)end, -1, "initrd");
+	free_reserved_area((void *)start, (void *)end, POISON_FREE_INITMEM,
+			"initrd");
 }
 
 #ifdef CONFIG_KEXEC_CORE

commit 4afd58e14dd415e456fd236755373f52e6055ec7
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon May 13 17:18:34 2019 -0700

    initramfs: provide a generic free_initrd_mem implementation
    
    For most architectures free_initrd_mem just expands to the same
    free_reserved_area call.  Provide that as a generic implementation marked
    __weak.
    
    Link: http://lkml.kernel.org/r/20190213174621.29297-8-hch@lst.de
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>     [m68k]
    Acked-by: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>   [arm64]
    Cc: Steven Price <steven.price@arm.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index cb3d17735c66..fcb759a106be 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -527,6 +527,11 @@ extern unsigned long __initramfs_size;
 #include <linux/initrd.h>
 #include <linux/kexec.h>
 
+void __weak free_initrd_mem(unsigned long start, unsigned long end)
+{
+	free_reserved_area((void *)start, (void *)end, -1, "initrd");
+}
+
 #ifdef CONFIG_KEXEC_CORE
 static bool kexec_free_initrd(void)
 {

commit d8ae8a3765bfa1f9bf977e2496fcc9cf64fbfabd
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon May 13 17:18:30 2019 -0700

    initramfs: move the legacy keepinitrd parameter to core code
    
    No need to handle the freeing disable in arch code when we already have a
    core hook (and a different name for the option) for it.
    
    Link: http://lkml.kernel.org/r/20190213174621.29297-7-hch@lst.de
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>     [arm64]
    Acked-by: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>   [m68k]
    Cc: Steven Price <steven.price@arm.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 32f940473d67..cb3d17735c66 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -513,6 +513,15 @@ static int __init retain_initrd_param(char *str)
 }
 __setup("retain_initrd", retain_initrd_param);
 
+#ifdef CONFIG_ARCH_HAS_KEEPINITRD
+static int __init keepinitrd_setup(char *__unused)
+{
+	do_retain_initrd = 1;
+	return 1;
+}
+__setup("keepinitrd", keepinitrd_setup);
+#endif
+
 extern char __initramfs_start[];
 extern unsigned long __initramfs_size;
 #include <linux/initrd.h>

commit afef7889c480ed134247f16c2ebdeabd75e77fd0
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon May 13 17:18:27 2019 -0700

    initramfs: cleanup populate_rootfs
    
    The code for kernels that support ramdisks or not is mostly the same.
    Unify it by using an IS_ENABLED for the info message, and moving the error
    message into a stub for populate_initrd_image.
    
    [cai@lca.pw: fix a compilation error]
      Link: http://lkml.kernel.org/r/20190328014806.36375-1-cai@lca.pw
    Link: http://lkml.kernel.org/r/20190213174621.29297-6-hch@lst.de
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Qian Cai <cai@lca.pw>
    Acked-by: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>   [arm64]
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>   [m68k]
    Cc: Steven Price <steven.price@arm.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index e3de626dbd98..32f940473d67 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -595,7 +595,11 @@ static void __init clean_rootfs(void)
 	ksys_close(fd);
 	kfree(buf);
 }
-#endif
+#else
+static inline void clean_rootfs(void)
+{
+}
+#endif /* CONFIG_BLK_DEV_RAM */
 
 #ifdef CONFIG_BLK_DEV_RAM
 static void populate_initrd_image(char *err)
@@ -617,6 +621,11 @@ static void populate_initrd_image(char *err)
 		       written, initrd_end - initrd_start);
 	ksys_close(fd);
 }
+#else
+static void populate_initrd_image(char *err)
+{
+	printk(KERN_EMERG "Initramfs unpacking failed: %s\n", err);
+}
 #endif /* CONFIG_BLK_DEV_RAM */
 
 static int __init populate_rootfs(void)
@@ -625,28 +634,22 @@ static int __init populate_rootfs(void)
 	char *err = unpack_to_rootfs(__initramfs_start, __initramfs_size);
 	if (err)
 		panic("%s", err); /* Failed to decompress INTERNAL initramfs */
-	/* If available load the bootloader supplied initrd */
-	if (initrd_start && !IS_ENABLED(CONFIG_INITRAMFS_FORCE)) {
-#ifdef CONFIG_BLK_DEV_RAM
+
+	if (!initrd_start || IS_ENABLED(CONFIG_INITRAMFS_FORCE))
+		goto done;
+
+	if (IS_ENABLED(CONFIG_BLK_DEV_RAM))
 		printk(KERN_INFO "Trying to unpack rootfs image as initramfs...\n");
-		err = unpack_to_rootfs((char *)initrd_start,
-			initrd_end - initrd_start);
-		if (!err)
-			goto done;
+	else
+		printk(KERN_INFO "Unpacking initramfs...\n");
 
+	err = unpack_to_rootfs((char *)initrd_start, initrd_end - initrd_start);
+	if (err) {
 		clean_rootfs();
 		populate_initrd_image(err);
-	done:
-		/* empty statement */;
-#else
-		printk(KERN_INFO "Unpacking initramfs...\n");
-		err = unpack_to_rootfs((char *)initrd_start,
-			initrd_end - initrd_start);
-		if (err)
-			printk(KERN_EMERG "Initramfs unpacking failed: %s\n", err);
-#endif
 	}
 
+done:
 	/*
 	 * If the initrd region is overlapped with crashkernel reserved region,
 	 * free only memory that is not part of crashkernel region.

commit 7c184ecd262fe64fe8cf4e099e0f7cefe88d88b2
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon May 13 17:18:24 2019 -0700

    initramfs: factor out a helper to populate the initrd image
    
    This will allow for cleaner code sharing in the caller.
    
    Link: http://lkml.kernel.org/r/20190213174621.29297-5-hch@lst.de
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>   [arm64]
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>   [m68k]
    Cc: Steven Price <steven.price@arm.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 5fda9557a134..e3de626dbd98 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -597,6 +597,28 @@ static void __init clean_rootfs(void)
 }
 #endif
 
+#ifdef CONFIG_BLK_DEV_RAM
+static void populate_initrd_image(char *err)
+{
+	ssize_t written;
+	int fd;
+
+	unpack_to_rootfs(__initramfs_start, __initramfs_size);
+
+	printk(KERN_INFO "rootfs image is not initramfs (%s); looks like an initrd\n",
+			err);
+	fd = ksys_open("/initrd.image", O_WRONLY | O_CREAT, 0700);
+	if (fd < 0)
+		return;
+
+	written = xwrite(fd, (char *)initrd_start, initrd_end - initrd_start);
+	if (written != initrd_end - initrd_start)
+		pr_err("/initrd.image: incomplete write (%zd != %ld)\n",
+		       written, initrd_end - initrd_start);
+	ksys_close(fd);
+}
+#endif /* CONFIG_BLK_DEV_RAM */
+
 static int __init populate_rootfs(void)
 {
 	/* Load the built in initramfs */
@@ -606,7 +628,6 @@ static int __init populate_rootfs(void)
 	/* If available load the bootloader supplied initrd */
 	if (initrd_start && !IS_ENABLED(CONFIG_INITRAMFS_FORCE)) {
 #ifdef CONFIG_BLK_DEV_RAM
-		int fd;
 		printk(KERN_INFO "Trying to unpack rootfs image as initramfs...\n");
 		err = unpack_to_rootfs((char *)initrd_start,
 			initrd_end - initrd_start);
@@ -614,22 +635,7 @@ static int __init populate_rootfs(void)
 			goto done;
 
 		clean_rootfs();
-		unpack_to_rootfs(__initramfs_start, __initramfs_size);
-
-		printk(KERN_INFO "rootfs image is not initramfs (%s)"
-				"; looks like an initrd\n", err);
-		fd = ksys_open("/initrd.image",
-			      O_WRONLY|O_CREAT, 0700);
-		if (fd >= 0) {
-			ssize_t written = xwrite(fd, (char *)initrd_start,
-						initrd_end - initrd_start);
-
-			if (written != initrd_end - initrd_start)
-				pr_err("/initrd.image: incomplete write (%zd != %ld)\n",
-				       written, initrd_end - initrd_start);
-
-			ksys_close(fd);
-		}
+		populate_initrd_image(err);
 	done:
 		/* empty statement */;
 #else

commit 23091e287355440fb680868c23bcada594d3f399
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon May 13 17:18:21 2019 -0700

    initramfs: cleanup initrd freeing
    
    Factor the kexec logic into a separate helper, and then inline the rest of
    free_initrd into the only caller.
    
    Link: http://lkml.kernel.org/r/20190213174621.29297-4-hch@lst.de
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>   [arm64]
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>   [m68k]
    Cc: Steven Price <steven.price@arm.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index c322e1099f43..5fda9557a134 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -518,37 +518,35 @@ extern unsigned long __initramfs_size;
 #include <linux/initrd.h>
 #include <linux/kexec.h>
 
-static void __init free_initrd(void)
-{
 #ifdef CONFIG_KEXEC_CORE
+static bool kexec_free_initrd(void)
+{
 	unsigned long crashk_start = (unsigned long)__va(crashk_res.start);
 	unsigned long crashk_end   = (unsigned long)__va(crashk_res.end);
-#endif
-	if (do_retain_initrd)
-		goto skip;
 
-#ifdef CONFIG_KEXEC_CORE
 	/*
 	 * If the initrd region is overlapped with crashkernel reserved region,
 	 * free only memory that is not part of crashkernel region.
 	 */
-	if (initrd_start < crashk_end && initrd_end > crashk_start) {
-		/*
-		 * Initialize initrd memory region since the kexec boot does
-		 * not do.
-		 */
-		memset((void *)initrd_start, 0, initrd_end - initrd_start);
-		if (initrd_start < crashk_start)
-			free_initrd_mem(initrd_start, crashk_start);
-		if (initrd_end > crashk_end)
-			free_initrd_mem(crashk_end, initrd_end);
-	} else
-#endif
-		free_initrd_mem(initrd_start, initrd_end);
-skip:
-	initrd_start = 0;
-	initrd_end = 0;
+	if (initrd_start >= crashk_end || initrd_end <= crashk_start)
+		return false;
+
+	/*
+	 * Initialize initrd memory region since the kexec boot does not do.
+	 */
+	memset((void *)initrd_start, 0, initrd_end - initrd_start);
+	if (initrd_start < crashk_start)
+		free_initrd_mem(initrd_start, crashk_start);
+	if (initrd_end > crashk_end)
+		free_initrd_mem(crashk_end, initrd_end);
+	return true;
 }
+#else
+static inline bool kexec_free_initrd(void)
+{
+	return false;
+}
+#endif /* CONFIG_KEXEC_CORE */
 
 #ifdef CONFIG_BLK_DEV_RAM
 #define BUF_SIZE 1024
@@ -642,7 +640,16 @@ static int __init populate_rootfs(void)
 			printk(KERN_EMERG "Initramfs unpacking failed: %s\n", err);
 #endif
 	}
-	free_initrd();
+
+	/*
+	 * If the initrd region is overlapped with crashkernel reserved region,
+	 * free only memory that is not part of crashkernel region.
+	 */
+	if (!do_retain_initrd && !kexec_free_initrd())
+		free_initrd_mem(initrd_start, initrd_end);
+	initrd_start = 0;
+	initrd_end = 0;
+
 	flush_delayed_fput();
 	return 0;
 }

commit 54c7a8916a887f357088f99e9c3a7720cd57d2c8
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon May 13 17:18:17 2019 -0700

    initramfs: free initrd memory if opening /initrd.image fails
    
    Patch series "initramfs tidyups".
    
    I've spent some time chasing down behavior in initramfs and found
    plenty of opportunity to improve the code.  A first stab on that is
    contained in this series.
    
    This patch (of 7):
    
    We free the initrd memory for all successful or error cases except for the
    case where opening /initrd.image fails, which looks like an oversight.
    
    Steven said:
    
    : This also changes the behaviour when CONFIG_INITRAMFS_FORCE is enabled
    : - specifically it means that the initrd is freed (previously it was
    : ignored and never freed).  But that seems like reasonable behaviour and
    : the previous behaviour looks like another oversight.
    
    Link: http://lkml.kernel.org/r/20190213174621.29297-3-hch@lst.de
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Steven Price <steven.price@arm.com>
    Acked-by: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>   [arm64]
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>   [m68k]
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 4749e1115eef..c322e1099f43 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -612,13 +612,12 @@ static int __init populate_rootfs(void)
 		printk(KERN_INFO "Trying to unpack rootfs image as initramfs...\n");
 		err = unpack_to_rootfs((char *)initrd_start,
 			initrd_end - initrd_start);
-		if (!err) {
-			free_initrd();
+		if (!err)
 			goto done;
-		} else {
-			clean_rootfs();
-			unpack_to_rootfs(__initramfs_start, __initramfs_size);
-		}
+
+		clean_rootfs();
+		unpack_to_rootfs(__initramfs_start, __initramfs_size);
+
 		printk(KERN_INFO "rootfs image is not initramfs (%s)"
 				"; looks like an initrd\n", err);
 		fd = ksys_open("/initrd.image",
@@ -632,7 +631,6 @@ static int __init populate_rootfs(void)
 				       written, initrd_end - initrd_start);
 
 			ksys_close(fd);
-			free_initrd();
 		}
 	done:
 		/* empty statement */;
@@ -642,9 +640,9 @@ static int __init populate_rootfs(void)
 			initrd_end - initrd_start);
 		if (err)
 			printk(KERN_EMERG "Initramfs unpacking failed: %s\n", err);
-		free_initrd();
 #endif
 	}
+	free_initrd();
 	flush_delayed_fput();
 	return 0;
 }

commit e5eed351fd5eb73eecc1407cf00309e868379253
Author: David Engraf <david.engraf@sysgo.com>
Date:   Thu Mar 7 16:30:19 2019 -0800

    init/initramfs.c: provide more details in error messages
    
    Use distinct error messages when archive decompression failed.
    
    Link: http://lkml.kernel.org/r/20190212075635.7373-1-david.engraf@sysgo.com
    Signed-off-by: David Engraf <david.engraf@sysgo.com>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Tested-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index fca899622937..4749e1115eef 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -431,7 +431,7 @@ static long __init flush_buffer(void *bufv, unsigned long len)
 			len -= written;
 			state = Reset;
 		} else
-			error("junk in compressed archive");
+			error("junk within compressed archive");
 	}
 	return origLen;
 }
@@ -488,9 +488,9 @@ static char * __init unpack_to_rootfs(char *buf, unsigned long len)
 				message = msg_buf;
 			}
 		} else
-			error("junk in compressed archive");
+			error("invalid magic at start of compressed archive");
 		if (state != Reset)
-			error("junk in compressed archive");
+			error("junk at the end of compressed archive");
 		this_header = saved_offset + my_inptr;
 		buf += my_inptr;
 		len -= my_inptr;

commit a841c673f1352f607fd3ba85de6c9c49ff2c1e12
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Wed Feb 20 22:18:52 2019 -0800

    revert "initramfs: cleanup incomplete rootfs"
    
    Revert ff1522bb7d9845 ("initramfs: cleanup incomplete rootfs").
    
    Andy reports
    
    : This breaks my setup where I have U-boot provided more size of initramfs
    : than needed.  This allows a bit of flexibility to increase or decrease
    : initramfs compressed image without taking care of bootloader.  The proper
    : solution is to do this if we sure that we didn't get enough memory,
    : otherwise I can't consider the error fatal to clean up rootfs.
    
    Fixes: ff1522bb7d9845 ("initramfs: cleanup incomplete rootfs")
    Reported-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Tested-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: David Engraf <david.engraf@sysgo.com>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 7cea802d00ef..fca899622937 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -550,6 +550,7 @@ static void __init free_initrd(void)
 	initrd_end = 0;
 }
 
+#ifdef CONFIG_BLK_DEV_RAM
 #define BUF_SIZE 1024
 static void __init clean_rootfs(void)
 {
@@ -596,6 +597,7 @@ static void __init clean_rootfs(void)
 	ksys_close(fd);
 	kfree(buf);
 }
+#endif
 
 static int __init populate_rootfs(void)
 {
@@ -638,10 +640,8 @@ static int __init populate_rootfs(void)
 		printk(KERN_INFO "Unpacking initramfs...\n");
 		err = unpack_to_rootfs((char *)initrd_start,
 			initrd_end - initrd_start);
-		if (err) {
+		if (err)
 			printk(KERN_EMERG "Initramfs unpacking failed: %s\n", err);
-			clean_rootfs();
-		}
 		free_initrd();
 #endif
 	}

commit ff1522bb7d98450c72aea729f0b4147bc9986aed
Author: David Engraf <david.engraf@sysgo.com>
Date:   Thu Jan 3 15:28:31 2019 -0800

    initramfs: cleanup incomplete rootfs
    
    Unpacking an external initrd may fail e.g.  not enough memory.  This
    leads to an incomplete rootfs because some files might be extracted
    already.  Fixed by cleaning the rootfs so the kernel is not using an
    incomplete rootfs.
    
    Link: http://lkml.kernel.org/r/20181030151805.5519-1-david.engraf@sysgo.com
    Signed-off-by: David Engraf <david.engraf@sysgo.com>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index fca899622937..7cea802d00ef 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -550,7 +550,6 @@ static void __init free_initrd(void)
 	initrd_end = 0;
 }
 
-#ifdef CONFIG_BLK_DEV_RAM
 #define BUF_SIZE 1024
 static void __init clean_rootfs(void)
 {
@@ -597,7 +596,6 @@ static void __init clean_rootfs(void)
 	ksys_close(fd);
 	kfree(buf);
 }
-#endif
 
 static int __init populate_rootfs(void)
 {
@@ -640,8 +638,10 @@ static int __init populate_rootfs(void)
 		printk(KERN_INFO "Unpacking initramfs...\n");
 		err = unpack_to_rootfs((char *)initrd_start,
 			initrd_end - initrd_start);
-		if (err)
+		if (err) {
 			printk(KERN_EMERG "Initramfs unpacking failed: %s\n", err);
+			clean_rootfs();
+		}
 		free_initrd();
 #endif
 	}

commit 89d04ec3491bea6d69943b5aed62fdebfad49638
Merge: 8c2def893afc 2595646791c3
Author: Jens Axboe <axboe@kernel.dk>
Date:   Tue Dec 4 09:38:05 2018 -0700

    Merge tag 'v4.20-rc5' into for-4.21/block
    
    Pull in v4.20-rc5, solving a conflict we'll otherwise get in aio.c and
    also getting the merge fix that went into mainline that users are
    hitting testing for-4.21/block and/or for-next.
    
    * tag 'v4.20-rc5': (664 commits)
      Linux 4.20-rc5
      PCI: Fix incorrect value returned from pcie_get_speed_cap()
      MAINTAINERS: Update linux-mips mailing list address
      ocfs2: fix potential use after free
      mm/khugepaged: fix the xas_create_range() error path
      mm/khugepaged: collapse_shmem() do not crash on Compound
      mm/khugepaged: collapse_shmem() without freezing new_page
      mm/khugepaged: minor reorderings in collapse_shmem()
      mm/khugepaged: collapse_shmem() remember to clear holes
      mm/khugepaged: fix crashes due to misaccounted holes
      mm/khugepaged: collapse_shmem() stop if punched or truncated
      mm/huge_memory: fix lockdep complaint on 32-bit i_size_read()
      mm/huge_memory: splitting set mapping+index before unfreeze
      mm/huge_memory: rename freeze_page() to unmap_page()
      initramfs: clean old path before creating a hardlink
      kernel/kcov.c: mark funcs in __sanitizer_cov_trace_pc() as notrace
      psi: make disabling/enabling easier for vendor kernels
      proc: fixup map_files test on arm
      debugobjects: avoid recursive calls with kmemleak
      userfaultfd: shmem: UFFDIO_COPY: set the page dirty if VM_WRITE is not set
      ...

commit 7c0950d455d6ab610d2990a13120f935b75abf2c
Author: Li Zhijian <lizhijian@cn.fujitsu.com>
Date:   Fri Nov 30 14:10:09 2018 -0800

    initramfs: clean old path before creating a hardlink
    
    sys_link() can fail due to the new path already existing.  This case
    ofen occurs when we use a concated initrd, for example:
    
    1) prepare a basic rootfs, it contains a regular files rc.local
    lizhijian@:~/yocto-tiny-i386-2016-04-22$ cat etc/rc.local
     #!/bin/sh
     echo "Running /etc/rc.local..."
    yocto-tiny-i386-2016-04-22$ find . | sed 's,^\./,,' | cpio -o -H newc | gzip -n -9 >../rootfs.cgz
    
    2) create a extra initrd which also includes a etc/rc.local
    lizhijian@:~/lkp-x86_64/etc$ echo "append initrd" >rc.local
    lizhijian@:~/lkp/lkp-x86_64/etc$ cat rc.local
    append initrd
    lizhijian@:~/lkp/lkp-x86_64/etc$ ln rc.local rc.local.hardlink
    append initrd
    lizhijian@:~/lkp/lkp-x86_64/etc$ stat rc.local rc.local.hardlink
      File: 'rc.local'
      Size: 14              Blocks: 8          IO Block: 4096   regular file
    Device: 801h/2049d      Inode: 11296086    Links: 2
    Access: (0664/-rw-rw-r--)  Uid: ( 1002/lizhijian)   Gid: ( 1002/lizhijian)
    Access: 2018-11-15 16:08:28.654464815 +0800
    Modify: 2018-11-15 16:07:57.514903210 +0800
    Change: 2018-11-15 16:08:24.180228872 +0800
     Birth: -
      File: 'rc.local.hardlink'
      Size: 14              Blocks: 8          IO Block: 4096   regular file
    Device: 801h/2049d      Inode: 11296086    Links: 2
    Access: (0664/-rw-rw-r--)  Uid: ( 1002/lizhijian)   Gid: ( 1002/lizhijian)
    Access: 2018-11-15 16:08:28.654464815 +0800
    Modify: 2018-11-15 16:07:57.514903210 +0800
    Change: 2018-11-15 16:08:24.180228872 +0800
     Birth: -
    
    lizhijian@:~/lkp/lkp-x86_64$ find . | sed 's,^\./,,' | cpio -o -H newc | gzip -n -9 >../rc-local.cgz
    lizhijian@:~/lkp/lkp-x86_64$ gzip -dc ../rc-local.cgz | cpio -t
    .
    etc
    etc/rc.local.hardlink <<< it will be extracted first at this initrd
    etc/rc.local
    
    3) concate 2 initrds and boot
    lizhijian@:~/lkp$ cat rootfs.cgz rc-local.cgz >concate-initrd.cgz
    lizhijian@:~/lkp$ qemu-system-x86_64 -nographic -enable-kvm -cpu host -smp 1 -m 1024 -kernel ~/lkp/linux/arch/x86/boot/bzImage -append "console=ttyS0 earlyprint=ttyS0 ignore_loglevel" -initrd ./concate-initr.cgz -serial stdio -nodefaults
    
    In this case, sys_link(2) will fail and return -EEXIST, so we can only get
    the rc.local at rootfs.cgz instead of rc-local.cgz
    
    [akpm@linux-foundation.org: move code to avoid forward declaration]
    Link: http://lkml.kernel.org/r/1542352368-13299-1-git-send-email-lizhijian@cn.fujitsu.com
    Signed-off-by: Li Zhijian <lizhijian@cn.fujitsu.com>
    Cc: Philip Li <philip.li@intel.com>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Li Zhijian <zhijianx.li@intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 640557788026..f6f4a1e4cd54 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -291,16 +291,6 @@ static int __init do_reset(void)
 	return 1;
 }
 
-static int __init maybe_link(void)
-{
-	if (nlink >= 2) {
-		char *old = find_link(major, minor, ino, mode, collected);
-		if (old)
-			return (ksys_link(old, collected) < 0) ? -1 : 1;
-	}
-	return 0;
-}
-
 static void __init clean_path(char *path, umode_t fmode)
 {
 	struct kstat st;
@@ -313,6 +303,18 @@ static void __init clean_path(char *path, umode_t fmode)
 	}
 }
 
+static int __init maybe_link(void)
+{
+	if (nlink >= 2) {
+		char *old = find_link(major, minor, ino, mode, collected);
+		if (old) {
+			clean_path(collected, 0);
+			return (ksys_link(old, collected) < 0) ? -1 : 1;
+		}
+	}
+	return 0;
+}
+
 static __initdata int wfd;
 
 static int __init do_name(void)

commit a1ce35fa49852db60fc6e268038530be533c5b15
Author: Jens Axboe <axboe@kernel.dk>
Date:   Mon Oct 29 10:23:51 2018 -0600

    block: remove dead elevator code
    
    This removes a bunch of core and elevator related code. On the core
    front, we remove anything related to queue running, draining,
    initialization, plugging, and congestions. We also kill anything
    related to request allocation, merging, retrieval, and completion.
    
    Remove any checking for single queue IO schedulers, as they no
    longer exist. This means we can also delete a bunch of code related
    to request issue, adding, completion, etc - and all the SQ related
    ops and helpers.
    
    Also kill the load_default_modules(), as all that did was provide
    for a way to load the default single queue elevator.
    
    Tested-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Omar Sandoval <osandov@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/init/initramfs.c b/init/initramfs.c
index 640557788026..96af18fec4d0 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -644,12 +644,6 @@ static int __init populate_rootfs(void)
 #endif
 	}
 	flush_delayed_fput();
-	/*
-	 * Try loading default modules from initramfs.  This gives
-	 * us a chance to load before device_initcalls.
-	 */
-	load_default_modules();
-
 	return 0;
 }
 rootfs_initcall(populate_rootfs);

commit 6ad018e3ca9efd80a724e32c02ae7552fd0829f2
Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Date:   Tue Aug 21 21:58:30 2018 -0700

    init/: remove ineffective sparse disabling
    
    Sparse checking used to be disabled on init/do_mounts.c and a few related
    files because "Many of the syscalls used in this file expect some of the
    arguments to be __user pointers not __kernel pointers".
    
    However since 28128c61e ("kconfig.h: Include compiler types to avoid
    missed struct attributes") the checks are, in fact, not disabled anymore
    because of the more early include of "linux/compiler_types.h"
    
    So remove the now ineffective #undefery that was done to disable these
    warnings, as well as the associated comment.
    
    Link: http://lkml.kernel.org/r/20180617115355.53799-1-luc.vanoostenryck@gmail.com
    Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Kees Cook <keescook@chromium.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 13643c46ebab..640557788026 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -1,14 +1,4 @@
 // SPDX-License-Identifier: GPL-2.0
-/*
- * Many of the syscalls used in this file expect some of the arguments
- * to be __user pointers not __kernel pointers.  To limit the sparse
- * noise, turn off sparse checking for this file.
- */
-#ifdef __CHECKER__
-#undef __CHECKER__
-#warning "Sparse checking disabled for this file"
-#endif
-
 #include <linux/init.h>
 #include <linux/fs.h>
 #include <linux/slab.h>

commit 454dab3f965ec24fda8fbe135c8dad4c5b238a86
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Mar 13 21:34:04 2018 +0100

    fs: add ksys_getdents64() helper; remove in-kernel calls to sys_getdents64()
    
    Using this helper allows us to avoid the in-kernel calls to the
    sys_getdents64() syscall. The ksys_ prefix denotes that this function
    is meant as a drop-in replacement for the syscall. In particular, it
    uses the same calling convention as sys_getdents64().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/initramfs.c b/init/initramfs.c
index 5f2ff1d2370e..13643c46ebab 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -579,7 +579,7 @@ static void __init clean_rootfs(void)
 	}
 
 	dirp = buf;
-	num = sys_getdents64(fd, dirp, BUF_SIZE);
+	num = ksys_getdents64(fd, dirp, BUF_SIZE);
 	while (num > 0) {
 		while (num > 0) {
 			struct kstat st;
@@ -599,7 +599,7 @@ static void __init clean_rootfs(void)
 		}
 		dirp = buf;
 		memset(buf, 0, BUF_SIZE);
-		num = sys_getdents64(fd, dirp, BUF_SIZE);
+		num = ksys_getdents64(fd, dirp, BUF_SIZE);
 	}
 
 	ksys_close(fd);

commit bae217ea8c7e123ed3fb1064909a262924771bbb
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:56 2018 +0100

    fs: add ksys_open() wrapper; remove in-kernel calls to sys_open()
    
    Using this wrapper allows us to avoid the in-kernel calls to the
    sys_open() syscall. The ksys_ prefix denotes that this function is meant
    as a drop-in replacement for the syscall. In particular, it uses the
    same calling convention as sys_open().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/initramfs.c b/init/initramfs.c
index ce2bcad97cdf..5f2ff1d2370e 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -340,7 +340,7 @@ static int __init do_name(void)
 			int openflags = O_WRONLY|O_CREAT;
 			if (ml != 1)
 				openflags |= O_TRUNC;
-			wfd = sys_open(collected, openflags, mode);
+			wfd = ksys_open(collected, openflags, mode);
 
 			if (wfd >= 0) {
 				ksys_fchown(wfd, uid, gid);
@@ -567,7 +567,7 @@ static void __init clean_rootfs(void)
 	struct linux_dirent64 *dirp;
 	int num;
 
-	fd = sys_open("/", O_RDONLY, 0);
+	fd = ksys_open("/", O_RDONLY, 0);
 	WARN_ON(fd < 0);
 	if (fd < 0)
 		return;
@@ -629,7 +629,7 @@ static int __init populate_rootfs(void)
 		}
 		printk(KERN_INFO "rootfs image is not initramfs (%s)"
 				"; looks like an initrd\n", err);
-		fd = sys_open("/initrd.image",
+		fd = ksys_open("/initrd.image",
 			      O_WRONLY|O_CREAT, 0700);
 		if (fd >= 0) {
 			ssize_t written = xwrite(fd, (char *)initrd_start,

commit 2ca2a09d6215fd9621aa3e2db7cc9428a61f2911
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:55 2018 +0100

    fs: add ksys_close() wrapper; remove in-kernel calls to sys_close()
    
    Using the ksys_close() wrapper allows us to get rid of in-kernel calls
    to the sys_close() syscall. The ksys_ prefix denotes that this function
    is meant as a drop-in replacement for the syscall. In particular, it
    uses the same calling convention as sys_close(), with one subtle
    difference:
    
    The few places which checked the return value did not care about the return
    value re-writing in sys_close(), so simply use a wrapper around
    __close_fd().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/initramfs.c b/init/initramfs.c
index 0d3b001b0dc5..ce2bcad97cdf 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -373,7 +373,7 @@ static int __init do_copy(void)
 	if (byte_count >= body_len) {
 		if (xwrite(wfd, victim, body_len) != body_len)
 			error("write error");
-		sys_close(wfd);
+		ksys_close(wfd);
 		do_utime(vcollected, mtime);
 		kfree(vcollected);
 		eat(body_len);
@@ -574,7 +574,7 @@ static void __init clean_rootfs(void)
 	buf = kzalloc(BUF_SIZE, GFP_KERNEL);
 	WARN_ON(!buf);
 	if (!buf) {
-		sys_close(fd);
+		ksys_close(fd);
 		return;
 	}
 
@@ -602,7 +602,7 @@ static void __init clean_rootfs(void)
 		num = sys_getdents64(fd, dirp, BUF_SIZE);
 	}
 
-	sys_close(fd);
+	ksys_close(fd);
 	kfree(buf);
 }
 #endif
@@ -639,7 +639,7 @@ static int __init populate_rootfs(void)
 				pr_err("/initrd.image: incomplete write (%zd != %ld)\n",
 				       written, initrd_end - initrd_start);
 
-			sys_close(fd);
+			ksys_close(fd);
 			free_initrd();
 		}
 	done:

commit 411d9475cf901b5a6d2996b46cb5726184a4fa50
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:54 2018 +0100

    fs: add ksys_ftruncate() wrapper; remove in-kernel calls to sys_ftruncate()
    
    Using the ksys_ftruncate() wrapper allows us to get rid of in-kernel
    calls to the sys_ftruncate() syscall. The ksys_ prefix denotes that this
    function is meant as a drop-in replacement for the syscall. In
    particular, it uses the same calling convention as sys_ftruncate().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/initramfs.c b/init/initramfs.c
index 35173bef7c00..0d3b001b0dc5 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -346,7 +346,7 @@ static int __init do_name(void)
 				ksys_fchown(wfd, uid, gid);
 				ksys_fchmod(wfd, mode);
 				if (body_len)
-					sys_ftruncate(wfd, body_len);
+					ksys_ftruncate(wfd, body_len);
 				vcollected = kstrdup(collected, GFP_KERNEL);
 				state = CopyFile;
 			}

commit 55731b3cda3a85ee888dac3bf1f36489f275c187
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:55 2018 +0100

    fs: add do_fchownat(), ksys_fchown() helpers and ksys_{,l}chown() wrappers
    
    Using the fs-interal do_fchownat() wrapper allows us to get rid of
    fs-internal calls to the sys_fchownat() syscall.
    
    Introducing the ksys_fchown() helper and the ksys_{,}chown() wrappers
    allows us to avoid the in-kernel calls to the sys_{,l,f}chown() syscalls.
    The ksys_ prefix denotes that these functions are meant as a drop-in
    replacement for the syscalls. In particular, they use the same calling
    convention as sys_{,l,f}chown().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/initramfs.c b/init/initramfs.c
index 16c3c23076e2..35173bef7c00 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -343,7 +343,7 @@ static int __init do_name(void)
 			wfd = sys_open(collected, openflags, mode);
 
 			if (wfd >= 0) {
-				sys_fchown(wfd, uid, gid);
+				ksys_fchown(wfd, uid, gid);
 				ksys_fchmod(wfd, mode);
 				if (body_len)
 					sys_ftruncate(wfd, body_len);
@@ -353,14 +353,14 @@ static int __init do_name(void)
 		}
 	} else if (S_ISDIR(mode)) {
 		ksys_mkdir(collected, mode);
-		sys_chown(collected, uid, gid);
+		ksys_chown(collected, uid, gid);
 		ksys_chmod(collected, mode);
 		dir_add(collected, mtime);
 	} else if (S_ISBLK(mode) || S_ISCHR(mode) ||
 		   S_ISFIFO(mode) || S_ISSOCK(mode)) {
 		if (maybe_link() == 0) {
 			ksys_mknod(collected, mode, rdev);
-			sys_chown(collected, uid, gid);
+			ksys_chown(collected, uid, gid);
 			ksys_chmod(collected, mode);
 			do_utime(collected, mtime);
 		}
@@ -393,7 +393,7 @@ static int __init do_symlink(void)
 	collected[N_ALIGN(name_len) + body_len] = '\0';
 	clean_path(collected, 0);
 	ksys_symlink(collected + N_ALIGN(name_len), collected);
-	sys_lchown(collected, uid, gid);
+	ksys_lchown(collected, uid, gid);
 	do_utime(collected, mtime);
 	state = SkipIt;
 	next_state = Reset;

commit 03450e271a160bc07a2c48e5769e0ba338582d77
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:53 2018 +0100

    fs: add ksys_fchmod() and do_fchmodat() helpers and ksys_chmod() wrapper; remove in-kernel calls to syscall
    
    Using the fs-internal do_fchmodat() helper allows us to get rid of
    fs-internal calls to the sys_fchmodat() syscall.
    
    Introducing the ksys_fchmod() helper and the ksys_chmod() wrapper allows
    us to avoid the in-kernel calls to the sys_fchmod() and sys_chmod()
    syscalls. The ksys_ prefix denotes that these functions are meant as a
    drop-in replacement for the syscalls. In particular, they use the same
    calling convention as sys_fchmod() and sys_chmod().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/initramfs.c b/init/initramfs.c
index 5855ab632b4e..16c3c23076e2 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -344,7 +344,7 @@ static int __init do_name(void)
 
 			if (wfd >= 0) {
 				sys_fchown(wfd, uid, gid);
-				sys_fchmod(wfd, mode);
+				ksys_fchmod(wfd, mode);
 				if (body_len)
 					sys_ftruncate(wfd, body_len);
 				vcollected = kstrdup(collected, GFP_KERNEL);
@@ -354,14 +354,14 @@ static int __init do_name(void)
 	} else if (S_ISDIR(mode)) {
 		ksys_mkdir(collected, mode);
 		sys_chown(collected, uid, gid);
-		sys_chmod(collected, mode);
+		ksys_chmod(collected, mode);
 		dir_add(collected, mtime);
 	} else if (S_ISBLK(mode) || S_ISCHR(mode) ||
 		   S_ISFIFO(mode) || S_ISSOCK(mode)) {
 		if (maybe_link() == 0) {
 			ksys_mknod(collected, mode, rdev);
 			sys_chown(collected, uid, gid);
-			sys_chmod(collected, mode);
+			ksys_chmod(collected, mode);
 			do_utime(collected, mtime);
 		}
 	}

commit 46ea89eb652a365e10257016d09dcf1aaf23cf63
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:53 2018 +0100

    fs: add do_linkat() helper and ksys_link() wrapper; remove in-kernel calls to syscall
    
    Using the fs-internal do_linkat() helper allows us to get rid of
    fs-internal calls to the sys_linkat() syscall.
    
    Introducing the ksys_link() wrapper allows us to avoid the in-kernel
    calls to sys_link() syscall. The ksys_ prefix denotes that this function
    is meant as a drop-in replacement for the syscall. In particular, it uses
    the same calling convention as sys_link().
    
    In the near future, the only fs-external user of ksys_link() should be
    converted to use vfs_link() instead.
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/initramfs.c b/init/initramfs.c
index 2972ed0ab399..5855ab632b4e 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -306,7 +306,7 @@ static int __init maybe_link(void)
 	if (nlink >= 2) {
 		char *old = find_link(major, minor, ino, mode, collected);
 		if (old)
-			return (sys_link(old, collected) < 0) ? -1 : 1;
+			return (ksys_link(old, collected) < 0) ? -1 : 1;
 	}
 	return 0;
 }

commit 87c4e19262d81862886207be3c8795f6576d5a52
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:50 2018 +0100

    fs: add do_mknodat() helper and ksys_mknod() wrapper; remove in-kernel calls to syscall
    
    Using the fs-internal do_mknodat() helper allows us to get rid of
    fs-internal calls to the sys_mknodat() syscall.
    
    Introducing the ksys_mknod() wrapper allows us to avoid the in-kernel
    calls to sys_mknod() syscall. The ksys_ prefix denotes that this function
    is meant as a drop-in replacement for the syscall. In particular, it uses
    the same calling convention as sys_mknod().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/initramfs.c b/init/initramfs.c
index cd9571a113b6..2972ed0ab399 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -359,7 +359,7 @@ static int __init do_name(void)
 	} else if (S_ISBLK(mode) || S_ISCHR(mode) ||
 		   S_ISFIFO(mode) || S_ISSOCK(mode)) {
 		if (maybe_link() == 0) {
-			sys_mknod(collected, mode, rdev);
+			ksys_mknod(collected, mode, rdev);
 			sys_chown(collected, uid, gid);
 			sys_chmod(collected, mode);
 			do_utime(collected, mtime);

commit b724e846b491ef8db943be8086226c9d8da31877
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:49 2018 +0100

    fs: add do_symlinkat() helper and ksys_symlink() wrapper; remove in-kernel calls to syscall
    
    Using the fs-internal do_symlinkat() helper allows us to get rid of
    fs-internal calls to the sys_symlinkat() syscall.
    
    Introducing the ksys_symlink() wrapper allows us to avoid the in-kernel
    calls to the sys_symlink() syscall. The ksys_ prefix denotes that this
    function is meant as a drop-in replacement for the syscall. In particular,
    it uses the same calling convention as sys_symlink().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/initramfs.c b/init/initramfs.c
index ca538a5f9fa9..cd9571a113b6 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -392,7 +392,7 @@ static int __init do_symlink(void)
 {
 	collected[N_ALIGN(name_len) + body_len] = '\0';
 	clean_path(collected, 0);
-	sys_symlink(collected + N_ALIGN(name_len), collected);
+	ksys_symlink(collected + N_ALIGN(name_len), collected);
 	sys_lchown(collected, uid, gid);
 	do_utime(collected, mtime);
 	state = SkipIt;

commit 0101db7a301981a008296d522d8c1f456b0fe837
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:49 2018 +0100

    fs: add do_mkdirat() helper and ksys_mkdir() wrapper; remove in-kernel calls to syscall
    
    Using the fs-internal do_mkdirat() helper allows us to get rid of
    fs-internal calls to the sys_mkdirat() syscall.
    
    Introducing the ksys_mkdir() wrapper allows us to avoid the in-kernel calls
    to the sys_mkdir() syscall. The ksys_ prefix denotes that this function is
    meant as a drop-in replacement for the syscall. In particular, it uses the
    same calling convention as sys_mkdir().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/initramfs.c b/init/initramfs.c
index 73bbb227f868..ca538a5f9fa9 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -352,7 +352,7 @@ static int __init do_name(void)
 			}
 		}
 	} else if (S_ISDIR(mode)) {
-		sys_mkdir(collected, mode);
+		ksys_mkdir(collected, mode);
 		sys_chown(collected, uid, gid);
 		sys_chmod(collected, mode);
 		dir_add(collected, mtime);

commit f459dffae1c6026928bbe8e972daecb635b7b5e9
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:48 2018 +0100

    fs: add ksys_rmdir() wrapper; remove in-kernel calls to sys_rmdir()
    
    Using this wrapper allows us to avoid the in-kernel calls to the
    sys_rmdir() syscall. The ksys_ prefix denotes that this function is meant
    as a drop-in replacement for the syscall. In particular, it uses the same
    calling convention as sys_rmdir().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/initramfs.c b/init/initramfs.c
index 08eb551168a8..73bbb227f868 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -317,7 +317,7 @@ static void __init clean_path(char *path, umode_t fmode)
 
 	if (!vfs_lstat(path, &st) && (st.mode ^ fmode) & S_IFMT) {
 		if (S_ISDIR(st.mode))
-			sys_rmdir(path);
+			ksys_rmdir(path);
 		else
 			ksys_unlink(path);
 	}
@@ -589,7 +589,7 @@ static void __init clean_rootfs(void)
 			WARN_ON_ONCE(ret);
 			if (!ret) {
 				if (S_ISDIR(st.mode))
-					sys_rmdir(dirp->d_name);
+					ksys_rmdir(dirp->d_name);
 				else
 					ksys_unlink(dirp->d_name);
 			}

commit 0f32ab8cfac478be053cb526ced8918ef6f4df47
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:47 2018 +0100

    fs: add ksys_unlink() wrapper; remove in-kernel calls to sys_unlink()
    
    Using this wrapper allows us to avoid the in-kernel calls to the
    sys_unlink() syscall. The ksys_ prefix denotes that this function is meant
    s a drop-in replacement for the syscall. In particular, it uses the same
    calling convention as sys_unlink().
    
    In the near future, all callers of ksys_unlink() should be converted to
    call do_unlinkat() directly or, at least, to operate on regular kernel
    pointers.
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/initramfs.c b/init/initramfs.c
index 6f972df15bf2..08eb551168a8 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -319,7 +319,7 @@ static void __init clean_path(char *path, umode_t fmode)
 		if (S_ISDIR(st.mode))
 			sys_rmdir(path);
 		else
-			sys_unlink(path);
+			ksys_unlink(path);
 	}
 }
 
@@ -591,7 +591,7 @@ static void __init clean_rootfs(void)
 				if (S_ISDIR(st.mode))
 					sys_rmdir(dirp->d_name);
 				else
-					sys_unlink(dirp->d_name);
+					ksys_unlink(dirp->d_name);
 			}
 
 			num -= dirp->d_reclen;

commit e7a3e8b2edf544ec28f689385c3adc2903f46ec0
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:41 2018 +0100

    fs: add ksys_write() helper; remove in-kernel calls to sys_write()
    
    Using this helper allows us to avoid the in-kernel calls to the sys_write()
    syscall. The ksys_ prefix denotes that this function is meant as a drop-in
    replacement for the syscall. In particular, it uses the same calling
    convention as sys_write().
    
    In the near future, the do_mounts / initramfs callers of ksys_write()
    should be converted to use filp_open() and vfs_write() instead.
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: linux-s390@vger.kernel.org
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/init/initramfs.c b/init/initramfs.c
index 7e99a0038942..6f972df15bf2 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -27,7 +27,7 @@ static ssize_t __init xwrite(int fd, const char *p, size_t count)
 
 	/* sys_write only can write MAX_RW_COUNT aka 2G-4K bytes at most */
 	while (count) {
-		ssize_t rv = sys_write(fd, p, count);
+		ssize_t rv = ksys_write(fd, p, count);
 
 		if (rv < 0) {
 			if (rv == -EINTR || rv == -EAGAIN)

commit e35c4c64fe492b212f9c7d9e046626e48e89f863
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Nov 17 15:31:04 2017 -0800

    initramfs: use time64_t timestamps
    
    The cpio format uses a 32-bit number to encode file timestamps, which
    breaks initramfs support in 2038.  This reinterprets the timestamp as
    unsigned, to give us another 68 years and avoids breaking until 2106.
    
    Link: http://lkml.kernel.org/r/20171019095536.801199-1-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Deepa Dinamani <deepa.kernel@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Stafford Horne <shorne@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 7046feffef6b..7e99a0038942 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -109,7 +109,7 @@ static void __init free_hash(void)
 	}
 }
 
-static long __init do_utime(char *filename, time_t mtime)
+static long __init do_utime(char *filename, time64_t mtime)
 {
 	struct timespec64 t[2];
 
@@ -125,10 +125,10 @@ static __initdata LIST_HEAD(dir_list);
 struct dir_entry {
 	struct list_head list;
 	char *name;
-	time_t mtime;
+	time64_t mtime;
 };
 
-static void __init dir_add(const char *name, time_t mtime)
+static void __init dir_add(const char *name, time64_t mtime)
 {
 	struct dir_entry *de = kmalloc(sizeof(struct dir_entry), GFP_KERNEL);
 	if (!de)
@@ -150,7 +150,7 @@ static void __init dir_utime(void)
 	}
 }
 
-static __initdata time_t mtime;
+static __initdata time64_t mtime;
 
 /* cpio header parsing */
 
@@ -177,7 +177,7 @@ static void __init parse_header(char *s)
 	uid = parsed[2];
 	gid = parsed[3];
 	nlink = parsed[4];
-	mtime = parsed[5];
+	mtime = parsed[5]; /* breaks in y2106 */
 	body_len = parsed[6];
 	major = parsed[7];
 	minor = parsed[8];

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index e64bf7b4c1ca..7046feffef6b 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Many of the syscalls used in this file expect some of the arguments
  * to be __user pointers not __kernel pointers.  To limit the sparse

commit aaed2dd8a31359e5767ee099ecbb078d55be4d29
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Wed Aug 2 19:51:15 2017 -0700

    utimes: Make utimes y2038 safe
    
    struct timespec is not y2038 safe on 32 bit machines.
    Replace timespec with y2038 safe struct timespec64.
    
    Note that the patch only changes the internals without
    modifying the syscall interfaces. This will be part
    of a separate series.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/init/initramfs.c b/init/initramfs.c
index 8a532050043f..e64bf7b4c1ca 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -110,7 +110,7 @@ static void __init free_hash(void)
 
 static long __init do_utime(char *filename, time_t mtime)
 {
-	struct timespec t[2];
+	struct timespec64 t[2];
 
 	t[0].tv_sec = mtime;
 	t[0].tv_nsec = 0;

commit 046aa1265f08d8400bd4b63171238c9daba15ec3
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon May 8 15:57:00 2017 -0700

    initramfs: use vfs_stat/lstat directly
    
    sys_newlstat is a system call implementation that is meant for user
    space, and that copies kernel-internal data structure to the user
    format, which is not needed for in-kernel users.
    
    Further, as we rearrange the system call implementation so we can extend
    it with 64-bit time_t, the prototype for sys_newlstat changes.
    
    This changes the initramfs code to use vfs_lstat directly, to get it out
    of the way of the time_t changes, and make it slightly more efficient in
    the process.  Along the same lines we also replace sys_stat and
    sys_stat64 with vfs_stat.
    
    Link: http://lkml.kernel.org/r/20170314214932.4052842-1-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 9d180273ee8c..8a532050043f 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -312,10 +312,10 @@ static int __init maybe_link(void)
 
 static void __init clean_path(char *path, umode_t fmode)
 {
-	struct stat st;
+	struct kstat st;
 
-	if (!sys_newlstat(path, &st) && (st.st_mode ^ fmode) & S_IFMT) {
-		if (S_ISDIR(st.st_mode))
+	if (!vfs_lstat(path, &st) && (st.mode ^ fmode) & S_IFMT) {
+		if (S_ISDIR(st.mode))
 			sys_rmdir(path);
 		else
 			sys_unlink(path);
@@ -581,13 +581,13 @@ static void __init clean_rootfs(void)
 	num = sys_getdents64(fd, dirp, BUF_SIZE);
 	while (num > 0) {
 		while (num > 0) {
-			struct stat st;
+			struct kstat st;
 			int ret;
 
-			ret = sys_newlstat(dirp->d_name, &st);
+			ret = vfs_lstat(dirp->d_name, &st);
 			WARN_ON_ONCE(ret);
 			if (!ret) {
-				if (S_ISDIR(st.st_mode))
+				if (S_ISDIR(st.mode))
 					sys_rmdir(dirp->d_name);
 				else
 					sys_unlink(dirp->d_name);

commit cff75e0b6fe835800f8e08a32d731119cd9e3b79
Author: Daniel Thompson <daniel.thompson@linaro.org>
Date:   Mon May 8 15:56:57 2017 -0700

    initramfs: provide a way to ignore image provided by bootloader
    
    Many "embedded" architectures provide CMDLINE_FORCE to allow the kernel
    to override the command line provided by an inflexible bootloader.
    However there is currrently no way for the kernel to override the
    initramfs image provided by the bootloader meaning there are still ways
    for bootloaders to make things difficult for us.
    
    Fix this by introducing INITRAMFS_FORCE which can prevent the kernel
    from loading the bootloader supplied image.
    
    We use CMDLINE_FORCE (and its friend CMDLINE_EXTEND) to imply that the
    system has an inflexible bootloader.  This allow us to avoid presenting
    this config option to users of systems where inflexible bootloaders
    aren't usually a problem.
    
    Link: http://lkml.kernel.org/r/20170217121940.30126-1-daniel.thompson@linaro.org
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 8daf7ac6c7e2..9d180273ee8c 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -613,7 +613,7 @@ static int __init populate_rootfs(void)
 	if (err)
 		panic("%s", err); /* Failed to decompress INTERNAL initramfs */
 	/* If available load the bootloader supplied initrd */
-	if (initrd_start) {
+	if (initrd_start && !IS_ENABLED(CONFIG_INITRAMFS_FORCE)) {
 #ifdef CONFIG_BLK_DEV_RAM
 		int fd;
 		printk(KERN_INFO "Trying to unpack rootfs image as initramfs...\n");

commit 394e4f5d5834b610ee032cceb20a1b1f45b01d28
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat May 6 10:27:13 2017 -0700

    initramfs: avoid "label at end of compound statement" error
    
    Commit 17a9be317475 ("initramfs: Always do fput() and load modules after
    rootfs populate") introduced an error for the
    
        CONFIG_BLK_DEV_RAM=y
    
    case, because even though the code looks fine, the compiler really wants
    a statement after a label, or you'll get complaints:
    
      init/initramfs.c: In function 'populate_rootfs':
      init/initramfs.c:644:2: error: label at end of compound statement
    
    That commit moved the subsequent statements to outside the compound
    statement, leaving the label without any associated statements.
    
    Reported-by: Jörg Otte <jrg.otte@gmail.com>
    Fixes: 17a9be317475 ("initramfs: Always do fput() and load modules after rootfs populate")
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: stable@vger.kernel.org  # if 17a9be317475 gets backported
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 3a6871597351..8daf7ac6c7e2 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -642,6 +642,7 @@ static int __init populate_rootfs(void)
 			free_initrd();
 		}
 	done:
+		/* empty statement */;
 #else
 		printk(KERN_INFO "Unpacking initramfs...\n");
 		err = unpack_to_rootfs((char *)initrd_start,

commit 17a9be31747535184f2af156b1f080ec4c92a952
Author: Stafford Horne <shorne@gmail.com>
Date:   Thu May 4 21:15:56 2017 +0900

    initramfs: Always do fput() and load modules after rootfs populate
    
    In OpenRISC we do not have a bootloader passed initrd, but the built in
    initramfs does contain the /init and other binaries, including modules.
    The previous commit 08865514805d2 ("initramfs: finish fput() before
    accessing any binary from initramfs") made a change to only call fput()
    if the bootloader initrd was available, this caused intermittent crashes
    for OpenRISC.
    
    This patch changes the fput() to happen unconditionally if any rootfs is
    loaded. Also, I added some comments to make it a bit more clear why we
    call unpack_to_rootfs() multiple times.
    
    Fixes: 08865514805d2 ("initramfs: finish fput() before accessing any binary from initramfs")
    Cc: stable@vger.kernel.org
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Stafford Horne <shorne@gmail.com>

diff --git a/init/initramfs.c b/init/initramfs.c
index 981f286c1d16..3a6871597351 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -608,9 +608,11 @@ static void __init clean_rootfs(void)
 
 static int __init populate_rootfs(void)
 {
+	/* Load the built in initramfs */
 	char *err = unpack_to_rootfs(__initramfs_start, __initramfs_size);
 	if (err)
 		panic("%s", err); /* Failed to decompress INTERNAL initramfs */
+	/* If available load the bootloader supplied initrd */
 	if (initrd_start) {
 #ifdef CONFIG_BLK_DEV_RAM
 		int fd;
@@ -648,13 +650,14 @@ static int __init populate_rootfs(void)
 			printk(KERN_EMERG "Initramfs unpacking failed: %s\n", err);
 		free_initrd();
 #endif
-		flush_delayed_fput();
-		/*
-		 * Try loading default modules from initramfs.  This gives
-		 * us a chance to load before device_initcalls.
-		 */
-		load_default_modules();
 	}
+	flush_delayed_fput();
+	/*
+	 * Try loading default modules from initramfs.  This gives
+	 * us a chance to load before device_initcalls.
+	 */
+	load_default_modules();
+
 	return 0;
 }
 rootfs_initcall(populate_rootfs);

commit 08865514805d2de8e7002fa8149c5de3e391f412
Author: Lokesh Vutla <lokeshvutla@ti.com>
Date:   Mon Feb 27 14:28:12 2017 -0800

    initramfs: finish fput() before accessing any binary from initramfs
    
    Commit 4a9d4b024a31 ("switch fput to task_work_add") implements a
    schedule_work() for completing fput(), but did not guarantee calling
    __fput() after unpacking initramfs.  Because of this, there is a
    possibility that during boot a driver can see ETXTBSY when it tries to
    load a binary from initramfs as fput() is still pending on that binary.
    
    This patch makes sure that fput() is completed after unpacking initramfs
    and removes the call to flush_delayed_fput() in kernel_init() which
    happens very late after unpacking initramfs.
    
    Link: http://lkml.kernel.org/r/20170201140540.22051-1-lokeshvutla@ti.com
    Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
    Reported-by: Murali Karicheri <m-karicheri2@ti.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: Sekhar Nori <nsekhar@ti.com>
    Cc: Nishanth Menon <nm@ti.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index b32ad7d97ac9..981f286c1d16 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -18,6 +18,7 @@
 #include <linux/dirent.h>
 #include <linux/syscalls.h>
 #include <linux/utime.h>
+#include <linux/file.h>
 
 static ssize_t __init xwrite(int fd, const char *p, size_t count)
 {
@@ -647,6 +648,7 @@ static int __init populate_rootfs(void)
 			printk(KERN_EMERG "Initramfs unpacking failed: %s\n", err);
 		free_initrd();
 #endif
+		flush_delayed_fput();
 		/*
 		 * Try loading default modules from initramfs.  This gives
 		 * us a chance to load before device_initcalls.

commit 2965faa5e03d1e71e9ff9aa143fff39e0a77543a
Author: Dave Young <dyoung@redhat.com>
Date:   Wed Sep 9 15:38:55 2015 -0700

    kexec: split kexec_load syscall from kexec core code
    
    There are two kexec load syscalls, kexec_load another and kexec_file_load.
     kexec_file_load has been splited as kernel/kexec_file.c.  In this patch I
    split kexec_load syscall code to kernel/kexec.c.
    
    And add a new kconfig option KEXEC_CORE, so we can disable kexec_load and
    use kexec_file_load only, or vice verse.
    
    The original requirement is from Ted Ts'o, he want kexec kernel signature
    being checked with CONFIG_KEXEC_VERIFY_SIG enabled.  But kexec-tools use
    kexec_load syscall can bypass the checking.
    
    Vivek Goyal proposed to create a common kconfig option so user can compile
    in only one syscall for loading kexec kernel.  KEXEC/KEXEC_FILE selects
    KEXEC_CORE so that old config files still work.
    
    Because there's general code need CONFIG_KEXEC_CORE, so I updated all the
    architecture Kconfig with a new option KEXEC_CORE, and let KEXEC selects
    KEXEC_CORE in arch Kconfig.  Also updated general kernel code with to
    kexec_load syscall.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Vivek Goyal <vgoyal@redhat.com>
    Cc: Petr Tesarik <ptesarik@suse.cz>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: Josh Boyer <jwboyer@fedoraproject.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index ad1bd7787bbb..b32ad7d97ac9 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -526,14 +526,14 @@ extern unsigned long __initramfs_size;
 
 static void __init free_initrd(void)
 {
-#ifdef CONFIG_KEXEC
+#ifdef CONFIG_KEXEC_CORE
 	unsigned long crashk_start = (unsigned long)__va(crashk_res.start);
 	unsigned long crashk_end   = (unsigned long)__va(crashk_res.end);
 #endif
 	if (do_retain_initrd)
 		goto skip;
 
-#ifdef CONFIG_KEXEC
+#ifdef CONFIG_KEXEC_CORE
 	/*
 	 * If the initrd region is overlapped with crashkernel reserved region,
 	 * free only memory that is not part of crashkernel region.

commit c34d85aca91729596f876604e147892b81ecbbe9
Author: Mark Rustad <mark.d.rustad@intel.com>
Date:   Mon Oct 13 15:54:07 2014 -0700

    init/initramfs.c: resolve shadow warnings
    
    Resolve shadow warnings that are produced in W=2 builds by renaming a
    global with a too-generic name and renaming a formal parameter.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Mark Rustad <mark.d.rustad@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index bece48c3461e..ad1bd7787bbb 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -197,14 +197,14 @@ static __initdata enum state {
 } state, next_state;
 
 static __initdata char *victim;
-static unsigned long count __initdata;
+static unsigned long byte_count __initdata;
 static __initdata loff_t this_header, next_header;
 
 static inline void __init eat(unsigned n)
 {
 	victim += n;
 	this_header += n;
-	count -= n;
+	byte_count -= n;
 }
 
 static __initdata char *vcollected;
@@ -214,7 +214,7 @@ static __initdata char *collect;
 
 static void __init read_into(char *buf, unsigned size, enum state next)
 {
-	if (count >= size) {
+	if (byte_count >= size) {
 		collected = victim;
 		eat(size);
 		state = next;
@@ -237,8 +237,8 @@ static int __init do_start(void)
 static int __init do_collect(void)
 {
 	unsigned long n = remains;
-	if (count < n)
-		n = count;
+	if (byte_count < n)
+		n = byte_count;
 	memcpy(collect, victim, n);
 	eat(n);
 	collect += n;
@@ -280,8 +280,8 @@ static int __init do_header(void)
 
 static int __init do_skip(void)
 {
-	if (this_header + count < next_header) {
-		eat(count);
+	if (this_header + byte_count < next_header) {
+		eat(byte_count);
 		return 1;
 	} else {
 		eat(next_header - this_header);
@@ -292,9 +292,9 @@ static int __init do_skip(void)
 
 static int __init do_reset(void)
 {
-	while(count && *victim == '\0')
+	while (byte_count && *victim == '\0')
 		eat(1);
-	if (count && (this_header & 3))
+	if (byte_count && (this_header & 3))
 		error("broken padding");
 	return 1;
 }
@@ -309,11 +309,11 @@ static int __init maybe_link(void)
 	return 0;
 }
 
-static void __init clean_path(char *path, umode_t mode)
+static void __init clean_path(char *path, umode_t fmode)
 {
 	struct stat st;
 
-	if (!sys_newlstat(path, &st) && (st.st_mode^mode) & S_IFMT) {
+	if (!sys_newlstat(path, &st) && (st.st_mode ^ fmode) & S_IFMT) {
 		if (S_ISDIR(st.st_mode))
 			sys_rmdir(path);
 		else
@@ -368,7 +368,7 @@ static int __init do_name(void)
 
 static int __init do_copy(void)
 {
-	if (count >= body_len) {
+	if (byte_count >= body_len) {
 		if (xwrite(wfd, victim, body_len) != body_len)
 			error("write error");
 		sys_close(wfd);
@@ -378,10 +378,10 @@ static int __init do_copy(void)
 		state = SkipIt;
 		return 0;
 	} else {
-		if (xwrite(wfd, victim, count) != count)
+		if (xwrite(wfd, victim, byte_count) != byte_count)
 			error("write error");
-		body_len -= count;
-		eat(count);
+		body_len -= byte_count;
+		eat(byte_count);
 		return 1;
 	}
 }
@@ -411,12 +411,12 @@ static __initdata int (*actions[])(void) = {
 
 static long __init write_buffer(char *buf, unsigned long len)
 {
-	count = len;
+	byte_count = len;
 	victim = buf;
 
 	while (!actions[state]())
 		;
-	return len - count;
+	return len - byte_count;
 }
 
 static long __init flush_buffer(void *bufv, unsigned long len)

commit 9687fd9101afaa1c4b1de7ffd2f9d7e53f45b29f
Author: David Engraf <david.engraf@sysgo.com>
Date:   Fri Aug 8 14:23:16 2014 -0700

    initramfs: add write error checks
    
    On a system with low memory extracting the initramfs may fail.  If this
    happens the user gets "Failed to execute /init" instead of an initramfs
    error.
    
    Check return value of sys_write and call error() when the write was
    incomplete or failed.
    
    Signed-off-by: David Engraf <david.engraf@sysgo.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index a7566031242e..bece48c3461e 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -369,7 +369,8 @@ static int __init do_name(void)
 static int __init do_copy(void)
 {
 	if (count >= body_len) {
-		xwrite(wfd, victim, body_len);
+		if (xwrite(wfd, victim, body_len) != body_len)
+			error("write error");
 		sys_close(wfd);
 		do_utime(vcollected, mtime);
 		kfree(vcollected);
@@ -377,7 +378,8 @@ static int __init do_copy(void)
 		state = SkipIt;
 		return 0;
 	} else {
-		xwrite(wfd, victim, count);
+		if (xwrite(wfd, victim, count) != count)
+			error("write error");
 		body_len -= count;
 		eat(count);
 		return 1;

commit d97b07c54f34e88352ebe676beb798c8f59ac588
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Aug 8 14:23:14 2014 -0700

    initramfs: support initramfs that is bigger than 2GiB
    
    Now with 64bit bzImage and kexec tools, we support ramdisk that size is
    bigger than 2g, as we could put it above 4G.
    
    Found compressed initramfs image could not be decompressed properly.  It
    turns out that image length is int during decompress detection, and it
    will become < 0 when length is more than 2G.  Furthermore, during
    decompressing len as int is used for inbuf count, that has problem too.
    
    Change len to long, that should be ok as on 32 bit platform long is
    32bits.
    
    Tested with following compressed initramfs image as root with kexec.
            gzip, bzip2, xz, lzma, lzop, lz4.
    run time for populate_rootfs():
       size        name       Nehalem-EX  Westmere-EX  Ivybridge-EX
     9034400256 root_img     :   26s           24s          30s
     3561095057 root_img.lz4 :   28s           27s          27s
     3459554629 root_img.lzo :   29s           29s          28s
     3219399480 root_img.gz  :   64s           62s          49s
     2251594592 root_img.xz  :  262s          260s         183s
     2226366598 root_img.lzma:  386s          376s         277s
     2901482513 root_img.bz2 :  635s          599s
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Rashika Kheria <rashika.kheria@gmail.com>
    Cc: Josh Triplett <josh@joshtriplett.org>
    Cc: Kyungsik Lee <kyungsik.lee@lge.com>
    Cc: P J P <ppandit@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
    Cc: "Daniel M. Weeks" <dan@danweeks.net>
    Cc: Alexandre Courbot <acourbot@nvidia.com>
    Cc: Jan Beulich <JBeulich@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 4f276b6a167b..a7566031242e 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -197,7 +197,7 @@ static __initdata enum state {
 } state, next_state;
 
 static __initdata char *victim;
-static __initdata unsigned count;
+static unsigned long count __initdata;
 static __initdata loff_t this_header, next_header;
 
 static inline void __init eat(unsigned n)
@@ -209,7 +209,7 @@ static inline void __init eat(unsigned n)
 
 static __initdata char *vcollected;
 static __initdata char *collected;
-static __initdata int remains;
+static long remains __initdata;
 static __initdata char *collect;
 
 static void __init read_into(char *buf, unsigned size, enum state next)
@@ -236,7 +236,7 @@ static int __init do_start(void)
 
 static int __init do_collect(void)
 {
-	unsigned n = remains;
+	unsigned long n = remains;
 	if (count < n)
 		n = count;
 	memcpy(collect, victim, n);
@@ -407,7 +407,7 @@ static __initdata int (*actions[])(void) = {
 	[Reset]		= do_reset,
 };
 
-static int __init write_buffer(char *buf, unsigned len)
+static long __init write_buffer(char *buf, unsigned long len)
 {
 	count = len;
 	victim = buf;
@@ -417,11 +417,11 @@ static int __init write_buffer(char *buf, unsigned len)
 	return len - count;
 }
 
-static int __init flush_buffer(void *bufv, unsigned len)
+static long __init flush_buffer(void *bufv, unsigned long len)
 {
 	char *buf = (char *) bufv;
-	int written;
-	int origLen = len;
+	long written;
+	long origLen = len;
 	if (message)
 		return -1;
 	while ((written = write_buffer(buf, len)) < len && !message) {
@@ -440,13 +440,13 @@ static int __init flush_buffer(void *bufv, unsigned len)
 	return origLen;
 }
 
-static unsigned my_inptr;   /* index of next byte to be processed in inbuf */
+static unsigned long my_inptr; /* index of next byte to be processed in inbuf */
 
 #include <linux/decompress/generic.h>
 
-static char * __init unpack_to_rootfs(char *buf, unsigned len)
+static char * __init unpack_to_rootfs(char *buf, unsigned long len)
 {
-	int written, res;
+	long written;
 	decompress_fn decompress;
 	const char *compress_name;
 	static __initdata char msg_buf[64];
@@ -480,7 +480,7 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len)
 		decompress = decompress_method(buf, len, &compress_name);
 		pr_debug("Detected %s compressed data\n", compress_name);
 		if (decompress) {
-			res = decompress(buf, len, NULL, flush_buffer, NULL,
+			int res = decompress(buf, len, NULL, flush_buffer, NULL,
 				   &my_inptr, error);
 			if (res)
 				error("decompressor failed");

commit 38747439914c468ecba70b492b54dc4ef0b50453
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Aug 8 14:23:12 2014 -0700

    initramfs: support initrd that is bigger than 2GiB
    
    When initrd (compressed or not) is used, kernel report data corrupted with
    /dev/ram0.
    
    The root cause:
    During initramfs checking, if it is initrd, it will be transferred to
    /initrd.image with sys_write.
    sys_write only support 2G-4K write, so if the initrd ram is more than
    that, /initrd.image will not complete at all.
    
    Add local xwrite to loop calling sys_write to workaround the problem.
    
    Also need to use xwrite in write_buffer() to handle:
    image is uncompressed cpio and there is one big file (>2G) in it.
       unpack_to_rootfs ===> write_buffer ===> actions[]/do_copy
    
    At the same time, we don't need to worry about sys_read/sys_write in
    do_mounts_rd.c::crd_load.  As decompressor will have fill/flush and local
    buffer that is smaller than 2G.
    
    Test with uncompressed initrd, and compressed ones with gz, bz2, lzma,xz,
    lzop.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
    Cc: "Daniel M. Weeks" <dan@danweeks.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index a8497fab1c3d..4f276b6a167b 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -19,6 +19,29 @@
 #include <linux/syscalls.h>
 #include <linux/utime.h>
 
+static ssize_t __init xwrite(int fd, const char *p, size_t count)
+{
+	ssize_t out = 0;
+
+	/* sys_write only can write MAX_RW_COUNT aka 2G-4K bytes at most */
+	while (count) {
+		ssize_t rv = sys_write(fd, p, count);
+
+		if (rv < 0) {
+			if (rv == -EINTR || rv == -EAGAIN)
+				continue;
+			return out ? out : rv;
+		} else if (rv == 0)
+			break;
+
+		p += rv;
+		out += rv;
+		count -= rv;
+	}
+
+	return out;
+}
+
 static __initdata char *message;
 static void __init error(char *x)
 {
@@ -346,7 +369,7 @@ static int __init do_name(void)
 static int __init do_copy(void)
 {
 	if (count >= body_len) {
-		sys_write(wfd, victim, body_len);
+		xwrite(wfd, victim, body_len);
 		sys_close(wfd);
 		do_utime(vcollected, mtime);
 		kfree(vcollected);
@@ -354,7 +377,7 @@ static int __init do_copy(void)
 		state = SkipIt;
 		return 0;
 	} else {
-		sys_write(wfd, victim, count);
+		xwrite(wfd, victim, count);
 		body_len -= count;
 		eat(count);
 		return 1;
@@ -603,8 +626,13 @@ static int __init populate_rootfs(void)
 		fd = sys_open("/initrd.image",
 			      O_WRONLY|O_CREAT, 0700);
 		if (fd >= 0) {
-			sys_write(fd, (char *)initrd_start,
-					initrd_end - initrd_start);
+			ssize_t written = xwrite(fd, (char *)initrd_start,
+						initrd_end - initrd_start);
+
+			if (written != initrd_end - initrd_start)
+				pr_err("/initrd.image: incomplete write (%zd != %ld)\n",
+				       written, initrd_end - initrd_start);
+
 			sys_close(fd);
 			free_initrd();
 		}

commit 6aa7a29aa8378fa868fabef6a84b0a40d5d9d677
Author: Daniel M. Weeks <dan@danweeks.net>
Date:   Mon Apr 7 15:39:16 2014 -0700

    initramfs: debug detected compression method
    
    This can greatly aid in narrowing down the real source of initramfs
    problems such as failures related to the compression of the in-kernel
    initramfs when an external initramfs is in use as well.  Existing errors
    are ambiguous as to which initramfs is a problem and why.
    
    [akpm@linux-foundation.org: use pr_debug()]
    Signed-off-by: Daniel M. Weeks <dan@danweeks.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 93b61396756b..a8497fab1c3d 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -455,6 +455,7 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len)
 		}
 		this_header = 0;
 		decompress = decompress_method(buf, len, &compress_name);
+		pr_debug("Detected %s compressed data\n", compress_name);
 		if (decompress) {
 			res = decompress(buf, len, NULL, flush_buffer, NULL,
 				   &my_inptr, error);

commit 499a4584d7f817d43d09ccfc6bb26315eeaab6bc
Author: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
Date:   Thu Jan 23 15:54:56 2014 -0800

    init: fix possible format string bug
    
    Use constant format string in case message changes.
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index a67ef9dbda9d..93b61396756b 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -583,7 +583,7 @@ static int __init populate_rootfs(void)
 {
 	char *err = unpack_to_rootfs(__initramfs_start, __initramfs_size);
 	if (err)
-		panic(err);	/* Failed to decompress INTERNAL initramfs */
+		panic("%s", err); /* Failed to decompress INTERNAL initramfs */
 	if (initrd_start) {
 #ifdef CONFIG_BLK_DEV_RAM
 		int fd;

commit bb813f4c933ae9f887a014483690d5f8b8ec05e1
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 18 14:05:56 2013 -0800

    init, block: try to load default elevator module early during boot
    
    This patch adds default module loading and uses it to load the default
    block elevator.  During boot, it's called right after initramfs or
    initrd is made available and right before control is passed to
    userland.  This ensures that as long as the modules are available in
    the usual places in initramfs, initrd or the root filesystem, the
    default modules are loaded as soon as possible.
    
    This will replace the on-demand elevator module loading from elevator
    init path.
    
    v2: Fixed build breakage when !CONFIG_BLOCK.  Reported by kbuild test
        robot.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Alex Riesen <raa.lkml@gmail.com>
    Cc: Fengguang We <fengguang.wu@intel.com>

diff --git a/init/initramfs.c b/init/initramfs.c
index 84c6bf111300..a67ef9dbda9d 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -592,7 +592,7 @@ static int __init populate_rootfs(void)
 			initrd_end - initrd_start);
 		if (!err) {
 			free_initrd();
-			return 0;
+			goto done;
 		} else {
 			clean_rootfs();
 			unpack_to_rootfs(__initramfs_start, __initramfs_size);
@@ -607,6 +607,7 @@ static int __init populate_rootfs(void)
 			sys_close(fd);
 			free_initrd();
 		}
+	done:
 #else
 		printk(KERN_INFO "Unpacking initramfs...\n");
 		err = unpack_to_rootfs((char *)initrd_start,
@@ -615,6 +616,11 @@ static int __init populate_rootfs(void)
 			printk(KERN_EMERG "Initramfs unpacking failed: %s\n", err);
 		free_initrd();
 #endif
+		/*
+		 * Try loading default modules from initramfs.  This gives
+		 * us a chance to load before device_initcalls.
+		 */
+		load_default_modules();
 	}
 	return 0;
 }

commit c67e5382fb3f312c95d8d01db40fb398e6da454d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 31 16:26:10 2012 -0700

    init: disable sparse checking of the mount.o source files
    
    The init/mount.o source files produce a number of sparse warnings of the
    type:
    
    warning: incorrect type in argument 1 (different address spaces)
       expected char [noderef] <asn:1>*dev_name
       got char *name
    
    This is due to the syscalls expecting some of the arguments to be user
    pointers but they are being passed as kernel pointers.  This is harmless
    but adds a lot of noise to a sparse build.
    
    To limit the noise just disable the sparse checking in the relevant source
    files, but still display a warning so that the user knows this has been
    done.
    
    Since the sparse checking has been disabled we can also remove the __user
    __force casts that are scattered thru the source.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 8216c303b082..84c6bf111300 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -1,3 +1,13 @@
+/*
+ * Many of the syscalls used in this file expect some of the arguments
+ * to be __user pointers not __kernel pointers.  To limit the sparse
+ * noise, turn off sparse checking for this file.
+ */
+#ifdef __CHECKER__
+#undef __CHECKER__
+#warning "Sparse checking disabled for this file"
+#endif
+
 #include <linux/init.h>
 #include <linux/fs.h>
 #include <linux/slab.h>
@@ -74,7 +84,7 @@ static void __init free_hash(void)
 	}
 }
 
-static long __init do_utime(char __user *filename, time_t mtime)
+static long __init do_utime(char *filename, time_t mtime)
 {
 	struct timespec t[2];
 
@@ -529,7 +539,7 @@ static void __init clean_rootfs(void)
 	struct linux_dirent64 *dirp;
 	int num;
 
-	fd = sys_open((const char __user __force *) "/", O_RDONLY, 0);
+	fd = sys_open("/", O_RDONLY, 0);
 	WARN_ON(fd < 0);
 	if (fd < 0)
 		return;
@@ -589,7 +599,7 @@ static int __init populate_rootfs(void)
 		}
 		printk(KERN_INFO "rootfs image is not initramfs (%s)"
 				"; looks like an initrd\n", err);
-		fd = sys_open((const char __user __force *) "/initrd.image",
+		fd = sys_open("/initrd.image",
 			      O_WRONLY|O_CREAT, 0700);
 		if (fd >= 0) {
 			sys_write(fd, (char *)initrd_start,

commit 685dd2d5bea3e6368cea8002caf404d1b0b5c9f1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 26 04:34:13 2011 -0400

    init/initramfs.c: should use umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/init/initramfs.c b/init/initramfs.c
index 2531811d42cb..8216c303b082 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -22,7 +22,7 @@ static void __init error(char *x)
 
 static __initdata struct hash {
 	int ino, minor, major;
-	mode_t mode;
+	umode_t mode;
 	struct hash *next;
 	char name[N_ALIGN(PATH_MAX)];
 } *head[32];
@@ -35,7 +35,7 @@ static inline int hash(int major, int minor, int ino)
 }
 
 static char __init *find_link(int major, int minor, int ino,
-			      mode_t mode, char *name)
+			      umode_t mode, char *name)
 {
 	struct hash **p, *q;
 	for (p = head + hash(major, minor, ino); *p; p = &(*p)->next) {
@@ -120,7 +120,7 @@ static __initdata time_t mtime;
 /* cpio header parsing */
 
 static __initdata unsigned long ino, major, minor, nlink;
-static __initdata mode_t mode;
+static __initdata umode_t mode;
 static __initdata unsigned long body_len, name_len;
 static __initdata uid_t uid;
 static __initdata gid_t gid;
@@ -276,7 +276,7 @@ static int __init maybe_link(void)
 	return 0;
 }
 
-static void __init clean_path(char *path, mode_t mode)
+static void __init clean_path(char *path, umode_t mode)
 {
 	struct stat st;
 

commit c9e2a72ff1acfdffdecb338b3d997f90c507e665
Merge: 9aca0e7c8c3a d63f6d1b4d3a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 28 15:13:55 2010 -0700

    Merge branch 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild-2.6
    
    * 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild-2.6:
      initramfs: Fix build break on symbol-prefixed archs
      initramfs: fix initramfs size calculation
      initramfs: generalize initramfs_data.xxx.S variants
      scripts/kallsyms: Enable error messages while hush up unnecessary warnings
      scripts/setlocalversion: update comment
      kbuild: Use a single clean rule for kernel and external modules
      kbuild: Do not run make clean in $(srctree)
      scripts/mod/modpost.c: fix commentary accordingly to last changes
      kbuild: Really don't clean bounds.h and asm-offsets.h

commit 562f5e638de4ef451226552fe8dd7847bacea24e
Author: Namhyung Kim <namhyung@gmail.com>
Date:   Tue Oct 26 14:22:42 2010 -0700

    init: mark __user address space on string literals
    
    When calling syscall service routines in kernel, some of arguments should
    be user pointers but were missing __user markup on string literals.  Add
    it.  Removes some sparse warnings.
    
    Signed-off-by: Namhyung Kim <namhyung@gmail.com>
    Cc: Phillip Lougher <phillip@lougher.demon.co.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 4b9c20205092..d9c6e782ff53 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -528,7 +528,7 @@ static void __init clean_rootfs(void)
 	struct linux_dirent64 *dirp;
 	int num;
 
-	fd = sys_open("/", O_RDONLY, 0);
+	fd = sys_open((const char __user __force *) "/", O_RDONLY, 0);
 	WARN_ON(fd < 0);
 	if (fd < 0)
 		return;
@@ -590,7 +590,8 @@ static int __init populate_rootfs(void)
 		}
 		printk(KERN_INFO "rootfs image is not initramfs (%s)"
 				"; looks like an initrd\n", err);
-		fd = sys_open("/initrd.image", O_WRONLY|O_CREAT, 0700);
+		fd = sys_open((const char __user __force *) "/initrd.image",
+			      O_WRONLY|O_CREAT, 0700);
 		if (fd >= 0) {
 			sys_write(fd, (char *)initrd_start,
 					initrd_end - initrd_start);

commit ffe8018c3424892c9590048fc36caa6c3e0c8a76
Author: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
Date:   Fri Sep 17 15:24:11 2010 -0700

    initramfs: fix initramfs size calculation
    
    The size of a built-in initramfs is calculated in init/initramfs.c by
    "__initramfs_end - __initramfs_start".  Those symbols are defined in the
    linker script include/asm-generic/vmlinux.lds.h:
    
    #define INIT_RAM_FS                                                     \
            . = ALIGN(PAGE_SIZE);                                           \
            VMLINUX_SYMBOL(__initramfs_start) = .;                          \
            *(.init.ramfs)                                                  \
            VMLINUX_SYMBOL(__initramfs_end) = .;
    
    If the initramfs file has an odd number of bytes, the "__initramfs_end"
    symbol points to an odd address, for example, the symbols in the
    System.map might look like:
    
        0000000000572000 T __initramfs_start
        00000000005bcd05 T __initramfs_end    <-- odd address
    
    At least on s390 this causes a problem:
    
    Certain s390 instructions, especially instructions for loading addresses
    (larl) or branch addresses must be on even addresses.  The compiler loads
    the symbol addresses with the "larl" instruction.  This instruction sets
    the last bit to 0 and, therefore, for odd size files, the calculated size
    is one byte less than it should be:
    
        0000000000540a9c <populate_rootfs>:
          540a9c:     eb cf f0 78 00 24       stmg    %r12,%r15,120(%r15),
          540aa2:     c0 10 00 01 8a af       larl    %r1,572000 <__initramfs_start>
          540aa8:     c0 c0 00 03 e1 2e       larl    %r12,5bcd04 <initramfs_end>
                                                      (Instead of  5bcd05)
          ...
          540abe:     1b c1                   sr      %r12,%r1
    
    To fix the problem, this patch introduces the global variable
    __initramfs_size, which is calculated in the "usr/initramfs_data.S" file.
    The populate_rootfs() function can then use the start marker of the
    .init.ramfs section and the value of __initramfs_size for loading the
    initramfs.  Because the start marker and size is sufficient, the
    __initramfs_end symbol is no longer needed and is removed.
    
    Signed-off-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
    Signed-off-by: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
    Reviewed-by: WANG Cong <xiyou.wangcong@gmail.com>
    Acked-by: Michal Marek <mmarek@suse.cz>
    Acked-by: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/init/initramfs.c b/init/initramfs.c
index 4b9c20205092..371c3da64ad3 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -483,7 +483,8 @@ static int __init retain_initrd_param(char *str)
 }
 __setup("retain_initrd", retain_initrd_param);
 
-extern char __initramfs_start[], __initramfs_end[];
+extern char __initramfs_start[];
+extern unsigned long __initramfs_size;
 #include <linux/initrd.h>
 #include <linux/kexec.h>
 
@@ -570,8 +571,7 @@ static void __init clean_rootfs(void)
 
 static int __init populate_rootfs(void)
 {
-	char *err = unpack_to_rootfs(__initramfs_start,
-			 __initramfs_end - __initramfs_start);
+	char *err = unpack_to_rootfs(__initramfs_start, __initramfs_size);
 	if (err)
 		panic(err);	/* Failed to decompress INTERNAL initramfs */
 	if (initrd_start) {
@@ -585,8 +585,7 @@ static int __init populate_rootfs(void)
 			return 0;
 		} else {
 			clean_rootfs();
-			unpack_to_rootfs(__initramfs_start,
-				 __initramfs_end - __initramfs_start);
+			unpack_to_rootfs(__initramfs_start, __initramfs_size);
 		}
 		printk(KERN_INFO "rootfs image is not initramfs (%s)"
 				"; looks like an initrd\n", err);

commit df37bd156dcb4f5441beaf5bde444adac974e9a0
Author: Phillip Lougher <phillip@lougher.demon.co.uk>
Date:   Fri Apr 23 13:18:11 2010 -0400

    initramfs: handle unrecognised decompressor when unpacking
    
    The unpack routine fails to handle the decompress_method() returning
    unrecognised decompressor (compress_name == NULL).  This results in the
    routine looping eventually oopsing on an out of bounds memory access.
    
    Note this bug is usually hidden, only triggering on trailing junk after
    one or more correct compressed blocks.  The case of the compressed archive
    being complete junk is (by accident?) caught by the if (state != Reset)
    check because state is initialised to Start, but not updated due to the
    decompressor not having been called.  Obviously if the junk is trailing a
    correctly decompressed buffer, state == Reset from the previous call to
    the decompressor.
    
    Signed-off-by: Phillip Lougher <phillip@lougher.demon.co.uk>
    Reported-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 37d3859b1b32..4b9c20205092 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -457,7 +457,8 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len)
 					 compress_name);
 				message = msg_buf;
 			}
-		}
+		} else
+			error("junk in compressed archive");
 		if (state != Reset)
 			error("junk in compressed archive");
 		this_header = saved_offset + my_inptr;

commit 8aaed5bec2b9177eab1796c8c4f7a4c90804eef6
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Mar 5 13:42:39 2010 -0800

    init/initramfs.c: fix "symbol shadows an earlier one" noise
    
    The symbol 'count' is a local global variable in this file.  The function
    clean_rootfs() should use a different symbol name to prevent "symbol
    shadows an earlier one" noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index b37d34beb90b..37d3859b1b32 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -525,7 +525,7 @@ static void __init clean_rootfs(void)
 	int fd;
 	void *buf;
 	struct linux_dirent64 *dirp;
-	int count;
+	int num;
 
 	fd = sys_open("/", O_RDONLY, 0);
 	WARN_ON(fd < 0);
@@ -539,9 +539,9 @@ static void __init clean_rootfs(void)
 	}
 
 	dirp = buf;
-	count = sys_getdents64(fd, dirp, BUF_SIZE);
-	while (count > 0) {
-		while (count > 0) {
+	num = sys_getdents64(fd, dirp, BUF_SIZE);
+	while (num > 0) {
+		while (num > 0) {
 			struct stat st;
 			int ret;
 
@@ -554,12 +554,12 @@ static void __init clean_rootfs(void)
 					sys_unlink(dirp->d_name);
 			}
 
-			count -= dirp->d_reclen;
+			num -= dirp->d_reclen;
 			dirp = (void *)dirp + dirp->d_reclen;
 		}
 		dirp = buf;
 		memset(buf, 0, BUF_SIZE);
-		count = sys_getdents64(fd, dirp, BUF_SIZE);
+		num = sys_getdents64(fd, dirp, BUF_SIZE);
 	}
 
 	sys_close(fd);

commit 54291362d2a5738e1b0495df2abcb9e6b0563a3f
Author: Phillip Lougher <phillip@lougher.demon.co.uk>
Date:   Mon Dec 14 21:45:19 2009 +0000

    initramfs: add missing decompressor error check
    
    The decompressors return error by calling a supplied error function, and/or
    by returning an error return value.  The initramfs code, however, fails to
    check the exit code returned by the decompressor, and only checks the error
    status set by calling the error function.
    
    This patch adds a return code check and calls the error function.
    
    Signed-off-by: Phillip Lougher <phillip@lougher.demon.co.uk>
    LKML-Reference: <4b26b1ef.0+ZWxT6886olqcSc%phillip@lougher.demon.co.uk>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/init/initramfs.c b/init/initramfs.c
index 4c00edc59689..b37d34beb90b 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -413,7 +413,7 @@ static unsigned my_inptr;   /* index of next byte to be processed in inbuf */
 
 static char * __init unpack_to_rootfs(char *buf, unsigned len)
 {
-	int written;
+	int written, res;
 	decompress_fn decompress;
 	const char *compress_name;
 	static __initdata char msg_buf[64];
@@ -445,10 +445,12 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len)
 		}
 		this_header = 0;
 		decompress = decompress_method(buf, len, &compress_name);
-		if (decompress)
-			decompress(buf, len, NULL, flush_buffer, NULL,
+		if (decompress) {
+			res = decompress(buf, len, NULL, flush_buffer, NULL,
 				   &my_inptr, error);
-		else if (compress_name) {
+			if (res)
+				error("decompressor failed");
+		} else if (compress_name) {
 			if (!message) {
 				snprintf(msg_buf, sizeof msg_buf,
 					 "compression method %s not configured",

commit a1e6b6c1a676d25acdf079ee8ab5cdfeb5e5b835
Author: Eric Piel <eric.piel@tremplin-utc.net>
Date:   Wed May 6 16:03:06 2009 -0700

    initramfs: clean up messages related to initramfs unpacking
    
    With the removal of duplicate unpack_to_rootfs() (commit
    df52092f3c97788592ef72501a43fb7ac6a3cfe0) the messages displayed do not
    actually correspond to what the kernel is doing.  In addition, depending
    if ramdisks are supported or not, the messages are not at all the same.
    
    So keep the messages more in sync with what is really doing the kernel,
    and only display a second message in case of failure.  This also ensure
    that the printk message cannot be split by other printk's.
    
    Signed-off-by: Eric Piel <eric.piel@tremplin-utc.net>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 9ee7b7810417..4c00edc59689 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -574,11 +574,10 @@ static int __init populate_rootfs(void)
 	if (initrd_start) {
 #ifdef CONFIG_BLK_DEV_RAM
 		int fd;
-		printk(KERN_INFO "checking if image is initramfs...\n");
+		printk(KERN_INFO "Trying to unpack rootfs image as initramfs...\n");
 		err = unpack_to_rootfs((char *)initrd_start,
 			initrd_end - initrd_start);
 		if (!err) {
-			printk(KERN_INFO "rootfs image is initramfs; unpacking...\n");
 			free_initrd();
 			return 0;
 		} else {
@@ -596,15 +595,11 @@ static int __init populate_rootfs(void)
 			free_initrd();
 		}
 #else
-		printk(KERN_INFO "Unpacking initramfs...");
+		printk(KERN_INFO "Unpacking initramfs...\n");
 		err = unpack_to_rootfs((char *)initrd_start,
 			initrd_end - initrd_start);
-		if (err) {
-			printk(" failed!\n");
-			printk(KERN_EMERG "%s\n", err);
-		} else {
-			printk(" done\n");
-		}
+		if (err)
+			printk(KERN_EMERG "Initramfs unpacking failed: %s\n", err);
 		free_initrd();
 #endif
 	}

commit d20d5a7456d57d8affa88f45f27ae96ea49c29e4
Author: Randy Robertson <rmrobert@vmware.com>
Date:   Mon Apr 13 14:40:04 2009 -0700

    initramfs: fix initramfs to work with hardlinked init
    
    Change cb6ff208076b5f434db1b8c983429269d719cef5 ("NOMMU: Support XIP on
    initramfs") seems to have broken booting from initramfs with /sbin/init
    being a hardlink.
    
    It seems like the logic required for XIP on nommu, i.e.  ftruncate to
    reported cpio header file size (body_len) is broken for hardlinks, which
    have a reported size of 0, and the truncate thus nukes the contents of the
    file (in my case busybox), making boot impossible and ending with runaway
    loop modprobe binfmt-0000 - and of course 0000 is not a valid binary
    format.
    
    My fix is to only call ftruncate if size is non-zero which fixes things
    for me, but I'm not certain whether this will break XIP for those files on
    nommu systems, although I would guess not.
    
    Signed-off-by: Randy Robertson <rmrobert@vmware.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index e44f2d932cc4..9ee7b7810417 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -310,7 +310,8 @@ static int __init do_name(void)
 			if (wfd >= 0) {
 				sys_fchown(wfd, uid, gid);
 				sys_fchmod(wfd, mode);
-				sys_ftruncate(wfd, body_len);
+				if (body_len)
+					sys_ftruncate(wfd, body_len);
 				vcollected = kstrdup(collected, GFP_KERNEL);
 				state = CopyFile;
 			}

commit b52bb3712a64c404846f30300b339cfd01e316be
Author: Nikanth Karthikesan <knikanth@suse.de>
Date:   Mon Apr 13 14:39:38 2009 -0700

    init/initramfs: fix warning with CONFIG_BLK_DEV_RAM=n
    
    init/initramfs.c:520: warning: 'clean_rootfs' defined but not used
    
    Signed-off-by: Nikanth Karthikesan <knikanth@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 80cd713f6cc5..e44f2d932cc4 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -515,6 +515,7 @@ static void __init free_initrd(void)
 	initrd_end = 0;
 }
 
+#ifdef CONFIG_BLK_DEV_RAM
 #define BUF_SIZE 1024
 static void __init clean_rootfs(void)
 {
@@ -561,6 +562,7 @@ static void __init clean_rootfs(void)
 	sys_close(fd);
 	kfree(buf);
 }
+#endif
 
 static int __init populate_rootfs(void)
 {

commit c1c490e017b66b31f6559db9cbb51a3ce00cf639
Author: Simon Kitching <skitching@apache.org>
Date:   Thu Apr 2 16:57:00 2009 -0700

    initramfs: prevent initramfs printk message being split by messages from other code.
    
    initramfs uses printk without a linefeed, then does some work, then uses
    printk to finish the message off.  However if some other code does a
    printk in between, then the messages get mixed together.  Better for each
    message to be an independent line...
    
    Example of problem that this fixes:
    
        checking if image is initramfs...<7>Switched to high resolution mode on CPU 1
        Switched to high resolution mode on CPU 0
        it is
    
    Signed-off-by: Simon Kitching <skitching@apache.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 619c1baf7701..80cd713f6cc5 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -571,11 +571,11 @@ static int __init populate_rootfs(void)
 	if (initrd_start) {
 #ifdef CONFIG_BLK_DEV_RAM
 		int fd;
-		printk(KERN_INFO "checking if image is initramfs...");
+		printk(KERN_INFO "checking if image is initramfs...\n");
 		err = unpack_to_rootfs((char *)initrd_start,
 			initrd_end - initrd_start);
 		if (!err) {
-			printk(" it is\n");
+			printk(KERN_INFO "rootfs image is initramfs; unpacking...\n");
 			free_initrd();
 			return 0;
 		} else {
@@ -583,7 +583,8 @@ static int __init populate_rootfs(void)
 			unpack_to_rootfs(__initramfs_start,
 				 __initramfs_end - __initramfs_start);
 		}
-		printk("it isn't (%s); looks like an initrd\n", err);
+		printk(KERN_INFO "rootfs image is not initramfs (%s)"
+				"; looks like an initrd\n", err);
 		fd = sys_open("/initrd.image", O_WRONLY|O_CREAT, 0700);
 		if (fd >= 0) {
 			sys_write(fd, (char *)initrd_start,

commit eedf2c5296a8dfaaf9aec1a938c1d3bd73159a30
Merge: 0151f94f2e61 df52092f3c97
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 28 14:00:33 2009 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/arjan/linux-2.6-async-for-30
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/arjan/linux-2.6-async-for-30:
      fastboot: remove duplicate unpack_to_rootfs()
      ide/net: flip the order of SATA and network init
      async: remove the temporary (2.6.29) "async is off by default" code
    
    Fix up conflicts in init/initramfs.c manually

commit df52092f3c97788592ef72501a43fb7ac6a3cfe0
Author: Li, Shaohua <shaohua.li@intel.com>
Date:   Wed Aug 13 17:26:01 2008 +0800

    fastboot: remove duplicate unpack_to_rootfs()
    
    we check if initrd is initramfs first and then do the real unpack. The check
    isn't required, we can directly do unpack.  If the initrd isn't an
    initramfs, we can remove the garbage.  In my laptop, this saves 0.1s boot
    time.
    
    This patch penalizes non-initramfs initrd case, but nowadays, initramfs is
    the most widely used method for initrds.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Acked-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/init/initramfs.c b/init/initramfs.c
index d9c941c0c3ca..d3c56fcb30b8 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -5,6 +5,7 @@
 #include <linux/fcntl.h>
 #include <linux/delay.h>
 #include <linux/string.h>
+#include <linux/dirent.h>
 #include <linux/syscalls.h>
 #include <linux/utime.h>
 
@@ -166,8 +167,6 @@ static __initdata char *victim;
 static __initdata unsigned count;
 static __initdata loff_t this_header, next_header;
 
-static __initdata int dry_run;
-
 static inline void __init eat(unsigned n)
 {
 	victim += n;
@@ -229,10 +228,6 @@ static int __init do_header(void)
 	parse_header(collected);
 	next_header = this_header + N_ALIGN(name_len) + body_len;
 	next_header = (next_header + 3) & ~3;
-	if (dry_run) {
-		read_into(name_buf, N_ALIGN(name_len), GotName);
-		return 0;
-	}
 	state = SkipIt;
 	if (name_len <= 0 || name_len > PATH_MAX)
 		return 0;
@@ -303,8 +298,6 @@ static int __init do_name(void)
 		free_hash();
 		return 0;
 	}
-	if (dry_run)
-		return 0;
 	clean_path(collected, mode);
 	if (S_ISREG(mode)) {
 		int ml = maybe_link();
@@ -476,10 +469,9 @@ static void __init flush_window(void)
 	outcnt = 0;
 }
 
-static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
+static char * __init unpack_to_rootfs(char *buf, unsigned len)
 {
 	int written;
-	dry_run = check_only;
 	header_buf = kmalloc(110, GFP_KERNEL);
 	symlink_buf = kmalloc(PATH_MAX + N_ALIGN(PATH_MAX) + 1, GFP_KERNEL);
 	name_buf = kmalloc(N_ALIGN(PATH_MAX), GFP_KERNEL);
@@ -574,10 +566,57 @@ static void __init free_initrd(void)
 	initrd_end = 0;
 }
 
+#define BUF_SIZE 1024
+static void __init clean_rootfs(void)
+{
+	int fd;
+	void *buf;
+	struct linux_dirent64 *dirp;
+	int count;
+
+	fd = sys_open("/", O_RDONLY, 0);
+	WARN_ON(fd < 0);
+	if (fd < 0)
+		return;
+	buf = kzalloc(BUF_SIZE, GFP_KERNEL);
+	WARN_ON(!buf);
+	if (!buf) {
+		sys_close(fd);
+		return;
+	}
+
+	dirp = buf;
+	count = sys_getdents64(fd, dirp, BUF_SIZE);
+	while (count > 0) {
+		while (count > 0) {
+			struct stat st;
+			int ret;
+
+			ret = sys_newlstat(dirp->d_name, &st);
+			WARN_ON_ONCE(ret);
+			if (!ret) {
+				if (S_ISDIR(st.st_mode))
+					sys_rmdir(dirp->d_name);
+				else
+					sys_unlink(dirp->d_name);
+			}
+
+			count -= dirp->d_reclen;
+			dirp = (void *)dirp + dirp->d_reclen;
+		}
+		dirp = buf;
+		memset(buf, 0, BUF_SIZE);
+		count = sys_getdents64(fd, dirp, BUF_SIZE);
+	}
+
+	sys_close(fd);
+	kfree(buf);
+}
+
 static int __init populate_rootfs(void)
 {
 	char *err = unpack_to_rootfs(__initramfs_start,
-			 __initramfs_end - __initramfs_start, 0);
+			 __initramfs_end - __initramfs_start);
 	if (err)
 		panic(err);
 	if (initrd_start) {
@@ -585,13 +624,15 @@ static int __init populate_rootfs(void)
 		int fd;
 		printk(KERN_INFO "checking if image is initramfs...");
 		err = unpack_to_rootfs((char *)initrd_start,
-			initrd_end - initrd_start, 1);
+			initrd_end - initrd_start);
 		if (!err) {
 			printk(" it is\n");
-			unpack_to_rootfs((char *)initrd_start,
-				initrd_end - initrd_start, 0);
 			free_initrd();
 			return 0;
+		} else {
+			clean_rootfs();
+			unpack_to_rootfs(__initramfs_start,
+				 __initramfs_end - __initramfs_start);
 		}
 		printk("it isn't (%s); looks like an initrd\n", err);
 		fd = sys_open("/initrd.image", O_WRONLY|O_CREAT, 0700);
@@ -604,7 +645,7 @@ static int __init populate_rootfs(void)
 #else
 		printk(KERN_INFO "Unpacking initramfs...");
 		err = unpack_to_rootfs((char *)initrd_start,
-			initrd_end - initrd_start, 0);
+			initrd_end - initrd_start);
 		if (err)
 			panic(err);
 		printk(" done\n");

commit 73310a169aebe257efdd35a763cce1c7658f40c9
Author: H. Peter Anvin <hpa@linux.intel.com>
Date:   Wed Jan 14 11:28:35 2009 -0800

    init: make initrd/initramfs decompression failure a KERN_EMERG event
    
    Impact: More consistent behaviour, avoid policy in the kernel
    
    Upgrade/downgrade initrd/initramfs decompression failure from
    inconsistently a panic or a KERN_ALERT message to a KERN_EMERG event.
    It is, however, possible do design a system which can recover from
    this (using the kernel builtin code and/or the internal initramfs),
    which means this is policy, not a technical necessity.
    
    A good way to handle this would be to have a panic-level=X option, to
    force a panic on a printk above a certain level.  That is a separate
    patch, however.
    
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/init/initramfs.c b/init/initramfs.c
index 9a7290ec8187..7dcde7ea6603 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -528,7 +528,7 @@ static int __init populate_rootfs(void)
 	char *err = unpack_to_rootfs(__initramfs_start,
 			 __initramfs_end - __initramfs_start, 0);
 	if (err)
-		panic(err);
+		panic(err);	/* Failed to decompress INTERNAL initramfs */
 	if (initrd_start) {
 #ifdef CONFIG_BLK_DEV_RAM
 		int fd;
@@ -554,9 +554,12 @@ static int __init populate_rootfs(void)
 		printk(KERN_INFO "Unpacking initramfs...");
 		err = unpack_to_rootfs((char *)initrd_start,
 			initrd_end - initrd_start, 0);
-		if (err)
-			panic(err);
-		printk(" done\n");
+		if (err) {
+			printk(" failed!\n");
+			printk(KERN_EMERG "%s\n", err);
+		} else {
+			printk(" done\n");
+		}
 		free_initrd();
 #endif
 	}

commit 23a22d57a8962479ca630c9542e62d6f86fdf927
Author: H. Peter Anvin <hpa@linux.intel.com>
Date:   Mon Jan 12 14:24:04 2009 -0800

    bzip2/lzma: comprehensible error messages for missing decompressor
    
    Instead of failing to identify a compressed image with a decompressor
    that we don't have compiled in, identify it and fail with a
    comprehensible panic message.
    
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/init/initramfs.c b/init/initramfs.c
index 76f4a0125338..9a7290ec8187 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -421,6 +421,8 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
 {
 	int written;
 	decompress_fn decompress;
+	const char *compress_name;
+	static __initdata char msg_buf[64];
 
 	dry_run = check_only;
 	header_buf = kmalloc(110, GFP_KERNEL);
@@ -449,10 +451,18 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
 			continue;
 		}
 		this_header = 0;
-		decompress = decompress_method(buf, len, NULL);
+		decompress = decompress_method(buf, len, &compress_name);
 		if (decompress)
 			decompress(buf, len, NULL, flush_buffer, NULL,
 				   &my_inptr, error);
+		else if (compress_name) {
+			if (!message) {
+				snprintf(msg_buf, sizeof msg_buf,
+					 "compression method %s not configured",
+					 compress_name);
+				message = msg_buf;
+			}
+		}
 		if (state != Reset)
 			error("junk in compressed archive");
 		this_header = saved_offset + my_inptr;

commit 736f93236ce786d1bcf09ad4dcb38a360d35ea1b
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sat Jan 10 12:06:19 2009 +0100

    bzip2/lzma: make flush_buffer() unconditional
    
    Impact: build fix
    
    flush_buffer() is used unconditionally:
    
      init/initramfs.c:456: error: 'flush_buffer' undeclared (first use in this function)
      init/initramfs.c:456: error: (Each undeclared identifier is reported only once
      init/initramfs.c:456: error: for each function it appears in.)
    
    So remove the decompressor #ifdefs from around it.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/init/initramfs.c b/init/initramfs.c
index f8241e832aa3..76f4a0125338 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -390,7 +390,6 @@ static int __init write_buffer(char *buf, unsigned len)
 	return len - count;
 }
 
-#if defined CONFIG_RD_GZIP || defined CONFIG_RD_BZIP2 || defined CONFIG_RD_LZMA
 static int __init flush_buffer(void *bufv, unsigned len)
 {
 	char *buf = (char *) bufv;
@@ -413,7 +412,6 @@ static int __init flush_buffer(void *bufv, unsigned len)
 	}
 	return origLen;
 }
-#endif
 
 static unsigned my_inptr;   /* index of next byte to be processed in inbuf */
 

commit b17304245f0db0ac69b795c411407808f3f2796d
Merge: 889c92d21db4 9a100a446491
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sat Jan 10 12:04:41 2009 +0100

    Merge branch 'linus' into x86/setup-lzma
    
    Conflicts:
            init/do_mounts_rd.c

commit 889c92d21db40be0b7d22a59395060237895bb85
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Thu Jan 8 15:14:17 2009 -0800

    bzip2/lzma: centralize format detection
    
    Centralize the compression format detection to a common routine in the
    lib directory, and use it for both initramfs and initrd.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/init/initramfs.c b/init/initramfs.c
index a3ba91cdab89..2f42984e5582 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -416,13 +416,13 @@ static int __init flush_buffer(void *bufv, unsigned len)
 
 static unsigned my_inptr;   /* index of next byte to be processed in inbuf */
 
-#include <linux/decompress/bunzip2.h>
-#include <linux/decompress/unlzma.h>
-#include <linux/decompress/inflate.h>
+#include <linux/decompress/generic.h>
 
 static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
 {
 	int written;
+	decompress_fn decompress;
+
 	dry_run = check_only;
 	header_buf = kmalloc(110, GFP_KERNEL);
 	symlink_buf = kmalloc(PATH_MAX + N_ALIGN(PATH_MAX) + 1, GFP_KERNEL);
@@ -450,35 +450,10 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
 			continue;
 		}
 		this_header = 0;
-#ifdef CONFIG_RD_GZIP
-		if (!gunzip(buf, len, NULL, flush_buffer, NULL,
-			    &my_inptr, error) &&
-		    message == NULL)
-			goto ok;
-#endif
-
-#ifdef CONFIG_RD_BZIP2
-		message = NULL; /* Zero out message, or else cpio will
-				   think an error has already occured */
-		if (!bunzip2(buf, len, NULL, flush_buffer, NULL,
-			     &my_inptr, error) &&
-		    message == NULL) {
-			goto ok;
-		}
-#endif
-
-#ifdef CONFIG_RD_LZMA
-		message = NULL; /* Zero out message, or else cpio will
-				   think an error has already occured */
-		if (!unlzma(buf, len, NULL, flush_buffer, NULL,
-			    &my_inptr, error) &&
-		    message == NULL) {
-			goto ok;
-		}
-#endif
-#if defined CONFIG_RD_GZIP || defined CONFIG_RD_BZIP2 || defined CONFIG_RD_LZMA
-ok:
-#endif
+		decompress = decompress_method(buf, len, NULL);
+		if (decompress)
+			decompress(buf, len, NULL, flush_buffer, NULL,
+				   &my_inptr, error);
 		if (state != Reset)
 			error("junk in compressed archive");
 		this_header = saved_offset + my_inptr;

commit cb6ff208076b5f434db1b8c983429269d719cef5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jan 8 12:04:48 2009 +0000

    NOMMU: Support XIP on initramfs
    
    Support XIP on files unpacked from the initramfs image on NOMMU systems.  This
    simply requires the length of the file to be preset so that the ramfs fs can
    attempt to garner sufficient contiguous storage to store the file (NOMMU mmap
    can only map contiguous RAM).
    
    All the other bits to do XIP on initramfs files are present:
    
     (1) ramfs's truncate attempts to allocate a contiguous run of pages when a
         file is truncated upwards from nothing.
    
     (2) ramfs sets BDI on its files to indicate direct mapping is possible, and
         that its files can be mapped for read, write and exec.
    
     (3) NOMMU mmap() will use the above bits to determine that it can do XIP.
         Possibly this needs better controls, because it will _always_ try and do
         XIP.
    
    One disadvantage of this very simplistic approach is that sufficient space
    will be allocated to store the whole file, and not just the bit that would be
    XIP'd.  To deal with this, though, the initramfs unpacker would have to be
    able to parse the file contents.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 4f5ba75aaa7c..d9c941c0c3ca 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -317,6 +317,7 @@ static int __init do_name(void)
 			if (wfd >= 0) {
 				sys_fchown(wfd, uid, gid);
 				sys_fchmod(wfd, mode);
+				sys_ftruncate(wfd, body_len);
 				vcollected = kstrdup(collected, GFP_KERNEL);
 				state = CopyFile;
 			}

commit a26ee60f90daffe1de6be0d093af86e7279b3dfd
Author: Alain Knaff <alain@knaff.lu>
Date:   Wed Jan 7 00:10:27 2009 -0800

    bzip2/lzma: fix built-in initramfs vs CONFIG_RD_GZIP
    
    Impact: Resolves build failures in some configurations
    
    Makes it possible to disable CONFIG_RD_GZIP . In that case, the
    built-in initramfs will be compressed by whatever compressor is
    available (bzip2 or lzma) or left uncompressed if none is available.
    
    It also removes a couple of warnings which occur when no ramdisk
    compression at all is chosen.
    
    It also restores the select ZLIB_INFLATE in drivers/block/Kconfig
    which somehow came missing. This is needed to activate compilation of
    the stuff in zlib_deflate.
    
    Signed-off-by: Alain Knaff <alain@knaff.lu>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/init/initramfs.c b/init/initramfs.c
index 40bd4fb95788..a3ba91cdab89 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -389,7 +389,7 @@ static int __init write_buffer(char *buf, unsigned len)
 	return len - count;
 }
 
-
+#if defined CONFIG_RD_GZIP || defined CONFIG_RD_BZIP2 || defined CONFIG_RD_LZMA
 static int __init flush_buffer(void *bufv, unsigned len)
 {
 	char *buf = (char *) bufv;
@@ -412,6 +412,7 @@ static int __init flush_buffer(void *bufv, unsigned len)
 	}
 	return origLen;
 }
+#endif
 
 static unsigned my_inptr;   /* index of next byte to be processed in inbuf */
 
@@ -449,10 +450,12 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
 			continue;
 		}
 		this_header = 0;
+#ifdef CONFIG_RD_GZIP
 		if (!gunzip(buf, len, NULL, flush_buffer, NULL,
 			    &my_inptr, error) &&
 		    message == NULL)
 			goto ok;
+#endif
 
 #ifdef CONFIG_RD_BZIP2
 		message = NULL; /* Zero out message, or else cpio will
@@ -473,7 +476,9 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
 			goto ok;
 		}
 #endif
+#if defined CONFIG_RD_GZIP || defined CONFIG_RD_BZIP2 || defined CONFIG_RD_LZMA
 ok:
+#endif
 		if (state != Reset)
 			error("junk in compressed archive");
 		this_header = saved_offset + my_inptr;

commit 30d65dbfe3add7f010a075991dc0bfeaebb7d9e1
Author: Alain Knaff <alain@knaff.lu>
Date:   Sun Jan 4 22:46:17 2009 +0100

    bzip2/lzma: config and initramfs support for bzip2/lzma decompression
    
    Impact: New code for initramfs decompression, new features
    
    This is the second part of the bzip2/lzma patch
    
    The bzip patch is based on an idea by Christian Ludwig, includes support for
    compressing the kernel with bzip2 or lzma rather than gzip. Both
    compressors give smaller sizes than gzip.  Lzma's decompresses faster
    than bzip2.
    
    It also supports ramdisks and initramfs' compressed using these two
    compressors.
    
    The functionality has been successfully used for a couple of years by
    the udpcast project
    
    This version applies to "tip" kernel 2.6.28
    
    This part contains:
    - support for new compressions (bzip2 and lzma) in initramfs and
    old-style ramdisk
    - config dialog for kernel compression (but new kernel compressions
    not yet supported)
    
    Signed-off-by: Alain Knaff <alain@knaff.lu>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/init/initramfs.c b/init/initramfs.c
index 4f5ba75aaa7c..40bd4fb95788 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -389,11 +389,14 @@ static int __init write_buffer(char *buf, unsigned len)
 	return len - count;
 }
 
-static void __init flush_buffer(char *buf, unsigned len)
+
+static int __init flush_buffer(void *bufv, unsigned len)
 {
+	char *buf = (char *) bufv;
 	int written;
+	int origLen = len;
 	if (message)
-		return;
+		return -1;
 	while ((written = write_buffer(buf, len)) < len && !message) {
 		char c = buf[written];
 		if (c == '0') {
@@ -407,73 +410,14 @@ static void __init flush_buffer(char *buf, unsigned len)
 		} else
 			error("junk in compressed archive");
 	}
+	return origLen;
 }
 
-/*
- * gzip declarations
- */
-
-#define OF(args)  args
-
-#ifndef memzero
-#define memzero(s, n)     memset ((s), 0, (n))
-#endif
-
-typedef unsigned char  uch;
-typedef unsigned short ush;
-typedef unsigned long  ulg;
-
-#define WSIZE 0x8000    /* window size--must be a power of two, and */
-			/*  at least 32K for zip's deflate method */
-
-static uch *inbuf;
-static uch *window;
-
-static unsigned insize;  /* valid bytes in inbuf */
-static unsigned inptr;   /* index of next byte to be processed in inbuf */
-static unsigned outcnt;  /* bytes in output buffer */
-static long bytes_out;
-
-#define get_byte()  (inptr < insize ? inbuf[inptr++] : -1)
-		
-/* Diagnostic functions (stubbed out) */
-#define Assert(cond,msg)
-#define Trace(x)
-#define Tracev(x)
-#define Tracevv(x)
-#define Tracec(c,x)
-#define Tracecv(c,x)
-
-#define STATIC static
-#define INIT __init
-
-static void __init flush_window(void);
-static void __init error(char *m);
-
-#define NO_INFLATE_MALLOC
+static unsigned my_inptr;   /* index of next byte to be processed in inbuf */
 
-#include "../lib/inflate.c"
-
-/* ===========================================================================
- * Write the output window window[0..outcnt-1] and update crc and bytes_out.
- * (Used for the decompressed data only.)
- */
-static void __init flush_window(void)
-{
-	ulg c = crc;         /* temporary variable */
-	unsigned n;
-	uch *in, ch;
-
-	flush_buffer(window, outcnt);
-	in = window;
-	for (n = 0; n < outcnt; n++) {
-		ch = *in++;
-		c = crc_32_tab[((int)c ^ ch) & 0xff] ^ (c >> 8);
-	}
-	crc = c;
-	bytes_out += (ulg)outcnt;
-	outcnt = 0;
-}
+#include <linux/decompress/bunzip2.h>
+#include <linux/decompress/unlzma.h>
+#include <linux/decompress/inflate.h>
 
 static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
 {
@@ -482,9 +426,10 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
 	header_buf = kmalloc(110, GFP_KERNEL);
 	symlink_buf = kmalloc(PATH_MAX + N_ALIGN(PATH_MAX) + 1, GFP_KERNEL);
 	name_buf = kmalloc(N_ALIGN(PATH_MAX), GFP_KERNEL);
-	window = kmalloc(WSIZE, GFP_KERNEL);
-	if (!window || !header_buf || !symlink_buf || !name_buf)
+
+	if (!header_buf || !symlink_buf || !name_buf)
 		panic("can't allocate buffers");
+
 	state = Start;
 	this_header = 0;
 	message = NULL;
@@ -504,22 +449,38 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
 			continue;
 		}
 		this_header = 0;
-		insize = len;
-		inbuf = buf;
-		inptr = 0;
-		outcnt = 0;		/* bytes in output buffer */
-		bytes_out = 0;
-		crc = (ulg)0xffffffffL; /* shift register contents */
-		makecrc();
-		gunzip();
+		if (!gunzip(buf, len, NULL, flush_buffer, NULL,
+			    &my_inptr, error) &&
+		    message == NULL)
+			goto ok;
+
+#ifdef CONFIG_RD_BZIP2
+		message = NULL; /* Zero out message, or else cpio will
+				   think an error has already occured */
+		if (!bunzip2(buf, len, NULL, flush_buffer, NULL,
+			     &my_inptr, error) &&
+		    message == NULL) {
+			goto ok;
+		}
+#endif
+
+#ifdef CONFIG_RD_LZMA
+		message = NULL; /* Zero out message, or else cpio will
+				   think an error has already occured */
+		if (!unlzma(buf, len, NULL, flush_buffer, NULL,
+			    &my_inptr, error) &&
+		    message == NULL) {
+			goto ok;
+		}
+#endif
+ok:
 		if (state != Reset)
-			error("junk in gzipped archive");
-		this_header = saved_offset + inptr;
-		buf += inptr;
-		len -= inptr;
+			error("junk in compressed archive");
+		this_header = saved_offset + my_inptr;
+		buf += my_inptr;
+		len -= my_inptr;
 	}
 	dir_utime();
-	kfree(window);
 	kfree(name_buf);
 	kfree(symlink_buf);
 	kfree(header_buf);

commit 889d51a10712b6fd6175196626de2116858394f4
Author: Nye Liu <nyet@nyet.org>
Date:   Wed Oct 15 22:01:40 2008 -0700

    initramfs: add option to preserve mtime from initramfs cpio images
    
    When unpacking the cpio into the initramfs, mtimes are not preserved by
    default.  This patch adds an INITRAMFS_PRESERVE_MTIME option that allows
    mtimes stored in the cpio image to be used when constructing the
    initramfs.
    
    For embedded applications that run exclusively out of the initramfs, this
    is invaluable:
    
    When building embedded application initramfs images, its nice to know when
    the files were actually created during the build process - that makes it
    easier to see what files were modified when so we can compare the files
    that are being used on the image with the files used during the build
    process.  This might help (for example) to determine if the target system
    has all the updated files you expect to see w/o having to check MD5s etc.
    
    In our environment, the whole system runs off the initramfs partition, and
    seeing the modified times of the shared libraries (for example) helps us
    find bugs that may have been introduced by the build system incorrectly
    propogating outdated shared libraries into the image.
    
    Similarly, many of the initializion/configuration files in /etc might be
    dynamically built by the build system, and knowing when they were modified
    helps us sanity check whether the target system has the "latest" files
    etc.
    
    Finally, we might use last modified times to determine whether a hot fix
    should be applied or not to the running ramfs.
    
    Signed-off-by: Nye Liu <nyet@nyet.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 644fc01ad5f0..4f5ba75aaa7c 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -6,6 +6,7 @@
 #include <linux/delay.h>
 #include <linux/string.h>
 #include <linux/syscalls.h>
+#include <linux/utime.h>
 
 static __initdata char *message;
 static void __init error(char *x)
@@ -72,6 +73,49 @@ static void __init free_hash(void)
 	}
 }
 
+static long __init do_utime(char __user *filename, time_t mtime)
+{
+	struct timespec t[2];
+
+	t[0].tv_sec = mtime;
+	t[0].tv_nsec = 0;
+	t[1].tv_sec = mtime;
+	t[1].tv_nsec = 0;
+
+	return do_utimes(AT_FDCWD, filename, t, AT_SYMLINK_NOFOLLOW);
+}
+
+static __initdata LIST_HEAD(dir_list);
+struct dir_entry {
+	struct list_head list;
+	char *name;
+	time_t mtime;
+};
+
+static void __init dir_add(const char *name, time_t mtime)
+{
+	struct dir_entry *de = kmalloc(sizeof(struct dir_entry), GFP_KERNEL);
+	if (!de)
+		panic("can't allocate dir_entry buffer");
+	INIT_LIST_HEAD(&de->list);
+	de->name = kstrdup(name, GFP_KERNEL);
+	de->mtime = mtime;
+	list_add(&de->list, &dir_list);
+}
+
+static void __init dir_utime(void)
+{
+	struct dir_entry *de, *tmp;
+	list_for_each_entry_safe(de, tmp, &dir_list, list) {
+		list_del(&de->list);
+		do_utime(de->name, de->mtime);
+		kfree(de->name);
+		kfree(de);
+	}
+}
+
+static __initdata time_t mtime;
+
 /* cpio header parsing */
 
 static __initdata unsigned long ino, major, minor, nlink;
@@ -97,6 +141,7 @@ static void __init parse_header(char *s)
 	uid = parsed[2];
 	gid = parsed[3];
 	nlink = parsed[4];
+	mtime = parsed[5];
 	body_len = parsed[6];
 	major = parsed[7];
 	minor = parsed[8];
@@ -130,6 +175,7 @@ static inline void __init eat(unsigned n)
 	count -= n;
 }
 
+static __initdata char *vcollected;
 static __initdata char *collected;
 static __initdata int remains;
 static __initdata char *collect;
@@ -271,6 +317,7 @@ static int __init do_name(void)
 			if (wfd >= 0) {
 				sys_fchown(wfd, uid, gid);
 				sys_fchmod(wfd, mode);
+				vcollected = kstrdup(collected, GFP_KERNEL);
 				state = CopyFile;
 			}
 		}
@@ -278,12 +325,14 @@ static int __init do_name(void)
 		sys_mkdir(collected, mode);
 		sys_chown(collected, uid, gid);
 		sys_chmod(collected, mode);
+		dir_add(collected, mtime);
 	} else if (S_ISBLK(mode) || S_ISCHR(mode) ||
 		   S_ISFIFO(mode) || S_ISSOCK(mode)) {
 		if (maybe_link() == 0) {
 			sys_mknod(collected, mode, rdev);
 			sys_chown(collected, uid, gid);
 			sys_chmod(collected, mode);
+			do_utime(collected, mtime);
 		}
 	}
 	return 0;
@@ -294,6 +343,8 @@ static int __init do_copy(void)
 	if (count >= body_len) {
 		sys_write(wfd, victim, body_len);
 		sys_close(wfd);
+		do_utime(vcollected, mtime);
+		kfree(vcollected);
 		eat(body_len);
 		state = SkipIt;
 		return 0;
@@ -311,6 +362,7 @@ static int __init do_symlink(void)
 	clean_path(collected, 0);
 	sys_symlink(collected + N_ALIGN(name_len), collected);
 	sys_lchown(collected, uid, gid);
+	do_utime(collected, mtime);
 	state = SkipIt;
 	next_state = Reset;
 	return 0;
@@ -466,6 +518,7 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
 		buf += inptr;
 		len -= inptr;
 	}
+	dir_utime();
 	kfree(window);
 	kfree(name_buf);
 	kfree(symlink_buf);

commit 2d6ffcca623a9a16df6cdfbe8250b7a5904a5f5e
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Fri Jul 25 01:45:44 2008 -0700

    inflate: refactor inflate malloc code
    
    Inflate requires some dynamic memory allocation very early in the boot
    process and this is provided with a set of four functions:
    malloc/free/gzip_mark/gzip_release.
    
    The old inflate code used a mark/release strategy rather than implement
    free.  This new version instead keeps a count on the number of outstanding
    allocations and when it hits zero, it resets the malloc arena.
    
    This allows removing all the mark and release implementations and unifying
    all the malloc/free implementations.
    
    The architecture-dependent code must define two addresses:
     - free_mem_ptr, the address of the beginning of the area in which
       allocations should be made
     - free_mem_end_ptr, the address of the end of the area in which
       allocations should be made. If set to 0, then no check is made on
       the number of allocations, it just grows as much as needed
    
    The architecture-dependent code can also provide an arch_decomp_wdog()
    function call.  This function will be called several times during the
    decompression process, and allow to notify the watchdog that the system is
    still running.  If an architecture provides such a call, then it must
    define ARCH_HAS_DECOMP_WDOG so that the generic inflate code calls
    arch_decomp_wdog().
    
    Work initially done by Matt Mackall, updated to a recent version of the
    kernel and improved by me.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Matt Mackall <mpm@selenic.com>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Mikael Starvik <mikael.starvik@axis.com>
    Cc: Jesper Nilsson <jesper.nilsson@axis.com>
    Cc: Haavard Skinnemoen <hskinnemoen@atmel.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 8eeeccb328c9..644fc01ad5f0 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -14,16 +14,6 @@ static void __init error(char *x)
 		message = x;
 }
 
-static void __init *malloc(size_t size)
-{
-	return kmalloc(size, GFP_KERNEL);
-}
-
-static void __init free(void *where)
-{
-	kfree(where);
-}
-
 /* link hash */
 
 #define N_ALIGN(len) ((((len) + 1) & ~3) + 2)
@@ -407,18 +397,10 @@ static long bytes_out;
 
 static void __init flush_window(void);
 static void __init error(char *m);
-static void __init gzip_mark(void **);
-static void __init gzip_release(void **);
 
-#include "../lib/inflate.c"
+#define NO_INFLATE_MALLOC
 
-static void __init gzip_mark(void **ptr)
-{
-}
-
-static void __init gzip_release(void **ptr)
-{
-}
+#include "../lib/inflate.c"
 
 /* ===========================================================================
  * Write the output window window[0..outcnt-1] and update crc and bytes_out.

commit 3265e66b1825942c6e0fc457986cdf941a5f7d37
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue Apr 29 00:59:43 2008 -0700

    directly use kmalloc() and kfree() in init/initramfs.c
    
    Instead of using the malloc() and free() wrappers needed by the
    lib/inflate.c code for allocations, simply use kmalloc() and kfree() in the
    initramfs code.  This is needed for a further lib/inflate.c-related cleanup
    patch that will remove the malloc() and free() functions.
    
    Take that opportunity to remove the useless kmalloc() return value
    cast.
    
    Based on work done by Matt Mackall.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Matt Mackall <mpm@selenic.com>
    Cc: Jan Engelhardt <jengelh@computergmbh.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index d53fee8d8604..8eeeccb328c9 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -57,7 +57,7 @@ static char __init *find_link(int major, int minor, int ino,
 			continue;
 		return (*p)->name;
 	}
-	q = (struct hash *)malloc(sizeof(struct hash));
+	q = kmalloc(sizeof(struct hash), GFP_KERNEL);
 	if (!q)
 		panic("can't allocate link hash entry");
 	q->major = major;
@@ -77,7 +77,7 @@ static void __init free_hash(void)
 		while (*p) {
 			q = *p;
 			*p = q->next;
-			free(q);
+			kfree(q);
 		}
 	}
 }
@@ -445,10 +445,10 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
 {
 	int written;
 	dry_run = check_only;
-	header_buf = malloc(110);
-	symlink_buf = malloc(PATH_MAX + N_ALIGN(PATH_MAX) + 1);
-	name_buf = malloc(N_ALIGN(PATH_MAX));
-	window = malloc(WSIZE);
+	header_buf = kmalloc(110, GFP_KERNEL);
+	symlink_buf = kmalloc(PATH_MAX + N_ALIGN(PATH_MAX) + 1, GFP_KERNEL);
+	name_buf = kmalloc(N_ALIGN(PATH_MAX), GFP_KERNEL);
+	window = kmalloc(WSIZE, GFP_KERNEL);
 	if (!window || !header_buf || !symlink_buf || !name_buf)
 		panic("can't allocate buffers");
 	state = Start;
@@ -484,10 +484,10 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
 		buf += inptr;
 		len -= inptr;
 	}
-	free(window);
-	free(name_buf);
-	free(symlink_buf);
-	free(header_buf);
+	kfree(window);
+	kfree(name_buf);
+	kfree(symlink_buf);
+	kfree(header_buf);
 	return message;
 }
 

commit 9a9e0d685553af76cb6ae2af93cca4913e7fcd47
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 15 11:53:32 2008 -0700

    ACPI: Remove ACPI_CUSTOM_DSDT_INITRD option
    
    This essentially reverts commit 71fc47a9adf8ee89e5c96a47222915c5485ac437
    ("ACPI: basic initramfs DSDT override support"), because the code simply
    isn't ready.
    
    It did ugly things to the init sequence to populate the rootfs image
    early, but that just ended up showing other problems with the whole
    approach.  The fact is, the VFS layer simply isn't initialized this
    early, and the relevant ACPI code should either run much later, or this
    shouldn't be done at all.
    
    For 2.6.25, we'll just pick the latter option.  We can revisit this
    concept later if necessary.
    
    Cc: Dave Hansen <haveblue@us.ibm.com>
    Cc: Tilman Schmidt <tilman@imap.cc>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Thomas Renninger <trenn@suse.de>
    Cc: Eric Piel <eric.piel@tremplin-utc.net>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Markus Gaugusch <dsdt@gaugusch.at>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index c0b1e0533d80..d53fee8d8604 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -538,7 +538,7 @@ static void __init free_initrd(void)
 	initrd_end = 0;
 }
 
-int __init populate_rootfs(void)
+static int __init populate_rootfs(void)
 {
 	char *err = unpack_to_rootfs(__initramfs_start,
 			 __initramfs_end - __initramfs_start, 0);
@@ -577,10 +577,4 @@ int __init populate_rootfs(void)
 	}
 	return 0;
 }
-#ifndef CONFIG_ACPI_CUSTOM_DSDT_INITRD
-/*
- * if this option is enabled, populate_rootfs() is called _earlier_ in the
- * boot sequence. This insures that the ACPI initialisation can find the file.
- */
 rootfs_initcall(populate_rootfs);
-#endif

commit 71fc47a9adf8ee89e5c96a47222915c5485ac437
Author: Markus Gaugusch <dsdt@gaugusch.at>
Date:   Tue Feb 5 00:04:06 2008 +0100

    ACPI: basic initramfs DSDT override support
    
    The basics of DSDT from initramfs. In case this option is selected,
    populate_rootfs() is called a bit earlier to have the initramfs content
    available during ACPI initialization.
    
    This is a very similar path to the one available at
    http://gaugusch.at/kernel.shtml but with some update in the
    documentation, default set to No and the change of populate_rootfs() the
    "Jeff Mahony way" (which avoids reading the initramfs twice).
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Eric Piel <eric.piel@tremplin-utc.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/init/initramfs.c b/init/initramfs.c
index d53fee8d8604..c0b1e0533d80 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -538,7 +538,7 @@ static void __init free_initrd(void)
 	initrd_end = 0;
 }
 
-static int __init populate_rootfs(void)
+int __init populate_rootfs(void)
 {
 	char *err = unpack_to_rootfs(__initramfs_start,
 			 __initramfs_end - __initramfs_start, 0);
@@ -577,4 +577,10 @@ static int __init populate_rootfs(void)
 	}
 	return 0;
 }
+#ifndef CONFIG_ACPI_CUSTOM_DSDT_INITRD
+/*
+ * if this option is enabled, populate_rootfs() is called _earlier_ in the
+ * boot sequence. This insures that the ACPI initialisation can find the file.
+ */
 rootfs_initcall(populate_rootfs);
+#endif

commit b25b7819e51f388f8c8d7ae4679a658895dc67cc
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Wed Feb 6 01:37:25 2008 -0800

    Remove superfluous checks for CONFIG_BLK_DEV_INITRD from initramfs.c
    
    Given that init/Makefile includes initramfs.c in the build only if
    CONFIG_BLK_DEV_INITRD is defined, there seems to be no point checking for
    it yet again.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 1db02a0025db..d53fee8d8604 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -503,7 +503,6 @@ static int __init retain_initrd_param(char *str)
 __setup("retain_initrd", retain_initrd_param);
 
 extern char __initramfs_start[], __initramfs_end[];
-#ifdef CONFIG_BLK_DEV_INITRD
 #include <linux/initrd.h>
 #include <linux/kexec.h>
 
@@ -539,15 +538,12 @@ static void __init free_initrd(void)
 	initrd_end = 0;
 }
 
-#endif
-
 static int __init populate_rootfs(void)
 {
 	char *err = unpack_to_rootfs(__initramfs_start,
 			 __initramfs_end - __initramfs_start, 0);
 	if (err)
 		panic(err);
-#ifdef CONFIG_BLK_DEV_INITRD
 	if (initrd_start) {
 #ifdef CONFIG_BLK_DEV_RAM
 		int fd;
@@ -579,7 +575,6 @@ static int __init populate_rootfs(void)
 		free_initrd();
 #endif
 	}
-#endif
 	return 0;
 }
 rootfs_initcall(populate_rootfs);

commit b0a5ab93158586e599ecd0d24a9a72da74d23ddd
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Jul 26 17:33:59 2007 +0100

    initramfs: missing __init
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 00eff7a11085..1db02a0025db 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -133,7 +133,7 @@ static __initdata loff_t this_header, next_header;
 
 static __initdata int dry_run;
 
-static inline void eat(unsigned n)
+static inline void __init eat(unsigned n)
 {
 	victim += n;
 	this_header += n;

commit 0a7b35cb18c52d651f6ed9cd59edc979200ab880
Author: Michael Neuling <mikey@neuling.org>
Date:   Sat Feb 10 01:44:33 2007 -0800

    [PATCH] Add retain_initrd boot option
    
    Add retain_initrd option to control freeing of initrd memory after
    extraction.  By default, free memory as previously.
    
    The first boot will need to hold a copy of the in memory fs for the second
    boot.  This image can be large (much larger than the kernel), hence we can
    save time when the memory loader is slow.  Also, it reduces the memory
    footprint while extracting the first boot since you don't need another copy
    of the fs.
    
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Cc: "Randy.Dunlap" <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 4fa0f7977de1..00eff7a11085 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -491,6 +491,17 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
 	return message;
 }
 
+static int __initdata do_retain_initrd;
+
+static int __init retain_initrd_param(char *str)
+{
+	if (*str)
+		return 0;
+	do_retain_initrd = 1;
+	return 1;
+}
+__setup("retain_initrd", retain_initrd_param);
+
 extern char __initramfs_start[], __initramfs_end[];
 #ifdef CONFIG_BLK_DEV_INITRD
 #include <linux/initrd.h>
@@ -501,7 +512,11 @@ static void __init free_initrd(void)
 #ifdef CONFIG_KEXEC
 	unsigned long crashk_start = (unsigned long)__va(crashk_res.start);
 	unsigned long crashk_end   = (unsigned long)__va(crashk_res.end);
+#endif
+	if (do_retain_initrd)
+		goto skip;
 
+#ifdef CONFIG_KEXEC
 	/*
 	 * If the initrd region is overlapped with crashkernel reserved region,
 	 * free only memory that is not part of crashkernel region.
@@ -519,7 +534,7 @@ static void __init free_initrd(void)
 	} else
 #endif
 		free_initrd_mem(initrd_start, initrd_end);
-
+skip:
 	initrd_start = 0;
 	initrd_end = 0;
 }

commit 8d610dd52dd1da696e199e4b4545f33a2a5de5c6
Author: Linus Torvalds <torvalds@woody.osdl.org>
Date:   Mon Dec 11 12:12:04 2006 -0800

    Make sure we populate the initroot filesystem late enough
    
    We should not initialize rootfs before all the core initializers have
    run.  So do it as a separate stage just before starting the regular
    driver initializers.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 85f04037ade1..4fa0f7977de1 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -526,7 +526,7 @@ static void __init free_initrd(void)
 
 #endif
 
-void __init populate_rootfs(void)
+static int __init populate_rootfs(void)
 {
 	char *err = unpack_to_rootfs(__initramfs_start,
 			 __initramfs_end - __initramfs_start, 0);
@@ -544,7 +544,7 @@ void __init populate_rootfs(void)
 			unpack_to_rootfs((char *)initrd_start,
 				initrd_end - initrd_start, 0);
 			free_initrd();
-			return;
+			return 0;
 		}
 		printk("it isn't (%s); looks like an initrd\n", err);
 		fd = sys_open("/initrd.image", O_WRONLY|O_CREAT, 0700);
@@ -565,4 +565,6 @@ void __init populate_rootfs(void)
 #endif
 	}
 #endif
+	return 0;
 }
+rootfs_initcall(populate_rootfs);

commit 2e591bbc0d563e12f5a260fbbca0df7d5810910e
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Wed Dec 6 20:37:19 2006 -0800

    [PATCH] Make initramfs printk a warning on incorrect cpio type
    
    It turns out that the "-c" option of cpio is highly unportable even between
    distros let alone unix variants, and may actually make the wrong type of
    cpio archive.  I just wasted quite some time on this, and the kernel can
    detect this and warn about it (it's __init memory so it gets thrown away
    and thus there is no runtime overhead)
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index d28c1094d7e5..85f04037ade1 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -182,6 +182,10 @@ static int __init do_collect(void)
 
 static int __init do_header(void)
 {
+	if (memcmp(collected, "070707", 6)==0) {
+		error("incorrect cpio method used: use -H newc option");
+		return 1;
+	}
 	if (memcmp(collected, "070701", 6)) {
 		error("no cpio magic");
 		return 1;

commit 2139a7fbf3effd8cad505871e3a3c308780ada32
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Mon Jun 26 00:28:02 2006 -0700

    [PATCH] initramfs overwrite fix
    
    This patch ensures that initramfs overwrites work correctly, even when dealing
    with device nodes of different types.  Furthermore, when replacing a file
    which already exists, we must make very certain that we truncate the existing
    file.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Cc: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index f81cfa40a719..d28c1094d7e5 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -30,6 +30,7 @@ static void __init free(void *where)
 
 static __initdata struct hash {
 	int ino, minor, major;
+	mode_t mode;
 	struct hash *next;
 	char name[N_ALIGN(PATH_MAX)];
 } *head[32];
@@ -41,7 +42,8 @@ static inline int hash(int major, int minor, int ino)
 	return tmp & 31;
 }
 
-static char __init *find_link(int major, int minor, int ino, char *name)
+static char __init *find_link(int major, int minor, int ino,
+			      mode_t mode, char *name)
 {
 	struct hash **p, *q;
 	for (p = head + hash(major, minor, ino); *p; p = &(*p)->next) {
@@ -51,14 +53,17 @@ static char __init *find_link(int major, int minor, int ino, char *name)
 			continue;
 		if ((*p)->major != major)
 			continue;
+		if (((*p)->mode ^ mode) & S_IFMT)
+			continue;
 		return (*p)->name;
 	}
 	q = (struct hash *)malloc(sizeof(struct hash));
 	if (!q)
 		panic("can't allocate link hash entry");
-	q->ino = ino;
-	q->minor = minor;
 	q->major = major;
+	q->minor = minor;
+	q->ino = ino;
+	q->mode = mode;
 	strcpy(q->name, name);
 	q->next = NULL;
 	*p = q;
@@ -229,13 +234,25 @@ static int __init do_reset(void)
 static int __init maybe_link(void)
 {
 	if (nlink >= 2) {
-		char *old = find_link(major, minor, ino, collected);
+		char *old = find_link(major, minor, ino, mode, collected);
 		if (old)
 			return (sys_link(old, collected) < 0) ? -1 : 1;
 	}
 	return 0;
 }
 
+static void __init clean_path(char *path, mode_t mode)
+{
+	struct stat st;
+
+	if (!sys_newlstat(path, &st) && (st.st_mode^mode) & S_IFMT) {
+		if (S_ISDIR(st.st_mode))
+			sys_rmdir(path);
+		else
+			sys_unlink(path);
+	}
+}
+
 static __initdata int wfd;
 
 static int __init do_name(void)
@@ -248,9 +265,15 @@ static int __init do_name(void)
 	}
 	if (dry_run)
 		return 0;
+	clean_path(collected, mode);
 	if (S_ISREG(mode)) {
-		if (maybe_link() >= 0) {
-			wfd = sys_open(collected, O_WRONLY|O_CREAT, mode);
+		int ml = maybe_link();
+		if (ml >= 0) {
+			int openflags = O_WRONLY|O_CREAT;
+			if (ml != 1)
+				openflags |= O_TRUNC;
+			wfd = sys_open(collected, openflags, mode);
+
 			if (wfd >= 0) {
 				sys_fchown(wfd, uid, gid);
 				sys_fchmod(wfd, mode);
@@ -291,6 +314,7 @@ static int __init do_copy(void)
 static int __init do_symlink(void)
 {
 	collected[N_ALIGN(name_len) + body_len] = '\0';
+	clean_path(collected, 0);
 	sys_symlink(collected + N_ALIGN(name_len), collected);
 	sys_lchown(collected, uid, gid);
 	state = SkipIt;

commit 6a050da45b5d855b48b057446847ff1542977b52
Author: Mark Huang <mlhuang@CS.Princeton.EDU>
Date:   Mon May 15 09:44:03 2006 -0700

    [PATCH] initramfs: fix CPIO hardlink check
    
    Copy the filenames of hardlinks when inserting them into the hash, since
    the "name" pointer may point to scratch space (name_buf).  Not doing so
    results in corruption if the scratch space is later overwritten: the wrong
    file may be hardlinked, or, if the scratch space contains garbage, the link
    will fail and a 0-byte file will be created instead.
    
    Signed-off-by: Mark Huang <mlhuang@cs.princeton.edu>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 679d870d991b..f81cfa40a719 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -26,10 +26,12 @@ static void __init free(void *where)
 
 /* link hash */
 
+#define N_ALIGN(len) ((((len) + 1) & ~3) + 2)
+
 static __initdata struct hash {
 	int ino, minor, major;
 	struct hash *next;
-	char *name;
+	char name[N_ALIGN(PATH_MAX)];
 } *head[32];
 
 static inline int hash(int major, int minor, int ino)
@@ -57,7 +59,7 @@ static char __init *find_link(int major, int minor, int ino, char *name)
 	q->ino = ino;
 	q->minor = minor;
 	q->major = major;
-	q->name = name;
+	strcpy(q->name, name);
 	q->next = NULL;
 	*p = q;
 	return NULL;
@@ -133,8 +135,6 @@ static inline void eat(unsigned n)
 	count -= n;
 }
 
-#define N_ALIGN(len) ((((len) + 1) & ~3) + 2)
-
 static __initdata char *collected;
 static __initdata int remains;
 static __initdata char *collect;

commit 33644c5e15917b36c26f0c30c48786c5e8e62be1
Author: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
Date:   Sun Mar 26 01:37:38 2006 -0800

    [PATCH] Fix typo causing bad mode of /initrd.image
    
    I noticed that after boot with an initrd in 2.6.16 the rootfs had:
    
    --w-r-xr-T    1 root     root      6241141 Jan  1  1970 initrd.image
    
    Which is caused by a small typo:
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 77b934cccefe..679d870d991b 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -519,7 +519,7 @@ void __init populate_rootfs(void)
 			return;
 		}
 		printk("it isn't (%s); looks like an initrd\n", err);
-		fd = sys_open("/initrd.image", O_WRONLY|O_CREAT, 700);
+		fd = sys_open("/initrd.image", O_WRONLY|O_CREAT, 0700);
 		if (fd >= 0) {
 			sys_write(fd, (char *)initrd_start,
 					initrd_end - initrd_start);

commit 340e48e662dc9bf79cdd9dc755cb2eb2bad580cd
Author: Zdenek Pavlas <pavlas@nextra.cz>
Date:   Sat Mar 25 03:07:49 2006 -0800

    [PATCH] BLK_DEV_INITRD: do not require BLK_DEV_RAM=y
    
    Initramfs initrd images do not need a ramdisk device, so remove this
    restriction in Kconfig.  BLK_DEV_RAM=n saves about 13k on i386.  Also
    without ramdisk device there's no need for "dry run", so initramfs unpacks
    much faster.
    
    People using cramfs, squashfs, or gzipped ext2/minix initrd images are
    probably smart enough not to turn off ramdisk support by accident.
    
    Cc: Al Viro <viro@ftp.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 637344b05981..77b934cccefe 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -506,6 +506,7 @@ void __init populate_rootfs(void)
 		panic(err);
 #ifdef CONFIG_BLK_DEV_INITRD
 	if (initrd_start) {
+#ifdef CONFIG_BLK_DEV_RAM
 		int fd;
 		printk(KERN_INFO "checking if image is initramfs...");
 		err = unpack_to_rootfs((char *)initrd_start,
@@ -525,6 +526,15 @@ void __init populate_rootfs(void)
 			sys_close(fd);
 			free_initrd();
 		}
+#else
+		printk(KERN_INFO "Unpacking initramfs...");
+		err = unpack_to_rootfs((char *)initrd_start,
+			initrd_end - initrd_start, 0);
+		if (err)
+			panic(err);
+		printk(" done\n");
+		free_initrd();
+#endif
 	}
 #endif
 }

commit 9c15e852a524d55ab768cf48c97f5c684f876af2
Author: Haren Myneni <haren@us.ibm.com>
Date:   Fri Feb 10 01:51:05 2006 -0800

    [PATCH] kexec: fix in free initrd when overlapped with crashkernel region
    
    It is possible that the reserved crashkernel region can be overlapped with
    initrd since the bootloader sets the initrd location.  When the initrd
    region is freed, the second kernel memory will not be contiguous.  The
    Kexec_load can cause an oops since there is no contiguous memory to write
    the second kernel or this memory could be used in the first kernel itself
    and may not be part of the dump.  For example, on powerpc, the initrd is
    located at 36MB and the crashkernel starts at 32MB.  The kexec_load caused
    panic since writing into non-allocated memory (after 36MB).  We could see
    the similar issue even on other archs.
    
    One possibility is to move the initrd outside of crashkernel region.  But,
    the initrd region will be freed anyway before the system is up.  This patch
    fixes this issue and frees only regions that are not part of crashkernel
    memory in case overlaps.
    
    Signed-off-by: Haren Myneni <haren@us.ibm.com>
    Acked-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 0c5d9a3f951b..637344b05981 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -466,10 +466,32 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
 extern char __initramfs_start[], __initramfs_end[];
 #ifdef CONFIG_BLK_DEV_INITRD
 #include <linux/initrd.h>
+#include <linux/kexec.h>
 
 static void __init free_initrd(void)
 {
-	free_initrd_mem(initrd_start, initrd_end);
+#ifdef CONFIG_KEXEC
+	unsigned long crashk_start = (unsigned long)__va(crashk_res.start);
+	unsigned long crashk_end   = (unsigned long)__va(crashk_res.end);
+
+	/*
+	 * If the initrd region is overlapped with crashkernel reserved region,
+	 * free only memory that is not part of crashkernel region.
+	 */
+	if (initrd_start < crashk_end && initrd_end > crashk_start) {
+		/*
+		 * Initialize initrd memory region since the kexec boot does
+		 * not do.
+		 */
+		memset((void *)initrd_start, 0, initrd_end - initrd_start);
+		if (initrd_start < crashk_start)
+			free_initrd_mem(initrd_start, crashk_start);
+		if (initrd_end > crashk_end)
+			free_initrd_mem(crashk_end, initrd_end);
+	} else
+#endif
+		free_initrd_mem(initrd_start, initrd_end);
+
 	initrd_start = 0;
 	initrd_end = 0;
 }

commit 0f3d2bd54f8fb178f516fc6903366e16e20f7428
Author: Jan Beulich <JBeulich@novell.com>
Date:   Tue Sep 13 01:25:12 2005 -0700

    [PATCH] free initrd mem adjustment
    
    Besides freeing initrd memory, also clear out the now dangling pointers to
    it, to make sure accidental late use attempts can be detected.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/init/initramfs.c b/init/initramfs.c
index 02c5ce64990d..0c5d9a3f951b 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -466,6 +466,14 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
 extern char __initramfs_start[], __initramfs_end[];
 #ifdef CONFIG_BLK_DEV_INITRD
 #include <linux/initrd.h>
+
+static void __init free_initrd(void)
+{
+	free_initrd_mem(initrd_start, initrd_end);
+	initrd_start = 0;
+	initrd_end = 0;
+}
+
 #endif
 
 void __init populate_rootfs(void)
@@ -484,7 +492,7 @@ void __init populate_rootfs(void)
 			printk(" it is\n");
 			unpack_to_rootfs((char *)initrd_start,
 				initrd_end - initrd_start, 0);
-			free_initrd_mem(initrd_start, initrd_end);
+			free_initrd();
 			return;
 		}
 		printk("it isn't (%s); looks like an initrd\n", err);
@@ -493,7 +501,7 @@ void __init populate_rootfs(void)
 			sys_write(fd, (char *)initrd_start,
 					initrd_end - initrd_start);
 			sys_close(fd);
-			free_initrd_mem(initrd_start, initrd_end);
+			free_initrd();
 		}
 	}
 #endif

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/init/initramfs.c b/init/initramfs.c
new file mode 100644
index 000000000000..02c5ce64990d
--- /dev/null
+++ b/init/initramfs.c
@@ -0,0 +1,500 @@
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/syscalls.h>
+
+static __initdata char *message;
+static void __init error(char *x)
+{
+	if (!message)
+		message = x;
+}
+
+static void __init *malloc(size_t size)
+{
+	return kmalloc(size, GFP_KERNEL);
+}
+
+static void __init free(void *where)
+{
+	kfree(where);
+}
+
+/* link hash */
+
+static __initdata struct hash {
+	int ino, minor, major;
+	struct hash *next;
+	char *name;
+} *head[32];
+
+static inline int hash(int major, int minor, int ino)
+{
+	unsigned long tmp = ino + minor + (major << 3);
+	tmp += tmp >> 5;
+	return tmp & 31;
+}
+
+static char __init *find_link(int major, int minor, int ino, char *name)
+{
+	struct hash **p, *q;
+	for (p = head + hash(major, minor, ino); *p; p = &(*p)->next) {
+		if ((*p)->ino != ino)
+			continue;
+		if ((*p)->minor != minor)
+			continue;
+		if ((*p)->major != major)
+			continue;
+		return (*p)->name;
+	}
+	q = (struct hash *)malloc(sizeof(struct hash));
+	if (!q)
+		panic("can't allocate link hash entry");
+	q->ino = ino;
+	q->minor = minor;
+	q->major = major;
+	q->name = name;
+	q->next = NULL;
+	*p = q;
+	return NULL;
+}
+
+static void __init free_hash(void)
+{
+	struct hash **p, *q;
+	for (p = head; p < head + 32; p++) {
+		while (*p) {
+			q = *p;
+			*p = q->next;
+			free(q);
+		}
+	}
+}
+
+/* cpio header parsing */
+
+static __initdata unsigned long ino, major, minor, nlink;
+static __initdata mode_t mode;
+static __initdata unsigned long body_len, name_len;
+static __initdata uid_t uid;
+static __initdata gid_t gid;
+static __initdata unsigned rdev;
+
+static void __init parse_header(char *s)
+{
+	unsigned long parsed[12];
+	char buf[9];
+	int i;
+
+	buf[8] = '\0';
+	for (i = 0, s += 6; i < 12; i++, s += 8) {
+		memcpy(buf, s, 8);
+		parsed[i] = simple_strtoul(buf, NULL, 16);
+	}
+	ino = parsed[0];
+	mode = parsed[1];
+	uid = parsed[2];
+	gid = parsed[3];
+	nlink = parsed[4];
+	body_len = parsed[6];
+	major = parsed[7];
+	minor = parsed[8];
+	rdev = new_encode_dev(MKDEV(parsed[9], parsed[10]));
+	name_len = parsed[11];
+}
+
+/* FSM */
+
+static __initdata enum state {
+	Start,
+	Collect,
+	GotHeader,
+	SkipIt,
+	GotName,
+	CopyFile,
+	GotSymlink,
+	Reset
+} state, next_state;
+
+static __initdata char *victim;
+static __initdata unsigned count;
+static __initdata loff_t this_header, next_header;
+
+static __initdata int dry_run;
+
+static inline void eat(unsigned n)
+{
+	victim += n;
+	this_header += n;
+	count -= n;
+}
+
+#define N_ALIGN(len) ((((len) + 1) & ~3) + 2)
+
+static __initdata char *collected;
+static __initdata int remains;
+static __initdata char *collect;
+
+static void __init read_into(char *buf, unsigned size, enum state next)
+{
+	if (count >= size) {
+		collected = victim;
+		eat(size);
+		state = next;
+	} else {
+		collect = collected = buf;
+		remains = size;
+		next_state = next;
+		state = Collect;
+	}
+}
+
+static __initdata char *header_buf, *symlink_buf, *name_buf;
+
+static int __init do_start(void)
+{
+	read_into(header_buf, 110, GotHeader);
+	return 0;
+}
+
+static int __init do_collect(void)
+{
+	unsigned n = remains;
+	if (count < n)
+		n = count;
+	memcpy(collect, victim, n);
+	eat(n);
+	collect += n;
+	if ((remains -= n) != 0)
+		return 1;
+	state = next_state;
+	return 0;
+}
+
+static int __init do_header(void)
+{
+	if (memcmp(collected, "070701", 6)) {
+		error("no cpio magic");
+		return 1;
+	}
+	parse_header(collected);
+	next_header = this_header + N_ALIGN(name_len) + body_len;
+	next_header = (next_header + 3) & ~3;
+	if (dry_run) {
+		read_into(name_buf, N_ALIGN(name_len), GotName);
+		return 0;
+	}
+	state = SkipIt;
+	if (name_len <= 0 || name_len > PATH_MAX)
+		return 0;
+	if (S_ISLNK(mode)) {
+		if (body_len > PATH_MAX)
+			return 0;
+		collect = collected = symlink_buf;
+		remains = N_ALIGN(name_len) + body_len;
+		next_state = GotSymlink;
+		state = Collect;
+		return 0;
+	}
+	if (S_ISREG(mode) || !body_len)
+		read_into(name_buf, N_ALIGN(name_len), GotName);
+	return 0;
+}
+
+static int __init do_skip(void)
+{
+	if (this_header + count < next_header) {
+		eat(count);
+		return 1;
+	} else {
+		eat(next_header - this_header);
+		state = next_state;
+		return 0;
+	}
+}
+
+static int __init do_reset(void)
+{
+	while(count && *victim == '\0')
+		eat(1);
+	if (count && (this_header & 3))
+		error("broken padding");
+	return 1;
+}
+
+static int __init maybe_link(void)
+{
+	if (nlink >= 2) {
+		char *old = find_link(major, minor, ino, collected);
+		if (old)
+			return (sys_link(old, collected) < 0) ? -1 : 1;
+	}
+	return 0;
+}
+
+static __initdata int wfd;
+
+static int __init do_name(void)
+{
+	state = SkipIt;
+	next_state = Reset;
+	if (strcmp(collected, "TRAILER!!!") == 0) {
+		free_hash();
+		return 0;
+	}
+	if (dry_run)
+		return 0;
+	if (S_ISREG(mode)) {
+		if (maybe_link() >= 0) {
+			wfd = sys_open(collected, O_WRONLY|O_CREAT, mode);
+			if (wfd >= 0) {
+				sys_fchown(wfd, uid, gid);
+				sys_fchmod(wfd, mode);
+				state = CopyFile;
+			}
+		}
+	} else if (S_ISDIR(mode)) {
+		sys_mkdir(collected, mode);
+		sys_chown(collected, uid, gid);
+		sys_chmod(collected, mode);
+	} else if (S_ISBLK(mode) || S_ISCHR(mode) ||
+		   S_ISFIFO(mode) || S_ISSOCK(mode)) {
+		if (maybe_link() == 0) {
+			sys_mknod(collected, mode, rdev);
+			sys_chown(collected, uid, gid);
+			sys_chmod(collected, mode);
+		}
+	}
+	return 0;
+}
+
+static int __init do_copy(void)
+{
+	if (count >= body_len) {
+		sys_write(wfd, victim, body_len);
+		sys_close(wfd);
+		eat(body_len);
+		state = SkipIt;
+		return 0;
+	} else {
+		sys_write(wfd, victim, count);
+		body_len -= count;
+		eat(count);
+		return 1;
+	}
+}
+
+static int __init do_symlink(void)
+{
+	collected[N_ALIGN(name_len) + body_len] = '\0';
+	sys_symlink(collected + N_ALIGN(name_len), collected);
+	sys_lchown(collected, uid, gid);
+	state = SkipIt;
+	next_state = Reset;
+	return 0;
+}
+
+static __initdata int (*actions[])(void) = {
+	[Start]		= do_start,
+	[Collect]	= do_collect,
+	[GotHeader]	= do_header,
+	[SkipIt]	= do_skip,
+	[GotName]	= do_name,
+	[CopyFile]	= do_copy,
+	[GotSymlink]	= do_symlink,
+	[Reset]		= do_reset,
+};
+
+static int __init write_buffer(char *buf, unsigned len)
+{
+	count = len;
+	victim = buf;
+
+	while (!actions[state]())
+		;
+	return len - count;
+}
+
+static void __init flush_buffer(char *buf, unsigned len)
+{
+	int written;
+	if (message)
+		return;
+	while ((written = write_buffer(buf, len)) < len && !message) {
+		char c = buf[written];
+		if (c == '0') {
+			buf += written;
+			len -= written;
+			state = Start;
+		} else if (c == 0) {
+			buf += written;
+			len -= written;
+			state = Reset;
+		} else
+			error("junk in compressed archive");
+	}
+}
+
+/*
+ * gzip declarations
+ */
+
+#define OF(args)  args
+
+#ifndef memzero
+#define memzero(s, n)     memset ((s), 0, (n))
+#endif
+
+typedef unsigned char  uch;
+typedef unsigned short ush;
+typedef unsigned long  ulg;
+
+#define WSIZE 0x8000    /* window size--must be a power of two, and */
+			/*  at least 32K for zip's deflate method */
+
+static uch *inbuf;
+static uch *window;
+
+static unsigned insize;  /* valid bytes in inbuf */
+static unsigned inptr;   /* index of next byte to be processed in inbuf */
+static unsigned outcnt;  /* bytes in output buffer */
+static long bytes_out;
+
+#define get_byte()  (inptr < insize ? inbuf[inptr++] : -1)
+		
+/* Diagnostic functions (stubbed out) */
+#define Assert(cond,msg)
+#define Trace(x)
+#define Tracev(x)
+#define Tracevv(x)
+#define Tracec(c,x)
+#define Tracecv(c,x)
+
+#define STATIC static
+#define INIT __init
+
+static void __init flush_window(void);
+static void __init error(char *m);
+static void __init gzip_mark(void **);
+static void __init gzip_release(void **);
+
+#include "../lib/inflate.c"
+
+static void __init gzip_mark(void **ptr)
+{
+}
+
+static void __init gzip_release(void **ptr)
+{
+}
+
+/* ===========================================================================
+ * Write the output window window[0..outcnt-1] and update crc and bytes_out.
+ * (Used for the decompressed data only.)
+ */
+static void __init flush_window(void)
+{
+	ulg c = crc;         /* temporary variable */
+	unsigned n;
+	uch *in, ch;
+
+	flush_buffer(window, outcnt);
+	in = window;
+	for (n = 0; n < outcnt; n++) {
+		ch = *in++;
+		c = crc_32_tab[((int)c ^ ch) & 0xff] ^ (c >> 8);
+	}
+	crc = c;
+	bytes_out += (ulg)outcnt;
+	outcnt = 0;
+}
+
+static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
+{
+	int written;
+	dry_run = check_only;
+	header_buf = malloc(110);
+	symlink_buf = malloc(PATH_MAX + N_ALIGN(PATH_MAX) + 1);
+	name_buf = malloc(N_ALIGN(PATH_MAX));
+	window = malloc(WSIZE);
+	if (!window || !header_buf || !symlink_buf || !name_buf)
+		panic("can't allocate buffers");
+	state = Start;
+	this_header = 0;
+	message = NULL;
+	while (!message && len) {
+		loff_t saved_offset = this_header;
+		if (*buf == '0' && !(this_header & 3)) {
+			state = Start;
+			written = write_buffer(buf, len);
+			buf += written;
+			len -= written;
+			continue;
+		}
+		if (!*buf) {
+			buf++;
+			len--;
+			this_header++;
+			continue;
+		}
+		this_header = 0;
+		insize = len;
+		inbuf = buf;
+		inptr = 0;
+		outcnt = 0;		/* bytes in output buffer */
+		bytes_out = 0;
+		crc = (ulg)0xffffffffL; /* shift register contents */
+		makecrc();
+		gunzip();
+		if (state != Reset)
+			error("junk in gzipped archive");
+		this_header = saved_offset + inptr;
+		buf += inptr;
+		len -= inptr;
+	}
+	free(window);
+	free(name_buf);
+	free(symlink_buf);
+	free(header_buf);
+	return message;
+}
+
+extern char __initramfs_start[], __initramfs_end[];
+#ifdef CONFIG_BLK_DEV_INITRD
+#include <linux/initrd.h>
+#endif
+
+void __init populate_rootfs(void)
+{
+	char *err = unpack_to_rootfs(__initramfs_start,
+			 __initramfs_end - __initramfs_start, 0);
+	if (err)
+		panic(err);
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (initrd_start) {
+		int fd;
+		printk(KERN_INFO "checking if image is initramfs...");
+		err = unpack_to_rootfs((char *)initrd_start,
+			initrd_end - initrd_start, 1);
+		if (!err) {
+			printk(" it is\n");
+			unpack_to_rootfs((char *)initrd_start,
+				initrd_end - initrd_start, 0);
+			free_initrd_mem(initrd_start, initrd_end);
+			return;
+		}
+		printk("it isn't (%s); looks like an initrd\n", err);
+		fd = sys_open("/initrd.image", O_WRONLY|O_CREAT, 700);
+		if (fd >= 0) {
+			sys_write(fd, (char *)initrd_start,
+					initrd_end - initrd_start);
+			sys_close(fd);
+			free_initrd_mem(initrd_start, initrd_end);
+		}
+	}
+#endif
+}
