commit a3963015787d0a3bd9c2d91b62de5ca70413dc3b
Author: Joe Perches <joe@perches.com>
Date:   Thu Jun 4 16:51:02 2020 -0700

    fs/seq_file.c: seq_read: Update pr_info_ratelimited
    
    Use a more common logging style.
    
    Add and use pr_fmt, coalesce the format string, align arguments,
    use better grammar.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Vasily Averin <vvs@virtuozzo.com>
    Link: http://lkml.kernel.org/r/96ff603230ca1bd60034c36519be3930c3a3a226.camel@perches.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 70f5fdf99bf6..4e6239f33c06 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -6,6 +6,8 @@
  * initial implementation -- AV, Oct 2001.
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/cache.h>
 #include <linux/fs.h>
 #include <linux/export.h>
@@ -233,9 +235,8 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 
 		p = m->op->next(m, p, &m->index);
 		if (pos == m->index) {
-			pr_info_ratelimited("buggy seq_file .next function %ps "
-				"did not updated position index\n",
-				m->op->next);
+			pr_info_ratelimited("buggy .next function %ps did not update position index\n",
+					    m->op->next);
 			m->index++;
 		}
 		if (!p || IS_ERR(p)) {

commit 3bfa7e141b0bbb818b25e0daafb65aee92e49ac4
Author: Vasily Averin <vvs@virtuozzo.com>
Date:   Fri Apr 10 14:34:06 2020 -0700

    fs/seq_file.c: seq_read(): add info message about buggy .next functions
    
    Patch series "seq_file .next functions should increase position index".
    
    In Aug 2018 NeilBrown noticed commit 1f4aace60b0e ("fs/seq_file.c:
    simplify seq_file iteration code and interface")
    
    "Some ->next functions do not increment *pos when they return NULL...
    Note that such ->next functions are buggy and should be fixed.  A simple
    demonstration is dd if=/proc/swaps bs=1000 skip=1 Choose any block size
    larger than the size of /proc/swaps.  This will always show the whole
    last line of /proc/swaps"
    
    Described problem is still actual.  If you make lseek into middle of
    last output line following read will output end of last line and whole
    last line once again.
    
      $ dd if=/proc/swaps bs=1  # usual output
      Filename                              Type            Size    Used    Priority
      /dev/dm-0                             partition       4194812 97536   -2
      104+0 records in
      104+0 records out
      104 bytes copied
    
      $ dd if=/proc/swaps bs=40 skip=1    # last line was generated twice
      dd: /proc/swaps: cannot skip to specified offset
      v/dm-0                                partition       4194812 97536   -2
      /dev/dm-0                             partition       4194812 97536   -2
      3+1 records in
      3+1 records out
      131 bytes copied
    
    There are lot of other affected files, I've found 30+ including
    /proc/net/ip_tables_matches and /proc/sysvipc/*
    
    I've sent patches into maillists of affected subsystems already, this
    patch-set fixes the problem in files related to pstore, tracing, gcov,
    sysvipc and other subsystems processed via linux-kernel@ mailing list
    directly
    
    https://bugzilla.kernel.org/show_bug.cgi?id=206283
    
    This patch (of 4):
    
    Add debug code to seq_read() to detect missed or out-of-tree incorrect
    .next seq_file functions.
    
    [akpm@linux-foundation.org: s/pr_info/pr_info_ratelimited/, per Qian Cai]
    https://bugzilla.kernel.org/show_bug.cgi?id=206283
    Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: NeilBrown <neilb@suse.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Cc: Peter Oberparleiter <oberpar@linux.ibm.com>
    Cc: Waiman Long <longman@redhat.com>
    Link: http://lkml.kernel.org/r/244674e5-760c-86bd-d08a-047042881748@virtuozzo.com
    Link: http://lkml.kernel.org/r/7c24087c-e280-e580-5b0c-0cdaeb14cd18@virtuozzo.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 79781ebd2145..70f5fdf99bf6 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -232,9 +232,12 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 		loff_t pos = m->index;
 
 		p = m->op->next(m, p, &m->index);
-		if (pos == m->index)
-			/* Buggy ->next function */
+		if (pos == m->index) {
+			pr_info_ratelimited("buggy seq_file .next function %ps "
+				"did not updated position index\n",
+				m->op->next);
 			m->index++;
+		}
 		if (!p || IS_ERR(p)) {
 			err = PTR_ERR(p);
 			break;

commit b829a0f0f2f2094c1e40637259c44b854e6ebe96
Author: Matthew Wilcox (Oracle) <willy@infradead.org>
Date:   Mon Apr 6 20:09:17 2020 -0700

    seq_file: remove m->version
    
    The process maps file was the only user of version (introduced back in
    2005).  Now that it uses ppos instead, we can remove it.
    
    Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Link: http://lkml.kernel.org/r/20200317193201.9924-4-adobriyan@gmail.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 1600034a929b..79781ebd2145 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -67,13 +67,6 @@ int seq_open(struct file *file, const struct seq_operations *op)
 	// to the lifetime of the file.
 	p->file = file;
 
-	/*
-	 * Wrappers around seq_open(e.g. swaps_open) need to be
-	 * aware of this. If they set f_version themselves, they
-	 * should call seq_open first and then set f_version.
-	 */
-	file->f_version = 0;
-
 	/*
 	 * seq_files support lseek() and pread().  They do not implement
 	 * write() at all, but we clear FMODE_PWRITE here for historical
@@ -94,7 +87,6 @@ static int traverse(struct seq_file *m, loff_t offset)
 	int error = 0;
 	void *p;
 
-	m->version = 0;
 	m->index = 0;
 	m->count = m->from = 0;
 	if (!offset)
@@ -160,26 +152,12 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 
 	mutex_lock(&m->lock);
 
-	/*
-	 * seq_file->op->..m_start/m_stop/m_next may do special actions
-	 * or optimisations based on the file->f_version, so we want to
-	 * pass the file->f_version to those methods.
-	 *
-	 * seq_file->version is just copy of f_version, and seq_file
-	 * methods can treat it simply as file version.
-	 * It is copied in first and copied out after all operations.
-	 * It is convenient to have it as  part of structure to avoid the
-	 * need of passing another argument to all the seq_file methods.
-	 */
-	m->version = file->f_version;
-
 	/*
 	 * if request is to read from zero offset, reset iterator to first
 	 * record as it might have been already advanced by previous requests
 	 */
 	if (*ppos == 0) {
 		m->index = 0;
-		m->version = 0;
 		m->count = 0;
 	}
 
@@ -190,7 +168,6 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 		if (err) {
 			/* With prejudice... */
 			m->read_pos = 0;
-			m->version = 0;
 			m->index = 0;
 			m->count = 0;
 			goto Done;
@@ -243,7 +220,6 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 		m->buf = seq_buf_alloc(m->size <<= 1);
 		if (!m->buf)
 			goto Enomem;
-		m->version = 0;
 		p = m->op->start(m, &m->index);
 	}
 	m->op->stop(m, p);
@@ -287,7 +263,6 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 		*ppos += copied;
 		m->read_pos += copied;
 	}
-	file->f_version = m->version;
 	mutex_unlock(&m->lock);
 	return copied;
 Enomem:
@@ -313,7 +288,6 @@ loff_t seq_lseek(struct file *file, loff_t offset, int whence)
 	loff_t retval = -EINVAL;
 
 	mutex_lock(&m->lock);
-	m->version = file->f_version;
 	switch (whence) {
 	case SEEK_CUR:
 		offset += file->f_pos;
@@ -329,7 +303,6 @@ loff_t seq_lseek(struct file *file, loff_t offset, int whence)
 				/* with extreme prejudice... */
 				file->f_pos = 0;
 				m->read_pos = 0;
-				m->version = 0;
 				m->index = 0;
 				m->count = 0;
 			} else {
@@ -340,7 +313,6 @@ loff_t seq_lseek(struct file *file, loff_t offset, int whence)
 			file->f_pos = offset;
 		}
 	}
-	file->f_version = m->version;
 	mutex_unlock(&m->lock);
 	return retval;
 }

commit 6a2aeab59e97101b4001bac84388fc49a992f87e
Author: NeilBrown <neilb@suse.com>
Date:   Tue Aug 13 15:37:44 2019 -0700

    seq_file: fix problem when seeking mid-record
    
    If you use lseek or similar (e.g.  pread) to access a location in a
    seq_file file that is within a record, rather than at a record boundary,
    then the first read will return the remainder of the record, and the
    second read will return the whole of that same record (instead of the
    next record).  When seeking to a record boundary, the next record is
    correctly returned.
    
    This bug was introduced by a recent patch (identified below).  Before
    that patch, seq_read() would increment m->index when the last of the
    buffer was returned (m->count == 0).  After that patch, we rely on
    ->next to increment m->index after filling the buffer - but there was
    one place where that didn't happen.
    
    Link: https://lkml.kernel.org/lkml/877e7xl029.fsf@notabene.neil.brown.name/
    Fixes: 1f4aace60b0e ("fs/seq_file.c: simplify seq_file iteration code and interface")
    Signed-off-by: NeilBrown <neilb@suse.com>
    Reported-by: Sergei Turchanov <turchanov@farpost.com>
    Tested-by: Sergei Turchanov <turchanov@farpost.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Markus Elfring <Markus.Elfring@web.de>
    Cc: <stable@vger.kernel.org>    [4.19+]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 04f09689cd6d..1600034a929b 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -119,6 +119,7 @@ static int traverse(struct seq_file *m, loff_t offset)
 		}
 		if (seq_has_overflowed(m))
 			goto Eoverflow;
+		p = m->op->next(m, p, &m->index);
 		if (pos + m->count > offset) {
 			m->from = offset - pos;
 			m->count -= m->from;
@@ -126,7 +127,6 @@ static int traverse(struct seq_file *m, loff_t offset)
 		}
 		pos += m->count;
 		m->count = 0;
-		p = m->op->next(m, p, &m->index);
 		if (pos == offset)
 			break;
 	}

commit ea053e164cc812f0c00a58cbbf8c65e27ceb6148
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Wed Jun 19 12:30:13 2019 -0400

    nfsd: escape high characters in binary data
    
    I'm exposing some information about NFS clients in pseudofiles.  I
    expect to eventually have simple tools to help read those pseudofiles.
    
    But it's also helpful if the raw files are human-readable to the extent
    possible.  It aids debugging and makes them usable on systems that don't
    have the latest nfs-utils.
    
    A minor challenge there is opaque client-generated protocol objects like
    state owners and client identifiers.  Some clients generate those to
    include handy information in plain ascii.  But they may also include
    arbitrary byte sequences.
    
    I think the simplest approach is to limit to isprint(c) && isascii(c)
    and escape everything else.
    
    That means you can just cat the file and get something that looks OK.
    Also, I'm trying to keep these files legal YAML, which requires them to
    UTF-8, and this is a simple way to guarantee that.
    
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index abe27ec43176..04f09689cd6d 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -384,6 +384,17 @@ void seq_escape(struct seq_file *m, const char *s, const char *esc)
 }
 EXPORT_SYMBOL(seq_escape);
 
+void seq_escape_mem_ascii(struct seq_file *m, const char *src, size_t isz)
+{
+	char *buf;
+	size_t size = seq_get_buf(m, &buf);
+	int ret;
+
+	ret = string_escape_mem_ascii(src, isz, buf, size);
+	seq_commit(m, ret < size ? ret : -1);
+}
+EXPORT_SYMBOL(seq_escape_mem_ascii);
+
 void seq_vprintf(struct seq_file *m, const char *f, va_list args)
 {
 	int len;

commit 0a4c92657f2543bb8fd480c5af90c6bb87f18e00
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Wed Jan 23 02:48:28 2019 -0600

    fs: mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    This patch fixes the following warnings:
    
    fs/affs/affs.h:124:38: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/configfs/dir.c:1692:11: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/configfs/dir.c:1694:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ceph/file.c:249:3: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ext4/hash.c:233:15: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ext4/hash.c:246:15: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ext2/inode.c:1237:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ext2/inode.c:1244:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ext4/indirect.c:1182:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ext4/indirect.c:1188:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ext4/indirect.c:1432:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ext4/indirect.c:1440:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/f2fs/node.c:618:8: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/f2fs/node.c:620:8: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/btrfs/ref-verify.c:522:15: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/gfs2/bmap.c:711:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/gfs2/bmap.c:722:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/jffs2/fs.c:339:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/nfsd/nfs4proc.c:429:12: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ufs/util.h:62:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ufs/util.h:43:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/fcntl.c:770:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/seq_file.c:319:10: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/libfs.c:148:11: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/libfs.c:150:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/signalfd.c:178:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/locks.c:1473:16: warning: this statement may fall through [-Wimplicit-fallthrough=]
    
    Warning level 3 was used: -Wimplicit-fallthrough=3
    
    This patch is part of the ongoing efforts to enabling
    -Wimplicit-fallthrough.
    
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 1dea7a8a5255..abe27ec43176 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -317,6 +317,7 @@ loff_t seq_lseek(struct file *file, loff_t offset, int whence)
 	switch (whence) {
 	case SEEK_CUR:
 		offset += file->f_pos;
+		/* fall through */
 	case SEEK_SET:
 		if (offset < 0)
 			break;

commit 1f4aace60b0edc2d885aaa263abf4df42c8c65a8
Author: NeilBrown <neilb@suse.com>
Date:   Fri Aug 17 15:44:41 2018 -0700

    fs/seq_file.c: simplify seq_file iteration code and interface
    
    The documentation for seq_file suggests that it is necessary to be able
    to move the iterator to a given offset, however that is not the case.
    If the iterator is stored in the private data and is stable from one
    read() syscall to the next, it is only necessary to support first/next
    interactions.  Implementing this in a client is a little clumsy.
    
     - if ->start() is given a pos of zero, it should go to start of
       sequence.
    
     - if ->start() is given the name pos that was given to the most recent
       next() or start(), it should restore the iterator to state just
       before that last call
    
     - if ->start is given another number, it should set the iterator one
       beyond the start just before the last ->start or ->next call.
    
    Also, the documentation says that the implementation can interpret the
    pos however it likes (other than zero meaning start), but seq_file
    increments the pos sometimes which does impose on the implementation.
    
    This patch simplifies the interface for first/next iteration and
    simplifies the code, while maintaining complete backward compatability.
    Now:
    
     - if ->start() is given a pos of zero, it should return an iterator
       placed at the start of the sequence
    
     - if ->start() is given a non-zero pos, it should return the iterator
       in the same state it was after the last ->start or ->next.
    
    This is particularly useful for interators which walk the multiple
    chains in a hash table, e.g.  using rhashtable_walk*.  See
    fs/gfs2/glock.c and drivers/staging/lustre/lustre/llite/vvp_dev.c
    
    A large part of achieving this is to *always* call ->next after ->show
    has successfully stored all of an entry in the buffer.  Never just
    increment the index instead.  Also:
    
     - always pass &m->index to ->start() and ->next(), never a temp
       variable
    
     - don't clear ->from when ->count is zero, as ->from is dead when
       ->count is zero.
    
    Some ->next functions do not increment *pos when they return NULL.  To
    maintain compatability with this, we still need to increment m->index in
    one place, if ->next didn't increment it.  Note that such ->next
    functions are buggy and should be fixed.  A simple demonstration is
    
       dd if=/proc/swaps bs=1000 skip=1
    
    Choose any block size larger than the size of /proc/swaps.  This will
    always show the whole last line of /proc/swaps.
    
    This patch doesn't work around buggy next() functions for this case.
    
    [neilb@suse.com: ensure ->from is valid]
      Link: http://lkml.kernel.org/r/87601ryb8a.fsf@notabene.neil.brown.name
    Signed-off-by: NeilBrown <neilb@suse.com>
    Acked-by: Jonathan Corbet <corbet@lwn.net>      [docs]
    Tested-by: Jann Horn <jannh@google.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Kees Cook <keescook@chromium.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 4cc090b50cc5..1dea7a8a5255 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -90,23 +90,22 @@ EXPORT_SYMBOL(seq_open);
 
 static int traverse(struct seq_file *m, loff_t offset)
 {
-	loff_t pos = 0, index;
+	loff_t pos = 0;
 	int error = 0;
 	void *p;
 
 	m->version = 0;
-	index = 0;
+	m->index = 0;
 	m->count = m->from = 0;
-	if (!offset) {
-		m->index = index;
+	if (!offset)
 		return 0;
-	}
+
 	if (!m->buf) {
 		m->buf = seq_buf_alloc(m->size = PAGE_SIZE);
 		if (!m->buf)
 			return -ENOMEM;
 	}
-	p = m->op->start(m, &index);
+	p = m->op->start(m, &m->index);
 	while (p) {
 		error = PTR_ERR(p);
 		if (IS_ERR(p))
@@ -123,20 +122,15 @@ static int traverse(struct seq_file *m, loff_t offset)
 		if (pos + m->count > offset) {
 			m->from = offset - pos;
 			m->count -= m->from;
-			m->index = index;
 			break;
 		}
 		pos += m->count;
 		m->count = 0;
-		if (pos == offset) {
-			index++;
-			m->index = index;
+		p = m->op->next(m, p, &m->index);
+		if (pos == offset)
 			break;
-		}
-		p = m->op->next(m, p, &index);
 	}
 	m->op->stop(m, p);
-	m->index = index;
 	return error;
 
 Eoverflow:
@@ -160,7 +154,6 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 {
 	struct seq_file *m = file->private_data;
 	size_t copied = 0;
-	loff_t pos;
 	size_t n;
 	void *p;
 	int err = 0;
@@ -223,16 +216,12 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 		size -= n;
 		buf += n;
 		copied += n;
-		if (!m->count) {
-			m->from = 0;
-			m->index++;
-		}
 		if (!size)
 			goto Done;
 	}
 	/* we need at least one record in buffer */
-	pos = m->index;
-	p = m->op->start(m, &pos);
+	m->from = 0;
+	p = m->op->start(m, &m->index);
 	while (1) {
 		err = PTR_ERR(p);
 		if (!p || IS_ERR(p))
@@ -243,8 +232,7 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 		if (unlikely(err))
 			m->count = 0;
 		if (unlikely(!m->count)) {
-			p = m->op->next(m, p, &pos);
-			m->index = pos;
+			p = m->op->next(m, p, &m->index);
 			continue;
 		}
 		if (m->count < m->size)
@@ -256,29 +244,33 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 		if (!m->buf)
 			goto Enomem;
 		m->version = 0;
-		pos = m->index;
-		p = m->op->start(m, &pos);
+		p = m->op->start(m, &m->index);
 	}
 	m->op->stop(m, p);
 	m->count = 0;
 	goto Done;
 Fill:
 	/* they want more? let's try to get some more */
-	while (m->count < size) {
+	while (1) {
 		size_t offs = m->count;
-		loff_t next = pos;
-		p = m->op->next(m, p, &next);
+		loff_t pos = m->index;
+
+		p = m->op->next(m, p, &m->index);
+		if (pos == m->index)
+			/* Buggy ->next function */
+			m->index++;
 		if (!p || IS_ERR(p)) {
 			err = PTR_ERR(p);
 			break;
 		}
+		if (m->count >= size)
+			break;
 		err = m->op->show(m, p);
 		if (seq_has_overflowed(m) || err) {
 			m->count = offs;
 			if (likely(err <= 0))
 				break;
 		}
-		pos = next;
 	}
 	m->op->stop(m, p);
 	n = min(m->count, size);
@@ -287,11 +279,7 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 		goto Efault;
 	copied += n;
 	m->count -= n;
-	if (m->count)
-		m->from = n;
-	else
-		pos++;
-	m->index = pos;
+	m->from = n;
 Done:
 	if (!copied)
 		copied = err;

commit 6c04ab0eddc9a38e6c14ae4b6217db1e34436b8c
Author: Hugh Dickins <hughd@google.com>
Date:   Fri May 25 14:47:50 2018 -0700

    proc: fix smaps and meminfo alignment
    
    The 4.17-rc /proc/meminfo and /proc/<pid>/smaps look ugly: single-digit
    numbers (commonly 0) are misaligned.
    
    Remove seq_put_decimal_ull_width()'s leftover optimization for single
    digits: it's wrong now that num_to_str() takes care of the width.
    
    Link: http://lkml.kernel.org/r/alpine.LSU.2.11.1805241554210.1326@eggly.anvils
    Fixes: d1be35cb6f96 ("proc: add seq_put_decimal_ull_width to speed up /proc/pid/smaps")
    Signed-off-by: Hugh Dickins <hughd@google.com>
    Cc: Andrei Vagin <avagin@openvz.org>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index c6c27f1f9c98..4cc090b50cc5 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -709,11 +709,6 @@ void seq_put_decimal_ull_width(struct seq_file *m, const char *delimiter,
 	if (m->count + width >= m->size)
 		goto overflow;
 
-	if (num < 10) {
-		m->buf[m->count++] = num + '0';
-		return;
-	}
-
 	len = num_to_str(m->buf + m->count, m->size - m->count, num, width);
 	if (!len)
 		goto overflow;

commit d64d01a155f84850f7dc9795f464e3df9a5ddb10
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Apr 10 16:34:49 2018 -0700

    seq_file: account everything to kmemcg
    
    All it takes to open a file and read 1 byte from it.
    
    seq_file will be allocated along with any private allocations, and more
    importantly seq file buffer which is 1 page by default.
    
    Link: http://lkml.kernel.org/r/20180310085252.GB17121@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Glauber Costa <glommer@gmail.com>
    Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 3cb340583074..c6c27f1f9c98 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -29,7 +29,7 @@ static void seq_set_overflow(struct seq_file *m)
 
 static void *seq_buf_alloc(unsigned long size)
 {
-	return kvmalloc(size, GFP_KERNEL);
+	return kvmalloc(size, GFP_KERNEL_ACCOUNT);
 }
 
 /**
@@ -566,7 +566,7 @@ static void single_stop(struct seq_file *p, void *v)
 int single_open(struct file *file, int (*show)(struct seq_file *, void *),
 		void *data)
 {
-	struct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);
+	struct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL_ACCOUNT);
 	int res = -ENOMEM;
 
 	if (op) {
@@ -628,7 +628,7 @@ void *__seq_open_private(struct file *f, const struct seq_operations *ops,
 	void *private;
 	struct seq_file *seq;
 
-	private = kzalloc(psize, GFP_KERNEL);
+	private = kzalloc(psize, GFP_KERNEL_ACCOUNT);
 	if (private == NULL)
 		goto out;
 
@@ -1112,5 +1112,5 @@ EXPORT_SYMBOL(seq_hlist_next_percpu);
 
 void __init seq_file_init(void)
 {
-	seq_file_cache = KMEM_CACHE(seq_file, SLAB_PANIC);
+	seq_file_cache = KMEM_CACHE(seq_file, SLAB_ACCOUNT|SLAB_PANIC);
 }

commit 0965232035cfa59a64d197cf8a8ee0bc407bb3e4
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Apr 10 16:34:45 2018 -0700

    seq_file: allocate seq_file from kmem_cache
    
    For fine-grained debugging and usercopy protection.
    
    Link: http://lkml.kernel.org/r/20180310085027.GA17121@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Glauber Costa <glommer@gmail.com>
    Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 0677e89f3c6f..3cb340583074 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -6,6 +6,7 @@
  * initial implementation -- AV, Oct 2001.
  */
 
+#include <linux/cache.h>
 #include <linux/fs.h>
 #include <linux/export.h>
 #include <linux/seq_file.h>
@@ -19,6 +20,8 @@
 #include <linux/uaccess.h>
 #include <asm/page.h>
 
+static struct kmem_cache *seq_file_cache __ro_after_init;
+
 static void seq_set_overflow(struct seq_file *m)
 {
 	m->count = m->size;
@@ -51,7 +54,7 @@ int seq_open(struct file *file, const struct seq_operations *op)
 
 	WARN_ON(file->private_data);
 
-	p = kzalloc(sizeof(*p), GFP_KERNEL);
+	p = kmem_cache_zalloc(seq_file_cache, GFP_KERNEL);
 	if (!p)
 		return -ENOMEM;
 
@@ -366,7 +369,7 @@ int seq_release(struct inode *inode, struct file *file)
 {
 	struct seq_file *m = file->private_data;
 	kvfree(m->buf);
-	kfree(m);
+	kmem_cache_free(seq_file_cache, m);
 	return 0;
 }
 EXPORT_SYMBOL(seq_release);
@@ -1106,3 +1109,8 @@ seq_hlist_next_percpu(void *v, struct hlist_head __percpu *head,
 	return NULL;
 }
 EXPORT_SYMBOL(seq_hlist_next_percpu);
+
+void __init seq_file_init(void)
+{
+	seq_file_cache = KMEM_CACHE(seq_file, SLAB_PANIC);
+}

commit 48dffbf82d2f17bc6dd3c2b7fd733738ea567914
Author: Andrei Vagin <avagin@openvz.org>
Date:   Tue Apr 10 16:31:23 2018 -0700

    proc: optimize single-symbol delimiters to spead up seq_put_decimal_ull
    
    A delimiter is a string which is printed before a number.  A
    syngle-symbol delimiters can be printed by set_putc() and this works
    faster than printing by set_puts().
    
    == test_proc.c
    
    int main(int argc, char **argv)
    {
            int n, i, fd;
            char buf[16384];
    
            n = atoi(argv[1]);
            for (i = 0; i < n; i++) {
                    fd = open(argv[2], O_RDONLY);
                    if (fd < 0)
                            return 1;
                    if (read(fd, buf, sizeof(buf)) <= 0)
                            return 1;
                    close(fd);
            }
    
            return 0;
    }
    ==
    
    $ time ./test_proc  1000000 /proc/1/stat
    
    == Before patch ==
      real  0m3.820s
      user  0m0.337s
      sys   0m3.394s
    
    == After patch ==
      real  0m3.110s
      user  0m0.324s
      sys   0m2.700s
    
    Link: http://lkml.kernel.org/r/20180212074931.7227-3-avagin@openvz.org
    Signed-off-by: Andrei Vagin <avagin@openvz.org>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 84650ad3b1bf..0677e89f3c6f 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -693,12 +693,12 @@ void seq_put_decimal_ull_width(struct seq_file *m, const char *delimiter,
 	if (m->count + 2 >= m->size) /* we'll write 2 bytes at least */
 		goto overflow;
 
-	len = strlen(delimiter);
-	if (m->count + len >= m->size)
-		goto overflow;
-
-	memcpy(m->buf + m->count, delimiter, len);
-	m->count += len;
+	if (delimiter && delimiter[0]) {
+		if (delimiter[1] == 0)
+			seq_putc(m, delimiter[0]);
+		else
+			seq_puts(m, delimiter);
+	}
 
 	if (!width)
 		width = 1;
@@ -782,12 +782,12 @@ void seq_put_decimal_ll(struct seq_file *m, const char *delimiter, long long num
 	if (m->count + 3 >= m->size) /* we'll write 2 bytes at least */
 		goto overflow;
 
-	len = strlen(delimiter);
-	if (m->count + len >= m->size)
-		goto overflow;
-
-	memcpy(m->buf + m->count, delimiter, len);
-	m->count += len;
+	if (delimiter && delimiter[0]) {
+		if (delimiter[1] == 0)
+			seq_putc(m, delimiter[0]);
+		else
+			seq_puts(m, delimiter);
+	}
 
 	if (m->count + 2 >= m->size)
 		goto overflow;

commit d1be35cb6f96975d792a1535d3fe9b75239065ee
Author: Andrei Vagin <avagin@openvz.org>
Date:   Tue Apr 10 16:31:16 2018 -0700

    proc: add seq_put_decimal_ull_width to speed up /proc/pid/smaps
    
    seq_put_decimal_ull_w(m, str, val, width) prints a decimal number with a
    specified minimal field width.
    
    It is equivalent of seq_printf(m, "%s%*d", str, width, val), but it
    works much faster.
    
    == test_smaps.py
      num = 0
      with open("/proc/1/smaps") as f:
              for x in xrange(10000):
                      data = f.read()
                      f.seek(0, 0)
    ==
    
    == Before patch ==
      $ time python test_smaps.py
      real    0m4.593s
      user    0m0.398s
      sys     0m4.158s
    
    == After patch ==
      $ time python test_smaps.py
      real    0m3.828s
      user    0m0.413s
      sys     0m3.408s
    
    $ perf -g record python test_smaps.py
    == Before patch ==
    -   79.01%     3.36%  python   [kernel.kallsyms]    [k] show_smap.isra.33
       - 75.65% show_smap.isra.33
          + 48.85% seq_printf
          + 15.75% __walk_page_range
          + 9.70% show_map_vma.isra.23
            0.61% seq_puts
    
    == After patch ==
    -   75.51%     4.62%  python   [kernel.kallsyms]    [k] show_smap.isra.33
       - 70.88% show_smap.isra.33
          + 24.82% seq_put_decimal_ull_w
          + 19.78% __walk_page_range
          + 12.74% seq_printf
          + 11.08% show_map_vma.isra.23
          + 1.68% seq_puts
    
    [akpm@linux-foundation.org: fix drivers/of/unittest.c build]
    Link: http://lkml.kernel.org/r/20180212074931.7227-1-avagin@openvz.org
    Signed-off-by: Andrei Vagin <avagin@openvz.org>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 3714ae1d5e1c..84650ad3b1bf 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -673,15 +673,20 @@ void seq_puts(struct seq_file *m, const char *s)
 }
 EXPORT_SYMBOL(seq_puts);
 
-/*
+/**
  * A helper routine for putting decimal numbers without rich format of printf().
  * only 'unsigned long long' is supported.
- * This routine will put strlen(delimiter) + number into seq_file.
+ * @m: seq_file identifying the buffer to which data should be written
+ * @delimiter: a string which is printed before the number
+ * @num: the number
+ * @width: a minimum field width
+ *
+ * This routine will put strlen(delimiter) + number into seq_filed.
  * This routine is very quick when you show lots of numbers.
  * In usual cases, it will be better to use seq_printf(). It's easier to read.
  */
-void seq_put_decimal_ull(struct seq_file *m, const char *delimiter,
-			 unsigned long long num)
+void seq_put_decimal_ull_width(struct seq_file *m, const char *delimiter,
+			 unsigned long long num, unsigned int width)
 {
 	int len;
 
@@ -695,7 +700,10 @@ void seq_put_decimal_ull(struct seq_file *m, const char *delimiter,
 	memcpy(m->buf + m->count, delimiter, len);
 	m->count += len;
 
-	if (m->count + 1 >= m->size)
+	if (!width)
+		width = 1;
+
+	if (m->count + width >= m->size)
 		goto overflow;
 
 	if (num < 10) {
@@ -703,7 +711,7 @@ void seq_put_decimal_ull(struct seq_file *m, const char *delimiter,
 		return;
 	}
 
-	len = num_to_str(m->buf + m->count, m->size - m->count, num);
+	len = num_to_str(m->buf + m->count, m->size - m->count, num, width);
 	if (!len)
 		goto overflow;
 
@@ -713,6 +721,12 @@ void seq_put_decimal_ull(struct seq_file *m, const char *delimiter,
 overflow:
 	seq_set_overflow(m);
 }
+
+void seq_put_decimal_ull(struct seq_file *m, const char *delimiter,
+			 unsigned long long num)
+{
+	return seq_put_decimal_ull_width(m, delimiter, num, 0);
+}
 EXPORT_SYMBOL(seq_put_decimal_ull);
 
 /**
@@ -788,7 +802,7 @@ void seq_put_decimal_ll(struct seq_file *m, const char *delimiter, long long num
 		return;
 	}
 
-	len = num_to_str(m->buf + m->count, m->size - m->count, num);
+	len = num_to_str(m->buf + m->count, m->size - m->count, num, 0);
 	if (!len)
 		goto overflow;
 

commit 8cfa67b4d9a9d9a6061f3cfd0e0ed16e66e45984
Author: Andrei Vagin <avagin@openvz.org>
Date:   Tue Apr 10 16:30:47 2018 -0700

    procfs: optimize seq_pad() to speed up /proc/pid/maps
    
    seq_printf() is slow and it can be replaced by memset() in this case.
    
    == test.py
      num = 0
      with open("/proc/1/maps") as f:
              while num < 10000 :
                      data = f.read()
                      f.seek(0, 0)
                      num = num + 1
    ==
    
    == Before patch ==
      $  time python test.py
      real  0m0.986s
      user  0m0.279s
      sys   0m0.707s
    
    == After patch ==
      $ time python test.py
      real  0m0.932s
      user  0m0.261s
      sys   0m0.669s
    
    $ perf record -g python test.py
    == Before patch ==
    -   47.35%     3.38%  python   [kernel.kallsyms] [k] show_map_vma.isra.23
       - 43.97% show_map_vma.isra.23
          + 20.84% seq_path
          - 15.73% show_vma_header_prefix
          + 6.96% seq_pad
       + 2.94% __GI___libc_read
    
    == After patch ==
    -   44.01%     0.34%  python   [kernel.kallsyms] [k] show_pid_map
       - 43.67% show_pid_map
          - 42.91% show_map_vma.isra.23
             + 21.55% seq_path
             - 15.68% show_vma_header_prefix
             + 2.08% seq_pad
            0.55% seq_putc
    
    Link: http://lkml.kernel.org/r/20180112185812.7710-2-avagin@openvz.org
    Signed-off-by: Andrei Vagin <avagin@openvz.org>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index cde1bdbf7801..3714ae1d5e1c 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -828,8 +828,14 @@ EXPORT_SYMBOL(seq_write);
 void seq_pad(struct seq_file *m, char c)
 {
 	int size = m->pad_until - m->count;
-	if (size > 0)
-		seq_printf(m, "%*s", size, "");
+	if (size > 0) {
+		if (size + m->count > m->size) {
+			seq_set_overflow(m);
+			return;
+		}
+		memset(m->buf + m->count, ' ', size);
+		m->count += size;
+	}
 	if (c)
 		seq_putc(m, c);
 }

commit 0e3dc019143104a6e676287b1e453cccd7add404
Author: Andrei Vagin <avagin@openvz.org>
Date:   Tue Apr 10 16:30:44 2018 -0700

    procfs: add seq_put_hex_ll to speed up /proc/pid/maps
    
    seq_put_hex_ll() prints a number in hexadecimal notation and works
    faster than seq_printf().
    
    == test.py
      num = 0
      with open("/proc/1/maps") as f:
              while num < 10000 :
                      data = f.read()
                      f.seek(0, 0)
                     num = num + 1
    ==
    
    == Before patch ==
      $  time python test.py
    
      real  0m1.561s
      user  0m0.257s
      sys   0m1.302s
    
    == After patch ==
      $ time python test.py
    
      real  0m0.986s
      user  0m0.279s
      sys   0m0.707s
    
    $ perf -g record python test.py:
    
    == Before patch ==
    -   67.42%     2.82%  python   [kernel.kallsyms] [k] show_map_vma.isra.22
       - 64.60% show_map_vma.isra.22
          - 44.98% seq_printf
             - seq_vprintf
                - vsnprintf
                   + 14.85% number
                   + 12.22% format_decode
                     5.56% memcpy_erms
          + 15.06% seq_path
          + 4.42% seq_pad
       + 2.45% __GI___libc_read
    
    == After patch ==
    -   47.35%     3.38%  python   [kernel.kallsyms] [k] show_map_vma.isra.23
       - 43.97% show_map_vma.isra.23
          + 20.84% seq_path
          - 15.73% show_vma_header_prefix
               10.55% seq_put_hex_ll
             + 2.65% seq_put_decimal_ull
               0.95% seq_putc
          + 6.96% seq_pad
       + 2.94% __GI___libc_read
    
    [avagin@openvz.org: use unsigned int instead of int where it is suitable]
      Link: http://lkml.kernel.org/r/20180214025619.4005-1-avagin@openvz.org
    [avagin@openvz.org: v2]
      Link: http://lkml.kernel.org/r/20180117082050.25406-1-avagin@openvz.org
    Link: http://lkml.kernel.org/r/20180112185812.7710-1-avagin@openvz.org
    Signed-off-by: Andrei Vagin <avagin@openvz.org>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index eea09f6d8830..cde1bdbf7801 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -715,6 +715,52 @@ void seq_put_decimal_ull(struct seq_file *m, const char *delimiter,
 }
 EXPORT_SYMBOL(seq_put_decimal_ull);
 
+/**
+ * seq_put_hex_ll - put a number in hexadecimal notation
+ * @m: seq_file identifying the buffer to which data should be written
+ * @delimiter: a string which is printed before the number
+ * @v: the number
+ * @width: a minimum field width
+ *
+ * seq_put_hex_ll(m, "", v, 8) is equal to seq_printf(m, "%08llx", v)
+ *
+ * This routine is very quick when you show lots of numbers.
+ * In usual cases, it will be better to use seq_printf(). It's easier to read.
+ */
+void seq_put_hex_ll(struct seq_file *m, const char *delimiter,
+				unsigned long long v, unsigned int width)
+{
+	unsigned int len;
+	int i;
+
+	if (delimiter && delimiter[0]) {
+		if (delimiter[1] == 0)
+			seq_putc(m, delimiter[0]);
+		else
+			seq_puts(m, delimiter);
+	}
+
+	/* If x is 0, the result of __builtin_clzll is undefined */
+	if (v == 0)
+		len = 1;
+	else
+		len = (sizeof(v) * 8 - __builtin_clzll(v) + 3) / 4;
+
+	if (len < width)
+		len = width;
+
+	if (m->count + len > m->size) {
+		seq_set_overflow(m);
+		return;
+	}
+
+	for (i = len - 1; i >= 0; i--) {
+		m->buf[m->count + i] = hex_asc[0xf & v];
+		v = v >> 4;
+	}
+	m->count += len;
+}
+
 void seq_put_decimal_ll(struct seq_file *m, const char *delimiter, long long num)
 {
 	int len;

commit cf5eebae2cd28d37581507668605f4d23cd7218d
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Nov 15 11:34:58 2017 +0100

    seq_file: fix incomplete reset on read from zero offset
    
    When resetting iterator on a zero offset we need to discard any data
    already in the buffer (count), and private state of the iterator (version).
    
    For example this bug results in first line being repeated in /proc/mounts
    if doing a zero size read before a non-zero size read.
    
    Reported-by: Rich Felker <dalias@libc.org>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Fixes: e522751d605d ("seq_file: reset iterator to first record for zero offset")
    Cc: <stable@vger.kernel.org> # v4.10
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 4be761c1a03d..eea09f6d8830 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -181,8 +181,11 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 	 * if request is to read from zero offset, reset iterator to first
 	 * record as it might have been already advanced by previous requests
 	 */
-	if (*ppos == 0)
+	if (*ppos == 0) {
 		m->index = 0;
+		m->version = 0;
+		m->count = 0;
+	}
 
 	/* Don't assume *ppos is where we left it */
 	if (unlikely(*ppos != m->read_pos)) {

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index dc7c2be963ed..4be761c1a03d 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * linux/fs/seq_file.c
  *

commit a7c3e901a46ff54c016d040847eda598a9e3e653
Author: Michal Hocko <mhocko@suse.com>
Date:   Mon May 8 15:57:09 2017 -0700

    mm: introduce kv[mz]alloc helpers
    
    Patch series "kvmalloc", v5.
    
    There are many open coded kmalloc with vmalloc fallback instances in the
    tree.  Most of them are not careful enough or simply do not care about
    the underlying semantic of the kmalloc/page allocator which means that
    a) some vmalloc fallbacks are basically unreachable because the kmalloc
    part will keep retrying until it succeeds b) the page allocator can
    invoke a really disruptive steps like the OOM killer to move forward
    which doesn't sound appropriate when we consider that the vmalloc
    fallback is available.
    
    As it can be seen implementing kvmalloc requires quite an intimate
    knowledge if the page allocator and the memory reclaim internals which
    strongly suggests that a helper should be implemented in the memory
    subsystem proper.
    
    Most callers, I could find, have been converted to use the helper
    instead.  This is patch 6.  There are some more relying on __GFP_REPEAT
    in the networking stack which I have converted as well and Eric Dumazet
    was not opposed [2] to convert them as well.
    
    [1] http://lkml.kernel.org/r/20170130094940.13546-1-mhocko@kernel.org
    [2] http://lkml.kernel.org/r/1485273626.16328.301.camel@edumazet-glaptop3.roam.corp.google.com
    
    This patch (of 9):
    
    Using kmalloc with the vmalloc fallback for larger allocations is a
    common pattern in the kernel code.  Yet we do not have any common helper
    for that and so users have invented their own helpers.  Some of them are
    really creative when doing so.  Let's just add kv[mz]alloc and make sure
    it is implemented properly.  This implementation makes sure to not make
    a large memory pressure for > PAGE_SZE requests (__GFP_NORETRY) and also
    to not warn about allocation failures.  This also rules out the OOM
    killer as the vmalloc is a more approapriate fallback than a disruptive
    user visible action.
    
    This patch also changes some existing users and removes helpers which
    are specific for them.  In some cases this is not possible (e.g.
    ext4_kvmalloc, libcfs_kvzalloc) because those seems to be broken and
    require GFP_NO{FS,IO} context which is not vmalloc compatible in general
    (note that the page table allocation is GFP_KERNEL).  Those need to be
    fixed separately.
    
    While we are at it, document that __vmalloc{_node} about unsupported gfp
    mask because there seems to be a lot of confusion out there.
    kvmalloc_node will warn about GFP_KERNEL incompatible (which are not
    superset) flags to catch new abusers.  Existing ones would have to die
    slowly.
    
    [sfr@canb.auug.org.au: f2fs fixup]
      Link: http://lkml.kernel.org/r/20170320163735.332e64b7@canb.auug.org.au
    Link: http://lkml.kernel.org/r/20170306103032.2540-2-mhocko@kernel.org
    Signed-off-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Reviewed-by: Andreas Dilger <adilger@dilger.ca> [ext4 part]
    Acked-by: Vlastimil Babka <vbabka@suse.cz>
    Cc: John Hubbard <jhubbard@nvidia.com>
    Cc: David Miller <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index ca69fb99e41a..dc7c2be963ed 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -25,21 +25,7 @@ static void seq_set_overflow(struct seq_file *m)
 
 static void *seq_buf_alloc(unsigned long size)
 {
-	void *buf;
-	gfp_t gfp = GFP_KERNEL;
-
-	/*
-	 * For high order allocations, use __GFP_NORETRY to avoid oom-killing -
-	 * it's better to fall back to vmalloc() than to kill things.  For small
-	 * allocations, just use GFP_KERNEL which will oom kill, thus no need
-	 * for vmalloc fallback.
-	 */
-	if (size > PAGE_SIZE)
-		gfp |= __GFP_NORETRY | __GFP_NOWARN;
-	buf = kmalloc(size, gfp);
-	if (!buf && size > PAGE_SIZE)
-		buf = vmalloc(size);
-	return buf;
+	return kvmalloc(size, GFP_KERNEL);
 }
 
 /**

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index a11f271800ef..ca69fb99e41a 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -15,7 +15,7 @@
 #include <linux/printk.h>
 #include <linux/string_helpers.h>
 
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/page.h>
 
 static void seq_set_overflow(struct seq_file *m)

commit e522751d605d99a81508e58390a8f51ee96fb662
Author: Tomasz Majchrzak <tomasz.majchrzak@intel.com>
Date:   Tue Nov 29 15:18:20 2016 +0100

    seq_file: reset iterator to first record for zero offset
    
    If kernfs file is empty on a first read, successive read operations
    using the same file descriptor will return no data, even when data is
    available. Default kernfs 'seq_next' implementation advances iterator
    position even when next object is not there. Kernfs 'seq_start' for
    following requests will not return iterator as position is already on
    the second object.
    
    This defect doesn't allow to monitor badblocks sysfs files from MD raid.
    They are initially empty but if data appears at some stage, userspace is
    not able to read it.
    
    Signed-off-by: Tomasz Majchrzak <tomasz.majchrzak@intel.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 368bfb92b115..a11f271800ef 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -190,6 +190,13 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 	 */
 	m->version = file->f_version;
 
+	/*
+	 * if request is to read from zero offset, reset iterator to first
+	 * record as it might have been already advanced by previous requests
+	 */
+	if (*ppos == 0)
+		m->index = 0;
+
 	/* Don't assume *ppos is where we left it */
 	if (unlikely(*ppos != m->read_pos)) {
 		while ((err = traverse(m, *ppos)) == -EAGAIN)

commit 75ba1d07fd6a494851db5132612944a9d4773f9c
Author: Joe Perches <joe@perches.com>
Date:   Fri Oct 7 17:02:20 2016 -0700

    seq/proc: modify seq_put_decimal_[u]ll to take a const char *, not char
    
    Allow some seq_puts removals by taking a string instead of a single
    char.
    
    [akpm@linux-foundation.org: update vmstat_show(), per Joe]
    Link: http://lkml.kernel.org/r/667e1cf3d436de91a5698170a1e98d882905e956.1470704995.git.joe@perches.com
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 6dc4296eed62..368bfb92b115 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -679,11 +679,11 @@ EXPORT_SYMBOL(seq_puts);
 /*
  * A helper routine for putting decimal numbers without rich format of printf().
  * only 'unsigned long long' is supported.
- * This routine will put one byte delimiter + number into seq_file.
+ * This routine will put strlen(delimiter) + number into seq_file.
  * This routine is very quick when you show lots of numbers.
  * In usual cases, it will be better to use seq_printf(). It's easier to read.
  */
-void seq_put_decimal_ull(struct seq_file *m, char delimiter,
+void seq_put_decimal_ull(struct seq_file *m, const char *delimiter,
 			 unsigned long long num)
 {
 	int len;
@@ -691,8 +691,15 @@ void seq_put_decimal_ull(struct seq_file *m, char delimiter,
 	if (m->count + 2 >= m->size) /* we'll write 2 bytes at least */
 		goto overflow;
 
-	if (delimiter)
-		m->buf[m->count++] = delimiter;
+	len = strlen(delimiter);
+	if (m->count + len >= m->size)
+		goto overflow;
+
+	memcpy(m->buf + m->count, delimiter, len);
+	m->count += len;
+
+	if (m->count + 1 >= m->size)
+		goto overflow;
 
 	if (num < 10) {
 		m->buf[m->count++] = num + '0';
@@ -702,6 +709,7 @@ void seq_put_decimal_ull(struct seq_file *m, char delimiter,
 	len = num_to_str(m->buf + m->count, m->size - m->count, num);
 	if (!len)
 		goto overflow;
+
 	m->count += len;
 	return;
 
@@ -710,19 +718,42 @@ void seq_put_decimal_ull(struct seq_file *m, char delimiter,
 }
 EXPORT_SYMBOL(seq_put_decimal_ull);
 
-void seq_put_decimal_ll(struct seq_file *m, char delimiter, long long num)
+void seq_put_decimal_ll(struct seq_file *m, const char *delimiter, long long num)
 {
+	int len;
+
+	if (m->count + 3 >= m->size) /* we'll write 2 bytes at least */
+		goto overflow;
+
+	len = strlen(delimiter);
+	if (m->count + len >= m->size)
+		goto overflow;
+
+	memcpy(m->buf + m->count, delimiter, len);
+	m->count += len;
+
+	if (m->count + 2 >= m->size)
+		goto overflow;
+
 	if (num < 0) {
-		if (m->count + 3 >= m->size) {
-			seq_set_overflow(m);
-			return;
-		}
-		if (delimiter)
-			m->buf[m->count++] = delimiter;
+		m->buf[m->count++] = '-';
 		num = -num;
-		delimiter = '-';
 	}
-	seq_put_decimal_ull(m, delimiter, num);
+
+	if (num < 10) {
+		m->buf[m->count++] = num + '0';
+		return;
+	}
+
+	len = num_to_str(m->buf + m->count, m->size - m->count, num);
+	if (!len)
+		goto overflow;
+
+	m->count += len;
+	return;
+
+overflow:
+	seq_set_overflow(m);
 }
 EXPORT_SYMBOL(seq_put_decimal_ll);
 

commit 088bf2ff5d12e2e32ee52a4024fec26e582f44d3
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Thu Aug 25 15:17:11 2016 -0700

    fs/seq_file: fix out-of-bounds read
    
    seq_read() is a nasty piece of work, not to mention buggy.
    
    It has (I think) an old bug which allows unprivileged userspace to read
    beyond the end of m->buf.
    
    I was getting these:
    
        BUG: KASAN: slab-out-of-bounds in seq_read+0xcd2/0x1480 at addr ffff880116889880
        Read of size 2713 by task trinity-c2/1329
        CPU: 2 PID: 1329 Comm: trinity-c2 Not tainted 4.8.0-rc1+ #96
        Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.9.3-0-ge2fc41e-prebuilt.qemu-project.org 04/01/2014
        Call Trace:
          kasan_object_err+0x1c/0x80
          kasan_report_error+0x2cb/0x7e0
          kasan_report+0x4e/0x80
          check_memory_region+0x13e/0x1a0
          kasan_check_read+0x11/0x20
          seq_read+0xcd2/0x1480
          proc_reg_read+0x10b/0x260
          do_loop_readv_writev.part.5+0x140/0x2c0
          do_readv_writev+0x589/0x860
          vfs_readv+0x7b/0xd0
          do_readv+0xd8/0x2c0
          SyS_readv+0xb/0x10
          do_syscall_64+0x1b3/0x4b0
          entry_SYSCALL64_slow_path+0x25/0x25
        Object at ffff880116889100, in cache kmalloc-4096 size: 4096
        Allocated:
        PID = 1329
          save_stack_trace+0x26/0x80
          save_stack+0x46/0xd0
          kasan_kmalloc+0xad/0xe0
          __kmalloc+0x1aa/0x4a0
          seq_buf_alloc+0x35/0x40
          seq_read+0x7d8/0x1480
          proc_reg_read+0x10b/0x260
          do_loop_readv_writev.part.5+0x140/0x2c0
          do_readv_writev+0x589/0x860
          vfs_readv+0x7b/0xd0
          do_readv+0xd8/0x2c0
          SyS_readv+0xb/0x10
          do_syscall_64+0x1b3/0x4b0
          return_from_SYSCALL_64+0x0/0x6a
        Freed:
        PID = 0
        (stack is not available)
        Memory state around the buggy address:
         ffff88011688a000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
         ffff88011688a080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
        >ffff88011688a100: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
                           ^
         ffff88011688a180: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
         ffff88011688a200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
        ==================================================================
        Disabling lock debugging due to kernel taint
    
    This seems to be the same thing that Dave Jones was seeing here:
    
      https://lkml.org/lkml/2016/8/12/334
    
    There are multiple issues here:
    
      1) If we enter the function with a non-empty buffer, there is an attempt
         to flush it. But it was not clearing m->from after doing so, which
         means that if we try to do this flush twice in a row without any call
         to traverse() in between, we are going to be reading from the wrong
         place -- the splat above, fixed by this patch.
    
      2) If there's a short write to userspace because of page faults, the
         buffer may already contain multiple lines (i.e. pos has advanced by
         more than 1), but we don't save the progress that was made so the
         next call will output what we've already returned previously. Since
         that is a much less serious issue (and I have a headache after
         staring at seq_read() for the past 8 hours), I'll leave that for now.
    
    Link: http://lkml.kernel.org/r/1471447270-32093-1-git-send-email-vegard.nossum@oracle.com
    Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
    Reported-by: Dave Jones <davej@codemonkey.org.uk>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 19f532e7d35e..6dc4296eed62 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -223,8 +223,10 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 		size -= n;
 		buf += n;
 		copied += n;
-		if (!m->count)
+		if (!m->count) {
+			m->from = 0;
 			m->index++;
+		}
 		if (!size)
 			goto Done;
 	}

commit 34dbbcdbf63360661ff7bda6c5f52f99ac515f92
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 14 11:22:00 2016 -0700

    Make file credentials available to the seqfile interfaces
    
    A lot of seqfile users seem to be using things like %pK that uses the
    credentials of the current process, but that is actually completely
    wrong for filesystem interfaces.
    
    The unix semantics for permission checking files is to check permissions
    at _open_ time, not at read or write time, and that is not just a small
    detail: passing off stdin/stdout/stderr to a suid application and making
    the actual IO happen in privileged context is a classic exploit
    technique.
    
    So if we want to be able to look at permissions at read time, we need to
    use the file open credentials, not the current ones.  Normal file
    accesses can just use "f_cred" (or any of the helper functions that do
    that, like file_ns_capable()), but the seqfile interfaces do not have
    any such options.
    
    It turns out that seq_file _does_ save away the user_ns information of
    the file, though.  Since user_ns is just part of the full credential
    information, replace that special case with saving off the cred pointer
    instead, and suddenly seq_file has all the permission information it
    needs.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index e85664b7c7d9..19f532e7d35e 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -72,9 +72,10 @@ int seq_open(struct file *file, const struct seq_operations *op)
 
 	mutex_init(&p->lock);
 	p->op = op;
-#ifdef CONFIG_USER_NS
-	p->user_ns = file->f_cred->user_ns;
-#endif
+
+	// No refcounting: the lifetime of 'p' is constrained
+	// to the lifetime of the file.
+	p->file = file;
 
 	/*
 	 * Wrappers around seq_open(e.g. swaps_open) need to be

commit 0f930902eb8806cff8dcaef9ff9faf3cfa5fd748
Author: Greg Thelen <gthelen@google.com>
Date:   Fri Nov 6 16:32:42 2015 -0800

    fs, seqfile: always allow oom killer
    
    Since 5cec38ac866b ("fs, seq_file: fallback to vmalloc instead of oom kill
    processes") seq_buf_alloc() avoids calling the oom killer for PAGE_SIZE or
    smaller allocations; but larger allocations can use the oom killer via
    vmalloc().  Thus reads of small files can return ENOMEM, but larger files
    use the oom killer to avoid ENOMEM.
    
    The effect of this bug is that reads from /proc and other virtual
    filesystems can return ENOMEM instead of the preferred behavior - oom
    killing something (possibly the calling process).  I don't know of anyone
    except Google who has noticed the issue.
    
    I suspect the fix is more needed in smaller systems where there isn't any
    reclaimable memory.  But these seem like the kinds of systems which
    probably don't use the oom killer for production situations.
    
    Memory overcommit requires use of the oom killer to select a victim
    regardless of file size.
    
    Enable oom killer for small seq_buf_alloc() allocations.
    
    Fixes: 5cec38ac866b ("fs, seq_file: fallback to vmalloc instead of oom kill processes")
    Signed-off-by: David Rientjes <rientjes@google.com>
    Signed-off-by: Greg Thelen <gthelen@google.com>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 00bbe2bfc634..e85664b7c7d9 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -26,12 +26,17 @@ static void seq_set_overflow(struct seq_file *m)
 static void *seq_buf_alloc(unsigned long size)
 {
 	void *buf;
+	gfp_t gfp = GFP_KERNEL;
 
 	/*
-	 * __GFP_NORETRY to avoid oom-killings with high-order allocations -
-	 * it's better to fall back to vmalloc() than to kill things.
+	 * For high order allocations, use __GFP_NORETRY to avoid oom-killing -
+	 * it's better to fall back to vmalloc() than to kill things.  For small
+	 * allocations, just use GFP_KERNEL which will oom kill, thus no need
+	 * for vmalloc fallback.
 	 */
-	buf = kmalloc(size, GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);
+	if (size > PAGE_SIZE)
+		gfp |= __GFP_NORETRY | __GFP_NOWARN;
+	buf = kmalloc(size, gfp);
 	if (!buf && size > PAGE_SIZE)
 		buf = vmalloc(size);
 	return buf;

commit 25c6bb76eafe37c8963ae58a6a1bcf4069caeedb
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Nov 6 16:32:40 2015 -0800

    seq_file: reuse string_escape_str()
    
    strint_escape_str() escapes input string by given criteria.  In case of
    seq_escape() the criteria is to convert some characters to their octal
    representation.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index ad034fb49f30..00bbe2bfc634 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -13,6 +13,7 @@
 #include <linux/cred.h>
 #include <linux/mm.h>
 #include <linux/printk.h>
+#include <linux/string_helpers.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -377,26 +378,12 @@ EXPORT_SYMBOL(seq_release);
  */
 void seq_escape(struct seq_file *m, const char *s, const char *esc)
 {
-	char *end = m->buf + m->size;
-	char *p;
-	char c;
+	char *buf;
+	size_t size = seq_get_buf(m, &buf);
+	int ret;
 
-	for (p = m->buf + m->count; (c = *s) != '\0' && p < end; s++) {
-		if (!strchr(esc, c)) {
-			*p++ = c;
-			continue;
-		}
-		if (p + 3 < end) {
-			*p++ = '\\';
-			*p++ = '0' + ((c & 0300) >> 6);
-			*p++ = '0' + ((c & 070) >> 3);
-			*p++ = '0' + (c & 07);
-			continue;
-		}
-		seq_set_overflow(m);
-		return;
-	}
-	m->count = p - m->buf;
+	ret = string_escape_str(s, buf, size, ESCAPE_OCTAL, esc);
+	seq_commit(m, ret < size ? ret : -1);
 }
 EXPORT_SYMBOL(seq_escape);
 

commit 8b91a318e422a0201a7bd7ac2626eecec6b27ae1
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Nov 6 16:32:37 2015 -0800

    fs/seq_file: use seq_* helpers in seq_hex_dump()
    
    This improves code readability.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 225586e141ca..ad034fb49f30 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -773,6 +773,8 @@ void seq_hex_dump(struct seq_file *m, const char *prefix_str, int prefix_type,
 {
 	const u8 *ptr = buf;
 	int i, linelen, remaining = len;
+	char *buffer;
+	size_t size;
 	int ret;
 
 	if (rowsize != 16 && rowsize != 32)
@@ -794,15 +796,12 @@ void seq_hex_dump(struct seq_file *m, const char *prefix_str, int prefix_type,
 			break;
 		}
 
+		size = seq_get_buf(m, &buffer);
 		ret = hex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,
-					 m->buf + m->count, m->size - m->count,
-					 ascii);
-		if (ret >= m->size - m->count) {
-			seq_set_overflow(m);
-		} else {
-			m->count += ret;
-			seq_putc(m, '\n');
-		}
+					 buffer, size, ascii);
+		seq_commit(m, ret < size ? ret : -1);
+
+		seq_putc(m, '\n');
 	}
 }
 EXPORT_SYMBOL(seq_hex_dump);

commit 6798a8caaf64fa68b9ab2044e070fe4545034e03
Author: Joe Perches <joe@perches.com>
Date:   Fri Sep 11 13:07:48 2015 -0700

    fs/seq_file: convert int seq_vprint/seq_printf/etc... returns to void
    
    The seq_<foo> function return values were frequently misused.
    
    See: commit 1f33c41c03da ("seq_file: Rename seq_overflow() to
         seq_has_overflowed() and make public")
    
    All uses of these return values have been removed, so convert the
    return types to void.
    
    Miscellanea:
    
    o Move seq_put_decimal_<type> and seq_escape prototypes closer the
      other seq_vprintf prototypes
    o Reorder seq_putc and seq_puts to return early on overflow
    o Add argument names to seq_vprintf and seq_printf
    o Update the seq_escape kernel-doc
    o Convert a couple of leading spaces to tabs in seq_escape
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Joerg Roedel <jroedel@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 263b125dbcf4..225586e141ca 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -372,16 +372,16 @@ EXPORT_SYMBOL(seq_release);
  *	@esc:	set of characters that need escaping
  *
  *	Puts string into buffer, replacing each occurrence of character from
- *	@esc with usual octal escape.  Returns 0 in case of success, -1 - in
- *	case of overflow.
+ *	@esc with usual octal escape.
+ *	Use seq_has_overflowed() to check for errors.
  */
-int seq_escape(struct seq_file *m, const char *s, const char *esc)
+void seq_escape(struct seq_file *m, const char *s, const char *esc)
 {
 	char *end = m->buf + m->size;
-        char *p;
+	char *p;
 	char c;
 
-        for (p = m->buf + m->count; (c = *s) != '\0' && p < end; s++) {
+	for (p = m->buf + m->count; (c = *s) != '\0' && p < end; s++) {
 		if (!strchr(esc, c)) {
 			*p++ = c;
 			continue;
@@ -394,14 +394,13 @@ int seq_escape(struct seq_file *m, const char *s, const char *esc)
 			continue;
 		}
 		seq_set_overflow(m);
-		return -1;
-        }
+		return;
+	}
 	m->count = p - m->buf;
-        return 0;
 }
 EXPORT_SYMBOL(seq_escape);
 
-int seq_vprintf(struct seq_file *m, const char *f, va_list args)
+void seq_vprintf(struct seq_file *m, const char *f, va_list args)
 {
 	int len;
 
@@ -409,24 +408,20 @@ int seq_vprintf(struct seq_file *m, const char *f, va_list args)
 		len = vsnprintf(m->buf + m->count, m->size - m->count, f, args);
 		if (m->count + len < m->size) {
 			m->count += len;
-			return 0;
+			return;
 		}
 	}
 	seq_set_overflow(m);
-	return -1;
 }
 EXPORT_SYMBOL(seq_vprintf);
 
-int seq_printf(struct seq_file *m, const char *f, ...)
+void seq_printf(struct seq_file *m, const char *f, ...)
 {
-	int ret;
 	va_list args;
 
 	va_start(args, f);
-	ret = seq_vprintf(m, f, args);
+	seq_vprintf(m, f, args);
 	va_end(args);
-
-	return ret;
 }
 EXPORT_SYMBOL(seq_printf);
 
@@ -664,26 +659,25 @@ int seq_open_private(struct file *filp, const struct seq_operations *ops,
 }
 EXPORT_SYMBOL(seq_open_private);
 
-int seq_putc(struct seq_file *m, char c)
+void seq_putc(struct seq_file *m, char c)
 {
-	if (m->count < m->size) {
-		m->buf[m->count++] = c;
-		return 0;
-	}
-	return -1;
+	if (m->count >= m->size)
+		return;
+
+	m->buf[m->count++] = c;
 }
 EXPORT_SYMBOL(seq_putc);
 
-int seq_puts(struct seq_file *m, const char *s)
+void seq_puts(struct seq_file *m, const char *s)
 {
 	int len = strlen(s);
-	if (m->count + len < m->size) {
-		memcpy(m->buf + m->count, s, len);
-		m->count += len;
-		return 0;
+
+	if (m->count + len >= m->size) {
+		seq_set_overflow(m);
+		return;
 	}
-	seq_set_overflow(m);
-	return -1;
+	memcpy(m->buf + m->count, s, len);
+	m->count += len;
 }
 EXPORT_SYMBOL(seq_puts);
 
@@ -694,8 +688,8 @@ EXPORT_SYMBOL(seq_puts);
  * This routine is very quick when you show lots of numbers.
  * In usual cases, it will be better to use seq_printf(). It's easier to read.
  */
-int seq_put_decimal_ull(struct seq_file *m, char delimiter,
-			unsigned long long num)
+void seq_put_decimal_ull(struct seq_file *m, char delimiter,
+			 unsigned long long num)
 {
 	int len;
 
@@ -707,35 +701,33 @@ int seq_put_decimal_ull(struct seq_file *m, char delimiter,
 
 	if (num < 10) {
 		m->buf[m->count++] = num + '0';
-		return 0;
+		return;
 	}
 
 	len = num_to_str(m->buf + m->count, m->size - m->count, num);
 	if (!len)
 		goto overflow;
 	m->count += len;
-	return 0;
+	return;
+
 overflow:
 	seq_set_overflow(m);
-	return -1;
 }
 EXPORT_SYMBOL(seq_put_decimal_ull);
 
-int seq_put_decimal_ll(struct seq_file *m, char delimiter,
-			long long num)
+void seq_put_decimal_ll(struct seq_file *m, char delimiter, long long num)
 {
 	if (num < 0) {
 		if (m->count + 3 >= m->size) {
 			seq_set_overflow(m);
-			return -1;
+			return;
 		}
 		if (delimiter)
 			m->buf[m->count++] = delimiter;
 		num = -num;
 		delimiter = '-';
 	}
-	return seq_put_decimal_ull(m, delimiter, num);
-
+	seq_put_decimal_ull(m, delimiter, num);
 }
 EXPORT_SYMBOL(seq_put_decimal_ll);
 

commit 37607102c4426cf92aeb5da1b1d9a79ba6d95e3f
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Sep 9 15:38:33 2015 -0700

    seq_file: provide an analogue of print_hex_dump()
    
    This introduces a new helper and switches current users to use it.  All
    patches are compiled tested. kmemleak is tested via its own test suite.
    
    This patch (of 6):
    
    The new seq_hex_dump() is a complete analogue of print_hex_dump().
    
    We have few users of this functionality already. It allows to reduce their
    codebase.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Joe Perches <joe@perches.com>
    Cc: Tadeusz Struk <tadeusz.struk@intel.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Tuchscherer <ingo.tuchscherer@de.ibm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Vladimir Kondratiev <qca_vkondrat@qca.qualcomm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index ce9e39fd5daf..263b125dbcf4 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -12,6 +12,7 @@
 #include <linux/slab.h>
 #include <linux/cred.h>
 #include <linux/mm.h>
+#include <linux/printk.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -773,6 +774,47 @@ void seq_pad(struct seq_file *m, char c)
 }
 EXPORT_SYMBOL(seq_pad);
 
+/* A complete analogue of print_hex_dump() */
+void seq_hex_dump(struct seq_file *m, const char *prefix_str, int prefix_type,
+		  int rowsize, int groupsize, const void *buf, size_t len,
+		  bool ascii)
+{
+	const u8 *ptr = buf;
+	int i, linelen, remaining = len;
+	int ret;
+
+	if (rowsize != 16 && rowsize != 32)
+		rowsize = 16;
+
+	for (i = 0; i < len && !seq_has_overflowed(m); i += rowsize) {
+		linelen = min(remaining, rowsize);
+		remaining -= rowsize;
+
+		switch (prefix_type) {
+		case DUMP_PREFIX_ADDRESS:
+			seq_printf(m, "%s%p: ", prefix_str, ptr + i);
+			break;
+		case DUMP_PREFIX_OFFSET:
+			seq_printf(m, "%s%.8x: ", prefix_str, i);
+			break;
+		default:
+			seq_printf(m, "%s", prefix_str);
+			break;
+		}
+
+		ret = hex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,
+					 m->buf + m->count, m->size - m->count,
+					 ascii);
+		if (ret >= m->size - m->count) {
+			seq_set_overflow(m);
+		} else {
+			m->count += ret;
+			seq_putc(m, '\n');
+		}
+	}
+}
+EXPORT_SYMBOL(seq_hex_dump);
+
 struct list_head *seq_list_start(struct list_head *head, loff_t pos)
 {
 	struct list_head *lh;

commit 1dc51b8288007753ad7cd7d08bb8fa930fc8bb10
Merge: 9b284cbdb5de 0f1db7dee200
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 4 19:36:06 2015 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull more vfs updates from Al Viro:
     "Assorted VFS fixes and related cleanups (IMO the most interesting in
      that part are f_path-related things and Eric's descriptor-related
      stuff).  UFS regression fixes (it got broken last cycle).  9P fixes.
      fs-cache series, DAX patches, Jan's file_remove_suid() work"
    
    [ I'd say this is much more than "fixes and related cleanups".  The
      file_table locking rule change by Eric Dumazet is a rather big and
      fundamental update even if the patch isn't huge.   - Linus ]
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (49 commits)
      9p: cope with bogus responses from server in p9_client_{read,write}
      p9_client_write(): avoid double p9_free_req()
      9p: forgetting to cancel request on interrupted zero-copy RPC
      dax: bdev_direct_access() may sleep
      block: Add support for DAX reads/writes to block devices
      dax: Use copy_from_iter_nocache
      dax: Add block size note to documentation
      fs/file.c: __fget() and dup2() atomicity rules
      fs/file.c: don't acquire files->file_lock in fd_install()
      fs:super:get_anon_bdev: fix race condition could cause dev exceed its upper limitation
      vfs: avoid creation of inode number 0 in get_next_ino
      namei: make set_root_rcu() return void
      make simple_positive() public
      ufs: use dir_pages instead of ufs_dir_pages()
      pagemap.h: move dir_pages() over there
      remove the pointless include of lglock.h
      fs: cleanup slight list_entry abuse
      xfs: Correctly lock inode when removing suid and file capabilities
      fs: Call security_ops->inode_killpriv on truncate
      fs: Provide function telling whether file_remove_privs() will do anything
      ...

commit 2d01eedf1d14432f4db5388a49dc5596a8c5bd02
Merge: 6ac15baacb6e abdd4a702528
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 1 17:47:51 2015 -0700

    Merge branch 'akpm' (patches from Andrew)
    
    Merge third patchbomb from Andrew Morton:
    
     - the rest of MM
    
     - scripts/gdb updates
    
     - ipc/ updates
    
     - lib/ updates
    
     - MAINTAINERS updates
    
     - various other misc things
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (67 commits)
      genalloc: rename of_get_named_gen_pool() to of_gen_pool_get()
      genalloc: rename dev_get_gen_pool() to gen_pool_get()
      x86: opt into HAVE_COPY_THREAD_TLS, for both 32-bit and 64-bit
      MAINTAINERS: add zpool
      MAINTAINERS: BCACHE: Kent Overstreet has changed email address
      MAINTAINERS: move Jens Osterkamp to CREDITS
      MAINTAINERS: remove unused nbd.h pattern
      MAINTAINERS: update brcm gpio filename pattern
      MAINTAINERS: update brcm dts pattern
      MAINTAINERS: update sound soc intel patterns
      MAINTAINERS: remove website for paride
      MAINTAINERS: update Emulex ocrdma email addresses
      bcache: use kvfree() in various places
      libcxgbi: use kvfree() in cxgbi_free_big_mem()
      target: use kvfree() in session alloc and free
      IB/ehca: use kvfree() in ipz_queue_{cd}tor()
      drm/nouveau/gem: use kvfree() in u_free()
      drm: use kvfree() in drm_free_large()
      cxgb4: use kvfree() in t4_free_mem()
      cxgb3: use kvfree() in cxgb_free_mem()
      ...

commit 460b865e53c347ebf110e50d499718cd9b39d810
Author: Yann Droneaud <ydroneaud@opteya.com>
Date:   Tue Jun 30 14:57:36 2015 -0700

    fs: document seq_open()'s usage of file->private_data
    
    seq_open() stores its struct seq_file in file->private_data, thus it must
    not be modified by user of seq_file.
    
    Link: http://lkml.kernel.org/r/cover.1433193673.git.ydroneaud@opteya.com
    Signed-off-by: Yann Droneaud <ydroneaud@opteya.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 5f163c6c821c..760e25dad985 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -48,6 +48,8 @@ static void *seq_buf_alloc(unsigned long size)
  *	ERR_PTR(error).  In the end of sequence they return %NULL. ->show()
  *	returns 0 in case of success and negative number in case of error.
  *	Returning SEQ_SKIP means "discard this element and move on".
+ *	Note: seq_open() will allocate a struct seq_file and store its
+ *	pointer in @file->private_data. This pointer should not be modified.
  */
 int seq_open(struct file *file, const struct seq_operations *op)
 {

commit 189f9841de23a58ecb4b2602db8581512ff08ba4
Author: Yann Droneaud <ydroneaud@opteya.com>
Date:   Tue Jun 30 14:57:33 2015 -0700

    fs: allocate structure unconditionally in seq_open()
    
    Since patch described below, from v2.6.15-rc1, seq_open() could use a
    struct seq_file already allocated by the caller if the pointer to the
    structure is stored in file->private_data before calling the function.
    
        Commit 1abe77b0fc4b485927f1f798ae81a752677e1d05
        Author: Al Viro <viro@zeniv.linux.org.uk>
        Date:   Mon Nov 7 17:15:34 2005 -0500
    
            [PATCH] allow callers of seq_open do allocation themselves
    
            Allow caller of seq_open() to kmalloc() seq_file + whatever else they
            want and set ->private_data to it.  seq_open() will then abstain from
            doing allocation itself.
    
    As there's no more use for such feature, as it could be easily replaced by
    calls to seq_open_private() (see commit 39699037a5c9 ("[FS] seq_file:
    Introduce the seq_open_private()")) and seq_release_private() (see
    v2.6.0-test3), support for this uncommon feature can be removed from
    seq_open().
    
    Link: http://lkml.kernel.org/r/cover.1433193673.git.ydroneaud@opteya.com
    Signed-off-by: Yann Droneaud <ydroneaud@opteya.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 555f82155be8..5f163c6c821c 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -51,15 +51,16 @@ static void *seq_buf_alloc(unsigned long size)
  */
 int seq_open(struct file *file, const struct seq_operations *op)
 {
-	struct seq_file *p = file->private_data;
+	struct seq_file *p;
+
+	WARN_ON(file->private_data);
+
+	p = kzalloc(sizeof(*p), GFP_KERNEL);
+	if (!p)
+		return -ENOMEM;
+
+	file->private_data = p;
 
-	if (!p) {
-		p = kmalloc(sizeof(*p), GFP_KERNEL);
-		if (!p)
-			return -ENOMEM;
-		file->private_data = p;
-	}
-	memset(p, 0, sizeof(*p));
 	mutex_init(&p->lock);
 	p->op = op;
 #ifdef CONFIG_USER_NS

commit 2726d56620ce71f40dd583d51391b86e1ab8cc57
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Jun 19 10:30:28 2015 +0200

    vfs: add seq_file_path() helper
    
    Turn
            seq_path(..., &file->f_path, ...);
    into
            seq_file_path(..., file, ...);
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 555f82155be8..d8a0545ad7ea 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -487,6 +487,20 @@ int seq_path(struct seq_file *m, const struct path *path, const char *esc)
 }
 EXPORT_SYMBOL(seq_path);
 
+/**
+ * seq_file_path - seq_file interface to print a pathname of a file
+ * @m: the seq_file handle
+ * @file: the struct file to print
+ * @esc: set of characters to escape in the output
+ *
+ * return the absolute path to the file.
+ */
+int seq_file_path(struct seq_file *m, struct file *file, const char *esc)
+{
+	return seq_path(m, &file->f_path, esc);
+}
+EXPORT_SYMBOL(seq_file_path);
+
 /*
  * Same as seq_path, but relative to supplied root.
  */

commit c8d3fe028f64054d75c72566efb9ecf3c75ee161
Author: Omar Sandoval <osandov@osandov.com>
Date:   Mon May 18 02:16:31 2015 -0700

    Btrfs: show subvol= and subvolid= in /proc/mounts
    
    Now that we're guaranteed to have a meaningful root dentry, we can just
    export seq_dentry() and use it in btrfs_show_options(). The subvolume ID
    is easy to get and can also be useful, so put that in there, too.
    
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 555f82155be8..52b492721603 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -538,6 +538,7 @@ int seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc)
 
 	return res;
 }
+EXPORT_SYMBOL(seq_dentry);
 
 static void *single_start(struct seq_file *p, loff_t *pos)
 {

commit 46385326cc1577587ed3e7432c2425cf6d3e4308
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Feb 13 14:38:15 2015 -0800

    bitmap, cpumask, nodemask: remove dedicated formatting functions
    
    Now that all bitmap formatting usages have been converted to
    '%*pb[l]', the separate formatting functions are unnecessary.  The
    following functions are removed.
    
    * bitmap_scn[list]printf()
    * cpumask_scnprintf(), cpulist_scnprintf()
    * [__]nodemask_scnprintf(), [__]nodelist_scnprintf()
    * seq_bitmap[_list](), seq_cpumask[_list](), seq_nodemask[_list]()
    * seq_buf_bitmask()
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index dbf3a59c86bb..555f82155be8 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -539,38 +539,6 @@ int seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc)
 	return res;
 }
 
-int seq_bitmap(struct seq_file *m, const unsigned long *bits,
-				   unsigned int nr_bits)
-{
-	if (m->count < m->size) {
-		int len = bitmap_scnprintf(m->buf + m->count,
-				m->size - m->count, bits, nr_bits);
-		if (m->count + len < m->size) {
-			m->count += len;
-			return 0;
-		}
-	}
-	seq_set_overflow(m);
-	return -1;
-}
-EXPORT_SYMBOL(seq_bitmap);
-
-int seq_bitmap_list(struct seq_file *m, const unsigned long *bits,
-		unsigned int nr_bits)
-{
-	if (m->count < m->size) {
-		int len = bitmap_scnlistprintf(m->buf + m->count,
-				m->size - m->count, bits, nr_bits);
-		if (m->count + len < m->size) {
-			m->count += len;
-			return 0;
-		}
-	}
-	seq_set_overflow(m);
-	return -1;
-}
-EXPORT_SYMBOL(seq_bitmap_list);
-
 static void *single_start(struct seq_file *p, loff_t *pos)
 {
 	return NULL + (*pos == 0);

commit 5cec38ac866bfb8775638e71a86e4d8cac30caae
Author: David Rientjes <rientjes@google.com>
Date:   Fri Dec 12 16:56:16 2014 -0800

    fs, seq_file: fallback to vmalloc instead of oom kill processes
    
    Since commit 058504edd026 ("fs/seq_file: fallback to vmalloc allocation"),
    seq_buf_alloc() falls back to vmalloc() when the kmalloc() for contiguous
    memory fails.  This was done to address order-4 slab allocations for
    reading /proc/stat on large machines and noticed because
    PAGE_ALLOC_COSTLY_ORDER < 4, so there is no infinite loop in the page
    allocator when allocating new slab for such high-order allocations.
    
    Contiguous memory isn't necessary for caller of seq_buf_alloc(), however.
    Other GFP_KERNEL high-order allocations that are <=
    PAGE_ALLOC_COSTLY_ORDER will simply loop forever in the page allocator and
    oom kill processes as a result.
    
    We don't want to kill processes so that we can allocate contiguous memory
    in situations when contiguous memory isn't necessary.
    
    This patch does the kmalloc() allocation with __GFP_NORETRY for high-order
    allocations.  This still utilizes memory compaction and direct reclaim in
    the allocation path, the only difference is that it will fail immediately
    instead of oom kill processes when out of memory.
    
    [akpm@linux-foundation.org: add comment]
    Signed-off-by: David Rientjes <rientjes@google.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 353948ba1c5b..dbf3a59c86bb 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -25,7 +25,11 @@ static void *seq_buf_alloc(unsigned long size)
 {
 	void *buf;
 
-	buf = kmalloc(size, GFP_KERNEL | __GFP_NOWARN);
+	/*
+	 * __GFP_NORETRY to avoid oom-killings with high-order allocations -
+	 * it's better to fall back to vmalloc() than to kill things.
+	 */
+	buf = kmalloc(size, GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);
 	if (!buf && size > PAGE_SIZE)
 		buf = vmalloc(size);
 	return buf;

commit 1f33c41c03daece85a84b8dcea5733f3efe3e2b0
Author: Joe Perches <joe@perches.com>
Date:   Mon Sep 29 16:08:21 2014 -0700

    seq_file: Rename seq_overflow() to seq_has_overflowed() and make public
    
    The return values of seq_printf/puts/putc are frequently misused.
    
    Start down a path to remove all the return value uses of these
    functions.
    
    Move the seq_overflow() to a global inlined function called
    seq_has_overflowed() that can be used by the users of seq_file() calls.
    
    Update the documentation to not show return types for seq_printf
    et al.  Add a description of seq_has_overflowed().
    
    Link: http://lkml.kernel.org/p/848ac7e3d1c31cddf638a8526fa3c59fa6fdeb8a.1412031505.git.joe@perches.com
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Joe Perches <joe@perches.com>
    [ Reworked the original patch from Joe ]
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 3857b720cb1b..353948ba1c5b 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -16,17 +16,6 @@
 #include <asm/uaccess.h>
 #include <asm/page.h>
 
-
-/*
- * seq_files have a buffer which can may overflow. When this happens a larger
- * buffer is reallocated and all the data will be printed again.
- * The overflow state is true when m->count == m->size.
- */
-static bool seq_overflow(struct seq_file *m)
-{
-	return m->count == m->size;
-}
-
 static void seq_set_overflow(struct seq_file *m)
 {
 	m->count = m->size;
@@ -124,7 +113,7 @@ static int traverse(struct seq_file *m, loff_t offset)
 			error = 0;
 			m->count = 0;
 		}
-		if (seq_overflow(m))
+		if (seq_has_overflowed(m))
 			goto Eoverflow;
 		if (pos + m->count > offset) {
 			m->from = offset - pos;
@@ -267,7 +256,7 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 			break;
 		}
 		err = m->op->show(m, p);
-		if (seq_overflow(m) || err) {
+		if (seq_has_overflowed(m) || err) {
 			m->count = offs;
 			if (likely(err <= 0))
 				break;

commit 058504edd02667eef8fac9be27ab3ea74332e9b4
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Wed Jul 2 15:22:37 2014 -0700

    fs/seq_file: fallback to vmalloc allocation
    
    There are a couple of seq_files which use the single_open() interface.
    This interface requires that the whole output must fit into a single
    buffer.
    
    E.g.  for /proc/stat allocation failures have been observed because an
    order-4 memory allocation failed due to memory fragmentation.  In such
    situations reading /proc/stat is not possible anymore.
    
    Therefore change the seq_file code to fallback to vmalloc allocations
    which will usually result in a couple of order-0 allocations and hence
    also work if memory is fragmented.
    
    For reference a call trace where reading from /proc/stat failed:
    
      sadc: page allocation failure: order:4, mode:0x1040d0
      CPU: 1 PID: 192063 Comm: sadc Not tainted 3.10.0-123.el7.s390x #1
      [...]
      Call Trace:
        show_stack+0x6c/0xe8
        warn_alloc_failed+0xd6/0x138
        __alloc_pages_nodemask+0x9da/0xb68
        __get_free_pages+0x2e/0x58
        kmalloc_order_trace+0x44/0xc0
        stat_open+0x5a/0xd8
        proc_reg_open+0x8a/0x140
        do_dentry_open+0x1bc/0x2c8
        finish_open+0x46/0x60
        do_last+0x382/0x10d0
        path_openat+0xc8/0x4f8
        do_filp_open+0x46/0xa8
        do_sys_open+0x114/0x1f0
        sysc_tracego+0x14/0x1a
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Tested-by: David Rientjes <rientjes@google.com>
    Cc: Ian Kent <raven@themaw.net>
    Cc: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
    Cc: Thorsten Diehl <thorsten.diehl@de.ibm.com>
    Cc: Andrea Righi <andrea@betterlinux.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Stefan Bader <stefan.bader@canonical.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 1d641bb108d2..3857b720cb1b 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -8,8 +8,10 @@
 #include <linux/fs.h>
 #include <linux/export.h>
 #include <linux/seq_file.h>
+#include <linux/vmalloc.h>
 #include <linux/slab.h>
 #include <linux/cred.h>
+#include <linux/mm.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -30,6 +32,16 @@ static void seq_set_overflow(struct seq_file *m)
 	m->count = m->size;
 }
 
+static void *seq_buf_alloc(unsigned long size)
+{
+	void *buf;
+
+	buf = kmalloc(size, GFP_KERNEL | __GFP_NOWARN);
+	if (!buf && size > PAGE_SIZE)
+		buf = vmalloc(size);
+	return buf;
+}
+
 /**
  *	seq_open -	initialize sequential file
  *	@file: file we initialize
@@ -96,7 +108,7 @@ static int traverse(struct seq_file *m, loff_t offset)
 		return 0;
 	}
 	if (!m->buf) {
-		m->buf = kmalloc(m->size = PAGE_SIZE, GFP_KERNEL);
+		m->buf = seq_buf_alloc(m->size = PAGE_SIZE);
 		if (!m->buf)
 			return -ENOMEM;
 	}
@@ -135,9 +147,9 @@ static int traverse(struct seq_file *m, loff_t offset)
 
 Eoverflow:
 	m->op->stop(m, p);
-	kfree(m->buf);
+	kvfree(m->buf);
 	m->count = 0;
-	m->buf = kmalloc(m->size <<= 1, GFP_KERNEL);
+	m->buf = seq_buf_alloc(m->size <<= 1);
 	return !m->buf ? -ENOMEM : -EAGAIN;
 }
 
@@ -192,7 +204,7 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 
 	/* grab buffer if we didn't have one */
 	if (!m->buf) {
-		m->buf = kmalloc(m->size = PAGE_SIZE, GFP_KERNEL);
+		m->buf = seq_buf_alloc(m->size = PAGE_SIZE);
 		if (!m->buf)
 			goto Enomem;
 	}
@@ -232,9 +244,9 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 		if (m->count < m->size)
 			goto Fill;
 		m->op->stop(m, p);
-		kfree(m->buf);
+		kvfree(m->buf);
 		m->count = 0;
-		m->buf = kmalloc(m->size <<= 1, GFP_KERNEL);
+		m->buf = seq_buf_alloc(m->size <<= 1);
 		if (!m->buf)
 			goto Enomem;
 		m->version = 0;
@@ -350,7 +362,7 @@ EXPORT_SYMBOL(seq_lseek);
 int seq_release(struct inode *inode, struct file *file)
 {
 	struct seq_file *m = file->private_data;
-	kfree(m->buf);
+	kvfree(m->buf);
 	kfree(m);
 	return 0;
 }
@@ -605,13 +617,13 @@ EXPORT_SYMBOL(single_open);
 int single_open_size(struct file *file, int (*show)(struct seq_file *, void *),
 		void *data, size_t size)
 {
-	char *buf = kmalloc(size, GFP_KERNEL);
+	char *buf = seq_buf_alloc(size);
 	int ret;
 	if (!buf)
 		return -ENOMEM;
 	ret = single_open(file, show, data);
 	if (ret) {
-		kfree(buf);
+		kvfree(buf);
 		return ret;
 	}
 	((struct seq_file *)file->private_data)->buf = buf;

commit 801a76050bcf8d4e500eb8d048ff6265f37a61c8
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Tue Nov 19 01:20:43 2013 +0000

    seq_file: always clear m->count when we free m->buf
    
    Once we'd freed m->buf, m->count should become zero - we have no valid
    contents reachable via m->buf.
    
    Reported-by: Charley (Hao Chuan) Chu <charley.chu@broadcom.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 1cd2388ca5bd..1d641bb108d2 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -136,6 +136,7 @@ static int traverse(struct seq_file *m, loff_t offset)
 Eoverflow:
 	m->op->stop(m, p);
 	kfree(m->buf);
+	m->count = 0;
 	m->buf = kmalloc(m->size <<= 1, GFP_KERNEL);
 	return !m->buf ? -ENOMEM : -EAGAIN;
 }
@@ -232,10 +233,10 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 			goto Fill;
 		m->op->stop(m, p);
 		kfree(m->buf);
+		m->count = 0;
 		m->buf = kmalloc(m->size <<= 1, GFP_KERNEL);
 		if (!m->buf)
 			goto Enomem;
-		m->count = 0;
 		m->version = 0;
 		pos = m->index;
 		p = m->op->start(m, &pos);

commit 839cc2a94cc3665bafe32203c2f095f4dd470a80
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Thu Nov 14 14:31:56 2013 -0800

    seq_file: introduce seq_setwidth() and seq_pad()
    
    There are several users who want to know bytes written by seq_*() for
    alignment purpose.  Currently they are using %n format for knowing it
    because seq_*() returns 0 on success.
    
    This patch introduces seq_setwidth() and seq_pad() for allowing them to
    align without using %n format.
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: David Miller <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index a290157265ef..1cd2388ca5bd 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -766,6 +766,21 @@ int seq_write(struct seq_file *seq, const void *data, size_t len)
 }
 EXPORT_SYMBOL(seq_write);
 
+/**
+ * seq_pad - write padding spaces to buffer
+ * @m: seq_file identifying the buffer to which data should be written
+ * @c: the byte to append after padding if non-zero
+ */
+void seq_pad(struct seq_file *m, char c)
+{
+	int size = m->pad_until - m->count;
+	if (size > 0)
+		seq_printf(m, "%*s", size, "");
+	if (c)
+		seq_putc(m, c);
+}
+EXPORT_SYMBOL(seq_pad);
+
 struct list_head *seq_list_start(struct list_head *head, loff_t pos)
 {
 	struct list_head *lh;

commit 05e16745c0c471bba313961b605b6da3b21a853d
Author: Gu Zheng <guz.fnst@cn.fujitsu.com>
Date:   Fri Oct 25 18:15:06 2013 +0800

    seq_file: always update file->f_pos in seq_lseek()
    
    This issue was first pointed out by Jiaxing Wang several months ago, but no
    further comments:
    https://lkml.org/lkml/2013/6/29/41
    
    As we know pread() does not change f_pos, so after pread(), file->f_pos
    and m->read_pos become different. And seq_lseek() does not update file->f_pos
    if offset equals to m->read_pos, so after pread() and seq_lseek()(lseek to
    m->read_pos), then a subsequent read may read from a wrong position, the
    following program produces the problem:
    
        char str1[32] = { 0 };
        char str2[32] = { 0 };
        int poffset = 10;
        int count = 20;
    
        /*open any seq file*/
        int fd = open("/proc/modules", O_RDONLY);
    
        pread(fd, str1, count, poffset);
        printf("pread:%s\n", str1);
    
        /*seek to where m->read_pos is*/
        lseek(fd, poffset+count, SEEK_SET);
    
        /*supposed to read from poffset+count, but this read from position 0*/
        read(fd, str2, count);
        printf("read:%s\n", str2);
    
    out put:
    pread:
     ck_netbios_ns 12665
    read:
     nf_conntrack_netbios
    
    /proc/modules:
    nf_conntrack_netbios_ns 12665 0 - Live 0xffffffffa038b000
    nf_conntrack_broadcast 12589 1 nf_conntrack_netbios_ns, Live 0xffffffffa0386000
    
    So we always update file->f_pos to offset in seq_lseek() to fix this issue.
    
    Signed-off-by: Jiaxing Wang <hello.wjx@gmail.com>
    Signed-off-by: Gu Zheng <guz.fnst@cn.fujitsu.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 3135c2525c76..a290157265ef 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -328,6 +328,8 @@ loff_t seq_lseek(struct file *file, loff_t offset, int whence)
 				m->read_pos = offset;
 				retval = file->f_pos = offset;
 			}
+		} else {
+			file->f_pos = offset;
 		}
 	}
 	file->f_version = m->version;

commit 0bc77381c1b1600e659eb7322c39d1753615722d
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Jun 21 08:58:21 2013 -0400

    seq_file: add seq_list_*_percpu helpers
    
    When we convert the file_lock_list to a set of percpu lists, we'll need
    a way to iterate over them in order to output /proc/locks info. Add
    some seq_list_*_percpu helpers to handle that.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: J. Bruce Fields <bfields@fieldses.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 774c1eb7f1c9..3135c2525c76 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -921,3 +921,57 @@ struct hlist_node *seq_hlist_next_rcu(void *v,
 		return rcu_dereference(node->next);
 }
 EXPORT_SYMBOL(seq_hlist_next_rcu);
+
+/**
+ * seq_hlist_start_precpu - start an iteration of a percpu hlist array
+ * @head: pointer to percpu array of struct hlist_heads
+ * @cpu:  pointer to cpu "cursor"
+ * @pos:  start position of sequence
+ *
+ * Called at seq_file->op->start().
+ */
+struct hlist_node *
+seq_hlist_start_percpu(struct hlist_head __percpu *head, int *cpu, loff_t pos)
+{
+	struct hlist_node *node;
+
+	for_each_possible_cpu(*cpu) {
+		hlist_for_each(node, per_cpu_ptr(head, *cpu)) {
+			if (pos-- == 0)
+				return node;
+		}
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(seq_hlist_start_percpu);
+
+/**
+ * seq_hlist_next_percpu - move to the next position of the percpu hlist array
+ * @v:    pointer to current hlist_node
+ * @head: pointer to percpu array of struct hlist_heads
+ * @cpu:  pointer to cpu "cursor"
+ * @pos:  start position of sequence
+ *
+ * Called at seq_file->op->next().
+ */
+struct hlist_node *
+seq_hlist_next_percpu(void *v, struct hlist_head __percpu *head,
+			int *cpu, loff_t *pos)
+{
+	struct hlist_node *node = v;
+
+	++*pos;
+
+	if (node->next)
+		return node->next;
+
+	for (*cpu = cpumask_next(*cpu, cpu_possible_mask); *cpu < nr_cpu_ids;
+	     *cpu = cpumask_next(*cpu, cpu_possible_mask)) {
+		struct hlist_head *bucket = per_cpu_ptr(head, *cpu);
+
+		if (!hlist_empty(bucket))
+			return bucket->first;
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(seq_hlist_next_percpu);

commit 2043f495c7c1a06f7748b5bcd17656d93c95e1a6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 13:43:23 2013 -0400

    new helper: single_open_size()
    
    Same as single_open(), but preallocates the buffer of given size.
    Doesn't make any sense for sizes up to PAGE_SIZE and doesn't make
    sense if output of show() exceeds PAGE_SIZE only rarely - seq_read()
    will take care of growing the buffer and redoing show().  If you
    _know_ that it will be large, it might make more sense to look into
    saner iterator, rather than go with single-shot one.  If that's
    impossible, single_open_size() might be for you.
    
    Again, don't use that without a good reason; occasionally that's really
    the best way to go, but very often there are better solutions.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 38bb59f3f2ad..774c1eb7f1c9 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -599,6 +599,24 @@ int single_open(struct file *file, int (*show)(struct seq_file *, void *),
 }
 EXPORT_SYMBOL(single_open);
 
+int single_open_size(struct file *file, int (*show)(struct seq_file *, void *),
+		void *data, size_t size)
+{
+	char *buf = kmalloc(size, GFP_KERNEL);
+	int ret;
+	if (!buf)
+		return -ENOMEM;
+	ret = single_open(file, show, data);
+	if (ret) {
+		kfree(buf);
+		return ret;
+	}
+	((struct seq_file *)file->private_data)->buf = buf;
+	((struct seq_file *)file->private_data)->size = size;
+	return 0;
+}
+EXPORT_SYMBOL(single_open_size);
+
 int single_release(struct inode *inode, struct file *file)
 {
 	const struct seq_operations *op = ((struct seq_file *)file->private_data)->op;

commit 56a79b7b021bf1b08334e63c2c14b280e2dbf47a
Merge: 1c82315a1214 dcf787f39162
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Mar 3 13:23:02 2013 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull  more VFS bits from Al Viro:
     "Unfortunately, it looks like xattr series will have to wait until the
      next cycle ;-/
    
      This pile contains 9p cleanups and fixes (races in v9fs_fid_add()
      etc), fixup for nommu breakage in shmem.c, several cleanups and a bit
      more file_inode() work"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      constify path_get/path_put and fs_struct.c stuff
      fix nommu breakage in shmem.c
      cache the value of file_inode() in struct file
      9p: if v9fs_fid_lookup() gets to asking server, it'd better have hashed dentry
      9p: make sure ->lookup() adds fid to the right dentry
      9p: untangle ->lookup() a bit
      9p: double iput() in ->lookup() if d_materialise_unique() fails
      9p: v9fs_fid_add() can't fail now
      v9fs: get rid of v9fs_dentry
      9p: turn fid->dlist into hlist
      9p: don't bother with private lock in ->d_fsdata; dentry->d_lock will do just fine
      more file_inode() open-coded instances
      selinux: opened file can't have NULL or negative ->f_path.dentry
    
    (In the meantime, the hlist traversal macros have changed, so this
    required a semantic conflict fixup for the newly hlistified fid->dlist)

commit 5e62adef9e1d3e8e26dfd6c95be484b955ad2927
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Wed Feb 27 17:03:22 2013 -0800

    fs/seq_file.c:seq_lseek(): fix switch statement indenting
    
    [akpm@linux-foundation.org: checkpatch fixes]
    Cc: Cyrill Gorcunov <gorcunov@openvz.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 11ba05608818..15c6304bab71 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -308,27 +308,27 @@ loff_t seq_lseek(struct file *file, loff_t offset, int whence)
 	mutex_lock(&m->lock);
 	m->version = file->f_version;
 	switch (whence) {
-		case SEEK_CUR:
-			offset += file->f_pos;
-		case SEEK_SET:
-			if (offset < 0)
-				break;
-			retval = offset;
-			if (offset != m->read_pos) {
-				while ((retval=traverse(m, offset)) == -EAGAIN)
-					;
-				if (retval) {
-					/* with extreme prejudice... */
-					file->f_pos = 0;
-					m->read_pos = 0;
-					m->version = 0;
-					m->index = 0;
-					m->count = 0;
-				} else {
-					m->read_pos = offset;
-					retval = file->f_pos = offset;
-				}
+	case SEEK_CUR:
+		offset += file->f_pos;
+	case SEEK_SET:
+		if (offset < 0)
+			break;
+		retval = offset;
+		if (offset != m->read_pos) {
+			while ((retval = traverse(m, offset)) == -EAGAIN)
+				;
+			if (retval) {
+				/* with extreme prejudice... */
+				file->f_pos = 0;
+				m->read_pos = 0;
+				m->version = 0;
+				m->index = 0;
+				m->count = 0;
+			} else {
+				m->read_pos = offset;
+				retval = file->f_pos = offset;
 			}
+		}
 	}
 	file->f_version = m->version;
 	mutex_unlock(&m->lock);

commit 80de7f7ae013b1e287059f39eaba2a12219681cf
Author: Cyrill Gorcunov <gorcunov@openvz.org>
Date:   Wed Feb 27 17:03:21 2013 -0800

    seq-file: use SEEK_ macros instead of hardcoded numbers
    
    Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index f2bc3dfd0b88..11ba05608818 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -308,9 +308,9 @@ loff_t seq_lseek(struct file *file, loff_t offset, int whence)
 	mutex_lock(&m->lock);
 	m->version = file->f_version;
 	switch (whence) {
-		case 1:
+		case SEEK_CUR:
 			offset += file->f_pos;
-		case 0:
+		case SEEK_SET:
 			if (offset < 0)
 				break;
 			retval = offset;

commit 6131ffaa1f091415b7a24abb01f033d9c0a727f4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Feb 27 16:59:05 2013 -0500

    more file_inode() open-coded instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index f2bc3dfd0b88..f9538ea2a756 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -339,7 +339,7 @@ EXPORT_SYMBOL(seq_lseek);
 /**
  *	seq_release -	free the structures associated with sequential file.
  *	@file: file in question
- *	@inode: file->f_path.dentry->d_inode
+ *	@inode: its inode
  *
  *	Frees the structures associated with sequential file; can be used
  *	as ->f_op->release() if you don't have private data to destroy.

commit 254adaa465c40151df11fc1f88f93e6e86eb61d4
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Wed Jan 9 17:13:00 2013 -0800

    seq_file: fix new kernel-doc warnings
    
    Fix kernel-doc warnings in fs/seq_file.c:
    
      Warning(fs/seq_file.c:304): No description found for parameter 'whence'
      Warning(fs/seq_file.c:304): Excess function parameter 'origin' description in 'seq_lseek'
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 9d863fb501f9..f2bc3dfd0b88 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -296,7 +296,7 @@ EXPORT_SYMBOL(seq_read);
  *	seq_lseek -	->llseek() method for sequential files.
  *	@file: the file in question
  *	@offset: new position
- *	@origin: 0 for absolute, 1 for relative position
+ *	@whence: 0 for absolute, 1 for relative position
  *
  *	Ready-made ->f_op->llseek()
  */

commit 965c8e59cfcf845ecde2265a1d1bfee5f011d302
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Mon Dec 17 15:59:39 2012 -0800

    lseek: the "whence" argument is called "whence"
    
    But the kernel decided to call it "origin" instead.  Fix most of the
    sites.
    
    Acked-by: Hugh Dickins <hughd@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 99dffab4c4e4..9d863fb501f9 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -300,14 +300,14 @@ EXPORT_SYMBOL(seq_read);
  *
  *	Ready-made ->f_op->llseek()
  */
-loff_t seq_lseek(struct file *file, loff_t offset, int origin)
+loff_t seq_lseek(struct file *file, loff_t offset, int whence)
 {
 	struct seq_file *m = file->private_data;
 	loff_t retval = -EINVAL;
 
 	mutex_lock(&m->lock);
 	m->version = file->f_version;
-	switch (origin) {
+	switch (whence) {
 		case 1:
 			offset += file->f_pos;
 		case 0:

commit adb37c4c67f807f16beb222028fb3ce9a354dc2b
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed May 23 18:01:20 2012 -0600

    userns: Make seq_file's user namespace accessible
    
    struct file already has a user namespace associated with it
    in file->f_cred->user_ns, unfortunately because struct
    seq_file has no struct file backpointer associated with
    it, it is difficult to get at the user namespace in seq_file
    context.  Therefore add a helper function seq_user_ns to return
    the associated user namespace and a user_ns field to struct
    seq_file to be used in implementing seq_user_ns.
    
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 14cf9de1dbe1..99dffab4c4e4 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -9,6 +9,7 @@
 #include <linux/export.h>
 #include <linux/seq_file.h>
 #include <linux/slab.h>
+#include <linux/cred.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -56,6 +57,9 @@ int seq_open(struct file *file, const struct seq_operations *op)
 	memset(p, 0, sizeof(*p));
 	mutex_init(&p->lock);
 	p->op = op;
+#ifdef CONFIG_USER_NS
+	p->user_ns = file->f_cred->user_ns;
+#endif
 
 	/*
 	 * Wrappers around seq_open(e.g. swaps_open) need to be

commit a4808147dcf1ecf2f76212a78fd9692b3c112f47
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jun 11 13:16:35 2012 +0100

    seq_file: Add seq_vprintf function and export it
    
    The existing seq_printf function is rewritten in terms of the new
    seq_vprintf which is also exported to modules. This allows GFS2
    (and potentially other seq_file users) to have a vprintf based
    interface and to avoid an extra copy into a temporary buffer in
    some cases.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Reported-by: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Al Viro <viro@ZenIV.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 0cbd0494b79e..14cf9de1dbe1 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -385,15 +385,12 @@ int seq_escape(struct seq_file *m, const char *s, const char *esc)
 }
 EXPORT_SYMBOL(seq_escape);
 
-int seq_printf(struct seq_file *m, const char *f, ...)
+int seq_vprintf(struct seq_file *m, const char *f, va_list args)
 {
-	va_list args;
 	int len;
 
 	if (m->count < m->size) {
-		va_start(args, f);
 		len = vsnprintf(m->buf + m->count, m->size - m->count, f, args);
-		va_end(args);
 		if (m->count + len < m->size) {
 			m->count += len;
 			return 0;
@@ -402,6 +399,19 @@ int seq_printf(struct seq_file *m, const char *f, ...)
 	seq_set_overflow(m);
 	return -1;
 }
+EXPORT_SYMBOL(seq_vprintf);
+
+int seq_printf(struct seq_file *m, const char *f, ...)
+{
+	int ret;
+	va_list args;
+
+	va_start(args, f);
+	ret = seq_vprintf(m, f, args);
+	va_end(args);
+
+	return ret;
+}
 EXPORT_SYMBOL(seq_printf);
 
 /**

commit 11bcb32848ddb5ab28f09f142b625e2ba4d55c4c
Merge: ed2d265d1266 8bc3bcc93a2b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 24 10:24:31 2012 -0700

    Merge tag 'module-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    Pull cleanup of fs/ and lib/ users of module.h from Paul Gortmaker:
     "Fix up files in fs/ and lib/ dirs to only use module.h if they really
      need it.
    
      These are trivial in scope vs the work done previously.  We now have
      things where any few remaining cleanups can be farmed out to arch or
      subsystem maintainers, and I have done so when possible.  What is
      remaining here represents the bits that don't clearly lie within a
      single arch/subsystem boundary, like the fs dir and the lib dir.
    
      Some duplicate includes arising from overlapping fixes from
      independent subsystem maintainer submissions are also quashed."
    
    Fix up trivial conflicts due to clashes with other include file cleanups
    (including some due to the previous bug.h cleanup pull).
    
    * tag 'module-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux:
      lib: reduce the use of module.h wherever possible
      fs: reduce the use of module.h wherever possible
      includecheck: delete any duplicate instances of module.h

commit e075f59152890ffd7e3d704afc997dd686c8a781
Author: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Date:   Fri Mar 23 15:02:55 2012 -0700

    seq_file: add seq_set_overflow(), seq_overflow()
    
    It is undocumented but a seq_file's overflow state is indicated by
    m->count == m->size.  Add seq_set_overflow() and seq_overflow() to
    set/check overflow status explicitly.
    
    Based on an idea from Eric Dumazet.
    
    [akpm@linux-foundation.org: tweak code comment]
    Signed-off-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 55c293f7024d..46cfb067fc3a 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -13,6 +13,22 @@
 #include <asm/uaccess.h>
 #include <asm/page.h>
 
+
+/*
+ * seq_files have a buffer which can may overflow. When this happens a larger
+ * buffer is reallocated and all the data will be printed again.
+ * The overflow state is true when m->count == m->size.
+ */
+static bool seq_overflow(struct seq_file *m)
+{
+	return m->count == m->size;
+}
+
+static void seq_set_overflow(struct seq_file *m)
+{
+	m->count = m->size;
+}
+
 /**
  *	seq_open -	initialize sequential file
  *	@file: file we initialize
@@ -92,7 +108,7 @@ static int traverse(struct seq_file *m, loff_t offset)
 			error = 0;
 			m->count = 0;
 		}
-		if (m->count == m->size)
+		if (seq_overflow(m))
 			goto Eoverflow;
 		if (pos + m->count > offset) {
 			m->from = offset - pos;
@@ -234,7 +250,7 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 			break;
 		}
 		err = m->op->show(m, p);
-		if (m->count == m->size || err) {
+		if (seq_overflow(m) || err) {
 			m->count = offs;
 			if (likely(err <= 0))
 				break;
@@ -361,7 +377,7 @@ int seq_escape(struct seq_file *m, const char *s, const char *esc)
 			*p++ = '0' + (c & 07);
 			continue;
 		}
-		m->count = m->size;
+		seq_set_overflow(m);
 		return -1;
         }
 	m->count = p - m->buf;
@@ -383,7 +399,7 @@ int seq_printf(struct seq_file *m, const char *f, ...)
 			return 0;
 		}
 	}
-	m->count = m->size;
+	seq_set_overflow(m);
 	return -1;
 }
 EXPORT_SYMBOL(seq_printf);
@@ -512,7 +528,7 @@ int seq_bitmap(struct seq_file *m, const unsigned long *bits,
 			return 0;
 		}
 	}
-	m->count = m->size;
+	seq_set_overflow(m);
 	return -1;
 }
 EXPORT_SYMBOL(seq_bitmap);
@@ -528,7 +544,7 @@ int seq_bitmap_list(struct seq_file *m, const unsigned long *bits,
 			return 0;
 		}
 	}
-	m->count = m->size;
+	seq_set_overflow(m);
 	return -1;
 }
 EXPORT_SYMBOL(seq_bitmap_list);
@@ -639,7 +655,7 @@ int seq_puts(struct seq_file *m, const char *s)
 		m->count += len;
 		return 0;
 	}
-	m->count = m->size;
+	seq_set_overflow(m);
 	return -1;
 }
 EXPORT_SYMBOL(seq_puts);
@@ -673,7 +689,7 @@ int seq_put_decimal_ull(struct seq_file *m, char delimiter,
 	m->count += len;
 	return 0;
 overflow:
-	m->count = m->size;
+	seq_set_overflow(m);
 	return -1;
 }
 EXPORT_SYMBOL(seq_put_decimal_ull);
@@ -683,7 +699,7 @@ int seq_put_decimal_ll(struct seq_file *m, char delimiter,
 {
 	if (num < 0) {
 		if (m->count + 3 >= m->size) {
-			m->count = m->size;
+			seq_set_overflow(m);
 			return -1;
 		}
 		if (delimiter)
@@ -711,7 +727,7 @@ int seq_write(struct seq_file *seq, const void *data, size_t len)
 		seq->count += len;
 		return 0;
 	}
-	seq->count = seq->size;
+	seq_set_overflow(seq);
 	return -1;
 }
 EXPORT_SYMBOL(seq_write);

commit bda7bad62bc4c4e0783348e8db51abe094153c56
Author: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Date:   Fri Mar 23 15:02:54 2012 -0700

    procfs: speed up /proc/pid/stat, statm
    
    Process accounting applications as top, ps visit some files under
    /proc/<pid>.  With seq_put_decimal_ull(), we can optimize /proc/<pid>/stat
    and /proc/<pid>/statm files.
    
    This patch adds
      - seq_put_decimal_ll() for signed values.
      - allow delimiter == 0.
      - convert seq_printf() to seq_put_decimal_ull/ll in /proc/stat, statm.
    
    Test result on a system with 2000+ procs.
    
    Before patch:
      [kamezawa@bluextal test]$ top -b -n 1 | wc -l
      2223
      [kamezawa@bluextal test]$ time top -b -n 1 > /dev/null
    
      real    0m0.675s
      user    0m0.044s
      sys     0m0.121s
    
      [kamezawa@bluextal test]$ time ps -elf > /dev/null
    
      real    0m0.236s
      user    0m0.056s
      sys     0m0.176s
    
    After patch:
      kamezawa@bluextal ~]$ time top -b -n 1 > /dev/null
    
      real    0m0.657s
      user    0m0.052s
      sys     0m0.100s
    
      [kamezawa@bluextal ~]$ time ps -elf > /dev/null
    
      real    0m0.198s
      user    0m0.050s
      sys     0m0.145s
    
    Considering top, ps tend to scan /proc periodically, this will reduce cpu
    consumption by top/ps to some extent.
    
    [akpm@linux-foundation.org: checkpatch fixes]
    Signed-off-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 7d19816c4cc9..55c293f7024d 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -659,7 +659,8 @@ int seq_put_decimal_ull(struct seq_file *m, char delimiter,
 	if (m->count + 2 >= m->size) /* we'll write 2 bytes at least */
 		goto overflow;
 
-	m->buf[m->count++] = delimiter;
+	if (delimiter)
+		m->buf[m->count++] = delimiter;
 
 	if (num < 10) {
 		m->buf[m->count++] = num + '0';
@@ -677,6 +678,24 @@ int seq_put_decimal_ull(struct seq_file *m, char delimiter,
 }
 EXPORT_SYMBOL(seq_put_decimal_ull);
 
+int seq_put_decimal_ll(struct seq_file *m, char delimiter,
+			long long num)
+{
+	if (num < 0) {
+		if (m->count + 3 >= m->size) {
+			m->count = m->size;
+			return -1;
+		}
+		if (delimiter)
+			m->buf[m->count++] = delimiter;
+		num = -num;
+		delimiter = '-';
+	}
+	return seq_put_decimal_ull(m, delimiter, num);
+
+}
+EXPORT_SYMBOL(seq_put_decimal_ll);
+
 /**
  * seq_write - write arbitrary data to buffer
  * @seq: seq_file identifying the buffer to which data should be written

commit 1ac101a5d675aca2426c5cd460c73fb95acb8391
Author: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Date:   Fri Mar 23 15:02:54 2012 -0700

    procfs: add num_to_str() to speed up /proc/stat
    
    == stat_check.py
    num = 0
    with open("/proc/stat") as f:
            while num < 1000 :
                    data = f.read()
                    f.seek(0, 0)
                    num = num + 1
    ==
    
    perf shows
    
        20.39%  stat_check.py  [kernel.kallsyms]    [k] format_decode
        13.41%  stat_check.py  [kernel.kallsyms]    [k] number
        12.61%  stat_check.py  [kernel.kallsyms]    [k] vsnprintf
        10.85%  stat_check.py  [kernel.kallsyms]    [k] memcpy
         4.85%  stat_check.py  [kernel.kallsyms]    [k] radix_tree_lookup
         4.43%  stat_check.py  [kernel.kallsyms]    [k] seq_printf
    
    This patch removes most of calls to vsnprintf() by adding num_to_str()
    and seq_print_decimal_ull(), which prints decimal numbers without rich
    functions provided by printf().
    
    On my 8cpu box.
    == Before patch ==
    [root@bluextal test]# time ./stat_check.py
    
    real    0m0.150s
    user    0m0.026s
    sys     0m0.121s
    
    == After patch ==
    [root@bluextal test]# time ./stat_check.py
    
    real    0m0.055s
    user    0m0.022s
    sys     0m0.030s
    
    [akpm@linux-foundation.org: remove incorrect comment, use less statck in num_to_str(), move comment from .h to .c, simplify seq_put_decimal_ull()]
    [andrea@betterlinux.com: avoid breaking the ABI in /proc/stat]
    Signed-off-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Signed-off-by: Andrea Righi <andrea@betterlinux.com>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Glauber Costa <glommer@parallels.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Paul Turner <pjt@google.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index aa242dc99373..7d19816c4cc9 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -644,6 +644,39 @@ int seq_puts(struct seq_file *m, const char *s)
 }
 EXPORT_SYMBOL(seq_puts);
 
+/*
+ * A helper routine for putting decimal numbers without rich format of printf().
+ * only 'unsigned long long' is supported.
+ * This routine will put one byte delimiter + number into seq_file.
+ * This routine is very quick when you show lots of numbers.
+ * In usual cases, it will be better to use seq_printf(). It's easier to read.
+ */
+int seq_put_decimal_ull(struct seq_file *m, char delimiter,
+			unsigned long long num)
+{
+	int len;
+
+	if (m->count + 2 >= m->size) /* we'll write 2 bytes at least */
+		goto overflow;
+
+	m->buf[m->count++] = delimiter;
+
+	if (num < 10) {
+		m->buf[m->count++] = num + '0';
+		return 0;
+	}
+
+	len = num_to_str(m->buf + m->count, m->size - m->count, num);
+	if (!len)
+		goto overflow;
+	m->count += len;
+	return 0;
+overflow:
+	m->count = m->size;
+	return -1;
+}
+EXPORT_SYMBOL(seq_put_decimal_ull);
+
 /**
  * seq_write - write arbitrary data to buffer
  * @seq: seq_file identifying the buffer to which data should be written

commit 7904ac84244b59f536c2a5d1066a10f46df07b08
Author: Earl Chew <echew@ixiacom.com>
Date:   Wed Mar 21 16:33:43 2012 -0700

    seq_file: fix mishandling of consecutive pread() invocations.
    
    The following program illustrates the problem:
    
        char buf[8192];
    
        int fd = open("/proc/self/maps", O_RDONLY);
    
        n = pread(fd, buf, sizeof(buf), 0);
        printf("%d\n", n);
    
        /* lseek(fd, 0, SEEK_CUR); */ /* Uncomment to work around */
    
        n = pread(fd, buf, sizeof(buf), 0);
        printf("%d\n", n);
    
    The second printf() prints zero, but uncommenting the lseek() corrects its
    behaviour.
    
    To fix, make seq_read() mirror seq_lseek() when processing changes in
    *ppos.  Restore m->version first, then if required traverse and update
    read_pos on success.
    
    Addresses https://bugzilla.kernel.org/show_bug.cgi?id=11856
    
    Signed-off-by: Earl Chew <echew@ixiacom.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 4023d6be939b..aa242dc99373 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -140,9 +140,21 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 
 	mutex_lock(&m->lock);
 
+	/*
+	 * seq_file->op->..m_start/m_stop/m_next may do special actions
+	 * or optimisations based on the file->f_version, so we want to
+	 * pass the file->f_version to those methods.
+	 *
+	 * seq_file->version is just copy of f_version, and seq_file
+	 * methods can treat it simply as file version.
+	 * It is copied in first and copied out after all operations.
+	 * It is convenient to have it as  part of structure to avoid the
+	 * need of passing another argument to all the seq_file methods.
+	 */
+	m->version = file->f_version;
+
 	/* Don't assume *ppos is where we left it */
 	if (unlikely(*ppos != m->read_pos)) {
-		m->read_pos = *ppos;
 		while ((err = traverse(m, *ppos)) == -EAGAIN)
 			;
 		if (err) {
@@ -152,21 +164,11 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 			m->index = 0;
 			m->count = 0;
 			goto Done;
+		} else {
+			m->read_pos = *ppos;
 		}
 	}
 
-	/*
-	 * seq_file->op->..m_start/m_stop/m_next may do special actions
-	 * or optimisations based on the file->f_version, so we want to
-	 * pass the file->f_version to those methods.
-	 *
-	 * seq_file->version is just copy of f_version, and seq_file
-	 * methods can treat it simply as file version.
-	 * It is copied in first and copied out after all operations.
-	 * It is convenient to have it as  part of structure to avoid the
-	 * need of passing another argument to all the seq_file methods.
-	 */
-	m->version = file->f_version;
 	/* grab buffer if we didn't have one */
 	if (!m->buf) {
 		m->buf = kmalloc(m->size = PAGE_SIZE, GFP_KERNEL);

commit 630d9c47274aa89bfa77fe6556d7818bdcb12992
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Nov 16 23:57:37 2011 -0500

    fs: reduce the use of module.h wherever possible
    
    For files only using THIS_MODULE and/or EXPORT_SYMBOL, map
    them onto including export.h -- or if the file isn't even
    using those, then just delete the include.  Fix up any implicit
    include dependencies that were being masked by module.h along
    the way.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 4023d6be939b..9f73c6b4436d 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -6,7 +6,7 @@
  */
 
 #include <linux/fs.h>
-#include <linux/module.h>
+#include <linux/export.h>
 #include <linux/seq_file.h>
 #include <linux/slab.h>
 

commit 8c9379e972e984d11c2b99121847ba9fa7a0c56c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 8 20:18:57 2011 -0500

    constify seq_file stuff
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index dba43c3ea3af..4023d6be939b 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -397,7 +397,7 @@ EXPORT_SYMBOL(seq_printf);
  *      Returns pointer past last written character in @s, or NULL in case of
  *      failure.
  */
-char *mangle_path(char *s, char *p, char *esc)
+char *mangle_path(char *s, const char *p, const char *esc)
 {
 	while (s <= p) {
 		char c = *p++;
@@ -427,7 +427,7 @@ EXPORT_SYMBOL(mangle_path);
  * return the absolute path of 'path', as represented by the
  * dentry / mnt pair in the path parameter.
  */
-int seq_path(struct seq_file *m, struct path *path, char *esc)
+int seq_path(struct seq_file *m, const struct path *path, const char *esc)
 {
 	char *buf;
 	size_t size = seq_get_buf(m, &buf);
@@ -450,8 +450,8 @@ EXPORT_SYMBOL(seq_path);
 /*
  * Same as seq_path, but relative to supplied root.
  */
-int seq_path_root(struct seq_file *m, struct path *path, struct path *root,
-		  char *esc)
+int seq_path_root(struct seq_file *m, const struct path *path,
+		  const struct path *root, const char *esc)
 {
 	char *buf;
 	size_t size = seq_get_buf(m, &buf);
@@ -480,7 +480,7 @@ int seq_path_root(struct seq_file *m, struct path *path, struct path *root,
 /*
  * returns the path of the 'dentry' from the root of its filesystem.
  */
-int seq_dentry(struct seq_file *m, struct dentry *dentry, char *esc)
+int seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc)
 {
 	char *buf;
 	size_t size = seq_get_buf(m, &buf);

commit 02125a826459a6ad142f8d91c5b6357562f96615
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Dec 5 08:43:34 2011 -0500

    fix apparmor dereferencing potentially freed dentry, sanitize __d_path() API
    
    __d_path() API is asking for trouble and in case of apparmor d_namespace_path()
    getting just that.  The root cause is that when __d_path() misses the root
    it had been told to look for, it stores the location of the most remote ancestor
    in *root.  Without grabbing references.  Sure, at the moment of call it had
    been pinned down by what we have in *path.  And if we raced with umount -l, we
    could have very well stopped at vfsmount/dentry that got freed as soon as
    prepend_path() dropped vfsmount_lock.
    
    It is safe to compare these pointers with pre-existing (and known to be still
    alive) vfsmount and dentry, as long as all we are asking is "is it the same
    address?".  Dereferencing is not safe and apparmor ended up stepping into
    that.  d_namespace_path() really wants to examine the place where we stopped,
    even if it's not connected to our namespace.  As the result, it looked
    at ->d_sb->s_magic of a dentry that might've been already freed by that point.
    All other callers had been careful enough to avoid that, but it's really
    a bad interface - it invites that kind of trouble.
    
    The fix is fairly straightforward, even though it's bigger than I'd like:
            * prepend_path() root argument becomes const.
            * __d_path() is never called with NULL/NULL root.  It was a kludge
    to start with.  Instead, we have an explicit function - d_absolute_root().
    Same as __d_path(), except that it doesn't get root passed and stops where
    it stops.  apparmor and tomoyo are using it.
            * __d_path() returns NULL on path outside of root.  The main
    caller is show_mountinfo() and that's precisely what we pass root for - to
    skip those outside chroot jail.  Those who don't want that can (and do)
    use d_path().
            * __d_path() root argument becomes const.  Everyone agrees, I hope.
            * apparmor does *NOT* try to use __d_path() or any of its variants
    when it sees that path->mnt is an internal vfsmount.  In that case it's
    definitely not mounted anywhere and dentry_path() is exactly what we want
    there.  Handling of sysctl()-triggered weirdness is moved to that place.
            * if apparmor is asked to do pathname relative to chroot jail
    and __d_path() tells it we it's not in that jail, the sucker just calls
    d_absolute_path() instead.  That's the other remaining caller of __d_path(),
    BTW.
            * seq_path_root() does _NOT_ return -ENAMETOOLONG (it's stupid anyway -
    the normal seq_file logics will take care of growing the buffer and redoing
    the call of ->show() just fine).  However, if it gets path not reachable
    from root, it returns SEQ_SKIP.  The only caller adjusted (i.e. stopped
    ignoring the return value as it used to do).
    
    Reviewed-by: John Johansen <john.johansen@canonical.com>
    ACKed-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: stable@vger.kernel.org

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 05d6b0e78c95..dba43c3ea3af 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -449,8 +449,6 @@ EXPORT_SYMBOL(seq_path);
 
 /*
  * Same as seq_path, but relative to supplied root.
- *
- * root may be changed, see __d_path().
  */
 int seq_path_root(struct seq_file *m, struct path *path, struct path *root,
 		  char *esc)
@@ -463,6 +461,8 @@ int seq_path_root(struct seq_file *m, struct path *path, struct path *root,
 		char *p;
 
 		p = __d_path(path, root, buf, size);
+		if (!p)
+			return SEQ_SKIP;
 		res = PTR_ERR(p);
 		if (!IS_ERR(p)) {
 			char *end = mangle_path(buf, p, esc);
@@ -474,7 +474,7 @@ int seq_path_root(struct seq_file *m, struct path *path, struct path *root,
 	}
 	seq_commit(m, res);
 
-	return res < 0 ? res : 0;
+	return res < 0 && res != -ENAMETOOLONG ? res : 0;
 }
 
 /*

commit be148247cfbe2422f5709e77d9c3e10b8a6394da
Author: Christoph Hellwig <hch@infradead.org>
Date:   Sun Oct 10 05:36:21 2010 -0400

    fs: take dcache_lock inside __d_path
    
    All callers take dcache_lock just around the call to __d_path, so
    take the lock into it in preparation of getting rid of dcache_lock.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 0e7cb1395a94..05d6b0e78c95 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -462,9 +462,7 @@ int seq_path_root(struct seq_file *m, struct path *path, struct path *root,
 	if (size) {
 		char *p;
 
-		spin_lock(&dcache_lock);
 		p = __d_path(path, root, buf, size);
-		spin_unlock(&dcache_lock);
 		res = PTR_ERR(p);
 		if (!IS_ERR(p)) {
 			char *end = mangle_path(buf, p, esc);

commit 8209e2f46752914e94f65469b8312c42dc5d7d8f
Author: Joe Perches <joe@perches.com>
Date:   Sat Sep 4 18:52:49 2010 -0700

    fs/seq_file.c: Remove unnecessary casts of private_data
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index e1f437be6c3c..0e7cb1395a94 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -131,7 +131,7 @@ static int traverse(struct seq_file *m, loff_t offset)
  */
 ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 {
-	struct seq_file *m = (struct seq_file *)file->private_data;
+	struct seq_file *m = file->private_data;
 	size_t copied = 0;
 	loff_t pos;
 	size_t n;
@@ -280,7 +280,7 @@ EXPORT_SYMBOL(seq_read);
  */
 loff_t seq_lseek(struct file *file, loff_t offset, int origin)
 {
-	struct seq_file *m = (struct seq_file *)file->private_data;
+	struct seq_file *m = file->private_data;
 	loff_t retval = -EINVAL;
 
 	mutex_lock(&m->lock);
@@ -324,7 +324,7 @@ EXPORT_SYMBOL(seq_lseek);
  */
 int seq_release(struct inode *inode, struct file *file)
 {
-	struct seq_file *m = (struct seq_file *)file->private_data;
+	struct seq_file *m = file->private_data;
 	kfree(m->buf);
 	kfree(m);
 	return 0;

commit 138860b95359feee49a31fb12be87825e4cd84ac
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Thu Mar 4 09:37:12 2010 -0800

    seq_file: fix new kernel-doc warnings
    
    Fix kernel-doc notation in new seq-file functions and
    correct spelling.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Li Zefan <lizf@cn.fujitsu.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 5afd554efad3..e1f437be6c3c 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -734,7 +734,7 @@ EXPORT_SYMBOL(seq_hlist_start_head);
  * seq_hlist_next - move to the next position of the hlist
  * @v:    the current iterator
  * @head: the head of the hlist
- * @pos:  the current posision
+ * @ppos: the current position
  *
  * Called at seq_file->op->next().
  */
@@ -800,7 +800,7 @@ EXPORT_SYMBOL(seq_hlist_start_head_rcu);
  * seq_hlist_next_rcu - move to the next position of the hlist protected by RCU
  * @v:    the current iterator
  * @head: the head of the hlist
- * @pos:  the current posision
+ * @ppos: the current position
  *
  * Called at seq_file->op->next().
  *

commit 1cc523271ef0b6305c565a143e3d48f6fff826dd
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Mon Feb 22 07:57:17 2010 +0000

    seq_file: add RCU versions of new hlist/list iterators (v3)
    
    Many usages of seq_file use RCU protected lists, so non RCU
    iterators will not work safely.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index f65b16f02da3..5afd554efad3 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -750,3 +750,74 @@ struct hlist_node *seq_hlist_next(void *v, struct hlist_head *head,
 		return node->next;
 }
 EXPORT_SYMBOL(seq_hlist_next);
+
+/**
+ * seq_hlist_start_rcu - start an iteration of a hlist protected by RCU
+ * @head: the head of the hlist
+ * @pos:  the start position of the sequence
+ *
+ * Called at seq_file->op->start().
+ *
+ * This list-traversal primitive may safely run concurrently with
+ * the _rcu list-mutation primitives such as hlist_add_head_rcu()
+ * as long as the traversal is guarded by rcu_read_lock().
+ */
+struct hlist_node *seq_hlist_start_rcu(struct hlist_head *head,
+				       loff_t pos)
+{
+	struct hlist_node *node;
+
+	__hlist_for_each_rcu(node, head)
+		if (pos-- == 0)
+			return node;
+	return NULL;
+}
+EXPORT_SYMBOL(seq_hlist_start_rcu);
+
+/**
+ * seq_hlist_start_head_rcu - start an iteration of a hlist protected by RCU
+ * @head: the head of the hlist
+ * @pos:  the start position of the sequence
+ *
+ * Called at seq_file->op->start(). Call this function if you want to
+ * print a header at the top of the output.
+ *
+ * This list-traversal primitive may safely run concurrently with
+ * the _rcu list-mutation primitives such as hlist_add_head_rcu()
+ * as long as the traversal is guarded by rcu_read_lock().
+ */
+struct hlist_node *seq_hlist_start_head_rcu(struct hlist_head *head,
+					    loff_t pos)
+{
+	if (!pos)
+		return SEQ_START_TOKEN;
+
+	return seq_hlist_start_rcu(head, pos - 1);
+}
+EXPORT_SYMBOL(seq_hlist_start_head_rcu);
+
+/**
+ * seq_hlist_next_rcu - move to the next position of the hlist protected by RCU
+ * @v:    the current iterator
+ * @head: the head of the hlist
+ * @pos:  the current posision
+ *
+ * Called at seq_file->op->next().
+ *
+ * This list-traversal primitive may safely run concurrently with
+ * the _rcu list-mutation primitives such as hlist_add_head_rcu()
+ * as long as the traversal is guarded by rcu_read_lock().
+ */
+struct hlist_node *seq_hlist_next_rcu(void *v,
+				      struct hlist_head *head,
+				      loff_t *ppos)
+{
+	struct hlist_node *node = v;
+
+	++*ppos;
+	if (v == SEQ_START_TOKEN)
+		return rcu_dereference(head->first);
+	else
+		return rcu_dereference(node->next);
+}
+EXPORT_SYMBOL(seq_hlist_next_rcu);

commit 66655de6d132b726be64c324bc3f9ea366d20697
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Mon Feb 8 23:18:22 2010 +0000

    seq_file: Add helpers for iteration over a hlist
    
    Some places in kernel need to iterate over a hlist in seq_file,
    so provide some common helpers.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index eae7d9dbf3ff..f65b16f02da3 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -674,7 +674,6 @@ struct list_head *seq_list_start(struct list_head *head, loff_t pos)
 
 	return NULL;
 }
-
 EXPORT_SYMBOL(seq_list_start);
 
 struct list_head *seq_list_start_head(struct list_head *head, loff_t pos)
@@ -684,7 +683,6 @@ struct list_head *seq_list_start_head(struct list_head *head, loff_t pos)
 
 	return seq_list_start(head, pos - 1);
 }
-
 EXPORT_SYMBOL(seq_list_start_head);
 
 struct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)
@@ -695,5 +693,60 @@ struct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)
 	++*ppos;
 	return lh == head ? NULL : lh;
 }
-
 EXPORT_SYMBOL(seq_list_next);
+
+/**
+ * seq_hlist_start - start an iteration of a hlist
+ * @head: the head of the hlist
+ * @pos:  the start position of the sequence
+ *
+ * Called at seq_file->op->start().
+ */
+struct hlist_node *seq_hlist_start(struct hlist_head *head, loff_t pos)
+{
+	struct hlist_node *node;
+
+	hlist_for_each(node, head)
+		if (pos-- == 0)
+			return node;
+	return NULL;
+}
+EXPORT_SYMBOL(seq_hlist_start);
+
+/**
+ * seq_hlist_start_head - start an iteration of a hlist
+ * @head: the head of the hlist
+ * @pos:  the start position of the sequence
+ *
+ * Called at seq_file->op->start(). Call this function if you want to
+ * print a header at the top of the output.
+ */
+struct hlist_node *seq_hlist_start_head(struct hlist_head *head, loff_t pos)
+{
+	if (!pos)
+		return SEQ_START_TOKEN;
+
+	return seq_hlist_start(head, pos - 1);
+}
+EXPORT_SYMBOL(seq_hlist_start_head);
+
+/**
+ * seq_hlist_next - move to the next position of the hlist
+ * @v:    the current iterator
+ * @head: the head of the hlist
+ * @pos:  the current posision
+ *
+ * Called at seq_file->op->next().
+ */
+struct hlist_node *seq_hlist_next(void *v, struct hlist_head *head,
+				  loff_t *ppos)
+{
+	struct hlist_node *node = v;
+
+	++*ppos;
+	if (v == SEQ_START_TOKEN)
+		return head->first;
+	else
+		return node->next;
+}
+EXPORT_SYMBOL(seq_hlist_next);

commit f84398068d9c2babe41500504ef247ae07081857
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Mon Sep 21 14:48:36 2009 +0200

    vfs: seq_file: add helpers for data filling
    
    Add two helpers that allow access to the seq_file's own buffer, but
    hide the internal details of seq_files.
    
    This allows easier implementation of special purpose filling
    functions.  It also cleans up some existing functions which duplicated
    the seq_file logic.
    
    Make these inline functions in seq_file.h, as suggested by Al.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Acked-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 66efd0aa8fb3..eae7d9dbf3ff 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -429,20 +429,21 @@ EXPORT_SYMBOL(mangle_path);
  */
 int seq_path(struct seq_file *m, struct path *path, char *esc)
 {
-	if (m->count < m->size) {
-		char *s = m->buf + m->count;
-		char *p = d_path(path, s, m->size - m->count);
+	char *buf;
+	size_t size = seq_get_buf(m, &buf);
+	int res = -1;
+
+	if (size) {
+		char *p = d_path(path, buf, size);
 		if (!IS_ERR(p)) {
-			s = mangle_path(s, p, esc);
-			if (s) {
-				p = m->buf + m->count;
-				m->count = s - m->buf;
-				return s - p;
-			}
+			char *end = mangle_path(buf, p, esc);
+			if (end)
+				res = end - buf;
 		}
 	}
-	m->count = m->size;
-	return -1;
+	seq_commit(m, res);
+
+	return res;
 }
 EXPORT_SYMBOL(seq_path);
 
@@ -454,27 +455,28 @@ EXPORT_SYMBOL(seq_path);
 int seq_path_root(struct seq_file *m, struct path *path, struct path *root,
 		  char *esc)
 {
-	int err = -ENAMETOOLONG;
-	if (m->count < m->size) {
-		char *s = m->buf + m->count;
+	char *buf;
+	size_t size = seq_get_buf(m, &buf);
+	int res = -ENAMETOOLONG;
+
+	if (size) {
 		char *p;
 
 		spin_lock(&dcache_lock);
-		p = __d_path(path, root, s, m->size - m->count);
+		p = __d_path(path, root, buf, size);
 		spin_unlock(&dcache_lock);
-		err = PTR_ERR(p);
+		res = PTR_ERR(p);
 		if (!IS_ERR(p)) {
-			s = mangle_path(s, p, esc);
-			if (s) {
-				p = m->buf + m->count;
-				m->count = s - m->buf;
-				return 0;
-			}
-			err = -ENAMETOOLONG;
+			char *end = mangle_path(buf, p, esc);
+			if (end)
+				res = end - buf;
+			else
+				res = -ENAMETOOLONG;
 		}
 	}
-	m->count = m->size;
-	return err;
+	seq_commit(m, res);
+
+	return res < 0 ? res : 0;
 }
 
 /*
@@ -482,20 +484,21 @@ int seq_path_root(struct seq_file *m, struct path *path, struct path *root,
  */
 int seq_dentry(struct seq_file *m, struct dentry *dentry, char *esc)
 {
-	if (m->count < m->size) {
-		char *s = m->buf + m->count;
-		char *p = dentry_path(dentry, s, m->size - m->count);
+	char *buf;
+	size_t size = seq_get_buf(m, &buf);
+	int res = -1;
+
+	if (size) {
+		char *p = dentry_path(dentry, buf, size);
 		if (!IS_ERR(p)) {
-			s = mangle_path(s, p, esc);
-			if (s) {
-				p = m->buf + m->count;
-				m->count = s - m->buf;
-				return s - p;
-			}
+			char *end = mangle_path(buf, p, esc);
+			if (end)
+				res = end - buf;
 		}
 	}
-	m->count = m->size;
-	return -1;
+	seq_commit(m, res);
+
+	return res;
 }
 
 int seq_bitmap(struct seq_file *m, const unsigned long *bits,

commit 7a62cc10215838286c747f86766063d5f01fcbd6
Author: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
Date:   Fri Sep 18 13:05:59 2009 -0700

    seq_file: return a negative error code when seq_path_root() fails.
    
    seq_path_root() is returning a return value of successful __d_path()
    instead of returning a negative value when mangle_path() failed.
    
    This is not a bug so far because nobody is using return value of
    seq_path_root().
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 6c959275f2d0..66efd0aa8fb3 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -470,6 +470,7 @@ int seq_path_root(struct seq_file *m, struct path *path, struct path *root,
 				m->count = s - m->buf;
 				return 0;
 			}
+			err = -ENAMETOOLONG;
 		}
 	}
 	m->count = m->size;

commit 0b923606e75f1ab672e25b14ac039a1cdcfa382f
Author: Peter Oberparleiter <oberpar@linux.vnet.ibm.com>
Date:   Wed Jun 17 16:28:05 2009 -0700

    seq_file: add function to write binary data
    
    seq_write() can be used to construct seq_files containing arbitrary data.
    Required by the gcov-profiling interface to synthesize binary profiling
    data files.
    
    Signed-off-by: Peter Oberparleiter <oberpar@linux.vnet.ibm.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Huang Ying <ying.huang@intel.com>
    Cc: Li Wei <W.Li@Sun.COM>
    Cc: Michael Ellerman <michaele@au1.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Heiko Carstens <heicars2@linux.vnet.ibm.com>
    Cc: Martin Schwidefsky <mschwid2@linux.vnet.ibm.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: WANG Cong <xiyou.wangcong@gmail.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 7f40f30c55c5..6c959275f2d0 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -640,6 +640,26 @@ int seq_puts(struct seq_file *m, const char *s)
 }
 EXPORT_SYMBOL(seq_puts);
 
+/**
+ * seq_write - write arbitrary data to buffer
+ * @seq: seq_file identifying the buffer to which data should be written
+ * @data: data address
+ * @len: number of bytes
+ *
+ * Return 0 on success, non-zero otherwise.
+ */
+int seq_write(struct seq_file *seq, const void *data, size_t len)
+{
+	if (seq->count + len < seq->size) {
+		memcpy(seq->buf + seq->count, data, len);
+		seq->count += len;
+		return 0;
+	}
+	seq->count = seq->size;
+	return -1;
+}
+EXPORT_SYMBOL(seq_write);
+
 struct list_head *seq_list_start(struct list_head *head, loff_t pos)
 {
 	struct list_head *lh;

commit af76aba00fdcfb21535c9f9872245d14097a4561
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Mar 30 22:05:11 2009 -0600

    cpumask: fix seq_bitmap_*() functions.
    
    1) seq_bitmap_list() should take a const.
    2) All the seq_bitmap should use cpumask_bits().
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index a1a4cfe19210..7f40f30c55c5 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -513,7 +513,7 @@ int seq_bitmap(struct seq_file *m, const unsigned long *bits,
 }
 EXPORT_SYMBOL(seq_bitmap);
 
-int seq_bitmap_list(struct seq_file *m, unsigned long *bits,
+int seq_bitmap_list(struct seq_file *m, const unsigned long *bits,
 		unsigned int nr_bits)
 {
 	if (m->count < m->size) {

commit 8f19d472935c83d823fa4cf02bcc0a7b9952db30
Author: Eric Biederman <ebiederm@xmission.com>
Date:   Wed Feb 18 14:48:16 2009 -0800

    seq_file: properly cope with pread
    
    Currently seq_read assumes that the offset passed to it is always the
    offset it passed to user space.  In the case pread this assumption is
    broken and we do the wrong thing when presented with pread.
    
    To solve this I introduce an offset cache inside of struct seq_file so we
    know where our logical file position is.  Then in seq_read if we try to
    read from another offset we reset our data structures and attempt to go to
    the offset user space wanted.
    
    [akpm@linux-foundation.org: restore FMODE_PWRITE]
    [pjt@google.com: seq_open needs its fmode opened up to take advantage of this]
    Signed-off-by: Eric Biederman <ebiederm@xmission.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Paul Turner <pjt@google.com>
    Cc: <stable@kernel.org>         [2.6.25.x, 2.6.26.x, 2.6.27.x, 2.6.28.x]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 5267098532bf..a1a4cfe19210 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -48,8 +48,16 @@ int seq_open(struct file *file, const struct seq_operations *op)
 	 */
 	file->f_version = 0;
 
-	/* SEQ files support lseek, but not pread/pwrite */
-	file->f_mode &= ~(FMODE_PREAD | FMODE_PWRITE);
+	/*
+	 * seq_files support lseek() and pread().  They do not implement
+	 * write() at all, but we clear FMODE_PWRITE here for historical
+	 * reasons.
+	 *
+	 * If a client of seq_files a) implements file.write() and b) wishes to
+	 * support pwrite() then that client will need to implement its own
+	 * file.open() which calls seq_open() and then sets FMODE_PWRITE.
+	 */
+	file->f_mode &= ~FMODE_PWRITE;
 	return 0;
 }
 EXPORT_SYMBOL(seq_open);
@@ -131,6 +139,22 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 	int err = 0;
 
 	mutex_lock(&m->lock);
+
+	/* Don't assume *ppos is where we left it */
+	if (unlikely(*ppos != m->read_pos)) {
+		m->read_pos = *ppos;
+		while ((err = traverse(m, *ppos)) == -EAGAIN)
+			;
+		if (err) {
+			/* With prejudice... */
+			m->read_pos = 0;
+			m->version = 0;
+			m->index = 0;
+			m->count = 0;
+			goto Done;
+		}
+	}
+
 	/*
 	 * seq_file->op->..m_start/m_stop/m_next may do special actions
 	 * or optimisations based on the file->f_version, so we want to
@@ -230,8 +254,10 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 Done:
 	if (!copied)
 		copied = err;
-	else
+	else {
 		*ppos += copied;
+		m->read_pos += copied;
+	}
 	file->f_version = m->version;
 	mutex_unlock(&m->lock);
 	return copied;
@@ -266,16 +292,18 @@ loff_t seq_lseek(struct file *file, loff_t offset, int origin)
 			if (offset < 0)
 				break;
 			retval = offset;
-			if (offset != file->f_pos) {
+			if (offset != m->read_pos) {
 				while ((retval=traverse(m, offset)) == -EAGAIN)
 					;
 				if (retval) {
 					/* with extreme prejudice... */
 					file->f_pos = 0;
+					m->read_pos = 0;
 					m->version = 0;
 					m->index = 0;
 					m->count = 0;
 				} else {
+					m->read_pos = offset;
 					retval = file->f_pos = offset;
 				}
 			}

commit f01d1d546abb2f4028b5299092f529eefb01253a
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Fri Feb 6 00:30:05 2009 +0300

    seq_file: fix big-enough lseek() + read()
    
    lseek() further than length of the file will leave stale ->index
    (second-to-last during iteration). Next seq_read() will not notice
    that ->f_pos is big enough to return 0, but will print last item
    as if ->f_pos is pointing to it.
    
    Introduced in commit cb510b8172602a66467f3551b4be1911f5a7c8c2
    aka "seq_file: more atomicity in traverse()".
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 2716c12eacf5..5267098532bf 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -102,6 +102,7 @@ static int traverse(struct seq_file *m, loff_t offset)
 		p = m->op->next(m, p, &index);
 	}
 	m->op->stop(m, p);
+	m->index = index;
 	return error;
 
 Eoverflow:

commit 33da8892a2f9e7d4b2d9a35fc80833ba2d2b1aa6
Author: Eric Biederman <ebiederm@xmission.com>
Date:   Wed Feb 4 15:12:25 2009 -0800

    seq_file: move traverse so it can be used from seq_read
    
    In 2.6.25 some /proc files were converted to use the seq_file
    infrastructure.  But seq_files do not correctly support pread(), which
    broke some usersapce applications.
    
    To handle pread correctly we can't assume that f_pos is where we left it
    in seq_read.  So move traverse() so that we can eventually use it in
    seq_read and do thus some day support pread().
    
    Signed-off-by: Eric Biederman <ebiederm@xmission.com>
    Cc: Paul Turner <pjt@google.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index b569ff1c4dc8..2716c12eacf5 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -54,6 +54,63 @@ int seq_open(struct file *file, const struct seq_operations *op)
 }
 EXPORT_SYMBOL(seq_open);
 
+static int traverse(struct seq_file *m, loff_t offset)
+{
+	loff_t pos = 0, index;
+	int error = 0;
+	void *p;
+
+	m->version = 0;
+	index = 0;
+	m->count = m->from = 0;
+	if (!offset) {
+		m->index = index;
+		return 0;
+	}
+	if (!m->buf) {
+		m->buf = kmalloc(m->size = PAGE_SIZE, GFP_KERNEL);
+		if (!m->buf)
+			return -ENOMEM;
+	}
+	p = m->op->start(m, &index);
+	while (p) {
+		error = PTR_ERR(p);
+		if (IS_ERR(p))
+			break;
+		error = m->op->show(m, p);
+		if (error < 0)
+			break;
+		if (unlikely(error)) {
+			error = 0;
+			m->count = 0;
+		}
+		if (m->count == m->size)
+			goto Eoverflow;
+		if (pos + m->count > offset) {
+			m->from = offset - pos;
+			m->count -= m->from;
+			m->index = index;
+			break;
+		}
+		pos += m->count;
+		m->count = 0;
+		if (pos == offset) {
+			index++;
+			m->index = index;
+			break;
+		}
+		p = m->op->next(m, p, &index);
+	}
+	m->op->stop(m, p);
+	return error;
+
+Eoverflow:
+	m->op->stop(m, p);
+	kfree(m->buf);
+	m->buf = kmalloc(m->size <<= 1, GFP_KERNEL);
+	return !m->buf ? -ENOMEM : -EAGAIN;
+}
+
 /**
  *	seq_read -	->read() method for sequential files.
  *	@file: the file to read from
@@ -186,63 +243,6 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 }
 EXPORT_SYMBOL(seq_read);
 
-static int traverse(struct seq_file *m, loff_t offset)
-{
-	loff_t pos = 0, index;
-	int error = 0;
-	void *p;
-
-	m->version = 0;
-	index = 0;
-	m->count = m->from = 0;
-	if (!offset) {
-		m->index = index;
-		return 0;
-	}
-	if (!m->buf) {
-		m->buf = kmalloc(m->size = PAGE_SIZE, GFP_KERNEL);
-		if (!m->buf)
-			return -ENOMEM;
-	}
-	p = m->op->start(m, &index);
-	while (p) {
-		error = PTR_ERR(p);
-		if (IS_ERR(p))
-			break;
-		error = m->op->show(m, p);
-		if (error < 0)
-			break;
-		if (unlikely(error)) {
-			error = 0;
-			m->count = 0;
-		}
-		if (m->count == m->size)
-			goto Eoverflow;
-		if (pos + m->count > offset) {
-			m->from = offset - pos;
-			m->count -= m->from;
-			m->index = index;
-			break;
-		}
-		pos += m->count;
-		m->count = 0;
-		if (pos == offset) {
-			index++;
-			m->index = index;
-			break;
-		}
-		p = m->op->next(m, p, &index);
-	}
-	m->op->stop(m, p);
-	return error;
-
-Eoverflow:
-	m->op->stop(m, p);
-	kfree(m->buf);
-	m->buf = kmalloc(m->size <<= 1, GFP_KERNEL);
-	return !m->buf ? -ENOMEM : -EAGAIN;
-}
-
 /**
  *	seq_lseek -	->llseek() method for sequential files.
  *	@file: the file in question

commit 7d3b56ba37a95f1f370f50258ed3954c304c524b
Merge: 269b012321f2 ab14398abd19
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 3 12:04:39 2009 -0800

    Merge branch 'cpus4096-for-linus-3' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'cpus4096-for-linus-3' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (77 commits)
      x86: setup_per_cpu_areas() cleanup
      cpumask: fix compile error when CONFIG_NR_CPUS is not defined
      cpumask: use alloc_cpumask_var_node where appropriate
      cpumask: convert shared_cpu_map in acpi_processor* structs to cpumask_var_t
      x86: use cpumask_var_t in acpi/boot.c
      x86: cleanup some remaining usages of NR_CPUS where s/b nr_cpu_ids
      sched: put back some stack hog changes that were undone in kernel/sched.c
      x86: enable cpus display of kernel_max and offlined cpus
      ia64: cpumask fix for is_affinity_mask_valid()
      cpumask: convert RCU implementations, fix
      xtensa: define __fls
      mn10300: define __fls
      m32r: define __fls
      h8300: define __fls
      frv: define __fls
      cris: define __fls
      cpumask: CONFIG_DISABLE_OBSOLETE_CPUMASK_FUNCTIONS
      cpumask: zero extra bits in alloc_cpumask_var_node
      cpumask: replace for_each_cpu_mask_nr with for_each_cpu in kernel/time/
      cpumask: convert mm/
      ...

commit 52afeefb9dac9287429642189996426a2bfd6a25
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Mon Dec 1 14:35:00 2008 -0800

    expand some comments (d_path / seq_path)
    
    Explain that you really need to use the return value of d_path rather than
    the buffer you passed into it.
    
    Also fix the comment for seq_path(), the function arguments changed
    recently but the comment hadn't been updated in sync.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 16c211558c22..99d8b8cfc9b7 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -389,8 +389,14 @@ char *mangle_path(char *s, char *p, char *esc)
 }
 EXPORT_SYMBOL(mangle_path);
 
-/*
- * return the absolute path of 'dentry' residing in mount 'mnt'.
+/**
+ * seq_path - seq_file interface to print a pathname
+ * @m: the seq_file handle
+ * @path: the struct path to print
+ * @esc: set of characters to escape in the output
+ *
+ * return the absolute path of 'path', as represented by the
+ * dentry / mnt pair in the path parameter.
  */
 int seq_path(struct seq_file *m, struct path *path, char *esc)
 {

commit cb78a0ce69fad2026825f957e24e2d9cda1ec9f1
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Tue Dec 30 09:05:14 2008 +1030

    bitmap: fix seq_bitmap and seq_cpumask to take const pointer
    
    Impact: cleanup
    
    seq_bitmap just calls bitmap_scnprintf on the bits: that arg can be const.
    Similarly, seq_cpumask just calls seq_bitmap.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 16c211558c22..c99358a52176 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -462,7 +462,8 @@ int seq_dentry(struct seq_file *m, struct dentry *dentry, char *esc)
 	return -1;
 }
 
-int seq_bitmap(struct seq_file *m, unsigned long *bits, unsigned int nr_bits)
+int seq_bitmap(struct seq_file *m, const unsigned long *bits,
+				   unsigned int nr_bits)
 {
 	if (m->count < m->size) {
 		int len = bitmap_scnprintf(m->buf + m->count,

commit 604094f4615180f71da799e7e5b191f5c2a42a28
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Nov 28 18:03:22 2008 +0100

    vfs, seqfile: export mangle_path() generally
    
    mangle_path() is trivial enough to make  export restrictions on it
    pointless - so change the export from EXPORT_SYMBOL_GPL to EXPORT_SYMBOL.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Al Viro <viro@ZenIV.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index f03220d7891b..16c211558c22 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -387,7 +387,7 @@ char *mangle_path(char *s, char *p, char *esc)
 	}
 	return NULL;
 }
-EXPORT_SYMBOL_GPL(mangle_path);
+EXPORT_SYMBOL(mangle_path);
 
 /*
  * return the absolute path of 'dentry' residing in mount 'mnt'.

commit 958086d1784459be3fe85e4cad79d42b17d33381
Author: Török Edwin <edwintorok@gmail.com>
Date:   Sun Nov 23 23:24:53 2008 +0200

    vfs, seqfile: fix comment style on mangle_path
    
    Impact: use standard docbook tags
    
    Reported-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Török Edwin <edwintorok@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index f5b61cc1cc1a..f03220d7891b 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -358,10 +358,10 @@ int seq_printf(struct seq_file *m, const char *f, ...)
 EXPORT_SYMBOL(seq_printf);
 
 /**
- * 	mangle_path - mangle and copy path to buffer beginning
- * 	@s - buffer start
- * 	@p - beginning of path in above buffer
- *      @esc - set of characters that need escaping
+ *	mangle_path -	mangle and copy path to buffer beginning
+ *	@s: buffer start
+ *	@p: beginning of path in above buffer
+ *	@esc: set of characters that need escaping
  *
  *      Copy the path from @p to @s, replacing each occurrence of character from
  *      @esc with usual octal escape.

commit 74e2f334f4440cbcb63e9ebbcdcea430d41bdfa3
Author: Török Edwin <edwintorok@gmail.com>
Date:   Sat Nov 22 13:28:48 2008 +0200

    vfs, seqfile: make mangle_path() global
    
    Impact: expose new VFS API
    
    make mangle_path() available, as per the suggestions of Christoph Hellwig
    and Al Viro:
    
      http://lkml.org/lkml/2008/11/4/338
    
    Signed-off-by: Török Edwin <edwintorok@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index eba2eabcd2b8..f5b61cc1cc1a 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -357,7 +357,18 @@ int seq_printf(struct seq_file *m, const char *f, ...)
 }
 EXPORT_SYMBOL(seq_printf);
 
-static char *mangle_path(char *s, char *p, char *esc)
+/**
+ * 	mangle_path - mangle and copy path to buffer beginning
+ * 	@s - buffer start
+ * 	@p - beginning of path in above buffer
+ *      @esc - set of characters that need escaping
+ *
+ *      Copy the path from @p to @s, replacing each occurrence of character from
+ *      @esc with usual octal escape.
+ *      Returns pointer past last written character in @s, or NULL in case of
+ *      failure.
+ */
+char *mangle_path(char *s, char *p, char *esc)
 {
 	while (s <= p) {
 		char c = *p++;
@@ -376,6 +387,7 @@ static char *mangle_path(char *s, char *p, char *esc)
 	}
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(mangle_path);
 
 /*
  * return the absolute path of 'dentry' residing in mount 'mnt'.

commit 3eda20118000941e7e8994fc5fac8706d8c10f00
Author: Lai Jiangshan <laijs@cn.fujitsu.com>
Date:   Sat Oct 18 20:28:19 2008 -0700

    seq_file: add seq_cpumask_list(), seq_nodemask_list()
    
    seq_cpumask_list(), seq_nodemask_list() are very like seq_cpumask(),
    seq_nodemask(), but they print human readable string.
    
    Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Paul Menage <menage@google.com>
    Cc: Paul Jackson <pj@sgi.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 11c85fec6b4f..eba2eabcd2b8 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -465,6 +465,22 @@ int seq_bitmap(struct seq_file *m, unsigned long *bits, unsigned int nr_bits)
 }
 EXPORT_SYMBOL(seq_bitmap);
 
+int seq_bitmap_list(struct seq_file *m, unsigned long *bits,
+		unsigned int nr_bits)
+{
+	if (m->count < m->size) {
+		int len = bitmap_scnlistprintf(m->buf + m->count,
+				m->size - m->count, bits, nr_bits);
+		if (m->count + len < m->size) {
+			m->count += len;
+			return 0;
+		}
+	}
+	m->count = m->size;
+	return -1;
+}
+EXPORT_SYMBOL(seq_bitmap_list);
+
 static void *single_start(struct seq_file *p, loff_t *pos)
 {
 	return NULL + (*pos == 0);

commit 85dd030edb174376ef43bc95e5fae4755af1ec98
Author: Lai Jiangshan <laijs@cn.fujitsu.com>
Date:   Sat Oct 18 20:28:18 2008 -0700

    seq_file: don't call bitmap_scnprintf_len()
    
    "m->count + len < m->size" is true commonly, so bitmap_scnprintf()
    is commonly called. this fix saves a call to bitmap_scnprintf_len().
    
    Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Paul Menage <menage@google.com>
    Cc: Paul Jackson <pj@sgi.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index bd20f7f5a933..11c85fec6b4f 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -452,17 +452,18 @@ int seq_dentry(struct seq_file *m, struct dentry *dentry, char *esc)
 
 int seq_bitmap(struct seq_file *m, unsigned long *bits, unsigned int nr_bits)
 {
-	size_t len = bitmap_scnprintf_len(nr_bits);
-
-	if (m->count + len < m->size) {
-		bitmap_scnprintf(m->buf + m->count, m->size - m->count,
-				 bits, nr_bits);
-		m->count += len;
-		return 0;
+	if (m->count < m->size) {
+		int len = bitmap_scnprintf(m->buf + m->count,
+				m->size - m->count, bits, nr_bits);
+		if (m->count + len < m->size) {
+			m->count += len;
+			return 0;
+		}
 	}
 	m->count = m->size;
 	return -1;
 }
+EXPORT_SYMBOL(seq_bitmap);
 
 static void *single_start(struct seq_file *p, loff_t *pos)
 {

commit 4cdfe84b51420c9ac95c7133da2d4c8a191094af
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Aug 24 07:45:33 2008 -0400

    [PATCH] deal with the first call of ->show() generating no output
    
    seq_read() has a subtle bug - we want the first loop there to go
    until at least one *non-empty* record had fit entirely into buffer.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 5d54205e486b..bd20f7f5a933 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -108,9 +108,9 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 			goto Done;
 	}
 	/* we need at least one record in buffer */
+	pos = m->index;
+	p = m->op->start(m, &pos);
 	while (1) {
-		pos = m->index;
-		p = m->op->start(m, &pos);
 		err = PTR_ERR(p);
 		if (!p || IS_ERR(p))
 			break;
@@ -119,6 +119,11 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 			break;
 		if (unlikely(err))
 			m->count = 0;
+		if (unlikely(!m->count)) {
+			p = m->op->next(m, p, &pos);
+			m->index = pos;
+			continue;
+		}
 		if (m->count < m->size)
 			goto Fill;
 		m->op->stop(m, p);
@@ -128,6 +133,8 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 			goto Enomem;
 		m->count = 0;
 		m->version = 0;
+		pos = m->index;
+		p = m->op->start(m, &pos);
 	}
 	m->op->stop(m, p);
 	m->count = 0;

commit 50ac2d694f2dd1658341cf97bcf2ffb836d772cb
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Aug 12 15:09:02 2008 -0700

    seq_file: add seq_cpumask(), seq_nodemask()
    
    Short enough reads from /proc/irq/*/smp_affinity return -EINVAL for no
    good reason.
    
    This became noticed with NR_CPUS=4096 patches, when length of printed
    representation of cpumask becase 1152, but cat(1) continued to read with
    1024-byte chunks.  bitmap_scnprintf() in good faith fills buffer, returns
    1023, check returns -EINVAL.
    
    Fix it by switching to seq_file, so handler will just fill buffer and
    doesn't care about offsets, length, filling EOF and all this crap.
    
    For that add seq_bitmap(), and wrappers around it -- seq_cpumask() and
    seq_nodemask().
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Reviewed-by: Paul Jackson <pj@sgi.com>
    Cc: Mike Travis <travis@sgi.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 3f54dbd6c49b..5d54205e486b 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -443,6 +443,20 @@ int seq_dentry(struct seq_file *m, struct dentry *dentry, char *esc)
 	return -1;
 }
 
+int seq_bitmap(struct seq_file *m, unsigned long *bits, unsigned int nr_bits)
+{
+	size_t len = bitmap_scnprintf_len(nr_bits);
+
+	if (m->count + len < m->size) {
+		bitmap_scnprintf(m->buf + m->count, m->size - m->count,
+				 bits, nr_bits);
+		m->count += len;
+		return 0;
+	}
+	m->count = m->size;
+	return -1;
+}
+
 static void *single_start(struct seq_file *p, loff_t *pos)
 {
 	return NULL + (*pos == 0);

commit 9d1bc60138977d9c79471b344a64f2df13b2ccef
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Thu Mar 27 13:06:21 2008 +0100

    [patch 2/7] vfs: mountinfo: add seq_file_root()
    
    Add a new function:
    
      seq_file_root()
    
    This is similar to seq_path(), but calculates the path relative to the
    given root, instead of current->fs->root.  If the path was unreachable
    from root, then modify the root parameter to reflect this.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index ae59f5a6c5c1..3f54dbd6c49b 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -392,6 +392,36 @@ int seq_path(struct seq_file *m, struct path *path, char *esc)
 }
 EXPORT_SYMBOL(seq_path);
 
+/*
+ * Same as seq_path, but relative to supplied root.
+ *
+ * root may be changed, see __d_path().
+ */
+int seq_path_root(struct seq_file *m, struct path *path, struct path *root,
+		  char *esc)
+{
+	int err = -ENAMETOOLONG;
+	if (m->count < m->size) {
+		char *s = m->buf + m->count;
+		char *p;
+
+		spin_lock(&dcache_lock);
+		p = __d_path(path, root, s, m->size - m->count);
+		spin_unlock(&dcache_lock);
+		err = PTR_ERR(p);
+		if (!IS_ERR(p)) {
+			s = mangle_path(s, p, esc);
+			if (s) {
+				p = m->buf + m->count;
+				m->count = s - m->buf;
+				return 0;
+			}
+		}
+	}
+	m->count = m->size;
+	return err;
+}
+
 /*
  * returns the path of the 'dentry' from the root of its filesystem.
  */

commit 6092d048183b76bfa3f84b32f8158dd8d10bd811
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Thu Mar 27 13:06:20 2008 +0100

    [patch 1/7] vfs: mountinfo: add dentry_path()
    
    [mszeredi@suse.cz] split big patch into managable chunks
    
    Add the following functions:
    
      dentry_path()
      seq_dentry()
    
    These are similar to d_path() and seq_path().  But instead of
    calculating the path within a mount namespace, they calculate the path
    from the root of the filesystem to a given dentry, ignoring mounts
    completely.
    
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index cdfd996ca6ef..ae59f5a6c5c1 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -350,28 +350,40 @@ int seq_printf(struct seq_file *m, const char *f, ...)
 }
 EXPORT_SYMBOL(seq_printf);
 
+static char *mangle_path(char *s, char *p, char *esc)
+{
+	while (s <= p) {
+		char c = *p++;
+		if (!c) {
+			return s;
+		} else if (!strchr(esc, c)) {
+			*s++ = c;
+		} else if (s + 4 > p) {
+			break;
+		} else {
+			*s++ = '\\';
+			*s++ = '0' + ((c & 0300) >> 6);
+			*s++ = '0' + ((c & 070) >> 3);
+			*s++ = '0' + (c & 07);
+		}
+	}
+	return NULL;
+}
+
+/*
+ * return the absolute path of 'dentry' residing in mount 'mnt'.
+ */
 int seq_path(struct seq_file *m, struct path *path, char *esc)
 {
 	if (m->count < m->size) {
 		char *s = m->buf + m->count;
 		char *p = d_path(path, s, m->size - m->count);
 		if (!IS_ERR(p)) {
-			while (s <= p) {
-				char c = *p++;
-				if (!c) {
-					p = m->buf + m->count;
-					m->count = s - m->buf;
-					return s - p;
-				} else if (!strchr(esc, c)) {
-					*s++ = c;
-				} else if (s + 4 > p) {
-					break;
-				} else {
-					*s++ = '\\';
-					*s++ = '0' + ((c & 0300) >> 6);
-					*s++ = '0' + ((c & 070) >> 3);
-					*s++ = '0' + (c & 07);
-				}
+			s = mangle_path(s, p, esc);
+			if (s) {
+				p = m->buf + m->count;
+				m->count = s - m->buf;
+				return s - p;
 			}
 		}
 	}
@@ -380,6 +392,27 @@ int seq_path(struct seq_file *m, struct path *path, char *esc)
 }
 EXPORT_SYMBOL(seq_path);
 
+/*
+ * returns the path of the 'dentry' from the root of its filesystem.
+ */
+int seq_dentry(struct seq_file *m, struct dentry *dentry, char *esc)
+{
+	if (m->count < m->size) {
+		char *s = m->buf + m->count;
+		char *p = dentry_path(dentry, s, m->size - m->count);
+		if (!IS_ERR(p)) {
+			s = mangle_path(s, p, esc);
+			if (s) {
+				p = m->buf + m->count;
+				m->count = s - m->buf;
+				return s - p;
+			}
+		}
+	}
+	m->count = m->size;
+	return -1;
+}
+
 static void *single_start(struct seq_file *p, loff_t *pos)
 {
 	return NULL + (*pos == 0);

commit 94bc891b00e40cbec375feb4568780af183fd7f4
Merge: 934b7024f0ed 1ec7f1ddbe5b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 22 18:27:56 2008 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6:
      [PATCH] get rid of __exit_files(), __exit_fs() and __put_fs_struct()
      [PATCH] proc_readfd_common() race fix
      [PATCH] double-free of inode on alloc_file() failure exit in create_write_pipe()
      [PATCH] teach seq_file to discard entries
      [PATCH] umount_tree() will unhash everything itself
      [PATCH] get rid of more nameidata passing in namespace.c
      [PATCH] switch a bunch of LSM hooks from nameidata to path
      [PATCH] lock exclusively in collect_mounts() and drop_collected_mounts()
      [PATCH] move a bunch of declarations to fs/internal.h

commit 16abef0e9e79643827fd5a2a14a07bced851ae72
Author: David Sterba <dsterba@suse.cz>
Date:   Tue Apr 22 15:09:22 2008 +0200

    fs: use loff_t type instead of long long
    
    Use offset type consistently.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 853770274f20..9943408b315e 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -239,7 +239,7 @@ static int traverse(struct seq_file *m, loff_t offset)
 loff_t seq_lseek(struct file *file, loff_t offset, int origin)
 {
 	struct seq_file *m = (struct seq_file *)file->private_data;
-	long long retval = -EINVAL;
+	loff_t retval = -EINVAL;
 
 	mutex_lock(&m->lock);
 	m->version = file->f_version;

commit 521b5d0c40386f4a9805cdec7bd979fc96a86aeb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 28 00:46:41 2008 -0400

    [PATCH] teach seq_file to discard entries
    
    Allow ->show() return SEQ_SKIP; that will discard all
    output from that element and move on.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 853770274f20..bf2bcfd4bcfb 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -25,6 +25,7 @@
  *	into the buffer.  In case of error ->start() and ->next() return
  *	ERR_PTR(error).  In the end of sequence they return %NULL. ->show()
  *	returns 0 in case of success and negative number in case of error.
+ *	Returning SEQ_SKIP means "discard this element and move on".
  */
 int seq_open(struct file *file, const struct seq_operations *op)
 {
@@ -114,8 +115,10 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 		if (!p || IS_ERR(p))
 			break;
 		err = m->op->show(m, p);
-		if (err)
+		if (err < 0)
 			break;
+		if (unlikely(err))
+			m->count = 0;
 		if (m->count < m->size)
 			goto Fill;
 		m->op->stop(m, p);
@@ -140,9 +143,10 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 			break;
 		}
 		err = m->op->show(m, p);
-		if (err || m->count == m->size) {
+		if (m->count == m->size || err) {
 			m->count = offs;
-			break;
+			if (likely(err <= 0))
+				break;
 		}
 		pos = next;
 	}
@@ -199,8 +203,12 @@ static int traverse(struct seq_file *m, loff_t offset)
 		if (IS_ERR(p))
 			break;
 		error = m->op->show(m, p);
-		if (error)
+		if (error < 0)
 			break;
+		if (unlikely(error)) {
+			error = 0;
+			m->count = 0;
+		}
 		if (m->count == m->size)
 			goto Eoverflow;
 		if (pos + m->count > offset) {

commit cf28b4863f9ee8f122e8ff3ac0d403e07ba9c6d9
Author: Jan Blunck <jblunck@suse.de>
Date:   Thu Feb 14 19:38:44 2008 -0800

    d_path: Make d_path() use a struct path
    
    d_path() is used on a <dentry,vfsmount> pair.  Lets use a struct path to
    reflect this.
    
    [akpm@linux-foundation.org: fix build in mm/memory.c]
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Acked-by: Bryan Wu <bryan.wu@analog.com>
    Acked-by: Christoph Hellwig <hch@infradead.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Michael Halcrow <mhalcrow@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 8d862907f060..853770274f20 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -346,8 +346,7 @@ int seq_path(struct seq_file *m, struct path *path, char *esc)
 {
 	if (m->count < m->size) {
 		char *s = m->buf + m->count;
-		char *p = d_path(path->dentry, path->mnt, s,
-				 m->size - m->count);
+		char *p = d_path(path, s, m->size - m->count);
 		if (!IS_ERR(p)) {
 			while (s <= p) {
 				char c = *p++;

commit c32c2f63a9d6c953aaf168c0b2551da9734f76d2
Author: Jan Blunck <jblunck@suse.de>
Date:   Thu Feb 14 19:38:43 2008 -0800

    d_path: Make seq_path() use a struct path argument
    
    seq_path() is always called with a dentry and a vfsmount from a struct path.
    Make seq_path() take it directly as an argument.
    
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index ca71c115bdaa..8d862907f060 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -342,13 +342,12 @@ int seq_printf(struct seq_file *m, const char *f, ...)
 }
 EXPORT_SYMBOL(seq_printf);
 
-int seq_path(struct seq_file *m,
-	     struct vfsmount *mnt, struct dentry *dentry,
-	     char *esc)
+int seq_path(struct seq_file *m, struct path *path, char *esc)
 {
 	if (m->count < m->size) {
 		char *s = m->buf + m->count;
-		char *p = d_path(dentry, mnt, s, m->size - m->count);
+		char *p = d_path(path->dentry, path->mnt, s,
+				 m->size - m->count);
 		if (!IS_ERR(p)) {
 			while (s <= p) {
 				char c = *p++;

commit 39699037a5c94d7cd1363dfe48a50c78c643fd9a
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Wed Oct 10 02:28:42 2007 -0700

    [FS] seq_file: Introduce the seq_open_private()
    
    This function allocates the zeroed chunk of memory and
    call seq_open(). The __seq_open_private() helper returns
    the allocated memory to make it possible for the caller
    to initialize it.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index bbb19be260ce..ca71c115bdaa 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -429,6 +429,39 @@ int seq_release_private(struct inode *inode, struct file *file)
 }
 EXPORT_SYMBOL(seq_release_private);
 
+void *__seq_open_private(struct file *f, const struct seq_operations *ops,
+		int psize)
+{
+	int rc;
+	void *private;
+	struct seq_file *seq;
+
+	private = kzalloc(psize, GFP_KERNEL);
+	if (private == NULL)
+		goto out;
+
+	rc = seq_open(f, ops);
+	if (rc < 0)
+		goto out_free;
+
+	seq = f->private_data;
+	seq->private = private;
+	return private;
+
+out_free:
+	kfree(private);
+out:
+	return NULL;
+}
+EXPORT_SYMBOL(__seq_open_private);
+
+int seq_open_private(struct file *filp, const struct seq_operations *ops,
+		int psize)
+{
+	return __seq_open_private(filp, ops, psize) ? 0 : -ENOMEM;
+}
+EXPORT_SYMBOL(seq_open_private);
+
 int seq_putc(struct seq_file *m, char c)
 {
 	if (m->count < m->size) {

commit cb510b8172602a66467f3551b4be1911f5a7c8c2
Author: Alexey Dobriyan <adobriyan@sw.ru>
Date:   Sun Jul 15 23:40:39 2007 -0700

    seq_file: more atomicity in traverse()
    
    Original problem: in some circumstances seq_file interface can present
    infinite proc file to the following script when normally said proc file is
    finite:
    
            while read line; do
                    [do something with $line]
            done </proc/$FILE
    
    bash, to implement such loop does essentially
    
            read(0, buf, 128);
            [find \n]
            lseek(0, -difference, SEEK_CUR);
    
    Consider, proc file prints list of objects each of them consists of many
    lines, each line is shorter than 128 bytes.
    
    Two objects in list, with ->index'es being 0 and 1.  Current one is 1, as
    bash prints second object line by line.
    
    Imagine first object being removed right before lseek().
    traverse() will be called, because there is negative offset.
    traverse() will reset ->index to 0 (!).
    traverse() will call ->next() and get NULL in any usual iterate-over-list
    code using list_for_each_entry_continue() and such. There is one object in
    list now after all...
    traverse() will return 0, lseek() will update file position and pretend
    everything is OK.
    
    So, what we have now: ->f_pos points to place where second object will be
    printed, but ->index is 0.  seq_read() instead of returning EOF, will start
    printing first line of first object every time it's called, until enough
    objects are added to ->f_pos return in bounds.
    
    Fix is to update ->index only after we're sure we saw enough objects down
    the road.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index e8e51db4989d..bbb19be260ce 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -177,21 +177,23 @@ EXPORT_SYMBOL(seq_read);
 
 static int traverse(struct seq_file *m, loff_t offset)
 {
-	loff_t pos = 0;
+	loff_t pos = 0, index;
 	int error = 0;
 	void *p;
 
 	m->version = 0;
-	m->index = 0;
+	index = 0;
 	m->count = m->from = 0;
-	if (!offset)
+	if (!offset) {
+		m->index = index;
 		return 0;
+	}
 	if (!m->buf) {
 		m->buf = kmalloc(m->size = PAGE_SIZE, GFP_KERNEL);
 		if (!m->buf)
 			return -ENOMEM;
 	}
-	p = m->op->start(m, &m->index);
+	p = m->op->start(m, &index);
 	while (p) {
 		error = PTR_ERR(p);
 		if (IS_ERR(p))
@@ -204,15 +206,17 @@ static int traverse(struct seq_file *m, loff_t offset)
 		if (pos + m->count > offset) {
 			m->from = offset - pos;
 			m->count -= m->from;
+			m->index = index;
 			break;
 		}
 		pos += m->count;
 		m->count = 0;
 		if (pos == offset) {
-			m->index++;
+			index++;
+			m->index = index;
 			break;
 		}
-		p = m->op->next(m, p, &m->index);
+		p = m->op->next(m, p, &index);
 	}
 	m->op->stop(m, p);
 	return error;

commit 00c5746da9fc6a793b9d94a8001ded5929f3a773
Author: Alexey Dobriyan <adobriyan@sw.ru>
Date:   Sun Jul 15 23:40:22 2007 -0700

    mutex_unlock() later in seq_lseek()
    
    All manipulations with struct seq_file::version are done under
    struct seq_file::lock except one introduced in commit
    d6b7a781c51c91dd054e5c437885205592faac21
    aka "[PATCH] Speed up /proc/pid/maps"
    
    Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 49194a4e6b91..e8e51db4989d 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -260,8 +260,8 @@ loff_t seq_lseek(struct file *file, loff_t offset, int origin)
 				}
 			}
 	}
-	mutex_unlock(&m->lock);
 	file->f_version = m->version;
+	mutex_unlock(&m->lock);
 	return retval;
 }
 EXPORT_SYMBOL(seq_lseek);

commit bcf67e16251c42302499499b1c50f7d35622f564
Author: Pavel Emelianov <xemul@sw.ru>
Date:   Tue Jul 10 17:22:26 2007 -0700

    Make common helpers for seq_files that work with list_heads
    
    Many places in kernel use seq_file API to iterate over a regular list_head.
    The code for such iteration is identical in all the places, so it's worth
    introducing a common helpers.
    
    This makes code about 300 lines smaller:
    
    The first version of this patch made the helper functions static inline
    in the seq_file.h header. This patch moves them to the fs/seq_file.c as
    Andrew proposed. The vmlinux .text section sizes are as follows:
    
    2.6.22-rc1-mm1:              0x001794d5
    with the previous version:   0x00179505
    with this patch:             0x00179135
    
    The config file used was make allnoconfig with the "y" inclusion of all
    the possible options to make the files modified by the patch compile plus
    drivers I have on the test node.
    
    This patch:
    
    Many places in kernel use seq_file API to iterate over a regular list_head.
    The code for such iteration is identical in all the places, so it's worth
    introducing a common helpers.
    
    Signed-off-by: Pavel Emelianov <xemul@openvz.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 0ac22af7afe5..49194a4e6b91 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -447,3 +447,37 @@ int seq_puts(struct seq_file *m, const char *s)
 	return -1;
 }
 EXPORT_SYMBOL(seq_puts);
+
+struct list_head *seq_list_start(struct list_head *head, loff_t pos)
+{
+	struct list_head *lh;
+
+	list_for_each(lh, head)
+		if (pos-- == 0)
+			return lh;
+
+	return NULL;
+}
+
+EXPORT_SYMBOL(seq_list_start);
+
+struct list_head *seq_list_start_head(struct list_head *head, loff_t pos)
+{
+	if (!pos)
+		return head;
+
+	return seq_list_start(head, pos - 1);
+}
+
+EXPORT_SYMBOL(seq_list_start_head);
+
+struct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)
+{
+	struct list_head *lh;
+
+	lh = ((struct list_head *)v)->next;
+	++*ppos;
+	return lh == head ? NULL : lh;
+}
+
+EXPORT_SYMBOL(seq_list_next);

commit 0f7fc9e4d03987fe29f6dd4aa67e4c56eb7ecb05
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Fri Dec 8 02:36:35 2006 -0800

    [PATCH] VFS: change struct file to use struct path
    
    This patch changes struct file to use struct path instead of having
    independent pointers to struct dentry and struct vfsmount, and converts all
    users of f_{dentry,vfsmnt} in fs/ to use f_path.{dentry,mnt}.
    
    Additionally, it adds two #define's to make the transition easier for users of
    the f_dentry and f_vfsmnt.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 10690aa401c7..0ac22af7afe5 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -269,7 +269,7 @@ EXPORT_SYMBOL(seq_lseek);
 /**
  *	seq_release -	free the structures associated with sequential file.
  *	@file: file in question
- *	@inode: file->f_dentry->d_inode
+ *	@inode: file->f_path.dentry->d_inode
  *
  *	Frees the structures associated with sequential file; can be used
  *	as ->f_op->release() if you don't have private data to destroy.

commit 15ad7cdcfd76450d4beebc789ec646664238184d
Author: Helge Deller <deller@gmx.de>
Date:   Wed Dec 6 20:40:36 2006 -0800

    [PATCH] struct seq_operations and struct file_operations constification
    
     - move some file_operations structs into the .rodata section
    
     - move static strings from policy_types[] array into the .rodata section
    
     - fix generic seq_operations usages, so that those structs may be defined
       as "const" as well
    
    [akpm@osdl.org: couple of fixes]
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 555b9ac04c25..10690aa401c7 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -26,7 +26,7 @@
  *	ERR_PTR(error).  In the end of sequence they return %NULL. ->show()
  *	returns 0 in case of success and negative number in case of error.
  */
-int seq_open(struct file *file, struct seq_operations *op)
+int seq_open(struct file *file, const struct seq_operations *op)
 {
 	struct seq_file *p = file->private_data;
 
@@ -408,7 +408,7 @@ EXPORT_SYMBOL(single_open);
 
 int single_release(struct inode *inode, struct file *file)
 {
-	struct seq_operations *op = ((struct seq_file *)file->private_data)->op;
+	const struct seq_operations *op = ((struct seq_file *)file->private_data)->op;
 	int res = seq_release(inode, file);
 	kfree(op);
 	return res;

commit 0ac1759abc69fb62438c30a7e422f628a1120d67
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Mar 23 03:00:37 2006 -0800

    [PATCH] sem2mutex: fs/seq_file.c
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 7c40570b71dc..555b9ac04c25 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -37,7 +37,7 @@ int seq_open(struct file *file, struct seq_operations *op)
 		file->private_data = p;
 	}
 	memset(p, 0, sizeof(*p));
-	sema_init(&p->sem, 1);
+	mutex_init(&p->lock);
 	p->op = op;
 
 	/*
@@ -71,7 +71,7 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 	void *p;
 	int err = 0;
 
-	down(&m->sem);
+	mutex_lock(&m->lock);
 	/*
 	 * seq_file->op->..m_start/m_stop/m_next may do special actions
 	 * or optimisations based on the file->f_version, so we want to
@@ -164,7 +164,7 @@ ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 	else
 		*ppos += copied;
 	file->f_version = m->version;
-	up(&m->sem);
+	mutex_unlock(&m->lock);
 	return copied;
 Enomem:
 	err = -ENOMEM;
@@ -237,7 +237,7 @@ loff_t seq_lseek(struct file *file, loff_t offset, int origin)
 	struct seq_file *m = (struct seq_file *)file->private_data;
 	long long retval = -EINVAL;
 
-	down(&m->sem);
+	mutex_lock(&m->lock);
 	m->version = file->f_version;
 	switch (origin) {
 		case 1:
@@ -260,7 +260,7 @@ loff_t seq_lseek(struct file *file, loff_t offset, int origin)
 				}
 			}
 	}
-	up(&m->sem);
+	mutex_unlock(&m->lock);
 	file->f_version = m->version;
 	return retval;
 }

commit 1abe77b0fc4b485927f1f798ae81a752677e1d05
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 7 17:15:34 2005 -0500

    [PATCH] allow callers of seq_open do allocation themselves
    
    Allow caller of seq_open() to kmalloc() seq_file + whatever else they
    want and set ->private_data to it.  seq_open() will then abstain from
    doing allocation itself.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 38ef913767ff..7c40570b71dc 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -28,13 +28,17 @@
  */
 int seq_open(struct file *file, struct seq_operations *op)
 {
-	struct seq_file *p = kmalloc(sizeof(*p), GFP_KERNEL);
-	if (!p)
-		return -ENOMEM;
+	struct seq_file *p = file->private_data;
+
+	if (!p) {
+		p = kmalloc(sizeof(*p), GFP_KERNEL);
+		if (!p)
+			return -ENOMEM;
+		file->private_data = p;
+	}
 	memset(p, 0, sizeof(*p));
 	sema_init(&p->sem, 1);
 	p->op = op;
-	file->private_data = p;
 
 	/*
 	 * Wrappers around seq_open(e.g. swaps_open) need to be

commit 67be2dd1bace0ec7ce2dbc1bba3f8df3d7be597e
Author: Martin Waitz <tali@admingilde.org>
Date:   Sun May 1 08:59:26 2005 -0700

    [PATCH] DocBook: fix some descriptions
    
    Some KernelDoc descriptions are updated to match the current code.
    No code changes.
    
    Signed-off-by: Martin Waitz <tali@admingilde.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/seq_file.c b/fs/seq_file.c
index 650c43ba86c4..38ef913767ff 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -51,7 +51,10 @@ EXPORT_SYMBOL(seq_open);
 
 /**
  *	seq_read -	->read() method for sequential files.
- *	@file, @buf, @size, @ppos: see file_operations method
+ *	@file: the file to read from
+ *	@buf: the buffer to read to
+ *	@size: the maximum number of bytes to read
+ *	@ppos: the current position in the file
  *
  *	Ready-made ->f_op->read()
  */
@@ -219,7 +222,9 @@ static int traverse(struct seq_file *m, loff_t offset)
 
 /**
  *	seq_lseek -	->llseek() method for sequential files.
- *	@file, @offset, @origin: see file_operations method
+ *	@file: the file in question
+ *	@offset: new position
+ *	@origin: 0 for absolute, 1 for relative position
  *
  *	Ready-made ->f_op->llseek()
  */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/fs/seq_file.c b/fs/seq_file.c
new file mode 100644
index 000000000000..650c43ba86c4
--- /dev/null
+++ b/fs/seq_file.c
@@ -0,0 +1,440 @@
+/*
+ * linux/fs/seq_file.c
+ *
+ * helper functions for making synthetic files from sequences of records.
+ * initial implementation -- AV, Oct 2001.
+ */
+
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+
+#include <asm/uaccess.h>
+#include <asm/page.h>
+
+/**
+ *	seq_open -	initialize sequential file
+ *	@file: file we initialize
+ *	@op: method table describing the sequence
+ *
+ *	seq_open() sets @file, associating it with a sequence described
+ *	by @op.  @op->start() sets the iterator up and returns the first
+ *	element of sequence. @op->stop() shuts it down.  @op->next()
+ *	returns the next element of sequence.  @op->show() prints element
+ *	into the buffer.  In case of error ->start() and ->next() return
+ *	ERR_PTR(error).  In the end of sequence they return %NULL. ->show()
+ *	returns 0 in case of success and negative number in case of error.
+ */
+int seq_open(struct file *file, struct seq_operations *op)
+{
+	struct seq_file *p = kmalloc(sizeof(*p), GFP_KERNEL);
+	if (!p)
+		return -ENOMEM;
+	memset(p, 0, sizeof(*p));
+	sema_init(&p->sem, 1);
+	p->op = op;
+	file->private_data = p;
+
+	/*
+	 * Wrappers around seq_open(e.g. swaps_open) need to be
+	 * aware of this. If they set f_version themselves, they
+	 * should call seq_open first and then set f_version.
+	 */
+	file->f_version = 0;
+
+	/* SEQ files support lseek, but not pread/pwrite */
+	file->f_mode &= ~(FMODE_PREAD | FMODE_PWRITE);
+	return 0;
+}
+EXPORT_SYMBOL(seq_open);
+
+/**
+ *	seq_read -	->read() method for sequential files.
+ *	@file, @buf, @size, @ppos: see file_operations method
+ *
+ *	Ready-made ->f_op->read()
+ */
+ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
+{
+	struct seq_file *m = (struct seq_file *)file->private_data;
+	size_t copied = 0;
+	loff_t pos;
+	size_t n;
+	void *p;
+	int err = 0;
+
+	down(&m->sem);
+	/*
+	 * seq_file->op->..m_start/m_stop/m_next may do special actions
+	 * or optimisations based on the file->f_version, so we want to
+	 * pass the file->f_version to those methods.
+	 *
+	 * seq_file->version is just copy of f_version, and seq_file
+	 * methods can treat it simply as file version.
+	 * It is copied in first and copied out after all operations.
+	 * It is convenient to have it as  part of structure to avoid the
+	 * need of passing another argument to all the seq_file methods.
+	 */
+	m->version = file->f_version;
+	/* grab buffer if we didn't have one */
+	if (!m->buf) {
+		m->buf = kmalloc(m->size = PAGE_SIZE, GFP_KERNEL);
+		if (!m->buf)
+			goto Enomem;
+	}
+	/* if not empty - flush it first */
+	if (m->count) {
+		n = min(m->count, size);
+		err = copy_to_user(buf, m->buf + m->from, n);
+		if (err)
+			goto Efault;
+		m->count -= n;
+		m->from += n;
+		size -= n;
+		buf += n;
+		copied += n;
+		if (!m->count)
+			m->index++;
+		if (!size)
+			goto Done;
+	}
+	/* we need at least one record in buffer */
+	while (1) {
+		pos = m->index;
+		p = m->op->start(m, &pos);
+		err = PTR_ERR(p);
+		if (!p || IS_ERR(p))
+			break;
+		err = m->op->show(m, p);
+		if (err)
+			break;
+		if (m->count < m->size)
+			goto Fill;
+		m->op->stop(m, p);
+		kfree(m->buf);
+		m->buf = kmalloc(m->size <<= 1, GFP_KERNEL);
+		if (!m->buf)
+			goto Enomem;
+		m->count = 0;
+		m->version = 0;
+	}
+	m->op->stop(m, p);
+	m->count = 0;
+	goto Done;
+Fill:
+	/* they want more? let's try to get some more */
+	while (m->count < size) {
+		size_t offs = m->count;
+		loff_t next = pos;
+		p = m->op->next(m, p, &next);
+		if (!p || IS_ERR(p)) {
+			err = PTR_ERR(p);
+			break;
+		}
+		err = m->op->show(m, p);
+		if (err || m->count == m->size) {
+			m->count = offs;
+			break;
+		}
+		pos = next;
+	}
+	m->op->stop(m, p);
+	n = min(m->count, size);
+	err = copy_to_user(buf, m->buf, n);
+	if (err)
+		goto Efault;
+	copied += n;
+	m->count -= n;
+	if (m->count)
+		m->from = n;
+	else
+		pos++;
+	m->index = pos;
+Done:
+	if (!copied)
+		copied = err;
+	else
+		*ppos += copied;
+	file->f_version = m->version;
+	up(&m->sem);
+	return copied;
+Enomem:
+	err = -ENOMEM;
+	goto Done;
+Efault:
+	err = -EFAULT;
+	goto Done;
+}
+EXPORT_SYMBOL(seq_read);
+
+static int traverse(struct seq_file *m, loff_t offset)
+{
+	loff_t pos = 0;
+	int error = 0;
+	void *p;
+
+	m->version = 0;
+	m->index = 0;
+	m->count = m->from = 0;
+	if (!offset)
+		return 0;
+	if (!m->buf) {
+		m->buf = kmalloc(m->size = PAGE_SIZE, GFP_KERNEL);
+		if (!m->buf)
+			return -ENOMEM;
+	}
+	p = m->op->start(m, &m->index);
+	while (p) {
+		error = PTR_ERR(p);
+		if (IS_ERR(p))
+			break;
+		error = m->op->show(m, p);
+		if (error)
+			break;
+		if (m->count == m->size)
+			goto Eoverflow;
+		if (pos + m->count > offset) {
+			m->from = offset - pos;
+			m->count -= m->from;
+			break;
+		}
+		pos += m->count;
+		m->count = 0;
+		if (pos == offset) {
+			m->index++;
+			break;
+		}
+		p = m->op->next(m, p, &m->index);
+	}
+	m->op->stop(m, p);
+	return error;
+
+Eoverflow:
+	m->op->stop(m, p);
+	kfree(m->buf);
+	m->buf = kmalloc(m->size <<= 1, GFP_KERNEL);
+	return !m->buf ? -ENOMEM : -EAGAIN;
+}
+
+/**
+ *	seq_lseek -	->llseek() method for sequential files.
+ *	@file, @offset, @origin: see file_operations method
+ *
+ *	Ready-made ->f_op->llseek()
+ */
+loff_t seq_lseek(struct file *file, loff_t offset, int origin)
+{
+	struct seq_file *m = (struct seq_file *)file->private_data;
+	long long retval = -EINVAL;
+
+	down(&m->sem);
+	m->version = file->f_version;
+	switch (origin) {
+		case 1:
+			offset += file->f_pos;
+		case 0:
+			if (offset < 0)
+				break;
+			retval = offset;
+			if (offset != file->f_pos) {
+				while ((retval=traverse(m, offset)) == -EAGAIN)
+					;
+				if (retval) {
+					/* with extreme prejudice... */
+					file->f_pos = 0;
+					m->version = 0;
+					m->index = 0;
+					m->count = 0;
+				} else {
+					retval = file->f_pos = offset;
+				}
+			}
+	}
+	up(&m->sem);
+	file->f_version = m->version;
+	return retval;
+}
+EXPORT_SYMBOL(seq_lseek);
+
+/**
+ *	seq_release -	free the structures associated with sequential file.
+ *	@file: file in question
+ *	@inode: file->f_dentry->d_inode
+ *
+ *	Frees the structures associated with sequential file; can be used
+ *	as ->f_op->release() if you don't have private data to destroy.
+ */
+int seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *m = (struct seq_file *)file->private_data;
+	kfree(m->buf);
+	kfree(m);
+	return 0;
+}
+EXPORT_SYMBOL(seq_release);
+
+/**
+ *	seq_escape -	print string into buffer, escaping some characters
+ *	@m:	target buffer
+ *	@s:	string
+ *	@esc:	set of characters that need escaping
+ *
+ *	Puts string into buffer, replacing each occurrence of character from
+ *	@esc with usual octal escape.  Returns 0 in case of success, -1 - in
+ *	case of overflow.
+ */
+int seq_escape(struct seq_file *m, const char *s, const char *esc)
+{
+	char *end = m->buf + m->size;
+        char *p;
+	char c;
+
+        for (p = m->buf + m->count; (c = *s) != '\0' && p < end; s++) {
+		if (!strchr(esc, c)) {
+			*p++ = c;
+			continue;
+		}
+		if (p + 3 < end) {
+			*p++ = '\\';
+			*p++ = '0' + ((c & 0300) >> 6);
+			*p++ = '0' + ((c & 070) >> 3);
+			*p++ = '0' + (c & 07);
+			continue;
+		}
+		m->count = m->size;
+		return -1;
+        }
+	m->count = p - m->buf;
+        return 0;
+}
+EXPORT_SYMBOL(seq_escape);
+
+int seq_printf(struct seq_file *m, const char *f, ...)
+{
+	va_list args;
+	int len;
+
+	if (m->count < m->size) {
+		va_start(args, f);
+		len = vsnprintf(m->buf + m->count, m->size - m->count, f, args);
+		va_end(args);
+		if (m->count + len < m->size) {
+			m->count += len;
+			return 0;
+		}
+	}
+	m->count = m->size;
+	return -1;
+}
+EXPORT_SYMBOL(seq_printf);
+
+int seq_path(struct seq_file *m,
+	     struct vfsmount *mnt, struct dentry *dentry,
+	     char *esc)
+{
+	if (m->count < m->size) {
+		char *s = m->buf + m->count;
+		char *p = d_path(dentry, mnt, s, m->size - m->count);
+		if (!IS_ERR(p)) {
+			while (s <= p) {
+				char c = *p++;
+				if (!c) {
+					p = m->buf + m->count;
+					m->count = s - m->buf;
+					return s - p;
+				} else if (!strchr(esc, c)) {
+					*s++ = c;
+				} else if (s + 4 > p) {
+					break;
+				} else {
+					*s++ = '\\';
+					*s++ = '0' + ((c & 0300) >> 6);
+					*s++ = '0' + ((c & 070) >> 3);
+					*s++ = '0' + (c & 07);
+				}
+			}
+		}
+	}
+	m->count = m->size;
+	return -1;
+}
+EXPORT_SYMBOL(seq_path);
+
+static void *single_start(struct seq_file *p, loff_t *pos)
+{
+	return NULL + (*pos == 0);
+}
+
+static void *single_next(struct seq_file *p, void *v, loff_t *pos)
+{
+	++*pos;
+	return NULL;
+}
+
+static void single_stop(struct seq_file *p, void *v)
+{
+}
+
+int single_open(struct file *file, int (*show)(struct seq_file *, void *),
+		void *data)
+{
+	struct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);
+	int res = -ENOMEM;
+
+	if (op) {
+		op->start = single_start;
+		op->next = single_next;
+		op->stop = single_stop;
+		op->show = show;
+		res = seq_open(file, op);
+		if (!res)
+			((struct seq_file *)file->private_data)->private = data;
+		else
+			kfree(op);
+	}
+	return res;
+}
+EXPORT_SYMBOL(single_open);
+
+int single_release(struct inode *inode, struct file *file)
+{
+	struct seq_operations *op = ((struct seq_file *)file->private_data)->op;
+	int res = seq_release(inode, file);
+	kfree(op);
+	return res;
+}
+EXPORT_SYMBOL(single_release);
+
+int seq_release_private(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+
+	kfree(seq->private);
+	seq->private = NULL;
+	return seq_release(inode, file);
+}
+EXPORT_SYMBOL(seq_release_private);
+
+int seq_putc(struct seq_file *m, char c)
+{
+	if (m->count < m->size) {
+		m->buf[m->count++] = c;
+		return 0;
+	}
+	return -1;
+}
+EXPORT_SYMBOL(seq_putc);
+
+int seq_puts(struct seq_file *m, const char *s)
+{
+	int len = strlen(s);
+	if (m->count + len < m->size) {
+		memcpy(m->buf + m->count, s, len);
+		m->count += len;
+		return 0;
+	}
+	m->count = m->size;
+	return -1;
+}
+EXPORT_SYMBOL(seq_puts);
