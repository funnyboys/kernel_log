commit 4a0b20be60bf387a1e4f989ff9953c0d1e0858aa
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Tue Oct 15 14:25:18 2019 +0100

    fsnotify: move declaration of fsnotify_mark_connector_cachep to fsnotify.h
    
    Move fsnotify_mark_connector_cachep to fsnotify.h to properly
    share it with the user in mark.c and avoid the following warning
    from sparse:
    
    fs/notify/mark.c:82:19: warning: symbol 'fsnotify_mark_connector_cachep' was not declared. Should it be static?
    
    Link: https://lore.kernel.org/r/20191015132518.21819-1-ben.dooks@codethink.co.uk
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index f3462828a0e2..ff2063ec6b0f 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -65,4 +65,6 @@ extern void __fsnotify_update_child_dentry_flags(struct inode *inode);
 extern struct fsnotify_event_holder *fsnotify_alloc_event_holder(void);
 extern void fsnotify_destroy_event_holder(struct fsnotify_event_holder *holder);
 
+extern struct kmem_cache *fsnotify_mark_connector_cachep;
+
 #endif	/* __FS_NOTIFY_FSNOTIFY_H_ */

commit b72679ee89a0a0ecd26f7b6fcae96cdaababff94
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sun Aug 18 14:18:46 2019 -0400

    notify: export symbols for use by the knfsd file cache
    
    The knfsd file cache will need to detect when files are unlinked, so that
    it can close the associated cached files. Export a minimal set of notifier
    functions to allow it to do so.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 5a00121fb219..f3462828a0e2 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -54,8 +54,6 @@ static inline void fsnotify_clear_marks_by_sb(struct super_block *sb)
 {
 	fsnotify_destroy_marks(&sb->s_fsnotify_marks);
 }
-/* Wait until all marks queued for destruction are destroyed */
-extern void fsnotify_wait_marks_destroyed(void);
 
 /*
  * update the dentry->d_flags of all of inode's children to indicate if inode cares

commit 1e6cb72399fd58b38a1c11055ef18fe01f535cda
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sat Sep 1 10:41:11 2018 +0300

    fsnotify: add super block object type
    
    Add the infrastructure to attach a mark to a super_block struct
    and detach all attached marks when super block is destroyed.
    
    This is going to be used by fanotify backend to setup super block
    marks.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 7902653dd577..5a00121fb219 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -21,6 +21,12 @@ static inline struct mount *fsnotify_conn_mount(
 	return container_of(conn->obj, struct mount, mnt_fsnotify_marks);
 }
 
+static inline struct super_block *fsnotify_conn_sb(
+				struct fsnotify_mark_connector *conn)
+{
+	return container_of(conn->obj, struct super_block, s_fsnotify_marks);
+}
+
 /* destroy all events sitting in this groups notification queue */
 extern void fsnotify_flush_notify(struct fsnotify_group *group);
 
@@ -43,6 +49,11 @@ static inline void fsnotify_clear_marks_by_mount(struct vfsmount *mnt)
 {
 	fsnotify_destroy_marks(&real_mount(mnt)->mnt_fsnotify_marks);
 }
+/* run the list of all marks associated with sb and destroy them */
+static inline void fsnotify_clear_marks_by_sb(struct super_block *sb)
+{
+	fsnotify_destroy_marks(&sb->s_fsnotify_marks);
+}
 /* Wait until all marks queued for destruction are destroyed */
 extern void fsnotify_wait_marks_destroyed(void);
 

commit 36f10f55ff1d2867bfc48ed898a9cc0dc6b49dd2
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sat Jun 23 17:54:49 2018 +0300

    fsnotify: let connector point to an abstract object
    
    Make the code to attach/detach a connector to object more generic
    by letting the fsnotify connector point to an abstract fsnotify_connp_t.
    Code that needs to dereference an inode or mount object now uses the
    helpers fsnotify_conn_{inode,mount}.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index caeee042d1cc..7902653dd577 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -9,14 +9,16 @@
 
 #include "../mount.h"
 
-static inline struct inode *fsnotify_obj_inode(fsnotify_connp_t *connp)
+static inline struct inode *fsnotify_conn_inode(
+				struct fsnotify_mark_connector *conn)
 {
-	return container_of(connp, struct inode, i_fsnotify_marks);
+	return container_of(conn->obj, struct inode, i_fsnotify_marks);
 }
 
-static inline struct mount *fsnotify_obj_mount(fsnotify_connp_t *connp)
+static inline struct mount *fsnotify_conn_mount(
+				struct fsnotify_mark_connector *conn)
 {
-	return container_of(connp, struct mount, mnt_fsnotify_marks);
+	return container_of(conn->obj, struct mount, mnt_fsnotify_marks);
 }
 
 /* destroy all events sitting in this groups notification queue */

commit b812a9f5896379b6cff2ac168ddb5b89037d8e78
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sat Jun 23 17:54:48 2018 +0300

    fsnotify: pass connp and object type to fsnotify_add_mark()
    
    Instead of passing inode and vfsmount arguments to fsnotify_add_mark()
    and its _locked variant, pass an abstract object pointer and the object
    type.
    
    The helpers fsnotify_obj_{inode,mount} are added to get the concrete
    object pointer from abstract object pointer.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 94cedf8264ba..caeee042d1cc 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -9,6 +9,16 @@
 
 #include "../mount.h"
 
+static inline struct inode *fsnotify_obj_inode(fsnotify_connp_t *connp)
+{
+	return container_of(connp, struct inode, i_fsnotify_marks);
+}
+
+static inline struct mount *fsnotify_obj_mount(fsnotify_connp_t *connp)
+{
+	return container_of(connp, struct mount, mnt_fsnotify_marks);
+}
+
 /* destroy all events sitting in this groups notification queue */
 extern void fsnotify_flush_notify(struct fsnotify_group *group);
 

commit 9b6e543450dc03635899ba56b1c39cc593694560
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sat Jun 23 17:54:47 2018 +0300

    fsnotify: use typedef fsnotify_connp_t for brevity
    
    The object marks manipulation functions fsnotify_destroy_marks()
    fsnotify_find_mark() and their helpers take an argument of type
    struct fsnotify_mark_connector __rcu ** to dereference the connector
    pointer. use a typedef to describe this type for brevity.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 34515d2c4ba3..94cedf8264ba 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -19,8 +19,8 @@ extern struct srcu_struct fsnotify_mark_srcu;
 extern int fsnotify_compare_groups(struct fsnotify_group *a,
 				   struct fsnotify_group *b);
 
-/* Destroy all marks connected via given connector */
-extern void fsnotify_destroy_marks(struct fsnotify_mark_connector __rcu **connp);
+/* Destroy all marks attached to an object via connector */
+extern void fsnotify_destroy_marks(fsnotify_connp_t *connp);
 /* run the list of all marks associated with inode and destroy them */
 static inline void fsnotify_clear_marks_by_inode(struct inode *inode)
 {

commit 5b0457ad021f3f7e3d9f4b84e7c3080748f383f8
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Apr 20 16:10:50 2018 -0700

    fsnotify: remove redundant arguments to handle_event()
    
    inode_mark and vfsmount_mark arguments are passed to handle_event()
    operation as function arguments as well as on iter_info struct.
    The difference is that iter_info struct may contain marks that should
    not be handled and are represented as NULL arguments to inode_mark or
    vfsmount_mark.
    
    Instead of passing the inode_mark and vfsmount_mark arguments, add
    a report_mask member to iter_info struct to indicate which marks should
    be handled, versus marks that should only be kept alive during user
    wait.
    
    This change is going to be used for passing more mark types
    with handle_event() (i.e. super block marks).
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 60f365dc1408..34515d2c4ba3 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -9,12 +9,6 @@
 
 #include "../mount.h"
 
-struct fsnotify_iter_info {
-	struct fsnotify_mark *inode_mark;
-	struct fsnotify_mark *vfsmount_mark;
-	int srcu_idx;
-};
-
 /* destroy all events sitting in this groups notification queue */
 extern void fsnotify_flush_notify(struct fsnotify_group *group);
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index bf012e8ecd14..60f365dc1408 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __FS_NOTIFY_FSNOTIFY_H_
 #define __FS_NOTIFY_FSNOTIFY_H_
 

commit b1362edfe15b20edd3d116cec521aa420b7afb98
Author: Jan Kara <jack@suse.cz>
Date:   Wed Dec 21 16:28:45 2016 +0100

    fsnotify: Remove fsnotify_find_{inode|vfsmount}_mark()
    
    These are very thin wrappers, just remove them. Drop
    fs/notify/vfsmount_mark.c as it is empty now.
    
    Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 3ec593c32684..bf012e8ecd14 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -24,10 +24,6 @@ extern struct srcu_struct fsnotify_mark_srcu;
 extern int fsnotify_compare_groups(struct fsnotify_group *a,
 				   struct fsnotify_group *b);
 
-/* Find mark belonging to given group in the list of marks */
-extern struct fsnotify_mark *fsnotify_find_mark(
-				struct fsnotify_mark_connector __rcu **connp,
-				struct fsnotify_group *group);
 /* Destroy all marks connected via given connector */
 extern void fsnotify_destroy_marks(struct fsnotify_mark_connector __rcu **connp);
 /* run the list of all marks associated with inode and destroy them */

commit 2e37c6ca8d76c362e844c0cf3ebe8ba2e27940cb
Author: Jan Kara <jack@suse.cz>
Date:   Wed Jan 4 10:51:58 2017 +0100

    fsnotify: Remove fsnotify_detach_group_marks()
    
    The function is already mostly contained in what
    fsnotify_clear_marks_by_group() does. Just update that function to not
    select marks when all of them should be destroyed and remove
    fsnotify_detach_group_marks().
    
    Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 86383c7865c0..3ec593c32684 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -40,8 +40,6 @@ static inline void fsnotify_clear_marks_by_mount(struct vfsmount *mnt)
 {
 	fsnotify_destroy_marks(&real_mount(mnt)->mnt_fsnotify_marks);
 }
-/* prepare for freeing all marks associated with given group */
-extern void fsnotify_detach_group_marks(struct fsnotify_group *group);
 /* Wait until all marks queued for destruction are destroyed */
 extern void fsnotify_wait_marks_destroyed(void);
 

commit abc77577a669f424c5d0c185b9994f2621c52aa4
Author: Jan Kara <jack@suse.cz>
Date:   Thu Nov 10 16:02:11 2016 +0100

    fsnotify: Provide framework for dropping SRCU lock in ->handle_event
    
    fanotify wants to drop fsnotify_mark_srcu lock when waiting for response
    from userspace so that the whole notification subsystem is not blocked
    during that time. This patch provides a framework for safely getting
    mark reference for a mark found in the object list which pins the mark
    in that list. We can then drop fsnotify_mark_srcu, wait for userspace
    response and then safely continue iteration of the object list once we
    reaquire fsnotify_mark_srcu.
    
    Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 2a92dc06198c..86383c7865c0 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -8,6 +8,12 @@
 
 #include "../mount.h"
 
+struct fsnotify_iter_info {
+	struct fsnotify_mark *inode_mark;
+	struct fsnotify_mark *vfsmount_mark;
+	int srcu_idx;
+};
+
 /* destroy all events sitting in this groups notification queue */
 extern void fsnotify_flush_notify(struct fsnotify_group *group);
 

commit f09b04a03e0239f65bd964a1de758e53cf6349e8
Author: Jan Kara <jack@suse.cz>
Date:   Wed Dec 21 14:48:18 2016 +0100

    fsnotify: Remove special handling of mark destruction on group shutdown
    
    Currently we queue all marks for destruction on group shutdown and then
    destroy them from fsnotify_destroy_group() instead from a worker thread
    which is the usual path. However worker can already be processing some
    list of marks to destroy so this does not make 100% all marks are really
    destroyed by the time group is shut down. This isn't a big problem as
    each mark holds group reference and thus group stays partially alive
    until all marks are really freed but there's no point in complicating
    our lives - just wait for the delayed work to be finished instead.
    
    Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 72050b75ca8c..2a92dc06198c 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -36,10 +36,8 @@ static inline void fsnotify_clear_marks_by_mount(struct vfsmount *mnt)
 }
 /* prepare for freeing all marks associated with given group */
 extern void fsnotify_detach_group_marks(struct fsnotify_group *group);
-/*
- * wait for fsnotify_mark_srcu period to end and free all marks in destroy_list
- */
-extern void fsnotify_mark_destroy_list(void);
+/* Wait until all marks queued for destruction are destroyed */
+extern void fsnotify_wait_marks_destroyed(void);
 
 /*
  * update the dentry->d_flags of all of inode's children to indicate if inode cares

commit 08991e83b7286635167bab40927665a90fb00d81
Author: Jan Kara <jack@suse.cz>
Date:   Wed Feb 1 09:21:58 2017 +0100

    fsnotify: Free fsnotify_mark_connector when there is no mark attached
    
    Currently we free fsnotify_mark_connector structure only when inode /
    vfsmount is getting freed. This can however impose noticeable memory
    overhead when marks get attached to inodes only temporarily. So free the
    connector structure once the last mark is detached from the object.
    Since notification infrastructure can be working with the connector
    under the protection of fsnotify_mark_srcu, we have to be careful and
    free the fsnotify_mark_connector only after SRCU period passes.
    
    Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 510f027bdf0f..72050b75ca8c 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -20,19 +20,19 @@ extern int fsnotify_compare_groups(struct fsnotify_group *a,
 
 /* Find mark belonging to given group in the list of marks */
 extern struct fsnotify_mark *fsnotify_find_mark(
-					struct fsnotify_mark_connector *conn,
-					struct fsnotify_group *group);
+				struct fsnotify_mark_connector __rcu **connp,
+				struct fsnotify_group *group);
 /* Destroy all marks connected via given connector */
-extern void fsnotify_destroy_marks(struct fsnotify_mark_connector *conn);
+extern void fsnotify_destroy_marks(struct fsnotify_mark_connector __rcu **connp);
 /* run the list of all marks associated with inode and destroy them */
 static inline void fsnotify_clear_marks_by_inode(struct inode *inode)
 {
-	fsnotify_destroy_marks(inode->i_fsnotify_marks);
+	fsnotify_destroy_marks(&inode->i_fsnotify_marks);
 }
 /* run the list of all marks associated with vfsmount and destroy them */
 static inline void fsnotify_clear_marks_by_mount(struct vfsmount *mnt)
 {
-	fsnotify_destroy_marks(real_mount(mnt)->mnt_fsnotify_marks);
+	fsnotify_destroy_marks(&real_mount(mnt)->mnt_fsnotify_marks);
 }
 /* prepare for freeing all marks associated with given group */
 extern void fsnotify_detach_group_marks(struct fsnotify_group *group);

commit 8212a6097a720896b4cdbe516487ad47f4296599
Author: Jan Kara <jack@suse.cz>
Date:   Wed Mar 15 09:48:11 2017 +0100

    fsnotify: Remove indirection from fsnotify_detach_mark()
    
    fsnotify_detach_mark() calls fsnotify_destroy_inode_mark() or
    fsnotify_destroy_vfsmount_mark() to remove mark from object list. These
    two functions are however very similar and differ only in the lock they
    use to protect the object list of marks. Simplify the code by removing
    the indirection and removing mark from the object list in a common
    function.
    
    Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 225924274f8a..510f027bdf0f 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -18,10 +18,6 @@ extern struct srcu_struct fsnotify_mark_srcu;
 extern int fsnotify_compare_groups(struct fsnotify_group *a,
 				   struct fsnotify_group *b);
 
-/* vfsmount specific destruction of a mark */
-extern void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark);
-/* inode specific destruction of a mark */
-extern struct inode *fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
 /* Find mark belonging to given group in the list of marks */
 extern struct fsnotify_mark *fsnotify_find_mark(
 					struct fsnotify_mark_connector *conn,

commit a03e2e4f078365428bb4317989cb5d1d6563cfe9
Author: Jan Kara <jack@suse.cz>
Date:   Wed Mar 15 09:41:15 2017 +0100

    fsnotify: Determine lock in fsnotify_destroy_marks()
    
    Instead of passing spinlock into fsnotify_destroy_marks() determine it
    directly in that function from the connector type. This will reduce code
    churn when changing lock protecting list of marks.
    
    Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 96051780d50e..225924274f8a 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -26,19 +26,17 @@ extern struct inode *fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
 extern struct fsnotify_mark *fsnotify_find_mark(
 					struct fsnotify_mark_connector *conn,
 					struct fsnotify_group *group);
-/* Destroy all marks connected via given connector protected by 'lock' */
-extern void fsnotify_destroy_marks(struct fsnotify_mark_connector *conn,
-				   spinlock_t *lock);
+/* Destroy all marks connected via given connector */
+extern void fsnotify_destroy_marks(struct fsnotify_mark_connector *conn);
 /* run the list of all marks associated with inode and destroy them */
 static inline void fsnotify_clear_marks_by_inode(struct inode *inode)
 {
-	fsnotify_destroy_marks(inode->i_fsnotify_marks, &inode->i_lock);
+	fsnotify_destroy_marks(inode->i_fsnotify_marks);
 }
 /* run the list of all marks associated with vfsmount and destroy them */
 static inline void fsnotify_clear_marks_by_mount(struct vfsmount *mnt)
 {
-	fsnotify_destroy_marks(real_mount(mnt)->mnt_fsnotify_marks,
-			       &mnt->mnt_root->d_lock);
+	fsnotify_destroy_marks(real_mount(mnt)->mnt_fsnotify_marks);
 }
 /* prepare for freeing all marks associated with given group */
 extern void fsnotify_detach_group_marks(struct fsnotify_group *group);

commit a242677bb1e6faa9bd82bd33afb2621071258231
Author: Jan Kara <jack@suse.cz>
Date:   Wed Mar 15 09:16:27 2017 +0100

    fsnotify: Move locking into fsnotify_recalc_mask()
    
    Move locking of locks protecting a list of marks into
    fsnotify_recalc_mask(). This reduces code churn in the following patch
    which changes the lock protecting the list of marks.
    
    Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 0354338aad78..96051780d50e 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -14,9 +14,6 @@ extern void fsnotify_flush_notify(struct fsnotify_group *group);
 /* protects reads of inode and vfsmount marks list */
 extern struct srcu_struct fsnotify_mark_srcu;
 
-/* Calculate mask of events for a list of marks */
-extern u32 fsnotify_recalc_mask(struct fsnotify_mark_connector *conn);
-
 /* compare two groups for sorting of marks lists */
 extern int fsnotify_compare_groups(struct fsnotify_group *a,
 				   struct fsnotify_group *b);

commit 755b5bc681eb46de7bfaec196f85e30efd95bd9f
Author: Jan Kara <jack@suse.cz>
Date:   Tue Mar 14 16:11:23 2017 +0100

    fsnotify: Remove indirection from mark list addition
    
    Adding notification mark to object list has been currently done through
    fsnotify_add_{inode|vfsmount}_mark() helpers from
    fsnotify_add_mark_locked() which call fsnotify_add_mark_list(). Remove
    this unnecessary indirection to simplify the code.
    
    Pushing all the locking to fsnotify_add_mark_list() also allows us to
    allocate the connector structure with GFP_KERNEL mode.
    
    Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 1a2aec65ebd8..0354338aad78 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -21,20 +21,6 @@ extern u32 fsnotify_recalc_mask(struct fsnotify_mark_connector *conn);
 extern int fsnotify_compare_groups(struct fsnotify_group *a,
 				   struct fsnotify_group *b);
 
-/* Add mark to a proper place in mark list */
-extern int fsnotify_add_mark_list(struct fsnotify_mark_connector **connp,
-				  struct fsnotify_mark *mark,
-				  struct inode *inode, struct vfsmount *mnt,
-				  int allow_dups);
-/* add a mark to an inode */
-extern int fsnotify_add_inode_mark(struct fsnotify_mark *mark,
-				   struct fsnotify_group *group, struct inode *inode,
-				   int allow_dups);
-/* add a mark to a vfsmount */
-extern int fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,
-				      struct fsnotify_group *group, struct vfsmount *mnt,
-				      int allow_dups);
-
 /* vfsmount specific destruction of a mark */
 extern void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark);
 /* inode specific destruction of a mark */

commit e911d8af87dba7642138f4320ca3db80629989f2
Author: Jan Kara <jack@suse.cz>
Date:   Tue Mar 14 14:48:00 2017 +0100

    fsnotify: Make fsnotify_mark_connector hold inode reference
    
    Currently inode reference is held by fsnotify marks. Change the rules so
    that inode reference is held by fsnotify_mark_connector structure
    whenever the list is non-empty. This simplifies the code and is more
    logical.
    
    Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index dd1a6798c9cd..1a2aec65ebd8 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -21,8 +21,6 @@ extern u32 fsnotify_recalc_mask(struct fsnotify_mark_connector *conn);
 extern int fsnotify_compare_groups(struct fsnotify_group *a,
 				   struct fsnotify_group *b);
 
-extern void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *fsn_mark,
-						__u32 mask);
 /* Add mark to a proper place in mark list */
 extern int fsnotify_add_mark_list(struct fsnotify_mark_connector **connp,
 				  struct fsnotify_mark *mark,
@@ -40,7 +38,7 @@ extern int fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,
 /* vfsmount specific destruction of a mark */
 extern void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark);
 /* inode specific destruction of a mark */
-extern void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
+extern struct inode *fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
 /* Find mark belonging to given group in the list of marks */
 extern struct fsnotify_mark *fsnotify_find_mark(
 					struct fsnotify_mark_connector *conn,

commit 86ffe245c430f07f95d5d28d3b694ea72f4492e7
Author: Jan Kara <jack@suse.cz>
Date:   Tue Mar 14 14:29:35 2017 +0100

    fsnotify: Move object pointer to fsnotify_mark_connector
    
    Move pointer to inode / vfsmount from mark itself to the
    fsnotify_mark_connector structure. This is another step on the path
    towards decoupling inode / vfsmount lifetime from notification mark
    lifetime.
    
    Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index eb64c59c9ad1..dd1a6798c9cd 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -26,6 +26,7 @@ extern void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *fsn_mark,
 /* Add mark to a proper place in mark list */
 extern int fsnotify_add_mark_list(struct fsnotify_mark_connector **connp,
 				  struct fsnotify_mark *mark,
+				  struct inode *inode, struct vfsmount *mnt,
 				  int allow_dups);
 /* add a mark to an inode */
 extern int fsnotify_add_inode_mark(struct fsnotify_mark *mark,
@@ -44,7 +45,7 @@ extern void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
 extern struct fsnotify_mark *fsnotify_find_mark(
 					struct fsnotify_mark_connector *conn,
 					struct fsnotify_group *group);
-/* Destroy all marks in the given list protected by 'lock' */
+/* Destroy all marks connected via given connector protected by 'lock' */
 extern void fsnotify_destroy_marks(struct fsnotify_mark_connector *conn,
 				   spinlock_t *lock);
 /* run the list of all marks associated with inode and destroy them */

commit 9dd813c15b2c101168808d4f5941a29985758973
Author: Jan Kara <jack@suse.cz>
Date:   Tue Mar 14 12:31:02 2017 +0100

    fsnotify: Move mark list head from object into dedicated structure
    
    Currently notification marks are attached to object (inode or vfsmnt) by
    a hlist_head in the object. The list is also protected by a spinlock in
    the object. So while there is any mark attached to the list of marks,
    the object must be pinned in memory (and thus e.g. last iput() deleting
    inode cannot happen). Also for list iteration in fsnotify() to work, we
    must hold fsnotify_mark_srcu lock so that mark itself and
    mark->obj_list.next cannot get freed. Thus we are required to wait for
    response to fanotify events from userspace process with
    fsnotify_mark_srcu lock held. That causes issues when userspace process
    is buggy and does not reply to some event - basically the whole
    notification subsystem gets eventually stuck.
    
    So to be able to drop fsnotify_mark_srcu lock while waiting for
    response, we have to pin the mark in memory and make sure it stays in
    the object list (as removing the mark waiting for response could lead to
    lost notification events for groups later in the list). However we don't
    want inode reclaim to block on such mark as that would lead to system
    just locking up elsewhere.
    
    This commit is the first in the series that paves way towards solving
    these conflicting lifetime needs. Instead of anchoring the list of marks
    directly in the object, we anchor it in a dedicated structure
    (fsnotify_mark_connector) and just point to that structure from the
    object. The following commits will also add spinlock protecting the list
    and object pointer to the structure.
    
    Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 0a3bc2cf192c..eb64c59c9ad1 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -15,7 +15,7 @@ extern void fsnotify_flush_notify(struct fsnotify_group *group);
 extern struct srcu_struct fsnotify_mark_srcu;
 
 /* Calculate mask of events for a list of marks */
-extern u32 fsnotify_recalc_mask(struct hlist_head *head);
+extern u32 fsnotify_recalc_mask(struct fsnotify_mark_connector *conn);
 
 /* compare two groups for sorting of marks lists */
 extern int fsnotify_compare_groups(struct fsnotify_group *a,
@@ -24,7 +24,7 @@ extern int fsnotify_compare_groups(struct fsnotify_group *a,
 extern void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *fsn_mark,
 						__u32 mask);
 /* Add mark to a proper place in mark list */
-extern int fsnotify_add_mark_list(struct hlist_head *head,
+extern int fsnotify_add_mark_list(struct fsnotify_mark_connector **connp,
 				  struct fsnotify_mark *mark,
 				  int allow_dups);
 /* add a mark to an inode */
@@ -41,19 +41,21 @@ extern void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark);
 /* inode specific destruction of a mark */
 extern void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
 /* Find mark belonging to given group in the list of marks */
-extern struct fsnotify_mark *fsnotify_find_mark(struct hlist_head *head,
-						struct fsnotify_group *group);
+extern struct fsnotify_mark *fsnotify_find_mark(
+					struct fsnotify_mark_connector *conn,
+					struct fsnotify_group *group);
 /* Destroy all marks in the given list protected by 'lock' */
-extern void fsnotify_destroy_marks(struct hlist_head *head, spinlock_t *lock);
+extern void fsnotify_destroy_marks(struct fsnotify_mark_connector *conn,
+				   spinlock_t *lock);
 /* run the list of all marks associated with inode and destroy them */
 static inline void fsnotify_clear_marks_by_inode(struct inode *inode)
 {
-	fsnotify_destroy_marks(&inode->i_fsnotify_marks, &inode->i_lock);
+	fsnotify_destroy_marks(inode->i_fsnotify_marks, &inode->i_lock);
 }
 /* run the list of all marks associated with vfsmount and destroy them */
 static inline void fsnotify_clear_marks_by_mount(struct vfsmount *mnt)
 {
-	fsnotify_destroy_marks(&real_mount(mnt)->mnt_fsnotify_marks,
+	fsnotify_destroy_marks(real_mount(mnt)->mnt_fsnotify_marks,
 			       &mnt->mnt_root->d_lock);
 }
 /* prepare for freeing all marks associated with given group */

commit 35e481761cdc688dbee0ef552a13f49af8eba6cc
Author: Jan Kara <jack@suse.cz>
Date:   Thu May 19 17:08:59 2016 -0700

    fsnotify: avoid spurious EMFILE errors from inotify_init()
    
    Inotify instance is destroyed when all references to it are dropped.
    That not only means that the corresponding file descriptor needs to be
    closed but also that all corresponding instance marks are freed (as each
    mark holds a reference to the inotify instance).  However marks are
    freed only after SRCU period ends which can take some time and thus if
    user rapidly creates and frees inotify instances, number of existing
    inotify instances can exceed max_user_instances limit although from user
    point of view there is always at most one existing instance.  Thus
    inotify_init() returns EMFILE error which is hard to justify from user
    point of view.  This problem is exposed by LTP inotify06 testcase on
    some machines.
    
    We fix the problem by making sure all group marks are properly freed
    while destroying inotify instance.  We wait for SRCU period to end in
    that path anyway since we have to make sure there is no event being
    added to the instance while we are tearing down the instance.  So it
    takes only some plumbing to allow for marks to be destroyed in that path
    as well and not from a dedicated work item.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Jan Kara <jack@suse.cz>
    Reported-by: Xiaoguang Wang <wangxg.fnst@cn.fujitsu.com>
    Tested-by: Xiaoguang Wang <wangxg.fnst@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index b44c68a857e7..0a3bc2cf192c 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -56,6 +56,13 @@ static inline void fsnotify_clear_marks_by_mount(struct vfsmount *mnt)
 	fsnotify_destroy_marks(&real_mount(mnt)->mnt_fsnotify_marks,
 			       &mnt->mnt_root->d_lock);
 }
+/* prepare for freeing all marks associated with given group */
+extern void fsnotify_detach_group_marks(struct fsnotify_group *group);
+/*
+ * wait for fsnotify_mark_srcu period to end and free all marks in destroy_list
+ */
+extern void fsnotify_mark_destroy_list(void);
+
 /*
  * update the dentry->d_flags of all of inode's children to indicate if inode cares
  * about events that happen to its children.

commit 925d1132a03e33cb8f29a0057300d023b4f1be23
Author: Jan Kara <jack@suse.com>
Date:   Fri Sep 4 15:43:09 2015 -0700

    fsnotify: remove mark->free_list
    
    Free list is used when all marks on given inode / mount should be
    destroyed when inode / mount is going away.  However we can free all of
    the marks without using a special list with some care.
    
    Signed-off-by: Jan Kara <jack@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 13a00be516d2..b44c68a857e7 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -6,6 +6,8 @@
 #include <linux/srcu.h>
 #include <linux/types.h>
 
+#include "../mount.h"
+
 /* destroy all events sitting in this groups notification queue */
 extern void fsnotify_flush_notify(struct fsnotify_group *group);
 
@@ -38,15 +40,22 @@ extern int fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,
 extern void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark);
 /* inode specific destruction of a mark */
 extern void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
-/* Destroy all marks in the given list */
-extern void fsnotify_destroy_marks(struct list_head *to_free);
 /* Find mark belonging to given group in the list of marks */
 extern struct fsnotify_mark *fsnotify_find_mark(struct hlist_head *head,
 						struct fsnotify_group *group);
-/* run the list of all marks associated with inode and flag them to be freed */
-extern void fsnotify_clear_marks_by_inode(struct inode *inode);
-/* run the list of all marks associated with vfsmount and flag them to be freed */
-extern void fsnotify_clear_marks_by_mount(struct vfsmount *mnt);
+/* Destroy all marks in the given list protected by 'lock' */
+extern void fsnotify_destroy_marks(struct hlist_head *head, spinlock_t *lock);
+/* run the list of all marks associated with inode and destroy them */
+static inline void fsnotify_clear_marks_by_inode(struct inode *inode)
+{
+	fsnotify_destroy_marks(&inode->i_fsnotify_marks, &inode->i_lock);
+}
+/* run the list of all marks associated with vfsmount and destroy them */
+static inline void fsnotify_clear_marks_by_mount(struct vfsmount *mnt)
+{
+	fsnotify_destroy_marks(&real_mount(mnt)->mnt_fsnotify_marks,
+			       &mnt->mnt_root->d_lock);
+}
 /*
  * update the dentry->d_flags of all of inode's children to indicate if inode cares
  * about events that happen to its children.

commit 0809ab69a2782afac8c4d7f3d35cd123050aab9a
Author: Jan Kara <jack@suse.cz>
Date:   Fri Dec 12 16:58:36 2014 -0800

    fsnotify: unify inode and mount marks handling
    
    There's a lot of common code in inode and mount marks handling.  Factor it
    out to a common helper function.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 3b68b0ae0a97..13a00be516d2 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -12,12 +12,19 @@ extern void fsnotify_flush_notify(struct fsnotify_group *group);
 /* protects reads of inode and vfsmount marks list */
 extern struct srcu_struct fsnotify_mark_srcu;
 
+/* Calculate mask of events for a list of marks */
+extern u32 fsnotify_recalc_mask(struct hlist_head *head);
+
 /* compare two groups for sorting of marks lists */
 extern int fsnotify_compare_groups(struct fsnotify_group *a,
 				   struct fsnotify_group *b);
 
 extern void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *fsn_mark,
 						__u32 mask);
+/* Add mark to a proper place in mark list */
+extern int fsnotify_add_mark_list(struct hlist_head *head,
+				  struct fsnotify_mark *mark,
+				  int allow_dups);
 /* add a mark to an inode */
 extern int fsnotify_add_inode_mark(struct fsnotify_mark *mark,
 				   struct fsnotify_group *group, struct inode *inode,
@@ -31,6 +38,11 @@ extern int fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,
 extern void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark);
 /* inode specific destruction of a mark */
 extern void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
+/* Destroy all marks in the given list */
+extern void fsnotify_destroy_marks(struct list_head *to_free);
+/* Find mark belonging to given group in the list of marks */
+extern struct fsnotify_mark *fsnotify_find_mark(struct hlist_head *head,
+						struct fsnotify_group *group);
 /* run the list of all marks associated with inode and flag them to be freed */
 extern void fsnotify_clear_marks_by_inode(struct inode *inode);
 /* run the list of all marks associated with vfsmount and flag them to be freed */

commit 8edc6e1688fc8f02c8c1f53a2ec4928cb1055f4d
Author: Jan Kara <jack@suse.cz>
Date:   Thu Nov 13 15:19:33 2014 -0800

    fanotify: fix notification of groups with inode & mount marks
    
    fsnotify() needs to merge inode and mount marks lists when notifying
    groups about events so that ignore masks from inode marks are reflected
    in mount mark notifications and groups are notified in proper order
    (according to priorities).
    
    Currently the sorting of the lists done by fsnotify_add_inode_mark() /
    fsnotify_add_vfsmount_mark() and fsnotify() differed which resulted
    ignore masks not being used in some cases.
    
    Fix the problem by always using the same comparison function when
    sorting / merging the mark lists.
    
    Thanks to Heinrich Schuchardt for improvements of my patch.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=87721
    Signed-off-by: Jan Kara <jack@suse.cz>
    Reported-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Tested-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 9c0898c4cfe1..3b68b0ae0a97 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -12,6 +12,10 @@ extern void fsnotify_flush_notify(struct fsnotify_group *group);
 /* protects reads of inode and vfsmount marks list */
 extern struct srcu_struct fsnotify_mark_srcu;
 
+/* compare two groups for sorting of marks lists */
+extern int fsnotify_compare_groups(struct fsnotify_group *a,
+				   struct fsnotify_group *b);
+
 extern void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *fsn_mark,
 						__u32 mask);
 /* add a mark to an inode */

commit cafbaae8afdb1e6cf9f4715aea2c897cf407ddfd
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Thu Oct 9 15:24:35 2014 -0700

    fs/notify/group.c: make fsnotify_final_destroy_group() static
    
    No callers outside this file.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 85e7d2b431d9..9c0898c4cfe1 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -23,9 +23,6 @@ extern int fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,
 				      struct fsnotify_group *group, struct vfsmount *mnt,
 				      int allow_dups);
 
-/* final kfree of a group */
-extern void fsnotify_final_destroy_group(struct fsnotify_group *group);
-
 /* vfsmount specific destruction of a mark */
 extern void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark);
 /* inode specific destruction of a mark */

commit 02436668d98385f5b5d9ffb695a37dadf98ed8a8
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Jul 28 10:18:39 2010 -0400

    fsnotify: remove global fsnotify groups lists
    
    The global fsnotify groups lists were invented as a way to increase the
    performance of fsnotify by shortcutting events which were not interesting.
    With the changes to walk the object lists rather than global groups lists
    these shortcuts are not useful.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index b41dbf5a125c..85e7d2b431d9 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -6,11 +6,6 @@
 #include <linux/srcu.h>
 #include <linux/types.h>
 
-/* all groups which receive inode fsnotify events */
-extern struct list_head fsnotify_inode_groups;
-/* all groups which receive vfsmount fsnotify events */
-extern struct list_head fsnotify_vfsmount_groups;
-
 /* destroy all events sitting in this groups notification queue */
 extern void fsnotify_flush_notify(struct fsnotify_group *group);
 
@@ -28,10 +23,6 @@ extern int fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,
 				      struct fsnotify_group *group, struct vfsmount *mnt,
 				      int allow_dups);
 
-/* add a group to the inode group list */
-extern void fsnotify_add_inode_group(struct fsnotify_group *group);
-/* add a group to the vfsmount group list */
-extern void fsnotify_add_vfsmount_group(struct fsnotify_group *group);
 /* final kfree of a group */
 extern void fsnotify_final_destroy_group(struct fsnotify_group *group);
 

commit 03930979afa63e079e9aefd4d3dd429240711027
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Jul 28 10:18:39 2010 -0400

    fsnotify: remove the global masks
    
    Because we walk the object->fsnotify_marks list instead of the global
    fsnotify groups list we don't need the fsnotify_inode_mask and
    fsnotify_vfsmount_mask as these were simply shortcuts in fsnotify() for
    performance.  They are now extra checks, rip them out.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 7eed86f942ba..b41dbf5a125c 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -10,10 +10,6 @@
 extern struct list_head fsnotify_inode_groups;
 /* all groups which receive vfsmount fsnotify events */
 extern struct list_head fsnotify_vfsmount_groups;
-/* all bitwise OR of all event types (FS_*) for all fsnotify_inode_groups */
-extern __u32 fsnotify_inode_mask;
-/* all bitwise OR of all event types (FS_*) for all fsnotify_vfsmount_groups */
-extern __u32 fsnotify_vfsmount_mask;
 
 /* destroy all events sitting in this groups notification queue */
 extern void fsnotify_flush_notify(struct fsnotify_group *group);

commit 75c1be487a690db43da2c1234fcacd84c982803c
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Jul 28 10:18:38 2010 -0400

    fsnotify: srcu to protect read side of inode and vfsmount locks
    
    Currently reading the inode->i_fsnotify_marks or
    vfsmount->mnt_fsnotify_marks lists are protected by a spinlock on both the
    read and the write side.  This patch protects the read side of those lists
    with a new single srcu.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 1be54f6f9e7d..7eed86f942ba 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -6,8 +6,6 @@
 #include <linux/srcu.h>
 #include <linux/types.h>
 
-/* protects reads of fsnotify_groups */
-extern struct srcu_struct fsnotify_grp_srcu;
 /* all groups which receive inode fsnotify events */
 extern struct list_head fsnotify_inode_groups;
 /* all groups which receive vfsmount fsnotify events */
@@ -20,6 +18,9 @@ extern __u32 fsnotify_vfsmount_mask;
 /* destroy all events sitting in this groups notification queue */
 extern void fsnotify_flush_notify(struct fsnotify_group *group);
 
+/* protects reads of inode and vfsmount marks list */
+extern struct srcu_struct fsnotify_mark_srcu;
+
 extern void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *fsn_mark,
 						__u32 mask);
 /* add a mark to an inode */

commit 90b1e7a57880fb66437ab7db39e1e65ca0372822
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Dec 17 21:24:33 2009 -0500

    fsnotify: allow marks to not pin inodes in core
    
    inotify marks must pin inodes in core.  dnotify doesn't technically need to
    since they are closed when the directory is closed.  fanotify also need to
    pin inodes in core as it works today.  But the next step is to introduce
    the concept of 'ignored masks' which is actually a mask of events for an
    inode of no interest.  I claim that these should be liberally sent to the
    kernel and should not pin the inode in core.  If the inode is brought back
    in the listener will get an event it may have thought excluded, but this is
    not a serious situation and one any listener should deal with.
    
    This patch lays the ground work for non-pinning inode marks by using lazy
    inode pinning.  We do not pin a mark until it has a non-zero mask entry.  If a
    listener new sets a mask we never pin the inode.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 204353c0f663..1be54f6f9e7d 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -20,6 +20,8 @@ extern __u32 fsnotify_vfsmount_mask;
 /* destroy all events sitting in this groups notification queue */
 extern void fsnotify_flush_notify(struct fsnotify_group *group);
 
+extern void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *fsn_mark,
+						__u32 mask);
 /* add a mark to an inode */
 extern int fsnotify_add_inode_mark(struct fsnotify_mark *mark,
 				   struct fsnotify_group *group, struct inode *inode,

commit ca9c726eea013394d1e846331b117effb21ead83
Author: Andreas Gruenbacher <agruen@suse.de>
Date:   Thu Dec 17 21:24:27 2009 -0500

    fsnotify: Infrastructure for per-mount watches
    
    Per-mount watches allow groups to listen to fsnotify events on an entire
    mount.  This patch simply adds and initializes the fields needed in the
    vfsmount struct to make this happen.
    
    Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 38f3fb5cef28..204353c0f663 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -42,6 +42,8 @@ extern void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark);
 extern void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
 /* run the list of all marks associated with inode and flag them to be freed */
 extern void fsnotify_clear_marks_by_inode(struct inode *inode);
+/* run the list of all marks associated with vfsmount and flag them to be freed */
+extern void fsnotify_clear_marks_by_mount(struct vfsmount *mnt);
 /*
  * update the dentry->d_flags of all of inode's children to indicate if inode cares
  * about events that happen to its children.

commit 0d48b7f01f442bc88a69aa98f3b6b015f2817608
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Dec 17 21:24:27 2009 -0500

    fsnotify: vfsmount marks generic functions
    
    Much like inode-mark.c has all of the code dealing with marks on inodes
    this patch adds a vfsmount-mark.c which has similar code but is intended
    for marks on vfsmounts.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 7c7a904b802d..38f3fb5cef28 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -24,6 +24,10 @@ extern void fsnotify_flush_notify(struct fsnotify_group *group);
 extern int fsnotify_add_inode_mark(struct fsnotify_mark *mark,
 				   struct fsnotify_group *group, struct inode *inode,
 				   int allow_dups);
+/* add a mark to a vfsmount */
+extern int fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,
+				      struct fsnotify_group *group, struct vfsmount *mnt,
+				      int allow_dups);
 
 /* add a group to the inode group list */
 extern void fsnotify_add_inode_group(struct fsnotify_group *group);
@@ -32,6 +36,8 @@ extern void fsnotify_add_vfsmount_group(struct fsnotify_group *group);
 /* final kfree of a group */
 extern void fsnotify_final_destroy_group(struct fsnotify_group *group);
 
+/* vfsmount specific destruction of a mark */
+extern void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark);
 /* inode specific destruction of a mark */
 extern void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
 /* run the list of all marks associated with inode and flag them to be freed */

commit 5444e2981c31d0ed7465475e451b8437084337e5
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Dec 17 21:24:27 2009 -0500

    fsnotify: split generic and inode specific mark code
    
    currently all marking is done by functions in inode-mark.c.  Some of this
    is pretty generic and should be instead done in a generic function and we
    should only put the inode specific code in inode-mark.c
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 2ba59158969f..7c7a904b802d 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -20,6 +20,11 @@ extern __u32 fsnotify_vfsmount_mask;
 /* destroy all events sitting in this groups notification queue */
 extern void fsnotify_flush_notify(struct fsnotify_group *group);
 
+/* add a mark to an inode */
+extern int fsnotify_add_inode_mark(struct fsnotify_mark *mark,
+				   struct fsnotify_group *group, struct inode *inode,
+				   int allow_dups);
+
 /* add a group to the inode group list */
 extern void fsnotify_add_inode_group(struct fsnotify_group *group);
 /* add a group to the vfsmount group list */
@@ -27,6 +32,8 @@ extern void fsnotify_add_vfsmount_group(struct fsnotify_group *group);
 /* final kfree of a group */
 extern void fsnotify_final_destroy_group(struct fsnotify_group *group);
 
+/* inode specific destruction of a mark */
+extern void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark);
 /* run the list of all marks associated with inode and flag them to be freed */
 extern void fsnotify_clear_marks_by_inode(struct inode *inode);
 /*

commit 7131485a93679ff9a543b74df280cfd119eb03ca
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Dec 17 21:24:23 2009 -0500

    fsnotify: mount point listeners list and global mask
    
    currently all of the notification systems implemented select which inodes
    they care about and receive messages only about those inodes (or the
    children of those inodes.)  This patch begins to flesh out fsnotify support
    for the concept of listeners that want to hear notification for an inode
    accessed below a given monut point.  This patch implements a second list
    of fsnotify groups to hold these types of groups and a second global mask
    to hold the events of interest for this type of group.
    
    The reason we want a second group list and mask is because the inode based
    notification should_send_event support which makes each group look for a mark
    on the given inode.  With one nfsmount listener that means that every group would
    have to take the inode->i_lock, look for their mark, not find one, and return
    for every operation.   By seperating vfsmount from inode listeners only when
    there is a inode listener will the inode groups have to look for their
    mark and take the inode lock.  vfsmount listeners will have to grab the lock and
    look for a mark but there should be fewer of them, and one vfsmount listener
    won't cause the i_lock to be grabbed and released for every fsnotify group
    on every io operation.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 5bd22412017f..2ba59158969f 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -10,14 +10,20 @@
 extern struct srcu_struct fsnotify_grp_srcu;
 /* all groups which receive inode fsnotify events */
 extern struct list_head fsnotify_inode_groups;
+/* all groups which receive vfsmount fsnotify events */
+extern struct list_head fsnotify_vfsmount_groups;
 /* all bitwise OR of all event types (FS_*) for all fsnotify_inode_groups */
 extern __u32 fsnotify_inode_mask;
+/* all bitwise OR of all event types (FS_*) for all fsnotify_vfsmount_groups */
+extern __u32 fsnotify_vfsmount_mask;
 
 /* destroy all events sitting in this groups notification queue */
 extern void fsnotify_flush_notify(struct fsnotify_group *group);
 
 /* add a group to the inode group list */
 extern void fsnotify_add_inode_group(struct fsnotify_group *group);
+/* add a group to the vfsmount group list */
+extern void fsnotify_add_vfsmount_group(struct fsnotify_group *group);
 /* final kfree of a group */
 extern void fsnotify_final_destroy_group(struct fsnotify_group *group);
 

commit 4ca763523e040dc61191d4866a82981a5d30a4e9
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Dec 17 21:24:23 2009 -0500

    fsnotify: add groups to fsnotify_inode_groups when registering inode watch
    
    Currently all fsnotify groups are added immediately to the
    fsnotify_inode_groups list upon creation.  This means, even groups with no
    watches (common for audit) will be on the global tracking list and will
    get checked for every event.  This patch adds groups to the global list on
    when the first inode mark is added to the group.
    
    Signed-of-by: Eric Paris <eparis@redhat.com>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index ec5aee43bdc5..5bd22412017f 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -16,6 +16,8 @@ extern __u32 fsnotify_inode_mask;
 /* destroy all events sitting in this groups notification queue */
 extern void fsnotify_flush_notify(struct fsnotify_group *group);
 
+/* add a group to the inode group list */
+extern void fsnotify_add_inode_group(struct fsnotify_group *group);
 /* final kfree of a group */
 extern void fsnotify_final_destroy_group(struct fsnotify_group *group);
 

commit 19c2a0e1a2f60112c158342ba5f568f72b741c2c
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Dec 17 21:24:23 2009 -0500

    fsnotify: rename fsnotify_groups to fsnotify_inode_groups
    
    Simple renaming patch.  fsnotify is about to support mount point listeners
    so I am renaming fsnotify_groups and fsnotify_mask to indicate these are lists
    used only for groups which have watches on inodes.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 4dc240824b2d..ec5aee43bdc5 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -8,10 +8,10 @@
 
 /* protects reads of fsnotify_groups */
 extern struct srcu_struct fsnotify_grp_srcu;
-/* all groups which receive fsnotify events */
-extern struct list_head fsnotify_groups;
-/* all bitwise OR of all event types (FS_*) for all fsnotify_groups */
-extern __u32 fsnotify_mask;
+/* all groups which receive inode fsnotify events */
+extern struct list_head fsnotify_inode_groups;
+/* all bitwise OR of all event types (FS_*) for all fsnotify_inode_groups */
+extern __u32 fsnotify_inode_mask;
 
 /* destroy all events sitting in this groups notification queue */
 extern void fsnotify_flush_notify(struct fsnotify_group *group);

commit a2d8bc6cb4a3024661baf877242f123787d0c054
Author: Eric Paris <eparis@redhat.com>
Date:   Thu May 21 17:01:37 2009 -0400

    fsnotify: generic notification queue and waitq
    
    inotify needs to do asyc notification in which event information is stored
    on a queue until the listener is ready to receive it.  This patch
    implements a generic notification queue for inotify (and later fanotify) to
    store events to be sent at a later time.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 83b8ec0a8ec2..4dc240824b2d 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -13,8 +13,12 @@ extern struct list_head fsnotify_groups;
 /* all bitwise OR of all event types (FS_*) for all fsnotify_groups */
 extern __u32 fsnotify_mask;
 
+/* destroy all events sitting in this groups notification queue */
+extern void fsnotify_flush_notify(struct fsnotify_group *group);
+
 /* final kfree of a group */
 extern void fsnotify_final_destroy_group(struct fsnotify_group *group);
+
 /* run the list of all marks associated with inode and flag them to be freed */
 extern void fsnotify_clear_marks_by_inode(struct inode *inode);
 /*
@@ -22,4 +26,9 @@ extern void fsnotify_clear_marks_by_inode(struct inode *inode);
  * about events that happen to its children.
  */
 extern void __fsnotify_update_child_dentry_flags(struct inode *inode);
+
+/* allocate and destroy and event holder to attach events to notification/access queues */
+extern struct fsnotify_event_holder *fsnotify_alloc_event_holder(void);
+extern void fsnotify_destroy_event_holder(struct fsnotify_event_holder *holder);
+
 #endif	/* __FS_NOTIFY_FSNOTIFY_H_ */

commit c28f7e56e9d95fb531dc3be8df2e7f52bee76d21
Author: Eric Paris <eparis@redhat.com>
Date:   Thu May 21 17:01:29 2009 -0400

    fsnotify: parent event notification
    
    inotify and dnotify both use a similar parent notification mechanism.  We
    add a generic parent notification mechanism to fsnotify for both of these
    to use.  This new machanism also adds the dentry flag optimization which
    exists for inotify to dnotify.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index 8ebcbe893c91..83b8ec0a8ec2 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -17,4 +17,9 @@ extern __u32 fsnotify_mask;
 extern void fsnotify_final_destroy_group(struct fsnotify_group *group);
 /* run the list of all marks associated with inode and flag them to be freed */
 extern void fsnotify_clear_marks_by_inode(struct inode *inode);
+/*
+ * update the dentry->d_flags of all of inode's children to indicate if inode cares
+ * about events that happen to its children.
+ */
+extern void __fsnotify_update_child_dentry_flags(struct inode *inode);
 #endif	/* __FS_NOTIFY_FSNOTIFY_H_ */

commit 3be25f49b9d6a97eae9bcb96d3292072b7658bd8
Author: Eric Paris <eparis@redhat.com>
Date:   Thu May 21 17:01:26 2009 -0400

    fsnotify: add marks to inodes so groups can interpret how to handle those inodes
    
    This patch creates a way for fsnotify groups to attach marks to inodes.
    These marks have little meaning to the generic fsnotify infrastructure
    and thus their meaning should be interpreted by the group that attached
    them to the inode's list.
    
    dnotify and inotify  will make use of these markings to indicate which
    inodes are of interest to their respective groups.  But this implementation
    has the useful property that in the future other listeners could actually
    use the marks for the exact opposite reason, aka to indicate which inodes
    it had NO interest in.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
index c6a8bd476572..8ebcbe893c91 100644
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@ -12,4 +12,9 @@ extern struct srcu_struct fsnotify_grp_srcu;
 extern struct list_head fsnotify_groups;
 /* all bitwise OR of all event types (FS_*) for all fsnotify_groups */
 extern __u32 fsnotify_mask;
+
+/* final kfree of a group */
+extern void fsnotify_final_destroy_group(struct fsnotify_group *group);
+/* run the list of all marks associated with inode and flag them to be freed */
+extern void fsnotify_clear_marks_by_inode(struct inode *inode);
 #endif	/* __FS_NOTIFY_FSNOTIFY_H_ */

commit 90586523eb4b349806887c62ee70685a49415124
Author: Eric Paris <eparis@redhat.com>
Date:   Thu May 21 17:01:20 2009 -0400

    fsnotify: unified filesystem notification backend
    
    fsnotify is a backend for filesystem notification.  fsnotify does
    not provide any userspace interface but does provide the basis
    needed for other notification schemes such as dnotify.  fsnotify
    can be extended to be the backend for inotify or the upcoming
    fanotify.  fsnotify provides a mechanism for "groups" to register for
    some set of filesystem events and to then deliver those events to
    those groups for processing.
    
    fsnotify has a number of benefits, the first being actually shrinking the size
    of an inode.  Before fsnotify to support both dnotify and inotify an inode had
    
            unsigned long           i_dnotify_mask; /* Directory notify events */
            struct dnotify_struct   *i_dnotify; /* for directory notifications */
            struct list_head        inotify_watches; /* watches on this inode */
            struct mutex            inotify_mutex;  /* protects the watches list
    
    But with fsnotify this same functionallity (and more) is done with just
    
            __u32                   i_fsnotify_mask; /* all events for this inode */
            struct hlist_head       i_fsnotify_mark_entries; /* marks on this inode */
    
    That's right, inotify, dnotify, and fanotify all in 64 bits.  We used that
    much space just in inotify_watches alone, before this patch set.
    
    fsnotify object lifetime and locking is MUCH better than what we have today.
    inotify locking is incredibly complex.  See 8f7b0ba1c8539 as an example of
    what's been busted since inception.  inotify needs to know internal semantics
    of superblock destruction and unmounting to function.  The inode pinning and
    vfs contortions are horrible.
    
    no fsnotify implementers do allocation under locks.  This means things like
    f04b30de3 which (due to an overabundance of caution) changes GFP_KERNEL to
    GFP_NOFS can be reverted.  There are no longer any allocation rules when using
    or implementing your own fsnotify listener.
    
    fsnotify paves the way for fanotify.  In brief fanotify is a notification
    mechanism that delivers the lisener both an 'event' and an open file descriptor
    to the object in question.  This means that fanotify is pathname agnostic.
    Some on lkml may not care for the original companies or users that pushed for
    TALPA, but fanotify was designed with flexibility and input for other users in
    mind.  The readahead group expressed interest in fanotify as it could be used
    to profile disk access on boot without breaking the audit system.  The desktop
    search groups have also expressed interest in fanotify as it solves a number
    of the race conditions and problems present with managing inotify when more
    than a limited number of specific files are of interest.  fanotify can provide
    for a userspace access control system which makes it a clean interface for AV
    vendors to hook without trying to do binary patching on the syscall table,
    LSM, and everywhere else they do their things today.  With this patch series
    fanotify can be implemented in less than 1200 lines of easy to review code.
    Almost all of which is the socket based user interface.
    
    This patch series builds fsnotify to the point that it can implement
    dnotify and inotify_user.  Patches exist and will be sent soon after
    acceptance to finish the in kernel inotify conversion (audit) and implement
    fanotify.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>

diff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.h
new file mode 100644
index 000000000000..c6a8bd476572
--- /dev/null
+++ b/fs/notify/fsnotify.h
@@ -0,0 +1,15 @@
+#ifndef __FS_NOTIFY_FSNOTIFY_H_
+#define __FS_NOTIFY_FSNOTIFY_H_
+
+#include <linux/list.h>
+#include <linux/fsnotify.h>
+#include <linux/srcu.h>
+#include <linux/types.h>
+
+/* protects reads of fsnotify_groups */
+extern struct srcu_struct fsnotify_grp_srcu;
+/* all groups which receive fsnotify events */
+extern struct list_head fsnotify_groups;
+/* all bitwise OR of all event types (FS_*) for all fsnotify_groups */
+extern __u32 fsnotify_mask;
+#endif	/* __FS_NOTIFY_FSNOTIFY_H_ */
