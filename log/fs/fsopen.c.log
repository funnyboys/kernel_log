commit cc3c0b533ab9142eac2e291628fbfca3685f38cd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Dec 21 00:16:49 2019 -0500

    add prefix to fs_context->log
    
    ... turning it into struct p_log embedded into fs_context.  Initialize
    the prefix with fs_type->name, turning fs_parse() into a trivial
    inline wrapper for __fs_parse().
    
    This makes fs_parameter_description->name completely unused.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fsopen.c b/fs/fsopen.c
index c822d8924ca9..2fa3f241b762 100644
--- a/fs/fsopen.c
+++ b/fs/fsopen.c
@@ -25,7 +25,7 @@ static ssize_t fscontext_read(struct file *file,
 			      char __user *_buf, size_t len, loff_t *pos)
 {
 	struct fs_context *fc = file->private_data;
-	struct fc_log *log = fc->log;
+	struct fc_log *log = fc->log.log;
 	unsigned int logsize = ARRAY_SIZE(log->buffer);
 	ssize_t ret;
 	char *p;
@@ -97,11 +97,11 @@ static int fscontext_create_fd(struct fs_context *fc, unsigned int o_flags)
 
 static int fscontext_alloc_log(struct fs_context *fc)
 {
-	fc->log = kzalloc(sizeof(*fc->log), GFP_KERNEL);
-	if (!fc->log)
+	fc->log.log = kzalloc(sizeof(*fc->log.log), GFP_KERNEL);
+	if (!fc->log.log)
 		return -ENOMEM;
-	refcount_set(&fc->log->usage, 1);
-	fc->log->owner = fc->fs_type->owner;
+	refcount_set(&fc->log.log->usage, 1);
+	fc->log.log->owner = fc->fs_type->owner;
 	return 0;
 }
 

commit aa1918f9491442a007a0cbe41a31539233209777
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 17 20:09:08 2019 -0500

    get rid of fs_value_is_filename_empty
    
    Its behaviour is identical to that of fs_value_is_filename.
    It makes no sense, anyway - LOOKUP_EMPTY affects nothing
    whatsoever once the pathname has been imported from userland.
    And both fs_value_is_filename and fs_value_is_filename_empty
    carry an already imported pathname.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fsopen.c b/fs/fsopen.c
index 043ffa8dc263..c822d8924ca9 100644
--- a/fs/fsopen.c
+++ b/fs/fsopen.c
@@ -321,6 +321,7 @@ SYSCALL_DEFINE5(fsconfig,
 	struct fs_context *fc;
 	struct fd f;
 	int ret;
+	int lookup_flags = 0;
 
 	struct fs_parameter param = {
 		.type	= fs_value_is_undefined,
@@ -409,19 +410,12 @@ SYSCALL_DEFINE5(fsconfig,
 			goto out_key;
 		}
 		break;
+	case FSCONFIG_SET_PATH_EMPTY:
+		lookup_flags = LOOKUP_EMPTY;
+		/* fallthru */
 	case FSCONFIG_SET_PATH:
 		param.type = fs_value_is_filename;
-		param.name = getname_flags(_value, 0, NULL);
-		if (IS_ERR(param.name)) {
-			ret = PTR_ERR(param.name);
-			goto out_key;
-		}
-		param.dirfd = aux;
-		param.size = strlen(param.name->name);
-		break;
-	case FSCONFIG_SET_PATH_EMPTY:
-		param.type = fs_value_is_filename_empty;
-		param.name = getname_flags(_value, LOOKUP_EMPTY, NULL);
+		param.name = getname_flags(_value, lookup_flags, NULL);
 		if (IS_ERR(param.name)) {
 			ret = PTR_ERR(param.name);
 			goto out_key;

commit 933a90bf4f3505f8ec83bda21a3c7d70d7c2b426
Merge: 5f4fc6d440d7 037f11b4752f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 19 10:42:02 2019 -0700

    Merge branch 'work.mount0' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs mount updates from Al Viro:
     "The first part of mount updates.
    
      Convert filesystems to use the new mount API"
    
    * 'work.mount0' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (63 commits)
      mnt_init(): call shmem_init() unconditionally
      constify ksys_mount() string arguments
      don't bother with registering rootfs
      init_rootfs(): don't bother with init_ramfs_fs()
      vfs: Convert smackfs to use the new mount API
      vfs: Convert selinuxfs to use the new mount API
      vfs: Convert securityfs to use the new mount API
      vfs: Convert apparmorfs to use the new mount API
      vfs: Convert openpromfs to use the new mount API
      vfs: Convert xenfs to use the new mount API
      vfs: Convert gadgetfs to use the new mount API
      vfs: Convert oprofilefs to use the new mount API
      vfs: Convert ibmasmfs to use the new mount API
      vfs: Convert qib_fs/ipathfs to use the new mount API
      vfs: Convert efivarfs to use the new mount API
      vfs: Convert configfs to use the new mount API
      vfs: Convert binfmt_misc to use the new mount API
      convenience helper: get_tree_single()
      convenience helper get_tree_nodev()
      vfs: Kill sget_userns()
      ...

commit c3aabf0780a506225b53bfe2b5177dd5dfec093d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon May 13 12:57:22 2019 -0400

    move mount_capable() further out
    
    Call graph of vfs_get_tree():
            vfs_fsconfig_locked()   # neither kernmount, nor submount
            do_new_mount()          # neither kernmount, nor submount
            fc_mount()
                    afs_mntpt_do_automount()        # submount
                    mount_one_hugetlbfs()           # kernmount
                    pid_ns_prepare_proc()           # kernmount
                    mq_create_mount()               # kernmount
                    vfs_kern_mount()
                            simple_pin_fs()         # kernmount
                            vfs_submount()          # submount
                            kern_mount()            # kernmount
                            init_mount_tree()
                            btrfs_mount()
                            nfs_do_root_mount()
    
            The first two need the check (unconditionally).
    init_mount_tree() is setting rootfs up; any capability
    checks make zero sense for that one.  And btrfs_mount()/
    nfs_do_root_mount() have the checks already done in their
    callers.
    
            IOW, we can shift mount_capable() handling into
    the two callers - one in the normal case of mount(2),
    another - in fsconfig(2) handling of FSCONFIG_CMD_CREATE.
    I.e. the syscalls that set a new filesystem up.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fsopen.c b/fs/fsopen.c
index c2891e933ef1..390172772f55 100644
--- a/fs/fsopen.c
+++ b/fs/fsopen.c
@@ -230,6 +230,8 @@ static int vfs_fsconfig_locked(struct fs_context *fc, int cmd,
 	case FSCONFIG_CMD_CREATE:
 		if (fc->phase != FS_CONTEXT_CREATE_PARAMS)
 			return -EBUSY;
+		if (!mount_capable(fc))
+			return -EPERM;
 		fc->phase = FS_CONTEXT_CREATING;
 		ret = vfs_get_tree(fc);
 		if (ret)

commit b4d0d230ccfb5d1a9ea85da64aa584df7c148ee9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:08:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 36
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public licence as published by
      the free software foundation either version 2 of the licence or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 114 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170857.552531963@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/fsopen.c b/fs/fsopen.c
index c2891e933ef1..a8bf83ce8d4e 100644
--- a/fs/fsopen.c
+++ b/fs/fsopen.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /* Filesystem access-by-fd.
  *
  * Copyright (C) 2017 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public Licence
- * as published by the Free Software Foundation; either version
- * 2 of the Licence, or (at your option) any later version.
  */
 
 #include <linux/fs_context.h>

commit 1cdc415f10831c18912943017d06b2be948c67b4
Author: Christian Brauner <christian@brauner.io>
Date:   Thu May 16 12:52:20 2019 +0100

    uapi, fsopen: use square brackets around "fscontext" [ver #2]
    
    Make the name of the anon inode fd "[fscontext]" instead of "fscontext".
    This is minor but most core-kernel anon inode fds already carry square
    brackets around their name:
    
    [eventfd]
    [eventpoll]
    [fanotify]
    [io_uring]
    [pidfd]
    [signalfd]
    [timerfd]
    [userfaultfd]
    
    For the sake of consistency lets do the same for the fscontext anon inode
    fd that comes with the new mount api.
    
    Signed-off-by: Christian Brauner <christian@brauner.io>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fsopen.c b/fs/fsopen.c
index 3bb9c0c8cbcc..c2891e933ef1 100644
--- a/fs/fsopen.c
+++ b/fs/fsopen.c
@@ -92,7 +92,7 @@ static int fscontext_create_fd(struct fs_context *fc, unsigned int o_flags)
 {
 	int fd;
 
-	fd = anon_inode_getfd("fscontext", &fscontext_fops, fc,
+	fd = anon_inode_getfd("[fscontext]", &fscontext_fops, fc,
 			      O_RDWR | o_flags);
 	if (fd < 0)
 		put_fs_context(fc);

commit cf3cba4a429be43e5527a3f78859b1bfd9ebc5fb
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:36:23 2018 +0000

    vfs: syscall: Add fspick() to select a superblock for reconfiguration
    
    Provide an fspick() system call that can be used to pick an existing
    mountpoint into an fs_context which can thereafter be used to reconfigure a
    superblock (equivalent of the superblock side of -o remount).
    
    This looks like:
    
            int fd = fspick(AT_FDCWD, "/mnt",
                            FSPICK_CLOEXEC | FSPICK_NO_AUTOMOUNT);
            fsconfig(fd, FSCONFIG_SET_FLAG, "intr", NULL, 0);
            fsconfig(fd, FSCONFIG_SET_FLAG, "noac", NULL, 0);
            fsconfig(fd, FSCONFIG_CMD_RECONFIGURE, NULL, NULL, 0);
    
    At the point of fspick being called, the file descriptor referring to the
    filesystem context is in exactly the same state as the one that was created
    by fsopen() after fsmount() has been successfully called.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-api@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fsopen.c b/fs/fsopen.c
index 65cc2f68f994..3bb9c0c8cbcc 100644
--- a/fs/fsopen.c
+++ b/fs/fsopen.c
@@ -156,6 +156,63 @@ SYSCALL_DEFINE2(fsopen, const char __user *, _fs_name, unsigned int, flags)
 	return ret;
 }
 
+/*
+ * Pick a superblock into a context for reconfiguration.
+ */
+SYSCALL_DEFINE3(fspick, int, dfd, const char __user *, path, unsigned int, flags)
+{
+	struct fs_context *fc;
+	struct path target;
+	unsigned int lookup_flags;
+	int ret;
+
+	if (!ns_capable(current->nsproxy->mnt_ns->user_ns, CAP_SYS_ADMIN))
+		return -EPERM;
+
+	if ((flags & ~(FSPICK_CLOEXEC |
+		       FSPICK_SYMLINK_NOFOLLOW |
+		       FSPICK_NO_AUTOMOUNT |
+		       FSPICK_EMPTY_PATH)) != 0)
+		return -EINVAL;
+
+	lookup_flags = LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT;
+	if (flags & FSPICK_SYMLINK_NOFOLLOW)
+		lookup_flags &= ~LOOKUP_FOLLOW;
+	if (flags & FSPICK_NO_AUTOMOUNT)
+		lookup_flags &= ~LOOKUP_AUTOMOUNT;
+	if (flags & FSPICK_EMPTY_PATH)
+		lookup_flags |= LOOKUP_EMPTY;
+	ret = user_path_at(dfd, path, lookup_flags, &target);
+	if (ret < 0)
+		goto err;
+
+	ret = -EINVAL;
+	if (target.mnt->mnt_root != target.dentry)
+		goto err_path;
+
+	fc = fs_context_for_reconfigure(target.dentry, 0, 0);
+	if (IS_ERR(fc)) {
+		ret = PTR_ERR(fc);
+		goto err_path;
+	}
+
+	fc->phase = FS_CONTEXT_RECONF_PARAMS;
+
+	ret = fscontext_alloc_log(fc);
+	if (ret < 0)
+		goto err_fc;
+
+	path_put(&target);
+	return fscontext_create_fd(fc, flags & FSPICK_CLOEXEC ? O_CLOEXEC : 0);
+
+err_fc:
+	put_fs_context(fc);
+err_path:
+	path_put(&target);
+err:
+	return ret;
+}
+
 /*
  * Check the state and apply the configuration.  Note that this function is
  * allowed to 'steal' the value by setting param->xxx to NULL before returning.

commit ecdab150fddb42fe6a739335257949220033b782
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:36:09 2018 +0000

    vfs: syscall: Add fsconfig() for configuring and managing a context
    
    Add a syscall for configuring a filesystem creation context and triggering
    actions upon it, to be used in conjunction with fsopen, fspick and fsmount.
    
        long fsconfig(int fs_fd, unsigned int cmd, const char *key,
                      const void *value, int aux);
    
    Where fs_fd indicates the context, cmd indicates the action to take, key
    indicates the parameter name for parameter-setting actions and, if needed,
    value points to a buffer containing the value and aux can give more
    information for the value.
    
    The following command IDs are proposed:
    
     (*) FSCONFIG_SET_FLAG: No value is specified.  The parameter must be
         boolean in nature.  The key may be prefixed with "no" to invert the
         setting. value must be NULL and aux must be 0.
    
     (*) FSCONFIG_SET_STRING: A string value is specified.  The parameter can
         be expecting boolean, integer, string or take a path.  A conversion to
         an appropriate type will be attempted (which may include looking up as
         a path).  value points to a NUL-terminated string and aux must be 0.
    
     (*) FSCONFIG_SET_BINARY: A binary blob is specified.  value points to
         the blob and aux indicates its size.  The parameter must be expecting
         a blob.
    
     (*) FSCONFIG_SET_PATH: A non-empty path is specified.  The parameter must
         be expecting a path object.  value points to a NUL-terminated string
         that is the path and aux is a file descriptor at which to start a
         relative lookup or AT_FDCWD.
    
     (*) FSCONFIG_SET_PATH_EMPTY: As fsconfig_set_path, but with AT_EMPTY_PATH
         implied.
    
     (*) FSCONFIG_SET_FD: An open file descriptor is specified.  value must
         be NULL and aux indicates the file descriptor.
    
     (*) FSCONFIG_CMD_CREATE: Trigger superblock creation.
    
     (*) FSCONFIG_CMD_RECONFIGURE: Trigger superblock reconfiguration.
    
    For the "set" command IDs, the idea is that the file_system_type will point
    to a list of parameters and the types of value that those parameters expect
    to take.  The core code can then do the parse and argument conversion and
    then give the LSM and FS a cooked option or array of options to use.
    
    Source specification is also done the same way same way, using special keys
    "source", "source1", "source2", etc..
    
    [!] Note that, for the moment, the key and value are just glued back
    together and handed to the filesystem.  Every filesystem that uses options
    uses match_token() and co. to do this, and this will need to be changed -
    but not all at once.
    
    Example usage:
    
        fd = fsopen("ext4", FSOPEN_CLOEXEC);
        fsconfig(fd, fsconfig_set_path, "source", "/dev/sda1", AT_FDCWD);
        fsconfig(fd, fsconfig_set_path_empty, "journal_path", "", journal_fd);
        fsconfig(fd, fsconfig_set_fd, "journal_fd", "", journal_fd);
        fsconfig(fd, fsconfig_set_flag, "user_xattr", NULL, 0);
        fsconfig(fd, fsconfig_set_flag, "noacl", NULL, 0);
        fsconfig(fd, fsconfig_set_string, "sb", "1", 0);
        fsconfig(fd, fsconfig_set_string, "errors", "continue", 0);
        fsconfig(fd, fsconfig_set_string, "data", "journal", 0);
        fsconfig(fd, fsconfig_set_string, "context", "unconfined_u:...", 0);
        fsconfig(fd, fsconfig_cmd_create, NULL, NULL, 0);
        mfd = fsmount(fd, FSMOUNT_CLOEXEC, MS_NOEXEC);
    
    or:
    
        fd = fsopen("ext4", FSOPEN_CLOEXEC);
        fsconfig(fd, fsconfig_set_string, "source", "/dev/sda1", 0);
        fsconfig(fd, fsconfig_cmd_create, NULL, NULL, 0);
        mfd = fsmount(fd, FSMOUNT_CLOEXEC, MS_NOEXEC);
    
    or:
    
        fd = fsopen("afs", FSOPEN_CLOEXEC);
        fsconfig(fd, fsconfig_set_string, "source", "#grand.central.org:root.cell", 0);
        fsconfig(fd, fsconfig_cmd_create, NULL, NULL, 0);
        mfd = fsmount(fd, FSMOUNT_CLOEXEC, MS_NOEXEC);
    
    or:
    
        fd = fsopen("jffs2", FSOPEN_CLOEXEC);
        fsconfig(fd, fsconfig_set_string, "source", "mtd0", 0);
        fsconfig(fd, fsconfig_cmd_create, NULL, NULL, 0);
        mfd = fsmount(fd, FSMOUNT_CLOEXEC, MS_NOEXEC);
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-api@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fsopen.c b/fs/fsopen.c
index 5fce6347de7a..65cc2f68f994 100644
--- a/fs/fsopen.c
+++ b/fs/fsopen.c
@@ -10,6 +10,7 @@
  */
 
 #include <linux/fs_context.h>
+#include <linux/fs_parser.h>
 #include <linux/slab.h>
 #include <linux/uaccess.h>
 #include <linux/syscalls.h>
@@ -18,6 +19,7 @@
 #include <linux/namei.h>
 #include <linux/file.h>
 #include <uapi/linux/mount.h>
+#include "internal.h"
 #include "mount.h"
 
 /*
@@ -153,3 +155,266 @@ SYSCALL_DEFINE2(fsopen, const char __user *, _fs_name, unsigned int, flags)
 	put_fs_context(fc);
 	return ret;
 }
+
+/*
+ * Check the state and apply the configuration.  Note that this function is
+ * allowed to 'steal' the value by setting param->xxx to NULL before returning.
+ */
+static int vfs_fsconfig_locked(struct fs_context *fc, int cmd,
+			       struct fs_parameter *param)
+{
+	struct super_block *sb;
+	int ret;
+
+	ret = finish_clean_context(fc);
+	if (ret)
+		return ret;
+	switch (cmd) {
+	case FSCONFIG_CMD_CREATE:
+		if (fc->phase != FS_CONTEXT_CREATE_PARAMS)
+			return -EBUSY;
+		fc->phase = FS_CONTEXT_CREATING;
+		ret = vfs_get_tree(fc);
+		if (ret)
+			break;
+		sb = fc->root->d_sb;
+		ret = security_sb_kern_mount(sb);
+		if (unlikely(ret)) {
+			fc_drop_locked(fc);
+			break;
+		}
+		up_write(&sb->s_umount);
+		fc->phase = FS_CONTEXT_AWAITING_MOUNT;
+		return 0;
+	case FSCONFIG_CMD_RECONFIGURE:
+		if (fc->phase != FS_CONTEXT_RECONF_PARAMS)
+			return -EBUSY;
+		fc->phase = FS_CONTEXT_RECONFIGURING;
+		sb = fc->root->d_sb;
+		if (!ns_capable(sb->s_user_ns, CAP_SYS_ADMIN)) {
+			ret = -EPERM;
+			break;
+		}
+		down_write(&sb->s_umount);
+		ret = reconfigure_super(fc);
+		up_write(&sb->s_umount);
+		if (ret)
+			break;
+		vfs_clean_context(fc);
+		return 0;
+	default:
+		if (fc->phase != FS_CONTEXT_CREATE_PARAMS &&
+		    fc->phase != FS_CONTEXT_RECONF_PARAMS)
+			return -EBUSY;
+
+		return vfs_parse_fs_param(fc, param);
+	}
+	fc->phase = FS_CONTEXT_FAILED;
+	return ret;
+}
+
+/**
+ * sys_fsconfig - Set parameters and trigger actions on a context
+ * @fd: The filesystem context to act upon
+ * @cmd: The action to take
+ * @_key: Where appropriate, the parameter key to set
+ * @_value: Where appropriate, the parameter value to set
+ * @aux: Additional information for the value
+ *
+ * This system call is used to set parameters on a context, including
+ * superblock settings, data source and security labelling.
+ *
+ * Actions include triggering the creation of a superblock and the
+ * reconfiguration of the superblock attached to the specified context.
+ *
+ * When setting a parameter, @cmd indicates the type of value being proposed
+ * and @_key indicates the parameter to be altered.
+ *
+ * @_value and @aux are used to specify the value, should a value be required:
+ *
+ * (*) fsconfig_set_flag: No value is specified.  The parameter must be boolean
+ *     in nature.  The key may be prefixed with "no" to invert the
+ *     setting. @_value must be NULL and @aux must be 0.
+ *
+ * (*) fsconfig_set_string: A string value is specified.  The parameter can be
+ *     expecting boolean, integer, string or take a path.  A conversion to an
+ *     appropriate type will be attempted (which may include looking up as a
+ *     path).  @_value points to a NUL-terminated string and @aux must be 0.
+ *
+ * (*) fsconfig_set_binary: A binary blob is specified.  @_value points to the
+ *     blob and @aux indicates its size.  The parameter must be expecting a
+ *     blob.
+ *
+ * (*) fsconfig_set_path: A non-empty path is specified.  The parameter must be
+ *     expecting a path object.  @_value points to a NUL-terminated string that
+ *     is the path and @aux is a file descriptor at which to start a relative
+ *     lookup or AT_FDCWD.
+ *
+ * (*) fsconfig_set_path_empty: As fsconfig_set_path, but with AT_EMPTY_PATH
+ *     implied.
+ *
+ * (*) fsconfig_set_fd: An open file descriptor is specified.  @_value must be
+ *     NULL and @aux indicates the file descriptor.
+ */
+SYSCALL_DEFINE5(fsconfig,
+		int, fd,
+		unsigned int, cmd,
+		const char __user *, _key,
+		const void __user *, _value,
+		int, aux)
+{
+	struct fs_context *fc;
+	struct fd f;
+	int ret;
+
+	struct fs_parameter param = {
+		.type	= fs_value_is_undefined,
+	};
+
+	if (fd < 0)
+		return -EINVAL;
+
+	switch (cmd) {
+	case FSCONFIG_SET_FLAG:
+		if (!_key || _value || aux)
+			return -EINVAL;
+		break;
+	case FSCONFIG_SET_STRING:
+		if (!_key || !_value || aux)
+			return -EINVAL;
+		break;
+	case FSCONFIG_SET_BINARY:
+		if (!_key || !_value || aux <= 0 || aux > 1024 * 1024)
+			return -EINVAL;
+		break;
+	case FSCONFIG_SET_PATH:
+	case FSCONFIG_SET_PATH_EMPTY:
+		if (!_key || !_value || (aux != AT_FDCWD && aux < 0))
+			return -EINVAL;
+		break;
+	case FSCONFIG_SET_FD:
+		if (!_key || _value || aux < 0)
+			return -EINVAL;
+		break;
+	case FSCONFIG_CMD_CREATE:
+	case FSCONFIG_CMD_RECONFIGURE:
+		if (_key || _value || aux)
+			return -EINVAL;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	f = fdget(fd);
+	if (!f.file)
+		return -EBADF;
+	ret = -EINVAL;
+	if (f.file->f_op != &fscontext_fops)
+		goto out_f;
+
+	fc = f.file->private_data;
+	if (fc->ops == &legacy_fs_context_ops) {
+		switch (cmd) {
+		case FSCONFIG_SET_BINARY:
+		case FSCONFIG_SET_PATH:
+		case FSCONFIG_SET_PATH_EMPTY:
+		case FSCONFIG_SET_FD:
+			ret = -EOPNOTSUPP;
+			goto out_f;
+		}
+	}
+
+	if (_key) {
+		param.key = strndup_user(_key, 256);
+		if (IS_ERR(param.key)) {
+			ret = PTR_ERR(param.key);
+			goto out_f;
+		}
+	}
+
+	switch (cmd) {
+	case FSCONFIG_SET_FLAG:
+		param.type = fs_value_is_flag;
+		break;
+	case FSCONFIG_SET_STRING:
+		param.type = fs_value_is_string;
+		param.string = strndup_user(_value, 256);
+		if (IS_ERR(param.string)) {
+			ret = PTR_ERR(param.string);
+			goto out_key;
+		}
+		param.size = strlen(param.string);
+		break;
+	case FSCONFIG_SET_BINARY:
+		param.type = fs_value_is_blob;
+		param.size = aux;
+		param.blob = memdup_user_nul(_value, aux);
+		if (IS_ERR(param.blob)) {
+			ret = PTR_ERR(param.blob);
+			goto out_key;
+		}
+		break;
+	case FSCONFIG_SET_PATH:
+		param.type = fs_value_is_filename;
+		param.name = getname_flags(_value, 0, NULL);
+		if (IS_ERR(param.name)) {
+			ret = PTR_ERR(param.name);
+			goto out_key;
+		}
+		param.dirfd = aux;
+		param.size = strlen(param.name->name);
+		break;
+	case FSCONFIG_SET_PATH_EMPTY:
+		param.type = fs_value_is_filename_empty;
+		param.name = getname_flags(_value, LOOKUP_EMPTY, NULL);
+		if (IS_ERR(param.name)) {
+			ret = PTR_ERR(param.name);
+			goto out_key;
+		}
+		param.dirfd = aux;
+		param.size = strlen(param.name->name);
+		break;
+	case FSCONFIG_SET_FD:
+		param.type = fs_value_is_file;
+		ret = -EBADF;
+		param.file = fget(aux);
+		if (!param.file)
+			goto out_key;
+		break;
+	default:
+		break;
+	}
+
+	ret = mutex_lock_interruptible(&fc->uapi_mutex);
+	if (ret == 0) {
+		ret = vfs_fsconfig_locked(fc, cmd, &param);
+		mutex_unlock(&fc->uapi_mutex);
+	}
+
+	/* Clean up the our record of any value that we obtained from
+	 * userspace.  Note that the value may have been stolen by the LSM or
+	 * filesystem, in which case the value pointer will have been cleared.
+	 */
+	switch (cmd) {
+	case FSCONFIG_SET_STRING:
+	case FSCONFIG_SET_BINARY:
+		kfree(param.string);
+		break;
+	case FSCONFIG_SET_PATH:
+	case FSCONFIG_SET_PATH_EMPTY:
+		if (param.name)
+			putname(param.name);
+		break;
+	case FSCONFIG_SET_FD:
+		if (param.file)
+			fput(param.file);
+		break;
+	default:
+		break;
+	}
+out_key:
+	kfree(param.key);
+out_f:
+	fdput(f);
+	return ret;
+}

commit 007ec26cdc9fefacbed85b592afc69413194499c
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:34:29 2018 +0000

    vfs: Implement logging through fs_context
    
    Implement the ability for filesystems to log error, warning and
    informational messages through the fs_context.  These can be extracted by
    userspace by reading from an fd created by fsopen().
    
    Error messages are prefixed with "e ", warnings with "w " and informational
    messages with "i ".
    
    Inside the kernel, formatted messages are malloc'd but unformatted messages
    are not copied if they're either in the core .rodata section or in the
    .rodata section of the filesystem module pinned by fs_context::fs_type.
    The messages are only good till the fs_type is released.
    
    Note that the logging object is shared between duplicated fs_context
    structures.  This is so that such as NFS which do a mount within a mount
    can get at least some of the errors from the inner mount.
    
    Five logging functions are provided for this:
    
     (1) void logfc(struct fs_context *fc, const char *fmt, ...);
    
         This logs a message into the context.  If the buffer is full, the
         earliest message is discarded.
    
     (2) void errorf(fc, fmt, ...);
    
         This wraps logfc() to log an error.
    
     (3) void invalf(fc, fmt, ...);
    
         This wraps errorf() and returns -EINVAL for convenience.
    
     (4) void warnf(fc, fmt, ...);
    
         This wraps logfc() to log a warning.
    
     (5) void infof(fc, fmt, ...);
    
         This wraps logfc() to log an informational message.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fsopen.c b/fs/fsopen.c
index d256f1ac9ff1..5fce6347de7a 100644
--- a/fs/fsopen.c
+++ b/fs/fsopen.c
@@ -20,6 +20,52 @@
 #include <uapi/linux/mount.h>
 #include "mount.h"
 
+/*
+ * Allow the user to read back any error, warning or informational messages.
+ */
+static ssize_t fscontext_read(struct file *file,
+			      char __user *_buf, size_t len, loff_t *pos)
+{
+	struct fs_context *fc = file->private_data;
+	struct fc_log *log = fc->log;
+	unsigned int logsize = ARRAY_SIZE(log->buffer);
+	ssize_t ret;
+	char *p;
+	bool need_free;
+	int index, n;
+
+	ret = mutex_lock_interruptible(&fc->uapi_mutex);
+	if (ret < 0)
+		return ret;
+
+	if (log->head == log->tail) {
+		mutex_unlock(&fc->uapi_mutex);
+		return -ENODATA;
+	}
+
+	index = log->tail & (logsize - 1);
+	p = log->buffer[index];
+	need_free = log->need_free & (1 << index);
+	log->buffer[index] = NULL;
+	log->need_free &= ~(1 << index);
+	log->tail++;
+	mutex_unlock(&fc->uapi_mutex);
+
+	ret = -EMSGSIZE;
+	n = strlen(p);
+	if (n > len)
+		goto err_free;
+	ret = -EFAULT;
+	if (copy_to_user(_buf, p, n) != 0)
+		goto err_free;
+	ret = n;
+
+err_free:
+	if (need_free)
+		kfree(p);
+	return ret;
+}
+
 static int fscontext_release(struct inode *inode, struct file *file)
 {
 	struct fs_context *fc = file->private_data;
@@ -32,6 +78,7 @@ static int fscontext_release(struct inode *inode, struct file *file)
 }
 
 const struct file_operations fscontext_fops = {
+	.read		= fscontext_read,
 	.release	= fscontext_release,
 	.llseek		= no_llseek,
 };
@@ -50,6 +97,16 @@ static int fscontext_create_fd(struct fs_context *fc, unsigned int o_flags)
 	return fd;
 }
 
+static int fscontext_alloc_log(struct fs_context *fc)
+{
+	fc->log = kzalloc(sizeof(*fc->log), GFP_KERNEL);
+	if (!fc->log)
+		return -ENOMEM;
+	refcount_set(&fc->log->usage, 1);
+	fc->log->owner = fc->fs_type->owner;
+	return 0;
+}
+
 /*
  * Open a filesystem by name so that it can be configured for mounting.
  *
@@ -62,6 +119,7 @@ SYSCALL_DEFINE2(fsopen, const char __user *, _fs_name, unsigned int, flags)
 	struct file_system_type *fs_type;
 	struct fs_context *fc;
 	const char *fs_name;
+	int ret;
 
 	if (!ns_capable(current->nsproxy->mnt_ns->user_ns, CAP_SYS_ADMIN))
 		return -EPERM;
@@ -84,5 +142,14 @@ SYSCALL_DEFINE2(fsopen, const char __user *, _fs_name, unsigned int, flags)
 		return PTR_ERR(fc);
 
 	fc->phase = FS_CONTEXT_CREATE_PARAMS;
+
+	ret = fscontext_alloc_log(fc);
+	if (ret < 0)
+		goto err_fc;
+
 	return fscontext_create_fd(fc, flags & FSOPEN_CLOEXEC ? O_CLOEXEC : 0);
+
+err_fc:
+	put_fs_context(fc);
+	return ret;
 }

commit 24dcb3d90a1f67fe08c68a004af37df059d74005
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:33:31 2018 +0000

    vfs: syscall: Add fsopen() to prepare for superblock creation
    
    Provide an fsopen() system call that starts the process of preparing to
    create a superblock that will then be mountable, using an fd as a context
    handle.  fsopen() is given the name of the filesystem that will be used:
    
            int mfd = fsopen(const char *fsname, unsigned int flags);
    
    where flags can be 0 or FSOPEN_CLOEXEC.
    
    For example:
    
            sfd = fsopen("ext4", FSOPEN_CLOEXEC);
            fsconfig(sfd, FSCONFIG_SET_PATH, "source", "/dev/sda1", AT_FDCWD);
            fsconfig(sfd, FSCONFIG_SET_FLAG, "noatime", NULL, 0);
            fsconfig(sfd, FSCONFIG_SET_FLAG, "acl", NULL, 0);
            fsconfig(sfd, FSCONFIG_SET_FLAG, "user_xattr", NULL, 0);
            fsconfig(sfd, FSCONFIG_SET_STRING, "sb", "1", 0);
            fsconfig(sfd, FSCONFIG_CMD_CREATE, NULL, NULL, 0);
            fsinfo(sfd, NULL, ...); // query new superblock attributes
            mfd = fsmount(sfd, FSMOUNT_CLOEXEC, MS_RELATIME);
            move_mount(mfd, "", sfd, AT_FDCWD, "/mnt", MOVE_MOUNT_F_EMPTY_PATH);
    
            sfd = fsopen("afs", -1);
            fsconfig(fd, FSCONFIG_SET_STRING, "source",
                     "#grand.central.org:root.cell", 0);
            fsconfig(fd, FSCONFIG_CMD_CREATE, NULL, NULL, 0);
            mfd = fsmount(sfd, 0, MS_NODEV);
            move_mount(mfd, "", sfd, AT_FDCWD, "/mnt", MOVE_MOUNT_F_EMPTY_PATH);
    
    If an error is reported at any step, an error message may be available to be
    read() back (ENODATA will be reported if there isn't an error available) in
    the form:
    
            "e <subsys>:<problem>"
            "e SELinux:Mount on mountpoint not permitted"
    
    Once fsmount() has been called, further fsconfig() calls will incur EBUSY,
    even if the fsmount() fails.  read() is still possible to retrieve error
    information.
    
    The fsopen() syscall creates a mount context and hangs it of the fd that it
    returns.
    
    Netlink is not used because it is optional and would make the core VFS
    dependent on the networking layer and also potentially add network
    namespace issues.
    
    Note that, for the moment, the caller must have SYS_CAP_ADMIN to use
    fsopen().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-api@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fsopen.c b/fs/fsopen.c
new file mode 100644
index 000000000000..d256f1ac9ff1
--- /dev/null
+++ b/fs/fsopen.c
@@ -0,0 +1,88 @@
+/* Filesystem access-by-fd.
+ *
+ * Copyright (C) 2017 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+
+#include <linux/fs_context.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/syscalls.h>
+#include <linux/security.h>
+#include <linux/anon_inodes.h>
+#include <linux/namei.h>
+#include <linux/file.h>
+#include <uapi/linux/mount.h>
+#include "mount.h"
+
+static int fscontext_release(struct inode *inode, struct file *file)
+{
+	struct fs_context *fc = file->private_data;
+
+	if (fc) {
+		file->private_data = NULL;
+		put_fs_context(fc);
+	}
+	return 0;
+}
+
+const struct file_operations fscontext_fops = {
+	.release	= fscontext_release,
+	.llseek		= no_llseek,
+};
+
+/*
+ * Attach a filesystem context to a file and an fd.
+ */
+static int fscontext_create_fd(struct fs_context *fc, unsigned int o_flags)
+{
+	int fd;
+
+	fd = anon_inode_getfd("fscontext", &fscontext_fops, fc,
+			      O_RDWR | o_flags);
+	if (fd < 0)
+		put_fs_context(fc);
+	return fd;
+}
+
+/*
+ * Open a filesystem by name so that it can be configured for mounting.
+ *
+ * We are allowed to specify a container in which the filesystem will be
+ * opened, thereby indicating which namespaces will be used (notably, which
+ * network namespace will be used for network filesystems).
+ */
+SYSCALL_DEFINE2(fsopen, const char __user *, _fs_name, unsigned int, flags)
+{
+	struct file_system_type *fs_type;
+	struct fs_context *fc;
+	const char *fs_name;
+
+	if (!ns_capable(current->nsproxy->mnt_ns->user_ns, CAP_SYS_ADMIN))
+		return -EPERM;
+
+	if (flags & ~FSOPEN_CLOEXEC)
+		return -EINVAL;
+
+	fs_name = strndup_user(_fs_name, PAGE_SIZE);
+	if (IS_ERR(fs_name))
+		return PTR_ERR(fs_name);
+
+	fs_type = get_fs_type(fs_name);
+	kfree(fs_name);
+	if (!fs_type)
+		return -ENODEV;
+
+	fc = fs_context_for_mount(fs_type, 0);
+	put_filesystem(fs_type);
+	if (IS_ERR(fc))
+		return PTR_ERR(fc);
+
+	fc->phase = FS_CONTEXT_CREATE_PARAMS;
+	return fscontext_create_fd(fc, flags & FSOPEN_CLOEXEC ? O_CLOEXEC : 0);
+}
