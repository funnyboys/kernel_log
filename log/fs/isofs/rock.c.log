commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 0ec137310320..94ef92fe806c 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *  linux/fs/isofs/rock.c
  *

commit a107bf8b3905b61bf8b5c181268bca8c05af7f69
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Wed Nov 30 09:52:01 2016 +0200

    isofs: add KERN_CONT to printing of ER records
    
    The ER records are printed without explicit log level presuming line
    continuation until "\n".  After the commit 4bcc595ccd8 (printk:
    reinstate KERN_CONT for printing continuation lines), the ER records are
    printed a character per line.
    
    Adding KERN_CONT to appropriate printk statements restores the printout
    behavior.
    
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 98b3eb7d8eaf..0ec137310320 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -377,9 +377,9 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 			{
 				int p;
 				for (p = 0; p < rr->u.ER.len_id; p++)
-					printk("%c", rr->u.ER.data[p]);
+					printk(KERN_CONT "%c", rr->u.ER.data[p]);
 			}
-			printk("\n");
+			printk(KERN_CONT "\n");
 			break;
 		case SIG('P', 'X'):
 			inode->i_mode = isonum_733(rr->u.PX.mode);

commit 99d825822eade8d827a1817357cbf3f889a552d6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu May 5 16:25:35 2016 -0400

    get_rock_ridge_filename(): handle malformed NM entries
    
    Payloads of NM entries are not supposed to contain NUL.  When we run
    into such, only the part prior to the first NUL goes into the
    concatenation (i.e. the directory entry name being encoded by a bunch
    of NM entries).  We do stop when the amount collected so far + the
    claimed amount in the current NM entry exceed 254.  So far, so good,
    but what we return as the total length is the sum of *claimed*
    sizes, not the actual amount collected.  And that can grow pretty
    large - not unlimited, since you'd need to put CE entries in
    between to be able to get more than the maximum that could be
    contained in one isofs directory entry / continuation chunk and
    we are stop once we'd encountered 32 CEs, but you can get about 8Kb
    easily.  And that's what will be passed to readdir callback as the
    name length.  8Kb __copy_to_user() from a buffer allocated by
    __get_free_page()
    
    Cc: stable@vger.kernel.org # 0.98pl6+ (yes, really)
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 5384ceb35b1c..98b3eb7d8eaf 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -203,6 +203,8 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 	int retnamlen = 0;
 	int truncate = 0;
 	int ret = 0;
+	char *p;
+	int len;
 
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
 		return 0;
@@ -267,12 +269,17 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 					rr->u.NM.flags);
 				break;
 			}
-			if ((strlen(retname) + rr->len - 5) >= 254) {
+			len = rr->len - 5;
+			if (retnamlen + len >= 254) {
 				truncate = 1;
 				break;
 			}
-			strncat(retname, rr->u.NM.name, rr->len - 5);
-			retnamlen += rr->len - 5;
+			p = memchr(rr->u.NM.name, '\0', len);
+			if (unlikely(p))
+				len = p - rr->u.NM.name;
+			memcpy(retname + retnamlen, rr->u.NM.name, len);
+			retnamlen += len;
+			retname[retnamlen] = '\0';
 			break;
 		case SIG('R', 'E'):
 			kfree(rs.buffer);

commit 21fc61c73c3903c4c312d0802da01ec2b323d174
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Nov 17 01:07:57 2015 -0500

    don't put symlink bodies in pagecache into highmem
    
    kmap() in page_follow_link_light() needed to go - allowing to hold
    an arbitrary number of kmaps for long is a great way to deadlocking
    the system.
    
    new helper (inode_nohighmem(inode)) needs to be used for pagecache
    symlinks inodes; done for all in-tree cases.  page_follow_link_light()
    instrumented to yell about anything missed.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 735d7522a3a9..5384ceb35b1c 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -687,7 +687,7 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	struct inode *inode = page->mapping->host;
 	struct iso_inode_info *ei = ISOFS_I(inode);
 	struct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);
-	char *link = kmap(page);
+	char *link = page_address(page);
 	unsigned long bufsize = ISOFS_BUFFER_SIZE(inode);
 	struct buffer_head *bh;
 	char *rpnt = link;
@@ -774,7 +774,6 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	brelse(bh);
 	*rpnt = '\0';
 	SetPageUptodate(page);
-	kunmap(page);
 	unlock_page(page);
 	return 0;
 
@@ -791,7 +790,6 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	brelse(bh);
 error:
 	SetPageError(page);
-	kunmap(page);
 	unlock_page(page);
 	return -EIO;
 }

commit 4e2024624e678f0ebb916e6192bd23c1f9fdf696
Author: Jan Kara <jack@suse.cz>
Date:   Thu Dec 18 17:26:10 2014 +0100

    isofs: Fix unchecked printing of ER records
    
    We didn't check length of rock ridge ER records before printing them.
    Thus corrupted isofs image can cause us to access and print some memory
    behind the buffer with obvious consequences.
    
    Reported-and-tested-by: Carl Henrik Lunde <chlunde@ping.uio.no>
    CC: stable@vger.kernel.org
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index bb63254ed848..735d7522a3a9 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -362,6 +362,9 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 			rs.cont_size = isonum_733(rr->u.CE.size);
 			break;
 		case SIG('E', 'R'):
+			/* Invalid length of ER tag id? */
+			if (rr->u.ER.len_id + offsetof(struct rock_ridge, u.ER.data) > rr->len)
+				goto out;
 			ISOFS_SB(inode->i_sb)->s_rock = 1;
 			printk(KERN_DEBUG "ISO 9660 Extensions: ");
 			{

commit f54e18f1b831c92f6512d2eedb224cd63d607d3d
Author: Jan Kara <jack@suse.cz>
Date:   Mon Dec 15 14:22:46 2014 +0100

    isofs: Fix infinite looping over CE entries
    
    Rock Ridge extensions define so called Continuation Entries (CE) which
    define where is further space with Rock Ridge data. Corrupted isofs
    image can contain arbitrarily long chain of these, including a one
    containing loop and thus causing kernel to end in an infinite loop when
    traversing these entries.
    
    Limit the traversal to 32 entries which should be more than enough space
    to store all the Rock Ridge data.
    
    Reported-by: P J P <ppandit@redhat.com>
    CC: stable@vger.kernel.org
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index f488bbae541a..bb63254ed848 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -30,6 +30,7 @@ struct rock_state {
 	int cont_size;
 	int cont_extent;
 	int cont_offset;
+	int cont_loops;
 	struct inode *inode;
 };
 
@@ -73,6 +74,9 @@ static void init_rock_state(struct rock_state *rs, struct inode *inode)
 	rs->inode = inode;
 }
 
+/* Maximum number of Rock Ridge continuation entries */
+#define RR_MAX_CE_ENTRIES 32
+
 /*
  * Returns 0 if the caller should continue scanning, 1 if the scan must end
  * and -ve on error.
@@ -105,6 +109,8 @@ static int rock_continue(struct rock_state *rs)
 			goto out;
 		}
 		ret = -EIO;
+		if (++rs->cont_loops >= RR_MAX_CE_ENTRIES)
+			goto out;
 		bh = sb_bread(rs->inode->i_sb, rs->cont_extent);
 		if (bh) {
 			memcpy(rs->buffer, bh->b_data + rs->cont_offset,

commit 410dd3cf4c9b36f27ed4542ee18b1af5e68645a4
Author: Jan Kara <jack@suse.cz>
Date:   Sun Aug 17 11:49:57 2014 +0200

    isofs: Fix unbounded recursion when processing relocated directories
    
    We did not check relocated directory in any way when processing Rock
    Ridge 'CL' tag. Thus a corrupted isofs image can possibly have a CL
    entry pointing to another CL entry leading to possibly unbounded
    recursion in kernel code and thus stack overflow or deadlocks (if there
    is a loop created from CL entries).
    
    Fix the problem by not allowing CL entry to point to a directory entry
    with CL entry (such use makes no good sense anyway) and by checking
    whether CL entry doesn't point to itself.
    
    CC: stable@vger.kernel.org
    Reported-by: Chris Evans <cevans@google.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index c0bf42472e40..f488bbae541a 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -288,12 +288,16 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 	goto out;
 }
 
+#define RR_REGARD_XA 1
+#define RR_RELOC_DE 2
+
 static int
 parse_rock_ridge_inode_internal(struct iso_directory_record *de,
-				struct inode *inode, int regard_xa)
+				struct inode *inode, int flags)
 {
 	int symlink_len = 0;
 	int cnt, sig;
+	unsigned int reloc_block;
 	struct inode *reloc;
 	struct rock_ridge *rr;
 	int rootflag;
@@ -305,7 +309,7 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 
 	init_rock_state(&rs, inode);
 	setup_rock_ridge(de, inode, &rs);
-	if (regard_xa) {
+	if (flags & RR_REGARD_XA) {
 		rs.chr += 14;
 		rs.len -= 14;
 		if (rs.len < 0)
@@ -485,12 +489,22 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 					"relocated directory\n");
 			goto out;
 		case SIG('C', 'L'):
-			ISOFS_I(inode)->i_first_extent =
-			    isonum_733(rr->u.CL.location);
-			reloc =
-			    isofs_iget(inode->i_sb,
-				       ISOFS_I(inode)->i_first_extent,
-				       0);
+			if (flags & RR_RELOC_DE) {
+				printk(KERN_ERR
+				       "ISOFS: Recursive directory relocation "
+				       "is not supported\n");
+				goto eio;
+			}
+			reloc_block = isonum_733(rr->u.CL.location);
+			if (reloc_block == ISOFS_I(inode)->i_iget5_block &&
+			    ISOFS_I(inode)->i_iget5_offset == 0) {
+				printk(KERN_ERR
+				       "ISOFS: Directory relocation points to "
+				       "itself\n");
+				goto eio;
+			}
+			ISOFS_I(inode)->i_first_extent = reloc_block;
+			reloc = isofs_iget_reloc(inode->i_sb, reloc_block, 0);
 			if (IS_ERR(reloc)) {
 				ret = PTR_ERR(reloc);
 				goto out;
@@ -637,9 +651,11 @@ static char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)
 	return rpnt;
 }
 
-int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode)
+int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode,
+			   int relocated)
 {
-	int result = parse_rock_ridge_inode_internal(de, inode, 0);
+	int flags = relocated ? RR_RELOC_DE : 0;
+	int result = parse_rock_ridge_inode_internal(de, inode, flags);
 
 	/*
 	 * if rockridge flag was reset and we didn't look for attributes
@@ -647,7 +663,8 @@ int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode)
 	 */
 	if ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)
 	    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {
-		result = parse_rock_ridge_inode_internal(de, inode, 14);
+		result = parse_rock_ridge_inode_internal(de, inode,
+							 flags | RR_REGARD_XA);
 	}
 	return result;
 }

commit ba64e2b9e368fbe588ed5e3bb1494cc1dc4664a4
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Feb 10 11:35:50 2012 -0800

    userns: Convert isofs to use kuid/kgid where appropriate
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 70e79d0c756a..c0bf42472e40 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -364,8 +364,8 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 		case SIG('P', 'X'):
 			inode->i_mode = isonum_733(rr->u.PX.mode);
 			set_nlink(inode, isonum_733(rr->u.PX.n_links));
-			inode->i_uid = isonum_733(rr->u.PX.uid);
-			inode->i_gid = isonum_733(rr->u.PX.gid);
+			i_uid_write(inode, isonum_733(rr->u.PX.uid));
+			i_gid_write(inode, isonum_733(rr->u.PX.gid));
 			break;
 		case SIG('P', 'N'):
 			{

commit bfe8684869601dacfcb2cd69ef8cfd9045f62170
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Oct 28 14:13:29 2011 +0200

    filesystems: add set_nlink()
    
    Replace remaining direct i_nlink updates with a new set_nlink()
    updater function.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Tested-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 1fbc7de88f50..70e79d0c756a 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -363,7 +363,7 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 			break;
 		case SIG('P', 'X'):
 			inode->i_mode = isonum_733(rr->u.PX.mode);
-			inode->i_nlink = isonum_733(rr->u.PX.n_links);
+			set_nlink(inode, isonum_733(rr->u.PX.n_links));
 			inode->i_uid = isonum_733(rr->u.PX.uid);
 			inode->i_gid = isonum_733(rr->u.PX.gid);
 			break;
@@ -496,7 +496,7 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 				goto out;
 			}
 			inode->i_mode = reloc->i_mode;
-			inode->i_nlink = reloc->i_nlink;
+			set_nlink(inode, reloc->i_nlink);
 			inode->i_uid = reloc->i_uid;
 			inode->i_gid = reloc->i_gid;
 			inode->i_rdev = reloc->i_rdev;

commit d769b3c2ab7184ddd42056595b627cc871caa90e
Author: Jan Kara <jack@suse.cz>
Date:   Thu Jul 21 22:22:25 2011 +0200

    isofs: Remove global fs lock
    
    sbi->s_mutex isn't needed for isofs at all so we can just remove it. Generally,
    since isofs is always mounted read-only, filesystem structure cannot change
    under us.  So buffer_head contents stays constant after it's filled in. That
    leaves us with possible changes of global data structures. Superblock changes
    only during filesystem mount (even remount does not change it), inodes are only
    filled in during reading from disk. So there are no changes of these structures
    to bother about.
    
    Arguments why sbi->s_mutex can be removed at each place:
    isofs_readdir: Accesses sb, inode, filp, local variables => s_mutex not needed
    isofs_lookup: Protected by directory's i_mutex. Accesses sb, inode, dentry,
      local variables => s_mutex not needed
    rock_ridge_symlink_readpage: Protected by page lock. Accesses sb, inode,
      local variables => s_mutex not needed.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index f9cd04db6eab..1fbc7de88f50 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -678,7 +678,6 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 
 	init_rock_state(&rs, inode);
 	block = ei->i_iget5_block;
-	mutex_lock(&sbi->s_mutex);
 	bh = sb_bread(inode->i_sb, block);
 	if (!bh)
 		goto out_noread;
@@ -748,7 +747,6 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 		goto fail;
 	brelse(bh);
 	*rpnt = '\0';
-	mutex_unlock(&sbi->s_mutex);
 	SetPageUptodate(page);
 	kunmap(page);
 	unlock_page(page);
@@ -765,7 +763,6 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	printk("symlink spans iso9660 blocks\n");
 fail:
 	brelse(bh);
-	mutex_unlock(&sbi->s_mutex);
 error:
 	SetPageError(page);
 	kunmap(page);

commit 4f819a7899b06afcd7623ab9d00fd81503ad3e24
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Sep 12 19:05:56 2010 +0200

    BKL: Remove BKL from isofs
    
    As in other file systems, we can replace the big kernel lock
    with a private mutex in isofs. This means we can now access
    multiple file systems concurrently, but it also means that
    we serialize readdir and lookup across sleeping operations
    which previously released the big kernel lock. This should
    not matter though, as these operations are in practice
    serialized through the hardware access.
    
    The isofs_get_blocks functions now does not take any lock
    any more, it used to recursively get the BKL. After looking
    at the code for hours, I convinced myself that it was never
    needed here anyway, because it only reads constant fields
    of the inode and writes to a buffer head array that is
    at this time only visible to the caller.
    
    The get_sb and fill_super operations do not need the locking
    at all because they operate on a file system that is either
    about to be created or to be destroyed but in either case
    is not visible to other threads.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 96a685c550fd..f9cd04db6eab 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -8,7 +8,6 @@
 
 #include <linux/slab.h>
 #include <linux/pagemap.h>
-#include <linux/smp_lock.h>
 
 #include "isofs.h"
 #include "rock.h"
@@ -661,6 +660,7 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 {
 	struct inode *inode = page->mapping->host;
 	struct iso_inode_info *ei = ISOFS_I(inode);
+	struct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);
 	char *link = kmap(page);
 	unsigned long bufsize = ISOFS_BUFFER_SIZE(inode);
 	struct buffer_head *bh;
@@ -673,12 +673,12 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	struct rock_state rs;
 	int ret;
 
-	if (!ISOFS_SB(inode->i_sb)->s_rock)
+	if (!sbi->s_rock)
 		goto error;
 
 	init_rock_state(&rs, inode);
 	block = ei->i_iget5_block;
-	lock_kernel();
+	mutex_lock(&sbi->s_mutex);
 	bh = sb_bread(inode->i_sb, block);
 	if (!bh)
 		goto out_noread;
@@ -748,7 +748,7 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 		goto fail;
 	brelse(bh);
 	*rpnt = '\0';
-	unlock_kernel();
+	mutex_unlock(&sbi->s_mutex);
 	SetPageUptodate(page);
 	kunmap(page);
 	unlock_page(page);
@@ -765,7 +765,7 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	printk("symlink spans iso9660 blocks\n");
 fail:
 	brelse(bh);
-	unlock_kernel();
+	mutex_unlock(&sbi->s_mutex);
 error:
 	SetPageError(page);
 	kunmap(page);

commit 59bc055211b8d266ab6089158058bf8268e02006
Author: Jan Kara <jack@suse.cz>
Date:   Wed Sep 23 14:44:56 2009 +0200

    zisofs: Implement reading of compressed files when PAGE_CACHE_SIZE > compress block size
    
    Also split and cleanup zisofs_readpage() when we are changing it anyway.
    
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index c2fb2dd0131f..96a685c550fd 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -518,8 +518,7 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 			if (algo == SIG('p', 'z')) {
 				int block_shift =
 					isonum_711(&rr->u.ZF.parms[1]);
-				if (block_shift < PAGE_CACHE_SHIFT
-						|| block_shift > 17) {
+				if (block_shift > 17) {
 					printk(KERN_WARNING "isofs: "
 						"Can't handle ZF block "
 						"size of 2^%d\n",

commit c0a1633b6201ef79e31b7da464d44fdf5953054d
Author: Adam Greenblatt <adam.greenblatt@gmail.com>
Date:   Fri Jul 25 01:46:32 2008 -0700

    isofs: fix minor filesystem corruption
    
    Some iso9660 images contain files with rockridge data that is either
    incorrect or incompletely parsed.  Prior to commit
    f2966632a134e865db3c819346a1dc7d96e05309 ("[PATCH] rock: handle directory
    overflows") (included with kernel 2.6.13) the kernel ignored the rockridge
    data for these files, while still allowing the files to be accessed under
    their non-rockridge names.  That commit inadvertently changed things so
    that files with invalid rockridge data could not be accessed at all.  (I
    ran across the problem when comparing some old CDs with hard disk copies I
    had made long ago under kernel 2.4: a few of the files on the hard disk
    copies were no longer visible on the CDs.)
    
    This change reverts to the pre-2.6.13 behavior.
    
    Signed-off-by: Adam Greenblatt <adam.greenblatt@gmail.com>
    Reviewed-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Cc: <stable@kernel.org>         [2.6.25.x, 2.6.26.x]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 6bd48f0a7047..c2fb2dd0131f 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -209,6 +209,11 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 
 	while (rs.len > 2) { /* There may be one byte for padding somewhere */
 		rr = (struct rock_ridge *)rs.chr;
+		/*
+		 * Ignore rock ridge info if rr->len is out of range, but
+		 * don't return -EIO because that would make the file
+		 * invisible.
+		 */
 		if (rr->len < 3)
 			goto out;	/* Something got screwed up here */
 		sig = isonum_721(rs.chr);
@@ -216,8 +221,12 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 			goto eio;
 		rs.chr += rr->len;
 		rs.len -= rr->len;
+		/*
+		 * As above, just ignore the rock ridge info if rr->len
+		 * is bogus.
+		 */
 		if (rs.len < 0)
-			goto eio;	/* corrupted isofs */
+			goto out;	/* Something got screwed up here */
 
 		switch (sig) {
 		case SIG('R', 'R'):
@@ -307,6 +316,11 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 repeat:
 	while (rs.len > 2) { /* There may be one byte for padding somewhere */
 		rr = (struct rock_ridge *)rs.chr;
+		/*
+		 * Ignore rock ridge info if rr->len is out of range, but
+		 * don't return -EIO because that would make the file
+		 * invisible.
+		 */
 		if (rr->len < 3)
 			goto out;	/* Something got screwed up here */
 		sig = isonum_721(rs.chr);
@@ -314,8 +328,12 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 			goto eio;
 		rs.chr += rr->len;
 		rs.len -= rr->len;
+		/*
+		 * As above, just ignore the rock ridge info if rr->len
+		 * is bogus.
+		 */
 		if (rs.len < 0)
-			goto eio;	/* corrupted isofs */
+			goto out;	/* Something got screwed up here */
 
 		switch (sig) {
 #ifndef CONFIG_ZISOFS		/* No flag for SF or ZF */

commit c4386c83bf849c56b1f49951595aeb7c9a719d21
Author: David Howells <dhowells@redhat.com>
Date:   Thu Feb 7 00:15:41 2008 -0800

    iget: stop ISOFS from using read_inode()
    
    Stop the ISOFS filesystem from using read_inode().  Make isofs_read_inode()
    return an error code, and make isofs_iget() pass it on.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: Jan Kara <jack@ucw.cz>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Cc: "Dave Young" <hidave.darkstar@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index f3a1db3098de..6bd48f0a7047 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -474,8 +474,10 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 			    isofs_iget(inode->i_sb,
 				       ISOFS_I(inode)->i_first_extent,
 				       0);
-			if (!reloc)
+			if (IS_ERR(reloc)) {
+				ret = PTR_ERR(reloc);
 				goto out;
+			}
 			inode->i_mode = reloc->i_mode;
 			inode->i_nlink = reloc->i_nlink;
 			inode->i_uid = reloc->i_uid;

commit f5e54d6e53a20cef45af7499e86164f0e0d16bb2
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jun 28 04:26:44 2006 -0700

    [PATCH] mark address_space_operations const
    
    Same as with already do with the file operations: keep them in .rodata and
    prevents people from doing runtime patching.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Steven French <sfrench@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 4326cb47f8fa..f3a1db3098de 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -754,6 +754,6 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	return -EIO;
 }
 
-struct address_space_operations isofs_symlink_aops = {
+const struct address_space_operations isofs_symlink_aops = {
 	.readpage = rock_ridge_symlink_readpage
 };

commit f2966632a134e865db3c819346a1dc7d96e05309
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Jun 21 17:16:51 2005 -0700

    [PATCH] rock: handle directory overflows
    
    Handle the case where the variable-sized part of a rock-ridge directory entry
    overhangs the end of the buffer which we allocated for it.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 9a81830abff8..4326cb47f8fa 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -126,6 +126,66 @@ static int rock_continue(struct rock_state *rs)
 	return ret;
 }
 
+/*
+ * We think there's a record of type `sig' at rs->chr.  Parse the signature
+ * and make sure that there's really room for a record of that type.
+ */
+static int rock_check_overflow(struct rock_state *rs, int sig)
+{
+	int len;
+
+	switch (sig) {
+	case SIG('S', 'P'):
+		len = sizeof(struct SU_SP_s);
+		break;
+	case SIG('C', 'E'):
+		len = sizeof(struct SU_CE_s);
+		break;
+	case SIG('E', 'R'):
+		len = sizeof(struct SU_ER_s);
+		break;
+	case SIG('R', 'R'):
+		len = sizeof(struct RR_RR_s);
+		break;
+	case SIG('P', 'X'):
+		len = sizeof(struct RR_PX_s);
+		break;
+	case SIG('P', 'N'):
+		len = sizeof(struct RR_PN_s);
+		break;
+	case SIG('S', 'L'):
+		len = sizeof(struct RR_SL_s);
+		break;
+	case SIG('N', 'M'):
+		len = sizeof(struct RR_NM_s);
+		break;
+	case SIG('C', 'L'):
+		len = sizeof(struct RR_CL_s);
+		break;
+	case SIG('P', 'L'):
+		len = sizeof(struct RR_PL_s);
+		break;
+	case SIG('T', 'F'):
+		len = sizeof(struct RR_TF_s);
+		break;
+	case SIG('Z', 'F'):
+		len = sizeof(struct RR_ZF_s);
+		break;
+	default:
+		len = 0;
+		break;
+	}
+	len += offsetof(struct rock_ridge, u);
+	if (len > rs->len) {
+		printk(KERN_NOTICE "rock: directory entry would overflow "
+				"storage\n");
+		printk(KERN_NOTICE "rock: sig=0x%02x, size=%d, remaining=%d\n",
+				sig, len, rs->len);
+		return -EIO;
+	}
+	return 0;
+}
+
 /*
  * return length of name field; 0: not found, -1: to be ignored
  */
@@ -152,10 +212,12 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 		if (rr->len < 3)
 			goto out;	/* Something got screwed up here */
 		sig = isonum_721(rs.chr);
+		if (rock_check_overflow(&rs, sig))
+			goto eio;
 		rs.chr += rr->len;
 		rs.len -= rr->len;
 		if (rs.len < 0)
-			goto out;	/* corrupted isofs */
+			goto eio;	/* corrupted isofs */
 
 		switch (sig) {
 		case SIG('R', 'R'):
@@ -213,6 +275,9 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 out:
 	kfree(rs.buffer);
 	return ret;
+eio:
+	ret = -EIO;
+	goto out;
 }
 
 static int
@@ -245,10 +310,12 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 		if (rr->len < 3)
 			goto out;	/* Something got screwed up here */
 		sig = isonum_721(rs.chr);
+		if (rock_check_overflow(&rs, sig))
+			goto eio;
 		rs.chr += rr->len;
 		rs.len -= rr->len;
 		if (rs.len < 0)
-			goto out;	/* corrupted isofs */
+			goto eio;	/* corrupted isofs */
 
 		switch (sig) {
 #ifndef CONFIG_ZISOFS		/* No flag for SF or ZF */
@@ -479,6 +546,9 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 out:
 	kfree(rs.buffer);
 	return ret;
+eio:
+	ret = -EIO;
+	goto out;
 }
 
 static char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)
@@ -618,6 +688,8 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 		if (rr->len < 3)
 			goto out;	/* Something got screwed up here */
 		sig = isonum_721(rs.chr);
+		if (rock_check_overflow(&rs, sig))
+			goto out;
 		rs.chr += rr->len;
 		rs.len -= rr->len;
 		if (rs.len < 0)

commit e595447e177b39aa6c96baaa57b30cde2d8b9df7
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Jun 21 17:16:50 2005 -0700

    [PATCH] rock.c: handle corrupted directories
    
    The bug in rock.c is that it's totally trusting of the contents of the
    directories.  If the directory says there's a continuation 10000 bytes into
    this 4k block then we cheerily poke around in memory we don't own and oops.
    
    So change rock_continue() to apply various sanity checks, at least ensuring
    that the offset+length remain within the bounds for the header part of a
    struct rock_ridge directory entry.
    
    Note that the kernel can still overindex the buffer due to the variable size
    of the rock-ridge directory entries.  We cannot check that in rock_continue()
    unless we go parse the directory entry's signature and work out its size.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 977dd7009c07..9a81830abff8 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -81,9 +81,22 @@ static void init_rock_state(struct rock_state *rs, struct inode *inode)
 static int rock_continue(struct rock_state *rs)
 {
 	int ret = 1;
+	int blocksize = 1 << rs->inode->i_blkbits;
+	const int min_de_size = offsetof(struct rock_ridge, u);
 
 	kfree(rs->buffer);
 	rs->buffer = NULL;
+
+	if ((unsigned)rs->cont_offset > blocksize - min_de_size ||
+	    (unsigned)rs->cont_size > blocksize ||
+	    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {
+		printk(KERN_NOTICE "rock: corrupted directory entry. "
+			"extent=%d, offset=%d, size=%d\n",
+			rs->cont_extent, rs->cont_offset, rs->cont_size);
+		ret = -EIO;
+		goto out;
+	}
+
 	if (rs->cont_extent) {
 		struct buffer_head *bh;
 

commit 7373909de403d229979842081c63917452e39402
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Jun 21 17:16:47 2005 -0700

    [PATCH] rock: comment tidies
    
    Be a bit more standard in comment layout.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index efefbcce4ce9..977dd7009c07 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -13,12 +13,14 @@
 #include "isofs.h"
 #include "rock.h"
 
-/* These functions are designed to read the system areas of a directory record
+/*
+ * These functions are designed to read the system areas of a directory record
  * and extract relevant information.  There are different functions provided
  * depending upon what information we need at the time.  One function fills
  * out an inode structure, a second one extracts a filename, a third one
  * returns a symbolic link name, and a fourth one returns the extent number
- * for the file. */
+ * for the file.
+ */
 
 #define SIG(A,B) ((A) | ((B) << 8))	/* isonum_721() */
 
@@ -34,7 +36,7 @@ struct rock_state {
 
 /*
  * This is a way of ensuring that we have something in the system
- *  use fields that is compatible with Rock Ridge.  Return zero on success.
+ * use fields that is compatible with Rock Ridge.  Return zero on success.
  */
 
 static int check_sp(struct rock_ridge *rr, struct inode *inode)
@@ -111,7 +113,9 @@ static int rock_continue(struct rock_state *rs)
 	return ret;
 }
 
-/* return length of name field; 0: not found, -1: to be ignored */
+/*
+ * return length of name field; 0: not found, -1: to be ignored
+ */
 int get_rock_ridge_filename(struct iso_directory_record *de,
 			    char *retname, struct inode *inode)
 {
@@ -535,8 +539,11 @@ static char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)
 int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode)
 {
 	int result = parse_rock_ridge_inode_internal(de, inode, 0);
-	/* if rockridge flag was reset and we didn't look for attributes
-	 * behind eventual XA attributes, have a look there */
+
+	/*
+	 * if rockridge flag was reset and we didn't look for attributes
+	 * behind eventual XA attributes, have a look there
+	 */
 	if ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)
 	    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {
 		result = parse_rock_ridge_inode_internal(de, inode, 14);
@@ -544,9 +551,10 @@ int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode)
 	return result;
 }
 
-/* readpage() for symlinks: reads symlink contents into the page and either
-   makes it uptodate and returns 0 or returns error (-EIO) */
-
+/*
+ * readpage() for symlinks: reads symlink contents into the page and either
+ * makes it uptodate and returns 0 or returns error (-EIO)
+ */
 static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 {
 	struct inode *inode = page->mapping->host;
@@ -584,8 +592,10 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	if (offset + *pnt > bufsize)
 		goto out_bad_span;
 
-	/* Now test for possible Rock Ridge extensions which will override
-	   some of these numbers in the inode structure. */
+	/*
+	 * Now test for possible Rock Ridge extensions which will override
+	 * some of these numbers in the inode structure.
+	 */
 
 	setup_rock_ridge(raw_de, inode, &rs);
 

commit ba40aaf04314ec5efd090e69518033fc55f450fa
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Jun 21 17:16:46 2005 -0700

    [PATCH] rock: remove MAYBE_CONTINUE
    
    - remove the MAYBE_CONTINUE macro
    
    - kfree(NULL) is OK.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index aafe356ec1b7..efefbcce4ce9 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -22,6 +22,16 @@
 
 #define SIG(A,B) ((A) | ((B) << 8))	/* isonum_721() */
 
+struct rock_state {
+	void *buffer;
+	unsigned char *chr;
+	int len;
+	int cont_size;
+	int cont_extent;
+	int cont_offset;
+	struct inode *inode;
+};
+
 /*
  * This is a way of ensuring that we have something in the system
  *  use fields that is compatible with Rock Ridge.  Return zero on success.
@@ -38,82 +48,96 @@ static int check_sp(struct rock_ridge *rr, struct inode *inode)
 }
 
 static void setup_rock_ridge(struct iso_directory_record *de,
-			struct inode *inode, unsigned char **chr, int *len)
+			struct inode *inode, struct rock_state *rs)
 {
-	*len = sizeof(struct iso_directory_record) + de->name_len[0];
-	if (*len & 1)
-		(*len)++;
-	*chr = (unsigned char *)de + *len;
-	*len = *((unsigned char *)de) - *len;
-	if (*len < 0)
-		*len = 0;
+	rs->len = sizeof(struct iso_directory_record) + de->name_len[0];
+	if (rs->len & 1)
+		(rs->len)++;
+	rs->chr = (unsigned char *)de + rs->len;
+	rs->len = *((unsigned char *)de) - rs->len;
+	if (rs->len < 0)
+		rs->len = 0;
 
 	if (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {
-		*len -= ISOFS_SB(inode->i_sb)->s_rock_offset;
-		*chr += ISOFS_SB(inode->i_sb)->s_rock_offset;
-		if (*len < 0)
-			*len = 0;
+		rs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;
+		rs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;
+		if (rs->len < 0)
+			rs->len = 0;
 	}
 }
 
-#define MAYBE_CONTINUE(LABEL,DEV) \
-  {if (buffer) { kfree(buffer); buffer = NULL; } \
-  if (cont_extent){ \
-    int block, offset, offset1; \
-    struct buffer_head * pbh; \
-    buffer = kmalloc(cont_size,GFP_KERNEL); \
-    if (!buffer) goto out; \
-    block = cont_extent; \
-    offset = cont_offset; \
-    offset1 = 0; \
-    pbh = sb_bread(DEV->i_sb, block); \
-    if(pbh){       \
-      if (offset > pbh->b_size || offset + cont_size > pbh->b_size){	\
-	brelse(pbh); \
-	goto out; \
-      } \
-      memcpy(buffer + offset1, pbh->b_data + offset, cont_size - offset1); \
-      brelse(pbh); \
-      chr = (unsigned char *) buffer; \
-      len = cont_size; \
-      cont_extent = 0; \
-      cont_size = 0; \
-      cont_offset = 0; \
-      goto LABEL; \
-    }    \
-    printk("Unable to read rock-ridge attributes\n");    \
-  }}
+static void init_rock_state(struct rock_state *rs, struct inode *inode)
+{
+	memset(rs, 0, sizeof(*rs));
+	rs->inode = inode;
+}
+
+/*
+ * Returns 0 if the caller should continue scanning, 1 if the scan must end
+ * and -ve on error.
+ */
+static int rock_continue(struct rock_state *rs)
+{
+	int ret = 1;
+
+	kfree(rs->buffer);
+	rs->buffer = NULL;
+	if (rs->cont_extent) {
+		struct buffer_head *bh;
+
+		rs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);
+		if (!rs->buffer) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		ret = -EIO;
+		bh = sb_bread(rs->inode->i_sb, rs->cont_extent);
+		if (bh) {
+			memcpy(rs->buffer, bh->b_data + rs->cont_offset,
+					rs->cont_size);
+			put_bh(bh);
+			rs->chr = rs->buffer;
+			rs->len = rs->cont_size;
+			rs->cont_extent = 0;
+			rs->cont_size = 0;
+			rs->cont_offset = 0;
+			return 0;
+		}
+		printk("Unable to read rock-ridge attributes\n");
+	}
+out:
+	kfree(rs->buffer);
+	rs->buffer = NULL;
+	return ret;
+}
 
 /* return length of name field; 0: not found, -1: to be ignored */
 int get_rock_ridge_filename(struct iso_directory_record *de,
 			    char *retname, struct inode *inode)
 {
-	int len;
-	unsigned char *chr;
-	int cont_extent = 0;
-	int cont_offset = 0;
-	int cont_size = 0;
-	void *buffer = NULL;
+	struct rock_state rs;
 	struct rock_ridge *rr;
 	int sig;
 	int retnamlen = 0;
 	int truncate = 0;
+	int ret = 0;
 
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
 		return 0;
 	*retname = 0;
 
-	setup_rock_ridge(de, inode, &chr, &len);
+	init_rock_state(&rs, inode);
+	setup_rock_ridge(de, inode, &rs);
 repeat:
 
-	while (len > 2) { /* There may be one byte for padding somewhere */
-		rr = (struct rock_ridge *)chr;
+	while (rs.len > 2) { /* There may be one byte for padding somewhere */
+		rr = (struct rock_ridge *)rs.chr;
 		if (rr->len < 3)
 			goto out;	/* Something got screwed up here */
-		sig = isonum_721(chr);
-		chr += rr->len;
-		len -= rr->len;
-		if (len < 0)
+		sig = isonum_721(rs.chr);
+		rs.chr += rr->len;
+		rs.len -= rr->len;
+		if (rs.len < 0)
 			goto out;	/* corrupted isofs */
 
 		switch (sig) {
@@ -126,9 +150,9 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 				goto out;
 			break;
 		case SIG('C', 'E'):
-			cont_extent = isonum_733(rr->u.CE.extent);
-			cont_offset = isonum_733(rr->u.CE.offset);
-			cont_size = isonum_733(rr->u.CE.size);
+			rs.cont_extent = isonum_733(rr->u.CE.extent);
+			rs.cont_offset = isonum_733(rr->u.CE.offset);
+			rs.cont_size = isonum_733(rr->u.CE.size);
 			break;
 		case SIG('N', 'M'):
 			if (truncate)
@@ -158,58 +182,55 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 			retnamlen += rr->len - 5;
 			break;
 		case SIG('R', 'E'):
-			if (buffer)
-				kfree(buffer);
+			kfree(rs.buffer);
 			return -1;
 		default:
 			break;
 		}
 	}
-	MAYBE_CONTINUE(repeat, inode);
-	kfree(buffer);
-	return retnamlen;	/* If 0, this file did not have a NM field */
+	ret = rock_continue(&rs);
+	if (ret == 0)
+		goto repeat;
+	if (ret == 1)
+		return retnamlen; /* If 0, this file did not have a NM field */
 out:
-	if (buffer)
-		kfree(buffer);
-	return 0;
+	kfree(rs.buffer);
+	return ret;
 }
 
 static int
 parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 				struct inode *inode, int regard_xa)
 {
-	int len;
-	unsigned char *chr;
 	int symlink_len = 0;
 	int cnt, sig;
 	struct inode *reloc;
 	struct rock_ridge *rr;
 	int rootflag;
-	int cont_extent = 0;
-	int cont_offset = 0;
-	int cont_size = 0;
-	void *buffer = NULL;
+	struct rock_state rs;
+	int ret = 0;
 
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
 		return 0;
 
-	setup_rock_ridge(de, inode, &chr, &len);
+	init_rock_state(&rs, inode);
+	setup_rock_ridge(de, inode, &rs);
 	if (regard_xa) {
-		chr += 14;
-		len -= 14;
-		if (len < 0)
-			len = 0;
+		rs.chr += 14;
+		rs.len -= 14;
+		if (rs.len < 0)
+			rs.len = 0;
 	}
 
 repeat:
-	while (len > 2) { /* There may be one byte for padding somewhere */
-		rr = (struct rock_ridge *)chr;
+	while (rs.len > 2) { /* There may be one byte for padding somewhere */
+		rr = (struct rock_ridge *)rs.chr;
 		if (rr->len < 3)
 			goto out;	/* Something got screwed up here */
-		sig = isonum_721(chr);
-		chr += rr->len;
-		len -= rr->len;
-		if (len < 0)
+		sig = isonum_721(rs.chr);
+		rs.chr += rr->len;
+		rs.len -= rr->len;
+		if (rs.len < 0)
 			goto out;	/* corrupted isofs */
 
 		switch (sig) {
@@ -225,9 +246,9 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 				goto out;
 			break;
 		case SIG('C', 'E'):
-			cont_extent = isonum_733(rr->u.CE.extent);
-			cont_offset = isonum_733(rr->u.CE.offset);
-			cont_size = isonum_733(rr->u.CE.size);
+			rs.cont_extent = isonum_733(rr->u.CE.extent);
+			rs.cont_offset = isonum_733(rr->u.CE.offset);
+			rs.cont_size = isonum_733(rr->u.CE.size);
 			break;
 		case SIG('E', 'R'):
 			ISOFS_SB(inode->i_sb)->s_rock = 1;
@@ -433,11 +454,14 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 			break;
 		}
 	}
-	MAYBE_CONTINUE(repeat, inode);
+	ret = rock_continue(&rs);
+	if (ret == 0)
+		goto repeat;
+	if (ret == 1)
+		ret = 0;
 out:
-	if (buffer)
-		kfree(buffer);
-	return 0;
+	kfree(rs.buffer);
+	return ret;
 }
 
 static char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)
@@ -533,19 +557,16 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	char *rpnt = link;
 	unsigned char *pnt;
 	struct iso_directory_record *raw_de;
-	int cont_extent = 0;
-	int cont_offset = 0;
-	int cont_size = 0;
-	void *buffer = NULL;
 	unsigned long block, offset;
 	int sig;
-	int len;
-	unsigned char *chr;
 	struct rock_ridge *rr;
+	struct rock_state rs;
+	int ret;
 
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
 		goto error;
 
+	init_rock_state(&rs, inode);
 	block = ei->i_iget5_block;
 	lock_kernel();
 	bh = sb_bread(inode->i_sb, block);
@@ -566,17 +587,17 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	/* Now test for possible Rock Ridge extensions which will override
 	   some of these numbers in the inode structure. */
 
-	setup_rock_ridge(raw_de, inode, &chr, &len);
+	setup_rock_ridge(raw_de, inode, &rs);
 
 repeat:
-	while (len > 2) { /* There may be one byte for padding somewhere */
-		rr = (struct rock_ridge *)chr;
+	while (rs.len > 2) { /* There may be one byte for padding somewhere */
+		rr = (struct rock_ridge *)rs.chr;
 		if (rr->len < 3)
 			goto out;	/* Something got screwed up here */
-		sig = isonum_721(chr);
-		chr += rr->len;
-		len -= rr->len;
-		if (len < 0)
+		sig = isonum_721(rs.chr);
+		rs.chr += rr->len;
+		rs.len -= rr->len;
+		if (rs.len < 0)
 			goto out;	/* corrupted isofs */
 
 		switch (sig) {
@@ -596,15 +617,18 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 			break;
 		case SIG('C', 'E'):
 			/* This tells is if there is a continuation record */
-			cont_extent = isonum_733(rr->u.CE.extent);
-			cont_offset = isonum_733(rr->u.CE.offset);
-			cont_size = isonum_733(rr->u.CE.size);
+			rs.cont_extent = isonum_733(rr->u.CE.extent);
+			rs.cont_offset = isonum_733(rr->u.CE.offset);
+			rs.cont_size = isonum_733(rr->u.CE.size);
 		default:
 			break;
 		}
 	}
-	MAYBE_CONTINUE(repeat, inode);
-	kfree(buffer);
+	ret = rock_continue(&rs);
+	if (ret == 0)
+		goto repeat;
+	if (ret < 0)
+		goto fail;
 
 	if (rpnt == link)
 		goto fail;
@@ -618,8 +642,7 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 
 	/* error exit from macro */
 out:
-	if (buffer)
-		kfree(buffer);
+	kfree(rs.buffer);
 	goto fail;
 out_noread:
 	printk("unable to read i-node block");

commit 76ab07ebc3ca69e2f14ccbed0de3a9dda9adc6da
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Jun 21 17:16:46 2005 -0700

    [PATCH] rock: remove SETUP_ROCK_RIDGE
    
    - Remove the SETUP_ROCK_RIDGE macro.
    
    - In rock_ridge_symlink_readpage(), rename raw_inode to raw_de.  It points
      at a directory entry, not an inode.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 283e92197bb1..aafe356ec1b7 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -37,18 +37,23 @@ static int check_sp(struct rock_ridge *rr, struct inode *inode)
 	return 0;
 }
 
-#define SETUP_ROCK_RIDGE(DE,CHR,LEN)	      		      	\
-  {LEN= sizeof(struct iso_directory_record) + DE->name_len[0];	\
-  if(LEN & 1) LEN++;						\
-  CHR = ((unsigned char *) DE) + LEN;				\
-  LEN = *((unsigned char *) DE) - LEN;                          \
-  if (LEN<0) LEN=0;                                             \
-  if (ISOFS_SB(inode->i_sb)->s_rock_offset!=-1)                \
-  {                                                             \
-     LEN-=ISOFS_SB(inode->i_sb)->s_rock_offset;                \
-     CHR+=ISOFS_SB(inode->i_sb)->s_rock_offset;                \
-     if (LEN<0) LEN=0;                                          \
-  }                                                             \
+static void setup_rock_ridge(struct iso_directory_record *de,
+			struct inode *inode, unsigned char **chr, int *len)
+{
+	*len = sizeof(struct iso_directory_record) + de->name_len[0];
+	if (*len & 1)
+		(*len)++;
+	*chr = (unsigned char *)de + *len;
+	*len = *((unsigned char *)de) - *len;
+	if (*len < 0)
+		*len = 0;
+
+	if (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {
+		*len -= ISOFS_SB(inode->i_sb)->s_rock_offset;
+		*chr += ISOFS_SB(inode->i_sb)->s_rock_offset;
+		if (*len < 0)
+			*len = 0;
+	}
 }
 
 #define MAYBE_CONTINUE(LABEL,DEV) \
@@ -98,7 +103,7 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 		return 0;
 	*retname = 0;
 
-	SETUP_ROCK_RIDGE(de, chr, len);
+	setup_rock_ridge(de, inode, &chr, &len);
 repeat:
 
 	while (len > 2) { /* There may be one byte for padding somewhere */
@@ -188,7 +193,7 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
 		return 0;
 
-	SETUP_ROCK_RIDGE(de, chr, len);
+	setup_rock_ridge(de, inode, &chr, &len);
 	if (regard_xa) {
 		chr += 14;
 		len -= 14;
@@ -527,7 +532,7 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	struct buffer_head *bh;
 	char *rpnt = link;
 	unsigned char *pnt;
-	struct iso_directory_record *raw_inode;
+	struct iso_directory_record *raw_de;
 	int cont_extent = 0;
 	int cont_offset = 0;
 	int cont_size = 0;
@@ -550,7 +555,7 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	offset = ei->i_iget5_offset;
 	pnt = (unsigned char *)bh->b_data + offset;
 
-	raw_inode = (struct iso_directory_record *)pnt;
+	raw_de = (struct iso_directory_record *)pnt;
 
 	/*
 	 * If we go past the end of the buffer, there is some sort of error.
@@ -561,7 +566,7 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	/* Now test for possible Rock Ridge extensions which will override
 	   some of these numbers in the inode structure. */
 
-	SETUP_ROCK_RIDGE(raw_inode, chr, len);
+	setup_rock_ridge(raw_de, inode, &chr, &len);
 
 repeat:
 	while (len > 2) { /* There may be one byte for padding somewhere */

commit 04f7aa9c7dc615c690cede9a80c83625ad2efef7
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Jun 21 17:16:45 2005 -0700

    [PATCH] rock: remove CHECK_CE
    
    Remove the CHECK_CE macro
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 9f2aaa27f8fa..283e92197bb1 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -37,11 +37,6 @@ static int check_sp(struct rock_ridge *rr, struct inode *inode)
 	return 0;
 }
 
-#define CHECK_CE	       			\
-      {cont_extent = isonum_733(rr->u.CE.extent); \
-      cont_offset = isonum_733(rr->u.CE.offset); \
-      cont_size = isonum_733(rr->u.CE.size);}
-
 #define SETUP_ROCK_RIDGE(DE,CHR,LEN)	      		      	\
   {LEN= sizeof(struct iso_directory_record) + DE->name_len[0];	\
   if(LEN & 1) LEN++;						\
@@ -126,7 +121,9 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 				goto out;
 			break;
 		case SIG('C', 'E'):
-			CHECK_CE;
+			cont_extent = isonum_733(rr->u.CE.extent);
+			cont_offset = isonum_733(rr->u.CE.offset);
+			cont_size = isonum_733(rr->u.CE.size);
 			break;
 		case SIG('N', 'M'):
 			if (truncate)
@@ -223,7 +220,9 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 				goto out;
 			break;
 		case SIG('C', 'E'):
-			CHECK_CE;
+			cont_extent = isonum_733(rr->u.CE.extent);
+			cont_offset = isonum_733(rr->u.CE.offset);
+			cont_size = isonum_733(rr->u.CE.size);
 			break;
 		case SIG('E', 'R'):
 			ISOFS_SB(inode->i_sb)->s_rock = 1;
@@ -592,7 +591,9 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 			break;
 		case SIG('C', 'E'):
 			/* This tells is if there is a continuation record */
-			CHECK_CE;
+			cont_extent = isonum_733(rr->u.CE.extent);
+			cont_offset = isonum_733(rr->u.CE.offset);
+			cont_size = isonum_733(rr->u.CE.size);
 		default:
 			break;
 		}

commit a40ea8f22e59c038ffdf219251a67311b9f6e362
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Jun 21 17:16:44 2005 -0700

    [PATCH] rock: remove CONTINUE_DECLS
    
    Remove the CONTINUE_DECLS macro.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 8497c6bd5678..9f2aaa27f8fa 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -37,14 +37,6 @@ static int check_sp(struct rock_ridge *rr, struct inode *inode)
 	return 0;
 }
 
-/* We define a series of macros because each function must do exactly the
-   same thing in certain places.  We use the macros to ensure that everything
-   is done correctly */
-
-#define CONTINUE_DECLS \
-  int cont_extent = 0, cont_offset = 0, cont_size = 0;   \
-  void *buffer = NULL
-
 #define CHECK_CE	       			\
       {cont_extent = isonum_733(rr->u.CE.extent); \
       cont_offset = isonum_733(rr->u.CE.offset); \
@@ -98,7 +90,10 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 {
 	int len;
 	unsigned char *chr;
-	CONTINUE_DECLS;
+	int cont_extent = 0;
+	int cont_offset = 0;
+	int cont_size = 0;
+	void *buffer = NULL;
 	struct rock_ridge *rr;
 	int sig;
 	int retnamlen = 0;
@@ -188,8 +183,10 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 	struct inode *reloc;
 	struct rock_ridge *rr;
 	int rootflag;
-
-	CONTINUE_DECLS;
+	int cont_extent = 0;
+	int cont_offset = 0;
+	int cont_size = 0;
+	void *buffer = NULL;
 
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
 		return 0;
@@ -532,7 +529,10 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	char *rpnt = link;
 	unsigned char *pnt;
 	struct iso_directory_record *raw_inode;
-	CONTINUE_DECLS;
+	int cont_extent = 0;
+	int cont_offset = 0;
+	int cont_size = 0;
+	void *buffer = NULL;
 	unsigned long block, offset;
 	int sig;
 	int len;

commit 12121714fbf36023d5892034d0c97df54a451543
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Jun 21 17:16:44 2005 -0700

    [PATCH] rock: remove CHECK_SP
    
    Remove the CHECK_SP macro.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index e981c040a49b..8497c6bd5678 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -22,12 +22,21 @@
 
 #define SIG(A,B) ((A) | ((B) << 8))	/* isonum_721() */
 
-/* This is a way of ensuring that we have something in the system
-   use fields that is compatible with Rock Ridge */
-#define CHECK_SP(FAIL)	       			\
-      if(rr->u.SP.magic[0] != 0xbe) FAIL;	\
-      if(rr->u.SP.magic[1] != 0xef) FAIL;       \
-      ISOFS_SB(inode->i_sb)->s_rock_offset=rr->u.SP.skip;
+/*
+ * This is a way of ensuring that we have something in the system
+ *  use fields that is compatible with Rock Ridge.  Return zero on success.
+ */
+
+static int check_sp(struct rock_ridge *rr, struct inode *inode)
+{
+	if (rr->u.SP.magic[0] != 0xbe)
+		return -1;
+	if (rr->u.SP.magic[1] != 0xef)
+		return -1;
+	ISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;
+	return 0;
+}
+
 /* We define a series of macros because each function must do exactly the
    same thing in certain places.  We use the macros to ensure that everything
    is done correctly */
@@ -118,7 +127,8 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 				goto out;
 			break;
 		case SIG('S', 'P'):
-			CHECK_SP(goto out);
+			if (check_sp(rr, inode))
+				goto out;
 			break;
 		case SIG('C', 'E'):
 			CHECK_CE;
@@ -212,7 +222,8 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 			break;
 #endif
 		case SIG('S', 'P'):
-			CHECK_SP(goto out);
+			if (check_sp(rr, inode))
+				goto out;
 			break;
 		case SIG('C', 'E'):
 			CHECK_CE;
@@ -570,7 +581,8 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 				goto out;
 			break;
 		case SIG('S', 'P'):
-			CHECK_SP(goto out);
+			if (check_sp(rr, inode))
+				goto out;
 			break;
 		case SIG('S', 'L'):
 			rpnt = get_symlink_chunk(rpnt, rr,

commit 7fa393a1d3d9485e428a3c74b5599190c14b13db
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Jun 21 17:16:43 2005 -0700

    [PATCH] rock: manual tidies
    
    Fix stuff which Lindent got wrong, rework a few deeply-nested blocks.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index bbc348f0189a..e981c040a49b 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -90,82 +90,78 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 	int len;
 	unsigned char *chr;
 	CONTINUE_DECLS;
-	int retnamlen = 0, truncate = 0;
+	struct rock_ridge *rr;
+	int sig;
+	int retnamlen = 0;
+	int truncate = 0;
 
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
 		return 0;
 	*retname = 0;
 
 	SETUP_ROCK_RIDGE(de, chr, len);
-      repeat:
-	{
-		struct rock_ridge *rr;
-		int sig;
-
-		while (len > 2) {	/* There may be one byte for padding somewhere */
-			rr = (struct rock_ridge *)chr;
-			if (rr->len < 3)
-				goto out;	/* Something got screwed up here */
-			sig = isonum_721(chr);
-			chr += rr->len;
-			len -= rr->len;
-			if (len < 0)
-				goto out;	/* corrupted isofs */
-
-			switch (sig) {
-			case SIG('R', 'R'):
-				if ((rr->u.RR.flags[0] & RR_NM) == 0)
-					goto out;
+repeat:
+
+	while (len > 2) { /* There may be one byte for padding somewhere */
+		rr = (struct rock_ridge *)chr;
+		if (rr->len < 3)
+			goto out;	/* Something got screwed up here */
+		sig = isonum_721(chr);
+		chr += rr->len;
+		len -= rr->len;
+		if (len < 0)
+			goto out;	/* corrupted isofs */
+
+		switch (sig) {
+		case SIG('R', 'R'):
+			if ((rr->u.RR.flags[0] & RR_NM) == 0)
+				goto out;
+			break;
+		case SIG('S', 'P'):
+			CHECK_SP(goto out);
+			break;
+		case SIG('C', 'E'):
+			CHECK_CE;
+			break;
+		case SIG('N', 'M'):
+			if (truncate)
 				break;
-			case SIG('S', 'P'):
-				CHECK_SP(goto out);
+			if (rr->len < 5)
 				break;
-			case SIG('C', 'E'):
-				CHECK_CE;
+			/*
+			 * If the flags are 2 or 4, this indicates '.' or '..'.
+			 * We don't want to do anything with this, because it
+			 * screws up the code that calls us.  We don't really
+			 * care anyways, since we can just use the non-RR
+			 * name.
+			 */
+			if (rr->u.NM.flags & 6)
 				break;
-			case SIG('N', 'M'):
-				if (truncate)
-					break;
-				if (rr->len < 5)
-					break;
-				/*
-				 * If the flags are 2 or 4, this indicates '.' or '..'.
-				 * We don't want to do anything with this, because it
-				 * screws up the code that calls us.  We don't really
-				 * care anyways, since we can just use the non-RR
-				 * name.
-				 */
-				if (rr->u.NM.flags & 6) {
-					break;
-				}
 
-				if (rr->u.NM.flags & ~1) {
-					printk
-					    ("Unsupported NM flag settings (%d)\n",
-					     rr->u.NM.flags);
-					break;
-				}
-				if ((strlen(retname) + rr->len - 5) >= 254) {
-					truncate = 1;
-					break;
-				}
-				strncat(retname, rr->u.NM.name, rr->len - 5);
-				retnamlen += rr->len - 5;
+			if (rr->u.NM.flags & ~1) {
+				printk("Unsupported NM flag settings (%d)\n",
+					rr->u.NM.flags);
 				break;
-			case SIG('R', 'E'):
-				if (buffer)
-					kfree(buffer);
-				return -1;
-			default:
+			}
+			if ((strlen(retname) + rr->len - 5) >= 254) {
+				truncate = 1;
 				break;
 			}
+			strncat(retname, rr->u.NM.name, rr->len - 5);
+			retnamlen += rr->len - 5;
+			break;
+		case SIG('R', 'E'):
+			if (buffer)
+				kfree(buffer);
+			return -1;
+		default:
+			break;
 		}
 	}
 	MAYBE_CONTINUE(repeat, inode);
-	if (buffer)
-		kfree(buffer);
+	kfree(buffer);
 	return retnamlen;	/* If 0, this file did not have a NM field */
-      out:
+out:
 	if (buffer)
 		kfree(buffer);
 	return 0;
@@ -178,6 +174,11 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 	int len;
 	unsigned char *chr;
 	int symlink_len = 0;
+	int cnt, sig;
+	struct inode *reloc;
+	struct rock_ridge *rr;
+	int rootflag;
+
 	CONTINUE_DECLS;
 
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
@@ -191,238 +192,237 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 			len = 0;
 	}
 
-      repeat:
-	{
-		int cnt, sig;
-		struct inode *reloc;
-		struct rock_ridge *rr;
-		int rootflag;
-
-		while (len > 2) {	/* There may be one byte for padding somewhere */
-			rr = (struct rock_ridge *)chr;
-			if (rr->len < 3)
-				goto out;	/* Something got screwed up here */
-			sig = isonum_721(chr);
-			chr += rr->len;
-			len -= rr->len;
-			if (len < 0)
-				goto out;	/* corrupted isofs */
-
-			switch (sig) {
+repeat:
+	while (len > 2) { /* There may be one byte for padding somewhere */
+		rr = (struct rock_ridge *)chr;
+		if (rr->len < 3)
+			goto out;	/* Something got screwed up here */
+		sig = isonum_721(chr);
+		chr += rr->len;
+		len -= rr->len;
+		if (len < 0)
+			goto out;	/* corrupted isofs */
+
+		switch (sig) {
 #ifndef CONFIG_ZISOFS		/* No flag for SF or ZF */
-			case SIG('R', 'R'):
-				if ((rr->u.RR.flags[0] &
-				     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)
-					goto out;
-				break;
+		case SIG('R', 'R'):
+			if ((rr->u.RR.flags[0] &
+			     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)
+				goto out;
+			break;
 #endif
-			case SIG('S', 'P'):
-				CHECK_SP(goto out);
-				break;
-			case SIG('C', 'E'):
-				CHECK_CE;
-				break;
-			case SIG('E', 'R'):
-				ISOFS_SB(inode->i_sb)->s_rock = 1;
-				printk(KERN_DEBUG "ISO 9660 Extensions: ");
-				{
-					int p;
-					for (p = 0; p < rr->u.ER.len_id; p++)
-						printk("%c", rr->u.ER.data[p]);
+		case SIG('S', 'P'):
+			CHECK_SP(goto out);
+			break;
+		case SIG('C', 'E'):
+			CHECK_CE;
+			break;
+		case SIG('E', 'R'):
+			ISOFS_SB(inode->i_sb)->s_rock = 1;
+			printk(KERN_DEBUG "ISO 9660 Extensions: ");
+			{
+				int p;
+				for (p = 0; p < rr->u.ER.len_id; p++)
+					printk("%c", rr->u.ER.data[p]);
+			}
+			printk("\n");
+			break;
+		case SIG('P', 'X'):
+			inode->i_mode = isonum_733(rr->u.PX.mode);
+			inode->i_nlink = isonum_733(rr->u.PX.n_links);
+			inode->i_uid = isonum_733(rr->u.PX.uid);
+			inode->i_gid = isonum_733(rr->u.PX.gid);
+			break;
+		case SIG('P', 'N'):
+			{
+				int high, low;
+				high = isonum_733(rr->u.PN.dev_high);
+				low = isonum_733(rr->u.PN.dev_low);
+				/*
+				 * The Rock Ridge standard specifies that if
+				 * sizeof(dev_t) <= 4, then the high field is
+				 * unused, and the device number is completely
+				 * stored in the low field.  Some writers may
+				 * ignore this subtlety,
+				 * and as a result we test to see if the entire
+				 * device number is
+				 * stored in the low field, and use that.
+				 */
+				if ((low & ~0xff) && high == 0) {
+					inode->i_rdev =
+					    MKDEV(low >> 8, low & 0xff);
+				} else {
+					inode->i_rdev =
+					    MKDEV(high, low);
 				}
-				printk("\n");
-				break;
-			case SIG('P', 'X'):
-				inode->i_mode = isonum_733(rr->u.PX.mode);
-				inode->i_nlink = isonum_733(rr->u.PX.n_links);
-				inode->i_uid = isonum_733(rr->u.PX.uid);
-				inode->i_gid = isonum_733(rr->u.PX.gid);
-				break;
-			case SIG('P', 'N'):
-				{
-					int high, low;
-					high = isonum_733(rr->u.PN.dev_high);
-					low = isonum_733(rr->u.PN.dev_low);
-					/*
-					 * The Rock Ridge standard specifies that if sizeof(dev_t) <= 4,
-					 * then the high field is unused, and the device number is completely
-					 * stored in the low field.  Some writers may ignore this subtlety,
-					 * and as a result we test to see if the entire device number is
-					 * stored in the low field, and use that.
-					 */
-					if ((low & ~0xff) && high == 0) {
-						inode->i_rdev =
-						    MKDEV(low >> 8, low & 0xff);
-					} else {
-						inode->i_rdev =
-						    MKDEV(high, low);
+			}
+			break;
+		case SIG('T', 'F'):
+			/*
+			 * Some RRIP writers incorrectly place ctime in the
+			 * TF_CREATE field. Try to handle this correctly for
+			 * either case.
+			 */
+			/* Rock ridge never appears on a High Sierra disk */
+			cnt = 0;
+			if (rr->u.TF.flags & TF_CREATE) {
+				inode->i_ctime.tv_sec =
+				    iso_date(rr->u.TF.times[cnt++].time,
+					     0);
+				inode->i_ctime.tv_nsec = 0;
+			}
+			if (rr->u.TF.flags & TF_MODIFY) {
+				inode->i_mtime.tv_sec =
+				    iso_date(rr->u.TF.times[cnt++].time,
+					     0);
+				inode->i_mtime.tv_nsec = 0;
+			}
+			if (rr->u.TF.flags & TF_ACCESS) {
+				inode->i_atime.tv_sec =
+				    iso_date(rr->u.TF.times[cnt++].time,
+					     0);
+				inode->i_atime.tv_nsec = 0;
+			}
+			if (rr->u.TF.flags & TF_ATTRIBUTES) {
+				inode->i_ctime.tv_sec =
+				    iso_date(rr->u.TF.times[cnt++].time,
+					     0);
+				inode->i_ctime.tv_nsec = 0;
+			}
+			break;
+		case SIG('S', 'L'):
+			{
+				int slen;
+				struct SL_component *slp;
+				struct SL_component *oldslp;
+				slen = rr->len - 5;
+				slp = &rr->u.SL.link;
+				inode->i_size = symlink_len;
+				while (slen > 1) {
+					rootflag = 0;
+					switch (slp->flags & ~1) {
+					case 0:
+						inode->i_size +=
+						    slp->len;
+						break;
+					case 2:
+						inode->i_size += 1;
+						break;
+					case 4:
+						inode->i_size += 2;
+						break;
+					case 8:
+						rootflag = 1;
+						inode->i_size += 1;
+						break;
+					default:
+						printk("Symlink component flag "
+							"not implemented\n");
 					}
-				}
-				break;
-			case SIG('T', 'F'):
-				/* Some RRIP writers incorrectly place ctime in the TF_CREATE field.
-				   Try to handle this correctly for either case. */
-				cnt = 0;	/* Rock ridge never appears on a High Sierra disk */
-				if (rr->u.TF.flags & TF_CREATE) {
-					inode->i_ctime.tv_sec =
-					    iso_date(rr->u.TF.times[cnt++].time,
-						     0);
-					inode->i_ctime.tv_nsec = 0;
-				}
-				if (rr->u.TF.flags & TF_MODIFY) {
-					inode->i_mtime.tv_sec =
-					    iso_date(rr->u.TF.times[cnt++].time,
-						     0);
-					inode->i_mtime.tv_nsec = 0;
-				}
-				if (rr->u.TF.flags & TF_ACCESS) {
-					inode->i_atime.tv_sec =
-					    iso_date(rr->u.TF.times[cnt++].time,
-						     0);
-					inode->i_atime.tv_nsec = 0;
-				}
-				if (rr->u.TF.flags & TF_ATTRIBUTES) {
-					inode->i_ctime.tv_sec =
-					    iso_date(rr->u.TF.times[cnt++].time,
-						     0);
-					inode->i_ctime.tv_nsec = 0;
-				}
-				break;
-			case SIG('S', 'L'):
-				{
-					int slen;
-					struct SL_component *slp;
-					struct SL_component *oldslp;
-					slen = rr->len - 5;
-					slp = &rr->u.SL.link;
-					inode->i_size = symlink_len;
-					while (slen > 1) {
-						rootflag = 0;
-						switch (slp->flags & ~1) {
-						case 0:
+					slen -= slp->len + 2;
+					oldslp = slp;
+					slp = (struct SL_component *)
+						(((char *)slp) + slp->len + 2);
+
+					if (slen < 2) {
+						if (((rr->u.SL.
+						      flags & 1) != 0)
+						    &&
+						    ((oldslp->
+						      flags & 1) == 0))
 							inode->i_size +=
-							    slp->len;
-							break;
-						case 2:
-							inode->i_size += 1;
-							break;
-						case 4:
-							inode->i_size += 2;
-							break;
-						case 8:
-							rootflag = 1;
-							inode->i_size += 1;
-							break;
-						default:
-							printk
-							    ("Symlink component flag not implemented\n");
-						}
-						slen -= slp->len + 2;
-						oldslp = slp;
-						slp =
-						    (struct SL_component
-						     *)(((char *)slp) +
-							slp->len + 2);
-
-						if (slen < 2) {
-							if (((rr->u.SL.
-							      flags & 1) != 0)
-							    &&
-							    ((oldslp->
-							      flags & 1) == 0))
-								inode->i_size +=
-								    1;
-							break;
-						}
-
-						/*
-						 * If this component record isn't continued, then append a '/'.
-						 */
-						if (!rootflag
-						    && (oldslp->flags & 1) == 0)
-							inode->i_size += 1;
+							    1;
+						break;
 					}
+
+					/*
+					 * If this component record isn't
+					 * continued, then append a '/'.
+					 */
+					if (!rootflag
+					    && (oldslp->flags & 1) == 0)
+						inode->i_size += 1;
 				}
-				symlink_len = inode->i_size;
-				break;
-			case SIG('R', 'E'):
-				printk(KERN_WARNING
-				       "Attempt to read inode for relocated directory\n");
+			}
+			symlink_len = inode->i_size;
+			break;
+		case SIG('R', 'E'):
+			printk(KERN_WARNING "Attempt to read inode for "
+					"relocated directory\n");
+			goto out;
+		case SIG('C', 'L'):
+			ISOFS_I(inode)->i_first_extent =
+			    isonum_733(rr->u.CL.location);
+			reloc =
+			    isofs_iget(inode->i_sb,
+				       ISOFS_I(inode)->i_first_extent,
+				       0);
+			if (!reloc)
 				goto out;
-			case SIG('C', 'L'):
-				ISOFS_I(inode)->i_first_extent =
-				    isonum_733(rr->u.CL.location);
-				reloc =
-				    isofs_iget(inode->i_sb,
-					       ISOFS_I(inode)->i_first_extent,
-					       0);
-				if (!reloc)
-					goto out;
-				inode->i_mode = reloc->i_mode;
-				inode->i_nlink = reloc->i_nlink;
-				inode->i_uid = reloc->i_uid;
-				inode->i_gid = reloc->i_gid;
-				inode->i_rdev = reloc->i_rdev;
-				inode->i_size = reloc->i_size;
-				inode->i_blocks = reloc->i_blocks;
-				inode->i_atime = reloc->i_atime;
-				inode->i_ctime = reloc->i_ctime;
-				inode->i_mtime = reloc->i_mtime;
-				iput(reloc);
-				break;
+			inode->i_mode = reloc->i_mode;
+			inode->i_nlink = reloc->i_nlink;
+			inode->i_uid = reloc->i_uid;
+			inode->i_gid = reloc->i_gid;
+			inode->i_rdev = reloc->i_rdev;
+			inode->i_size = reloc->i_size;
+			inode->i_blocks = reloc->i_blocks;
+			inode->i_atime = reloc->i_atime;
+			inode->i_ctime = reloc->i_ctime;
+			inode->i_mtime = reloc->i_mtime;
+			iput(reloc);
+			break;
 #ifdef CONFIG_ZISOFS
-			case SIG('Z', 'F'):
-				if (!ISOFS_SB(inode->i_sb)->s_nocompress) {
-					int algo;
-					algo = isonum_721(rr->u.ZF.algorithm);
-					if (algo == SIG('p', 'z')) {
-						int block_shift =
-						    isonum_711(&rr->u.ZF.
-							       parms[1]);
-						if (block_shift <
-						    PAGE_CACHE_SHIFT
-						    || block_shift > 17) {
-							printk(KERN_WARNING
-							       "isofs: Can't handle ZF block size of 2^%d\n",
-							       block_shift);
-						} else {
-							/* Note: we don't change i_blocks here */
-							ISOFS_I(inode)->
-							    i_file_format =
-							    isofs_file_compressed;
-							/* Parameters to compression algorithm (header size, block size) */
-							ISOFS_I(inode)->
-							    i_format_parm[0] =
-							    isonum_711(&rr->u.
-								       ZF.
-								       parms
-								       [0]);
-							ISOFS_I(inode)->
-							    i_format_parm[1] =
-							    isonum_711(&rr->u.
-								       ZF.
-								       parms
-								       [1]);
-							inode->i_size =
-							    isonum_733(rr->u.ZF.
-								       real_size);
-						}
-					} else {
-						printk(KERN_WARNING
-						       "isofs: Unknown ZF compression algorithm: %c%c\n",
-						       rr->u.ZF.algorithm[0],
-						       rr->u.ZF.algorithm[1]);
-					}
-				}
-				break;
-#endif
-			default:
+		case SIG('Z', 'F'): {
+			int algo;
+
+			if (ISOFS_SB(inode->i_sb)->s_nocompress)
 				break;
+			algo = isonum_721(rr->u.ZF.algorithm);
+			if (algo == SIG('p', 'z')) {
+				int block_shift =
+					isonum_711(&rr->u.ZF.parms[1]);
+				if (block_shift < PAGE_CACHE_SHIFT
+						|| block_shift > 17) {
+					printk(KERN_WARNING "isofs: "
+						"Can't handle ZF block "
+						"size of 2^%d\n",
+						block_shift);
+				} else {
+					/*
+					 * Note: we don't change
+					 * i_blocks here
+					 */
+					ISOFS_I(inode)->i_file_format =
+						isofs_file_compressed;
+					/*
+					 * Parameters to compression
+					 * algorithm (header size,
+					 * block size)
+					 */
+					ISOFS_I(inode)->i_format_parm[0] =
+						isonum_711(&rr->u.ZF.parms[0]);
+					ISOFS_I(inode)->i_format_parm[1] =
+						isonum_711(&rr->u.ZF.parms[1]);
+					inode->i_size =
+					    isonum_733(rr->u.ZF.
+						       real_size);
+				}
+			} else {
+				printk(KERN_WARNING
+				       "isofs: Unknown ZF compression "
+						"algorithm: %c%c\n",
+				       rr->u.ZF.algorithm[0],
+				       rr->u.ZF.algorithm[1]);
 			}
+			break;
+		}
+#endif
+		default:
+			break;
 		}
 	}
 	MAYBE_CONTINUE(repeat, inode);
-      out:
+out:
 	if (buffer)
 		kfree(buffer);
 	return 0;
@@ -553,8 +553,8 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 
 	SETUP_ROCK_RIDGE(raw_inode, chr, len);
 
-      repeat:
-	while (len > 2) {	/* There may be one byte for padding somewhere */
+repeat:
+	while (len > 2) { /* There may be one byte for padding somewhere */
 		rr = (struct rock_ridge *)chr;
 		if (rr->len < 3)
 			goto out;	/* Something got screwed up here */
@@ -586,8 +586,7 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 		}
 	}
 	MAYBE_CONTINUE(repeat, inode);
-	if (buffer)
-		kfree(buffer);
+	kfree(buffer);
 
 	if (rpnt == link)
 		goto fail;
@@ -600,19 +599,19 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	return 0;
 
 	/* error exit from macro */
-      out:
+out:
 	if (buffer)
 		kfree(buffer);
 	goto fail;
-      out_noread:
+out_noread:
 	printk("unable to read i-node block");
 	goto fail;
-      out_bad_span:
+out_bad_span:
 	printk("symlink spans iso9660 blocks\n");
-      fail:
+fail:
 	brelse(bh);
 	unlock_kernel();
-      error:
+error:
 	SetPageError(page);
 	kunmap(page);
 	unlock_page(page);

commit 1d372116383f79e42a3eb010c7d6ec3dd28767b3
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Jun 21 17:16:42 2005 -0700

    [PATCH] rock: lindent it
    
    Trying to turn rock.c into something which humans can read so we can fix some
    bugs.
    
    Start out by feeding it through scripts/Lindent.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 089e79c65585..bbc348f0189a 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -20,8 +20,7 @@
  * returns a symbolic link name, and a fourth one returns the extent number
  * for the file. */
 
-#define SIG(A,B) ((A) | ((B) << 8)) /* isonum_721() */
-
+#define SIG(A,B) ((A) | ((B) << 8))	/* isonum_721() */
 
 /* This is a way of ensuring that we have something in the system
    use fields that is compatible with Rock Ridge */
@@ -54,7 +53,7 @@
      CHR+=ISOFS_SB(inode->i_sb)->s_rock_offset;                \
      if (LEN<0) LEN=0;                                          \
   }                                                             \
-}                                     
+}
 
 #define MAYBE_CONTINUE(LABEL,DEV) \
   {if (buffer) { kfree(buffer); buffer = NULL; } \
@@ -85,280 +84,348 @@
   }}
 
 /* return length of name field; 0: not found, -1: to be ignored */
-int get_rock_ridge_filename(struct iso_directory_record * de,
-			    char * retname, struct inode * inode)
+int get_rock_ridge_filename(struct iso_directory_record *de,
+			    char *retname, struct inode *inode)
 {
-  int len;
-  unsigned char * chr;
-  CONTINUE_DECLS;
-  int retnamlen = 0, truncate=0;
- 
-  if (!ISOFS_SB(inode->i_sb)->s_rock) return 0;
-  *retname = 0;
-
-  SETUP_ROCK_RIDGE(de, chr, len);
- repeat:
-  {
-    struct rock_ridge * rr;
-    int sig;
-    
-    while (len > 2){ /* There may be one byte for padding somewhere */
-      rr = (struct rock_ridge *) chr;
-      if (rr->len < 3) goto out; /* Something got screwed up here */
-      sig = isonum_721(chr);
-      chr += rr->len; 
-      len -= rr->len;
-      if (len < 0) goto out;	/* corrupted isofs */
-
-      switch(sig){
-      case SIG('R','R'):
-	if((rr->u.RR.flags[0] & RR_NM) == 0) goto out;
-	break;
-      case SIG('S','P'):
-	CHECK_SP(goto out);
-	break;
-      case SIG('C','E'):
-	CHECK_CE;
-	break;
-      case SIG('N','M'):
-	if (truncate) break;
-	if (rr->len < 5) break;
-        /*
-	 * If the flags are 2 or 4, this indicates '.' or '..'.
-	 * We don't want to do anything with this, because it
-	 * screws up the code that calls us.  We don't really
-	 * care anyways, since we can just use the non-RR
-	 * name.
-	 */
-	if (rr->u.NM.flags & 6) {
-	  break;
-	}
+	int len;
+	unsigned char *chr;
+	CONTINUE_DECLS;
+	int retnamlen = 0, truncate = 0;
 
-	if (rr->u.NM.flags & ~1) {
-	  printk("Unsupported NM flag settings (%d)\n",rr->u.NM.flags);
-	  break;
-	}
-	if((strlen(retname) + rr->len - 5) >= 254) {
-	  truncate = 1;
-	  break;
+	if (!ISOFS_SB(inode->i_sb)->s_rock)
+		return 0;
+	*retname = 0;
+
+	SETUP_ROCK_RIDGE(de, chr, len);
+      repeat:
+	{
+		struct rock_ridge *rr;
+		int sig;
+
+		while (len > 2) {	/* There may be one byte for padding somewhere */
+			rr = (struct rock_ridge *)chr;
+			if (rr->len < 3)
+				goto out;	/* Something got screwed up here */
+			sig = isonum_721(chr);
+			chr += rr->len;
+			len -= rr->len;
+			if (len < 0)
+				goto out;	/* corrupted isofs */
+
+			switch (sig) {
+			case SIG('R', 'R'):
+				if ((rr->u.RR.flags[0] & RR_NM) == 0)
+					goto out;
+				break;
+			case SIG('S', 'P'):
+				CHECK_SP(goto out);
+				break;
+			case SIG('C', 'E'):
+				CHECK_CE;
+				break;
+			case SIG('N', 'M'):
+				if (truncate)
+					break;
+				if (rr->len < 5)
+					break;
+				/*
+				 * If the flags are 2 or 4, this indicates '.' or '..'.
+				 * We don't want to do anything with this, because it
+				 * screws up the code that calls us.  We don't really
+				 * care anyways, since we can just use the non-RR
+				 * name.
+				 */
+				if (rr->u.NM.flags & 6) {
+					break;
+				}
+
+				if (rr->u.NM.flags & ~1) {
+					printk
+					    ("Unsupported NM flag settings (%d)\n",
+					     rr->u.NM.flags);
+					break;
+				}
+				if ((strlen(retname) + rr->len - 5) >= 254) {
+					truncate = 1;
+					break;
+				}
+				strncat(retname, rr->u.NM.name, rr->len - 5);
+				retnamlen += rr->len - 5;
+				break;
+			case SIG('R', 'E'):
+				if (buffer)
+					kfree(buffer);
+				return -1;
+			default:
+				break;
+			}
+		}
 	}
-	strncat(retname, rr->u.NM.name, rr->len - 5);
-	retnamlen += rr->len - 5;
-	break;
-      case SIG('R','E'):
-	if (buffer) kfree(buffer);
-	return -1;
-      default:
-	break;
-      }
-    }
-  }
-  MAYBE_CONTINUE(repeat,inode);
-  if (buffer) kfree(buffer);
-  return retnamlen; /* If 0, this file did not have a NM field */
- out:
-  if(buffer) kfree(buffer);
-  return 0;
+	MAYBE_CONTINUE(repeat, inode);
+	if (buffer)
+		kfree(buffer);
+	return retnamlen;	/* If 0, this file did not have a NM field */
+      out:
+	if (buffer)
+		kfree(buffer);
+	return 0;
 }
 
 static int
 parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 				struct inode *inode, int regard_xa)
 {
-  int len;
-  unsigned char * chr;
-  int symlink_len = 0;
-  CONTINUE_DECLS;
-
-  if (!ISOFS_SB(inode->i_sb)->s_rock) return 0;
-
-  SETUP_ROCK_RIDGE(de, chr, len);
-  if (regard_xa)
-   {
-     chr+=14;
-     len-=14;
-     if (len<0) len=0;
-   }
-   
- repeat:
-  {
-    int cnt, sig;
-    struct inode * reloc;
-    struct rock_ridge * rr;
-    int rootflag;
-    
-    while (len > 2){ /* There may be one byte for padding somewhere */
-      rr = (struct rock_ridge *) chr;
-      if (rr->len < 3) goto out; /* Something got screwed up here */
-      sig = isonum_721(chr);
-      chr += rr->len; 
-      len -= rr->len;
-      if (len < 0) goto out;	/* corrupted isofs */
-      
-      switch(sig){
+	int len;
+	unsigned char *chr;
+	int symlink_len = 0;
+	CONTINUE_DECLS;
+
+	if (!ISOFS_SB(inode->i_sb)->s_rock)
+		return 0;
+
+	SETUP_ROCK_RIDGE(de, chr, len);
+	if (regard_xa) {
+		chr += 14;
+		len -= 14;
+		if (len < 0)
+			len = 0;
+	}
+
+      repeat:
+	{
+		int cnt, sig;
+		struct inode *reloc;
+		struct rock_ridge *rr;
+		int rootflag;
+
+		while (len > 2) {	/* There may be one byte for padding somewhere */
+			rr = (struct rock_ridge *)chr;
+			if (rr->len < 3)
+				goto out;	/* Something got screwed up here */
+			sig = isonum_721(chr);
+			chr += rr->len;
+			len -= rr->len;
+			if (len < 0)
+				goto out;	/* corrupted isofs */
+
+			switch (sig) {
 #ifndef CONFIG_ZISOFS		/* No flag for SF or ZF */
-      case SIG('R','R'):
-	if((rr->u.RR.flags[0] & 
- 	    (RR_PX | RR_TF | RR_SL | RR_CL)) == 0) goto out;
-	break;
+			case SIG('R', 'R'):
+				if ((rr->u.RR.flags[0] &
+				     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)
+					goto out;
+				break;
 #endif
-      case SIG('S','P'):
-	CHECK_SP(goto out);
-	break;
-      case SIG('C','E'):
-	CHECK_CE;
-	break;
-      case SIG('E','R'):
-	ISOFS_SB(inode->i_sb)->s_rock = 1;
-	printk(KERN_DEBUG "ISO 9660 Extensions: ");
-	{ int p;
-	  for(p=0;p<rr->u.ER.len_id;p++) printk("%c",rr->u.ER.data[p]);
-	}
-	  printk("\n");
-	break;
-      case SIG('P','X'):
-	inode->i_mode  = isonum_733(rr->u.PX.mode);
-	inode->i_nlink = isonum_733(rr->u.PX.n_links);
-	inode->i_uid   = isonum_733(rr->u.PX.uid);
-	inode->i_gid   = isonum_733(rr->u.PX.gid);
-	break;
-      case SIG('P','N'):
-	{ int high, low;
-	  high = isonum_733(rr->u.PN.dev_high);
-	  low = isonum_733(rr->u.PN.dev_low);
-	  /*
-	   * The Rock Ridge standard specifies that if sizeof(dev_t) <= 4,
-	   * then the high field is unused, and the device number is completely
-	   * stored in the low field.  Some writers may ignore this subtlety,
-	   * and as a result we test to see if the entire device number is
-	   * stored in the low field, and use that.
-	   */
-	  if((low & ~0xff) && high == 0) {
-	    inode->i_rdev = MKDEV(low >> 8, low & 0xff);
-	  } else {
-	    inode->i_rdev = MKDEV(high, low);
-	  }
-	}
-	break;
-      case SIG('T','F'):
-	/* Some RRIP writers incorrectly place ctime in the TF_CREATE field.
-	   Try to handle this correctly for either case. */
-	cnt = 0; /* Rock ridge never appears on a High Sierra disk */
-	if(rr->u.TF.flags & TF_CREATE) { 
-	  inode->i_ctime.tv_sec = iso_date(rr->u.TF.times[cnt++].time, 0);
-	  inode->i_ctime.tv_nsec = 0;
-	}
-	if(rr->u.TF.flags & TF_MODIFY) {
-	  inode->i_mtime.tv_sec = iso_date(rr->u.TF.times[cnt++].time, 0);
-	  inode->i_mtime.tv_nsec = 0;
-	}
-	if(rr->u.TF.flags & TF_ACCESS) {
-	  inode->i_atime.tv_sec = iso_date(rr->u.TF.times[cnt++].time, 0);
-	  inode->i_atime.tv_nsec = 0;
-	}
-	if(rr->u.TF.flags & TF_ATTRIBUTES) { 
-	  inode->i_ctime.tv_sec = iso_date(rr->u.TF.times[cnt++].time, 0);
-	  inode->i_ctime.tv_nsec = 0;
-	} 
-	break;
-      case SIG('S','L'):
-	{int slen;
-	 struct SL_component * slp;
-	 struct SL_component * oldslp;
-	 slen = rr->len - 5;
-	 slp = &rr->u.SL.link;
-	 inode->i_size = symlink_len;
-	 while (slen > 1){
-	   rootflag = 0;
-	   switch(slp->flags &~1){
-	   case 0:
-	     inode->i_size += slp->len;
-	     break;
-	   case 2:
-	     inode->i_size += 1;
-	     break;
-	   case 4:
-	     inode->i_size += 2;
-	     break;
-	   case 8:
-	     rootflag = 1;
-	     inode->i_size += 1;
-	     break;
-	   default:
-	     printk("Symlink component flag not implemented\n");
-	   }
-	   slen -= slp->len + 2;
-	   oldslp = slp;
-	   slp = (struct SL_component *) (((char *) slp) + slp->len + 2);
-
-	   if(slen < 2) {
-	     if(    ((rr->u.SL.flags & 1) != 0) 
-		    && ((oldslp->flags & 1) == 0) ) inode->i_size += 1;
-	     break;
-	   }
-
-	   /*
-	    * If this component record isn't continued, then append a '/'.
-	    */
-	   if (!rootflag && (oldslp->flags & 1) == 0)
-		   inode->i_size += 1;
-	 }
-	}
-	symlink_len = inode->i_size;
-	break;
-      case SIG('R','E'):
-	printk(KERN_WARNING "Attempt to read inode for relocated directory\n");
-	goto out;
-      case SIG('C','L'):
-	ISOFS_I(inode)->i_first_extent = isonum_733(rr->u.CL.location);
-	reloc = isofs_iget(inode->i_sb, ISOFS_I(inode)->i_first_extent, 0);
-	if (!reloc)
-		goto out;
-	inode->i_mode = reloc->i_mode;
-	inode->i_nlink = reloc->i_nlink;
-	inode->i_uid = reloc->i_uid;
-	inode->i_gid = reloc->i_gid;
-	inode->i_rdev = reloc->i_rdev;
-	inode->i_size = reloc->i_size;
-	inode->i_blocks = reloc->i_blocks;
-	inode->i_atime = reloc->i_atime;
-	inode->i_ctime = reloc->i_ctime;
-	inode->i_mtime = reloc->i_mtime;
-	iput(reloc);
-	break;
+			case SIG('S', 'P'):
+				CHECK_SP(goto out);
+				break;
+			case SIG('C', 'E'):
+				CHECK_CE;
+				break;
+			case SIG('E', 'R'):
+				ISOFS_SB(inode->i_sb)->s_rock = 1;
+				printk(KERN_DEBUG "ISO 9660 Extensions: ");
+				{
+					int p;
+					for (p = 0; p < rr->u.ER.len_id; p++)
+						printk("%c", rr->u.ER.data[p]);
+				}
+				printk("\n");
+				break;
+			case SIG('P', 'X'):
+				inode->i_mode = isonum_733(rr->u.PX.mode);
+				inode->i_nlink = isonum_733(rr->u.PX.n_links);
+				inode->i_uid = isonum_733(rr->u.PX.uid);
+				inode->i_gid = isonum_733(rr->u.PX.gid);
+				break;
+			case SIG('P', 'N'):
+				{
+					int high, low;
+					high = isonum_733(rr->u.PN.dev_high);
+					low = isonum_733(rr->u.PN.dev_low);
+					/*
+					 * The Rock Ridge standard specifies that if sizeof(dev_t) <= 4,
+					 * then the high field is unused, and the device number is completely
+					 * stored in the low field.  Some writers may ignore this subtlety,
+					 * and as a result we test to see if the entire device number is
+					 * stored in the low field, and use that.
+					 */
+					if ((low & ~0xff) && high == 0) {
+						inode->i_rdev =
+						    MKDEV(low >> 8, low & 0xff);
+					} else {
+						inode->i_rdev =
+						    MKDEV(high, low);
+					}
+				}
+				break;
+			case SIG('T', 'F'):
+				/* Some RRIP writers incorrectly place ctime in the TF_CREATE field.
+				   Try to handle this correctly for either case. */
+				cnt = 0;	/* Rock ridge never appears on a High Sierra disk */
+				if (rr->u.TF.flags & TF_CREATE) {
+					inode->i_ctime.tv_sec =
+					    iso_date(rr->u.TF.times[cnt++].time,
+						     0);
+					inode->i_ctime.tv_nsec = 0;
+				}
+				if (rr->u.TF.flags & TF_MODIFY) {
+					inode->i_mtime.tv_sec =
+					    iso_date(rr->u.TF.times[cnt++].time,
+						     0);
+					inode->i_mtime.tv_nsec = 0;
+				}
+				if (rr->u.TF.flags & TF_ACCESS) {
+					inode->i_atime.tv_sec =
+					    iso_date(rr->u.TF.times[cnt++].time,
+						     0);
+					inode->i_atime.tv_nsec = 0;
+				}
+				if (rr->u.TF.flags & TF_ATTRIBUTES) {
+					inode->i_ctime.tv_sec =
+					    iso_date(rr->u.TF.times[cnt++].time,
+						     0);
+					inode->i_ctime.tv_nsec = 0;
+				}
+				break;
+			case SIG('S', 'L'):
+				{
+					int slen;
+					struct SL_component *slp;
+					struct SL_component *oldslp;
+					slen = rr->len - 5;
+					slp = &rr->u.SL.link;
+					inode->i_size = symlink_len;
+					while (slen > 1) {
+						rootflag = 0;
+						switch (slp->flags & ~1) {
+						case 0:
+							inode->i_size +=
+							    slp->len;
+							break;
+						case 2:
+							inode->i_size += 1;
+							break;
+						case 4:
+							inode->i_size += 2;
+							break;
+						case 8:
+							rootflag = 1;
+							inode->i_size += 1;
+							break;
+						default:
+							printk
+							    ("Symlink component flag not implemented\n");
+						}
+						slen -= slp->len + 2;
+						oldslp = slp;
+						slp =
+						    (struct SL_component
+						     *)(((char *)slp) +
+							slp->len + 2);
+
+						if (slen < 2) {
+							if (((rr->u.SL.
+							      flags & 1) != 0)
+							    &&
+							    ((oldslp->
+							      flags & 1) == 0))
+								inode->i_size +=
+								    1;
+							break;
+						}
+
+						/*
+						 * If this component record isn't continued, then append a '/'.
+						 */
+						if (!rootflag
+						    && (oldslp->flags & 1) == 0)
+							inode->i_size += 1;
+					}
+				}
+				symlink_len = inode->i_size;
+				break;
+			case SIG('R', 'E'):
+				printk(KERN_WARNING
+				       "Attempt to read inode for relocated directory\n");
+				goto out;
+			case SIG('C', 'L'):
+				ISOFS_I(inode)->i_first_extent =
+				    isonum_733(rr->u.CL.location);
+				reloc =
+				    isofs_iget(inode->i_sb,
+					       ISOFS_I(inode)->i_first_extent,
+					       0);
+				if (!reloc)
+					goto out;
+				inode->i_mode = reloc->i_mode;
+				inode->i_nlink = reloc->i_nlink;
+				inode->i_uid = reloc->i_uid;
+				inode->i_gid = reloc->i_gid;
+				inode->i_rdev = reloc->i_rdev;
+				inode->i_size = reloc->i_size;
+				inode->i_blocks = reloc->i_blocks;
+				inode->i_atime = reloc->i_atime;
+				inode->i_ctime = reloc->i_ctime;
+				inode->i_mtime = reloc->i_mtime;
+				iput(reloc);
+				break;
 #ifdef CONFIG_ZISOFS
-      case SIG('Z','F'):
-	      if ( !ISOFS_SB(inode->i_sb)->s_nocompress ) {
-		      int algo;
-		      algo = isonum_721(rr->u.ZF.algorithm);
-		      if ( algo == SIG('p','z') ) {
-			      int block_shift = isonum_711(&rr->u.ZF.parms[1]);
-			      if ( block_shift < PAGE_CACHE_SHIFT || block_shift > 17 ) {
-				      printk(KERN_WARNING "isofs: Can't handle ZF block size of 2^%d\n", block_shift);
-			      } else {
-				/* Note: we don't change i_blocks here */
-				      ISOFS_I(inode)->i_file_format = isofs_file_compressed;
-				/* Parameters to compression algorithm (header size, block size) */
-				      ISOFS_I(inode)->i_format_parm[0] = isonum_711(&rr->u.ZF.parms[0]);
-				      ISOFS_I(inode)->i_format_parm[1] = isonum_711(&rr->u.ZF.parms[1]);
-				      inode->i_size = isonum_733(rr->u.ZF.real_size);
-			      }
-		      } else {
-			      printk(KERN_WARNING "isofs: Unknown ZF compression algorithm: %c%c\n",
-				     rr->u.ZF.algorithm[0], rr->u.ZF.algorithm[1]);
-		      }
-	      }
-	      break;
+			case SIG('Z', 'F'):
+				if (!ISOFS_SB(inode->i_sb)->s_nocompress) {
+					int algo;
+					algo = isonum_721(rr->u.ZF.algorithm);
+					if (algo == SIG('p', 'z')) {
+						int block_shift =
+						    isonum_711(&rr->u.ZF.
+							       parms[1]);
+						if (block_shift <
+						    PAGE_CACHE_SHIFT
+						    || block_shift > 17) {
+							printk(KERN_WARNING
+							       "isofs: Can't handle ZF block size of 2^%d\n",
+							       block_shift);
+						} else {
+							/* Note: we don't change i_blocks here */
+							ISOFS_I(inode)->
+							    i_file_format =
+							    isofs_file_compressed;
+							/* Parameters to compression algorithm (header size, block size) */
+							ISOFS_I(inode)->
+							    i_format_parm[0] =
+							    isonum_711(&rr->u.
+								       ZF.
+								       parms
+								       [0]);
+							ISOFS_I(inode)->
+							    i_format_parm[1] =
+							    isonum_711(&rr->u.
+								       ZF.
+								       parms
+								       [1]);
+							inode->i_size =
+							    isonum_733(rr->u.ZF.
+								       real_size);
+						}
+					} else {
+						printk(KERN_WARNING
+						       "isofs: Unknown ZF compression algorithm: %c%c\n",
+						       rr->u.ZF.algorithm[0],
+						       rr->u.ZF.algorithm[1]);
+					}
+				}
+				break;
 #endif
-      default:
-	break;
-      }
-    }
-  }
-  MAYBE_CONTINUE(repeat,inode);
- out:
-  if(buffer) kfree(buffer);
-  return 0;
+			default:
+				break;
+			}
+		}
+	}
+	MAYBE_CONTINUE(repeat, inode);
+      out:
+	if (buffer)
+		kfree(buffer);
+	return 0;
 }
 
 static char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)
@@ -376,32 +443,32 @@ static char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)
 			if (slp->len > plimit - rpnt)
 				return NULL;
 			memcpy(rpnt, slp->text, slp->len);
-			rpnt+=slp->len;
+			rpnt += slp->len;
 			break;
 		case 2:
 			if (rpnt >= plimit)
 				return NULL;
-			*rpnt++='.';
+			*rpnt++ = '.';
 			break;
 		case 4:
 			if (2 > plimit - rpnt)
 				return NULL;
-			*rpnt++='.';
-			*rpnt++='.';
+			*rpnt++ = '.';
+			*rpnt++ = '.';
 			break;
 		case 8:
 			if (rpnt >= plimit)
 				return NULL;
 			rootflag = 1;
-			*rpnt++='/';
+			*rpnt++ = '/';
 			break;
 		default:
 			printk("Symlink component flag not implemented (%d)\n",
-			     slp->flags);
+			       slp->flags);
 		}
 		slen -= slp->len + 2;
 		oldslp = slp;
-		slp = (struct SL_component *) ((char *) slp + slp->len + 2);
+		slp = (struct SL_component *)((char *)slp + slp->len + 2);
 
 		if (slen < 2) {
 			/*
@@ -412,7 +479,7 @@ static char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)
 			    !(oldslp->flags & 1)) {
 				if (rpnt >= plimit)
 					return NULL;
-				*rpnt++='/';
+				*rpnt++ = '/';
 			}
 			break;
 		}
@@ -423,24 +490,22 @@ static char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)
 		if (!rootflag && !(oldslp->flags & 1)) {
 			if (rpnt >= plimit)
 				return NULL;
-			*rpnt++='/';
+			*rpnt++ = '/';
 		}
 	}
 	return rpnt;
 }
 
-int parse_rock_ridge_inode(struct iso_directory_record * de,
-			   struct inode * inode)
+int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode)
 {
-   int result=parse_rock_ridge_inode_internal(de,inode,0);
-   /* if rockridge flag was reset and we didn't look for attributes
-    * behind eventual XA attributes, have a look there */
-   if ((ISOFS_SB(inode->i_sb)->s_rock_offset==-1)
-       &&(ISOFS_SB(inode->i_sb)->s_rock==2))
-     {
-	result=parse_rock_ridge_inode_internal(de,inode,14);
-     }
-   return result;
+	int result = parse_rock_ridge_inode_internal(de, inode, 0);
+	/* if rockridge flag was reset and we didn't look for attributes
+	 * behind eventual XA attributes, have a look there */
+	if ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)
+	    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {
+		result = parse_rock_ridge_inode_internal(de, inode, 14);
+	}
+	return result;
 }
 
 /* readpage() for symlinks: reads symlink contents into the page and either
@@ -449,7 +514,7 @@ int parse_rock_ridge_inode(struct iso_directory_record * de,
 static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 {
 	struct inode *inode = page->mapping->host;
-        struct iso_inode_info *ei = ISOFS_I(inode);
+	struct iso_inode_info *ei = ISOFS_I(inode);
 	char *link = kmap(page);
 	unsigned long bufsize = ISOFS_BUFFER_SIZE(inode);
 	struct buffer_head *bh;
@@ -472,10 +537,10 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	if (!bh)
 		goto out_noread;
 
-        offset = ei->i_iget5_offset;
-	pnt = (unsigned char *) bh->b_data + offset;
+	offset = ei->i_iget5_offset;
+	pnt = (unsigned char *)bh->b_data + offset;
 
-	raw_inode = (struct iso_directory_record *) pnt;
+	raw_inode = (struct iso_directory_record *)pnt;
 
 	/*
 	 * If we go past the end of the buffer, there is some sort of error.
@@ -489,8 +554,8 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 	SETUP_ROCK_RIDGE(raw_inode, chr, len);
 
       repeat:
-	while (len > 2) { /* There may be one byte for padding somewhere */
-		rr = (struct rock_ridge *) chr;
+	while (len > 2) {	/* There may be one byte for padding somewhere */
+		rr = (struct rock_ridge *)chr;
 		if (rr->len < 3)
 			goto out;	/* Something got screwed up here */
 		sig = isonum_721(chr);
@@ -555,5 +620,5 @@ static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
 }
 
 struct address_space_operations isofs_symlink_aops = {
-	.readpage	= rock_ridge_symlink_readpage
+	.readpage = rock_ridge_symlink_readpage
 };

commit 94f2f715771d0aa5554451d1e2a920f11b8be3fe
Author: Al Viro <viro@www.linux.org.uk>
Date:   Mon Apr 25 18:32:12 2005 -0700

    [PATCH] isofs includes sanitized
    
    fs/isofs includes trimmed down to something resembling sanity.
    
    Kernel-only parts of linux/iso_fs.h and entire linux/iso_fs_{sb,i}.h
    moved to fs/isofs/isofs.h.
    
    A lot of useless #include in fs/isofs/*.c killed.
    
    Signed-off-by: Al Viro <viro@parcelfarce.linux.theplanet.co.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 8bdd3e409543..089e79c65585 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -6,17 +6,11 @@
  *  Rock Ridge Extensions to iso9660
  */
 
-#include <linux/stat.h>
-#include <linux/time.h>
-#include <linux/iso_fs.h>
-#include <linux/string.h>
-#include <linux/mm.h>
 #include <linux/slab.h>
 #include <linux/pagemap.h>
 #include <linux/smp_lock.h>
-#include <linux/buffer_head.h>
-#include <asm/page.h>
 
+#include "isofs.h"
 #include "rock.h"
 
 /* These functions are designed to read the system areas of a directory record

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
new file mode 100644
index 000000000000..8bdd3e409543
--- /dev/null
+++ b/fs/isofs/rock.c
@@ -0,0 +1,565 @@
+/*
+ *  linux/fs/isofs/rock.c
+ *
+ *  (C) 1992, 1993  Eric Youngdale
+ *
+ *  Rock Ridge Extensions to iso9660
+ */
+
+#include <linux/stat.h>
+#include <linux/time.h>
+#include <linux/iso_fs.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/smp_lock.h>
+#include <linux/buffer_head.h>
+#include <asm/page.h>
+
+#include "rock.h"
+
+/* These functions are designed to read the system areas of a directory record
+ * and extract relevant information.  There are different functions provided
+ * depending upon what information we need at the time.  One function fills
+ * out an inode structure, a second one extracts a filename, a third one
+ * returns a symbolic link name, and a fourth one returns the extent number
+ * for the file. */
+
+#define SIG(A,B) ((A) | ((B) << 8)) /* isonum_721() */
+
+
+/* This is a way of ensuring that we have something in the system
+   use fields that is compatible with Rock Ridge */
+#define CHECK_SP(FAIL)	       			\
+      if(rr->u.SP.magic[0] != 0xbe) FAIL;	\
+      if(rr->u.SP.magic[1] != 0xef) FAIL;       \
+      ISOFS_SB(inode->i_sb)->s_rock_offset=rr->u.SP.skip;
+/* We define a series of macros because each function must do exactly the
+   same thing in certain places.  We use the macros to ensure that everything
+   is done correctly */
+
+#define CONTINUE_DECLS \
+  int cont_extent = 0, cont_offset = 0, cont_size = 0;   \
+  void *buffer = NULL
+
+#define CHECK_CE	       			\
+      {cont_extent = isonum_733(rr->u.CE.extent); \
+      cont_offset = isonum_733(rr->u.CE.offset); \
+      cont_size = isonum_733(rr->u.CE.size);}
+
+#define SETUP_ROCK_RIDGE(DE,CHR,LEN)	      		      	\
+  {LEN= sizeof(struct iso_directory_record) + DE->name_len[0];	\
+  if(LEN & 1) LEN++;						\
+  CHR = ((unsigned char *) DE) + LEN;				\
+  LEN = *((unsigned char *) DE) - LEN;                          \
+  if (LEN<0) LEN=0;                                             \
+  if (ISOFS_SB(inode->i_sb)->s_rock_offset!=-1)                \
+  {                                                             \
+     LEN-=ISOFS_SB(inode->i_sb)->s_rock_offset;                \
+     CHR+=ISOFS_SB(inode->i_sb)->s_rock_offset;                \
+     if (LEN<0) LEN=0;                                          \
+  }                                                             \
+}                                     
+
+#define MAYBE_CONTINUE(LABEL,DEV) \
+  {if (buffer) { kfree(buffer); buffer = NULL; } \
+  if (cont_extent){ \
+    int block, offset, offset1; \
+    struct buffer_head * pbh; \
+    buffer = kmalloc(cont_size,GFP_KERNEL); \
+    if (!buffer) goto out; \
+    block = cont_extent; \
+    offset = cont_offset; \
+    offset1 = 0; \
+    pbh = sb_bread(DEV->i_sb, block); \
+    if(pbh){       \
+      if (offset > pbh->b_size || offset + cont_size > pbh->b_size){	\
+	brelse(pbh); \
+	goto out; \
+      } \
+      memcpy(buffer + offset1, pbh->b_data + offset, cont_size - offset1); \
+      brelse(pbh); \
+      chr = (unsigned char *) buffer; \
+      len = cont_size; \
+      cont_extent = 0; \
+      cont_size = 0; \
+      cont_offset = 0; \
+      goto LABEL; \
+    }    \
+    printk("Unable to read rock-ridge attributes\n");    \
+  }}
+
+/* return length of name field; 0: not found, -1: to be ignored */
+int get_rock_ridge_filename(struct iso_directory_record * de,
+			    char * retname, struct inode * inode)
+{
+  int len;
+  unsigned char * chr;
+  CONTINUE_DECLS;
+  int retnamlen = 0, truncate=0;
+ 
+  if (!ISOFS_SB(inode->i_sb)->s_rock) return 0;
+  *retname = 0;
+
+  SETUP_ROCK_RIDGE(de, chr, len);
+ repeat:
+  {
+    struct rock_ridge * rr;
+    int sig;
+    
+    while (len > 2){ /* There may be one byte for padding somewhere */
+      rr = (struct rock_ridge *) chr;
+      if (rr->len < 3) goto out; /* Something got screwed up here */
+      sig = isonum_721(chr);
+      chr += rr->len; 
+      len -= rr->len;
+      if (len < 0) goto out;	/* corrupted isofs */
+
+      switch(sig){
+      case SIG('R','R'):
+	if((rr->u.RR.flags[0] & RR_NM) == 0) goto out;
+	break;
+      case SIG('S','P'):
+	CHECK_SP(goto out);
+	break;
+      case SIG('C','E'):
+	CHECK_CE;
+	break;
+      case SIG('N','M'):
+	if (truncate) break;
+	if (rr->len < 5) break;
+        /*
+	 * If the flags are 2 or 4, this indicates '.' or '..'.
+	 * We don't want to do anything with this, because it
+	 * screws up the code that calls us.  We don't really
+	 * care anyways, since we can just use the non-RR
+	 * name.
+	 */
+	if (rr->u.NM.flags & 6) {
+	  break;
+	}
+
+	if (rr->u.NM.flags & ~1) {
+	  printk("Unsupported NM flag settings (%d)\n",rr->u.NM.flags);
+	  break;
+	}
+	if((strlen(retname) + rr->len - 5) >= 254) {
+	  truncate = 1;
+	  break;
+	}
+	strncat(retname, rr->u.NM.name, rr->len - 5);
+	retnamlen += rr->len - 5;
+	break;
+      case SIG('R','E'):
+	if (buffer) kfree(buffer);
+	return -1;
+      default:
+	break;
+      }
+    }
+  }
+  MAYBE_CONTINUE(repeat,inode);
+  if (buffer) kfree(buffer);
+  return retnamlen; /* If 0, this file did not have a NM field */
+ out:
+  if(buffer) kfree(buffer);
+  return 0;
+}
+
+static int
+parse_rock_ridge_inode_internal(struct iso_directory_record *de,
+				struct inode *inode, int regard_xa)
+{
+  int len;
+  unsigned char * chr;
+  int symlink_len = 0;
+  CONTINUE_DECLS;
+
+  if (!ISOFS_SB(inode->i_sb)->s_rock) return 0;
+
+  SETUP_ROCK_RIDGE(de, chr, len);
+  if (regard_xa)
+   {
+     chr+=14;
+     len-=14;
+     if (len<0) len=0;
+   }
+   
+ repeat:
+  {
+    int cnt, sig;
+    struct inode * reloc;
+    struct rock_ridge * rr;
+    int rootflag;
+    
+    while (len > 2){ /* There may be one byte for padding somewhere */
+      rr = (struct rock_ridge *) chr;
+      if (rr->len < 3) goto out; /* Something got screwed up here */
+      sig = isonum_721(chr);
+      chr += rr->len; 
+      len -= rr->len;
+      if (len < 0) goto out;	/* corrupted isofs */
+      
+      switch(sig){
+#ifndef CONFIG_ZISOFS		/* No flag for SF or ZF */
+      case SIG('R','R'):
+	if((rr->u.RR.flags[0] & 
+ 	    (RR_PX | RR_TF | RR_SL | RR_CL)) == 0) goto out;
+	break;
+#endif
+      case SIG('S','P'):
+	CHECK_SP(goto out);
+	break;
+      case SIG('C','E'):
+	CHECK_CE;
+	break;
+      case SIG('E','R'):
+	ISOFS_SB(inode->i_sb)->s_rock = 1;
+	printk(KERN_DEBUG "ISO 9660 Extensions: ");
+	{ int p;
+	  for(p=0;p<rr->u.ER.len_id;p++) printk("%c",rr->u.ER.data[p]);
+	}
+	  printk("\n");
+	break;
+      case SIG('P','X'):
+	inode->i_mode  = isonum_733(rr->u.PX.mode);
+	inode->i_nlink = isonum_733(rr->u.PX.n_links);
+	inode->i_uid   = isonum_733(rr->u.PX.uid);
+	inode->i_gid   = isonum_733(rr->u.PX.gid);
+	break;
+      case SIG('P','N'):
+	{ int high, low;
+	  high = isonum_733(rr->u.PN.dev_high);
+	  low = isonum_733(rr->u.PN.dev_low);
+	  /*
+	   * The Rock Ridge standard specifies that if sizeof(dev_t) <= 4,
+	   * then the high field is unused, and the device number is completely
+	   * stored in the low field.  Some writers may ignore this subtlety,
+	   * and as a result we test to see if the entire device number is
+	   * stored in the low field, and use that.
+	   */
+	  if((low & ~0xff) && high == 0) {
+	    inode->i_rdev = MKDEV(low >> 8, low & 0xff);
+	  } else {
+	    inode->i_rdev = MKDEV(high, low);
+	  }
+	}
+	break;
+      case SIG('T','F'):
+	/* Some RRIP writers incorrectly place ctime in the TF_CREATE field.
+	   Try to handle this correctly for either case. */
+	cnt = 0; /* Rock ridge never appears on a High Sierra disk */
+	if(rr->u.TF.flags & TF_CREATE) { 
+	  inode->i_ctime.tv_sec = iso_date(rr->u.TF.times[cnt++].time, 0);
+	  inode->i_ctime.tv_nsec = 0;
+	}
+	if(rr->u.TF.flags & TF_MODIFY) {
+	  inode->i_mtime.tv_sec = iso_date(rr->u.TF.times[cnt++].time, 0);
+	  inode->i_mtime.tv_nsec = 0;
+	}
+	if(rr->u.TF.flags & TF_ACCESS) {
+	  inode->i_atime.tv_sec = iso_date(rr->u.TF.times[cnt++].time, 0);
+	  inode->i_atime.tv_nsec = 0;
+	}
+	if(rr->u.TF.flags & TF_ATTRIBUTES) { 
+	  inode->i_ctime.tv_sec = iso_date(rr->u.TF.times[cnt++].time, 0);
+	  inode->i_ctime.tv_nsec = 0;
+	} 
+	break;
+      case SIG('S','L'):
+	{int slen;
+	 struct SL_component * slp;
+	 struct SL_component * oldslp;
+	 slen = rr->len - 5;
+	 slp = &rr->u.SL.link;
+	 inode->i_size = symlink_len;
+	 while (slen > 1){
+	   rootflag = 0;
+	   switch(slp->flags &~1){
+	   case 0:
+	     inode->i_size += slp->len;
+	     break;
+	   case 2:
+	     inode->i_size += 1;
+	     break;
+	   case 4:
+	     inode->i_size += 2;
+	     break;
+	   case 8:
+	     rootflag = 1;
+	     inode->i_size += 1;
+	     break;
+	   default:
+	     printk("Symlink component flag not implemented\n");
+	   }
+	   slen -= slp->len + 2;
+	   oldslp = slp;
+	   slp = (struct SL_component *) (((char *) slp) + slp->len + 2);
+
+	   if(slen < 2) {
+	     if(    ((rr->u.SL.flags & 1) != 0) 
+		    && ((oldslp->flags & 1) == 0) ) inode->i_size += 1;
+	     break;
+	   }
+
+	   /*
+	    * If this component record isn't continued, then append a '/'.
+	    */
+	   if (!rootflag && (oldslp->flags & 1) == 0)
+		   inode->i_size += 1;
+	 }
+	}
+	symlink_len = inode->i_size;
+	break;
+      case SIG('R','E'):
+	printk(KERN_WARNING "Attempt to read inode for relocated directory\n");
+	goto out;
+      case SIG('C','L'):
+	ISOFS_I(inode)->i_first_extent = isonum_733(rr->u.CL.location);
+	reloc = isofs_iget(inode->i_sb, ISOFS_I(inode)->i_first_extent, 0);
+	if (!reloc)
+		goto out;
+	inode->i_mode = reloc->i_mode;
+	inode->i_nlink = reloc->i_nlink;
+	inode->i_uid = reloc->i_uid;
+	inode->i_gid = reloc->i_gid;
+	inode->i_rdev = reloc->i_rdev;
+	inode->i_size = reloc->i_size;
+	inode->i_blocks = reloc->i_blocks;
+	inode->i_atime = reloc->i_atime;
+	inode->i_ctime = reloc->i_ctime;
+	inode->i_mtime = reloc->i_mtime;
+	iput(reloc);
+	break;
+#ifdef CONFIG_ZISOFS
+      case SIG('Z','F'):
+	      if ( !ISOFS_SB(inode->i_sb)->s_nocompress ) {
+		      int algo;
+		      algo = isonum_721(rr->u.ZF.algorithm);
+		      if ( algo == SIG('p','z') ) {
+			      int block_shift = isonum_711(&rr->u.ZF.parms[1]);
+			      if ( block_shift < PAGE_CACHE_SHIFT || block_shift > 17 ) {
+				      printk(KERN_WARNING "isofs: Can't handle ZF block size of 2^%d\n", block_shift);
+			      } else {
+				/* Note: we don't change i_blocks here */
+				      ISOFS_I(inode)->i_file_format = isofs_file_compressed;
+				/* Parameters to compression algorithm (header size, block size) */
+				      ISOFS_I(inode)->i_format_parm[0] = isonum_711(&rr->u.ZF.parms[0]);
+				      ISOFS_I(inode)->i_format_parm[1] = isonum_711(&rr->u.ZF.parms[1]);
+				      inode->i_size = isonum_733(rr->u.ZF.real_size);
+			      }
+		      } else {
+			      printk(KERN_WARNING "isofs: Unknown ZF compression algorithm: %c%c\n",
+				     rr->u.ZF.algorithm[0], rr->u.ZF.algorithm[1]);
+		      }
+	      }
+	      break;
+#endif
+      default:
+	break;
+      }
+    }
+  }
+  MAYBE_CONTINUE(repeat,inode);
+ out:
+  if(buffer) kfree(buffer);
+  return 0;
+}
+
+static char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)
+{
+	int slen;
+	int rootflag;
+	struct SL_component *oldslp;
+	struct SL_component *slp;
+	slen = rr->len - 5;
+	slp = &rr->u.SL.link;
+	while (slen > 1) {
+		rootflag = 0;
+		switch (slp->flags & ~1) {
+		case 0:
+			if (slp->len > plimit - rpnt)
+				return NULL;
+			memcpy(rpnt, slp->text, slp->len);
+			rpnt+=slp->len;
+			break;
+		case 2:
+			if (rpnt >= plimit)
+				return NULL;
+			*rpnt++='.';
+			break;
+		case 4:
+			if (2 > plimit - rpnt)
+				return NULL;
+			*rpnt++='.';
+			*rpnt++='.';
+			break;
+		case 8:
+			if (rpnt >= plimit)
+				return NULL;
+			rootflag = 1;
+			*rpnt++='/';
+			break;
+		default:
+			printk("Symlink component flag not implemented (%d)\n",
+			     slp->flags);
+		}
+		slen -= slp->len + 2;
+		oldslp = slp;
+		slp = (struct SL_component *) ((char *) slp + slp->len + 2);
+
+		if (slen < 2) {
+			/*
+			 * If there is another SL record, and this component
+			 * record isn't continued, then add a slash.
+			 */
+			if ((!rootflag) && (rr->u.SL.flags & 1) &&
+			    !(oldslp->flags & 1)) {
+				if (rpnt >= plimit)
+					return NULL;
+				*rpnt++='/';
+			}
+			break;
+		}
+
+		/*
+		 * If this component record isn't continued, then append a '/'.
+		 */
+		if (!rootflag && !(oldslp->flags & 1)) {
+			if (rpnt >= plimit)
+				return NULL;
+			*rpnt++='/';
+		}
+	}
+	return rpnt;
+}
+
+int parse_rock_ridge_inode(struct iso_directory_record * de,
+			   struct inode * inode)
+{
+   int result=parse_rock_ridge_inode_internal(de,inode,0);
+   /* if rockridge flag was reset and we didn't look for attributes
+    * behind eventual XA attributes, have a look there */
+   if ((ISOFS_SB(inode->i_sb)->s_rock_offset==-1)
+       &&(ISOFS_SB(inode->i_sb)->s_rock==2))
+     {
+	result=parse_rock_ridge_inode_internal(de,inode,14);
+     }
+   return result;
+}
+
+/* readpage() for symlinks: reads symlink contents into the page and either
+   makes it uptodate and returns 0 or returns error (-EIO) */
+
+static int rock_ridge_symlink_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+        struct iso_inode_info *ei = ISOFS_I(inode);
+	char *link = kmap(page);
+	unsigned long bufsize = ISOFS_BUFFER_SIZE(inode);
+	struct buffer_head *bh;
+	char *rpnt = link;
+	unsigned char *pnt;
+	struct iso_directory_record *raw_inode;
+	CONTINUE_DECLS;
+	unsigned long block, offset;
+	int sig;
+	int len;
+	unsigned char *chr;
+	struct rock_ridge *rr;
+
+	if (!ISOFS_SB(inode->i_sb)->s_rock)
+		goto error;
+
+	block = ei->i_iget5_block;
+	lock_kernel();
+	bh = sb_bread(inode->i_sb, block);
+	if (!bh)
+		goto out_noread;
+
+        offset = ei->i_iget5_offset;
+	pnt = (unsigned char *) bh->b_data + offset;
+
+	raw_inode = (struct iso_directory_record *) pnt;
+
+	/*
+	 * If we go past the end of the buffer, there is some sort of error.
+	 */
+	if (offset + *pnt > bufsize)
+		goto out_bad_span;
+
+	/* Now test for possible Rock Ridge extensions which will override
+	   some of these numbers in the inode structure. */
+
+	SETUP_ROCK_RIDGE(raw_inode, chr, len);
+
+      repeat:
+	while (len > 2) { /* There may be one byte for padding somewhere */
+		rr = (struct rock_ridge *) chr;
+		if (rr->len < 3)
+			goto out;	/* Something got screwed up here */
+		sig = isonum_721(chr);
+		chr += rr->len;
+		len -= rr->len;
+		if (len < 0)
+			goto out;	/* corrupted isofs */
+
+		switch (sig) {
+		case SIG('R', 'R'):
+			if ((rr->u.RR.flags[0] & RR_SL) == 0)
+				goto out;
+			break;
+		case SIG('S', 'P'):
+			CHECK_SP(goto out);
+			break;
+		case SIG('S', 'L'):
+			rpnt = get_symlink_chunk(rpnt, rr,
+						 link + (PAGE_SIZE - 1));
+			if (rpnt == NULL)
+				goto out;
+			break;
+		case SIG('C', 'E'):
+			/* This tells is if there is a continuation record */
+			CHECK_CE;
+		default:
+			break;
+		}
+	}
+	MAYBE_CONTINUE(repeat, inode);
+	if (buffer)
+		kfree(buffer);
+
+	if (rpnt == link)
+		goto fail;
+	brelse(bh);
+	*rpnt = '\0';
+	unlock_kernel();
+	SetPageUptodate(page);
+	kunmap(page);
+	unlock_page(page);
+	return 0;
+
+	/* error exit from macro */
+      out:
+	if (buffer)
+		kfree(buffer);
+	goto fail;
+      out_noread:
+	printk("unable to read i-node block");
+	goto fail;
+      out_bad_span:
+	printk("symlink spans iso9660 blocks\n");
+      fail:
+	brelse(bh);
+	unlock_kernel();
+      error:
+	SetPageError(page);
+	kunmap(page);
+	unlock_page(page);
+	return -EIO;
+}
+
+struct address_space_operations isofs_symlink_aops = {
+	.readpage	= rock_ridge_symlink_readpage
+};
