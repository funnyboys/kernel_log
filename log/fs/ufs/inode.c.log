commit bb8c2d66bc6f7dd6e00fc25203efe0858cf91a5e
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Dec 11 06:35:18 2017 -0500

    ufs: use new i_version API
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index afb601c0dda0..c843ec858cf7 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -36,6 +36,7 @@
 #include <linux/mm.h>
 #include <linux/buffer_head.h>
 #include <linux/writeback.h>
+#include <linux/iversion.h>
 
 #include "ufs_fs.h"
 #include "ufs.h"
@@ -693,7 +694,7 @@ struct inode *ufs_iget(struct super_block *sb, unsigned long ino)
 	if (err)
 		goto bad_inode;
 
-	inode->i_version++;
+	inode_inc_iversion(inode);
 	ufsi->i_lastfrag =
 		(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;
 	ufsi->i_dir_start_lookup = 0;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index f36d6a53687d..afb601c0dda0 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *  linux/fs/ufs/inode.c
  *

commit c0ef65d2928249e822b813beb41b6c1478c556ab
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 16 23:54:47 2017 -0400

    ufs_iget(): fail with -ESTALE on deleted inode
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 7b1b810a8ab1..f36d6a53687d 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -566,10 +566,8 @@ static int ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 	 */
 	inode->i_mode = mode = fs16_to_cpu(sb, ufs_inode->ui_mode);
 	set_nlink(inode, fs16_to_cpu(sb, ufs_inode->ui_nlink));
-	if (inode->i_nlink == 0) {
-		ufs_error (sb, "ufs_read_inode", "inode %lu has zero nlink\n", inode->i_ino);
-		return -1;
-	}
+	if (inode->i_nlink == 0)
+		return -ESTALE;
 
 	/*
 	 * Linux now has 32-bit uid and gid, so we can support EFT.
@@ -614,10 +612,8 @@ static int ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)
 	 */
 	inode->i_mode = mode = fs16_to_cpu(sb, ufs2_inode->ui_mode);
 	set_nlink(inode, fs16_to_cpu(sb, ufs2_inode->ui_nlink));
-	if (inode->i_nlink == 0) {
-		ufs_error (sb, "ufs_read_inode", "inode %lu has zero nlink\n", inode->i_ino);
-		return -1;
-	}
+	if (inode->i_nlink == 0)
+		return -ESTALE;
 
         /*
          * Linux now has 32-bit uid and gid, so we can support EFT.
@@ -657,7 +653,7 @@ struct inode *ufs_iget(struct super_block *sb, unsigned long ino)
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
 	struct buffer_head * bh;
 	struct inode *inode;
-	int err;
+	int err = -EIO;
 
 	UFSD("ENTER, ino %lu\n", ino);
 
@@ -692,9 +688,10 @@ struct inode *ufs_iget(struct super_block *sb, unsigned long ino)
 		err = ufs1_read_inode(inode,
 				      ufs_inode + ufs_inotofsbo(inode->i_ino));
 	}
-
+	brelse(bh);
 	if (err)
 		goto bad_inode;
+
 	inode->i_version++;
 	ufsi->i_lastfrag =
 		(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;
@@ -703,15 +700,13 @@ struct inode *ufs_iget(struct super_block *sb, unsigned long ino)
 
 	ufs_set_inode_ops(inode);
 
-	brelse(bh);
-
 	UFSD("EXIT\n");
 	unlock_new_inode(inode);
 	return inode;
 
 bad_inode:
 	iget_failed(inode);
-	return ERR_PTR(-EIO);
+	return ERR_PTR(err);
 }
 
 static void ufs1_update_inode(struct inode *inode, struct ufs_inode *ufs_inode)

commit 23ac7cba73bb2c6e80f9cdebeb39dc3dad34ebb3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 16 23:49:17 2017 -0400

    fix signedness of timestamps on ufs1
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 9f4590261134..7b1b810a8ab1 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -578,9 +578,9 @@ static int ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 	i_gid_write(inode, ufs_get_inode_gid(sb, ufs_inode));
 
 	inode->i_size = fs64_to_cpu(sb, ufs_inode->ui_size);
-	inode->i_atime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_atime.tv_sec);
-	inode->i_ctime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_ctime.tv_sec);
-	inode->i_mtime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_mtime.tv_sec);
+	inode->i_atime.tv_sec = (signed)fs32_to_cpu(sb, ufs_inode->ui_atime.tv_sec);
+	inode->i_ctime.tv_sec = (signed)fs32_to_cpu(sb, ufs_inode->ui_ctime.tv_sec);
+	inode->i_mtime.tv_sec = (signed)fs32_to_cpu(sb, ufs_inode->ui_mtime.tv_sec);
 	inode->i_mtime.tv_nsec = 0;
 	inode->i_atime.tv_nsec = 0;
 	inode->i_ctime.tv_nsec = 0;

commit a8fad984833832d5ca11a9ed64ddc55646da30e3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 15 03:57:46 2017 -0400

    ufs_truncate_blocks(): fix the case when size is in the last direct block
    
    The logics when deciding whether we need to do anything with direct blocks
    is broken when new size is within the last direct block.  It's better to
    find the path to the last byte _not_ to be removed and use that instead
    of the path to the beginning of the first block to be freed...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 1dda6c4875f9..9f4590261134 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -886,7 +886,6 @@ static inline void free_data(struct to_free *ctx, u64 from, unsigned count)
 	ctx->to = from + count;
 }
 
-#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)
 #define DIRECT_FRAGMENT ((inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift)
 
 static void ufs_trunc_direct(struct inode *inode)
@@ -1124,19 +1123,24 @@ static void ufs_truncate_blocks(struct inode *inode)
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
 	unsigned offsets[4];
-	int depth = ufs_block_to_path(inode, DIRECT_BLOCK, offsets);
+	int depth;
 	int depth2;
 	unsigned i;
 	struct ufs_buffer_head *ubh[3];
 	void *p;
 	u64 block;
 
-	if (!depth)
-		return;
+	if (inode->i_size) {
+		sector_t last = (inode->i_size - 1) >> uspi->s_bshift;
+		depth = ufs_block_to_path(inode, last, offsets);
+		if (!depth)
+			return;
+	} else {
+		depth = 1;
+	}
 
-	/* find the last non-zero in offsets[] */
 	for (depth2 = depth - 1; depth2; depth2--)
-		if (offsets[depth2])
+		if (offsets[depth2] != uspi->s_apb - 1)
 			break;
 
 	mutex_lock(&ufsi->truncate_mutex);
@@ -1145,9 +1149,8 @@ static void ufs_truncate_blocks(struct inode *inode)
 		offsets[0] = UFS_IND_BLOCK;
 	} else {
 		/* get the blocks that should be partially emptied */
-		p = ufs_get_direct_data_ptr(uspi, ufsi, offsets[0]);
+		p = ufs_get_direct_data_ptr(uspi, ufsi, offsets[0]++);
 		for (i = 0; i < depth2; i++) {
-			offsets[i]++;	/* next branch is fully freed */
 			block = ufs_data_ptr_to_cpu(sb, p);
 			if (!block)
 				break;
@@ -1158,7 +1161,7 @@ static void ufs_truncate_blocks(struct inode *inode)
 				write_sequnlock(&ufsi->meta_lock);
 				break;
 			}
-			p = ubh_get_data_ptr(uspi, ubh[i], offsets[i + 1]);
+			p = ubh_get_data_ptr(uspi, ubh[i], offsets[i + 1]++);
 		}
 		while (i--)
 			free_branch_tail(inode, offsets[i + 1], ubh[i], depth - i - 1);

commit 09bf4f5b6e6013f0ad6b090d4a8deebd4e56d878
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 15 00:17:30 2017 -0400

    ufs: avoid grabbing ->truncate_mutex if possible
    
    tail unpacking is done in a wrong place; the deadlocks galore
    is best dealt with by doing that in ->write_iter() (and switching
    to iomap, while we are at it), but that's rather painful to
    backport.  The trouble comes from grabbing pages that cover
    the beginning of tail from inside of ufs_new_fragments(); ongoing
    pageout of any of those is going to deadlock on ->truncate_mutex
    with process that got around to extending the tail holding that
    and waiting for page to get unlocked, while ->writepage() on
    that page is waiting on ->truncate_mutex.
    
    The thing is, we don't need ->truncate_mutex when the fragment
    we are trying to map is within the tail - the damn thing is
    allocated (tail can't contain holes).
    
    Let's do a plain lookup and if the fragment is present, we can
    just pretend that we'd won the race in almost all cases.  The
    only exception is a fragment between the end of tail and the
    end of block containing tail.
    
    Protect ->i_lastfrag with ->meta_lock - read_seqlock_excl() is
    sufficient.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index da553ffec85b..1dda6c4875f9 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -401,13 +401,20 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 	u64 phys64 = 0;
 	unsigned frag = fragment & uspi->s_fpbmask;
 
-	if (!create) {
-		phys64 = ufs_frag_map(inode, offsets, depth);
-		if (phys64)
-			map_bh(bh_result, sb, phys64 + frag);
-		return 0;
-	}
+	phys64 = ufs_frag_map(inode, offsets, depth);
+	if (!create)
+		goto done;
 
+	if (phys64) {
+		if (fragment >= UFS_NDIR_FRAGMENT)
+			goto done;
+		read_seqlock_excl(&UFS_I(inode)->meta_lock);
+		if (fragment < UFS_I(inode)->i_lastfrag) {
+			read_sequnlock_excl(&UFS_I(inode)->meta_lock);
+			goto done;
+		}
+		read_sequnlock_excl(&UFS_I(inode)->meta_lock);
+	}
         /* This code entered only while writing ....? */
 
 	mutex_lock(&UFS_I(inode)->truncate_mutex);
@@ -451,6 +458,11 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 	}
 	mutex_unlock(&UFS_I(inode)->truncate_mutex);
 	return err;
+
+done:
+	if (phys64)
+		map_bh(bh_result, sb, phys64 + frag);
+	return 0;
 }
 
 static int ufs_writepage(struct page *page, struct writeback_control *wbc)
@@ -1161,7 +1173,9 @@ static void ufs_truncate_blocks(struct inode *inode)
 			free_full_branch(inode, block, i - UFS_IND_BLOCK + 1);
 		}
 	}
+	read_seqlock_excl(&ufsi->meta_lock);
 	ufsi->i_lastfrag = DIRECT_FRAGMENT;
+	read_sequnlock_excl(&ufsi->meta_lock);
 	mark_inode_dirty(inode);
 	mutex_unlock(&ufsi->truncate_mutex);
 }

commit 67a70017fa0a152657bc7e337e69bb9c9f5549bf
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jun 10 12:01:50 2017 -0400

    ufs: we need to sync inode before freeing it
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 34f11cf0900a..da553ffec85b 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -848,6 +848,7 @@ void ufs_evict_inode(struct inode * inode)
 		    (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
 		     S_ISLNK(inode->i_mode)))
 			ufs_truncate_blocks(inode);
+		ufs_update_inode(inode, inode_needs_sync(inode));
 	}
 
 	invalidate_inode_buffers(inode);

commit babef37dccbaa49249a22bae9150686815d7be71
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 9 16:20:34 2017 -0400

    excessive checks in ufs_write_failed() and ufs_evict_inode()
    
    As it is, short copy in write() to append-only file will fail
    to truncate the excessive allocated blocks.  As the matter of
    fact, all checks in ufs_truncate_blocks() are either redundant
    or wrong for that caller.  As for the only other caller
    (ufs_evict_inode()), we only need the file type checks there.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 9bf10285c628..34f11cf0900a 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -844,7 +844,9 @@ void ufs_evict_inode(struct inode * inode)
 	truncate_inode_pages_final(&inode->i_data);
 	if (want_delete) {
 		inode->i_size = 0;
-		if (inode->i_blocks)
+		if (inode->i_blocks &&
+		    (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
+		     S_ISLNK(inode->i_mode)))
 			ufs_truncate_blocks(inode);
 	}
 
@@ -1103,7 +1105,7 @@ static int ufs_alloc_lastblock(struct inode *inode, loff_t size)
        return err;
 }
 
-static void __ufs_truncate_blocks(struct inode *inode)
+static void ufs_truncate_blocks(struct inode *inode)
 {
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
@@ -1186,7 +1188,7 @@ static int ufs_truncate(struct inode *inode, loff_t size)
 
 	truncate_setsize(inode, size);
 
-	__ufs_truncate_blocks(inode);
+	ufs_truncate_blocks(inode);
 	inode->i_mtime = inode->i_ctime = current_time(inode);
 	mark_inode_dirty(inode);
 out:
@@ -1194,16 +1196,6 @@ static int ufs_truncate(struct inode *inode, loff_t size)
 	return err;
 }
 
-static void ufs_truncate_blocks(struct inode *inode)
-{
-	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
-	      S_ISLNK(inode->i_mode)))
-		return;
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
-		return;
-	__ufs_truncate_blocks(inode);
-}
-
 int ufs_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	struct inode *inode = d_inode(dentry);

commit 006351ac8ead0d4a67dd3845e3ceffe650a23212
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 8 23:28:53 2017 -0400

    ufs_getfrag_block(): we only grab ->truncate_mutex on block creation path
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 966cced0f88e..9bf10285c628 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -403,7 +403,9 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 
 	if (!create) {
 		phys64 = ufs_frag_map(inode, offsets, depth);
-		goto out;
+		if (phys64)
+			map_bh(bh_result, sb, phys64 + frag);
+		return 0;
 	}
 
         /* This code entered only while writing ....? */

commit 940ef1a0ed939c2ca029fca715e25e7778ce1e34
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 8 23:27:12 2017 -0400

    ufs_extend_tail(): fix the braino in calling conventions of ufs_new_fragments()
    
    ... and it really needs splitting into "new" and "extend" cases, but that's for
    later
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index feb5f280db09..966cced0f88e 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -235,7 +235,8 @@ ufs_extend_tail(struct inode *inode, u64 writes_to,
 
 	p = ufs_get_direct_data_ptr(uspi, ufsi, block);
 	tmp = ufs_new_fragments(inode, p, lastfrag, ufs_data_ptr_to_cpu(sb, p),
-				new_size, err, locked_page);
+				new_size - (lastfrag & uspi->s_fpbmask), err,
+				locked_page);
 	return tmp != 0;
 }
 

commit 8785d84d002c2ce0f68fbcd6c2c86be859802c7e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 8 02:42:03 2017 -0400

    ufs: restore proper tail allocation
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 7e41aee7b69a..feb5f280db09 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -284,7 +284,7 @@ ufs_inode_getfrag(struct inode *inode, unsigned index,
 			goal += uspi->s_fpb;
 	}
 	tmp = ufs_new_fragments(inode, p, ufs_blknum(new_fragment),
-				goal, uspi->s_fpb, err, locked_page);
+				goal, nfrags, err, locked_page);
 
 	if (!tmp) {
 		*err = -ENOSPC;

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 1bc0bd6a9848..7e41aee7b69a 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -25,7 +25,7 @@
  *        David S. Miller (davem@caip.rutgers.edu), 1995
  */
 
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #include <linux/errno.h>
 #include <linux/fs.h>

commit f698cccbc89e33cda4795a375e47daaa3689485e
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Dec 20 10:56:28 2016 -0500

    ufs: fix function declaration for ufs_truncate_blocks
    
    sparse says:
    
        fs/ufs/inode.c:1195:6: warning: symbol 'ufs_truncate_blocks' was not declared. Should it be static?
    
    Note that the forward declaration in the file is already marked static.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 45ceb94e89e4..1bc0bd6a9848 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1191,7 +1191,7 @@ static int ufs_truncate(struct inode *inode, loff_t size)
 	return err;
 }
 
-void ufs_truncate_blocks(struct inode *inode)
+static void ufs_truncate_blocks(struct inode *inode)
 {
 	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
 	      S_ISLNK(inode->i_mode)))

commit e64855c6cfaa0a80c1b71c5f647cb792dc436668
Author: Jan Kara <jack@suse.cz>
Date:   Fri Nov 4 18:08:15 2016 +0100

    fs: Add helper to clean bdev aliases under a bh and use it
    
    Add a helper function that clears buffer heads from a block device
    aliasing passed bh. Use this helper function from filesystems instead of
    the original unmap_underlying_metadata() to save some boiler plate code
    and also have a better name for the functionalily since it is not
    unmapping anything for a *long* time.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 190d64be22ed..45ceb94e89e4 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1070,8 +1070,7 @@ static int ufs_alloc_lastblock(struct inode *inode, loff_t size)
 
        if (buffer_new(bh)) {
 	       clear_buffer_new(bh);
-	       unmap_underlying_metadata(bh->b_bdev,
-					 bh->b_blocknr);
+	       clean_bdev_bh_alias(bh);
 	       /*
 		* we do not zeroize fragment, because of
 		* if it maped to hole, it already contains zeroes

commit 101105b1717f536ca741f940033996302d4ef191
Merge: 35ff96dfd3c9 3873691e5ab3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 20:16:43 2016 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull more vfs updates from Al Viro:
     ">rename2() work from Miklos + current_time() from Deepa"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs: Replace current_fs_time() with current_time()
      fs: Replace CURRENT_TIME_SEC with current_time() for inode timestamps
      fs: Replace CURRENT_TIME with current_time() for inode timestamps
      fs: proc: Delete inode time initializations in proc_alloc_inode()
      vfs: Add current_time() api
      vfs: add note about i_op->rename changes to porting
      fs: rename "rename2" i_op to "rename"
      vfs: remove unused i_op->rename
      fs: make remaining filesystems use .rename2
      libfs: support RENAME_NOREPLACE in simple_rename()
      fs: support RENAME_NOREPLACE for local filesystems
      ncpfs: fix unused variable warning

commit 02027d42c3f747945f19111d3da2092ed2148ac8
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Wed Sep 14 07:48:05 2016 -0700

    fs: Replace CURRENT_TIME_SEC with current_time() for inode timestamps
    
    CURRENT_TIME_SEC is not y2038 safe. current_time() will
    be transitioned to use 64 bit time along with vfs in a
    separate patch.
    There is no plan to transistion CURRENT_TIME_SEC to use
    y2038 safe time interfaces.
    
    current_time() will also be extended to use superblock
    range checking parameters when range checking is introduced.
    
    This works because alloc_super() fills in the the s_time_gran
    in super block to NSEC_PER_SEC.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Acked-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 9f49431e798d..edd3c0a58ed4 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -293,7 +293,7 @@ ufs_inode_getfrag(struct inode *inode, unsigned index,
 
 	if (new)
 		*new = 1;
-	inode->i_ctime = CURRENT_TIME_SEC;
+	inode->i_ctime = current_time(inode);
 	if (IS_SYNC(inode))
 		ufs_sync_inode (inode);
 	mark_inode_dirty(inode);
@@ -375,7 +375,7 @@ ufs_inode_getblock(struct inode *inode, u64 ind_block,
 	mark_buffer_dirty(bh);
 	if (IS_SYNC(inode))
 		sync_dirty_buffer(bh);
-	inode->i_ctime = CURRENT_TIME_SEC;
+	inode->i_ctime = current_time(inode);
 	mark_inode_dirty(inode);
 out:
 	brelse (bh);
@@ -1185,7 +1185,7 @@ static int ufs_truncate(struct inode *inode, loff_t size)
 	truncate_setsize(inode, size);
 
 	__ufs_truncate_blocks(inode);
-	inode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;
+	inode->i_mtime = inode->i_ctime = current_time(inode);
 	mark_inode_dirty(inode);
 out:
 	UFSD("EXIT: err %d\n", err);

commit 31051c85b5e2aaaf6315f74c72a732673632a905
Author: Jan Kara <jack@suse.cz>
Date:   Thu May 26 16:55:18 2016 +0200

    fs: Give dentry to inode_change_ok() instead of inode
    
    inode_change_ok() will be resposible for clearing capabilities and IMA
    extended attributes and as such will need dentry. Give it as an argument
    to inode_change_ok() instead of an inode. Also rename inode_change_ok()
    to setattr_prepare() to better relect that it does also some
    modifications in addition to checks.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 9f49431e798d..e4a4d248a0f5 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1208,7 +1208,7 @@ int ufs_setattr(struct dentry *dentry, struct iattr *attr)
 	unsigned int ia_valid = attr->ia_valid;
 	int error;
 
-	error = inode_change_ok(inode, attr);
+	error = setattr_prepare(dentry, attr);
 	if (error)
 		return error;
 

commit 09cbfeaf1a5a67bfb3201e0c83c810cecb2efa5a
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Fri Apr 1 15:29:47 2016 +0300

    mm, fs: get rid of PAGE_CACHE_* and page_cache_{get,release} macros
    
    PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} macros were introduced *long* time
    ago with promise that one day it will be possible to implement page
    cache with bigger chunks than PAGE_SIZE.
    
    This promise never materialized.  And unlikely will.
    
    We have many places where PAGE_CACHE_SIZE assumed to be equal to
    PAGE_SIZE.  And it's constant source of confusion on whether
    PAGE_CACHE_* or PAGE_* constant should be used in a particular case,
    especially on the border between fs and mm.
    
    Global switching to PAGE_CACHE_SIZE != PAGE_SIZE would cause to much
    breakage to be doable.
    
    Let's stop pretending that pages in page cache are special.  They are
    not.
    
    The changes are pretty straight-forward:
    
     - <foo> << (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - <foo> >> (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} -> PAGE_{SIZE,SHIFT,MASK,ALIGN};
    
     - page_cache_get() -> get_page();
    
     - page_cache_release() -> put_page();
    
    This patch contains automated changes generated with coccinelle using
    script below.  For some reason, coccinelle doesn't patch header files.
    I've called spatch for them manually.
    
    The only adjustment after coccinelle is revert of changes to
    PAGE_CAHCE_ALIGN definition: we are going to drop it later.
    
    There are few places in the code where coccinelle didn't reach.  I'll
    fix them manually in a separate patch.  Comments and documentation also
    will be addressed with the separate patch.
    
    virtual patch
    
    @@
    expression E;
    @@
    - E << (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    expression E;
    @@
    - E >> (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    @@
    - PAGE_CACHE_SHIFT
    + PAGE_SHIFT
    
    @@
    @@
    - PAGE_CACHE_SIZE
    + PAGE_SIZE
    
    @@
    @@
    - PAGE_CACHE_MASK
    + PAGE_MASK
    
    @@
    expression E;
    @@
    - PAGE_CACHE_ALIGN(E)
    + PAGE_ALIGN(E)
    
    @@
    expression E;
    @@
    - page_cache_get(E)
    + get_page(E)
    
    @@
    expression E;
    @@
    - page_cache_release(E)
    + put_page(E)
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index d897e169ab9c..9f49431e798d 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1051,13 +1051,13 @@ static int ufs_alloc_lastblock(struct inode *inode, loff_t size)
 	lastfrag--;
 
 	lastpage = ufs_get_locked_page(mapping, lastfrag >>
-				       (PAGE_CACHE_SHIFT - inode->i_blkbits));
+				       (PAGE_SHIFT - inode->i_blkbits));
        if (IS_ERR(lastpage)) {
                err = -EIO;
                goto out;
        }
 
-       end = lastfrag & ((1 << (PAGE_CACHE_SHIFT - inode->i_blkbits)) - 1);
+       end = lastfrag & ((1 << (PAGE_SHIFT - inode->i_blkbits)) - 1);
        bh = page_buffers(lastpage);
        for (i = 0; i < end; ++i)
                bh = bh->b_this_page;

commit 21fc61c73c3903c4c312d0802da01ec2b323d174
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Nov 17 01:07:57 2015 -0500

    don't put symlink bodies in pagecache into highmem
    
    kmap() in page_follow_link_light() needed to go - allowing to hold
    an arbitrary number of kmaps for long is a great way to deadlocking
    the system.
    
    new helper (inode_nohighmem(inode)) needs to be used for pagecache
    symlinks inodes; done for all in-tree cases.  page_follow_link_light()
    instrumented to yell about anything missed.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 737160a7b819..d897e169ab9c 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -533,6 +533,7 @@ static void ufs_set_inode_ops(struct inode *inode)
 		} else {
 			inode->i_mapping->a_ops = &ufs_aops;
 			inode->i_op = &page_symlink_inode_operations;
+			inode_nohighmem(inode);
 		}
 	} else
 		init_special_inode(inode, inode->i_mode,

commit 9cdce3c074fbd7083923f15225e112a91daff8ed
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Nov 15 18:24:17 2015 -0500

    ufs: get rid of ->setattr() for symlinks
    
    It was to needed for a couple of months in 2010, until UFS
    quota support got dropped.  Since then it's equivalent to
    simple_setattr() (i.e. the default) for everything except the
    regular files.  And dropping it there allows to convert all
    UFS symlinks to {page,simple}_symlink_inode_operations, getting
    rid of fs/ufs/symlink.c completely.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index a064cf44b143..737160a7b819 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -528,11 +528,11 @@ static void ufs_set_inode_ops(struct inode *inode)
 		inode->i_mapping->a_ops = &ufs_aops;
 	} else if (S_ISLNK(inode->i_mode)) {
 		if (!inode->i_blocks) {
-			inode->i_op = &ufs_fast_symlink_inode_operations;
 			inode->i_link = (char *)UFS_I(inode)->i_u1.i_symlink;
+			inode->i_op = &simple_symlink_inode_operations;
 		} else {
-			inode->i_op = &ufs_symlink_inode_operations;
 			inode->i_mapping->a_ops = &ufs_aops;
+			inode->i_op = &page_symlink_inode_operations;
 		}
 	} else
 		init_special_inode(inode, inode->i_mode,

commit 4e317ce73aecb735f389ab0d42ae3197a55265e4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 19 14:27:10 2015 -0400

    ufs_inode_get{frag,block}(): get rid of 'phys' argument
    
    Just pass NULL as locked_page in case of first block in the indirect
    chain.  Old calling conventions aside, a reason for having 'phys'
    was that ufs_inode_getfrag() used to be able to do _two_ allocations
    - indirect block and extending/reallocating a tail.  We needed
    locked_page for the latter (it's a data), but we also needed to
    figure out that indirect block is metadata.  So we used to pass
    non-NULL locked_page in all cases *and* used NULL phys as
    indication of being asked to allocate an indirect.
    
    With tail unpacking taken into a separate function we don't need
    those convolutions anymore.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 7f551b3e3ba4..a064cf44b143 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -245,15 +245,13 @@ ufs_extend_tail(struct inode *inode, u64 writes_to,
  * @index: number of block pointer within the inode's array.
  * @new_fragment: number of new allocated fragment(s)
  * @err: we set it if something wrong
- * @phys: pointer to where we save physical number of new allocated fragments,
- *   NULL if we allocate not data(indirect blocks for example).
  * @new: we set it if we allocate new block
  * @locked_page: for ufs_new_fragments()
  */
 static u64
 ufs_inode_getfrag(struct inode *inode, unsigned index,
 		  sector_t new_fragment, int *err,
-		  long *phys, int *new, struct page *locked_page)
+		  int *new, struct page *locked_page)
 {
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
@@ -286,18 +284,15 @@ ufs_inode_getfrag(struct inode *inode, unsigned index,
 			goal += uspi->s_fpb;
 	}
 	tmp = ufs_new_fragments(inode, p, ufs_blknum(new_fragment),
-				goal, uspi->s_fpb, err,
-				phys != NULL ? locked_page : NULL);
+				goal, uspi->s_fpb, err, locked_page);
 
 	if (!tmp) {
 		*err = -ENOSPC;
 		return 0;
 	}
 
-	if (phys) {
-		*err = 0;
+	if (new)
 		*new = 1;
-	}
 	inode->i_ctime = CURRENT_TIME_SEC;
 	if (IS_SYNC(inode))
 		ufs_sync_inode (inode);
@@ -329,14 +324,13 @@ ufs_inode_getfrag(struct inode *inode, unsigned index,
  * @new_fragment: number of new allocated fragment
  *  (block will hold this fragment and also uspi->s_fpb-1)
  * @err: see ufs_inode_getfrag()
- * @phys: see ufs_inode_getfrag()
  * @new: see ufs_inode_getfrag()
  * @locked_page: see ufs_inode_getfrag()
  */
 static u64
 ufs_inode_getblock(struct inode *inode, u64 ind_block,
 		  unsigned index, sector_t new_fragment, int *err,
-		  long *phys, int *new, struct page *locked_page)
+		  int *new, struct page *locked_page)
 {
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
@@ -404,7 +398,6 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 	unsigned offsets[4];
 	int depth = ufs_block_to_path(inode, fragment >> uspi->s_fpbshift, offsets);
 	u64 phys64 = 0;
-	unsigned long phys;
 	unsigned frag = fragment & uspi->s_fpbmask;
 
 	if (!create) {
@@ -435,16 +428,16 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 
 	if (depth == 1) {
 		phys64 = ufs_inode_getfrag(inode, offsets[0], fragment,
-					   &err, &phys, &new, bh_result->b_page);
+					   &err, &new, bh_result->b_page);
 	} else {
 		int i;
 		phys64 = ufs_inode_getfrag(inode, offsets[0], fragment,
-					   &err, NULL, NULL, bh_result->b_page);
+					   &err, NULL, NULL);
 		for (i = 1; i < depth - 1; i++)
 			phys64 = ufs_inode_getblock(inode, phys64, offsets[i],
-						fragment, &err, NULL, NULL, NULL);
+						fragment, &err, NULL, NULL);
 		phys64 = ufs_inode_getblock(inode, phys64, offsets[depth - 1],
-					fragment, &err, &phys, &new, bh_result->b_page);
+					fragment, &err, &new, bh_result->b_page);
 	}
 out:
 	if (phys64) {

commit 0385f1f9e3e5cb17047474037002500383237f47
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 19 14:20:21 2015 -0400

    ufs_getfrag_block(): tidy up a bit
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index ed70147e1cb4..7f551b3e3ba4 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -398,40 +398,30 @@ ufs_inode_getblock(struct inode *inode, u64 ind_block,
 
 static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head *bh_result, int create)
 {
-	struct super_block * sb = inode->i_sb;
-	struct ufs_sb_info * sbi = UFS_SB(sb);
-	struct ufs_sb_private_info * uspi = sbi->s_uspi;
-	struct buffer_head * bh;
-	int ret, err, new;
+	struct super_block *sb = inode->i_sb;
+	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
+	int err = 0, new = 0;
 	unsigned offsets[4];
 	int depth = ufs_block_to_path(inode, fragment >> uspi->s_fpbshift, offsets);
-	unsigned long phys;
 	u64 phys64 = 0;
+	unsigned long phys;
 	unsigned frag = fragment & uspi->s_fpbmask;
 
 	if (!create) {
 		phys64 = ufs_frag_map(inode, offsets, depth);
-		if (phys64) {
-			phys64 += frag;
-			map_bh(bh_result, sb, phys64);
-		}
-		return 0;
+		goto out;
 	}
 
         /* This code entered only while writing ....? */
 
-	err = -EIO;
-	new = 0;
-	ret = 0;
-	bh = NULL;
-
 	mutex_lock(&UFS_I(inode)->truncate_mutex);
 
 	UFSD("ENTER, ino %lu, fragment %llu\n", inode->i_ino, (unsigned long long)fragment);
-	if (!depth)
-		goto abort_too_big;
-
-	err = 0;
+	if (unlikely(!depth)) {
+		ufs_warning(sb, "ufs_get_block", "block > big");
+		err = -EIO;
+		goto out;
+	}
 
 	if (UFS_I(inode)->i_lastfrag < UFS_NDIR_FRAGMENT) {
 		unsigned lastfrag = UFS_I(inode)->i_lastfrag;
@@ -439,7 +429,7 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 		if (tailfrags && fragment >= lastfrag) {
 			if (!ufs_extend_tail(inode, fragment,
 					     &err, bh_result->b_page))
-				goto abort;
+				goto out;
 		}
 	}
 
@@ -456,23 +446,15 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 		phys64 = ufs_inode_getblock(inode, phys64, offsets[depth - 1],
 					fragment, &err, &phys, &new, bh_result->b_page);
 	}
+out:
 	if (phys64) {
 		phys64 += frag;
-		phys = phys64;
+		map_bh(bh_result, sb, phys64);
+		if (new)
+			set_buffer_new(bh_result);
 	}
-	if (err)
-		goto abort;
-	if (new)
-		set_buffer_new(bh_result);
-	map_bh(bh_result, sb, phys);
-abort:
 	mutex_unlock(&UFS_I(inode)->truncate_mutex);
-
 	return err;
-
-abort_too_big:
-	ufs_warning(sb, "ufs_get_block", "block > big");
-	goto abort;
 }
 
 static int ufs_writepage(struct page *page, struct writeback_control *wbc)

commit 5fbfb238f7a0a5c4633438eb5bdfb4810995c76a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 19 14:10:53 2015 -0400

    ufs_inode_getblock(): failure to read an indirect block is -EIO
    
    ... and not "write to beginning of the disk", TYVM...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index f2d8cc2166af..ed70147e1cb4 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -349,8 +349,10 @@ ufs_inode_getblock(struct inode *inode, u64 ind_block,
 		return 0;
 
 	bh = sb_bread(sb, ind_block + (index >> shift));
-	if (unlikely(!bh))
+	if (unlikely(!bh)) {
+		*err = -EIO;
 		return 0;
+	}
 
 	index &= uspi->s_apbmask >> uspi->s_fpbshift;
 	if (uspi->fs_magic == UFS2_MAGIC)
@@ -454,7 +456,6 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 		phys64 = ufs_inode_getblock(inode, phys64, offsets[depth - 1],
 					fragment, &err, &phys, &new, bh_result->b_page);
 	}
-out:
 	if (phys64) {
 		phys64 += frag;
 		phys = phys64;

commit 4eeff4c9326878ff58ef6fe68d2bf22ef877e5a2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 19 14:08:16 2015 -0400

    ufs_getfrag_block(): turn following indirects into a loop
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index c05cf14ef8ff..f2d8cc2166af 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -444,37 +444,21 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 	if (depth == 1) {
 		phys64 = ufs_inode_getfrag(inode, offsets[0], fragment,
 					   &err, &phys, &new, bh_result->b_page);
-		if (phys64) {
-			phys64 += frag;
-			phys = phys64;
-		}
-		goto out;
-	}
-	if (depth == 2) {
-		phys64 = ufs_inode_getfrag(inode, offsets[0], fragment,
-					   &err, NULL, NULL, bh_result->b_page);
-		goto get_indirect;
-	}
-	if (depth == 3) {
+	} else {
+		int i;
 		phys64 = ufs_inode_getfrag(inode, offsets[0], fragment,
 					   &err, NULL, NULL, bh_result->b_page);
-		goto get_double;
+		for (i = 1; i < depth - 1; i++)
+			phys64 = ufs_inode_getblock(inode, phys64, offsets[i],
+						fragment, &err, NULL, NULL, NULL);
+		phys64 = ufs_inode_getblock(inode, phys64, offsets[depth - 1],
+					fragment, &err, &phys, &new, bh_result->b_page);
 	}
-	phys64 = ufs_inode_getfrag(inode, offsets[0], fragment,
-				   &err, NULL, NULL, bh_result->b_page);
-	phys64 = ufs_inode_getblock(inode, phys64, offsets[1],
-				fragment, &err, NULL, NULL, NULL);
-get_double:
-	phys64 = ufs_inode_getblock(inode, phys64, offsets[depth - 2],
-				fragment, &err, NULL, NULL, NULL);
-get_indirect:
-	phys64 = ufs_inode_getblock(inode, phys64, offsets[depth - 1],
-				fragment, &err, &phys, &new, bh_result->b_page);
+out:
 	if (phys64) {
 		phys64 += frag;
 		phys = phys64;
 	}
-out:
 	if (err)
 		goto abort;
 	if (new)

commit 5336970be09becb2b59ac3812718b2cb80d33347
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 19 13:53:52 2015 -0400

    ufs_inode_getfrag(): pass index instead of 'fragment'
    
    same story as with ufs_inode_getblock()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index d652f64885fd..c05cf14ef8ff 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -242,10 +242,8 @@ ufs_extend_tail(struct inode *inode, u64 writes_to,
 /**
  * ufs_inode_getfrag() - allocate new fragment(s)
  * @inode: pointer to inode
- * @fragment: number of `fragment' which hold pointer
- *   to new allocated fragment(s)
+ * @index: number of block pointer within the inode's array.
  * @new_fragment: number of new allocated fragment(s)
- * @required: how many fragment(s) we require
  * @err: we set it if something wrong
  * @phys: pointer to where we save physical number of new allocated fragments,
  *   NULL if we allocate not data(indirect blocks for example).
@@ -253,15 +251,14 @@ ufs_extend_tail(struct inode *inode, u64 writes_to,
  * @locked_page: for ufs_new_fragments()
  */
 static u64
-ufs_inode_getfrag(struct inode *inode, u64 fragment,
-		  sector_t new_fragment, unsigned int required, int *err,
+ufs_inode_getfrag(struct inode *inode, unsigned index,
+		  sector_t new_fragment, int *err,
 		  long *phys, int *new, struct page *locked_page)
 {
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
-	unsigned blockoff;
-	u64 tmp, goal, lastfrag, block;
+	u64 tmp, goal, lastfrag;
 	unsigned nfrags = uspi->s_fpb;
 	void *p;
 
@@ -270,9 +267,7 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
              goto ufs2;
          */
 
-	block = ufs_fragstoblks (fragment);
-	blockoff = ufs_fragnum (fragment);
-	p = ufs_get_direct_data_ptr(uspi, ufsi, block);
+	p = ufs_get_direct_data_ptr(uspi, ufsi, index);
 	tmp = ufs_data_ptr_to_cpu(sb, p);
 	if (tmp)
 		goto out;
@@ -284,13 +279,13 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 		nfrags = (new_fragment & uspi->s_fpbmask) + 1;
 
 	goal = 0;
-	if (block) {
+	if (index) {
 		goal = ufs_data_ptr_to_cpu(sb,
-				 ufs_get_direct_data_ptr(uspi, ufsi, block - 1));
+				 ufs_get_direct_data_ptr(uspi, ufsi, index - 1));
 		if (goal)
 			goal += uspi->s_fpb;
 	}
-	tmp = ufs_new_fragments(inode, p, fragment - blockoff,
+	tmp = ufs_new_fragments(inode, p, ufs_blknum(new_fragment),
 				goal, uspi->s_fpb, err,
 				phys != NULL ? locked_page : NULL);
 
@@ -408,7 +403,7 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 	int ret, err, new;
 	unsigned offsets[4];
 	int depth = ufs_block_to_path(inode, fragment >> uspi->s_fpbshift, offsets);
-	unsigned long ptr,phys;
+	unsigned long phys;
 	u64 phys64 = 0;
 	unsigned frag = fragment & uspi->s_fpbmask;
 
@@ -446,38 +441,27 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 		}
 	}
 
-	ptr = fragment;
-
 	if (depth == 1) {
-		phys64 = ufs_inode_getfrag(inode, ptr, fragment, 1, &err, &phys,
-					&new, bh_result->b_page);
+		phys64 = ufs_inode_getfrag(inode, offsets[0], fragment,
+					   &err, &phys, &new, bh_result->b_page);
 		if (phys64) {
 			phys64 += frag;
 			phys = phys64;
 		}
 		goto out;
 	}
-	ptr -= UFS_NDIR_FRAGMENT;
 	if (depth == 2) {
-		phys64 = ufs_inode_getfrag(inode,
-					UFS_IND_FRAGMENT + (ptr >> uspi->s_apbshift),
-					fragment, uspi->s_fpb, &err, NULL, NULL,
-					bh_result->b_page);
+		phys64 = ufs_inode_getfrag(inode, offsets[0], fragment,
+					   &err, NULL, NULL, bh_result->b_page);
 		goto get_indirect;
 	}
-	ptr -= 1 << (uspi->s_apbshift + uspi->s_fpbshift);
 	if (depth == 3) {
-		phys64 = ufs_inode_getfrag(inode,
-					UFS_DIND_FRAGMENT + (ptr >> uspi->s_2apbshift),
-					fragment, uspi->s_fpb, &err, NULL, NULL,
-					bh_result->b_page);
+		phys64 = ufs_inode_getfrag(inode, offsets[0], fragment,
+					   &err, NULL, NULL, bh_result->b_page);
 		goto get_double;
 	}
-	ptr -= 1 << (uspi->s_2apbshift + uspi->s_fpbshift);
-	phys64 = ufs_inode_getfrag(inode,
-				UFS_TIND_FRAGMENT + (ptr >> uspi->s_3apbshift),
-				fragment, uspi->s_fpb, &err, NULL, NULL,
-				bh_result->b_page);
+	phys64 = ufs_inode_getfrag(inode, offsets[0], fragment,
+				   &err, NULL, NULL, bh_result->b_page);
 	phys64 = ufs_inode_getblock(inode, phys64, offsets[1],
 				fragment, &err, NULL, NULL, NULL);
 get_double:

commit 0f3c1294bedcc4544c68d6b84699bdaa334b11b8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 19 13:40:25 2015 -0400

    ufs_inode_getfrag(): split extending the partial blocks off
    
    ufs_extend_tail() is handling that now.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 25d47df934e2..d652f64885fd 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -205,6 +205,40 @@ static u64 ufs_frag_map(struct inode *inode, unsigned offsets[4], int depth)
 	goto again;
 }
 
+/*
+ * Unpacking tails: we have a file with partial final block and
+ * we had been asked to extend it.  If the fragment being written
+ * is within the same block, we need to extend the tail just to cover
+ * that fragment.  Otherwise the tail is extended to full block.
+ *
+ * Note that we might need to create a _new_ tail, but that will
+ * be handled elsewhere; this is strictly for resizing old
+ * ones.
+ */
+static bool
+ufs_extend_tail(struct inode *inode, u64 writes_to,
+		  int *err, struct page *locked_page)
+{
+	struct ufs_inode_info *ufsi = UFS_I(inode);
+	struct super_block *sb = inode->i_sb;
+	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
+	unsigned lastfrag = ufsi->i_lastfrag;	/* it's a short file, so unsigned is enough */
+	unsigned block = ufs_fragstoblks(lastfrag);
+	unsigned new_size;
+	void *p;
+	u64 tmp;
+
+	if (writes_to < (lastfrag | uspi->s_fpbmask))
+		new_size = (writes_to & uspi->s_fpbmask) + 1;
+	else
+		new_size = uspi->s_fpb;
+
+	p = ufs_get_direct_data_ptr(uspi, ufsi, block);
+	tmp = ufs_new_fragments(inode, p, lastfrag, ufs_data_ptr_to_cpu(sb, p),
+				new_size, err, locked_page);
+	return tmp != 0;
+}
+
 /**
  * ufs_inode_getfrag() - allocate new fragment(s)
  * @inode: pointer to inode
@@ -226,13 +260,10 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
-	unsigned blockoff, lastblockoff;
-	u64 tmp, goal, lastfrag, block, lastblock;
-	void *p, *p2;
-
-	UFSD("ENTER, ino %lu, fragment %llu, new_fragment %llu, required %u, "
-	     "metadata %d\n", inode->i_ino, (unsigned long long)fragment,
-	     (unsigned long long)new_fragment, required, !phys);
+	unsigned blockoff;
+	u64 tmp, goal, lastfrag, block;
+	unsigned nfrags = uspi->s_fpb;
+	void *p;
 
         /* TODO : to be done for write support
         if ( (flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)
@@ -242,66 +273,27 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 	block = ufs_fragstoblks (fragment);
 	blockoff = ufs_fragnum (fragment);
 	p = ufs_get_direct_data_ptr(uspi, ufsi, block);
-
-	goal = 0;
-
 	tmp = ufs_data_ptr_to_cpu(sb, p);
+	if (tmp)
+		goto out;
 
 	lastfrag = ufsi->i_lastfrag;
-	if (tmp && fragment < lastfrag)
-		goto out;
 
-	lastblock = ufs_fragstoblks (lastfrag);
-	lastblockoff = ufs_fragnum (lastfrag);
-	/*
-	 * We will extend file into new block beyond last allocated block
-	 */
-	if (lastblock < block) {
-		/*
-		 * We must reallocate last allocated block
-		 */
-		if (lastblockoff) {
-			p2 = ufs_get_direct_data_ptr(uspi, ufsi, lastblock);
-			tmp = ufs_new_fragments(inode, p2, lastfrag,
-						ufs_data_ptr_to_cpu(sb, p2),
-						uspi->s_fpb - lastblockoff,
-						err, locked_page);
-			if (!tmp)
-				return 0;
-			lastfrag = ufsi->i_lastfrag;
-		}
-		tmp = ufs_data_ptr_to_cpu(sb,
-					 ufs_get_direct_data_ptr(uspi, ufsi,
-								 lastblock));
-		if (tmp)
-			goal = tmp + uspi->s_fpb;
-		tmp = ufs_new_fragments (inode, p, fragment - blockoff,
-					 goal, required + blockoff,
-					 err,
-					 phys != NULL ? locked_page : NULL);
-	} else if (lastblock == block) {
-	/*
-	 * We will extend last allocated block
-	 */
-		tmp = ufs_new_fragments(inode, p, fragment -
-					(blockoff - lastblockoff),
-					ufs_data_ptr_to_cpu(sb, p),
-					required +  (blockoff - lastblockoff),
-					err, phys != NULL ? locked_page : NULL);
-	} else /* (lastblock > block) */ {
-	/*
-	 * We will allocate new block before last allocated block
-	 */
-		if (block) {
-			tmp = ufs_data_ptr_to_cpu(sb,
-						 ufs_get_direct_data_ptr(uspi, ufsi, block - 1));
-			if (tmp)
-				goal = tmp + uspi->s_fpb;
-		}
-		tmp = ufs_new_fragments(inode, p, fragment - blockoff,
-					goal, uspi->s_fpb, err,
-					phys != NULL ? locked_page : NULL);
+	/* will that be a new tail? */
+	if (new_fragment < UFS_NDIR_FRAGMENT && new_fragment >= lastfrag)
+		nfrags = (new_fragment & uspi->s_fpbmask) + 1;
+
+	goal = 0;
+	if (block) {
+		goal = ufs_data_ptr_to_cpu(sb,
+				 ufs_get_direct_data_ptr(uspi, ufsi, block - 1));
+		if (goal)
+			goal += uspi->s_fpb;
 	}
+	tmp = ufs_new_fragments(inode, p, fragment - blockoff,
+				goal, uspi->s_fpb, err,
+				phys != NULL ? locked_page : NULL);
+
 	if (!tmp) {
 		*err = -ENOSPC;
 		return 0;
@@ -419,7 +411,6 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 	unsigned long ptr,phys;
 	u64 phys64 = 0;
 	unsigned frag = fragment & uspi->s_fpbmask;
-	unsigned mask = uspi->s_apbmask >> uspi->s_fpbshift;
 
 	if (!create) {
 		phys64 = ufs_frag_map(inode, offsets, depth);
@@ -444,6 +435,17 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 		goto abort_too_big;
 
 	err = 0;
+
+	if (UFS_I(inode)->i_lastfrag < UFS_NDIR_FRAGMENT) {
+		unsigned lastfrag = UFS_I(inode)->i_lastfrag;
+		unsigned tailfrags = lastfrag & uspi->s_fpbmask;
+		if (tailfrags && fragment >= lastfrag) {
+			if (!ufs_extend_tail(inode, fragment,
+					     &err, bh_result->b_page))
+				goto abort;
+		}
+	}
+
 	ptr = fragment;
 
 	if (depth == 1) {

commit 619cfac09134b4de7a4f232cf3636cf43728577d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 19 01:23:08 2015 -0400

    ufs_inode_getblock(): pass indirect block number and full index
    
    ... instead of messing with buffer_head.  We can bloody well do
    sb_bread() in there.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 6866b904f148..25d47df934e2 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -337,8 +337,8 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 /**
  * ufs_inode_getblock() - allocate new block
  * @inode: pointer to inode
- * @bh: pointer to block which hold "pointer" to new allocated block
- * @index: number of pointer in the indirect block
+ * @ind_block: block number of the indirect block
+ * @index: number of pointer within the indirect block
  * @new_fragment: number of new allocated fragment
  *  (block will hold this fragment and also uspi->s_fpb-1)
  * @err: see ufs_inode_getfrag()
@@ -347,23 +347,25 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
  * @locked_page: see ufs_inode_getfrag()
  */
 static u64
-ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
+ufs_inode_getblock(struct inode *inode, u64 ind_block,
 		  unsigned index, sector_t new_fragment, int *err,
 		  long *phys, int *new, struct page *locked_page)
 {
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
+	int shift = uspi->s_apbshift - uspi->s_fpbshift;
 	u64 tmp = 0, goal;
+	struct buffer_head *bh;
 	void *p;
 
-	if (!bh)
-		goto out;
-	if (!buffer_uptodate(bh)) {
-		ll_rw_block (READ, 1, &bh);
-		wait_on_buffer (bh);
-		if (!buffer_uptodate(bh))
-			goto out;
-	}
+	if (!ind_block)
+		return 0;
+
+	bh = sb_bread(sb, ind_block + (index >> shift));
+	if (unlikely(!bh))
+		return 0;
+
+	index &= uspi->s_apbmask >> uspi->s_fpbshift;
 	if (uspi->fs_magic == UFS2_MAGIC)
 		p = (__fs64 *)bh->b_data + index;
 	else
@@ -459,12 +461,6 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 					UFS_IND_FRAGMENT + (ptr >> uspi->s_apbshift),
 					fragment, uspi->s_fpb, &err, NULL, NULL,
 					bh_result->b_page);
-		if (phys64) {
-			phys64 += (ptr >> uspi->s_apbshift) & uspi->s_fpbmask;
-			bh = sb_getblk(sb, phys64);
-		} else {
-			bh = NULL;
-		}
 		goto get_indirect;
 	}
 	ptr -= 1 << (uspi->s_apbshift + uspi->s_fpbshift);
@@ -473,12 +469,6 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 					UFS_DIND_FRAGMENT + (ptr >> uspi->s_2apbshift),
 					fragment, uspi->s_fpb, &err, NULL, NULL,
 					bh_result->b_page);
-		if (phys64) {
-			phys64 += (ptr >> uspi->s_2apbshift) & uspi->s_fpbmask;
-			bh = sb_getblk(sb, phys64);
-		} else {
-			bh = NULL;
-		}
 		goto get_double;
 	}
 	ptr -= 1 << (uspi->s_2apbshift + uspi->s_fpbshift);
@@ -486,33 +476,13 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 				UFS_TIND_FRAGMENT + (ptr >> uspi->s_3apbshift),
 				fragment, uspi->s_fpb, &err, NULL, NULL,
 				bh_result->b_page);
-	if (phys64) {
-		phys64 += (ptr >> uspi->s_3apbshift) & uspi->s_fpbmask;
-		bh = sb_getblk(sb, phys64);
-	} else {
-		bh = NULL;
-	}
-	phys64 = ufs_inode_getblock(inode, bh,
-				offsets[1] & mask,
+	phys64 = ufs_inode_getblock(inode, phys64, offsets[1],
 				fragment, &err, NULL, NULL, NULL);
-	if (phys64) {
-		phys64 += (ptr >> uspi->s_2apbshift) & uspi->s_fpbmask,
-		bh = sb_getblk(sb, phys64);
-	} else {
-		bh = NULL;
-	}
 get_double:
-	phys64 = ufs_inode_getblock(inode, bh,
-				offsets[depth - 2] & mask,
+	phys64 = ufs_inode_getblock(inode, phys64, offsets[depth - 2],
 				fragment, &err, NULL, NULL, NULL);
-	if (phys64) {
-		phys64 += (ptr >> uspi->s_apbshift) & uspi->s_fpbmask,
-		bh = sb_getblk(sb, phys64);
-	} else {
-		bh = NULL;
-	}
 get_indirect:
-	phys64 = ufs_inode_getblock(inode, bh, offsets[depth - 1] & mask,
+	phys64 = ufs_inode_getblock(inode, phys64, offsets[depth - 1],
 				fragment, &err, &phys, &new, bh_result->b_page);
 	if (phys64) {
 		phys64 += frag;

commit 721435a7679e13f810133dbea769f87ad7bae3a1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 19 01:06:21 2015 -0400

    ufs_inode_getblock(): pass index instead of 'fragment'
    
    The value passed to ufs_inode_getblock() as the 3rd argument
    had lower bits ignored; the upper bits were shifted down
    and used and they actually make sense - those are _lower_ bits
    of index in indirect block (i.e. they form the index within
    a fragment within an indirect block).
    
    Pass those as argument.  Upper bits of index (i.e. the number
    of fragment within indirect block) will join them shortly.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index eeccf45fcd57..6866b904f148 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -338,8 +338,7 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
  * ufs_inode_getblock() - allocate new block
  * @inode: pointer to inode
  * @bh: pointer to block which hold "pointer" to new allocated block
- * @fragment: number of `fragment' which hold pointer
- *   to new allocated block
+ * @index: number of pointer in the indirect block
  * @new_fragment: number of new allocated fragment
  *  (block will hold this fragment and also uspi->s_fpb-1)
  * @err: see ufs_inode_getfrag()
@@ -349,20 +348,14 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
  */
 static u64
 ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
-		  u64 fragment, sector_t new_fragment, int *err,
+		  unsigned index, sector_t new_fragment, int *err,
 		  long *phys, int *new, struct page *locked_page)
 {
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
-	u64 tmp = 0, goal, block;
+	u64 tmp = 0, goal;
 	void *p;
 
-	block = ufs_fragstoblks (fragment);
-
-	UFSD("ENTER, ino %lu, fragment %llu, new_fragment %llu, metadata %d\n",
-	     inode->i_ino, (unsigned long long)fragment,
-	     (unsigned long long)new_fragment, !phys);
-
 	if (!bh)
 		goto out;
 	if (!buffer_uptodate(bh)) {
@@ -372,17 +365,17 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 			goto out;
 	}
 	if (uspi->fs_magic == UFS2_MAGIC)
-		p = (__fs64 *)bh->b_data + block;
+		p = (__fs64 *)bh->b_data + index;
 	else
-		p = (__fs32 *)bh->b_data + block;
+		p = (__fs32 *)bh->b_data + index;
 
 	tmp = ufs_data_ptr_to_cpu(sb, p);
 	if (tmp)
 		goto out;
 
-	if (block && (uspi->fs_magic == UFS2_MAGIC ?
-		      (tmp = fs64_to_cpu(sb, ((__fs64 *)bh->b_data)[block-1])) :
-		      (tmp = fs32_to_cpu(sb, ((__fs32 *)bh->b_data)[block-1]))))
+	if (index && (uspi->fs_magic == UFS2_MAGIC ?
+		      (tmp = fs64_to_cpu(sb, ((__fs64 *)bh->b_data)[index-1])) :
+		      (tmp = fs32_to_cpu(sb, ((__fs32 *)bh->b_data)[index-1]))))
 		goal = tmp + uspi->s_fpb;
 	else
 		goal = bh->b_blocknr + uspi->s_fpb;
@@ -424,6 +417,7 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 	unsigned long ptr,phys;
 	u64 phys64 = 0;
 	unsigned frag = fragment & uspi->s_fpbmask;
+	unsigned mask = uspi->s_apbmask >> uspi->s_fpbshift;
 
 	if (!create) {
 		phys64 = ufs_frag_map(inode, offsets, depth);
@@ -499,7 +493,7 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 		bh = NULL;
 	}
 	phys64 = ufs_inode_getblock(inode, bh,
-				(ptr >> uspi->s_2apbshift) & uspi->s_apbmask,
+				offsets[1] & mask,
 				fragment, &err, NULL, NULL, NULL);
 	if (phys64) {
 		phys64 += (ptr >> uspi->s_2apbshift) & uspi->s_fpbmask,
@@ -509,7 +503,7 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 	}
 get_double:
 	phys64 = ufs_inode_getblock(inode, bh,
-				(ptr >> uspi->s_apbshift) & uspi->s_apbmask,
+				offsets[depth - 2] & mask,
 				fragment, &err, NULL, NULL, NULL);
 	if (phys64) {
 		phys64 += (ptr >> uspi->s_apbshift) & uspi->s_fpbmask,
@@ -518,8 +512,8 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 		bh = NULL;
 	}
 get_indirect:
-	phys64 = ufs_inode_getblock(inode, bh, ptr & uspi->s_apbmask, fragment,
-			  &err, &phys, &new, bh_result->b_page);
+	phys64 = ufs_inode_getblock(inode, bh, offsets[depth - 1] & mask,
+				fragment, &err, &phys, &new, bh_result->b_page);
 	if (phys64) {
 		phys64 += frag;
 		phys = phys64;

commit 177848a018cb2cb196feac2990814ac8d7bb3c8e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 19 00:53:06 2015 -0400

    ufs_inode_get{frag,block}(): leave sb_getblk() to caller
    
    just return the damn block number
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 156ba3c26906..eeccf45fcd57 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -218,7 +218,7 @@ static u64 ufs_frag_map(struct inode *inode, unsigned offsets[4], int depth)
  * @new: we set it if we allocate new block
  * @locked_page: for ufs_new_fragments()
  */
-static struct buffer_head *
+static u64
 ufs_inode_getfrag(struct inode *inode, u64 fragment,
 		  sector_t new_fragment, unsigned int required, int *err,
 		  long *phys, int *new, struct page *locked_page)
@@ -267,7 +267,7 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 						uspi->s_fpb - lastblockoff,
 						err, locked_page);
 			if (!tmp)
-				return NULL;
+				return 0;
 			lastfrag = ufsi->i_lastfrag;
 		}
 		tmp = ufs_data_ptr_to_cpu(sb,
@@ -304,7 +304,7 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 	}
 	if (!tmp) {
 		*err = -ENOSPC;
-		return NULL;
+		return 0;
 	}
 
 	if (phys) {
@@ -316,13 +316,7 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 		ufs_sync_inode (inode);
 	mark_inode_dirty(inode);
 out:
-	tmp += uspi->s_sbbase + blockoff;
-	if (!phys) {
-		return sb_getblk(sb, tmp);
-	} else {
-		*phys = tmp;
-		return NULL;
-	}
+	return tmp + uspi->s_sbbase;
 
      /* This part : To be implemented ....
         Required only for writing, not required for READ-ONLY.
@@ -353,26 +347,22 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
  * @new: see ufs_inode_getfrag()
  * @locked_page: see ufs_inode_getfrag()
  */
-static struct buffer_head *
+static u64
 ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 		  u64 fragment, sector_t new_fragment, int *err,
 		  long *phys, int *new, struct page *locked_page)
 {
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
-	struct buffer_head * result;
-	unsigned blockoff;
 	u64 tmp = 0, goal, block;
 	void *p;
 
 	block = ufs_fragstoblks (fragment);
-	blockoff = ufs_fragnum (fragment);
 
 	UFSD("ENTER, ino %lu, fragment %llu, new_fragment %llu, metadata %d\n",
 	     inode->i_ino, (unsigned long long)fragment,
 	     (unsigned long long)new_fragment, !phys);
 
-	result = NULL;
 	if (!bh)
 		goto out;
 	if (!buffer_uptodate(bh)) {
@@ -411,16 +401,10 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 	mark_inode_dirty(inode);
 out:
 	brelse (bh);
-	if (tmp) {
-		tmp += uspi->s_sbbase + blockoff;
-		if (phys) {
-			*phys = tmp;
-		} else {
-			result = sb_getblk(sb, tmp);
-		}
-	}
 	UFSD("EXIT\n");
-	return result;
+	if (tmp)
+		tmp += uspi->s_sbbase;
+	return tmp;
 }
 
 /**
@@ -439,11 +423,12 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 	int depth = ufs_block_to_path(inode, fragment >> uspi->s_fpbshift, offsets);
 	unsigned long ptr,phys;
 	u64 phys64 = 0;
+	unsigned frag = fragment & uspi->s_fpbmask;
 
 	if (!create) {
 		phys64 = ufs_frag_map(inode, offsets, depth);
 		if (phys64) {
-			phys64 += fragment & uspi->s_fpbmask;
+			phys64 += frag;
 			map_bh(bh_result, sb, phys64);
 		}
 		return 0;
@@ -466,42 +451,79 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 	ptr = fragment;
 
 	if (depth == 1) {
-		bh = ufs_inode_getfrag(inode, ptr, fragment, 1, &err, &phys,
+		phys64 = ufs_inode_getfrag(inode, ptr, fragment, 1, &err, &phys,
 					&new, bh_result->b_page);
+		if (phys64) {
+			phys64 += frag;
+			phys = phys64;
+		}
 		goto out;
 	}
 	ptr -= UFS_NDIR_FRAGMENT;
 	if (depth == 2) {
-		bh = ufs_inode_getfrag(inode,
+		phys64 = ufs_inode_getfrag(inode,
 					UFS_IND_FRAGMENT + (ptr >> uspi->s_apbshift),
 					fragment, uspi->s_fpb, &err, NULL, NULL,
 					bh_result->b_page);
+		if (phys64) {
+			phys64 += (ptr >> uspi->s_apbshift) & uspi->s_fpbmask;
+			bh = sb_getblk(sb, phys64);
+		} else {
+			bh = NULL;
+		}
 		goto get_indirect;
 	}
 	ptr -= 1 << (uspi->s_apbshift + uspi->s_fpbshift);
 	if (depth == 3) {
-		bh = ufs_inode_getfrag(inode,
+		phys64 = ufs_inode_getfrag(inode,
 					UFS_DIND_FRAGMENT + (ptr >> uspi->s_2apbshift),
 					fragment, uspi->s_fpb, &err, NULL, NULL,
 					bh_result->b_page);
+		if (phys64) {
+			phys64 += (ptr >> uspi->s_2apbshift) & uspi->s_fpbmask;
+			bh = sb_getblk(sb, phys64);
+		} else {
+			bh = NULL;
+		}
 		goto get_double;
 	}
 	ptr -= 1 << (uspi->s_2apbshift + uspi->s_fpbshift);
-	bh = ufs_inode_getfrag(inode,
+	phys64 = ufs_inode_getfrag(inode,
 				UFS_TIND_FRAGMENT + (ptr >> uspi->s_3apbshift),
 				fragment, uspi->s_fpb, &err, NULL, NULL,
 				bh_result->b_page);
-	bh = ufs_inode_getblock(inode, bh,
+	if (phys64) {
+		phys64 += (ptr >> uspi->s_3apbshift) & uspi->s_fpbmask;
+		bh = sb_getblk(sb, phys64);
+	} else {
+		bh = NULL;
+	}
+	phys64 = ufs_inode_getblock(inode, bh,
 				(ptr >> uspi->s_2apbshift) & uspi->s_apbmask,
 				fragment, &err, NULL, NULL, NULL);
+	if (phys64) {
+		phys64 += (ptr >> uspi->s_2apbshift) & uspi->s_fpbmask,
+		bh = sb_getblk(sb, phys64);
+	} else {
+		bh = NULL;
+	}
 get_double:
-	bh = ufs_inode_getblock(inode, bh,
+	phys64 = ufs_inode_getblock(inode, bh,
 				(ptr >> uspi->s_apbshift) & uspi->s_apbmask,
 				fragment, &err, NULL, NULL, NULL);
+	if (phys64) {
+		phys64 += (ptr >> uspi->s_apbshift) & uspi->s_fpbmask,
+		bh = sb_getblk(sb, phys64);
+	} else {
+		bh = NULL;
+	}
 get_indirect:
-	bh = ufs_inode_getblock(inode, bh, ptr & uspi->s_apbmask, fragment,
+	phys64 = ufs_inode_getblock(inode, bh, ptr & uspi->s_apbmask, fragment,
 			  &err, &phys, &new, bh_result->b_page);
-
+	if (phys64) {
+		phys64 += frag;
+		phys = phys64;
+	}
 out:
 	if (err)
 		goto abort;

commit 8d9dcf14367388674f4d792f494e6f1d6536ac95
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 19 00:32:42 2015 -0400

    ufs_getfrag_block(): get rid of macro jungles
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index d65a89030c91..156ba3c26906 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -465,49 +465,42 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 	err = 0;
 	ptr = fragment;
 
-	/*
-	 * ok, these macros clean the logic up a bit and make
-	 * it much more readable:
-	 */
-#define GET_INODE_DATABLOCK(x) \
-	ufs_inode_getfrag(inode, x, fragment, 1, &err, &phys, &new,\
-			  bh_result->b_page)
-#define GET_INODE_PTR(x) \
-	ufs_inode_getfrag(inode, x, fragment, uspi->s_fpb, &err, NULL, NULL,\
-			  bh_result->b_page)
-#define GET_INDIRECT_DATABLOCK(x) \
-	ufs_inode_getblock(inode, bh, x, fragment,	\
-			  &err, &phys, &new, bh_result->b_page)
-#define GET_INDIRECT_PTR(x) \
-	ufs_inode_getblock(inode, bh, x, fragment,	\
-			  &err, NULL, NULL, NULL)
-
 	if (depth == 1) {
-		bh = GET_INODE_DATABLOCK(ptr);
+		bh = ufs_inode_getfrag(inode, ptr, fragment, 1, &err, &phys,
+					&new, bh_result->b_page);
 		goto out;
 	}
 	ptr -= UFS_NDIR_FRAGMENT;
 	if (depth == 2) {
-		bh = GET_INODE_PTR(UFS_IND_FRAGMENT + (ptr >> uspi->s_apbshift));
+		bh = ufs_inode_getfrag(inode,
+					UFS_IND_FRAGMENT + (ptr >> uspi->s_apbshift),
+					fragment, uspi->s_fpb, &err, NULL, NULL,
+					bh_result->b_page);
 		goto get_indirect;
 	}
 	ptr -= 1 << (uspi->s_apbshift + uspi->s_fpbshift);
 	if (depth == 3) {
-		bh = GET_INODE_PTR(UFS_DIND_FRAGMENT + (ptr >> uspi->s_2apbshift));
+		bh = ufs_inode_getfrag(inode,
+					UFS_DIND_FRAGMENT + (ptr >> uspi->s_2apbshift),
+					fragment, uspi->s_fpb, &err, NULL, NULL,
+					bh_result->b_page);
 		goto get_double;
 	}
 	ptr -= 1 << (uspi->s_2apbshift + uspi->s_fpbshift);
-	bh = GET_INODE_PTR(UFS_TIND_FRAGMENT + (ptr >> uspi->s_3apbshift));
-	bh = GET_INDIRECT_PTR((ptr >> uspi->s_2apbshift) & uspi->s_apbmask);
+	bh = ufs_inode_getfrag(inode,
+				UFS_TIND_FRAGMENT + (ptr >> uspi->s_3apbshift),
+				fragment, uspi->s_fpb, &err, NULL, NULL,
+				bh_result->b_page);
+	bh = ufs_inode_getblock(inode, bh,
+				(ptr >> uspi->s_2apbshift) & uspi->s_apbmask,
+				fragment, &err, NULL, NULL, NULL);
 get_double:
-	bh = GET_INDIRECT_PTR((ptr >> uspi->s_apbshift) & uspi->s_apbmask);
+	bh = ufs_inode_getblock(inode, bh,
+				(ptr >> uspi->s_apbshift) & uspi->s_apbmask,
+				fragment, &err, NULL, NULL, NULL);
 get_indirect:
-	bh = GET_INDIRECT_DATABLOCK(ptr & uspi->s_apbmask);
-
-#undef GET_INODE_DATABLOCK
-#undef GET_INODE_PTR
-#undef GET_INDIRECT_DATABLOCK
-#undef GET_INDIRECT_PTR
+	bh = ufs_inode_getblock(inode, bh, ptr & uspi->s_apbmask, fragment,
+			  &err, &phys, &new, bh_result->b_page);
 
 out:
 	if (err)

commit bbb3eb9d3432ce55a620778ecf5670fa7942090e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 19 00:10:00 2015 -0400

    ufs_inode_get{frag,block}(): consolidate success exits
    
    These calling conventions are rudiments of pre-2.3 times; they
    really need to be sanitized.  This is the first step; next
    will be _always_ returning a block number, instead of this
    "return a pointer to buffer_head, except when we get to the
    actual data" crap.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 5c4a4abae652..d65a89030c91 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -226,7 +226,6 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
-	struct buffer_head * result;
 	unsigned blockoff, lastblockoff;
 	u64 tmp, goal, lastfrag, block, lastblock;
 	void *p, *p2;
@@ -249,14 +248,8 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 	tmp = ufs_data_ptr_to_cpu(sb, p);
 
 	lastfrag = ufsi->i_lastfrag;
-	if (tmp && fragment < lastfrag) {
-		if (!phys) {
-			return sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
-		} else {
-			*phys = uspi->s_sbbase + tmp + blockoff;
-			return NULL;
-		}
-	}
+	if (tmp && fragment < lastfrag)
+		goto out;
 
 	lastblock = ufs_fragstoblks (lastfrag);
 	lastblockoff = ufs_fragnum (lastfrag);
@@ -314,20 +307,22 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 		return NULL;
 	}
 
-	if (!phys) {
-		result = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
-	} else {
-		*phys = uspi->s_sbbase + tmp + blockoff;
-		result = NULL;
+	if (phys) {
 		*err = 0;
 		*new = 1;
 	}
-
 	inode->i_ctime = CURRENT_TIME_SEC;
 	if (IS_SYNC(inode))
 		ufs_sync_inode (inode);
 	mark_inode_dirty(inode);
-	return result;
+out:
+	tmp += uspi->s_sbbase + blockoff;
+	if (!phys) {
+		return sb_getblk(sb, tmp);
+	} else {
+		*phys = tmp;
+		return NULL;
+	}
 
      /* This part : To be implemented ....
         Required only for writing, not required for READ-ONLY.
@@ -367,7 +362,7 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
 	struct buffer_head * result;
 	unsigned blockoff;
-	u64 tmp, goal, block;
+	u64 tmp = 0, goal, block;
 	void *p;
 
 	block = ufs_fragstoblks (fragment);
@@ -392,13 +387,8 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 		p = (__fs32 *)bh->b_data + block;
 
 	tmp = ufs_data_ptr_to_cpu(sb, p);
-	if (tmp) {
-		if (!phys)
-			result = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
-		else
-			*phys = uspi->s_sbbase + tmp + blockoff;
+	if (tmp)
 		goto out;
-	}
 
 	if (block && (uspi->fs_magic == UFS2_MAGIC ?
 		      (tmp = fs64_to_cpu(sb, ((__fs64 *)bh->b_data)[block-1])) :
@@ -411,12 +401,8 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 	if (!tmp)
 		goto out;
 
-	if (!phys) {
-		result = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
-	} else {
-		*phys = uspi->s_sbbase + tmp + blockoff;
+	if (new)
 		*new = 1;
-	}
 
 	mark_buffer_dirty(bh);
 	if (IS_SYNC(inode))
@@ -425,6 +411,14 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 	mark_inode_dirty(inode);
 out:
 	brelse (bh);
+	if (tmp) {
+		tmp += uspi->s_sbbase + blockoff;
+		if (phys) {
+			*phys = tmp;
+		} else {
+			result = sb_getblk(sb, tmp);
+		}
+	}
 	UFSD("EXIT\n");
 	return result;
 }

commit 71dd42846ffb2bd1a90e9ac2c52df0cc2ed92307
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 4 14:34:43 2015 -0400

    ufs: use the branch depth in ufs_getfrag_block()
    
    we'd already calculated it...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 0f0c6dfccd10..5c4a4abae652 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -465,9 +465,7 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 	mutex_lock(&UFS_I(inode)->truncate_mutex);
 
 	UFSD("ENTER, ino %lu, fragment %llu\n", inode->i_ino, (unsigned long long)fragment);
-	if (fragment >
-	    ((UFS_NDADDR + uspi->s_apb + uspi->s_2apb + uspi->s_3apb)
-	     << uspi->s_fpbshift))
+	if (!depth)
 		goto abort_too_big;
 
 	err = 0;
@@ -490,17 +488,17 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 	ufs_inode_getblock(inode, bh, x, fragment,	\
 			  &err, NULL, NULL, NULL)
 
-	if (ptr < UFS_NDIR_FRAGMENT) {
+	if (depth == 1) {
 		bh = GET_INODE_DATABLOCK(ptr);
 		goto out;
 	}
 	ptr -= UFS_NDIR_FRAGMENT;
-	if (ptr < (1 << (uspi->s_apbshift + uspi->s_fpbshift))) {
+	if (depth == 2) {
 		bh = GET_INODE_PTR(UFS_IND_FRAGMENT + (ptr >> uspi->s_apbshift));
 		goto get_indirect;
 	}
 	ptr -= 1 << (uspi->s_apbshift + uspi->s_fpbshift);
-	if (ptr < (1 << (uspi->s_2apbshift + uspi->s_fpbshift))) {
+	if (depth == 3) {
 		bh = GET_INODE_PTR(UFS_DIND_FRAGMENT + (ptr >> uspi->s_2apbshift));
 		goto get_double;
 	}

commit 4b7068c8b178401637ef2fb068d6256c97d23f4a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 4 14:27:23 2015 -0400

    ufs: move calculation of offsets into ufs_getfrag_block()
    
    ... and massage ufs_frag_map() to take those instead of fragment number.
    
    As it is, we duplicate the damn thing on the write side, open-coded and
    bloody hard to follow.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 95cb0a8f5ec9..0f0c6dfccd10 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -119,20 +119,18 @@ static inline int grow_chain64(struct ufs_inode_info *ufsi,
  * the beginning of the filesystem.
  */
 
-static u64 ufs_frag_map(struct inode *inode, sector_t frag)
+static u64 ufs_frag_map(struct inode *inode, unsigned offsets[4], int depth)
 {
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
 	u64 mask = (u64) uspi->s_apbmask>>uspi->s_fpbshift;
 	int shift = uspi->s_apbshift-uspi->s_fpbshift;
-	unsigned offsets[4], *p;
 	Indirect chain[4], *q = chain;
-	int depth = ufs_block_to_path(inode, frag >> uspi->s_fpbshift, offsets);
+	unsigned *p;
 	unsigned flags = UFS_SB(sb)->s_flags;
 	u64 res = 0;
 
-	UFSD(": frag = %llu  depth = %d\n", (unsigned long long)frag, depth);
 	UFSD(": uspi->s_fpbshift = %d ,uspi->s_apbmask = %x, mask=%llx\n",
 		uspi->s_fpbshift, uspi->s_apbmask,
 		(unsigned long long)mask);
@@ -191,7 +189,7 @@ static u64 ufs_frag_map(struct inode *inode, sector_t frag)
 	}
 	res = fs64_to_cpu(sb, q->key64);
 found:
-	res += uspi->s_sbbase + (frag & uspi->s_fpbmask);
+	res += uspi->s_sbbase;
 no_block:
 	while (q > chain) {
 		brelse(q->bh);
@@ -443,14 +441,17 @@ static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buff
 	struct ufs_sb_private_info * uspi = sbi->s_uspi;
 	struct buffer_head * bh;
 	int ret, err, new;
+	unsigned offsets[4];
+	int depth = ufs_block_to_path(inode, fragment >> uspi->s_fpbshift, offsets);
 	unsigned long ptr,phys;
 	u64 phys64 = 0;
 
 	if (!create) {
-		phys64 = ufs_frag_map(inode, fragment);
-		UFSD("phys64 = %llu\n", (unsigned long long)phys64);
-		if (phys64)
+		phys64 = ufs_frag_map(inode, offsets, depth);
+		if (phys64) {
+			phys64 += fragment & uspi->s_fpbmask;
 			map_bh(bh_result, sb, phys64);
+		}
 		return 0;
 	}
 

commit 5a39c25562aa5eab5a798919855cf41ddeed8b0d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 22:39:46 2015 -0400

    ufs_inode_get{frag,block}(): get rid of retries
    
    We are holding ->truncate_mutex, so nobody else can alter our
    block pointers.  Rechecks/retries were needed back when we
    only held BKL there, and had to cope with write_begin/writepage
    and writepage/truncate races.  Can't happen anymore...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 86cc1eea0fb2..95cb0a8f5ec9 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -248,20 +248,12 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 
 	goal = 0;
 
-repeat:
 	tmp = ufs_data_ptr_to_cpu(sb, p);
 
 	lastfrag = ufsi->i_lastfrag;
 	if (tmp && fragment < lastfrag) {
 		if (!phys) {
-			result = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
-			if (tmp == ufs_data_ptr_to_cpu(sb, p)) {
-				UFSD("EXIT, result %llu\n",
-				     (unsigned long long)tmp + blockoff);
-				return result;
-			}
-			brelse (result);
-			goto repeat;
+			return sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
 		} else {
 			*phys = uspi->s_sbbase + tmp + blockoff;
 			return NULL;
@@ -283,14 +275,9 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 						ufs_data_ptr_to_cpu(sb, p2),
 						uspi->s_fpb - lastblockoff,
 						err, locked_page);
-			if (!tmp) {
-				if (lastfrag != ufsi->i_lastfrag)
-					goto repeat;
-				else
-					return NULL;
-			}
+			if (!tmp)
+				return NULL;
 			lastfrag = ufsi->i_lastfrag;
-
 		}
 		tmp = ufs_data_ptr_to_cpu(sb,
 					 ufs_get_direct_data_ptr(uspi, ufsi,
@@ -325,9 +312,6 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 					phys != NULL ? locked_page : NULL);
 	}
 	if (!tmp) {
-		if ((!blockoff && ufs_data_ptr_to_cpu(sb, p)) ||
-		    (blockoff && lastfrag != ufsi->i_lastfrag))
-			goto repeat;
 		*err = -ENOSPC;
 		return NULL;
 	}
@@ -345,7 +329,6 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 	if (IS_SYNC(inode))
 		ufs_sync_inode (inode);
 	mark_inode_dirty(inode);
-	UFSD("EXIT, result %llu\n", (unsigned long long)tmp + blockoff);
 	return result;
 
      /* This part : To be implemented ....
@@ -409,19 +392,14 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 		p = (__fs64 *)bh->b_data + block;
 	else
 		p = (__fs32 *)bh->b_data + block;
-repeat:
+
 	tmp = ufs_data_ptr_to_cpu(sb, p);
 	if (tmp) {
-		if (!phys) {
+		if (!phys)
 			result = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
-			if (tmp == ufs_data_ptr_to_cpu(sb, p))
-				goto out;
-			brelse (result);
-			goto repeat;
-		} else {
+		else
 			*phys = uspi->s_sbbase + tmp + blockoff;
-			goto out;
-		}
+		goto out;
 	}
 
 	if (block && (uspi->fs_magic == UFS2_MAGIC ?
@@ -432,12 +410,8 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 		goal = bh->b_blocknr + uspi->s_fpb;
 	tmp = ufs_new_fragments(inode, p, ufs_blknum(new_fragment), goal,
 				uspi->s_fpb, err, locked_page);
-	if (!tmp) {
-		if (ufs_data_ptr_to_cpu(sb, p))
-			goto repeat;
+	if (!tmp)
 		goto out;
-	}
-
 
 	if (!phys) {
 		result = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
@@ -451,7 +425,6 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 		sync_dirty_buffer(bh);
 	inode->i_ctime = CURRENT_TIME_SEC;
 	mark_inode_dirty(inode);
-	UFSD("result %llu\n", (unsigned long long)tmp + blockoff);
 out:
 	brelse (bh);
 	UFSD("EXIT\n");

commit f53bd1421b3eb84375e9e6964665d23d4190400d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 20:17:32 2015 -0400

    __ufs_truncate_blocks(): avoid excessive dirtying of indirect blocks
    
    There's a case when an indirect block gets dirtied for no good
    reason - when there's a hole starting in the middle of area
    covered by it and spanning past its end, and truncate() is done
    precisely to the beginning of the hole.
    
    The block is obviously not modified at all - all removals happen
    beyond it.  However, existing code ends up dirtying it just in
    case.  It's trivial to fix and while it's not a real bug by any
    stretch of imagination, it makes the damn thing harder to follow.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 424949f459c8..86cc1eea0fb2 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1251,10 +1251,8 @@ static void __ufs_truncate_blocks(struct inode *inode)
 			}
 			p = ubh_get_data_ptr(uspi, ubh[i], offsets[i + 1]);
 		}
-		while (i--) {
-			ubh_mark_buffer_dirty(ubh[i]);
+		while (i--)
 			free_branch_tail(inode, offsets[i + 1], ubh[i], depth - i - 1);
-		}
 	}
 	for (i = offsets[0]; i <= UFS_TIND_BLOCK; i++) {
 		p = ufs_get_direct_data_ptr(uspi, ufsi, i);

commit cc7231e30916f5326bdde55a7a4c59431e15bc1b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 20:14:02 2015 -0400

    free_full_branch(): don't bother modifying the block we are going to free
    
    Note that it's already made unreachable from the inode, so we don't have
    to worry about ufs_frag_map() walking into something already freed.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 26835a80f7dd..424949f459c8 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1081,13 +1081,8 @@ static void free_full_branch(struct inode *inode, u64 ind_block, int depth)
 		for (i = 0; i < uspi->s_apb; i++) {
 			void *p = ubh_get_data_ptr(uspi, ubh, i);
 			u64 block = ufs_data_ptr_to_cpu(sb, p);
-			if (block) {
-				write_seqlock(&UFS_I(inode)->meta_lock);
-				ufs_data_ptr_clear(uspi, p);
-				write_sequnlock(&UFS_I(inode)->meta_lock);
+			if (block)
 				free_full_branch(inode, block, depth);
-				ubh_mark_buffer_dirty(ubh);
-			}
 		}
 	} else {
 		struct to_free ctx = {.inode = inode};
@@ -1095,13 +1090,8 @@ static void free_full_branch(struct inode *inode, u64 ind_block, int depth)
 		for (i = 0; i < uspi->s_apb; i++) {
 			void *p = ubh_get_data_ptr(uspi, ubh, i);
 			u64 block = ufs_data_ptr_to_cpu(sb, p);
-			if (block) {
-				write_seqlock(&UFS_I(inode)->meta_lock);
-				ufs_data_ptr_clear(uspi, p);
-				write_sequnlock(&UFS_I(inode)->meta_lock);
-				ubh_mark_buffer_dirty(ubh);
+			if (block)
 				free_data(&ctx, block, uspi->s_fpb);
-			}
 		}
 		free_data(&ctx, 0, 0);
 	}

commit b6eede0ec642d1be17065110718cb4f4ed7ba5e0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 20:09:39 2015 -0400

    move marking inode dirty to the end of __ufs_truncate_blocks()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index efe71e5acb00..26835a80f7dd 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1027,7 +1027,6 @@ static void ufs_trunc_direct(struct inode *inode)
 	frag1 = ufs_fragnum (frag1);
 
 	ufs_free_fragments(inode, tmp + frag1, frag2);
-	mark_inode_dirty(inode);
 
 next1:
 	/*
@@ -1043,7 +1042,6 @@ static void ufs_trunc_direct(struct inode *inode)
 		write_sequnlock(&ufsi->meta_lock);
 
 		free_data(&ctx, tmp, uspi->s_fpb);
-		mark_inode_dirty(inode);
 	}
 
 	free_data(&ctx, 0, 0);
@@ -1064,7 +1062,6 @@ static void ufs_trunc_direct(struct inode *inode)
 	write_sequnlock(&ufsi->meta_lock);
 
 	ufs_free_fragments (inode, tmp, frag4);
-	mark_inode_dirty(inode);
  next3:
 
 	UFSD("EXIT: ino %lu\n", inode->i_ino);
@@ -1104,7 +1101,6 @@ static void free_full_branch(struct inode *inode, u64 ind_block, int depth)
 				write_sequnlock(&UFS_I(inode)->meta_lock);
 				ubh_mark_buffer_dirty(ubh);
 				free_data(&ctx, block, uspi->s_fpb);
-				mark_inode_dirty(inode);
 			}
 		}
 		free_data(&ctx, 0, 0);
@@ -1112,7 +1108,6 @@ static void free_full_branch(struct inode *inode, u64 ind_block, int depth)
 
 	ubh_bforget(ubh);
 	ufs_free_blocks(inode, ind_block, uspi->s_fpb);
-	mark_inode_dirty(inode);
 }
 
 static void free_branch_tail(struct inode *inode, unsigned from, struct ufs_buffer_head *ubh, int depth)
@@ -1145,7 +1140,6 @@ static void free_branch_tail(struct inode *inode, unsigned from, struct ufs_buff
 				write_sequnlock(&UFS_I(inode)->meta_lock);
 				ubh_mark_buffer_dirty(ubh);
 				free_data(&ctx, block, uspi->s_fpb);
-				mark_inode_dirty(inode);
 			}
 		}
 		free_data(&ctx, 0, 0);
@@ -1283,6 +1277,7 @@ static void __ufs_truncate_blocks(struct inode *inode)
 		}
 	}
 	ufsi->i_lastfrag = DIRECT_FRAGMENT;
+	mark_inode_dirty(inode);
 	mutex_unlock(&ufsi->truncate_mutex);
 }
 

commit 163073db51930d1f9c2960b8e5660c269164f29b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 20:07:08 2015 -0400

    free_full_branch(): saner calling conventions
    
    Have caller fetch the block number *and* remove it from wherever
    it was.  Pass the block number instead.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 314caad56d83..efe71e5acb00 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1070,57 +1070,48 @@ static void ufs_trunc_direct(struct inode *inode)
 	UFSD("EXIT: ino %lu\n", inode->i_ino);
 }
 
-static void free_full_branch(struct inode *inode, int depth, void *p)
+static void free_full_branch(struct inode *inode, u64 ind_block, int depth)
 {
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
-	struct ufs_inode_info *ufsi = UFS_I(inode);
-	struct ufs_buffer_head *ubh;
-	u64 tmp;
+	struct ufs_buffer_head *ubh = ubh_bread(sb, ind_block, uspi->s_bsize);
 	unsigned i;
 
-	tmp = ufs_data_ptr_to_cpu(sb, p);
-	if (!tmp)
-		return;
-	ubh = ubh_bread (sb, tmp, uspi->s_bsize);
-	if (!ubh) {
-		write_seqlock(&ufsi->meta_lock);
-		ufs_data_ptr_clear(uspi, p);
-		write_sequnlock(&ufsi->meta_lock);
+	if (!ubh)
 		return;
-	}
 
 	if (--depth) {
-		for (i = 0 ; i < uspi->s_apb ; i++) {
-			void *ind = ubh_get_data_ptr(uspi, ubh, i);
-			free_full_branch(inode, depth, ind);
-			ubh_mark_buffer_dirty(ubh);
+		for (i = 0; i < uspi->s_apb; i++) {
+			void *p = ubh_get_data_ptr(uspi, ubh, i);
+			u64 block = ufs_data_ptr_to_cpu(sb, p);
+			if (block) {
+				write_seqlock(&UFS_I(inode)->meta_lock);
+				ufs_data_ptr_clear(uspi, p);
+				write_sequnlock(&UFS_I(inode)->meta_lock);
+				free_full_branch(inode, block, depth);
+				ubh_mark_buffer_dirty(ubh);
+			}
 		}
 	} else {
 		struct to_free ctx = {.inode = inode};
 
 		for (i = 0; i < uspi->s_apb; i++) {
-			void *ind = ubh_get_data_ptr(uspi, ubh, i);
-			tmp = ufs_data_ptr_to_cpu(sb, ind);
-			if (!tmp)
-				continue;
-
-			write_seqlock(&UFS_I(inode)->meta_lock);
-			ufs_data_ptr_clear(uspi, ind);
-			write_sequnlock(&UFS_I(inode)->meta_lock);
-			ubh_mark_buffer_dirty(ubh);
-			free_data(&ctx, tmp, uspi->s_fpb);
-			mark_inode_dirty(inode);
+			void *p = ubh_get_data_ptr(uspi, ubh, i);
+			u64 block = ufs_data_ptr_to_cpu(sb, p);
+			if (block) {
+				write_seqlock(&UFS_I(inode)->meta_lock);
+				ufs_data_ptr_clear(uspi, p);
+				write_sequnlock(&UFS_I(inode)->meta_lock);
+				ubh_mark_buffer_dirty(ubh);
+				free_data(&ctx, block, uspi->s_fpb);
+				mark_inode_dirty(inode);
+			}
 		}
 		free_data(&ctx, 0, 0);
 	}
-	tmp = ufs_data_ptr_to_cpu(sb, p);
-	write_seqlock(&ufsi->meta_lock);
-	ufs_data_ptr_clear(uspi, p);
-	write_sequnlock(&ufsi->meta_lock);
 
 	ubh_bforget(ubh);
-	ufs_free_blocks(inode, tmp, uspi->s_fpb);
+	ufs_free_blocks(inode, ind_block, uspi->s_fpb);
 	mark_inode_dirty(inode);
 }
 
@@ -1132,25 +1123,30 @@ static void free_branch_tail(struct inode *inode, unsigned from, struct ufs_buff
 
 	if (--depth) {
 		for (i = from; i < uspi->s_apb ; i++) {
-			void *ind = ubh_get_data_ptr(uspi, ubh, i);
-			free_full_branch(inode, depth, ind);
-			ubh_mark_buffer_dirty(ubh);
+			void *p = ubh_get_data_ptr(uspi, ubh, i);
+			u64 block = ufs_data_ptr_to_cpu(sb, p);
+			if (block) {
+				write_seqlock(&UFS_I(inode)->meta_lock);
+				ufs_data_ptr_clear(uspi, p);
+				write_sequnlock(&UFS_I(inode)->meta_lock);
+				ubh_mark_buffer_dirty(ubh);
+				free_full_branch(inode, block, depth);
+			}
 		}
 	} else {
 		struct to_free ctx = {.inode = inode};
 
 		for (i = from; i < uspi->s_apb; i++) {
-			void *ind = ubh_get_data_ptr(uspi, ubh, i);
-			u64 tmp = ufs_data_ptr_to_cpu(sb, ind);
-			if (!tmp)
-				continue;
-
-			write_seqlock(&UFS_I(inode)->meta_lock);
-			ufs_data_ptr_clear(uspi, ind);
-			write_sequnlock(&UFS_I(inode)->meta_lock);
-			ubh_mark_buffer_dirty(ubh);
-			free_data(&ctx, tmp, uspi->s_fpb);
-			mark_inode_dirty(inode);
+			void *p = ubh_get_data_ptr(uspi, ubh, i);
+			u64 block = ufs_data_ptr_to_cpu(sb, p);
+			if (block) {
+				write_seqlock(&UFS_I(inode)->meta_lock);
+				ufs_data_ptr_clear(uspi, p);
+				write_sequnlock(&UFS_I(inode)->meta_lock);
+				ubh_mark_buffer_dirty(ubh);
+				free_data(&ctx, block, uspi->s_fpb);
+				mark_inode_dirty(inode);
+			}
 		}
 		free_data(&ctx, 0, 0);
 	}
@@ -1277,8 +1273,14 @@ static void __ufs_truncate_blocks(struct inode *inode)
 		}
 	}
 	for (i = offsets[0]; i <= UFS_TIND_BLOCK; i++) {
-		free_full_branch(inode, i - UFS_IND_BLOCK + 1,
-			   ufs_get_direct_data_ptr(uspi, ufsi, i));
+		p = ufs_get_direct_data_ptr(uspi, ufsi, i);
+		block = ufs_data_ptr_to_cpu(sb, p);
+		if (block) {
+			write_seqlock(&ufsi->meta_lock);
+			ufs_data_ptr_clear(uspi, p);
+			write_sequnlock(&ufsi->meta_lock);
+			free_full_branch(inode, block, i - UFS_IND_BLOCK + 1);
+		}
 	}
 	ufsi->i_lastfrag = DIRECT_FRAGMENT;
 	mutex_unlock(&ufsi->truncate_mutex);

commit 7b4e4f7f815db0059150a12542b28c787e19c0d7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 19:13:02 2015 -0400

    ufs_trunc_branch(): kill recursion
    
    turn recursion into a pair of loops
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index dac81c318da7..314caad56d83 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1124,34 +1124,14 @@ static void free_full_branch(struct inode *inode, int depth, void *p)
 	mark_inode_dirty(inode);
 }
 
-static void ufs_trunc_branch(struct inode *inode, unsigned *offsets, int depth2, int depth, void *p)
+static void free_branch_tail(struct inode *inode, unsigned from, struct ufs_buffer_head *ubh, int depth)
 {
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
-	struct ufs_inode_info *ufsi = UFS_I(inode);
-	struct ufs_buffer_head *ubh;
-	u64 tmp;
-	unsigned from = *offsets++;
 	unsigned i;
 
-	tmp = ufs_data_ptr_to_cpu(sb, p);
-	if (!tmp)
-		return;
-	ubh = ubh_bread (sb, tmp, uspi->s_bsize);
-	if (!ubh) {
-		write_seqlock(&ufsi->meta_lock);
-		ufs_data_ptr_clear(uspi, p);
-		write_sequnlock(&ufsi->meta_lock);
-		return;
-	}
-
-	if (--depth2) {
-		void *ind = ubh_get_data_ptr(uspi, ubh, from++);
-		ufs_trunc_branch(inode, offsets, depth2, depth - 1, ind);
-		ubh_mark_buffer_dirty(ubh);
-	}
 	if (--depth) {
-		for (i = from ; i < uspi->s_apb ; i++) {
+		for (i = from; i < uspi->s_apb ; i++) {
 			void *ind = ubh_get_data_ptr(uspi, ubh, i);
 			free_full_branch(inode, depth, ind);
 			ubh_mark_buffer_dirty(ubh);
@@ -1161,7 +1141,7 @@ static void ufs_trunc_branch(struct inode *inode, unsigned *offsets, int depth2,
 
 		for (i = from; i < uspi->s_apb; i++) {
 			void *ind = ubh_get_data_ptr(uspi, ubh, i);
-			tmp = ufs_data_ptr_to_cpu(sb, ind);
+			u64 tmp = ufs_data_ptr_to_cpu(sb, ind);
 			if (!tmp)
 				continue;
 
@@ -1258,6 +1238,9 @@ static void __ufs_truncate_blocks(struct inode *inode)
 	int depth = ufs_block_to_path(inode, DIRECT_BLOCK, offsets);
 	int depth2;
 	unsigned i;
+	struct ufs_buffer_head *ubh[3];
+	void *p;
+	u64 block;
 
 	if (!depth)
 		return;
@@ -1272,9 +1255,26 @@ static void __ufs_truncate_blocks(struct inode *inode)
 		ufs_trunc_direct(inode);
 		offsets[0] = UFS_IND_BLOCK;
 	} else {
-		if (depth2)
-			ufs_trunc_branch(inode, offsets + 1, depth2, depth - 1,
-			   ufs_get_direct_data_ptr(uspi, ufsi, offsets[0]++));
+		/* get the blocks that should be partially emptied */
+		p = ufs_get_direct_data_ptr(uspi, ufsi, offsets[0]);
+		for (i = 0; i < depth2; i++) {
+			offsets[i]++;	/* next branch is fully freed */
+			block = ufs_data_ptr_to_cpu(sb, p);
+			if (!block)
+				break;
+			ubh[i] = ubh_bread(sb, block, uspi->s_bsize);
+			if (!ubh[i]) {
+				write_seqlock(&ufsi->meta_lock);
+				ufs_data_ptr_clear(uspi, p);
+				write_sequnlock(&ufsi->meta_lock);
+				break;
+			}
+			p = ubh_get_data_ptr(uspi, ubh[i], offsets[i + 1]);
+		}
+		while (i--) {
+			ubh_mark_buffer_dirty(ubh[i]);
+			free_branch_tail(inode, offsets[i + 1], ubh[i], depth - i - 1);
+		}
 	}
 	for (i = offsets[0]; i <= UFS_TIND_BLOCK; i++) {
 		free_full_branch(inode, i - UFS_IND_BLOCK + 1,

commit 6aab6dd37946d0d592105872bd533bb7d2931f3f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 17:23:34 2015 -0400

    ufs_trunc_branch(): massage towards killing recursion
    
    We always have 0 < depth2 <= depth in there, so
    if (--depth) {
            if (--depth2)
                    A
            B
    } else {
            C // not using depth2
    }
    D // not using depth2
    
    is equivalent to
    
    if (--depth2)
            A with s/depth/depth - 1/
    if (--depth)
            B
    else
            C
    D
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index c06556558c9b..dac81c318da7 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1145,12 +1145,12 @@ static void ufs_trunc_branch(struct inode *inode, unsigned *offsets, int depth2,
 		return;
 	}
 
+	if (--depth2) {
+		void *ind = ubh_get_data_ptr(uspi, ubh, from++);
+		ufs_trunc_branch(inode, offsets, depth2, depth - 1, ind);
+		ubh_mark_buffer_dirty(ubh);
+	}
 	if (--depth) {
-		if (--depth2) {
-			void *ind = ubh_get_data_ptr(uspi, ubh, from++);
-			ufs_trunc_branch(inode, offsets, depth2, depth, ind);
-			ubh_mark_buffer_dirty(ubh);
-		}
 		for (i = from ; i < uspi->s_apb ; i++) {
 			void *ind = ubh_get_data_ptr(uspi, ubh, i);
 			free_full_branch(inode, depth, ind);

commit 6d1ebbca2b2fe516ff5f279848cffbd23d2b0270
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 17:11:49 2015 -0400

    split ufs_truncate_branch() into full- and partial-branch variants
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 39de7782b7c5..c06556558c9b 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1070,6 +1070,60 @@ static void ufs_trunc_direct(struct inode *inode)
 	UFSD("EXIT: ino %lu\n", inode->i_ino);
 }
 
+static void free_full_branch(struct inode *inode, int depth, void *p)
+{
+	struct super_block *sb = inode->i_sb;
+	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
+	struct ufs_inode_info *ufsi = UFS_I(inode);
+	struct ufs_buffer_head *ubh;
+	u64 tmp;
+	unsigned i;
+
+	tmp = ufs_data_ptr_to_cpu(sb, p);
+	if (!tmp)
+		return;
+	ubh = ubh_bread (sb, tmp, uspi->s_bsize);
+	if (!ubh) {
+		write_seqlock(&ufsi->meta_lock);
+		ufs_data_ptr_clear(uspi, p);
+		write_sequnlock(&ufsi->meta_lock);
+		return;
+	}
+
+	if (--depth) {
+		for (i = 0 ; i < uspi->s_apb ; i++) {
+			void *ind = ubh_get_data_ptr(uspi, ubh, i);
+			free_full_branch(inode, depth, ind);
+			ubh_mark_buffer_dirty(ubh);
+		}
+	} else {
+		struct to_free ctx = {.inode = inode};
+
+		for (i = 0; i < uspi->s_apb; i++) {
+			void *ind = ubh_get_data_ptr(uspi, ubh, i);
+			tmp = ufs_data_ptr_to_cpu(sb, ind);
+			if (!tmp)
+				continue;
+
+			write_seqlock(&UFS_I(inode)->meta_lock);
+			ufs_data_ptr_clear(uspi, ind);
+			write_sequnlock(&UFS_I(inode)->meta_lock);
+			ubh_mark_buffer_dirty(ubh);
+			free_data(&ctx, tmp, uspi->s_fpb);
+			mark_inode_dirty(inode);
+		}
+		free_data(&ctx, 0, 0);
+	}
+	tmp = ufs_data_ptr_to_cpu(sb, p);
+	write_seqlock(&ufsi->meta_lock);
+	ufs_data_ptr_clear(uspi, p);
+	write_sequnlock(&ufsi->meta_lock);
+
+	ubh_bforget(ubh);
+	ufs_free_blocks(inode, tmp, uspi->s_fpb);
+	mark_inode_dirty(inode);
+}
+
 static void ufs_trunc_branch(struct inode *inode, unsigned *offsets, int depth2, int depth, void *p)
 {
 	struct super_block *sb = inode->i_sb;
@@ -1077,8 +1131,7 @@ static void ufs_trunc_branch(struct inode *inode, unsigned *offsets, int depth2,
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct ufs_buffer_head *ubh;
 	u64 tmp;
-	bool free_it = !offsets;
-	unsigned from = offsets ? *offsets++ : 0;
+	unsigned from = *offsets++;
 	unsigned i;
 
 	tmp = ufs_data_ptr_to_cpu(sb, p);
@@ -1093,14 +1146,14 @@ static void ufs_trunc_branch(struct inode *inode, unsigned *offsets, int depth2,
 	}
 
 	if (--depth) {
-		if (offsets && --depth2) {
+		if (--depth2) {
 			void *ind = ubh_get_data_ptr(uspi, ubh, from++);
 			ufs_trunc_branch(inode, offsets, depth2, depth, ind);
 			ubh_mark_buffer_dirty(ubh);
 		}
 		for (i = from ; i < uspi->s_apb ; i++) {
 			void *ind = ubh_get_data_ptr(uspi, ubh, i);
-			ufs_trunc_branch(inode, NULL, 0, depth, ind);
+			free_full_branch(inode, depth, ind);
 			ubh_mark_buffer_dirty(ubh);
 		}
 	} else {
@@ -1121,17 +1174,6 @@ static void ufs_trunc_branch(struct inode *inode, unsigned *offsets, int depth2,
 		}
 		free_data(&ctx, 0, 0);
 	}
-	if (free_it) {
-		tmp = ufs_data_ptr_to_cpu(sb, p);
-		write_seqlock(&ufsi->meta_lock);
-		ufs_data_ptr_clear(uspi, p);
-		write_sequnlock(&ufsi->meta_lock);
-
-		ubh_bforget(ubh);
-		ufs_free_blocks(inode, tmp, uspi->s_fpb);
-		mark_inode_dirty(inode);
-		return;
-	}
 	if (IS_SYNC(inode) && ubh_buffer_dirty(ubh))
 		ubh_sync_block(ubh);
 	ubh_brelse(ubh);
@@ -1235,7 +1277,7 @@ static void __ufs_truncate_blocks(struct inode *inode)
 			   ufs_get_direct_data_ptr(uspi, ufsi, offsets[0]++));
 	}
 	for (i = offsets[0]; i <= UFS_TIND_BLOCK; i++) {
-		ufs_trunc_branch(inode, NULL, 0, i - UFS_IND_BLOCK + 1,
+		free_full_branch(inode, i - UFS_IND_BLOCK + 1,
 			   ufs_get_direct_data_ptr(uspi, ufsi, i));
 	}
 	ufsi->i_lastfrag = DIRECT_FRAGMENT;

commit a138b4b688c10eb82044451b81534c382d1cddbd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 02:18:54 2015 -0400

    ufs: unify the logics for collecting adjacent data blocks to free
    
    open-coded in several places...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 480c34ee1805..39de7782b7c5 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -960,6 +960,22 @@ void ufs_evict_inode(struct inode * inode)
 		ufs_free_inode(inode);
 }
 
+struct to_free {
+	struct inode *inode;
+	u64 to;
+	unsigned count;
+};
+
+static inline void free_data(struct to_free *ctx, u64 from, unsigned count)
+{
+	if (ctx->count && ctx->to != from) {
+		ufs_free_blocks(ctx->inode, ctx->to - ctx->count, ctx->count);
+		ctx->count = 0;
+	}
+	ctx->count += count;
+	ctx->to = from + count;
+}
+
 #define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)
 #define DIRECT_FRAGMENT ((inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift)
 
@@ -970,7 +986,7 @@ static void ufs_trunc_direct(struct inode *inode)
 	struct ufs_sb_private_info * uspi;
 	void *p;
 	u64 frag1, frag2, frag3, frag4, block1, block2;
-	unsigned frag_to_free, free_count;
+	struct to_free ctx = {.inode = inode};
 	unsigned i, tmp;
 
 	UFSD("ENTER: ino %lu\n", inode->i_ino);
@@ -978,9 +994,6 @@ static void ufs_trunc_direct(struct inode *inode)
 	sb = inode->i_sb;
 	uspi = UFS_SB(sb)->s_uspi;
 
-	frag_to_free = 0;
-	free_count = 0;
-
 	frag1 = DIRECT_FRAGMENT;
 	frag4 = min_t(u64, UFS_NDIR_FRAGMENT, ufsi->i_lastfrag);
 	frag2 = ((frag1 & uspi->s_fpbmask) ? ((frag1 | uspi->s_fpbmask) + 1) : frag1);
@@ -1015,7 +1028,6 @@ static void ufs_trunc_direct(struct inode *inode)
 
 	ufs_free_fragments(inode, tmp + frag1, frag2);
 	mark_inode_dirty(inode);
-	frag_to_free = tmp + frag1;
 
 next1:
 	/*
@@ -1030,21 +1042,11 @@ static void ufs_trunc_direct(struct inode *inode)
 		ufs_data_ptr_clear(uspi, p);
 		write_sequnlock(&ufsi->meta_lock);
 
-		if (free_count == 0) {
-			frag_to_free = tmp;
-			free_count = uspi->s_fpb;
-		} else if (free_count > 0 && frag_to_free == tmp - free_count)
-			free_count += uspi->s_fpb;
-		else {
-			ufs_free_blocks (inode, frag_to_free, free_count);
-			frag_to_free = tmp;
-			free_count = uspi->s_fpb;
-		}
+		free_data(&ctx, tmp, uspi->s_fpb);
 		mark_inode_dirty(inode);
 	}
 
-	if (free_count > 0)
-		ufs_free_blocks (inode, frag_to_free, free_count);
+	free_data(&ctx, 0, 0);
 
 	if (frag3 >= frag4)
 		goto next3;
@@ -1102,8 +1104,7 @@ static void ufs_trunc_branch(struct inode *inode, unsigned *offsets, int depth2,
 			ubh_mark_buffer_dirty(ubh);
 		}
 	} else {
-		u64 frag_to_free = 0;
-		unsigned free_count = 0;
+		struct to_free ctx = {.inode = inode};
 
 		for (i = from; i < uspi->s_apb; i++) {
 			void *ind = ubh_get_data_ptr(uspi, ubh, i);
@@ -1115,23 +1116,10 @@ static void ufs_trunc_branch(struct inode *inode, unsigned *offsets, int depth2,
 			ufs_data_ptr_clear(uspi, ind);
 			write_sequnlock(&UFS_I(inode)->meta_lock);
 			ubh_mark_buffer_dirty(ubh);
-			if (free_count == 0) {
-				frag_to_free = tmp;
-				free_count = uspi->s_fpb;
-			} else if (free_count > 0 && frag_to_free == tmp - free_count)
-				free_count += uspi->s_fpb;
-			else {
-				ufs_free_blocks (inode, frag_to_free, free_count);
-				frag_to_free = tmp;
-				free_count = uspi->s_fpb;
-			}
-
+			free_data(&ctx, tmp, uspi->s_fpb);
 			mark_inode_dirty(inode);
 		}
-
-		if (free_count > 0) {
-			ufs_free_blocks (inode, frag_to_free, free_count);
-		}
+		free_data(&ctx, 0, 0);
 	}
 	if (free_it) {
 		tmp = ufs_data_ptr_to_cpu(sb, p);

commit a96574233c5d2e50736d83abf65161ec5fa55852
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 16:13:56 2015 -0400

    ufs_trunc_branch(): separate the calls with non-NULL offsets
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 9e409c12afdf..480c34ee1805 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1091,13 +1091,16 @@ static void ufs_trunc_branch(struct inode *inode, unsigned *offsets, int depth2,
 	}
 
 	if (--depth) {
-		if (!--depth2)
-			offsets = NULL;
-		for (i = from ; i < uspi->s_apb ; i++, offsets = NULL) {
-			void *ind = ubh_get_data_ptr(uspi, ubh, i);
+		if (offsets && --depth2) {
+			void *ind = ubh_get_data_ptr(uspi, ubh, from++);
 			ufs_trunc_branch(inode, offsets, depth2, depth, ind);
 			ubh_mark_buffer_dirty(ubh);
 		}
+		for (i = from ; i < uspi->s_apb ; i++) {
+			void *ind = ubh_get_data_ptr(uspi, ubh, i);
+			ufs_trunc_branch(inode, NULL, 0, depth, ind);
+			ubh_mark_buffer_dirty(ubh);
+		}
 	} else {
 		u64 frag_to_free = 0;
 		unsigned free_count = 0;

commit 97e0f8f87c918620689ce542664a3115b752649d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 16:05:18 2015 -0400

    ufs_trunc_branch(): never call with offsets != NULL && depth2 == 0
    
    For calls in __ufs_truncate_blocks() it's just a matter of not
    incrementing offsets[0] and not making that call - immediately
    following loop will be executed one extra time and we'll be just
    fine.  For recursive call in ufs_trunc_branch() itself, just
    assing NULL to offsets if we would be about to make such call.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 285eacd02d60..9e409c12afdf 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1075,7 +1075,7 @@ static void ufs_trunc_branch(struct inode *inode, unsigned *offsets, int depth2,
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct ufs_buffer_head *ubh;
 	u64 tmp;
-	bool free_it = !offsets || !depth2;
+	bool free_it = !offsets;
 	unsigned from = offsets ? *offsets++ : 0;
 	unsigned i;
 
@@ -1091,9 +1091,11 @@ static void ufs_trunc_branch(struct inode *inode, unsigned *offsets, int depth2,
 	}
 
 	if (--depth) {
+		if (!--depth2)
+			offsets = NULL;
 		for (i = from ; i < uspi->s_apb ; i++, offsets = NULL) {
 			void *ind = ubh_get_data_ptr(uspi, ubh, i);
-			ufs_trunc_branch(inode, offsets, depth2 - 1, depth, ind);
+			ufs_trunc_branch(inode, offsets, depth2, depth, ind);
 			ubh_mark_buffer_dirty(ubh);
 		}
 	} else {
@@ -1237,7 +1239,8 @@ static void __ufs_truncate_blocks(struct inode *inode)
 		ufs_trunc_direct(inode);
 		offsets[0] = UFS_IND_BLOCK;
 	} else {
-		ufs_trunc_branch(inode, offsets + 1, depth2, depth - 1,
+		if (depth2)
+			ufs_trunc_branch(inode, offsets + 1, depth2, depth - 1,
 			   ufs_get_direct_data_ptr(uspi, ufsi, offsets[0]++));
 	}
 	for (i = offsets[0]; i <= UFS_TIND_BLOCK; i++) {

commit 42432739b5902f72011f701f5cd5b4227ebe991c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 15:47:17 2015 -0400

    __ufs_trunc_blocks(): turn the part after switch into a loop
    
    ... and turn the switch into if (), since all cases with
    depth != 1 have just become identical.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 1427d277a690..285eacd02d60 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1222,6 +1222,7 @@ static void __ufs_truncate_blocks(struct inode *inode)
 	unsigned offsets[4];
 	int depth = ufs_block_to_path(inode, DIRECT_BLOCK, offsets);
 	int depth2;
+	unsigned i;
 
 	if (!depth)
 		return;
@@ -1232,33 +1233,17 @@ static void __ufs_truncate_blocks(struct inode *inode)
 			break;
 
 	mutex_lock(&ufsi->truncate_mutex);
-	switch (depth) {
-	case 1:
+	if (depth == 1) {
 		ufs_trunc_direct(inode);
-		goto l1;
-	case 2:
-		ufs_trunc_branch(inode, offsets + 1, depth2, 1,
-			   ufs_get_direct_data_ptr(uspi, ufsi, UFS_IND_BLOCK));
-		goto l2;
-	case 3:
-		ufs_trunc_branch(inode, offsets + 1, depth2, 2,
-			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
-		goto l3;
-	case 4:
-		ufs_trunc_branch(inode, offsets + 1, depth2, 3,
-			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK));
-		goto l4;
+		offsets[0] = UFS_IND_BLOCK;
+	} else {
+		ufs_trunc_branch(inode, offsets + 1, depth2, depth - 1,
+			   ufs_get_direct_data_ptr(uspi, ufsi, offsets[0]++));
+	}
+	for (i = offsets[0]; i <= UFS_TIND_BLOCK; i++) {
+		ufs_trunc_branch(inode, NULL, 0, i - UFS_IND_BLOCK + 1,
+			   ufs_get_direct_data_ptr(uspi, ufsi, i));
 	}
-l1:
-	ufs_trunc_branch(inode, NULL, 0, 1,
-			   ufs_get_direct_data_ptr(uspi, ufsi, UFS_IND_BLOCK));
-l2:
-	ufs_trunc_branch(inode, NULL, 0, 2,
-			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
-l3:
-	ufs_trunc_branch(inode, NULL, 0, 3,
-			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK));
-l4:
 	ufsi->i_lastfrag = DIRECT_FRAGMENT;
 	mutex_unlock(&ufsi->truncate_mutex);
 }

commit ef3a315d4ca179fd0b56597e695cd262a8b559b7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 15:42:25 2015 -0400

    __ufs_truncate_blocks(): unify freeing the full branches
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 0d57c41b7705..1427d277a690 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1235,31 +1235,30 @@ static void __ufs_truncate_blocks(struct inode *inode)
 	switch (depth) {
 	case 1:
 		ufs_trunc_direct(inode);
-		ufs_trunc_branch(inode, NULL, 0, 1,
-			   ufs_get_direct_data_ptr(uspi, ufsi, UFS_IND_BLOCK));
-		ufs_trunc_branch(inode, NULL, 0, 2,
-			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
-		ufs_trunc_branch(inode, NULL, 0, 3,
-			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK));
-		break;
+		goto l1;
 	case 2:
 		ufs_trunc_branch(inode, offsets + 1, depth2, 1,
 			   ufs_get_direct_data_ptr(uspi, ufsi, UFS_IND_BLOCK));
-		ufs_trunc_branch(inode, NULL, 0, 2,
-			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
-		ufs_trunc_branch(inode, NULL, 0, 3,
-			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK));
-		break;
+		goto l2;
 	case 3:
 		ufs_trunc_branch(inode, offsets + 1, depth2, 2,
 			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
-		ufs_trunc_branch(inode, NULL, 0, 3,
-			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK));
-		break;
+		goto l3;
 	case 4:
 		ufs_trunc_branch(inode, offsets + 1, depth2, 3,
 			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK));
+		goto l4;
 	}
+l1:
+	ufs_trunc_branch(inode, NULL, 0, 1,
+			   ufs_get_direct_data_ptr(uspi, ufsi, UFS_IND_BLOCK));
+l2:
+	ufs_trunc_branch(inode, NULL, 0, 2,
+			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
+l3:
+	ufs_trunc_branch(inode, NULL, 0, 3,
+			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK));
+l4:
 	ufsi->i_lastfrag = DIRECT_FRAGMENT;
 	mutex_unlock(&ufsi->truncate_mutex);
 }

commit 9e0fbbde2724d5d3bb9edca6b77e26eb28341154
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 15:33:47 2015 -0400

    unify ufs_trunc_..indirect()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index e90266a221b8..0d57c41b7705 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1068,147 +1068,65 @@ static void ufs_trunc_direct(struct inode *inode)
 	UFSD("EXIT: ino %lu\n", inode->i_ino);
 }
 
-
-static void ufs_trunc_indirect(struct inode *inode, unsigned *offsets, int depth2, void *p)
-{
-	struct super_block *sb = inode->i_sb;
-	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
-	struct ufs_buffer_head * ind_ubh;
-	void *ind;
-	u64 tmp, frag_to_free = 0;
-	unsigned free_count = 0;
-	unsigned from = offsets ? *offsets : 0;
-	bool to_free = !offsets || !depth2;
-	unsigned i;
-
-	tmp = ufs_data_ptr_to_cpu(sb, p);
-	if (!tmp)
-		return;
-	ind_ubh = ubh_bread(sb, tmp, uspi->s_bsize);
-	if (!ind_ubh) {
-		write_seqlock(&UFS_I(inode)->meta_lock);
-		ufs_data_ptr_clear(uspi, p);
-		write_sequnlock(&UFS_I(inode)->meta_lock);
-		return;
-	}
-
-	for (i = from; i < uspi->s_apb; i++) {
-		ind = ubh_get_data_ptr(uspi, ind_ubh, i);
-		tmp = ufs_data_ptr_to_cpu(sb, ind);
-		if (!tmp)
-			continue;
-
-		write_seqlock(&UFS_I(inode)->meta_lock);
-		ufs_data_ptr_clear(uspi, ind);
-		write_sequnlock(&UFS_I(inode)->meta_lock);
-		ubh_mark_buffer_dirty(ind_ubh);
-		if (free_count == 0) {
-			frag_to_free = tmp;
-			free_count = uspi->s_fpb;
-		} else if (free_count > 0 && frag_to_free == tmp - free_count)
-			free_count += uspi->s_fpb;
-		else {
-			ufs_free_blocks (inode, frag_to_free, free_count);
-			frag_to_free = tmp;
-			free_count = uspi->s_fpb;
-		}
-
-		mark_inode_dirty(inode);
-	}
-
-	if (free_count > 0) {
-		ufs_free_blocks (inode, frag_to_free, free_count);
-	}
-	if (to_free) {
-		tmp = ufs_data_ptr_to_cpu(sb, p);
-		write_seqlock(&UFS_I(inode)->meta_lock);
-		ufs_data_ptr_clear(uspi, p);
-		write_sequnlock(&UFS_I(inode)->meta_lock);
-
-		ubh_bforget(ind_ubh);
-		ufs_free_blocks (inode, tmp, uspi->s_fpb);
-		mark_inode_dirty(inode);
-		return;
-	}
-	if (IS_SYNC(inode) && ubh_buffer_dirty(ind_ubh))
-		ubh_sync_block(ind_ubh);
-	ubh_brelse (ind_ubh);
-}
-
-static void ufs_trunc_dindirect(struct inode *inode, unsigned *offsets, int depth2, void *p)
+static void ufs_trunc_branch(struct inode *inode, unsigned *offsets, int depth2, int depth, void *p)
 {
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
-	struct ufs_buffer_head *dind_bh;
+	struct ufs_inode_info *ufsi = UFS_I(inode);
+	struct ufs_buffer_head *ubh;
 	u64 tmp;
-	void *dind;
 	bool free_it = !offsets || !depth2;
-	unsigned dindirect_block = offsets ? *offsets++ : 0;
+	unsigned from = offsets ? *offsets++ : 0;
 	unsigned i;
 
 	tmp = ufs_data_ptr_to_cpu(sb, p);
 	if (!tmp)
 		return;
-	dind_bh = ubh_bread(sb, tmp, uspi->s_bsize);
-	if (!dind_bh) {
-		write_seqlock(&UFS_I(inode)->meta_lock);
-		ufs_data_ptr_clear(uspi, p);
-		write_sequnlock(&UFS_I(inode)->meta_lock);
-		return;
-	}
-
-	for (i = dindirect_block ; i < uspi->s_apb ; i++, offsets = NULL) {
-		dind = ubh_get_data_ptr(uspi, dind_bh, i);
-		tmp = ufs_data_ptr_to_cpu(sb, dind);
-		if (!tmp)
-			continue;
-		ufs_trunc_indirect(inode, offsets, depth2 - 1, dind);
-		ubh_mark_buffer_dirty(dind_bh);
-	}
-
-	if (free_it) {
-		tmp = ufs_data_ptr_to_cpu(sb, p);
-		write_seqlock(&UFS_I(inode)->meta_lock);
-		ufs_data_ptr_clear(uspi, p);
-		write_sequnlock(&UFS_I(inode)->meta_lock);
-
-		ubh_bforget(dind_bh);
-		ufs_free_blocks(inode, tmp, uspi->s_fpb);
-		mark_inode_dirty(inode);
-		return;
-	}
-	if (IS_SYNC(inode) && ubh_buffer_dirty(dind_bh))
-		ubh_sync_block(dind_bh);
-	ubh_brelse (dind_bh);
-}
-
-static void ufs_trunc_tindirect(struct inode *inode, unsigned *offsets, int depth2)
-{
-	struct super_block *sb = inode->i_sb;
-	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
-	struct ufs_inode_info *ufsi = UFS_I(inode);
-	struct ufs_buffer_head * tind_bh;
-	u64 tmp;
-	void *tind, *p;
-	bool free_it = !offsets || !depth2;
-	unsigned tindirect_block = offsets ? *offsets++ : 0;
-	unsigned i;
-
-	p = ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK);
-	if (!(tmp = ufs_data_ptr_to_cpu(sb, p)))
-		return;
-	tind_bh = ubh_bread (sb, tmp, uspi->s_bsize);
-	if (!tind_bh) {
+	ubh = ubh_bread (sb, tmp, uspi->s_bsize);
+	if (!ubh) {
 		write_seqlock(&ufsi->meta_lock);
 		ufs_data_ptr_clear(uspi, p);
 		write_sequnlock(&ufsi->meta_lock);
 		return;
 	}
 
-	for (i = tindirect_block ; i < uspi->s_apb ; i++, offsets = NULL) {
-		tind = ubh_get_data_ptr(uspi, tind_bh, i);
-		ufs_trunc_dindirect(inode, offsets, depth2 - 1, tind);
-		ubh_mark_buffer_dirty(tind_bh);
+	if (--depth) {
+		for (i = from ; i < uspi->s_apb ; i++, offsets = NULL) {
+			void *ind = ubh_get_data_ptr(uspi, ubh, i);
+			ufs_trunc_branch(inode, offsets, depth2 - 1, depth, ind);
+			ubh_mark_buffer_dirty(ubh);
+		}
+	} else {
+		u64 frag_to_free = 0;
+		unsigned free_count = 0;
+
+		for (i = from; i < uspi->s_apb; i++) {
+			void *ind = ubh_get_data_ptr(uspi, ubh, i);
+			tmp = ufs_data_ptr_to_cpu(sb, ind);
+			if (!tmp)
+				continue;
+
+			write_seqlock(&UFS_I(inode)->meta_lock);
+			ufs_data_ptr_clear(uspi, ind);
+			write_sequnlock(&UFS_I(inode)->meta_lock);
+			ubh_mark_buffer_dirty(ubh);
+			if (free_count == 0) {
+				frag_to_free = tmp;
+				free_count = uspi->s_fpb;
+			} else if (free_count > 0 && frag_to_free == tmp - free_count)
+				free_count += uspi->s_fpb;
+			else {
+				ufs_free_blocks (inode, frag_to_free, free_count);
+				frag_to_free = tmp;
+				free_count = uspi->s_fpb;
+			}
+
+			mark_inode_dirty(inode);
+		}
+
+		if (free_count > 0) {
+			ufs_free_blocks (inode, frag_to_free, free_count);
+		}
 	}
 	if (free_it) {
 		tmp = ufs_data_ptr_to_cpu(sb, p);
@@ -1216,14 +1134,14 @@ static void ufs_trunc_tindirect(struct inode *inode, unsigned *offsets, int dept
 		ufs_data_ptr_clear(uspi, p);
 		write_sequnlock(&ufsi->meta_lock);
 
-		ubh_bforget(tind_bh);
+		ubh_bforget(ubh);
 		ufs_free_blocks(inode, tmp, uspi->s_fpb);
 		mark_inode_dirty(inode);
 		return;
 	}
-	if (IS_SYNC(inode) && ubh_buffer_dirty(tind_bh))
-		ubh_sync_block(tind_bh);
-	ubh_brelse (tind_bh);
+	if (IS_SYNC(inode) && ubh_buffer_dirty(ubh))
+		ubh_sync_block(ubh);
+	ubh_brelse(ubh);
 }
 
 static int ufs_alloc_lastblock(struct inode *inode, loff_t size)
@@ -1317,26 +1235,30 @@ static void __ufs_truncate_blocks(struct inode *inode)
 	switch (depth) {
 	case 1:
 		ufs_trunc_direct(inode);
-		ufs_trunc_indirect(inode, NULL, 0,
+		ufs_trunc_branch(inode, NULL, 0, 1,
 			   ufs_get_direct_data_ptr(uspi, ufsi, UFS_IND_BLOCK));
-		ufs_trunc_dindirect(inode, NULL, 0,
+		ufs_trunc_branch(inode, NULL, 0, 2,
 			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
-		ufs_trunc_tindirect(inode, NULL, 0);
+		ufs_trunc_branch(inode, NULL, 0, 3,
+			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK));
 		break;
 	case 2:
-		ufs_trunc_indirect(inode, offsets + 1, depth2,
+		ufs_trunc_branch(inode, offsets + 1, depth2, 1,
 			   ufs_get_direct_data_ptr(uspi, ufsi, UFS_IND_BLOCK));
-		ufs_trunc_dindirect(inode, NULL, 0,
+		ufs_trunc_branch(inode, NULL, 0, 2,
 			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
-		ufs_trunc_tindirect(inode, NULL, 0);
+		ufs_trunc_branch(inode, NULL, 0, 3,
+			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK));
 		break;
 	case 3:
-		ufs_trunc_dindirect(inode, offsets + 1, depth2,
+		ufs_trunc_branch(inode, offsets + 1, depth2, 2,
 			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
-		ufs_trunc_tindirect(inode, NULL, 0);
+		ufs_trunc_branch(inode, NULL, 0, 3,
+			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK));
 		break;
 	case 4:
-		ufs_trunc_tindirect(inode, offsets + 1, depth2);
+		ufs_trunc_branch(inode, offsets + 1, depth2, 3,
+			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK));
 	}
 	ufsi->i_lastfrag = DIRECT_FRAGMENT;
 	mutex_unlock(&ufsi->truncate_mutex);

commit 6775e24d9ccf6a48ebd1d31ca77db5ebfe00ce43
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 14:55:50 2015 -0400

    ufs_trunc_..indirect(): more massage towards unifying
    
    Instead of manually checking that the array contains only zeroes,
    find the position of the last non-zero (in __ufs_truncate(), where
    we can conveniently do that) and use that to tell if there's
    any non-zero in the array tail passed to ufs_trunc_...indirect().
    
    The goal of all that clumsiness is to get fold these functions
    together.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 34d8dac4fe8b..e90266a221b8 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1069,7 +1069,7 @@ static void ufs_trunc_direct(struct inode *inode)
 }
 
 
-static void ufs_trunc_indirect(struct inode *inode, unsigned *offsets, void *p)
+static void ufs_trunc_indirect(struct inode *inode, unsigned *offsets, int depth2, void *p)
 {
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
@@ -1078,7 +1078,7 @@ static void ufs_trunc_indirect(struct inode *inode, unsigned *offsets, void *p)
 	u64 tmp, frag_to_free = 0;
 	unsigned free_count = 0;
 	unsigned from = offsets ? *offsets : 0;
-	bool to_free = !offsets || !from;
+	bool to_free = !offsets || !depth2;
 	unsigned i;
 
 	tmp = ufs_data_ptr_to_cpu(sb, p);
@@ -1135,14 +1135,14 @@ static void ufs_trunc_indirect(struct inode *inode, unsigned *offsets, void *p)
 	ubh_brelse (ind_ubh);
 }
 
-static void ufs_trunc_dindirect(struct inode *inode, unsigned *offsets, void *p)
+static void ufs_trunc_dindirect(struct inode *inode, unsigned *offsets, int depth2, void *p)
 {
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
 	struct ufs_buffer_head *dind_bh;
 	u64 tmp;
 	void *dind;
-	bool free_it = !offsets || !(offsets[0] || offsets[1]);
+	bool free_it = !offsets || !depth2;
 	unsigned dindirect_block = offsets ? *offsets++ : 0;
 	unsigned i;
 
@@ -1162,7 +1162,7 @@ static void ufs_trunc_dindirect(struct inode *inode, unsigned *offsets, void *p)
 		tmp = ufs_data_ptr_to_cpu(sb, dind);
 		if (!tmp)
 			continue;
-		ufs_trunc_indirect(inode, offsets, dind);
+		ufs_trunc_indirect(inode, offsets, depth2 - 1, dind);
 		ubh_mark_buffer_dirty(dind_bh);
 	}
 
@@ -1182,7 +1182,7 @@ static void ufs_trunc_dindirect(struct inode *inode, unsigned *offsets, void *p)
 	ubh_brelse (dind_bh);
 }
 
-static void ufs_trunc_tindirect(struct inode *inode, unsigned *offsets)
+static void ufs_trunc_tindirect(struct inode *inode, unsigned *offsets, int depth2)
 {
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
@@ -1190,7 +1190,7 @@ static void ufs_trunc_tindirect(struct inode *inode, unsigned *offsets)
 	struct ufs_buffer_head * tind_bh;
 	u64 tmp;
 	void *tind, *p;
-	bool free_it = !offsets || !(offsets[0] || offsets[1] || offsets[2]);
+	bool free_it = !offsets || !depth2;
 	unsigned tindirect_block = offsets ? *offsets++ : 0;
 	unsigned i;
 
@@ -1207,7 +1207,7 @@ static void ufs_trunc_tindirect(struct inode *inode, unsigned *offsets)
 
 	for (i = tindirect_block ; i < uspi->s_apb ; i++, offsets = NULL) {
 		tind = ubh_get_data_ptr(uspi, tind_bh, i);
-		ufs_trunc_dindirect(inode, offsets, tind);
+		ufs_trunc_dindirect(inode, offsets, depth2 - 1, tind);
 		ubh_mark_buffer_dirty(tind_bh);
 	}
 	if (free_it) {
@@ -1303,31 +1303,40 @@ static void __ufs_truncate_blocks(struct inode *inode)
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
 	unsigned offsets[4];
 	int depth = ufs_block_to_path(inode, DIRECT_BLOCK, offsets);
+	int depth2;
+
+	if (!depth)
+		return;
+
+	/* find the last non-zero in offsets[] */
+	for (depth2 = depth - 1; depth2; depth2--)
+		if (offsets[depth2])
+			break;
 
 	mutex_lock(&ufsi->truncate_mutex);
 	switch (depth) {
 	case 1:
 		ufs_trunc_direct(inode);
-		ufs_trunc_indirect(inode, NULL,
+		ufs_trunc_indirect(inode, NULL, 0,
 			   ufs_get_direct_data_ptr(uspi, ufsi, UFS_IND_BLOCK));
-		ufs_trunc_dindirect(inode, NULL,
+		ufs_trunc_dindirect(inode, NULL, 0,
 			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
-		ufs_trunc_tindirect(inode, NULL);
+		ufs_trunc_tindirect(inode, NULL, 0);
 		break;
 	case 2:
-		ufs_trunc_indirect(inode, offsets + 1,
+		ufs_trunc_indirect(inode, offsets + 1, depth2,
 			   ufs_get_direct_data_ptr(uspi, ufsi, UFS_IND_BLOCK));
-		ufs_trunc_dindirect(inode, NULL,
+		ufs_trunc_dindirect(inode, NULL, 0,
 			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
-		ufs_trunc_tindirect(inode, NULL);
+		ufs_trunc_tindirect(inode, NULL, 0);
 		break;
 	case 3:
-		ufs_trunc_dindirect(inode, offsets + 1,
+		ufs_trunc_dindirect(inode, offsets + 1, depth2,
 			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
-		ufs_trunc_tindirect(inode, NULL);
+		ufs_trunc_tindirect(inode, NULL, 0);
 		break;
 	case 4:
-		ufs_trunc_tindirect(inode, offsets + 1);
+		ufs_trunc_tindirect(inode, offsets + 1, depth2);
 	}
 	ufsi->i_lastfrag = DIRECT_FRAGMENT;
 	mutex_unlock(&ufsi->truncate_mutex);

commit 85416288bf730cffb61ab6ce8a7b97b17c73458f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 14:36:31 2015 -0400

    ufs_trunc_...indirect(): pass the array of indices instead of offsets
    
    rather than bitslicing the offset just formed as sum of shifted indices,
    pass the array of those indices itself.  NULL is used as equivalent
    of "all zeroes" (== free the entire branch).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index c2544d62adf2..34d8dac4fe8b 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1069,7 +1069,7 @@ static void ufs_trunc_direct(struct inode *inode)
 }
 
 
-static void ufs_trunc_indirect(struct inode *inode, unsigned from, void *p)
+static void ufs_trunc_indirect(struct inode *inode, unsigned *offsets, void *p)
 {
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
@@ -1077,7 +1077,8 @@ static void ufs_trunc_indirect(struct inode *inode, unsigned from, void *p)
 	void *ind;
 	u64 tmp, frag_to_free = 0;
 	unsigned free_count = 0;
-	bool to_free = !from;
+	unsigned from = offsets ? *offsets : 0;
+	bool to_free = !offsets || !from;
 	unsigned i;
 
 	tmp = ufs_data_ptr_to_cpu(sb, p);
@@ -1134,16 +1135,15 @@ static void ufs_trunc_indirect(struct inode *inode, unsigned from, void *p)
 	ubh_brelse (ind_ubh);
 }
 
-static void ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)
+static void ufs_trunc_dindirect(struct inode *inode, unsigned *offsets, void *p)
 {
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
 	struct ufs_buffer_head *dind_bh;
 	u64 tmp;
 	void *dind;
-	bool free_it = !offset;
-	unsigned dindirect_block = offset >> uspi->s_apbshift;
-	unsigned from = offset & uspi->s_apbmask;
+	bool free_it = !offsets || !(offsets[0] || offsets[1]);
+	unsigned dindirect_block = offsets ? *offsets++ : 0;
 	unsigned i;
 
 	tmp = ufs_data_ptr_to_cpu(sb, p);
@@ -1157,12 +1157,12 @@ static void ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)
 		return;
 	}
 
-	for (i = dindirect_block ; i < uspi->s_apb ; i++, from = 0) {
+	for (i = dindirect_block ; i < uspi->s_apb ; i++, offsets = NULL) {
 		dind = ubh_get_data_ptr(uspi, dind_bh, i);
 		tmp = ufs_data_ptr_to_cpu(sb, dind);
 		if (!tmp)
 			continue;
-		ufs_trunc_indirect(inode, from, dind);
+		ufs_trunc_indirect(inode, offsets, dind);
 		ubh_mark_buffer_dirty(dind_bh);
 	}
 
@@ -1182,7 +1182,7 @@ static void ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)
 	ubh_brelse (dind_bh);
 }
 
-static void ufs_trunc_tindirect(struct inode *inode, u64 offset)
+static void ufs_trunc_tindirect(struct inode *inode, unsigned *offsets)
 {
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
@@ -1190,12 +1190,10 @@ static void ufs_trunc_tindirect(struct inode *inode, u64 offset)
 	struct ufs_buffer_head * tind_bh;
 	u64 tmp;
 	void *tind, *p;
-	bool free_it = !offset;
-	unsigned tindirect_block = offset >> uspi->s_2apbshift;
+	bool free_it = !offsets || !(offsets[0] || offsets[1] || offsets[2]);
+	unsigned tindirect_block = offsets ? *offsets++ : 0;
 	unsigned i;
 
-	offset -= tindirect_block << uspi->s_2apbshift;
-
 	p = ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK);
 	if (!(tmp = ufs_data_ptr_to_cpu(sb, p)))
 		return;
@@ -1207,9 +1205,9 @@ static void ufs_trunc_tindirect(struct inode *inode, u64 offset)
 		return;
 	}
 
-	for (i = tindirect_block ; i < uspi->s_apb ; i++, offset = 0) {
+	for (i = tindirect_block ; i < uspi->s_apb ; i++, offsets = NULL) {
 		tind = ubh_get_data_ptr(uspi, tind_bh, i);
-		ufs_trunc_dindirect(inode, offset, tind);
+		ufs_trunc_dindirect(inode, offsets, tind);
 		ubh_mark_buffer_dirty(tind_bh);
 	}
 	if (free_it) {
@@ -1310,30 +1308,26 @@ static void __ufs_truncate_blocks(struct inode *inode)
 	switch (depth) {
 	case 1:
 		ufs_trunc_direct(inode);
-		ufs_trunc_indirect(inode, 0,
+		ufs_trunc_indirect(inode, NULL,
 			   ufs_get_direct_data_ptr(uspi, ufsi, UFS_IND_BLOCK));
-		ufs_trunc_dindirect(inode, 0,
+		ufs_trunc_dindirect(inode, NULL,
 			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
-		ufs_trunc_tindirect(inode, 0);
+		ufs_trunc_tindirect(inode, NULL);
 		break;
 	case 2:
-		ufs_trunc_indirect(inode, offsets[1],
+		ufs_trunc_indirect(inode, offsets + 1,
 			   ufs_get_direct_data_ptr(uspi, ufsi, UFS_IND_BLOCK));
-		ufs_trunc_dindirect(inode, 0,
+		ufs_trunc_dindirect(inode, NULL,
 			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
-		ufs_trunc_tindirect(inode, 0);
+		ufs_trunc_tindirect(inode, NULL);
 		break;
 	case 3:
-		ufs_trunc_dindirect(inode,
-			    (offsets[1] << uspi->s_apbshift) + offsets[2],
+		ufs_trunc_dindirect(inode, offsets + 1,
 			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
-		ufs_trunc_tindirect(inode, 0);
+		ufs_trunc_tindirect(inode, NULL);
 		break;
 	case 4:
-		ufs_trunc_tindirect(inode,
-			   (offsets[1] << uspi->s_2apbshift) +
-			   (offsets[2] << uspi->s_apbshift) +
-			   offsets[3]);
+		ufs_trunc_tindirect(inode, offsets + 1);
 	}
 	ufsi->i_lastfrag = DIRECT_FRAGMENT;
 	mutex_unlock(&ufsi->truncate_mutex);

commit 7a4fdda72451f094374324a552be9fc7de8f3e8d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 14:28:54 2015 -0400

    __ufs_truncate(); find cutoff distances into branches by offsets[] array
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index b4d6398a2d54..c2544d62adf2 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1324,12 +1324,16 @@ static void __ufs_truncate_blocks(struct inode *inode)
 		ufs_trunc_tindirect(inode, 0);
 		break;
 	case 3:
-		ufs_trunc_dindirect(inode, DIRECT_BLOCK - UFS_IND_BLOCK - uspi->s_apb,
+		ufs_trunc_dindirect(inode,
+			    (offsets[1] << uspi->s_apbshift) + offsets[2],
 			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
 		ufs_trunc_tindirect(inode, 0);
 		break;
 	case 4:
-		ufs_trunc_tindirect(inode, DIRECT_BLOCK - UFS_NDADDR - uspi->s_apb - uspi->s_2apb);
+		ufs_trunc_tindirect(inode,
+			   (offsets[1] << uspi->s_2apbshift) +
+			   (offsets[2] << uspi->s_apbshift) +
+			   offsets[3]);
 	}
 	ufsi->i_lastfrag = DIRECT_FRAGMENT;
 	mutex_unlock(&ufsi->truncate_mutex);

commit 7bad5939fcd04bb83122bdb90981ec5ae2f90e0d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 14:21:09 2015 -0400

    ufs_trunc_dindirect(): pass the number of blocks to keep
    
    same as the previous two.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 9c4471a82d2f..b4d6398a2d54 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1136,25 +1136,15 @@ static void ufs_trunc_indirect(struct inode *inode, unsigned from, void *p)
 
 static void ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)
 {
-	struct super_block * sb;
-	struct ufs_sb_private_info * uspi;
+	struct super_block *sb = inode->i_sb;
+	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
 	struct ufs_buffer_head *dind_bh;
-	u64 i, tmp, dindirect_block;
+	u64 tmp;
 	void *dind;
-	unsigned from;
-
-	UFSD("ENTER: ino %lu\n", inode->i_ino);
-
-	sb = inode->i_sb;
-	uspi = UFS_SB(sb)->s_uspi;
-
-	if (DIRECT_BLOCK <= offset) {
-		dindirect_block = 0;
-		from = 0;
-	} else {
-		dindirect_block = (DIRECT_BLOCK - offset) >> uspi->s_apbshift;
-		from = (DIRECT_BLOCK - offset) & uspi->s_apbmask;
-	}
+	bool free_it = !offset;
+	unsigned dindirect_block = offset >> uspi->s_apbshift;
+	unsigned from = offset & uspi->s_apbmask;
+	unsigned i;
 
 	tmp = ufs_data_ptr_to_cpu(sb, p);
 	if (!tmp)
@@ -1176,11 +1166,7 @@ static void ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)
 		ubh_mark_buffer_dirty(dind_bh);
 	}
 
-	for (i = 0; i < uspi->s_apb; i++)
-		if (!ufs_is_data_ptr_zero(uspi,
-					  ubh_get_data_ptr(uspi, dind_bh, i)))
-			break;
-	if (i >= uspi->s_apb) {
+	if (free_it) {
 		tmp = ufs_data_ptr_to_cpu(sb, p);
 		write_seqlock(&UFS_I(inode)->meta_lock);
 		ufs_data_ptr_clear(uspi, p);
@@ -1189,13 +1175,11 @@ static void ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)
 		ubh_bforget(dind_bh);
 		ufs_free_blocks(inode, tmp, uspi->s_fpb);
 		mark_inode_dirty(inode);
-		dind_bh = NULL;
+		return;
 	}
-	if (IS_SYNC(inode) && dind_bh && ubh_buffer_dirty(dind_bh))
+	if (IS_SYNC(inode) && ubh_buffer_dirty(dind_bh))
 		ubh_sync_block(dind_bh);
 	ubh_brelse (dind_bh);
-
-	UFSD("EXIT: ino %lu\n", inode->i_ino);
 }
 
 static void ufs_trunc_tindirect(struct inode *inode, u64 offset)
@@ -1210,6 +1194,8 @@ static void ufs_trunc_tindirect(struct inode *inode, u64 offset)
 	unsigned tindirect_block = offset >> uspi->s_2apbshift;
 	unsigned i;
 
+	offset -= tindirect_block << uspi->s_2apbshift;
+
 	p = ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK);
 	if (!(tmp = ufs_data_ptr_to_cpu(sb, p)))
 		return;
@@ -1221,10 +1207,9 @@ static void ufs_trunc_tindirect(struct inode *inode, u64 offset)
 		return;
 	}
 
-	for (i = tindirect_block ; i < uspi->s_apb ; i++) {
+	for (i = tindirect_block ; i < uspi->s_apb ; i++, offset = 0) {
 		tind = ubh_get_data_ptr(uspi, tind_bh, i);
-		ufs_trunc_dindirect(inode, UFS_NDADDR +
-			uspi->s_apb + ((i + 1) << uspi->s_2apbshift), tind);
+		ufs_trunc_dindirect(inode, offset, tind);
 		ubh_mark_buffer_dirty(tind_bh);
 	}
 	if (free_it) {
@@ -1318,18 +1303,28 @@ static void __ufs_truncate_blocks(struct inode *inode)
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
-	unsigned offsets[4] = {0,};
+	unsigned offsets[4];
 	int depth = ufs_block_to_path(inode, DIRECT_BLOCK, offsets);
 
 	mutex_lock(&ufsi->truncate_mutex);
 	switch (depth) {
 	case 1:
 		ufs_trunc_direct(inode);
+		ufs_trunc_indirect(inode, 0,
+			   ufs_get_direct_data_ptr(uspi, ufsi, UFS_IND_BLOCK));
+		ufs_trunc_dindirect(inode, 0,
+			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
+		ufs_trunc_tindirect(inode, 0);
+		break;
 	case 2:
 		ufs_trunc_indirect(inode, offsets[1],
 			   ufs_get_direct_data_ptr(uspi, ufsi, UFS_IND_BLOCK));
+		ufs_trunc_dindirect(inode, 0,
+			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
+		ufs_trunc_tindirect(inode, 0);
+		break;
 	case 3:
-		ufs_trunc_dindirect(inode, UFS_IND_BLOCK + uspi->s_apb,
+		ufs_trunc_dindirect(inode, DIRECT_BLOCK - UFS_IND_BLOCK - uspi->s_apb,
 			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
 		ufs_trunc_tindirect(inode, 0);
 		break;

commit 6ac36b8777d934e3cd7eb0f023a5043d5c03b00c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jun 17 01:54:58 2015 -0400

    ufs_trunc_indirect(): pass the index of the first pointer to free
    
    ... instead of file offset.  Same cleanups as in the tindirect
    conversion in previous commit.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 5b3f1c44d4b0..9c4471a82d2f 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1069,25 +1069,16 @@ static void ufs_trunc_direct(struct inode *inode)
 }
 
 
-static void ufs_trunc_indirect(struct inode *inode, u64 offset, void *p)
+static void ufs_trunc_indirect(struct inode *inode, unsigned from, void *p)
 {
-	struct super_block * sb;
-	struct ufs_sb_private_info * uspi;
+	struct super_block *sb = inode->i_sb;
+	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
 	struct ufs_buffer_head * ind_ubh;
 	void *ind;
-	u64 tmp, indirect_block, i, frag_to_free;
-	unsigned free_count;
-
-	UFSD("ENTER: ino %lu, offset %llu, p: %p\n",
-	     inode->i_ino, (unsigned long long)offset, p);
-
-	BUG_ON(!p);
-
-	sb = inode->i_sb;
-	uspi = UFS_SB(sb)->s_uspi;
-
-	frag_to_free = 0;
-	free_count = 0;
+	u64 tmp, frag_to_free = 0;
+	unsigned free_count = 0;
+	bool to_free = !from;
+	unsigned i;
 
 	tmp = ufs_data_ptr_to_cpu(sb, p);
 	if (!tmp)
@@ -1100,8 +1091,7 @@ static void ufs_trunc_indirect(struct inode *inode, u64 offset, void *p)
 		return;
 	}
 
-	indirect_block = (DIRECT_BLOCK > offset) ? (DIRECT_BLOCK - offset) : 0;
-	for (i = indirect_block; i < uspi->s_apb; i++) {
+	for (i = from; i < uspi->s_apb; i++) {
 		ind = ubh_get_data_ptr(uspi, ind_ubh, i);
 		tmp = ufs_data_ptr_to_cpu(sb, ind);
 		if (!tmp)
@@ -1128,11 +1118,7 @@ static void ufs_trunc_indirect(struct inode *inode, u64 offset, void *p)
 	if (free_count > 0) {
 		ufs_free_blocks (inode, frag_to_free, free_count);
 	}
-	for (i = 0; i < uspi->s_apb; i++)
-		if (!ufs_is_data_ptr_zero(uspi,
-					  ubh_get_data_ptr(uspi, ind_ubh, i)))
-			break;
-	if (i >= uspi->s_apb) {
+	if (to_free) {
 		tmp = ufs_data_ptr_to_cpu(sb, p);
 		write_seqlock(&UFS_I(inode)->meta_lock);
 		ufs_data_ptr_clear(uspi, p);
@@ -1141,13 +1127,11 @@ static void ufs_trunc_indirect(struct inode *inode, u64 offset, void *p)
 		ubh_bforget(ind_ubh);
 		ufs_free_blocks (inode, tmp, uspi->s_fpb);
 		mark_inode_dirty(inode);
-		ind_ubh = NULL;
+		return;
 	}
-	if (IS_SYNC(inode) && ind_ubh && ubh_buffer_dirty(ind_ubh))
+	if (IS_SYNC(inode) && ubh_buffer_dirty(ind_ubh))
 		ubh_sync_block(ind_ubh);
 	ubh_brelse (ind_ubh);
-
-	UFSD("EXIT: ino %lu\n", inode->i_ino);
 }
 
 static void ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)
@@ -1157,14 +1141,20 @@ static void ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)
 	struct ufs_buffer_head *dind_bh;
 	u64 i, tmp, dindirect_block;
 	void *dind;
+	unsigned from;
 
 	UFSD("ENTER: ino %lu\n", inode->i_ino);
 
 	sb = inode->i_sb;
 	uspi = UFS_SB(sb)->s_uspi;
 
-	dindirect_block = (DIRECT_BLOCK > offset)
-		? ((DIRECT_BLOCK - offset) >> uspi->s_apbshift) : 0;
+	if (DIRECT_BLOCK <= offset) {
+		dindirect_block = 0;
+		from = 0;
+	} else {
+		dindirect_block = (DIRECT_BLOCK - offset) >> uspi->s_apbshift;
+		from = (DIRECT_BLOCK - offset) & uspi->s_apbmask;
+	}
 
 	tmp = ufs_data_ptr_to_cpu(sb, p);
 	if (!tmp)
@@ -1177,12 +1167,12 @@ static void ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)
 		return;
 	}
 
-	for (i = dindirect_block ; i < uspi->s_apb ; i++) {
+	for (i = dindirect_block ; i < uspi->s_apb ; i++, from = 0) {
 		dind = ubh_get_data_ptr(uspi, dind_bh, i);
 		tmp = ufs_data_ptr_to_cpu(sb, dind);
 		if (!tmp)
 			continue;
-		ufs_trunc_indirect (inode, offset + (i << uspi->s_apbshift), dind);
+		ufs_trunc_indirect(inode, from, dind);
 		ubh_mark_buffer_dirty(dind_bh);
 	}
 
@@ -1328,7 +1318,7 @@ static void __ufs_truncate_blocks(struct inode *inode)
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
-	unsigned offsets[4];
+	unsigned offsets[4] = {0,};
 	int depth = ufs_block_to_path(inode, DIRECT_BLOCK, offsets);
 
 	mutex_lock(&ufsi->truncate_mutex);
@@ -1336,7 +1326,7 @@ static void __ufs_truncate_blocks(struct inode *inode)
 	case 1:
 		ufs_trunc_direct(inode);
 	case 2:
-		ufs_trunc_indirect(inode, UFS_IND_BLOCK,
+		ufs_trunc_indirect(inode, offsets[1],
 			   ufs_get_direct_data_ptr(uspi, ufsi, UFS_IND_BLOCK));
 	case 3:
 		ufs_trunc_dindirect(inode, UFS_IND_BLOCK + uspi->s_apb,

commit 18ca51d8211065f10672374336cd08d495968c73
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 13:45:07 2015 -0400

    ufs_trunc_tindirect(): pass the number of blocks to keep
    
    IOW, the distance of cutoff from the begining of the branch
    (in blocks).
    
    That (and the fact that block just prior to cutoff is guaranteed to
    be present) allows to tell whether to free triple indirect block
    just by looking at the offset.
    
    While we are at it, using u64 for index in the block is wrong -
    those should be unsigned int.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index afb0f32b921c..5b3f1c44d4b0 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1208,19 +1208,17 @@ static void ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)
 	UFSD("EXIT: ino %lu\n", inode->i_ino);
 }
 
-static void ufs_trunc_tindirect(struct inode *inode)
+static void ufs_trunc_tindirect(struct inode *inode, u64 offset)
 {
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct ufs_buffer_head * tind_bh;
-	u64 tindirect_block, tmp, i;
+	u64 tmp;
 	void *tind, *p;
-
-	UFSD("ENTER: ino %lu\n", inode->i_ino);
-
-	tindirect_block = (DIRECT_BLOCK > (UFS_NDADDR + uspi->s_apb + uspi->s_2apb))
-		? ((DIRECT_BLOCK - UFS_NDADDR - uspi->s_apb - uspi->s_2apb) >> uspi->s_2apbshift) : 0;
+	bool free_it = !offset;
+	unsigned tindirect_block = offset >> uspi->s_2apbshift;
+	unsigned i;
 
 	p = ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK);
 	if (!(tmp = ufs_data_ptr_to_cpu(sb, p)))
@@ -1239,11 +1237,7 @@ static void ufs_trunc_tindirect(struct inode *inode)
 			uspi->s_apb + ((i + 1) << uspi->s_2apbshift), tind);
 		ubh_mark_buffer_dirty(tind_bh);
 	}
-	for (i = 0; i < uspi->s_apb; i++)
-		if (!ufs_is_data_ptr_zero(uspi,
-					  ubh_get_data_ptr(uspi, tind_bh, i)))
-			break;
-	if (i >= uspi->s_apb) {
+	if (free_it) {
 		tmp = ufs_data_ptr_to_cpu(sb, p);
 		write_seqlock(&ufsi->meta_lock);
 		ufs_data_ptr_clear(uspi, p);
@@ -1252,13 +1246,11 @@ static void ufs_trunc_tindirect(struct inode *inode)
 		ubh_bforget(tind_bh);
 		ufs_free_blocks(inode, tmp, uspi->s_fpb);
 		mark_inode_dirty(inode);
-		tind_bh = NULL;
+		return;
 	}
-	if (IS_SYNC(inode) && tind_bh && ubh_buffer_dirty(tind_bh))
+	if (IS_SYNC(inode) && ubh_buffer_dirty(tind_bh))
 		ubh_sync_block(tind_bh);
 	ubh_brelse (tind_bh);
-
-	UFSD("EXIT: ino %lu\n", inode->i_ino);
 }
 
 static int ufs_alloc_lastblock(struct inode *inode, loff_t size)
@@ -1349,8 +1341,10 @@ static void __ufs_truncate_blocks(struct inode *inode)
 	case 3:
 		ufs_trunc_dindirect(inode, UFS_IND_BLOCK + uspi->s_apb,
 			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
+		ufs_trunc_tindirect(inode, 0);
+		break;
 	case 4:
-		ufs_trunc_tindirect(inode);
+		ufs_trunc_tindirect(inode, DIRECT_BLOCK - UFS_NDADDR - uspi->s_apb - uspi->s_2apb);
 	}
 	ufsi->i_lastfrag = DIRECT_FRAGMENT;
 	mutex_unlock(&ufsi->truncate_mutex);

commit 31cd043e1a09c579c4cd38ea432200fbeae6af1f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jun 17 01:10:03 2015 -0400

    ufs: beginning of __ufs_truncate_block() massage
    
    Use ufs_block_to_path() to find the cutoff path in the block pointers' tree.
    For now just use the information about the depth (to bypass the fully
    preserved subtrees); subsequent commits will use the information about actual
    path.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 43672183fee3..afb0f32b921c 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1336,14 +1336,22 @@ static void __ufs_truncate_blocks(struct inode *inode)
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
+	unsigned offsets[4];
+	int depth = ufs_block_to_path(inode, DIRECT_BLOCK, offsets);
 
 	mutex_lock(&ufsi->truncate_mutex);
-	ufs_trunc_direct(inode);
-	ufs_trunc_indirect(inode, UFS_IND_BLOCK,
+	switch (depth) {
+	case 1:
+		ufs_trunc_direct(inode);
+	case 2:
+		ufs_trunc_indirect(inode, UFS_IND_BLOCK,
 			   ufs_get_direct_data_ptr(uspi, ufsi, UFS_IND_BLOCK));
-	ufs_trunc_dindirect(inode, UFS_IND_BLOCK + uspi->s_apb,
+	case 3:
+		ufs_trunc_dindirect(inode, UFS_IND_BLOCK + uspi->s_apb,
 			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
-	ufs_trunc_tindirect(inode);
+	case 4:
+		ufs_trunc_tindirect(inode);
+	}
 	ufsi->i_lastfrag = DIRECT_FRAGMENT;
 	mutex_unlock(&ufsi->truncate_mutex);
 }

commit 4e3911f3d704d681477cdb4e1a2bfd52d5e42d23
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 4 14:13:14 2015 -0400

    ufs: the offsets ufs_block_to_path() puts into array are not sector_t
    
    type makes no sense - those are indices in block number arrays, not
    block numbers.  And no, UFS is not likely to grow indirect blocks with
    4Gpointers in them...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index ec758edbda47..43672183fee3 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -41,7 +41,7 @@
 #include "swab.h"
 #include "util.h"
 
-static int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t offsets[4])
+static int ufs_block_to_path(struct inode *inode, sector_t i_block, unsigned offsets[4])
 {
 	struct ufs_sb_private_info *uspi = UFS_SB(inode->i_sb)->s_uspi;
 	int ptrs = uspi->s_apb;
@@ -153,7 +153,7 @@ static u64 ufs_frag_map(struct inode *inode, sector_t frag)
 	while (--depth) {
 		__fs32 *ptr;
 		struct buffer_head *bh;
-		sector_t n = *p++;
+		unsigned n = *p++;
 
 		bh = sb_bread(sb, uspi->s_sbbase +
 				  fs32_to_cpu(sb, q->key32) + (n>>shift));
@@ -177,7 +177,7 @@ static u64 ufs_frag_map(struct inode *inode, sector_t frag)
 	while (--depth) {
 		__fs64 *ptr;
 		struct buffer_head *bh;
-		sector_t n = *p++;
+		unsigned n = *p++;
 
 		bh = sb_bread(sb, uspi->s_sbbase +
 				  fs64_to_cpu(sb, q->key64) + (n>>shift));

commit 010d331fc315c96607aa6ecdfebb9fcdd349fc9b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jun 17 12:44:14 2015 -0400

    ufs: move truncate code into inode.c
    
    It is closely tied to block pointers handling there, can benefit
    from existing helpers, etc. - no point keeping them apart.
    
    Trimmed the trailing whitespaces in inode.c at the same time.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 100f93c6b309..ec758edbda47 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -126,7 +126,7 @@ static u64 ufs_frag_map(struct inode *inode, sector_t frag)
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
 	u64 mask = (u64) uspi->s_apbmask>>uspi->s_fpbshift;
 	int shift = uspi->s_apbshift-uspi->s_fpbshift;
-	sector_t offsets[4], *p;
+	unsigned offsets[4], *p;
 	Indirect chain[4], *q = chain;
 	int depth = ufs_block_to_path(inode, frag >> uspi->s_fpbshift, offsets);
 	unsigned flags = UFS_SB(sb)->s_flags;
@@ -290,14 +290,14 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 					return NULL;
 			}
 			lastfrag = ufsi->i_lastfrag;
-			
+
 		}
 		tmp = ufs_data_ptr_to_cpu(sb,
 					 ufs_get_direct_data_ptr(uspi, ufsi,
 								 lastblock));
 		if (tmp)
 			goal = tmp + uspi->s_fpb;
-		tmp = ufs_new_fragments (inode, p, fragment - blockoff, 
+		tmp = ufs_new_fragments (inode, p, fragment - blockoff,
 					 goal, required + blockoff,
 					 err,
 					 phys != NULL ? locked_page : NULL);
@@ -436,7 +436,7 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 		if (ufs_data_ptr_to_cpu(sb, p))
 			goto repeat;
 		goto out;
-	}		
+	}
 
 
 	if (!phys) {
@@ -463,7 +463,7 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
  * readpage, writepage and so on
  */
 
-int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head *bh_result, int create)
+static int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head *bh_result, int create)
 {
 	struct super_block * sb = inode->i_sb;
 	struct ufs_sb_info * sbi = UFS_SB(sb);
@@ -472,7 +472,7 @@ int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head
 	int ret, err, new;
 	unsigned long ptr,phys;
 	u64 phys64 = 0;
-	
+
 	if (!create) {
 		phys64 = ufs_frag_map(inode, fragment);
 		UFSD("phys64 = %llu\n", (unsigned long long)phys64);
@@ -498,7 +498,7 @@ int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head
 
 	err = 0;
 	ptr = fragment;
-	  
+
 	/*
 	 * ok, these macros clean the logic up a bit and make
 	 * it much more readable:
@@ -574,6 +574,8 @@ int ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len)
 	return __block_write_begin(page, pos, len, ufs_getfrag_block);
 }
 
+static void ufs_truncate_blocks(struct inode *);
+
 static void ufs_write_failed(struct address_space *mapping, loff_t to)
 {
 	struct inode *inode = mapping->host;
@@ -661,7 +663,7 @@ static int ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 		ufs_error (sb, "ufs_read_inode", "inode %lu has zero nlink\n", inode->i_ino);
 		return -1;
 	}
-	
+
 	/*
 	 * Linux now has 32-bit uid and gid, so we can support EFT.
 	 */
@@ -681,7 +683,7 @@ static int ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 	ufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);
 	ufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);
 
-	
+
 	if (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {
 		memcpy(ufsi->i_u1.i_data, &ufs_inode->ui_u2.ui_addr,
 		       sizeof(ufs_inode->ui_u2.ui_addr));
@@ -815,7 +817,7 @@ static void ufs1_update_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 
 	ufs_set_inode_uid(sb, ufs_inode, i_uid_read(inode));
 	ufs_set_inode_gid(sb, ufs_inode, i_gid_read(inode));
-		
+
 	ufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);
 	ufs_inode->ui_atime.tv_sec = cpu_to_fs32(sb, inode->i_atime.tv_sec);
 	ufs_inode->ui_atime.tv_usec = 0;
@@ -917,12 +919,12 @@ static int ufs_update_inode(struct inode * inode, int do_sync)
 
 		ufs1_update_inode(inode, ufs_inode + ufs_inotofsbo(inode->i_ino));
 	}
-		
+
 	mark_buffer_dirty(bh);
 	if (do_sync)
 		sync_dirty_buffer(bh);
 	brelse (bh);
-	
+
 	UFSD("EXIT\n");
 	return 0;
 }
@@ -957,3 +959,457 @@ void ufs_evict_inode(struct inode * inode)
 	if (want_delete)
 		ufs_free_inode(inode);
 }
+
+#define DIRECT_BLOCK ((inode->i_size + uspi->s_bsize - 1) >> uspi->s_bshift)
+#define DIRECT_FRAGMENT ((inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift)
+
+static void ufs_trunc_direct(struct inode *inode)
+{
+	struct ufs_inode_info *ufsi = UFS_I(inode);
+	struct super_block * sb;
+	struct ufs_sb_private_info * uspi;
+	void *p;
+	u64 frag1, frag2, frag3, frag4, block1, block2;
+	unsigned frag_to_free, free_count;
+	unsigned i, tmp;
+
+	UFSD("ENTER: ino %lu\n", inode->i_ino);
+
+	sb = inode->i_sb;
+	uspi = UFS_SB(sb)->s_uspi;
+
+	frag_to_free = 0;
+	free_count = 0;
+
+	frag1 = DIRECT_FRAGMENT;
+	frag4 = min_t(u64, UFS_NDIR_FRAGMENT, ufsi->i_lastfrag);
+	frag2 = ((frag1 & uspi->s_fpbmask) ? ((frag1 | uspi->s_fpbmask) + 1) : frag1);
+	frag3 = frag4 & ~uspi->s_fpbmask;
+	block1 = block2 = 0;
+	if (frag2 > frag3) {
+		frag2 = frag4;
+		frag3 = frag4 = 0;
+	} else if (frag2 < frag3) {
+		block1 = ufs_fragstoblks (frag2);
+		block2 = ufs_fragstoblks (frag3);
+	}
+
+	UFSD("ino %lu, frag1 %llu, frag2 %llu, block1 %llu, block2 %llu,"
+	     " frag3 %llu, frag4 %llu\n", inode->i_ino,
+	     (unsigned long long)frag1, (unsigned long long)frag2,
+	     (unsigned long long)block1, (unsigned long long)block2,
+	     (unsigned long long)frag3, (unsigned long long)frag4);
+
+	if (frag1 >= frag2)
+		goto next1;
+
+	/*
+	 * Free first free fragments
+	 */
+	p = ufs_get_direct_data_ptr(uspi, ufsi, ufs_fragstoblks(frag1));
+	tmp = ufs_data_ptr_to_cpu(sb, p);
+	if (!tmp )
+		ufs_panic (sb, "ufs_trunc_direct", "internal error");
+	frag2 -= frag1;
+	frag1 = ufs_fragnum (frag1);
+
+	ufs_free_fragments(inode, tmp + frag1, frag2);
+	mark_inode_dirty(inode);
+	frag_to_free = tmp + frag1;
+
+next1:
+	/*
+	 * Free whole blocks
+	 */
+	for (i = block1 ; i < block2; i++) {
+		p = ufs_get_direct_data_ptr(uspi, ufsi, i);
+		tmp = ufs_data_ptr_to_cpu(sb, p);
+		if (!tmp)
+			continue;
+		write_seqlock(&ufsi->meta_lock);
+		ufs_data_ptr_clear(uspi, p);
+		write_sequnlock(&ufsi->meta_lock);
+
+		if (free_count == 0) {
+			frag_to_free = tmp;
+			free_count = uspi->s_fpb;
+		} else if (free_count > 0 && frag_to_free == tmp - free_count)
+			free_count += uspi->s_fpb;
+		else {
+			ufs_free_blocks (inode, frag_to_free, free_count);
+			frag_to_free = tmp;
+			free_count = uspi->s_fpb;
+		}
+		mark_inode_dirty(inode);
+	}
+
+	if (free_count > 0)
+		ufs_free_blocks (inode, frag_to_free, free_count);
+
+	if (frag3 >= frag4)
+		goto next3;
+
+	/*
+	 * Free last free fragments
+	 */
+	p = ufs_get_direct_data_ptr(uspi, ufsi, ufs_fragstoblks(frag3));
+	tmp = ufs_data_ptr_to_cpu(sb, p);
+	if (!tmp )
+		ufs_panic(sb, "ufs_truncate_direct", "internal error");
+	frag4 = ufs_fragnum (frag4);
+	write_seqlock(&ufsi->meta_lock);
+	ufs_data_ptr_clear(uspi, p);
+	write_sequnlock(&ufsi->meta_lock);
+
+	ufs_free_fragments (inode, tmp, frag4);
+	mark_inode_dirty(inode);
+ next3:
+
+	UFSD("EXIT: ino %lu\n", inode->i_ino);
+}
+
+
+static void ufs_trunc_indirect(struct inode *inode, u64 offset, void *p)
+{
+	struct super_block * sb;
+	struct ufs_sb_private_info * uspi;
+	struct ufs_buffer_head * ind_ubh;
+	void *ind;
+	u64 tmp, indirect_block, i, frag_to_free;
+	unsigned free_count;
+
+	UFSD("ENTER: ino %lu, offset %llu, p: %p\n",
+	     inode->i_ino, (unsigned long long)offset, p);
+
+	BUG_ON(!p);
+
+	sb = inode->i_sb;
+	uspi = UFS_SB(sb)->s_uspi;
+
+	frag_to_free = 0;
+	free_count = 0;
+
+	tmp = ufs_data_ptr_to_cpu(sb, p);
+	if (!tmp)
+		return;
+	ind_ubh = ubh_bread(sb, tmp, uspi->s_bsize);
+	if (!ind_ubh) {
+		write_seqlock(&UFS_I(inode)->meta_lock);
+		ufs_data_ptr_clear(uspi, p);
+		write_sequnlock(&UFS_I(inode)->meta_lock);
+		return;
+	}
+
+	indirect_block = (DIRECT_BLOCK > offset) ? (DIRECT_BLOCK - offset) : 0;
+	for (i = indirect_block; i < uspi->s_apb; i++) {
+		ind = ubh_get_data_ptr(uspi, ind_ubh, i);
+		tmp = ufs_data_ptr_to_cpu(sb, ind);
+		if (!tmp)
+			continue;
+
+		write_seqlock(&UFS_I(inode)->meta_lock);
+		ufs_data_ptr_clear(uspi, ind);
+		write_sequnlock(&UFS_I(inode)->meta_lock);
+		ubh_mark_buffer_dirty(ind_ubh);
+		if (free_count == 0) {
+			frag_to_free = tmp;
+			free_count = uspi->s_fpb;
+		} else if (free_count > 0 && frag_to_free == tmp - free_count)
+			free_count += uspi->s_fpb;
+		else {
+			ufs_free_blocks (inode, frag_to_free, free_count);
+			frag_to_free = tmp;
+			free_count = uspi->s_fpb;
+		}
+
+		mark_inode_dirty(inode);
+	}
+
+	if (free_count > 0) {
+		ufs_free_blocks (inode, frag_to_free, free_count);
+	}
+	for (i = 0; i < uspi->s_apb; i++)
+		if (!ufs_is_data_ptr_zero(uspi,
+					  ubh_get_data_ptr(uspi, ind_ubh, i)))
+			break;
+	if (i >= uspi->s_apb) {
+		tmp = ufs_data_ptr_to_cpu(sb, p);
+		write_seqlock(&UFS_I(inode)->meta_lock);
+		ufs_data_ptr_clear(uspi, p);
+		write_sequnlock(&UFS_I(inode)->meta_lock);
+
+		ubh_bforget(ind_ubh);
+		ufs_free_blocks (inode, tmp, uspi->s_fpb);
+		mark_inode_dirty(inode);
+		ind_ubh = NULL;
+	}
+	if (IS_SYNC(inode) && ind_ubh && ubh_buffer_dirty(ind_ubh))
+		ubh_sync_block(ind_ubh);
+	ubh_brelse (ind_ubh);
+
+	UFSD("EXIT: ino %lu\n", inode->i_ino);
+}
+
+static void ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)
+{
+	struct super_block * sb;
+	struct ufs_sb_private_info * uspi;
+	struct ufs_buffer_head *dind_bh;
+	u64 i, tmp, dindirect_block;
+	void *dind;
+
+	UFSD("ENTER: ino %lu\n", inode->i_ino);
+
+	sb = inode->i_sb;
+	uspi = UFS_SB(sb)->s_uspi;
+
+	dindirect_block = (DIRECT_BLOCK > offset)
+		? ((DIRECT_BLOCK - offset) >> uspi->s_apbshift) : 0;
+
+	tmp = ufs_data_ptr_to_cpu(sb, p);
+	if (!tmp)
+		return;
+	dind_bh = ubh_bread(sb, tmp, uspi->s_bsize);
+	if (!dind_bh) {
+		write_seqlock(&UFS_I(inode)->meta_lock);
+		ufs_data_ptr_clear(uspi, p);
+		write_sequnlock(&UFS_I(inode)->meta_lock);
+		return;
+	}
+
+	for (i = dindirect_block ; i < uspi->s_apb ; i++) {
+		dind = ubh_get_data_ptr(uspi, dind_bh, i);
+		tmp = ufs_data_ptr_to_cpu(sb, dind);
+		if (!tmp)
+			continue;
+		ufs_trunc_indirect (inode, offset + (i << uspi->s_apbshift), dind);
+		ubh_mark_buffer_dirty(dind_bh);
+	}
+
+	for (i = 0; i < uspi->s_apb; i++)
+		if (!ufs_is_data_ptr_zero(uspi,
+					  ubh_get_data_ptr(uspi, dind_bh, i)))
+			break;
+	if (i >= uspi->s_apb) {
+		tmp = ufs_data_ptr_to_cpu(sb, p);
+		write_seqlock(&UFS_I(inode)->meta_lock);
+		ufs_data_ptr_clear(uspi, p);
+		write_sequnlock(&UFS_I(inode)->meta_lock);
+
+		ubh_bforget(dind_bh);
+		ufs_free_blocks(inode, tmp, uspi->s_fpb);
+		mark_inode_dirty(inode);
+		dind_bh = NULL;
+	}
+	if (IS_SYNC(inode) && dind_bh && ubh_buffer_dirty(dind_bh))
+		ubh_sync_block(dind_bh);
+	ubh_brelse (dind_bh);
+
+	UFSD("EXIT: ino %lu\n", inode->i_ino);
+}
+
+static void ufs_trunc_tindirect(struct inode *inode)
+{
+	struct super_block *sb = inode->i_sb;
+	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
+	struct ufs_inode_info *ufsi = UFS_I(inode);
+	struct ufs_buffer_head * tind_bh;
+	u64 tindirect_block, tmp, i;
+	void *tind, *p;
+
+	UFSD("ENTER: ino %lu\n", inode->i_ino);
+
+	tindirect_block = (DIRECT_BLOCK > (UFS_NDADDR + uspi->s_apb + uspi->s_2apb))
+		? ((DIRECT_BLOCK - UFS_NDADDR - uspi->s_apb - uspi->s_2apb) >> uspi->s_2apbshift) : 0;
+
+	p = ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK);
+	if (!(tmp = ufs_data_ptr_to_cpu(sb, p)))
+		return;
+	tind_bh = ubh_bread (sb, tmp, uspi->s_bsize);
+	if (!tind_bh) {
+		write_seqlock(&ufsi->meta_lock);
+		ufs_data_ptr_clear(uspi, p);
+		write_sequnlock(&ufsi->meta_lock);
+		return;
+	}
+
+	for (i = tindirect_block ; i < uspi->s_apb ; i++) {
+		tind = ubh_get_data_ptr(uspi, tind_bh, i);
+		ufs_trunc_dindirect(inode, UFS_NDADDR +
+			uspi->s_apb + ((i + 1) << uspi->s_2apbshift), tind);
+		ubh_mark_buffer_dirty(tind_bh);
+	}
+	for (i = 0; i < uspi->s_apb; i++)
+		if (!ufs_is_data_ptr_zero(uspi,
+					  ubh_get_data_ptr(uspi, tind_bh, i)))
+			break;
+	if (i >= uspi->s_apb) {
+		tmp = ufs_data_ptr_to_cpu(sb, p);
+		write_seqlock(&ufsi->meta_lock);
+		ufs_data_ptr_clear(uspi, p);
+		write_sequnlock(&ufsi->meta_lock);
+
+		ubh_bforget(tind_bh);
+		ufs_free_blocks(inode, tmp, uspi->s_fpb);
+		mark_inode_dirty(inode);
+		tind_bh = NULL;
+	}
+	if (IS_SYNC(inode) && tind_bh && ubh_buffer_dirty(tind_bh))
+		ubh_sync_block(tind_bh);
+	ubh_brelse (tind_bh);
+
+	UFSD("EXIT: ino %lu\n", inode->i_ino);
+}
+
+static int ufs_alloc_lastblock(struct inode *inode, loff_t size)
+{
+	int err = 0;
+	struct super_block *sb = inode->i_sb;
+	struct address_space *mapping = inode->i_mapping;
+	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
+	unsigned i, end;
+	sector_t lastfrag;
+	struct page *lastpage;
+	struct buffer_head *bh;
+	u64 phys64;
+
+	lastfrag = (size + uspi->s_fsize - 1) >> uspi->s_fshift;
+
+	if (!lastfrag)
+		goto out;
+
+	lastfrag--;
+
+	lastpage = ufs_get_locked_page(mapping, lastfrag >>
+				       (PAGE_CACHE_SHIFT - inode->i_blkbits));
+       if (IS_ERR(lastpage)) {
+               err = -EIO;
+               goto out;
+       }
+
+       end = lastfrag & ((1 << (PAGE_CACHE_SHIFT - inode->i_blkbits)) - 1);
+       bh = page_buffers(lastpage);
+       for (i = 0; i < end; ++i)
+               bh = bh->b_this_page;
+
+
+       err = ufs_getfrag_block(inode, lastfrag, bh, 1);
+
+       if (unlikely(err))
+	       goto out_unlock;
+
+       if (buffer_new(bh)) {
+	       clear_buffer_new(bh);
+	       unmap_underlying_metadata(bh->b_bdev,
+					 bh->b_blocknr);
+	       /*
+		* we do not zeroize fragment, because of
+		* if it maped to hole, it already contains zeroes
+		*/
+	       set_buffer_uptodate(bh);
+	       mark_buffer_dirty(bh);
+	       set_page_dirty(lastpage);
+       }
+
+       if (lastfrag >= UFS_IND_FRAGMENT) {
+	       end = uspi->s_fpb - ufs_fragnum(lastfrag) - 1;
+	       phys64 = bh->b_blocknr + 1;
+	       for (i = 0; i < end; ++i) {
+		       bh = sb_getblk(sb, i + phys64);
+		       lock_buffer(bh);
+		       memset(bh->b_data, 0, sb->s_blocksize);
+		       set_buffer_uptodate(bh);
+		       mark_buffer_dirty(bh);
+		       unlock_buffer(bh);
+		       sync_dirty_buffer(bh);
+		       brelse(bh);
+	       }
+       }
+out_unlock:
+       ufs_put_locked_page(lastpage);
+out:
+       return err;
+}
+
+static void __ufs_truncate_blocks(struct inode *inode)
+{
+	struct ufs_inode_info *ufsi = UFS_I(inode);
+	struct super_block *sb = inode->i_sb;
+	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
+
+	mutex_lock(&ufsi->truncate_mutex);
+	ufs_trunc_direct(inode);
+	ufs_trunc_indirect(inode, UFS_IND_BLOCK,
+			   ufs_get_direct_data_ptr(uspi, ufsi, UFS_IND_BLOCK));
+	ufs_trunc_dindirect(inode, UFS_IND_BLOCK + uspi->s_apb,
+			    ufs_get_direct_data_ptr(uspi, ufsi, UFS_DIND_BLOCK));
+	ufs_trunc_tindirect(inode);
+	ufsi->i_lastfrag = DIRECT_FRAGMENT;
+	mutex_unlock(&ufsi->truncate_mutex);
+}
+
+static int ufs_truncate(struct inode *inode, loff_t size)
+{
+	int err = 0;
+
+	UFSD("ENTER: ino %lu, i_size: %llu, old_i_size: %llu\n",
+	     inode->i_ino, (unsigned long long)size,
+	     (unsigned long long)i_size_read(inode));
+
+	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
+	      S_ISLNK(inode->i_mode)))
+		return -EINVAL;
+	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+		return -EPERM;
+
+	err = ufs_alloc_lastblock(inode, size);
+
+	if (err)
+		goto out;
+
+	block_truncate_page(inode->i_mapping, size, ufs_getfrag_block);
+
+	truncate_setsize(inode, size);
+
+	__ufs_truncate_blocks(inode);
+	inode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;
+	mark_inode_dirty(inode);
+out:
+	UFSD("EXIT: err %d\n", err);
+	return err;
+}
+
+void ufs_truncate_blocks(struct inode *inode)
+{
+	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
+	      S_ISLNK(inode->i_mode)))
+		return;
+	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+		return;
+	__ufs_truncate_blocks(inode);
+}
+
+int ufs_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	struct inode *inode = d_inode(dentry);
+	unsigned int ia_valid = attr->ia_valid;
+	int error;
+
+	error = inode_change_ok(inode, attr);
+	if (error)
+		return error;
+
+	if (ia_valid & ATTR_SIZE && attr->ia_size != inode->i_size) {
+		error = ufs_truncate(inode, attr->ia_size);
+		if (error)
+			return error;
+	}
+
+	setattr_copy(inode, attr);
+	mark_inode_dirty(inode);
+	return 0;
+}
+
+const struct inode_operations ufs_file_inode_operations = {
+	.setattr = ufs_setattr,
+};

commit 724bb09fdc06d4ff03757b25d6dba9ef1b133e8f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jun 17 12:02:56 2015 -0400

    ufs: don't use lock_ufs() for block pointers tree protection
    
    * stores to block pointers are under per-inode seqlock (meta_lock) and
    mutex (truncate_mutex)
    * fetches of block pointers are either under truncate_mutex, or wrapped
    into seqretry loop on meta_lock
    * all changes of ->i_size are under truncate_mutex and i_mutex
    * all changes of ->i_lastfrag are under truncate_mutex
    
    It's similar to what ext2 is doing; the main difference is that unlike
    ext2 we can't rely upon the atomicity of stores into block pointers -
    on UFS2 they are 64bit.  So we can't cut the corner when switching
    a pointer from NULL to non-NULL as we could in ext2_splice_branch()
    and need to use meta_lock on all modifications.
    
    We use seqlock where ext2 uses rwlock; ext2 could probably also benefit
    from such change...
    
    Another non-trivial difference is that with UFS we *cannot* have reader
    grab truncate_mutex in case of race - it has to keep retrying.  That
    might be possible to change, but not until we lift tail unpacking
    several levels up in call chain.
    
    After that commit we do *NOT* hold fs-wide serialization on accesses
    to block pointers anymore.  Moreover, lock_ufs() can become a normal
    mutex now - it's only used on statfs, remount and sync_fs and none
    of those uses are recursive.  As the matter of fact, *now* it can be
    collapsed with ->s_lock, and be eventually replaced with saner
    per-cylinder-group spinlocks, but that's a separate story.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index a4fc3adfdc4c..100f93c6b309 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -41,8 +41,6 @@
 #include "swab.h"
 #include "util.h"
 
-static u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock);
-
 static int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t offsets[4])
 {
 	struct ufs_sb_private_info *uspi = UFS_SB(inode->i_sb)->s_uspi;
@@ -75,12 +73,53 @@ static int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t off
 	return n;
 }
 
+typedef struct {
+	void	*p;
+	union {
+		__fs32	key32;
+		__fs64	key64;
+	};
+	struct buffer_head *bh;
+} Indirect;
+
+static inline int grow_chain32(struct ufs_inode_info *ufsi,
+			       struct buffer_head *bh, __fs32 *v,
+			       Indirect *from, Indirect *to)
+{
+	Indirect *p;
+	unsigned seq;
+	to->bh = bh;
+	do {
+		seq = read_seqbegin(&ufsi->meta_lock);
+		to->key32 = *(__fs32 *)(to->p = v);
+		for (p = from; p <= to && p->key32 == *(__fs32 *)p->p; p++)
+			;
+	} while (read_seqretry(&ufsi->meta_lock, seq));
+	return (p > to);
+}
+
+static inline int grow_chain64(struct ufs_inode_info *ufsi,
+			       struct buffer_head *bh, __fs64 *v,
+			       Indirect *from, Indirect *to)
+{
+	Indirect *p;
+	unsigned seq;
+	to->bh = bh;
+	do {
+		seq = read_seqbegin(&ufsi->meta_lock);
+		to->key64 = *(__fs64 *)(to->p = v);
+		for (p = from; p <= to && p->key64 == *(__fs64 *)p->p; p++)
+			;
+	} while (read_seqretry(&ufsi->meta_lock, seq));
+	return (p > to);
+}
+
 /*
  * Returns the location of the fragment from
  * the beginning of the filesystem.
  */
 
-static u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock)
+static u64 ufs_frag_map(struct inode *inode, sector_t frag)
 {
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
@@ -88,12 +127,10 @@ static u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock)
 	u64 mask = (u64) uspi->s_apbmask>>uspi->s_fpbshift;
 	int shift = uspi->s_apbshift-uspi->s_fpbshift;
 	sector_t offsets[4], *p;
+	Indirect chain[4], *q = chain;
 	int depth = ufs_block_to_path(inode, frag >> uspi->s_fpbshift, offsets);
-	u64  ret = 0L;
-	__fs32 block;
-	__fs64 u2_block = 0L;
 	unsigned flags = UFS_SB(sb)->s_flags;
-	u64 temp = 0L;
+	u64 res = 0;
 
 	UFSD(": frag = %llu  depth = %d\n", (unsigned long long)frag, depth);
 	UFSD(": uspi->s_fpbshift = %d ,uspi->s_apbmask = %x, mask=%llx\n",
@@ -101,59 +138,73 @@ static u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock)
 		(unsigned long long)mask);
 
 	if (depth == 0)
-		return 0;
+		goto no_block;
 
+again:
 	p = offsets;
 
-	if (needs_lock)
-		lock_ufs(sb);
 	if ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)
 		goto ufs2;
 
-	block = ufsi->i_u1.i_data[*p++];
-	if (!block)
-		goto out;
+	if (!grow_chain32(ufsi, NULL, &ufsi->i_u1.i_data[*p++], chain, q))
+		goto changed;
+	if (!q->key32)
+		goto no_block;
 	while (--depth) {
+		__fs32 *ptr;
 		struct buffer_head *bh;
 		sector_t n = *p++;
 
-		bh = sb_bread(sb, uspi->s_sbbase + fs32_to_cpu(sb, block)+(n>>shift));
+		bh = sb_bread(sb, uspi->s_sbbase +
+				  fs32_to_cpu(sb, q->key32) + (n>>shift));
 		if (!bh)
-			goto out;
-		block = ((__fs32 *) bh->b_data)[n & mask];
-		brelse (bh);
-		if (!block)
-			goto out;
+			goto no_block;
+		ptr = (__fs32 *)bh->b_data + (n & mask);
+		if (!grow_chain32(ufsi, bh, ptr, chain, ++q))
+			goto changed;
+		if (!q->key32)
+			goto no_block;
 	}
-	ret = (u64) (uspi->s_sbbase + fs32_to_cpu(sb, block) + (frag & uspi->s_fpbmask));
-	goto out;
-ufs2:
-	u2_block = ufsi->i_u1.u2_i_data[*p++];
-	if (!u2_block)
-		goto out;
+	res = fs32_to_cpu(sb, q->key32);
+	goto found;
 
+ufs2:
+	if (!grow_chain64(ufsi, NULL, &ufsi->i_u1.u2_i_data[*p++], chain, q))
+		goto changed;
+	if (!q->key64)
+		goto no_block;
 
 	while (--depth) {
+		__fs64 *ptr;
 		struct buffer_head *bh;
 		sector_t n = *p++;
 
-
-		temp = (u64)(uspi->s_sbbase) + fs64_to_cpu(sb, u2_block);
-		bh = sb_bread(sb, temp +(u64) (n>>shift));
+		bh = sb_bread(sb, uspi->s_sbbase +
+				  fs64_to_cpu(sb, q->key64) + (n>>shift));
 		if (!bh)
-			goto out;
-		u2_block = ((__fs64 *)bh->b_data)[n & mask];
-		brelse(bh);
-		if (!u2_block)
-			goto out;
+			goto no_block;
+		ptr = (__fs64 *)bh->b_data + (n & mask);
+		if (!grow_chain64(ufsi, bh, ptr, chain, ++q))
+			goto changed;
+		if (!q->key64)
+			goto no_block;
+	}
+	res = fs64_to_cpu(sb, q->key64);
+found:
+	res += uspi->s_sbbase + (frag & uspi->s_fpbmask);
+no_block:
+	while (q > chain) {
+		brelse(q->bh);
+		q--;
 	}
-	temp = (u64)uspi->s_sbbase + fs64_to_cpu(sb, u2_block);
-	ret = temp + (u64) (frag & uspi->s_fpbmask);
+	return res;
 
-out:
-	if (needs_lock)
-		unlock_ufs(sb);
-	return ret;
+changed:
+	while (q > chain) {
+		brelse(q->bh);
+		q--;
+	}
+	goto again;
 }
 
 /**
@@ -421,10 +472,9 @@ int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head
 	int ret, err, new;
 	unsigned long ptr,phys;
 	u64 phys64 = 0;
-	bool needs_lock = (sbi->mutex_owner != current);
 	
 	if (!create) {
-		phys64 = ufs_frag_map(inode, fragment, needs_lock);
+		phys64 = ufs_frag_map(inode, fragment);
 		UFSD("phys64 = %llu\n", (unsigned long long)phys64);
 		if (phys64)
 			map_bh(bh_result, sb, phys64);
@@ -438,8 +488,7 @@ int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head
 	ret = 0;
 	bh = NULL;
 
-	if (needs_lock)
-		lock_ufs(sb);
+	mutex_lock(&UFS_I(inode)->truncate_mutex);
 
 	UFSD("ENTER, ino %lu, fragment %llu\n", inode->i_ino, (unsigned long long)fragment);
 	if (fragment >
@@ -501,8 +550,7 @@ int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head
 		set_buffer_new(bh_result);
 	map_bh(bh_result, sb, phys);
 abort:
-	if (needs_lock)
-		unlock_ufs(sb);
+	mutex_unlock(&UFS_I(inode)->truncate_mutex);
 
 	return err;
 

commit 3b7a3a05e8b006a73c406230b3d2d3da920779d9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jun 16 18:06:40 2015 -0400

    ufs: free excessive blocks upon ->write_begin() failure/short copy
    
    Broken in "[PATCH] ufs: truncate should allocate block for last byte";
    all way back in 2006.  ufs_setattr() hadn't been the only user of
    vmtruncate() and eliminating ->truncate() method required corrections
    in a bunch of places.  Eventually those places had migrated into
    ->write_begin() failure exit and ->write_end() after short copy...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 282b0ced6272..a4fc3adfdc4c 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -530,8 +530,10 @@ static void ufs_write_failed(struct address_space *mapping, loff_t to)
 {
 	struct inode *inode = mapping->host;
 
-	if (to > inode->i_size)
+	if (to > inode->i_size) {
 		truncate_pagecache(inode, inode->i_size);
+		ufs_truncate_blocks(inode);
+	}
 }
 
 static int ufs_write_begin(struct file *file, struct address_space *mapping,
@@ -548,6 +550,18 @@ static int ufs_write_begin(struct file *file, struct address_space *mapping,
 	return ret;
 }
 
+static int ufs_write_end(struct file *file, struct address_space *mapping,
+			loff_t pos, unsigned len, unsigned copied,
+			struct page *page, void *fsdata)
+{
+	int ret;
+
+	ret = generic_write_end(file, mapping, pos, len, copied, page, fsdata);
+	if (ret < len)
+		ufs_write_failed(mapping, pos + len);
+	return ret;
+}
+
 static sector_t ufs_bmap(struct address_space *mapping, sector_t block)
 {
 	return generic_block_bmap(mapping,block,ufs_getfrag_block);
@@ -557,7 +571,7 @@ const struct address_space_operations ufs_aops = {
 	.readpage = ufs_readpage,
 	.writepage = ufs_writepage,
 	.write_begin = ufs_write_begin,
-	.write_end = generic_write_end,
+	.write_end = ufs_write_end,
 	.bmap = ufs_bmap
 };
 

commit d622f167b8435c856376edec130053fb56bf83e4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jun 16 18:04:16 2015 -0400

    ufs: switch ufs_evict_inode() to trimmed-down variant of ufs_truncate()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 0e4d88e0e709..282b0ced6272 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -884,14 +884,9 @@ void ufs_evict_inode(struct inode * inode)
 
 	truncate_inode_pages_final(&inode->i_data);
 	if (want_delete) {
-		loff_t old_i_size;
-		/*UFS_I(inode)->i_dtime = CURRENT_TIME;*/
-		mark_inode_dirty(inode);
-		ufs_update_inode(inode, IS_SYNC(inode));
-		old_i_size = inode->i_size;
 		inode->i_size = 0;
-		if (inode->i_blocks && ufs_truncate(inode, old_i_size))
-			ufs_warning(inode->i_sb, __func__, "ufs_truncate failed\n");
+		if (inode->i_blocks)
+			ufs_truncate_blocks(inode);
 	}
 
 	invalidate_inode_buffers(inode);

commit f3e0f3da1b65e84ea82176c1cda03a4b694c9911
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jun 16 02:35:14 2015 -0400

    ufs: kill more lock_ufs() calls
    
    a) move it inside ufs_truncate()
    b) ufs_free_inode() doesn't need it - it's serialized on ->s_lock
    c) ufs_write_inode() doesn't need it either (and can be called without
    it anyway).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index f913a6924b23..0e4d88e0e709 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -867,11 +867,7 @@ static int ufs_update_inode(struct inode * inode, int do_sync)
 
 int ufs_write_inode(struct inode *inode, struct writeback_control *wbc)
 {
-	int ret;
-	lock_ufs(inode->i_sb);
-	ret = ufs_update_inode(inode, wbc->sync_mode == WB_SYNC_ALL);
-	unlock_ufs(inode->i_sb);
-	return ret;
+	return ufs_update_inode(inode, wbc->sync_mode == WB_SYNC_ALL);
 }
 
 int ufs_sync_inode (struct inode *inode)
@@ -890,22 +886,17 @@ void ufs_evict_inode(struct inode * inode)
 	if (want_delete) {
 		loff_t old_i_size;
 		/*UFS_I(inode)->i_dtime = CURRENT_TIME;*/
-		lock_ufs(inode->i_sb);
 		mark_inode_dirty(inode);
 		ufs_update_inode(inode, IS_SYNC(inode));
 		old_i_size = inode->i_size;
 		inode->i_size = 0;
 		if (inode->i_blocks && ufs_truncate(inode, old_i_size))
 			ufs_warning(inode->i_sb, __func__, "ufs_truncate failed\n");
-		unlock_ufs(inode->i_sb);
 	}
 
 	invalidate_inode_buffers(inode);
 	clear_inode(inode);
 
-	if (want_delete) {
-		lock_ufs(inode->i_sb);
+	if (want_delete)
 		ufs_free_inode(inode);
-		unlock_ufs(inode->i_sb);
-	}
 }

commit 4ef51e8b7aaa67493ad5b36a0e5874bf6ff8b956
Merge: b853a16176cf e4f95517f182
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jun 17 14:44:05 2015 -0400

    Merge branch 'for-linus' into for-next

commit 13b987ea275840d74d9df9a44326632fab1894da
Author: Fabian Frederick <fabf@skynet.be>
Date:   Wed Jun 10 10:09:32 2015 +1000

    fs/ufs: revert "ufs: fix deadlocks introduced by sb mutex merge"
    
    This reverts commit 9ef7db7f38d0 ("ufs: fix deadlocks introduced by sb
    mutex merge") That patch tried to solve commit 0244756edc4b98c ("ufs: sb
    mutex merge + mutex_destroy") which is itself partially reverted due to
    multiple deadlocks.
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Suggested-by: Jan Kara <jack@suse.cz>
    Cc: Ian Campbell <ian.campbell@citrix.com>
    Cc: Evgeniy Dushistov <dushistov@mail.ru>
    Cc: Alexey Khoroshilov <khoroshilov@ispras.ru>
    Cc: Roger Pau Monne <roger.pau@citrix.com>
    Cc: Ian Jackson <Ian.Jackson@eu.citrix.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index be7d42c7d938..2d93ab07da8a 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -902,6 +902,9 @@ void ufs_evict_inode(struct inode * inode)
 	invalidate_inode_buffers(inode);
 	clear_inode(inode);
 
-	if (want_delete)
+	if (want_delete) {
+		lock_ufs(inode->i_sb);
 		ufs_free_inode(inode);
+		unlock_ufs(inode->i_sb);
+	}
 }

commit 4b8061a67f67ebd28d4273b05d1b6ae38f2a019b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat May 2 10:28:56 2015 -0400

    ufs: switch to simple_follow_link()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index be7d42c7d938..99aaf5c9bf4d 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -572,9 +572,10 @@ static void ufs_set_inode_ops(struct inode *inode)
 		inode->i_fop = &ufs_dir_operations;
 		inode->i_mapping->a_ops = &ufs_aops;
 	} else if (S_ISLNK(inode->i_mode)) {
-		if (!inode->i_blocks)
+		if (!inode->i_blocks) {
 			inode->i_op = &ufs_fast_symlink_inode_operations;
-		else {
+			inode->i_link = (char *)UFS_I(inode)->i_u1.i_symlink;
+		} else {
 			inode->i_op = &ufs_symlink_inode_operations;
 			inode->i_mapping->a_ops = &ufs_aops;
 		}

commit 9ef7db7f38d0472dd9c444e42d5c5175ccbe5451
Author: Alexey Khoroshilov <khoroshilov@ispras.ru>
Date:   Tue Sep 2 11:40:17 2014 +0400

    ufs: fix deadlocks introduced by sb mutex merge
    
    Commit 0244756edc4b ("ufs: sb mutex merge + mutex_destroy") introduces
    deadlocks in ufs_new_inode() and ufs_free_inode().
    Most callers of that functions acqure the mutex by themselves and
    ufs_{new,free}_inode() do that via lock_ufs(),
    i.e we have an unavoidable double lock.
    
    The patch proposes to resolve the issue by making sure that
    ufs_{new,free}_inode() are not called with the mutex held.
    
    Found by Linux Driver Verification project (linuxtesting.org).
    
    Cc: stable@vger.kernel.org # 3.16
    Signed-off-by: Alexey Khoroshilov <khoroshilov@ispras.ru>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 7c580c97990e..be7d42c7d938 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -902,9 +902,6 @@ void ufs_evict_inode(struct inode * inode)
 	invalidate_inode_buffers(inode);
 	clear_inode(inode);
 
-	if (want_delete) {
-		lock_ufs(inode->i_sb);
-		ufs_free_inode (inode);
-		unlock_ufs(inode->i_sb);
-	}
+	if (want_delete)
+		ufs_free_inode(inode);
 }

commit edc023caf407b74ee2eb56dda23437c5836655f3
Author: Fabian Frederick <fabf@skynet.be>
Date:   Fri Aug 8 14:21:08 2014 -0700

    fs/ufs/inode.c: kernel-doc warning fixes
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 61e8a9b021dd..7c580c97990e 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -158,16 +158,16 @@ static u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock)
 
 /**
  * ufs_inode_getfrag() - allocate new fragment(s)
- * @inode - pointer to inode
- * @fragment - number of `fragment' which hold pointer
+ * @inode: pointer to inode
+ * @fragment: number of `fragment' which hold pointer
  *   to new allocated fragment(s)
- * @new_fragment - number of new allocated fragment(s)
- * @required - how many fragment(s) we require
- * @err - we set it if something wrong
- * @phys - pointer to where we save physical number of new allocated fragments,
+ * @new_fragment: number of new allocated fragment(s)
+ * @required: how many fragment(s) we require
+ * @err: we set it if something wrong
+ * @phys: pointer to where we save physical number of new allocated fragments,
  *   NULL if we allocate not data(indirect blocks for example).
- * @new - we set it if we allocate new block
- * @locked_page - for ufs_new_fragments()
+ * @new: we set it if we allocate new block
+ * @locked_page: for ufs_new_fragments()
  */
 static struct buffer_head *
 ufs_inode_getfrag(struct inode *inode, u64 fragment,
@@ -315,16 +315,16 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 
 /**
  * ufs_inode_getblock() - allocate new block
- * @inode - pointer to inode
- * @bh - pointer to block which hold "pointer" to new allocated block
- * @fragment - number of `fragment' which hold pointer
+ * @inode: pointer to inode
+ * @bh: pointer to block which hold "pointer" to new allocated block
+ * @fragment: number of `fragment' which hold pointer
  *   to new allocated block
- * @new_fragment - number of new allocated fragment
+ * @new_fragment: number of new allocated fragment
  *  (block will hold this fragment and also uspi->s_fpb-1)
- * @err - see ufs_inode_getfrag()
- * @phys - see ufs_inode_getfrag()
- * @new - see ufs_inode_getfrag()
- * @locked_page - see ufs_inode_getfrag()
+ * @err: see ufs_inode_getfrag()
+ * @phys: see ufs_inode_getfrag()
+ * @new: see ufs_inode_getfrag()
+ * @locked_page: see ufs_inode_getfrag()
  */
 static struct buffer_head *
 ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,

commit 91b0abe36a7b2b3b02d7500925a5f8455334f0e5
Author: Johannes Weiner <hannes@cmpxchg.org>
Date:   Thu Apr 3 14:47:49 2014 -0700

    mm + fs: store shadow entries in page cache
    
    Reclaim will be leaving shadow entries in the page cache radix tree upon
    evicting the real page.  As those pages are found from the LRU, an
    iput() can lead to the inode being freed concurrently.  At this point,
    reclaim must no longer install shadow pages because the inode freeing
    code needs to ensure the page tree is really empty.
    
    Add an address_space flag, AS_EXITING, that the inode freeing code sets
    under the tree lock before doing the final truncate.  Reclaim will check
    for this flag before installing shadow pages.
    
    Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Reviewed-by: Minchan Kim <minchan@kernel.org>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Bob Liu <bob.liu@oracle.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: Luigi Semenzato <semenzato@google.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Metin Doslu <metin@citusdata.com>
    Cc: Michel Lespinasse <walken@google.com>
    Cc: Ozgun Erdogan <ozgun@citusdata.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Roman Gushchin <klamm@yandex-team.ru>
    Cc: Ryan Mallon <rmallon@gmail.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index c8ca96086784..61e8a9b021dd 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -885,7 +885,7 @@ void ufs_evict_inode(struct inode * inode)
 	if (!inode->i_nlink && !is_bad_inode(inode))
 		want_delete = 1;
 
-	truncate_inode_pages(&inode->i_data, 0);
+	truncate_inode_pages_final(&inode->i_data);
 	if (want_delete) {
 		loff_t old_i_size;
 		/*UFS_I(inode)->i_dtime = CURRENT_TIME;*/

commit 7caef26767c1727d7abfbbbfbe8b2bb473430d48
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Thu Sep 12 15:13:56 2013 -0700

    truncate: drop 'oldsize' truncate_pagecache() parameter
    
    truncate_pagecache() doesn't care about old size since commit
    cedabed49b39 ("vfs: Fix vmtruncate() regression").  Let's drop it.
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index ff24e4449ece..c8ca96086784 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -531,7 +531,7 @@ static void ufs_write_failed(struct address_space *mapping, loff_t to)
 	struct inode *inode = mapping->host;
 
 	if (to > inode->i_size)
-		truncate_pagecache(inode, to, inode->i_size);
+		truncate_pagecache(inode, inode->i_size);
 }
 
 static int ufs_write_begin(struct file *file, struct address_space *mapping,

commit 83f6e3710a932d400100767ad445a4bd9476e083
Author: Marco Stornelli <marco.stornelli@gmail.com>
Date:   Sat Dec 15 11:45:14 2012 +0100

    ufs: drop vmtruncate
    
    Removed vmtruncate
    
    Signed-off-by: Marco Stornelli <marco.stornelli@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index eb6d0b7dc879..ff24e4449ece 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -526,6 +526,14 @@ int ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len)
 	return __block_write_begin(page, pos, len, ufs_getfrag_block);
 }
 
+static void ufs_write_failed(struct address_space *mapping, loff_t to)
+{
+	struct inode *inode = mapping->host;
+
+	if (to > inode->i_size)
+		truncate_pagecache(inode, to, inode->i_size);
+}
+
 static int ufs_write_begin(struct file *file, struct address_space *mapping,
 			loff_t pos, unsigned len, unsigned flags,
 			struct page **pagep, void **fsdata)
@@ -534,11 +542,8 @@ static int ufs_write_begin(struct file *file, struct address_space *mapping,
 
 	ret = block_write_begin(mapping, pos, len, flags, pagep,
 				ufs_getfrag_block);
-	if (unlikely(ret)) {
-		loff_t isize = mapping->host->i_size;
-		if (pos + len > isize)
-			vmtruncate(mapping->host, isize);
-	}
+	if (unlikely(ret))
+		ufs_write_failed(mapping, pos + len);
 
 	return ret;
 }

commit 72235465864d84cedb2d9f26f8e1de824ee20339
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Feb 10 12:21:22 2012 -0800

    userns: Convert the ufs filesystem to use kuid/kgid where appropriate
    
    Cc: Evgeniy Dushistov <dushistov@mail.ru>
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index dd7c89d8a1c1..eb6d0b7dc879 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -597,8 +597,8 @@ static int ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 	/*
 	 * Linux now has 32-bit uid and gid, so we can support EFT.
 	 */
-	inode->i_uid = ufs_get_inode_uid(sb, ufs_inode);
-	inode->i_gid = ufs_get_inode_gid(sb, ufs_inode);
+	i_uid_write(inode, ufs_get_inode_uid(sb, ufs_inode));
+	i_gid_write(inode, ufs_get_inode_gid(sb, ufs_inode));
 
 	inode->i_size = fs64_to_cpu(sb, ufs_inode->ui_size);
 	inode->i_atime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_atime.tv_sec);
@@ -645,8 +645,8 @@ static int ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)
         /*
          * Linux now has 32-bit uid and gid, so we can support EFT.
          */
-	inode->i_uid = fs32_to_cpu(sb, ufs2_inode->ui_uid);
-	inode->i_gid = fs32_to_cpu(sb, ufs2_inode->ui_gid);
+	i_uid_write(inode, fs32_to_cpu(sb, ufs2_inode->ui_uid));
+	i_gid_write(inode, fs32_to_cpu(sb, ufs2_inode->ui_gid));
 
 	inode->i_size = fs64_to_cpu(sb, ufs2_inode->ui_size);
 	inode->i_atime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_atime);
@@ -745,8 +745,8 @@ static void ufs1_update_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 	ufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);
 	ufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);
 
-	ufs_set_inode_uid(sb, ufs_inode, inode->i_uid);
-	ufs_set_inode_gid(sb, ufs_inode, inode->i_gid);
+	ufs_set_inode_uid(sb, ufs_inode, i_uid_read(inode));
+	ufs_set_inode_gid(sb, ufs_inode, i_gid_read(inode));
 		
 	ufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);
 	ufs_inode->ui_atime.tv_sec = cpu_to_fs32(sb, inode->i_atime.tv_sec);
@@ -789,8 +789,8 @@ static void ufs2_update_inode(struct inode *inode, struct ufs2_inode *ufs_inode)
 	ufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);
 	ufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);
 
-	ufs_inode->ui_uid = cpu_to_fs32(sb, inode->i_uid);
-	ufs_inode->ui_gid = cpu_to_fs32(sb, inode->i_gid);
+	ufs_inode->ui_uid = cpu_to_fs32(sb, i_uid_read(inode));
+	ufs_inode->ui_gid = cpu_to_fs32(sb, i_gid_read(inode));
 
 	ufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);
 	ufs_inode->ui_atime = cpu_to_fs64(sb, inode->i_atime.tv_sec);

commit dbd5768f87ff6fb0a4fe09c4d7b6c4a24de99430
Author: Jan Kara <jack@suse.cz>
Date:   Thu May 3 14:48:02 2012 +0200

    vfs: Rename end_writeback() to clear_inode()
    
    After we moved inode_sync_wait() from end_writeback() it doesn't make sense
    to call the function end_writeback() anymore. Rename it to clear_inode()
    which well says what the function really does - set I_CLEAR flag.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 7cdd3953d67e..dd7c89d8a1c1 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -895,7 +895,7 @@ void ufs_evict_inode(struct inode * inode)
 	}
 
 	invalidate_inode_buffers(inode);
-	end_writeback(inode);
+	clear_inode(inode);
 
 	if (want_delete) {
 		lock_ufs(inode->i_sb);

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 9094e1d917be..7cdd3953d67e 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -26,7 +26,6 @@
  */
 
 #include <asm/uaccess.h>
-#include <asm/system.h>
 
 #include <linux/errno.h>
 #include <linux/fs.h>

commit 6a9a06d9ca3d307bd83d93e442ad964f5de7ec2c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 26 02:49:13 2011 -0400

    ufs: propagate umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 879b13436fa4..9094e1d917be 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -583,7 +583,7 @@ static int ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 {
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
-	mode_t mode;
+	umode_t mode;
 
 	/*
 	 * Copy data to the in-core inode.
@@ -630,7 +630,7 @@ static int ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)
 {
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
-	mode_t mode;
+	umode_t mode;
 
 	UFSD("Reading ufs2 inode, ino %lu\n", inode->i_ino);
 	/*

commit bfe8684869601dacfcb2cd69ef8cfd9045f62170
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Oct 28 14:13:29 2011 +0200

    filesystems: add set_nlink()
    
    Replace remaining direct i_nlink updates with a new set_nlink()
    updater function.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Tested-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index b4d791a83207..879b13436fa4 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -589,7 +589,7 @@ static int ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 	 * Copy data to the in-core inode.
 	 */
 	inode->i_mode = mode = fs16_to_cpu(sb, ufs_inode->ui_mode);
-	inode->i_nlink = fs16_to_cpu(sb, ufs_inode->ui_nlink);
+	set_nlink(inode, fs16_to_cpu(sb, ufs_inode->ui_nlink));
 	if (inode->i_nlink == 0) {
 		ufs_error (sb, "ufs_read_inode", "inode %lu has zero nlink\n", inode->i_ino);
 		return -1;
@@ -637,7 +637,7 @@ static int ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)
 	 * Copy data to the in-core inode.
 	 */
 	inode->i_mode = mode = fs16_to_cpu(sb, ufs2_inode->ui_mode);
-	inode->i_nlink = fs16_to_cpu(sb, ufs2_inode->ui_nlink);
+	set_nlink(inode, fs16_to_cpu(sb, ufs2_inode->ui_nlink));
 	if (inode->i_nlink == 0) {
 		ufs_error (sb, "ufs_read_inode", "inode %lu has zero nlink\n", inode->i_ino);
 		return -1;

commit 07f9479a40cc778bc1462ada11f95b01360ae4ff
Merge: 9d5e6bdb3013 cd2e49e90f1c
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue Apr 26 10:22:15 2011 +0200

    Merge branch 'master' into for-next
    
    Fast-forwarded to current state of Linus' tree as there are patches to be
    applied for files that didn't exist on the old branch.

commit 7422caa5a1a53ee6b21a687c61cc5435edf8c19f
Author: Alessio Igor Bogani <abogani@kernel.org>
Date:   Fri Apr 8 19:33:07 2011 +0200

    ufs: Fix a typo
    
    Signed-off-by: Alessio Igor Bogani <abogani@kernel.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 03c255f12df5..6863599f7033 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -409,7 +409,7 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 }
 
 /**
- * ufs_getfrag_bloc() - `get_block_t' function, interface between UFS and
+ * ufs_getfrag_block() - `get_block_t' function, interface between UFS and
  * readpage, writepage and so on
  */
 

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 27a4babe7df0..e765743cf9f3 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -78,7 +78,7 @@ static int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t off
 
 /*
  * Returns the location of the fragment from
- * the begining of the filesystem.
+ * the beginning of the filesystem.
  */
 
 static u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock)

commit 6c5103890057b1bb781b26b7aae38d33e4c517d8
Merge: 3dab04e6978e 9d2e157d970a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 24 10:16:26 2011 -0700

    Merge branch 'for-2.6.39/core' of git://git.kernel.dk/linux-2.6-block
    
    * 'for-2.6.39/core' of git://git.kernel.dk/linux-2.6-block: (65 commits)
      Documentation/iostats.txt: bit-size reference etc.
      cfq-iosched: removing unnecessary think time checking
      cfq-iosched: Don't clear queue stats when preempt.
      blk-throttle: Reset group slice when limits are changed
      blk-cgroup: Only give unaccounted_time under debug
      cfq-iosched: Don't set active queue in preempt
      block: fix non-atomic access to genhd inflight structures
      block: attempt to merge with existing requests on plug flush
      block: NULL dereference on error path in __blkdev_get()
      cfq-iosched: Don't update group weights when on service tree
      fs: assign sb->s_bdi to default_backing_dev_info if the bdi is going away
      block: Require subsystems to explicitly allocate bio_set integrity mempool
      jbd2: finish conversion from WRITE_SYNC_PLUG to WRITE_SYNC and explicit plugging
      jbd: finish conversion from WRITE_SYNC_PLUG to WRITE_SYNC and explicit plugging
      fs: make fsync_buffers_list() plug
      mm: make generic_writepages() use plugging
      blk-cgroup: Add unaccounted time to timeslice_used.
      block: fixup plugging stubs for !CONFIG_BLOCK
      block: remove obsolete comments for blkdev_issue_zeroout.
      blktrace: Use rq->cmd_flags directly in blk_add_trace_rq.
      ...
    
    Fix up conflicts in fs/{aio.c,super.c}

commit 7eaceaccab5f40bbfda044629a6298616aeaed50
Author: Jens Axboe <jaxboe@fusionio.com>
Date:   Thu Mar 10 08:52:07 2011 +0100

    block: remove per-queue plugging
    
    Code has been converted over to the new explicit on-stack plugging,
    and delay users have been converted to use the new API for that.
    So lets kill off the old plugging along with aops->sync_page().
    
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 2b251f2093af..83b28444eb17 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -588,7 +588,6 @@ static sector_t ufs_bmap(struct address_space *mapping, sector_t block)
 const struct address_space_operations ufs_aops = {
 	.readpage = ufs_readpage,
 	.writepage = ufs_writepage,
-	.sync_page = block_sync_page,
 	.write_begin = ufs_write_begin,
 	.write_end = generic_write_end,
 	.bmap = ufs_bmap

commit 788257d6101d986ac8f2741aaa35974af47f574c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jan 24 10:14:12 2011 +0100

    ufs: remove the BKL
    
    This introduces a new per-superblock mutex in UFS to replace
    the big kernel lock. I have been careful to avoid nested
    calls to lock_ufs and to get the lock order right with
    respect to other mutexes, in particular lock_super.
    
    I did not make any attempt to prove that the big kernel
    lock is not needed in a particular place in the code,
    which is very possible.
    
    The mutex has a significant performance impact, so it is only
    used on SMP or PREEMPT configurations.
    
    As Nick Piggin noticed, any allocation inside of the lock
    may end up deadlocking when we get to ufs_getfrag_block
    in the reclaim task, so we now use GFP_NOFS.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Nick Bowler <nbowler@elliptictech.com>
    Cc: Evgeniy Dushistov <dushistov@mail.ru>
    Cc: Nick Piggin <npiggin@gmail.com>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 2b251f2093af..03c255f12df5 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -34,7 +34,6 @@
 #include <linux/stat.h>
 #include <linux/string.h>
 #include <linux/mm.h>
-#include <linux/smp_lock.h>
 #include <linux/buffer_head.h>
 #include <linux/writeback.h>
 
@@ -43,7 +42,7 @@
 #include "swab.h"
 #include "util.h"
 
-static u64 ufs_frag_map(struct inode *inode, sector_t frag);
+static u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock);
 
 static int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t offsets[4])
 {
@@ -82,7 +81,7 @@ static int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t off
  * the begining of the filesystem.
  */
 
-static u64 ufs_frag_map(struct inode *inode, sector_t frag)
+static u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock)
 {
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
@@ -107,7 +106,8 @@ static u64 ufs_frag_map(struct inode *inode, sector_t frag)
 
 	p = offsets;
 
-	lock_kernel();
+	if (needs_lock)
+		lock_ufs(sb);
 	if ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)
 		goto ufs2;
 
@@ -152,7 +152,8 @@ static u64 ufs_frag_map(struct inode *inode, sector_t frag)
 	ret = temp + (u64) (frag & uspi->s_fpbmask);
 
 out:
-	unlock_kernel();
+	if (needs_lock)
+		unlock_ufs(sb);
 	return ret;
 }
 
@@ -415,14 +416,16 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head *bh_result, int create)
 {
 	struct super_block * sb = inode->i_sb;
-	struct ufs_sb_private_info * uspi = UFS_SB(sb)->s_uspi;
+	struct ufs_sb_info * sbi = UFS_SB(sb);
+	struct ufs_sb_private_info * uspi = sbi->s_uspi;
 	struct buffer_head * bh;
 	int ret, err, new;
 	unsigned long ptr,phys;
 	u64 phys64 = 0;
+	bool needs_lock = (sbi->mutex_owner != current);
 	
 	if (!create) {
-		phys64 = ufs_frag_map(inode, fragment);
+		phys64 = ufs_frag_map(inode, fragment, needs_lock);
 		UFSD("phys64 = %llu\n", (unsigned long long)phys64);
 		if (phys64)
 			map_bh(bh_result, sb, phys64);
@@ -436,7 +439,8 @@ int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head
 	ret = 0;
 	bh = NULL;
 
-	lock_kernel();
+	if (needs_lock)
+		lock_ufs(sb);
 
 	UFSD("ENTER, ino %lu, fragment %llu\n", inode->i_ino, (unsigned long long)fragment);
 	if (fragment >
@@ -498,7 +502,9 @@ int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head
 		set_buffer_new(bh_result);
 	map_bh(bh_result, sb, phys);
 abort:
-	unlock_kernel();
+	if (needs_lock)
+		unlock_ufs(sb);
+
 	return err;
 
 abort_too_big:
@@ -506,48 +512,6 @@ int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head
 	goto abort;
 }
 
-static struct buffer_head *ufs_getfrag(struct inode *inode,
-				       unsigned int fragment,
-				       int create, int *err)
-{
-	struct buffer_head dummy;
-	int error;
-
-	dummy.b_state = 0;
-	dummy.b_blocknr = -1000;
-	error = ufs_getfrag_block(inode, fragment, &dummy, create);
-	*err = error;
-	if (!error && buffer_mapped(&dummy)) {
-		struct buffer_head *bh;
-		bh = sb_getblk(inode->i_sb, dummy.b_blocknr);
-		if (buffer_new(&dummy)) {
-			memset(bh->b_data, 0, inode->i_sb->s_blocksize);
-			set_buffer_uptodate(bh);
-			mark_buffer_dirty(bh);
-		}
-		return bh;
-	}
-	return NULL;
-}
-
-struct buffer_head * ufs_bread (struct inode * inode, unsigned fragment,
-	int create, int * err)
-{
-	struct buffer_head * bh;
-
-	UFSD("ENTER, ino %lu, fragment %u\n", inode->i_ino, fragment);
-	bh = ufs_getfrag (inode, fragment, create, err);
-	if (!bh || buffer_uptodate(bh)) 		
-		return bh;
-	ll_rw_block (READ, 1, &bh);
-	wait_on_buffer (bh);
-	if (buffer_uptodate(bh))
-		return bh;
-	brelse (bh);
-	*err = -EIO;
-	return NULL;
-}
-
 static int ufs_writepage(struct page *page, struct writeback_control *wbc)
 {
 	return block_write_full_page(page,ufs_getfrag_block,wbc);
@@ -900,9 +864,9 @@ static int ufs_update_inode(struct inode * inode, int do_sync)
 int ufs_write_inode(struct inode *inode, struct writeback_control *wbc)
 {
 	int ret;
-	lock_kernel();
+	lock_ufs(inode->i_sb);
 	ret = ufs_update_inode(inode, wbc->sync_mode == WB_SYNC_ALL);
-	unlock_kernel();
+	unlock_ufs(inode->i_sb);
 	return ret;
 }
 
@@ -922,22 +886,22 @@ void ufs_evict_inode(struct inode * inode)
 	if (want_delete) {
 		loff_t old_i_size;
 		/*UFS_I(inode)->i_dtime = CURRENT_TIME;*/
-		lock_kernel();
+		lock_ufs(inode->i_sb);
 		mark_inode_dirty(inode);
 		ufs_update_inode(inode, IS_SYNC(inode));
 		old_i_size = inode->i_size;
 		inode->i_size = 0;
 		if (inode->i_blocks && ufs_truncate(inode, old_i_size))
 			ufs_warning(inode->i_sb, __func__, "ufs_truncate failed\n");
-		unlock_kernel();
+		unlock_ufs(inode->i_sb);
 	}
 
 	invalidate_inode_buffers(inode);
 	end_writeback(inode);
 
 	if (want_delete) {
-		lock_kernel();
+		lock_ufs(inode->i_sb);
 		ufs_free_inode (inode);
-		unlock_kernel();
+		unlock_ufs(inode->i_sb);
 	}
 }

commit 58e8268c7bae538ccb8b7eccc817c1c28bcd4da2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jun 5 19:40:56 2010 -0400

    switch ufs to ->evict_inode()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 45cafa937a4b..2b251f2093af 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -911,24 +911,33 @@ int ufs_sync_inode (struct inode *inode)
 	return ufs_update_inode (inode, 1);
 }
 
-void ufs_delete_inode (struct inode * inode)
+void ufs_evict_inode(struct inode * inode)
 {
-	loff_t old_i_size;
+	int want_delete = 0;
+
+	if (!inode->i_nlink && !is_bad_inode(inode))
+		want_delete = 1;
 
 	truncate_inode_pages(&inode->i_data, 0);
-	if (is_bad_inode(inode))
-		goto no_delete;
-	/*UFS_I(inode)->i_dtime = CURRENT_TIME;*/
-	lock_kernel();
-	mark_inode_dirty(inode);
-	ufs_update_inode(inode, IS_SYNC(inode));
-	old_i_size = inode->i_size;
-	inode->i_size = 0;
-	if (inode->i_blocks && ufs_truncate(inode, old_i_size))
-		ufs_warning(inode->i_sb, __func__, "ufs_truncate failed\n");
-	ufs_free_inode (inode);
-	unlock_kernel();
-	return;
-no_delete:
-	clear_inode(inode);	/* We must guarantee clearing of inode... */
+	if (want_delete) {
+		loff_t old_i_size;
+		/*UFS_I(inode)->i_dtime = CURRENT_TIME;*/
+		lock_kernel();
+		mark_inode_dirty(inode);
+		ufs_update_inode(inode, IS_SYNC(inode));
+		old_i_size = inode->i_size;
+		inode->i_size = 0;
+		if (inode->i_blocks && ufs_truncate(inode, old_i_size))
+			ufs_warning(inode->i_sb, __func__, "ufs_truncate failed\n");
+		unlock_kernel();
+	}
+
+	invalidate_inode_buffers(inode);
+	end_writeback(inode);
+
+	if (want_delete) {
+		lock_kernel();
+		ufs_free_inode (inode);
+		unlock_kernel();
+	}
 }

commit 155130a4f7848b1aac439cab6bda1a175507c71c
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jun 4 11:29:58 2010 +0200

    get rid of block_write_begin_newtrunc
    
    Move the call to vmtruncate to get rid of accessive blocks to the callers
    in preparation of the new truncate sequence and rename the non-truncating
    version to block_write_begin.
    
    While we're at it also remove several unused arguments to block_write_begin.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 45ce32391f8f..45cafa937a4b 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -567,9 +567,17 @@ static int ufs_write_begin(struct file *file, struct address_space *mapping,
 			loff_t pos, unsigned len, unsigned flags,
 			struct page **pagep, void **fsdata)
 {
-	*pagep = NULL;
-	return block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,
+	int ret;
+
+	ret = block_write_begin(mapping, pos, len, flags, pagep,
 				ufs_getfrag_block);
+	if (unlikely(ret)) {
+		loff_t isize = mapping->host->i_size;
+		if (pos + len > isize)
+			vmtruncate(mapping->host, isize);
+	}
+
+	return ret;
 }
 
 static sector_t ufs_bmap(struct address_space *mapping, sector_t block)

commit 6e1db88d536adcbbfe562b2d4b7d6425784fff12
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jun 4 11:29:57 2010 +0200

    introduce __block_write_begin
    
    Split up the block_write_begin implementation - __block_write_begin is a new
    trivial wrapper for block_prepare_write that always takes an already
    allocated page and can be either called from block_write_begin or filesystem
    code that already has a page allocated.  Remove the handling of already
    allocated pages from block_write_begin after switching all callers that
    do it to __block_write_begin.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index a9555b1ffd28..45ce32391f8f 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -560,8 +560,7 @@ static int ufs_readpage(struct file *file, struct page *page)
 
 int ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len)
 {
-	return block_write_begin_newtrunc(NULL, page->mapping, pos, len, 0,
-					  &page, NULL, ufs_getfrag_block);
+	return __block_write_begin(page, pos, len, ufs_getfrag_block);
 }
 
 static int ufs_write_begin(struct file *file, struct address_space *mapping,

commit f4e420dc423148fba637af1ab618fa8896dfb2d6
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jun 4 11:29:56 2010 +0200

    clean up write_begin usage for directories in pagecache
    
    For filesystem that implement directories in pagecache we call
    block_write_begin with an already allocated page for this code, while the
    normal regular file write path uses the default block_write_begin behaviour.
    
    Get rid of the __foofs_write_begin helper and opencode the normal write_begin
    call in foofs_write_begin, while adding a new foofs_prepare_chunk helper for
    the directory code.  The added benefit is that foofs_prepare_chunk has
    a much saner calling convention.
    
    Note that the interruptible flag passed into block_write_begin is always
    ignored if we already pass in a page (see next patch for details), and
    we never were doing truncations of exessive blocks for this case either so we
    can switch directly to block_write_begin_newtrunc.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 73fe773aa034..a9555b1ffd28 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -558,12 +558,10 @@ static int ufs_readpage(struct file *file, struct page *page)
 	return block_read_full_page(page,ufs_getfrag_block);
 }
 
-int __ufs_write_begin(struct file *file, struct address_space *mapping,
-			loff_t pos, unsigned len, unsigned flags,
-			struct page **pagep, void **fsdata)
+int ufs_prepare_chunk(struct page *page, loff_t pos, unsigned len)
 {
-	return block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,
-				ufs_getfrag_block);
+	return block_write_begin_newtrunc(NULL, page->mapping, pos, len, 0,
+					  &page, NULL, ufs_getfrag_block);
 }
 
 static int ufs_write_begin(struct file *file, struct address_space *mapping,
@@ -571,7 +569,8 @@ static int ufs_write_begin(struct file *file, struct address_space *mapping,
 			struct page **pagep, void **fsdata)
 {
 	*pagep = NULL;
-	return __ufs_write_begin(file, mapping, pos, len, flags, pagep, fsdata);
+	return block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,
+				ufs_getfrag_block);
 }
 
 static sector_t ufs_bmap(struct address_space *mapping, sector_t block)

commit 8f45c33decf62e1aaaa9411aae8fef6a38f95845
Author: Jan Kara <jack@suse.cz>
Date:   Thu May 20 16:00:36 2010 +0200

    ufs: Remove dead quota code
    
    UFS quota is non-functional at least since 2.6.12 because dq_op was set
    to NULL. Since the filesystem exists mainly to allow cooperation with Solaris
    and quota format isn't standard, just remove the dead code.
    
    CC: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index cffa756f1047..73fe773aa034 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -37,7 +37,6 @@
 #include <linux/smp_lock.h>
 #include <linux/buffer_head.h>
 #include <linux/writeback.h>
-#include <linux/quotaops.h>
 
 #include "ufs_fs.h"
 #include "ufs.h"
@@ -910,9 +909,6 @@ void ufs_delete_inode (struct inode * inode)
 {
 	loff_t old_i_size;
 
-	if (!is_bad_inode(inode))
-		dquot_initialize(inode);
-
 	truncate_inode_pages(&inode->i_data, 0);
 	if (is_bad_inode(inode))
 		goto no_delete;

commit 311b9549ed2bb0f2c2257781c3e88cb00505e80e
Author: Dmitry Monakhov <dmonakhov@openvz.org>
Date:   Thu Apr 15 00:56:58 2010 +0200

    ufs: add ufs speciffic ->setattr call
    
    generic setattr not longer responsible for quota transfer.
    use ufs_setattr for all ufs's inodes.
    
    Signed-off-by: Dmitry Monakhov <dmonakhov@openvz.org>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 80b68c3702d1..cffa756f1047 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -603,7 +603,7 @@ static void ufs_set_inode_ops(struct inode *inode)
 		if (!inode->i_blocks)
 			inode->i_op = &ufs_fast_symlink_inode_operations;
 		else {
-			inode->i_op = &page_symlink_inode_operations;
+			inode->i_op = &ufs_symlink_inode_operations;
 			inode->i_mapping->a_ops = &ufs_aops;
 		}
 	} else

commit e213e26ab3988c516c06eba4dcd030ac052f6dc9
Merge: c812a51d11bb efd8f0e6f6c1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 5 13:20:53 2010 -0800

    Merge branch 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs-2.6
    
    * 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs-2.6: (33 commits)
      quota: stop using QUOTA_OK / NO_QUOTA
      dquot: cleanup dquot initialize routine
      dquot: move dquot initialization responsibility into the filesystem
      dquot: cleanup dquot drop routine
      dquot: move dquot drop responsibility into the filesystem
      dquot: cleanup dquot transfer routine
      dquot: move dquot transfer responsibility into the filesystem
      dquot: cleanup inode allocation / freeing routines
      dquot: cleanup space allocation / freeing routines
      ext3: add writepage sanity checks
      ext3: Truncate allocated blocks if direct IO write fails to update i_size
      quota: Properly invalidate caches even for filesystems with blocksize < pagesize
      quota: generalize quota transfer interface
      quota: sb_quota state flags cleanup
      jbd: Delay discarding buffers in journal_unmap_buffer
      ext3: quota_write cross block boundary behaviour
      quota: drop permission checks from xfs_fs_set_xstate/xfs_fs_set_xquota
      quota: split out compat_sys_quotactl support from quota.c
      quota: split out netlink notification support from quota.c
      quota: remove invalid optimization from quota_sync_all
      ...
    
    Fixed trivial conflicts in fs/namei.c and fs/ufs/inode.c

commit a9185b41a4f84971b930c519f0c63bd450c4810d
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Mar 5 09:21:37 2010 +0100

    pass writeback_control to ->write_inode
    
    This gives the filesystem more information about the writeback that
    is happening.  Trond requested this for the NFS unstable write handling,
    and other filesystems might benefit from this too by beeing able to
    distinguish between the different callers in more detail.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 7cf33379fd46..0a627e08610b 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -36,6 +36,7 @@
 #include <linux/mm.h>
 #include <linux/smp_lock.h>
 #include <linux/buffer_head.h>
+#include <linux/writeback.h>
 
 #include "ufs_fs.h"
 #include "ufs.h"
@@ -890,11 +891,11 @@ static int ufs_update_inode(struct inode * inode, int do_sync)
 	return 0;
 }
 
-int ufs_write_inode (struct inode * inode, int wait)
+int ufs_write_inode(struct inode *inode, struct writeback_control *wbc)
 {
 	int ret;
 	lock_kernel();
-	ret = ufs_update_inode (inode, wait);
+	ret = ufs_update_inode(inode, wbc->sync_mode == WB_SYNC_ALL);
 	unlock_kernel();
 	return ret;
 }

commit 871a293155a24554e153538d36e3a80fa169aefb
Author: Christoph Hellwig <hch@infradead.org>
Date:   Wed Mar 3 09:05:07 2010 -0500

    dquot: cleanup dquot initialize routine
    
    Get rid of the initialize dquot operation - it is now always called from
    the filesystem and if a filesystem really needs it's own (which none
    currently does) it can just call into it's own routine directly.
    
    Rename the now static low-level dquot_initialize helper to __dquot_initialize
    and vfs_dq_init to dquot_initialize to have a consistent namespace.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index fff8edab382f..09aef49beedb 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -910,7 +910,7 @@ void ufs_delete_inode (struct inode * inode)
 	loff_t old_i_size;
 
 	if (!is_bad_inode(inode))
-		vfs_dq_init(inode);
+		dquot_initialize(inode);
 
 	truncate_inode_pages(&inode->i_data, 0);
 	if (is_bad_inode(inode))

commit 907f4554e2521cb28b0009d17167760650a9561c
Author: Christoph Hellwig <hch@infradead.org>
Date:   Wed Mar 3 09:05:06 2010 -0500

    dquot: move dquot initialization responsibility into the filesystem
    
    Currently various places in the VFS call vfs_dq_init directly.  This means
    we tie the quota code into the VFS.  Get rid of that and make the
    filesystem responsible for the initialization.   For most metadata operations
    this is a straight forward move into the methods, but for truncate and
    open it's a bit more complicated.
    
    For truncate we currently only call vfs_dq_init for the sys_truncate case
    because open already takes care of it for ftruncate and open(O_TRUNC) - the
    new code causes an additional vfs_dq_init for those which is harmless.
    
    For open the initialization is moved from do_filp_open into the open method,
    which means it happens slightly earlier now, and only for regular files.
    The latter is fine because we don't need to initialize it for operations
    on special files, and we already do it as part of the namespace operations
    for directories.
    
    Add a dquot_file_open helper that filesystems that support generic quotas
    can use to fill in ->open.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 7cf33379fd46..fff8edab382f 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -36,6 +36,7 @@
 #include <linux/mm.h>
 #include <linux/smp_lock.h>
 #include <linux/buffer_head.h>
+#include <linux/quotaops.h>
 
 #include "ufs_fs.h"
 #include "ufs.h"
@@ -908,6 +909,9 @@ void ufs_delete_inode (struct inode * inode)
 {
 	loff_t old_i_size;
 
+	if (!is_bad_inode(inode))
+		vfs_dq_init(inode);
+
 	truncate_inode_pages(&inode->i_data, 0);
 	if (is_bad_inode(inode))
 		goto no_delete;

commit 37044c86baf8cb894c69bb811e35a7f6f6dbce1c
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Wed Jun 17 16:26:28 2009 -0700

    ufs: sector_t cannot be negative
    
    unsigned i_block,fragment cannot be negative.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 3d2512c21f05..7cf33379fd46 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -56,9 +56,7 @@ static int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t off
 
 
 	UFSD("ptrs=uspi->s_apb = %d,double_blocks=%ld \n",ptrs,double_blocks);
-	if (i_block < 0) {
-		ufs_warning(inode->i_sb, "ufs_block_to_path", "block < 0");
-	} else if (i_block < direct_blocks) {
+	if (i_block < direct_blocks) {
 		offsets[n++] = i_block;
 	} else if ((i_block -= direct_blocks) < indirect_blocks) {
 		offsets[n++] = UFS_IND_BLOCK;
@@ -440,8 +438,6 @@ int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head
 	lock_kernel();
 
 	UFSD("ENTER, ino %lu, fragment %llu\n", inode->i_ino, (unsigned long long)fragment);
-	if (fragment < 0)
-		goto abort_negative;
 	if (fragment >
 	    ((UFS_NDADDR + uspi->s_apb + uspi->s_2apb + uspi->s_3apb)
 	     << uspi->s_fpbshift))
@@ -504,10 +500,6 @@ int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head
 	unlock_kernel();
 	return err;
 
-abort_negative:
-	ufs_warning(sb, "ufs_get_block", "block < 0");
-	goto abort;
-
 abort_too_big:
 	ufs_warning(sb, "ufs_get_block", "block > big");
 	goto abort;

commit b12903f1384cd176a3994a6bf6caf5a482169cc8
Author: Duane Griffin <duaneg@dghda.com>
Date:   Thu Jan 8 22:43:50 2009 +0000

    ufs: ensure fast symlinks are NUL-terminated
    
    Ensure fast symlink targets are NUL-terminated, even if corrupted
    on-disk.
    
    Signed-off-by: Duane Griffin <duaneg@dghda.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index ac8b324415d3..3d2512c21f05 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -658,7 +658,8 @@ static int ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 		       sizeof(ufs_inode->ui_u2.ui_addr));
 	} else {
 		memcpy(ufsi->i_u1.i_symlink, ufs_inode->ui_u2.ui_symlink,
-		       sizeof(ufs_inode->ui_u2.ui_symlink));
+		       sizeof(ufs_inode->ui_u2.ui_symlink) - 1);
+		ufsi->i_u1.i_symlink[sizeof(ufs_inode->ui_u2.ui_symlink) - 1] = 0;
 	}
 	return 0;
 }
@@ -706,7 +707,8 @@ static int ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)
 		       sizeof(ufs2_inode->ui_u2.ui_addr));
 	} else {
 		memcpy(ufsi->i_u1.i_symlink, ufs2_inode->ui_u2.ui_symlink,
-		       sizeof(ufs2_inode->ui_u2.ui_symlink));
+		       sizeof(ufs2_inode->ui_u2.ui_symlink) - 1);
+		ufsi->i_u1.i_symlink[sizeof(ufs2_inode->ui_u2.ui_symlink) - 1] = 0;
 	}
 	return 0;
 }

commit f33219b7a90c4779a0b59e11fb35ebc4542db328
Author: Duane Griffin <duaneg@dghda.com>
Date:   Thu Jan 8 22:43:49 2009 +0000

    ufs: don't truncate longer ufs2 fast symlinks
    
    ufs2 fast symlinks can be twice as long as ufs ones, however the code
    was using the ufs size in various places. Fix that so ufs2 symlinks over
    60 characters aren't truncated.
    
    Note that we copy the entire area instead of using the maxsymlinklen field
    from the superblock. This way we will be more robust against corruption (of
    the superblock).
    
    While we are at it, use memcpy instead of open-coding it with for loops.
    
    Signed-off-by: Duane Griffin <duaneg@dghda.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 39f877898565..ac8b324415d3 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -622,7 +622,6 @@ static int ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
 	mode_t mode;
-	unsigned i;
 
 	/*
 	 * Copy data to the in-core inode.
@@ -655,11 +654,11 @@ static int ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 
 	
 	if (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {
-		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR); i++)
-			ufsi->i_u1.i_data[i] = ufs_inode->ui_u2.ui_addr.ui_db[i];
+		memcpy(ufsi->i_u1.i_data, &ufs_inode->ui_u2.ui_addr,
+		       sizeof(ufs_inode->ui_u2.ui_addr));
 	} else {
-		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR) * 4; i++)
-			ufsi->i_u1.i_symlink[i] = ufs_inode->ui_u2.ui_symlink[i];
+		memcpy(ufsi->i_u1.i_symlink, ufs_inode->ui_u2.ui_symlink,
+		       sizeof(ufs_inode->ui_u2.ui_symlink));
 	}
 	return 0;
 }
@@ -669,7 +668,6 @@ static int ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
 	mode_t mode;
-	unsigned i;
 
 	UFSD("Reading ufs2 inode, ino %lu\n", inode->i_ino);
 	/*
@@ -704,12 +702,11 @@ static int ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)
 	*/
 
 	if (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {
-		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR); i++)
-			ufsi->i_u1.u2_i_data[i] =
-				ufs2_inode->ui_u2.ui_addr.ui_db[i];
+		memcpy(ufsi->i_u1.u2_i_data, &ufs2_inode->ui_u2.ui_addr,
+		       sizeof(ufs2_inode->ui_u2.ui_addr));
 	} else {
-		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR) * 4; i++)
-			ufsi->i_u1.i_symlink[i] = ufs2_inode->ui_u2.ui_symlink[i];
+		memcpy(ufsi->i_u1.i_symlink, ufs2_inode->ui_u2.ui_symlink,
+		       sizeof(ufs2_inode->ui_u2.ui_symlink));
 	}
 	return 0;
 }
@@ -781,7 +778,6 @@ static void ufs1_update_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 {
 	struct super_block *sb = inode->i_sb;
  	struct ufs_inode_info *ufsi = UFS_I(inode);
- 	unsigned i;
 
 	ufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);
 	ufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);
@@ -809,12 +805,12 @@ static void ufs1_update_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 		/* ufs_inode->ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode->i_rdev); */
 		ufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.i_data[0];
 	} else if (inode->i_blocks) {
-		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR); i++)
-			ufs_inode->ui_u2.ui_addr.ui_db[i] = ufsi->i_u1.i_data[i];
+		memcpy(&ufs_inode->ui_u2.ui_addr, ufsi->i_u1.i_data,
+		       sizeof(ufs_inode->ui_u2.ui_addr));
 	}
 	else {
-		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR) * 4; i++)
-			ufs_inode->ui_u2.ui_symlink[i] = ufsi->i_u1.i_symlink[i];
+		memcpy(&ufs_inode->ui_u2.ui_symlink, ufsi->i_u1.i_symlink,
+		       sizeof(ufs_inode->ui_u2.ui_symlink));
 	}
 
 	if (!inode->i_nlink)
@@ -825,7 +821,6 @@ static void ufs2_update_inode(struct inode *inode, struct ufs2_inode *ufs_inode)
 {
 	struct super_block *sb = inode->i_sb;
  	struct ufs_inode_info *ufsi = UFS_I(inode);
- 	unsigned i;
 
 	UFSD("ENTER\n");
 	ufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);
@@ -850,11 +845,11 @@ static void ufs2_update_inode(struct inode *inode, struct ufs2_inode *ufs_inode)
 		/* ufs_inode->ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode->i_rdev); */
 		ufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.u2_i_data[0];
 	} else if (inode->i_blocks) {
-		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR); i++)
-			ufs_inode->ui_u2.ui_addr.ui_db[i] = ufsi->i_u1.u2_i_data[i];
+		memcpy(&ufs_inode->ui_u2.ui_addr, ufsi->i_u1.u2_i_data,
+		       sizeof(ufs_inode->ui_u2.ui_addr));
 	} else {
-		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR) * 4; i++)
-			ufs_inode->ui_u2.ui_symlink[i] = ufsi->i_u1.i_symlink[i];
+		memcpy(&ufs_inode->ui_u2.ui_symlink, ufsi->i_u1.i_symlink,
+		       sizeof(ufs_inode->ui_u2.ui_symlink));
  	}
 
 	if (!inode->i_nlink)

commit 9746077a71d01b8d86f5e471a3a2c8f1fa91ef94
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Apr 28 02:16:17 2008 -0700

    ufs: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: Jan Engelhardt <jengelh@linux01.gwdg.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 5446b888fc8e..39f877898565 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -929,7 +929,7 @@ void ufs_delete_inode (struct inode * inode)
 	old_i_size = inode->i_size;
 	inode->i_size = 0;
 	if (inode->i_blocks && ufs_truncate(inode, old_i_size))
-		ufs_warning(inode->i_sb, __FUNCTION__, "ufs_truncate failed\n");
+		ufs_warning(inode->i_sb, __func__, "ufs_truncate failed\n");
 	ufs_free_inode (inode);
 	unlock_kernel();
 	return;

commit e542059884bb6d651d7ffc64eacedbab2b64078c
Author: Mike Frysinger <vapier@gentoo.org>
Date:   Fri Feb 8 04:21:31 2008 -0800

    drop linux/ufs_fs.h from userspace export and relocate it to fs/ufs/ufs_fs.h
    
    Per previous discussions about cleaning up ufs_fs.h, people just want
    this straight up dropped from userspace export.  The only remaining
    consumer (silo) has been fixed a while ago to not rely on this header.
    This allows use to move it completely from include/linux/ to fs/ufs/
    seeing as how the only in-kernel consumer is fs/ufs/.
    
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Cc: Jan Kara <jack@ucw.cz>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 489f26bc26d9..5446b888fc8e 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -30,7 +30,6 @@
 
 #include <linux/errno.h>
 #include <linux/fs.h>
-#include <linux/ufs_fs.h>
 #include <linux/time.h>
 #include <linux/stat.h>
 #include <linux/string.h>
@@ -38,6 +37,7 @@
 #include <linux/smp_lock.h>
 #include <linux/buffer_head.h>
 
+#include "ufs_fs.h"
 #include "ufs.h"
 #include "swab.h"
 #include "util.h"

commit b55c460da6df4e8dfc6f68c00fafe7337b54e2f8
Author: David Howells <dhowells@redhat.com>
Date:   Thu Feb 7 00:15:48 2008 -0800

    iget: stop UFS from using iget() and read_inode()
    
    Stop the UFS filesystem from using iget() and read_inode().  Replace
    ufs_read_inode() with ufs_iget(), and call that instead of iget().  ufs_iget()
    then uses iget_locked() directly and returns a proper error code instead of an
    inode in the event of an error.
    
    ufs_fill_super() returns any error incurred when getting the root inode
    instead of EINVAL.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: Evgeniy Dushistov <dushistov@mail.ru>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 4320782761ae..489f26bc26d9 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -714,26 +714,30 @@ static int ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)
 	return 0;
 }
 
-void ufs_read_inode(struct inode * inode)
+struct inode *ufs_iget(struct super_block *sb, unsigned long ino)
 {
-	struct ufs_inode_info *ufsi = UFS_I(inode);
-	struct super_block * sb;
-	struct ufs_sb_private_info * uspi;
+	struct ufs_inode_info *ufsi;
+	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
 	struct buffer_head * bh;
+	struct inode *inode;
 	int err;
 
-	UFSD("ENTER, ino %lu\n", inode->i_ino);
-
-	sb = inode->i_sb;
-	uspi = UFS_SB(sb)->s_uspi;
+	UFSD("ENTER, ino %lu\n", ino);
 
-	if (inode->i_ino < UFS_ROOTINO ||
-	    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {
+	if (ino < UFS_ROOTINO || ino > (uspi->s_ncg * uspi->s_ipg)) {
 		ufs_warning(sb, "ufs_read_inode", "bad inode number (%lu)\n",
-			    inode->i_ino);
-		goto bad_inode;
+			    ino);
+		return ERR_PTR(-EIO);
 	}
 
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	ufsi = UFS_I(inode);
+
 	bh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));
 	if (!bh) {
 		ufs_warning(sb, "ufs_read_inode", "unable to read inode %lu\n",
@@ -765,10 +769,12 @@ void ufs_read_inode(struct inode * inode)
 	brelse(bh);
 
 	UFSD("EXIT\n");
-	return;
+	unlock_new_inode(inode);
+	return inode;
 
 bad_inode:
-	make_bad_inode(inode);
+	iget_failed(inode);
+	return ERR_PTR(-EIO);
 }
 
 static void ufs1_update_inode(struct inode *inode, struct ufs_inode *ufs_inode)

commit bcd6d4ecf6868ed57d4daae5d48e52d0752566d2
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Oct 16 23:26:51 2007 -0700

    ufs: move non-layout parts of ufs_fs.h to fs/ufs/
    
    Move prototypes and in-core structures to fs/ufs/ similar to what most
    other filesystems already do.
    
    I made little modifications: move also ufs debug macros and
    mount options constants into fs/ufs/ufs.h, this stuff
    also private for ufs.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index d84d4b0f4779..4320782761ae 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -38,6 +38,7 @@
 #include <linux/smp_lock.h>
 #include <linux/buffer_head.h>
 
+#include "ufs.h"
 #include "swab.h"
 #include "util.h"
 

commit 82b9d1d0da8046088b0f505f92a97d12d9804613
Author: Nick Piggin <npiggin@suse.de>
Date:   Tue Oct 16 01:25:19 2007 -0700

    ufs: convert to new aops
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Cc: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index f18b79122fa3..d84d4b0f4779 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -558,24 +558,39 @@ static int ufs_writepage(struct page *page, struct writeback_control *wbc)
 {
 	return block_write_full_page(page,ufs_getfrag_block,wbc);
 }
+
 static int ufs_readpage(struct file *file, struct page *page)
 {
 	return block_read_full_page(page,ufs_getfrag_block);
 }
-static int ufs_prepare_write(struct file *file, struct page *page, unsigned from, unsigned to)
+
+int __ufs_write_begin(struct file *file, struct address_space *mapping,
+			loff_t pos, unsigned len, unsigned flags,
+			struct page **pagep, void **fsdata)
 {
-	return block_prepare_write(page,from,to,ufs_getfrag_block);
+	return block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,
+				ufs_getfrag_block);
 }
+
+static int ufs_write_begin(struct file *file, struct address_space *mapping,
+			loff_t pos, unsigned len, unsigned flags,
+			struct page **pagep, void **fsdata)
+{
+	*pagep = NULL;
+	return __ufs_write_begin(file, mapping, pos, len, flags, pagep, fsdata);
+}
+
 static sector_t ufs_bmap(struct address_space *mapping, sector_t block)
 {
 	return generic_block_bmap(mapping,block,ufs_getfrag_block);
 }
+
 const struct address_space_operations ufs_aops = {
 	.readpage = ufs_readpage,
 	.writepage = ufs_writepage,
 	.sync_page = block_sync_page,
-	.prepare_write = ufs_prepare_write,
-	.commit_write = generic_commit_write,
+	.write_begin = ufs_write_begin,
+	.write_end = generic_write_end,
 	.bmap = ufs_bmap
 };
 

commit 07a0cfec30848319cc86f21cce0d2efeca593e1a
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Mon Apr 16 22:53:24 2007 -0700

    ufs proper handling of zero link case
    
    This patch should fix or partly fix this bug:
    http://bugzilla.kernel.org/show_bug.cgi?id=8276
    
    The problem is:
    
    - if we see "zero link case" during reading inode operation, we call
      ufs_error(which remount fs readonly), but not "mark" inode as bad (1)
    
    - in readonly case we do not fill some data structures, which are used in
      read and write case (2)
    
    - VFS call ufs_delete_inode if link count is zero (3)
    
    so (1)->(3)->(2) cause oops, this patch should fix such scenario
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Cc: Jim Paris <jim@jtan.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 013d7afe7cde..f18b79122fa3 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -601,7 +601,7 @@ static void ufs_set_inode_ops(struct inode *inode)
 				   ufs_get_inode_dev(inode->i_sb, UFS_I(inode)));
 }
 
-static void ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)
+static int ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 {
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
@@ -613,8 +613,10 @@ static void ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 	 */
 	inode->i_mode = mode = fs16_to_cpu(sb, ufs_inode->ui_mode);
 	inode->i_nlink = fs16_to_cpu(sb, ufs_inode->ui_nlink);
-	if (inode->i_nlink == 0)
+	if (inode->i_nlink == 0) {
 		ufs_error (sb, "ufs_read_inode", "inode %lu has zero nlink\n", inode->i_ino);
+		return -1;
+	}
 	
 	/*
 	 * Linux now has 32-bit uid and gid, so we can support EFT.
@@ -643,9 +645,10 @@ static void ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR) * 4; i++)
 			ufsi->i_u1.i_symlink[i] = ufs_inode->ui_u2.ui_symlink[i];
 	}
+	return 0;
 }
 
-static void ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)
+static int ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)
 {
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
@@ -658,8 +661,10 @@ static void ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)
 	 */
 	inode->i_mode = mode = fs16_to_cpu(sb, ufs2_inode->ui_mode);
 	inode->i_nlink = fs16_to_cpu(sb, ufs2_inode->ui_nlink);
-	if (inode->i_nlink == 0)
+	if (inode->i_nlink == 0) {
 		ufs_error (sb, "ufs_read_inode", "inode %lu has zero nlink\n", inode->i_ino);
+		return -1;
+	}
 
         /*
          * Linux now has 32-bit uid and gid, so we can support EFT.
@@ -690,6 +695,7 @@ static void ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)
 		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR) * 4; i++)
 			ufsi->i_u1.i_symlink[i] = ufs2_inode->ui_u2.ui_symlink[i];
 	}
+	return 0;
 }
 
 void ufs_read_inode(struct inode * inode)
@@ -698,6 +704,7 @@ void ufs_read_inode(struct inode * inode)
 	struct super_block * sb;
 	struct ufs_sb_private_info * uspi;
 	struct buffer_head * bh;
+	int err;
 
 	UFSD("ENTER, ino %lu\n", inode->i_ino);
 
@@ -720,14 +727,17 @@ void ufs_read_inode(struct inode * inode)
 	if ((UFS_SB(sb)->s_flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {
 		struct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;
 
-		ufs2_read_inode(inode,
-				ufs2_inode + ufs_inotofsbo(inode->i_ino));
+		err = ufs2_read_inode(inode,
+				      ufs2_inode + ufs_inotofsbo(inode->i_ino));
 	} else {
 		struct ufs_inode *ufs_inode = (struct ufs_inode *)bh->b_data;
 
-		ufs1_read_inode(inode, ufs_inode + ufs_inotofsbo(inode->i_ino));
+		err = ufs1_read_inode(inode,
+				      ufs_inode + ufs_inotofsbo(inode->i_ino));
 	}
 
+	if (err)
+		goto bad_inode;
 	inode->i_version++;
 	ufsi->i_lastfrag =
 		(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;
@@ -888,6 +898,8 @@ void ufs_delete_inode (struct inode * inode)
 	loff_t old_i_size;
 
 	truncate_inode_pages(&inode->i_data, 0);
+	if (is_bad_inode(inode))
+		goto no_delete;
 	/*UFS_I(inode)->i_dtime = CURRENT_TIME;*/
 	lock_kernel();
 	mark_inode_dirty(inode);
@@ -898,4 +910,7 @@ void ufs_delete_inode (struct inode * inode)
 		ufs_warning(inode->i_sb, __FUNCTION__, "ufs_truncate failed\n");
 	ufs_free_inode (inode);
 	unlock_kernel();
+	return;
+no_delete:
+	clear_inode(inode);	/* We must guarantee clearing of inode... */
 }

commit 4b25a37e2093146c1f9aa436b832b7d4ef880ca4
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Fri Mar 16 13:38:09 2007 -0800

    [PATCH] ufs: zeroize the rest of block in truncate
    
    This patch fix behaviour in such test scenario:
    
      lseek(fd, BIG_OFFSET)
      write(fd, buf, sizeof(buf))
      truncate(BIG_OFFSET)
      truncate(BIG_OFFSET + sizeof(buf))
      read(fd, buf...)
    
    Because of if file big enough(BIG_OFFSET) we start allocate space by block,
    ordinary block size > page size, so we should zeroize the rest of block in
    truncate(except last framgnet, about which VFS should care), to not get
    garbage, when we extend file.
    
    Also patch corrects conversion from pointer to block to physical block number,
    this helps in case of not common used UFS types.
    
    And add to debug output inode number.
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 366618dd698d..013d7afe7cde 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -212,7 +212,7 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 			brelse (result);
 			goto repeat;
 		} else {
-			*phys = tmp + blockoff;
+			*phys = uspi->s_sbbase + tmp + blockoff;
 			return NULL;
 		}
 	}
@@ -282,9 +282,9 @@ ufs_inode_getfrag(struct inode *inode, u64 fragment,
 	}
 
 	if (!phys) {
-		result = sb_getblk(sb, tmp + blockoff);
+		result = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
 	} else {
-		*phys = tmp + blockoff;
+		*phys = uspi->s_sbbase + tmp + blockoff;
 		result = NULL;
 		*err = 0;
 		*new = 1;
@@ -368,7 +368,7 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 			brelse (result);
 			goto repeat;
 		} else {
-			*phys = tmp + blockoff;
+			*phys = uspi->s_sbbase + tmp + blockoff;
 			goto out;
 		}
 	}
@@ -389,9 +389,9 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 
 
 	if (!phys) {
-		result = sb_getblk(sb, tmp + blockoff);
+		result = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
 	} else {
-		*phys = tmp + blockoff;
+		*phys = uspi->s_sbbase + tmp + blockoff;
 		*new = 1;
 	}
 

commit 2189850f42beff23af32d847bd043cd1d1811a80
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Fri Mar 16 13:38:07 2007 -0800

    [PATCH] ufs2: more correct work with time
    
    This patch corrects work with time in UFS2 case.
    
    1) According to UFS2 disk layout modification/access and so on "time"
       should be hold in two variables one 64bit for seconds and another 32bit for
       nanoseconds,
    
       at now for some unknown reason we suppose that "inode time" holds in
       three variables 32bit for seconds, 32bit for milliseconds and 32bit for
       nanoseconds.
    
    2) We set amount of nanoseconds in "VFS inode" to 0 during read, instead of
       getting values from "on disk inode"(this should close
       http://bugzilla.kernel.org/show_bug.cgi?id=7991).
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Cc: Bjoern Jacke <bjoern@j3e.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index fb34ad03e224..366618dd698d 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -668,12 +668,12 @@ static void ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)
 	inode->i_gid = fs32_to_cpu(sb, ufs2_inode->ui_gid);
 
 	inode->i_size = fs64_to_cpu(sb, ufs2_inode->ui_size);
-	inode->i_atime.tv_sec = fs32_to_cpu(sb, ufs2_inode->ui_atime.tv_sec);
-	inode->i_ctime.tv_sec = fs32_to_cpu(sb, ufs2_inode->ui_ctime.tv_sec);
-	inode->i_mtime.tv_sec = fs32_to_cpu(sb, ufs2_inode->ui_mtime.tv_sec);
-	inode->i_mtime.tv_nsec = 0;
-	inode->i_atime.tv_nsec = 0;
-	inode->i_ctime.tv_nsec = 0;
+	inode->i_atime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_atime);
+	inode->i_ctime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_ctime);
+	inode->i_mtime.tv_sec = fs64_to_cpu(sb, ufs2_inode->ui_mtime);
+	inode->i_atime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_atimensec);
+	inode->i_ctime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_ctimensec);
+	inode->i_mtime.tv_nsec = fs32_to_cpu(sb, ufs2_inode->ui_mtimensec);
 	inode->i_blocks = fs64_to_cpu(sb, ufs2_inode->ui_blocks);
 	inode->i_generation = fs32_to_cpu(sb, ufs2_inode->ui_gen);
 	ufsi->i_flags = fs32_to_cpu(sb, ufs2_inode->ui_flags);
@@ -803,12 +803,12 @@ static void ufs2_update_inode(struct inode *inode, struct ufs2_inode *ufs_inode)
 	ufs_inode->ui_gid = cpu_to_fs32(sb, inode->i_gid);
 
 	ufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);
-	ufs_inode->ui_atime.tv_sec = cpu_to_fs32(sb, inode->i_atime.tv_sec);
-	ufs_inode->ui_atime.tv_usec = 0;
-	ufs_inode->ui_ctime.tv_sec = cpu_to_fs32(sb, inode->i_ctime.tv_sec);
-	ufs_inode->ui_ctime.tv_usec = 0;
-	ufs_inode->ui_mtime.tv_sec = cpu_to_fs32(sb, inode->i_mtime.tv_sec);
-	ufs_inode->ui_mtime.tv_usec = 0;
+	ufs_inode->ui_atime = cpu_to_fs64(sb, inode->i_atime.tv_sec);
+	ufs_inode->ui_atimensec = cpu_to_fs32(sb, inode->i_atime.tv_nsec);
+	ufs_inode->ui_ctime = cpu_to_fs64(sb, inode->i_ctime.tv_sec);
+	ufs_inode->ui_ctimensec = cpu_to_fs32(sb, inode->i_ctime.tv_nsec);
+	ufs_inode->ui_mtime = cpu_to_fs64(sb, inode->i_mtime.tv_sec);
+	ufs_inode->ui_mtimensec = cpu_to_fs32(sb, inode->i_mtime.tv_nsec);
 
 	ufs_inode->ui_blocks = cpu_to_fs64(sb, inode->i_blocks);
 	ufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);

commit 54fb996ac15c4014fa4d6b0ec8e42da134204897
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Mon Feb 12 00:54:32 2007 -0800

    [PATCH] ufs2 write: block allocation update
    
    Patch adds ability to work with 64bit metadata, this made by replacing work
    with 32bit pointers by inline functions.
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index dd52eecdcb0f..fb34ad03e224 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -170,7 +170,7 @@ static u64 ufs_frag_map(struct inode *inode, sector_t frag)
  * @locked_page - for ufs_new_fragments()
  */
 static struct buffer_head *
-ufs_inode_getfrag(struct inode *inode, unsigned int fragment,
+ufs_inode_getfrag(struct inode *inode, u64 fragment,
 		  sector_t new_fragment, unsigned int required, int *err,
 		  long *phys, int *new, struct page *locked_page)
 {
@@ -178,12 +178,12 @@ ufs_inode_getfrag(struct inode *inode, unsigned int fragment,
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
 	struct buffer_head * result;
-	unsigned block, blockoff, lastfrag, lastblock, lastblockoff;
-	unsigned tmp, goal;
-	__fs32 * p, * p2;
+	unsigned blockoff, lastblockoff;
+	u64 tmp, goal, lastfrag, block, lastblock;
+	void *p, *p2;
 
-	UFSD("ENTER, ino %lu, fragment %u, new_fragment %llu, required %u, "
-	     "metadata %d\n", inode->i_ino, fragment,
+	UFSD("ENTER, ino %lu, fragment %llu, new_fragment %llu, required %u, "
+	     "metadata %d\n", inode->i_ino, (unsigned long long)fragment,
 	     (unsigned long long)new_fragment, required, !phys);
 
         /* TODO : to be done for write support
@@ -193,17 +193,20 @@ ufs_inode_getfrag(struct inode *inode, unsigned int fragment,
 
 	block = ufs_fragstoblks (fragment);
 	blockoff = ufs_fragnum (fragment);
-	p = ufsi->i_u1.i_data + block;
+	p = ufs_get_direct_data_ptr(uspi, ufsi, block);
+
 	goal = 0;
 
 repeat:
-	tmp = fs32_to_cpu(sb, *p);
+	tmp = ufs_data_ptr_to_cpu(sb, p);
+
 	lastfrag = ufsi->i_lastfrag;
 	if (tmp && fragment < lastfrag) {
 		if (!phys) {
 			result = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
-			if (tmp == fs32_to_cpu(sb, *p)) {
-				UFSD("EXIT, result %u\n", tmp + blockoff);
+			if (tmp == ufs_data_ptr_to_cpu(sb, p)) {
+				UFSD("EXIT, result %llu\n",
+				     (unsigned long long)tmp + blockoff);
 				return result;
 			}
 			brelse (result);
@@ -224,10 +227,11 @@ ufs_inode_getfrag(struct inode *inode, unsigned int fragment,
 		 * We must reallocate last allocated block
 		 */
 		if (lastblockoff) {
-			p2 = ufsi->i_u1.i_data + lastblock;
-			tmp = ufs_new_fragments (inode, p2, lastfrag, 
-						 fs32_to_cpu(sb, *p2), uspi->s_fpb - lastblockoff,
-						 err, locked_page);
+			p2 = ufs_get_direct_data_ptr(uspi, ufsi, lastblock);
+			tmp = ufs_new_fragments(inode, p2, lastfrag,
+						ufs_data_ptr_to_cpu(sb, p2),
+						uspi->s_fpb - lastblockoff,
+						err, locked_page);
 			if (!tmp) {
 				if (lastfrag != ufsi->i_lastfrag)
 					goto repeat;
@@ -237,27 +241,31 @@ ufs_inode_getfrag(struct inode *inode, unsigned int fragment,
 			lastfrag = ufsi->i_lastfrag;
 			
 		}
-		tmp = fs32_to_cpu(sb, ufsi->i_u1.i_data[lastblock]);
+		tmp = ufs_data_ptr_to_cpu(sb,
+					 ufs_get_direct_data_ptr(uspi, ufsi,
+								 lastblock));
 		if (tmp)
 			goal = tmp + uspi->s_fpb;
 		tmp = ufs_new_fragments (inode, p, fragment - blockoff, 
 					 goal, required + blockoff,
 					 err,
 					 phys != NULL ? locked_page : NULL);
-	}
+	} else if (lastblock == block) {
 	/*
 	 * We will extend last allocated block
 	 */
-	else if (lastblock == block) {
-		tmp = ufs_new_fragments(inode, p, fragment - (blockoff - lastblockoff),
-					fs32_to_cpu(sb, *p), required +  (blockoff - lastblockoff),
+		tmp = ufs_new_fragments(inode, p, fragment -
+					(blockoff - lastblockoff),
+					ufs_data_ptr_to_cpu(sb, p),
+					required +  (blockoff - lastblockoff),
 					err, phys != NULL ? locked_page : NULL);
 	} else /* (lastblock > block) */ {
 	/*
 	 * We will allocate new block before last allocated block
 	 */
 		if (block) {
-			tmp = fs32_to_cpu(sb, ufsi->i_u1.i_data[block-1]);
+			tmp = ufs_data_ptr_to_cpu(sb,
+						 ufs_get_direct_data_ptr(uspi, ufsi, block - 1));
 			if (tmp)
 				goal = tmp + uspi->s_fpb;
 		}
@@ -266,7 +274,7 @@ ufs_inode_getfrag(struct inode *inode, unsigned int fragment,
 					phys != NULL ? locked_page : NULL);
 	}
 	if (!tmp) {
-		if ((!blockoff && *p) || 
+		if ((!blockoff && ufs_data_ptr_to_cpu(sb, p)) ||
 		    (blockoff && lastfrag != ufsi->i_lastfrag))
 			goto repeat;
 		*err = -ENOSPC;
@@ -286,7 +294,7 @@ ufs_inode_getfrag(struct inode *inode, unsigned int fragment,
 	if (IS_SYNC(inode))
 		ufs_sync_inode (inode);
 	mark_inode_dirty(inode);
-	UFSD("EXIT, result %u\n", tmp + blockoff);
+	UFSD("EXIT, result %llu\n", (unsigned long long)tmp + blockoff);
 	return result;
 
      /* This part : To be implemented ....
@@ -320,20 +328,22 @@ ufs_inode_getfrag(struct inode *inode, unsigned int fragment,
  */
 static struct buffer_head *
 ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
-		  unsigned int fragment, sector_t new_fragment, int *err,
+		  u64 fragment, sector_t new_fragment, int *err,
 		  long *phys, int *new, struct page *locked_page)
 {
 	struct super_block *sb = inode->i_sb;
 	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
 	struct buffer_head * result;
-	unsigned tmp, goal, block, blockoff;
-	__fs32 * p;
+	unsigned blockoff;
+	u64 tmp, goal, block;
+	void *p;
 
 	block = ufs_fragstoblks (fragment);
 	blockoff = ufs_fragnum (fragment);
 
-	UFSD("ENTER, ino %lu, fragment %u, new_fragment %llu, metadata %d\n",
-	     inode->i_ino, fragment, (unsigned long long)new_fragment, !phys);
+	UFSD("ENTER, ino %lu, fragment %llu, new_fragment %llu, metadata %d\n",
+	     inode->i_ino, (unsigned long long)fragment,
+	     (unsigned long long)new_fragment, !phys);
 
 	result = NULL;
 	if (!bh)
@@ -344,14 +354,16 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 		if (!buffer_uptodate(bh))
 			goto out;
 	}
-
-	p = (__fs32 *) bh->b_data + block;
+	if (uspi->fs_magic == UFS2_MAGIC)
+		p = (__fs64 *)bh->b_data + block;
+	else
+		p = (__fs32 *)bh->b_data + block;
 repeat:
-	tmp = fs32_to_cpu(sb, *p);
+	tmp = ufs_data_ptr_to_cpu(sb, p);
 	if (tmp) {
 		if (!phys) {
 			result = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
-			if (tmp == fs32_to_cpu(sb, *p))
+			if (tmp == ufs_data_ptr_to_cpu(sb, p))
 				goto out;
 			brelse (result);
 			goto repeat;
@@ -361,14 +373,16 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 		}
 	}
 
-	if (block && (tmp = fs32_to_cpu(sb, ((__fs32*)bh->b_data)[block-1])))
+	if (block && (uspi->fs_magic == UFS2_MAGIC ?
+		      (tmp = fs64_to_cpu(sb, ((__fs64 *)bh->b_data)[block-1])) :
+		      (tmp = fs32_to_cpu(sb, ((__fs32 *)bh->b_data)[block-1]))))
 		goal = tmp + uspi->s_fpb;
 	else
 		goal = bh->b_blocknr + uspi->s_fpb;
 	tmp = ufs_new_fragments(inode, p, ufs_blknum(new_fragment), goal,
 				uspi->s_fpb, err, locked_page);
 	if (!tmp) {
-		if (fs32_to_cpu(sb, *p))
+		if (ufs_data_ptr_to_cpu(sb, p))
 			goto repeat;
 		goto out;
 	}		
@@ -386,7 +400,7 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 		sync_dirty_buffer(bh);
 	inode->i_ctime = CURRENT_TIME_SEC;
 	mark_inode_dirty(inode);
-	UFSD("result %u\n", tmp + blockoff);
+	UFSD("result %llu\n", (unsigned long long)tmp + blockoff);
 out:
 	brelse (bh);
 	UFSD("EXIT\n");

commit 3313e29267414e4e3bf0d3de1caf9cb439b64aaf
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Mon Feb 12 00:54:31 2007 -0800

    [PATCH] ufs2 write: inodes write
    
    This patch adds into write inode path function to write UFS2 inode, and
    modifys allocate inode path to allocate and init additional inode chunks.
    
    Also some cleanups:
    - remove not used parameters in some functions
    - remove i_gen field from ufs_inode_info structure,
    there is i_generation in inode structure with same purposes.
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 4295ca91cf85..dd52eecdcb0f 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -616,8 +616,8 @@ static void ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 	inode->i_atime.tv_nsec = 0;
 	inode->i_ctime.tv_nsec = 0;
 	inode->i_blocks = fs32_to_cpu(sb, ufs_inode->ui_blocks);
+	inode->i_generation = fs32_to_cpu(sb, ufs_inode->ui_gen);
 	ufsi->i_flags = fs32_to_cpu(sb, ufs_inode->ui_flags);
-	ufsi->i_gen = fs32_to_cpu(sb, ufs_inode->ui_gen);
 	ufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);
 	ufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);
 
@@ -661,8 +661,8 @@ static void ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)
 	inode->i_atime.tv_nsec = 0;
 	inode->i_ctime.tv_nsec = 0;
 	inode->i_blocks = fs64_to_cpu(sb, ufs2_inode->ui_blocks);
+	inode->i_generation = fs32_to_cpu(sb, ufs2_inode->ui_gen);
 	ufsi->i_flags = fs32_to_cpu(sb, ufs2_inode->ui_flags);
-	ufsi->i_gen = fs32_to_cpu(sb, ufs2_inode->ui_gen);
 	/*
 	ufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);
 	ufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);
@@ -731,34 +731,11 @@ void ufs_read_inode(struct inode * inode)
 	make_bad_inode(inode);
 }
 
-static int ufs_update_inode(struct inode * inode, int do_sync)
+static void ufs1_update_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 {
-	struct ufs_inode_info *ufsi = UFS_I(inode);
-	struct super_block * sb;
-	struct ufs_sb_private_info * uspi;
-	struct buffer_head * bh;
-	struct ufs_inode * ufs_inode;
-	unsigned i;
-	unsigned flags;
-
-	UFSD("ENTER, ino %lu\n", inode->i_ino);
-
-	sb = inode->i_sb;
-	uspi = UFS_SB(sb)->s_uspi;
-	flags = UFS_SB(sb)->s_flags;
-
-	if (inode->i_ino < UFS_ROOTINO || 
-	    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {
-		ufs_warning (sb, "ufs_read_inode", "bad inode number (%lu)\n", inode->i_ino);
-		return -1;
-	}
-
-	bh = sb_bread(sb, ufs_inotofsba(inode->i_ino));
-	if (!bh) {
-		ufs_warning (sb, "ufs_read_inode", "unable to read inode %lu\n", inode->i_ino);
-		return -1;
-	}
-	ufs_inode = (struct ufs_inode *) (bh->b_data + ufs_inotofsbo(inode->i_ino) * sizeof(struct ufs_inode));
+	struct super_block *sb = inode->i_sb;
+ 	struct ufs_inode_info *ufsi = UFS_I(inode);
+ 	unsigned i;
 
 	ufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);
 	ufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);
@@ -775,9 +752,9 @@ static int ufs_update_inode(struct inode * inode, int do_sync)
 	ufs_inode->ui_mtime.tv_usec = 0;
 	ufs_inode->ui_blocks = cpu_to_fs32(sb, inode->i_blocks);
 	ufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);
-	ufs_inode->ui_gen = cpu_to_fs32(sb, ufsi->i_gen);
+	ufs_inode->ui_gen = cpu_to_fs32(sb, inode->i_generation);
 
-	if ((flags & UFS_UID_MASK) == UFS_UID_EFT) {
+	if ((UFS_SB(sb)->s_flags & UFS_UID_MASK) == UFS_UID_EFT) {
 		ufs_inode->ui_u3.ui_sun.ui_shadow = cpu_to_fs32(sb, ufsi->i_shadow);
 		ufs_inode->ui_u3.ui_sun.ui_oeftflag = cpu_to_fs32(sb, ufsi->i_oeftflag);
 	}
@@ -796,6 +773,78 @@ static int ufs_update_inode(struct inode * inode, int do_sync)
 
 	if (!inode->i_nlink)
 		memset (ufs_inode, 0, sizeof(struct ufs_inode));
+}
+
+static void ufs2_update_inode(struct inode *inode, struct ufs2_inode *ufs_inode)
+{
+	struct super_block *sb = inode->i_sb;
+ 	struct ufs_inode_info *ufsi = UFS_I(inode);
+ 	unsigned i;
+
+	UFSD("ENTER\n");
+	ufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);
+	ufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);
+
+	ufs_inode->ui_uid = cpu_to_fs32(sb, inode->i_uid);
+	ufs_inode->ui_gid = cpu_to_fs32(sb, inode->i_gid);
+
+	ufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);
+	ufs_inode->ui_atime.tv_sec = cpu_to_fs32(sb, inode->i_atime.tv_sec);
+	ufs_inode->ui_atime.tv_usec = 0;
+	ufs_inode->ui_ctime.tv_sec = cpu_to_fs32(sb, inode->i_ctime.tv_sec);
+	ufs_inode->ui_ctime.tv_usec = 0;
+	ufs_inode->ui_mtime.tv_sec = cpu_to_fs32(sb, inode->i_mtime.tv_sec);
+	ufs_inode->ui_mtime.tv_usec = 0;
+
+	ufs_inode->ui_blocks = cpu_to_fs64(sb, inode->i_blocks);
+	ufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);
+	ufs_inode->ui_gen = cpu_to_fs32(sb, inode->i_generation);
+
+	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {
+		/* ufs_inode->ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode->i_rdev); */
+		ufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.u2_i_data[0];
+	} else if (inode->i_blocks) {
+		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR); i++)
+			ufs_inode->ui_u2.ui_addr.ui_db[i] = ufsi->i_u1.u2_i_data[i];
+	} else {
+		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR) * 4; i++)
+			ufs_inode->ui_u2.ui_symlink[i] = ufsi->i_u1.i_symlink[i];
+ 	}
+
+	if (!inode->i_nlink)
+		memset (ufs_inode, 0, sizeof(struct ufs2_inode));
+	UFSD("EXIT\n");
+}
+
+static int ufs_update_inode(struct inode * inode, int do_sync)
+{
+	struct super_block *sb = inode->i_sb;
+	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
+	struct buffer_head * bh;
+
+	UFSD("ENTER, ino %lu\n", inode->i_ino);
+
+	if (inode->i_ino < UFS_ROOTINO ||
+	    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {
+		ufs_warning (sb, "ufs_read_inode", "bad inode number (%lu)\n", inode->i_ino);
+		return -1;
+	}
+
+	bh = sb_bread(sb, ufs_inotofsba(inode->i_ino));
+	if (!bh) {
+		ufs_warning (sb, "ufs_read_inode", "unable to read inode %lu\n", inode->i_ino);
+		return -1;
+	}
+	if (uspi->fs_magic == UFS2_MAGIC) {
+		struct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;
+
+		ufs2_update_inode(inode,
+				  ufs2_inode + ufs_inotofsbo(inode->i_ino));
+	} else {
+		struct ufs_inode *ufs_inode = (struct ufs_inode *) bh->b_data;
+
+		ufs1_update_inode(inode, ufs_inode + ufs_inotofsbo(inode->i_ino));
+	}
 		
 	mark_buffer_dirty(bh);
 	if (do_sync)

commit a685e26fff387db350966f88eaad515bf41c4705
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Mon Jan 29 13:19:54 2007 -0800

    [PATCH] ufs: alloc metadata null page fix
    
    These series of patches result of UFS1 write support stress testing, like
    running fsx-linux, untar and build linux kernel etc
    
    We pass from ufs::get_block_t to levels below: pointer to the current page, to
    make possible things like reallocation of blocks on the fly, and we also uses
    this pointer for indication, what actually we allocate data block or meta data
    block, but currently we make decision about what we allocate on the wrong
    level, this may and cause oops if we allocate blocks in some special order.
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 2fbab0aab688..4295ca91cf85 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -242,7 +242,8 @@ ufs_inode_getfrag(struct inode *inode, unsigned int fragment,
 			goal = tmp + uspi->s_fpb;
 		tmp = ufs_new_fragments (inode, p, fragment - blockoff, 
 					 goal, required + blockoff,
-					 err, locked_page);
+					 err,
+					 phys != NULL ? locked_page : NULL);
 	}
 	/*
 	 * We will extend last allocated block
@@ -250,7 +251,7 @@ ufs_inode_getfrag(struct inode *inode, unsigned int fragment,
 	else if (lastblock == block) {
 		tmp = ufs_new_fragments(inode, p, fragment - (blockoff - lastblockoff),
 					fs32_to_cpu(sb, *p), required +  (blockoff - lastblockoff),
-					err, locked_page);
+					err, phys != NULL ? locked_page : NULL);
 	} else /* (lastblock > block) */ {
 	/*
 	 * We will allocate new block before last allocated block
@@ -261,7 +262,8 @@ ufs_inode_getfrag(struct inode *inode, unsigned int fragment,
 				goal = tmp + uspi->s_fpb;
 		}
 		tmp = ufs_new_fragments(inode, p, fragment - blockoff,
-					goal, uspi->s_fpb, err, locked_page);
+					goal, uspi->s_fpb, err,
+					phys != NULL ? locked_page : NULL);
 	}
 	if (!tmp) {
 		if ((!blockoff && *p) || 
@@ -438,9 +440,11 @@ int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head
 	 * it much more readable:
 	 */
 #define GET_INODE_DATABLOCK(x) \
-	ufs_inode_getfrag(inode, x, fragment, 1, &err, &phys, &new, bh_result->b_page)
+	ufs_inode_getfrag(inode, x, fragment, 1, &err, &phys, &new,\
+			  bh_result->b_page)
 #define GET_INODE_PTR(x) \
-	ufs_inode_getfrag(inode, x, fragment, uspi->s_fpb, &err, NULL, NULL, NULL)
+	ufs_inode_getfrag(inode, x, fragment, uspi->s_fpb, &err, NULL, NULL,\
+			  bh_result->b_page)
 #define GET_INDIRECT_DATABLOCK(x) \
 	ufs_inode_getblock(inode, bh, x, fragment,	\
 			  &err, &phys, &new, bh_result->b_page)

commit d63b70902befe189ba2672925f28ec3f4db41352
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Fri Jan 5 16:37:04 2007 -0800

    [PATCH] fix garbage instead of zeroes in UFS
    
    Looks like this is the problem, which point Al Viro some time ago:
    
    ufs's get_block callback allocates 16k of disk at a time, and links that
    entire 16k into the file's metadata.  But because get_block is called for only
    a single buffer_head (a 2k buffer_head in this case?) we are only able to tell
    the VFS that this 2k is buffer_new().
    
    So when ufs_getfrag_block() is later called to map some more data in the file,
    and when that data resides within the remaining 14k of this fragment,
    ufs_getfrag_block() will incorrectly return a !buffer_new() buffer_head.
    
    I don't see _right_ way to do nullification of whole block, if use inode
    page cache, some pages may be outside of inode limits (inode size), and
    will be lost; if use blockdev page cache it is possible to zero real data,
    if later inode page cache will be used.
    
    The simpliest way, as can I see usage of block device page cache, but not only
    mark dirty, but also sync it during "nullification".  I use my simple tests
    collection, which I used for check that create,open,write,read,close works on
    ufs, and I see that this patch makes ufs code 18% slower then before.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index ee1eaa6f4ec2..2fbab0aab688 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -156,36 +156,6 @@ static u64 ufs_frag_map(struct inode *inode, sector_t frag)
 	return ret;
 }
 
-static void ufs_clear_frag(struct inode *inode, struct buffer_head *bh)
-{
-	lock_buffer(bh);
-	memset(bh->b_data, 0, inode->i_sb->s_blocksize);
-	set_buffer_uptodate(bh);
-	mark_buffer_dirty(bh);
-	unlock_buffer(bh);
-	if (IS_SYNC(inode))
-		sync_dirty_buffer(bh);
-}
-
-static struct buffer_head *
-ufs_clear_frags(struct inode *inode, sector_t beg,
-		unsigned int n, sector_t want)
-{
-	struct buffer_head *res = NULL, *bh;
-	sector_t end = beg + n;
-
-	for (; beg < end; ++beg) {
-		bh = sb_getblk(inode->i_sb, beg);
-		ufs_clear_frag(inode, bh);
-		if (want != beg)
-			brelse(bh);
-		else
-			res = bh;
-	}
-	BUG_ON(!res);
-	return res;
-}
-
 /**
  * ufs_inode_getfrag() - allocate new fragment(s)
  * @inode - pointer to inode
@@ -302,7 +272,7 @@ ufs_inode_getfrag(struct inode *inode, unsigned int fragment,
 	}
 
 	if (!phys) {
-		result = ufs_clear_frags(inode, tmp, required, tmp + blockoff);
+		result = sb_getblk(sb, tmp + blockoff);
 	} else {
 		*phys = tmp + blockoff;
 		result = NULL;
@@ -403,8 +373,7 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 
 
 	if (!phys) {
-		result = ufs_clear_frags(inode, tmp, uspi->s_fpb,
-					 tmp + blockoff);
+		result = sb_getblk(sb, tmp + blockoff);
 	} else {
 		*phys = tmp + blockoff;
 		*new = 1;
@@ -471,13 +440,13 @@ int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head
 #define GET_INODE_DATABLOCK(x) \
 	ufs_inode_getfrag(inode, x, fragment, 1, &err, &phys, &new, bh_result->b_page)
 #define GET_INODE_PTR(x) \
-	ufs_inode_getfrag(inode, x, fragment, uspi->s_fpb, &err, NULL, NULL, bh_result->b_page)
+	ufs_inode_getfrag(inode, x, fragment, uspi->s_fpb, &err, NULL, NULL, NULL)
 #define GET_INDIRECT_DATABLOCK(x) \
 	ufs_inode_getblock(inode, bh, x, fragment,	\
-			  &err, &phys, &new, bh_result->b_page);
+			  &err, &phys, &new, bh_result->b_page)
 #define GET_INDIRECT_PTR(x) \
 	ufs_inode_getblock(inode, bh, x, fragment,	\
-			  &err, NULL, NULL, bh_result->b_page);
+			  &err, NULL, NULL, NULL)
 
 	if (ptr < UFS_NDIR_FRAGMENT) {
 		bh = GET_INODE_DATABLOCK(ptr);

commit ba52de123d454b57369f291348266d86f4b35070
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Wed Sep 27 01:50:49 2006 -0700

    [PATCH] inode-diet: Eliminate i_blksize from the inode structure
    
    This eliminates the i_blksize field from struct inode.  Filesystems that want
    to provide a per-inode st_blksize can do so by providing their own getattr
    routine instead of using the generic_fillattr() function.
    
    Note that some filesystems were providing pretty much random (and incorrect)
    values for i_blksize.
    
    [bunk@stusta.de: cleanup]
    [akpm@osdl.org: generic_fillattr() fix]
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 30c6e8a9446c..ee1eaa6f4ec2 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -741,7 +741,6 @@ void ufs_read_inode(struct inode * inode)
 		ufs1_read_inode(inode, ufs_inode + ufs_inotofsbo(inode->i_ino));
 	}
 
-	inode->i_blksize = PAGE_SIZE;/*This is the optimal IO size (for stat)*/
 	inode->i_version++;
 	ufsi->i_lastfrag =
 		(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;

commit c37336b078ba9d2ff38c535b194996a7ad6e69f8
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Sun Aug 27 01:23:45 2006 -0700

    [PATCH] ufs: write to hole in big file
    
    On UFS, this scenario:
            open(O_TRUNC)
            lseek(1024 * 1024 * 80)
            write("A")
            lseek(1024 * 2)
            write("A")
    
    may cause access to invalid address.
    
    This happened because of "goal" is calculated in wrong way in block
    allocation path, as I see this problem exists also in 2.4.
    
    We use construction like this i_data[lastfrag], i_data array of pointers to
    direct blocks, indirect and so on, it has ceratain size ~20 elements, and
    lastfrag may have value for example 40000.
    
    Also this patch fixes related to handling such scenario issues, wrong
    zeroing metadata, in case of block(not fragment) allocation, and wrong goal
    calculation, when we allocate block
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index e7c8615beb65..30c6e8a9446c 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -169,18 +169,20 @@ static void ufs_clear_frag(struct inode *inode, struct buffer_head *bh)
 
 static struct buffer_head *
 ufs_clear_frags(struct inode *inode, sector_t beg,
-		unsigned int n)
+		unsigned int n, sector_t want)
 {
-	struct buffer_head *res, *bh;
+	struct buffer_head *res = NULL, *bh;
 	sector_t end = beg + n;
 
-	res = sb_getblk(inode->i_sb, beg);
-	ufs_clear_frag(inode, res);
-	for (++beg; beg < end; ++beg) {
+	for (; beg < end; ++beg) {
 		bh = sb_getblk(inode->i_sb, beg);
 		ufs_clear_frag(inode, bh);
-		brelse(bh);
+		if (want != beg)
+			brelse(bh);
+		else
+			res = bh;
 	}
+	BUG_ON(!res);
 	return res;
 }
 
@@ -265,7 +267,9 @@ ufs_inode_getfrag(struct inode *inode, unsigned int fragment,
 			lastfrag = ufsi->i_lastfrag;
 			
 		}
-		goal = fs32_to_cpu(sb, ufsi->i_u1.i_data[lastblock]) + uspi->s_fpb;
+		tmp = fs32_to_cpu(sb, ufsi->i_u1.i_data[lastblock]);
+		if (tmp)
+			goal = tmp + uspi->s_fpb;
 		tmp = ufs_new_fragments (inode, p, fragment - blockoff, 
 					 goal, required + blockoff,
 					 err, locked_page);
@@ -277,13 +281,15 @@ ufs_inode_getfrag(struct inode *inode, unsigned int fragment,
 		tmp = ufs_new_fragments(inode, p, fragment - (blockoff - lastblockoff),
 					fs32_to_cpu(sb, *p), required +  (blockoff - lastblockoff),
 					err, locked_page);
-	}
+	} else /* (lastblock > block) */ {
 	/*
 	 * We will allocate new block before last allocated block
 	 */
-	else /* (lastblock > block) */ {
-		if (lastblock && (tmp = fs32_to_cpu(sb, ufsi->i_u1.i_data[lastblock-1])))
-			goal = tmp + uspi->s_fpb;
+		if (block) {
+			tmp = fs32_to_cpu(sb, ufsi->i_u1.i_data[block-1]);
+			if (tmp)
+				goal = tmp + uspi->s_fpb;
+		}
 		tmp = ufs_new_fragments(inode, p, fragment - blockoff,
 					goal, uspi->s_fpb, err, locked_page);
 	}
@@ -296,7 +302,7 @@ ufs_inode_getfrag(struct inode *inode, unsigned int fragment,
 	}
 
 	if (!phys) {
-		result = ufs_clear_frags(inode, tmp + blockoff, required);
+		result = ufs_clear_frags(inode, tmp, required, tmp + blockoff);
 	} else {
 		*phys = tmp + blockoff;
 		result = NULL;
@@ -383,7 +389,7 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 		}
 	}
 
-	if (block && (tmp = fs32_to_cpu(sb, ((__fs32*)bh->b_data)[block-1]) + uspi->s_fpb))
+	if (block && (tmp = fs32_to_cpu(sb, ((__fs32*)bh->b_data)[block-1])))
 		goal = tmp + uspi->s_fpb;
 	else
 		goal = bh->b_blocknr + uspi->s_fpb;
@@ -397,7 +403,8 @@ ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
 
 
 	if (!phys) {
-		result = ufs_clear_frags(inode, tmp + blockoff, uspi->s_fpb);
+		result = ufs_clear_frags(inode, tmp, uspi->s_fpb,
+					 tmp + blockoff);
 	} else {
 		*phys = tmp + blockoff;
 		*new = 1;

commit 10e5dce07e6f8f9cea1b54161a888bb099484f88
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Sat Jul 1 04:36:24 2006 -0700

    [PATCH] ufs: truncate should allocate block for last byte
    
    This patch fixes buggy behaviour of UFS
    in such kind of scenario:
    open(, O_TRUNC...)
    ftruncate(, 1024)
    ftruncate(, 0)
    
    Such a scenario causes ufs_panic and remount read-only.  This happen
    because of according to specification UFS should always allocate block for
    last byte, and many parts of our implementation rely on this, but
    `ufs_truncate' doesn't care about this.
    
    To make possible return error code and to know about old size, this patch
    removes `truncate' from ufs inode_operations and uses `setattr' method to
    call ufs_truncate.
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 488b5ff48afb..e7c8615beb65 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -843,14 +843,17 @@ int ufs_sync_inode (struct inode *inode)
 
 void ufs_delete_inode (struct inode * inode)
 {
+	loff_t old_i_size;
+
 	truncate_inode_pages(&inode->i_data, 0);
 	/*UFS_I(inode)->i_dtime = CURRENT_TIME;*/
 	lock_kernel();
 	mark_inode_dirty(inode);
 	ufs_update_inode(inode, IS_SYNC(inode));
+	old_i_size = inode->i_size;
 	inode->i_size = 0;
-	if (inode->i_blocks)
-		ufs_truncate (inode);
+	if (inode->i_blocks && ufs_truncate(inode, old_i_size))
+		ufs_warning(inode->i_sb, __FUNCTION__, "ufs_truncate failed\n");
 	ufs_free_inode (inode);
 	unlock_kernel();
 }

commit 7256d819e43f89af6ba30047936c96c683436941
Author: Andrew Morton <akpm@osdl.org>
Date:   Thu Jun 29 02:24:29 2006 -0700

    [PATCH] ufs: printk() fix
    
    fs/ufs/inode.c: In function `ufs_frag_map':
    fs/ufs/inode.c:101: warning: long long unsigned int format, u64 arg (arg 4)
    fs/ufs/inode.c: In function `ufs_getfrag_block':
    fs/ufs/inode.c:432: warning: long long unsigned int format, u64 arg (arg 2)
    
    Cc: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 8e1f90e42040..488b5ff48afb 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -98,7 +98,9 @@ static u64 ufs_frag_map(struct inode *inode, sector_t frag)
 	u64 temp = 0L;
 
 	UFSD(": frag = %llu  depth = %d\n", (unsigned long long)frag, depth);
-	UFSD(": uspi->s_fpbshift = %d ,uspi->s_apbmask = %x, mask=%llx\n",uspi->s_fpbshift,uspi->s_apbmask,mask);
+	UFSD(": uspi->s_fpbshift = %d ,uspi->s_apbmask = %x, mask=%llx\n",
+		uspi->s_fpbshift, uspi->s_apbmask,
+		(unsigned long long)mask);
 
 	if (depth == 0)
 		return 0;
@@ -429,7 +431,7 @@ int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head
 	
 	if (!create) {
 		phys64 = ufs_frag_map(inode, fragment);
-		UFSD("phys64 = %llu \n",phys64);
+		UFSD("phys64 = %llu\n", (unsigned long long)phys64);
 		if (phys64)
 			map_bh(bh_result, sb, phys64);
 		return 0;

commit f5e54d6e53a20cef45af7499e86164f0e0d16bb2
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jun 28 04:26:44 2006 -0700

    [PATCH] mark address_space_operations const
    
    Same as with already do with the file operations: keep them in .rodata and
    prevents people from doing runtime patching.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Steven French <sfrench@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 259bd196099d..8e1f90e42040 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -574,7 +574,7 @@ static sector_t ufs_bmap(struct address_space *mapping, sector_t block)
 {
 	return generic_block_bmap(mapping,block,ufs_getfrag_block);
 }
-struct address_space_operations ufs_aops = {
+const struct address_space_operations ufs_aops = {
 	.readpage = ufs_readpage,
 	.writepage = ufs_writepage,
 	.sync_page = block_sync_page,

commit 05f225dc8729d3e5703b8c34e750fdca67bcefe6
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Tue Jun 27 02:53:59 2006 -0700

    [PATCH] ufs: ufs_read_inode cleanup
    
    Add missed ufsi->i_dir_start_lookup initialization in ufs_read_inode in
    UFS2 case.  Also it cleans ufs_read_inode function to prevent such kind of
    situation in the future: it move depend on UFS type parts of code into
    separate functions and leaves in ufs_read_inode only generic code.  It
    cleans code and avoids duplication.
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index f2dbdf5a8769..259bd196099d 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -605,39 +605,12 @@ static void ufs_set_inode_ops(struct inode *inode)
 				   ufs_get_inode_dev(inode->i_sb, UFS_I(inode)));
 }
 
-void ufs_read_inode (struct inode * inode)
+static void ufs1_read_inode(struct inode *inode, struct ufs_inode *ufs_inode)
 {
 	struct ufs_inode_info *ufsi = UFS_I(inode);
-	struct super_block * sb;
-	struct ufs_sb_private_info * uspi;
-	struct ufs_inode * ufs_inode;	
-	struct ufs2_inode *ufs2_inode;
-	struct buffer_head * bh;
+	struct super_block *sb = inode->i_sb;
 	mode_t mode;
 	unsigned i;
-	unsigned flags;
-	
-	UFSD("ENTER, ino %lu\n", inode->i_ino);
-	
-	sb = inode->i_sb;
-	uspi = UFS_SB(sb)->s_uspi;
-	flags = UFS_SB(sb)->s_flags;
-
-	if (inode->i_ino < UFS_ROOTINO || 
-	    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {
-		ufs_warning (sb, "ufs_read_inode", "bad inode number (%lu)\n", inode->i_ino);
-		goto bad_inode;
-	}
-	
-	bh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));
-	if (!bh) {
-		ufs_warning (sb, "ufs_read_inode", "unable to read inode %lu\n", inode->i_ino);
-		goto bad_inode;
-	}
-	if ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)
-		goto ufs2_inode;
-
-	ufs_inode = (struct ufs_inode *) (bh->b_data + sizeof(struct ufs_inode) * ufs_inotofsbo(inode->i_ino));
 
 	/*
 	 * Copy data to the in-core inode.
@@ -661,14 +634,11 @@ void ufs_read_inode (struct inode * inode)
 	inode->i_atime.tv_nsec = 0;
 	inode->i_ctime.tv_nsec = 0;
 	inode->i_blocks = fs32_to_cpu(sb, ufs_inode->ui_blocks);
-	inode->i_blksize = PAGE_SIZE;   /* This is the optimal IO size (for stat) */
-	inode->i_version++;
 	ufsi->i_flags = fs32_to_cpu(sb, ufs_inode->ui_flags);
 	ufsi->i_gen = fs32_to_cpu(sb, ufs_inode->ui_gen);
 	ufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);
 	ufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);
-	ufsi->i_lastfrag = (inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;
-	ufsi->i_dir_start_lookup = 0;
+
 	
 	if (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {
 		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR); i++)
@@ -677,24 +647,16 @@ void ufs_read_inode (struct inode * inode)
 		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR) * 4; i++)
 			ufsi->i_u1.i_symlink[i] = ufs_inode->ui_u2.ui_symlink[i];
 	}
-	ufsi->i_osync = 0;
-
-	ufs_set_inode_ops(inode);
-
-	brelse (bh);
-
-	UFSD("EXIT\n");
-	return;
+}
 
-bad_inode:
-	make_bad_inode(inode);
-	return;
+static void ufs2_read_inode(struct inode *inode, struct ufs2_inode *ufs2_inode)
+{
+	struct ufs_inode_info *ufsi = UFS_I(inode);
+	struct super_block *sb = inode->i_sb;
+	mode_t mode;
+	unsigned i;
 
-ufs2_inode :
 	UFSD("Reading ufs2 inode, ino %lu\n", inode->i_ino);
-
-	ufs2_inode = (struct ufs2_inode *)(bh->b_data + sizeof(struct ufs2_inode) * ufs_inotofsbo(inode->i_ino));
-
 	/*
 	 * Copy data to the in-core inode.
 	 */
@@ -717,26 +679,64 @@ ufs2_inode :
 	inode->i_atime.tv_nsec = 0;
 	inode->i_ctime.tv_nsec = 0;
 	inode->i_blocks = fs64_to_cpu(sb, ufs2_inode->ui_blocks);
-	inode->i_blksize = PAGE_SIZE; /*This is the optimal IO size(for stat)*/
-
-	inode->i_version++;
 	ufsi->i_flags = fs32_to_cpu(sb, ufs2_inode->ui_flags);
 	ufsi->i_gen = fs32_to_cpu(sb, ufs2_inode->ui_gen);
 	/*
 	ufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);
 	ufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);
 	*/
-	ufsi->i_lastfrag= (inode->i_size + uspi->s_fsize- 1) >> uspi->s_fshift;
 
 	if (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {
 		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR); i++)
 			ufsi->i_u1.u2_i_data[i] =
 				ufs2_inode->ui_u2.ui_addr.ui_db[i];
-	}
-	else {
+	} else {
 		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR) * 4; i++)
 			ufsi->i_u1.i_symlink[i] = ufs2_inode->ui_u2.ui_symlink[i];
 	}
+}
+
+void ufs_read_inode(struct inode * inode)
+{
+	struct ufs_inode_info *ufsi = UFS_I(inode);
+	struct super_block * sb;
+	struct ufs_sb_private_info * uspi;
+	struct buffer_head * bh;
+
+	UFSD("ENTER, ino %lu\n", inode->i_ino);
+
+	sb = inode->i_sb;
+	uspi = UFS_SB(sb)->s_uspi;
+
+	if (inode->i_ino < UFS_ROOTINO ||
+	    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {
+		ufs_warning(sb, "ufs_read_inode", "bad inode number (%lu)\n",
+			    inode->i_ino);
+		goto bad_inode;
+	}
+
+	bh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));
+	if (!bh) {
+		ufs_warning(sb, "ufs_read_inode", "unable to read inode %lu\n",
+			    inode->i_ino);
+		goto bad_inode;
+	}
+	if ((UFS_SB(sb)->s_flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {
+		struct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;
+
+		ufs2_read_inode(inode,
+				ufs2_inode + ufs_inotofsbo(inode->i_ino));
+	} else {
+		struct ufs_inode *ufs_inode = (struct ufs_inode *)bh->b_data;
+
+		ufs1_read_inode(inode, ufs_inode + ufs_inotofsbo(inode->i_ino));
+	}
+
+	inode->i_blksize = PAGE_SIZE;/*This is the optimal IO size (for stat)*/
+	inode->i_version++;
+	ufsi->i_lastfrag =
+		(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;
+	ufsi->i_dir_start_lookup = 0;
 	ufsi->i_osync = 0;
 
 	ufs_set_inode_ops(inode);
@@ -745,6 +745,9 @@ ufs2_inode :
 
 	UFSD("EXIT\n");
 	return;
+
+bad_inode:
+	make_bad_inode(inode);
 }
 
 static int ufs_update_inode(struct inode * inode, int do_sync)

commit 138bb68ac9d49b0ea7eeecb3a245dc4e20f181da
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sun Jun 25 05:47:32 2006 -0700

    [PATCH] fs/ufs/inode.c: make 2 functions static
    
    Make two needlessly global functions static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 01c5f19cbabe..f2dbdf5a8769 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -41,6 +41,8 @@
 #include "swab.h"
 #include "util.h"
 
+static u64 ufs_frag_map(struct inode *inode, sector_t frag);
+
 static int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t offsets[4])
 {
 	struct ufs_sb_private_info *uspi = UFS_SB(inode->i_sb)->s_uspi;
@@ -80,7 +82,7 @@ static int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t off
  * the begining of the filesystem.
  */
 
-u64  ufs_frag_map(struct inode *inode, sector_t frag)
+static u64 ufs_frag_map(struct inode *inode, sector_t frag)
 {
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block *sb = inode->i_sb;
@@ -514,8 +516,9 @@ int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head
 	goto abort;
 }
 
-struct buffer_head *ufs_getfrag(struct inode *inode, unsigned int fragment,
-				int create, int *err)
+static struct buffer_head *ufs_getfrag(struct inode *inode,
+				       unsigned int fragment,
+				       int create, int *err)
 {
 	struct buffer_head dummy;
 	int error;

commit f391475812ba39afa322c835217ffe936f5e754a
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Sun Jun 25 05:47:28 2006 -0700

    [PATCH] ufs: missed brelse and wrong baseblk
    
    This patch fixes two bugs, which introduced by previous patches:
    
    1) Missed "brelse"
    
    2) Sometimes "baseblk" may be wrongly calculated, if i_size is equal to
       zero, which lead infinite cycle in "mpage_writepages".
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 72282043a8f4..01c5f19cbabe 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -175,6 +175,7 @@ ufs_clear_frags(struct inode *inode, sector_t beg,
 	for (++beg; beg < end; ++beg) {
 		bh = sb_getblk(inode->i_sb, beg);
 		ufs_clear_frag(inode, bh);
+		brelse(bh);
 	}
 	return res;
 }

commit 022a6dc5f461a30615bcd1687569abeee7ef8ba2
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Sun Jun 25 05:47:27 2006 -0700

    [PATCH] ufs: zero metadata
    
    Presently if we allocate several "metadata" blocks (pointers to indirect
    blocks for example), we fill with zeroes only the first block.  This cause
    some problems in "truncate" function.  Also this patch remove some unused
    arguments from several functions and add comments.
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index c57612d443d0..72282043a8f4 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -152,7 +152,7 @@ u64  ufs_frag_map(struct inode *inode, sector_t frag)
 	return ret;
 }
 
-static void ufs_clear_block(struct inode *inode, struct buffer_head *bh)
+static void ufs_clear_frag(struct inode *inode, struct buffer_head *bh)
 {
 	lock_buffer(bh);
 	memset(bh->b_data, 0, inode->i_sb->s_blocksize);
@@ -163,27 +163,52 @@ static void ufs_clear_block(struct inode *inode, struct buffer_head *bh)
 		sync_dirty_buffer(bh);
 }
 
-static struct buffer_head *ufs_inode_getfrag(struct inode *inode,
-					     unsigned int fragment, unsigned int new_fragment,
-					     unsigned int required, int *err, int metadata,
-					     long *phys, int *new, struct page *locked_page)
+static struct buffer_head *
+ufs_clear_frags(struct inode *inode, sector_t beg,
+		unsigned int n)
+{
+	struct buffer_head *res, *bh;
+	sector_t end = beg + n;
+
+	res = sb_getblk(inode->i_sb, beg);
+	ufs_clear_frag(inode, res);
+	for (++beg; beg < end; ++beg) {
+		bh = sb_getblk(inode->i_sb, beg);
+		ufs_clear_frag(inode, bh);
+	}
+	return res;
+}
+
+/**
+ * ufs_inode_getfrag() - allocate new fragment(s)
+ * @inode - pointer to inode
+ * @fragment - number of `fragment' which hold pointer
+ *   to new allocated fragment(s)
+ * @new_fragment - number of new allocated fragment(s)
+ * @required - how many fragment(s) we require
+ * @err - we set it if something wrong
+ * @phys - pointer to where we save physical number of new allocated fragments,
+ *   NULL if we allocate not data(indirect blocks for example).
+ * @new - we set it if we allocate new block
+ * @locked_page - for ufs_new_fragments()
+ */
+static struct buffer_head *
+ufs_inode_getfrag(struct inode *inode, unsigned int fragment,
+		  sector_t new_fragment, unsigned int required, int *err,
+		  long *phys, int *new, struct page *locked_page)
 {
 	struct ufs_inode_info *ufsi = UFS_I(inode);
-	struct super_block * sb;
-	struct ufs_sb_private_info * uspi;
+	struct super_block *sb = inode->i_sb;
+	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
 	struct buffer_head * result;
 	unsigned block, blockoff, lastfrag, lastblock, lastblockoff;
 	unsigned tmp, goal;
 	__fs32 * p, * p2;
-	unsigned flags = 0;
 
-	UFSD("ENTER, ino %lu, fragment %u, new_fragment %u, required %u\n",
-		inode->i_ino, fragment, new_fragment, required);
+	UFSD("ENTER, ino %lu, fragment %u, new_fragment %llu, required %u, "
+	     "metadata %d\n", inode->i_ino, fragment,
+	     (unsigned long long)new_fragment, required, !phys);
 
-	sb = inode->i_sb;
-	uspi = UFS_SB(sb)->s_uspi;
-
-	flags = UFS_SB(sb)->s_flags;
         /* TODO : to be done for write support
         if ( (flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)
              goto ufs2;
@@ -198,7 +223,7 @@ static struct buffer_head *ufs_inode_getfrag(struct inode *inode,
 	tmp = fs32_to_cpu(sb, *p);
 	lastfrag = ufsi->i_lastfrag;
 	if (tmp && fragment < lastfrag) {
-		if (metadata) {
+		if (!phys) {
 			result = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
 			if (tmp == fs32_to_cpu(sb, *p)) {
 				UFSD("EXIT, result %u\n", tmp + blockoff);
@@ -265,9 +290,8 @@ static struct buffer_head *ufs_inode_getfrag(struct inode *inode,
 		return NULL;
 	}
 
-	if (metadata) {
-		result = sb_getblk(inode->i_sb, tmp + blockoff);
-		ufs_clear_block(inode, result);
+	if (!phys) {
+		result = ufs_clear_frags(inode, tmp + blockoff, required);
 	} else {
 		*phys = tmp + blockoff;
 		result = NULL;
@@ -298,23 +322,35 @@ static struct buffer_head *ufs_inode_getfrag(struct inode *inode,
      */
 }
 
-static struct buffer_head *ufs_block_getfrag(struct inode *inode, struct buffer_head *bh,
-					     unsigned int fragment, unsigned int new_fragment,
-					     unsigned int blocksize, int * err, int metadata,
-					     long *phys, int *new, struct page *locked_page)
+/**
+ * ufs_inode_getblock() - allocate new block
+ * @inode - pointer to inode
+ * @bh - pointer to block which hold "pointer" to new allocated block
+ * @fragment - number of `fragment' which hold pointer
+ *   to new allocated block
+ * @new_fragment - number of new allocated fragment
+ *  (block will hold this fragment and also uspi->s_fpb-1)
+ * @err - see ufs_inode_getfrag()
+ * @phys - see ufs_inode_getfrag()
+ * @new - see ufs_inode_getfrag()
+ * @locked_page - see ufs_inode_getfrag()
+ */
+static struct buffer_head *
+ufs_inode_getblock(struct inode *inode, struct buffer_head *bh,
+		  unsigned int fragment, sector_t new_fragment, int *err,
+		  long *phys, int *new, struct page *locked_page)
 {
-	struct super_block * sb;
-	struct ufs_sb_private_info * uspi;
+	struct super_block *sb = inode->i_sb;
+	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
 	struct buffer_head * result;
 	unsigned tmp, goal, block, blockoff;
 	__fs32 * p;
 
-	sb = inode->i_sb;
-	uspi = UFS_SB(sb)->s_uspi;
 	block = ufs_fragstoblks (fragment);
 	blockoff = ufs_fragnum (fragment);
 
-	UFSD("ENTER, ino %lu, fragment %u, new_fragment %u\n", inode->i_ino, fragment, new_fragment);
+	UFSD("ENTER, ino %lu, fragment %u, new_fragment %llu, metadata %d\n",
+	     inode->i_ino, fragment, (unsigned long long)new_fragment, !phys);
 
 	result = NULL;
 	if (!bh)
@@ -330,7 +366,7 @@ static struct buffer_head *ufs_block_getfrag(struct inode *inode, struct buffer_
 repeat:
 	tmp = fs32_to_cpu(sb, *p);
 	if (tmp) {
-		if (metadata) {
+		if (!phys) {
 			result = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
 			if (tmp == fs32_to_cpu(sb, *p))
 				goto out;
@@ -355,9 +391,8 @@ static struct buffer_head *ufs_block_getfrag(struct inode *inode, struct buffer_
 	}		
 
 
-	if (metadata) {
-		result = sb_getblk(sb, tmp + blockoff);
-		ufs_clear_block(inode, result);
+	if (!phys) {
+		result = ufs_clear_frags(inode, tmp + blockoff, uspi->s_fpb);
 	} else {
 		*phys = tmp + blockoff;
 		*new = 1;
@@ -375,11 +410,12 @@ static struct buffer_head *ufs_block_getfrag(struct inode *inode, struct buffer_
 	return result;
 }
 
-/*
- * This function gets the block which contains the fragment.
+/**
+ * ufs_getfrag_bloc() - `get_block_t' function, interface between UFS and
+ * readpage, writepage and so on
  */
 
-int ufs_getfrag_block (struct inode *inode, sector_t fragment, struct buffer_head *bh_result, int create)
+int ufs_getfrag_block(struct inode *inode, sector_t fragment, struct buffer_head *bh_result, int create)
 {
 	struct super_block * sb = inode->i_sb;
 	struct ufs_sb_private_info * uspi = UFS_SB(sb)->s_uspi;
@@ -421,15 +457,15 @@ int ufs_getfrag_block (struct inode *inode, sector_t fragment, struct buffer_hea
 	 * it much more readable:
 	 */
 #define GET_INODE_DATABLOCK(x) \
-	ufs_inode_getfrag(inode, x, fragment, 1, &err, 0, &phys, &new, bh_result->b_page)
+	ufs_inode_getfrag(inode, x, fragment, 1, &err, &phys, &new, bh_result->b_page)
 #define GET_INODE_PTR(x) \
-	ufs_inode_getfrag(inode, x, fragment, uspi->s_fpb, &err, 1, NULL, NULL, bh_result->b_page)
+	ufs_inode_getfrag(inode, x, fragment, uspi->s_fpb, &err, NULL, NULL, bh_result->b_page)
 #define GET_INDIRECT_DATABLOCK(x) \
-	ufs_block_getfrag(inode, bh, x, fragment, sb->s_blocksize,	\
-			  &err, 0, &phys, &new, bh_result->b_page);
+	ufs_inode_getblock(inode, bh, x, fragment,	\
+			  &err, &phys, &new, bh_result->b_page);
 #define GET_INDIRECT_PTR(x) \
-	ufs_block_getfrag(inode, bh, x, fragment, sb->s_blocksize,	\
-			  &err, 1, NULL, NULL, bh_result->b_page);
+	ufs_inode_getblock(inode, bh, x, fragment,	\
+			  &err, NULL, NULL, bh_result->b_page);
 
 	if (ptr < UFS_NDIR_FRAGMENT) {
 		bh = GET_INODE_DATABLOCK(ptr);

commit dd187a2603d9904ddc410441348f0cfc558a5233
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Sun Jun 25 05:47:25 2006 -0700

    [PATCH] ufs: little directory lookup optimization
    
    This patch make little optimization of ufs_find_entry like "ext2" does.  Save
    number of page and reuse it again in the next call.
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 01f754462341..c57612d443d0 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -628,12 +628,12 @@ void ufs_read_inode (struct inode * inode)
 	ufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);
 	ufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);
 	ufsi->i_lastfrag = (inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;
+	ufsi->i_dir_start_lookup = 0;
 	
 	if (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {
 		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR); i++)
 			ufsi->i_u1.i_data[i] = ufs_inode->ui_u2.ui_addr.ui_db[i];
-	}
-	else {
+	} else {
 		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR) * 4; i++)
 			ufsi->i_u1.i_symlink[i] = ufs_inode->ui_u2.ui_symlink[i];
 	}

commit abf5d15fd2e52517dd56a17a846d5a1f900b7db4
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Sun Jun 25 05:47:24 2006 -0700

    [PATCH] ufs: easy debug
    
    Currently to turn on debug mode "user" has to edit ~10 files, to turn off he
    has to do it again.
    
    This patch introduce such changes:
    1)turn on(off) debug messages via ".config"
    2)remove unnecessary duplication of code
    3)make "UFSD" macros more similar to function
    4)fix some compiler warnings
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index c28b7522c9e7..01f754462341 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -41,15 +41,6 @@
 #include "swab.h"
 #include "util.h"
 
-#undef UFS_INODE_DEBUG
-#undef UFS_INODE_DEBUG_MORE
-
-#ifdef UFS_INODE_DEBUG
-#define UFSD(x) printk("(%s, %d), %s: ", __FILE__, __LINE__, __FUNCTION__); printk x;
-#else
-#define UFSD(x)
-#endif
-
 static int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t offsets[4])
 {
 	struct ufs_sb_private_info *uspi = UFS_SB(inode->i_sb)->s_uspi;
@@ -61,7 +52,7 @@ static int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t off
 	int n = 0;
 
 
-	UFSD(("ptrs=uspi->s_apb = %d,double_blocks=%ld \n",ptrs,double_blocks));
+	UFSD("ptrs=uspi->s_apb = %d,double_blocks=%ld \n",ptrs,double_blocks);
 	if (i_block < 0) {
 		ufs_warning(inode->i_sb, "ufs_block_to_path", "block < 0");
 	} else if (i_block < direct_blocks) {
@@ -104,8 +95,8 @@ u64  ufs_frag_map(struct inode *inode, sector_t frag)
 	unsigned flags = UFS_SB(sb)->s_flags;
 	u64 temp = 0L;
 
-	UFSD((": frag = %llu  depth = %d\n", (unsigned long long)frag, depth));
-	UFSD((": uspi->s_fpbshift = %d ,uspi->s_apbmask = %x, mask=%llx\n",uspi->s_fpbshift,uspi->s_apbmask,mask));
+	UFSD(": frag = %llu  depth = %d\n", (unsigned long long)frag, depth);
+	UFSD(": uspi->s_fpbshift = %d ,uspi->s_apbmask = %x, mask=%llx\n",uspi->s_fpbshift,uspi->s_apbmask,mask);
 
 	if (depth == 0)
 		return 0;
@@ -186,8 +177,8 @@ static struct buffer_head *ufs_inode_getfrag(struct inode *inode,
 	__fs32 * p, * p2;
 	unsigned flags = 0;
 
-	UFSD(("ENTER, ino %lu, fragment %u, new_fragment %u, required %u\n",
-		inode->i_ino, fragment, new_fragment, required))         
+	UFSD("ENTER, ino %lu, fragment %u, new_fragment %u, required %u\n",
+		inode->i_ino, fragment, new_fragment, required);
 
 	sb = inode->i_sb;
 	uspi = UFS_SB(sb)->s_uspi;
@@ -210,7 +201,7 @@ static struct buffer_head *ufs_inode_getfrag(struct inode *inode,
 		if (metadata) {
 			result = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
 			if (tmp == fs32_to_cpu(sb, *p)) {
-				UFSD(("EXIT, result %u\n", tmp + blockoff))
+				UFSD("EXIT, result %u\n", tmp + blockoff);
 				return result;
 			}
 			brelse (result);
@@ -288,7 +279,7 @@ static struct buffer_head *ufs_inode_getfrag(struct inode *inode,
 	if (IS_SYNC(inode))
 		ufs_sync_inode (inode);
 	mark_inode_dirty(inode);
-	UFSD(("EXIT, result %u\n", tmp + blockoff))
+	UFSD("EXIT, result %u\n", tmp + blockoff);
 	return result;
 
      /* This part : To be implemented ....
@@ -323,7 +314,7 @@ static struct buffer_head *ufs_block_getfrag(struct inode *inode, struct buffer_
 	block = ufs_fragstoblks (fragment);
 	blockoff = ufs_fragnum (fragment);
 
-	UFSD(("ENTER, ino %lu, fragment %u, new_fragment %u\n", inode->i_ino, fragment, new_fragment))	
+	UFSD("ENTER, ino %lu, fragment %u, new_fragment %u\n", inode->i_ino, fragment, new_fragment);
 
 	result = NULL;
 	if (!bh)
@@ -377,10 +368,10 @@ static struct buffer_head *ufs_block_getfrag(struct inode *inode, struct buffer_
 		sync_dirty_buffer(bh);
 	inode->i_ctime = CURRENT_TIME_SEC;
 	mark_inode_dirty(inode);
-	UFSD(("result %u\n", tmp + blockoff));
+	UFSD("result %u\n", tmp + blockoff);
 out:
 	brelse (bh);
-	UFSD(("EXIT\n"));
+	UFSD("EXIT\n");
 	return result;
 }
 
@@ -399,7 +390,7 @@ int ufs_getfrag_block (struct inode *inode, sector_t fragment, struct buffer_hea
 	
 	if (!create) {
 		phys64 = ufs_frag_map(inode, fragment);
-		UFSD(("phys64 = %llu \n",phys64));
+		UFSD("phys64 = %llu \n",phys64);
 		if (phys64)
 			map_bh(bh_result, sb, phys64);
 		return 0;
@@ -414,7 +405,7 @@ int ufs_getfrag_block (struct inode *inode, sector_t fragment, struct buffer_hea
 
 	lock_kernel();
 
-	UFSD(("ENTER, ino %lu, fragment %llu\n", inode->i_ino, (unsigned long long)fragment))
+	UFSD("ENTER, ino %lu, fragment %llu\n", inode->i_ino, (unsigned long long)fragment);
 	if (fragment < 0)
 		goto abort_negative;
 	if (fragment >
@@ -514,7 +505,7 @@ struct buffer_head * ufs_bread (struct inode * inode, unsigned fragment,
 {
 	struct buffer_head * bh;
 
-	UFSD(("ENTER, ino %lu, fragment %u\n", inode->i_ino, fragment))
+	UFSD("ENTER, ino %lu, fragment %u\n", inode->i_ino, fragment);
 	bh = ufs_getfrag (inode, fragment, create, err);
 	if (!bh || buffer_uptodate(bh)) 		
 		return bh;
@@ -586,7 +577,7 @@ void ufs_read_inode (struct inode * inode)
 	unsigned i;
 	unsigned flags;
 	
-	UFSD(("ENTER, ino %lu\n", inode->i_ino))
+	UFSD("ENTER, ino %lu\n", inode->i_ino);
 	
 	sb = inode->i_sb;
 	uspi = UFS_SB(sb)->s_uspi;
@@ -652,7 +643,7 @@ void ufs_read_inode (struct inode * inode)
 
 	brelse (bh);
 
-	UFSD(("EXIT\n"))
+	UFSD("EXIT\n");
 	return;
 
 bad_inode:
@@ -660,7 +651,7 @@ void ufs_read_inode (struct inode * inode)
 	return;
 
 ufs2_inode :
-	UFSD(("Reading ufs2 inode, ino %lu\n", inode->i_ino))
+	UFSD("Reading ufs2 inode, ino %lu\n", inode->i_ino);
 
 	ufs2_inode = (struct ufs2_inode *)(bh->b_data + sizeof(struct ufs2_inode) * ufs_inotofsbo(inode->i_ino));
 
@@ -712,7 +703,7 @@ ufs2_inode :
 
 	brelse(bh);
 
-	UFSD(("EXIT\n"))
+	UFSD("EXIT\n");
 	return;
 }
 
@@ -726,7 +717,7 @@ static int ufs_update_inode(struct inode * inode, int do_sync)
 	unsigned i;
 	unsigned flags;
 
-	UFSD(("ENTER, ino %lu\n", inode->i_ino))
+	UFSD("ENTER, ino %lu\n", inode->i_ino);
 
 	sb = inode->i_sb;
 	uspi = UFS_SB(sb)->s_uspi;
@@ -787,7 +778,7 @@ static int ufs_update_inode(struct inode * inode, int do_sync)
 		sync_dirty_buffer(bh);
 	brelse (bh);
 	
-	UFSD(("EXIT\n"))
+	UFSD("EXIT\n");
 	return 0;
 }
 

commit 826843a347cc8fd596a4c73d3fbdf04a1f130b8a
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Sun Jun 25 05:47:21 2006 -0700

    [PATCH] ufs: directory and page cache: install aops
    
    This series of patches finished "bugs fixing" mentioned
    here http://lkml.org/lkml/2006/1/31/275 .
    
    The main bugs:
    * for i in `seq 1 1000`; do touch $i; done - crash system
    * mkdir create directory without "." and ".." entries
    
    The suggested solution is work with page cache instead of straight work
    with blocks.  Such solution has following advantages
    
    * reduce code size and its complexity
    * some global locks go away
    * fix bugs
    
    The most part of code is stolen from ext2, because of it has similar
    directory structure.
    
    Patches testes with UFS1 and UFS2 file systems.
    
    This patch installs i_mapping->a_ops for directory inodes and removes some
    duplicated code.
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index ea2267316a72..c28b7522c9e7 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -552,6 +552,28 @@ struct address_space_operations ufs_aops = {
 	.bmap = ufs_bmap
 };
 
+static void ufs_set_inode_ops(struct inode *inode)
+{
+	if (S_ISREG(inode->i_mode)) {
+		inode->i_op = &ufs_file_inode_operations;
+		inode->i_fop = &ufs_file_operations;
+		inode->i_mapping->a_ops = &ufs_aops;
+	} else if (S_ISDIR(inode->i_mode)) {
+		inode->i_op = &ufs_dir_inode_operations;
+		inode->i_fop = &ufs_dir_operations;
+		inode->i_mapping->a_ops = &ufs_aops;
+	} else if (S_ISLNK(inode->i_mode)) {
+		if (!inode->i_blocks)
+			inode->i_op = &ufs_fast_symlink_inode_operations;
+		else {
+			inode->i_op = &page_symlink_inode_operations;
+			inode->i_mapping->a_ops = &ufs_aops;
+		}
+	} else
+		init_special_inode(inode, inode->i_mode,
+				   ufs_get_inode_dev(inode->i_sb, UFS_I(inode)));
+}
+
 void ufs_read_inode (struct inode * inode)
 {
 	struct ufs_inode_info *ufsi = UFS_I(inode);
@@ -626,23 +648,7 @@ void ufs_read_inode (struct inode * inode)
 	}
 	ufsi->i_osync = 0;
 
-	if (S_ISREG(inode->i_mode)) {
-		inode->i_op = &ufs_file_inode_operations;
-		inode->i_fop = &ufs_file_operations;
-		inode->i_mapping->a_ops = &ufs_aops;
-	} else if (S_ISDIR(inode->i_mode)) {
-		inode->i_op = &ufs_dir_inode_operations;
-		inode->i_fop = &ufs_dir_operations;
-	} else if (S_ISLNK(inode->i_mode)) {
-		if (!inode->i_blocks)
-			inode->i_op = &ufs_fast_symlink_inode_operations;
-		else {
-			inode->i_op = &page_symlink_inode_operations;
-			inode->i_mapping->a_ops = &ufs_aops;
-		}
-	} else
-		init_special_inode(inode, inode->i_mode,
-			ufs_get_inode_dev(sb, ufsi));
+	ufs_set_inode_ops(inode);
 
 	brelse (bh);
 
@@ -702,23 +708,7 @@ ufs2_inode :
 	}
 	ufsi->i_osync = 0;
 
-	if (S_ISREG(inode->i_mode)) {
-		inode->i_op = &ufs_file_inode_operations;
-		inode->i_fop = &ufs_file_operations;
-		inode->i_mapping->a_ops = &ufs_aops;
-	} else if (S_ISDIR(inode->i_mode)) {
-		inode->i_op = &ufs_dir_inode_operations;
-		inode->i_fop = &ufs_dir_operations;
-	} else if (S_ISLNK(inode->i_mode)) {
-		if (!inode->i_blocks)
-			inode->i_op = &ufs_fast_symlink_inode_operations;
-		else {
-			inode->i_op = &page_symlink_inode_operations;
-			inode->i_mapping->a_ops = &ufs_aops;
-		}
-	} else   /* TODO  : here ...*/
-		init_special_inode(inode, inode->i_mode,
-			ufs_get_inode_dev(sb, ufsi));
+	ufs_set_inode_ops(inode);
 
 	brelse(bh);
 

commit 6ef4d6bf86a82965896eaa1a189177239ec2bbab
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Sun Jun 25 05:47:20 2006 -0700

    [PATCH] ufs: change block number on the fly
    
    First of all some necessary notes about UFS by it self: To avoid waste of disk
    space the tail of file consists not from blocks (which is ordinary big enough,
    16K usually), it consists from fragments(which is ordinary 2K).  When file is
    growing its tail occupy 1 fragment, 2 fragments...  At some stage decision to
    allocate whole block is made and all fragments are moved to one block.
    
    How this situation was handled before:
    
      ufs_prepare_write
      ->block_prepare_write
        ->ufs_getfrag_block
          ->...
            ->ufs_new_fragments:
    
            bh = sb_bread
            bh->b_blocknr = result + i;
            mark_buffer_dirty (bh);
    
    This is wrong solution, because:
    
    - it didn't take into consideration that there is another cache: "inode page
      cache"
    
    - because of sb_getblk uses not b_blocknr, (it uses page->index) to find
      certain block, this breaks sb_getblk.
    
    How this situation is handled now: we go though all "page inode cache", if
    there are no such page in cache we load it into cache, and change b_blocknr.
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 2b2366360e5a..ea2267316a72 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -172,9 +172,10 @@ static void ufs_clear_block(struct inode *inode, struct buffer_head *bh)
 		sync_dirty_buffer(bh);
 }
 
-static struct buffer_head * ufs_inode_getfrag (struct inode *inode,
-	unsigned int fragment, unsigned int new_fragment,
-	unsigned int required, int *err, int metadata, long *phys, int *new)
+static struct buffer_head *ufs_inode_getfrag(struct inode *inode,
+					     unsigned int fragment, unsigned int new_fragment,
+					     unsigned int required, int *err, int metadata,
+					     long *phys, int *new, struct page *locked_page)
 {
 	struct ufs_inode_info *ufsi = UFS_I(inode);
 	struct super_block * sb;
@@ -232,7 +233,8 @@ static struct buffer_head * ufs_inode_getfrag (struct inode *inode,
 		if (lastblockoff) {
 			p2 = ufsi->i_u1.i_data + lastblock;
 			tmp = ufs_new_fragments (inode, p2, lastfrag, 
-				fs32_to_cpu(sb, *p2), uspi->s_fpb - lastblockoff, err);
+						 fs32_to_cpu(sb, *p2), uspi->s_fpb - lastblockoff,
+						 err, locked_page);
 			if (!tmp) {
 				if (lastfrag != ufsi->i_lastfrag)
 					goto repeat;
@@ -244,14 +246,16 @@ static struct buffer_head * ufs_inode_getfrag (struct inode *inode,
 		}
 		goal = fs32_to_cpu(sb, ufsi->i_u1.i_data[lastblock]) + uspi->s_fpb;
 		tmp = ufs_new_fragments (inode, p, fragment - blockoff, 
-			goal, required + blockoff, err);
+					 goal, required + blockoff,
+					 err, locked_page);
 	}
 	/*
 	 * We will extend last allocated block
 	 */
 	else if (lastblock == block) {
-		tmp = ufs_new_fragments (inode, p, fragment - (blockoff - lastblockoff),
-			fs32_to_cpu(sb, *p), required +  (blockoff - lastblockoff), err);
+		tmp = ufs_new_fragments(inode, p, fragment - (blockoff - lastblockoff),
+					fs32_to_cpu(sb, *p), required +  (blockoff - lastblockoff),
+					err, locked_page);
 	}
 	/*
 	 * We will allocate new block before last allocated block
@@ -259,8 +263,8 @@ static struct buffer_head * ufs_inode_getfrag (struct inode *inode,
 	else /* (lastblock > block) */ {
 		if (lastblock && (tmp = fs32_to_cpu(sb, ufsi->i_u1.i_data[lastblock-1])))
 			goal = tmp + uspi->s_fpb;
-		tmp = ufs_new_fragments (inode, p, fragment - blockoff, 
-			goal, uspi->s_fpb, err);
+		tmp = ufs_new_fragments(inode, p, fragment - blockoff,
+					goal, uspi->s_fpb, err, locked_page);
 	}
 	if (!tmp) {
 		if ((!blockoff && *p) || 
@@ -303,9 +307,10 @@ static struct buffer_head * ufs_inode_getfrag (struct inode *inode,
      */
 }
 
-static struct buffer_head * ufs_block_getfrag (struct inode *inode,
-	struct buffer_head *bh, unsigned int fragment, unsigned int new_fragment, 
-	unsigned int blocksize, int * err, int metadata, long *phys, int *new)
+static struct buffer_head *ufs_block_getfrag(struct inode *inode, struct buffer_head *bh,
+					     unsigned int fragment, unsigned int new_fragment,
+					     unsigned int blocksize, int * err, int metadata,
+					     long *phys, int *new, struct page *locked_page)
 {
 	struct super_block * sb;
 	struct ufs_sb_private_info * uspi;
@@ -350,7 +355,8 @@ static struct buffer_head * ufs_block_getfrag (struct inode *inode,
 		goal = tmp + uspi->s_fpb;
 	else
 		goal = bh->b_blocknr + uspi->s_fpb;
-	tmp = ufs_new_fragments (inode, p, ufs_blknum(new_fragment), goal, uspi->s_fpb, err);
+	tmp = ufs_new_fragments(inode, p, ufs_blknum(new_fragment), goal,
+				uspi->s_fpb, err, locked_page);
 	if (!tmp) {
 		if (fs32_to_cpu(sb, *p))
 			goto repeat;
@@ -424,15 +430,15 @@ int ufs_getfrag_block (struct inode *inode, sector_t fragment, struct buffer_hea
 	 * it much more readable:
 	 */
 #define GET_INODE_DATABLOCK(x) \
-		ufs_inode_getfrag(inode, x, fragment, 1, &err, 0, &phys, &new)
+	ufs_inode_getfrag(inode, x, fragment, 1, &err, 0, &phys, &new, bh_result->b_page)
 #define GET_INODE_PTR(x) \
-		ufs_inode_getfrag(inode, x, fragment, uspi->s_fpb, &err, 1, NULL, NULL)
+	ufs_inode_getfrag(inode, x, fragment, uspi->s_fpb, &err, 1, NULL, NULL, bh_result->b_page)
 #define GET_INDIRECT_DATABLOCK(x) \
-		ufs_block_getfrag(inode, bh, x, fragment, sb->s_blocksize, \
-				  &err, 0, &phys, &new);
+	ufs_block_getfrag(inode, bh, x, fragment, sb->s_blocksize,	\
+			  &err, 0, &phys, &new, bh_result->b_page);
 #define GET_INDIRECT_PTR(x) \
-		ufs_block_getfrag(inode, bh, x, fragment, sb->s_blocksize, \
-				  &err, 1, NULL, NULL);
+	ufs_block_getfrag(inode, bh, x, fragment, sb->s_blocksize,	\
+			  &err, 1, NULL, NULL, bh_result->b_page);
 
 	if (ptr < UFS_NDIR_FRAGMENT) {
 		bh = GET_INODE_DATABLOCK(ptr);

commit c9a27b5dca52bbd0955e065e49e56eb313d02c34
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Sun Jun 25 05:47:19 2006 -0700

    [PATCH] ufs: right block allocation
    
    * After block allocation, we map it on the same "address" as 8 others
      blocks
    
    * We nullify block several times: once in ufs/block.c and once in
      block_*write_full_page, and use different "caches" for this.
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 3c3f62ce2ad9..2b2366360e5a 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -161,6 +161,17 @@ u64  ufs_frag_map(struct inode *inode, sector_t frag)
 	return ret;
 }
 
+static void ufs_clear_block(struct inode *inode, struct buffer_head *bh)
+{
+	lock_buffer(bh);
+	memset(bh->b_data, 0, inode->i_sb->s_blocksize);
+	set_buffer_uptodate(bh);
+	mark_buffer_dirty(bh);
+	unlock_buffer(bh);
+	if (IS_SYNC(inode))
+		sync_dirty_buffer(bh);
+}
+
 static struct buffer_head * ufs_inode_getfrag (struct inode *inode,
 	unsigned int fragment, unsigned int new_fragment,
 	unsigned int required, int *err, int metadata, long *phys, int *new)
@@ -204,7 +215,7 @@ static struct buffer_head * ufs_inode_getfrag (struct inode *inode,
 			brelse (result);
 			goto repeat;
 		} else {
-			*phys = tmp;
+			*phys = tmp + blockoff;
 			return NULL;
 		}
 	}
@@ -259,14 +270,11 @@ static struct buffer_head * ufs_inode_getfrag (struct inode *inode,
 		return NULL;
 	}
 
-	/* The nullification of framgents done in ufs/balloc.c is
-	 * something I don't have the stomache to move into here right
-	 * now. -DaveM
-	 */
 	if (metadata) {
 		result = sb_getblk(inode->i_sb, tmp + blockoff);
+		ufs_clear_block(inode, result);
 	} else {
-		*phys = tmp;
+		*phys = tmp + blockoff;
 		result = NULL;
 		*err = 0;
 		*new = 1;
@@ -333,7 +341,7 @@ static struct buffer_head * ufs_block_getfrag (struct inode *inode,
 			brelse (result);
 			goto repeat;
 		} else {
-			*phys = tmp;
+			*phys = tmp + blockoff;
 			goto out;
 		}
 	}
@@ -349,14 +357,12 @@ static struct buffer_head * ufs_block_getfrag (struct inode *inode,
 		goto out;
 	}		
 
-	/* The nullification of framgents done in ufs/balloc.c is
-	 * something I don't have the stomache to move into here right
-	 * now. -DaveM
-	 */
+
 	if (metadata) {
 		result = sb_getblk(sb, tmp + blockoff);
+		ufs_clear_block(inode, result);
 	} else {
-		*phys = tmp;
+		*phys = tmp + blockoff;
 		*new = 1;
 	}
 

commit 09114eb8c53d2d3b2ff9523e011cb68b2e245dce
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Fri Feb 3 03:04:06 2006 -0800

    [PATCH] ufs: fix hang during `rm'
    
    This fixes the code like this:
    
            bh = sb_find_get_block (sb, tmp + j);
            if ((bh && DATA_BUFFER_USED(bh)) || tmp != fs32_to_cpu(sb, *p)) {
                    retry = 1;
                    brelse (bh);
                    goto next1;
            }
            bforget (bh);
    
    sb_find_get_block() ordinarily returns a buffer_head with b_count>=2, and
    this code assume that in case if "b_count>1" buffer is used, so this caused
    infinite loop.
    
    (akpm: that is-the-buffer-busy code is incomprehensible.  Good riddance.  Use
    of block_truncate_page() seems sane).
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index e0c04e36a051..3c3f62ce2ad9 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -376,7 +376,7 @@ static struct buffer_head * ufs_block_getfrag (struct inode *inode,
  * This function gets the block which contains the fragment.
  */
 
-static int ufs_getfrag_block (struct inode *inode, sector_t fragment, struct buffer_head *bh_result, int create)
+int ufs_getfrag_block (struct inode *inode, sector_t fragment, struct buffer_head *bh_result, int create)
 {
 	struct super_block * sb = inode->i_sb;
 	struct ufs_sb_private_info * uspi = UFS_SB(sb)->s_uspi;

commit 7b4ee73e28052e53aac2fef1c91029666d8b2d70
Author: Evgeniy <dushistov@mail.ru>
Date:   Sat Jan 14 11:42:06 2006 +0300

    [PATCH] ufs cleanup
    
    Here is update of ufs cleanup patch, brought on by the recently fixed
    ubh_get_usb_second() bug that made some ugly code rather painfully
    obvious.  It also includes
    
     - fix compilation warnings which appears if debug mode turn on
     - remove unnecessary duplication of code to support UFS2
    
    I tested it on ufs1 and ufs2 file-systems.
    
    Signed-off-by: Evgeniy Dushistov <dushistov@mail.ru>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 55f4aa16e3fc..e0c04e36a051 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -61,7 +61,7 @@ static int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t off
 	int n = 0;
 
 
-	UFSD(("ptrs=uspi->s_apb = %d,double_blocks=%d \n",ptrs,double_blocks));
+	UFSD(("ptrs=uspi->s_apb = %d,double_blocks=%ld \n",ptrs,double_blocks));
 	if (i_block < 0) {
 		ufs_warning(inode->i_sb, "ufs_block_to_path", "block < 0");
 	} else if (i_block < direct_blocks) {
@@ -104,7 +104,7 @@ u64  ufs_frag_map(struct inode *inode, sector_t frag)
 	unsigned flags = UFS_SB(sb)->s_flags;
 	u64 temp = 0L;
 
-	UFSD((": frag = %lu  depth = %d\n",frag,depth));
+	UFSD((": frag = %llu  depth = %d\n", (unsigned long long)frag, depth));
 	UFSD((": uspi->s_fpbshift = %d ,uspi->s_apbmask = %x, mask=%llx\n",uspi->s_fpbshift,uspi->s_apbmask,mask));
 
 	if (depth == 0)
@@ -365,9 +365,10 @@ static struct buffer_head * ufs_block_getfrag (struct inode *inode,
 		sync_dirty_buffer(bh);
 	inode->i_ctime = CURRENT_TIME_SEC;
 	mark_inode_dirty(inode);
+	UFSD(("result %u\n", tmp + blockoff));
 out:
 	brelse (bh);
-	UFSD(("EXIT, result %u\n", tmp + blockoff))
+	UFSD(("EXIT\n"));
 	return result;
 }
 
@@ -386,7 +387,7 @@ static int ufs_getfrag_block (struct inode *inode, sector_t fragment, struct buf
 	
 	if (!create) {
 		phys64 = ufs_frag_map(inode, fragment);
-		UFSD(("phys64 = %lu \n",phys64));
+		UFSD(("phys64 = %llu \n",phys64));
 		if (phys64)
 			map_bh(bh_result, sb, phys64);
 		return 0;
@@ -401,7 +402,7 @@ static int ufs_getfrag_block (struct inode *inode, sector_t fragment, struct buf
 
 	lock_kernel();
 
-	UFSD(("ENTER, ino %lu, fragment %u\n", inode->i_ino, fragment))
+	UFSD(("ENTER, ino %lu, fragment %llu\n", inode->i_ino, (unsigned long long)fragment))
 	if (fragment < 0)
 		goto abort_negative;
 	if (fragment >

commit fef266580e5cf897a1b63528fc6b1185e2d6bb87
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Fri Sep 9 13:01:31 2005 -0700

    [PATCH] update filesystems for new delete_inode behavior
    
    Update the file systems in fs/ implementing a delete_inode() callback to
    call truncate_inode_pages().  One implementation note: In developing this
    patch I put the calls to truncate_inode_pages() at the very top of those
    filesystems delete_inode() callbacks in order to retain the previous
    behavior.  I'm guessing that some of those could probably be optimized.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>
    Acked-by: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Hugh Dickins <hugh@veritas.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 718627ca8b5c..55f4aa16e3fc 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -804,6 +804,7 @@ int ufs_sync_inode (struct inode *inode)
 
 void ufs_delete_inode (struct inode * inode)
 {
+	truncate_inode_pages(&inode->i_data, 0);
 	/*UFS_I(inode)->i_dtime = CURRENT_TIME;*/
 	lock_kernel();
 	mark_inode_dirty(inode);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
new file mode 100644
index 000000000000..718627ca8b5c
--- /dev/null
+++ b/fs/ufs/inode.c
@@ -0,0 +1,816 @@
+/*
+ *  linux/fs/ufs/inode.c
+ *
+ * Copyright (C) 1998
+ * Daniel Pirkl <daniel.pirkl@email.cz>
+ * Charles University, Faculty of Mathematics and Physics
+ *
+ *  from
+ *
+ *  linux/fs/ext2/inode.c
+ *
+ * Copyright (C) 1992, 1993, 1994, 1995
+ * Remy Card (card@masi.ibp.fr)
+ * Laboratoire MASI - Institut Blaise Pascal
+ * Universite Pierre et Marie Curie (Paris VI)
+ *
+ *  from
+ *
+ *  linux/fs/minix/inode.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ *
+ *  Goal-directed block allocation by Stephen Tweedie (sct@dcs.ed.ac.uk), 1993
+ *  Big-endian to little-endian byte-swapping/bitmaps by
+ *        David S. Miller (davem@caip.rutgers.edu), 1995
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/ufs_fs.h>
+#include <linux/time.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/smp_lock.h>
+#include <linux/buffer_head.h>
+
+#include "swab.h"
+#include "util.h"
+
+#undef UFS_INODE_DEBUG
+#undef UFS_INODE_DEBUG_MORE
+
+#ifdef UFS_INODE_DEBUG
+#define UFSD(x) printk("(%s, %d), %s: ", __FILE__, __LINE__, __FUNCTION__); printk x;
+#else
+#define UFSD(x)
+#endif
+
+static int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t offsets[4])
+{
+	struct ufs_sb_private_info *uspi = UFS_SB(inode->i_sb)->s_uspi;
+	int ptrs = uspi->s_apb;
+	int ptrs_bits = uspi->s_apbshift;
+	const long direct_blocks = UFS_NDADDR,
+		indirect_blocks = ptrs,
+		double_blocks = (1 << (ptrs_bits * 2));
+	int n = 0;
+
+
+	UFSD(("ptrs=uspi->s_apb = %d,double_blocks=%d \n",ptrs,double_blocks));
+	if (i_block < 0) {
+		ufs_warning(inode->i_sb, "ufs_block_to_path", "block < 0");
+	} else if (i_block < direct_blocks) {
+		offsets[n++] = i_block;
+	} else if ((i_block -= direct_blocks) < indirect_blocks) {
+		offsets[n++] = UFS_IND_BLOCK;
+		offsets[n++] = i_block;
+	} else if ((i_block -= indirect_blocks) < double_blocks) {
+		offsets[n++] = UFS_DIND_BLOCK;
+		offsets[n++] = i_block >> ptrs_bits;
+		offsets[n++] = i_block & (ptrs - 1);
+	} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {
+		offsets[n++] = UFS_TIND_BLOCK;
+		offsets[n++] = i_block >> (ptrs_bits * 2);
+		offsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);
+		offsets[n++] = i_block & (ptrs - 1);
+	} else {
+		ufs_warning(inode->i_sb, "ufs_block_to_path", "block > big");
+	}
+	return n;
+}
+
+/*
+ * Returns the location of the fragment from
+ * the begining of the filesystem.
+ */
+
+u64  ufs_frag_map(struct inode *inode, sector_t frag)
+{
+	struct ufs_inode_info *ufsi = UFS_I(inode);
+	struct super_block *sb = inode->i_sb;
+	struct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;
+	u64 mask = (u64) uspi->s_apbmask>>uspi->s_fpbshift;
+	int shift = uspi->s_apbshift-uspi->s_fpbshift;
+	sector_t offsets[4], *p;
+	int depth = ufs_block_to_path(inode, frag >> uspi->s_fpbshift, offsets);
+	u64  ret = 0L;
+	__fs32 block;
+	__fs64 u2_block = 0L;
+	unsigned flags = UFS_SB(sb)->s_flags;
+	u64 temp = 0L;
+
+	UFSD((": frag = %lu  depth = %d\n",frag,depth));
+	UFSD((": uspi->s_fpbshift = %d ,uspi->s_apbmask = %x, mask=%llx\n",uspi->s_fpbshift,uspi->s_apbmask,mask));
+
+	if (depth == 0)
+		return 0;
+
+	p = offsets;
+
+	lock_kernel();
+	if ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)
+		goto ufs2;
+
+	block = ufsi->i_u1.i_data[*p++];
+	if (!block)
+		goto out;
+	while (--depth) {
+		struct buffer_head *bh;
+		sector_t n = *p++;
+
+		bh = sb_bread(sb, uspi->s_sbbase + fs32_to_cpu(sb, block)+(n>>shift));
+		if (!bh)
+			goto out;
+		block = ((__fs32 *) bh->b_data)[n & mask];
+		brelse (bh);
+		if (!block)
+			goto out;
+	}
+	ret = (u64) (uspi->s_sbbase + fs32_to_cpu(sb, block) + (frag & uspi->s_fpbmask));
+	goto out;
+ufs2:
+	u2_block = ufsi->i_u1.u2_i_data[*p++];
+	if (!u2_block)
+		goto out;
+
+
+	while (--depth) {
+		struct buffer_head *bh;
+		sector_t n = *p++;
+
+
+		temp = (u64)(uspi->s_sbbase) + fs64_to_cpu(sb, u2_block);
+		bh = sb_bread(sb, temp +(u64) (n>>shift));
+		if (!bh)
+			goto out;
+		u2_block = ((__fs64 *)bh->b_data)[n & mask];
+		brelse(bh);
+		if (!u2_block)
+			goto out;
+	}
+	temp = (u64)uspi->s_sbbase + fs64_to_cpu(sb, u2_block);
+	ret = temp + (u64) (frag & uspi->s_fpbmask);
+
+out:
+	unlock_kernel();
+	return ret;
+}
+
+static struct buffer_head * ufs_inode_getfrag (struct inode *inode,
+	unsigned int fragment, unsigned int new_fragment,
+	unsigned int required, int *err, int metadata, long *phys, int *new)
+{
+	struct ufs_inode_info *ufsi = UFS_I(inode);
+	struct super_block * sb;
+	struct ufs_sb_private_info * uspi;
+	struct buffer_head * result;
+	unsigned block, blockoff, lastfrag, lastblock, lastblockoff;
+	unsigned tmp, goal;
+	__fs32 * p, * p2;
+	unsigned flags = 0;
+
+	UFSD(("ENTER, ino %lu, fragment %u, new_fragment %u, required %u\n",
+		inode->i_ino, fragment, new_fragment, required))         
+
+	sb = inode->i_sb;
+	uspi = UFS_SB(sb)->s_uspi;
+
+	flags = UFS_SB(sb)->s_flags;
+        /* TODO : to be done for write support
+        if ( (flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)
+             goto ufs2;
+         */
+
+	block = ufs_fragstoblks (fragment);
+	blockoff = ufs_fragnum (fragment);
+	p = ufsi->i_u1.i_data + block;
+	goal = 0;
+
+repeat:
+	tmp = fs32_to_cpu(sb, *p);
+	lastfrag = ufsi->i_lastfrag;
+	if (tmp && fragment < lastfrag) {
+		if (metadata) {
+			result = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
+			if (tmp == fs32_to_cpu(sb, *p)) {
+				UFSD(("EXIT, result %u\n", tmp + blockoff))
+				return result;
+			}
+			brelse (result);
+			goto repeat;
+		} else {
+			*phys = tmp;
+			return NULL;
+		}
+	}
+
+	lastblock = ufs_fragstoblks (lastfrag);
+	lastblockoff = ufs_fragnum (lastfrag);
+	/*
+	 * We will extend file into new block beyond last allocated block
+	 */
+	if (lastblock < block) {
+		/*
+		 * We must reallocate last allocated block
+		 */
+		if (lastblockoff) {
+			p2 = ufsi->i_u1.i_data + lastblock;
+			tmp = ufs_new_fragments (inode, p2, lastfrag, 
+				fs32_to_cpu(sb, *p2), uspi->s_fpb - lastblockoff, err);
+			if (!tmp) {
+				if (lastfrag != ufsi->i_lastfrag)
+					goto repeat;
+				else
+					return NULL;
+			}
+			lastfrag = ufsi->i_lastfrag;
+			
+		}
+		goal = fs32_to_cpu(sb, ufsi->i_u1.i_data[lastblock]) + uspi->s_fpb;
+		tmp = ufs_new_fragments (inode, p, fragment - blockoff, 
+			goal, required + blockoff, err);
+	}
+	/*
+	 * We will extend last allocated block
+	 */
+	else if (lastblock == block) {
+		tmp = ufs_new_fragments (inode, p, fragment - (blockoff - lastblockoff),
+			fs32_to_cpu(sb, *p), required +  (blockoff - lastblockoff), err);
+	}
+	/*
+	 * We will allocate new block before last allocated block
+	 */
+	else /* (lastblock > block) */ {
+		if (lastblock && (tmp = fs32_to_cpu(sb, ufsi->i_u1.i_data[lastblock-1])))
+			goal = tmp + uspi->s_fpb;
+		tmp = ufs_new_fragments (inode, p, fragment - blockoff, 
+			goal, uspi->s_fpb, err);
+	}
+	if (!tmp) {
+		if ((!blockoff && *p) || 
+		    (blockoff && lastfrag != ufsi->i_lastfrag))
+			goto repeat;
+		*err = -ENOSPC;
+		return NULL;
+	}
+
+	/* The nullification of framgents done in ufs/balloc.c is
+	 * something I don't have the stomache to move into here right
+	 * now. -DaveM
+	 */
+	if (metadata) {
+		result = sb_getblk(inode->i_sb, tmp + blockoff);
+	} else {
+		*phys = tmp;
+		result = NULL;
+		*err = 0;
+		*new = 1;
+	}
+
+	inode->i_ctime = CURRENT_TIME_SEC;
+	if (IS_SYNC(inode))
+		ufs_sync_inode (inode);
+	mark_inode_dirty(inode);
+	UFSD(("EXIT, result %u\n", tmp + blockoff))
+	return result;
+
+     /* This part : To be implemented ....
+        Required only for writing, not required for READ-ONLY.
+ufs2:
+
+	u2_block = ufs_fragstoblks(fragment);
+	u2_blockoff = ufs_fragnum(fragment);
+	p = ufsi->i_u1.u2_i_data + block;
+	goal = 0;
+
+repeat2:
+	tmp = fs32_to_cpu(sb, *p);
+	lastfrag = ufsi->i_lastfrag;
+
+     */
+}
+
+static struct buffer_head * ufs_block_getfrag (struct inode *inode,
+	struct buffer_head *bh, unsigned int fragment, unsigned int new_fragment, 
+	unsigned int blocksize, int * err, int metadata, long *phys, int *new)
+{
+	struct super_block * sb;
+	struct ufs_sb_private_info * uspi;
+	struct buffer_head * result;
+	unsigned tmp, goal, block, blockoff;
+	__fs32 * p;
+
+	sb = inode->i_sb;
+	uspi = UFS_SB(sb)->s_uspi;
+	block = ufs_fragstoblks (fragment);
+	blockoff = ufs_fragnum (fragment);
+
+	UFSD(("ENTER, ino %lu, fragment %u, new_fragment %u\n", inode->i_ino, fragment, new_fragment))	
+
+	result = NULL;
+	if (!bh)
+		goto out;
+	if (!buffer_uptodate(bh)) {
+		ll_rw_block (READ, 1, &bh);
+		wait_on_buffer (bh);
+		if (!buffer_uptodate(bh))
+			goto out;
+	}
+
+	p = (__fs32 *) bh->b_data + block;
+repeat:
+	tmp = fs32_to_cpu(sb, *p);
+	if (tmp) {
+		if (metadata) {
+			result = sb_getblk(sb, uspi->s_sbbase + tmp + blockoff);
+			if (tmp == fs32_to_cpu(sb, *p))
+				goto out;
+			brelse (result);
+			goto repeat;
+		} else {
+			*phys = tmp;
+			goto out;
+		}
+	}
+
+	if (block && (tmp = fs32_to_cpu(sb, ((__fs32*)bh->b_data)[block-1]) + uspi->s_fpb))
+		goal = tmp + uspi->s_fpb;
+	else
+		goal = bh->b_blocknr + uspi->s_fpb;
+	tmp = ufs_new_fragments (inode, p, ufs_blknum(new_fragment), goal, uspi->s_fpb, err);
+	if (!tmp) {
+		if (fs32_to_cpu(sb, *p))
+			goto repeat;
+		goto out;
+	}		
+
+	/* The nullification of framgents done in ufs/balloc.c is
+	 * something I don't have the stomache to move into here right
+	 * now. -DaveM
+	 */
+	if (metadata) {
+		result = sb_getblk(sb, tmp + blockoff);
+	} else {
+		*phys = tmp;
+		*new = 1;
+	}
+
+	mark_buffer_dirty(bh);
+	if (IS_SYNC(inode))
+		sync_dirty_buffer(bh);
+	inode->i_ctime = CURRENT_TIME_SEC;
+	mark_inode_dirty(inode);
+out:
+	brelse (bh);
+	UFSD(("EXIT, result %u\n", tmp + blockoff))
+	return result;
+}
+
+/*
+ * This function gets the block which contains the fragment.
+ */
+
+static int ufs_getfrag_block (struct inode *inode, sector_t fragment, struct buffer_head *bh_result, int create)
+{
+	struct super_block * sb = inode->i_sb;
+	struct ufs_sb_private_info * uspi = UFS_SB(sb)->s_uspi;
+	struct buffer_head * bh;
+	int ret, err, new;
+	unsigned long ptr,phys;
+	u64 phys64 = 0;
+	
+	if (!create) {
+		phys64 = ufs_frag_map(inode, fragment);
+		UFSD(("phys64 = %lu \n",phys64));
+		if (phys64)
+			map_bh(bh_result, sb, phys64);
+		return 0;
+	}
+
+        /* This code entered only while writing ....? */
+
+	err = -EIO;
+	new = 0;
+	ret = 0;
+	bh = NULL;
+
+	lock_kernel();
+
+	UFSD(("ENTER, ino %lu, fragment %u\n", inode->i_ino, fragment))
+	if (fragment < 0)
+		goto abort_negative;
+	if (fragment >
+	    ((UFS_NDADDR + uspi->s_apb + uspi->s_2apb + uspi->s_3apb)
+	     << uspi->s_fpbshift))
+		goto abort_too_big;
+
+	err = 0;
+	ptr = fragment;
+	  
+	/*
+	 * ok, these macros clean the logic up a bit and make
+	 * it much more readable:
+	 */
+#define GET_INODE_DATABLOCK(x) \
+		ufs_inode_getfrag(inode, x, fragment, 1, &err, 0, &phys, &new)
+#define GET_INODE_PTR(x) \
+		ufs_inode_getfrag(inode, x, fragment, uspi->s_fpb, &err, 1, NULL, NULL)
+#define GET_INDIRECT_DATABLOCK(x) \
+		ufs_block_getfrag(inode, bh, x, fragment, sb->s_blocksize, \
+				  &err, 0, &phys, &new);
+#define GET_INDIRECT_PTR(x) \
+		ufs_block_getfrag(inode, bh, x, fragment, sb->s_blocksize, \
+				  &err, 1, NULL, NULL);
+
+	if (ptr < UFS_NDIR_FRAGMENT) {
+		bh = GET_INODE_DATABLOCK(ptr);
+		goto out;
+	}
+	ptr -= UFS_NDIR_FRAGMENT;
+	if (ptr < (1 << (uspi->s_apbshift + uspi->s_fpbshift))) {
+		bh = GET_INODE_PTR(UFS_IND_FRAGMENT + (ptr >> uspi->s_apbshift));
+		goto get_indirect;
+	}
+	ptr -= 1 << (uspi->s_apbshift + uspi->s_fpbshift);
+	if (ptr < (1 << (uspi->s_2apbshift + uspi->s_fpbshift))) {
+		bh = GET_INODE_PTR(UFS_DIND_FRAGMENT + (ptr >> uspi->s_2apbshift));
+		goto get_double;
+	}
+	ptr -= 1 << (uspi->s_2apbshift + uspi->s_fpbshift);
+	bh = GET_INODE_PTR(UFS_TIND_FRAGMENT + (ptr >> uspi->s_3apbshift));
+	bh = GET_INDIRECT_PTR((ptr >> uspi->s_2apbshift) & uspi->s_apbmask);
+get_double:
+	bh = GET_INDIRECT_PTR((ptr >> uspi->s_apbshift) & uspi->s_apbmask);
+get_indirect:
+	bh = GET_INDIRECT_DATABLOCK(ptr & uspi->s_apbmask);
+
+#undef GET_INODE_DATABLOCK
+#undef GET_INODE_PTR
+#undef GET_INDIRECT_DATABLOCK
+#undef GET_INDIRECT_PTR
+
+out:
+	if (err)
+		goto abort;
+	if (new)
+		set_buffer_new(bh_result);
+	map_bh(bh_result, sb, phys);
+abort:
+	unlock_kernel();
+	return err;
+
+abort_negative:
+	ufs_warning(sb, "ufs_get_block", "block < 0");
+	goto abort;
+
+abort_too_big:
+	ufs_warning(sb, "ufs_get_block", "block > big");
+	goto abort;
+}
+
+struct buffer_head *ufs_getfrag(struct inode *inode, unsigned int fragment,
+				int create, int *err)
+{
+	struct buffer_head dummy;
+	int error;
+
+	dummy.b_state = 0;
+	dummy.b_blocknr = -1000;
+	error = ufs_getfrag_block(inode, fragment, &dummy, create);
+	*err = error;
+	if (!error && buffer_mapped(&dummy)) {
+		struct buffer_head *bh;
+		bh = sb_getblk(inode->i_sb, dummy.b_blocknr);
+		if (buffer_new(&dummy)) {
+			memset(bh->b_data, 0, inode->i_sb->s_blocksize);
+			set_buffer_uptodate(bh);
+			mark_buffer_dirty(bh);
+		}
+		return bh;
+	}
+	return NULL;
+}
+
+struct buffer_head * ufs_bread (struct inode * inode, unsigned fragment,
+	int create, int * err)
+{
+	struct buffer_head * bh;
+
+	UFSD(("ENTER, ino %lu, fragment %u\n", inode->i_ino, fragment))
+	bh = ufs_getfrag (inode, fragment, create, err);
+	if (!bh || buffer_uptodate(bh)) 		
+		return bh;
+	ll_rw_block (READ, 1, &bh);
+	wait_on_buffer (bh);
+	if (buffer_uptodate(bh))
+		return bh;
+	brelse (bh);
+	*err = -EIO;
+	return NULL;
+}
+
+static int ufs_writepage(struct page *page, struct writeback_control *wbc)
+{
+	return block_write_full_page(page,ufs_getfrag_block,wbc);
+}
+static int ufs_readpage(struct file *file, struct page *page)
+{
+	return block_read_full_page(page,ufs_getfrag_block);
+}
+static int ufs_prepare_write(struct file *file, struct page *page, unsigned from, unsigned to)
+{
+	return block_prepare_write(page,from,to,ufs_getfrag_block);
+}
+static sector_t ufs_bmap(struct address_space *mapping, sector_t block)
+{
+	return generic_block_bmap(mapping,block,ufs_getfrag_block);
+}
+struct address_space_operations ufs_aops = {
+	.readpage = ufs_readpage,
+	.writepage = ufs_writepage,
+	.sync_page = block_sync_page,
+	.prepare_write = ufs_prepare_write,
+	.commit_write = generic_commit_write,
+	.bmap = ufs_bmap
+};
+
+void ufs_read_inode (struct inode * inode)
+{
+	struct ufs_inode_info *ufsi = UFS_I(inode);
+	struct super_block * sb;
+	struct ufs_sb_private_info * uspi;
+	struct ufs_inode * ufs_inode;	
+	struct ufs2_inode *ufs2_inode;
+	struct buffer_head * bh;
+	mode_t mode;
+	unsigned i;
+	unsigned flags;
+	
+	UFSD(("ENTER, ino %lu\n", inode->i_ino))
+	
+	sb = inode->i_sb;
+	uspi = UFS_SB(sb)->s_uspi;
+	flags = UFS_SB(sb)->s_flags;
+
+	if (inode->i_ino < UFS_ROOTINO || 
+	    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {
+		ufs_warning (sb, "ufs_read_inode", "bad inode number (%lu)\n", inode->i_ino);
+		goto bad_inode;
+	}
+	
+	bh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));
+	if (!bh) {
+		ufs_warning (sb, "ufs_read_inode", "unable to read inode %lu\n", inode->i_ino);
+		goto bad_inode;
+	}
+	if ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)
+		goto ufs2_inode;
+
+	ufs_inode = (struct ufs_inode *) (bh->b_data + sizeof(struct ufs_inode) * ufs_inotofsbo(inode->i_ino));
+
+	/*
+	 * Copy data to the in-core inode.
+	 */
+	inode->i_mode = mode = fs16_to_cpu(sb, ufs_inode->ui_mode);
+	inode->i_nlink = fs16_to_cpu(sb, ufs_inode->ui_nlink);
+	if (inode->i_nlink == 0)
+		ufs_error (sb, "ufs_read_inode", "inode %lu has zero nlink\n", inode->i_ino);
+	
+	/*
+	 * Linux now has 32-bit uid and gid, so we can support EFT.
+	 */
+	inode->i_uid = ufs_get_inode_uid(sb, ufs_inode);
+	inode->i_gid = ufs_get_inode_gid(sb, ufs_inode);
+
+	inode->i_size = fs64_to_cpu(sb, ufs_inode->ui_size);
+	inode->i_atime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_atime.tv_sec);
+	inode->i_ctime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_ctime.tv_sec);
+	inode->i_mtime.tv_sec = fs32_to_cpu(sb, ufs_inode->ui_mtime.tv_sec);
+	inode->i_mtime.tv_nsec = 0;
+	inode->i_atime.tv_nsec = 0;
+	inode->i_ctime.tv_nsec = 0;
+	inode->i_blocks = fs32_to_cpu(sb, ufs_inode->ui_blocks);
+	inode->i_blksize = PAGE_SIZE;   /* This is the optimal IO size (for stat) */
+	inode->i_version++;
+	ufsi->i_flags = fs32_to_cpu(sb, ufs_inode->ui_flags);
+	ufsi->i_gen = fs32_to_cpu(sb, ufs_inode->ui_gen);
+	ufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);
+	ufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);
+	ufsi->i_lastfrag = (inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;
+	
+	if (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {
+		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR); i++)
+			ufsi->i_u1.i_data[i] = ufs_inode->ui_u2.ui_addr.ui_db[i];
+	}
+	else {
+		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR) * 4; i++)
+			ufsi->i_u1.i_symlink[i] = ufs_inode->ui_u2.ui_symlink[i];
+	}
+	ufsi->i_osync = 0;
+
+	if (S_ISREG(inode->i_mode)) {
+		inode->i_op = &ufs_file_inode_operations;
+		inode->i_fop = &ufs_file_operations;
+		inode->i_mapping->a_ops = &ufs_aops;
+	} else if (S_ISDIR(inode->i_mode)) {
+		inode->i_op = &ufs_dir_inode_operations;
+		inode->i_fop = &ufs_dir_operations;
+	} else if (S_ISLNK(inode->i_mode)) {
+		if (!inode->i_blocks)
+			inode->i_op = &ufs_fast_symlink_inode_operations;
+		else {
+			inode->i_op = &page_symlink_inode_operations;
+			inode->i_mapping->a_ops = &ufs_aops;
+		}
+	} else
+		init_special_inode(inode, inode->i_mode,
+			ufs_get_inode_dev(sb, ufsi));
+
+	brelse (bh);
+
+	UFSD(("EXIT\n"))
+	return;
+
+bad_inode:
+	make_bad_inode(inode);
+	return;
+
+ufs2_inode :
+	UFSD(("Reading ufs2 inode, ino %lu\n", inode->i_ino))
+
+	ufs2_inode = (struct ufs2_inode *)(bh->b_data + sizeof(struct ufs2_inode) * ufs_inotofsbo(inode->i_ino));
+
+	/*
+	 * Copy data to the in-core inode.
+	 */
+	inode->i_mode = mode = fs16_to_cpu(sb, ufs2_inode->ui_mode);
+	inode->i_nlink = fs16_to_cpu(sb, ufs2_inode->ui_nlink);
+	if (inode->i_nlink == 0)
+		ufs_error (sb, "ufs_read_inode", "inode %lu has zero nlink\n", inode->i_ino);
+
+        /*
+         * Linux now has 32-bit uid and gid, so we can support EFT.
+         */
+	inode->i_uid = fs32_to_cpu(sb, ufs2_inode->ui_uid);
+	inode->i_gid = fs32_to_cpu(sb, ufs2_inode->ui_gid);
+
+	inode->i_size = fs64_to_cpu(sb, ufs2_inode->ui_size);
+	inode->i_atime.tv_sec = fs32_to_cpu(sb, ufs2_inode->ui_atime.tv_sec);
+	inode->i_ctime.tv_sec = fs32_to_cpu(sb, ufs2_inode->ui_ctime.tv_sec);
+	inode->i_mtime.tv_sec = fs32_to_cpu(sb, ufs2_inode->ui_mtime.tv_sec);
+	inode->i_mtime.tv_nsec = 0;
+	inode->i_atime.tv_nsec = 0;
+	inode->i_ctime.tv_nsec = 0;
+	inode->i_blocks = fs64_to_cpu(sb, ufs2_inode->ui_blocks);
+	inode->i_blksize = PAGE_SIZE; /*This is the optimal IO size(for stat)*/
+
+	inode->i_version++;
+	ufsi->i_flags = fs32_to_cpu(sb, ufs2_inode->ui_flags);
+	ufsi->i_gen = fs32_to_cpu(sb, ufs2_inode->ui_gen);
+	/*
+	ufsi->i_shadow = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_shadow);
+	ufsi->i_oeftflag = fs32_to_cpu(sb, ufs_inode->ui_u3.ui_sun.ui_oeftflag);
+	*/
+	ufsi->i_lastfrag= (inode->i_size + uspi->s_fsize- 1) >> uspi->s_fshift;
+
+	if (S_ISCHR(mode) || S_ISBLK(mode) || inode->i_blocks) {
+		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR); i++)
+			ufsi->i_u1.u2_i_data[i] =
+				ufs2_inode->ui_u2.ui_addr.ui_db[i];
+	}
+	else {
+		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR) * 4; i++)
+			ufsi->i_u1.i_symlink[i] = ufs2_inode->ui_u2.ui_symlink[i];
+	}
+	ufsi->i_osync = 0;
+
+	if (S_ISREG(inode->i_mode)) {
+		inode->i_op = &ufs_file_inode_operations;
+		inode->i_fop = &ufs_file_operations;
+		inode->i_mapping->a_ops = &ufs_aops;
+	} else if (S_ISDIR(inode->i_mode)) {
+		inode->i_op = &ufs_dir_inode_operations;
+		inode->i_fop = &ufs_dir_operations;
+	} else if (S_ISLNK(inode->i_mode)) {
+		if (!inode->i_blocks)
+			inode->i_op = &ufs_fast_symlink_inode_operations;
+		else {
+			inode->i_op = &page_symlink_inode_operations;
+			inode->i_mapping->a_ops = &ufs_aops;
+		}
+	} else   /* TODO  : here ...*/
+		init_special_inode(inode, inode->i_mode,
+			ufs_get_inode_dev(sb, ufsi));
+
+	brelse(bh);
+
+	UFSD(("EXIT\n"))
+	return;
+}
+
+static int ufs_update_inode(struct inode * inode, int do_sync)
+{
+	struct ufs_inode_info *ufsi = UFS_I(inode);
+	struct super_block * sb;
+	struct ufs_sb_private_info * uspi;
+	struct buffer_head * bh;
+	struct ufs_inode * ufs_inode;
+	unsigned i;
+	unsigned flags;
+
+	UFSD(("ENTER, ino %lu\n", inode->i_ino))
+
+	sb = inode->i_sb;
+	uspi = UFS_SB(sb)->s_uspi;
+	flags = UFS_SB(sb)->s_flags;
+
+	if (inode->i_ino < UFS_ROOTINO || 
+	    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {
+		ufs_warning (sb, "ufs_read_inode", "bad inode number (%lu)\n", inode->i_ino);
+		return -1;
+	}
+
+	bh = sb_bread(sb, ufs_inotofsba(inode->i_ino));
+	if (!bh) {
+		ufs_warning (sb, "ufs_read_inode", "unable to read inode %lu\n", inode->i_ino);
+		return -1;
+	}
+	ufs_inode = (struct ufs_inode *) (bh->b_data + ufs_inotofsbo(inode->i_ino) * sizeof(struct ufs_inode));
+
+	ufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);
+	ufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);
+
+	ufs_set_inode_uid(sb, ufs_inode, inode->i_uid);
+	ufs_set_inode_gid(sb, ufs_inode, inode->i_gid);
+		
+	ufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);
+	ufs_inode->ui_atime.tv_sec = cpu_to_fs32(sb, inode->i_atime.tv_sec);
+	ufs_inode->ui_atime.tv_usec = 0;
+	ufs_inode->ui_ctime.tv_sec = cpu_to_fs32(sb, inode->i_ctime.tv_sec);
+	ufs_inode->ui_ctime.tv_usec = 0;
+	ufs_inode->ui_mtime.tv_sec = cpu_to_fs32(sb, inode->i_mtime.tv_sec);
+	ufs_inode->ui_mtime.tv_usec = 0;
+	ufs_inode->ui_blocks = cpu_to_fs32(sb, inode->i_blocks);
+	ufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);
+	ufs_inode->ui_gen = cpu_to_fs32(sb, ufsi->i_gen);
+
+	if ((flags & UFS_UID_MASK) == UFS_UID_EFT) {
+		ufs_inode->ui_u3.ui_sun.ui_shadow = cpu_to_fs32(sb, ufsi->i_shadow);
+		ufs_inode->ui_u3.ui_sun.ui_oeftflag = cpu_to_fs32(sb, ufsi->i_oeftflag);
+	}
+
+	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {
+		/* ufs_inode->ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode->i_rdev); */
+		ufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.i_data[0];
+	} else if (inode->i_blocks) {
+		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR); i++)
+			ufs_inode->ui_u2.ui_addr.ui_db[i] = ufsi->i_u1.i_data[i];
+	}
+	else {
+		for (i = 0; i < (UFS_NDADDR + UFS_NINDIR) * 4; i++)
+			ufs_inode->ui_u2.ui_symlink[i] = ufsi->i_u1.i_symlink[i];
+	}
+
+	if (!inode->i_nlink)
+		memset (ufs_inode, 0, sizeof(struct ufs_inode));
+		
+	mark_buffer_dirty(bh);
+	if (do_sync)
+		sync_dirty_buffer(bh);
+	brelse (bh);
+	
+	UFSD(("EXIT\n"))
+	return 0;
+}
+
+int ufs_write_inode (struct inode * inode, int wait)
+{
+	int ret;
+	lock_kernel();
+	ret = ufs_update_inode (inode, wait);
+	unlock_kernel();
+	return ret;
+}
+
+int ufs_sync_inode (struct inode *inode)
+{
+	return ufs_update_inode (inode, 1);
+}
+
+void ufs_delete_inode (struct inode * inode)
+{
+	/*UFS_I(inode)->i_dtime = CURRENT_TIME;*/
+	lock_kernel();
+	mark_inode_dirty(inode);
+	ufs_update_inode(inode, IS_SYNC(inode));
+	inode->i_size = 0;
+	if (inode->i_blocks)
+		ufs_truncate (inode);
+	ufs_free_inode (inode);
+	unlock_kernel();
+}
