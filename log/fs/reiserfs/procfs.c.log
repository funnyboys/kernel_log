commit 154a4dcfc95f9dfcb2fda3ddf24c0602060d1120
Author: Alex Shi <alex.shi@linux.alibaba.com>
Date:   Tue Jan 21 18:25:38 2020 +0800

    fs/reiserfs: remove unused macros
    
    these macros are never used from introduced. better to
    remove them.
    
    Link: https://lore.kernel.org/r/1579602338-57079-1-git-send-email-alex.shi@linux.alibaba.com
    Signed-off-by: Alex Shi <alex.shi@linux.alibaba.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Bharath Vedartham <linux.bhar@gmail.com>
    Cc: Hariprasad Kelam <hariprasad.kelam@gmail.com>
    Cc: Jason Yan <yanaijie@huawei.com>
    Cc: zhengbin <zhengbin13@huawei.com>
    Cc: Jia-Ju Bai <baijiaju1990@gmail.com>
    Cc: reiserfs-devel@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index f2cf3441fdfc..ff336513c254 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -63,7 +63,6 @@ static int show_version(struct seq_file *m, void *unused)
 #define MAP( i ) D4C( objectid_map( sb, rs )[ i ] )
 
 #define DJF( x ) le32_to_cpu( rs -> x )
-#define DJV( x ) le32_to_cpu( s_v1 -> x )
 #define DJP( x ) le32_to_cpu( jp -> x )
 #define JF( x ) ( r -> s_journal -> x )
 

commit 34d082604a7c8856051ff441fef0e22d93afd848
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Aug 21 21:59:26 2018 -0700

    reiserfs: use monotonic time for j_trans_start_time
    
    Using CLOCK_REALTIME time_t timestamps breaks on 32-bit systems in 2038,
    and gives surprising results with a concurrent settimeofday().
    
    This changes the reiserfs journal timestamps to use ktime_get_seconds()
    instead, which makes it use a 64-bit CLOCK_MONOTONIC stamp.
    
    In the procfs output, the monotonic timestamp needs to be converted back
    to CLOCK_REALTIME to keep the existing ABI.
    
    Link: http://lkml.kernel.org/r/20180620142522.27639-2-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index e39b3910d24d..f2cf3441fdfc 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -297,6 +297,13 @@ static int show_oidmap(struct seq_file *m, void *unused)
 	return 0;
 }
 
+static time64_t ktime_mono_to_real_seconds(time64_t mono)
+{
+	ktime_t kt = ktime_set(mono, NSEC_PER_SEC/2);
+
+	return ktime_divns(ktime_mono_to_real(kt), NSEC_PER_SEC);
+}
+
 static int show_journal(struct seq_file *m, void *unused)
 {
 	struct super_block *sb = m->private;
@@ -325,7 +332,7 @@ static int show_journal(struct seq_file *m, void *unused)
 		   "j_bcount: \t%lu\n"
 		   "j_first_unflushed_offset: \t%lu\n"
 		   "j_last_flush_trans_id: \t%u\n"
-		   "j_trans_start_time: \t%li\n"
+		   "j_trans_start_time: \t%lli\n"
 		   "j_list_bitmap_index: \t%i\n"
 		   "j_must_wait: \t%i\n"
 		   "j_next_full_flush: \t%i\n"
@@ -366,7 +373,7 @@ static int show_journal(struct seq_file *m, void *unused)
 		   JF(j_bcount),
 		   JF(j_first_unflushed_offset),
 		   JF(j_last_flush_trans_id),
-		   JF(j_trans_start_time),
+		   ktime_mono_to_real_seconds(JF(j_trans_start_time)),
 		   JF(j_list_bitmap_index),
 		   JF(j_must_wait),
 		   JF(j_next_full_flush),

commit 3f3942aca6da351a12543aa776467791b63b3a78
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 15 15:57:23 2018 +0200

    proc: introduce proc_create_single{,_data}
    
    Variants of proc_create{,_data} that directly take a seq_file show
    callback and drastically reduces the boilerplate code in the callers.
    
    All trivial callers converted over.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index fe999157dd97..e39b3910d24d 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -389,27 +389,13 @@ static int show_journal(struct seq_file *m, void *unused)
 	return 0;
 }
 
-static int r_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, PDE_DATA(inode), 
-				proc_get_parent_data(inode));
-}
-
-static const struct file_operations r_file_operations = {
-	.open = r_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
 static struct proc_dir_entry *proc_info_root = NULL;
 static const char proc_info_root_name[] = "fs/reiserfs";
 
 static void add_file(struct super_block *sb, char *name,
 		     int (*func) (struct seq_file *, void *))
 {
-	proc_create_data(name, 0, REISERFS_SB(sb)->procdir,
-			 &r_file_operations, func);
+	proc_create_single_data(name, 0, REISERFS_SB(sb)->procdir, func, sb);
 }
 
 int reiserfs_proc_info_init(struct super_block *sb)

commit a1c6f05733c27ba7067c06c095f49e8732a5ae17
Author: Dmitry Monakhov <dmonakhov@openvz.org>
Date:   Mon Apr 13 16:31:37 2015 +0400

    fs: use block_device name vsprintf helper
    
    Signed-off-by: Dmitry Monakhov <dmonakhov@openvz.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 621b9f381fe1..fe999157dd97 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -303,11 +303,10 @@ static int show_journal(struct seq_file *m, void *unused)
 	struct reiserfs_sb_info *r = REISERFS_SB(sb);
 	struct reiserfs_super_block *rs = r->s_rs;
 	struct journal_params *jp = &rs->s_v1.s_journal;
-	char b[BDEVNAME_SIZE];
 
 	seq_printf(m,		/* on-disk fields */
 		   "jp_journal_1st_block: \t%i\n"
-		   "jp_journal_dev: \t%s[%x]\n"
+		   "jp_journal_dev: \t%pg[%x]\n"
 		   "jp_journal_size: \t%i\n"
 		   "jp_journal_trans_max: \t%i\n"
 		   "jp_journal_magic: \t%i\n"
@@ -348,7 +347,7 @@ static int show_journal(struct seq_file *m, void *unused)
 		   "prepare: \t%12lu\n"
 		   "prepare_retry: \t%12lu\n",
 		   DJP(jp_journal_1st_block),
-		   bdevname(SB_JOURNAL(sb)->j_dev_bd, b),
+		   SB_JOURNAL(sb)->j_dev_bd,
 		   DJP(jp_journal_dev),
 		   DJP(jp_journal_size),
 		   DJP(jp_journal_trans_max),

commit 17093991af4995c4b93f6d8ac63aab68fcd9e1be
Author: Fabian Frederick <fabf@skynet.be>
Date:   Fri Aug 8 14:21:12 2014 -0700

    fs/reiserfs: use linux/uaccess.h
    
    Fix checkpatch warning
    
      WARNING: Use #include <linux/uaccess.h> instead of <asm/uaccess.h>
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 02b0b7d0f7d5..621b9f381fe1 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -11,7 +11,7 @@
 #include <linux/module.h>
 #include <linux/time.h>
 #include <linux/seq_file.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include "reiserfs.h"
 #include <linux/init.h>
 #include <linux/proc_fs.h>

commit 2ccdc413196b43a02bb68b46be5b68850904e9ea
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Nov 22 13:25:39 2013 -0500

    kill reiserfs_bdevname()
    
    it's never called with NULL argument...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index a958444a75fc..02b0b7d0f7d5 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -419,7 +419,7 @@ int reiserfs_proc_info_init(struct super_block *sb)
 	char *s;
 
 	/* Some block devices use /'s */
-	strlcpy(b, reiserfs_bdevname(sb), BDEVNAME_SIZE);
+	strlcpy(b, sb->s_id, BDEVNAME_SIZE);
 	s = strchr(b, '/');
 	if (s)
 		*s = '!';
@@ -449,7 +449,7 @@ int reiserfs_proc_info_done(struct super_block *sb)
 		char *s;
 
 		/* Some block devices use /'s */
-		strlcpy(b, reiserfs_bdevname(sb), BDEVNAME_SIZE);
+		strlcpy(b, sb->s_id, BDEVNAME_SIZE);
 		s = strchr(b, '/');
 		if (s)
 			*s = '!';

commit 672fe15d091ce76d6fb98e489962e9add7c1ba4c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Aug 5 17:37:37 2013 +0400

    reiserfs: fix deadlock in umount
    
    Since remove_proc_entry() started to wait for IO in progress (i.e.
    since 2007 or so), the locking in fs/reiserfs/proc.c became wrong;
    if procfs read happens between the moment when umount() locks the
    victim superblock and removal of /proc/fs/reiserfs/<device>/*,
    we'll get a deadlock - read will wait for s_umount (in sget(),
    called by r_start()), while umount will wait in remove_proc_entry()
    for that read to finish, holding s_umount all along.
    
    Fortunately, the same change allows a much simpler race avoidance -
    all we need to do is remove the procfs entries in the very beginning
    of reiserfs ->kill_sb(); that'll guarantee that pointer to superblock
    will remain valid for the duration for procfs IO, so we don't need
    sget() to keep the sucker alive.  As the matter of fact, we can
    get rid of the home-grown iterator completely, and use single_open()
    instead.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 33532f79b4f7..a958444a75fc 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -19,12 +19,13 @@
 /*
  * LOCKING:
  *
- * We rely on new Alexander Viro's super-block locking.
+ * These guys are evicted from procfs as the very first step in ->kill_sb().
  *
  */
 
-static int show_version(struct seq_file *m, struct super_block *sb)
+static int show_version(struct seq_file *m, void *unused)
 {
+	struct super_block *sb = m->private;
 	char *format;
 
 	if (REISERFS_SB(sb)->s_properties & (1 << REISERFS_3_6)) {
@@ -66,8 +67,9 @@ static int show_version(struct seq_file *m, struct super_block *sb)
 #define DJP( x ) le32_to_cpu( jp -> x )
 #define JF( x ) ( r -> s_journal -> x )
 
-static int show_super(struct seq_file *m, struct super_block *sb)
+static int show_super(struct seq_file *m, void *unused)
 {
+	struct super_block *sb = m->private;
 	struct reiserfs_sb_info *r = REISERFS_SB(sb);
 
 	seq_printf(m, "state: \t%s\n"
@@ -128,8 +130,9 @@ static int show_super(struct seq_file *m, struct super_block *sb)
 	return 0;
 }
 
-static int show_per_level(struct seq_file *m, struct super_block *sb)
+static int show_per_level(struct seq_file *m, void *unused)
 {
+	struct super_block *sb = m->private;
 	struct reiserfs_sb_info *r = REISERFS_SB(sb);
 	int level;
 
@@ -186,8 +189,9 @@ static int show_per_level(struct seq_file *m, struct super_block *sb)
 	return 0;
 }
 
-static int show_bitmap(struct seq_file *m, struct super_block *sb)
+static int show_bitmap(struct seq_file *m, void *unused)
 {
+	struct super_block *sb = m->private;
 	struct reiserfs_sb_info *r = REISERFS_SB(sb);
 
 	seq_printf(m, "free_block: %lu\n"
@@ -218,8 +222,9 @@ static int show_bitmap(struct seq_file *m, struct super_block *sb)
 	return 0;
 }
 
-static int show_on_disk_super(struct seq_file *m, struct super_block *sb)
+static int show_on_disk_super(struct seq_file *m, void *unused)
 {
+	struct super_block *sb = m->private;
 	struct reiserfs_sb_info *sb_info = REISERFS_SB(sb);
 	struct reiserfs_super_block *rs = sb_info->s_rs;
 	int hash_code = DFL(s_hash_function_code);
@@ -261,8 +266,9 @@ static int show_on_disk_super(struct seq_file *m, struct super_block *sb)
 	return 0;
 }
 
-static int show_oidmap(struct seq_file *m, struct super_block *sb)
+static int show_oidmap(struct seq_file *m, void *unused)
 {
+	struct super_block *sb = m->private;
 	struct reiserfs_sb_info *sb_info = REISERFS_SB(sb);
 	struct reiserfs_super_block *rs = sb_info->s_rs;
 	unsigned int mapsize = le16_to_cpu(rs->s_v1.s_oid_cursize);
@@ -291,8 +297,9 @@ static int show_oidmap(struct seq_file *m, struct super_block *sb)
 	return 0;
 }
 
-static int show_journal(struct seq_file *m, struct super_block *sb)
+static int show_journal(struct seq_file *m, void *unused)
 {
+	struct super_block *sb = m->private;
 	struct reiserfs_sb_info *r = REISERFS_SB(sb);
 	struct reiserfs_super_block *rs = r->s_rs;
 	struct journal_params *jp = &rs->s_v1.s_journal;
@@ -383,92 +390,24 @@ static int show_journal(struct seq_file *m, struct super_block *sb)
 	return 0;
 }
 
-/* iterator */
-static int test_sb(struct super_block *sb, void *data)
-{
-	return data == sb;
-}
-
-static int set_sb(struct super_block *sb, void *data)
-{
-	return -ENOENT;
-}
-
-struct reiserfs_seq_private {
-	struct super_block *sb;
-	int (*show) (struct seq_file *, struct super_block *);
-};
-
-static void *r_start(struct seq_file *m, loff_t * pos)
-{
-	struct reiserfs_seq_private *priv = m->private;
-	loff_t l = *pos;
-
-	if (l)
-		return NULL;
-
-	if (IS_ERR(sget(&reiserfs_fs_type, test_sb, set_sb, 0, priv->sb)))
-		return NULL;
-
-	up_write(&priv->sb->s_umount);
-	return priv->sb;
-}
-
-static void *r_next(struct seq_file *m, void *v, loff_t * pos)
-{
-	++*pos;
-	if (v)
-		deactivate_super(v);
-	return NULL;
-}
-
-static void r_stop(struct seq_file *m, void *v)
-{
-	if (v)
-		deactivate_super(v);
-}
-
-static int r_show(struct seq_file *m, void *v)
-{
-	struct reiserfs_seq_private *priv = m->private;
-	return priv->show(m, v);
-}
-
-static const struct seq_operations r_ops = {
-	.start = r_start,
-	.next = r_next,
-	.stop = r_stop,
-	.show = r_show,
-};
-
 static int r_open(struct inode *inode, struct file *file)
 {
-	struct reiserfs_seq_private *priv;
-	int ret = seq_open_private(file, &r_ops,
-				   sizeof(struct reiserfs_seq_private));
-
-	if (!ret) {
-		struct seq_file *m = file->private_data;
-		priv = m->private;
-		priv->sb = proc_get_parent_data(inode);
-		priv->show = PDE_DATA(inode);
-	}
-	return ret;
+	return single_open(file, PDE_DATA(inode), 
+				proc_get_parent_data(inode));
 }
 
 static const struct file_operations r_file_operations = {
 	.open = r_open,
 	.read = seq_read,
 	.llseek = seq_lseek,
-	.release = seq_release_private,
-	.owner = THIS_MODULE,
+	.release = single_release,
 };
 
 static struct proc_dir_entry *proc_info_root = NULL;
 static const char proc_info_root_name[] = "fs/reiserfs";
 
 static void add_file(struct super_block *sb, char *name,
-		     int (*func) (struct seq_file *, struct super_block *))
+		     int (*func) (struct seq_file *, void *))
 {
 	proc_create_data(name, 0, REISERFS_SB(sb)->procdir,
 			 &r_file_operations, func);

commit e42270a19e357d7808890bdbeb0cae97f2a2d234
Author: David Howells <dhowells@redhat.com>
Date:   Fri Apr 12 11:17:06 2013 +0100

    reiserfs: Don't access the proc_dir_entry in r_open(), r_start() r_show()
    
    Don't access the proc_dir_entry in ReiserFS's r_open(), r_start() r_show()
    procfs interface functions.
    
    ReiserFS stores the ->show() method pointer in PDE->data and the super_block
    pointer in PDE->parent->data.  This isn't changing.
    
    Currently, ReiserFS passes the PDE pointer into seq_file::private from
    r_open() so that r_start() and r_show() can then access it.  Instead, use
    seq_open_private() to allocate a two-pointer struct that's passed through
    seq_file::private and put the ->show() method and the sb pointers in there.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: reiserfs-devel@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 07c2162ef556..33532f79b4f7 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -394,20 +394,24 @@ static int set_sb(struct super_block *sb, void *data)
 	return -ENOENT;
 }
 
+struct reiserfs_seq_private {
+	struct super_block *sb;
+	int (*show) (struct seq_file *, struct super_block *);
+};
+
 static void *r_start(struct seq_file *m, loff_t * pos)
 {
-	struct proc_dir_entry *de = m->private;
-	struct super_block *s = de->parent->data;
+	struct reiserfs_seq_private *priv = m->private;
 	loff_t l = *pos;
 
 	if (l)
 		return NULL;
 
-	if (IS_ERR(sget(&reiserfs_fs_type, test_sb, set_sb, 0, s)))
+	if (IS_ERR(sget(&reiserfs_fs_type, test_sb, set_sb, 0, priv->sb)))
 		return NULL;
 
-	up_write(&s->s_umount);
-	return s;
+	up_write(&priv->sb->s_umount);
+	return priv->sb;
 }
 
 static void *r_next(struct seq_file *m, void *v, loff_t * pos)
@@ -426,9 +430,8 @@ static void r_stop(struct seq_file *m, void *v)
 
 static int r_show(struct seq_file *m, void *v)
 {
-	struct proc_dir_entry *de = m->private;
-	int (*show) (struct seq_file *, struct super_block *) = de->data;
-	return show(m, v);
+	struct reiserfs_seq_private *priv = m->private;
+	return priv->show(m, v);
 }
 
 static const struct seq_operations r_ops = {
@@ -440,11 +443,15 @@ static const struct seq_operations r_ops = {
 
 static int r_open(struct inode *inode, struct file *file)
 {
-	int ret = seq_open(file, &r_ops);
+	struct reiserfs_seq_private *priv;
+	int ret = seq_open_private(file, &r_ops,
+				   sizeof(struct reiserfs_seq_private));
 
 	if (!ret) {
 		struct seq_file *m = file->private_data;
-		m->private = PDE(inode);
+		priv = m->private;
+		priv->sb = proc_get_parent_data(inode);
+		priv->show = PDE_DATA(inode);
 	}
 	return ret;
 }
@@ -453,7 +460,7 @@ static const struct file_operations r_file_operations = {
 	.open = r_open,
 	.read = seq_read,
 	.llseek = seq_lseek,
-	.release = seq_release,
+	.release = seq_release_private,
 	.owner = THIS_MODULE,
 };
 

commit 270b5ac2151707c25d3327722c5badfbd95945bc
Author: David Howells <dhowells@redhat.com>
Date:   Fri Apr 12 02:48:30 2013 +0100

    proc: Add proc_mkdir_data()
    
    Add proc_mkdir_data() to allow procfs directories to be created that are
    annotated at the time of creation with private data rather than doing this
    post-creation.  This means no access is then required to the proc_dir_entry
    struct to set this.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    cc: Neela Syam Kolli <megaraidlinux@lsi.com>
    cc: Jerry Chuang <jerry-chuang@realtek.com>
    cc: linux-scsi@vger.kernel.org
    cc: devel@driverdev.osuosl.org
    cc: linux-wireless@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 274adea363ff..07c2162ef556 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -479,9 +479,8 @@ int reiserfs_proc_info_init(struct super_block *sb)
 		*s = '!';
 
 	spin_lock_init(&__PINFO(sb).lock);
-	REISERFS_SB(sb)->procdir = proc_mkdir(b, proc_info_root);
+	REISERFS_SB(sb)->procdir = proc_mkdir_data(b, 0, proc_info_root, sb);
 	if (REISERFS_SB(sb)->procdir) {
-		REISERFS_SB(sb)->procdir->data = sb;
 		add_file(sb, "version", show_version);
 		add_file(sb, "super", show_super);
 		add_file(sb, "per-level", show_per_level);

commit 121daf5f8b4a60158e26f357eb286acf83eb33b4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 30 20:16:20 2013 -0400

    reiserfs: use proc_remove_subtree()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 9cc0740adffa..274adea363ff 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -499,29 +499,17 @@ int reiserfs_proc_info_init(struct super_block *sb)
 int reiserfs_proc_info_done(struct super_block *sb)
 {
 	struct proc_dir_entry *de = REISERFS_SB(sb)->procdir;
-	char b[BDEVNAME_SIZE];
-	char *s;
+	if (de) {
+		char b[BDEVNAME_SIZE];
+		char *s;
 
-	/* Some block devices use /'s */
-	strlcpy(b, reiserfs_bdevname(sb), BDEVNAME_SIZE);
-	s = strchr(b, '/');
-	if (s)
-		*s = '!';
+		/* Some block devices use /'s */
+		strlcpy(b, reiserfs_bdevname(sb), BDEVNAME_SIZE);
+		s = strchr(b, '/');
+		if (s)
+			*s = '!';
 
-	if (de) {
-		remove_proc_entry("journal", de);
-		remove_proc_entry("oidmap", de);
-		remove_proc_entry("on-disk-super", de);
-		remove_proc_entry("bitmap", de);
-		remove_proc_entry("per-level", de);
-		remove_proc_entry("super", de);
-		remove_proc_entry("version", de);
-	}
-	spin_lock(&__PINFO(sb).lock);
-	__PINFO(sb).exiting = 1;
-	spin_unlock(&__PINFO(sb).lock);
-	if (proc_info_root) {
-		remove_proc_entry(b, proc_info_root);
+		remove_proc_subtree(b, proc_info_root);
 		REISERFS_SB(sb)->procdir = NULL;
 	}
 	return 0;

commit 496ad9aa8ef448058e36ca7a787c61f2e63f0f54
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jan 23 17:07:38 2013 -0500

    new helper: file_inode(file)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index e60e87035bb3..9cc0740adffa 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -281,7 +281,7 @@ static int show_oidmap(struct seq_file *m, struct super_block *sb)
 	}
 #if defined( REISERFS_USE_OIDMAPF )
 	if (sb_info->oidmap.use_file && (sb_info->oidmap.mapf != NULL)) {
-		loff_t size = sb_info->oidmap.mapf->f_path.dentry->d_inode->i_size;
+		loff_t size = file_inode(sb_info->oidmap.mapf)->i_size;
 		total_used += size / sizeof(reiserfs_oidinterval_d_t);
 	}
 #endif

commit 9249e17fe094d853d1ef7475dd559a2cc7e23d42
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jun 25 12:55:37 2012 +0100

    VFS: Pass mount flags to sget()
    
    Pass mount flags to sget() so that it can use them in initialising a new
    superblock before the set function is called.  They could also be passed to the
    compare function.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 2c1ade692cc8..e60e87035bb3 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -403,7 +403,7 @@ static void *r_start(struct seq_file *m, loff_t * pos)
 	if (l)
 		return NULL;
 
-	if (IS_ERR(sget(&reiserfs_fs_type, test_sb, set_sb, s)))
+	if (IS_ERR(sget(&reiserfs_fs_type, test_sb, set_sb, 0, s)))
 		return NULL;
 
 	up_write(&s->s_umount);

commit f466c6fdb3b1f043ff1977a8d2a1d0cd4dc164fa
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 17 01:16:43 2012 -0400

    move private bits of reiserfs_fs.h to fs/reiserfs/reiserfs.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index f931a089bbe7..2c1ade692cc8 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -12,7 +12,7 @@
 #include <linux/time.h>
 #include <linux/seq_file.h>
 #include <asm/uaccess.h>
-#include <linux/reiserfs_fs.h>
+#include "reiserfs.h"
 #include <linux/init.h>
 #include <linux/proc_fs.h>
 

commit a8a4b79b53fc7cbb023afedf58b04dd4e9bbb114
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 17 01:06:11 2012 -0400

    kill pointless includes of reiserfs_fs_{i,sb}.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 7a9981196c1c..f931a089bbe7 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -13,7 +13,6 @@
 #include <linux/seq_file.h>
 #include <asm/uaccess.h>
 #include <linux/reiserfs_fs.h>
-#include <linux/reiserfs_fs_sb.h>
 #include <linux/init.h>
 #include <linux/proc_fs.h>
 

commit e3c96f53ac132743fda1384910feb863a2eab916
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Dec 15 16:46:54 2009 -0800

    reiserfs: don't compile procfs.o at all if no support
    
    * small define cleanup in header
    * fix #ifdeffery in procfs.c via Kconfig
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 0ebb11646526..7a9981196c1c 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -17,8 +17,6 @@
 #include <linux/init.h>
 #include <linux/proc_fs.h>
 
-#ifdef CONFIG_REISERFS_PROC_INFO
-
 /*
  * LOCKING:
  *
@@ -551,30 +549,6 @@ int reiserfs_proc_info_global_done(void)
 	}
 	return 0;
 }
-
-/* REISERFS_PROC_INFO */
-#else
-
-int reiserfs_proc_info_init(struct super_block *sb)
-{
-	return 0;
-}
-int reiserfs_proc_info_done(struct super_block *sb)
-{
-	return 0;
-}
-
-int reiserfs_proc_info_global_init(void)
-{
-	return 0;
-}
-int reiserfs_proc_info_global_done(void)
-{
-	return 0;
-}
-/* REISERFS_PROC_INFO */
-#endif
-
 /*
  * Revision 1.1.8.2  2001/07/15 17:08:42  god
  *  . use get_super() in procfs.c

commit 904e812931f001b984912b2d2f653ea69520313c
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Dec 15 16:46:52 2009 -0800

    reiserfs: remove /proc/fs/reiserfs/version
    
    /proc/fs/reiserfs/version is on the way of removing ->read_proc interface.
     It's empty however, so simply remove it instead of doing dummy
    conversion.  It's hard to see what information userspace can extract from
    empty file.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 9229e5514a4e..0ebb11646526 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -48,14 +48,6 @@ static int show_version(struct seq_file *m, struct super_block *sb)
 	return 0;
 }
 
-int reiserfs_global_version_in_proc(char *buffer, char **start, off_t offset,
-				    int count, int *eof, void *data)
-{
-	*start = buffer;
-	*eof = 1;
-	return 0;
-}
-
 #define SF( x ) ( r -> x )
 #define SFP( x ) SF( s_proc_info_data.x )
 #define SFPL( x ) SFP( x[ level ] )
@@ -538,19 +530,6 @@ int reiserfs_proc_info_done(struct super_block *sb)
 	return 0;
 }
 
-struct proc_dir_entry *reiserfs_proc_register_global(char *name,
-						     read_proc_t * func)
-{
-	return (proc_info_root) ? create_proc_read_entry(name, 0,
-							 proc_info_root,
-							 func, NULL) : NULL;
-}
-
-void reiserfs_proc_unregister_global(const char *name)
-{
-	remove_proc_entry(name, proc_info_root);
-}
-
 int reiserfs_proc_info_global_init(void)
 {
 	if (proc_info_root == NULL) {
@@ -585,16 +564,6 @@ int reiserfs_proc_info_done(struct super_block *sb)
 	return 0;
 }
 
-struct proc_dir_entry *reiserfs_proc_register_global(char *name,
-						     read_proc_t * func)
-{
-	return NULL;
-}
-
-void reiserfs_proc_unregister_global(const char *name)
-{;
-}
-
 int reiserfs_proc_info_global_init(void)
 {
 	return 0;
@@ -603,14 +572,6 @@ int reiserfs_proc_info_global_done(void)
 {
 	return 0;
 }
-
-int reiserfs_global_version_in_proc(char *buffer, char **start,
-				    off_t offset,
-				    int count, int *eof, void *data)
-{
-	return 0;
-}
-
 /* REISERFS_PROC_INFO */
 #endif
 

commit 99b76233803beab302123d243eea9e41149804f3
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 25 22:48:06 2009 +0300

    proc 2/2: remove struct proc_dir_entry::owner
    
    Setting ->owner as done currently (pde->owner = THIS_MODULE) is racy
    as correctly noted at bug #12454. Someone can lookup entry with NULL
    ->owner, thus not pinning enything, and release it later resulting
    in module refcount underflow.
    
    We can keep ->owner and supply it at registration time like ->proc_fops
    and ->data.
    
    But this leaves ->owner as easy-manipulative field (just one C assignment)
    and somebody will forget to unpin previous/pin current module when
    switching ->owner. ->proc_fops is declared as "const" which should give
    some thoughts.
    
    ->read_proc/->write_proc were just fixed to not require ->owner for
    protection.
    
    rmmod'ed directories will be empty and return "." and ".." -- no harm.
    And directories with tricky enough readdir and lookup shouldn't be modular.
    We definitely don't want such modular code.
    
    Removing ->owner will also make PDE smaller.
    
    So, let's nuke it.
    
    Kudos to Jeff Layton for reminding about this, let's say, oversight.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=12454
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index d5066400638a..9229e5514a4e 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -492,7 +492,6 @@ int reiserfs_proc_info_init(struct super_block *sb)
 	spin_lock_init(&__PINFO(sb).lock);
 	REISERFS_SB(sb)->procdir = proc_mkdir(b, proc_info_root);
 	if (REISERFS_SB(sb)->procdir) {
-		REISERFS_SB(sb)->procdir->owner = THIS_MODULE;
 		REISERFS_SB(sb)->procdir->data = sb;
 		add_file(sb, "version", show_version);
 		add_file(sb, "super", show_super);
@@ -556,9 +555,7 @@ int reiserfs_proc_info_global_init(void)
 {
 	if (proc_info_root == NULL) {
 		proc_info_root = proc_mkdir(proc_info_root_name, NULL);
-		if (proc_info_root) {
-			proc_info_root->owner = THIS_MODULE;
-		} else {
+		if (!proc_info_root) {
 			reiserfs_warning(NULL, "cannot create /proc/%s",
 					 proc_info_root_name);
 			return 1;

commit 0222e6571c332563a48d4cf5487b67feabe60b5e
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:44 2009 -0400

    reiserfs: strip trailing whitespace
    
    This patch strips trailing whitespace from the reiserfs code.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index d4d7f1433ed0..d5066400638a 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -633,7 +633,7 @@ int reiserfs_global_version_in_proc(char *buffer, char **start,
  *
  */
 
-/* 
+/*
  * Make Linus happy.
  * Local variables:
  * c-indentation-style: "K&R"

commit 45b03d5e8e674eb6555b767e1c8eb40b671ff892
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:21 2009 -0400

    reiserfs: rework reiserfs_warning
    
    ReiserFS warnings can be somewhat inconsistent.
    In some cases:
     * a unique identifier may be associated with it
     * the function name may be included
     * the device may be printed separately
    
    This patch aims to make warnings more consistent. reiserfs_warning() prints
    the device name, so printing it a second time is not required. The function
    name for a warning is always helpful in debugging, so it is now automatically
    inserted into the output. Hans has stated that every warning should have
    a unique identifier. Some cases lack them, others really shouldn't have them.
    reiserfs_warning() now expects an id associated with each message. In the
    rare case where one isn't needed, "" will suffice.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 370988efc8ad..d4d7f1433ed0 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -503,7 +503,7 @@ int reiserfs_proc_info_init(struct super_block *sb)
 		add_file(sb, "journal", show_journal);
 		return 0;
 	}
-	reiserfs_warning(sb, "reiserfs: cannot create /proc/%s/%s",
+	reiserfs_warning(sb, "cannot create /proc/%s/%s",
 			 proc_info_root_name, b);
 	return 1;
 }
@@ -559,8 +559,7 @@ int reiserfs_proc_info_global_init(void)
 		if (proc_info_root) {
 			proc_info_root->owner = THIS_MODULE;
 		} else {
-			reiserfs_warning(NULL,
-					 "reiserfs: cannot create /proc/%s",
+			reiserfs_warning(NULL, "cannot create /proc/%s",
 					 proc_info_root_name);
 			return 1;
 		}

commit 600ed41675d8c384519d8f0b3c76afed39ef2f4b
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:17 2009 -0400

    reiserfs: audit transaction ids to always be unsigned ints
    
    This patch fixes up the reiserfs code such that transaction ids are
    always unsigned ints.  In places they can currently be signed ints or
    unsigned longs.
    
    The former just causes an annoying clm-2200 warning and may join a
    transaction when it should wait.
    
    The latter is just for correctness since the disk format uses a 32-bit
    transaction id.  There aren't any runtime problems that result from it
    not wrapping at the correct location since the value is truncated
    correctly even on big endian systems.  The 0 value might make it to
    disk, but the mount-time checks will bump it to 10 itself.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 37173fa07d15..370988efc8ad 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -321,7 +321,7 @@ static int show_journal(struct seq_file *m, struct super_block *sb)
 		   /* incore fields */
 		   "j_1st_reserved_block: \t%i\n"
 		   "j_state: \t%li\n"
-		   "j_trans_id: \t%lu\n"
+		   "j_trans_id: \t%u\n"
 		   "j_mount_id: \t%lu\n"
 		   "j_start: \t%lu\n"
 		   "j_len: \t%lu\n"
@@ -329,7 +329,7 @@ static int show_journal(struct seq_file *m, struct super_block *sb)
 		   "j_wcount: \t%i\n"
 		   "j_bcount: \t%lu\n"
 		   "j_first_unflushed_offset: \t%lu\n"
-		   "j_last_flush_trans_id: \t%lu\n"
+		   "j_last_flush_trans_id: \t%u\n"
 		   "j_trans_start_time: \t%li\n"
 		   "j_list_bitmap_index: \t%i\n"
 		   "j_must_wait: \t%i\n"

commit 6b23ea7679978e6e1148aae9245021dfbcd989d7
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Oct 15 22:04:11 2008 -0700

    reiserfs/procfs.c: remove CVS keywords
    
    Remove CVS keywords that weren't updated for a long time from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index b9dbeeca7049..37173fa07d15 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -8,8 +8,6 @@
 
 /* proc info support a la one created by Sizif@Botik.RU for PGC */
 
-/* $Id: procfs.c,v 1.1.8.2 2001/07/15 17:08:42 god Exp $ */
-
 #include <linux/module.h>
 #include <linux/time.h>
 #include <linux/seq_file.h>
@@ -621,7 +619,6 @@ int reiserfs_global_version_in_proc(char *buffer, char **start,
 #endif
 
 /*
- * $Log: procfs.c,v $
  * Revision 1.1.8.2  2001/07/15 17:08:42  god
  *  . use get_super() in procfs.c
  *  . remove remove_save_link() from reiserfs_do_truncate()

commit 19b4fc52d63b77adf700a215bfbabd680a8f1718
Author: Denis V. Lunev <den@openvz.org>
Date:   Tue Apr 29 01:02:09 2008 -0700

    reiserfs: use non-racy method for proc entries creation
    
    Use proc_create()/proc_create_data() to make sure that ->proc_fops and ->data
    be setup before gluing PDE to main tree.
    
    /proc entry owner is also added.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 8f86c52b30d8..b9dbeeca7049 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -467,6 +467,7 @@ static const struct file_operations r_file_operations = {
 	.read = seq_read,
 	.llseek = seq_lseek,
 	.release = seq_release,
+	.owner = THIS_MODULE,
 };
 
 static struct proc_dir_entry *proc_info_root = NULL;
@@ -475,12 +476,8 @@ static const char proc_info_root_name[] = "fs/reiserfs";
 static void add_file(struct super_block *sb, char *name,
 		     int (*func) (struct seq_file *, struct super_block *))
 {
-	struct proc_dir_entry *de;
-	de = create_proc_entry(name, 0, REISERFS_SB(sb)->procdir);
-	if (de) {
-		de->data = func;
-		de->proc_fops = &r_file_operations;
-	}
+	proc_create_data(name, 0, REISERFS_SB(sb)->procdir,
+			 &r_file_operations, func);
 }
 
 int reiserfs_proc_info_init(struct super_block *sb)

commit ec26e11740cdff8c3c8330ea235478704ffb4a71
Author: Jan Engelhardt <jengelh@computergmbh.de>
Date:   Fri Feb 8 04:21:18 2008 -0800

    reiserfs: constify function pointer tables
    
    Signed-off-by: Jan Engelhardt <jengelh@computergmbh.de>
    Acked-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 001144621672..8f86c52b30d8 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -444,7 +444,7 @@ static int r_show(struct seq_file *m, void *v)
 	return show(m, v);
 }
 
-static struct seq_operations r_ops = {
+static const struct seq_operations r_ops = {
 	.start = r_start,
 	.next = r_next,
 	.stop = r_stop,

commit 5a622f2d0f86b316b07b55a4866ecb5518dd1cf7
Author: Alexey Dobriyan <adobriyan@sw.ru>
Date:   Tue Dec 4 23:45:28 2007 -0800

    proc: fix proc_dir_entry refcounting
    
    Creating PDEs with refcount 0 and "deleted" flag has problems (see below).
    Switch to usual scheme:
    * PDE is created with refcount 1
    * every de_get does +1
    * every de_put() and remove_proc_entry() do -1
    * once refcount reaches 0, PDE is freed.
    
    This elegantly fixes at least two following races (both observed) without
    introducing new locks, without abusing old locks, without spreading
    lock_kernel():
    
    1) PDE leak
    
    remove_proc_entry                       de_put
    -----------------                       ------
                            [refcnt = 1]
    if (atomic_read(&de->count) == 0)
                                            if (atomic_dec_and_test(&de->count))
                                                    if (de->deleted)
                                                            /* also not taken! */
                                                            free_proc_entry(de);
    else
            de->deleted = 1;
                    [refcount=0, deleted=1]
    
    2) use after free
    
    remove_proc_entry                       de_put
    -----------------                       ------
                            [refcnt = 1]
    
                                            if (atomic_dec_and_test(&de->count))
    if (atomic_read(&de->count) == 0)
            free_proc_entry(de);
                                                    /* boom! */
                                                    if (de->deleted)
                                                            free_proc_entry(de);
    
    BUG: unable to handle kernel paging request at virtual address 6b6b6b6b
    printing eip: c10acdda *pdpt = 00000000338f8001 *pde = 0000000000000000
    Oops: 0000 [#1] PREEMPT SMP
    Modules linked in: af_packet ipv6 cpufreq_ondemand loop serio_raw psmouse k8temp hwmon sr_mod cdrom
    Pid: 23161, comm: cat Not tainted (2.6.24-rc2-8c0863403f109a43d7000b4646da4818220d501f #4)
    EIP: 0060:[<c10acdda>] EFLAGS: 00210097 CPU: 1
    EIP is at strnlen+0x6/0x18
    EAX: 6b6b6b6b EBX: 6b6b6b6b ECX: 6b6b6b6b EDX: fffffffe
    ESI: c128fa3b EDI: f380bf34 EBP: ffffffff ESP: f380be44
     DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068
    Process cat (pid: 23161, ti=f380b000 task=f38f2570 task.ti=f380b000)
    Stack: c10ac4f0 00000278 c12ce000 f43cd2a8 00000163 00000000 7da86067 00000400
           c128fa20 00896b18 f38325a8 c128fe20 ffffffff 00000000 c11f291e 00000400
           f75be300 c128fa20 f769c9a0 c10ac779 f380bf34 f7bfee70 c1018e6b f380bf34
    Call Trace:
     [<c10ac4f0>] vsnprintf+0x2ad/0x49b
     [<c10ac779>] vscnprintf+0x14/0x1f
     [<c1018e6b>] vprintk+0xc5/0x2f9
     [<c10379f1>] handle_fasteoi_irq+0x0/0xab
     [<c1004f44>] do_IRQ+0x9f/0xb7
     [<c117db3b>] preempt_schedule_irq+0x3f/0x5b
     [<c100264e>] need_resched+0x1f/0x21
     [<c10190ba>] printk+0x1b/0x1f
     [<c107c8ad>] de_put+0x3d/0x50
     [<c107c8f8>] proc_delete_inode+0x38/0x41
     [<c107c8c0>] proc_delete_inode+0x0/0x41
     [<c1066298>] generic_delete_inode+0x5e/0xc6
     [<c1065aa9>] iput+0x60/0x62
     [<c1063c8e>] d_kill+0x2d/0x46
     [<c1063fa9>] dput+0xdc/0xe4
     [<c10571a1>] __fput+0xb0/0xcd
     [<c1054e49>] filp_close+0x48/0x4f
     [<c1055ee9>] sys_close+0x67/0xa5
     [<c10026b6>] sysenter_past_esp+0x5f/0x85
    =======================
    Code: c9 74 0c f2 ae 74 05 bf 01 00 00 00 4f 89 fa 5f 89 d0 c3 85 c9 57 89 c7 89 d0 74 05 f2 ae 75 01 4f 89 f8 5f c3 89 c1 89 c8 eb 06 <80> 38 00 74 07 40 4a 83 fa ff 75 f4 29 c8 c3 90 90 90 57 83 c9
    EIP: [<c10acdda>] strnlen+0x6/0x18 SS:ESP 0068:f380be44
    
    Also, remove broken usage of ->deleted from reiserfs: if sget() succeeds,
    module is already pinned and remove_proc_entry() can't happen => nobody
    can mark PDE deleted.
    
    Dummy proc root in netns code is not marked with refcount 1. AFAICS, we
    never get it, it's just for proper /proc/net removal. I double checked
    CLONE_NETNS continues to work.
    
    Patch survives many hours of modprobe/rmmod/cat loops without new bugs
    which can be attributed to refcounting.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 9aa7a06e093f..001144621672 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -420,12 +420,6 @@ static void *r_start(struct seq_file *m, loff_t * pos)
 		return NULL;
 
 	up_write(&s->s_umount);
-
-	if (de->deleted) {
-		deactivate_super(s);
-		return NULL;
-	}
-
 	return s;
 }
 

commit e63340ae6b6205fef26b40a75673d1c9c0c8bb90
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue May 8 00:28:08 2007 -0700

    header cleaning: don't include smp_lock.h when not used
    
    Remove includes of <linux/smp_lock.h> where it is not used/needed.
    Suggested by Al Viro.
    
    Builds cleanly on x86_64, i386, alpha, ia64, powerpc, sparc,
    sparc64, and arm (all 59 defconfigs).
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 83b9135a411a..9aa7a06e093f 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -16,7 +16,6 @@
 #include <asm/uaccess.h>
 #include <linux/reiserfs_fs.h>
 #include <linux/reiserfs_fs_sb.h>
-#include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/proc_fs.h>
 

commit f87367a6b1e3ec1fd440158e5eb357fbd5c2288e
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Tue May 8 00:25:01 2007 -0700

    reiserfs: correct misspelled "REISERFS_PROC_INFO" to "CONFIG_REISERFS_PROC_INFO"
    
    Correct the misspelling of the preprocessor check of a Kconfig option to refer
    to CONFIG_REISERFS_PROC_INFO and not just the incorrect REISERFS_PROC_INFO.
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index ecc9943202fc..83b9135a411a 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -20,7 +20,7 @@
 #include <linux/init.h>
 #include <linux/proc_fs.h>
 
-#if defined( REISERFS_PROC_INFO )
+#ifdef CONFIG_REISERFS_PROC_INFO
 
 /*
  * LOCKING:

commit 1fc5adbd1916793c19d25347f484806c124d9be7
Author: Josef Sipek <jsipek@fsl.cs.sunysb.edu>
Date:   Fri Dec 8 02:37:33 2006 -0800

    [PATCH] struct path: convert reiserfs
    
    Signed-off-by: Josef Sipek <jsipek@fsl.cs.sunysb.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index c533ec1bcaec..ecc9943202fc 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -295,7 +295,7 @@ static int show_oidmap(struct seq_file *m, struct super_block *sb)
 	}
 #if defined( REISERFS_USE_OIDMAPF )
 	if (sb_info->oidmap.use_file && (sb_info->oidmap.mapf != NULL)) {
-		loff_t size = sb_info->oidmap.mapf->f_dentry->d_inode->i_size;
+		loff_t size = sb_info->oidmap.mapf->f_path.dentry->d_inode->i_size;
 		total_used += size / sizeof(reiserfs_oidinterval_d_t);
 	}
 #endif

commit 6fbe82a952790c634ea6035c223a01a81377daf1
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Jul 14 00:24:22 2006 -0700

    [PATCH] reiserfs: fix handling of device names with /'s in them
    
    On systems with block devices containing a slash (virtual dasd, cciss,
    etc), reiserfs will fail to initialize /proc/fs/reiserfs/<dev> due to it
    being interpreted as a subdirectory.  The generic block device code changes
    the / to !  for use in the sysfs tree.  This patch uses that convention.
    
    Tested by making dm devices use dm/<number> rather than dm-<number>
    
    [akpm@osdl.org: name variables consistently]
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 5d8a8cfebc70..c533ec1bcaec 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -492,9 +492,17 @@ static void add_file(struct super_block *sb, char *name,
 
 int reiserfs_proc_info_init(struct super_block *sb)
 {
+	char b[BDEVNAME_SIZE];
+	char *s;
+
+	/* Some block devices use /'s */
+	strlcpy(b, reiserfs_bdevname(sb), BDEVNAME_SIZE);
+	s = strchr(b, '/');
+	if (s)
+		*s = '!';
+
 	spin_lock_init(&__PINFO(sb).lock);
-	REISERFS_SB(sb)->procdir =
-	    proc_mkdir(reiserfs_bdevname(sb), proc_info_root);
+	REISERFS_SB(sb)->procdir = proc_mkdir(b, proc_info_root);
 	if (REISERFS_SB(sb)->procdir) {
 		REISERFS_SB(sb)->procdir->owner = THIS_MODULE;
 		REISERFS_SB(sb)->procdir->data = sb;
@@ -508,13 +516,22 @@ int reiserfs_proc_info_init(struct super_block *sb)
 		return 0;
 	}
 	reiserfs_warning(sb, "reiserfs: cannot create /proc/%s/%s",
-			 proc_info_root_name, reiserfs_bdevname(sb));
+			 proc_info_root_name, b);
 	return 1;
 }
 
 int reiserfs_proc_info_done(struct super_block *sb)
 {
 	struct proc_dir_entry *de = REISERFS_SB(sb)->procdir;
+	char b[BDEVNAME_SIZE];
+	char *s;
+
+	/* Some block devices use /'s */
+	strlcpy(b, reiserfs_bdevname(sb), BDEVNAME_SIZE);
+	s = strchr(b, '/');
+	if (s)
+		*s = '!';
+
 	if (de) {
 		remove_proc_entry("journal", de);
 		remove_proc_entry("oidmap", de);
@@ -528,7 +545,7 @@ int reiserfs_proc_info_done(struct super_block *sb)
 	__PINFO(sb).exiting = 1;
 	spin_unlock(&__PINFO(sb).lock);
 	if (proc_info_root) {
-		remove_proc_entry(reiserfs_bdevname(sb), proc_info_root);
+		remove_proc_entry(b, proc_info_root);
 		REISERFS_SB(sb)->procdir = NULL;
 	}
 	return 0;

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index 731688e1cfe3..5d8a8cfebc70 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -10,7 +10,6 @@
 
 /* $Id: procfs.c,v 1.1.8.2 2001/07/15 17:08:42 god Exp $ */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/time.h>
 #include <linux/seq_file.h>

commit 4b6f5d20b04dcbc3d888555522b90ba6d36c4106
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Tue Mar 28 01:56:42 2006 -0800

    [PATCH] Make most file operations structs in fs/ const
    
    This is a conversion to make the various file_operations structs in fs/
    const.  Basically a regexp job, with a few manual fixups
    
    The goal is both to increase correctness (harder to accidentally write to
    shared datastructures) and reducing the false sharing of cachelines with
    things that get dirty in .data (while .rodata is nicely read only and thus
    cache clean)
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index ef6caed9336b..731688e1cfe3 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -470,7 +470,7 @@ static int r_open(struct inode *inode, struct file *file)
 	return ret;
 }
 
-static struct file_operations r_file_operations = {
+static const struct file_operations r_file_operations = {
 	.open = r_open,
 	.read = seq_read,
 	.llseek = seq_lseek,

commit d739b42b82773206297db1fc0d96ef895a5d9688
Author: Pekka Enberg <penberg@cs.helsinki.fi>
Date:   Wed Feb 1 03:06:43 2006 -0800

    [PATCH] reiserfs: remove kmalloc wrapper
    
    Remove kmalloc() wrapper from fs/reiserfs/.  Please note that a reiserfs
    /proc entry format is changed because kmalloc statistics is removed.
    
    Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index fc2f43c75df4..ef6caed9336b 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -88,7 +88,6 @@ static int show_super(struct seq_file *m, struct super_block *sb)
 	seq_printf(m, "state: \t%s\n"
 		   "mount options: \t%s%s%s%s%s%s%s%s%s%s%s\n"
 		   "gen. counter: \t%i\n"
-		   "s_kmallocs: \t%i\n"
 		   "s_disk_reads: \t%i\n"
 		   "s_disk_writes: \t%i\n"
 		   "s_fix_nodes: \t%i\n"
@@ -128,7 +127,7 @@ static int show_super(struct seq_file *m, struct super_block *sb)
 		   "SMALL_TAILS " : "NO_TAILS ",
 		   replay_only(sb) ? "REPLAY_ONLY " : "",
 		   convert_reiserfs(sb) ? "CONV " : "",
-		   atomic_read(&r->s_generation_counter), SF(s_kmallocs),
+		   atomic_read(&r->s_generation_counter),
 		   SF(s_disk_reads), SF(s_disk_writes), SF(s_fix_nodes),
 		   SF(s_do_balance), SF(s_unneeded_left_neighbor),
 		   SF(s_good_search_by_key_reada), SF(s_bmaps),

commit bd4c625c061c2a38568d0add3478f59172455159
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Tue Jul 12 20:21:28 2005 -0700

    reiserfs: run scripts/Lindent on reiserfs code
    
    This was a pure indentation change, using:
    
            scripts/Lindent fs/reiserfs/*.c include/linux/reiserfs_*.h
    
    to make reiserfs match the regular Linux indentation style.  As Jeff
    Mahoney <jeffm@suse.com> writes:
    
     The ReiserFS code is a mix of a number of different coding styles, sometimes
     different even from line-to-line. Since the code has been relatively stable
     for quite some time and there are few outstanding patches to be applied, it
     is time to reformat the code to conform to the Linux style standard outlined
     in Documentation/CodingStyle.
    
     This patch contains the result of running scripts/Lindent against
     fs/reiserfs/*.c and include/linux/reiserfs_*.h. There are places where the
     code can be made to look better, but I'd rather keep those patches separate
     so that there isn't a subtle by-hand hand accident in the middle of a huge
     patch. To be clear: This patch is reformatting *only*.
    
     A number of patches may follow that continue to make the code more consistent
     with the Linux coding style.
    
     Hans wasn't particularly enthusiastic about these patches, but said he
     wouldn't really oppose them either.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index e242ebc7f6f6..fc2f43c75df4 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -33,28 +33,27 @@
 static int show_version(struct seq_file *m, struct super_block *sb)
 {
 	char *format;
-    
-	if ( REISERFS_SB(sb)->s_properties & (1 << REISERFS_3_6) ) {
+
+	if (REISERFS_SB(sb)->s_properties & (1 << REISERFS_3_6)) {
 		format = "3.6";
-	} else if ( REISERFS_SB(sb)->s_properties & (1 << REISERFS_3_5) ) {
+	} else if (REISERFS_SB(sb)->s_properties & (1 << REISERFS_3_5)) {
 		format = "3.5";
 	} else {
 		format = "unknown";
 	}
 
-	seq_printf(m, "%s format\twith checks %s\n",
-			format,
+	seq_printf(m, "%s format\twith checks %s\n", format,
 #if defined( CONFIG_REISERFS_CHECK )
-			"on"
+		   "on"
 #else
-			"off"
+		   "off"
 #endif
-		);
+	    );
 	return 0;
 }
 
-int reiserfs_global_version_in_proc( char *buffer, char **start, off_t offset,
-				     int count, int *eof, void *data )
+int reiserfs_global_version_in_proc(char *buffer, char **start, off_t offset,
+				    int count, int *eof, void *data)
 {
 	*start = buffer;
 	*eof = 1;
@@ -79,87 +78,68 @@ int reiserfs_global_version_in_proc( char *buffer, char **start, off_t offset,
 
 #define DJF( x ) le32_to_cpu( rs -> x )
 #define DJV( x ) le32_to_cpu( s_v1 -> x )
-#define DJP( x ) le32_to_cpu( jp -> x ) 
+#define DJP( x ) le32_to_cpu( jp -> x )
 #define JF( x ) ( r -> s_journal -> x )
 
 static int show_super(struct seq_file *m, struct super_block *sb)
 {
 	struct reiserfs_sb_info *r = REISERFS_SB(sb);
-    
-	seq_printf(m,	"state: \t%s\n"
-			"mount options: \t%s%s%s%s%s%s%s%s%s%s%s\n"
-			"gen. counter: \t%i\n"
-			"s_kmallocs: \t%i\n"
-			"s_disk_reads: \t%i\n"
-			"s_disk_writes: \t%i\n"
-			"s_fix_nodes: \t%i\n"
-			"s_do_balance: \t%i\n"
-			"s_unneeded_left_neighbor: \t%i\n"
-			"s_good_search_by_key_reada: \t%i\n"
-			"s_bmaps: \t%i\n"
-			"s_bmaps_without_search: \t%i\n"
-			"s_direct2indirect: \t%i\n"
-			"s_indirect2direct: \t%i\n"
-			"\n"
-			"max_hash_collisions: \t%i\n"
-
-			"breads: \t%lu\n"
-			"bread_misses: \t%lu\n"
-
-			"search_by_key: \t%lu\n"
-			"search_by_key_fs_changed: \t%lu\n"
-			"search_by_key_restarted: \t%lu\n"
-			
-			"insert_item_restarted: \t%lu\n"
-			"paste_into_item_restarted: \t%lu\n"
-			"cut_from_item_restarted: \t%lu\n"
-			"delete_solid_item_restarted: \t%lu\n"
-			"delete_item_restarted: \t%lu\n"
-
-			"leaked_oid: \t%lu\n"
-			"leaves_removable: \t%lu\n",
-
-			SF( s_mount_state ) == REISERFS_VALID_FS ?
-			"REISERFS_VALID_FS" : "REISERFS_ERROR_FS",
-			reiserfs_r5_hash( sb ) ? "FORCE_R5 " : "",
-			reiserfs_rupasov_hash( sb ) ? "FORCE_RUPASOV " : "",
-			reiserfs_tea_hash( sb ) ? "FORCE_TEA " : "",
-			reiserfs_hash_detect( sb ) ? "DETECT_HASH " : "",
-			reiserfs_no_border( sb ) ? "NO_BORDER " : "BORDER ",
-			reiserfs_no_unhashed_relocation( sb ) ? "NO_UNHASHED_RELOCATION " : "",
-			reiserfs_hashed_relocation( sb ) ? "UNHASHED_RELOCATION " : "",
-			reiserfs_test4( sb ) ? "TEST4 " : "",
-			have_large_tails( sb ) ? "TAILS " : have_small_tails(sb)?"SMALL_TAILS ":"NO_TAILS ",
-			replay_only( sb ) ? "REPLAY_ONLY " : "",
-			convert_reiserfs( sb ) ? "CONV " : "",
-
-			atomic_read( &r -> s_generation_counter ),
-			SF( s_kmallocs ),
-			SF( s_disk_reads ),
-			SF( s_disk_writes ),
-			SF( s_fix_nodes ),
-			SF( s_do_balance ),
-			SF( s_unneeded_left_neighbor ),
-			SF( s_good_search_by_key_reada ),
-			SF( s_bmaps ),
-			SF( s_bmaps_without_search ),
-			SF( s_direct2indirect ),
-			SF( s_indirect2direct ),
-			SFP( max_hash_collisions ),
-			SFP( breads ),
-			SFP( bread_miss ),
-			SFP( search_by_key ),
-			SFP( search_by_key_fs_changed ),
-			SFP( search_by_key_restarted ),
-
-			SFP( insert_item_restarted ),
-			SFP( paste_into_item_restarted ),
-			SFP( cut_from_item_restarted ),
-			SFP( delete_solid_item_restarted ),
-			SFP( delete_item_restarted ),
-
-			SFP( leaked_oid ),
-			SFP( leaves_removable ) );
+
+	seq_printf(m, "state: \t%s\n"
+		   "mount options: \t%s%s%s%s%s%s%s%s%s%s%s\n"
+		   "gen. counter: \t%i\n"
+		   "s_kmallocs: \t%i\n"
+		   "s_disk_reads: \t%i\n"
+		   "s_disk_writes: \t%i\n"
+		   "s_fix_nodes: \t%i\n"
+		   "s_do_balance: \t%i\n"
+		   "s_unneeded_left_neighbor: \t%i\n"
+		   "s_good_search_by_key_reada: \t%i\n"
+		   "s_bmaps: \t%i\n"
+		   "s_bmaps_without_search: \t%i\n"
+		   "s_direct2indirect: \t%i\n"
+		   "s_indirect2direct: \t%i\n"
+		   "\n"
+		   "max_hash_collisions: \t%i\n"
+		   "breads: \t%lu\n"
+		   "bread_misses: \t%lu\n"
+		   "search_by_key: \t%lu\n"
+		   "search_by_key_fs_changed: \t%lu\n"
+		   "search_by_key_restarted: \t%lu\n"
+		   "insert_item_restarted: \t%lu\n"
+		   "paste_into_item_restarted: \t%lu\n"
+		   "cut_from_item_restarted: \t%lu\n"
+		   "delete_solid_item_restarted: \t%lu\n"
+		   "delete_item_restarted: \t%lu\n"
+		   "leaked_oid: \t%lu\n"
+		   "leaves_removable: \t%lu\n",
+		   SF(s_mount_state) == REISERFS_VALID_FS ?
+		   "REISERFS_VALID_FS" : "REISERFS_ERROR_FS",
+		   reiserfs_r5_hash(sb) ? "FORCE_R5 " : "",
+		   reiserfs_rupasov_hash(sb) ? "FORCE_RUPASOV " : "",
+		   reiserfs_tea_hash(sb) ? "FORCE_TEA " : "",
+		   reiserfs_hash_detect(sb) ? "DETECT_HASH " : "",
+		   reiserfs_no_border(sb) ? "NO_BORDER " : "BORDER ",
+		   reiserfs_no_unhashed_relocation(sb) ?
+		   "NO_UNHASHED_RELOCATION " : "",
+		   reiserfs_hashed_relocation(sb) ? "UNHASHED_RELOCATION " : "",
+		   reiserfs_test4(sb) ? "TEST4 " : "",
+		   have_large_tails(sb) ? "TAILS " : have_small_tails(sb) ?
+		   "SMALL_TAILS " : "NO_TAILS ",
+		   replay_only(sb) ? "REPLAY_ONLY " : "",
+		   convert_reiserfs(sb) ? "CONV " : "",
+		   atomic_read(&r->s_generation_counter), SF(s_kmallocs),
+		   SF(s_disk_reads), SF(s_disk_writes), SF(s_fix_nodes),
+		   SF(s_do_balance), SF(s_unneeded_left_neighbor),
+		   SF(s_good_search_by_key_reada), SF(s_bmaps),
+		   SF(s_bmaps_without_search), SF(s_direct2indirect),
+		   SF(s_indirect2direct), SFP(max_hash_collisions), SFP(breads),
+		   SFP(bread_miss), SFP(search_by_key),
+		   SFP(search_by_key_fs_changed), SFP(search_by_key_restarted),
+		   SFP(insert_item_restarted), SFP(paste_into_item_restarted),
+		   SFP(cut_from_item_restarted),
+		   SFP(delete_solid_item_restarted), SFP(delete_item_restarted),
+		   SFP(leaked_oid), SFP(leaves_removable));
 
 	return 0;
 }
@@ -169,61 +149,55 @@ static int show_per_level(struct seq_file *m, struct super_block *sb)
 	struct reiserfs_sb_info *r = REISERFS_SB(sb);
 	int level;
 
-	seq_printf(m,	"level\t"
-			"     balances"
-			" [sbk:  reads"
-			"   fs_changed"
-			"   restarted]"
-			"   free space"
-			"        items"
-			"   can_remove"
-			"         lnum"
-			"         rnum"
-			"       lbytes"
-			"       rbytes"
-			"     get_neig"
-			" get_neig_res"
-			"  need_l_neig"
-			"  need_r_neig"
-			"\n"
-			
-		);
-
-	for( level = 0 ; level < MAX_HEIGHT ; ++ level ) {
-		seq_printf(m,	"%i\t"
-				" %12lu"
-				" %12lu"
-				" %12lu"
-				" %12lu"
-				" %12lu"
-				" %12lu"
-				" %12lu"
-				" %12li"
-				" %12li"
-				" %12li"
-				" %12li"
-				" %12lu"
-				" %12lu"
-				" %12lu"
-				" %12lu"
-				"\n",
-				level, 
-				SFPL( balance_at ),
-				SFPL( sbk_read_at ),
-				SFPL( sbk_fs_changed ),
-				SFPL( sbk_restarted ),
-				SFPL( free_at ),
-				SFPL( items_at ),
-				SFPL( can_node_be_removed ),
-				SFPL( lnum ),
-				SFPL( rnum ),
-				SFPL( lbytes ),
-				SFPL( rbytes ),
-				SFPL( get_neighbors ),
-				SFPL( get_neighbors_restart ),
-				SFPL( need_l_neighbor ),
-				SFPL( need_r_neighbor )
-			);
+	seq_printf(m, "level\t"
+		   "     balances"
+		   " [sbk:  reads"
+		   "   fs_changed"
+		   "   restarted]"
+		   "   free space"
+		   "        items"
+		   "   can_remove"
+		   "         lnum"
+		   "         rnum"
+		   "       lbytes"
+		   "       rbytes"
+		   "     get_neig"
+		   " get_neig_res" "  need_l_neig" "  need_r_neig" "\n");
+
+	for (level = 0; level < MAX_HEIGHT; ++level) {
+		seq_printf(m, "%i\t"
+			   " %12lu"
+			   " %12lu"
+			   " %12lu"
+			   " %12lu"
+			   " %12lu"
+			   " %12lu"
+			   " %12lu"
+			   " %12li"
+			   " %12li"
+			   " %12li"
+			   " %12li"
+			   " %12lu"
+			   " %12lu"
+			   " %12lu"
+			   " %12lu"
+			   "\n",
+			   level,
+			   SFPL(balance_at),
+			   SFPL(sbk_read_at),
+			   SFPL(sbk_fs_changed),
+			   SFPL(sbk_restarted),
+			   SFPL(free_at),
+			   SFPL(items_at),
+			   SFPL(can_node_be_removed),
+			   SFPL(lnum),
+			   SFPL(rnum),
+			   SFPL(lbytes),
+			   SFPL(rbytes),
+			   SFPL(get_neighbors),
+			   SFPL(get_neighbors_restart),
+			   SFPL(need_l_neighbor), SFPL(need_r_neighbor)
+		    );
 	}
 	return 0;
 }
@@ -232,31 +206,30 @@ static int show_bitmap(struct seq_file *m, struct super_block *sb)
 {
 	struct reiserfs_sb_info *r = REISERFS_SB(sb);
 
-	seq_printf(m,	"free_block: %lu\n"
-			"  scan_bitmap:"
-			"          wait"
-			"          bmap"
-			"         retry"
-			"        stolen"
-			"  journal_hint"
-			"journal_nohint"
-			"\n"
-			" %14lu"
-			" %14lu"
-			" %14lu"
-			" %14lu"
-			" %14lu"
-			" %14lu"
-			" %14lu"
-			"\n",
-			SFP( free_block ),
-			SFPF( call ), 
-			SFPF( wait ), 
-			SFPF( bmap ),
-			SFPF( retry ),
-			SFPF( stolen ),
-			SFPF( in_journal_hint ),
-			SFPF( in_journal_nohint ) );
+	seq_printf(m, "free_block: %lu\n"
+		   "  scan_bitmap:"
+		   "          wait"
+		   "          bmap"
+		   "         retry"
+		   "        stolen"
+		   "  journal_hint"
+		   "journal_nohint"
+		   "\n"
+		   " %14lu"
+		   " %14lu"
+		   " %14lu"
+		   " %14lu"
+		   " %14lu"
+		   " %14lu"
+		   " %14lu"
+		   "\n",
+		   SFP(free_block),
+		   SFPF(call),
+		   SFPF(wait),
+		   SFPF(bmap),
+		   SFPF(retry),
+		   SFPF(stolen),
+		   SFPF(in_journal_hint), SFPF(in_journal_nohint));
 
 	return 0;
 }
@@ -264,46 +237,42 @@ static int show_bitmap(struct seq_file *m, struct super_block *sb)
 static int show_on_disk_super(struct seq_file *m, struct super_block *sb)
 {
 	struct reiserfs_sb_info *sb_info = REISERFS_SB(sb);
-	struct reiserfs_super_block *rs = sb_info -> s_rs;
-	int hash_code = DFL( s_hash_function_code );
-	__u32 flags = DJF( s_flags );
-
-	seq_printf(m,	"block_count: \t%i\n"
-			"free_blocks: \t%i\n"
-			"root_block: \t%i\n"
-			"blocksize: \t%i\n"
-			"oid_maxsize: \t%i\n"
-			"oid_cursize: \t%i\n"
-			"umount_state: \t%i\n"
-			"magic: \t%10.10s\n"
-			"fs_state: \t%i\n"
-			"hash: \t%s\n"
-			"tree_height: \t%i\n"
-			"bmap_nr: \t%i\n"
-			"version: \t%i\n"
-			"flags: \t%x[%s]\n"
-			"reserved_for_journal: \t%i\n",
-
-			DFL( s_block_count ),
-			DFL( s_free_blocks ),
-			DFL( s_root_block ),
-			DF( s_blocksize ),
-			DF( s_oid_maxsize ),
-			DF( s_oid_cursize ),
-			DF( s_umount_state ),
-			rs -> s_v1.s_magic,
-			DF( s_fs_state ),
-			hash_code == TEA_HASH ? "tea" :
-			( hash_code == YURA_HASH ) ? "rupasov" :
-			( hash_code == R5_HASH ) ? "r5" :
-			( hash_code == UNSET_HASH ) ? "unset" : "unknown",
-			DF( s_tree_height ),
-			DF( s_bmap_nr ),
-			DF( s_version ),
-			flags,
-			( flags & reiserfs_attrs_cleared )
-			? "attrs_cleared" : "",
-			DF (s_reserved_for_journal));
+	struct reiserfs_super_block *rs = sb_info->s_rs;
+	int hash_code = DFL(s_hash_function_code);
+	__u32 flags = DJF(s_flags);
+
+	seq_printf(m, "block_count: \t%i\n"
+		   "free_blocks: \t%i\n"
+		   "root_block: \t%i\n"
+		   "blocksize: \t%i\n"
+		   "oid_maxsize: \t%i\n"
+		   "oid_cursize: \t%i\n"
+		   "umount_state: \t%i\n"
+		   "magic: \t%10.10s\n"
+		   "fs_state: \t%i\n"
+		   "hash: \t%s\n"
+		   "tree_height: \t%i\n"
+		   "bmap_nr: \t%i\n"
+		   "version: \t%i\n"
+		   "flags: \t%x[%s]\n"
+		   "reserved_for_journal: \t%i\n",
+		   DFL(s_block_count),
+		   DFL(s_free_blocks),
+		   DFL(s_root_block),
+		   DF(s_blocksize),
+		   DF(s_oid_maxsize),
+		   DF(s_oid_cursize),
+		   DF(s_umount_state),
+		   rs->s_v1.s_magic,
+		   DF(s_fs_state),
+		   hash_code == TEA_HASH ? "tea" :
+		   (hash_code == YURA_HASH) ? "rupasov" :
+		   (hash_code == R5_HASH) ? "r5" :
+		   (hash_code == UNSET_HASH) ? "unset" : "unknown",
+		   DF(s_tree_height),
+		   DF(s_bmap_nr),
+		   DF(s_version), flags, (flags & reiserfs_attrs_cleared)
+		   ? "attrs_cleared" : "", DF(s_reserved_for_journal));
 
 	return 0;
 }
@@ -311,131 +280,122 @@ static int show_on_disk_super(struct seq_file *m, struct super_block *sb)
 static int show_oidmap(struct seq_file *m, struct super_block *sb)
 {
 	struct reiserfs_sb_info *sb_info = REISERFS_SB(sb);
-	struct reiserfs_super_block *rs = sb_info -> s_rs;
-	unsigned int mapsize = le16_to_cpu( rs -> s_v1.s_oid_cursize );
+	struct reiserfs_super_block *rs = sb_info->s_rs;
+	unsigned int mapsize = le16_to_cpu(rs->s_v1.s_oid_cursize);
 	unsigned long total_used = 0;
 	int i;
 
-	for( i = 0 ; i < mapsize ; ++i ) {
+	for (i = 0; i < mapsize; ++i) {
 		__u32 right;
 
-		right = ( i == mapsize - 1 ) ? MAX_KEY_OBJECTID : MAP( i + 1 );
+		right = (i == mapsize - 1) ? MAX_KEY_OBJECTID : MAP(i + 1);
 		seq_printf(m, "%s: [ %x .. %x )\n",
-				( i & 1 ) ? "free" : "used", MAP( i ), right );
-		if( ! ( i & 1 ) ) {
-			total_used += right - MAP( i );
+			   (i & 1) ? "free" : "used", MAP(i), right);
+		if (!(i & 1)) {
+			total_used += right - MAP(i);
 		}
 	}
 #if defined( REISERFS_USE_OIDMAPF )
-	if( sb_info -> oidmap.use_file && ( sb_info -> oidmap.mapf != NULL ) ) {
+	if (sb_info->oidmap.use_file && (sb_info->oidmap.mapf != NULL)) {
 		loff_t size = sb_info->oidmap.mapf->f_dentry->d_inode->i_size;
-		total_used += size / sizeof( reiserfs_oidinterval_d_t );
+		total_used += size / sizeof(reiserfs_oidinterval_d_t);
 	}
 #endif
-	seq_printf(m, "total: \t%i [%i/%i] used: %lu [exact]\n", 
-			mapsize, 
-			mapsize, le16_to_cpu( rs -> s_v1.s_oid_maxsize ),
-			total_used);
+	seq_printf(m, "total: \t%i [%i/%i] used: %lu [exact]\n",
+		   mapsize,
+		   mapsize, le16_to_cpu(rs->s_v1.s_oid_maxsize), total_used);
 	return 0;
 }
 
 static int show_journal(struct seq_file *m, struct super_block *sb)
 {
 	struct reiserfs_sb_info *r = REISERFS_SB(sb);
-	struct reiserfs_super_block *rs = r -> s_rs;
+	struct reiserfs_super_block *rs = r->s_rs;
 	struct journal_params *jp = &rs->s_v1.s_journal;
 	char b[BDEVNAME_SIZE];
-    
-
-	seq_printf(m,	 /* on-disk fields */
- 			"jp_journal_1st_block: \t%i\n"
- 			"jp_journal_dev: \t%s[%x]\n"
- 			"jp_journal_size: \t%i\n"
- 			"jp_journal_trans_max: \t%i\n"
- 			"jp_journal_magic: \t%i\n"
- 			"jp_journal_max_batch: \t%i\n"
- 			"jp_journal_max_commit_age: \t%i\n"
- 			"jp_journal_max_trans_age: \t%i\n"
-			/* incore fields */
-			"j_1st_reserved_block: \t%i\n"	  
-			"j_state: \t%li\n"			
-			"j_trans_id: \t%lu\n"
-			"j_mount_id: \t%lu\n"
-			"j_start: \t%lu\n"
-			"j_len: \t%lu\n"
-			"j_len_alloc: \t%lu\n"
-			"j_wcount: \t%i\n"
-			"j_bcount: \t%lu\n"
-			"j_first_unflushed_offset: \t%lu\n"
-			"j_last_flush_trans_id: \t%lu\n"
-			"j_trans_start_time: \t%li\n"
-			"j_list_bitmap_index: \t%i\n"
-			"j_must_wait: \t%i\n"
-			"j_next_full_flush: \t%i\n"
-			"j_next_async_flush: \t%i\n"
-			"j_cnode_used: \t%i\n"
-			"j_cnode_free: \t%i\n"
-			"\n"
-			/* reiserfs_proc_info_data_t.journal fields */
-			"in_journal: \t%12lu\n"
-			"in_journal_bitmap: \t%12lu\n"
-			"in_journal_reusable: \t%12lu\n"
-			"lock_journal: \t%12lu\n"
-			"lock_journal_wait: \t%12lu\n"
-			"journal_begin: \t%12lu\n"
-			"journal_relock_writers: \t%12lu\n"
-			"journal_relock_wcount: \t%12lu\n"
-			"mark_dirty: \t%12lu\n"
-			"mark_dirty_already: \t%12lu\n"
-			"mark_dirty_notjournal: \t%12lu\n"
-			"restore_prepared: \t%12lu\n"
-			"prepare: \t%12lu\n"
-			"prepare_retry: \t%12lu\n",
-
-                        DJP( jp_journal_1st_block ),
-                        bdevname(SB_JOURNAL(sb)->j_dev_bd, b),
-                        DJP( jp_journal_dev ),
-                        DJP( jp_journal_size ),
-                        DJP( jp_journal_trans_max ),
-                        DJP( jp_journal_magic ),
-                        DJP( jp_journal_max_batch ),
-			SB_JOURNAL(sb)->j_max_commit_age,
-                        DJP( jp_journal_max_trans_age ),
-
-			JF( j_1st_reserved_block ),			
-			JF( j_state ),			
-			JF( j_trans_id ),
-			JF( j_mount_id ),
-			JF( j_start ),
-			JF( j_len ),
-			JF( j_len_alloc ),
-			atomic_read( & r -> s_journal -> j_wcount ),
-			JF( j_bcount ),
-			JF( j_first_unflushed_offset ),
-			JF( j_last_flush_trans_id ),
-			JF( j_trans_start_time ),
-			JF( j_list_bitmap_index ),
-			JF( j_must_wait ),
-			JF( j_next_full_flush ),
-			JF( j_next_async_flush ),
-			JF( j_cnode_used ),
-			JF( j_cnode_free ),
-
-			SFPJ( in_journal ),
-			SFPJ( in_journal_bitmap ),
-			SFPJ( in_journal_reusable ),
-			SFPJ( lock_journal ),
-			SFPJ( lock_journal_wait ),
-			SFPJ( journal_being ),
-			SFPJ( journal_relock_writers ),
-			SFPJ( journal_relock_wcount ),
-			SFPJ( mark_dirty ),
-			SFPJ( mark_dirty_already ),
-			SFPJ( mark_dirty_notjournal ),
-			SFPJ( restore_prepared ),
-			SFPJ( prepare ),
-			SFPJ( prepare_retry )
-		);
+
+	seq_printf(m,		/* on-disk fields */
+		   "jp_journal_1st_block: \t%i\n"
+		   "jp_journal_dev: \t%s[%x]\n"
+		   "jp_journal_size: \t%i\n"
+		   "jp_journal_trans_max: \t%i\n"
+		   "jp_journal_magic: \t%i\n"
+		   "jp_journal_max_batch: \t%i\n"
+		   "jp_journal_max_commit_age: \t%i\n"
+		   "jp_journal_max_trans_age: \t%i\n"
+		   /* incore fields */
+		   "j_1st_reserved_block: \t%i\n"
+		   "j_state: \t%li\n"
+		   "j_trans_id: \t%lu\n"
+		   "j_mount_id: \t%lu\n"
+		   "j_start: \t%lu\n"
+		   "j_len: \t%lu\n"
+		   "j_len_alloc: \t%lu\n"
+		   "j_wcount: \t%i\n"
+		   "j_bcount: \t%lu\n"
+		   "j_first_unflushed_offset: \t%lu\n"
+		   "j_last_flush_trans_id: \t%lu\n"
+		   "j_trans_start_time: \t%li\n"
+		   "j_list_bitmap_index: \t%i\n"
+		   "j_must_wait: \t%i\n"
+		   "j_next_full_flush: \t%i\n"
+		   "j_next_async_flush: \t%i\n"
+		   "j_cnode_used: \t%i\n" "j_cnode_free: \t%i\n" "\n"
+		   /* reiserfs_proc_info_data_t.journal fields */
+		   "in_journal: \t%12lu\n"
+		   "in_journal_bitmap: \t%12lu\n"
+		   "in_journal_reusable: \t%12lu\n"
+		   "lock_journal: \t%12lu\n"
+		   "lock_journal_wait: \t%12lu\n"
+		   "journal_begin: \t%12lu\n"
+		   "journal_relock_writers: \t%12lu\n"
+		   "journal_relock_wcount: \t%12lu\n"
+		   "mark_dirty: \t%12lu\n"
+		   "mark_dirty_already: \t%12lu\n"
+		   "mark_dirty_notjournal: \t%12lu\n"
+		   "restore_prepared: \t%12lu\n"
+		   "prepare: \t%12lu\n"
+		   "prepare_retry: \t%12lu\n",
+		   DJP(jp_journal_1st_block),
+		   bdevname(SB_JOURNAL(sb)->j_dev_bd, b),
+		   DJP(jp_journal_dev),
+		   DJP(jp_journal_size),
+		   DJP(jp_journal_trans_max),
+		   DJP(jp_journal_magic),
+		   DJP(jp_journal_max_batch),
+		   SB_JOURNAL(sb)->j_max_commit_age,
+		   DJP(jp_journal_max_trans_age),
+		   JF(j_1st_reserved_block),
+		   JF(j_state),
+		   JF(j_trans_id),
+		   JF(j_mount_id),
+		   JF(j_start),
+		   JF(j_len),
+		   JF(j_len_alloc),
+		   atomic_read(&r->s_journal->j_wcount),
+		   JF(j_bcount),
+		   JF(j_first_unflushed_offset),
+		   JF(j_last_flush_trans_id),
+		   JF(j_trans_start_time),
+		   JF(j_list_bitmap_index),
+		   JF(j_must_wait),
+		   JF(j_next_full_flush),
+		   JF(j_next_async_flush),
+		   JF(j_cnode_used),
+		   JF(j_cnode_free),
+		   SFPJ(in_journal),
+		   SFPJ(in_journal_bitmap),
+		   SFPJ(in_journal_reusable),
+		   SFPJ(lock_journal),
+		   SFPJ(lock_journal_wait),
+		   SFPJ(journal_being),
+		   SFPJ(journal_relock_writers),
+		   SFPJ(journal_relock_wcount),
+		   SFPJ(mark_dirty),
+		   SFPJ(mark_dirty_already),
+		   SFPJ(mark_dirty_notjournal),
+		   SFPJ(restore_prepared), SFPJ(prepare), SFPJ(prepare_retry)
+	    );
 	return 0;
 }
 
@@ -450,7 +410,7 @@ static int set_sb(struct super_block *sb, void *data)
 	return -ENOENT;
 }
 
-static void *r_start(struct seq_file *m, loff_t *pos)
+static void *r_start(struct seq_file *m, loff_t * pos)
 {
 	struct proc_dir_entry *de = m->private;
 	struct super_block *s = de->parent->data;
@@ -472,7 +432,7 @@ static void *r_start(struct seq_file *m, loff_t *pos)
 	return s;
 }
 
-static void *r_next(struct seq_file *m, void *v, loff_t *pos)
+static void *r_next(struct seq_file *m, void *v, loff_t * pos)
 {
 	++*pos;
 	if (v)
@@ -489,7 +449,7 @@ static void r_stop(struct seq_file *m, void *v)
 static int r_show(struct seq_file *m, void *v)
 {
 	struct proc_dir_entry *de = m->private;
-	int (*show)(struct seq_file *, struct super_block *) = de->data;
+	int (*show) (struct seq_file *, struct super_block *) = de->data;
 	return show(m, v);
 }
 
@@ -512,17 +472,17 @@ static int r_open(struct inode *inode, struct file *file)
 }
 
 static struct file_operations r_file_operations = {
-	.open		= r_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= seq_release,
+	.open = r_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
 };
 
 static struct proc_dir_entry *proc_info_root = NULL;
 static const char proc_info_root_name[] = "fs/reiserfs";
 
 static void add_file(struct super_block *sb, char *name,
-	int (*func)(struct seq_file *, struct super_block *))
+		     int (*func) (struct seq_file *, struct super_block *))
 {
 	struct proc_dir_entry *de;
 	de = create_proc_entry(name, 0, REISERFS_SB(sb)->procdir);
@@ -532,11 +492,12 @@ static void add_file(struct super_block *sb, char *name,
 	}
 }
 
-int reiserfs_proc_info_init( struct super_block *sb )
+int reiserfs_proc_info_init(struct super_block *sb)
 {
-	spin_lock_init( & __PINFO( sb ).lock );
-	REISERFS_SB(sb)->procdir = proc_mkdir(reiserfs_bdevname (sb), proc_info_root);
-	if( REISERFS_SB(sb)->procdir ) {
+	spin_lock_init(&__PINFO(sb).lock);
+	REISERFS_SB(sb)->procdir =
+	    proc_mkdir(reiserfs_bdevname(sb), proc_info_root);
+	if (REISERFS_SB(sb)->procdir) {
 		REISERFS_SB(sb)->procdir->owner = THIS_MODULE;
 		REISERFS_SB(sb)->procdir->data = sb;
 		add_file(sb, "version", show_version);
@@ -549,11 +510,11 @@ int reiserfs_proc_info_init( struct super_block *sb )
 		return 0;
 	}
 	reiserfs_warning(sb, "reiserfs: cannot create /proc/%s/%s",
-			 proc_info_root_name, reiserfs_bdevname (sb) );
+			 proc_info_root_name, reiserfs_bdevname(sb));
 	return 1;
 }
 
-int reiserfs_proc_info_done( struct super_block *sb )
+int reiserfs_proc_info_done(struct super_block *sb)
 {
 	struct proc_dir_entry *de = REISERFS_SB(sb)->procdir;
 	if (de) {
@@ -565,48 +526,48 @@ int reiserfs_proc_info_done( struct super_block *sb )
 		remove_proc_entry("super", de);
 		remove_proc_entry("version", de);
 	}
-	spin_lock( & __PINFO( sb ).lock );
-	__PINFO( sb ).exiting = 1;
-	spin_unlock( & __PINFO( sb ).lock );
-	if ( proc_info_root ) {
-		remove_proc_entry( reiserfs_bdevname (sb), proc_info_root );
+	spin_lock(&__PINFO(sb).lock);
+	__PINFO(sb).exiting = 1;
+	spin_unlock(&__PINFO(sb).lock);
+	if (proc_info_root) {
+		remove_proc_entry(reiserfs_bdevname(sb), proc_info_root);
 		REISERFS_SB(sb)->procdir = NULL;
 	}
 	return 0;
 }
 
-struct proc_dir_entry *reiserfs_proc_register_global( char *name, 
-						      read_proc_t *func )
+struct proc_dir_entry *reiserfs_proc_register_global(char *name,
+						     read_proc_t * func)
 {
-	return ( proc_info_root ) ? create_proc_read_entry( name, 0, 
-							    proc_info_root, 
-							    func, NULL ) : NULL;
+	return (proc_info_root) ? create_proc_read_entry(name, 0,
+							 proc_info_root,
+							 func, NULL) : NULL;
 }
 
-void reiserfs_proc_unregister_global( const char *name )
+void reiserfs_proc_unregister_global(const char *name)
 {
-	remove_proc_entry( name, proc_info_root );
+	remove_proc_entry(name, proc_info_root);
 }
 
-int reiserfs_proc_info_global_init( void )
+int reiserfs_proc_info_global_init(void)
 {
-	if( proc_info_root == NULL ) {
+	if (proc_info_root == NULL) {
 		proc_info_root = proc_mkdir(proc_info_root_name, NULL);
-		if( proc_info_root ) {
-			proc_info_root -> owner = THIS_MODULE;
+		if (proc_info_root) {
+			proc_info_root->owner = THIS_MODULE;
 		} else {
-			reiserfs_warning (NULL,
-					  "reiserfs: cannot create /proc/%s",
-					  proc_info_root_name );
+			reiserfs_warning(NULL,
+					 "reiserfs: cannot create /proc/%s",
+					 proc_info_root_name);
 			return 1;
 		}
 	}
 	return 0;
 }
 
-int reiserfs_proc_info_global_done( void )
+int reiserfs_proc_info_global_done(void)
 {
-	if ( proc_info_root != NULL ) {
+	if (proc_info_root != NULL) {
 		proc_info_root = NULL;
 		remove_proc_entry(proc_info_root_name, NULL);
 	}
@@ -616,22 +577,40 @@ int reiserfs_proc_info_global_done( void )
 /* REISERFS_PROC_INFO */
 #else
 
-int reiserfs_proc_info_init( struct super_block *sb ) { return 0; }
-int reiserfs_proc_info_done( struct super_block *sb ) { return 0; }
+int reiserfs_proc_info_init(struct super_block *sb)
+{
+	return 0;
+}
+int reiserfs_proc_info_done(struct super_block *sb)
+{
+	return 0;
+}
 
-struct proc_dir_entry *reiserfs_proc_register_global( char *name, 
-						      read_proc_t *func )
-{ return NULL; }
+struct proc_dir_entry *reiserfs_proc_register_global(char *name,
+						     read_proc_t * func)
+{
+	return NULL;
+}
 
-void reiserfs_proc_unregister_global( const char *name ) {;}
+void reiserfs_proc_unregister_global(const char *name)
+{;
+}
 
-int reiserfs_proc_info_global_init( void ) { return 0; }
-int reiserfs_proc_info_global_done( void ) { return 0; }
+int reiserfs_proc_info_global_init(void)
+{
+	return 0;
+}
+int reiserfs_proc_info_global_done(void)
+{
+	return 0;
+}
 
-int reiserfs_global_version_in_proc( char *buffer, char **start, 
-				     off_t offset,
-				     int count, int *eof, void *data )
-{ return 0; }
+int reiserfs_global_version_in_proc(char *buffer, char **start,
+				    off_t offset,
+				    int count, int *eof, void *data)
+{
+	return 0;
+}
 
 /* REISERFS_PROC_INFO */
 #endif

commit 3e8962be915bacc1d70e4849a075041838d60a3f
Author: Al Viro <viro@www.linux.org.uk>
Date:   Sun May 1 08:59:18 2005 -0700

    [PATCH] reiserfs endianness: annotate little-endian objects
    
    little-endian objects annotated as such; again, obviously no changes of
    resulting code, we only replace __u16 with __le16, etc.  in relevant places.
    
    Signed-off-by: Al Viro <viro@parcelfarce.linux.theplanet.co.uk>
    Cc: <reiserfs-dev@namesys.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
index f4ea81ae0e0f..e242ebc7f6f6 100644
--- a/fs/reiserfs/procfs.c
+++ b/fs/reiserfs/procfs.c
@@ -73,8 +73,8 @@ int reiserfs_global_version_in_proc( char *buffer, char **start, off_t offset,
 #define DFL( x ) D4C( rs -> s_v1.x )
 
 #define objectid_map( s, rs ) (old_format_only (s) ?				\
-                         (__u32 *)((struct reiserfs_super_block_v1 *)rs + 1) :	\
-			 (__u32 *)(rs + 1))
+                         (__le32 *)((struct reiserfs_super_block_v1 *)rs + 1) :	\
+			 (__le32 *)(rs + 1))
 #define MAP( i ) D4C( objectid_map( sb, rs )[ i ] )
 
 #define DJF( x ) le32_to_cpu( rs -> x )

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/fs/reiserfs/procfs.c b/fs/reiserfs/procfs.c
new file mode 100644
index 000000000000..f4ea81ae0e0f
--- /dev/null
+++ b/fs/reiserfs/procfs.c
@@ -0,0 +1,664 @@
+/* -*- linux-c -*- */
+
+/* fs/reiserfs/procfs.c */
+
+/*
+ * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ */
+
+/* proc info support a la one created by Sizif@Botik.RU for PGC */
+
+/* $Id: procfs.c,v 1.1.8.2 2001/07/15 17:08:42 god Exp $ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/time.h>
+#include <linux/seq_file.h>
+#include <asm/uaccess.h>
+#include <linux/reiserfs_fs.h>
+#include <linux/reiserfs_fs_sb.h>
+#include <linux/smp_lock.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+
+#if defined( REISERFS_PROC_INFO )
+
+/*
+ * LOCKING:
+ *
+ * We rely on new Alexander Viro's super-block locking.
+ *
+ */
+
+static int show_version(struct seq_file *m, struct super_block *sb)
+{
+	char *format;
+    
+	if ( REISERFS_SB(sb)->s_properties & (1 << REISERFS_3_6) ) {
+		format = "3.6";
+	} else if ( REISERFS_SB(sb)->s_properties & (1 << REISERFS_3_5) ) {
+		format = "3.5";
+	} else {
+		format = "unknown";
+	}
+
+	seq_printf(m, "%s format\twith checks %s\n",
+			format,
+#if defined( CONFIG_REISERFS_CHECK )
+			"on"
+#else
+			"off"
+#endif
+		);
+	return 0;
+}
+
+int reiserfs_global_version_in_proc( char *buffer, char **start, off_t offset,
+				     int count, int *eof, void *data )
+{
+	*start = buffer;
+	*eof = 1;
+	return 0;
+}
+
+#define SF( x ) ( r -> x )
+#define SFP( x ) SF( s_proc_info_data.x )
+#define SFPL( x ) SFP( x[ level ] )
+#define SFPF( x ) SFP( scan_bitmap.x )
+#define SFPJ( x ) SFP( journal.x )
+
+#define D2C( x ) le16_to_cpu( x )
+#define D4C( x ) le32_to_cpu( x )
+#define DF( x ) D2C( rs -> s_v1.x )
+#define DFL( x ) D4C( rs -> s_v1.x )
+
+#define objectid_map( s, rs ) (old_format_only (s) ?				\
+                         (__u32 *)((struct reiserfs_super_block_v1 *)rs + 1) :	\
+			 (__u32 *)(rs + 1))
+#define MAP( i ) D4C( objectid_map( sb, rs )[ i ] )
+
+#define DJF( x ) le32_to_cpu( rs -> x )
+#define DJV( x ) le32_to_cpu( s_v1 -> x )
+#define DJP( x ) le32_to_cpu( jp -> x ) 
+#define JF( x ) ( r -> s_journal -> x )
+
+static int show_super(struct seq_file *m, struct super_block *sb)
+{
+	struct reiserfs_sb_info *r = REISERFS_SB(sb);
+    
+	seq_printf(m,	"state: \t%s\n"
+			"mount options: \t%s%s%s%s%s%s%s%s%s%s%s\n"
+			"gen. counter: \t%i\n"
+			"s_kmallocs: \t%i\n"
+			"s_disk_reads: \t%i\n"
+			"s_disk_writes: \t%i\n"
+			"s_fix_nodes: \t%i\n"
+			"s_do_balance: \t%i\n"
+			"s_unneeded_left_neighbor: \t%i\n"
+			"s_good_search_by_key_reada: \t%i\n"
+			"s_bmaps: \t%i\n"
+			"s_bmaps_without_search: \t%i\n"
+			"s_direct2indirect: \t%i\n"
+			"s_indirect2direct: \t%i\n"
+			"\n"
+			"max_hash_collisions: \t%i\n"
+
+			"breads: \t%lu\n"
+			"bread_misses: \t%lu\n"
+
+			"search_by_key: \t%lu\n"
+			"search_by_key_fs_changed: \t%lu\n"
+			"search_by_key_restarted: \t%lu\n"
+			
+			"insert_item_restarted: \t%lu\n"
+			"paste_into_item_restarted: \t%lu\n"
+			"cut_from_item_restarted: \t%lu\n"
+			"delete_solid_item_restarted: \t%lu\n"
+			"delete_item_restarted: \t%lu\n"
+
+			"leaked_oid: \t%lu\n"
+			"leaves_removable: \t%lu\n",
+
+			SF( s_mount_state ) == REISERFS_VALID_FS ?
+			"REISERFS_VALID_FS" : "REISERFS_ERROR_FS",
+			reiserfs_r5_hash( sb ) ? "FORCE_R5 " : "",
+			reiserfs_rupasov_hash( sb ) ? "FORCE_RUPASOV " : "",
+			reiserfs_tea_hash( sb ) ? "FORCE_TEA " : "",
+			reiserfs_hash_detect( sb ) ? "DETECT_HASH " : "",
+			reiserfs_no_border( sb ) ? "NO_BORDER " : "BORDER ",
+			reiserfs_no_unhashed_relocation( sb ) ? "NO_UNHASHED_RELOCATION " : "",
+			reiserfs_hashed_relocation( sb ) ? "UNHASHED_RELOCATION " : "",
+			reiserfs_test4( sb ) ? "TEST4 " : "",
+			have_large_tails( sb ) ? "TAILS " : have_small_tails(sb)?"SMALL_TAILS ":"NO_TAILS ",
+			replay_only( sb ) ? "REPLAY_ONLY " : "",
+			convert_reiserfs( sb ) ? "CONV " : "",
+
+			atomic_read( &r -> s_generation_counter ),
+			SF( s_kmallocs ),
+			SF( s_disk_reads ),
+			SF( s_disk_writes ),
+			SF( s_fix_nodes ),
+			SF( s_do_balance ),
+			SF( s_unneeded_left_neighbor ),
+			SF( s_good_search_by_key_reada ),
+			SF( s_bmaps ),
+			SF( s_bmaps_without_search ),
+			SF( s_direct2indirect ),
+			SF( s_indirect2direct ),
+			SFP( max_hash_collisions ),
+			SFP( breads ),
+			SFP( bread_miss ),
+			SFP( search_by_key ),
+			SFP( search_by_key_fs_changed ),
+			SFP( search_by_key_restarted ),
+
+			SFP( insert_item_restarted ),
+			SFP( paste_into_item_restarted ),
+			SFP( cut_from_item_restarted ),
+			SFP( delete_solid_item_restarted ),
+			SFP( delete_item_restarted ),
+
+			SFP( leaked_oid ),
+			SFP( leaves_removable ) );
+
+	return 0;
+}
+
+static int show_per_level(struct seq_file *m, struct super_block *sb)
+{
+	struct reiserfs_sb_info *r = REISERFS_SB(sb);
+	int level;
+
+	seq_printf(m,	"level\t"
+			"     balances"
+			" [sbk:  reads"
+			"   fs_changed"
+			"   restarted]"
+			"   free space"
+			"        items"
+			"   can_remove"
+			"         lnum"
+			"         rnum"
+			"       lbytes"
+			"       rbytes"
+			"     get_neig"
+			" get_neig_res"
+			"  need_l_neig"
+			"  need_r_neig"
+			"\n"
+			
+		);
+
+	for( level = 0 ; level < MAX_HEIGHT ; ++ level ) {
+		seq_printf(m,	"%i\t"
+				" %12lu"
+				" %12lu"
+				" %12lu"
+				" %12lu"
+				" %12lu"
+				" %12lu"
+				" %12lu"
+				" %12li"
+				" %12li"
+				" %12li"
+				" %12li"
+				" %12lu"
+				" %12lu"
+				" %12lu"
+				" %12lu"
+				"\n",
+				level, 
+				SFPL( balance_at ),
+				SFPL( sbk_read_at ),
+				SFPL( sbk_fs_changed ),
+				SFPL( sbk_restarted ),
+				SFPL( free_at ),
+				SFPL( items_at ),
+				SFPL( can_node_be_removed ),
+				SFPL( lnum ),
+				SFPL( rnum ),
+				SFPL( lbytes ),
+				SFPL( rbytes ),
+				SFPL( get_neighbors ),
+				SFPL( get_neighbors_restart ),
+				SFPL( need_l_neighbor ),
+				SFPL( need_r_neighbor )
+			);
+	}
+	return 0;
+}
+
+static int show_bitmap(struct seq_file *m, struct super_block *sb)
+{
+	struct reiserfs_sb_info *r = REISERFS_SB(sb);
+
+	seq_printf(m,	"free_block: %lu\n"
+			"  scan_bitmap:"
+			"          wait"
+			"          bmap"
+			"         retry"
+			"        stolen"
+			"  journal_hint"
+			"journal_nohint"
+			"\n"
+			" %14lu"
+			" %14lu"
+			" %14lu"
+			" %14lu"
+			" %14lu"
+			" %14lu"
+			" %14lu"
+			"\n",
+			SFP( free_block ),
+			SFPF( call ), 
+			SFPF( wait ), 
+			SFPF( bmap ),
+			SFPF( retry ),
+			SFPF( stolen ),
+			SFPF( in_journal_hint ),
+			SFPF( in_journal_nohint ) );
+
+	return 0;
+}
+
+static int show_on_disk_super(struct seq_file *m, struct super_block *sb)
+{
+	struct reiserfs_sb_info *sb_info = REISERFS_SB(sb);
+	struct reiserfs_super_block *rs = sb_info -> s_rs;
+	int hash_code = DFL( s_hash_function_code );
+	__u32 flags = DJF( s_flags );
+
+	seq_printf(m,	"block_count: \t%i\n"
+			"free_blocks: \t%i\n"
+			"root_block: \t%i\n"
+			"blocksize: \t%i\n"
+			"oid_maxsize: \t%i\n"
+			"oid_cursize: \t%i\n"
+			"umount_state: \t%i\n"
+			"magic: \t%10.10s\n"
+			"fs_state: \t%i\n"
+			"hash: \t%s\n"
+			"tree_height: \t%i\n"
+			"bmap_nr: \t%i\n"
+			"version: \t%i\n"
+			"flags: \t%x[%s]\n"
+			"reserved_for_journal: \t%i\n",
+
+			DFL( s_block_count ),
+			DFL( s_free_blocks ),
+			DFL( s_root_block ),
+			DF( s_blocksize ),
+			DF( s_oid_maxsize ),
+			DF( s_oid_cursize ),
+			DF( s_umount_state ),
+			rs -> s_v1.s_magic,
+			DF( s_fs_state ),
+			hash_code == TEA_HASH ? "tea" :
+			( hash_code == YURA_HASH ) ? "rupasov" :
+			( hash_code == R5_HASH ) ? "r5" :
+			( hash_code == UNSET_HASH ) ? "unset" : "unknown",
+			DF( s_tree_height ),
+			DF( s_bmap_nr ),
+			DF( s_version ),
+			flags,
+			( flags & reiserfs_attrs_cleared )
+			? "attrs_cleared" : "",
+			DF (s_reserved_for_journal));
+
+	return 0;
+}
+
+static int show_oidmap(struct seq_file *m, struct super_block *sb)
+{
+	struct reiserfs_sb_info *sb_info = REISERFS_SB(sb);
+	struct reiserfs_super_block *rs = sb_info -> s_rs;
+	unsigned int mapsize = le16_to_cpu( rs -> s_v1.s_oid_cursize );
+	unsigned long total_used = 0;
+	int i;
+
+	for( i = 0 ; i < mapsize ; ++i ) {
+		__u32 right;
+
+		right = ( i == mapsize - 1 ) ? MAX_KEY_OBJECTID : MAP( i + 1 );
+		seq_printf(m, "%s: [ %x .. %x )\n",
+				( i & 1 ) ? "free" : "used", MAP( i ), right );
+		if( ! ( i & 1 ) ) {
+			total_used += right - MAP( i );
+		}
+	}
+#if defined( REISERFS_USE_OIDMAPF )
+	if( sb_info -> oidmap.use_file && ( sb_info -> oidmap.mapf != NULL ) ) {
+		loff_t size = sb_info->oidmap.mapf->f_dentry->d_inode->i_size;
+		total_used += size / sizeof( reiserfs_oidinterval_d_t );
+	}
+#endif
+	seq_printf(m, "total: \t%i [%i/%i] used: %lu [exact]\n", 
+			mapsize, 
+			mapsize, le16_to_cpu( rs -> s_v1.s_oid_maxsize ),
+			total_used);
+	return 0;
+}
+
+static int show_journal(struct seq_file *m, struct super_block *sb)
+{
+	struct reiserfs_sb_info *r = REISERFS_SB(sb);
+	struct reiserfs_super_block *rs = r -> s_rs;
+	struct journal_params *jp = &rs->s_v1.s_journal;
+	char b[BDEVNAME_SIZE];
+    
+
+	seq_printf(m,	 /* on-disk fields */
+ 			"jp_journal_1st_block: \t%i\n"
+ 			"jp_journal_dev: \t%s[%x]\n"
+ 			"jp_journal_size: \t%i\n"
+ 			"jp_journal_trans_max: \t%i\n"
+ 			"jp_journal_magic: \t%i\n"
+ 			"jp_journal_max_batch: \t%i\n"
+ 			"jp_journal_max_commit_age: \t%i\n"
+ 			"jp_journal_max_trans_age: \t%i\n"
+			/* incore fields */
+			"j_1st_reserved_block: \t%i\n"	  
+			"j_state: \t%li\n"			
+			"j_trans_id: \t%lu\n"
+			"j_mount_id: \t%lu\n"
+			"j_start: \t%lu\n"
+			"j_len: \t%lu\n"
+			"j_len_alloc: \t%lu\n"
+			"j_wcount: \t%i\n"
+			"j_bcount: \t%lu\n"
+			"j_first_unflushed_offset: \t%lu\n"
+			"j_last_flush_trans_id: \t%lu\n"
+			"j_trans_start_time: \t%li\n"
+			"j_list_bitmap_index: \t%i\n"
+			"j_must_wait: \t%i\n"
+			"j_next_full_flush: \t%i\n"
+			"j_next_async_flush: \t%i\n"
+			"j_cnode_used: \t%i\n"
+			"j_cnode_free: \t%i\n"
+			"\n"
+			/* reiserfs_proc_info_data_t.journal fields */
+			"in_journal: \t%12lu\n"
+			"in_journal_bitmap: \t%12lu\n"
+			"in_journal_reusable: \t%12lu\n"
+			"lock_journal: \t%12lu\n"
+			"lock_journal_wait: \t%12lu\n"
+			"journal_begin: \t%12lu\n"
+			"journal_relock_writers: \t%12lu\n"
+			"journal_relock_wcount: \t%12lu\n"
+			"mark_dirty: \t%12lu\n"
+			"mark_dirty_already: \t%12lu\n"
+			"mark_dirty_notjournal: \t%12lu\n"
+			"restore_prepared: \t%12lu\n"
+			"prepare: \t%12lu\n"
+			"prepare_retry: \t%12lu\n",
+
+                        DJP( jp_journal_1st_block ),
+                        bdevname(SB_JOURNAL(sb)->j_dev_bd, b),
+                        DJP( jp_journal_dev ),
+                        DJP( jp_journal_size ),
+                        DJP( jp_journal_trans_max ),
+                        DJP( jp_journal_magic ),
+                        DJP( jp_journal_max_batch ),
+			SB_JOURNAL(sb)->j_max_commit_age,
+                        DJP( jp_journal_max_trans_age ),
+
+			JF( j_1st_reserved_block ),			
+			JF( j_state ),			
+			JF( j_trans_id ),
+			JF( j_mount_id ),
+			JF( j_start ),
+			JF( j_len ),
+			JF( j_len_alloc ),
+			atomic_read( & r -> s_journal -> j_wcount ),
+			JF( j_bcount ),
+			JF( j_first_unflushed_offset ),
+			JF( j_last_flush_trans_id ),
+			JF( j_trans_start_time ),
+			JF( j_list_bitmap_index ),
+			JF( j_must_wait ),
+			JF( j_next_full_flush ),
+			JF( j_next_async_flush ),
+			JF( j_cnode_used ),
+			JF( j_cnode_free ),
+
+			SFPJ( in_journal ),
+			SFPJ( in_journal_bitmap ),
+			SFPJ( in_journal_reusable ),
+			SFPJ( lock_journal ),
+			SFPJ( lock_journal_wait ),
+			SFPJ( journal_being ),
+			SFPJ( journal_relock_writers ),
+			SFPJ( journal_relock_wcount ),
+			SFPJ( mark_dirty ),
+			SFPJ( mark_dirty_already ),
+			SFPJ( mark_dirty_notjournal ),
+			SFPJ( restore_prepared ),
+			SFPJ( prepare ),
+			SFPJ( prepare_retry )
+		);
+	return 0;
+}
+
+/* iterator */
+static int test_sb(struct super_block *sb, void *data)
+{
+	return data == sb;
+}
+
+static int set_sb(struct super_block *sb, void *data)
+{
+	return -ENOENT;
+}
+
+static void *r_start(struct seq_file *m, loff_t *pos)
+{
+	struct proc_dir_entry *de = m->private;
+	struct super_block *s = de->parent->data;
+	loff_t l = *pos;
+
+	if (l)
+		return NULL;
+
+	if (IS_ERR(sget(&reiserfs_fs_type, test_sb, set_sb, s)))
+		return NULL;
+
+	up_write(&s->s_umount);
+
+	if (de->deleted) {
+		deactivate_super(s);
+		return NULL;
+	}
+
+	return s;
+}
+
+static void *r_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	++*pos;
+	if (v)
+		deactivate_super(v);
+	return NULL;
+}
+
+static void r_stop(struct seq_file *m, void *v)
+{
+	if (v)
+		deactivate_super(v);
+}
+
+static int r_show(struct seq_file *m, void *v)
+{
+	struct proc_dir_entry *de = m->private;
+	int (*show)(struct seq_file *, struct super_block *) = de->data;
+	return show(m, v);
+}
+
+static struct seq_operations r_ops = {
+	.start = r_start,
+	.next = r_next,
+	.stop = r_stop,
+	.show = r_show,
+};
+
+static int r_open(struct inode *inode, struct file *file)
+{
+	int ret = seq_open(file, &r_ops);
+
+	if (!ret) {
+		struct seq_file *m = file->private_data;
+		m->private = PDE(inode);
+	}
+	return ret;
+}
+
+static struct file_operations r_file_operations = {
+	.open		= r_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+static struct proc_dir_entry *proc_info_root = NULL;
+static const char proc_info_root_name[] = "fs/reiserfs";
+
+static void add_file(struct super_block *sb, char *name,
+	int (*func)(struct seq_file *, struct super_block *))
+{
+	struct proc_dir_entry *de;
+	de = create_proc_entry(name, 0, REISERFS_SB(sb)->procdir);
+	if (de) {
+		de->data = func;
+		de->proc_fops = &r_file_operations;
+	}
+}
+
+int reiserfs_proc_info_init( struct super_block *sb )
+{
+	spin_lock_init( & __PINFO( sb ).lock );
+	REISERFS_SB(sb)->procdir = proc_mkdir(reiserfs_bdevname (sb), proc_info_root);
+	if( REISERFS_SB(sb)->procdir ) {
+		REISERFS_SB(sb)->procdir->owner = THIS_MODULE;
+		REISERFS_SB(sb)->procdir->data = sb;
+		add_file(sb, "version", show_version);
+		add_file(sb, "super", show_super);
+		add_file(sb, "per-level", show_per_level);
+		add_file(sb, "bitmap", show_bitmap);
+		add_file(sb, "on-disk-super", show_on_disk_super);
+		add_file(sb, "oidmap", show_oidmap);
+		add_file(sb, "journal", show_journal);
+		return 0;
+	}
+	reiserfs_warning(sb, "reiserfs: cannot create /proc/%s/%s",
+			 proc_info_root_name, reiserfs_bdevname (sb) );
+	return 1;
+}
+
+int reiserfs_proc_info_done( struct super_block *sb )
+{
+	struct proc_dir_entry *de = REISERFS_SB(sb)->procdir;
+	if (de) {
+		remove_proc_entry("journal", de);
+		remove_proc_entry("oidmap", de);
+		remove_proc_entry("on-disk-super", de);
+		remove_proc_entry("bitmap", de);
+		remove_proc_entry("per-level", de);
+		remove_proc_entry("super", de);
+		remove_proc_entry("version", de);
+	}
+	spin_lock( & __PINFO( sb ).lock );
+	__PINFO( sb ).exiting = 1;
+	spin_unlock( & __PINFO( sb ).lock );
+	if ( proc_info_root ) {
+		remove_proc_entry( reiserfs_bdevname (sb), proc_info_root );
+		REISERFS_SB(sb)->procdir = NULL;
+	}
+	return 0;
+}
+
+struct proc_dir_entry *reiserfs_proc_register_global( char *name, 
+						      read_proc_t *func )
+{
+	return ( proc_info_root ) ? create_proc_read_entry( name, 0, 
+							    proc_info_root, 
+							    func, NULL ) : NULL;
+}
+
+void reiserfs_proc_unregister_global( const char *name )
+{
+	remove_proc_entry( name, proc_info_root );
+}
+
+int reiserfs_proc_info_global_init( void )
+{
+	if( proc_info_root == NULL ) {
+		proc_info_root = proc_mkdir(proc_info_root_name, NULL);
+		if( proc_info_root ) {
+			proc_info_root -> owner = THIS_MODULE;
+		} else {
+			reiserfs_warning (NULL,
+					  "reiserfs: cannot create /proc/%s",
+					  proc_info_root_name );
+			return 1;
+		}
+	}
+	return 0;
+}
+
+int reiserfs_proc_info_global_done( void )
+{
+	if ( proc_info_root != NULL ) {
+		proc_info_root = NULL;
+		remove_proc_entry(proc_info_root_name, NULL);
+	}
+	return 0;
+}
+
+/* REISERFS_PROC_INFO */
+#else
+
+int reiserfs_proc_info_init( struct super_block *sb ) { return 0; }
+int reiserfs_proc_info_done( struct super_block *sb ) { return 0; }
+
+struct proc_dir_entry *reiserfs_proc_register_global( char *name, 
+						      read_proc_t *func )
+{ return NULL; }
+
+void reiserfs_proc_unregister_global( const char *name ) {;}
+
+int reiserfs_proc_info_global_init( void ) { return 0; }
+int reiserfs_proc_info_global_done( void ) { return 0; }
+
+int reiserfs_global_version_in_proc( char *buffer, char **start, 
+				     off_t offset,
+				     int count, int *eof, void *data )
+{ return 0; }
+
+/* REISERFS_PROC_INFO */
+#endif
+
+/*
+ * $Log: procfs.c,v $
+ * Revision 1.1.8.2  2001/07/15 17:08:42  god
+ *  . use get_super() in procfs.c
+ *  . remove remove_save_link() from reiserfs_do_truncate()
+ *
+ * I accept terms and conditions stated in the Legal Agreement
+ * (available at http://www.namesys.com/legalese.html)
+ *
+ * Revision 1.1.8.1  2001/07/11 16:48:50  god
+ * proc info support
+ *
+ * I accept terms and conditions stated in the Legal Agreement
+ * (available at http://www.namesys.com/legalese.html)
+ *
+ */
+
+/* 
+ * Make Linus happy.
+ * Local variables:
+ * c-indentation-style: "K&R"
+ * mode-name: "LC"
+ * c-basic-offset: 8
+ * tab-width: 8
+ * End:
+ */
