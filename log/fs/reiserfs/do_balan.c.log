commit 5404e7e0ac0cd03b83dd2476155254ee1e50529f
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Apr 6 20:11:46 2020 -0700

    reiserfs: clean up several indentation issues
    
    There are several places where code is indented incorrectly. Fix these.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Link: http://lkml.kernel.org/r/20200325135018.113431-1-colin.king@canonical.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 4075e41408b4..5129efc6f2e6 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -842,7 +842,7 @@ static void balance_leaf_paste_right_whole(struct tree_balance *tb,
 	struct item_head *pasted;
 	struct buffer_info bi;
 
-							buffer_info_init_right(tb, &bi);
+	buffer_info_init_right(tb, &bi);
 	leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
 
 	/* append item in R[0] */

commit b25bab17221ba366ffdff9dd62945932aac7dc98
Author: Jason Yan <yanaijie@huawei.com>
Date:   Wed Sep 25 16:47:22 2019 -0700

    fs/reiserfs/do_balan.c: remove set but not used variable
    
    Fix the following gcc warning:
    
    fs/reiserfs/do_balan.c: In function balance_leaf_insert_right:
    fs/reiserfs/do_balan.c:629:6: warning: variable ret set but not used
    [-Wunused-but-set-variable]
    
    Link: http://lkml.kernel.org/r/20190827032932.46622-2-yanaijie@huawei.com
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    Cc: zhengbin <zhengbin13@huawei.com>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index ffb6d7f0da94..4075e41408b4 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -626,7 +626,6 @@ static void balance_leaf_insert_right(struct tree_balance *tb,
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	int n = B_NR_ITEMS(tbS0);
 	struct buffer_info bi;
-	int ret;
 
 	/* new item or part of it doesn't fall into R[0] */
 	if (n - tb->rnum[0] >= tb->item_pos) {
@@ -690,7 +689,7 @@ static void balance_leaf_insert_right(struct tree_balance *tb,
 		/* whole new item falls into R[0] */
 
 		/* Shift rnum[0]-1 items to R[0] */
-		ret = leaf_shift_right(tb, tb->rnum[0] - 1, tb->rbytes);
+		leaf_shift_right(tb, tb->rnum[0] - 1, tb->rbytes);
 
 		/* Insert new item into R[0] */
 		buffer_info_init_right(tb, &bi);

commit da5184c2ab10b57bf9b58f818405aa0054a2f829
Author: zhengbin <zhengbin13@huawei.com>
Date:   Wed Sep 25 16:47:16 2019 -0700

    fs/reiserfs/do_balan.c: remove set but not used variables
    
    fs/reiserfs/do_balan.c: In function balance_leaf_when_delete:
    fs/reiserfs/do_balan.c:245:20: warning: variable ih set but not used [-Wunused-but-set-variable]
    fs/reiserfs/do_balan.c: In function balance_leaf_insert_left:
    fs/reiserfs/do_balan.c:301:7: warning: variable version set but not used [-Wunused-but-set-variable]
    fs/reiserfs/do_balan.c: In function balance_leaf_insert_right:
    fs/reiserfs/do_balan.c:649:7: warning: variable version set but not used [-Wunused-but-set-variable]
    fs/reiserfs/do_balan.c: In function balance_leaf_new_nodes_insert:
    fs/reiserfs/do_balan.c:953:7: warning: variable version set but not used [-Wunused-but-set-variable]
    
    Link: http://lkml.kernel.org/r/1566379929-118398-8-git-send-email-zhengbin13@huawei.com
    Signed-off-by: zhengbin <zhengbin13@huawei.com>
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 9c02d96d3a42..ffb6d7f0da94 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -239,10 +239,8 @@ static int balance_leaf_when_delete_left(struct tree_balance *tb)
 static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
-	int item_pos = PATH_LAST_POSITION(tb->tb_path);
 	struct buffer_info bi;
 	int n;
-	struct item_head *ih;
 
 	RFALSE(tb->FR[0] && B_LEVEL(tb->FR[0]) != DISK_LEAF_NODE_LEVEL + 1,
 	       "vs- 12000: level: wrong FR %z", tb->FR[0]);
@@ -251,7 +249,6 @@ static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 	RFALSE(!tb->blknum[0] && !PATH_H_PPARENT(tb->tb_path, 0),
 	       "PAP-12010: tree can not be empty");
 
-	ih = item_head(tbS0, item_pos);
 	buffer_info_init_tbS0(tb, &bi);
 
 	/* Delete or truncate the item */
@@ -298,7 +295,6 @@ static unsigned int balance_leaf_insert_left(struct tree_balance *tb,
 	if (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {
 		/* part of new item falls into L[0] */
 		int new_item_len, shift;
-		int version;
 
 		ret = leaf_shift_left(tb, tb->lnum[0] - 1, -1);
 
@@ -317,8 +313,6 @@ static unsigned int balance_leaf_insert_left(struct tree_balance *tb,
 		leaf_insert_into_buf(&bi, n + tb->item_pos - ret, ih, body,
 			     min_t(int, tb->zeroes_num, ih_item_len(ih)));
 
-		version = ih_version(ih);
-
 		/*
 		 * Calculate key component, item length and body to
 		 * insert into S[0]
@@ -646,13 +640,11 @@ static void balance_leaf_insert_right(struct tree_balance *tb,
 	if (tb->item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1) {
 		loff_t old_key_comp, old_len, r_zeroes_number;
 		const char *r_body;
-		int version, shift;
+		int shift;
 		loff_t offset;
 
 		leaf_shift_right(tb, tb->rnum[0] - 1, -1);
 
-		version = ih_version(ih);
-
 		/* Remember key component and item length */
 		old_key_comp = le_ih_k_offset(ih);
 		old_len = ih_item_len(ih);
@@ -950,14 +942,12 @@ static void balance_leaf_new_nodes_insert(struct tree_balance *tb,
 	if (tb->item_pos == n - tb->snum[i] + 1 && tb->sbytes[i] != -1) {
 		int old_key_comp, old_len, r_zeroes_number;
 		const char *r_body;
-		int version;
 
 		/* Move snum[i]-1 items from S[0] to S_new[i] */
 		leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i] - 1, -1,
 				tb->S_new[i]);
 
 		/* Remember key component and item length */
-		version = ih_version(ih);
 		old_key_comp = le_ih_k_offset(ih);
 		old_len = ih_item_len(ih);
 

commit cec997093bbff881c3da49084dfba4f76361e96a
Merge: 8d2d441ac4af 01777836c870
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 13 17:45:40 2014 -0600

    Merge branch 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs
    
    Pull quota, reiserfs, UDF updates from Jan Kara:
     "Scalability improvements for quota, a few reiserfs fixes, and couple
      of misc cleanups (udf, ext2)"
    
    * 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs:
      reiserfs: Fix use after free in journal teardown
      reiserfs: fix corruption introduced by balance_leaf refactor
      udf: avoid redundant memcpy when writing data in ICB
      fs/udf: re-use hex_asc_upper_{hi,lo} macros
      fs/quota: kernel-doc warning fixes
      udf: use linux/uaccess.h
      fs/ext2/super.c: Drop memory allocation cast
      quota: remove dqptr_sem
      quota: simplify remove_inode_dquot_ref()
      quota: avoid unnecessary dqget()/dqput() calls
      quota: protect Q_GETFMT by dqonoff_mutex

commit 17093991af4995c4b93f6d8ac63aab68fcd9e1be
Author: Fabian Frederick <fabf@skynet.be>
Date:   Fri Aug 8 14:21:12 2014 -0700

    fs/reiserfs: use linux/uaccess.h
    
    Fix checkpatch warning
    
      WARNING: Use #include <linux/uaccess.h> instead of <asm/uaccess.h>
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 54fdf196bfb2..5739cb99de7b 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -10,7 +10,7 @@
  * and using buffers obtained after all above.
  */
 
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/time.h>
 #include "reiserfs.h"
 #include <linux/buffer_head.h>

commit 27d0e5bc85f3341b9ba66f0c23627cf9d7538c9d
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Aug 4 19:51:47 2014 -0400

    reiserfs: fix corruption introduced by balance_leaf refactor
    
    Commits f1f007c308e (reiserfs: balance_leaf refactor, pull out
    balance_leaf_insert_left) and cf22df182bf (reiserfs: balance_leaf
    refactor, pull out balance_leaf_paste_left) missed that the `body'
    pointer was getting repositioned. Subsequent users of the pointer
    would expect it to be repositioned, and as a result, parts of the
    tree would get overwritten. The most common observed corruption
    is indirect block pointers being overwritten.
    
    Since the body value isn't actually used anymore in the called routines,
    we can pass back the offset it should be shifted. We constify the body
    and ih pointers in the balance_leaf as a mostly-free preventative measure.
    
    Cc: <stable@vger.kernel.org> # 3.16
    Reported-and-tested-by: Jeff Chua <jeff.chua.linux@gmail.com>
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 54fdf196bfb2..4d5e5297793f 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -286,12 +286,14 @@ static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 	return 0;
 }
 
-static void balance_leaf_insert_left(struct tree_balance *tb,
-				     struct item_head *ih, const char *body)
+static unsigned int balance_leaf_insert_left(struct tree_balance *tb,
+					     struct item_head *const ih,
+					     const char * const body)
 {
 	int ret;
 	struct buffer_info bi;
 	int n = B_NR_ITEMS(tb->L[0]);
+	unsigned body_shift_bytes = 0;
 
 	if (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {
 		/* part of new item falls into L[0] */
@@ -329,7 +331,7 @@ static void balance_leaf_insert_left(struct tree_balance *tb,
 
 		put_ih_item_len(ih, new_item_len);
 		if (tb->lbytes > tb->zeroes_num) {
-			body += (tb->lbytes - tb->zeroes_num);
+			body_shift_bytes = tb->lbytes - tb->zeroes_num;
 			tb->zeroes_num = 0;
 		} else
 			tb->zeroes_num -= tb->lbytes;
@@ -349,11 +351,12 @@ static void balance_leaf_insert_left(struct tree_balance *tb,
 		tb->insert_size[0] = 0;
 		tb->zeroes_num = 0;
 	}
+	return body_shift_bytes;
 }
 
 static void balance_leaf_paste_left_shift_dirent(struct tree_balance *tb,
-						 struct item_head *ih,
-						 const char *body)
+						 struct item_head * const ih,
+						 const char * const body)
 {
 	int n = B_NR_ITEMS(tb->L[0]);
 	struct buffer_info bi;
@@ -413,17 +416,18 @@ static void balance_leaf_paste_left_shift_dirent(struct tree_balance *tb,
 	tb->pos_in_item -= tb->lbytes;
 }
 
-static void balance_leaf_paste_left_shift(struct tree_balance *tb,
-					  struct item_head *ih,
-					  const char *body)
+static unsigned int balance_leaf_paste_left_shift(struct tree_balance *tb,
+						  struct item_head * const ih,
+						  const char * const body)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	int n = B_NR_ITEMS(tb->L[0]);
 	struct buffer_info bi;
+	int body_shift_bytes = 0;
 
 	if (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {
 		balance_leaf_paste_left_shift_dirent(tb, ih, body);
-		return;
+		return 0;
 	}
 
 	RFALSE(tb->lbytes <= 0,
@@ -497,7 +501,7 @@ static void balance_leaf_paste_left_shift(struct tree_balance *tb,
 		 * insert_size[0]
 		 */
 		if (l_n > tb->zeroes_num) {
-			body += (l_n - tb->zeroes_num);
+			body_shift_bytes = l_n - tb->zeroes_num;
 			tb->zeroes_num = 0;
 		} else
 			tb->zeroes_num -= l_n;
@@ -526,13 +530,14 @@ static void balance_leaf_paste_left_shift(struct tree_balance *tb,
 		 */
 		leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
 	}
+	return body_shift_bytes;
 }
 
 
 /* appended item will be in L[0] in whole */
 static void balance_leaf_paste_left_whole(struct tree_balance *tb,
-					  struct item_head *ih,
-					  const char *body)
+					  struct item_head * const ih,
+					  const char * const body)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	int n = B_NR_ITEMS(tb->L[0]);
@@ -584,39 +589,44 @@ static void balance_leaf_paste_left_whole(struct tree_balance *tb,
 	tb->zeroes_num = 0;
 }
 
-static void balance_leaf_paste_left(struct tree_balance *tb,
-				    struct item_head *ih, const char *body)
+static unsigned int balance_leaf_paste_left(struct tree_balance *tb,
+					    struct item_head * const ih,
+					    const char * const body)
 {
 	/* we must shift the part of the appended item */
 	if (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1)
-		balance_leaf_paste_left_shift(tb, ih, body);
+		return balance_leaf_paste_left_shift(tb, ih, body);
 	else
 		balance_leaf_paste_left_whole(tb, ih, body);
+	return 0;
 }
 
 /* Shift lnum[0] items from S[0] to the left neighbor L[0] */
-static void balance_leaf_left(struct tree_balance *tb, struct item_head *ih,
-			      const char *body, int flag)
+static unsigned int balance_leaf_left(struct tree_balance *tb,
+				      struct item_head * const ih,
+				      const char * const body, int flag)
 {
 	if (tb->lnum[0] <= 0)
-		return;
+		return 0;
 
 	/* new item or it part falls to L[0], shift it too */
 	if (tb->item_pos < tb->lnum[0]) {
 		BUG_ON(flag != M_INSERT && flag != M_PASTE);
 
 		if (flag == M_INSERT)
-			balance_leaf_insert_left(tb, ih, body);
+			return balance_leaf_insert_left(tb, ih, body);
 		else /* M_PASTE */
-			balance_leaf_paste_left(tb, ih, body);
+			return balance_leaf_paste_left(tb, ih, body);
 	} else
 		/* new item doesn't fall into L[0] */
 		leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
+	return 0;
 }
 
 
 static void balance_leaf_insert_right(struct tree_balance *tb,
-				      struct item_head *ih, const char *body)
+				      struct item_head * const ih,
+				      const char * const body)
 {
 
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
@@ -704,7 +714,8 @@ static void balance_leaf_insert_right(struct tree_balance *tb,
 
 
 static void balance_leaf_paste_right_shift_dirent(struct tree_balance *tb,
-				     struct item_head *ih, const char *body)
+				     struct item_head * const ih,
+				     const char * const body)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	struct buffer_info bi;
@@ -754,7 +765,8 @@ static void balance_leaf_paste_right_shift_dirent(struct tree_balance *tb,
 }
 
 static void balance_leaf_paste_right_shift(struct tree_balance *tb,
-				     struct item_head *ih, const char *body)
+				     struct item_head * const ih,
+				     const char * const body)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	int n_shift, n_rem, r_zeroes_number, version;
@@ -831,7 +843,8 @@ static void balance_leaf_paste_right_shift(struct tree_balance *tb,
 }
 
 static void balance_leaf_paste_right_whole(struct tree_balance *tb,
-				     struct item_head *ih, const char *body)
+				     struct item_head * const ih,
+				     const char * const body)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	int n = B_NR_ITEMS(tbS0);
@@ -874,7 +887,8 @@ static void balance_leaf_paste_right_whole(struct tree_balance *tb,
 }
 
 static void balance_leaf_paste_right(struct tree_balance *tb,
-				     struct item_head *ih, const char *body)
+				     struct item_head * const ih,
+				     const char * const body)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	int n = B_NR_ITEMS(tbS0);
@@ -896,8 +910,9 @@ static void balance_leaf_paste_right(struct tree_balance *tb,
 }
 
 /* shift rnum[0] items from S[0] to the right neighbor R[0] */
-static void balance_leaf_right(struct tree_balance *tb, struct item_head *ih,
-			       const char *body, int flag)
+static void balance_leaf_right(struct tree_balance *tb,
+			       struct item_head * const ih,
+			       const char * const body, int flag)
 {
 	if (tb->rnum[0] <= 0)
 		return;
@@ -911,8 +926,8 @@ static void balance_leaf_right(struct tree_balance *tb, struct item_head *ih,
 }
 
 static void balance_leaf_new_nodes_insert(struct tree_balance *tb,
-					  struct item_head *ih,
-					  const char *body,
+					  struct item_head * const ih,
+					  const char * const body,
 					  struct item_head *insert_key,
 					  struct buffer_head **insert_ptr,
 					  int i)
@@ -1003,8 +1018,8 @@ static void balance_leaf_new_nodes_insert(struct tree_balance *tb,
 
 /* we append to directory item */
 static void balance_leaf_new_nodes_paste_dirent(struct tree_balance *tb,
-					 struct item_head *ih,
-					 const char *body,
+					 struct item_head * const ih,
+					 const char * const body,
 					 struct item_head *insert_key,
 					 struct buffer_head **insert_ptr,
 					 int i)
@@ -1058,8 +1073,8 @@ static void balance_leaf_new_nodes_paste_dirent(struct tree_balance *tb,
 }
 
 static void balance_leaf_new_nodes_paste_shift(struct tree_balance *tb,
-					 struct item_head *ih,
-					 const char *body,
+					 struct item_head * const ih,
+					 const char * const body,
 					 struct item_head *insert_key,
 					 struct buffer_head **insert_ptr,
 					 int i)
@@ -1131,8 +1146,8 @@ static void balance_leaf_new_nodes_paste_shift(struct tree_balance *tb,
 }
 
 static void balance_leaf_new_nodes_paste_whole(struct tree_balance *tb,
-					       struct item_head *ih,
-					       const char *body,
+					       struct item_head * const ih,
+					       const char * const body,
 					       struct item_head *insert_key,
 					       struct buffer_head **insert_ptr,
 					       int i)
@@ -1184,8 +1199,8 @@ static void balance_leaf_new_nodes_paste_whole(struct tree_balance *tb,
 
 }
 static void balance_leaf_new_nodes_paste(struct tree_balance *tb,
-					 struct item_head *ih,
-					 const char *body,
+					 struct item_head * const ih,
+					 const char * const body,
 					 struct item_head *insert_key,
 					 struct buffer_head **insert_ptr,
 					 int i)
@@ -1214,8 +1229,8 @@ static void balance_leaf_new_nodes_paste(struct tree_balance *tb,
 
 /* Fill new nodes that appear in place of S[0] */
 static void balance_leaf_new_nodes(struct tree_balance *tb,
-				   struct item_head *ih,
-				   const char *body,
+				   struct item_head * const ih,
+				   const char * const body,
 				   struct item_head *insert_key,
 				   struct buffer_head **insert_ptr,
 				   int flag)
@@ -1254,8 +1269,8 @@ static void balance_leaf_new_nodes(struct tree_balance *tb,
 }
 
 static void balance_leaf_finish_node_insert(struct tree_balance *tb,
-					    struct item_head *ih,
-					    const char *body)
+					    struct item_head * const ih,
+					    const char * const body)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	struct buffer_info bi;
@@ -1271,8 +1286,8 @@ static void balance_leaf_finish_node_insert(struct tree_balance *tb,
 }
 
 static void balance_leaf_finish_node_paste_dirent(struct tree_balance *tb,
-						  struct item_head *ih,
-						  const char *body)
+						  struct item_head * const ih,
+						  const char * const body)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	struct item_head *pasted = item_head(tbS0, tb->item_pos);
@@ -1305,8 +1320,8 @@ static void balance_leaf_finish_node_paste_dirent(struct tree_balance *tb,
 }
 
 static void balance_leaf_finish_node_paste(struct tree_balance *tb,
-					   struct item_head *ih,
-					   const char *body)
+					   struct item_head * const ih,
+					   const char * const body)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	struct buffer_info bi;
@@ -1349,8 +1364,8 @@ static void balance_leaf_finish_node_paste(struct tree_balance *tb,
  * of the affected item which remains in S
  */
 static void balance_leaf_finish_node(struct tree_balance *tb,
-				      struct item_head *ih,
-				      const char *body, int flag)
+				      struct item_head * const ih,
+				      const char * const body, int flag)
 {
 	/* if we must insert or append into buffer S[0] */
 	if (0 <= tb->item_pos && tb->item_pos < tb->s0num) {
@@ -1402,7 +1417,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 	    && is_indirect_le_ih(item_head(tbS0, tb->item_pos)))
 		tb->pos_in_item *= UNFM_P_SIZE;
 
-	balance_leaf_left(tb, ih, body, flag);
+	body += balance_leaf_left(tb, ih, body, flag);
 
 	/* tb->lnum[0] > 0 */
 	/* Calculate new item position */

commit 19ef1229bc2e2468bdf4ea594a57e4287ffa1e6b
Author: Jan Kara <jack@suse.cz>
Date:   Wed Jun 11 17:29:26 2014 +0200

    reiserfs: Fix compilation breakage with CONFIG_REISERFS_CHECK
    
    There was a bug in debug printout when CONFIG_REISERFS_CHECK was
    enabled so one of the assertions in do_balan.c didn't compile. Fix it.
    
    Fixes: 0080e9f9d3ac717537dbd6db1fc8ef72ce0b9cc1
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 547575c1c3c0..54fdf196bfb2 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -1249,7 +1249,7 @@ static void balance_leaf_new_nodes(struct tree_balance *tb,
 		       || buffer_journal_dirty(tb->S_new[i])
 		       || buffer_dirty(tb->S_new[i]),
 		       "PAP-12247: S_new[%d] : (%b)",
-		       i, format_bh(tb->S_new[i]));
+		       i, tb->S_new[i]);
 	}
 }
 

commit 83a3a56936667e8dbf2a43ceb380bc5a08d5fa0b
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:01:02 2014 -0400

    reiserfs: balance_leaf refactor, split up balance_leaf_when_delete
    
    Splut up balance_leaf_when_delete into:
    balance_leaf_when_delete_del
    balance_leaf_when_cut
    balance_leaf_when_delete_left
    
    Also reformat to adhere to CodingStyle.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 959b7b578f9d..547575c1c3c0 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -74,6 +74,159 @@ inline void do_balance_mark_leaf_dirty(struct tree_balance *tb,
  * Note that all *num* count new items being created.
  */
 
+static void balance_leaf_when_delete_del(struct tree_balance *tb)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int item_pos = PATH_LAST_POSITION(tb->tb_path);
+	struct buffer_info bi;
+#ifdef CONFIG_REISERFS_CHECK
+	struct item_head *ih = item_head(tbS0, item_pos);
+#endif
+
+	RFALSE(ih_item_len(ih) + IH_SIZE != -tb->insert_size[0],
+	       "vs-12013: mode Delete, insert size %d, ih to be deleted %h",
+	       -tb->insert_size[0], ih);
+
+	buffer_info_init_tbS0(tb, &bi);
+	leaf_delete_items(&bi, 0, item_pos, 1, -1);
+
+	if (!item_pos && tb->CFL[0]) {
+		if (B_NR_ITEMS(tbS0)) {
+			replace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);
+		} else {
+			if (!PATH_H_POSITION(tb->tb_path, 1))
+				replace_key(tb, tb->CFL[0], tb->lkey[0],
+					    PATH_H_PPARENT(tb->tb_path, 0), 0);
+		}
+	}
+
+	RFALSE(!item_pos && !tb->CFL[0],
+	       "PAP-12020: tb->CFL[0]==%p, tb->L[0]==%p", tb->CFL[0],
+	       tb->L[0]);
+}
+
+/* cut item in S[0] */
+static void balance_leaf_when_delete_cut(struct tree_balance *tb)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int item_pos = PATH_LAST_POSITION(tb->tb_path);
+	struct item_head *ih = item_head(tbS0, item_pos);
+	int pos_in_item = tb->tb_path->pos_in_item;
+	struct buffer_info bi;
+	buffer_info_init_tbS0(tb, &bi);
+
+	if (is_direntry_le_ih(ih)) {
+		/*
+		 * UFS unlink semantics are such that you can only
+		 * delete one directory entry at a time.
+		 *
+		 * when we cut a directory tb->insert_size[0] means
+		 * number of entries to be cut (always 1)
+		 */
+		tb->insert_size[0] = -1;
+		leaf_cut_from_buffer(&bi, item_pos, pos_in_item,
+				     -tb->insert_size[0]);
+
+		RFALSE(!item_pos && !pos_in_item && !tb->CFL[0],
+		       "PAP-12030: can not change delimiting key. CFL[0]=%p",
+		       tb->CFL[0]);
+
+		if (!item_pos && !pos_in_item && tb->CFL[0])
+			replace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);
+	} else {
+		leaf_cut_from_buffer(&bi, item_pos, pos_in_item,
+				     -tb->insert_size[0]);
+
+		RFALSE(!ih_item_len(ih),
+		       "PAP-12035: cut must leave non-zero dynamic "
+		       "length of item");
+	}
+}
+
+static int balance_leaf_when_delete_left(struct tree_balance *tb)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int n = B_NR_ITEMS(tbS0);
+
+	/* L[0] must be joined with S[0] */
+	if (tb->lnum[0] == -1) {
+		/* R[0] must be also joined with S[0] */
+		if (tb->rnum[0] == -1) {
+			if (tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0)) {
+				/*
+				 * all contents of all the
+				 * 3 buffers will be in L[0]
+				 */
+				if (PATH_H_POSITION(tb->tb_path, 1) == 0 &&
+				    1 < B_NR_ITEMS(tb->FR[0]))
+					replace_key(tb, tb->CFL[0],
+						    tb->lkey[0], tb->FR[0], 1);
+
+				leaf_move_items(LEAF_FROM_S_TO_L, tb, n, -1,
+						NULL);
+				leaf_move_items(LEAF_FROM_R_TO_L, tb,
+						B_NR_ITEMS(tb->R[0]), -1,
+						NULL);
+
+				reiserfs_invalidate_buffer(tb, tbS0);
+				reiserfs_invalidate_buffer(tb, tb->R[0]);
+
+				return 0;
+			}
+
+			/* all contents of all the 3 buffers will be in R[0] */
+			leaf_move_items(LEAF_FROM_S_TO_R, tb, n, -1, NULL);
+			leaf_move_items(LEAF_FROM_L_TO_R, tb,
+					B_NR_ITEMS(tb->L[0]), -1, NULL);
+
+			/* right_delimiting_key is correct in R[0] */
+			replace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);
+
+			reiserfs_invalidate_buffer(tb, tbS0);
+			reiserfs_invalidate_buffer(tb, tb->L[0]);
+
+			return -1;
+		}
+
+		RFALSE(tb->rnum[0] != 0,
+		       "PAP-12045: rnum must be 0 (%d)", tb->rnum[0]);
+		/* all contents of L[0] and S[0] will be in L[0] */
+		leaf_shift_left(tb, n, -1);
+
+		reiserfs_invalidate_buffer(tb, tbS0);
+
+		return 0;
+	}
+
+	/*
+	 * a part of contents of S[0] will be in L[0] and
+	 * the rest part of S[0] will be in R[0]
+	 */
+
+	RFALSE((tb->lnum[0] + tb->rnum[0] < n) ||
+	       (tb->lnum[0] + tb->rnum[0] > n + 1),
+	       "PAP-12050: rnum(%d) and lnum(%d) and item "
+	       "number(%d) in S[0] are not consistent",
+	       tb->rnum[0], tb->lnum[0], n);
+	RFALSE((tb->lnum[0] + tb->rnum[0] == n) &&
+	       (tb->lbytes != -1 || tb->rbytes != -1),
+	       "PAP-12055: bad rbytes (%d)/lbytes (%d) "
+	       "parameters when items are not split",
+	       tb->rbytes, tb->lbytes);
+	RFALSE((tb->lnum[0] + tb->rnum[0] == n + 1) &&
+	       (tb->lbytes < 1 || tb->rbytes != -1),
+	       "PAP-12060: bad rbytes (%d)/lbytes (%d) "
+	       "parameters when items are split",
+	       tb->rbytes, tb->lbytes);
+
+	leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
+	leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
+
+	reiserfs_invalidate_buffer(tb, tbS0);
+
+	return 0;
+}
+
 /*
  * Balance leaf node in case of delete or cut: insert_size[0] < 0
  *
@@ -87,7 +240,6 @@ static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	int item_pos = PATH_LAST_POSITION(tb->tb_path);
-	int pos_in_item = tb->tb_path->pos_in_item;
 	struct buffer_info bi;
 	int n;
 	struct item_head *ih;
@@ -104,166 +256,23 @@ static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 
 	/* Delete or truncate the item */
 
-	switch (flag) {
-	case M_DELETE:		/* delete item in S[0] */
-
-		RFALSE(ih_item_len(ih) + IH_SIZE != -tb->insert_size[0],
-		       "vs-12013: mode Delete, insert size %d, ih to be deleted %h",
-		       -tb->insert_size[0], ih);
-
-		leaf_delete_items(&bi, 0, item_pos, 1, -1);
-
-		if (!item_pos && tb->CFL[0]) {
-			if (B_NR_ITEMS(tbS0)) {
-				replace_key(tb, tb->CFL[0], tb->lkey[0], tbS0,
-					    0);
-			} else {
-				if (!PATH_H_POSITION(tb->tb_path, 1))
-					replace_key(tb, tb->CFL[0], tb->lkey[0],
-						    PATH_H_PPARENT(tb->tb_path,
-								   0), 0);
-			}
-		}
-
-		RFALSE(!item_pos && !tb->CFL[0],
-		       "PAP-12020: tb->CFL[0]==%p, tb->L[0]==%p", tb->CFL[0],
-		       tb->L[0]);
-
-		break;
-
-	case M_CUT:{		/* cut item in S[0] */
-			if (is_direntry_le_ih(ih)) {
-
-				/*
-				 * UFS unlink semantics are such that you
-				 * can only delete one directory entry at
-				 * a time.
-				 */
-
-				/*
-				 * when we cut a directory tb->insert_size[0]
-				 * means number of entries to be cut (always 1)
-				 */
-				tb->insert_size[0] = -1;
-				leaf_cut_from_buffer(&bi, item_pos, pos_in_item,
-						     -tb->insert_size[0]);
-
-				RFALSE(!item_pos && !pos_in_item && !tb->CFL[0],
-				       "PAP-12030: can not change delimiting key. CFL[0]=%p",
-				       tb->CFL[0]);
-
-				if (!item_pos && !pos_in_item && tb->CFL[0]) {
-					replace_key(tb, tb->CFL[0], tb->lkey[0],
-						    tbS0, 0);
-				}
-			} else {
-				leaf_cut_from_buffer(&bi, item_pos, pos_in_item,
-						     -tb->insert_size[0]);
-
-				RFALSE(!ih_item_len(ih),
-				       "PAP-12035: cut must leave non-zero dynamic length of item");
-			}
-			break;
-		}
+	BUG_ON(flag != M_DELETE && flag != M_CUT);
+	if (flag == M_DELETE)
+		balance_leaf_when_delete_del(tb);
+	else /* M_CUT */
+		balance_leaf_when_delete_cut(tb);
 
-	default:
-		print_cur_tb("12040");
-		reiserfs_panic(tb->tb_sb, "PAP-12040",
-			       "unexpected mode: %s(%d)",
-			       (flag ==
-				M_PASTE) ? "PASTE" : ((flag ==
-						       M_INSERT) ? "INSERT" :
-						      "UNKNOWN"), flag);
-	}
 
 	/*
 	 * the rule is that no shifting occurs unless by shifting
 	 * a node can be freed
 	 */
 	n = B_NR_ITEMS(tbS0);
-	/* L[0] takes part in balancing */
-	if (tb->lnum[0]) {
-		/* L[0] must be joined with S[0] */
-		if (tb->lnum[0] == -1) {
-			/* R[0] must be also joined with S[0] */
-			if (tb->rnum[0] == -1) {
-				if (tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0)) {
-					/*
-					 * all contents of all the 3 buffers
-					 * will be in L[0]
-					 */
-					if (PATH_H_POSITION(tb->tb_path, 1) == 0
-					    && 1 < B_NR_ITEMS(tb->FR[0]))
-						replace_key(tb, tb->CFL[0],
-							    tb->lkey[0],
-							    tb->FR[0], 1);
-
-					leaf_move_items(LEAF_FROM_S_TO_L, tb, n,
-							-1, NULL);
-					leaf_move_items(LEAF_FROM_R_TO_L, tb,
-							B_NR_ITEMS(tb->R[0]),
-							-1, NULL);
-
-					reiserfs_invalidate_buffer(tb, tbS0);
-					reiserfs_invalidate_buffer(tb,
-								   tb->R[0]);
-
-					return 0;
-				}
-				/*
-				 * all contents of all the 3 buffers will
-				 * be in R[0]
-				 */
-				leaf_move_items(LEAF_FROM_S_TO_R, tb, n, -1,
-						NULL);
-				leaf_move_items(LEAF_FROM_L_TO_R, tb,
-						B_NR_ITEMS(tb->L[0]), -1, NULL);
 
-				/* right_delimiting_key is correct in R[0] */
-				replace_key(tb, tb->CFR[0], tb->rkey[0],
-					    tb->R[0], 0);
 
-				reiserfs_invalidate_buffer(tb, tbS0);
-				reiserfs_invalidate_buffer(tb, tb->L[0]);
-
-				return -1;
-			}
-
-			RFALSE(tb->rnum[0] != 0,
-			       "PAP-12045: rnum must be 0 (%d)", tb->rnum[0]);
-			/* all contents of L[0] and S[0] will be in L[0] */
-			leaf_shift_left(tb, n, -1);
-
-			reiserfs_invalidate_buffer(tb, tbS0);
-
-			return 0;
-		}
-
-		/*
-		 * a part of contents of S[0] will be in L[0] and the
-		 * rest part of S[0] will be in R[0]
-		 */
-
-		RFALSE((tb->lnum[0] + tb->rnum[0] < n) ||
-		       (tb->lnum[0] + tb->rnum[0] > n + 1),
-		       "PAP-12050: rnum(%d) and lnum(%d) and item number(%d) in S[0] are not consistent",
-		       tb->rnum[0], tb->lnum[0], n);
-		RFALSE((tb->lnum[0] + tb->rnum[0] == n) &&
-		       (tb->lbytes != -1 || tb->rbytes != -1),
-		       "PAP-12055: bad rbytes (%d)/lbytes (%d) parameters when items are not split",
-		       tb->rbytes, tb->lbytes);
-		RFALSE((tb->lnum[0] + tb->rnum[0] == n + 1) &&
-		       (tb->lbytes < 1 || tb->rbytes != -1),
-		       "PAP-12060: bad rbytes (%d)/lbytes (%d) parameters when items are split",
-		       tb->rbytes, tb->lbytes);
-
-		leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
-		leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
-
-		reiserfs_invalidate_buffer(tb, tbS0);
-
-		return 0;
-	}
+	/* L[0] takes part in balancing */
+	if (tb->lnum[0])
+		return balance_leaf_when_delete_left(tb);
 
 	if (tb->rnum[0] == -1) {
 		/* all contents of R[0] and S[0] will be in R[0] */
@@ -1880,9 +1889,8 @@ void do_balance(struct tree_balance *tb, struct item_head *ih,
 
 	/* Balance internal level of the tree. */
 	for (h = 1; h < MAX_HEIGHT && tb->insert_size[h]; h++)
-		child_pos =
-		    balance_internal(tb, h, child_pos, insert_key, insert_ptr);
+		child_pos = balance_internal(tb, h, child_pos, insert_key,
+					     insert_ptr);
 
 	do_balance_completed(tb);
-
 }

commit 441378c2bf4f3a510d1afba5bf9911cb40596b68
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:01:01 2014 -0400

    reiserfs: balance_leaf refactor, format balance_leaf_finish_node
    
    Split out balance_leaf_finish_node_dirent from balance_leaf_paste_finish_node.
    
    Also reformat to adhere to CodingStyle.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index cffcb67a5436..959b7b578f9d 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -72,19 +72,6 @@ inline void do_balance_mark_leaf_dirty(struct tree_balance *tb,
  *    if snum1 is larger than 0 we put items into the new node s1
  *    if snum2 is larger than 0 we put items into the new node s2
  * Note that all *num* count new items being created.
- *
- * It would be easier to read balance_leaf() if each of these summary
- * lines was a separate procedure rather than being inlined.  I think
- * that there are many passages here and in balance_leaf_when_delete() in
- * which two calls to one procedure can replace two passages, and it
- * might save cache space and improve software maintenance costs to do so.
- *
- * Vladimir made the perceptive comment that we should offload most of
- * the decision making in this function into fix_nodes/check_balance, and
- * then create some sort of structure in tb that says what actions should
- * be performed by do_balance.
- *
- * -Hans
  */
 
 /*
@@ -1263,18 +1250,49 @@ static void balance_leaf_finish_node_insert(struct tree_balance *tb,
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	struct buffer_info bi;
-			buffer_info_init_tbS0(tb, &bi);
-			leaf_insert_into_buf(&bi, tb->item_pos, ih,
-					     body, tb->zeroes_num);
-
-			/*
-			 * If we insert the first key
-			 * change the delimiting key
-			 */
-			if (tb->item_pos == 0) {
-				if (tb->CFL[0])	/* can be 0 in reiserfsck */
-					replace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);
-			}
+	buffer_info_init_tbS0(tb, &bi);
+	leaf_insert_into_buf(&bi, tb->item_pos, ih, body, tb->zeroes_num);
+
+	/* If we insert the first key change the delimiting key */
+	if (tb->item_pos == 0) {
+		if (tb->CFL[0])	/* can be 0 in reiserfsck */
+			replace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);
+
+	}
+}
+
+static void balance_leaf_finish_node_paste_dirent(struct tree_balance *tb,
+						  struct item_head *ih,
+						  const char *body)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	struct item_head *pasted = item_head(tbS0, tb->item_pos);
+	struct buffer_info bi;
+
+	if (tb->pos_in_item >= 0 && tb->pos_in_item <= ih_entry_count(pasted)) {
+		RFALSE(!tb->insert_size[0],
+		       "PAP-12260: insert_size is 0 already");
+
+		/* prepare space */
+		buffer_info_init_tbS0(tb, &bi);
+		leaf_paste_in_buffer(&bi, tb->item_pos, tb->pos_in_item,
+				     tb->insert_size[0], body, tb->zeroes_num);
+
+		/* paste entry */
+		leaf_paste_entries(&bi, tb->item_pos, tb->pos_in_item, 1,
+				   (struct reiserfs_de_head *)body,
+				   body + DEH_SIZE, tb->insert_size[0]);
+
+		if (!tb->item_pos && !tb->pos_in_item) {
+			RFALSE(!tb->CFL[0] || !tb->L[0],
+			       "PAP-12270: CFL[0]/L[0] must  be specified");
+			if (tb->CFL[0])
+				replace_key(tb, tb->CFL[0], tb->lkey[0],
+					    tbS0, 0);
+		}
+
+		tb->insert_size[0] = 0;
+	}
 }
 
 static void balance_leaf_finish_node_paste(struct tree_balance *tb,
@@ -1283,74 +1301,37 @@ static void balance_leaf_finish_node_paste(struct tree_balance *tb,
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	struct buffer_info bi;
-				struct item_head *pasted;
-
-				pasted = item_head(tbS0, tb->item_pos);
-				/* when directory, may be new entry already pasted */
-				if (is_direntry_le_ih(pasted)) {
-					if (tb->pos_in_item >= 0 && tb->pos_in_item <= ih_entry_count(pasted)) {
-
-						RFALSE(!tb->insert_size[0],
-						       "PAP-12260: insert_size is 0 already");
-
-						/* prepare space */
-						buffer_info_init_tbS0(tb, &bi);
-						leaf_paste_in_buffer(&bi, tb->item_pos, tb->pos_in_item,
-								     tb->insert_size[0], body,
-								     tb->zeroes_num);
-
-						/* paste entry */
-						leaf_paste_entries(&bi, tb->item_pos, tb->pos_in_item, 1,
-								   (struct reiserfs_de_head *)body,
-								   body + DEH_SIZE,
-								   tb->insert_size[0]);
-						if (!tb->item_pos && !tb->pos_in_item) {
-							RFALSE(!tb->CFL[0] || !tb->L[0],
-							       "PAP-12270: CFL[0]/L[0] must be specified");
-							if (tb->CFL[0])
-								replace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);
-						}
-						tb->insert_size[0] = 0;
-					}
-				} else {	/* regular object */
-					if (tb->pos_in_item == ih_item_len(pasted)) {
-
-						RFALSE(tb->insert_size[0] <= 0,
-						       "PAP-12275: insert size must not be %d",
-						       tb->insert_size[0]);
-						buffer_info_init_tbS0(tb, &bi);
-						leaf_paste_in_buffer(&bi, tb->item_pos, tb->pos_in_item,
-								     tb->insert_size[0], body, tb->zeroes_num);
-
-						if (is_indirect_le_ih(pasted)) {
-#if 0
-							RFALSE(tb->
-							       insert_size[0] !=
-							       UNFM_P_SIZE,
-							       "PAP-12280: insert_size for indirect item must be %d, not %d",
-							       UNFM_P_SIZE,
-							       tb->
-							       insert_size[0]);
-#endif
-							set_ih_free_space(pasted, 0);
-						}
-						tb->insert_size[0] = 0;
-					}
-#ifdef CONFIG_REISERFS_CHECK
-					else {
-						if (tb->insert_size[0]) {
-							print_cur_tb("12285");
-							reiserfs_panic(tb->tb_sb,
-							    "PAP-12285",
-							    "insert_size "
-							    "must be 0 "
-							    "(%d)",
-							    tb->insert_size[0]);
-						}
-					}
-#endif				/* CONFIG_REISERFS_CHECK */
+	struct item_head *pasted = item_head(tbS0, tb->item_pos);
 
-				}
+	/* when directory, may be new entry already pasted */
+	if (is_direntry_le_ih(pasted)) {
+		balance_leaf_finish_node_paste_dirent(tb, ih, body);
+		return;
+	}
+
+	/* regular object */
+
+	if (tb->pos_in_item == ih_item_len(pasted)) {
+		RFALSE(tb->insert_size[0] <= 0,
+		       "PAP-12275: insert size must not be %d",
+		       tb->insert_size[0]);
+		buffer_info_init_tbS0(tb, &bi);
+		leaf_paste_in_buffer(&bi, tb->item_pos,
+				     tb->pos_in_item, tb->insert_size[0], body,
+				     tb->zeroes_num);
+
+		if (is_indirect_le_ih(pasted))
+			set_ih_free_space(pasted, 0);
+
+		tb->insert_size[0] = 0;
+	}
+#ifdef CONFIG_REISERFS_CHECK
+	else if (tb->insert_size[0]) {
+		print_cur_tb("12285");
+		reiserfs_panic(tb->tb_sb, "PAP-12285",
+		    "insert_size must be 0 (%d)", tb->insert_size[0]);
+	}
+#endif
 }
 
 /*

commit b54b8c918415376c6cfca0e1ceed26cf62b92ae1
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:01:00 2014 -0400

    reiserfs: balance_leaf refactor, format balance_leaf_new_nodes_paste
    
    Break up balance_leaf_paste_new_nodes into:
    balance_leaf_paste_new_nodes_shift
    balance_leaf_paste_new_nodes_shift_dirent
    balance_leaf_paste_new_nodes_whole
    
    and keep balance_leaf_paste_new_nodes as a handler to select which
    is appropriate.
    
    Also reformat to adhere to CodingStyle.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 793fab7b9f02..cffcb67a5436 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -714,7 +714,7 @@ static void balance_leaf_paste_right_shift_dirent(struct tree_balance *tb,
 	struct buffer_info bi;
 	int entry_count;
 
-	RFALSE(zeroes_num,
+	RFALSE(tb->zeroes_num,
 	       "PAP-12145: invalid parameter in case of a directory");
 	entry_count = ih_entry_count(item_head(tbS0, tb->item_pos));
 
@@ -782,10 +782,10 @@ static void balance_leaf_paste_right_shift(struct tree_balance *tb,
 	if (n_shift < 0)
 		n_shift = 0;
 
-	RFALSE(pos_in_item != ih_item_len(item_head(tbS0, item_pos)),
+	RFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)),
 	       "PAP-12155: invalid position to paste. ih_item_len=%d, "
-	       "pos_in_item=%d", pos_in_item,
-	       ih_item_len(item_head(tbS0, item_pos)));
+	       "pos_in_item=%d", tb->pos_in_item,
+	       ih_item_len(item_head(tbS0, tb->item_pos)));
 
 	leaf_shift_right(tb, tb->rnum[0], n_shift);
 
@@ -924,68 +924,89 @@ static void balance_leaf_new_nodes_insert(struct tree_balance *tb,
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	int n = B_NR_ITEMS(tbS0);
 	struct buffer_info bi;
-			if (n - tb->snum[i] < tb->item_pos) {	/* new item or it's part falls to first new node S_new[i] */
-				if (tb->item_pos == n - tb->snum[i] + 1 && tb->sbytes[i] != -1) {	/* part of new item falls into S_new[i] */
-					int old_key_comp, old_len, r_zeroes_number;
-					const char *r_body;
-					int version;
-
-					/* Move snum[i]-1 items from S[0] to S_new[i] */
-					leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-							tb->snum[i] - 1, -1,
-							tb->S_new[i]);
-					/* Remember key component and item length */
-					version = ih_version(ih);
-					old_key_comp = le_ih_k_offset(ih);
-					old_len = ih_item_len(ih);
-
-					/* Calculate key component and item length to insert into S_new[i] */
-					set_le_ih_k_offset(ih, le_ih_k_offset(ih) +
-							   ((old_len - tb->sbytes[i]) << (is_indirect_le_ih(ih) ? tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT : 0)));
-
-					put_ih_item_len(ih, tb->sbytes[i]);
-
-					/* Insert part of the item into S_new[i] before 0-th item */
-					buffer_info_init_bh(tb, &bi, tb->S_new[i]);
-
-					if ((old_len - tb->sbytes[i]) > tb->zeroes_num) {
-						r_zeroes_number = 0;
-						r_body = body + (old_len - tb->sbytes[i]) - tb->zeroes_num;
-					} else {
-						r_body = body;
-						r_zeroes_number = tb->zeroes_num - (old_len - tb->sbytes[i]);
-						tb->zeroes_num -= r_zeroes_number;
-					}
+	int shift;
 
-					leaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);
+	/* new item or it part don't falls into S_new[i] */
+	if (n - tb->snum[i] >= tb->item_pos) {
+		leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
+				tb->snum[i], tb->sbytes[i], tb->S_new[i]);
+		return;
+	}
 
-					/* Calculate key component and item length to insert into S[i] */
-					set_le_ih_k_offset(ih, old_key_comp);
-					put_ih_item_len(ih, old_len - tb->sbytes[i]);
-					tb->insert_size[0] -= tb->sbytes[i];
-				} else {	/* whole new item falls into S_new[i] */
+	/* new item or it's part falls to first new node S_new[i] */
 
-					/* Shift snum[0] - 1 items to S_new[i] (sbytes[i] of split item) */
-					leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-							tb->snum[i] - 1, tb->sbytes[i], tb->S_new[i]);
+	/* part of new item falls into S_new[i] */
+	if (tb->item_pos == n - tb->snum[i] + 1 && tb->sbytes[i] != -1) {
+		int old_key_comp, old_len, r_zeroes_number;
+		const char *r_body;
+		int version;
 
-					/* Insert new item into S_new[i] */
-					buffer_info_init_bh(tb, &bi, tb->S_new[i]);
-					leaf_insert_into_buf(&bi, tb->item_pos - n + tb->snum[i] - 1,
-							     ih, body, tb->zeroes_num);
+		/* Move snum[i]-1 items from S[0] to S_new[i] */
+		leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i] - 1, -1,
+				tb->S_new[i]);
 
-					tb->zeroes_num = tb->insert_size[0] = 0;
-				}
-			}
+		/* Remember key component and item length */
+		version = ih_version(ih);
+		old_key_comp = le_ih_k_offset(ih);
+		old_len = ih_item_len(ih);
+
+		/*
+		 * Calculate key component and item length to insert
+		 * into S_new[i]
+		 */
+		shift = 0;
+		if (is_indirect_le_ih(ih))
+			shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;
+		set_le_ih_k_offset(ih,
+				   le_ih_k_offset(ih) +
+				   ((old_len - tb->sbytes[i]) << shift));
 
-			else {	/* new item or it part don't falls into S_new[i] */
+		put_ih_item_len(ih, tb->sbytes[i]);
 
-				leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-						tb->snum[i], tb->sbytes[i], tb->S_new[i]);
-			}
+		/* Insert part of the item into S_new[i] before 0-th item */
+		buffer_info_init_bh(tb, &bi, tb->S_new[i]);
+
+		if ((old_len - tb->sbytes[i]) > tb->zeroes_num) {
+			r_zeroes_number = 0;
+			r_body = body + (old_len - tb->sbytes[i]) -
+					 tb->zeroes_num;
+		} else {
+			r_body = body;
+			r_zeroes_number = tb->zeroes_num - (old_len -
+					  tb->sbytes[i]);
+			tb->zeroes_num -= r_zeroes_number;
+		}
+
+		leaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);
+
+		/*
+		 * Calculate key component and item length to
+		 * insert into S[i]
+		 */
+		set_le_ih_k_offset(ih, old_key_comp);
+		put_ih_item_len(ih, old_len - tb->sbytes[i]);
+		tb->insert_size[0] -= tb->sbytes[i];
+	} else {
+		/* whole new item falls into S_new[i] */
+
+		/*
+		 * Shift snum[0] - 1 items to S_new[i]
+		 * (sbytes[i] of split item)
+		 */
+		leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
+				tb->snum[i] - 1, tb->sbytes[i], tb->S_new[i]);
+
+		/* Insert new item into S_new[i] */
+		buffer_info_init_bh(tb, &bi, tb->S_new[i]);
+		leaf_insert_into_buf(&bi, tb->item_pos - n + tb->snum[i] - 1,
+				     ih, body, tb->zeroes_num);
+
+		tb->zeroes_num = tb->insert_size[0] = 0;
+	}
 }
 
-static void balance_leaf_new_nodes_paste(struct tree_balance *tb,
+/* we append to directory item */
+static void balance_leaf_new_nodes_paste_dirent(struct tree_balance *tb,
 					 struct item_head *ih,
 					 const char *body,
 					 struct item_head *insert_key,
@@ -993,153 +1014,206 @@ static void balance_leaf_new_nodes_paste(struct tree_balance *tb,
 					 int i)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
-	int n = B_NR_ITEMS(tbS0);
+	struct item_head *aux_ih = item_head(tbS0, tb->item_pos);
+	int entry_count = ih_entry_count(aux_ih);
 	struct buffer_info bi;
-			if (n - tb->snum[i] <= tb->item_pos) {	/* pasted item or part if it falls to S_new[i] */
-				if (tb->item_pos == n - tb->snum[i] && tb->sbytes[i] != -1) {	/* we must shift part of the appended item */
-					struct item_head *aux_ih;
-
-					RFALSE(ih, "PAP-12210: ih must be 0");
-
-					aux_ih = item_head(tbS0, tb->item_pos);
-					if (is_direntry_le_ih(aux_ih)) {
-						/* we append to directory item */
-
-						int entry_count;
-
-						entry_count = ih_entry_count(aux_ih);
-
-						if (entry_count - tb->sbytes[i] < tb->pos_in_item && tb->pos_in_item <= entry_count) {
-							/* new directory entry falls into S_new[i] */
-
-							RFALSE(!tb->insert_size[0], "PAP-12215: insert_size is already 0");
-							RFALSE(tb->sbytes[i] - 1 >= entry_count,
-							       "PAP-12220: there are no so much entries (%d), only %d",
-							       tb->sbytes[i] - 1, entry_count);
-
-							/* Shift snum[i]-1 items in whole. Shift sbytes[i] directory entries from directory item number snum[i] */
-							leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], tb->sbytes[i] - 1, tb->S_new[i]);
-							/* Paste given directory entry to directory item */
-							buffer_info_init_bh(tb, &bi, tb->S_new[i]);
-							leaf_paste_in_buffer(&bi, 0, tb->pos_in_item - entry_count + tb->sbytes[i] - 1,
-							     tb->insert_size[0], body, tb->zeroes_num);
-							/* paste new directory entry */
-							leaf_paste_entries(&bi, 0, tb->pos_in_item - entry_count + tb->sbytes[i] - 1, 1,
-									   (struct reiserfs_de_head *) body,
-									   body + DEH_SIZE, tb->insert_size[0]);
-							tb->insert_size[0] = 0;
-							tb->pos_in_item++;
-						} else {	/* new directory entry doesn't fall into S_new[i] */
-							leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], tb->sbytes[i], tb->S_new[i]);
-						}
-					} else {	/* regular object */
-
-						int n_shift, n_rem, r_zeroes_number;
-						const char *r_body;
-
-						RFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)) || tb->insert_size[0] <= 0,
-						       "PAP-12225: item too short or insert_size <= 0");
-
-						/* Calculate number of bytes which must be shifted from appended item */
-						n_shift = tb->sbytes[i] - tb->insert_size[0];
-						if (n_shift < 0)
-							n_shift = 0;
-						leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], n_shift, tb->S_new[i]);
-
-						/* Calculate number of bytes which must remain in body after append to S_new[i] */
-						n_rem = tb->insert_size[0] - tb->sbytes[i];
-						if (n_rem < 0)
-							n_rem = 0;
-						/* Append part of body into S_new[0] */
-						buffer_info_init_bh(tb, &bi, tb->S_new[i]);
-						if (n_rem > tb->zeroes_num) {
-							r_zeroes_number = 0;
-							r_body = body + n_rem - tb->zeroes_num;
-						} else {
-							r_body = body;
-							r_zeroes_number = tb->zeroes_num - n_rem;
-							tb->zeroes_num -= r_zeroes_number;
-						}
 
-						leaf_paste_in_buffer(&bi, 0, n_shift,
-								     tb->insert_size[0] - n_rem,
-								     r_body, r_zeroes_number);
-						{
-							struct item_head *tmp;
-
-							tmp = item_head(tb->S_new[i], 0);
-							if (is_indirect_le_ih
-							    (tmp)) {
-								set_ih_free_space(tmp, 0);
-								set_le_ih_k_offset(tmp, le_ih_k_offset(tmp) + (n_rem << (tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT)));
-							} else {
-								set_le_ih_k_offset(tmp, le_ih_k_offset(tmp) + n_rem);
-							}
-						}
+	if (entry_count - tb->sbytes[i] < tb->pos_in_item &&
+	    tb->pos_in_item <= entry_count) {
+		/* new directory entry falls into S_new[i] */
 
-						tb->insert_size[0] = n_rem;
-						if (!n_rem)
-							tb->pos_in_item++;
-					}
-				} else
-					/* item falls wholly into S_new[i] */
-				{
-					int leaf_mi;
-					struct item_head *pasted;
+		RFALSE(!tb->insert_size[0],
+		       "PAP-12215: insert_size is already 0");
+		RFALSE(tb->sbytes[i] - 1 >= entry_count,
+		       "PAP-12220: there are no so much entries (%d), only %d",
+		       tb->sbytes[i] - 1, entry_count);
+
+		/*
+		 * Shift snum[i]-1 items in whole.
+		 * Shift sbytes[i] directory entries
+		 * from directory item number snum[i]
+		 */
+		leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],
+				tb->sbytes[i] - 1, tb->S_new[i]);
+
+		/*
+		 * Paste given directory entry to
+		 * directory item
+		 */
+		buffer_info_init_bh(tb, &bi, tb->S_new[i]);
+		leaf_paste_in_buffer(&bi, 0, tb->pos_in_item - entry_count +
+				     tb->sbytes[i] - 1, tb->insert_size[0],
+				     body, tb->zeroes_num);
+
+		/* paste new directory entry */
+		leaf_paste_entries(&bi, 0, tb->pos_in_item - entry_count +
+				   tb->sbytes[i] - 1, 1,
+				   (struct reiserfs_de_head *) body,
+				   body + DEH_SIZE, tb->insert_size[0]);
+
+		tb->insert_size[0] = 0;
+		tb->pos_in_item++;
+	} else {
+		/* new directory entry doesn't fall into S_new[i] */
+		leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],
+				tb->sbytes[i], tb->S_new[i]);
+	}
+
+}
+
+static void balance_leaf_new_nodes_paste_shift(struct tree_balance *tb,
+					 struct item_head *ih,
+					 const char *body,
+					 struct item_head *insert_key,
+					 struct buffer_head **insert_ptr,
+					 int i)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	struct item_head *aux_ih = item_head(tbS0, tb->item_pos);
+	int n_shift, n_rem, r_zeroes_number, shift;
+	const char *r_body;
+	struct item_head *tmp;
+	struct buffer_info bi;
+
+	RFALSE(ih, "PAP-12210: ih must be 0");
+
+	if (is_direntry_le_ih(aux_ih)) {
+		balance_leaf_new_nodes_paste_dirent(tb, ih, body, insert_key,
+						    insert_ptr, i);
+		return;
+	}
+
+	/* regular object */
+
+
+	RFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)) ||
+	       tb->insert_size[0] <= 0,
+	       "PAP-12225: item too short or insert_size <= 0");
+
+	/*
+	 * Calculate number of bytes which must be shifted from appended item
+	 */
+	n_shift = tb->sbytes[i] - tb->insert_size[0];
+	if (n_shift < 0)
+		n_shift = 0;
+	leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], n_shift,
+			tb->S_new[i]);
+
+	/*
+	 * Calculate number of bytes which must remain in body after
+	 * append to S_new[i]
+	 */
+	n_rem = tb->insert_size[0] - tb->sbytes[i];
+	if (n_rem < 0)
+		n_rem = 0;
+
+	/* Append part of body into S_new[0] */
+	buffer_info_init_bh(tb, &bi, tb->S_new[i]);
+	if (n_rem > tb->zeroes_num) {
+		r_zeroes_number = 0;
+		r_body = body + n_rem - tb->zeroes_num;
+	} else {
+		r_body = body;
+		r_zeroes_number = tb->zeroes_num - n_rem;
+		tb->zeroes_num -= r_zeroes_number;
+	}
+
+	leaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem,
+			     r_body, r_zeroes_number);
+
+	tmp = item_head(tb->S_new[i], 0);
+	shift = 0;
+	if (is_indirect_le_ih(tmp)) {
+		set_ih_free_space(tmp, 0);
+		shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;
+	}
+	add_le_ih_k_offset(tmp, n_rem << shift);
+
+	tb->insert_size[0] = n_rem;
+	if (!n_rem)
+		tb->pos_in_item++;
+}
+
+static void balance_leaf_new_nodes_paste_whole(struct tree_balance *tb,
+					       struct item_head *ih,
+					       const char *body,
+					       struct item_head *insert_key,
+					       struct buffer_head **insert_ptr,
+					       int i)
+
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int n = B_NR_ITEMS(tbS0);
+	int leaf_mi;
+	struct item_head *pasted;
+	struct buffer_info bi;
 
 #ifdef CONFIG_REISERFS_CHECK
-					struct item_head *ih_check = item_head(tbS0, tb->item_pos);
-
-					if (!is_direntry_le_ih(ih_check)
-					    && (tb->pos_in_item != ih_item_len(ih_check)
-						|| tb->insert_size[0] <= 0))
-						reiserfs_panic(tb->tb_sb,
-							     "PAP-12235",
-							     "pos_in_item "
-							     "must be equal "
-							     "to ih_item_len");
-#endif				/* CONFIG_REISERFS_CHECK */
+	struct item_head *ih_check = item_head(tbS0, tb->item_pos);
 
-					leaf_mi = leaf_move_items(LEAF_FROM_S_TO_SNEW,
-							    tb, tb->snum[i],
-							    tb->sbytes[i],
-							    tb->S_new[i]);
-
-					RFALSE(leaf_mi,
-					       "PAP-12240: unexpected value returned by leaf_move_items (%d)",
-					       leaf_mi);
-
-					/* paste into item */
-					buffer_info_init_bh(tb, &bi, tb->S_new[i]);
-					leaf_paste_in_buffer(&bi,
-							     tb->item_pos - n + tb->snum[i],
-							     tb->pos_in_item,
-							     tb->insert_size[0],
-							     body, tb->zeroes_num);
-
-					pasted = item_head(tb->S_new[i], tb->item_pos - n + tb->snum[i]);
-					if (is_direntry_le_ih(pasted)) {
-						leaf_paste_entries(&bi,
-								   tb->item_pos - n + tb->snum[i],
-								   tb->pos_in_item, 1,
-								   (struct reiserfs_de_head *)body,
-								   body + DEH_SIZE,
-								   tb->insert_size[0]);
-					}
+	if (!is_direntry_le_ih(ih_check) &&
+	    (tb->pos_in_item != ih_item_len(ih_check) ||
+	    tb->insert_size[0] <= 0))
+		reiserfs_panic(tb->tb_sb,
+			     "PAP-12235",
+			     "pos_in_item must be equal to ih_item_len");
+#endif
 
-					/* if we paste to indirect item update ih_free_space */
-					if (is_indirect_le_ih(pasted))
-						set_ih_free_space(pasted, 0);
-					tb->zeroes_num = tb->insert_size[0] = 0;
-				}
-			}
+	leaf_mi = leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],
+				  tb->sbytes[i], tb->S_new[i]);
 
-			else {	/* pasted item doesn't fall into S_new[i] */
+	RFALSE(leaf_mi,
+	       "PAP-12240: unexpected value returned by leaf_move_items (%d)",
+	       leaf_mi);
 
-				leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-						tb->snum[i], tb->sbytes[i], tb->S_new[i]);
-			}
+	/* paste into item */
+	buffer_info_init_bh(tb, &bi, tb->S_new[i]);
+	leaf_paste_in_buffer(&bi, tb->item_pos - n + tb->snum[i],
+			     tb->pos_in_item, tb->insert_size[0],
+			     body, tb->zeroes_num);
+
+	pasted = item_head(tb->S_new[i], tb->item_pos - n +
+			   tb->snum[i]);
+	if (is_direntry_le_ih(pasted))
+		leaf_paste_entries(&bi, tb->item_pos - n + tb->snum[i],
+				   tb->pos_in_item, 1,
+				   (struct reiserfs_de_head *)body,
+				   body + DEH_SIZE, tb->insert_size[0]);
+
+	/* if we paste to indirect item update ih_free_space */
+	if (is_indirect_le_ih(pasted))
+		set_ih_free_space(pasted, 0);
+
+	tb->zeroes_num = tb->insert_size[0] = 0;
+
+}
+static void balance_leaf_new_nodes_paste(struct tree_balance *tb,
+					 struct item_head *ih,
+					 const char *body,
+					 struct item_head *insert_key,
+					 struct buffer_head **insert_ptr,
+					 int i)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int n = B_NR_ITEMS(tbS0);
+
+	/* pasted item doesn't fall into S_new[i] */
+	if (n - tb->snum[i] > tb->item_pos) {
+		leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
+				tb->snum[i], tb->sbytes[i], tb->S_new[i]);
+		return;
+	}
+
+	/* pasted item or part if it falls to S_new[i] */
 
+	if (tb->item_pos == n - tb->snum[i] && tb->sbytes[i] != -1)
+		/* we must shift part of the appended item */
+		balance_leaf_new_nodes_paste_shift(tb, ih, body, insert_key,
+						   insert_ptr, i);
+	else
+		/* item falls wholly into S_new[i] */
+		balance_leaf_new_nodes_paste_whole(tb, ih, body, insert_key,
+						   insert_ptr, i);
 }
 
 /* Fill new nodes that appear in place of S[0] */
@@ -1152,6 +1226,7 @@ static void balance_leaf_new_nodes(struct tree_balance *tb,
 {
 	int i;
 	for (i = tb->blknum[0] - 2; i >= 0; i--) {
+		BUG_ON(flag != M_INSERT && flag != M_PASTE);
 
 		RFALSE(!tb->snum[i],
 		       "PAP-12200: snum[%d] == %d. Must be > 0", i,
@@ -1164,21 +1239,12 @@ static void balance_leaf_new_nodes(struct tree_balance *tb,
 		/* initialized block type and tree level */
 		set_blkh_level(B_BLK_HEAD(tb->S_new[i]), DISK_LEAF_NODE_LEVEL);
 
-		switch (flag) {
-		case M_INSERT:	/* insert item */
+		if (flag == M_INSERT)
 			balance_leaf_new_nodes_insert(tb, ih, body, insert_key,
 						      insert_ptr, i);
-			break;
-
-		case M_PASTE:	/* append item */
+		else /* M_PASTE */
 			balance_leaf_new_nodes_paste(tb, ih, body, insert_key,
 						     insert_ptr, i);
-			break;
-		default:	/* cases d and t */
-			reiserfs_panic(tb->tb_sb, "PAP-12245",
-				       "blknum > 2: unexpected mode: %s(%d)",
-				       (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
-		}
 
 		memcpy(insert_key + i, leaf_key(tb->S_new[i], 0), KEY_SIZE);
 		insert_ptr[i] = tb->S_new[i];

commit 2369ecd8e81f7295b14f205ff49160fc5c1cfa93
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:59 2014 -0400

    reiserfs: balance_leaf refactor, format balance_leaf_paste_right
    
    Break up balance_leaf_paste_right into:
    balance_leaf_paste_right_shift
    balance_leaf_paste_right_shift_dirent
    balance_leaf_paste_right_whole
    
    and keep balance_leaf_paste_right as a handler to select which is appropriate.
    
    Also reformat to adhere to CodingStyle.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index fcebfca0bbb8..793fab7b9f02 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -706,155 +706,197 @@ static void balance_leaf_insert_right(struct tree_balance *tb,
 	}
 }
 
-static void balance_leaf_paste_right(struct tree_balance *tb,
+
+static void balance_leaf_paste_right_shift_dirent(struct tree_balance *tb,
 				     struct item_head *ih, const char *body)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
-	int n = B_NR_ITEMS(tbS0);
 	struct buffer_info bi;
-	int ret_val;
+	int entry_count;
 
-			if (n - tb->rnum[0] <= tb->item_pos) {	/* pasted item or part of it falls to R[0] */
-				if (tb->item_pos == n - tb->rnum[0] && tb->rbytes != -1) {	/* we must shift the part of the appended item */
-					if (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {	/* we append to directory item */
-						int entry_count;
+	RFALSE(zeroes_num,
+	       "PAP-12145: invalid parameter in case of a directory");
+	entry_count = ih_entry_count(item_head(tbS0, tb->item_pos));
 
-						RFALSE(tb->zeroes_num,
-						       "PAP-12145: invalid parameter in case of a directory");
-						entry_count = ih_entry_count(item_head
-								  (tbS0, tb->item_pos));
-						if (entry_count - tb->rbytes <
-						    tb->pos_in_item)
-							/* new directory entry falls into R[0] */
-						{
-							int paste_entry_position;
+	/* new directory entry falls into R[0] */
+	if (entry_count - tb->rbytes < tb->pos_in_item) {
+		int paste_entry_position;
 
-							RFALSE(tb->rbytes - 1 >= entry_count || !tb-> insert_size[0],
-							       "PAP-12150: no enough of entries to shift to R[0]: rbytes=%d, entry_count=%d",
-							       tb->rbytes, entry_count);
-							/* Shift rnum[0]-1 items in whole. Shift rbytes-1 directory entries from directory item number rnum[0] */
-							leaf_shift_right(tb, tb->rnum[0], tb->rbytes - 1);
-							/* Paste given directory entry to directory item */
-							paste_entry_position = tb->pos_in_item - entry_count + tb->rbytes - 1;
-							buffer_info_init_right(tb, &bi);
-							leaf_paste_in_buffer(&bi, 0, paste_entry_position, tb->insert_size[0], body, tb->zeroes_num);
-							/* paste entry */
-							leaf_paste_entries(&bi, 0, paste_entry_position, 1,
-									   (struct reiserfs_de_head *) body,
-									   body + DEH_SIZE, tb->insert_size[0]);
+		RFALSE(tb->rbytes - 1 >= entry_count || !tb->insert_size[0],
+		       "PAP-12150: no enough of entries to shift to R[0]: "
+		       "rbytes=%d, entry_count=%d", tb->rbytes, entry_count);
 
-							if (paste_entry_position == 0) {
-								/* change delimiting keys */
-								replace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0],0);
-							}
+		/*
+		 * Shift rnum[0]-1 items in whole.
+		 * Shift rbytes-1 directory entries from directory
+		 * item number rnum[0]
+		 */
+		leaf_shift_right(tb, tb->rnum[0], tb->rbytes - 1);
 
-							tb->insert_size[0] = 0;
-							tb->pos_in_item++;
-						} else {	/* new directory entry doesn't fall into R[0] */
+		/* Paste given directory entry to directory item */
+		paste_entry_position = tb->pos_in_item - entry_count +
+				       tb->rbytes - 1;
+		buffer_info_init_right(tb, &bi);
+		leaf_paste_in_buffer(&bi, 0, paste_entry_position,
+				     tb->insert_size[0], body, tb->zeroes_num);
 
-							leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
-						}
-					} else {	/* regular object */
+		/* paste entry */
+		leaf_paste_entries(&bi, 0, paste_entry_position, 1,
+				   (struct reiserfs_de_head *) body,
+				   body + DEH_SIZE, tb->insert_size[0]);
 
-						int n_shift, n_rem, r_zeroes_number;
-						const char *r_body;
+		/* change delimiting keys */
+		if (paste_entry_position == 0)
+			replace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);
 
-						/* Calculate number of bytes which must be shifted from appended item */
-						if ((n_shift = tb->rbytes - tb->insert_size[0]) < 0)
-							n_shift = 0;
+		tb->insert_size[0] = 0;
+		tb->pos_in_item++;
+	} else {
+		/* new directory entry doesn't fall into R[0] */
+		leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
+	}
+}
 
-						RFALSE(tb->pos_in_item != ih_item_len
-						       (item_head(tbS0, tb->item_pos)),
-						       "PAP-12155: invalid position to paste. ih_item_len=%d, pos_in_item=%d",
-						       tb->pos_in_item, ih_item_len
-						       (item_head(tbS0, tb->item_pos)));
+static void balance_leaf_paste_right_shift(struct tree_balance *tb,
+				     struct item_head *ih, const char *body)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int n_shift, n_rem, r_zeroes_number, version;
+	unsigned long temp_rem;
+	const char *r_body;
+	struct buffer_info bi;
 
-						leaf_shift_right(tb, tb->rnum[0], n_shift);
-						/* Calculate number of bytes which must remain in body after appending to R[0] */
-						if ((n_rem = tb->insert_size[0] - tb->rbytes) < 0)
-							n_rem = 0;
+	/* we append to directory item */
+	if (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {
+		balance_leaf_paste_right_shift_dirent(tb, ih, body);
+		return;
+	}
 
-						{
-							int version;
-							unsigned long temp_rem = n_rem;
+	/* regular object */
 
-							version = ih_version(item_head(tb->R[0], 0));
-							if (is_indirect_le_key(version, leaf_key(tb->R[0], 0))) {
-								temp_rem = n_rem << (tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT);
-							}
-							set_le_key_k_offset(version, leaf_key(tb->R[0], 0),
-							     le_key_k_offset(version, leaf_key(tb->R[0], 0)) + temp_rem);
-							set_le_key_k_offset(version, internal_key(tb->CFR[0], tb->rkey[0]),
-							     le_key_k_offset(version, internal_key(tb->CFR[0], tb->rkey[0])) + temp_rem);
-						}
-/*		  k_offset (leaf_key(tb->R[0],0)) += n_rem;
-		  k_offset (internal_key(tb->CFR[0],tb->rkey[0])) += n_rem;*/
-						do_balance_mark_internal_dirty(tb, tb->CFR[0], 0);
+	/*
+	 * Calculate number of bytes which must be shifted
+	 * from appended item
+	 */
+	n_shift = tb->rbytes - tb->insert_size[0];
+	if (n_shift < 0)
+		n_shift = 0;
 
-						/* Append part of body into R[0] */
-						buffer_info_init_right(tb, &bi);
-						if (n_rem > tb->zeroes_num) {
-							r_zeroes_number = 0;
-							r_body = body + n_rem - tb->zeroes_num;
-						} else {
-							r_body = body;
-							r_zeroes_number = tb->zeroes_num - n_rem;
-							tb->zeroes_num -= r_zeroes_number;
-						}
+	RFALSE(pos_in_item != ih_item_len(item_head(tbS0, item_pos)),
+	       "PAP-12155: invalid position to paste. ih_item_len=%d, "
+	       "pos_in_item=%d", pos_in_item,
+	       ih_item_len(item_head(tbS0, item_pos)));
 
-						leaf_paste_in_buffer(&bi, 0, n_shift,
-								     tb->insert_size[0] - n_rem,
-								     r_body, r_zeroes_number);
+	leaf_shift_right(tb, tb->rnum[0], n_shift);
 
-						if (is_indirect_le_ih(item_head(tb->R[0], 0))) {
-#if 0
-							RFALSE(n_rem,
-							       "PAP-12160: paste more than one unformatted node pointer");
-#endif
-							set_ih_free_space(item_head(tb->R[0], 0), 0);
-						}
-						tb->insert_size[0] = n_rem;
-						if (!n_rem)
-							tb->pos_in_item++;
-					}
-				} else {	/* pasted item in whole falls into R[0] */
+	/*
+	 * Calculate number of bytes which must remain in body
+	 * after appending to R[0]
+	 */
+	n_rem = tb->insert_size[0] - tb->rbytes;
+	if (n_rem < 0)
+		n_rem = 0;
 
-					struct item_head *pasted;
+	temp_rem = n_rem;
 
-					ret_val = leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
-					/* append item in R[0] */
-					if (tb->pos_in_item >= 0) {
-						buffer_info_init_right(tb, &bi);
-						leaf_paste_in_buffer(&bi, tb->item_pos - n + tb->rnum[0], tb->pos_in_item,
-								     tb->insert_size[0], body, tb->zeroes_num);
-					}
+	version = ih_version(item_head(tb->R[0], 0));
 
-					/* paste new entry, if item is directory item */
-					pasted = item_head(tb->R[0], tb->item_pos - n + tb->rnum[0]);
-					if (is_direntry_le_ih(pasted) && tb->pos_in_item >= 0) {
-						leaf_paste_entries(&bi, tb->item_pos - n + tb->rnum[0],
-								   tb->pos_in_item, 1,
-								   (struct reiserfs_de_head *) body,
-								   body + DEH_SIZE, tb->insert_size[0]);
-						if (!tb->pos_in_item) {
+	if (is_indirect_le_key(version, leaf_key(tb->R[0], 0))) {
+		int shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;
+		temp_rem = n_rem << shift;
+	}
 
-							RFALSE(tb->item_pos - n + tb->rnum[0],
-							       "PAP-12165: directory item must be first item of node when pasting is in 0th position");
+	add_le_key_k_offset(version, leaf_key(tb->R[0], 0), temp_rem);
+	add_le_key_k_offset(version, internal_key(tb->CFR[0], tb->rkey[0]),
+			    temp_rem);
 
-							/* update delimiting keys */
-							replace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);
-						}
-					}
+	do_balance_mark_internal_dirty(tb, tb->CFR[0], 0);
 
-					if (is_indirect_le_ih(pasted))
-						set_ih_free_space(pasted, 0);
-					tb->zeroes_num = tb->insert_size[0] = 0;
-				}
-			} else {	/* new item doesn't fall into R[0] */
+	/* Append part of body into R[0] */
+	buffer_info_init_right(tb, &bi);
+	if (n_rem > tb->zeroes_num) {
+		r_zeroes_number = 0;
+		r_body = body + n_rem - tb->zeroes_num;
+	} else {
+		r_body = body;
+		r_zeroes_number = tb->zeroes_num - n_rem;
+		tb->zeroes_num -= r_zeroes_number;
+	}
 
-				leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
-			}
+	leaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem,
+			     r_body, r_zeroes_number);
+
+	if (is_indirect_le_ih(item_head(tb->R[0], 0)))
+		set_ih_free_space(item_head(tb->R[0], 0), 0);
+
+	tb->insert_size[0] = n_rem;
+	if (!n_rem)
+		tb->pos_in_item++;
+}
+
+static void balance_leaf_paste_right_whole(struct tree_balance *tb,
+				     struct item_head *ih, const char *body)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int n = B_NR_ITEMS(tbS0);
+	struct item_head *pasted;
+	struct buffer_info bi;
+
+							buffer_info_init_right(tb, &bi);
+	leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
+
+	/* append item in R[0] */
+	if (tb->pos_in_item >= 0) {
+		buffer_info_init_right(tb, &bi);
+		leaf_paste_in_buffer(&bi, tb->item_pos - n + tb->rnum[0],
+				     tb->pos_in_item, tb->insert_size[0], body,
+				     tb->zeroes_num);
+	}
+
+	/* paste new entry, if item is directory item */
+	pasted = item_head(tb->R[0], tb->item_pos - n + tb->rnum[0]);
+	if (is_direntry_le_ih(pasted) && tb->pos_in_item >= 0) {
+		leaf_paste_entries(&bi, tb->item_pos - n + tb->rnum[0],
+				   tb->pos_in_item, 1,
+				   (struct reiserfs_de_head *)body,
+				   body + DEH_SIZE, tb->insert_size[0]);
+
+		if (!tb->pos_in_item) {
+
+			RFALSE(tb->item_pos - n + tb->rnum[0],
+			       "PAP-12165: directory item must be first "
+			       "item of node when pasting is in 0th position");
+
+			/* update delimiting keys */
+			replace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);
+		}
+	}
+
+	if (is_indirect_le_ih(pasted))
+		set_ih_free_space(pasted, 0);
+	tb->zeroes_num = tb->insert_size[0] = 0;
+}
+
+static void balance_leaf_paste_right(struct tree_balance *tb,
+				     struct item_head *ih, const char *body)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int n = B_NR_ITEMS(tbS0);
 
+	/* new item doesn't fall into R[0] */
+	if (n - tb->rnum[0] > tb->item_pos) {
+		leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
+		return;
+	}
+
+	/* pasted item or part of it falls to R[0] */
+
+	if (tb->item_pos == n - tb->rnum[0] && tb->rbytes != -1)
+		/* we must shift the part of the appended item */
+		balance_leaf_paste_right_shift(tb, ih, body);
+	else
+		/* pasted item in whole falls into R[0] */
+		balance_leaf_paste_right_whole(tb, ih, body);
 }
 
 /* shift rnum[0] items from S[0] to the right neighbor R[0] */
@@ -870,7 +912,6 @@ static void balance_leaf_right(struct tree_balance *tb, struct item_head *ih,
 		balance_leaf_insert_right(tb, ih, body);
 	else /* M_PASTE */
 		balance_leaf_paste_right(tb, ih, body);
-
 }
 
 static void balance_leaf_new_nodes_insert(struct tree_balance *tb,
@@ -1083,8 +1124,7 @@ static void balance_leaf_new_nodes_paste(struct tree_balance *tb,
 								   tb->pos_in_item, 1,
 								   (struct reiserfs_de_head *)body,
 								   body + DEH_SIZE,
-								   tb->insert_size[0]
-						    );
+								   tb->insert_size[0]);
 					}
 
 					/* if we paste to indirect item update ih_free_space */

commit 8dbf0d8c9ba6df7e8437244b5fa9648dca55ef11
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:58 2014 -0400

    reiserfs: balance_leaf refactor, format balance_leaf_insert_right
    
    Reformat balance_leaf_insert_right to adhere to CodingStyle.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 843c4023ad36..fcebfca0bbb8 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -626,71 +626,84 @@ static void balance_leaf_insert_right(struct tree_balance *tb,
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	int n = B_NR_ITEMS(tbS0);
 	struct buffer_info bi;
-	int ret_val;
-			if (n - tb->rnum[0] < tb->item_pos) {	/* new item or its part falls to R[0] */
-				if (tb->item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1) {	/* part of new item falls into R[0] */
-					loff_t old_key_comp, old_len, r_zeroes_number;
-					const char *r_body;
-					int version;
-					loff_t offset;
+	int ret;
 
-					leaf_shift_right(tb, tb->rnum[0] - 1, -1);
+	/* new item or part of it doesn't fall into R[0] */
+	if (n - tb->rnum[0] >= tb->item_pos) {
+		leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
+		return;
+	}
 
-					version = ih_version(ih);
-					/* Remember key component and item length */
-					old_key_comp = le_ih_k_offset(ih);
-					old_len = ih_item_len(ih);
+	/* new item or its part falls to R[0] */
 
-					/* Calculate key component and item length to insert into R[0] */
-					offset = le_ih_k_offset(ih) + ((old_len - tb->rbytes) << (is_indirect_le_ih(ih) ? tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT : 0));
-					set_le_ih_k_offset(ih, offset);
-					put_ih_item_len(ih, tb->rbytes);
-					/* Insert part of the item into R[0] */
-					buffer_info_init_right(tb, &bi);
-					if ((old_len - tb->rbytes) > tb->zeroes_num) {
-						r_zeroes_number = 0;
-						r_body = body + (old_len - tb->rbytes) - tb->zeroes_num;
-					} else {
-						r_body = body;
-						r_zeroes_number = tb->zeroes_num - (old_len - tb->rbytes);
-						tb->zeroes_num -= r_zeroes_number;
-					}
+	/* part of new item falls into R[0] */
+	if (tb->item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1) {
+		loff_t old_key_comp, old_len, r_zeroes_number;
+		const char *r_body;
+		int version, shift;
+		loff_t offset;
+
+		leaf_shift_right(tb, tb->rnum[0] - 1, -1);
 
-					leaf_insert_into_buf(&bi, 0, ih, r_body,
-							     r_zeroes_number);
+		version = ih_version(ih);
 
-					/* Replace right delimiting key by first key in R[0] */
-					replace_key(tb, tb->CFR[0], tb->rkey[0],
-						    tb->R[0], 0);
+		/* Remember key component and item length */
+		old_key_comp = le_ih_k_offset(ih);
+		old_len = ih_item_len(ih);
 
-					/* Calculate key component and item length to insert into S[0] */
-					set_le_ih_k_offset(ih, old_key_comp);
-					put_ih_item_len(ih, old_len - tb->rbytes);
+		/*
+		 * Calculate key component and item length to insert
+		 * into R[0]
+		 */
+		shift = 0;
+		if (is_indirect_le_ih(ih))
+			shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;
+		offset = le_ih_k_offset(ih) + ((old_len - tb->rbytes) << shift);
+		set_le_ih_k_offset(ih, offset);
+		put_ih_item_len(ih, tb->rbytes);
+
+		/* Insert part of the item into R[0] */
+		buffer_info_init_right(tb, &bi);
+		if ((old_len - tb->rbytes) > tb->zeroes_num) {
+			r_zeroes_number = 0;
+			r_body = body + (old_len - tb->rbytes) - tb->zeroes_num;
+		} else {
+			r_body = body;
+			r_zeroes_number = tb->zeroes_num -
+					  (old_len - tb->rbytes);
+			tb->zeroes_num -= r_zeroes_number;
+		}
 
-					tb->insert_size[0] -= tb->rbytes;
+		leaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);
 
-				} else {	/* whole new item falls into R[0] */
+		/* Replace right delimiting key by first key in R[0] */
+		replace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);
 
-					/* Shift rnum[0]-1 items to R[0] */
-					ret_val = leaf_shift_right(tb, tb->rnum[0] - 1, tb->rbytes);
-					/* Insert new item into R[0] */
-					buffer_info_init_right(tb, &bi);
-					leaf_insert_into_buf(&bi, tb->item_pos - n + tb->rnum[0] - 1,
-							     ih, body, tb->zeroes_num);
+		/*
+		 * Calculate key component and item length to
+		 * insert into S[0]
+		 */
+		set_le_ih_k_offset(ih, old_key_comp);
+		put_ih_item_len(ih, old_len - tb->rbytes);
 
-					if (tb->item_pos - n + tb->rnum[0] - 1 == 0) {
-						replace_key(tb, tb->CFR[0],
-							    tb->rkey[0],
-							    tb->R[0], 0);
+		tb->insert_size[0] -= tb->rbytes;
 
-					}
-					tb->zeroes_num = tb->insert_size[0] = 0;
-				}
-			} else {	/* new item or part of it doesn't fall into R[0] */
+	} else {
+		/* whole new item falls into R[0] */
 
-				leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
-			}
+		/* Shift rnum[0]-1 items to R[0] */
+		ret = leaf_shift_right(tb, tb->rnum[0] - 1, tb->rbytes);
+
+		/* Insert new item into R[0] */
+		buffer_info_init_right(tb, &bi);
+		leaf_insert_into_buf(&bi, tb->item_pos - n + tb->rnum[0] - 1,
+				     ih, body, tb->zeroes_num);
 
+		if (tb->item_pos - n + tb->rnum[0] - 1 == 0)
+			replace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);
+
+		tb->zeroes_num = tb->insert_size[0] = 0;
+	}
 }
 
 static void balance_leaf_paste_right(struct tree_balance *tb,

commit 3fade9377f44586845e82d542368cbf78471653c
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:57 2014 -0400

    reiserfs: balance_leaf refactor, format balance_leaf_paste_left
    
    Break up balance_leaf_paste_left into:
    balance_leaf_paste_left_shift
    balance_leaf_paste_left_shift_dirent
    balance_leaf_paste_left_whole
    
    and keep balance_leaf_paste_left as a handler to select which is appropriate.
    
    Also reformat to adhere to CodingStyle.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index cca685daf26d..843c4023ad36 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -355,164 +355,247 @@ static void balance_leaf_insert_left(struct tree_balance *tb,
 	}
 }
 
-static void balance_leaf_paste_left(struct tree_balance *tb,
-				    struct item_head *ih, const char *body)
+static void balance_leaf_paste_left_shift_dirent(struct tree_balance *tb,
+						 struct item_head *ih,
+						 const char *body)
 {
-	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
-	int ret_val;
+	int n = B_NR_ITEMS(tb->L[0]);
 	struct buffer_info bi;
+
+	RFALSE(tb->zeroes_num,
+	       "PAP-12090: invalid parameter in case of a directory");
+
+	/* directory item */
+	if (tb->lbytes > tb->pos_in_item) {
+		/* new directory entry falls into L[0] */
+		struct item_head *pasted;
+		int ret, l_pos_in_item = tb->pos_in_item;
+
+		/*
+		 * Shift lnum[0] - 1 items in whole.
+		 * Shift lbytes - 1 entries from given directory item
+		 */
+		ret = leaf_shift_left(tb, tb->lnum[0], tb->lbytes - 1);
+		if (ret && !tb->item_pos) {
+			pasted = item_head(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1);
+			l_pos_in_item += ih_entry_count(pasted) -
+					 (tb->lbytes - 1);
+		}
+
+		/* Append given directory entry to directory item */
+		buffer_info_init_left(tb, &bi);
+		leaf_paste_in_buffer(&bi, n + tb->item_pos - ret,
+				     l_pos_in_item, tb->insert_size[0],
+				     body, tb->zeroes_num);
+
+		/*
+		 * previous string prepared space for pasting new entry,
+		 * following string pastes this entry
+		 */
+
+		/*
+		 * when we have merge directory item, pos_in_item
+		 * has been changed too
+		 */
+
+		/* paste new directory entry. 1 is entry number */
+		leaf_paste_entries(&bi, n + tb->item_pos - ret,
+				   l_pos_in_item, 1,
+				   (struct reiserfs_de_head *) body,
+				   body + DEH_SIZE, tb->insert_size[0]);
+		tb->insert_size[0] = 0;
+	} else {
+		/* new directory item doesn't fall into L[0] */
+		/*
+		 * Shift lnum[0]-1 items in whole. Shift lbytes
+		 * directory entries from directory item number lnum[0]
+		 */
+		leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
+	}
+
+	/* Calculate new position to append in item body */
+	tb->pos_in_item -= tb->lbytes;
+}
+
+static void balance_leaf_paste_left_shift(struct tree_balance *tb,
+					  struct item_head *ih,
+					  const char *body)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	int n = B_NR_ITEMS(tb->L[0]);
+	struct buffer_info bi;
 
-				if (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {
-					/* we must shift the part of the appended item */
-					if (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {
+	if (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {
+		balance_leaf_paste_left_shift_dirent(tb, ih, body);
+		return;
+	}
 
-						RFALSE(tb->zeroes_num,
-						       "PAP-12090: invalid parameter in case of a directory");
-						/* directory item */
-						if (tb->lbytes > tb->pos_in_item) {
-							/* new directory entry falls into L[0] */
-							struct item_head *pasted;
-							int l_pos_in_item = tb->pos_in_item;
-
-							/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 entries from given directory item */
-							ret_val = leaf_shift_left(tb, tb->lnum[0], tb->lbytes-1);
-							if (ret_val && !tb->item_pos) {
-								pasted = item_head(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1);
-								l_pos_in_item += ih_entry_count(pasted) - (tb->lbytes -1);
-							}
+	RFALSE(tb->lbytes <= 0,
+	       "PAP-12095: there is nothing to shift to L[0]. "
+	       "lbytes=%d", tb->lbytes);
+	RFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)),
+	       "PAP-12100: incorrect position to paste: "
+	       "item_len=%d, pos_in_item=%d",
+	       ih_item_len(item_head(tbS0, tb->item_pos)), tb->pos_in_item);
 
-							/* Append given directory entry to directory item */
-							buffer_info_init_left(tb, &bi);
-							leaf_paste_in_buffer(&bi, n + tb->item_pos - ret_val, l_pos_in_item, tb->insert_size[0], body, tb->zeroes_num);
+	/* appended item will be in L[0] in whole */
+	if (tb->lbytes >= tb->pos_in_item) {
+		struct item_head *tbS0_pos_ih, *tbL0_ih;
+		struct item_head *tbS0_0_ih;
+		struct reiserfs_key *left_delim_key;
+		int ret, l_n, version, temp_l;
 
-							/* previous string prepared space for pasting new entry, following string pastes this entry */
+		tbS0_pos_ih = item_head(tbS0, tb->item_pos);
+		tbS0_0_ih = item_head(tbS0, 0);
 
-							/* when we have merge directory item, pos_in_item has been changed too */
+		/*
+		 * this bytes number must be appended
+		 * to the last item of L[h]
+		 */
+		l_n = tb->lbytes - tb->pos_in_item;
 
-							/* paste new directory entry. 1 is entry number */
-							leaf_paste_entries(&bi, n + tb->item_pos - ret_val, l_pos_in_item,
-									   1, (struct reiserfs_de_head *) body,
-									   body + DEH_SIZE, tb->insert_size[0]);
-							tb->insert_size[0] = 0;
-						} else {
-							/* new directory item doesn't fall into L[0] */
-							/* Shift lnum[0]-1 items in whole. Shift lbytes directory entries from directory item number lnum[0] */
-							leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
-						}
-						/* Calculate new position to append in item body */
-						tb->pos_in_item -= tb->lbytes;
-					} else {
-						/* regular object */
-						RFALSE(tb->lbytes <= 0, "PAP-12095: there is nothing to shift to L[0]. lbytes=%d", tb->lbytes);
-						RFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)),
-						       "PAP-12100: incorrect position to paste: item_len=%d, pos_in_item=%d",
-						       ih_item_len(item_head(tbS0, tb->item_pos)), tb->pos_in_item);
-
-						if (tb->lbytes >= tb->pos_in_item) {
-							/* appended item will be in L[0] in whole */
-							int l_n;
-
-							/* this bytes number must be appended to the last item of L[h] */
-							l_n = tb->lbytes - tb->pos_in_item;
-
-							/* Calculate new insert_size[0] */
-							tb->insert_size[0] -= l_n;
-
-							RFALSE(tb->insert_size[0] <= 0,
-							       "PAP-12105: there is nothing to paste into L[0]. insert_size=%d",
-							       tb->insert_size[0]);
-							ret_val = leaf_shift_left(tb, tb->lnum[0], ih_item_len
-									    (item_head(tbS0, tb->item_pos)));
-							/* Append to body of item in L[0] */
-							buffer_info_init_left(tb, &bi);
-							leaf_paste_in_buffer
-							    (&bi, n + tb->item_pos - ret_val, ih_item_len
-							     (item_head(tb->L[0], n + tb->item_pos - ret_val)),
-							     l_n, body,
-							     tb->zeroes_num > l_n ? l_n : tb->zeroes_num);
-							/* 0-th item in S0 can be only of DIRECT type when l_n != 0 */
-							{
-								int version;
-								int temp_l = l_n;
-
-								RFALSE(ih_item_len(item_head(tbS0, 0)),
-								     "PAP-12106: item length must be 0");
-								RFALSE(comp_short_le_keys(leaf_key(tbS0, 0), leaf_key
-								      (tb->L[0], n + tb->item_pos - ret_val)),
-								     "PAP-12107: items must be of the same file");
-								if (is_indirect_le_ih(item_head(tb->L[0], n + tb->item_pos - ret_val))) {
-									temp_l = l_n << (tb->tb_sb-> s_blocksize_bits - UNFM_P_SHIFT);
-								}
-								/* update key of first item in S0 */
-								version = ih_version(item_head(tbS0, 0));
-								set_le_key_k_offset(version, leaf_key(tbS0, 0),
-								     le_key_k_offset(version,leaf_key(tbS0, 0)) + temp_l);
-								/* update left delimiting key */
-								set_le_key_k_offset(version, internal_key(tb->CFL[0], tb->lkey[0]),
-								     le_key_k_offset(version, internal_key(tb->CFL[0], tb->lkey[0])) + temp_l);
-							}
+		/* Calculate new insert_size[0] */
+		tb->insert_size[0] -= l_n;
 
-							/* Calculate new body, position in item and insert_size[0] */
-							if (l_n > tb->zeroes_num) {
-								body += (l_n - tb->zeroes_num);
-								tb->zeroes_num = 0;
-							} else
-								tb->zeroes_num -= l_n;
-							tb->pos_in_item = 0;
+		RFALSE(tb->insert_size[0] <= 0,
+		       "PAP-12105: there is nothing to paste into "
+		       "L[0]. insert_size=%d", tb->insert_size[0]);
 
-							RFALSE(comp_short_le_keys(leaf_key(tbS0, 0), leaf_key(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1))
-							     || !op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size)
-							     || !op_is_left_mergeable(internal_key(tb->CFL[0], tb->lkey[0]), tbS0->b_size),
-							     "PAP-12120: item must be merge-able with left neighboring item");
-						} else {	/* only part of the appended item will be in L[0] */
+		ret = leaf_shift_left(tb, tb->lnum[0],
+				      ih_item_len(tbS0_pos_ih));
 
-							/* Calculate position in item for append in S[0] */
-							tb->pos_in_item -= tb->lbytes;
+		tbL0_ih = item_head(tb->L[0], n + tb->item_pos - ret);
 
-							RFALSE(tb->pos_in_item <= 0, "PAP-12125: no place for paste. pos_in_item=%d", tb->pos_in_item);
+		/* Append to body of item in L[0] */
+		buffer_info_init_left(tb, &bi);
+		leaf_paste_in_buffer(&bi, n + tb->item_pos - ret,
+				     ih_item_len(tbL0_ih), l_n, body,
+				     min_t(int, l_n, tb->zeroes_num));
 
-							/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
-							leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
-						}
-					}
-				} else {	/* appended item will be in L[0] in whole */
+		/*
+		 * 0-th item in S0 can be only of DIRECT type
+		 * when l_n != 0
+		 */
+		temp_l = l_n;
 
-					struct item_head *pasted;
+		RFALSE(ih_item_len(tbS0_0_ih),
+		       "PAP-12106: item length must be 0");
+		RFALSE(comp_short_le_keys(&tbS0_0_ih->ih_key,
+		       leaf_key(tb->L[0], n + tb->item_pos - ret)),
+		       "PAP-12107: items must be of the same file");
 
-					if (!tb->item_pos && op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size)) {	/* if we paste into first item of S[0] and it is left mergable */
-						/* then increment pos_in_item by the size of the last item in L[0] */
-						pasted = item_head(tb->L[0], n - 1);
-						if (is_direntry_le_ih(pasted))
-							tb->pos_in_item += ih_entry_count(pasted);
-						else
-							tb->pos_in_item += ih_item_len(pasted);
-					}
+		if (is_indirect_le_ih(tbL0_ih)) {
+			int shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;
+			temp_l = l_n << shift;
+		}
+		/* update key of first item in S0 */
+		version = ih_version(tbS0_0_ih);
+		add_le_key_k_offset(version, &tbS0_0_ih->ih_key, temp_l);
 
-					/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
-					ret_val = leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
-					/* Append to body of item in L[0] */
-					buffer_info_init_left(tb, &bi);
-					leaf_paste_in_buffer(&bi, n + tb->item_pos - ret_val,
-							     tb->pos_in_item,
-							     tb->insert_size[0],
-							     body, tb->zeroes_num);
+		/* update left delimiting key */
+		left_delim_key = internal_key(tb->CFL[0], tb->lkey[0]);
+		add_le_key_k_offset(version, left_delim_key, temp_l);
 
-					/* if appended item is directory, paste entry */
-					pasted = item_head(tb->L[0], n + tb->item_pos - ret_val);
-					if (is_direntry_le_ih(pasted))
-						leaf_paste_entries(&bi, n + tb->item_pos - ret_val,
-								   tb->pos_in_item, 1,
-								   (struct reiserfs_de_head *) body,
-								   body + DEH_SIZE,
-								   tb->insert_size[0]);
-					/* if appended item is indirect item, put unformatted node into un list */
-					if (is_indirect_le_ih(pasted))
-						set_ih_free_space(pasted, 0);
-					tb->insert_size[0] = 0;
-					tb->zeroes_num = 0;
-				}
+		/*
+		 * Calculate new body, position in item and
+		 * insert_size[0]
+		 */
+		if (l_n > tb->zeroes_num) {
+			body += (l_n - tb->zeroes_num);
+			tb->zeroes_num = 0;
+		} else
+			tb->zeroes_num -= l_n;
+		tb->pos_in_item = 0;
+
+		RFALSE(comp_short_le_keys(&tbS0_0_ih->ih_key,
+					  leaf_key(tb->L[0],
+						 B_NR_ITEMS(tb->L[0]) - 1)) ||
+		       !op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size) ||
+		       !op_is_left_mergeable(left_delim_key, tbS0->b_size),
+		       "PAP-12120: item must be merge-able with left "
+		       "neighboring item");
+	} else {
+		/* only part of the appended item will be in L[0] */
+
+		/* Calculate position in item for append in S[0] */
+		tb->pos_in_item -= tb->lbytes;
 
+		RFALSE(tb->pos_in_item <= 0,
+		       "PAP-12125: no place for paste. pos_in_item=%d",
+		       tb->pos_in_item);
+
+		/*
+		 * Shift lnum[0] - 1 items in whole.
+		 * Shift lbytes - 1 byte from item number lnum[0]
+		 */
+		leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
+	}
+}
+
+
+/* appended item will be in L[0] in whole */
+static void balance_leaf_paste_left_whole(struct tree_balance *tb,
+					  struct item_head *ih,
+					  const char *body)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int n = B_NR_ITEMS(tb->L[0]);
+	struct buffer_info bi;
+	struct item_head *pasted;
+	int ret;
+
+	/* if we paste into first item of S[0] and it is left mergable */
+	if (!tb->item_pos &&
+	    op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size)) {
+		/*
+		 * then increment pos_in_item by the size of the
+		 * last item in L[0]
+		 */
+		pasted = item_head(tb->L[0], n - 1);
+		if (is_direntry_le_ih(pasted))
+			tb->pos_in_item += ih_entry_count(pasted);
+		else
+			tb->pos_in_item += ih_item_len(pasted);
+	}
+
+	/*
+	 * Shift lnum[0] - 1 items in whole.
+	 * Shift lbytes - 1 byte from item number lnum[0]
+	 */
+	ret = leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
+
+	/* Append to body of item in L[0] */
+	buffer_info_init_left(tb, &bi);
+	leaf_paste_in_buffer(&bi, n + tb->item_pos - ret, tb->pos_in_item,
+			     tb->insert_size[0], body, tb->zeroes_num);
+
+	/* if appended item is directory, paste entry */
+	pasted = item_head(tb->L[0], n + tb->item_pos - ret);
+	if (is_direntry_le_ih(pasted))
+		leaf_paste_entries(&bi, n + tb->item_pos - ret,
+				   tb->pos_in_item, 1,
+				   (struct reiserfs_de_head *)body,
+				   body + DEH_SIZE, tb->insert_size[0]);
+
+	/*
+	 * if appended item is indirect item, put unformatted node
+	 * into un list
+	 */
+	if (is_indirect_le_ih(pasted))
+		set_ih_free_space(pasted, 0);
+
+	tb->insert_size[0] = 0;
+	tb->zeroes_num = 0;
+}
+
+static void balance_leaf_paste_left(struct tree_balance *tb,
+				    struct item_head *ih, const char *body)
+{
+	/* we must shift the part of the appended item */
+	if (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1)
+		balance_leaf_paste_left_shift(tb, ih, body);
+	else
+		balance_leaf_paste_left_whole(tb, ih, body);
 }
 
 /* Shift lnum[0] items from S[0] to the left neighbor L[0] */

commit 4bf4de6bc45a6b1cfa6af6cf235480287c8784fb
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:56 2014 -0400

    reiserfs: balance_leaf refactor, format balance_leaf_insert_left
    
    Reformat balance_leaf_insert_left to adhere to CodingStyle.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index b7085b7e7524..cca685daf26d 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -293,59 +293,66 @@ static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 static void balance_leaf_insert_left(struct tree_balance *tb,
 				     struct item_head *ih, const char *body)
 {
-	int ret_val;
+	int ret;
 	struct buffer_info bi;
 	int n = B_NR_ITEMS(tb->L[0]);
 
-				if (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {
-					/* part of new item falls into L[0] */
-					int new_item_len;
-					int version;
+	if (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {
+		/* part of new item falls into L[0] */
+		int new_item_len, shift;
+		int version;
 
-					ret_val = leaf_shift_left(tb, tb->lnum[0] - 1, -1);
+		ret = leaf_shift_left(tb, tb->lnum[0] - 1, -1);
 
-					/* Calculate item length to insert to S[0] */
-					new_item_len = ih_item_len(ih) - tb->lbytes;
-					/* Calculate and check item length to insert to L[0] */
-					put_ih_item_len(ih, ih_item_len(ih) - new_item_len);
+		/* Calculate item length to insert to S[0] */
+		new_item_len = ih_item_len(ih) - tb->lbytes;
 
-					RFALSE(ih_item_len(ih) <= 0,
-					       "PAP-12080: there is nothing to insert into L[0]: ih_item_len=%d",
-					       ih_item_len(ih));
+		/* Calculate and check item length to insert to L[0] */
+		put_ih_item_len(ih, ih_item_len(ih) - new_item_len);
 
-					/* Insert new item into L[0] */
-					buffer_info_init_left(tb, &bi);
-					leaf_insert_into_buf(&bi,
-							n + tb->item_pos - ret_val, ih, body,
-							tb->zeroes_num > ih_item_len(ih) ? ih_item_len(ih) : tb->zeroes_num);
+		RFALSE(ih_item_len(ih) <= 0,
+		       "PAP-12080: there is nothing to insert into L[0]: "
+		       "ih_item_len=%d", ih_item_len(ih));
 
-					version = ih_version(ih);
+		/* Insert new item into L[0] */
+		buffer_info_init_left(tb, &bi);
+		leaf_insert_into_buf(&bi, n + tb->item_pos - ret, ih, body,
+			     min_t(int, tb->zeroes_num, ih_item_len(ih)));
 
-					/* Calculate key component, item length and body to insert into S[0] */
-					set_le_ih_k_offset(ih, le_ih_k_offset(ih) +
-							(tb->lbytes << (is_indirect_le_ih(ih) ? tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT : 0)));
-
-					put_ih_item_len(ih, new_item_len);
-					if (tb->lbytes > tb->zeroes_num) {
-						body += (tb->lbytes - tb->zeroes_num);
-						tb->zeroes_num = 0;
-					} else
-						tb->zeroes_num -= tb->lbytes;
-
-					RFALSE(ih_item_len(ih) <= 0,
-					       "PAP-12085: there is nothing to insert into S[0]: ih_item_len=%d",
-					       ih_item_len(ih));
-				} else {
-					/* new item in whole falls into L[0] */
-					/* Shift lnum[0]-1 items to L[0] */
-					ret_val = leaf_shift_left(tb, tb->lnum[0] - 1, tb->lbytes);
-					/* Insert new item into L[0] */
-					buffer_info_init_left(tb, &bi);
-					leaf_insert_into_buf(&bi, n + tb->item_pos - ret_val, ih, body, tb->zeroes_num);
-					tb->insert_size[0] = 0;
-					tb->zeroes_num = 0;
-				}
+		version = ih_version(ih);
 
+		/*
+		 * Calculate key component, item length and body to
+		 * insert into S[0]
+		 */
+		shift = 0;
+		if (is_indirect_le_ih(ih))
+			shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;
+
+		add_le_ih_k_offset(ih, tb->lbytes << shift);
+
+		put_ih_item_len(ih, new_item_len);
+		if (tb->lbytes > tb->zeroes_num) {
+			body += (tb->lbytes - tb->zeroes_num);
+			tb->zeroes_num = 0;
+		} else
+			tb->zeroes_num -= tb->lbytes;
+
+		RFALSE(ih_item_len(ih) <= 0,
+		       "PAP-12085: there is nothing to insert into S[0]: "
+		       "ih_item_len=%d", ih_item_len(ih));
+	} else {
+		/* new item in whole falls into L[0] */
+		/* Shift lnum[0]-1 items to L[0] */
+		ret = leaf_shift_left(tb, tb->lnum[0] - 1, tb->lbytes);
+
+		/* Insert new item into L[0] */
+		buffer_info_init_left(tb, &bi);
+		leaf_insert_into_buf(&bi, n + tb->item_pos - ret, ih, body,
+				     tb->zeroes_num);
+		tb->insert_size[0] = 0;
+		tb->zeroes_num = 0;
+	}
 }
 
 static void balance_leaf_paste_left(struct tree_balance *tb,

commit 0080e9f9d3ac717537dbd6db1fc8ef72ce0b9cc1
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:55 2014 -0400

    reiserfs: balance_leaf refactor, pull out balance_leaf{left, right, new_nodes, finish_node}
    
    Break out the code that splits paste/insert for each phase.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 18adf948aa80..b7085b7e7524 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -508,6 +508,27 @@ static void balance_leaf_paste_left(struct tree_balance *tb,
 
 }
 
+/* Shift lnum[0] items from S[0] to the left neighbor L[0] */
+static void balance_leaf_left(struct tree_balance *tb, struct item_head *ih,
+			      const char *body, int flag)
+{
+	if (tb->lnum[0] <= 0)
+		return;
+
+	/* new item or it part falls to L[0], shift it too */
+	if (tb->item_pos < tb->lnum[0]) {
+		BUG_ON(flag != M_INSERT && flag != M_PASTE);
+
+		if (flag == M_INSERT)
+			balance_leaf_insert_left(tb, ih, body);
+		else /* M_PASTE */
+			balance_leaf_paste_left(tb, ih, body);
+	} else
+		/* new item doesn't fall into L[0] */
+		leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
+}
+
+
 static void balance_leaf_insert_right(struct tree_balance *tb,
 				      struct item_head *ih, const char *body)
 {
@@ -733,6 +754,22 @@ static void balance_leaf_paste_right(struct tree_balance *tb,
 
 }
 
+/* shift rnum[0] items from S[0] to the right neighbor R[0] */
+static void balance_leaf_right(struct tree_balance *tb, struct item_head *ih,
+			       const char *body, int flag)
+{
+	if (tb->rnum[0] <= 0)
+		return;
+
+	BUG_ON(flag != M_INSERT && flag != M_PASTE);
+
+	if (flag == M_INSERT)
+		balance_leaf_insert_right(tb, ih, body);
+	else /* M_PASTE */
+		balance_leaf_paste_right(tb, ih, body);
+
+}
+
 static void balance_leaf_new_nodes_insert(struct tree_balance *tb,
 					  struct item_head *ih,
 					  const char *body,
@@ -962,6 +999,55 @@ static void balance_leaf_new_nodes_paste(struct tree_balance *tb,
 
 }
 
+/* Fill new nodes that appear in place of S[0] */
+static void balance_leaf_new_nodes(struct tree_balance *tb,
+				   struct item_head *ih,
+				   const char *body,
+				   struct item_head *insert_key,
+				   struct buffer_head **insert_ptr,
+				   int flag)
+{
+	int i;
+	for (i = tb->blknum[0] - 2; i >= 0; i--) {
+
+		RFALSE(!tb->snum[i],
+		       "PAP-12200: snum[%d] == %d. Must be > 0", i,
+		       tb->snum[i]);
+
+		/* here we shift from S to S_new nodes */
+
+		tb->S_new[i] = get_FEB(tb);
+
+		/* initialized block type and tree level */
+		set_blkh_level(B_BLK_HEAD(tb->S_new[i]), DISK_LEAF_NODE_LEVEL);
+
+		switch (flag) {
+		case M_INSERT:	/* insert item */
+			balance_leaf_new_nodes_insert(tb, ih, body, insert_key,
+						      insert_ptr, i);
+			break;
+
+		case M_PASTE:	/* append item */
+			balance_leaf_new_nodes_paste(tb, ih, body, insert_key,
+						     insert_ptr, i);
+			break;
+		default:	/* cases d and t */
+			reiserfs_panic(tb->tb_sb, "PAP-12245",
+				       "blknum > 2: unexpected mode: %s(%d)",
+				       (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
+		}
+
+		memcpy(insert_key + i, leaf_key(tb->S_new[i], 0), KEY_SIZE);
+		insert_ptr[i] = tb->S_new[i];
+
+		RFALSE(!buffer_journaled(tb->S_new[i])
+		       || buffer_journal_dirty(tb->S_new[i])
+		       || buffer_dirty(tb->S_new[i]),
+		       "PAP-12247: S_new[%d] : (%b)",
+		       i, format_bh(tb->S_new[i]));
+	}
+}
+
 static void balance_leaf_finish_node_insert(struct tree_balance *tb,
 					    struct item_head *ih,
 					    const char *body)
@@ -1058,6 +1144,24 @@ static void balance_leaf_finish_node_paste(struct tree_balance *tb,
 				}
 }
 
+/*
+ * if the affected item was not wholly shifted then we
+ * perform all necessary operations on that part or whole
+ * of the affected item which remains in S
+ */
+static void balance_leaf_finish_node(struct tree_balance *tb,
+				      struct item_head *ih,
+				      const char *body, int flag)
+{
+	/* if we must insert or append into buffer S[0] */
+	if (0 <= tb->item_pos && tb->item_pos < tb->s0num) {
+		if (flag == M_INSERT)
+			balance_leaf_finish_node_insert(tb, ih, body);
+		else /* M_PASTE */
+			balance_leaf_finish_node_paste(tb, ih, body);
+	}
+}
+
 /**
  * balance_leaf - reiserfs tree balancing algorithm
  * @tb: tree balance state
@@ -1078,7 +1182,6 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 			struct buffer_head **insert_ptr)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
-	int n, i;
 
 	PROC_INFO_INC(tb->tb_sb, balance_at[0]);
 
@@ -1100,55 +1203,13 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 	    && is_indirect_le_ih(item_head(tbS0, tb->item_pos)))
 		tb->pos_in_item *= UNFM_P_SIZE;
 
-	if (tb->lnum[0] > 0) {
-		/* Shift lnum[0] items from S[0] to the left neighbor L[0] */
-		if (tb->item_pos < tb->lnum[0]) {
-			/* new item or it part falls to L[0], shift it too */
-			n = B_NR_ITEMS(tb->L[0]);
-
-			switch (flag) {
-			case M_INSERT:	/* insert item into L[0] */
-				balance_leaf_insert_left(tb, ih, body);
-				break;
-
-			case M_PASTE:	/* append item in L[0] */
-				balance_leaf_paste_left(tb, ih, body);
-				break;
-			default:	/* cases d and t */
-				reiserfs_panic(tb->tb_sb, "PAP-12130",
-					       "lnum > 0: unexpected mode: "
-					       " %s(%d)",
-					       (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
-			}
-		} else {
-			/* new item doesn't fall into L[0] */
-			leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
-		}
-	}
+	balance_leaf_left(tb, ih, body, flag);
 
 	/* tb->lnum[0] > 0 */
 	/* Calculate new item position */
 	tb->item_pos -= (tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0));
 
-	if (tb->rnum[0] > 0) {
-		/* shift rnum[0] items from S[0] to the right neighbor R[0] */
-		n = B_NR_ITEMS(tbS0);
-		switch (flag) {
-
-		case M_INSERT:	/* insert item */
-			balance_leaf_insert_right(tb, ih, body);
-			break;
-
-		case M_PASTE:	/* append item */
-			balance_leaf_paste_right(tb, ih, body);
-			break;
-		default:	/* cases d and t */
-			reiserfs_panic(tb->tb_sb, "PAP-12175",
-				       "rnum > 0: unexpected mode: %s(%d)",
-				       (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
-		}
-
-	}
+	balance_leaf_right(tb, ih, body, flag);
 
 	/* tb->rnum[0] > 0 */
 	RFALSE(tb->blknum[0] > 3,
@@ -1183,62 +1244,10 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 		return 0;
 	}
 
-	/* Fill new nodes that appear in place of S[0] */
-	for (i = tb->blknum[0] - 2; i >= 0; i--) {
-
-		RFALSE(!tb->snum[i],
-		       "PAP-12200: snum[%d] == %d. Must be > 0", i,
-		       tb->snum[i]);
-
-		/* here we shift from S to S_new nodes */
-
-		tb->S_new[i] = get_FEB(tb);
-
-		/* initialized block type and tree level */
-		set_blkh_level(B_BLK_HEAD(tb->S_new[i]), DISK_LEAF_NODE_LEVEL);
-
-		n = B_NR_ITEMS(tbS0);
-
-		switch (flag) {
-		case M_INSERT:	/* insert item */
-			balance_leaf_new_nodes_insert(tb, ih, body, insert_key,
-						      insert_ptr, i);
-			break;
-
-		case M_PASTE:	/* append item */
-			balance_leaf_new_nodes_paste(tb, ih, body, insert_key,
-						     insert_ptr, i);
-			break;
-		default:	/* cases d and t */
-			reiserfs_panic(tb->tb_sb, "PAP-12245",
-				       "blknum > 2: unexpected mode: %s(%d)",
-				       (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
-		}
-
-		memcpy(insert_key + i, leaf_key(tb->S_new[i], 0), KEY_SIZE);
-		insert_ptr[i] = tb->S_new[i];
-
-		RFALSE(!buffer_journaled(tb->S_new[i])
-		       || buffer_journal_dirty(tb->S_new[i])
-		       || buffer_dirty(tb->S_new[i]),
-		       "PAP-12247: S_new[%d] : (%b)",
-		       i, tb->S_new[i]);
-	}
-
-	/* if the affected item was not wholly shifted then we perform all necessary operations on that part or whole of the
-	   affected item which remains in S */
-	if (0 <= tb->item_pos && tb->item_pos < tb->s0num) {	/* if we must insert or append into buffer S[0] */
+	balance_leaf_new_nodes(tb, ih, body, insert_key, insert_ptr, flag);
 
-		switch (flag) {
-		case M_INSERT:	/* insert item into S[0] */
-			balance_leaf_finish_node_insert(tb, ih, body);
-			break;
+	balance_leaf_finish_node(tb, ih, body, flag);
 
-		case M_PASTE:	/* append item in S[0] */
-			balance_leaf_finish_node_paste(tb, ih, body);
-			break;
-		}
-	}
 #ifdef CONFIG_REISERFS_CHECK
 	if (flag == M_PASTE && tb->insert_size[0]) {
 		print_cur_tb("12290");

commit 7f447ba825a0752c0450ebd129f187484e86fe8b
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:54 2014 -0400

    reiserfs: balance_leaf refactor, pull out balance_leaf_finish_node_paste
    
    This patch factors out a new balance_leaf_finish_node_paste from the code
    in balance_leaf responsible for pasting new content into existing items
    held in S[0].
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 1c4b45993c79..18adf948aa80 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -982,6 +982,82 @@ static void balance_leaf_finish_node_insert(struct tree_balance *tb,
 			}
 }
 
+static void balance_leaf_finish_node_paste(struct tree_balance *tb,
+					   struct item_head *ih,
+					   const char *body)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	struct buffer_info bi;
+				struct item_head *pasted;
+
+				pasted = item_head(tbS0, tb->item_pos);
+				/* when directory, may be new entry already pasted */
+				if (is_direntry_le_ih(pasted)) {
+					if (tb->pos_in_item >= 0 && tb->pos_in_item <= ih_entry_count(pasted)) {
+
+						RFALSE(!tb->insert_size[0],
+						       "PAP-12260: insert_size is 0 already");
+
+						/* prepare space */
+						buffer_info_init_tbS0(tb, &bi);
+						leaf_paste_in_buffer(&bi, tb->item_pos, tb->pos_in_item,
+								     tb->insert_size[0], body,
+								     tb->zeroes_num);
+
+						/* paste entry */
+						leaf_paste_entries(&bi, tb->item_pos, tb->pos_in_item, 1,
+								   (struct reiserfs_de_head *)body,
+								   body + DEH_SIZE,
+								   tb->insert_size[0]);
+						if (!tb->item_pos && !tb->pos_in_item) {
+							RFALSE(!tb->CFL[0] || !tb->L[0],
+							       "PAP-12270: CFL[0]/L[0] must be specified");
+							if (tb->CFL[0])
+								replace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);
+						}
+						tb->insert_size[0] = 0;
+					}
+				} else {	/* regular object */
+					if (tb->pos_in_item == ih_item_len(pasted)) {
+
+						RFALSE(tb->insert_size[0] <= 0,
+						       "PAP-12275: insert size must not be %d",
+						       tb->insert_size[0]);
+						buffer_info_init_tbS0(tb, &bi);
+						leaf_paste_in_buffer(&bi, tb->item_pos, tb->pos_in_item,
+								     tb->insert_size[0], body, tb->zeroes_num);
+
+						if (is_indirect_le_ih(pasted)) {
+#if 0
+							RFALSE(tb->
+							       insert_size[0] !=
+							       UNFM_P_SIZE,
+							       "PAP-12280: insert_size for indirect item must be %d, not %d",
+							       UNFM_P_SIZE,
+							       tb->
+							       insert_size[0]);
+#endif
+							set_ih_free_space(pasted, 0);
+						}
+						tb->insert_size[0] = 0;
+					}
+#ifdef CONFIG_REISERFS_CHECK
+					else {
+						if (tb->insert_size[0]) {
+							print_cur_tb("12285");
+							reiserfs_panic(tb->tb_sb,
+							    "PAP-12285",
+							    "insert_size "
+							    "must be 0 "
+							    "(%d)",
+							    tb->insert_size[0]);
+						}
+					}
+#endif				/* CONFIG_REISERFS_CHECK */
+
+				}
+}
+
 /**
  * balance_leaf - reiserfs tree balancing algorithm
  * @tb: tree balance state
@@ -1002,7 +1078,6 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 			struct buffer_head **insert_ptr)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
-	struct buffer_info bi;
 	int n, i;
 
 	PROC_INFO_INC(tb->tb_sb, balance_at[0]);
@@ -1159,76 +1234,9 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 			balance_leaf_finish_node_insert(tb, ih, body);
 			break;
 
-		case M_PASTE:{	/* append item in S[0] */
-				struct item_head *pasted;
-
-				pasted = item_head(tbS0, tb->item_pos);
-				/* when directory, may be new entry already pasted */
-				if (is_direntry_le_ih(pasted)) {
-					if (tb->pos_in_item >= 0 && tb->pos_in_item <= ih_entry_count(pasted)) {
-
-						RFALSE(!tb->insert_size[0],
-						       "PAP-12260: insert_size is 0 already");
-
-						/* prepare space */
-						buffer_info_init_tbS0(tb, &bi);
-						leaf_paste_in_buffer(&bi, tb->item_pos, tb->pos_in_item,
-								     tb->insert_size[0], body,
-								     tb->zeroes_num);
-
-						/* paste entry */
-						leaf_paste_entries(&bi, tb->item_pos, tb->pos_in_item, 1,
-								   (struct reiserfs_de_head *)body,
-								   body + DEH_SIZE,
-								   tb->insert_size[0]);
-						if (!tb->item_pos && !tb->pos_in_item) {
-							RFALSE(!tb->CFL[0] || !tb->L[0],
-							       "PAP-12270: CFL[0]/L[0] must be specified");
-							if (tb->CFL[0])
-								replace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);
-						}
-						tb->insert_size[0] = 0;
-					}
-				} else {	/* regular object */
-					if (tb->pos_in_item == ih_item_len(pasted)) {
-
-						RFALSE(tb->insert_size[0] <= 0,
-						       "PAP-12275: insert size must not be %d",
-						       tb->insert_size[0]);
-						buffer_info_init_tbS0(tb, &bi);
-						leaf_paste_in_buffer(&bi, tb->item_pos, tb->pos_in_item,
-								     tb->insert_size[0], body, tb->zeroes_num);
-
-						if (is_indirect_le_ih(pasted)) {
-#if 0
-							RFALSE(tb->
-							       insert_size[0] !=
-							       UNFM_P_SIZE,
-							       "PAP-12280: insert_size for indirect item must be %d, not %d",
-							       UNFM_P_SIZE,
-							       tb->
-							       insert_size[0]);
-#endif
-							set_ih_free_space(pasted, 0);
-						}
-						tb->insert_size[0] = 0;
-					}
-#ifdef CONFIG_REISERFS_CHECK
-					else {
-						if (tb->insert_size[0]) {
-							print_cur_tb("12285");
-							reiserfs_panic(tb->tb_sb,
-							    "PAP-12285",
-							    "insert_size "
-							    "must be 0 "
-							    "(%d)",
-							    tb->insert_size[0]);
-						}
-					}
-#endif				/* CONFIG_REISERFS_CHECK */
-
-				}
-			}	/* case M_PASTE: */
+		case M_PASTE:	/* append item in S[0] */
+			balance_leaf_finish_node_paste(tb, ih, body);
+			break;
 		}
 	}
 #ifdef CONFIG_REISERFS_CHECK

commit 8c480ea1940ffad74af3bb0db8885e413e6aee0a
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:53 2014 -0400

    reiserfs: balance_leaf refactor pull out balance_leaf_finish_node_insert
    
    This patch factors out a new balance_leaf_finish_node_insert from the code
    in balance_leaf responsible for inserting new items into S[0]
    
    It has not been reformatted yet.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index db189cbfdaba..1c4b45993c79 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -962,6 +962,26 @@ static void balance_leaf_new_nodes_paste(struct tree_balance *tb,
 
 }
 
+static void balance_leaf_finish_node_insert(struct tree_balance *tb,
+					    struct item_head *ih,
+					    const char *body)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	struct buffer_info bi;
+			buffer_info_init_tbS0(tb, &bi);
+			leaf_insert_into_buf(&bi, tb->item_pos, ih,
+					     body, tb->zeroes_num);
+
+			/*
+			 * If we insert the first key
+			 * change the delimiting key
+			 */
+			if (tb->item_pos == 0) {
+				if (tb->CFL[0])	/* can be 0 in reiserfsck */
+					replace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);
+			}
+}
+
 /**
  * balance_leaf - reiserfs tree balancing algorithm
  * @tb: tree balance state
@@ -1136,15 +1156,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 
 		switch (flag) {
 		case M_INSERT:	/* insert item into S[0] */
-			buffer_info_init_tbS0(tb, &bi);
-			leaf_insert_into_buf(&bi, tb->item_pos, ih,
-					     body, tb->zeroes_num);
-
-			/* If we insert the first key change the delimiting key */
-			if (tb->item_pos == 0) {
-				if (tb->CFL[0])	/* can be 0 in reiserfsck */
-					replace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);
-			}
+			balance_leaf_finish_node_insert(tb, ih, body);
 			break;
 
 		case M_PASTE:{	/* append item in S[0] */

commit 9d496552b95e957b919f9934672ea1af6c0f3c6d
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:52 2014 -0400

    reiserfs: balance_leaf refactor, pull out balance_leaf_new_nodes_paste
    
    This patch factors out a new balance_leaf_new_nodes_insert from the code
    in balance_leaf responsible for pasting new content into existing items
    that may have been shifted into new nodes in the tree.
    
    It has not been reformatted yet.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index c2c5ba77cfe0..db189cbfdaba 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -804,6 +804,164 @@ static void balance_leaf_new_nodes_insert(struct tree_balance *tb,
 			}
 }
 
+static void balance_leaf_new_nodes_paste(struct tree_balance *tb,
+					 struct item_head *ih,
+					 const char *body,
+					 struct item_head *insert_key,
+					 struct buffer_head **insert_ptr,
+					 int i)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int n = B_NR_ITEMS(tbS0);
+	struct buffer_info bi;
+			if (n - tb->snum[i] <= tb->item_pos) {	/* pasted item or part if it falls to S_new[i] */
+				if (tb->item_pos == n - tb->snum[i] && tb->sbytes[i] != -1) {	/* we must shift part of the appended item */
+					struct item_head *aux_ih;
+
+					RFALSE(ih, "PAP-12210: ih must be 0");
+
+					aux_ih = item_head(tbS0, tb->item_pos);
+					if (is_direntry_le_ih(aux_ih)) {
+						/* we append to directory item */
+
+						int entry_count;
+
+						entry_count = ih_entry_count(aux_ih);
+
+						if (entry_count - tb->sbytes[i] < tb->pos_in_item && tb->pos_in_item <= entry_count) {
+							/* new directory entry falls into S_new[i] */
+
+							RFALSE(!tb->insert_size[0], "PAP-12215: insert_size is already 0");
+							RFALSE(tb->sbytes[i] - 1 >= entry_count,
+							       "PAP-12220: there are no so much entries (%d), only %d",
+							       tb->sbytes[i] - 1, entry_count);
+
+							/* Shift snum[i]-1 items in whole. Shift sbytes[i] directory entries from directory item number snum[i] */
+							leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], tb->sbytes[i] - 1, tb->S_new[i]);
+							/* Paste given directory entry to directory item */
+							buffer_info_init_bh(tb, &bi, tb->S_new[i]);
+							leaf_paste_in_buffer(&bi, 0, tb->pos_in_item - entry_count + tb->sbytes[i] - 1,
+							     tb->insert_size[0], body, tb->zeroes_num);
+							/* paste new directory entry */
+							leaf_paste_entries(&bi, 0, tb->pos_in_item - entry_count + tb->sbytes[i] - 1, 1,
+									   (struct reiserfs_de_head *) body,
+									   body + DEH_SIZE, tb->insert_size[0]);
+							tb->insert_size[0] = 0;
+							tb->pos_in_item++;
+						} else {	/* new directory entry doesn't fall into S_new[i] */
+							leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], tb->sbytes[i], tb->S_new[i]);
+						}
+					} else {	/* regular object */
+
+						int n_shift, n_rem, r_zeroes_number;
+						const char *r_body;
+
+						RFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)) || tb->insert_size[0] <= 0,
+						       "PAP-12225: item too short or insert_size <= 0");
+
+						/* Calculate number of bytes which must be shifted from appended item */
+						n_shift = tb->sbytes[i] - tb->insert_size[0];
+						if (n_shift < 0)
+							n_shift = 0;
+						leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], n_shift, tb->S_new[i]);
+
+						/* Calculate number of bytes which must remain in body after append to S_new[i] */
+						n_rem = tb->insert_size[0] - tb->sbytes[i];
+						if (n_rem < 0)
+							n_rem = 0;
+						/* Append part of body into S_new[0] */
+						buffer_info_init_bh(tb, &bi, tb->S_new[i]);
+						if (n_rem > tb->zeroes_num) {
+							r_zeroes_number = 0;
+							r_body = body + n_rem - tb->zeroes_num;
+						} else {
+							r_body = body;
+							r_zeroes_number = tb->zeroes_num - n_rem;
+							tb->zeroes_num -= r_zeroes_number;
+						}
+
+						leaf_paste_in_buffer(&bi, 0, n_shift,
+								     tb->insert_size[0] - n_rem,
+								     r_body, r_zeroes_number);
+						{
+							struct item_head *tmp;
+
+							tmp = item_head(tb->S_new[i], 0);
+							if (is_indirect_le_ih
+							    (tmp)) {
+								set_ih_free_space(tmp, 0);
+								set_le_ih_k_offset(tmp, le_ih_k_offset(tmp) + (n_rem << (tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT)));
+							} else {
+								set_le_ih_k_offset(tmp, le_ih_k_offset(tmp) + n_rem);
+							}
+						}
+
+						tb->insert_size[0] = n_rem;
+						if (!n_rem)
+							tb->pos_in_item++;
+					}
+				} else
+					/* item falls wholly into S_new[i] */
+				{
+					int leaf_mi;
+					struct item_head *pasted;
+
+#ifdef CONFIG_REISERFS_CHECK
+					struct item_head *ih_check = item_head(tbS0, tb->item_pos);
+
+					if (!is_direntry_le_ih(ih_check)
+					    && (tb->pos_in_item != ih_item_len(ih_check)
+						|| tb->insert_size[0] <= 0))
+						reiserfs_panic(tb->tb_sb,
+							     "PAP-12235",
+							     "pos_in_item "
+							     "must be equal "
+							     "to ih_item_len");
+#endif				/* CONFIG_REISERFS_CHECK */
+
+					leaf_mi = leaf_move_items(LEAF_FROM_S_TO_SNEW,
+							    tb, tb->snum[i],
+							    tb->sbytes[i],
+							    tb->S_new[i]);
+
+					RFALSE(leaf_mi,
+					       "PAP-12240: unexpected value returned by leaf_move_items (%d)",
+					       leaf_mi);
+
+					/* paste into item */
+					buffer_info_init_bh(tb, &bi, tb->S_new[i]);
+					leaf_paste_in_buffer(&bi,
+							     tb->item_pos - n + tb->snum[i],
+							     tb->pos_in_item,
+							     tb->insert_size[0],
+							     body, tb->zeroes_num);
+
+					pasted = item_head(tb->S_new[i], tb->item_pos - n + tb->snum[i]);
+					if (is_direntry_le_ih(pasted)) {
+						leaf_paste_entries(&bi,
+								   tb->item_pos - n + tb->snum[i],
+								   tb->pos_in_item, 1,
+								   (struct reiserfs_de_head *)body,
+								   body + DEH_SIZE,
+								   tb->insert_size[0]
+						    );
+					}
+
+					/* if we paste to indirect item update ih_free_space */
+					if (is_indirect_le_ih(pasted))
+						set_ih_free_space(pasted, 0);
+					tb->zeroes_num = tb->insert_size[0] = 0;
+				}
+			}
+
+			else {	/* pasted item doesn't fall into S_new[i] */
+
+				leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
+						tb->snum[i], tb->sbytes[i], tb->S_new[i]);
+			}
+
+}
+
 /**
  * balance_leaf - reiserfs tree balancing algorithm
  * @tb: tree balance state
@@ -953,152 +1111,8 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 			break;
 
 		case M_PASTE:	/* append item */
-
-			if (n - tb->snum[i] <= tb->item_pos) {	/* pasted item or part if it falls to S_new[i] */
-				if (tb->item_pos == n - tb->snum[i] && tb->sbytes[i] != -1) {	/* we must shift part of the appended item */
-					struct item_head *aux_ih;
-
-					RFALSE(ih, "PAP-12210: ih must be 0");
-
-					aux_ih = item_head(tbS0, tb->item_pos);
-					if (is_direntry_le_ih(aux_ih)) {
-						/* we append to directory item */
-
-						int entry_count;
-
-						entry_count = ih_entry_count(aux_ih);
-
-						if (entry_count - tb->sbytes[i] < tb->pos_in_item && tb->pos_in_item <= entry_count) {
-							/* new directory entry falls into S_new[i] */
-
-							RFALSE(!tb->insert_size[0], "PAP-12215: insert_size is already 0");
-							RFALSE(tb->sbytes[i] - 1 >= entry_count,
-							       "PAP-12220: there are no so much entries (%d), only %d",
-							       tb->sbytes[i] - 1, entry_count);
-
-							/* Shift snum[i]-1 items in whole. Shift sbytes[i] directory entries from directory item number snum[i] */
-							leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], tb->sbytes[i] - 1, tb->S_new[i]);
-							/* Paste given directory entry to directory item */
-							buffer_info_init_bh(tb, &bi, tb->S_new[i]);
-							leaf_paste_in_buffer(&bi, 0, tb->pos_in_item - entry_count + tb->sbytes[i] - 1,
-							     tb->insert_size[0], body, tb->zeroes_num);
-							/* paste new directory entry */
-							leaf_paste_entries(&bi, 0, tb->pos_in_item - entry_count + tb->sbytes[i] - 1, 1,
-									   (struct reiserfs_de_head *) body,
-									   body + DEH_SIZE, tb->insert_size[0]);
-							tb->insert_size[0] = 0;
-							tb->pos_in_item++;
-						} else {	/* new directory entry doesn't fall into S_new[i] */
-							leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], tb->sbytes[i], tb->S_new[i]);
-						}
-					} else {	/* regular object */
-
-						int n_shift, n_rem, r_zeroes_number;
-						const char *r_body;
-
-						RFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)) || tb->insert_size[0] <= 0,
-						       "PAP-12225: item too short or insert_size <= 0");
-
-						/* Calculate number of bytes which must be shifted from appended item */
-						n_shift = tb->sbytes[i] - tb->insert_size[0];
-						if (n_shift < 0)
-							n_shift = 0;
-						leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], n_shift, tb->S_new[i]);
-
-						/* Calculate number of bytes which must remain in body after append to S_new[i] */
-						n_rem = tb->insert_size[0] - tb->sbytes[i];
-						if (n_rem < 0)
-							n_rem = 0;
-						/* Append part of body into S_new[0] */
-						buffer_info_init_bh(tb, &bi, tb->S_new[i]);
-						if (n_rem > tb->zeroes_num) {
-							r_zeroes_number = 0;
-							r_body = body + n_rem - tb->zeroes_num;
-						} else {
-							r_body = body;
-							r_zeroes_number = tb->zeroes_num - n_rem;
-							tb->zeroes_num -= r_zeroes_number;
-						}
-
-						leaf_paste_in_buffer(&bi, 0, n_shift,
-								     tb->insert_size[0] - n_rem,
-								     r_body, r_zeroes_number);
-						{
-							struct item_head *tmp;
-
-							tmp = item_head(tb->S_new[i], 0);
-							if (is_indirect_le_ih
-							    (tmp)) {
-								set_ih_free_space(tmp, 0);
-								set_le_ih_k_offset(tmp, le_ih_k_offset(tmp) + (n_rem << (tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT)));
-							} else {
-								set_le_ih_k_offset(tmp, le_ih_k_offset(tmp) + n_rem);
-							}
-						}
-
-						tb->insert_size[0] = n_rem;
-						if (!n_rem)
-							tb->pos_in_item++;
-					}
-				} else
-					/* item falls wholly into S_new[i] */
-				{
-					int leaf_mi;
-					struct item_head *pasted;
-
-#ifdef CONFIG_REISERFS_CHECK
-					struct item_head *ih_check = item_head(tbS0, tb->item_pos);
-
-					if (!is_direntry_le_ih(ih_check)
-					    && (tb->pos_in_item != ih_item_len(ih_check)
-						|| tb->insert_size[0] <= 0))
-						reiserfs_panic(tb->tb_sb,
-							     "PAP-12235",
-							     "pos_in_item "
-							     "must be equal "
-							     "to ih_item_len");
-#endif				/* CONFIG_REISERFS_CHECK */
-
-					leaf_mi = leaf_move_items(LEAF_FROM_S_TO_SNEW,
-							    tb, tb->snum[i],
-							    tb->sbytes[i],
-							    tb->S_new[i]);
-
-					RFALSE(leaf_mi,
-					       "PAP-12240: unexpected value returned by leaf_move_items (%d)",
-					       leaf_mi);
-
-					/* paste into item */
-					buffer_info_init_bh(tb, &bi, tb->S_new[i]);
-					leaf_paste_in_buffer(&bi,
-							     tb->item_pos - n + tb->snum[i],
-							     tb->pos_in_item,
-							     tb->insert_size[0],
-							     body, tb->zeroes_num);
-
-					pasted = item_head(tb->S_new[i], tb->item_pos - n + tb->snum[i]);
-					if (is_direntry_le_ih(pasted)) {
-						leaf_paste_entries(&bi,
-								   tb->item_pos - n + tb->snum[i],
-								   tb->pos_in_item, 1,
-								   (struct reiserfs_de_head *)body,
-								   body + DEH_SIZE,
-								   tb->insert_size[0]
-						    );
-					}
-
-					/* if we paste to indirect item update ih_free_space */
-					if (is_indirect_le_ih(pasted))
-						set_ih_free_space(pasted, 0);
-					tb->zeroes_num = tb->insert_size[0] = 0;
-				}
-			}
-
-			else {	/* pasted item doesn't fall into S_new[i] */
-
-				leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-						tb->snum[i], tb->sbytes[i], tb->S_new[i]);
-			}
+			balance_leaf_new_nodes_paste(tb, ih, body, insert_key,
+						     insert_ptr, i);
 			break;
 		default:	/* cases d and t */
 			reiserfs_panic(tb->tb_sb, "PAP-12245",

commit 65ab18cb735e828199ce331c6eda7fb0904048e1
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:51 2014 -0400

    reiserfs: balance_leaf refactor, pull out balance_leaf_new_nodes_insert
    
    This patch factors out a new balance_leaf_new_nodes_insert from the code
    in balance_leaf responsible for inserting new items into new nodes in
    the tree.
    
    It has not been reformatted yet.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 4dbe0a34739f..c2c5ba77cfe0 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -733,6 +733,77 @@ static void balance_leaf_paste_right(struct tree_balance *tb,
 
 }
 
+static void balance_leaf_new_nodes_insert(struct tree_balance *tb,
+					  struct item_head *ih,
+					  const char *body,
+					  struct item_head *insert_key,
+					  struct buffer_head **insert_ptr,
+					  int i)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int n = B_NR_ITEMS(tbS0);
+	struct buffer_info bi;
+			if (n - tb->snum[i] < tb->item_pos) {	/* new item or it's part falls to first new node S_new[i] */
+				if (tb->item_pos == n - tb->snum[i] + 1 && tb->sbytes[i] != -1) {	/* part of new item falls into S_new[i] */
+					int old_key_comp, old_len, r_zeroes_number;
+					const char *r_body;
+					int version;
+
+					/* Move snum[i]-1 items from S[0] to S_new[i] */
+					leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
+							tb->snum[i] - 1, -1,
+							tb->S_new[i]);
+					/* Remember key component and item length */
+					version = ih_version(ih);
+					old_key_comp = le_ih_k_offset(ih);
+					old_len = ih_item_len(ih);
+
+					/* Calculate key component and item length to insert into S_new[i] */
+					set_le_ih_k_offset(ih, le_ih_k_offset(ih) +
+							   ((old_len - tb->sbytes[i]) << (is_indirect_le_ih(ih) ? tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT : 0)));
+
+					put_ih_item_len(ih, tb->sbytes[i]);
+
+					/* Insert part of the item into S_new[i] before 0-th item */
+					buffer_info_init_bh(tb, &bi, tb->S_new[i]);
+
+					if ((old_len - tb->sbytes[i]) > tb->zeroes_num) {
+						r_zeroes_number = 0;
+						r_body = body + (old_len - tb->sbytes[i]) - tb->zeroes_num;
+					} else {
+						r_body = body;
+						r_zeroes_number = tb->zeroes_num - (old_len - tb->sbytes[i]);
+						tb->zeroes_num -= r_zeroes_number;
+					}
+
+					leaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);
+
+					/* Calculate key component and item length to insert into S[i] */
+					set_le_ih_k_offset(ih, old_key_comp);
+					put_ih_item_len(ih, old_len - tb->sbytes[i]);
+					tb->insert_size[0] -= tb->sbytes[i];
+				} else {	/* whole new item falls into S_new[i] */
+
+					/* Shift snum[0] - 1 items to S_new[i] (sbytes[i] of split item) */
+					leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
+							tb->snum[i] - 1, tb->sbytes[i], tb->S_new[i]);
+
+					/* Insert new item into S_new[i] */
+					buffer_info_init_bh(tb, &bi, tb->S_new[i]);
+					leaf_insert_into_buf(&bi, tb->item_pos - n + tb->snum[i] - 1,
+							     ih, body, tb->zeroes_num);
+
+					tb->zeroes_num = tb->insert_size[0] = 0;
+				}
+			}
+
+			else {	/* new item or it part don't falls into S_new[i] */
+
+				leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
+						tb->snum[i], tb->sbytes[i], tb->S_new[i]);
+			}
+}
+
 /**
  * balance_leaf - reiserfs tree balancing algorithm
  * @tb: tree balance state
@@ -877,66 +948,8 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 
 		switch (flag) {
 		case M_INSERT:	/* insert item */
-
-			if (n - tb->snum[i] < tb->item_pos) {	/* new item or it's part falls to first new node S_new[i] */
-				if (tb->item_pos == n - tb->snum[i] + 1 && tb->sbytes[i] != -1) {	/* part of new item falls into S_new[i] */
-					int old_key_comp, old_len, r_zeroes_number;
-					const char *r_body;
-					int version;
-
-					/* Move snum[i]-1 items from S[0] to S_new[i] */
-					leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-							tb->snum[i] - 1, -1,
-							tb->S_new[i]);
-					/* Remember key component and item length */
-					version = ih_version(ih);
-					old_key_comp = le_ih_k_offset(ih);
-					old_len = ih_item_len(ih);
-
-					/* Calculate key component and item length to insert into S_new[i] */
-					set_le_ih_k_offset(ih, le_ih_k_offset(ih) +
-							   ((old_len - tb->sbytes[i]) << (is_indirect_le_ih(ih) ? tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT : 0)));
-
-					put_ih_item_len(ih, tb->sbytes[i]);
-
-					/* Insert part of the item into S_new[i] before 0-th item */
-					buffer_info_init_bh(tb, &bi, tb->S_new[i]);
-
-					if ((old_len - tb->sbytes[i]) > tb->zeroes_num) {
-						r_zeroes_number = 0;
-						r_body = body + (old_len - tb->sbytes[i]) - tb->zeroes_num;
-					} else {
-						r_body = body;
-						r_zeroes_number = tb->zeroes_num - (old_len - tb->sbytes[i]);
-						tb->zeroes_num -= r_zeroes_number;
-					}
-
-					leaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);
-
-					/* Calculate key component and item length to insert into S[i] */
-					set_le_ih_k_offset(ih, old_key_comp);
-					put_ih_item_len(ih, old_len - tb->sbytes[i]);
-					tb->insert_size[0] -= tb->sbytes[i];
-				} else {	/* whole new item falls into S_new[i] */
-
-					/* Shift snum[0] - 1 items to S_new[i] (sbytes[i] of split item) */
-					leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-							tb->snum[i] - 1, tb->sbytes[i], tb->S_new[i]);
-
-					/* Insert new item into S_new[i] */
-					buffer_info_init_bh(tb, &bi, tb->S_new[i]);
-					leaf_insert_into_buf(&bi, tb->item_pos - n + tb->snum[i] - 1,
-							     ih, body, tb->zeroes_num);
-
-					tb->zeroes_num = tb->insert_size[0] = 0;
-				}
-			}
-
-			else {	/* new item or it part don't falls into S_new[i] */
-
-				leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-						tb->snum[i], tb->sbytes[i], tb->S_new[i]);
-			}
+			balance_leaf_new_nodes_insert(tb, ih, body, insert_key,
+						      insert_ptr, i);
 			break;
 
 		case M_PASTE:	/* append item */

commit 3f0eb27655bba38e3dfb14db93b2720c4eccf4a8
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:50 2014 -0400

    reiserfs: balance_leaf refactor, pull out balance_leaf_paste_right
    
    This patch factors out a new balance_leaf_paste_right from the code in
    balance_leaf responsible for pasting new contents into an existing item
    located in the node to the right of S[0] in the tree.
    
    It has not been reformatted yet.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index fc15e676a651..4dbe0a34739f 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -582,91 +582,14 @@ static void balance_leaf_insert_right(struct tree_balance *tb,
 
 }
 
-/**
- * balance_leaf - reiserfs tree balancing algorithm
- * @tb: tree balance state
- * @ih: item header of inserted item (little endian)
- * @body: body of inserted item or bytes to paste
- * @flag: i - insert, d - delete, c - cut, p - paste (see do_balance)
- * passed back:
- * @insert_key: key to insert new nodes
- * @insert_ptr: array of nodes to insert at the next level
- *
- * In our processing of one level we sometimes determine what must be
- * inserted into the next higher level.  This insertion consists of a
- * key or two keys and their corresponding pointers.
- */
-static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
-			const char *body, int flag,
-			struct item_head *insert_key,
-			struct buffer_head **insert_ptr)
+static void balance_leaf_paste_right(struct tree_balance *tb,
+				     struct item_head *ih, const char *body)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int n = B_NR_ITEMS(tbS0);
 	struct buffer_info bi;
-	int n, i;
 	int ret_val;
 
-	PROC_INFO_INC(tb->tb_sb, balance_at[0]);
-
-	/* Make balance in case insert_size[0] < 0 */
-	if (tb->insert_size[0] < 0)
-		return balance_leaf_when_delete(tb, flag);
-
-	tb->item_pos = PATH_LAST_POSITION(tb->tb_path),
-	tb->pos_in_item = tb->tb_path->pos_in_item,
-	tb->zeroes_num = 0;
-	if (flag == M_INSERT && !body)
-		tb->zeroes_num = ih_item_len(ih);
-
-	/*
-	 * for indirect item pos_in_item is measured in unformatted node
-	 * pointers. Recalculate to bytes
-	 */
-	if (flag != M_INSERT
-	    && is_indirect_le_ih(item_head(tbS0, tb->item_pos)))
-		tb->pos_in_item *= UNFM_P_SIZE;
-
-	if (tb->lnum[0] > 0) {
-		/* Shift lnum[0] items from S[0] to the left neighbor L[0] */
-		if (tb->item_pos < tb->lnum[0]) {
-			/* new item or it part falls to L[0], shift it too */
-			n = B_NR_ITEMS(tb->L[0]);
-
-			switch (flag) {
-			case M_INSERT:	/* insert item into L[0] */
-				balance_leaf_insert_left(tb, ih, body);
-				break;
-
-			case M_PASTE:	/* append item in L[0] */
-				balance_leaf_paste_left(tb, ih, body);
-				break;
-			default:	/* cases d and t */
-				reiserfs_panic(tb->tb_sb, "PAP-12130",
-					       "lnum > 0: unexpected mode: "
-					       " %s(%d)",
-					       (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
-			}
-		} else {
-			/* new item doesn't fall into L[0] */
-			leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
-		}
-	}
-
-	/* tb->lnum[0] > 0 */
-	/* Calculate new item position */
-	tb->item_pos -= (tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0));
-
-	if (tb->rnum[0] > 0) {
-		/* shift rnum[0] items from S[0] to the right neighbor R[0] */
-		n = B_NR_ITEMS(tbS0);
-		switch (flag) {
-
-		case M_INSERT:	/* insert item */
-			balance_leaf_insert_right(tb, ih, body);
-			break;
-
-		case M_PASTE:	/* append item */
-
 			if (n - tb->rnum[0] <= tb->item_pos) {	/* pasted item or part of it falls to R[0] */
 				if (tb->item_pos == n - tb->rnum[0] && tb->rbytes != -1) {	/* we must shift the part of the appended item */
 					if (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {	/* we append to directory item */
@@ -807,6 +730,93 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 
 				leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
 			}
+
+}
+
+/**
+ * balance_leaf - reiserfs tree balancing algorithm
+ * @tb: tree balance state
+ * @ih: item header of inserted item (little endian)
+ * @body: body of inserted item or bytes to paste
+ * @flag: i - insert, d - delete, c - cut, p - paste (see do_balance)
+ * passed back:
+ * @insert_key: key to insert new nodes
+ * @insert_ptr: array of nodes to insert at the next level
+ *
+ * In our processing of one level we sometimes determine what must be
+ * inserted into the next higher level.  This insertion consists of a
+ * key or two keys and their corresponding pointers.
+ */
+static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
+			const char *body, int flag,
+			struct item_head *insert_key,
+			struct buffer_head **insert_ptr)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	struct buffer_info bi;
+	int n, i;
+
+	PROC_INFO_INC(tb->tb_sb, balance_at[0]);
+
+	/* Make balance in case insert_size[0] < 0 */
+	if (tb->insert_size[0] < 0)
+		return balance_leaf_when_delete(tb, flag);
+
+	tb->item_pos = PATH_LAST_POSITION(tb->tb_path),
+	tb->pos_in_item = tb->tb_path->pos_in_item,
+	tb->zeroes_num = 0;
+	if (flag == M_INSERT && !body)
+		tb->zeroes_num = ih_item_len(ih);
+
+	/*
+	 * for indirect item pos_in_item is measured in unformatted node
+	 * pointers. Recalculate to bytes
+	 */
+	if (flag != M_INSERT
+	    && is_indirect_le_ih(item_head(tbS0, tb->item_pos)))
+		tb->pos_in_item *= UNFM_P_SIZE;
+
+	if (tb->lnum[0] > 0) {
+		/* Shift lnum[0] items from S[0] to the left neighbor L[0] */
+		if (tb->item_pos < tb->lnum[0]) {
+			/* new item or it part falls to L[0], shift it too */
+			n = B_NR_ITEMS(tb->L[0]);
+
+			switch (flag) {
+			case M_INSERT:	/* insert item into L[0] */
+				balance_leaf_insert_left(tb, ih, body);
+				break;
+
+			case M_PASTE:	/* append item in L[0] */
+				balance_leaf_paste_left(tb, ih, body);
+				break;
+			default:	/* cases d and t */
+				reiserfs_panic(tb->tb_sb, "PAP-12130",
+					       "lnum > 0: unexpected mode: "
+					       " %s(%d)",
+					       (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
+			}
+		} else {
+			/* new item doesn't fall into L[0] */
+			leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
+		}
+	}
+
+	/* tb->lnum[0] > 0 */
+	/* Calculate new item position */
+	tb->item_pos -= (tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0));
+
+	if (tb->rnum[0] > 0) {
+		/* shift rnum[0] items from S[0] to the right neighbor R[0] */
+		n = B_NR_ITEMS(tbS0);
+		switch (flag) {
+
+		case M_INSERT:	/* insert item */
+			balance_leaf_insert_right(tb, ih, body);
+			break;
+
+		case M_PASTE:	/* append item */
+			balance_leaf_paste_right(tb, ih, body);
 			break;
 		default:	/* cases d and t */
 			reiserfs_panic(tb->tb_sb, "PAP-12175",

commit e80ef3d1488e3bfb8eb39b0643cfaffb25ed9814
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:49 2014 -0400

    reiserfs: balance_leaf refactor, pull out balance_leaf_insert_right
    
    This patch factors out a new balance_leaf_insert_right from the code in
    balance_leaf responsible for inserting new items into the node to
    the right of S[0] in the tree.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index f8fab372e32c..fc15e676a651 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -508,6 +508,80 @@ static void balance_leaf_paste_left(struct tree_balance *tb,
 
 }
 
+static void balance_leaf_insert_right(struct tree_balance *tb,
+				      struct item_head *ih, const char *body)
+{
+
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int n = B_NR_ITEMS(tbS0);
+	struct buffer_info bi;
+	int ret_val;
+			if (n - tb->rnum[0] < tb->item_pos) {	/* new item or its part falls to R[0] */
+				if (tb->item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1) {	/* part of new item falls into R[0] */
+					loff_t old_key_comp, old_len, r_zeroes_number;
+					const char *r_body;
+					int version;
+					loff_t offset;
+
+					leaf_shift_right(tb, tb->rnum[0] - 1, -1);
+
+					version = ih_version(ih);
+					/* Remember key component and item length */
+					old_key_comp = le_ih_k_offset(ih);
+					old_len = ih_item_len(ih);
+
+					/* Calculate key component and item length to insert into R[0] */
+					offset = le_ih_k_offset(ih) + ((old_len - tb->rbytes) << (is_indirect_le_ih(ih) ? tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT : 0));
+					set_le_ih_k_offset(ih, offset);
+					put_ih_item_len(ih, tb->rbytes);
+					/* Insert part of the item into R[0] */
+					buffer_info_init_right(tb, &bi);
+					if ((old_len - tb->rbytes) > tb->zeroes_num) {
+						r_zeroes_number = 0;
+						r_body = body + (old_len - tb->rbytes) - tb->zeroes_num;
+					} else {
+						r_body = body;
+						r_zeroes_number = tb->zeroes_num - (old_len - tb->rbytes);
+						tb->zeroes_num -= r_zeroes_number;
+					}
+
+					leaf_insert_into_buf(&bi, 0, ih, r_body,
+							     r_zeroes_number);
+
+					/* Replace right delimiting key by first key in R[0] */
+					replace_key(tb, tb->CFR[0], tb->rkey[0],
+						    tb->R[0], 0);
+
+					/* Calculate key component and item length to insert into S[0] */
+					set_le_ih_k_offset(ih, old_key_comp);
+					put_ih_item_len(ih, old_len - tb->rbytes);
+
+					tb->insert_size[0] -= tb->rbytes;
+
+				} else {	/* whole new item falls into R[0] */
+
+					/* Shift rnum[0]-1 items to R[0] */
+					ret_val = leaf_shift_right(tb, tb->rnum[0] - 1, tb->rbytes);
+					/* Insert new item into R[0] */
+					buffer_info_init_right(tb, &bi);
+					leaf_insert_into_buf(&bi, tb->item_pos - n + tb->rnum[0] - 1,
+							     ih, body, tb->zeroes_num);
+
+					if (tb->item_pos - n + tb->rnum[0] - 1 == 0) {
+						replace_key(tb, tb->CFR[0],
+							    tb->rkey[0],
+							    tb->R[0], 0);
+
+					}
+					tb->zeroes_num = tb->insert_size[0] = 0;
+				}
+			} else {	/* new item or part of it doesn't fall into R[0] */
+
+				leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
+			}
+
+}
+
 /**
  * balance_leaf - reiserfs tree balancing algorithm
  * @tb: tree balance state
@@ -588,69 +662,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 		switch (flag) {
 
 		case M_INSERT:	/* insert item */
-			if (n - tb->rnum[0] < tb->item_pos) {	/* new item or its part falls to R[0] */
-				if (tb->item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1) {	/* part of new item falls into R[0] */
-					loff_t old_key_comp, old_len, r_zeroes_number;
-					const char *r_body;
-					int version;
-					loff_t offset;
-
-					leaf_shift_right(tb, tb->rnum[0] - 1, -1);
-
-					version = ih_version(ih);
-					/* Remember key component and item length */
-					old_key_comp = le_ih_k_offset(ih);
-					old_len = ih_item_len(ih);
-
-					/* Calculate key component and item length to insert into R[0] */
-					offset = le_ih_k_offset(ih) + ((old_len - tb->rbytes) << (is_indirect_le_ih(ih) ? tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT : 0));
-					set_le_ih_k_offset(ih, offset);
-					put_ih_item_len(ih, tb->rbytes);
-					/* Insert part of the item into R[0] */
-					buffer_info_init_right(tb, &bi);
-					if ((old_len - tb->rbytes) > tb->zeroes_num) {
-						r_zeroes_number = 0;
-						r_body = body + (old_len - tb->rbytes) - tb->zeroes_num;
-					} else {
-						r_body = body;
-						r_zeroes_number = tb->zeroes_num - (old_len - tb->rbytes);
-						tb->zeroes_num -= r_zeroes_number;
-					}
-
-					leaf_insert_into_buf(&bi, 0, ih, r_body,
-							     r_zeroes_number);
-
-					/* Replace right delimiting key by first key in R[0] */
-					replace_key(tb, tb->CFR[0], tb->rkey[0],
-						    tb->R[0], 0);
-
-					/* Calculate key component and item length to insert into S[0] */
-					set_le_ih_k_offset(ih, old_key_comp);
-					put_ih_item_len(ih, old_len - tb->rbytes);
-
-					tb->insert_size[0] -= tb->rbytes;
-
-				} else {	/* whole new item falls into R[0] */
-
-					/* Shift rnum[0]-1 items to R[0] */
-					ret_val = leaf_shift_right(tb, tb->rnum[0] - 1, tb->rbytes);
-					/* Insert new item into R[0] */
-					buffer_info_init_right(tb, &bi);
-					leaf_insert_into_buf(&bi, tb->item_pos - n + tb->rnum[0] - 1,
-							     ih, body, tb->zeroes_num);
-
-					if (tb->item_pos - n + tb->rnum[0] - 1 == 0) {
-						replace_key(tb, tb->CFR[0],
-							    tb->rkey[0],
-							    tb->R[0], 0);
-
-					}
-					tb->zeroes_num = tb->insert_size[0] = 0;
-				}
-			} else {	/* new item or part of it doesn't fall into R[0] */
-
-				leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
-			}
+			balance_leaf_insert_right(tb, ih, body);
 			break;
 
 		case M_PASTE:	/* append item */

commit cf22df182bfce50670c25ce432e679e03aff3745
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:48 2014 -0400

    reiserfs: balance_leaf refactor, pull out balance_leaf_paste_left
    
    This patch factors out a new balance_leaf_paste_left from the code in
    balance_leaf responsible for pasting new content into an existing item
    located in the node to the left of S[0] in the tree.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 44eb4f6ce0da..f8fab372e32c 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -348,62 +348,13 @@ static void balance_leaf_insert_left(struct tree_balance *tb,
 
 }
 
-/**
- * balance_leaf - reiserfs tree balancing algorithm
- * @tb: tree balance state
- * @ih: item header of inserted item (little endian)
- * @body: body of inserted item or bytes to paste
- * @flag: i - insert, d - delete, c - cut, p - paste (see do_balance)
- * passed back:
- * @insert_key: key to insert new nodes
- * @insert_ptr: array of nodes to insert at the next level
- *
- * In our processing of one level we sometimes determine what must be
- * inserted into the next higher level.  This insertion consists of a
- * key or two keys and their corresponding pointers.
- */
-static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
-			const char *body, int flag,
-			struct item_head *insert_key,
-			struct buffer_head **insert_ptr)
+static void balance_leaf_paste_left(struct tree_balance *tb,
+				    struct item_head *ih, const char *body)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
-	struct buffer_info bi;
-	int n, i;
 	int ret_val;
-
-	PROC_INFO_INC(tb->tb_sb, balance_at[0]);
-
-	/* Make balance in case insert_size[0] < 0 */
-	if (tb->insert_size[0] < 0)
-		return balance_leaf_when_delete(tb, flag);
-
-	tb->item_pos = PATH_LAST_POSITION(tb->tb_path),
-	tb->pos_in_item = tb->tb_path->pos_in_item,
-	tb->zeroes_num = 0;
-	if (flag == M_INSERT && !body)
-		tb->zeroes_num = ih_item_len(ih);
-
-	/*
-	 * for indirect item pos_in_item is measured in unformatted node
-	 * pointers. Recalculate to bytes
-	 */
-	if (flag != M_INSERT
-	    && is_indirect_le_ih(item_head(tbS0, tb->item_pos)))
-		tb->pos_in_item *= UNFM_P_SIZE;
-
-	if (tb->lnum[0] > 0) {
-		/* Shift lnum[0] items from S[0] to the left neighbor L[0] */
-		if (tb->item_pos < tb->lnum[0]) {
-			/* new item or it part falls to L[0], shift it too */
-			n = B_NR_ITEMS(tb->L[0]);
-
-			switch (flag) {
-			case M_INSERT:	/* insert item into L[0] */
-				balance_leaf_insert_left(tb, ih, body);
-				break;
-
-			case M_PASTE:	/* append item in L[0] */
+	struct buffer_info bi;
+	int n = B_NR_ITEMS(tb->L[0]);
 
 				if (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {
 					/* we must shift the part of the appended item */
@@ -554,6 +505,66 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 					tb->insert_size[0] = 0;
 					tb->zeroes_num = 0;
 				}
+
+}
+
+/**
+ * balance_leaf - reiserfs tree balancing algorithm
+ * @tb: tree balance state
+ * @ih: item header of inserted item (little endian)
+ * @body: body of inserted item or bytes to paste
+ * @flag: i - insert, d - delete, c - cut, p - paste (see do_balance)
+ * passed back:
+ * @insert_key: key to insert new nodes
+ * @insert_ptr: array of nodes to insert at the next level
+ *
+ * In our processing of one level we sometimes determine what must be
+ * inserted into the next higher level.  This insertion consists of a
+ * key or two keys and their corresponding pointers.
+ */
+static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
+			const char *body, int flag,
+			struct item_head *insert_key,
+			struct buffer_head **insert_ptr)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	struct buffer_info bi;
+	int n, i;
+	int ret_val;
+
+	PROC_INFO_INC(tb->tb_sb, balance_at[0]);
+
+	/* Make balance in case insert_size[0] < 0 */
+	if (tb->insert_size[0] < 0)
+		return balance_leaf_when_delete(tb, flag);
+
+	tb->item_pos = PATH_LAST_POSITION(tb->tb_path),
+	tb->pos_in_item = tb->tb_path->pos_in_item,
+	tb->zeroes_num = 0;
+	if (flag == M_INSERT && !body)
+		tb->zeroes_num = ih_item_len(ih);
+
+	/*
+	 * for indirect item pos_in_item is measured in unformatted node
+	 * pointers. Recalculate to bytes
+	 */
+	if (flag != M_INSERT
+	    && is_indirect_le_ih(item_head(tbS0, tb->item_pos)))
+		tb->pos_in_item *= UNFM_P_SIZE;
+
+	if (tb->lnum[0] > 0) {
+		/* Shift lnum[0] items from S[0] to the left neighbor L[0] */
+		if (tb->item_pos < tb->lnum[0]) {
+			/* new item or it part falls to L[0], shift it too */
+			n = B_NR_ITEMS(tb->L[0]);
+
+			switch (flag) {
+			case M_INSERT:	/* insert item into L[0] */
+				balance_leaf_insert_left(tb, ih, body);
+				break;
+
+			case M_PASTE:	/* append item in L[0] */
+				balance_leaf_paste_left(tb, ih, body);
 				break;
 			default:	/* cases d and t */
 				reiserfs_panic(tb->tb_sb, "PAP-12130",

commit f1f007c308eb95be5ebb3d9fec566f86662975be
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:47 2014 -0400

    reiserfs: balance_leaf refactor, pull out balance_leaf_insert_left
    
    This patch factors out a new balance_leaf_insert_left from the code in
    balance_leaf responsible for inserting new items into the node to
    the left of S[0] in the tree.
    
    It is not yet formatted correctly.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 6dbe55ff408e..44eb4f6ce0da 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -290,6 +290,64 @@ static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 	return 0;
 }
 
+static void balance_leaf_insert_left(struct tree_balance *tb,
+				     struct item_head *ih, const char *body)
+{
+	int ret_val;
+	struct buffer_info bi;
+	int n = B_NR_ITEMS(tb->L[0]);
+
+				if (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {
+					/* part of new item falls into L[0] */
+					int new_item_len;
+					int version;
+
+					ret_val = leaf_shift_left(tb, tb->lnum[0] - 1, -1);
+
+					/* Calculate item length to insert to S[0] */
+					new_item_len = ih_item_len(ih) - tb->lbytes;
+					/* Calculate and check item length to insert to L[0] */
+					put_ih_item_len(ih, ih_item_len(ih) - new_item_len);
+
+					RFALSE(ih_item_len(ih) <= 0,
+					       "PAP-12080: there is nothing to insert into L[0]: ih_item_len=%d",
+					       ih_item_len(ih));
+
+					/* Insert new item into L[0] */
+					buffer_info_init_left(tb, &bi);
+					leaf_insert_into_buf(&bi,
+							n + tb->item_pos - ret_val, ih, body,
+							tb->zeroes_num > ih_item_len(ih) ? ih_item_len(ih) : tb->zeroes_num);
+
+					version = ih_version(ih);
+
+					/* Calculate key component, item length and body to insert into S[0] */
+					set_le_ih_k_offset(ih, le_ih_k_offset(ih) +
+							(tb->lbytes << (is_indirect_le_ih(ih) ? tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT : 0)));
+
+					put_ih_item_len(ih, new_item_len);
+					if (tb->lbytes > tb->zeroes_num) {
+						body += (tb->lbytes - tb->zeroes_num);
+						tb->zeroes_num = 0;
+					} else
+						tb->zeroes_num -= tb->lbytes;
+
+					RFALSE(ih_item_len(ih) <= 0,
+					       "PAP-12085: there is nothing to insert into S[0]: ih_item_len=%d",
+					       ih_item_len(ih));
+				} else {
+					/* new item in whole falls into L[0] */
+					/* Shift lnum[0]-1 items to L[0] */
+					ret_val = leaf_shift_left(tb, tb->lnum[0] - 1, tb->lbytes);
+					/* Insert new item into L[0] */
+					buffer_info_init_left(tb, &bi);
+					leaf_insert_into_buf(&bi, n + tb->item_pos - ret_val, ih, body, tb->zeroes_num);
+					tb->insert_size[0] = 0;
+					tb->zeroes_num = 0;
+				}
+
+}
+
 /**
  * balance_leaf - reiserfs tree balancing algorithm
  * @tb: tree balance state
@@ -342,55 +400,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 
 			switch (flag) {
 			case M_INSERT:	/* insert item into L[0] */
-
-				if (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {
-					/* part of new item falls into L[0] */
-					int new_item_len;
-					int version;
-
-					ret_val = leaf_shift_left(tb, tb->lnum[0] - 1, -1);
-
-					/* Calculate item length to insert to S[0] */
-					new_item_len = ih_item_len(ih) - tb->lbytes;
-					/* Calculate and check item length to insert to L[0] */
-					put_ih_item_len(ih, ih_item_len(ih) - new_item_len);
-
-					RFALSE(ih_item_len(ih) <= 0,
-					       "PAP-12080: there is nothing to insert into L[0]: ih_item_len=%d",
-					       ih_item_len(ih));
-
-					/* Insert new item into L[0] */
-					buffer_info_init_left(tb, &bi);
-					leaf_insert_into_buf(&bi,
-							n + tb->item_pos - ret_val, ih, body,
-							tb->zeroes_num > ih_item_len(ih) ? ih_item_len(ih) : tb->zeroes_num);
-
-					version = ih_version(ih);
-
-					/* Calculate key component, item length and body to insert into S[0] */
-					set_le_ih_k_offset(ih, le_ih_k_offset(ih) +
-							(tb-> lbytes << (is_indirect_le_ih(ih) ? tb->tb_sb-> s_blocksize_bits - UNFM_P_SHIFT : 0)));
-
-					put_ih_item_len(ih, new_item_len);
-					if (tb->lbytes > tb->zeroes_num) {
-						body += (tb->lbytes - tb->zeroes_num);
-						tb->zeroes_num = 0;
-					} else
-						tb->zeroes_num -= tb->lbytes;
-
-					RFALSE(ih_item_len(ih) <= 0,
-					       "PAP-12085: there is nothing to insert into S[0]: ih_item_len=%d",
-					       ih_item_len(ih));
-				} else {
-					/* new item in whole falls into L[0] */
-					/* Shift lnum[0]-1 items to L[0] */
-					ret_val = leaf_shift_left(tb, tb->lnum[0] - 1, tb->lbytes);
-					/* Insert new item into L[0] */
-					buffer_info_init_left(tb, &bi);
-					leaf_insert_into_buf(&bi, n + tb->item_pos - ret_val, ih, body, tb->zeroes_num);
-					tb->insert_size[0] = 0;
-					tb->zeroes_num = 0;
-				}
+				balance_leaf_insert_left(tb, ih, body);
 				break;
 
 			case M_PASTE:	/* append item in L[0] */

commit b49fb112d4ae62ca1c549130a111fb39e85e2c93
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:46 2014 -0400

    reiserfs: balance_leaf refactor, move state variables into tree_balance
    
    This patch pushes the rest of the state variables in balance_leaf into
    the tree_balance structure so we can use them when we split balance_leaf
    into separate functions.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index bbc282b7007c..6dbe55ff408e 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -310,27 +310,9 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 			struct buffer_head **insert_ptr)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
-	/* index into the array of item headers in S[0] of the affected item */
-	int item_pos = PATH_LAST_POSITION(tb->tb_path);
 	struct buffer_info bi;
-	/* new nodes allocated to hold what could not fit into S */
-	struct buffer_head *S_new[2];
-	/*
-	 * number of items that will be placed into S_new
-	 * (includes partially shifted items)
-	 */
-	int snum[2];
-	/*
-	 * if an item is partially shifted into S_new then if it is a
-	 * directory item it is the number of entries from the item that
-	 * are shifted into S_new else it is the number of bytes from
-	 * the item that are shifted into S_new
-	 */
-	int sbytes[2];
 	int n, i;
 	int ret_val;
-	int pos_in_item;
-	int zeros_num;
 
 	PROC_INFO_INC(tb->tb_sb, balance_at[0]);
 
@@ -338,29 +320,30 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 	if (tb->insert_size[0] < 0)
 		return balance_leaf_when_delete(tb, flag);
 
-	zeros_num = 0;
+	tb->item_pos = PATH_LAST_POSITION(tb->tb_path),
+	tb->pos_in_item = tb->tb_path->pos_in_item,
+	tb->zeroes_num = 0;
 	if (flag == M_INSERT && !body)
-		zeros_num = ih_item_len(ih);
+		tb->zeroes_num = ih_item_len(ih);
 
-	pos_in_item = tb->tb_path->pos_in_item;
 	/*
 	 * for indirect item pos_in_item is measured in unformatted node
 	 * pointers. Recalculate to bytes
 	 */
 	if (flag != M_INSERT
-	    && is_indirect_le_ih(item_head(tbS0, item_pos)))
-		pos_in_item *= UNFM_P_SIZE;
+	    && is_indirect_le_ih(item_head(tbS0, tb->item_pos)))
+		tb->pos_in_item *= UNFM_P_SIZE;
 
 	if (tb->lnum[0] > 0) {
 		/* Shift lnum[0] items from S[0] to the left neighbor L[0] */
-		if (item_pos < tb->lnum[0]) {
+		if (tb->item_pos < tb->lnum[0]) {
 			/* new item or it part falls to L[0], shift it too */
 			n = B_NR_ITEMS(tb->L[0]);
 
 			switch (flag) {
 			case M_INSERT:	/* insert item into L[0] */
 
-				if (item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {
+				if (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {
 					/* part of new item falls into L[0] */
 					int new_item_len;
 					int version;
@@ -379,8 +362,8 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 					/* Insert new item into L[0] */
 					buffer_info_init_left(tb, &bi);
 					leaf_insert_into_buf(&bi,
-							n + item_pos - ret_val, ih, body,
-							zeros_num > ih_item_len(ih) ? ih_item_len(ih) : zeros_num);
+							n + tb->item_pos - ret_val, ih, body,
+							tb->zeroes_num > ih_item_len(ih) ? ih_item_len(ih) : tb->zeroes_num);
 
 					version = ih_version(ih);
 
@@ -389,11 +372,11 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 							(tb-> lbytes << (is_indirect_le_ih(ih) ? tb->tb_sb-> s_blocksize_bits - UNFM_P_SHIFT : 0)));
 
 					put_ih_item_len(ih, new_item_len);
-					if (tb->lbytes > zeros_num) {
-						body += (tb->lbytes - zeros_num);
-						zeros_num = 0;
+					if (tb->lbytes > tb->zeroes_num) {
+						body += (tb->lbytes - tb->zeroes_num);
+						tb->zeroes_num = 0;
 					} else
-						zeros_num -= tb->lbytes;
+						tb->zeroes_num -= tb->lbytes;
 
 					RFALSE(ih_item_len(ih) <= 0,
 					       "PAP-12085: there is nothing to insert into S[0]: ih_item_len=%d",
@@ -404,43 +387,43 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 					ret_val = leaf_shift_left(tb, tb->lnum[0] - 1, tb->lbytes);
 					/* Insert new item into L[0] */
 					buffer_info_init_left(tb, &bi);
-					leaf_insert_into_buf(&bi, n + item_pos - ret_val, ih, body, zeros_num);
+					leaf_insert_into_buf(&bi, n + tb->item_pos - ret_val, ih, body, tb->zeroes_num);
 					tb->insert_size[0] = 0;
-					zeros_num = 0;
+					tb->zeroes_num = 0;
 				}
 				break;
 
 			case M_PASTE:	/* append item in L[0] */
 
-				if (item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {
+				if (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {
 					/* we must shift the part of the appended item */
-					if (is_direntry_le_ih(item_head(tbS0, item_pos))) {
+					if (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {
 
-						RFALSE(zeros_num,
+						RFALSE(tb->zeroes_num,
 						       "PAP-12090: invalid parameter in case of a directory");
 						/* directory item */
-						if (tb->lbytes > pos_in_item) {
+						if (tb->lbytes > tb->pos_in_item) {
 							/* new directory entry falls into L[0] */
 							struct item_head *pasted;
-							int l_pos_in_item = pos_in_item;
+							int l_pos_in_item = tb->pos_in_item;
 
 							/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 entries from given directory item */
 							ret_val = leaf_shift_left(tb, tb->lnum[0], tb->lbytes-1);
-							if (ret_val && !item_pos) {
+							if (ret_val && !tb->item_pos) {
 								pasted = item_head(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1);
 								l_pos_in_item += ih_entry_count(pasted) - (tb->lbytes -1);
 							}
 
 							/* Append given directory entry to directory item */
 							buffer_info_init_left(tb, &bi);
-							leaf_paste_in_buffer(&bi, n + item_pos - ret_val, l_pos_in_item, tb->insert_size[0], body, zeros_num);
+							leaf_paste_in_buffer(&bi, n + tb->item_pos - ret_val, l_pos_in_item, tb->insert_size[0], body, tb->zeroes_num);
 
 							/* previous string prepared space for pasting new entry, following string pastes this entry */
 
 							/* when we have merge directory item, pos_in_item has been changed too */
 
 							/* paste new directory entry. 1 is entry number */
-							leaf_paste_entries(&bi, n + item_pos - ret_val, l_pos_in_item,
+							leaf_paste_entries(&bi, n + tb->item_pos - ret_val, l_pos_in_item,
 									   1, (struct reiserfs_de_head *) body,
 									   body + DEH_SIZE, tb->insert_size[0]);
 							tb->insert_size[0] = 0;
@@ -450,20 +433,20 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 							leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
 						}
 						/* Calculate new position to append in item body */
-						pos_in_item -= tb->lbytes;
+						tb->pos_in_item -= tb->lbytes;
 					} else {
 						/* regular object */
 						RFALSE(tb->lbytes <= 0, "PAP-12095: there is nothing to shift to L[0]. lbytes=%d", tb->lbytes);
-						RFALSE(pos_in_item != ih_item_len(item_head(tbS0, item_pos)),
+						RFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)),
 						       "PAP-12100: incorrect position to paste: item_len=%d, pos_in_item=%d",
-						       ih_item_len(item_head(tbS0, item_pos)),pos_in_item);
+						       ih_item_len(item_head(tbS0, tb->item_pos)), tb->pos_in_item);
 
-						if (tb->lbytes >= pos_in_item) {
+						if (tb->lbytes >= tb->pos_in_item) {
 							/* appended item will be in L[0] in whole */
 							int l_n;
 
 							/* this bytes number must be appended to the last item of L[h] */
-							l_n = tb->lbytes - pos_in_item;
+							l_n = tb->lbytes - tb->pos_in_item;
 
 							/* Calculate new insert_size[0] */
 							tb->insert_size[0] -= l_n;
@@ -472,14 +455,14 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 							       "PAP-12105: there is nothing to paste into L[0]. insert_size=%d",
 							       tb->insert_size[0]);
 							ret_val = leaf_shift_left(tb, tb->lnum[0], ih_item_len
-									    (item_head(tbS0, item_pos)));
+									    (item_head(tbS0, tb->item_pos)));
 							/* Append to body of item in L[0] */
 							buffer_info_init_left(tb, &bi);
 							leaf_paste_in_buffer
-							    (&bi, n + item_pos - ret_val, ih_item_len
-							     (item_head(tb->L[0], n + item_pos - ret_val)),
+							    (&bi, n + tb->item_pos - ret_val, ih_item_len
+							     (item_head(tb->L[0], n + tb->item_pos - ret_val)),
 							     l_n, body,
-							     zeros_num > l_n ? l_n : zeros_num);
+							     tb->zeroes_num > l_n ? l_n : tb->zeroes_num);
 							/* 0-th item in S0 can be only of DIRECT type when l_n != 0 */
 							{
 								int version;
@@ -488,9 +471,9 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 								RFALSE(ih_item_len(item_head(tbS0, 0)),
 								     "PAP-12106: item length must be 0");
 								RFALSE(comp_short_le_keys(leaf_key(tbS0, 0), leaf_key
-								      (tb->L[0], n + item_pos - ret_val)),
+								      (tb->L[0], n + tb->item_pos - ret_val)),
 								     "PAP-12107: items must be of the same file");
-								if (is_indirect_le_ih(item_head(tb->L[0], n + item_pos - ret_val))) {
+								if (is_indirect_le_ih(item_head(tb->L[0], n + tb->item_pos - ret_val))) {
 									temp_l = l_n << (tb->tb_sb-> s_blocksize_bits - UNFM_P_SHIFT);
 								}
 								/* update key of first item in S0 */
@@ -503,12 +486,12 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 							}
 
 							/* Calculate new body, position in item and insert_size[0] */
-							if (l_n > zeros_num) {
-								body += (l_n - zeros_num);
-								zeros_num = 0;
+							if (l_n > tb->zeroes_num) {
+								body += (l_n - tb->zeroes_num);
+								tb->zeroes_num = 0;
 							} else
-								zeros_num -= l_n;
-							pos_in_item = 0;
+								tb->zeroes_num -= l_n;
+							tb->pos_in_item = 0;
 
 							RFALSE(comp_short_le_keys(leaf_key(tbS0, 0), leaf_key(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1))
 							     || !op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size)
@@ -517,9 +500,9 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 						} else {	/* only part of the appended item will be in L[0] */
 
 							/* Calculate position in item for append in S[0] */
-							pos_in_item -= tb->lbytes;
+							tb->pos_in_item -= tb->lbytes;
 
-							RFALSE(pos_in_item <= 0, "PAP-12125: no place for paste. pos_in_item=%d", pos_in_item);
+							RFALSE(tb->pos_in_item <= 0, "PAP-12125: no place for paste. pos_in_item=%d", tb->pos_in_item);
 
 							/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
 							leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
@@ -529,29 +512,29 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 
 					struct item_head *pasted;
 
-					if (!item_pos && op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size)) {	/* if we paste into first item of S[0] and it is left mergable */
+					if (!tb->item_pos && op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size)) {	/* if we paste into first item of S[0] and it is left mergable */
 						/* then increment pos_in_item by the size of the last item in L[0] */
 						pasted = item_head(tb->L[0], n - 1);
 						if (is_direntry_le_ih(pasted))
-							pos_in_item += ih_entry_count(pasted);
+							tb->pos_in_item += ih_entry_count(pasted);
 						else
-							pos_in_item += ih_item_len(pasted);
+							tb->pos_in_item += ih_item_len(pasted);
 					}
 
 					/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
 					ret_val = leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
 					/* Append to body of item in L[0] */
 					buffer_info_init_left(tb, &bi);
-					leaf_paste_in_buffer(&bi, n + item_pos - ret_val,
-							     pos_in_item,
+					leaf_paste_in_buffer(&bi, n + tb->item_pos - ret_val,
+							     tb->pos_in_item,
 							     tb->insert_size[0],
-							     body, zeros_num);
+							     body, tb->zeroes_num);
 
 					/* if appended item is directory, paste entry */
-					pasted = item_head(tb->L[0], n + item_pos - ret_val);
+					pasted = item_head(tb->L[0], n + tb->item_pos - ret_val);
 					if (is_direntry_le_ih(pasted))
-						leaf_paste_entries(&bi, n + item_pos - ret_val,
-								   pos_in_item, 1,
+						leaf_paste_entries(&bi, n + tb->item_pos - ret_val,
+								   tb->pos_in_item, 1,
 								   (struct reiserfs_de_head *) body,
 								   body + DEH_SIZE,
 								   tb->insert_size[0]);
@@ -559,7 +542,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 					if (is_indirect_le_ih(pasted))
 						set_ih_free_space(pasted, 0);
 					tb->insert_size[0] = 0;
-					zeros_num = 0;
+					tb->zeroes_num = 0;
 				}
 				break;
 			default:	/* cases d and t */
@@ -576,7 +559,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 
 	/* tb->lnum[0] > 0 */
 	/* Calculate new item position */
-	item_pos -= (tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0));
+	tb->item_pos -= (tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0));
 
 	if (tb->rnum[0] > 0) {
 		/* shift rnum[0] items from S[0] to the right neighbor R[0] */
@@ -584,9 +567,9 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 		switch (flag) {
 
 		case M_INSERT:	/* insert item */
-			if (n - tb->rnum[0] < item_pos) {	/* new item or its part falls to R[0] */
-				if (item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1) {	/* part of new item falls into R[0] */
-					loff_t old_key_comp, old_len, r_zeros_number;
+			if (n - tb->rnum[0] < tb->item_pos) {	/* new item or its part falls to R[0] */
+				if (tb->item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1) {	/* part of new item falls into R[0] */
+					loff_t old_key_comp, old_len, r_zeroes_number;
 					const char *r_body;
 					int version;
 					loff_t offset;
@@ -604,17 +587,17 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 					put_ih_item_len(ih, tb->rbytes);
 					/* Insert part of the item into R[0] */
 					buffer_info_init_right(tb, &bi);
-					if ((old_len - tb->rbytes) > zeros_num) {
-						r_zeros_number = 0;
-						r_body = body + (old_len - tb->rbytes) - zeros_num;
+					if ((old_len - tb->rbytes) > tb->zeroes_num) {
+						r_zeroes_number = 0;
+						r_body = body + (old_len - tb->rbytes) - tb->zeroes_num;
 					} else {
 						r_body = body;
-						r_zeros_number = zeros_num - (old_len - tb->rbytes);
-						zeros_num -= r_zeros_number;
+						r_zeroes_number = tb->zeroes_num - (old_len - tb->rbytes);
+						tb->zeroes_num -= r_zeroes_number;
 					}
 
 					leaf_insert_into_buf(&bi, 0, ih, r_body,
-							     r_zeros_number);
+							     r_zeroes_number);
 
 					/* Replace right delimiting key by first key in R[0] */
 					replace_key(tb, tb->CFR[0], tb->rkey[0],
@@ -632,16 +615,16 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 					ret_val = leaf_shift_right(tb, tb->rnum[0] - 1, tb->rbytes);
 					/* Insert new item into R[0] */
 					buffer_info_init_right(tb, &bi);
-					leaf_insert_into_buf(&bi, item_pos - n + tb->rnum[0] - 1,
-							     ih, body, zeros_num);
+					leaf_insert_into_buf(&bi, tb->item_pos - n + tb->rnum[0] - 1,
+							     ih, body, tb->zeroes_num);
 
-					if (item_pos - n + tb->rnum[0] - 1 == 0) {
+					if (tb->item_pos - n + tb->rnum[0] - 1 == 0) {
 						replace_key(tb, tb->CFR[0],
 							    tb->rkey[0],
 							    tb->R[0], 0);
 
 					}
-					zeros_num = tb->insert_size[0] = 0;
+					tb->zeroes_num = tb->insert_size[0] = 0;
 				}
 			} else {	/* new item or part of it doesn't fall into R[0] */
 
@@ -651,17 +634,17 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 
 		case M_PASTE:	/* append item */
 
-			if (n - tb->rnum[0] <= item_pos) {	/* pasted item or part of it falls to R[0] */
-				if (item_pos == n - tb->rnum[0] && tb->rbytes != -1) {	/* we must shift the part of the appended item */
-					if (is_direntry_le_ih(item_head(tbS0, item_pos))) {	/* we append to directory item */
+			if (n - tb->rnum[0] <= tb->item_pos) {	/* pasted item or part of it falls to R[0] */
+				if (tb->item_pos == n - tb->rnum[0] && tb->rbytes != -1) {	/* we must shift the part of the appended item */
+					if (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {	/* we append to directory item */
 						int entry_count;
 
-						RFALSE(zeros_num,
+						RFALSE(tb->zeroes_num,
 						       "PAP-12145: invalid parameter in case of a directory");
 						entry_count = ih_entry_count(item_head
-								  (tbS0, item_pos));
+								  (tbS0, tb->item_pos));
 						if (entry_count - tb->rbytes <
-						    pos_in_item)
+						    tb->pos_in_item)
 							/* new directory entry falls into R[0] */
 						{
 							int paste_entry_position;
@@ -672,9 +655,9 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 							/* Shift rnum[0]-1 items in whole. Shift rbytes-1 directory entries from directory item number rnum[0] */
 							leaf_shift_right(tb, tb->rnum[0], tb->rbytes - 1);
 							/* Paste given directory entry to directory item */
-							paste_entry_position = pos_in_item - entry_count + tb->rbytes - 1;
+							paste_entry_position = tb->pos_in_item - entry_count + tb->rbytes - 1;
 							buffer_info_init_right(tb, &bi);
-							leaf_paste_in_buffer(&bi, 0, paste_entry_position, tb->insert_size[0], body, zeros_num);
+							leaf_paste_in_buffer(&bi, 0, paste_entry_position, tb->insert_size[0], body, tb->zeroes_num);
 							/* paste entry */
 							leaf_paste_entries(&bi, 0, paste_entry_position, 1,
 									   (struct reiserfs_de_head *) body,
@@ -686,25 +669,25 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 							}
 
 							tb->insert_size[0] = 0;
-							pos_in_item++;
+							tb->pos_in_item++;
 						} else {	/* new directory entry doesn't fall into R[0] */
 
 							leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
 						}
 					} else {	/* regular object */
 
-						int n_shift, n_rem, r_zeros_number;
+						int n_shift, n_rem, r_zeroes_number;
 						const char *r_body;
 
 						/* Calculate number of bytes which must be shifted from appended item */
 						if ((n_shift = tb->rbytes - tb->insert_size[0]) < 0)
 							n_shift = 0;
 
-						RFALSE(pos_in_item != ih_item_len
-						       (item_head(tbS0, item_pos)),
+						RFALSE(tb->pos_in_item != ih_item_len
+						       (item_head(tbS0, tb->item_pos)),
 						       "PAP-12155: invalid position to paste. ih_item_len=%d, pos_in_item=%d",
-						       pos_in_item, ih_item_len
-						       (item_head(tbS0, item_pos)));
+						       tb->pos_in_item, ih_item_len
+						       (item_head(tbS0, tb->item_pos)));
 
 						leaf_shift_right(tb, tb->rnum[0], n_shift);
 						/* Calculate number of bytes which must remain in body after appending to R[0] */
@@ -730,18 +713,18 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 
 						/* Append part of body into R[0] */
 						buffer_info_init_right(tb, &bi);
-						if (n_rem > zeros_num) {
-							r_zeros_number = 0;
-							r_body = body + n_rem - zeros_num;
+						if (n_rem > tb->zeroes_num) {
+							r_zeroes_number = 0;
+							r_body = body + n_rem - tb->zeroes_num;
 						} else {
 							r_body = body;
-							r_zeros_number = zeros_num - n_rem;
-							zeros_num -= r_zeros_number;
+							r_zeroes_number = tb->zeroes_num - n_rem;
+							tb->zeroes_num -= r_zeroes_number;
 						}
 
 						leaf_paste_in_buffer(&bi, 0, n_shift,
 								     tb->insert_size[0] - n_rem,
-								     r_body, r_zeros_number);
+								     r_body, r_zeroes_number);
 
 						if (is_indirect_le_ih(item_head(tb->R[0], 0))) {
 #if 0
@@ -752,7 +735,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 						}
 						tb->insert_size[0] = n_rem;
 						if (!n_rem)
-							pos_in_item++;
+							tb->pos_in_item++;
 					}
 				} else {	/* pasted item in whole falls into R[0] */
 
@@ -760,22 +743,22 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 
 					ret_val = leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
 					/* append item in R[0] */
-					if (pos_in_item >= 0) {
+					if (tb->pos_in_item >= 0) {
 						buffer_info_init_right(tb, &bi);
-						leaf_paste_in_buffer(&bi, item_pos - n + tb->rnum[0], pos_in_item,
-								     tb->insert_size[0], body, zeros_num);
+						leaf_paste_in_buffer(&bi, tb->item_pos - n + tb->rnum[0], tb->pos_in_item,
+								     tb->insert_size[0], body, tb->zeroes_num);
 					}
 
 					/* paste new entry, if item is directory item */
-					pasted = item_head(tb->R[0], item_pos - n + tb->rnum[0]);
-					if (is_direntry_le_ih(pasted) && pos_in_item >= 0) {
-						leaf_paste_entries(&bi, item_pos - n + tb->rnum[0],
-								   pos_in_item, 1,
+					pasted = item_head(tb->R[0], tb->item_pos - n + tb->rnum[0]);
+					if (is_direntry_le_ih(pasted) && tb->pos_in_item >= 0) {
+						leaf_paste_entries(&bi, tb->item_pos - n + tb->rnum[0],
+								   tb->pos_in_item, 1,
 								   (struct reiserfs_de_head *) body,
 								   body + DEH_SIZE, tb->insert_size[0]);
-						if (!pos_in_item) {
+						if (!tb->pos_in_item) {
 
-							RFALSE(item_pos - n + tb->rnum[0],
+							RFALSE(tb->item_pos - n + tb->rnum[0],
 							       "PAP-12165: directory item must be first item of node when pasting is in 0th position");
 
 							/* update delimiting keys */
@@ -785,7 +768,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 
 					if (is_indirect_le_ih(pasted))
 						set_ih_free_space(pasted, 0);
-					zeros_num = tb->insert_size[0] = 0;
+					tb->zeroes_num = tb->insert_size[0] = 0;
 				}
 			} else {	/* new item doesn't fall into R[0] */
 
@@ -834,39 +817,34 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 	}
 
 	/* Fill new nodes that appear in place of S[0] */
-
-	/* I am told that this copying is because we need an array to enable
-	   the looping code. -Hans */
-	snum[0] = tb->s1num, snum[1] = tb->s2num;
-	sbytes[0] = tb->s1bytes;
-	sbytes[1] = tb->s2bytes;
 	for (i = tb->blknum[0] - 2; i >= 0; i--) {
 
-		RFALSE(!snum[i], "PAP-12200: snum[%d] == %d. Must be > 0", i,
-		       snum[i]);
+		RFALSE(!tb->snum[i],
+		       "PAP-12200: snum[%d] == %d. Must be > 0", i,
+		       tb->snum[i]);
 
 		/* here we shift from S to S_new nodes */
 
-		S_new[i] = get_FEB(tb);
+		tb->S_new[i] = get_FEB(tb);
 
 		/* initialized block type and tree level */
-		set_blkh_level(B_BLK_HEAD(S_new[i]), DISK_LEAF_NODE_LEVEL);
+		set_blkh_level(B_BLK_HEAD(tb->S_new[i]), DISK_LEAF_NODE_LEVEL);
 
 		n = B_NR_ITEMS(tbS0);
 
 		switch (flag) {
 		case M_INSERT:	/* insert item */
 
-			if (n - snum[i] < item_pos) {	/* new item or it's part falls to first new node S_new[i] */
-				if (item_pos == n - snum[i] + 1 && sbytes[i] != -1) {	/* part of new item falls into S_new[i] */
-					int old_key_comp, old_len, r_zeros_number;
+			if (n - tb->snum[i] < tb->item_pos) {	/* new item or it's part falls to first new node S_new[i] */
+				if (tb->item_pos == n - tb->snum[i] + 1 && tb->sbytes[i] != -1) {	/* part of new item falls into S_new[i] */
+					int old_key_comp, old_len, r_zeroes_number;
 					const char *r_body;
 					int version;
 
 					/* Move snum[i]-1 items from S[0] to S_new[i] */
 					leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-							snum[i] - 1, -1,
-							S_new[i]);
+							tb->snum[i] - 1, -1,
+							tb->S_new[i]);
 					/* Remember key component and item length */
 					version = ih_version(ih);
 					old_key_comp = le_ih_k_offset(ih);
@@ -874,59 +852,59 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 
 					/* Calculate key component and item length to insert into S_new[i] */
 					set_le_ih_k_offset(ih, le_ih_k_offset(ih) +
-							   ((old_len - sbytes[i]) << (is_indirect_le_ih(ih) ? tb->tb_sb-> s_blocksize_bits - UNFM_P_SHIFT : 0)));
+							   ((old_len - tb->sbytes[i]) << (is_indirect_le_ih(ih) ? tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT : 0)));
 
-					put_ih_item_len(ih, sbytes[i]);
+					put_ih_item_len(ih, tb->sbytes[i]);
 
 					/* Insert part of the item into S_new[i] before 0-th item */
-					buffer_info_init_bh(tb, &bi, S_new[i]);
+					buffer_info_init_bh(tb, &bi, tb->S_new[i]);
 
-					if ((old_len - sbytes[i]) > zeros_num) {
-						r_zeros_number = 0;
-						r_body = body + (old_len - sbytes[i]) - zeros_num;
+					if ((old_len - tb->sbytes[i]) > tb->zeroes_num) {
+						r_zeroes_number = 0;
+						r_body = body + (old_len - tb->sbytes[i]) - tb->zeroes_num;
 					} else {
 						r_body = body;
-						r_zeros_number = zeros_num - (old_len - sbytes[i]);
-						zeros_num -= r_zeros_number;
+						r_zeroes_number = tb->zeroes_num - (old_len - tb->sbytes[i]);
+						tb->zeroes_num -= r_zeroes_number;
 					}
 
-					leaf_insert_into_buf(&bi, 0, ih, r_body, r_zeros_number);
+					leaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);
 
 					/* Calculate key component and item length to insert into S[i] */
 					set_le_ih_k_offset(ih, old_key_comp);
-					put_ih_item_len(ih, old_len - sbytes[i]);
-					tb->insert_size[0] -= sbytes[i];
+					put_ih_item_len(ih, old_len - tb->sbytes[i]);
+					tb->insert_size[0] -= tb->sbytes[i];
 				} else {	/* whole new item falls into S_new[i] */
 
 					/* Shift snum[0] - 1 items to S_new[i] (sbytes[i] of split item) */
 					leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-							snum[i] - 1, sbytes[i], S_new[i]);
+							tb->snum[i] - 1, tb->sbytes[i], tb->S_new[i]);
 
 					/* Insert new item into S_new[i] */
-					buffer_info_init_bh(tb, &bi, S_new[i]);
-					leaf_insert_into_buf(&bi, item_pos - n + snum[i] - 1,
-							     ih, body, zeros_num);
+					buffer_info_init_bh(tb, &bi, tb->S_new[i]);
+					leaf_insert_into_buf(&bi, tb->item_pos - n + tb->snum[i] - 1,
+							     ih, body, tb->zeroes_num);
 
-					zeros_num = tb->insert_size[0] = 0;
+					tb->zeroes_num = tb->insert_size[0] = 0;
 				}
 			}
 
 			else {	/* new item or it part don't falls into S_new[i] */
 
 				leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-						snum[i], sbytes[i], S_new[i]);
+						tb->snum[i], tb->sbytes[i], tb->S_new[i]);
 			}
 			break;
 
 		case M_PASTE:	/* append item */
 
-			if (n - snum[i] <= item_pos) {	/* pasted item or part if it falls to S_new[i] */
-				if (item_pos == n - snum[i] && sbytes[i] != -1) {	/* we must shift part of the appended item */
+			if (n - tb->snum[i] <= tb->item_pos) {	/* pasted item or part if it falls to S_new[i] */
+				if (tb->item_pos == n - tb->snum[i] && tb->sbytes[i] != -1) {	/* we must shift part of the appended item */
 					struct item_head *aux_ih;
 
 					RFALSE(ih, "PAP-12210: ih must be 0");
 
-					aux_ih = item_head(tbS0, item_pos);
+					aux_ih = item_head(tbS0, tb->item_pos);
 					if (is_direntry_le_ih(aux_ih)) {
 						/* we append to directory item */
 
@@ -934,65 +912,65 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 
 						entry_count = ih_entry_count(aux_ih);
 
-						if (entry_count - sbytes[i] < pos_in_item && pos_in_item <= entry_count) {
+						if (entry_count - tb->sbytes[i] < tb->pos_in_item && tb->pos_in_item <= entry_count) {
 							/* new directory entry falls into S_new[i] */
 
 							RFALSE(!tb->insert_size[0], "PAP-12215: insert_size is already 0");
-							RFALSE(sbytes[i] - 1 >= entry_count,
+							RFALSE(tb->sbytes[i] - 1 >= entry_count,
 							       "PAP-12220: there are no so much entries (%d), only %d",
-							       sbytes[i] - 1, entry_count);
+							       tb->sbytes[i] - 1, entry_count);
 
 							/* Shift snum[i]-1 items in whole. Shift sbytes[i] directory entries from directory item number snum[i] */
-							leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i] - 1, S_new[i]);
+							leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], tb->sbytes[i] - 1, tb->S_new[i]);
 							/* Paste given directory entry to directory item */
-							buffer_info_init_bh(tb, &bi, S_new[i]);
-							leaf_paste_in_buffer(&bi, 0, pos_in_item - entry_count + sbytes[i] - 1,
-							     tb->insert_size[0], body, zeros_num);
+							buffer_info_init_bh(tb, &bi, tb->S_new[i]);
+							leaf_paste_in_buffer(&bi, 0, tb->pos_in_item - entry_count + tb->sbytes[i] - 1,
+							     tb->insert_size[0], body, tb->zeroes_num);
 							/* paste new directory entry */
-							leaf_paste_entries(&bi, 0, pos_in_item - entry_count + sbytes[i] - 1, 1,
+							leaf_paste_entries(&bi, 0, tb->pos_in_item - entry_count + tb->sbytes[i] - 1, 1,
 									   (struct reiserfs_de_head *) body,
 									   body + DEH_SIZE, tb->insert_size[0]);
 							tb->insert_size[0] = 0;
-							pos_in_item++;
+							tb->pos_in_item++;
 						} else {	/* new directory entry doesn't fall into S_new[i] */
-							leaf_move_items(LEAF_FROM_S_TO_SNEW,tb, snum[i], sbytes[i], S_new[i]);
+							leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], tb->sbytes[i], tb->S_new[i]);
 						}
 					} else {	/* regular object */
 
-						int n_shift, n_rem, r_zeros_number;
+						int n_shift, n_rem, r_zeroes_number;
 						const char *r_body;
 
-						RFALSE(pos_in_item != ih_item_len(item_head(tbS0, item_pos)) || tb->insert_size[0] <= 0,
+						RFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)) || tb->insert_size[0] <= 0,
 						       "PAP-12225: item too short or insert_size <= 0");
 
 						/* Calculate number of bytes which must be shifted from appended item */
-						n_shift = sbytes[i] - tb->insert_size[0];
+						n_shift = tb->sbytes[i] - tb->insert_size[0];
 						if (n_shift < 0)
 							n_shift = 0;
-						leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, snum[i], n_shift, S_new[i]);
+						leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], n_shift, tb->S_new[i]);
 
 						/* Calculate number of bytes which must remain in body after append to S_new[i] */
-						n_rem = tb->insert_size[0] - sbytes[i];
+						n_rem = tb->insert_size[0] - tb->sbytes[i];
 						if (n_rem < 0)
 							n_rem = 0;
 						/* Append part of body into S_new[0] */
-						buffer_info_init_bh(tb, &bi, S_new[i]);
-						if (n_rem > zeros_num) {
-							r_zeros_number = 0;
-							r_body = body + n_rem - zeros_num;
+						buffer_info_init_bh(tb, &bi, tb->S_new[i]);
+						if (n_rem > tb->zeroes_num) {
+							r_zeroes_number = 0;
+							r_body = body + n_rem - tb->zeroes_num;
 						} else {
 							r_body = body;
-							r_zeros_number = zeros_num - n_rem;
-							zeros_num -= r_zeros_number;
+							r_zeroes_number = tb->zeroes_num - n_rem;
+							tb->zeroes_num -= r_zeroes_number;
 						}
 
 						leaf_paste_in_buffer(&bi, 0, n_shift,
 								     tb->insert_size[0] - n_rem,
-								     r_body, r_zeros_number);
+								     r_body, r_zeroes_number);
 						{
 							struct item_head *tmp;
 
-							tmp = item_head(S_new[i], 0);
+							tmp = item_head(tb->S_new[i], 0);
 							if (is_indirect_le_ih
 							    (tmp)) {
 								set_ih_free_space(tmp, 0);
@@ -1004,7 +982,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 
 						tb->insert_size[0] = n_rem;
 						if (!n_rem)
-							pos_in_item++;
+							tb->pos_in_item++;
 					}
 				} else
 					/* item falls wholly into S_new[i] */
@@ -1013,10 +991,10 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 					struct item_head *pasted;
 
 #ifdef CONFIG_REISERFS_CHECK
-					struct item_head *ih_check = item_head(tbS0, item_pos);
+					struct item_head *ih_check = item_head(tbS0, tb->item_pos);
 
 					if (!is_direntry_le_ih(ih_check)
-					    && (pos_in_item != ih_item_len(ih_check)
+					    && (tb->pos_in_item != ih_item_len(ih_check)
 						|| tb->insert_size[0] <= 0))
 						reiserfs_panic(tb->tb_sb,
 							     "PAP-12235",
@@ -1026,27 +1004,27 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 #endif				/* CONFIG_REISERFS_CHECK */
 
 					leaf_mi = leaf_move_items(LEAF_FROM_S_TO_SNEW,
-							    tb, snum[i],
-							    sbytes[i],
-							    S_new[i]);
+							    tb, tb->snum[i],
+							    tb->sbytes[i],
+							    tb->S_new[i]);
 
 					RFALSE(leaf_mi,
 					       "PAP-12240: unexpected value returned by leaf_move_items (%d)",
 					       leaf_mi);
 
 					/* paste into item */
-					buffer_info_init_bh(tb, &bi, S_new[i]);
+					buffer_info_init_bh(tb, &bi, tb->S_new[i]);
 					leaf_paste_in_buffer(&bi,
-							     item_pos - n + snum[i],
-							     pos_in_item,
+							     tb->item_pos - n + tb->snum[i],
+							     tb->pos_in_item,
 							     tb->insert_size[0],
-							     body, zeros_num);
+							     body, tb->zeroes_num);
 
-					pasted = item_head(S_new[i], item_pos - n + snum[i]);
+					pasted = item_head(tb->S_new[i], tb->item_pos - n + tb->snum[i]);
 					if (is_direntry_le_ih(pasted)) {
 						leaf_paste_entries(&bi,
-								   item_pos - n + snum[i],
-								   pos_in_item, 1,
+								   tb->item_pos - n + tb->snum[i],
+								   tb->pos_in_item, 1,
 								   (struct reiserfs_de_head *)body,
 								   body + DEH_SIZE,
 								   tb->insert_size[0]
@@ -1056,14 +1034,14 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 					/* if we paste to indirect item update ih_free_space */
 					if (is_indirect_le_ih(pasted))
 						set_ih_free_space(pasted, 0);
-					zeros_num = tb->insert_size[0] = 0;
+					tb->zeroes_num = tb->insert_size[0] = 0;
 				}
 			}
 
 			else {	/* pasted item doesn't fall into S_new[i] */
 
 				leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-						snum[i], sbytes[i], S_new[i]);
+						tb->snum[i], tb->sbytes[i], tb->S_new[i]);
 			}
 			break;
 		default:	/* cases d and t */
@@ -1072,27 +1050,28 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 				       (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
 		}
 
-		memcpy(insert_key + i, leaf_key(S_new[i], 0), KEY_SIZE);
-		insert_ptr[i] = S_new[i];
+		memcpy(insert_key + i, leaf_key(tb->S_new[i], 0), KEY_SIZE);
+		insert_ptr[i] = tb->S_new[i];
 
-		RFALSE(!buffer_journaled(S_new[i])
-		       || buffer_journal_dirty(S_new[i])
-		       || buffer_dirty(S_new[i]), "PAP-12247: S_new[%d] : (%b)",
-		       i, S_new[i]);
+		RFALSE(!buffer_journaled(tb->S_new[i])
+		       || buffer_journal_dirty(tb->S_new[i])
+		       || buffer_dirty(tb->S_new[i]),
+		       "PAP-12247: S_new[%d] : (%b)",
+		       i, tb->S_new[i]);
 	}
 
 	/* if the affected item was not wholly shifted then we perform all necessary operations on that part or whole of the
 	   affected item which remains in S */
-	if (0 <= item_pos && item_pos < tb->s0num) {	/* if we must insert or append into buffer S[0] */
+	if (0 <= tb->item_pos && tb->item_pos < tb->s0num) {	/* if we must insert or append into buffer S[0] */
 
 		switch (flag) {
 		case M_INSERT:	/* insert item into S[0] */
 			buffer_info_init_tbS0(tb, &bi);
-			leaf_insert_into_buf(&bi, item_pos, ih, body,
-					     zeros_num);
+			leaf_insert_into_buf(&bi, tb->item_pos, ih,
+					     body, tb->zeroes_num);
 
 			/* If we insert the first key change the delimiting key */
-			if (item_pos == 0) {
+			if (tb->item_pos == 0) {
 				if (tb->CFL[0])	/* can be 0 in reiserfsck */
 					replace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);
 			}
@@ -1101,26 +1080,26 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 		case M_PASTE:{	/* append item in S[0] */
 				struct item_head *pasted;
 
-				pasted = item_head(tbS0, item_pos);
+				pasted = item_head(tbS0, tb->item_pos);
 				/* when directory, may be new entry already pasted */
 				if (is_direntry_le_ih(pasted)) {
-					if (pos_in_item >= 0 && pos_in_item <= ih_entry_count(pasted)) {
+					if (tb->pos_in_item >= 0 && tb->pos_in_item <= ih_entry_count(pasted)) {
 
 						RFALSE(!tb->insert_size[0],
 						       "PAP-12260: insert_size is 0 already");
 
 						/* prepare space */
 						buffer_info_init_tbS0(tb, &bi);
-						leaf_paste_in_buffer(&bi, item_pos, pos_in_item,
+						leaf_paste_in_buffer(&bi, tb->item_pos, tb->pos_in_item,
 								     tb->insert_size[0], body,
-								     zeros_num);
+								     tb->zeroes_num);
 
 						/* paste entry */
-						leaf_paste_entries(&bi, item_pos, pos_in_item, 1,
+						leaf_paste_entries(&bi, tb->item_pos, tb->pos_in_item, 1,
 								   (struct reiserfs_de_head *)body,
 								   body + DEH_SIZE,
 								   tb->insert_size[0]);
-						if (!item_pos && !pos_in_item) {
+						if (!tb->item_pos && !tb->pos_in_item) {
 							RFALSE(!tb->CFL[0] || !tb->L[0],
 							       "PAP-12270: CFL[0]/L[0] must be specified");
 							if (tb->CFL[0])
@@ -1129,14 +1108,14 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
 						tb->insert_size[0] = 0;
 					}
 				} else {	/* regular object */
-					if (pos_in_item == ih_item_len(pasted)) {
+					if (tb->pos_in_item == ih_item_len(pasted)) {
 
 						RFALSE(tb->insert_size[0] <= 0,
 						       "PAP-12275: insert size must not be %d",
 						       tb->insert_size[0]);
 						buffer_info_init_tbS0(tb, &bi);
-						leaf_paste_in_buffer(&bi, item_pos, pos_in_item,
-								     tb->insert_size[0], body, zeros_num);
+						leaf_paste_in_buffer(&bi, tb->item_pos, tb->pos_in_item,
+								     tb->insert_size[0], body, tb->zeroes_num);
 
 						if (is_indirect_le_ih(pasted)) {
 #if 0

commit 97fd4b97a947dc9d11dee1bbcceca7a124df9e4e
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:45 2014 -0400

    reiserfs: balance_leaf refactor, reformat balance_leaf comments
    
    The comments in balance_leaf are as bad as the code. This patch shifts
    them around to fit in 80 columns and be easier to read.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index bfed0f6d9185..bbc282b7007c 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -290,31 +290,43 @@ static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 	return 0;
 }
 
-static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item header of inserted item (this is on little endian) */
-			const char *body,	/* body  of inserted item or bytes to paste */
-			int flag,	/* i - insert, d - delete, c - cut, p - paste
-					   (see comment to do_balance) */
-			struct item_head *insert_key,	/* in our processing of one level we sometimes determine what
-							   must be inserted into the next higher level.  This insertion
-							   consists of a key or two keys and their corresponding
-							   pointers */
-			struct buffer_head **insert_ptr	/* inserted node-ptrs for the next level */
-    )
+/**
+ * balance_leaf - reiserfs tree balancing algorithm
+ * @tb: tree balance state
+ * @ih: item header of inserted item (little endian)
+ * @body: body of inserted item or bytes to paste
+ * @flag: i - insert, d - delete, c - cut, p - paste (see do_balance)
+ * passed back:
+ * @insert_key: key to insert new nodes
+ * @insert_ptr: array of nodes to insert at the next level
+ *
+ * In our processing of one level we sometimes determine what must be
+ * inserted into the next higher level.  This insertion consists of a
+ * key or two keys and their corresponding pointers.
+ */
+static int balance_leaf(struct tree_balance *tb, struct item_head *ih,
+			const char *body, int flag,
+			struct item_head *insert_key,
+			struct buffer_head **insert_ptr)
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
-	int item_pos = PATH_LAST_POSITION(tb->tb_path);	/*  index into the array of item headers in S[0]
-							   of the affected item */
+	/* index into the array of item headers in S[0] of the affected item */
+	int item_pos = PATH_LAST_POSITION(tb->tb_path);
 	struct buffer_info bi;
-	struct buffer_head *S_new[2];	/* new nodes allocated to hold what could not fit into S */
-	int snum[2];		/* number of items that will be placed
-				   into S_new (includes partially shifted
-				   items) */
-	int sbytes[2];		/* if an item is partially shifted into S_new then
-				   if it is a directory item
-				   it is the number of entries from the item that are shifted into S_new
-				   else
-				   it is the number of bytes from the item that are shifted into S_new
-				 */
+	/* new nodes allocated to hold what could not fit into S */
+	struct buffer_head *S_new[2];
+	/*
+	 * number of items that will be placed into S_new
+	 * (includes partially shifted items)
+	 */
+	int snum[2];
+	/*
+	 * if an item is partially shifted into S_new then if it is a
+	 * directory item it is the number of entries from the item that
+	 * are shifted into S_new else it is the number of bytes from
+	 * the item that are shifted into S_new
+	 */
+	int sbytes[2];
 	int n, i;
 	int ret_val;
 	int pos_in_item;
@@ -331,8 +343,10 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 		zeros_num = ih_item_len(ih);
 
 	pos_in_item = tb->tb_path->pos_in_item;
-	/* for indirect item pos_in_item is measured in unformatted node
-	   pointers. Recalculate to bytes */
+	/*
+	 * for indirect item pos_in_item is measured in unformatted node
+	 * pointers. Recalculate to bytes
+	 */
 	if (flag != M_INSERT
 	    && is_indirect_le_ih(item_head(tbS0, item_pos)))
 		pos_in_item *= UNFM_P_SIZE;
@@ -792,16 +806,20 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 	RFALSE(tb->blknum[0] < 0,
 	       "PAP-12185: blknum can not be %d. It must be >= 0", tb->blknum[0]);
 
-	/* if while adding to a node we discover that it is possible to split
-	   it in two, and merge the left part into the left neighbor and the
-	   right part into the right neighbor, eliminating the node */
+	/*
+	 * if while adding to a node we discover that it is possible to split
+	 * it in two, and merge the left part into the left neighbor and the
+	 * right part into the right neighbor, eliminating the node
+	 */
 	if (tb->blknum[0] == 0) {	/* node S[0] is empty now */
 
 		RFALSE(!tb->lnum[0] || !tb->rnum[0],
 		       "PAP-12190: lnum and rnum must not be zero");
-		/* if insertion was done before 0-th position in R[0], right
-		   delimiting key of the tb->L[0]'s and left delimiting key are
-		   not set correctly */
+		/*
+		 * if insertion was done before 0-th position in R[0], right
+		 * delimiting key of the tb->L[0]'s and left delimiting key are
+		 * not set correctly
+		 */
 		if (tb->CFL[0]) {
 			if (!tb->CFR[0])
 				reiserfs_panic(tb->tb_sb, "vs-12195",
@@ -1159,9 +1177,11 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 			       "PAP-12290", "insert_size is still not 0 (%d)",
 			       tb->insert_size[0]);
 	}
-#endif				/* CONFIG_REISERFS_CHECK */
+#endif
+
+	/* Leaf level of the tree is balanced (end of balance_leaf) */
 	return 0;
-}				/* Leaf level of the tree is balanced (end of balance_leaf) */
+}
 
 /* Make empty node */
 void make_empty_node(struct buffer_info *bi)

commit a228bf8f0a3e5f1406edbd61f7400e87e23af5f7
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:42 2014 -0400

    reiserfs: cleanup, remove unnecessary parens
    
    The reiserfs code is littered with extra parens in places where the authors
    may not have been certain about precedence of & vs ->. This patch cleans them
    out.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 7decd932bf82..bfed0f6d9185 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -1575,7 +1575,7 @@ void do_balance(struct tree_balance *tb, struct item_head *ih,
 		return;
 	}
 
-	atomic_inc(&(fs_generation(tb->tb_sb)));
+	atomic_inc(&fs_generation(tb->tb_sb));
 	do_balance_starts(tb);
 
 	/*

commit 09f1b80ba8c967b6e17c0516e95578d5da18115f
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:39 2014 -0400

    reiserfs: cleanup, remove sb argument from journal_mark_dirty
    
    journal_mark_dirty doesn't need a separate sb argument; It's provided
    by the transaction handle.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 399b2009b677..7decd932bf82 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -56,8 +56,7 @@ static inline void buffer_info_init_bh(struct tree_balance *tb,
 inline void do_balance_mark_leaf_dirty(struct tree_balance *tb,
 				       struct buffer_head *bh, int flag)
 {
-	journal_mark_dirty(tb->transaction_handle,
-			   tb->transaction_handle->t_super, bh);
+	journal_mark_dirty(tb->transaction_handle, bh);
 }
 
 #define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty

commit 098297b27d23ad9d0fc302e3417474d9342c6c14
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:36 2014 -0400

    reiserfs: cleanup, reformat comments to normal kernel style
    
    This patch reformats comments in the reiserfs code to fit in 80 columns and
    to follow the style rules.
    
    There is no functional change but it helps make my eyes bleed less.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 80b2b1b37169..399b2009b677 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -2,18 +2,13 @@
  * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
  */
 
-/* Now we have all buffers that must be used in balancing of the tree 	*/
-/* Further calculations can not cause schedule(), and thus the buffer 	*/
-/* tree will be stable until the balancing will be finished 		*/
-/* balance the tree according to the analysis made before,		*/
-/* and using buffers obtained after all above.				*/
-
-/**
- ** balance_leaf_when_delete
- ** balance_leaf
- ** do_balance
- **
- **/
+/*
+ * Now we have all buffers that must be used in balancing of the tree
+ * Further calculations can not cause schedule(), and thus the buffer
+ * tree will be stable until the balancing will be finished
+ * balance the tree according to the analysis made before,
+ * and using buffers obtained after all above.
+ */
 
 #include <asm/uaccess.h>
 #include <linux/time.h>
@@ -68,35 +63,39 @@ inline void do_balance_mark_leaf_dirty(struct tree_balance *tb,
 #define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty
 #define do_balance_mark_sb_dirty do_balance_mark_leaf_dirty
 
-/* summary:
- if deleting something ( tb->insert_size[0] < 0 )
-   return(balance_leaf_when_delete()); (flag d handled here)
- else
-   if lnum is larger than 0 we put items into the left node
-   if rnum is larger than 0 we put items into the right node
-   if snum1 is larger than 0 we put items into the new node s1
-   if snum2 is larger than 0 we put items into the new node s2
-Note that all *num* count new items being created.
-
-It would be easier to read balance_leaf() if each of these summary
-lines was a separate procedure rather than being inlined.  I think
-that there are many passages here and in balance_leaf_when_delete() in
-which two calls to one procedure can replace two passages, and it
-might save cache space and improve software maintenance costs to do so.
-
-Vladimir made the perceptive comment that we should offload most of
-the decision making in this function into fix_nodes/check_balance, and
-then create some sort of structure in tb that says what actions should
-be performed by do_balance.
-
--Hans */
-
-/* Balance leaf node in case of delete or cut: insert_size[0] < 0
+/*
+ * summary:
+ *  if deleting something ( tb->insert_size[0] < 0 )
+ *    return(balance_leaf_when_delete()); (flag d handled here)
+ *  else
+ *    if lnum is larger than 0 we put items into the left node
+ *    if rnum is larger than 0 we put items into the right node
+ *    if snum1 is larger than 0 we put items into the new node s1
+ *    if snum2 is larger than 0 we put items into the new node s2
+ * Note that all *num* count new items being created.
+ *
+ * It would be easier to read balance_leaf() if each of these summary
+ * lines was a separate procedure rather than being inlined.  I think
+ * that there are many passages here and in balance_leaf_when_delete() in
+ * which two calls to one procedure can replace two passages, and it
+ * might save cache space and improve software maintenance costs to do so.
+ *
+ * Vladimir made the perceptive comment that we should offload most of
+ * the decision making in this function into fix_nodes/check_balance, and
+ * then create some sort of structure in tb that says what actions should
+ * be performed by do_balance.
+ *
+ * -Hans
+ */
+
+/*
+ * Balance leaf node in case of delete or cut: insert_size[0] < 0
  *
  * lnum, rnum can have values >= -1
  *	-1 means that the neighbor must be joined with S
  *	 0 means that nothing should be done with the neighbor
- *	>0 means to shift entirely or partly the specified number of items to the neighbor
+ *	>0 means to shift entirely or partly the specified number of items
+ *         to the neighbor
  */
 static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 {
@@ -149,8 +148,16 @@ static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 	case M_CUT:{		/* cut item in S[0] */
 			if (is_direntry_le_ih(ih)) {
 
-				/* UFS unlink semantics are such that you can only delete one directory entry at a time. */
-				/* when we cut a directory tb->insert_size[0] means number of entries to be cut (always 1) */
+				/*
+				 * UFS unlink semantics are such that you
+				 * can only delete one directory entry at
+				 * a time.
+				 */
+
+				/*
+				 * when we cut a directory tb->insert_size[0]
+				 * means number of entries to be cut (always 1)
+				 */
 				tb->insert_size[0] = -1;
 				leaf_cut_from_buffer(&bi, item_pos, pos_in_item,
 						     -tb->insert_size[0]);
@@ -183,13 +190,22 @@ static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 						      "UNKNOWN"), flag);
 	}
 
-	/* the rule is that no shifting occurs unless by shifting a node can be freed */
+	/*
+	 * the rule is that no shifting occurs unless by shifting
+	 * a node can be freed
+	 */
 	n = B_NR_ITEMS(tbS0);
-	if (tb->lnum[0]) {	/* L[0] takes part in balancing */
-		if (tb->lnum[0] == -1) {	/* L[0] must be joined with S[0] */
-			if (tb->rnum[0] == -1) {	/* R[0] must be also joined with S[0] */
+	/* L[0] takes part in balancing */
+	if (tb->lnum[0]) {
+		/* L[0] must be joined with S[0] */
+		if (tb->lnum[0] == -1) {
+			/* R[0] must be also joined with S[0] */
+			if (tb->rnum[0] == -1) {
 				if (tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0)) {
-					/* all contents of all the 3 buffers will be in L[0] */
+					/*
+					 * all contents of all the 3 buffers
+					 * will be in L[0]
+					 */
 					if (PATH_H_POSITION(tb->tb_path, 1) == 0
 					    && 1 < B_NR_ITEMS(tb->FR[0]))
 						replace_key(tb, tb->CFL[0],
@@ -208,7 +224,10 @@ static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 
 					return 0;
 				}
-				/* all contents of all the 3 buffers will be in R[0] */
+				/*
+				 * all contents of all the 3 buffers will
+				 * be in R[0]
+				 */
 				leaf_move_items(LEAF_FROM_S_TO_R, tb, n, -1,
 						NULL);
 				leaf_move_items(LEAF_FROM_L_TO_R, tb,
@@ -233,7 +252,11 @@ static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 
 			return 0;
 		}
-		/* a part of contents of S[0] will be in L[0] and the rest part of S[0] will be in R[0] */
+
+		/*
+		 * a part of contents of S[0] will be in L[0] and the
+		 * rest part of S[0] will be in R[0]
+		 */
 
 		RFALSE((tb->lnum[0] + tb->rnum[0] < n) ||
 		       (tb->lnum[0] + tb->rnum[0] > n + 1),
@@ -1178,9 +1201,7 @@ struct buffer_head *get_FEB(struct tree_balance *tb)
 	return tb->used[i];
 }
 
-/* This is now used because reiserfs_free_block has to be able to
-** schedule.
-*/
+/* This is now used because reiserfs_free_block has to be able to schedule. */
 static void store_thrown(struct tree_balance *tb, struct buffer_head *bh)
 {
 	int i;
@@ -1335,8 +1356,10 @@ static int check_before_balancing(struct tree_balance *tb)
 			       "mount point.");
 	}
 
-	/* double check that buffers that we will modify are unlocked. (fix_nodes should already have
-	   prepped all of these for us). */
+	/*
+	 * double check that buffers that we will modify are unlocked.
+	 * (fix_nodes should already have prepped all of these for us).
+	 */
 	if (tb->lnum[0]) {
 		retval |= locked_or_not_in_tree(tb, tb->L[0], "L[0]");
 		retval |= locked_or_not_in_tree(tb, tb->FL[0], "FL[0]");
@@ -1429,49 +1452,51 @@ static void check_internal_levels(struct tree_balance *tb)
 
 #endif
 
-/* Now we have all of the buffers that must be used in balancing of
-   the tree.  We rely on the assumption that schedule() will not occur
-   while do_balance works. ( Only interrupt handlers are acceptable.)
-   We balance the tree according to the analysis made before this,
-   using buffers already obtained.  For SMP support it will someday be
-   necessary to add ordered locking of tb. */
-
-/* Some interesting rules of balancing:
-
-   we delete a maximum of two nodes per level per balancing: we never
-   delete R, when we delete two of three nodes L, S, R then we move
-   them into R.
-
-   we only delete L if we are deleting two nodes, if we delete only
-   one node we delete S
-
-   if we shift leaves then we shift as much as we can: this is a
-   deliberate policy of extremism in node packing which results in
-   higher average utilization after repeated random balance operations
-   at the cost of more memory copies and more balancing as a result of
-   small insertions to full nodes.
-
-   if we shift internal nodes we try to evenly balance the node
-   utilization, with consequent less balancing at the cost of lower
-   utilization.
-
-   one could argue that the policy for directories in leaves should be
-   that of internal nodes, but we will wait until another day to
-   evaluate this....  It would be nice to someday measure and prove
-   these assumptions as to what is optimal....
+/*
+ * Now we have all of the buffers that must be used in balancing of
+ * the tree.  We rely on the assumption that schedule() will not occur
+ * while do_balance works. ( Only interrupt handlers are acceptable.)
+ * We balance the tree according to the analysis made before this,
+ * using buffers already obtained.  For SMP support it will someday be
+ * necessary to add ordered locking of tb.
+ */
 
-*/
+/*
+ * Some interesting rules of balancing:
+ * we delete a maximum of two nodes per level per balancing: we never
+ * delete R, when we delete two of three nodes L, S, R then we move
+ * them into R.
+ *
+ * we only delete L if we are deleting two nodes, if we delete only
+ * one node we delete S
+ *
+ * if we shift leaves then we shift as much as we can: this is a
+ * deliberate policy of extremism in node packing which results in
+ * higher average utilization after repeated random balance operations
+ * at the cost of more memory copies and more balancing as a result of
+ * small insertions to full nodes.
+ *
+ * if we shift internal nodes we try to evenly balance the node
+ * utilization, with consequent less balancing at the cost of lower
+ * utilization.
+ *
+ * one could argue that the policy for directories in leaves should be
+ * that of internal nodes, but we will wait until another day to
+ * evaluate this....  It would be nice to someday measure and prove
+ * these assumptions as to what is optimal....
+ */
 
 static inline void do_balance_starts(struct tree_balance *tb)
 {
-	/* use print_cur_tb() to see initial state of struct
-	   tree_balance */
+	/* use print_cur_tb() to see initial state of struct tree_balance */
 
 	/* store_print_tb (tb); */
 
 	/* do not delete, just comment it out */
-/*    print_tb(flag, PATH_LAST_POSITION(tb->tb_path), tb->tb_path->pos_in_item, tb,
-	     "check");*/
+	/*
+	print_tb(flag, PATH_LAST_POSITION(tb->tb_path),
+		 tb->tb_path->pos_in_item, tb, "check");
+	*/
 	RFALSE(check_before_balancing(tb), "PAP-12340: locked buffers in TB");
 #ifdef CONFIG_REISERFS_CHECK
 	REISERFS_SB(tb->tb_sb)->cur_tb = tb;
@@ -1487,9 +1512,10 @@ static inline void do_balance_completed(struct tree_balance *tb)
 	REISERFS_SB(tb->tb_sb)->cur_tb = NULL;
 #endif
 
-	/* reiserfs_free_block is no longer schedule safe.  So, we need to
-	 ** put the buffers we want freed on the thrown list during do_balance,
-	 ** and then free them now
+	/*
+	 * reiserfs_free_block is no longer schedule safe.  So, we need to
+	 * put the buffers we want freed on the thrown list during do_balance,
+	 * and then free them now
 	 */
 
 	REISERFS_SB(tb->tb_sb)->s_do_balance++;
@@ -1500,36 +1526,40 @@ static inline void do_balance_completed(struct tree_balance *tb)
 	free_thrown(tb);
 }
 
-void do_balance(struct tree_balance *tb,	/* tree_balance structure */
-		struct item_head *ih,	/* item header of inserted item */
-		const char *body,	/* body  of inserted item or bytes to paste */
-		int flag)
-{				/* i - insert, d - delete
-				   c - cut, p - paste
-
-				   Cut means delete part of an item
-				   (includes removing an entry from a
-				   directory).
-
-				   Delete means delete whole item.
-
-				   Insert means add a new item into the
-				   tree.
-
-				   Paste means to append to the end of an
-				   existing file or to insert a directory
-				   entry.  */
-	int child_pos,		/* position of a child node in its parent */
-	 h;			/* level of the tree being processed */
-	struct item_head insert_key[2];	/* in our processing of one level
-					   we sometimes determine what
-					   must be inserted into the next
-					   higher level.  This insertion
-					   consists of a key or two keys
-					   and their corresponding
-					   pointers */
-	struct buffer_head *insert_ptr[2];	/* inserted node-ptrs for the next
-						   level */
+/*
+ * do_balance - balance the tree
+ *
+ * @tb: tree_balance structure
+ * @ih: item header of inserted item
+ * @body: body of inserted item or bytes to paste
+ * @flag: 'i' - insert, 'd' - delete, 'c' - cut, 'p' paste
+ *
+ * Cut means delete part of an item (includes removing an entry from a
+ * directory).
+ *
+ * Delete means delete whole item.
+ *
+ * Insert means add a new item into the tree.
+ *
+ * Paste means to append to the end of an existing file or to
+ * insert a directory entry.
+ */
+void do_balance(struct tree_balance *tb, struct item_head *ih,
+		const char *body, int flag)
+{
+	int child_pos;		/* position of a child node in its parent */
+	int h;			/* level of the tree being processed */
+
+	/*
+	 * in our processing of one level we sometimes determine what
+	 * must be inserted into the next higher level.  This insertion
+	 * consists of a key or two keys and their corresponding
+	 * pointers
+	 */
+	struct item_head insert_key[2];
+
+	/* inserted node-ptrs for the next level */
+	struct buffer_head *insert_ptr[2];
 
 	tb->tb_mode = flag;
 	tb->need_balance_dirty = 0;
@@ -1549,9 +1579,11 @@ void do_balance(struct tree_balance *tb,	/* tree_balance structure */
 	atomic_inc(&(fs_generation(tb->tb_sb)));
 	do_balance_starts(tb);
 
-	/* balance leaf returns 0 except if combining L R and S into
-	   one node.  see balance_internal() for explanation of this
-	   line of code. */
+	/*
+	 * balance_leaf returns 0 except if combining L R and S into
+	 * one node.  see balance_internal() for explanation of this
+	 * line of code.
+	 */
 	child_pos = PATH_H_B_ITEM_ORDER(tb->tb_path, 0) +
 	    balance_leaf(tb, ih, body, flag, insert_key, insert_ptr);
 

commit 4cf5f7addf18ecae2ea49b11944976cbd26d5281
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:35 2014 -0400

    reiserfs: cleanup, rename key and item accessors to more friendly names
    
    This patch does a quick search and replace:
    B_N_PITEM_HEAD() -> item_head()
    B_N_PDELIM_KEY() -> internal_key()
    B_N_PKEY() -> leaf_key()
    B_N_PITEM() -> item_body()
    
    And the item_head version:
    B_I_PITEM() -> ih_item_body()
    I_ENTRY_COUNT() -> ih_entry_count()
    
    And the treepath variants:
    get_ih() -> tp_item_head()
    PATH_PITEM_HEAD() -> tp_item_head()
    get_item() -> tp_item_body()
    
    ... which makes the code much easier on the eyes.
    
    I've also removed a few unused macros.
    
    Checkpatch will complain about the 80 character limit for do_balan.c.
    I've addressed that in a later patchset to split up balance_leaf().
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 9a3c68cf6026..80b2b1b37169 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -114,7 +114,7 @@ static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 	RFALSE(!tb->blknum[0] && !PATH_H_PPARENT(tb->tb_path, 0),
 	       "PAP-12010: tree can not be empty");
 
-	ih = B_N_PITEM_HEAD(tbS0, item_pos);
+	ih = item_head(tbS0, item_pos);
 	buffer_info_init_tbS0(tb, &bi);
 
 	/* Delete or truncate the item */
@@ -312,7 +312,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 	/* for indirect item pos_in_item is measured in unformatted node
 	   pointers. Recalculate to bytes */
 	if (flag != M_INSERT
-	    && is_indirect_le_ih(B_N_PITEM_HEAD(tbS0, item_pos)))
+	    && is_indirect_le_ih(item_head(tbS0, item_pos)))
 		pos_in_item *= UNFM_P_SIZE;
 
 	if (tb->lnum[0] > 0) {
@@ -378,7 +378,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 
 				if (item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {
 					/* we must shift the part of the appended item */
-					if (is_direntry_le_ih(B_N_PITEM_HEAD(tbS0, item_pos))) {
+					if (is_direntry_le_ih(item_head(tbS0, item_pos))) {
 
 						RFALSE(zeros_num,
 						       "PAP-12090: invalid parameter in case of a directory");
@@ -391,8 +391,8 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 entries from given directory item */
 							ret_val = leaf_shift_left(tb, tb->lnum[0], tb->lbytes-1);
 							if (ret_val && !item_pos) {
-								pasted = B_N_PITEM_HEAD(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1);
-								l_pos_in_item += I_ENTRY_COUNT(pasted) - (tb->lbytes -1);
+								pasted = item_head(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1);
+								l_pos_in_item += ih_entry_count(pasted) - (tb->lbytes -1);
 							}
 
 							/* Append given directory entry to directory item */
@@ -418,9 +418,9 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 					} else {
 						/* regular object */
 						RFALSE(tb->lbytes <= 0, "PAP-12095: there is nothing to shift to L[0]. lbytes=%d", tb->lbytes);
-						RFALSE(pos_in_item != ih_item_len(B_N_PITEM_HEAD(tbS0, item_pos)),
+						RFALSE(pos_in_item != ih_item_len(item_head(tbS0, item_pos)),
 						       "PAP-12100: incorrect position to paste: item_len=%d, pos_in_item=%d",
-						       ih_item_len(B_N_PITEM_HEAD(tbS0, item_pos)),pos_in_item);
+						       ih_item_len(item_head(tbS0, item_pos)),pos_in_item);
 
 						if (tb->lbytes >= pos_in_item) {
 							/* appended item will be in L[0] in whole */
@@ -436,12 +436,12 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							       "PAP-12105: there is nothing to paste into L[0]. insert_size=%d",
 							       tb->insert_size[0]);
 							ret_val = leaf_shift_left(tb, tb->lnum[0], ih_item_len
-									    (B_N_PITEM_HEAD(tbS0, item_pos)));
+									    (item_head(tbS0, item_pos)));
 							/* Append to body of item in L[0] */
 							buffer_info_init_left(tb, &bi);
 							leaf_paste_in_buffer
 							    (&bi, n + item_pos - ret_val, ih_item_len
-							     (B_N_PITEM_HEAD(tb->L[0], n + item_pos - ret_val)),
+							     (item_head(tb->L[0], n + item_pos - ret_val)),
 							     l_n, body,
 							     zeros_num > l_n ? l_n : zeros_num);
 							/* 0-th item in S0 can be only of DIRECT type when l_n != 0 */
@@ -449,21 +449,21 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 								int version;
 								int temp_l = l_n;
 
-								RFALSE(ih_item_len(B_N_PITEM_HEAD(tbS0, 0)),
+								RFALSE(ih_item_len(item_head(tbS0, 0)),
 								     "PAP-12106: item length must be 0");
-								RFALSE(comp_short_le_keys(B_N_PKEY(tbS0, 0), B_N_PKEY
+								RFALSE(comp_short_le_keys(leaf_key(tbS0, 0), leaf_key
 								      (tb->L[0], n + item_pos - ret_val)),
 								     "PAP-12107: items must be of the same file");
-								if (is_indirect_le_ih(B_N_PITEM_HEAD(tb->L[0], n + item_pos - ret_val))) {
+								if (is_indirect_le_ih(item_head(tb->L[0], n + item_pos - ret_val))) {
 									temp_l = l_n << (tb->tb_sb-> s_blocksize_bits - UNFM_P_SHIFT);
 								}
 								/* update key of first item in S0 */
-								version = ih_version(B_N_PITEM_HEAD(tbS0, 0));
-								set_le_key_k_offset(version, B_N_PKEY(tbS0, 0),
-								     le_key_k_offset(version,B_N_PKEY(tbS0, 0)) + temp_l);
+								version = ih_version(item_head(tbS0, 0));
+								set_le_key_k_offset(version, leaf_key(tbS0, 0),
+								     le_key_k_offset(version,leaf_key(tbS0, 0)) + temp_l);
 								/* update left delimiting key */
-								set_le_key_k_offset(version, B_N_PDELIM_KEY(tb->CFL[0], tb->lkey[0]),
-								     le_key_k_offset(version, B_N_PDELIM_KEY(tb->CFL[0], tb->lkey[0])) + temp_l);
+								set_le_key_k_offset(version, internal_key(tb->CFL[0], tb->lkey[0]),
+								     le_key_k_offset(version, internal_key(tb->CFL[0], tb->lkey[0])) + temp_l);
 							}
 
 							/* Calculate new body, position in item and insert_size[0] */
@@ -474,9 +474,9 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 								zeros_num -= l_n;
 							pos_in_item = 0;
 
-							RFALSE(comp_short_le_keys(B_N_PKEY(tbS0, 0), B_N_PKEY(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1))
-							     || !op_is_left_mergeable(B_N_PKEY(tbS0, 0), tbS0->b_size)
-							     || !op_is_left_mergeable(B_N_PDELIM_KEY(tb->CFL[0], tb->lkey[0]), tbS0->b_size),
+							RFALSE(comp_short_le_keys(leaf_key(tbS0, 0), leaf_key(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1))
+							     || !op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size)
+							     || !op_is_left_mergeable(internal_key(tb->CFL[0], tb->lkey[0]), tbS0->b_size),
 							     "PAP-12120: item must be merge-able with left neighboring item");
 						} else {	/* only part of the appended item will be in L[0] */
 
@@ -493,9 +493,9 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 
 					struct item_head *pasted;
 
-					if (!item_pos && op_is_left_mergeable(B_N_PKEY(tbS0, 0), tbS0->b_size)) {	/* if we paste into first item of S[0] and it is left mergable */
+					if (!item_pos && op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size)) {	/* if we paste into first item of S[0] and it is left mergable */
 						/* then increment pos_in_item by the size of the last item in L[0] */
-						pasted = B_N_PITEM_HEAD(tb->L[0], n - 1);
+						pasted = item_head(tb->L[0], n - 1);
 						if (is_direntry_le_ih(pasted))
 							pos_in_item += ih_entry_count(pasted);
 						else
@@ -512,7 +512,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							     body, zeros_num);
 
 					/* if appended item is directory, paste entry */
-					pasted = B_N_PITEM_HEAD(tb->L[0], n + item_pos - ret_val);
+					pasted = item_head(tb->L[0], n + item_pos - ret_val);
 					if (is_direntry_le_ih(pasted))
 						leaf_paste_entries(&bi, n + item_pos - ret_val,
 								   pos_in_item, 1,
@@ -617,12 +617,12 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 
 			if (n - tb->rnum[0] <= item_pos) {	/* pasted item or part of it falls to R[0] */
 				if (item_pos == n - tb->rnum[0] && tb->rbytes != -1) {	/* we must shift the part of the appended item */
-					if (is_direntry_le_ih(B_N_PITEM_HEAD(tbS0, item_pos))) {	/* we append to directory item */
+					if (is_direntry_le_ih(item_head(tbS0, item_pos))) {	/* we append to directory item */
 						int entry_count;
 
 						RFALSE(zeros_num,
 						       "PAP-12145: invalid parameter in case of a directory");
-						entry_count = I_ENTRY_COUNT(B_N_PITEM_HEAD
+						entry_count = ih_entry_count(item_head
 								  (tbS0, item_pos));
 						if (entry_count - tb->rbytes <
 						    pos_in_item)
@@ -665,10 +665,10 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							n_shift = 0;
 
 						RFALSE(pos_in_item != ih_item_len
-						       (B_N_PITEM_HEAD(tbS0, item_pos)),
+						       (item_head(tbS0, item_pos)),
 						       "PAP-12155: invalid position to paste. ih_item_len=%d, pos_in_item=%d",
 						       pos_in_item, ih_item_len
-						       (B_N_PITEM_HEAD(tbS0, item_pos)));
+						       (item_head(tbS0, item_pos)));
 
 						leaf_shift_right(tb, tb->rnum[0], n_shift);
 						/* Calculate number of bytes which must remain in body after appending to R[0] */
@@ -679,17 +679,17 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							int version;
 							unsigned long temp_rem = n_rem;
 
-							version = ih_version(B_N_PITEM_HEAD(tb->R[0], 0));
-							if (is_indirect_le_key(version, B_N_PKEY(tb->R[0], 0))) {
+							version = ih_version(item_head(tb->R[0], 0));
+							if (is_indirect_le_key(version, leaf_key(tb->R[0], 0))) {
 								temp_rem = n_rem << (tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT);
 							}
-							set_le_key_k_offset(version, B_N_PKEY(tb->R[0], 0),
-							     le_key_k_offset(version, B_N_PKEY(tb->R[0], 0)) + temp_rem);
-							set_le_key_k_offset(version, B_N_PDELIM_KEY(tb->CFR[0], tb->rkey[0]),
-							     le_key_k_offset(version, B_N_PDELIM_KEY(tb->CFR[0], tb->rkey[0])) + temp_rem);
+							set_le_key_k_offset(version, leaf_key(tb->R[0], 0),
+							     le_key_k_offset(version, leaf_key(tb->R[0], 0)) + temp_rem);
+							set_le_key_k_offset(version, internal_key(tb->CFR[0], tb->rkey[0]),
+							     le_key_k_offset(version, internal_key(tb->CFR[0], tb->rkey[0])) + temp_rem);
 						}
-/*		  k_offset (B_N_PKEY(tb->R[0],0)) += n_rem;
-		  k_offset (B_N_PDELIM_KEY(tb->CFR[0],tb->rkey[0])) += n_rem;*/
+/*		  k_offset (leaf_key(tb->R[0],0)) += n_rem;
+		  k_offset (internal_key(tb->CFR[0],tb->rkey[0])) += n_rem;*/
 						do_balance_mark_internal_dirty(tb, tb->CFR[0], 0);
 
 						/* Append part of body into R[0] */
@@ -707,12 +707,12 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 								     tb->insert_size[0] - n_rem,
 								     r_body, r_zeros_number);
 
-						if (is_indirect_le_ih(B_N_PITEM_HEAD(tb->R[0], 0))) {
+						if (is_indirect_le_ih(item_head(tb->R[0], 0))) {
 #if 0
 							RFALSE(n_rem,
 							       "PAP-12160: paste more than one unformatted node pointer");
 #endif
-							set_ih_free_space(B_N_PITEM_HEAD(tb->R[0], 0), 0);
+							set_ih_free_space(item_head(tb->R[0], 0), 0);
 						}
 						tb->insert_size[0] = n_rem;
 						if (!n_rem)
@@ -731,7 +731,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 					}
 
 					/* paste new entry, if item is directory item */
-					pasted = B_N_PITEM_HEAD(tb->R[0], item_pos - n + tb->rnum[0]);
+					pasted = item_head(tb->R[0], item_pos - n + tb->rnum[0]);
 					if (is_direntry_le_ih(pasted) && pos_in_item >= 0) {
 						leaf_paste_entries(&bi, item_pos - n + tb->rnum[0],
 								   pos_in_item, 1,
@@ -784,8 +784,8 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 			if (!tb->CFR[0])
 				reiserfs_panic(tb->tb_sb, "vs-12195",
 					       "CFR not initialized");
-			copy_key(B_N_PDELIM_KEY(tb->CFL[0], tb->lkey[0]),
-				 B_N_PDELIM_KEY(tb->CFR[0], tb->rkey[0]));
+			copy_key(internal_key(tb->CFL[0], tb->lkey[0]),
+				 internal_key(tb->CFR[0], tb->rkey[0]));
 			do_balance_mark_internal_dirty(tb, tb->CFL[0], 0);
 		}
 
@@ -886,7 +886,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 
 					RFALSE(ih, "PAP-12210: ih must be 0");
 
-					aux_ih = B_N_PITEM_HEAD(tbS0, item_pos);
+					aux_ih = item_head(tbS0, item_pos);
 					if (is_direntry_le_ih(aux_ih)) {
 						/* we append to directory item */
 
@@ -922,7 +922,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 						int n_shift, n_rem, r_zeros_number;
 						const char *r_body;
 
-						RFALSE(pos_in_item != ih_item_len(B_N_PITEM_HEAD(tbS0, item_pos)) || tb->insert_size[0] <= 0,
+						RFALSE(pos_in_item != ih_item_len(item_head(tbS0, item_pos)) || tb->insert_size[0] <= 0,
 						       "PAP-12225: item too short or insert_size <= 0");
 
 						/* Calculate number of bytes which must be shifted from appended item */
@@ -952,7 +952,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 						{
 							struct item_head *tmp;
 
-							tmp = B_N_PITEM_HEAD(S_new[i], 0);
+							tmp = item_head(S_new[i], 0);
 							if (is_indirect_le_ih
 							    (tmp)) {
 								set_ih_free_space(tmp, 0);
@@ -973,7 +973,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 					struct item_head *pasted;
 
 #ifdef CONFIG_REISERFS_CHECK
-					struct item_head *ih_check = B_N_PITEM_HEAD(tbS0, item_pos);
+					struct item_head *ih_check = item_head(tbS0, item_pos);
 
 					if (!is_direntry_le_ih(ih_check)
 					    && (pos_in_item != ih_item_len(ih_check)
@@ -1002,7 +1002,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							     tb->insert_size[0],
 							     body, zeros_num);
 
-					pasted = B_N_PITEM_HEAD(S_new[i], item_pos - n + snum[i]);
+					pasted = item_head(S_new[i], item_pos - n + snum[i]);
 					if (is_direntry_le_ih(pasted)) {
 						leaf_paste_entries(&bi,
 								   item_pos - n + snum[i],
@@ -1032,7 +1032,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 				       (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
 		}
 
-		memcpy(insert_key + i, B_N_PKEY(S_new[i], 0), KEY_SIZE);
+		memcpy(insert_key + i, leaf_key(S_new[i], 0), KEY_SIZE);
 		insert_ptr[i] = S_new[i];
 
 		RFALSE(!buffer_journaled(S_new[i])
@@ -1061,7 +1061,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 		case M_PASTE:{	/* append item in S[0] */
 				struct item_head *pasted;
 
-				pasted = B_N_PITEM_HEAD(tbS0, item_pos);
+				pasted = item_head(tbS0, item_pos);
 				/* when directory, may be new entry already pasted */
 				if (is_direntry_le_ih(pasted)) {
 					if (pos_in_item >= 0 && pos_in_item <= ih_entry_count(pasted)) {
@@ -1246,10 +1246,10 @@ void replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,
 
 	if (B_IS_ITEMS_LEVEL(src))
 		/* source buffer contains leaf node */
-		memcpy(B_N_PDELIM_KEY(dest, n_dest), B_N_PITEM_HEAD(src, n_src),
+		memcpy(internal_key(dest, n_dest), item_head(src, n_src),
 		       KEY_SIZE);
 	else
-		memcpy(B_N_PDELIM_KEY(dest, n_dest), B_N_PDELIM_KEY(src, n_src),
+		memcpy(internal_key(dest, n_dest), internal_key(src, n_src),
 		       KEY_SIZE);
 
 	do_balance_mark_internal_dirty(tb, dest, 0);

commit 416e2abd925d0f41dc877d1fe01489d79bdecf4c
Author: Dave Jones <davej@redhat.com>
Date:   Mon Feb 17 16:21:24 2014 -0500

    reiserfs: fix utterly brain-damaged indentation.
    
    This has been this way for years, and every time I stumble across it I
    lose my lunch.  After coming across it for the nth time in the Coverity
    results, I had to overcome the bystander effect and do something about
    it.
    
    This ignores the 79 column limit in favor of making it look like C
    instead of gibberish.
    
    The correct thing to do here would be to lose some of the indentation by
    breaking this function up into several smaller ones.  I might do that at
    some point if I have the stomach to look at this again.
    
    (Also some of those overlong ternary operations would likely be more
    readable as regular if's)
    
    Signed-off-by: Dave Jones <davej@fedoraproject.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 2b7882b508db..9a3c68cf6026 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -324,23 +324,17 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 			switch (flag) {
 			case M_INSERT:	/* insert item into L[0] */
 
-				if (item_pos == tb->lnum[0] - 1
-				    && tb->lbytes != -1) {
+				if (item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {
 					/* part of new item falls into L[0] */
 					int new_item_len;
 					int version;
 
-					ret_val =
-					    leaf_shift_left(tb, tb->lnum[0] - 1,
-							    -1);
+					ret_val = leaf_shift_left(tb, tb->lnum[0] - 1, -1);
 
 					/* Calculate item length to insert to S[0] */
-					new_item_len =
-					    ih_item_len(ih) - tb->lbytes;
+					new_item_len = ih_item_len(ih) - tb->lbytes;
 					/* Calculate and check item length to insert to L[0] */
-					put_ih_item_len(ih,
-							ih_item_len(ih) -
-							new_item_len);
+					put_ih_item_len(ih, ih_item_len(ih) - new_item_len);
 
 					RFALSE(ih_item_len(ih) <= 0,
 					       "PAP-12080: there is nothing to insert into L[0]: ih_item_len=%d",
@@ -349,30 +343,18 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 					/* Insert new item into L[0] */
 					buffer_info_init_left(tb, &bi);
 					leaf_insert_into_buf(&bi,
-							     n + item_pos -
-							     ret_val, ih, body,
-							     zeros_num >
-							     ih_item_len(ih) ?
-							     ih_item_len(ih) :
-							     zeros_num);
+							n + item_pos - ret_val, ih, body,
+							zeros_num > ih_item_len(ih) ? ih_item_len(ih) : zeros_num);
 
 					version = ih_version(ih);
 
 					/* Calculate key component, item length and body to insert into S[0] */
-					set_le_ih_k_offset(ih,
-							   le_ih_k_offset(ih) +
-							   (tb->
-							    lbytes <<
-							    (is_indirect_le_ih
-							     (ih) ? tb->tb_sb->
-							     s_blocksize_bits -
-							     UNFM_P_SHIFT :
-							     0)));
+					set_le_ih_k_offset(ih, le_ih_k_offset(ih) +
+							(tb-> lbytes << (is_indirect_le_ih(ih) ? tb->tb_sb-> s_blocksize_bits - UNFM_P_SHIFT : 0)));
 
 					put_ih_item_len(ih, new_item_len);
 					if (tb->lbytes > zeros_num) {
-						body +=
-						    (tb->lbytes - zeros_num);
+						body += (tb->lbytes - zeros_num);
 						zeros_num = 0;
 					} else
 						zeros_num -= tb->lbytes;
@@ -383,15 +365,10 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 				} else {
 					/* new item in whole falls into L[0] */
 					/* Shift lnum[0]-1 items to L[0] */
-					ret_val =
-					    leaf_shift_left(tb, tb->lnum[0] - 1,
-							    tb->lbytes);
+					ret_val = leaf_shift_left(tb, tb->lnum[0] - 1, tb->lbytes);
 					/* Insert new item into L[0] */
 					buffer_info_init_left(tb, &bi);
-					leaf_insert_into_buf(&bi,
-							     n + item_pos -
-							     ret_val, ih, body,
-							     zeros_num);
+					leaf_insert_into_buf(&bi, n + item_pos - ret_val, ih, body, zeros_num);
 					tb->insert_size[0] = 0;
 					zeros_num = 0;
 				}
@@ -399,264 +376,117 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 
 			case M_PASTE:	/* append item in L[0] */
 
-				if (item_pos == tb->lnum[0] - 1
-				    && tb->lbytes != -1) {
+				if (item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {
 					/* we must shift the part of the appended item */
-					if (is_direntry_le_ih
-					    (B_N_PITEM_HEAD(tbS0, item_pos))) {
+					if (is_direntry_le_ih(B_N_PITEM_HEAD(tbS0, item_pos))) {
 
 						RFALSE(zeros_num,
 						       "PAP-12090: invalid parameter in case of a directory");
 						/* directory item */
 						if (tb->lbytes > pos_in_item) {
 							/* new directory entry falls into L[0] */
-							struct item_head
-							    *pasted;
-							int l_pos_in_item =
-							    pos_in_item;
+							struct item_head *pasted;
+							int l_pos_in_item = pos_in_item;
 
 							/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 entries from given directory item */
-							ret_val =
-							    leaf_shift_left(tb,
-									    tb->
-									    lnum
-									    [0],
-									    tb->
-									    lbytes
-									    -
-									    1);
-							if (ret_val
-							    && !item_pos) {
-								pasted =
-								    B_N_PITEM_HEAD
-								    (tb->L[0],
-								     B_NR_ITEMS
-								     (tb->
-								      L[0]) -
-								     1);
-								l_pos_in_item +=
-								    I_ENTRY_COUNT
-								    (pasted) -
-								    (tb->
-								     lbytes -
-								     1);
+							ret_val = leaf_shift_left(tb, tb->lnum[0], tb->lbytes-1);
+							if (ret_val && !item_pos) {
+								pasted = B_N_PITEM_HEAD(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1);
+								l_pos_in_item += I_ENTRY_COUNT(pasted) - (tb->lbytes -1);
 							}
 
 							/* Append given directory entry to directory item */
 							buffer_info_init_left(tb, &bi);
-							leaf_paste_in_buffer
-							    (&bi,
-							     n + item_pos -
-							     ret_val,
-							     l_pos_in_item,
-							     tb->insert_size[0],
-							     body, zeros_num);
+							leaf_paste_in_buffer(&bi, n + item_pos - ret_val, l_pos_in_item, tb->insert_size[0], body, zeros_num);
 
 							/* previous string prepared space for pasting new entry, following string pastes this entry */
 
 							/* when we have merge directory item, pos_in_item has been changed too */
 
 							/* paste new directory entry. 1 is entry number */
-							leaf_paste_entries(&bi,
-									   n +
-									   item_pos
-									   -
-									   ret_val,
-									   l_pos_in_item,
-									   1,
-									   (struct
-									    reiserfs_de_head
-									    *)
-									   body,
-									   body
-									   +
-									   DEH_SIZE,
-									   tb->
-									   insert_size
-									   [0]
-							    );
+							leaf_paste_entries(&bi, n + item_pos - ret_val, l_pos_in_item,
+									   1, (struct reiserfs_de_head *) body,
+									   body + DEH_SIZE, tb->insert_size[0]);
 							tb->insert_size[0] = 0;
 						} else {
 							/* new directory item doesn't fall into L[0] */
 							/* Shift lnum[0]-1 items in whole. Shift lbytes directory entries from directory item number lnum[0] */
-							leaf_shift_left(tb,
-									tb->
-									lnum[0],
-									tb->
-									lbytes);
+							leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
 						}
 						/* Calculate new position to append in item body */
 						pos_in_item -= tb->lbytes;
 					} else {
 						/* regular object */
-						RFALSE(tb->lbytes <= 0,
-						       "PAP-12095: there is nothing to shift to L[0]. lbytes=%d",
-						       tb->lbytes);
-						RFALSE(pos_in_item !=
-						       ih_item_len
-						       (B_N_PITEM_HEAD
-							(tbS0, item_pos)),
+						RFALSE(tb->lbytes <= 0, "PAP-12095: there is nothing to shift to L[0]. lbytes=%d", tb->lbytes);
+						RFALSE(pos_in_item != ih_item_len(B_N_PITEM_HEAD(tbS0, item_pos)),
 						       "PAP-12100: incorrect position to paste: item_len=%d, pos_in_item=%d",
-						       ih_item_len
-						       (B_N_PITEM_HEAD
-							(tbS0, item_pos)),
-						       pos_in_item);
+						       ih_item_len(B_N_PITEM_HEAD(tbS0, item_pos)),pos_in_item);
 
 						if (tb->lbytes >= pos_in_item) {
 							/* appended item will be in L[0] in whole */
 							int l_n;
 
 							/* this bytes number must be appended to the last item of L[h] */
-							l_n =
-							    tb->lbytes -
-							    pos_in_item;
+							l_n = tb->lbytes - pos_in_item;
 
 							/* Calculate new insert_size[0] */
-							tb->insert_size[0] -=
-							    l_n;
+							tb->insert_size[0] -= l_n;
 
-							RFALSE(tb->
-							       insert_size[0] <=
-							       0,
+							RFALSE(tb->insert_size[0] <= 0,
 							       "PAP-12105: there is nothing to paste into L[0]. insert_size=%d",
-							       tb->
-							       insert_size[0]);
-							ret_val =
-							    leaf_shift_left(tb,
-									    tb->
-									    lnum
-									    [0],
-									    ih_item_len
-									    (B_N_PITEM_HEAD
-									     (tbS0,
-									      item_pos)));
+							       tb->insert_size[0]);
+							ret_val = leaf_shift_left(tb, tb->lnum[0], ih_item_len
+									    (B_N_PITEM_HEAD(tbS0, item_pos)));
 							/* Append to body of item in L[0] */
 							buffer_info_init_left(tb, &bi);
 							leaf_paste_in_buffer
-							    (&bi,
-							     n + item_pos -
-							     ret_val,
-							     ih_item_len
-							     (B_N_PITEM_HEAD
-							      (tb->L[0],
-							       n + item_pos -
-							       ret_val)), l_n,
-							     body,
-							     zeros_num >
-							     l_n ? l_n :
-							     zeros_num);
+							    (&bi, n + item_pos - ret_val, ih_item_len
+							     (B_N_PITEM_HEAD(tb->L[0], n + item_pos - ret_val)),
+							     l_n, body,
+							     zeros_num > l_n ? l_n : zeros_num);
 							/* 0-th item in S0 can be only of DIRECT type when l_n != 0 */
 							{
 								int version;
-								int temp_l =
-								    l_n;
-
-								RFALSE
-								    (ih_item_len
-								     (B_N_PITEM_HEAD
-								      (tbS0,
-								       0)),
+								int temp_l = l_n;
+
+								RFALSE(ih_item_len(B_N_PITEM_HEAD(tbS0, 0)),
 								     "PAP-12106: item length must be 0");
-								RFALSE
-								    (comp_short_le_keys
-								     (B_N_PKEY
-								      (tbS0, 0),
-								      B_N_PKEY
-								      (tb->L[0],
-								       n +
-								       item_pos
-								       -
-								       ret_val)),
+								RFALSE(comp_short_le_keys(B_N_PKEY(tbS0, 0), B_N_PKEY
+								      (tb->L[0], n + item_pos - ret_val)),
 								     "PAP-12107: items must be of the same file");
 								if (is_indirect_le_ih(B_N_PITEM_HEAD(tb->L[0], n + item_pos - ret_val))) {
-									temp_l =
-									    l_n
-									    <<
-									    (tb->
-									     tb_sb->
-									     s_blocksize_bits
-									     -
-									     UNFM_P_SHIFT);
+									temp_l = l_n << (tb->tb_sb-> s_blocksize_bits - UNFM_P_SHIFT);
 								}
 								/* update key of first item in S0 */
-								version =
-								    ih_version
-								    (B_N_PITEM_HEAD
-								     (tbS0, 0));
-								set_le_key_k_offset
-								    (version,
-								     B_N_PKEY
-								     (tbS0, 0),
-								     le_key_k_offset
-								     (version,
-								      B_N_PKEY
-								      (tbS0,
-								       0)) +
-								     temp_l);
+								version = ih_version(B_N_PITEM_HEAD(tbS0, 0));
+								set_le_key_k_offset(version, B_N_PKEY(tbS0, 0),
+								     le_key_k_offset(version,B_N_PKEY(tbS0, 0)) + temp_l);
 								/* update left delimiting key */
-								set_le_key_k_offset
-								    (version,
-								     B_N_PDELIM_KEY
-								     (tb->
-								      CFL[0],
-								      tb->
-								      lkey[0]),
-								     le_key_k_offset
-								     (version,
-								      B_N_PDELIM_KEY
-								      (tb->
-								       CFL[0],
-								       tb->
-								       lkey[0]))
-								     + temp_l);
+								set_le_key_k_offset(version, B_N_PDELIM_KEY(tb->CFL[0], tb->lkey[0]),
+								     le_key_k_offset(version, B_N_PDELIM_KEY(tb->CFL[0], tb->lkey[0])) + temp_l);
 							}
 
 							/* Calculate new body, position in item and insert_size[0] */
 							if (l_n > zeros_num) {
-								body +=
-								    (l_n -
-								     zeros_num);
+								body += (l_n - zeros_num);
 								zeros_num = 0;
 							} else
-								zeros_num -=
-								    l_n;
+								zeros_num -= l_n;
 							pos_in_item = 0;
 
-							RFALSE
-							    (comp_short_le_keys
-							     (B_N_PKEY(tbS0, 0),
-							      B_N_PKEY(tb->L[0],
-								       B_NR_ITEMS
-								       (tb->
-									L[0]) -
-								       1))
-							     ||
-							     !op_is_left_mergeable
-							     (B_N_PKEY(tbS0, 0),
-							      tbS0->b_size)
-							     ||
-							     !op_is_left_mergeable
-							     (B_N_PDELIM_KEY
-							      (tb->CFL[0],
-							       tb->lkey[0]),
-							      tbS0->b_size),
+							RFALSE(comp_short_le_keys(B_N_PKEY(tbS0, 0), B_N_PKEY(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1))
+							     || !op_is_left_mergeable(B_N_PKEY(tbS0, 0), tbS0->b_size)
+							     || !op_is_left_mergeable(B_N_PDELIM_KEY(tb->CFL[0], tb->lkey[0]), tbS0->b_size),
 							     "PAP-12120: item must be merge-able with left neighboring item");
 						} else {	/* only part of the appended item will be in L[0] */
 
 							/* Calculate position in item for append in S[0] */
-							pos_in_item -=
-							    tb->lbytes;
+							pos_in_item -= tb->lbytes;
 
-							RFALSE(pos_in_item <= 0,
-							       "PAP-12125: no place for paste. pos_in_item=%d",
-							       pos_in_item);
+							RFALSE(pos_in_item <= 0, "PAP-12125: no place for paste. pos_in_item=%d", pos_in_item);
 
 							/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
-							leaf_shift_left(tb,
-									tb->
-									lnum[0],
-									tb->
-									lbytes);
+							leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
 						}
 					}
 				} else {	/* appended item will be in L[0] in whole */
@@ -665,52 +495,30 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 
 					if (!item_pos && op_is_left_mergeable(B_N_PKEY(tbS0, 0), tbS0->b_size)) {	/* if we paste into first item of S[0] and it is left mergable */
 						/* then increment pos_in_item by the size of the last item in L[0] */
-						pasted =
-						    B_N_PITEM_HEAD(tb->L[0],
-								   n - 1);
+						pasted = B_N_PITEM_HEAD(tb->L[0], n - 1);
 						if (is_direntry_le_ih(pasted))
-							pos_in_item +=
-							    ih_entry_count
-							    (pasted);
+							pos_in_item += ih_entry_count(pasted);
 						else
-							pos_in_item +=
-							    ih_item_len(pasted);
+							pos_in_item += ih_item_len(pasted);
 					}
 
 					/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
-					ret_val =
-					    leaf_shift_left(tb, tb->lnum[0],
-							    tb->lbytes);
+					ret_val = leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
 					/* Append to body of item in L[0] */
 					buffer_info_init_left(tb, &bi);
-					leaf_paste_in_buffer(&bi,
-							     n + item_pos -
-							     ret_val,
+					leaf_paste_in_buffer(&bi, n + item_pos - ret_val,
 							     pos_in_item,
 							     tb->insert_size[0],
 							     body, zeros_num);
 
 					/* if appended item is directory, paste entry */
-					pasted =
-					    B_N_PITEM_HEAD(tb->L[0],
-							   n + item_pos -
-							   ret_val);
+					pasted = B_N_PITEM_HEAD(tb->L[0], n + item_pos - ret_val);
 					if (is_direntry_le_ih(pasted))
-						leaf_paste_entries(&bi,
-								   n +
-								   item_pos -
-								   ret_val,
-								   pos_in_item,
-								   1,
-								   (struct
-								    reiserfs_de_head
-								    *)body,
-								   body +
-								   DEH_SIZE,
-								   tb->
-								   insert_size
-								   [0]
-						    );
+						leaf_paste_entries(&bi, n + item_pos - ret_val,
+								   pos_in_item, 1,
+								   (struct reiserfs_de_head *) body,
+								   body + DEH_SIZE,
+								   tb->insert_size[0]);
 					/* if appended item is indirect item, put unformatted node into un list */
 					if (is_indirect_le_ih(pasted))
 						set_ih_free_space(pasted, 0);
@@ -722,13 +530,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 				reiserfs_panic(tb->tb_sb, "PAP-12130",
 					       "lnum > 0: unexpected mode: "
 					       " %s(%d)",
-					       (flag ==
-						M_DELETE) ? "DELETE" : ((flag ==
-									 M_CUT)
-									? "CUT"
-									:
-									"UNKNOWN"),
-					       flag);
+					       (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
 			}
 		} else {
 			/* new item doesn't fall into L[0] */
@@ -748,14 +550,12 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 		case M_INSERT:	/* insert item */
 			if (n - tb->rnum[0] < item_pos) {	/* new item or its part falls to R[0] */
 				if (item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1) {	/* part of new item falls into R[0] */
-					loff_t old_key_comp, old_len,
-					    r_zeros_number;
+					loff_t old_key_comp, old_len, r_zeros_number;
 					const char *r_body;
 					int version;
 					loff_t offset;
 
-					leaf_shift_right(tb, tb->rnum[0] - 1,
-							 -1);
+					leaf_shift_right(tb, tb->rnum[0] - 1, -1);
 
 					version = ih_version(ih);
 					/* Remember key component and item length */
@@ -763,29 +563,17 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 					old_len = ih_item_len(ih);
 
 					/* Calculate key component and item length to insert into R[0] */
-					offset =
-					    le_ih_k_offset(ih) +
-					    ((old_len -
-					      tb->
-					      rbytes) << (is_indirect_le_ih(ih)
-							  ? tb->tb_sb->
-							  s_blocksize_bits -
-							  UNFM_P_SHIFT : 0));
+					offset = le_ih_k_offset(ih) + ((old_len - tb->rbytes) << (is_indirect_le_ih(ih) ? tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT : 0));
 					set_le_ih_k_offset(ih, offset);
 					put_ih_item_len(ih, tb->rbytes);
 					/* Insert part of the item into R[0] */
 					buffer_info_init_right(tb, &bi);
 					if ((old_len - tb->rbytes) > zeros_num) {
 						r_zeros_number = 0;
-						r_body =
-						    body + (old_len -
-							    tb->rbytes) -
-						    zeros_num;
+						r_body = body + (old_len - tb->rbytes) - zeros_num;
 					} else {
 						r_body = body;
-						r_zeros_number =
-						    zeros_num - (old_len -
-								 tb->rbytes);
+						r_zeros_number = zeros_num - (old_len - tb->rbytes);
 						zeros_num -= r_zeros_number;
 					}
 
@@ -798,25 +586,18 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 
 					/* Calculate key component and item length to insert into S[0] */
 					set_le_ih_k_offset(ih, old_key_comp);
-					put_ih_item_len(ih,
-							old_len - tb->rbytes);
+					put_ih_item_len(ih, old_len - tb->rbytes);
 
 					tb->insert_size[0] -= tb->rbytes;
 
 				} else {	/* whole new item falls into R[0] */
 
 					/* Shift rnum[0]-1 items to R[0] */
-					ret_val =
-					    leaf_shift_right(tb,
-							     tb->rnum[0] - 1,
-							     tb->rbytes);
+					ret_val = leaf_shift_right(tb, tb->rnum[0] - 1, tb->rbytes);
 					/* Insert new item into R[0] */
 					buffer_info_init_right(tb, &bi);
-					leaf_insert_into_buf(&bi,
-							     item_pos - n +
-							     tb->rnum[0] - 1,
-							     ih, body,
-							     zeros_num);
+					leaf_insert_into_buf(&bi, item_pos - n + tb->rnum[0] - 1,
+							     ih, body, zeros_num);
 
 					if (item_pos - n + tb->rnum[0] - 1 == 0) {
 						replace_key(tb, tb->CFR[0],
@@ -841,200 +622,97 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 
 						RFALSE(zeros_num,
 						       "PAP-12145: invalid parameter in case of a directory");
-						entry_count =
-						    I_ENTRY_COUNT(B_N_PITEM_HEAD
-								  (tbS0,
-								   item_pos));
+						entry_count = I_ENTRY_COUNT(B_N_PITEM_HEAD
+								  (tbS0, item_pos));
 						if (entry_count - tb->rbytes <
 						    pos_in_item)
 							/* new directory entry falls into R[0] */
 						{
 							int paste_entry_position;
 
-							RFALSE(tb->rbytes - 1 >=
-							       entry_count
-							       || !tb->
-							       insert_size[0],
+							RFALSE(tb->rbytes - 1 >= entry_count || !tb-> insert_size[0],
 							       "PAP-12150: no enough of entries to shift to R[0]: rbytes=%d, entry_count=%d",
-							       tb->rbytes,
-							       entry_count);
+							       tb->rbytes, entry_count);
 							/* Shift rnum[0]-1 items in whole. Shift rbytes-1 directory entries from directory item number rnum[0] */
-							leaf_shift_right(tb,
-									 tb->
-									 rnum
-									 [0],
-									 tb->
-									 rbytes
-									 - 1);
+							leaf_shift_right(tb, tb->rnum[0], tb->rbytes - 1);
 							/* Paste given directory entry to directory item */
-							paste_entry_position =
-							    pos_in_item -
-							    entry_count +
-							    tb->rbytes - 1;
+							paste_entry_position = pos_in_item - entry_count + tb->rbytes - 1;
 							buffer_info_init_right(tb, &bi);
-							leaf_paste_in_buffer
-							    (&bi, 0,
-							     paste_entry_position,
-							     tb->insert_size[0],
-							     body, zeros_num);
+							leaf_paste_in_buffer(&bi, 0, paste_entry_position, tb->insert_size[0], body, zeros_num);
 							/* paste entry */
-							leaf_paste_entries(&bi,
-									   0,
-									   paste_entry_position,
-									   1,
-									   (struct
-									    reiserfs_de_head
-									    *)
-									   body,
-									   body
-									   +
-									   DEH_SIZE,
-									   tb->
-									   insert_size
-									   [0]
-							    );
-
-							if (paste_entry_position
-							    == 0) {
+							leaf_paste_entries(&bi, 0, paste_entry_position, 1,
+									   (struct reiserfs_de_head *) body,
+									   body + DEH_SIZE, tb->insert_size[0]);
+
+							if (paste_entry_position == 0) {
 								/* change delimiting keys */
-								replace_key(tb,
-									    tb->
-									    CFR
-									    [0],
-									    tb->
-									    rkey
-									    [0],
-									    tb->
-									    R
-									    [0],
-									    0);
+								replace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0],0);
 							}
 
 							tb->insert_size[0] = 0;
 							pos_in_item++;
 						} else {	/* new directory entry doesn't fall into R[0] */
 
-							leaf_shift_right(tb,
-									 tb->
-									 rnum
-									 [0],
-									 tb->
-									 rbytes);
+							leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
 						}
 					} else {	/* regular object */
 
-						int n_shift, n_rem,
-						    r_zeros_number;
+						int n_shift, n_rem, r_zeros_number;
 						const char *r_body;
 
 						/* Calculate number of bytes which must be shifted from appended item */
-						if ((n_shift =
-						     tb->rbytes -
-						     tb->insert_size[0]) < 0)
+						if ((n_shift = tb->rbytes - tb->insert_size[0]) < 0)
 							n_shift = 0;
 
-						RFALSE(pos_in_item !=
-						       ih_item_len
-						       (B_N_PITEM_HEAD
-							(tbS0, item_pos)),
+						RFALSE(pos_in_item != ih_item_len
+						       (B_N_PITEM_HEAD(tbS0, item_pos)),
 						       "PAP-12155: invalid position to paste. ih_item_len=%d, pos_in_item=%d",
-						       pos_in_item,
-						       ih_item_len
-						       (B_N_PITEM_HEAD
-							(tbS0, item_pos)));
-
-						leaf_shift_right(tb,
-								 tb->rnum[0],
-								 n_shift);
+						       pos_in_item, ih_item_len
+						       (B_N_PITEM_HEAD(tbS0, item_pos)));
+
+						leaf_shift_right(tb, tb->rnum[0], n_shift);
 						/* Calculate number of bytes which must remain in body after appending to R[0] */
-						if ((n_rem =
-						     tb->insert_size[0] -
-						     tb->rbytes) < 0)
+						if ((n_rem = tb->insert_size[0] - tb->rbytes) < 0)
 							n_rem = 0;
 
 						{
 							int version;
-							unsigned long temp_rem =
-							    n_rem;
-
-							version =
-							    ih_version
-							    (B_N_PITEM_HEAD
-							     (tb->R[0], 0));
-							if (is_indirect_le_key
-							    (version,
-							     B_N_PKEY(tb->R[0],
-								      0))) {
-								temp_rem =
-								    n_rem <<
-								    (tb->tb_sb->
-								     s_blocksize_bits
-								     -
-								     UNFM_P_SHIFT);
+							unsigned long temp_rem = n_rem;
+
+							version = ih_version(B_N_PITEM_HEAD(tb->R[0], 0));
+							if (is_indirect_le_key(version, B_N_PKEY(tb->R[0], 0))) {
+								temp_rem = n_rem << (tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT);
 							}
-							set_le_key_k_offset
-							    (version,
-							     B_N_PKEY(tb->R[0],
-								      0),
-							     le_key_k_offset
-							     (version,
-							      B_N_PKEY(tb->R[0],
-								       0)) +
-							     temp_rem);
-							set_le_key_k_offset
-							    (version,
-							     B_N_PDELIM_KEY(tb->
-									    CFR
-									    [0],
-									    tb->
-									    rkey
-									    [0]),
-							     le_key_k_offset
-							     (version,
-							      B_N_PDELIM_KEY
-							      (tb->CFR[0],
-							       tb->rkey[0])) +
-							     temp_rem);
+							set_le_key_k_offset(version, B_N_PKEY(tb->R[0], 0),
+							     le_key_k_offset(version, B_N_PKEY(tb->R[0], 0)) + temp_rem);
+							set_le_key_k_offset(version, B_N_PDELIM_KEY(tb->CFR[0], tb->rkey[0]),
+							     le_key_k_offset(version, B_N_PDELIM_KEY(tb->CFR[0], tb->rkey[0])) + temp_rem);
 						}
 /*		  k_offset (B_N_PKEY(tb->R[0],0)) += n_rem;
 		  k_offset (B_N_PDELIM_KEY(tb->CFR[0],tb->rkey[0])) += n_rem;*/
-						do_balance_mark_internal_dirty
-						    (tb, tb->CFR[0], 0);
+						do_balance_mark_internal_dirty(tb, tb->CFR[0], 0);
 
 						/* Append part of body into R[0] */
 						buffer_info_init_right(tb, &bi);
 						if (n_rem > zeros_num) {
 							r_zeros_number = 0;
-							r_body =
-							    body + n_rem -
-							    zeros_num;
+							r_body = body + n_rem - zeros_num;
 						} else {
 							r_body = body;
-							r_zeros_number =
-							    zeros_num - n_rem;
-							zeros_num -=
-							    r_zeros_number;
+							r_zeros_number = zeros_num - n_rem;
+							zeros_num -= r_zeros_number;
 						}
 
-						leaf_paste_in_buffer(&bi, 0,
-								     n_shift,
-								     tb->
-								     insert_size
-								     [0] -
-								     n_rem,
-								     r_body,
-								     r_zeros_number);
-
-						if (is_indirect_le_ih
-						    (B_N_PITEM_HEAD
-						     (tb->R[0], 0))) {
+						leaf_paste_in_buffer(&bi, 0, n_shift,
+								     tb->insert_size[0] - n_rem,
+								     r_body, r_zeros_number);
+
+						if (is_indirect_le_ih(B_N_PITEM_HEAD(tb->R[0], 0))) {
 #if 0
 							RFALSE(n_rem,
 							       "PAP-12160: paste more than one unformatted node pointer");
 #endif
-							set_ih_free_space
-							    (B_N_PITEM_HEAD
-							     (tb->R[0], 0), 0);
+							set_ih_free_space(B_N_PITEM_HEAD(tb->R[0], 0), 0);
 						}
 						tb->insert_size[0] = n_rem;
 						if (!n_rem)
@@ -1044,58 +722,28 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 
 					struct item_head *pasted;
 
-					ret_val =
-					    leaf_shift_right(tb, tb->rnum[0],
-							     tb->rbytes);
+					ret_val = leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
 					/* append item in R[0] */
 					if (pos_in_item >= 0) {
 						buffer_info_init_right(tb, &bi);
-						leaf_paste_in_buffer(&bi,
-								     item_pos -
-								     n +
-								     tb->
-								     rnum[0],
-								     pos_in_item,
-								     tb->
-								     insert_size
-								     [0], body,
-								     zeros_num);
+						leaf_paste_in_buffer(&bi, item_pos - n + tb->rnum[0], pos_in_item,
+								     tb->insert_size[0], body, zeros_num);
 					}
 
 					/* paste new entry, if item is directory item */
-					pasted =
-					    B_N_PITEM_HEAD(tb->R[0],
-							   item_pos - n +
-							   tb->rnum[0]);
-					if (is_direntry_le_ih(pasted)
-					    && pos_in_item >= 0) {
-						leaf_paste_entries(&bi,
-								   item_pos -
-								   n +
-								   tb->rnum[0],
-								   pos_in_item,
-								   1,
-								   (struct
-								    reiserfs_de_head
-								    *)body,
-								   body +
-								   DEH_SIZE,
-								   tb->
-								   insert_size
-								   [0]
-						    );
+					pasted = B_N_PITEM_HEAD(tb->R[0], item_pos - n + tb->rnum[0]);
+					if (is_direntry_le_ih(pasted) && pos_in_item >= 0) {
+						leaf_paste_entries(&bi, item_pos - n + tb->rnum[0],
+								   pos_in_item, 1,
+								   (struct reiserfs_de_head *) body,
+								   body + DEH_SIZE, tb->insert_size[0]);
 						if (!pos_in_item) {
 
-							RFALSE(item_pos - n +
-							       tb->rnum[0],
+							RFALSE(item_pos - n + tb->rnum[0],
 							       "PAP-12165: directory item must be first item of node when pasting is in 0th position");
 
 							/* update delimiting keys */
-							replace_key(tb,
-								    tb->CFR[0],
-								    tb->rkey[0],
-								    tb->R[0],
-								    0);
+							replace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);
 						}
 					}
 
@@ -1111,22 +759,16 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 		default:	/* cases d and t */
 			reiserfs_panic(tb->tb_sb, "PAP-12175",
 				       "rnum > 0: unexpected mode: %s(%d)",
-				       (flag ==
-					M_DELETE) ? "DELETE" : ((flag ==
-								 M_CUT) ? "CUT"
-								: "UNKNOWN"),
-				       flag);
+				       (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
 		}
 
 	}
 
 	/* tb->rnum[0] > 0 */
 	RFALSE(tb->blknum[0] > 3,
-	       "PAP-12180: blknum can not be %d. It must be <= 3",
-	       tb->blknum[0]);
+	       "PAP-12180: blknum can not be %d. It must be <= 3", tb->blknum[0]);
 	RFALSE(tb->blknum[0] < 0,
-	       "PAP-12185: blknum can not be %d. It must be >= 0",
-	       tb->blknum[0]);
+	       "PAP-12185: blknum can not be %d. It must be >= 0", tb->blknum[0]);
 
 	/* if while adding to a node we discover that it is possible to split
 	   it in two, and merge the left part into the left neighbor and the
@@ -1177,8 +819,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 
 			if (n - snum[i] < item_pos) {	/* new item or it's part falls to first new node S_new[i] */
 				if (item_pos == n - snum[i] + 1 && sbytes[i] != -1) {	/* part of new item falls into S_new[i] */
-					int old_key_comp, old_len,
-					    r_zeros_number;
+					int old_key_comp, old_len, r_zeros_number;
 					const char *r_body;
 					int version;
 
@@ -1192,15 +833,8 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 					old_len = ih_item_len(ih);
 
 					/* Calculate key component and item length to insert into S_new[i] */
-					set_le_ih_k_offset(ih,
-							   le_ih_k_offset(ih) +
-							   ((old_len -
-							     sbytes[i]) <<
-							    (is_indirect_le_ih
-							     (ih) ? tb->tb_sb->
-							     s_blocksize_bits -
-							     UNFM_P_SHIFT :
-							     0)));
+					set_le_ih_k_offset(ih, le_ih_k_offset(ih) +
+							   ((old_len - sbytes[i]) << (is_indirect_le_ih(ih) ? tb->tb_sb-> s_blocksize_bits - UNFM_P_SHIFT : 0)));
 
 					put_ih_item_len(ih, sbytes[i]);
 
@@ -1209,39 +843,29 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 
 					if ((old_len - sbytes[i]) > zeros_num) {
 						r_zeros_number = 0;
-						r_body =
-						    body + (old_len -
-							    sbytes[i]) -
-						    zeros_num;
+						r_body = body + (old_len - sbytes[i]) - zeros_num;
 					} else {
 						r_body = body;
-						r_zeros_number =
-						    zeros_num - (old_len -
-								 sbytes[i]);
+						r_zeros_number = zeros_num - (old_len - sbytes[i]);
 						zeros_num -= r_zeros_number;
 					}
 
-					leaf_insert_into_buf(&bi, 0, ih, r_body,
-							     r_zeros_number);
+					leaf_insert_into_buf(&bi, 0, ih, r_body, r_zeros_number);
 
 					/* Calculate key component and item length to insert into S[i] */
 					set_le_ih_k_offset(ih, old_key_comp);
-					put_ih_item_len(ih,
-							old_len - sbytes[i]);
+					put_ih_item_len(ih, old_len - sbytes[i]);
 					tb->insert_size[0] -= sbytes[i];
 				} else {	/* whole new item falls into S_new[i] */
 
 					/* Shift snum[0] - 1 items to S_new[i] (sbytes[i] of split item) */
 					leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-							snum[i] - 1, sbytes[i],
-							S_new[i]);
+							snum[i] - 1, sbytes[i], S_new[i]);
 
 					/* Insert new item into S_new[i] */
 					buffer_info_init_bh(tb, &bi, S_new[i]);
-					leaf_insert_into_buf(&bi,
-							     item_pos - n +
-							     snum[i] - 1, ih,
-							     body, zeros_num);
+					leaf_insert_into_buf(&bi, item_pos - n + snum[i] - 1,
+							     ih, body, zeros_num);
 
 					zeros_num = tb->insert_size[0] = 0;
 				}
@@ -1268,150 +892,73 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 
 						int entry_count;
 
-						entry_count =
-						    ih_entry_count(aux_ih);
+						entry_count = ih_entry_count(aux_ih);
 
-						if (entry_count - sbytes[i] <
-						    pos_in_item
-						    && pos_in_item <=
-						    entry_count) {
+						if (entry_count - sbytes[i] < pos_in_item && pos_in_item <= entry_count) {
 							/* new directory entry falls into S_new[i] */
 
-							RFALSE(!tb->
-							       insert_size[0],
-							       "PAP-12215: insert_size is already 0");
-							RFALSE(sbytes[i] - 1 >=
-							       entry_count,
+							RFALSE(!tb->insert_size[0], "PAP-12215: insert_size is already 0");
+							RFALSE(sbytes[i] - 1 >= entry_count,
 							       "PAP-12220: there are no so much entries (%d), only %d",
-							       sbytes[i] - 1,
-							       entry_count);
+							       sbytes[i] - 1, entry_count);
 
 							/* Shift snum[i]-1 items in whole. Shift sbytes[i] directory entries from directory item number snum[i] */
-							leaf_move_items
-							    (LEAF_FROM_S_TO_SNEW,
-							     tb, snum[i],
-							     sbytes[i] - 1,
-							     S_new[i]);
+							leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i] - 1, S_new[i]);
 							/* Paste given directory entry to directory item */
 							buffer_info_init_bh(tb, &bi, S_new[i]);
-							leaf_paste_in_buffer
-							    (&bi, 0,
-							     pos_in_item -
-							     entry_count +
-							     sbytes[i] - 1,
-							     tb->insert_size[0],
-							     body, zeros_num);
+							leaf_paste_in_buffer(&bi, 0, pos_in_item - entry_count + sbytes[i] - 1,
+							     tb->insert_size[0], body, zeros_num);
 							/* paste new directory entry */
-							leaf_paste_entries(&bi,
-									   0,
-									   pos_in_item
-									   -
-									   entry_count
-									   +
-									   sbytes
-									   [i] -
-									   1, 1,
-									   (struct
-									    reiserfs_de_head
-									    *)
-									   body,
-									   body
-									   +
-									   DEH_SIZE,
-									   tb->
-									   insert_size
-									   [0]
-							    );
+							leaf_paste_entries(&bi, 0, pos_in_item - entry_count + sbytes[i] - 1, 1,
+									   (struct reiserfs_de_head *) body,
+									   body + DEH_SIZE, tb->insert_size[0]);
 							tb->insert_size[0] = 0;
 							pos_in_item++;
 						} else {	/* new directory entry doesn't fall into S_new[i] */
-							leaf_move_items
-							    (LEAF_FROM_S_TO_SNEW,
-							     tb, snum[i],
-							     sbytes[i],
-							     S_new[i]);
+							leaf_move_items(LEAF_FROM_S_TO_SNEW,tb, snum[i], sbytes[i], S_new[i]);
 						}
 					} else {	/* regular object */
 
-						int n_shift, n_rem,
-						    r_zeros_number;
+						int n_shift, n_rem, r_zeros_number;
 						const char *r_body;
 
-						RFALSE(pos_in_item !=
-						       ih_item_len
-						       (B_N_PITEM_HEAD
-							(tbS0, item_pos))
-						       || tb->insert_size[0] <=
-						       0,
+						RFALSE(pos_in_item != ih_item_len(B_N_PITEM_HEAD(tbS0, item_pos)) || tb->insert_size[0] <= 0,
 						       "PAP-12225: item too short or insert_size <= 0");
 
 						/* Calculate number of bytes which must be shifted from appended item */
-						n_shift =
-						    sbytes[i] -
-						    tb->insert_size[0];
+						n_shift = sbytes[i] - tb->insert_size[0];
 						if (n_shift < 0)
 							n_shift = 0;
-						leaf_move_items
-						    (LEAF_FROM_S_TO_SNEW, tb,
-						     snum[i], n_shift,
-						     S_new[i]);
+						leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, snum[i], n_shift, S_new[i]);
 
 						/* Calculate number of bytes which must remain in body after append to S_new[i] */
-						n_rem =
-						    tb->insert_size[0] -
-						    sbytes[i];
+						n_rem = tb->insert_size[0] - sbytes[i];
 						if (n_rem < 0)
 							n_rem = 0;
 						/* Append part of body into S_new[0] */
 						buffer_info_init_bh(tb, &bi, S_new[i]);
 						if (n_rem > zeros_num) {
 							r_zeros_number = 0;
-							r_body =
-							    body + n_rem -
-							    zeros_num;
+							r_body = body + n_rem - zeros_num;
 						} else {
 							r_body = body;
-							r_zeros_number =
-							    zeros_num - n_rem;
-							zeros_num -=
-							    r_zeros_number;
+							r_zeros_number = zeros_num - n_rem;
+							zeros_num -= r_zeros_number;
 						}
 
-						leaf_paste_in_buffer(&bi, 0,
-								     n_shift,
-								     tb->
-								     insert_size
-								     [0] -
-								     n_rem,
-								     r_body,
-								     r_zeros_number);
+						leaf_paste_in_buffer(&bi, 0, n_shift,
+								     tb->insert_size[0] - n_rem,
+								     r_body, r_zeros_number);
 						{
 							struct item_head *tmp;
 
-							tmp =
-							    B_N_PITEM_HEAD(S_new
-									   [i],
-									   0);
+							tmp = B_N_PITEM_HEAD(S_new[i], 0);
 							if (is_indirect_le_ih
 							    (tmp)) {
-								set_ih_free_space
-								    (tmp, 0);
-								set_le_ih_k_offset
-								    (tmp,
-								     le_ih_k_offset
-								     (tmp) +
-								     (n_rem <<
-								      (tb->
-								       tb_sb->
-								       s_blocksize_bits
-								       -
-								       UNFM_P_SHIFT)));
+								set_ih_free_space(tmp, 0);
+								set_le_ih_k_offset(tmp, le_ih_k_offset(tmp) + (n_rem << (tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT)));
 							} else {
-								set_le_ih_k_offset
-								    (tmp,
-								     le_ih_k_offset
-								     (tmp) +
-								     n_rem);
+								set_le_ih_k_offset(tmp, le_ih_k_offset(tmp) + n_rem);
 							}
 						}
 
@@ -1426,8 +973,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 					struct item_head *pasted;
 
 #ifdef CONFIG_REISERFS_CHECK
-					struct item_head *ih_check =
-					    B_N_PITEM_HEAD(tbS0, item_pos);
+					struct item_head *ih_check = B_N_PITEM_HEAD(tbS0, item_pos);
 
 					if (!is_direntry_le_ih(ih_check)
 					    && (pos_in_item != ih_item_len(ih_check)
@@ -1439,8 +985,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							     "to ih_item_len");
 #endif				/* CONFIG_REISERFS_CHECK */
 
-					leaf_mi =
-					    leaf_move_items(LEAF_FROM_S_TO_SNEW,
+					leaf_mi = leaf_move_items(LEAF_FROM_S_TO_SNEW,
 							    tb, snum[i],
 							    sbytes[i],
 							    S_new[i]);
@@ -1452,30 +997,19 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 					/* paste into item */
 					buffer_info_init_bh(tb, &bi, S_new[i]);
 					leaf_paste_in_buffer(&bi,
-							     item_pos - n +
-							     snum[i],
+							     item_pos - n + snum[i],
 							     pos_in_item,
 							     tb->insert_size[0],
 							     body, zeros_num);
 
-					pasted =
-					    B_N_PITEM_HEAD(S_new[i],
-							   item_pos - n +
-							   snum[i]);
+					pasted = B_N_PITEM_HEAD(S_new[i], item_pos - n + snum[i]);
 					if (is_direntry_le_ih(pasted)) {
 						leaf_paste_entries(&bi,
-								   item_pos -
-								   n + snum[i],
-								   pos_in_item,
-								   1,
-								   (struct
-								    reiserfs_de_head
-								    *)body,
-								   body +
-								   DEH_SIZE,
-								   tb->
-								   insert_size
-								   [0]
+								   item_pos - n + snum[i],
+								   pos_in_item, 1,
+								   (struct reiserfs_de_head *)body,
+								   body + DEH_SIZE,
+								   tb->insert_size[0]
 						    );
 					}
 
@@ -1495,11 +1029,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 		default:	/* cases d and t */
 			reiserfs_panic(tb->tb_sb, "PAP-12245",
 				       "blknum > 2: unexpected mode: %s(%d)",
-				       (flag ==
-					M_DELETE) ? "DELETE" : ((flag ==
-								 M_CUT) ? "CUT"
-								: "UNKNOWN"),
-				       flag);
+				       (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
 		}
 
 		memcpy(insert_key + i, B_N_PKEY(S_new[i], 0), KEY_SIZE);
@@ -1524,9 +1054,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 			/* If we insert the first key change the delimiting key */
 			if (item_pos == 0) {
 				if (tb->CFL[0])	/* can be 0 in reiserfsck */
-					replace_key(tb, tb->CFL[0], tb->lkey[0],
-						    tbS0, 0);
-
+					replace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);
 			}
 			break;
 
@@ -1536,53 +1064,27 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 				pasted = B_N_PITEM_HEAD(tbS0, item_pos);
 				/* when directory, may be new entry already pasted */
 				if (is_direntry_le_ih(pasted)) {
-					if (pos_in_item >= 0 &&
-					    pos_in_item <=
-					    ih_entry_count(pasted)) {
+					if (pos_in_item >= 0 && pos_in_item <= ih_entry_count(pasted)) {
 
 						RFALSE(!tb->insert_size[0],
 						       "PAP-12260: insert_size is 0 already");
 
 						/* prepare space */
 						buffer_info_init_tbS0(tb, &bi);
-						leaf_paste_in_buffer(&bi,
-								     item_pos,
-								     pos_in_item,
-								     tb->
-								     insert_size
-								     [0], body,
+						leaf_paste_in_buffer(&bi, item_pos, pos_in_item,
+								     tb->insert_size[0], body,
 								     zeros_num);
 
 						/* paste entry */
-						leaf_paste_entries(&bi,
-								   item_pos,
-								   pos_in_item,
-								   1,
-								   (struct
-								    reiserfs_de_head
-								    *)body,
-								   body +
-								   DEH_SIZE,
-								   tb->
-								   insert_size
-								   [0]
-						    );
+						leaf_paste_entries(&bi, item_pos, pos_in_item, 1,
+								   (struct reiserfs_de_head *)body,
+								   body + DEH_SIZE,
+								   tb->insert_size[0]);
 						if (!item_pos && !pos_in_item) {
-							RFALSE(!tb->CFL[0]
-							       || !tb->L[0],
+							RFALSE(!tb->CFL[0] || !tb->L[0],
 							       "PAP-12270: CFL[0]/L[0] must be specified");
-							if (tb->CFL[0]) {
-								replace_key(tb,
-									    tb->
-									    CFL
-									    [0],
-									    tb->
-									    lkey
-									    [0],
-									    tbS0,
-									    0);
-
-							}
+							if (tb->CFL[0])
+								replace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);
 						}
 						tb->insert_size[0] = 0;
 					}
@@ -1593,13 +1095,8 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 						       "PAP-12275: insert size must not be %d",
 						       tb->insert_size[0]);
 						buffer_info_init_tbS0(tb, &bi);
-						leaf_paste_in_buffer(&bi,
-								     item_pos,
-								     pos_in_item,
-								     tb->
-								     insert_size
-								     [0], body,
-								     zeros_num);
+						leaf_paste_in_buffer(&bi, item_pos, pos_in_item,
+								     tb->insert_size[0], body, zeros_num);
 
 						if (is_indirect_le_ih(pasted)) {
 #if 0
@@ -1611,8 +1108,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							       tb->
 							       insert_size[0]);
 #endif
-							set_ih_free_space
-							    (pasted, 0);
+							set_ih_free_space(pasted, 0);
 						}
 						tb->insert_size[0] = 0;
 					}
@@ -1620,8 +1116,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 					else {
 						if (tb->insert_size[0]) {
 							print_cur_tb("12285");
-							reiserfs_panic(tb->
-								       tb_sb,
+							reiserfs_panic(tb->tb_sb,
 							    "PAP-12285",
 							    "insert_size "
 							    "must be 0 "

commit f466c6fdb3b1f043ff1977a8d2a1d0cd4dc164fa
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 17 01:16:43 2012 -0400

    move private bits of reiserfs_fs.h to fs/reiserfs/reiserfs.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 60c080440661..2b7882b508db 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -17,7 +17,7 @@
 
 #include <asm/uaccess.h>
 #include <linux/time.h>
-#include <linux/reiserfs_fs.h>
+#include "reiserfs.h"
 #include <linux/buffer_head.h>
 #include <linux/kernel.h>
 

commit 08f14fc8963e585e65b71212ce8050607b9b6c36
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Sat May 16 19:10:38 2009 +0200

    kill-the-bkl/reiserfs: move the concurrent tree accesses checks per superblock
    
    When do_balance() balances the tree, a trick is performed to
    provide the ability for other tree writers/readers to check whether
    do_balance() is executing concurrently (requires CONFIG_REISERFS_CHECK).
    
    This is done to protect concurrent accesses to the tree. The trick
    is the following:
    
    When do_balance is called, a unique global variable called cur_tb
    takes a pointer to the current tree to be rebalanced.
    Once do_balance finishes its work, cur_tb takes the NULL value.
    
    Then, concurrent tree readers/writers just have to check the value
    of cur_tb to ensure do_balance isn't executing concurrently.
    If it is, then it proves that schedule() occured on do_balance(),
    which then relaxed the bkl that protected the tree.
    
    Now that the bkl has be turned into a mutex, this check is still
    fine even though do_balance() becomes preemptible: the write lock
    will not be automatically released on schedule(), so the tree is
    still protected.
    
    But this is only fine if we have a single reiserfs mountpoint.
    Indeed, because the bkl is a global lock, it didn't allowed
    concurrent executions between a tree reader/writer in a mount point
    and a do_balance() on another tree from another mountpoint.
    
    So assuming all these readers/writers weren't supposed to be
    reentrant, the current check now sometimes detect false positives with
    the current per-superblock mutex which allows this reentrancy.
    
    This patch keeps the concurrent tree accesses check but moves it
    per superblock, so that only trees from a same mount point are
    checked to be not accessed concurrently.
    
    [ Impact: fix spurious panic while running several reiserfs mount-points ]
    
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 128d3f7c8aa5..60c080440661 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -21,14 +21,6 @@
 #include <linux/buffer_head.h>
 #include <linux/kernel.h>
 
-#ifdef CONFIG_REISERFS_CHECK
-
-struct tree_balance *cur_tb = NULL;	/* detects whether more than one
-					   copy of tb exists as a means
-					   of checking whether schedule
-					   is interrupting do_balance */
-#endif
-
 static inline void buffer_info_init_left(struct tree_balance *tb,
                                          struct buffer_info *bi)
 {
@@ -1840,11 +1832,12 @@ static int check_before_balancing(struct tree_balance *tb)
 {
 	int retval = 0;
 
-	if (cur_tb) {
+	if (REISERFS_SB(tb->tb_sb)->cur_tb) {
 		reiserfs_panic(tb->tb_sb, "vs-12335", "suspect that schedule "
 			       "occurred based on cur_tb not being null at "
 			       "this point in code. do_balance cannot properly "
-			       "handle schedule occurring while it runs.");
+			       "handle concurrent tree accesses on a same "
+			       "mount point.");
 	}
 
 	/* double check that buffers that we will modify are unlocked. (fix_nodes should already have
@@ -1986,7 +1979,7 @@ static inline void do_balance_starts(struct tree_balance *tb)
 	     "check");*/
 	RFALSE(check_before_balancing(tb), "PAP-12340: locked buffers in TB");
 #ifdef CONFIG_REISERFS_CHECK
-	cur_tb = tb;
+	REISERFS_SB(tb->tb_sb)->cur_tb = tb;
 #endif
 }
 
@@ -1996,7 +1989,7 @@ static inline void do_balance_completed(struct tree_balance *tb)
 #ifdef CONFIG_REISERFS_CHECK
 	check_leaf_level(tb);
 	check_internal_levels(tb);
-	cur_tb = NULL;
+	REISERFS_SB(tb->tb_sb)->cur_tb = NULL;
 #endif
 
 	/* reiserfs_free_block is no longer schedule safe.  So, we need to

commit 1d965fe0eb435b3f9a10538815f6a68de0aef03c
Author: Jeff Mahoney <jeffm@jeffreymahoney.com>
Date:   Wed Jun 17 16:26:29 2009 -0700

    reiserfs: fix warnings with gcc 4.4
    
    Several code paths in reiserfs have a construct like:
    
     if (is_direntry_le_ih(ih = B_N_PITEM_HEAD(src, item_num))) ...
    
    which, in addition to being ugly, end up causing compiler warnings with
    gcc 4.4.0.  Previous compilers didn't issue a warning.
    
    fs/reiserfs/do_balan.c:1273: warning: operation on `aux_ih' may be undefined
    fs/reiserfs/lbalance.c:393: warning: operation on `ih' may be undefined
    fs/reiserfs/lbalance.c:421: warning: operation on `ih' may be undefined
    fs/reiserfs/lbalance.c:777: warning: operation on `ih' may be undefined
    
    I believe this is due to the ih being passed to macros which evaluate the
    argument more than once.  This is old code and we haven't seen any
    problems with it, but this patch eliminates the warnings.
    
    It converts the multiple evaluation macros to static inlines and does a
    preassignment for the cases that were causing the warnings because that
    code is just ugly.
    
    Reported-by: Chris Mason <mason@oracle.com>
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 4beb964a2a3e..128d3f7c8aa5 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -1270,9 +1270,8 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 
 					RFALSE(ih, "PAP-12210: ih must be 0");
 
-					if (is_direntry_le_ih
-					    (aux_ih =
-					     B_N_PITEM_HEAD(tbS0, item_pos))) {
+					aux_ih = B_N_PITEM_HEAD(tbS0, item_pos);
+					if (is_direntry_le_ih(aux_ih)) {
 						/* we append to directory item */
 
 						int entry_count;

commit 0222e6571c332563a48d4cf5487b67feabe60b5e
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:44 2009 -0400

    reiserfs: strip trailing whitespace
    
    This patch strips trailing whitespace from the reiserfs code.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 723a7f4011d0..4beb964a2a3e 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -76,21 +76,21 @@ inline void do_balance_mark_leaf_dirty(struct tree_balance *tb,
 #define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty
 #define do_balance_mark_sb_dirty do_balance_mark_leaf_dirty
 
-/* summary: 
+/* summary:
  if deleting something ( tb->insert_size[0] < 0 )
    return(balance_leaf_when_delete()); (flag d handled here)
  else
    if lnum is larger than 0 we put items into the left node
    if rnum is larger than 0 we put items into the right node
    if snum1 is larger than 0 we put items into the new node s1
-   if snum2 is larger than 0 we put items into the new node s2 
+   if snum2 is larger than 0 we put items into the new node s2
 Note that all *num* count new items being created.
 
 It would be easier to read balance_leaf() if each of these summary
 lines was a separate procedure rather than being inlined.  I think
 that there are many passages here and in balance_leaf_when_delete() in
 which two calls to one procedure can replace two passages, and it
-might save cache space and improve software maintenance costs to do so.  
+might save cache space and improve software maintenance costs to do so.
 
 Vladimir made the perceptive comment that we should offload most of
 the decision making in this function into fix_nodes/check_balance, and
@@ -288,15 +288,15 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
     )
 {
 	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
-	int item_pos = PATH_LAST_POSITION(tb->tb_path);	/*  index into the array of item headers in S[0] 
+	int item_pos = PATH_LAST_POSITION(tb->tb_path);	/*  index into the array of item headers in S[0]
 							   of the affected item */
 	struct buffer_info bi;
 	struct buffer_head *S_new[2];	/* new nodes allocated to hold what could not fit into S */
 	int snum[2];		/* number of items that will be placed
 				   into S_new (includes partially shifted
 				   items) */
-	int sbytes[2];		/* if an item is partially shifted into S_new then 
-				   if it is a directory item 
+	int sbytes[2];		/* if an item is partially shifted into S_new then
+				   if it is a directory item
 				   it is the number of entries from the item that are shifted into S_new
 				   else
 				   it is the number of bytes from the item that are shifted into S_new
@@ -1983,7 +1983,7 @@ static inline void do_balance_starts(struct tree_balance *tb)
 	/* store_print_tb (tb); */
 
 	/* do not delete, just comment it out */
-/*    print_tb(flag, PATH_LAST_POSITION(tb->tb_path), tb->tb_path->pos_in_item, tb, 
+/*    print_tb(flag, PATH_LAST_POSITION(tb->tb_path), tb->tb_path->pos_in_item, tb,
 	     "check");*/
 	RFALSE(check_before_balancing(tb), "PAP-12340: locked buffers in TB");
 #ifdef CONFIG_REISERFS_CHECK

commit fba4ebb5f0f84a6f9989e9591741ddff946de320
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:42 2009 -0400

    reiserfs: factor out buffer_info initialization
    
    This is the first in a series of patches to make balance_leaf() not
    quite so insane.
    
    This patch factors out the open coded initializations of buffer_info
    structures and defines a few initializers for the 4 cases they're used.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index e788fbc3ff6b..723a7f4011d0 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -29,6 +29,43 @@ struct tree_balance *cur_tb = NULL;	/* detects whether more than one
 					   is interrupting do_balance */
 #endif
 
+static inline void buffer_info_init_left(struct tree_balance *tb,
+                                         struct buffer_info *bi)
+{
+	bi->tb          = tb;
+	bi->bi_bh       = tb->L[0];
+	bi->bi_parent   = tb->FL[0];
+	bi->bi_position = get_left_neighbor_position(tb, 0);
+}
+
+static inline void buffer_info_init_right(struct tree_balance *tb,
+                                          struct buffer_info *bi)
+{
+	bi->tb          = tb;
+	bi->bi_bh       = tb->R[0];
+	bi->bi_parent   = tb->FR[0];
+	bi->bi_position = get_right_neighbor_position(tb, 0);
+}
+
+static inline void buffer_info_init_tbS0(struct tree_balance *tb,
+                                         struct buffer_info *bi)
+{
+	bi->tb          = tb;
+	bi->bi_bh        = PATH_PLAST_BUFFER(tb->tb_path);
+	bi->bi_parent   = PATH_H_PPARENT(tb->tb_path, 0);
+	bi->bi_position = PATH_H_POSITION(tb->tb_path, 1);
+}
+
+static inline void buffer_info_init_bh(struct tree_balance *tb,
+                                       struct buffer_info *bi,
+                                       struct buffer_head *bh)
+{
+	bi->tb          = tb;
+	bi->bi_bh       = bh;
+	bi->bi_parent   = NULL;
+	bi->bi_position = 0;
+}
+
 inline void do_balance_mark_leaf_dirty(struct tree_balance *tb,
 				       struct buffer_head *bh, int flag)
 {
@@ -86,6 +123,7 @@ static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 	       "PAP-12010: tree can not be empty");
 
 	ih = B_N_PITEM_HEAD(tbS0, item_pos);
+	buffer_info_init_tbS0(tb, &bi);
 
 	/* Delete or truncate the item */
 
@@ -96,10 +134,6 @@ static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 		       "vs-12013: mode Delete, insert size %d, ih to be deleted %h",
 		       -tb->insert_size[0], ih);
 
-		bi.tb = tb;
-		bi.bi_bh = tbS0;
-		bi.bi_parent = PATH_H_PPARENT(tb->tb_path, 0);
-		bi.bi_position = PATH_H_POSITION(tb->tb_path, 1);
 		leaf_delete_items(&bi, 0, item_pos, 1, -1);
 
 		if (!item_pos && tb->CFL[0]) {
@@ -121,10 +155,6 @@ static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 		break;
 
 	case M_CUT:{		/* cut item in S[0] */
-			bi.tb = tb;
-			bi.bi_bh = tbS0;
-			bi.bi_parent = PATH_H_PPARENT(tb->tb_path, 0);
-			bi.bi_position = PATH_H_POSITION(tb->tb_path, 1);
 			if (is_direntry_le_ih(ih)) {
 
 				/* UFS unlink semantics are such that you can only delete one directory entry at a time. */
@@ -325,11 +355,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 					       ih_item_len(ih));
 
 					/* Insert new item into L[0] */
-					bi.tb = tb;
-					bi.bi_bh = tb->L[0];
-					bi.bi_parent = tb->FL[0];
-					bi.bi_position =
-					    get_left_neighbor_position(tb, 0);
+					buffer_info_init_left(tb, &bi);
 					leaf_insert_into_buf(&bi,
 							     n + item_pos -
 							     ret_val, ih, body,
@@ -369,11 +395,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 					    leaf_shift_left(tb, tb->lnum[0] - 1,
 							    tb->lbytes);
 					/* Insert new item into L[0] */
-					bi.tb = tb;
-					bi.bi_bh = tb->L[0];
-					bi.bi_parent = tb->FL[0];
-					bi.bi_position =
-					    get_left_neighbor_position(tb, 0);
+					buffer_info_init_left(tb, &bi);
 					leaf_insert_into_buf(&bi,
 							     n + item_pos -
 							     ret_val, ih, body,
@@ -429,13 +451,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							}
 
 							/* Append given directory entry to directory item */
-							bi.tb = tb;
-							bi.bi_bh = tb->L[0];
-							bi.bi_parent =
-							    tb->FL[0];
-							bi.bi_position =
-							    get_left_neighbor_position
-							    (tb, 0);
+							buffer_info_init_left(tb, &bi);
 							leaf_paste_in_buffer
 							    (&bi,
 							     n + item_pos -
@@ -523,13 +539,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 									     (tbS0,
 									      item_pos)));
 							/* Append to body of item in L[0] */
-							bi.tb = tb;
-							bi.bi_bh = tb->L[0];
-							bi.bi_parent =
-							    tb->FL[0];
-							bi.bi_position =
-							    get_left_neighbor_position
-							    (tb, 0);
+							buffer_info_init_left(tb, &bi);
 							leaf_paste_in_buffer
 							    (&bi,
 							     n + item_pos -
@@ -680,11 +690,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 					    leaf_shift_left(tb, tb->lnum[0],
 							    tb->lbytes);
 					/* Append to body of item in L[0] */
-					bi.tb = tb;
-					bi.bi_bh = tb->L[0];
-					bi.bi_parent = tb->FL[0];
-					bi.bi_position =
-					    get_left_neighbor_position(tb, 0);
+					buffer_info_init_left(tb, &bi);
 					leaf_paste_in_buffer(&bi,
 							     n + item_pos -
 							     ret_val,
@@ -776,11 +782,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 					set_le_ih_k_offset(ih, offset);
 					put_ih_item_len(ih, tb->rbytes);
 					/* Insert part of the item into R[0] */
-					bi.tb = tb;
-					bi.bi_bh = tb->R[0];
-					bi.bi_parent = tb->FR[0];
-					bi.bi_position =
-					    get_right_neighbor_position(tb, 0);
+					buffer_info_init_right(tb, &bi);
 					if ((old_len - tb->rbytes) > zeros_num) {
 						r_zeros_number = 0;
 						r_body =
@@ -817,11 +819,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							     tb->rnum[0] - 1,
 							     tb->rbytes);
 					/* Insert new item into R[0] */
-					bi.tb = tb;
-					bi.bi_bh = tb->R[0];
-					bi.bi_parent = tb->FR[0];
-					bi.bi_position =
-					    get_right_neighbor_position(tb, 0);
+					buffer_info_init_right(tb, &bi);
 					leaf_insert_into_buf(&bi,
 							     item_pos - n +
 							     tb->rnum[0] - 1,
@@ -881,13 +879,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							    pos_in_item -
 							    entry_count +
 							    tb->rbytes - 1;
-							bi.tb = tb;
-							bi.bi_bh = tb->R[0];
-							bi.bi_parent =
-							    tb->FR[0];
-							bi.bi_position =
-							    get_right_neighbor_position
-							    (tb, 0);
+							buffer_info_init_right(tb, &bi);
 							leaf_paste_in_buffer
 							    (&bi, 0,
 							     paste_entry_position,
@@ -1018,12 +1010,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 						    (tb, tb->CFR[0], 0);
 
 						/* Append part of body into R[0] */
-						bi.tb = tb;
-						bi.bi_bh = tb->R[0];
-						bi.bi_parent = tb->FR[0];
-						bi.bi_position =
-						    get_right_neighbor_position
-						    (tb, 0);
+						buffer_info_init_right(tb, &bi);
 						if (n_rem > zeros_num) {
 							r_zeros_number = 0;
 							r_body =
@@ -1070,12 +1057,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							     tb->rbytes);
 					/* append item in R[0] */
 					if (pos_in_item >= 0) {
-						bi.tb = tb;
-						bi.bi_bh = tb->R[0];
-						bi.bi_parent = tb->FR[0];
-						bi.bi_position =
-						    get_right_neighbor_position
-						    (tb, 0);
+						buffer_info_init_right(tb, &bi);
 						leaf_paste_in_buffer(&bi,
 								     item_pos -
 								     n +
@@ -1231,10 +1213,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 					put_ih_item_len(ih, sbytes[i]);
 
 					/* Insert part of the item into S_new[i] before 0-th item */
-					bi.tb = tb;
-					bi.bi_bh = S_new[i];
-					bi.bi_parent = NULL;
-					bi.bi_position = 0;
+					buffer_info_init_bh(tb, &bi, S_new[i]);
 
 					if ((old_len - sbytes[i]) > zeros_num) {
 						r_zeros_number = 0;
@@ -1266,10 +1245,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							S_new[i]);
 
 					/* Insert new item into S_new[i] */
-					bi.tb = tb;
-					bi.bi_bh = S_new[i];
-					bi.bi_parent = NULL;
-					bi.bi_position = 0;
+					buffer_info_init_bh(tb, &bi, S_new[i]);
 					leaf_insert_into_buf(&bi,
 							     item_pos - n +
 							     snum[i] - 1, ih,
@@ -1326,10 +1302,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							     sbytes[i] - 1,
 							     S_new[i]);
 							/* Paste given directory entry to directory item */
-							bi.tb = tb;
-							bi.bi_bh = S_new[i];
-							bi.bi_parent = NULL;
-							bi.bi_position = 0;
+							buffer_info_init_bh(tb, &bi, S_new[i]);
 							leaf_paste_in_buffer
 							    (&bi, 0,
 							     pos_in_item -
@@ -1399,11 +1372,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 						if (n_rem < 0)
 							n_rem = 0;
 						/* Append part of body into S_new[0] */
-						bi.tb = tb;
-						bi.bi_bh = S_new[i];
-						bi.bi_parent = NULL;
-						bi.bi_position = 0;
-
+						buffer_info_init_bh(tb, &bi, S_new[i]);
 						if (n_rem > zeros_num) {
 							r_zeros_number = 0;
 							r_body =
@@ -1490,10 +1459,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 					       leaf_mi);
 
 					/* paste into item */
-					bi.tb = tb;
-					bi.bi_bh = S_new[i];
-					bi.bi_parent = NULL;
-					bi.bi_position = 0;
+					buffer_info_init_bh(tb, &bi, S_new[i]);
 					leaf_paste_in_buffer(&bi,
 							     item_pos - n +
 							     snum[i],
@@ -1560,10 +1526,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 
 		switch (flag) {
 		case M_INSERT:	/* insert item into S[0] */
-			bi.tb = tb;
-			bi.bi_bh = tbS0;
-			bi.bi_parent = PATH_H_PPARENT(tb->tb_path, 0);
-			bi.bi_position = PATH_H_POSITION(tb->tb_path, 1);
+			buffer_info_init_tbS0(tb, &bi);
 			leaf_insert_into_buf(&bi, item_pos, ih, body,
 					     zeros_num);
 
@@ -1590,14 +1553,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 						       "PAP-12260: insert_size is 0 already");
 
 						/* prepare space */
-						bi.tb = tb;
-						bi.bi_bh = tbS0;
-						bi.bi_parent =
-						    PATH_H_PPARENT(tb->tb_path,
-								   0);
-						bi.bi_position =
-						    PATH_H_POSITION(tb->tb_path,
-								    1);
+						buffer_info_init_tbS0(tb, &bi);
 						leaf_paste_in_buffer(&bi,
 								     item_pos,
 								     pos_in_item,
@@ -1645,14 +1601,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 						RFALSE(tb->insert_size[0] <= 0,
 						       "PAP-12275: insert size must not be %d",
 						       tb->insert_size[0]);
-						bi.tb = tb;
-						bi.bi_bh = tbS0;
-						bi.bi_parent =
-						    PATH_H_PPARENT(tb->tb_path,
-								   0);
-						bi.bi_position =
-						    PATH_H_POSITION(tb->tb_path,
-								    1);
+						buffer_info_init_tbS0(tb, &bi);
 						leaf_paste_in_buffer(&bi,
 								     item_pos,
 								     pos_in_item,
@@ -1725,7 +1674,6 @@ void make_empty_node(struct buffer_info *bi)
 struct buffer_head *get_FEB(struct tree_balance *tb)
 {
 	int i;
-	struct buffer_head *first_b;
 	struct buffer_info bi;
 
 	for (i = 0; i < MAX_FEB_SIZE; i++)
@@ -1735,16 +1683,13 @@ struct buffer_head *get_FEB(struct tree_balance *tb)
 	if (i == MAX_FEB_SIZE)
 		reiserfs_panic(tb->tb_sb, "vs-12300", "FEB list is empty");
 
-	bi.tb = tb;
-	bi.bi_bh = first_b = tb->FEB[i];
-	bi.bi_parent = NULL;
-	bi.bi_position = 0;
+	buffer_info_init_bh(tb, &bi, tb->FEB[i]);
 	make_empty_node(&bi);
-	set_buffer_uptodate(first_b);
+	set_buffer_uptodate(tb->FEB[i]);
+	tb->used[i] = tb->FEB[i];
 	tb->FEB[i] = NULL;
-	tb->used[i] = first_b;
 
-	return (first_b);
+	return tb->used[i];
 }
 
 /* This is now used because reiserfs_free_block has to be able to

commit c3a9c2109f84882b9b3178f6b1838d550d3df0ec
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:25 2009 -0400

    reiserfs: rework reiserfs_panic
    
    ReiserFS panics can be somewhat inconsistent.
    In some cases:
     * a unique identifier may be associated with it
     * the function name may be included
     * the device may be printed separately
    
    This patch aims to make warnings more consistent. reiserfs_warning() prints
    the device name, so printing it a second time is not required. The function
    name for a warning is always helpful in debugging, so it is now automatically
    inserted into the output. Hans has stated that every warning should have
    a unique identifier. Some cases lack them, others really shouldn't have them.
    reiserfs_warning() now expects an id associated with each message. In the
    rare case where one isn't needed, "" will suffice.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index f701f37ddf98..e788fbc3ff6b 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -153,8 +153,8 @@ static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 
 	default:
 		print_cur_tb("12040");
-		reiserfs_panic(tb->tb_sb,
-			       "PAP-12040: balance_leaf_when_delete: unexpectable mode: %s(%d)",
+		reiserfs_panic(tb->tb_sb, "PAP-12040",
+			       "unexpected mode: %s(%d)",
 			       (flag ==
 				M_PASTE) ? "PASTE" : ((flag ==
 						       M_INSERT) ? "INSERT" :
@@ -721,8 +721,9 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 				}
 				break;
 			default:	/* cases d and t */
-				reiserfs_panic(tb->tb_sb,
-					       "PAP-12130: balance_leaf: lnum > 0: unexpectable mode: %s(%d)",
+				reiserfs_panic(tb->tb_sb, "PAP-12130",
+					       "lnum > 0: unexpected mode: "
+					       " %s(%d)",
 					       (flag ==
 						M_DELETE) ? "DELETE" : ((flag ==
 									 M_CUT)
@@ -1134,8 +1135,8 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 			}
 			break;
 		default:	/* cases d and t */
-			reiserfs_panic(tb->tb_sb,
-				       "PAP-12175: balance_leaf: rnum > 0: unexpectable mode: %s(%d)",
+			reiserfs_panic(tb->tb_sb, "PAP-12175",
+				       "rnum > 0: unexpected mode: %s(%d)",
 				       (flag ==
 					M_DELETE) ? "DELETE" : ((flag ==
 								 M_CUT) ? "CUT"
@@ -1165,8 +1166,8 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 		   not set correctly */
 		if (tb->CFL[0]) {
 			if (!tb->CFR[0])
-				reiserfs_panic(tb->tb_sb,
-					       "vs-12195: balance_leaf: CFR not initialized");
+				reiserfs_panic(tb->tb_sb, "vs-12195",
+					       "CFR not initialized");
 			copy_key(B_N_PDELIM_KEY(tb->CFL[0], tb->lkey[0]),
 				 B_N_PDELIM_KEY(tb->CFR[0], tb->rkey[0]));
 			do_balance_mark_internal_dirty(tb, tb->CFL[0], 0);
@@ -1472,7 +1473,10 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 					    && (pos_in_item != ih_item_len(ih_check)
 						|| tb->insert_size[0] <= 0))
 						reiserfs_panic(tb->tb_sb,
-							       "PAP-12235: balance_leaf: pos_in_item must be equal to ih_item_len");
+							     "PAP-12235",
+							     "pos_in_item "
+							     "must be equal "
+							     "to ih_item_len");
 #endif				/* CONFIG_REISERFS_CHECK */
 
 					leaf_mi =
@@ -1532,8 +1536,8 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 			}
 			break;
 		default:	/* cases d and t */
-			reiserfs_panic(tb->tb_sb,
-				       "PAP-12245: balance_leaf: blknum > 2: unexpectable mode: %s(%d)",
+			reiserfs_panic(tb->tb_sb, "PAP-12245",
+				       "blknum > 2: unexpected mode: %s(%d)",
 				       (flag ==
 					M_DELETE) ? "DELETE" : ((flag ==
 								 M_CUT) ? "CUT"
@@ -1678,10 +1682,11 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							print_cur_tb("12285");
 							reiserfs_panic(tb->
 								       tb_sb,
-								       "PAP-12285: balance_leaf: insert_size must be 0 (%d)",
-								       tb->
-								       insert_size
-								       [0]);
+							    "PAP-12285",
+							    "insert_size "
+							    "must be 0 "
+							    "(%d)",
+							    tb->insert_size[0]);
 						}
 					}
 #endif				/* CONFIG_REISERFS_CHECK */
@@ -1694,11 +1699,10 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 	if (flag == M_PASTE && tb->insert_size[0]) {
 		print_cur_tb("12290");
 		reiserfs_panic(tb->tb_sb,
-			       "PAP-12290: balance_leaf: insert_size is still not 0 (%d)",
+			       "PAP-12290", "insert_size is still not 0 (%d)",
 			       tb->insert_size[0]);
 	}
 #endif				/* CONFIG_REISERFS_CHECK */
-
 	return 0;
 }				/* Leaf level of the tree is balanced (end of balance_leaf) */
 
@@ -1729,8 +1733,7 @@ struct buffer_head *get_FEB(struct tree_balance *tb)
 			break;
 
 	if (i == MAX_FEB_SIZE)
-		reiserfs_panic(tb->tb_sb,
-			       "vs-12300: get_FEB: FEB list is empty");
+		reiserfs_panic(tb->tb_sb, "vs-12300", "FEB list is empty");
 
 	bi.tb = tb;
 	bi.bi_bh = first_b = tb->FEB[i];
@@ -1871,8 +1874,8 @@ static void check_internal_node(struct super_block *s, struct buffer_head *bh,
 	for (i = 0; i <= B_NR_ITEMS(bh); i++, dc++) {
 		if (!is_reusable(s, dc_block_number(dc), 1)) {
 			print_cur_tb(mes);
-			reiserfs_panic(s,
-				       "PAP-12338: check_internal_node: invalid child pointer %y in %b",
+			reiserfs_panic(s, "PAP-12338",
+				       "invalid child pointer %y in %b",
 				       dc, bh);
 		}
 	}
@@ -1894,9 +1897,10 @@ static int check_before_balancing(struct tree_balance *tb)
 	int retval = 0;
 
 	if (cur_tb) {
-		reiserfs_panic(tb->tb_sb, "vs-12335: check_before_balancing: "
-			       "suspect that schedule occurred based on cur_tb not being null at this point in code. "
-			       "do_balance cannot properly handle schedule occurring while it runs.");
+		reiserfs_panic(tb->tb_sb, "vs-12335", "suspect that schedule "
+			       "occurred based on cur_tb not being null at "
+			       "this point in code. do_balance cannot properly "
+			       "handle schedule occurring while it runs.");
 	}
 
 	/* double check that buffers that we will modify are unlocked. (fix_nodes should already have
@@ -1928,8 +1932,8 @@ static void check_after_balance_leaf(struct tree_balance *tb)
 		    dc_size(B_N_CHILD
 			    (tb->FL[0], get_left_neighbor_position(tb, 0)))) {
 			print_cur_tb("12221");
-			reiserfs_panic(tb->tb_sb,
-				       "PAP-12355: check_after_balance_leaf: shift to left was incorrect");
+			reiserfs_panic(tb->tb_sb, "PAP-12355",
+				       "shift to left was incorrect");
 		}
 	}
 	if (tb->rnum[0]) {
@@ -1938,8 +1942,8 @@ static void check_after_balance_leaf(struct tree_balance *tb)
 		    dc_size(B_N_CHILD
 			    (tb->FR[0], get_right_neighbor_position(tb, 0)))) {
 			print_cur_tb("12222");
-			reiserfs_panic(tb->tb_sb,
-				       "PAP-12360: check_after_balance_leaf: shift to right was incorrect");
+			reiserfs_panic(tb->tb_sb, "PAP-12360",
+				       "shift to right was incorrect");
 		}
 	}
 	if (PATH_H_PBUFFER(tb->tb_path, 1) &&
@@ -1964,8 +1968,7 @@ static void check_after_balance_leaf(struct tree_balance *tb)
 					 (PATH_H_PBUFFER(tb->tb_path, 1),
 					  PATH_H_POSITION(tb->tb_path, 1))),
 				 right);
-		reiserfs_panic(tb->tb_sb,
-			       "PAP-12365: check_after_balance_leaf: S is incorrect");
+		reiserfs_panic(tb->tb_sb, "PAP-12365", "S is incorrect");
 	}
 }
 
@@ -2100,8 +2103,8 @@ void do_balance(struct tree_balance *tb,	/* tree_balance structure */
 	tb->need_balance_dirty = 0;
 
 	if (FILESYSTEM_CHANGED_TB(tb)) {
-		reiserfs_panic(tb->tb_sb,
-			       "clm-6000: do_balance, fs generation has changed\n");
+		reiserfs_panic(tb->tb_sb, "clm-6000", "fs generation has "
+			       "changed");
 	}
 	/* if we have no real work to do  */
 	if (!tb->insert_size[0]) {

commit 45b03d5e8e674eb6555b767e1c8eb40b671ff892
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:21 2009 -0400

    reiserfs: rework reiserfs_warning
    
    ReiserFS warnings can be somewhat inconsistent.
    In some cases:
     * a unique identifier may be associated with it
     * the function name may be included
     * the device may be printed separately
    
    This patch aims to make warnings more consistent. reiserfs_warning() prints
    the device name, so printing it a second time is not required. The function
    name for a warning is always helpful in debugging, so it is now automatically
    inserted into the output. Hans has stated that every warning should have
    a unique identifier. Some cases lack them, others really shouldn't have them.
    reiserfs_warning() now expects an id associated with each message. In the
    rare case where one isn't needed, "" will suffice.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 99f80538c4bf..f701f37ddf98 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -1752,15 +1752,16 @@ static void store_thrown(struct tree_balance *tb, struct buffer_head *bh)
 	int i;
 
 	if (buffer_dirty(bh))
-		reiserfs_warning(tb->tb_sb,
-				 "store_thrown deals with dirty buffer");
+		reiserfs_warning(tb->tb_sb, "reiserfs-12320",
+				 "called with dirty buffer");
 	for (i = 0; i < ARRAY_SIZE(tb->thrown); i++)
 		if (!tb->thrown[i]) {
 			tb->thrown[i] = bh;
 			get_bh(bh);	/* free_thrown puts this */
 			return;
 		}
-	reiserfs_warning(tb->tb_sb, "store_thrown: too many thrown buffers");
+	reiserfs_warning(tb->tb_sb, "reiserfs-12321",
+			 "too many thrown buffers");
 }
 
 static void free_thrown(struct tree_balance *tb)
@@ -1771,8 +1772,8 @@ static void free_thrown(struct tree_balance *tb)
 		if (tb->thrown[i]) {
 			blocknr = tb->thrown[i]->b_blocknr;
 			if (buffer_dirty(tb->thrown[i]))
-				reiserfs_warning(tb->tb_sb,
-						 "free_thrown deals with dirty buffer %d",
+				reiserfs_warning(tb->tb_sb, "reiserfs-12322",
+						 "called with dirty buffer %d",
 						 blocknr);
 			brelse(tb->thrown[i]);	/* incremented in store_thrown */
 			reiserfs_free_block(tb->transaction_handle, NULL,
@@ -1877,13 +1878,12 @@ static void check_internal_node(struct super_block *s, struct buffer_head *bh,
 	}
 }
 
-static int locked_or_not_in_tree(struct buffer_head *bh, char *which)
+static int locked_or_not_in_tree(struct tree_balance *tb,
+				  struct buffer_head *bh, char *which)
 {
 	if ((!buffer_journal_prepared(bh) && buffer_locked(bh)) ||
 	    !B_IS_IN_TREE(bh)) {
-		reiserfs_warning(NULL,
-				 "vs-12339: locked_or_not_in_tree: %s (%b)",
-				 which, bh);
+		reiserfs_warning(tb->tb_sb, "vs-12339", "%s (%b)", which, bh);
 		return 1;
 	}
 	return 0;
@@ -1902,18 +1902,19 @@ static int check_before_balancing(struct tree_balance *tb)
 	/* double check that buffers that we will modify are unlocked. (fix_nodes should already have
 	   prepped all of these for us). */
 	if (tb->lnum[0]) {
-		retval |= locked_or_not_in_tree(tb->L[0], "L[0]");
-		retval |= locked_or_not_in_tree(tb->FL[0], "FL[0]");
-		retval |= locked_or_not_in_tree(tb->CFL[0], "CFL[0]");
+		retval |= locked_or_not_in_tree(tb, tb->L[0], "L[0]");
+		retval |= locked_or_not_in_tree(tb, tb->FL[0], "FL[0]");
+		retval |= locked_or_not_in_tree(tb, tb->CFL[0], "CFL[0]");
 		check_leaf(tb->L[0]);
 	}
 	if (tb->rnum[0]) {
-		retval |= locked_or_not_in_tree(tb->R[0], "R[0]");
-		retval |= locked_or_not_in_tree(tb->FR[0], "FR[0]");
-		retval |= locked_or_not_in_tree(tb->CFR[0], "CFR[0]");
+		retval |= locked_or_not_in_tree(tb, tb->R[0], "R[0]");
+		retval |= locked_or_not_in_tree(tb, tb->FR[0], "FR[0]");
+		retval |= locked_or_not_in_tree(tb, tb->CFR[0], "CFR[0]");
 		check_leaf(tb->R[0]);
 	}
-	retval |= locked_or_not_in_tree(PATH_PLAST_BUFFER(tb->tb_path), "S[0]");
+	retval |= locked_or_not_in_tree(tb, PATH_PLAST_BUFFER(tb->tb_path),
+					"S[0]");
 	check_leaf(PATH_PLAST_BUFFER(tb->tb_path));
 
 	return retval;
@@ -1952,7 +1953,7 @@ static void check_after_balance_leaf(struct tree_balance *tb)
 					       PATH_H_POSITION(tb->tb_path,
 							       1))));
 		print_cur_tb("12223");
-		reiserfs_warning(tb->tb_sb,
+		reiserfs_warning(tb->tb_sb, "reiserfs-12363",
 				 "B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) = %d; "
 				 "MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d",
 				 left,
@@ -2104,9 +2105,8 @@ void do_balance(struct tree_balance *tb,	/* tree_balance structure */
 	}
 	/* if we have no real work to do  */
 	if (!tb->insert_size[0]) {
-		reiserfs_warning(tb->tb_sb,
-				 "PAP-12350: do_balance: insert_size == 0, mode == %c",
-				 flag);
+		reiserfs_warning(tb->tb_sb, "PAP-12350",
+				 "insert_size == 0, mode == %c", flag);
 		unfix_nodes(tb);
 		return;
 	}

commit eba00305591714f1d85ccad1afbf58259c2197b4
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:18 2009 -0400

    reiserfs: use buffer_info for leaf_paste_entries
    
    This patch makes leaf_paste_entries more consistent with respect to the
    other leaf operations.  Using buffer_info instead of buffer_head
    directly allows us to get a superblock pointer for use in error
    handling.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 2f87f5b14630..99f80538c4bf 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -449,8 +449,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							/* when we have merge directory item, pos_in_item has been changed too */
 
 							/* paste new directory entry. 1 is entry number */
-							leaf_paste_entries(bi.
-									   bi_bh,
+							leaf_paste_entries(&bi,
 									   n +
 									   item_pos
 									   -
@@ -699,7 +698,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							   n + item_pos -
 							   ret_val);
 					if (is_direntry_le_ih(pasted))
-						leaf_paste_entries(bi.bi_bh,
+						leaf_paste_entries(&bi,
 								   n +
 								   item_pos -
 								   ret_val,
@@ -894,8 +893,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							     tb->insert_size[0],
 							     body, zeros_num);
 							/* paste entry */
-							leaf_paste_entries(bi.
-									   bi_bh,
+							leaf_paste_entries(&bi,
 									   0,
 									   paste_entry_position,
 									   1,
@@ -1096,7 +1094,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							   tb->rnum[0]);
 					if (is_direntry_le_ih(pasted)
 					    && pos_in_item >= 0) {
-						leaf_paste_entries(bi.bi_bh,
+						leaf_paste_entries(&bi,
 								   item_pos -
 								   n +
 								   tb->rnum[0],
@@ -1339,8 +1337,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							     tb->insert_size[0],
 							     body, zeros_num);
 							/* paste new directory entry */
-							leaf_paste_entries(bi.
-									   bi_bh,
+							leaf_paste_entries(&bi,
 									   0,
 									   pos_in_item
 									   -
@@ -1505,7 +1502,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 							   item_pos - n +
 							   snum[i]);
 					if (is_direntry_le_ih(pasted)) {
-						leaf_paste_entries(bi.bi_bh,
+						leaf_paste_entries(&bi,
 								   item_pos -
 								   n + snum[i],
 								   pos_in_item,
@@ -1606,7 +1603,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 								     zeros_num);
 
 						/* paste entry */
-						leaf_paste_entries(bi.bi_bh,
+						leaf_paste_entries(&bi,
 								   item_pos,
 								   pos_in_item,
 								   1,

commit 8acc570fabc022d41baedc0c9bf976a4b9d16d6f
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Apr 28 02:16:21 2008 -0700

    reiserfs: fix more sparse warnings in do_balan.c
    
    fs/reiserfs/do_balan.c:1467:10: warning: symbol 'ret_val' shadows an earlier one
    fs/reiserfs/do_balan.c:275:6: originally declared here
    fs/reiserfs/do_balan.c:1471:23: warning: symbol 'ih' shadows an earlier one
    fs/reiserfs/do_balan.c:249:67: originally declared here
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 7ee4208793b6..2f87f5b14630 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -1464,29 +1464,29 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 				} else
 					/* item falls wholly into S_new[i] */
 				{
-					int ret_val;
+					int leaf_mi;
 					struct item_head *pasted;
 
 #ifdef CONFIG_REISERFS_CHECK
-					struct item_head *ih =
+					struct item_head *ih_check =
 					    B_N_PITEM_HEAD(tbS0, item_pos);
 
-					if (!is_direntry_le_ih(ih)
-					    && (pos_in_item != ih_item_len(ih)
+					if (!is_direntry_le_ih(ih_check)
+					    && (pos_in_item != ih_item_len(ih_check)
 						|| tb->insert_size[0] <= 0))
 						reiserfs_panic(tb->tb_sb,
 							       "PAP-12235: balance_leaf: pos_in_item must be equal to ih_item_len");
 #endif				/* CONFIG_REISERFS_CHECK */
 
-					ret_val =
+					leaf_mi =
 					    leaf_move_items(LEAF_FROM_S_TO_SNEW,
 							    tb, snum[i],
 							    sbytes[i],
 							    S_new[i]);
 
-					RFALSE(ret_val,
+					RFALSE(leaf_mi,
 					       "PAP-12240: unexpected value returned by leaf_move_items (%d)",
-					       ret_val);
+					       leaf_mi);
 
 					/* paste into item */
 					bi.tb = tb;

commit 9dce07f1a441b77a15631cf0ed0238e0baa7ed64
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Mar 29 03:07:28 2008 +0000

    NULL noise: fs/*, mm/*, kernel/*
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index f85c5cf4934c..7ee4208793b6 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -283,7 +283,7 @@ static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item h
 		return balance_leaf_when_delete(tb, flag);
 
 	zeros_num = 0;
-	if (flag == M_INSERT && body == 0)
+	if (flag == M_INSERT && !body)
 		zeros_num = ih_item_len(ih);
 
 	pos_in_item = tb->tb_path->pos_in_item;
@@ -1728,7 +1728,7 @@ struct buffer_head *get_FEB(struct tree_balance *tb)
 	struct buffer_info bi;
 
 	for (i = 0; i < MAX_FEB_SIZE; i++)
-		if (tb->FEB[i] != 0)
+		if (tb->FEB[i] != NULL)
 			break;
 
 	if (i == MAX_FEB_SIZE)
@@ -1827,7 +1827,7 @@ int get_left_neighbor_position(struct tree_balance *tb, int h)
 {
 	int Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);
 
-	RFALSE(PATH_H_PPARENT(tb->tb_path, h) == 0 || tb->FL[h] == 0,
+	RFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL,
 	       "vs-12325: FL[%d](%p) or F[%d](%p) does not exist",
 	       h, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));
 
@@ -1841,7 +1841,7 @@ int get_right_neighbor_position(struct tree_balance *tb, int h)
 {
 	int Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);
 
-	RFALSE(PATH_H_PPARENT(tb->tb_path, h) == 0 || tb->FR[h] == 0,
+	RFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL,
 	       "vs-12330: F[%d](%p) or FR[%d](%p) does not exist",
 	       h, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);
 

commit 79a81aef769f3a188988ad16032ccfc445cfaa13
Author: Ahmed S. Darwish <darwish.07@gmail.com>
Date:   Mon Feb 12 00:52:09 2007 -0800

    [PATCH] reiserfs: Use ARRAY_SIZE macro when appropriate
    
    Use ARRAY_SIZE macro already defined in kernel.h
    
    Signed-off-by: Ahmed S. Darwish <darwish.07@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index fba304e64de8..f85c5cf4934c 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -19,6 +19,7 @@
 #include <linux/time.h>
 #include <linux/reiserfs_fs.h>
 #include <linux/buffer_head.h>
+#include <linux/kernel.h>
 
 #ifdef CONFIG_REISERFS_CHECK
 
@@ -1756,7 +1757,7 @@ static void store_thrown(struct tree_balance *tb, struct buffer_head *bh)
 	if (buffer_dirty(bh))
 		reiserfs_warning(tb->tb_sb,
 				 "store_thrown deals with dirty buffer");
-	for (i = 0; i < sizeof(tb->thrown) / sizeof(tb->thrown[0]); i++)
+	for (i = 0; i < ARRAY_SIZE(tb->thrown); i++)
 		if (!tb->thrown[i]) {
 			tb->thrown[i] = bh;
 			get_bh(bh);	/* free_thrown puts this */
@@ -1769,7 +1770,7 @@ static void free_thrown(struct tree_balance *tb)
 {
 	int i;
 	b_blocknr_t blocknr;
-	for (i = 0; i < sizeof(tb->thrown) / sizeof(tb->thrown[0]); i++) {
+	for (i = 0; i < ARRAY_SIZE(tb->thrown); i++) {
 		if (tb->thrown[i]) {
 			blocknr = tb->thrown[i]->b_blocknr;
 			if (buffer_dirty(tb->thrown[i]))

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index b2264ba3cc56..fba304e64de8 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -15,7 +15,6 @@
  **
  **/
 
-#include <linux/config.h>
 #include <asm/uaccess.h>
 #include <linux/time.h>
 #include <linux/reiserfs_fs.h>

commit bd4c625c061c2a38568d0add3478f59172455159
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Tue Jul 12 20:21:28 2005 -0700

    reiserfs: run scripts/Lindent on reiserfs code
    
    This was a pure indentation change, using:
    
            scripts/Lindent fs/reiserfs/*.c include/linux/reiserfs_*.h
    
    to make reiserfs match the regular Linux indentation style.  As Jeff
    Mahoney <jeffm@suse.com> writes:
    
     The ReiserFS code is a mix of a number of different coding styles, sometimes
     different even from line-to-line. Since the code has been relatively stable
     for quite some time and there are few outstanding patches to be applied, it
     is time to reformat the code to conform to the Linux style standard outlined
     in Documentation/CodingStyle.
    
     This patch contains the result of running scripts/Lindent against
     fs/reiserfs/*.c and include/linux/reiserfs_*.h. There are places where the
     code can be made to look better, but I'd rather keep those patches separate
     so that there isn't a subtle by-hand hand accident in the middle of a huge
     patch. To be clear: This patch is reformatting *only*.
    
     A number of patches may follow that continue to make the code more consistent
     with the Linux coding style.
    
     Hans wasn't particularly enthusiastic about these patches, but said he
     wouldn't really oppose them either.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
index 2118db2896c7..b2264ba3cc56 100644
--- a/fs/reiserfs/do_balan.c
+++ b/fs/reiserfs/do_balan.c
@@ -8,7 +8,6 @@
 /* balance the tree according to the analysis made before,		*/
 /* and using buffers obtained after all above.				*/
 
-
 /**
  ** balance_leaf_when_delete
  ** balance_leaf
@@ -24,23 +23,22 @@
 
 #ifdef CONFIG_REISERFS_CHECK
 
-struct tree_balance * cur_tb = NULL; /* detects whether more than one
-                                        copy of tb exists as a means
-                                        of checking whether schedule
-                                        is interrupting do_balance */
+struct tree_balance *cur_tb = NULL;	/* detects whether more than one
+					   copy of tb exists as a means
+					   of checking whether schedule
+					   is interrupting do_balance */
 #endif
 
-inline void do_balance_mark_leaf_dirty (struct tree_balance * tb, 
-					struct buffer_head * bh, int flag)
+inline void do_balance_mark_leaf_dirty(struct tree_balance *tb,
+				       struct buffer_head *bh, int flag)
 {
-    journal_mark_dirty(tb->transaction_handle,
-                       tb->transaction_handle->t_super, bh) ;
+	journal_mark_dirty(tb->transaction_handle,
+			   tb->transaction_handle->t_super, bh);
 }
 
 #define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty
 #define do_balance_mark_sb_dirty do_balance_mark_leaf_dirty
 
-
 /* summary: 
  if deleting something ( tb->insert_size[0] < 0 )
    return(balance_leaf_when_delete()); (flag d handled here)
@@ -64,8 +62,6 @@ be performed by do_balance.
 
 -Hans */
 
-
-
 /* Balance leaf node in case of delete or cut: insert_size[0] < 0
  *
  * lnum, rnum can have values >= -1
@@ -73,1384 +69,1933 @@ be performed by do_balance.
  *	 0 means that nothing should be done with the neighbor
  *	>0 means to shift entirely or partly the specified number of items to the neighbor
  */
-static int balance_leaf_when_delete (struct tree_balance * tb, int flag)
+static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 {
-    struct buffer_head * tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
-    int item_pos = PATH_LAST_POSITION (tb->tb_path);
-    int pos_in_item = tb->tb_path->pos_in_item;
-    struct buffer_info bi;
-    int n;
-    struct item_head * ih;
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int item_pos = PATH_LAST_POSITION(tb->tb_path);
+	int pos_in_item = tb->tb_path->pos_in_item;
+	struct buffer_info bi;
+	int n;
+	struct item_head *ih;
 
-    RFALSE( tb->FR[0] && B_LEVEL (tb->FR[0]) != DISK_LEAF_NODE_LEVEL + 1,
-	    "vs- 12000: level: wrong FR %z", tb->FR[0]);
-    RFALSE( tb->blknum[0] > 1,
-	    "PAP-12005: tb->blknum == %d, can not be > 1", tb->blknum[0]);
-    RFALSE( ! tb->blknum[0] && ! PATH_H_PPARENT(tb->tb_path, 0),
-	    "PAP-12010: tree can not be empty");
+	RFALSE(tb->FR[0] && B_LEVEL(tb->FR[0]) != DISK_LEAF_NODE_LEVEL + 1,
+	       "vs- 12000: level: wrong FR %z", tb->FR[0]);
+	RFALSE(tb->blknum[0] > 1,
+	       "PAP-12005: tb->blknum == %d, can not be > 1", tb->blknum[0]);
+	RFALSE(!tb->blknum[0] && !PATH_H_PPARENT(tb->tb_path, 0),
+	       "PAP-12010: tree can not be empty");
 
-    ih = B_N_PITEM_HEAD (tbS0, item_pos);
+	ih = B_N_PITEM_HEAD(tbS0, item_pos);
 
-    /* Delete or truncate the item */
+	/* Delete or truncate the item */
 
-    switch (flag) {
-    case M_DELETE:   /* delete item in S[0] */
+	switch (flag) {
+	case M_DELETE:		/* delete item in S[0] */
+
+		RFALSE(ih_item_len(ih) + IH_SIZE != -tb->insert_size[0],
+		       "vs-12013: mode Delete, insert size %d, ih to be deleted %h",
+		       -tb->insert_size[0], ih);
+
+		bi.tb = tb;
+		bi.bi_bh = tbS0;
+		bi.bi_parent = PATH_H_PPARENT(tb->tb_path, 0);
+		bi.bi_position = PATH_H_POSITION(tb->tb_path, 1);
+		leaf_delete_items(&bi, 0, item_pos, 1, -1);
+
+		if (!item_pos && tb->CFL[0]) {
+			if (B_NR_ITEMS(tbS0)) {
+				replace_key(tb, tb->CFL[0], tb->lkey[0], tbS0,
+					    0);
+			} else {
+				if (!PATH_H_POSITION(tb->tb_path, 1))
+					replace_key(tb, tb->CFL[0], tb->lkey[0],
+						    PATH_H_PPARENT(tb->tb_path,
+								   0), 0);
+			}
+		}
 
-	RFALSE( ih_item_len(ih) + IH_SIZE != -tb->insert_size[0],
-	        "vs-12013: mode Delete, insert size %d, ih to be deleted %h",
- 		 -tb->insert_size [0], ih);
+		RFALSE(!item_pos && !tb->CFL[0],
+		       "PAP-12020: tb->CFL[0]==%p, tb->L[0]==%p", tb->CFL[0],
+		       tb->L[0]);
 
-	bi.tb = tb;
-	bi.bi_bh = tbS0;
-	bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
-	bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
-	leaf_delete_items (&bi, 0, item_pos, 1, -1);
-
-	if ( ! item_pos && tb->CFL[0] ) {
-	    if ( B_NR_ITEMS(tbS0) ) {
-		replace_key(tb, tb->CFL[0],tb->lkey[0],tbS0,0);
-	    }
-	    else {
-		if ( ! PATH_H_POSITION (tb->tb_path, 1) )
-		    replace_key(tb, tb->CFL[0],tb->lkey[0],PATH_H_PPARENT(tb->tb_path, 0),0);
-	    }
-	} 
-
-	RFALSE( ! item_pos && !tb->CFL[0],
-		"PAP-12020: tb->CFL[0]==%p, tb->L[0]==%p", tb->CFL[0], tb->L[0]);
-    
-	break;
-
-    case M_CUT: {  /* cut item in S[0] */
-	bi.tb = tb;
-	bi.bi_bh = tbS0;
-	bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
-	bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
-	if (is_direntry_le_ih (ih)) {
-
-	    /* UFS unlink semantics are such that you can only delete one directory entry at a time. */
-	    /* when we cut a directory tb->insert_size[0] means number of entries to be cut (always 1) */
-	    tb->insert_size[0] = -1;
-	    leaf_cut_from_buffer (&bi, item_pos, pos_in_item, -tb->insert_size[0]);
-
-	    RFALSE( ! item_pos && ! pos_in_item && ! tb->CFL[0],
-		    "PAP-12030: can not change delimiting key. CFL[0]=%p", 
-		    tb->CFL[0]);
-
-	    if ( ! item_pos && ! pos_in_item && tb->CFL[0] ) {
-		replace_key(tb, tb->CFL[0],tb->lkey[0],tbS0,0);
-	    }
-	} else {
-	    leaf_cut_from_buffer (&bi, item_pos, pos_in_item, -tb->insert_size[0]);
-
-	    RFALSE( ! ih_item_len(ih),
-		"PAP-12035: cut must leave non-zero dynamic length of item");
-	}
-	break;
-    }
-
-    default:
-	print_cur_tb ("12040");
-	reiserfs_panic (tb->tb_sb, "PAP-12040: balance_leaf_when_delete: unexpectable mode: %s(%d)",
-			(flag == M_PASTE) ? "PASTE" : ((flag == M_INSERT) ? "INSERT" : "UNKNOWN"), flag);
-    }
-
-    /* the rule is that no shifting occurs unless by shifting a node can be freed */
-    n = B_NR_ITEMS(tbS0);
-    if ( tb->lnum[0] )     /* L[0] takes part in balancing */
-    {
-	if ( tb->lnum[0] == -1 )    /* L[0] must be joined with S[0] */
-	{
-	    if ( tb->rnum[0] == -1 )    /* R[0] must be also joined with S[0] */
-	    {			
-		if ( tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0) )
-		{
-		    /* all contents of all the 3 buffers will be in L[0] */
-		    if ( PATH_H_POSITION (tb->tb_path, 1) == 0 && 1 < B_NR_ITEMS(tb->FR[0]) )
-			replace_key(tb, tb->CFL[0],tb->lkey[0],tb->FR[0],1);
-
-		    leaf_move_items (LEAF_FROM_S_TO_L, tb, n, -1, NULL);
-		    leaf_move_items (LEAF_FROM_R_TO_L, tb, B_NR_ITEMS(tb->R[0]), -1, NULL);
-
-		    reiserfs_invalidate_buffer (tb, tbS0);
-		    reiserfs_invalidate_buffer (tb, tb->R[0]);
-
-		    return 0;
+		break;
+
+	case M_CUT:{		/* cut item in S[0] */
+			bi.tb = tb;
+			bi.bi_bh = tbS0;
+			bi.bi_parent = PATH_H_PPARENT(tb->tb_path, 0);
+			bi.bi_position = PATH_H_POSITION(tb->tb_path, 1);
+			if (is_direntry_le_ih(ih)) {
+
+				/* UFS unlink semantics are such that you can only delete one directory entry at a time. */
+				/* when we cut a directory tb->insert_size[0] means number of entries to be cut (always 1) */
+				tb->insert_size[0] = -1;
+				leaf_cut_from_buffer(&bi, item_pos, pos_in_item,
+						     -tb->insert_size[0]);
+
+				RFALSE(!item_pos && !pos_in_item && !tb->CFL[0],
+				       "PAP-12030: can not change delimiting key. CFL[0]=%p",
+				       tb->CFL[0]);
+
+				if (!item_pos && !pos_in_item && tb->CFL[0]) {
+					replace_key(tb, tb->CFL[0], tb->lkey[0],
+						    tbS0, 0);
+				}
+			} else {
+				leaf_cut_from_buffer(&bi, item_pos, pos_in_item,
+						     -tb->insert_size[0]);
+
+				RFALSE(!ih_item_len(ih),
+				       "PAP-12035: cut must leave non-zero dynamic length of item");
+			}
+			break;
 		}
-		/* all contents of all the 3 buffers will be in R[0] */
-		leaf_move_items (LEAF_FROM_S_TO_R, tb, n, -1, NULL);
-		leaf_move_items (LEAF_FROM_L_TO_R, tb, B_NR_ITEMS(tb->L[0]), -1, NULL);
 
-		/* right_delimiting_key is correct in R[0] */
-		replace_key(tb, tb->CFR[0],tb->rkey[0],tb->R[0],0);
+	default:
+		print_cur_tb("12040");
+		reiserfs_panic(tb->tb_sb,
+			       "PAP-12040: balance_leaf_when_delete: unexpectable mode: %s(%d)",
+			       (flag ==
+				M_PASTE) ? "PASTE" : ((flag ==
+						       M_INSERT) ? "INSERT" :
+						      "UNKNOWN"), flag);
+	}
 
-		reiserfs_invalidate_buffer (tb, tbS0);
-		reiserfs_invalidate_buffer (tb, tb->L[0]);
+	/* the rule is that no shifting occurs unless by shifting a node can be freed */
+	n = B_NR_ITEMS(tbS0);
+	if (tb->lnum[0]) {	/* L[0] takes part in balancing */
+		if (tb->lnum[0] == -1) {	/* L[0] must be joined with S[0] */
+			if (tb->rnum[0] == -1) {	/* R[0] must be also joined with S[0] */
+				if (tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0)) {
+					/* all contents of all the 3 buffers will be in L[0] */
+					if (PATH_H_POSITION(tb->tb_path, 1) == 0
+					    && 1 < B_NR_ITEMS(tb->FR[0]))
+						replace_key(tb, tb->CFL[0],
+							    tb->lkey[0],
+							    tb->FR[0], 1);
+
+					leaf_move_items(LEAF_FROM_S_TO_L, tb, n,
+							-1, NULL);
+					leaf_move_items(LEAF_FROM_R_TO_L, tb,
+							B_NR_ITEMS(tb->R[0]),
+							-1, NULL);
+
+					reiserfs_invalidate_buffer(tb, tbS0);
+					reiserfs_invalidate_buffer(tb,
+								   tb->R[0]);
+
+					return 0;
+				}
+				/* all contents of all the 3 buffers will be in R[0] */
+				leaf_move_items(LEAF_FROM_S_TO_R, tb, n, -1,
+						NULL);
+				leaf_move_items(LEAF_FROM_L_TO_R, tb,
+						B_NR_ITEMS(tb->L[0]), -1, NULL);
+
+				/* right_delimiting_key is correct in R[0] */
+				replace_key(tb, tb->CFR[0], tb->rkey[0],
+					    tb->R[0], 0);
 
-		return -1;
-	    }
+				reiserfs_invalidate_buffer(tb, tbS0);
+				reiserfs_invalidate_buffer(tb, tb->L[0]);
 
-	    RFALSE( tb->rnum[0] != 0, 
-		    "PAP-12045: rnum must be 0 (%d)", tb->rnum[0]);
-	    /* all contents of L[0] and S[0] will be in L[0] */
-	    leaf_shift_left(tb, n, -1);
+				return -1;
+			}
 
-	    reiserfs_invalidate_buffer (tb, tbS0);
+			RFALSE(tb->rnum[0] != 0,
+			       "PAP-12045: rnum must be 0 (%d)", tb->rnum[0]);
+			/* all contents of L[0] and S[0] will be in L[0] */
+			leaf_shift_left(tb, n, -1);
 
-	    return 0;
+			reiserfs_invalidate_buffer(tb, tbS0);
+
+			return 0;
+		}
+		/* a part of contents of S[0] will be in L[0] and the rest part of S[0] will be in R[0] */
+
+		RFALSE((tb->lnum[0] + tb->rnum[0] < n) ||
+		       (tb->lnum[0] + tb->rnum[0] > n + 1),
+		       "PAP-12050: rnum(%d) and lnum(%d) and item number(%d) in S[0] are not consistent",
+		       tb->rnum[0], tb->lnum[0], n);
+		RFALSE((tb->lnum[0] + tb->rnum[0] == n) &&
+		       (tb->lbytes != -1 || tb->rbytes != -1),
+		       "PAP-12055: bad rbytes (%d)/lbytes (%d) parameters when items are not split",
+		       tb->rbytes, tb->lbytes);
+		RFALSE((tb->lnum[0] + tb->rnum[0] == n + 1) &&
+		       (tb->lbytes < 1 || tb->rbytes != -1),
+		       "PAP-12060: bad rbytes (%d)/lbytes (%d) parameters when items are split",
+		       tb->rbytes, tb->lbytes);
+
+		leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
+		leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
+
+		reiserfs_invalidate_buffer(tb, tbS0);
+
+		return 0;
 	}
-	/* a part of contents of S[0] will be in L[0] and the rest part of S[0] will be in R[0] */
-
-	RFALSE( ( tb->lnum[0] + tb->rnum[0] < n ) || 
-		( tb->lnum[0] + tb->rnum[0] > n+1 ),
-		"PAP-12050: rnum(%d) and lnum(%d) and item number(%d) in S[0] are not consistent",
-		tb->rnum[0], tb->lnum[0], n);
-	RFALSE( ( tb->lnum[0] + tb->rnum[0] == n ) && 
-		(tb->lbytes != -1 || tb->rbytes != -1),
-		"PAP-12055: bad rbytes (%d)/lbytes (%d) parameters when items are not split", 
-		tb->rbytes, tb->lbytes);
-	RFALSE( ( tb->lnum[0] + tb->rnum[0] == n + 1 ) && 
-		(tb->lbytes < 1 || tb->rbytes != -1),
-		"PAP-12060: bad rbytes (%d)/lbytes (%d) parameters when items are split", 
-		tb->rbytes, tb->lbytes);
-
-	leaf_shift_left (tb, tb->lnum[0], tb->lbytes);
-	leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
-
-	reiserfs_invalidate_buffer (tb, tbS0);
 
-	return 0;
-    }
+	if (tb->rnum[0] == -1) {
+		/* all contents of R[0] and S[0] will be in R[0] */
+		leaf_shift_right(tb, n, -1);
+		reiserfs_invalidate_buffer(tb, tbS0);
+		return 0;
+	}
 
-    if ( tb->rnum[0] == -1 ) {
-	/* all contents of R[0] and S[0] will be in R[0] */
-	leaf_shift_right(tb, n, -1);
-	reiserfs_invalidate_buffer (tb, tbS0);
+	RFALSE(tb->rnum[0],
+	       "PAP-12065: bad rnum parameter must be 0 (%d)", tb->rnum[0]);
 	return 0;
-    }
-
-    RFALSE( tb->rnum[0], 
-	    "PAP-12065: bad rnum parameter must be 0 (%d)", tb->rnum[0]);
-    return 0;
 }
 
-
-static int balance_leaf (struct tree_balance * tb,
-			 struct item_head * ih,		/* item header of inserted item (this is on little endian) */
-			 const char * body,		/* body  of inserted item or bytes to paste */
-			 int flag,			/* i - insert, d - delete, c - cut, p - paste
-							   (see comment to do_balance) */
-			 struct item_head * insert_key,  /* in our processing of one level we sometimes determine what
-							    must be inserted into the next higher level.  This insertion
-							    consists of a key or two keys and their corresponding
-							    pointers */
-			 struct buffer_head ** insert_ptr /* inserted node-ptrs for the next level */
+static int balance_leaf(struct tree_balance *tb, struct item_head *ih,	/* item header of inserted item (this is on little endian) */
+			const char *body,	/* body  of inserted item or bytes to paste */
+			int flag,	/* i - insert, d - delete, c - cut, p - paste
+					   (see comment to do_balance) */
+			struct item_head *insert_key,	/* in our processing of one level we sometimes determine what
+							   must be inserted into the next higher level.  This insertion
+							   consists of a key or two keys and their corresponding
+							   pointers */
+			struct buffer_head **insert_ptr	/* inserted node-ptrs for the next level */
     )
 {
-    struct buffer_head * tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
-    int item_pos = PATH_LAST_POSITION (tb->tb_path);	/*  index into the array of item headers in S[0] 
-							    of the affected item */
-    struct buffer_info bi;
-    struct buffer_head *S_new[2];  /* new nodes allocated to hold what could not fit into S */
-    int snum[2];	    /* number of items that will be placed
-                               into S_new (includes partially shifted
-                               items) */
-    int sbytes[2];          /* if an item is partially shifted into S_new then 
-			       if it is a directory item 
-			       it is the number of entries from the item that are shifted into S_new
-			       else
-			       it is the number of bytes from the item that are shifted into S_new
-			    */
-    int n, i;
-    int ret_val;
-    int pos_in_item;
-    int zeros_num;
-
-    PROC_INFO_INC( tb -> tb_sb, balance_at[ 0 ] );
-
-    /* Make balance in case insert_size[0] < 0 */
-    if ( tb->insert_size[0] < 0 )
-	return balance_leaf_when_delete (tb, flag);
-  
-    zeros_num = 0;
-    if (flag == M_INSERT && body == 0)
-	zeros_num = ih_item_len( ih );
-
-    pos_in_item = tb->tb_path->pos_in_item;
-    /* for indirect item pos_in_item is measured in unformatted node
-       pointers. Recalculate to bytes */
-    if (flag != M_INSERT && is_indirect_le_ih (B_N_PITEM_HEAD (tbS0, item_pos)))
-	pos_in_item *= UNFM_P_SIZE;
-
-    if ( tb->lnum[0] > 0 ) {
-	/* Shift lnum[0] items from S[0] to the left neighbor L[0] */
-	if ( item_pos < tb->lnum[0] ) {
-	    /* new item or it part falls to L[0], shift it too */
-	    n = B_NR_ITEMS(tb->L[0]);
-
-	    switch (flag) {
-	    case M_INSERT:   /* insert item into L[0] */
-
-		if ( item_pos == tb->lnum[0] - 1 && tb->lbytes != -1 ) {
-		    /* part of new item falls into L[0] */
-		    int new_item_len;
-		    int version;
-
-		    ret_val = leaf_shift_left (tb, tb->lnum[0]-1, -1);
-
-		    /* Calculate item length to insert to S[0] */
-		    new_item_len = ih_item_len(ih) - tb->lbytes;
-		    /* Calculate and check item length to insert to L[0] */
-		    put_ih_item_len(ih, ih_item_len(ih) - new_item_len );
-
-		    RFALSE( ih_item_len(ih) <= 0,
-			    "PAP-12080: there is nothing to insert into L[0]: ih_item_len=%d",
-                            ih_item_len(ih));
-
-		    /* Insert new item into L[0] */
-		    bi.tb = tb;
-		    bi.bi_bh = tb->L[0];
-		    bi.bi_parent = tb->FL[0];
-		    bi.bi_position = get_left_neighbor_position (tb, 0);
-		    leaf_insert_into_buf (&bi, n + item_pos - ret_val, ih, body,
-					  zeros_num > ih_item_len(ih) ? ih_item_len(ih) : zeros_num);
-
-		    version = ih_version (ih);
-
-		    /* Calculate key component, item length and body to insert into S[0] */
-                    set_le_ih_k_offset( ih, le_ih_k_offset( ih ) + (tb->lbytes << (is_indirect_le_ih(ih)?tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT:0)) );
-
-		    put_ih_item_len( ih, new_item_len );
-		    if ( tb->lbytes >  zeros_num ) {
-			body += (tb->lbytes - zeros_num);
-			zeros_num = 0;
-		    }
-		    else
-			zeros_num -= tb->lbytes;
-
-		    RFALSE( ih_item_len(ih) <= 0,
-			"PAP-12085: there is nothing to insert into S[0]: ih_item_len=%d",
-			ih_item_len(ih));
-		} else {
-		    /* new item in whole falls into L[0] */
-		    /* Shift lnum[0]-1 items to L[0] */
-		    ret_val = leaf_shift_left(tb, tb->lnum[0]-1, tb->lbytes);
-		    /* Insert new item into L[0] */
-		    bi.tb = tb;
-		    bi.bi_bh = tb->L[0];
-		    bi.bi_parent = tb->FL[0];
-		    bi.bi_position = get_left_neighbor_position (tb, 0);
-		    leaf_insert_into_buf (&bi, n + item_pos - ret_val, ih, body, zeros_num);
-		    tb->insert_size[0] = 0;
-		    zeros_num = 0;
-		}
-		break;
-
-	    case M_PASTE:   /* append item in L[0] */
-
-		if ( item_pos == tb->lnum[0] - 1 && tb->lbytes != -1 ) {
-		    /* we must shift the part of the appended item */
-		    if ( is_direntry_le_ih (B_N_PITEM_HEAD (tbS0, item_pos))) {
-
-			RFALSE( zeros_num,
-				"PAP-12090: invalid parameter in case of a directory");
-			/* directory item */
-			if ( tb->lbytes > pos_in_item ) {
-			    /* new directory entry falls into L[0] */
-			    struct item_head * pasted;
-			    int l_pos_in_item = pos_in_item;
-							  
-			    /* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 entries from given directory item */
-			    ret_val = leaf_shift_left(tb, tb->lnum[0], tb->lbytes - 1);
-			    if ( ret_val && ! item_pos ) {
-				pasted =  B_N_PITEM_HEAD(tb->L[0],B_NR_ITEMS(tb->L[0])-1);
-				l_pos_in_item += I_ENTRY_COUNT(pasted) - (tb->lbytes-1);
-			    }
-
-			    /* Append given directory entry to directory item */
-			    bi.tb = tb;
-			    bi.bi_bh = tb->L[0];
-			    bi.bi_parent = tb->FL[0];
-			    bi.bi_position = get_left_neighbor_position (tb, 0);
-			    leaf_paste_in_buffer (&bi, n + item_pos - ret_val, l_pos_in_item,
-						  tb->insert_size[0], body, zeros_num);
-
-			    /* previous string prepared space for pasting new entry, following string pastes this entry */
-
-			    /* when we have merge directory item, pos_in_item has been changed too */
-
-			    /* paste new directory entry. 1 is entry number */
-			    leaf_paste_entries (bi.bi_bh, n + item_pos - ret_val, l_pos_in_item, 1,
-						(struct reiserfs_de_head *)body, 
-						body + DEH_SIZE, tb->insert_size[0]
-				);
-			    tb->insert_size[0] = 0;
-			} else {
-			    /* new directory item doesn't fall into L[0] */
-			    /* Shift lnum[0]-1 items in whole. Shift lbytes directory entries from directory item number lnum[0] */
-			    leaf_shift_left (tb, tb->lnum[0], tb->lbytes);
-			}
-			/* Calculate new position to append in item body */
-			pos_in_item -= tb->lbytes;
-		    }
-		    else {
-			/* regular object */
-			RFALSE( tb->lbytes <= 0,
-			        "PAP-12095: there is nothing to shift to L[0]. lbytes=%d",
-				tb->lbytes);
-			RFALSE( pos_in_item != ih_item_len(B_N_PITEM_HEAD(tbS0, item_pos)),
-                                "PAP-12100: incorrect position to paste: item_len=%d, pos_in_item=%d",
-				ih_item_len(B_N_PITEM_HEAD(tbS0,item_pos)), pos_in_item);
-
-			if ( tb->lbytes >= pos_in_item ) {
-			    /* appended item will be in L[0] in whole */
-			    int l_n;
-
-			    /* this bytes number must be appended to the last item of L[h] */
-			    l_n = tb->lbytes - pos_in_item;
-
-			    /* Calculate new insert_size[0] */
-			    tb->insert_size[0] -= l_n;
-
-			    RFALSE( tb->insert_size[0] <= 0,
-				    "PAP-12105: there is nothing to paste into L[0]. insert_size=%d",
-				    tb->insert_size[0]);
-			    ret_val =  leaf_shift_left(tb,tb->lnum[0], 
-						       ih_item_len(B_N_PITEM_HEAD(tbS0,item_pos)));
-			    /* Append to body of item in L[0] */
-			    bi.tb = tb;
-			    bi.bi_bh = tb->L[0];
-			    bi.bi_parent = tb->FL[0];
-			    bi.bi_position = get_left_neighbor_position (tb, 0);
-			    leaf_paste_in_buffer(
-				&bi,n + item_pos - ret_val,
-				ih_item_len( B_N_PITEM_HEAD(tb->L[0],n+item_pos-ret_val)),
-				l_n,body, zeros_num > l_n ? l_n : zeros_num
-				);
-			    /* 0-th item in S0 can be only of DIRECT type when l_n != 0*/
-			    {
-				int version;
-				int temp_l = l_n;
-				
-				RFALSE (ih_item_len (B_N_PITEM_HEAD (tbS0, 0)),
-					"PAP-12106: item length must be 0");
-				RFALSE (comp_short_le_keys (B_N_PKEY (tbS0, 0),
-							    B_N_PKEY (tb->L[0],
-									    n + item_pos - ret_val)),
-					"PAP-12107: items must be of the same file");
-				if (is_indirect_le_ih(B_N_PITEM_HEAD (tb->L[0],
-								      n + item_pos - ret_val)))	{
-				    temp_l = l_n << (tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT);
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int item_pos = PATH_LAST_POSITION(tb->tb_path);	/*  index into the array of item headers in S[0] 
+							   of the affected item */
+	struct buffer_info bi;
+	struct buffer_head *S_new[2];	/* new nodes allocated to hold what could not fit into S */
+	int snum[2];		/* number of items that will be placed
+				   into S_new (includes partially shifted
+				   items) */
+	int sbytes[2];		/* if an item is partially shifted into S_new then 
+				   if it is a directory item 
+				   it is the number of entries from the item that are shifted into S_new
+				   else
+				   it is the number of bytes from the item that are shifted into S_new
+				 */
+	int n, i;
+	int ret_val;
+	int pos_in_item;
+	int zeros_num;
+
+	PROC_INFO_INC(tb->tb_sb, balance_at[0]);
+
+	/* Make balance in case insert_size[0] < 0 */
+	if (tb->insert_size[0] < 0)
+		return balance_leaf_when_delete(tb, flag);
+
+	zeros_num = 0;
+	if (flag == M_INSERT && body == 0)
+		zeros_num = ih_item_len(ih);
+
+	pos_in_item = tb->tb_path->pos_in_item;
+	/* for indirect item pos_in_item is measured in unformatted node
+	   pointers. Recalculate to bytes */
+	if (flag != M_INSERT
+	    && is_indirect_le_ih(B_N_PITEM_HEAD(tbS0, item_pos)))
+		pos_in_item *= UNFM_P_SIZE;
+
+	if (tb->lnum[0] > 0) {
+		/* Shift lnum[0] items from S[0] to the left neighbor L[0] */
+		if (item_pos < tb->lnum[0]) {
+			/* new item or it part falls to L[0], shift it too */
+			n = B_NR_ITEMS(tb->L[0]);
+
+			switch (flag) {
+			case M_INSERT:	/* insert item into L[0] */
+
+				if (item_pos == tb->lnum[0] - 1
+				    && tb->lbytes != -1) {
+					/* part of new item falls into L[0] */
+					int new_item_len;
+					int version;
+
+					ret_val =
+					    leaf_shift_left(tb, tb->lnum[0] - 1,
+							    -1);
+
+					/* Calculate item length to insert to S[0] */
+					new_item_len =
+					    ih_item_len(ih) - tb->lbytes;
+					/* Calculate and check item length to insert to L[0] */
+					put_ih_item_len(ih,
+							ih_item_len(ih) -
+							new_item_len);
+
+					RFALSE(ih_item_len(ih) <= 0,
+					       "PAP-12080: there is nothing to insert into L[0]: ih_item_len=%d",
+					       ih_item_len(ih));
+
+					/* Insert new item into L[0] */
+					bi.tb = tb;
+					bi.bi_bh = tb->L[0];
+					bi.bi_parent = tb->FL[0];
+					bi.bi_position =
+					    get_left_neighbor_position(tb, 0);
+					leaf_insert_into_buf(&bi,
+							     n + item_pos -
+							     ret_val, ih, body,
+							     zeros_num >
+							     ih_item_len(ih) ?
+							     ih_item_len(ih) :
+							     zeros_num);
+
+					version = ih_version(ih);
+
+					/* Calculate key component, item length and body to insert into S[0] */
+					set_le_ih_k_offset(ih,
+							   le_ih_k_offset(ih) +
+							   (tb->
+							    lbytes <<
+							    (is_indirect_le_ih
+							     (ih) ? tb->tb_sb->
+							     s_blocksize_bits -
+							     UNFM_P_SHIFT :
+							     0)));
+
+					put_ih_item_len(ih, new_item_len);
+					if (tb->lbytes > zeros_num) {
+						body +=
+						    (tb->lbytes - zeros_num);
+						zeros_num = 0;
+					} else
+						zeros_num -= tb->lbytes;
+
+					RFALSE(ih_item_len(ih) <= 0,
+					       "PAP-12085: there is nothing to insert into S[0]: ih_item_len=%d",
+					       ih_item_len(ih));
+				} else {
+					/* new item in whole falls into L[0] */
+					/* Shift lnum[0]-1 items to L[0] */
+					ret_val =
+					    leaf_shift_left(tb, tb->lnum[0] - 1,
+							    tb->lbytes);
+					/* Insert new item into L[0] */
+					bi.tb = tb;
+					bi.bi_bh = tb->L[0];
+					bi.bi_parent = tb->FL[0];
+					bi.bi_position =
+					    get_left_neighbor_position(tb, 0);
+					leaf_insert_into_buf(&bi,
+							     n + item_pos -
+							     ret_val, ih, body,
+							     zeros_num);
+					tb->insert_size[0] = 0;
+					zeros_num = 0;
 				}
-				/* update key of first item in S0 */
-				version = ih_version (B_N_PITEM_HEAD (tbS0, 0));
-				set_le_key_k_offset (version, B_N_PKEY (tbS0, 0), 
-						     le_key_k_offset (version, B_N_PKEY (tbS0, 0)) + temp_l);
-				/* update left delimiting key */
-				set_le_key_k_offset (version, B_N_PDELIM_KEY(tb->CFL[0],tb->lkey[0]),
-						     le_key_k_offset (version, B_N_PDELIM_KEY(tb->CFL[0],tb->lkey[0])) + temp_l);
-			    }
-
-			    /* Calculate new body, position in item and insert_size[0] */
-			    if ( l_n > zeros_num ) {
-				body += (l_n - zeros_num);
-				zeros_num = 0;
-			    }
-			    else
-				zeros_num -= l_n;
-			    pos_in_item = 0;	
-
-			    RFALSE( comp_short_le_keys 
-				    (B_N_PKEY(tbS0,0),
-				     B_N_PKEY(tb->L[0],B_NR_ITEMS(tb->L[0])-1)) ||
-				
-				    !op_is_left_mergeable 
-				    (B_N_PKEY (tbS0, 0), tbS0->b_size) ||
-				    !op_is_left_mergeable
-				    (B_N_PDELIM_KEY(tb->CFL[0],tb->lkey[0]), 
-				     tbS0->b_size),
-				    "PAP-12120: item must be merge-able with left neighboring item");
-			}
-			else /* only part of the appended item will be in L[0] */
-			{
-			    /* Calculate position in item for append in S[0] */
-			    pos_in_item -= tb->lbytes;
-
-			    RFALSE( pos_in_item <= 0,
-				    "PAP-12125: no place for paste. pos_in_item=%d", pos_in_item);
-
-			    /* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
-			    leaf_shift_left(tb,tb->lnum[0],tb->lbytes);
-			}
-		    }
-		}
-		else /* appended item will be in L[0] in whole */
-		{
-		    struct item_head * pasted;
-
-			if ( ! item_pos  && op_is_left_mergeable (B_N_PKEY (tbS0, 0), tbS0->b_size) )
-			{ /* if we paste into first item of S[0] and it is left mergable */
-			    /* then increment pos_in_item by the size of the last item in L[0] */
-			    pasted = B_N_PITEM_HEAD(tb->L[0],n-1);
-			    if ( is_direntry_le_ih (pasted) )
-				pos_in_item += ih_entry_count(pasted);
-			    else
-				pos_in_item += ih_item_len(pasted);
+				break;
+
+			case M_PASTE:	/* append item in L[0] */
+
+				if (item_pos == tb->lnum[0] - 1
+				    && tb->lbytes != -1) {
+					/* we must shift the part of the appended item */
+					if (is_direntry_le_ih
+					    (B_N_PITEM_HEAD(tbS0, item_pos))) {
+
+						RFALSE(zeros_num,
+						       "PAP-12090: invalid parameter in case of a directory");
+						/* directory item */
+						if (tb->lbytes > pos_in_item) {
+							/* new directory entry falls into L[0] */
+							struct item_head
+							    *pasted;
+							int l_pos_in_item =
+							    pos_in_item;
+
+							/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 entries from given directory item */
+							ret_val =
+							    leaf_shift_left(tb,
+									    tb->
+									    lnum
+									    [0],
+									    tb->
+									    lbytes
+									    -
+									    1);
+							if (ret_val
+							    && !item_pos) {
+								pasted =
+								    B_N_PITEM_HEAD
+								    (tb->L[0],
+								     B_NR_ITEMS
+								     (tb->
+								      L[0]) -
+								     1);
+								l_pos_in_item +=
+								    I_ENTRY_COUNT
+								    (pasted) -
+								    (tb->
+								     lbytes -
+								     1);
+							}
+
+							/* Append given directory entry to directory item */
+							bi.tb = tb;
+							bi.bi_bh = tb->L[0];
+							bi.bi_parent =
+							    tb->FL[0];
+							bi.bi_position =
+							    get_left_neighbor_position
+							    (tb, 0);
+							leaf_paste_in_buffer
+							    (&bi,
+							     n + item_pos -
+							     ret_val,
+							     l_pos_in_item,
+							     tb->insert_size[0],
+							     body, zeros_num);
+
+							/* previous string prepared space for pasting new entry, following string pastes this entry */
+
+							/* when we have merge directory item, pos_in_item has been changed too */
+
+							/* paste new directory entry. 1 is entry number */
+							leaf_paste_entries(bi.
+									   bi_bh,
+									   n +
+									   item_pos
+									   -
+									   ret_val,
+									   l_pos_in_item,
+									   1,
+									   (struct
+									    reiserfs_de_head
+									    *)
+									   body,
+									   body
+									   +
+									   DEH_SIZE,
+									   tb->
+									   insert_size
+									   [0]
+							    );
+							tb->insert_size[0] = 0;
+						} else {
+							/* new directory item doesn't fall into L[0] */
+							/* Shift lnum[0]-1 items in whole. Shift lbytes directory entries from directory item number lnum[0] */
+							leaf_shift_left(tb,
+									tb->
+									lnum[0],
+									tb->
+									lbytes);
+						}
+						/* Calculate new position to append in item body */
+						pos_in_item -= tb->lbytes;
+					} else {
+						/* regular object */
+						RFALSE(tb->lbytes <= 0,
+						       "PAP-12095: there is nothing to shift to L[0]. lbytes=%d",
+						       tb->lbytes);
+						RFALSE(pos_in_item !=
+						       ih_item_len
+						       (B_N_PITEM_HEAD
+							(tbS0, item_pos)),
+						       "PAP-12100: incorrect position to paste: item_len=%d, pos_in_item=%d",
+						       ih_item_len
+						       (B_N_PITEM_HEAD
+							(tbS0, item_pos)),
+						       pos_in_item);
+
+						if (tb->lbytes >= pos_in_item) {
+							/* appended item will be in L[0] in whole */
+							int l_n;
+
+							/* this bytes number must be appended to the last item of L[h] */
+							l_n =
+							    tb->lbytes -
+							    pos_in_item;
+
+							/* Calculate new insert_size[0] */
+							tb->insert_size[0] -=
+							    l_n;
+
+							RFALSE(tb->
+							       insert_size[0] <=
+							       0,
+							       "PAP-12105: there is nothing to paste into L[0]. insert_size=%d",
+							       tb->
+							       insert_size[0]);
+							ret_val =
+							    leaf_shift_left(tb,
+									    tb->
+									    lnum
+									    [0],
+									    ih_item_len
+									    (B_N_PITEM_HEAD
+									     (tbS0,
+									      item_pos)));
+							/* Append to body of item in L[0] */
+							bi.tb = tb;
+							bi.bi_bh = tb->L[0];
+							bi.bi_parent =
+							    tb->FL[0];
+							bi.bi_position =
+							    get_left_neighbor_position
+							    (tb, 0);
+							leaf_paste_in_buffer
+							    (&bi,
+							     n + item_pos -
+							     ret_val,
+							     ih_item_len
+							     (B_N_PITEM_HEAD
+							      (tb->L[0],
+							       n + item_pos -
+							       ret_val)), l_n,
+							     body,
+							     zeros_num >
+							     l_n ? l_n :
+							     zeros_num);
+							/* 0-th item in S0 can be only of DIRECT type when l_n != 0 */
+							{
+								int version;
+								int temp_l =
+								    l_n;
+
+								RFALSE
+								    (ih_item_len
+								     (B_N_PITEM_HEAD
+								      (tbS0,
+								       0)),
+								     "PAP-12106: item length must be 0");
+								RFALSE
+								    (comp_short_le_keys
+								     (B_N_PKEY
+								      (tbS0, 0),
+								      B_N_PKEY
+								      (tb->L[0],
+								       n +
+								       item_pos
+								       -
+								       ret_val)),
+								     "PAP-12107: items must be of the same file");
+								if (is_indirect_le_ih(B_N_PITEM_HEAD(tb->L[0], n + item_pos - ret_val))) {
+									temp_l =
+									    l_n
+									    <<
+									    (tb->
+									     tb_sb->
+									     s_blocksize_bits
+									     -
+									     UNFM_P_SHIFT);
+								}
+								/* update key of first item in S0 */
+								version =
+								    ih_version
+								    (B_N_PITEM_HEAD
+								     (tbS0, 0));
+								set_le_key_k_offset
+								    (version,
+								     B_N_PKEY
+								     (tbS0, 0),
+								     le_key_k_offset
+								     (version,
+								      B_N_PKEY
+								      (tbS0,
+								       0)) +
+								     temp_l);
+								/* update left delimiting key */
+								set_le_key_k_offset
+								    (version,
+								     B_N_PDELIM_KEY
+								     (tb->
+								      CFL[0],
+								      tb->
+								      lkey[0]),
+								     le_key_k_offset
+								     (version,
+								      B_N_PDELIM_KEY
+								      (tb->
+								       CFL[0],
+								       tb->
+								       lkey[0]))
+								     + temp_l);
+							}
+
+							/* Calculate new body, position in item and insert_size[0] */
+							if (l_n > zeros_num) {
+								body +=
+								    (l_n -
+								     zeros_num);
+								zeros_num = 0;
+							} else
+								zeros_num -=
+								    l_n;
+							pos_in_item = 0;
+
+							RFALSE
+							    (comp_short_le_keys
+							     (B_N_PKEY(tbS0, 0),
+							      B_N_PKEY(tb->L[0],
+								       B_NR_ITEMS
+								       (tb->
+									L[0]) -
+								       1))
+							     ||
+							     !op_is_left_mergeable
+							     (B_N_PKEY(tbS0, 0),
+							      tbS0->b_size)
+							     ||
+							     !op_is_left_mergeable
+							     (B_N_PDELIM_KEY
+							      (tb->CFL[0],
+							       tb->lkey[0]),
+							      tbS0->b_size),
+							     "PAP-12120: item must be merge-able with left neighboring item");
+						} else {	/* only part of the appended item will be in L[0] */
+
+							/* Calculate position in item for append in S[0] */
+							pos_in_item -=
+							    tb->lbytes;
+
+							RFALSE(pos_in_item <= 0,
+							       "PAP-12125: no place for paste. pos_in_item=%d",
+							       pos_in_item);
+
+							/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
+							leaf_shift_left(tb,
+									tb->
+									lnum[0],
+									tb->
+									lbytes);
+						}
+					}
+				} else {	/* appended item will be in L[0] in whole */
+
+					struct item_head *pasted;
+
+					if (!item_pos && op_is_left_mergeable(B_N_PKEY(tbS0, 0), tbS0->b_size)) {	/* if we paste into first item of S[0] and it is left mergable */
+						/* then increment pos_in_item by the size of the last item in L[0] */
+						pasted =
+						    B_N_PITEM_HEAD(tb->L[0],
+								   n - 1);
+						if (is_direntry_le_ih(pasted))
+							pos_in_item +=
+							    ih_entry_count
+							    (pasted);
+						else
+							pos_in_item +=
+							    ih_item_len(pasted);
+					}
+
+					/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
+					ret_val =
+					    leaf_shift_left(tb, tb->lnum[0],
+							    tb->lbytes);
+					/* Append to body of item in L[0] */
+					bi.tb = tb;
+					bi.bi_bh = tb->L[0];
+					bi.bi_parent = tb->FL[0];
+					bi.bi_position =
+					    get_left_neighbor_position(tb, 0);
+					leaf_paste_in_buffer(&bi,
+							     n + item_pos -
+							     ret_val,
+							     pos_in_item,
+							     tb->insert_size[0],
+							     body, zeros_num);
+
+					/* if appended item is directory, paste entry */
+					pasted =
+					    B_N_PITEM_HEAD(tb->L[0],
+							   n + item_pos -
+							   ret_val);
+					if (is_direntry_le_ih(pasted))
+						leaf_paste_entries(bi.bi_bh,
+								   n +
+								   item_pos -
+								   ret_val,
+								   pos_in_item,
+								   1,
+								   (struct
+								    reiserfs_de_head
+								    *)body,
+								   body +
+								   DEH_SIZE,
+								   tb->
+								   insert_size
+								   [0]
+						    );
+					/* if appended item is indirect item, put unformatted node into un list */
+					if (is_indirect_le_ih(pasted))
+						set_ih_free_space(pasted, 0);
+					tb->insert_size[0] = 0;
+					zeros_num = 0;
+				}
+				break;
+			default:	/* cases d and t */
+				reiserfs_panic(tb->tb_sb,
+					       "PAP-12130: balance_leaf: lnum > 0: unexpectable mode: %s(%d)",
+					       (flag ==
+						M_DELETE) ? "DELETE" : ((flag ==
+									 M_CUT)
+									? "CUT"
+									:
+									"UNKNOWN"),
+					       flag);
 			}
-
-		    /* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
-		    ret_val = leaf_shift_left(tb,tb->lnum[0],tb->lbytes);
-		    /* Append to body of item in L[0] */
-		    bi.tb = tb;
-		    bi.bi_bh = tb->L[0];
-		    bi.bi_parent = tb->FL[0];
-		    bi.bi_position = get_left_neighbor_position (tb, 0);
-		    leaf_paste_in_buffer (&bi, n + item_pos - ret_val, pos_in_item, tb->insert_size[0],
-					  body, zeros_num);
-
-		    /* if appended item is directory, paste entry */
-		    pasted = B_N_PITEM_HEAD (tb->L[0], n + item_pos - ret_val);
-		    if (is_direntry_le_ih (pasted))
-			leaf_paste_entries (
-			    bi.bi_bh, n + item_pos - ret_val, pos_in_item, 1, 
-			    (struct reiserfs_de_head *)body, body + DEH_SIZE, tb->insert_size[0]
-			    );
-		    /* if appended item is indirect item, put unformatted node into un list */
-		    if (is_indirect_le_ih (pasted))
-			set_ih_free_space (pasted, 0);
-		    tb->insert_size[0] = 0;
-		    zeros_num = 0;
+		} else {
+			/* new item doesn't fall into L[0] */
+			leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
 		}
-		break;
-	    default:    /* cases d and t */
-		reiserfs_panic (tb->tb_sb, "PAP-12130: balance_leaf: lnum > 0: unexpectable mode: %s(%d)",
-				(flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
-	    }
-	} else { 
-	    /* new item doesn't fall into L[0] */
-	    leaf_shift_left(tb,tb->lnum[0],tb->lbytes);
 	}
-    }	/* tb->lnum[0] > 0 */
 
-    /* Calculate new item position */
-    item_pos -= ( tb->lnum[0] - (( tb->lbytes != -1 ) ? 1 : 0));
-
-    if ( tb->rnum[0] > 0 ) {
-	/* shift rnum[0] items from S[0] to the right neighbor R[0] */
-	n = B_NR_ITEMS(tbS0);
-	switch ( flag ) {
-
-	case M_INSERT:   /* insert item */
-	    if ( n - tb->rnum[0] < item_pos )
-	    { /* new item or its part falls to R[0] */
-		if ( item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1 )
-		{ /* part of new item falls into R[0] */
-		    loff_t old_key_comp, old_len, r_zeros_number;
-		    const char * r_body;
-		    int version;
-		    loff_t offset;
-
-		    leaf_shift_right(tb,tb->rnum[0]-1,-1);
-
-		    version = ih_version(ih);
-		    /* Remember key component and item length */
-                    old_key_comp = le_ih_k_offset( ih );
-		    old_len = ih_item_len(ih);
-
-		    /* Calculate key component and item length to insert into R[0] */
-                    offset = le_ih_k_offset( ih ) + ((old_len - tb->rbytes )<<(is_indirect_le_ih(ih)?tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT:0));
-                    set_le_ih_k_offset( ih, offset );
-		    put_ih_item_len( ih, tb->rbytes);
-		    /* Insert part of the item into R[0] */
-		    bi.tb = tb;
-		    bi.bi_bh = tb->R[0];
-		    bi.bi_parent = tb->FR[0];
-		    bi.bi_position = get_right_neighbor_position (tb, 0);
-		    if ( (old_len - tb->rbytes) > zeros_num ) {
-			r_zeros_number = 0;
-			r_body = body + (old_len - tb->rbytes) - zeros_num;
-		    }
-		    else {
-			r_body = body;
-			r_zeros_number = zeros_num - (old_len - tb->rbytes);
-			zeros_num -= r_zeros_number;
-		    }
-
-		    leaf_insert_into_buf (&bi, 0, ih, r_body, r_zeros_number);
-
-		    /* Replace right delimiting key by first key in R[0] */
-		    replace_key(tb, tb->CFR[0],tb->rkey[0],tb->R[0],0);
-
-		    /* Calculate key component and item length to insert into S[0] */
-                    set_le_ih_k_offset( ih, old_key_comp );
-		    put_ih_item_len( ih, old_len - tb->rbytes );
-
-		    tb->insert_size[0] -= tb->rbytes;
+	/* tb->lnum[0] > 0 */
+	/* Calculate new item position */
+	item_pos -= (tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0));
+
+	if (tb->rnum[0] > 0) {
+		/* shift rnum[0] items from S[0] to the right neighbor R[0] */
+		n = B_NR_ITEMS(tbS0);
+		switch (flag) {
+
+		case M_INSERT:	/* insert item */
+			if (n - tb->rnum[0] < item_pos) {	/* new item or its part falls to R[0] */
+				if (item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1) {	/* part of new item falls into R[0] */
+					loff_t old_key_comp, old_len,
+					    r_zeros_number;
+					const char *r_body;
+					int version;
+					loff_t offset;
+
+					leaf_shift_right(tb, tb->rnum[0] - 1,
+							 -1);
+
+					version = ih_version(ih);
+					/* Remember key component and item length */
+					old_key_comp = le_ih_k_offset(ih);
+					old_len = ih_item_len(ih);
+
+					/* Calculate key component and item length to insert into R[0] */
+					offset =
+					    le_ih_k_offset(ih) +
+					    ((old_len -
+					      tb->
+					      rbytes) << (is_indirect_le_ih(ih)
+							  ? tb->tb_sb->
+							  s_blocksize_bits -
+							  UNFM_P_SHIFT : 0));
+					set_le_ih_k_offset(ih, offset);
+					put_ih_item_len(ih, tb->rbytes);
+					/* Insert part of the item into R[0] */
+					bi.tb = tb;
+					bi.bi_bh = tb->R[0];
+					bi.bi_parent = tb->FR[0];
+					bi.bi_position =
+					    get_right_neighbor_position(tb, 0);
+					if ((old_len - tb->rbytes) > zeros_num) {
+						r_zeros_number = 0;
+						r_body =
+						    body + (old_len -
+							    tb->rbytes) -
+						    zeros_num;
+					} else {
+						r_body = body;
+						r_zeros_number =
+						    zeros_num - (old_len -
+								 tb->rbytes);
+						zeros_num -= r_zeros_number;
+					}
+
+					leaf_insert_into_buf(&bi, 0, ih, r_body,
+							     r_zeros_number);
+
+					/* Replace right delimiting key by first key in R[0] */
+					replace_key(tb, tb->CFR[0], tb->rkey[0],
+						    tb->R[0], 0);
+
+					/* Calculate key component and item length to insert into S[0] */
+					set_le_ih_k_offset(ih, old_key_comp);
+					put_ih_item_len(ih,
+							old_len - tb->rbytes);
+
+					tb->insert_size[0] -= tb->rbytes;
+
+				} else {	/* whole new item falls into R[0] */
+
+					/* Shift rnum[0]-1 items to R[0] */
+					ret_val =
+					    leaf_shift_right(tb,
+							     tb->rnum[0] - 1,
+							     tb->rbytes);
+					/* Insert new item into R[0] */
+					bi.tb = tb;
+					bi.bi_bh = tb->R[0];
+					bi.bi_parent = tb->FR[0];
+					bi.bi_position =
+					    get_right_neighbor_position(tb, 0);
+					leaf_insert_into_buf(&bi,
+							     item_pos - n +
+							     tb->rnum[0] - 1,
+							     ih, body,
+							     zeros_num);
+
+					if (item_pos - n + tb->rnum[0] - 1 == 0) {
+						replace_key(tb, tb->CFR[0],
+							    tb->rkey[0],
+							    tb->R[0], 0);
+
+					}
+					zeros_num = tb->insert_size[0] = 0;
+				}
+			} else {	/* new item or part of it doesn't fall into R[0] */
 
-		}
-		else /* whole new item falls into R[0] */
-		{					  
-		    /* Shift rnum[0]-1 items to R[0] */
-		    ret_val = leaf_shift_right(tb,tb->rnum[0]-1,tb->rbytes);
-		    /* Insert new item into R[0] */
-		    bi.tb = tb;
-		    bi.bi_bh = tb->R[0];
-		    bi.bi_parent = tb->FR[0];
-		    bi.bi_position = get_right_neighbor_position (tb, 0);
-		    leaf_insert_into_buf (&bi, item_pos - n + tb->rnum[0] - 1, ih, body, zeros_num);
-
-		    if ( item_pos - n + tb->rnum[0] - 1 == 0 ) {
-			replace_key(tb, tb->CFR[0],tb->rkey[0],tb->R[0],0);
-
-		    }
-		    zeros_num = tb->insert_size[0] = 0;
-		}
-	    }
-	    else /* new item or part of it doesn't fall into R[0] */
-	    {
-		leaf_shift_right(tb,tb->rnum[0],tb->rbytes);
-	    }
-	    break;
-
-	case M_PASTE:   /* append item */
-
-	    if ( n - tb->rnum[0] <= item_pos )  /* pasted item or part of it falls to R[0] */
-	    {
-		if ( item_pos == n - tb->rnum[0] && tb->rbytes != -1 )
-		{ /* we must shift the part of the appended item */
-		    if ( is_direntry_le_ih (B_N_PITEM_HEAD(tbS0, item_pos)))
-		    { /* we append to directory item */
-			int entry_count;
-
-			RFALSE( zeros_num,
-				"PAP-12145: invalid parameter in case of a directory");
-			entry_count = I_ENTRY_COUNT(B_N_PITEM_HEAD(tbS0, item_pos));
-			if ( entry_count - tb->rbytes < pos_in_item )
-			    /* new directory entry falls into R[0] */
-			{
-			    int paste_entry_position;
-
-			    RFALSE( tb->rbytes - 1 >= entry_count || 
-				    ! tb->insert_size[0],
-				    "PAP-12150: no enough of entries to shift to R[0]: rbytes=%d, entry_count=%d",
-				    tb->rbytes, entry_count);
-			    /* Shift rnum[0]-1 items in whole. Shift rbytes-1 directory entries from directory item number rnum[0] */
-			    leaf_shift_right(tb,tb->rnum[0],tb->rbytes - 1);
-			    /* Paste given directory entry to directory item */
-			    paste_entry_position = pos_in_item - entry_count + tb->rbytes - 1;
-			    bi.tb = tb;
-			    bi.bi_bh = tb->R[0];
-			    bi.bi_parent = tb->FR[0];
-			    bi.bi_position = get_right_neighbor_position (tb, 0);
-			    leaf_paste_in_buffer (&bi, 0, paste_entry_position,
-						  tb->insert_size[0],body,zeros_num);
-			    /* paste entry */
-			    leaf_paste_entries (
-				bi.bi_bh, 0, paste_entry_position, 1, (struct reiserfs_de_head *)body, 
-				body + DEH_SIZE, tb->insert_size[0]
-				);								
-						
-			    if ( paste_entry_position == 0 ) {
-				/* change delimiting keys */
-				replace_key(tb, tb->CFR[0],tb->rkey[0],tb->R[0],0);
-			    }
-
-			    tb->insert_size[0] = 0;
-			    pos_in_item++;
-			}
-			else /* new directory entry doesn't fall into R[0] */
-			{
-			    leaf_shift_right(tb,tb->rnum[0],tb->rbytes);
-			}
-		    }
-		    else /* regular object */
-		    {
-			int n_shift, n_rem, r_zeros_number;
-			const char * r_body;
-
-			/* Calculate number of bytes which must be shifted from appended item */
-			if ( (n_shift = tb->rbytes - tb->insert_size[0]) < 0 )
-			    n_shift = 0;
-
-			RFALSE(pos_in_item != ih_item_len(B_N_PITEM_HEAD (tbS0, item_pos)),
-			       "PAP-12155: invalid position to paste. ih_item_len=%d, pos_in_item=%d",
-                               pos_in_item, ih_item_len( B_N_PITEM_HEAD(tbS0,item_pos)));
-
-			leaf_shift_right(tb,tb->rnum[0],n_shift);
-			/* Calculate number of bytes which must remain in body after appending to R[0] */
-			if ( (n_rem = tb->insert_size[0] - tb->rbytes) < 0 )
-			    n_rem = 0;
-			
-			{
-			  int version;
-			  unsigned long temp_rem = n_rem;
-			  
-			  version = ih_version (B_N_PITEM_HEAD (tb->R[0],0));
-			  if (is_indirect_le_key(version,B_N_PKEY(tb->R[0],0))){
-			      temp_rem = n_rem << (tb->tb_sb->s_blocksize_bits -
-					 UNFM_P_SHIFT);
-			  }
-			  set_le_key_k_offset (version, B_N_PKEY(tb->R[0],0), 
-					       le_key_k_offset (version, B_N_PKEY(tb->R[0],0)) + temp_rem);
-			  set_le_key_k_offset (version, B_N_PDELIM_KEY(tb->CFR[0],tb->rkey[0]), 
-					       le_key_k_offset (version, B_N_PDELIM_KEY(tb->CFR[0],tb->rkey[0])) + temp_rem);
+				leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
 			}
+			break;
+
+		case M_PASTE:	/* append item */
+
+			if (n - tb->rnum[0] <= item_pos) {	/* pasted item or part of it falls to R[0] */
+				if (item_pos == n - tb->rnum[0] && tb->rbytes != -1) {	/* we must shift the part of the appended item */
+					if (is_direntry_le_ih(B_N_PITEM_HEAD(tbS0, item_pos))) {	/* we append to directory item */
+						int entry_count;
+
+						RFALSE(zeros_num,
+						       "PAP-12145: invalid parameter in case of a directory");
+						entry_count =
+						    I_ENTRY_COUNT(B_N_PITEM_HEAD
+								  (tbS0,
+								   item_pos));
+						if (entry_count - tb->rbytes <
+						    pos_in_item)
+							/* new directory entry falls into R[0] */
+						{
+							int paste_entry_position;
+
+							RFALSE(tb->rbytes - 1 >=
+							       entry_count
+							       || !tb->
+							       insert_size[0],
+							       "PAP-12150: no enough of entries to shift to R[0]: rbytes=%d, entry_count=%d",
+							       tb->rbytes,
+							       entry_count);
+							/* Shift rnum[0]-1 items in whole. Shift rbytes-1 directory entries from directory item number rnum[0] */
+							leaf_shift_right(tb,
+									 tb->
+									 rnum
+									 [0],
+									 tb->
+									 rbytes
+									 - 1);
+							/* Paste given directory entry to directory item */
+							paste_entry_position =
+							    pos_in_item -
+							    entry_count +
+							    tb->rbytes - 1;
+							bi.tb = tb;
+							bi.bi_bh = tb->R[0];
+							bi.bi_parent =
+							    tb->FR[0];
+							bi.bi_position =
+							    get_right_neighbor_position
+							    (tb, 0);
+							leaf_paste_in_buffer
+							    (&bi, 0,
+							     paste_entry_position,
+							     tb->insert_size[0],
+							     body, zeros_num);
+							/* paste entry */
+							leaf_paste_entries(bi.
+									   bi_bh,
+									   0,
+									   paste_entry_position,
+									   1,
+									   (struct
+									    reiserfs_de_head
+									    *)
+									   body,
+									   body
+									   +
+									   DEH_SIZE,
+									   tb->
+									   insert_size
+									   [0]
+							    );
+
+							if (paste_entry_position
+							    == 0) {
+								/* change delimiting keys */
+								replace_key(tb,
+									    tb->
+									    CFR
+									    [0],
+									    tb->
+									    rkey
+									    [0],
+									    tb->
+									    R
+									    [0],
+									    0);
+							}
+
+							tb->insert_size[0] = 0;
+							pos_in_item++;
+						} else {	/* new directory entry doesn't fall into R[0] */
+
+							leaf_shift_right(tb,
+									 tb->
+									 rnum
+									 [0],
+									 tb->
+									 rbytes);
+						}
+					} else {	/* regular object */
+
+						int n_shift, n_rem,
+						    r_zeros_number;
+						const char *r_body;
+
+						/* Calculate number of bytes which must be shifted from appended item */
+						if ((n_shift =
+						     tb->rbytes -
+						     tb->insert_size[0]) < 0)
+							n_shift = 0;
+
+						RFALSE(pos_in_item !=
+						       ih_item_len
+						       (B_N_PITEM_HEAD
+							(tbS0, item_pos)),
+						       "PAP-12155: invalid position to paste. ih_item_len=%d, pos_in_item=%d",
+						       pos_in_item,
+						       ih_item_len
+						       (B_N_PITEM_HEAD
+							(tbS0, item_pos)));
+
+						leaf_shift_right(tb,
+								 tb->rnum[0],
+								 n_shift);
+						/* Calculate number of bytes which must remain in body after appending to R[0] */
+						if ((n_rem =
+						     tb->insert_size[0] -
+						     tb->rbytes) < 0)
+							n_rem = 0;
+
+						{
+							int version;
+							unsigned long temp_rem =
+							    n_rem;
+
+							version =
+							    ih_version
+							    (B_N_PITEM_HEAD
+							     (tb->R[0], 0));
+							if (is_indirect_le_key
+							    (version,
+							     B_N_PKEY(tb->R[0],
+								      0))) {
+								temp_rem =
+								    n_rem <<
+								    (tb->tb_sb->
+								     s_blocksize_bits
+								     -
+								     UNFM_P_SHIFT);
+							}
+							set_le_key_k_offset
+							    (version,
+							     B_N_PKEY(tb->R[0],
+								      0),
+							     le_key_k_offset
+							     (version,
+							      B_N_PKEY(tb->R[0],
+								       0)) +
+							     temp_rem);
+							set_le_key_k_offset
+							    (version,
+							     B_N_PDELIM_KEY(tb->
+									    CFR
+									    [0],
+									    tb->
+									    rkey
+									    [0]),
+							     le_key_k_offset
+							     (version,
+							      B_N_PDELIM_KEY
+							      (tb->CFR[0],
+							       tb->rkey[0])) +
+							     temp_rem);
+						}
 /*		  k_offset (B_N_PKEY(tb->R[0],0)) += n_rem;
 		  k_offset (B_N_PDELIM_KEY(tb->CFR[0],tb->rkey[0])) += n_rem;*/
-			do_balance_mark_internal_dirty (tb, tb->CFR[0], 0);
-
-			/* Append part of body into R[0] */
-			bi.tb = tb;
-			bi.bi_bh = tb->R[0];
-			bi.bi_parent = tb->FR[0];
-			bi.bi_position = get_right_neighbor_position (tb, 0);
-			if ( n_rem > zeros_num ) {
-			    r_zeros_number = 0;
-			    r_body = body + n_rem - zeros_num;
-			}
-			else {
-			    r_body = body;
-			    r_zeros_number = zeros_num - n_rem;
-			    zeros_num -= r_zeros_number;
-			}
-
-			leaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem, r_body, r_zeros_number);
-
-			if (is_indirect_le_ih (B_N_PITEM_HEAD(tb->R[0],0))) {
+						do_balance_mark_internal_dirty
+						    (tb, tb->CFR[0], 0);
+
+						/* Append part of body into R[0] */
+						bi.tb = tb;
+						bi.bi_bh = tb->R[0];
+						bi.bi_parent = tb->FR[0];
+						bi.bi_position =
+						    get_right_neighbor_position
+						    (tb, 0);
+						if (n_rem > zeros_num) {
+							r_zeros_number = 0;
+							r_body =
+							    body + n_rem -
+							    zeros_num;
+						} else {
+							r_body = body;
+							r_zeros_number =
+							    zeros_num - n_rem;
+							zeros_num -=
+							    r_zeros_number;
+						}
+
+						leaf_paste_in_buffer(&bi, 0,
+								     n_shift,
+								     tb->
+								     insert_size
+								     [0] -
+								     n_rem,
+								     r_body,
+								     r_zeros_number);
+
+						if (is_indirect_le_ih
+						    (B_N_PITEM_HEAD
+						     (tb->R[0], 0))) {
 #if 0
-			    RFALSE( n_rem,
-				    "PAP-12160: paste more than one unformatted node pointer");
+							RFALSE(n_rem,
+							       "PAP-12160: paste more than one unformatted node pointer");
 #endif
-			    set_ih_free_space (B_N_PITEM_HEAD(tb->R[0],0), 0);
-			}
-			tb->insert_size[0] = n_rem;
-			if ( ! n_rem )
-			    pos_in_item ++;
-		    }
-		}
-		else /* pasted item in whole falls into R[0] */
-		{
-		    struct item_head * pasted;
+							set_ih_free_space
+							    (B_N_PITEM_HEAD
+							     (tb->R[0], 0), 0);
+						}
+						tb->insert_size[0] = n_rem;
+						if (!n_rem)
+							pos_in_item++;
+					}
+				} else {	/* pasted item in whole falls into R[0] */
+
+					struct item_head *pasted;
+
+					ret_val =
+					    leaf_shift_right(tb, tb->rnum[0],
+							     tb->rbytes);
+					/* append item in R[0] */
+					if (pos_in_item >= 0) {
+						bi.tb = tb;
+						bi.bi_bh = tb->R[0];
+						bi.bi_parent = tb->FR[0];
+						bi.bi_position =
+						    get_right_neighbor_position
+						    (tb, 0);
+						leaf_paste_in_buffer(&bi,
+								     item_pos -
+								     n +
+								     tb->
+								     rnum[0],
+								     pos_in_item,
+								     tb->
+								     insert_size
+								     [0], body,
+								     zeros_num);
+					}
+
+					/* paste new entry, if item is directory item */
+					pasted =
+					    B_N_PITEM_HEAD(tb->R[0],
+							   item_pos - n +
+							   tb->rnum[0]);
+					if (is_direntry_le_ih(pasted)
+					    && pos_in_item >= 0) {
+						leaf_paste_entries(bi.bi_bh,
+								   item_pos -
+								   n +
+								   tb->rnum[0],
+								   pos_in_item,
+								   1,
+								   (struct
+								    reiserfs_de_head
+								    *)body,
+								   body +
+								   DEH_SIZE,
+								   tb->
+								   insert_size
+								   [0]
+						    );
+						if (!pos_in_item) {
+
+							RFALSE(item_pos - n +
+							       tb->rnum[0],
+							       "PAP-12165: directory item must be first item of node when pasting is in 0th position");
+
+							/* update delimiting keys */
+							replace_key(tb,
+								    tb->CFR[0],
+								    tb->rkey[0],
+								    tb->R[0],
+								    0);
+						}
+					}
+
+					if (is_indirect_le_ih(pasted))
+						set_ih_free_space(pasted, 0);
+					zeros_num = tb->insert_size[0] = 0;
+				}
+			} else {	/* new item doesn't fall into R[0] */
 
-		    ret_val = leaf_shift_right(tb,tb->rnum[0],tb->rbytes);
-		    /* append item in R[0] */
-		    if ( pos_in_item >= 0 ) {
-			bi.tb = tb;
-			bi.bi_bh = tb->R[0];
-			bi.bi_parent = tb->FR[0];
-			bi.bi_position = get_right_neighbor_position (tb, 0);
-			leaf_paste_in_buffer(&bi,item_pos - n + tb->rnum[0], pos_in_item,
-					     tb->insert_size[0],body, zeros_num);
-		    }
-
-		    /* paste new entry, if item is directory item */
-		    pasted = B_N_PITEM_HEAD(tb->R[0], item_pos - n + tb->rnum[0]);
-		    if (is_direntry_le_ih (pasted) && pos_in_item >= 0 ) {
-			leaf_paste_entries (
-			    bi.bi_bh, item_pos - n + tb->rnum[0], pos_in_item, 1, 
-			    (struct reiserfs_de_head *)body, body + DEH_SIZE, tb->insert_size[0]
-			    );
-			if ( ! pos_in_item ) {
-
-			    RFALSE( item_pos - n + tb->rnum[0],
-				    "PAP-12165: directory item must be first item of node when pasting is in 0th position");
-
-			    /* update delimiting keys */
-			    replace_key(tb, tb->CFR[0],tb->rkey[0],tb->R[0],0);
+				leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
 			}
-		    }
-
-		    if (is_indirect_le_ih (pasted))
-			set_ih_free_space (pasted, 0);
-		    zeros_num = tb->insert_size[0] = 0;
+			break;
+		default:	/* cases d and t */
+			reiserfs_panic(tb->tb_sb,
+				       "PAP-12175: balance_leaf: rnum > 0: unexpectable mode: %s(%d)",
+				       (flag ==
+					M_DELETE) ? "DELETE" : ((flag ==
+								 M_CUT) ? "CUT"
+								: "UNKNOWN"),
+				       flag);
 		}
-	    }
-	    else /* new item doesn't fall into R[0] */
-	    {
-		leaf_shift_right(tb,tb->rnum[0],tb->rbytes);
-	    }
-	    break;
-	default:    /* cases d and t */
-	    reiserfs_panic (tb->tb_sb, "PAP-12175: balance_leaf: rnum > 0: unexpectable mode: %s(%d)",
-			    (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
-	}
-    
-    }	/* tb->rnum[0] > 0 */
-
-
-    RFALSE( tb->blknum[0] > 3,
-	    "PAP-12180: blknum can not be %d. It must be <= 3",  tb->blknum[0]);
-    RFALSE( tb->blknum[0] < 0,
-	    "PAP-12185: blknum can not be %d. It must be >= 0",  tb->blknum[0]);
-
-    /* if while adding to a node we discover that it is possible to split
-       it in two, and merge the left part into the left neighbor and the
-       right part into the right neighbor, eliminating the node */
-    if ( tb->blknum[0] == 0 ) { /* node S[0] is empty now */
-
-	RFALSE( ! tb->lnum[0] || ! tb->rnum[0],
-	        "PAP-12190: lnum and rnum must not be zero");
-	/* if insertion was done before 0-th position in R[0], right
-	   delimiting key of the tb->L[0]'s and left delimiting key are
-	   not set correctly */
-	if (tb->CFL[0]) {
-	    if (!tb->CFR[0])
-		reiserfs_panic (tb->tb_sb, "vs-12195: balance_leaf: CFR not initialized");
-	    copy_key (B_N_PDELIM_KEY (tb->CFL[0], tb->lkey[0]), B_N_PDELIM_KEY (tb->CFR[0], tb->rkey[0]));
-	    do_balance_mark_internal_dirty (tb, tb->CFL[0], 0);
-	}
-
-	reiserfs_invalidate_buffer(tb,tbS0);									
-	return 0;
-    }
-
-
-    /* Fill new nodes that appear in place of S[0] */
 
-    /* I am told that this copying is because we need an array to enable
-       the looping code. -Hans */
-    snum[0] = tb->s1num,
-	snum[1] = tb->s2num;
-    sbytes[0] = tb->s1bytes;
-    sbytes[1] = tb->s2bytes;
-    for( i = tb->blknum[0] - 2; i >= 0; i-- ) {
-
-	RFALSE( !snum[i], "PAP-12200: snum[%d] == %d. Must be > 0", i, snum[i]);
+	}
 
-	/* here we shift from S to S_new nodes */
+	/* tb->rnum[0] > 0 */
+	RFALSE(tb->blknum[0] > 3,
+	       "PAP-12180: blknum can not be %d. It must be <= 3",
+	       tb->blknum[0]);
+	RFALSE(tb->blknum[0] < 0,
+	       "PAP-12185: blknum can not be %d. It must be >= 0",
+	       tb->blknum[0]);
+
+	/* if while adding to a node we discover that it is possible to split
+	   it in two, and merge the left part into the left neighbor and the
+	   right part into the right neighbor, eliminating the node */
+	if (tb->blknum[0] == 0) {	/* node S[0] is empty now */
+
+		RFALSE(!tb->lnum[0] || !tb->rnum[0],
+		       "PAP-12190: lnum and rnum must not be zero");
+		/* if insertion was done before 0-th position in R[0], right
+		   delimiting key of the tb->L[0]'s and left delimiting key are
+		   not set correctly */
+		if (tb->CFL[0]) {
+			if (!tb->CFR[0])
+				reiserfs_panic(tb->tb_sb,
+					       "vs-12195: balance_leaf: CFR not initialized");
+			copy_key(B_N_PDELIM_KEY(tb->CFL[0], tb->lkey[0]),
+				 B_N_PDELIM_KEY(tb->CFR[0], tb->rkey[0]));
+			do_balance_mark_internal_dirty(tb, tb->CFL[0], 0);
+		}
 
-	S_new[i] = get_FEB(tb);
+		reiserfs_invalidate_buffer(tb, tbS0);
+		return 0;
+	}
 
-	/* initialized block type and tree level */
-        set_blkh_level( B_BLK_HEAD(S_new[i]), DISK_LEAF_NODE_LEVEL );
+	/* Fill new nodes that appear in place of S[0] */
+
+	/* I am told that this copying is because we need an array to enable
+	   the looping code. -Hans */
+	snum[0] = tb->s1num, snum[1] = tb->s2num;
+	sbytes[0] = tb->s1bytes;
+	sbytes[1] = tb->s2bytes;
+	for (i = tb->blknum[0] - 2; i >= 0; i--) {
+
+		RFALSE(!snum[i], "PAP-12200: snum[%d] == %d. Must be > 0", i,
+		       snum[i]);
+
+		/* here we shift from S to S_new nodes */
+
+		S_new[i] = get_FEB(tb);
+
+		/* initialized block type and tree level */
+		set_blkh_level(B_BLK_HEAD(S_new[i]), DISK_LEAF_NODE_LEVEL);
+
+		n = B_NR_ITEMS(tbS0);
+
+		switch (flag) {
+		case M_INSERT:	/* insert item */
+
+			if (n - snum[i] < item_pos) {	/* new item or it's part falls to first new node S_new[i] */
+				if (item_pos == n - snum[i] + 1 && sbytes[i] != -1) {	/* part of new item falls into S_new[i] */
+					int old_key_comp, old_len,
+					    r_zeros_number;
+					const char *r_body;
+					int version;
+
+					/* Move snum[i]-1 items from S[0] to S_new[i] */
+					leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
+							snum[i] - 1, -1,
+							S_new[i]);
+					/* Remember key component and item length */
+					version = ih_version(ih);
+					old_key_comp = le_ih_k_offset(ih);
+					old_len = ih_item_len(ih);
+
+					/* Calculate key component and item length to insert into S_new[i] */
+					set_le_ih_k_offset(ih,
+							   le_ih_k_offset(ih) +
+							   ((old_len -
+							     sbytes[i]) <<
+							    (is_indirect_le_ih
+							     (ih) ? tb->tb_sb->
+							     s_blocksize_bits -
+							     UNFM_P_SHIFT :
+							     0)));
+
+					put_ih_item_len(ih, sbytes[i]);
+
+					/* Insert part of the item into S_new[i] before 0-th item */
+					bi.tb = tb;
+					bi.bi_bh = S_new[i];
+					bi.bi_parent = NULL;
+					bi.bi_position = 0;
+
+					if ((old_len - sbytes[i]) > zeros_num) {
+						r_zeros_number = 0;
+						r_body =
+						    body + (old_len -
+							    sbytes[i]) -
+						    zeros_num;
+					} else {
+						r_body = body;
+						r_zeros_number =
+						    zeros_num - (old_len -
+								 sbytes[i]);
+						zeros_num -= r_zeros_number;
+					}
+
+					leaf_insert_into_buf(&bi, 0, ih, r_body,
+							     r_zeros_number);
+
+					/* Calculate key component and item length to insert into S[i] */
+					set_le_ih_k_offset(ih, old_key_comp);
+					put_ih_item_len(ih,
+							old_len - sbytes[i]);
+					tb->insert_size[0] -= sbytes[i];
+				} else {	/* whole new item falls into S_new[i] */
+
+					/* Shift snum[0] - 1 items to S_new[i] (sbytes[i] of split item) */
+					leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
+							snum[i] - 1, sbytes[i],
+							S_new[i]);
+
+					/* Insert new item into S_new[i] */
+					bi.tb = tb;
+					bi.bi_bh = S_new[i];
+					bi.bi_parent = NULL;
+					bi.bi_position = 0;
+					leaf_insert_into_buf(&bi,
+							     item_pos - n +
+							     snum[i] - 1, ih,
+							     body, zeros_num);
+
+					zeros_num = tb->insert_size[0] = 0;
+				}
+			}
 
+			else {	/* new item or it part don't falls into S_new[i] */
 
-	n = B_NR_ITEMS(tbS0);
-	
-	switch (flag) {
-	case M_INSERT:   /* insert item */
-
-	    if ( n - snum[i] < item_pos )
-	    { /* new item or it's part falls to first new node S_new[i]*/
-		if ( item_pos == n - snum[i] + 1 && sbytes[i] != -1 )
-		{ /* part of new item falls into S_new[i] */
-		    int old_key_comp, old_len, r_zeros_number;
-		    const char * r_body;
-		    int version;
-
-		    /* Move snum[i]-1 items from S[0] to S_new[i] */
-		    leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i] - 1, -1, S_new[i]);
-		    /* Remember key component and item length */
-		    version = ih_version (ih);
-                    old_key_comp = le_ih_k_offset( ih );
-		    old_len = ih_item_len(ih);
-
-		    /* Calculate key component and item length to insert into S_new[i] */
-                    set_le_ih_k_offset( ih,
-                                le_ih_k_offset(ih) + ((old_len - sbytes[i] )<<(is_indirect_le_ih(ih)?tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT:0)) );
-
-		    put_ih_item_len( ih, sbytes[i] );
-
-		    /* Insert part of the item into S_new[i] before 0-th item */
-		    bi.tb = tb;
-		    bi.bi_bh = S_new[i];
-		    bi.bi_parent = NULL;
-		    bi.bi_position = 0;
-
-		    if ( (old_len - sbytes[i]) > zeros_num ) {
-			r_zeros_number = 0;
-			r_body = body + (old_len - sbytes[i]) - zeros_num;
-		    }
-		    else {
-			r_body = body;
-			r_zeros_number = zeros_num - (old_len - sbytes[i]);
-			zeros_num -= r_zeros_number;
-		    }
-
-		    leaf_insert_into_buf (&bi, 0, ih, r_body, r_zeros_number);
-
-		    /* Calculate key component and item length to insert into S[i] */
-                    set_le_ih_k_offset( ih, old_key_comp );
-		    put_ih_item_len( ih, old_len - sbytes[i] );
-		    tb->insert_size[0] -= sbytes[i];
-		}
-		else /* whole new item falls into S_new[i] */
-		{
-		    /* Shift snum[0] - 1 items to S_new[i] (sbytes[i] of split item) */
-		    leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i] - 1, sbytes[i], S_new[i]);
-
-		    /* Insert new item into S_new[i] */
-		    bi.tb = tb;
-		    bi.bi_bh = S_new[i];
-		    bi.bi_parent = NULL;
-		    bi.bi_position = 0;
-		    leaf_insert_into_buf (&bi, item_pos - n + snum[i] - 1, ih, body, zeros_num);
-
-		    zeros_num = tb->insert_size[0] = 0;
-		}
-	    }
-
-	    else /* new item or it part don't falls into S_new[i] */
-	    {
-		leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i], S_new[i]);
-	    }
-	    break;
-
-	case M_PASTE:   /* append item */
-
-	    if ( n - snum[i] <= item_pos )  /* pasted item or part if it falls to S_new[i] */
-	    {
-		if ( item_pos == n - snum[i] && sbytes[i] != -1 )
-		{ /* we must shift part of the appended item */
-		    struct item_head * aux_ih;
-
-		    RFALSE( ih, "PAP-12210: ih must be 0");
-
-		    if ( is_direntry_le_ih (aux_ih = B_N_PITEM_HEAD(tbS0,item_pos))) {
-			/* we append to directory item */
-
-			int entry_count;
-		
-			entry_count = ih_entry_count(aux_ih);
-
-			if ( entry_count - sbytes[i] < pos_in_item  && pos_in_item <= entry_count ) {
-			    /* new directory entry falls into S_new[i] */
-		  
-			    RFALSE( ! tb->insert_size[0],
-				    "PAP-12215: insert_size is already 0");
-			    RFALSE( sbytes[i] - 1 >= entry_count,
-				    "PAP-12220: there are no so much entries (%d), only %d",
-				    sbytes[i] - 1, entry_count);
-
-			    /* Shift snum[i]-1 items in whole. Shift sbytes[i] directory entries from directory item number snum[i] */
-			    leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i]-1, S_new[i]);
-			    /* Paste given directory entry to directory item */
-			    bi.tb = tb;
-			    bi.bi_bh = S_new[i];
-			    bi.bi_parent = NULL;
-			    bi.bi_position = 0;
-			    leaf_paste_in_buffer (&bi, 0, pos_in_item - entry_count + sbytes[i] - 1,
-						  tb->insert_size[0], body,zeros_num);
-			    /* paste new directory entry */
-			    leaf_paste_entries (
-				bi.bi_bh, 0, pos_in_item - entry_count + sbytes[i] - 1,
-				1, (struct reiserfs_de_head *)body, body + DEH_SIZE,
-				tb->insert_size[0]
-				);
-			    tb->insert_size[0] = 0;
-			    pos_in_item++;
-			} else { /* new directory entry doesn't fall into S_new[i] */
-			    leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i], S_new[i]);
+				leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
+						snum[i], sbytes[i], S_new[i]);
 			}
-		    }
-		    else /* regular object */
-		    {
-			int n_shift, n_rem, r_zeros_number;
-			const char * r_body;
-
-			RFALSE( pos_in_item != ih_item_len(B_N_PITEM_HEAD(tbS0,item_pos)) ||
-			        tb->insert_size[0] <= 0,
-			        "PAP-12225: item too short or insert_size <= 0");
-
-			/* Calculate number of bytes which must be shifted from appended item */
-			n_shift = sbytes[i] - tb->insert_size[0];
-			if ( n_shift < 0 )
-			    n_shift = 0;
-			leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], n_shift, S_new[i]);
-
-			/* Calculate number of bytes which must remain in body after append to S_new[i] */
-			n_rem = tb->insert_size[0] - sbytes[i];
-			if ( n_rem < 0 )
-			    n_rem = 0;
-			/* Append part of body into S_new[0] */
-			bi.tb = tb;
-			bi.bi_bh = S_new[i];
-			bi.bi_parent = NULL;
-			bi.bi_position = 0;
+			break;
+
+		case M_PASTE:	/* append item */
+
+			if (n - snum[i] <= item_pos) {	/* pasted item or part if it falls to S_new[i] */
+				if (item_pos == n - snum[i] && sbytes[i] != -1) {	/* we must shift part of the appended item */
+					struct item_head *aux_ih;
+
+					RFALSE(ih, "PAP-12210: ih must be 0");
+
+					if (is_direntry_le_ih
+					    (aux_ih =
+					     B_N_PITEM_HEAD(tbS0, item_pos))) {
+						/* we append to directory item */
+
+						int entry_count;
+
+						entry_count =
+						    ih_entry_count(aux_ih);
+
+						if (entry_count - sbytes[i] <
+						    pos_in_item
+						    && pos_in_item <=
+						    entry_count) {
+							/* new directory entry falls into S_new[i] */
+
+							RFALSE(!tb->
+							       insert_size[0],
+							       "PAP-12215: insert_size is already 0");
+							RFALSE(sbytes[i] - 1 >=
+							       entry_count,
+							       "PAP-12220: there are no so much entries (%d), only %d",
+							       sbytes[i] - 1,
+							       entry_count);
+
+							/* Shift snum[i]-1 items in whole. Shift sbytes[i] directory entries from directory item number snum[i] */
+							leaf_move_items
+							    (LEAF_FROM_S_TO_SNEW,
+							     tb, snum[i],
+							     sbytes[i] - 1,
+							     S_new[i]);
+							/* Paste given directory entry to directory item */
+							bi.tb = tb;
+							bi.bi_bh = S_new[i];
+							bi.bi_parent = NULL;
+							bi.bi_position = 0;
+							leaf_paste_in_buffer
+							    (&bi, 0,
+							     pos_in_item -
+							     entry_count +
+							     sbytes[i] - 1,
+							     tb->insert_size[0],
+							     body, zeros_num);
+							/* paste new directory entry */
+							leaf_paste_entries(bi.
+									   bi_bh,
+									   0,
+									   pos_in_item
+									   -
+									   entry_count
+									   +
+									   sbytes
+									   [i] -
+									   1, 1,
+									   (struct
+									    reiserfs_de_head
+									    *)
+									   body,
+									   body
+									   +
+									   DEH_SIZE,
+									   tb->
+									   insert_size
+									   [0]
+							    );
+							tb->insert_size[0] = 0;
+							pos_in_item++;
+						} else {	/* new directory entry doesn't fall into S_new[i] */
+							leaf_move_items
+							    (LEAF_FROM_S_TO_SNEW,
+							     tb, snum[i],
+							     sbytes[i],
+							     S_new[i]);
+						}
+					} else {	/* regular object */
+
+						int n_shift, n_rem,
+						    r_zeros_number;
+						const char *r_body;
+
+						RFALSE(pos_in_item !=
+						       ih_item_len
+						       (B_N_PITEM_HEAD
+							(tbS0, item_pos))
+						       || tb->insert_size[0] <=
+						       0,
+						       "PAP-12225: item too short or insert_size <= 0");
+
+						/* Calculate number of bytes which must be shifted from appended item */
+						n_shift =
+						    sbytes[i] -
+						    tb->insert_size[0];
+						if (n_shift < 0)
+							n_shift = 0;
+						leaf_move_items
+						    (LEAF_FROM_S_TO_SNEW, tb,
+						     snum[i], n_shift,
+						     S_new[i]);
+
+						/* Calculate number of bytes which must remain in body after append to S_new[i] */
+						n_rem =
+						    tb->insert_size[0] -
+						    sbytes[i];
+						if (n_rem < 0)
+							n_rem = 0;
+						/* Append part of body into S_new[0] */
+						bi.tb = tb;
+						bi.bi_bh = S_new[i];
+						bi.bi_parent = NULL;
+						bi.bi_position = 0;
+
+						if (n_rem > zeros_num) {
+							r_zeros_number = 0;
+							r_body =
+							    body + n_rem -
+							    zeros_num;
+						} else {
+							r_body = body;
+							r_zeros_number =
+							    zeros_num - n_rem;
+							zeros_num -=
+							    r_zeros_number;
+						}
+
+						leaf_paste_in_buffer(&bi, 0,
+								     n_shift,
+								     tb->
+								     insert_size
+								     [0] -
+								     n_rem,
+								     r_body,
+								     r_zeros_number);
+						{
+							struct item_head *tmp;
+
+							tmp =
+							    B_N_PITEM_HEAD(S_new
+									   [i],
+									   0);
+							if (is_indirect_le_ih
+							    (tmp)) {
+								set_ih_free_space
+								    (tmp, 0);
+								set_le_ih_k_offset
+								    (tmp,
+								     le_ih_k_offset
+								     (tmp) +
+								     (n_rem <<
+								      (tb->
+								       tb_sb->
+								       s_blocksize_bits
+								       -
+								       UNFM_P_SHIFT)));
+							} else {
+								set_le_ih_k_offset
+								    (tmp,
+								     le_ih_k_offset
+								     (tmp) +
+								     n_rem);
+							}
+						}
+
+						tb->insert_size[0] = n_rem;
+						if (!n_rem)
+							pos_in_item++;
+					}
+				} else
+					/* item falls wholly into S_new[i] */
+				{
+					int ret_val;
+					struct item_head *pasted;
 
-			if ( n_rem > zeros_num ) {
-			    r_zeros_number = 0;
-			    r_body = body + n_rem - zeros_num;
-			}
-			else {
-			    r_body = body;
-			    r_zeros_number = zeros_num - n_rem;
-			    zeros_num -= r_zeros_number;
+#ifdef CONFIG_REISERFS_CHECK
+					struct item_head *ih =
+					    B_N_PITEM_HEAD(tbS0, item_pos);
+
+					if (!is_direntry_le_ih(ih)
+					    && (pos_in_item != ih_item_len(ih)
+						|| tb->insert_size[0] <= 0))
+						reiserfs_panic(tb->tb_sb,
+							       "PAP-12235: balance_leaf: pos_in_item must be equal to ih_item_len");
+#endif				/* CONFIG_REISERFS_CHECK */
+
+					ret_val =
+					    leaf_move_items(LEAF_FROM_S_TO_SNEW,
+							    tb, snum[i],
+							    sbytes[i],
+							    S_new[i]);
+
+					RFALSE(ret_val,
+					       "PAP-12240: unexpected value returned by leaf_move_items (%d)",
+					       ret_val);
+
+					/* paste into item */
+					bi.tb = tb;
+					bi.bi_bh = S_new[i];
+					bi.bi_parent = NULL;
+					bi.bi_position = 0;
+					leaf_paste_in_buffer(&bi,
+							     item_pos - n +
+							     snum[i],
+							     pos_in_item,
+							     tb->insert_size[0],
+							     body, zeros_num);
+
+					pasted =
+					    B_N_PITEM_HEAD(S_new[i],
+							   item_pos - n +
+							   snum[i]);
+					if (is_direntry_le_ih(pasted)) {
+						leaf_paste_entries(bi.bi_bh,
+								   item_pos -
+								   n + snum[i],
+								   pos_in_item,
+								   1,
+								   (struct
+								    reiserfs_de_head
+								    *)body,
+								   body +
+								   DEH_SIZE,
+								   tb->
+								   insert_size
+								   [0]
+						    );
+					}
+
+					/* if we paste to indirect item update ih_free_space */
+					if (is_indirect_le_ih(pasted))
+						set_ih_free_space(pasted, 0);
+					zeros_num = tb->insert_size[0] = 0;
+				}
 			}
 
-			leaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0]-n_rem, r_body,r_zeros_number);
-			{
-			    struct item_head * tmp;
-
-			    tmp = B_N_PITEM_HEAD(S_new[i],0);
-			    if (is_indirect_le_ih (tmp)) {
-				set_ih_free_space (tmp, 0);
-				set_le_ih_k_offset( tmp, le_ih_k_offset(tmp) + 
-					            (n_rem << (tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT)));
-			    } else {
-				set_le_ih_k_offset( tmp, le_ih_k_offset(tmp) + 
-				                    n_rem );
-			    }
-			}
+			else {	/* pasted item doesn't fall into S_new[i] */
 
-			tb->insert_size[0] = n_rem;
-			if ( ! n_rem )
-			    pos_in_item++;
-		    }
+				leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
+						snum[i], sbytes[i], S_new[i]);
+			}
+			break;
+		default:	/* cases d and t */
+			reiserfs_panic(tb->tb_sb,
+				       "PAP-12245: balance_leaf: blknum > 2: unexpectable mode: %s(%d)",
+				       (flag ==
+					M_DELETE) ? "DELETE" : ((flag ==
+								 M_CUT) ? "CUT"
+								: "UNKNOWN"),
+				       flag);
 		}
-		else
-		    /* item falls wholly into S_new[i] */
-		{
-		    int ret_val;
-		    struct item_head * pasted;
 
-#ifdef CONFIG_REISERFS_CHECK
-		    struct item_head * ih = B_N_PITEM_HEAD(tbS0,item_pos);
-
-		    if ( ! is_direntry_le_ih(ih) && (pos_in_item != ih_item_len(ih) ||
-						     tb->insert_size[0] <= 0) )
-			reiserfs_panic (tb->tb_sb, "PAP-12235: balance_leaf: pos_in_item must be equal to ih_item_len");
-#endif /* CONFIG_REISERFS_CHECK */
-
-		    ret_val = leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i], S_new[i]);
-
-		    RFALSE( ret_val,
-			    "PAP-12240: unexpected value returned by leaf_move_items (%d)",
-			    ret_val);
-
-		    /* paste into item */
-		    bi.tb = tb;
-		    bi.bi_bh = S_new[i];
-		    bi.bi_parent = NULL;
-		    bi.bi_position = 0;
-		    leaf_paste_in_buffer(&bi, item_pos - n + snum[i], pos_in_item, tb->insert_size[0], body, zeros_num);
-
-		    pasted = B_N_PITEM_HEAD(S_new[i], item_pos - n + snum[i]);
-		    if (is_direntry_le_ih (pasted))
-		    {
-			leaf_paste_entries (
-			    bi.bi_bh, item_pos - n + snum[i], pos_in_item, 1, 
-			    (struct reiserfs_de_head *)body, body + DEH_SIZE, tb->insert_size[0]
-			    );
-		    }
-
-		    /* if we paste to indirect item update ih_free_space */
-		    if (is_indirect_le_ih (pasted))
-			set_ih_free_space (pasted, 0);
-		    zeros_num = tb->insert_size[0] = 0;
-		}
-	    }
-
-	    else /* pasted item doesn't fall into S_new[i] */
-	    {
-		leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i], S_new[i]);
-	    }
-	    break;
-	default:    /* cases d and t */
-	    reiserfs_panic (tb->tb_sb, "PAP-12245: balance_leaf: blknum > 2: unexpectable mode: %s(%d)",
-			    (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
+		memcpy(insert_key + i, B_N_PKEY(S_new[i], 0), KEY_SIZE);
+		insert_ptr[i] = S_new[i];
+
+		RFALSE(!buffer_journaled(S_new[i])
+		       || buffer_journal_dirty(S_new[i])
+		       || buffer_dirty(S_new[i]), "PAP-12247: S_new[%d] : (%b)",
+		       i, S_new[i]);
 	}
 
-	memcpy (insert_key + i,B_N_PKEY(S_new[i],0),KEY_SIZE);
-	insert_ptr[i] = S_new[i];
-
-	RFALSE (!buffer_journaled (S_new [i]) || buffer_journal_dirty (S_new [i]) ||
-		buffer_dirty (S_new [i]),
-		"PAP-12247: S_new[%d] : (%b)", i, S_new[i]);
-    }
-
-    /* if the affected item was not wholly shifted then we perform all necessary operations on that part or whole of the
-       affected item which remains in S */
-    if ( 0 <= item_pos && item_pos < tb->s0num )
-    { /* if we must insert or append into buffer S[0] */
-
-	switch (flag)
-	{
-	case M_INSERT:   /* insert item into S[0] */
-	    bi.tb = tb;
-	    bi.bi_bh = tbS0;
-	    bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
-	    bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
-	    leaf_insert_into_buf (&bi, item_pos, ih, body, zeros_num);
-
-	    /* If we insert the first key change the delimiting key */
-	    if( item_pos == 0 ) {
-		if (tb->CFL[0]) /* can be 0 in reiserfsck */
-		    replace_key(tb, tb->CFL[0], tb->lkey[0],tbS0,0);
-
-	    }
-	    break;
-
-	case M_PASTE: {  /* append item in S[0] */
-	    struct item_head * pasted;
-
-	    pasted = B_N_PITEM_HEAD (tbS0, item_pos);
-	    /* when directory, may be new entry already pasted */
-	    if (is_direntry_le_ih (pasted)) {
-		if ( pos_in_item >= 0 &&
-		    pos_in_item <= ih_entry_count(pasted) ) {
-
-		    RFALSE( ! tb->insert_size[0], 
-			    "PAP-12260: insert_size is 0 already");
-
-		    /* prepare space */
-		    bi.tb = tb;
-		    bi.bi_bh = tbS0;
-		    bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
-		    bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
-		    leaf_paste_in_buffer(&bi, item_pos, pos_in_item, tb->insert_size[0], body, zeros_num);
-
-		    /* paste entry */
-		    leaf_paste_entries (
-			bi.bi_bh, item_pos, pos_in_item, 1, (struct reiserfs_de_head *)body,
-			body + DEH_SIZE, tb->insert_size[0]
-			);
-		    if ( ! item_pos && ! pos_in_item ) {
-			RFALSE( !tb->CFL[0] || !tb->L[0], 
-				"PAP-12270: CFL[0]/L[0] must be specified");
-			if (tb->CFL[0]) {
-			    replace_key(tb, tb->CFL[0], tb->lkey[0],tbS0,0);
+	/* if the affected item was not wholly shifted then we perform all necessary operations on that part or whole of the
+	   affected item which remains in S */
+	if (0 <= item_pos && item_pos < tb->s0num) {	/* if we must insert or append into buffer S[0] */
+
+		switch (flag) {
+		case M_INSERT:	/* insert item into S[0] */
+			bi.tb = tb;
+			bi.bi_bh = tbS0;
+			bi.bi_parent = PATH_H_PPARENT(tb->tb_path, 0);
+			bi.bi_position = PATH_H_POSITION(tb->tb_path, 1);
+			leaf_insert_into_buf(&bi, item_pos, ih, body,
+					     zeros_num);
+
+			/* If we insert the first key change the delimiting key */
+			if (item_pos == 0) {
+				if (tb->CFL[0])	/* can be 0 in reiserfsck */
+					replace_key(tb, tb->CFL[0], tb->lkey[0],
+						    tbS0, 0);
 
 			}
-		    }
-		    tb->insert_size[0] = 0;
-		}
-	    } else { /* regular object */
-		if ( pos_in_item == ih_item_len(pasted) ) {
-
-		    RFALSE( tb->insert_size[0] <= 0,
-			    "PAP-12275: insert size must not be %d",
-                            tb->insert_size[0]);
-		    bi.tb = tb;
-		    bi.bi_bh = tbS0;
-		    bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
-		    bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
-		    leaf_paste_in_buffer (&bi, item_pos, pos_in_item, tb->insert_size[0], body, zeros_num);
-
-		    if (is_indirect_le_ih (pasted)) {
+			break;
+
+		case M_PASTE:{	/* append item in S[0] */
+				struct item_head *pasted;
+
+				pasted = B_N_PITEM_HEAD(tbS0, item_pos);
+				/* when directory, may be new entry already pasted */
+				if (is_direntry_le_ih(pasted)) {
+					if (pos_in_item >= 0 &&
+					    pos_in_item <=
+					    ih_entry_count(pasted)) {
+
+						RFALSE(!tb->insert_size[0],
+						       "PAP-12260: insert_size is 0 already");
+
+						/* prepare space */
+						bi.tb = tb;
+						bi.bi_bh = tbS0;
+						bi.bi_parent =
+						    PATH_H_PPARENT(tb->tb_path,
+								   0);
+						bi.bi_position =
+						    PATH_H_POSITION(tb->tb_path,
+								    1);
+						leaf_paste_in_buffer(&bi,
+								     item_pos,
+								     pos_in_item,
+								     tb->
+								     insert_size
+								     [0], body,
+								     zeros_num);
+
+						/* paste entry */
+						leaf_paste_entries(bi.bi_bh,
+								   item_pos,
+								   pos_in_item,
+								   1,
+								   (struct
+								    reiserfs_de_head
+								    *)body,
+								   body +
+								   DEH_SIZE,
+								   tb->
+								   insert_size
+								   [0]
+						    );
+						if (!item_pos && !pos_in_item) {
+							RFALSE(!tb->CFL[0]
+							       || !tb->L[0],
+							       "PAP-12270: CFL[0]/L[0] must be specified");
+							if (tb->CFL[0]) {
+								replace_key(tb,
+									    tb->
+									    CFL
+									    [0],
+									    tb->
+									    lkey
+									    [0],
+									    tbS0,
+									    0);
+
+							}
+						}
+						tb->insert_size[0] = 0;
+					}
+				} else {	/* regular object */
+					if (pos_in_item == ih_item_len(pasted)) {
+
+						RFALSE(tb->insert_size[0] <= 0,
+						       "PAP-12275: insert size must not be %d",
+						       tb->insert_size[0]);
+						bi.tb = tb;
+						bi.bi_bh = tbS0;
+						bi.bi_parent =
+						    PATH_H_PPARENT(tb->tb_path,
+								   0);
+						bi.bi_position =
+						    PATH_H_POSITION(tb->tb_path,
+								    1);
+						leaf_paste_in_buffer(&bi,
+								     item_pos,
+								     pos_in_item,
+								     tb->
+								     insert_size
+								     [0], body,
+								     zeros_num);
+
+						if (is_indirect_le_ih(pasted)) {
 #if 0
-			RFALSE( tb->insert_size[0] != UNFM_P_SIZE,
-				"PAP-12280: insert_size for indirect item must be %d, not %d",
-				UNFM_P_SIZE, tb->insert_size[0]);
+							RFALSE(tb->
+							       insert_size[0] !=
+							       UNFM_P_SIZE,
+							       "PAP-12280: insert_size for indirect item must be %d, not %d",
+							       UNFM_P_SIZE,
+							       tb->
+							       insert_size[0]);
 #endif
-			set_ih_free_space (pasted, 0);
-		    }
-		    tb->insert_size[0] = 0;
-		}
-
+							set_ih_free_space
+							    (pasted, 0);
+						}
+						tb->insert_size[0] = 0;
+					}
 #ifdef CONFIG_REISERFS_CHECK
-		else {
-		    if ( tb->insert_size[0] ) {
-			print_cur_tb ("12285");
-			reiserfs_panic (tb->tb_sb, "PAP-12285: balance_leaf: insert_size must be 0 (%d)", tb->insert_size[0]);
-		    }
+					else {
+						if (tb->insert_size[0]) {
+							print_cur_tb("12285");
+							reiserfs_panic(tb->
+								       tb_sb,
+								       "PAP-12285: balance_leaf: insert_size must be 0 (%d)",
+								       tb->
+								       insert_size
+								       [0]);
+						}
+					}
+#endif				/* CONFIG_REISERFS_CHECK */
+
+				}
+			}	/* case M_PASTE: */
 		}
-#endif /* CONFIG_REISERFS_CHECK */
-	    
-	    }
-	} /* case M_PASTE: */
 	}
-    }
-
 #ifdef CONFIG_REISERFS_CHECK
-    if ( flag == M_PASTE && tb->insert_size[0] ) {
-	print_cur_tb ("12290");
-	reiserfs_panic (tb->tb_sb, "PAP-12290: balance_leaf: insert_size is still not 0 (%d)", tb->insert_size[0]);
-    }
-#endif /* CONFIG_REISERFS_CHECK */
-
-    return 0;
-} /* Leaf level of the tree is balanced (end of balance_leaf) */
-
+	if (flag == M_PASTE && tb->insert_size[0]) {
+		print_cur_tb("12290");
+		reiserfs_panic(tb->tb_sb,
+			       "PAP-12290: balance_leaf: insert_size is still not 0 (%d)",
+			       tb->insert_size[0]);
+	}
+#endif				/* CONFIG_REISERFS_CHECK */
 
+	return 0;
+}				/* Leaf level of the tree is balanced (end of balance_leaf) */
 
 /* Make empty node */
-void make_empty_node (struct buffer_info * bi)
+void make_empty_node(struct buffer_info *bi)
 {
-    struct block_head * blkh;
+	struct block_head *blkh;
 
-    RFALSE( bi->bi_bh == NULL, "PAP-12295: pointer to the buffer is NULL");
+	RFALSE(bi->bi_bh == NULL, "PAP-12295: pointer to the buffer is NULL");
 
-    blkh = B_BLK_HEAD(bi->bi_bh);
-    set_blkh_nr_item( blkh, 0 );
-    set_blkh_free_space( blkh, MAX_CHILD_SIZE(bi->bi_bh) );
+	blkh = B_BLK_HEAD(bi->bi_bh);
+	set_blkh_nr_item(blkh, 0);
+	set_blkh_free_space(blkh, MAX_CHILD_SIZE(bi->bi_bh));
 
-    if (bi->bi_parent)
-	B_N_CHILD (bi->bi_parent, bi->bi_position)->dc_size = 0; /* Endian safe if 0 */
+	if (bi->bi_parent)
+		B_N_CHILD(bi->bi_parent, bi->bi_position)->dc_size = 0;	/* Endian safe if 0 */
 }
 
-
 /* Get first empty buffer */
-struct buffer_head * get_FEB (struct tree_balance * tb)
+struct buffer_head *get_FEB(struct tree_balance *tb)
 {
-    int i;
-    struct buffer_head * first_b;
-    struct buffer_info bi;
-
-    for (i = 0; i < MAX_FEB_SIZE; i ++)
-	if (tb->FEB[i] != 0)
-	    break;
-
-    if (i == MAX_FEB_SIZE)
-	reiserfs_panic(tb->tb_sb, "vs-12300: get_FEB: FEB list is empty");
-
-    bi.tb = tb;
-    bi.bi_bh = first_b = tb->FEB[i];
-    bi.bi_parent = NULL;
-    bi.bi_position = 0;
-    make_empty_node (&bi);
-    set_buffer_uptodate(first_b);
-    tb->FEB[i] = NULL;
-    tb->used[i] = first_b;
-
-    return(first_b);
-}
+	int i;
+	struct buffer_head *first_b;
+	struct buffer_info bi;
 
+	for (i = 0; i < MAX_FEB_SIZE; i++)
+		if (tb->FEB[i] != 0)
+			break;
+
+	if (i == MAX_FEB_SIZE)
+		reiserfs_panic(tb->tb_sb,
+			       "vs-12300: get_FEB: FEB list is empty");
+
+	bi.tb = tb;
+	bi.bi_bh = first_b = tb->FEB[i];
+	bi.bi_parent = NULL;
+	bi.bi_position = 0;
+	make_empty_node(&bi);
+	set_buffer_uptodate(first_b);
+	tb->FEB[i] = NULL;
+	tb->used[i] = first_b;
+
+	return (first_b);
+}
 
 /* This is now used because reiserfs_free_block has to be able to
 ** schedule.
 */
-static void store_thrown (struct tree_balance * tb, struct buffer_head * bh)
+static void store_thrown(struct tree_balance *tb, struct buffer_head *bh)
 {
-    int i;
-
-    if (buffer_dirty (bh))
-      reiserfs_warning (tb->tb_sb, "store_thrown deals with dirty buffer");
-    for (i = 0; i < sizeof (tb->thrown)/sizeof (tb->thrown[0]); i ++)
-	if (!tb->thrown[i]) {
-	    tb->thrown[i] = bh;
-	    get_bh(bh) ; /* free_thrown puts this */
-	    return;
-	}
-    reiserfs_warning (tb->tb_sb, "store_thrown: too many thrown buffers");
+	int i;
+
+	if (buffer_dirty(bh))
+		reiserfs_warning(tb->tb_sb,
+				 "store_thrown deals with dirty buffer");
+	for (i = 0; i < sizeof(tb->thrown) / sizeof(tb->thrown[0]); i++)
+		if (!tb->thrown[i]) {
+			tb->thrown[i] = bh;
+			get_bh(bh);	/* free_thrown puts this */
+			return;
+		}
+	reiserfs_warning(tb->tb_sb, "store_thrown: too many thrown buffers");
 }
 
-static void free_thrown(struct tree_balance *tb) {
-    int i ;
-    b_blocknr_t blocknr ;
-    for (i = 0; i < sizeof (tb->thrown)/sizeof (tb->thrown[0]); i++) {
-	if (tb->thrown[i]) {
-	    blocknr = tb->thrown[i]->b_blocknr ;
-	    if (buffer_dirty (tb->thrown[i]))
-	      reiserfs_warning (tb->tb_sb,
-				"free_thrown deals with dirty buffer %d",
-				blocknr);
-	    brelse(tb->thrown[i]) ; /* incremented in store_thrown */
-	    reiserfs_free_block (tb->transaction_handle, NULL, blocknr, 0);
+static void free_thrown(struct tree_balance *tb)
+{
+	int i;
+	b_blocknr_t blocknr;
+	for (i = 0; i < sizeof(tb->thrown) / sizeof(tb->thrown[0]); i++) {
+		if (tb->thrown[i]) {
+			blocknr = tb->thrown[i]->b_blocknr;
+			if (buffer_dirty(tb->thrown[i]))
+				reiserfs_warning(tb->tb_sb,
+						 "free_thrown deals with dirty buffer %d",
+						 blocknr);
+			brelse(tb->thrown[i]);	/* incremented in store_thrown */
+			reiserfs_free_block(tb->transaction_handle, NULL,
+					    blocknr, 0);
+		}
 	}
-    }
 }
 
-void reiserfs_invalidate_buffer (struct tree_balance * tb, struct buffer_head * bh)
+void reiserfs_invalidate_buffer(struct tree_balance *tb, struct buffer_head *bh)
 {
-    struct block_head *blkh;
-    blkh = B_BLK_HEAD(bh);
-    set_blkh_level( blkh, FREE_LEVEL );
-    set_blkh_nr_item( blkh, 0 );
-    
-    clear_buffer_dirty(bh);
-    store_thrown (tb, bh);
+	struct block_head *blkh;
+	blkh = B_BLK_HEAD(bh);
+	set_blkh_level(blkh, FREE_LEVEL);
+	set_blkh_nr_item(blkh, 0);
+
+	clear_buffer_dirty(bh);
+	store_thrown(tb, bh);
 }
 
 /* Replace n_dest'th key in buffer dest by n_src'th key of buffer src.*/
-void replace_key (struct tree_balance * tb, struct buffer_head * dest, int n_dest,
-		  struct buffer_head * src, int n_src)
+void replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,
+		 struct buffer_head *src, int n_src)
 {
 
-    RFALSE( dest == NULL || src == NULL,
-	    "vs-12305: source or destination buffer is 0 (src=%p, dest=%p)",
-	    src, dest);
-    RFALSE( ! B_IS_KEYS_LEVEL (dest),
-	    "vs-12310: invalid level (%z) for destination buffer. dest must be leaf",
-	    dest);
-    RFALSE( n_dest < 0 || n_src < 0,
-	    "vs-12315: src(%d) or dest(%d) key number < 0", n_src, n_dest);
-    RFALSE( n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),
-	    "vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big",
-	    n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));
-   
-    if (B_IS_ITEMS_LEVEL (src))
-	/* source buffer contains leaf node */
-	memcpy (B_N_PDELIM_KEY(dest,n_dest), B_N_PITEM_HEAD(src,n_src), KEY_SIZE);
-    else
-	memcpy (B_N_PDELIM_KEY(dest,n_dest), B_N_PDELIM_KEY(src,n_src), KEY_SIZE);
-
-    do_balance_mark_internal_dirty (tb, dest, 0);
+	RFALSE(dest == NULL || src == NULL,
+	       "vs-12305: source or destination buffer is 0 (src=%p, dest=%p)",
+	       src, dest);
+	RFALSE(!B_IS_KEYS_LEVEL(dest),
+	       "vs-12310: invalid level (%z) for destination buffer. dest must be leaf",
+	       dest);
+	RFALSE(n_dest < 0 || n_src < 0,
+	       "vs-12315: src(%d) or dest(%d) key number < 0", n_src, n_dest);
+	RFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),
+	       "vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big",
+	       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));
+
+	if (B_IS_ITEMS_LEVEL(src))
+		/* source buffer contains leaf node */
+		memcpy(B_N_PDELIM_KEY(dest, n_dest), B_N_PITEM_HEAD(src, n_src),
+		       KEY_SIZE);
+	else
+		memcpy(B_N_PDELIM_KEY(dest, n_dest), B_N_PDELIM_KEY(src, n_src),
+		       KEY_SIZE);
+
+	do_balance_mark_internal_dirty(tb, dest, 0);
 }
 
-
-int get_left_neighbor_position (
-				struct tree_balance * tb, 
-				int h
-				)
+int get_left_neighbor_position(struct tree_balance *tb, int h)
 {
-  int Sh_position = PATH_H_POSITION (tb->tb_path, h + 1);
+	int Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);
 
-  RFALSE( PATH_H_PPARENT (tb->tb_path, h) == 0 || tb->FL[h] == 0,
-	  "vs-12325: FL[%d](%p) or F[%d](%p) does not exist", 
-	  h, tb->FL[h], h, PATH_H_PPARENT (tb->tb_path, h));
+	RFALSE(PATH_H_PPARENT(tb->tb_path, h) == 0 || tb->FL[h] == 0,
+	       "vs-12325: FL[%d](%p) or F[%d](%p) does not exist",
+	       h, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));
 
-  if (Sh_position == 0)
-    return B_NR_ITEMS (tb->FL[h]);
-  else
-    return Sh_position - 1;
+	if (Sh_position == 0)
+		return B_NR_ITEMS(tb->FL[h]);
+	else
+		return Sh_position - 1;
 }
 
-
-int get_right_neighbor_position (struct tree_balance * tb, int h)
+int get_right_neighbor_position(struct tree_balance *tb, int h)
 {
-  int Sh_position = PATH_H_POSITION (tb->tb_path, h + 1);
+	int Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);
 
-  RFALSE( PATH_H_PPARENT (tb->tb_path, h) == 0 || tb->FR[h] == 0,
-	  "vs-12330: F[%d](%p) or FR[%d](%p) does not exist", 
-	  h, PATH_H_PPARENT (tb->tb_path, h), h, tb->FR[h]);
+	RFALSE(PATH_H_PPARENT(tb->tb_path, h) == 0 || tb->FR[h] == 0,
+	       "vs-12330: F[%d](%p) or FR[%d](%p) does not exist",
+	       h, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);
 
-  if (Sh_position == B_NR_ITEMS (PATH_H_PPARENT (tb->tb_path, h)))
-    return 0;
-  else
-    return Sh_position + 1;
+	if (Sh_position == B_NR_ITEMS(PATH_H_PPARENT(tb->tb_path, h)))
+		return 0;
+	else
+		return Sh_position + 1;
 }
 
-
 #ifdef CONFIG_REISERFS_CHECK
 
-int is_reusable (struct super_block * s, b_blocknr_t block, int bit_value);
-static void check_internal_node (struct super_block * s, struct buffer_head * bh, char * mes)
+int is_reusable(struct super_block *s, b_blocknr_t block, int bit_value);
+static void check_internal_node(struct super_block *s, struct buffer_head *bh,
+				char *mes)
 {
-  struct disk_child * dc;
-  int i;
-
-  RFALSE( !bh, "PAP-12336: bh == 0");
-
-  if (!bh || !B_IS_IN_TREE (bh))
-    return;
- 
-  RFALSE( !buffer_dirty (bh) && 
-	  !(buffer_journaled(bh) || buffer_journal_dirty(bh)),
-	  "PAP-12337: buffer (%b) must be dirty", bh);
-  dc = B_N_CHILD (bh, 0);
-
-  for (i = 0; i <= B_NR_ITEMS (bh); i ++, dc ++) {
-    if (!is_reusable (s, dc_block_number(dc), 1) ) {
-      print_cur_tb (mes);
-      reiserfs_panic (s, "PAP-12338: check_internal_node: invalid child pointer %y in %b", dc, bh);
-    }
-  }
-}
+	struct disk_child *dc;
+	int i;
 
+	RFALSE(!bh, "PAP-12336: bh == 0");
 
-static int locked_or_not_in_tree (struct buffer_head * bh, char * which)
-{
-  if ( (!buffer_journal_prepared (bh) && buffer_locked (bh)) ||
-        !B_IS_IN_TREE (bh) ) {
-    reiserfs_warning (NULL, "vs-12339: locked_or_not_in_tree: %s (%b)",
-                      which, bh);
-    return 1;
-  } 
-  return 0;
-}
+	if (!bh || !B_IS_IN_TREE(bh))
+		return;
 
+	RFALSE(!buffer_dirty(bh) &&
+	       !(buffer_journaled(bh) || buffer_journal_dirty(bh)),
+	       "PAP-12337: buffer (%b) must be dirty", bh);
+	dc = B_N_CHILD(bh, 0);
 
-static int check_before_balancing (struct tree_balance * tb)
-{
-  int retval = 0;	
-
-  if ( cur_tb ) {
-    reiserfs_panic (tb->tb_sb, "vs-12335: check_before_balancing: "
-		    "suspect that schedule occurred based on cur_tb not being null at this point in code. "
-		    "do_balance cannot properly handle schedule occurring while it runs.");
-  }
-  
-  /* double check that buffers that we will modify are unlocked. (fix_nodes should already have
-     prepped all of these for us). */
-  if ( tb->lnum[0] ) {
-    retval |= locked_or_not_in_tree (tb->L[0], "L[0]");
-    retval |= locked_or_not_in_tree (tb->FL[0], "FL[0]");
-    retval |= locked_or_not_in_tree (tb->CFL[0], "CFL[0]");
-    check_leaf (tb->L[0]);
-  }
-  if ( tb->rnum[0] ) {
-    retval |= locked_or_not_in_tree (tb->R[0], "R[0]");
-    retval |= locked_or_not_in_tree (tb->FR[0], "FR[0]");
-    retval |= locked_or_not_in_tree (tb->CFR[0], "CFR[0]");
-    check_leaf (tb->R[0]);
-  }
-  retval |= locked_or_not_in_tree (PATH_PLAST_BUFFER (tb->tb_path), "S[0]");
-  check_leaf (PATH_PLAST_BUFFER (tb->tb_path));
-
-  return retval;
+	for (i = 0; i <= B_NR_ITEMS(bh); i++, dc++) {
+		if (!is_reusable(s, dc_block_number(dc), 1)) {
+			print_cur_tb(mes);
+			reiserfs_panic(s,
+				       "PAP-12338: check_internal_node: invalid child pointer %y in %b",
+				       dc, bh);
+		}
+	}
 }
 
+static int locked_or_not_in_tree(struct buffer_head *bh, char *which)
+{
+	if ((!buffer_journal_prepared(bh) && buffer_locked(bh)) ||
+	    !B_IS_IN_TREE(bh)) {
+		reiserfs_warning(NULL,
+				 "vs-12339: locked_or_not_in_tree: %s (%b)",
+				 which, bh);
+		return 1;
+	}
+	return 0;
+}
 
-static void check_after_balance_leaf (struct tree_balance * tb)
+static int check_before_balancing(struct tree_balance *tb)
 {
-    if (tb->lnum[0]) {
-	if (B_FREE_SPACE (tb->L[0]) != 
-	    MAX_CHILD_SIZE (tb->L[0]) - dc_size(B_N_CHILD (tb->FL[0], get_left_neighbor_position (tb, 0)))) {
-	    print_cur_tb ("12221");
-	    reiserfs_panic (tb->tb_sb, "PAP-12355: check_after_balance_leaf: shift to left was incorrect");
+	int retval = 0;
+
+	if (cur_tb) {
+		reiserfs_panic(tb->tb_sb, "vs-12335: check_before_balancing: "
+			       "suspect that schedule occurred based on cur_tb not being null at this point in code. "
+			       "do_balance cannot properly handle schedule occurring while it runs.");
 	}
-    }
-    if (tb->rnum[0]) {
-	if (B_FREE_SPACE (tb->R[0]) != 
-	    MAX_CHILD_SIZE (tb->R[0]) - dc_size(B_N_CHILD (tb->FR[0], get_right_neighbor_position (tb, 0)))) {
-	    print_cur_tb ("12222");
-	    reiserfs_panic (tb->tb_sb, "PAP-12360: check_after_balance_leaf: shift to right was incorrect");
+
+	/* double check that buffers that we will modify are unlocked. (fix_nodes should already have
+	   prepped all of these for us). */
+	if (tb->lnum[0]) {
+		retval |= locked_or_not_in_tree(tb->L[0], "L[0]");
+		retval |= locked_or_not_in_tree(tb->FL[0], "FL[0]");
+		retval |= locked_or_not_in_tree(tb->CFL[0], "CFL[0]");
+		check_leaf(tb->L[0]);
 	}
-    }
-    if (PATH_H_PBUFFER(tb->tb_path,1) &&
-	(B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) != 
-		    (MAX_CHILD_SIZE (PATH_H_PBUFFER(tb->tb_path,0)) -
-		    dc_size(B_N_CHILD (PATH_H_PBUFFER(tb->tb_path,1),
-		    PATH_H_POSITION (tb->tb_path, 1)))) )) {
-	int left = B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0));
-	int right = (MAX_CHILD_SIZE (PATH_H_PBUFFER(tb->tb_path,0)) -
-		    dc_size(B_N_CHILD (PATH_H_PBUFFER(tb->tb_path,1),
-			PATH_H_POSITION (tb->tb_path, 1))));
-	print_cur_tb ("12223");
-	reiserfs_warning (tb->tb_sb,
-	    "B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) = %d; "
-    	    "MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d",
-	    left,
-	    MAX_CHILD_SIZE (PATH_H_PBUFFER(tb->tb_path,0)),
-	    PATH_H_PBUFFER(tb->tb_path,1),
-	    PATH_H_POSITION (tb->tb_path, 1),
-	    dc_size(B_N_CHILD (PATH_H_PBUFFER(tb->tb_path,1), PATH_H_POSITION (tb->tb_path, 1 )) ),
-	    right );
-	reiserfs_panic (tb->tb_sb, "PAP-12365: check_after_balance_leaf: S is incorrect");
-    }
-}
+	if (tb->rnum[0]) {
+		retval |= locked_or_not_in_tree(tb->R[0], "R[0]");
+		retval |= locked_or_not_in_tree(tb->FR[0], "FR[0]");
+		retval |= locked_or_not_in_tree(tb->CFR[0], "CFR[0]");
+		check_leaf(tb->R[0]);
+	}
+	retval |= locked_or_not_in_tree(PATH_PLAST_BUFFER(tb->tb_path), "S[0]");
+	check_leaf(PATH_PLAST_BUFFER(tb->tb_path));
 
+	return retval;
+}
 
-static void check_leaf_level (struct tree_balance * tb)
+static void check_after_balance_leaf(struct tree_balance *tb)
 {
-  check_leaf (tb->L[0]);
-  check_leaf (tb->R[0]);
-  check_leaf (PATH_PLAST_BUFFER (tb->tb_path));
+	if (tb->lnum[0]) {
+		if (B_FREE_SPACE(tb->L[0]) !=
+		    MAX_CHILD_SIZE(tb->L[0]) -
+		    dc_size(B_N_CHILD
+			    (tb->FL[0], get_left_neighbor_position(tb, 0)))) {
+			print_cur_tb("12221");
+			reiserfs_panic(tb->tb_sb,
+				       "PAP-12355: check_after_balance_leaf: shift to left was incorrect");
+		}
+	}
+	if (tb->rnum[0]) {
+		if (B_FREE_SPACE(tb->R[0]) !=
+		    MAX_CHILD_SIZE(tb->R[0]) -
+		    dc_size(B_N_CHILD
+			    (tb->FR[0], get_right_neighbor_position(tb, 0)))) {
+			print_cur_tb("12222");
+			reiserfs_panic(tb->tb_sb,
+				       "PAP-12360: check_after_balance_leaf: shift to right was incorrect");
+		}
+	}
+	if (PATH_H_PBUFFER(tb->tb_path, 1) &&
+	    (B_FREE_SPACE(PATH_H_PBUFFER(tb->tb_path, 0)) !=
+	     (MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)) -
+	      dc_size(B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),
+				PATH_H_POSITION(tb->tb_path, 1)))))) {
+		int left = B_FREE_SPACE(PATH_H_PBUFFER(tb->tb_path, 0));
+		int right = (MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)) -
+			     dc_size(B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),
+					       PATH_H_POSITION(tb->tb_path,
+							       1))));
+		print_cur_tb("12223");
+		reiserfs_warning(tb->tb_sb,
+				 "B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) = %d; "
+				 "MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d",
+				 left,
+				 MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)),
+				 PATH_H_PBUFFER(tb->tb_path, 1),
+				 PATH_H_POSITION(tb->tb_path, 1),
+				 dc_size(B_N_CHILD
+					 (PATH_H_PBUFFER(tb->tb_path, 1),
+					  PATH_H_POSITION(tb->tb_path, 1))),
+				 right);
+		reiserfs_panic(tb->tb_sb,
+			       "PAP-12365: check_after_balance_leaf: S is incorrect");
+	}
 }
 
-static void check_internal_levels (struct tree_balance * tb)
+static void check_leaf_level(struct tree_balance *tb)
 {
-  int h;
+	check_leaf(tb->L[0]);
+	check_leaf(tb->R[0]);
+	check_leaf(PATH_PLAST_BUFFER(tb->tb_path));
+}
 
-  /* check all internal nodes */
-  for (h = 1; tb->insert_size[h]; h ++) {
-    check_internal_node (tb->tb_sb, PATH_H_PBUFFER (tb->tb_path, h), "BAD BUFFER ON PATH");
-    if (tb->lnum[h])
-      check_internal_node (tb->tb_sb, tb->L[h], "BAD L");
-    if (tb->rnum[h])
-      check_internal_node (tb->tb_sb, tb->R[h], "BAD R");
-  }
+static void check_internal_levels(struct tree_balance *tb)
+{
+	int h;
+
+	/* check all internal nodes */
+	for (h = 1; tb->insert_size[h]; h++) {
+		check_internal_node(tb->tb_sb, PATH_H_PBUFFER(tb->tb_path, h),
+				    "BAD BUFFER ON PATH");
+		if (tb->lnum[h])
+			check_internal_node(tb->tb_sb, tb->L[h], "BAD L");
+		if (tb->rnum[h])
+			check_internal_node(tb->tb_sb, tb->R[h], "BAD R");
+	}
 
 }
 
 #endif
 
-
-
-
-
-
 /* Now we have all of the buffers that must be used in balancing of
    the tree.  We rely on the assumption that schedule() will not occur
    while do_balance works. ( Only interrupt handlers are acceptable.)
@@ -1484,114 +2029,109 @@ static void check_internal_levels (struct tree_balance * tb)
 
 */
 
-static inline void do_balance_starts (struct tree_balance *tb)
+static inline void do_balance_starts(struct tree_balance *tb)
 {
-    /* use print_cur_tb() to see initial state of struct
-       tree_balance */
+	/* use print_cur_tb() to see initial state of struct
+	   tree_balance */
 
-    /* store_print_tb (tb); */
+	/* store_print_tb (tb); */
 
-    /* do not delete, just comment it out */
+	/* do not delete, just comment it out */
 /*    print_tb(flag, PATH_LAST_POSITION(tb->tb_path), tb->tb_path->pos_in_item, tb, 
 	     "check");*/
-    RFALSE( check_before_balancing (tb), "PAP-12340: locked buffers in TB");
+	RFALSE(check_before_balancing(tb), "PAP-12340: locked buffers in TB");
 #ifdef CONFIG_REISERFS_CHECK
-    cur_tb = tb;
+	cur_tb = tb;
 #endif
 }
 
-
-static inline void do_balance_completed (struct tree_balance * tb)
+static inline void do_balance_completed(struct tree_balance *tb)
 {
-    
+
 #ifdef CONFIG_REISERFS_CHECK
-    check_leaf_level (tb);
-    check_internal_levels (tb);
-    cur_tb = NULL;
+	check_leaf_level(tb);
+	check_internal_levels(tb);
+	cur_tb = NULL;
 #endif
 
-    /* reiserfs_free_block is no longer schedule safe.  So, we need to
-    ** put the buffers we want freed on the thrown list during do_balance,
-    ** and then free them now
-    */
-
-    REISERFS_SB(tb->tb_sb)->s_do_balance ++;
+	/* reiserfs_free_block is no longer schedule safe.  So, we need to
+	 ** put the buffers we want freed on the thrown list during do_balance,
+	 ** and then free them now
+	 */
 
+	REISERFS_SB(tb->tb_sb)->s_do_balance++;
 
-    /* release all nodes hold to perform the balancing */
-    unfix_nodes(tb);
+	/* release all nodes hold to perform the balancing */
+	unfix_nodes(tb);
 
-    free_thrown(tb) ;
+	free_thrown(tb);
 }
 
+void do_balance(struct tree_balance *tb,	/* tree_balance structure */
+		struct item_head *ih,	/* item header of inserted item */
+		const char *body,	/* body  of inserted item or bytes to paste */
+		int flag)
+{				/* i - insert, d - delete
+				   c - cut, p - paste
+
+				   Cut means delete part of an item
+				   (includes removing an entry from a
+				   directory).
+
+				   Delete means delete whole item.
+
+				   Insert means add a new item into the
+				   tree.
+
+				   Paste means to append to the end of an
+				   existing file or to insert a directory
+				   entry.  */
+	int child_pos,		/* position of a child node in its parent */
+	 h;			/* level of the tree being processed */
+	struct item_head insert_key[2];	/* in our processing of one level
+					   we sometimes determine what
+					   must be inserted into the next
+					   higher level.  This insertion
+					   consists of a key or two keys
+					   and their corresponding
+					   pointers */
+	struct buffer_head *insert_ptr[2];	/* inserted node-ptrs for the next
+						   level */
+
+	tb->tb_mode = flag;
+	tb->need_balance_dirty = 0;
+
+	if (FILESYSTEM_CHANGED_TB(tb)) {
+		reiserfs_panic(tb->tb_sb,
+			       "clm-6000: do_balance, fs generation has changed\n");
+	}
+	/* if we have no real work to do  */
+	if (!tb->insert_size[0]) {
+		reiserfs_warning(tb->tb_sb,
+				 "PAP-12350: do_balance: insert_size == 0, mode == %c",
+				 flag);
+		unfix_nodes(tb);
+		return;
+	}
 
+	atomic_inc(&(fs_generation(tb->tb_sb)));
+	do_balance_starts(tb);
 
-
-
-void do_balance (struct tree_balance * tb, /* tree_balance structure */
-		 struct item_head * ih,	   /* item header of inserted item */
-		 const char * body,  /* body  of inserted item or bytes to paste */
-		 int flag)  /* i - insert, d - delete
-			       c - cut, p - paste
-						      
-			       Cut means delete part of an item
-			       (includes removing an entry from a
-			       directory).
-						      
-			       Delete means delete whole item.
-						      
-			       Insert means add a new item into the
-			       tree.
-						      						      
-			       Paste means to append to the end of an
-			       existing file or to insert a directory
-			       entry.  */
-{
-    int child_pos, /* position of a child node in its parent */
-	h;	   /* level of the tree being processed */
-    struct item_head insert_key[2]; /* in our processing of one level
-				       we sometimes determine what
-				       must be inserted into the next
-				       higher level.  This insertion
-				       consists of a key or two keys
-				       and their corresponding
-				       pointers */
-    struct buffer_head *insert_ptr[2]; /* inserted node-ptrs for the next
-					  level */
-
-    tb->tb_mode = flag;
-    tb->need_balance_dirty = 0;
-
-    if (FILESYSTEM_CHANGED_TB(tb)) {
-        reiserfs_panic(tb->tb_sb, "clm-6000: do_balance, fs generation has changed\n") ;
-    }
-    /* if we have no real work to do  */
-    if ( ! tb->insert_size[0] ) {
-	reiserfs_warning (tb->tb_sb,
-			  "PAP-12350: do_balance: insert_size == 0, mode == %c",
-			  flag);
-	unfix_nodes(tb);
-	return;
-    }
-
-    atomic_inc (&(fs_generation (tb->tb_sb)));
-    do_balance_starts (tb);
-    
 	/* balance leaf returns 0 except if combining L R and S into
 	   one node.  see balance_internal() for explanation of this
-	   line of code.*/
-	child_pos = PATH_H_B_ITEM_ORDER (tb->tb_path, 0) +
-	  balance_leaf (tb, ih, body, flag, insert_key, insert_ptr);
+	   line of code. */
+	child_pos = PATH_H_B_ITEM_ORDER(tb->tb_path, 0) +
+	    balance_leaf(tb, ih, body, flag, insert_key, insert_ptr);
 
 #ifdef CONFIG_REISERFS_CHECK
-    check_after_balance_leaf (tb);
+	check_after_balance_leaf(tb);
 #endif
 
-    /* Balance internal level of the tree. */
-    for ( h = 1; h < MAX_HEIGHT && tb->insert_size[h]; h++ )
-	child_pos = balance_internal (tb, h, child_pos, insert_key, insert_ptr);
-
+	/* Balance internal level of the tree. */
+	for (h = 1; h < MAX_HEIGHT && tb->insert_size[h]; h++)
+		child_pos =
+		    balance_internal(tb, h, child_pos, insert_key, insert_ptr);
 
-    do_balance_completed (tb);
+	do_balance_completed(tb);
 
 }

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/fs/reiserfs/do_balan.c b/fs/reiserfs/do_balan.c
new file mode 100644
index 000000000000..2118db2896c7
--- /dev/null
+++ b/fs/reiserfs/do_balan.c
@@ -0,0 +1,1597 @@
+/*
+ * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ */
+
+/* Now we have all buffers that must be used in balancing of the tree 	*/
+/* Further calculations can not cause schedule(), and thus the buffer 	*/
+/* tree will be stable until the balancing will be finished 		*/
+/* balance the tree according to the analysis made before,		*/
+/* and using buffers obtained after all above.				*/
+
+
+/**
+ ** balance_leaf_when_delete
+ ** balance_leaf
+ ** do_balance
+ **
+ **/
+
+#include <linux/config.h>
+#include <asm/uaccess.h>
+#include <linux/time.h>
+#include <linux/reiserfs_fs.h>
+#include <linux/buffer_head.h>
+
+#ifdef CONFIG_REISERFS_CHECK
+
+struct tree_balance * cur_tb = NULL; /* detects whether more than one
+                                        copy of tb exists as a means
+                                        of checking whether schedule
+                                        is interrupting do_balance */
+#endif
+
+inline void do_balance_mark_leaf_dirty (struct tree_balance * tb, 
+					struct buffer_head * bh, int flag)
+{
+    journal_mark_dirty(tb->transaction_handle,
+                       tb->transaction_handle->t_super, bh) ;
+}
+
+#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty
+#define do_balance_mark_sb_dirty do_balance_mark_leaf_dirty
+
+
+/* summary: 
+ if deleting something ( tb->insert_size[0] < 0 )
+   return(balance_leaf_when_delete()); (flag d handled here)
+ else
+   if lnum is larger than 0 we put items into the left node
+   if rnum is larger than 0 we put items into the right node
+   if snum1 is larger than 0 we put items into the new node s1
+   if snum2 is larger than 0 we put items into the new node s2 
+Note that all *num* count new items being created.
+
+It would be easier to read balance_leaf() if each of these summary
+lines was a separate procedure rather than being inlined.  I think
+that there are many passages here and in balance_leaf_when_delete() in
+which two calls to one procedure can replace two passages, and it
+might save cache space and improve software maintenance costs to do so.  
+
+Vladimir made the perceptive comment that we should offload most of
+the decision making in this function into fix_nodes/check_balance, and
+then create some sort of structure in tb that says what actions should
+be performed by do_balance.
+
+-Hans */
+
+
+
+/* Balance leaf node in case of delete or cut: insert_size[0] < 0
+ *
+ * lnum, rnum can have values >= -1
+ *	-1 means that the neighbor must be joined with S
+ *	 0 means that nothing should be done with the neighbor
+ *	>0 means to shift entirely or partly the specified number of items to the neighbor
+ */
+static int balance_leaf_when_delete (struct tree_balance * tb, int flag)
+{
+    struct buffer_head * tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+    int item_pos = PATH_LAST_POSITION (tb->tb_path);
+    int pos_in_item = tb->tb_path->pos_in_item;
+    struct buffer_info bi;
+    int n;
+    struct item_head * ih;
+
+    RFALSE( tb->FR[0] && B_LEVEL (tb->FR[0]) != DISK_LEAF_NODE_LEVEL + 1,
+	    "vs- 12000: level: wrong FR %z", tb->FR[0]);
+    RFALSE( tb->blknum[0] > 1,
+	    "PAP-12005: tb->blknum == %d, can not be > 1", tb->blknum[0]);
+    RFALSE( ! tb->blknum[0] && ! PATH_H_PPARENT(tb->tb_path, 0),
+	    "PAP-12010: tree can not be empty");
+
+    ih = B_N_PITEM_HEAD (tbS0, item_pos);
+
+    /* Delete or truncate the item */
+
+    switch (flag) {
+    case M_DELETE:   /* delete item in S[0] */
+
+	RFALSE( ih_item_len(ih) + IH_SIZE != -tb->insert_size[0],
+	        "vs-12013: mode Delete, insert size %d, ih to be deleted %h",
+ 		 -tb->insert_size [0], ih);
+
+	bi.tb = tb;
+	bi.bi_bh = tbS0;
+	bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
+	bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
+	leaf_delete_items (&bi, 0, item_pos, 1, -1);
+
+	if ( ! item_pos && tb->CFL[0] ) {
+	    if ( B_NR_ITEMS(tbS0) ) {
+		replace_key(tb, tb->CFL[0],tb->lkey[0],tbS0,0);
+	    }
+	    else {
+		if ( ! PATH_H_POSITION (tb->tb_path, 1) )
+		    replace_key(tb, tb->CFL[0],tb->lkey[0],PATH_H_PPARENT(tb->tb_path, 0),0);
+	    }
+	} 
+
+	RFALSE( ! item_pos && !tb->CFL[0],
+		"PAP-12020: tb->CFL[0]==%p, tb->L[0]==%p", tb->CFL[0], tb->L[0]);
+    
+	break;
+
+    case M_CUT: {  /* cut item in S[0] */
+	bi.tb = tb;
+	bi.bi_bh = tbS0;
+	bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
+	bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
+	if (is_direntry_le_ih (ih)) {
+
+	    /* UFS unlink semantics are such that you can only delete one directory entry at a time. */
+	    /* when we cut a directory tb->insert_size[0] means number of entries to be cut (always 1) */
+	    tb->insert_size[0] = -1;
+	    leaf_cut_from_buffer (&bi, item_pos, pos_in_item, -tb->insert_size[0]);
+
+	    RFALSE( ! item_pos && ! pos_in_item && ! tb->CFL[0],
+		    "PAP-12030: can not change delimiting key. CFL[0]=%p", 
+		    tb->CFL[0]);
+
+	    if ( ! item_pos && ! pos_in_item && tb->CFL[0] ) {
+		replace_key(tb, tb->CFL[0],tb->lkey[0],tbS0,0);
+	    }
+	} else {
+	    leaf_cut_from_buffer (&bi, item_pos, pos_in_item, -tb->insert_size[0]);
+
+	    RFALSE( ! ih_item_len(ih),
+		"PAP-12035: cut must leave non-zero dynamic length of item");
+	}
+	break;
+    }
+
+    default:
+	print_cur_tb ("12040");
+	reiserfs_panic (tb->tb_sb, "PAP-12040: balance_leaf_when_delete: unexpectable mode: %s(%d)",
+			(flag == M_PASTE) ? "PASTE" : ((flag == M_INSERT) ? "INSERT" : "UNKNOWN"), flag);
+    }
+
+    /* the rule is that no shifting occurs unless by shifting a node can be freed */
+    n = B_NR_ITEMS(tbS0);
+    if ( tb->lnum[0] )     /* L[0] takes part in balancing */
+    {
+	if ( tb->lnum[0] == -1 )    /* L[0] must be joined with S[0] */
+	{
+	    if ( tb->rnum[0] == -1 )    /* R[0] must be also joined with S[0] */
+	    {			
+		if ( tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0) )
+		{
+		    /* all contents of all the 3 buffers will be in L[0] */
+		    if ( PATH_H_POSITION (tb->tb_path, 1) == 0 && 1 < B_NR_ITEMS(tb->FR[0]) )
+			replace_key(tb, tb->CFL[0],tb->lkey[0],tb->FR[0],1);
+
+		    leaf_move_items (LEAF_FROM_S_TO_L, tb, n, -1, NULL);
+		    leaf_move_items (LEAF_FROM_R_TO_L, tb, B_NR_ITEMS(tb->R[0]), -1, NULL);
+
+		    reiserfs_invalidate_buffer (tb, tbS0);
+		    reiserfs_invalidate_buffer (tb, tb->R[0]);
+
+		    return 0;
+		}
+		/* all contents of all the 3 buffers will be in R[0] */
+		leaf_move_items (LEAF_FROM_S_TO_R, tb, n, -1, NULL);
+		leaf_move_items (LEAF_FROM_L_TO_R, tb, B_NR_ITEMS(tb->L[0]), -1, NULL);
+
+		/* right_delimiting_key is correct in R[0] */
+		replace_key(tb, tb->CFR[0],tb->rkey[0],tb->R[0],0);
+
+		reiserfs_invalidate_buffer (tb, tbS0);
+		reiserfs_invalidate_buffer (tb, tb->L[0]);
+
+		return -1;
+	    }
+
+	    RFALSE( tb->rnum[0] != 0, 
+		    "PAP-12045: rnum must be 0 (%d)", tb->rnum[0]);
+	    /* all contents of L[0] and S[0] will be in L[0] */
+	    leaf_shift_left(tb, n, -1);
+
+	    reiserfs_invalidate_buffer (tb, tbS0);
+
+	    return 0;
+	}
+	/* a part of contents of S[0] will be in L[0] and the rest part of S[0] will be in R[0] */
+
+	RFALSE( ( tb->lnum[0] + tb->rnum[0] < n ) || 
+		( tb->lnum[0] + tb->rnum[0] > n+1 ),
+		"PAP-12050: rnum(%d) and lnum(%d) and item number(%d) in S[0] are not consistent",
+		tb->rnum[0], tb->lnum[0], n);
+	RFALSE( ( tb->lnum[0] + tb->rnum[0] == n ) && 
+		(tb->lbytes != -1 || tb->rbytes != -1),
+		"PAP-12055: bad rbytes (%d)/lbytes (%d) parameters when items are not split", 
+		tb->rbytes, tb->lbytes);
+	RFALSE( ( tb->lnum[0] + tb->rnum[0] == n + 1 ) && 
+		(tb->lbytes < 1 || tb->rbytes != -1),
+		"PAP-12060: bad rbytes (%d)/lbytes (%d) parameters when items are split", 
+		tb->rbytes, tb->lbytes);
+
+	leaf_shift_left (tb, tb->lnum[0], tb->lbytes);
+	leaf_shift_right(tb, tb->rnum[0], tb->rbytes);
+
+	reiserfs_invalidate_buffer (tb, tbS0);
+
+	return 0;
+    }
+
+    if ( tb->rnum[0] == -1 ) {
+	/* all contents of R[0] and S[0] will be in R[0] */
+	leaf_shift_right(tb, n, -1);
+	reiserfs_invalidate_buffer (tb, tbS0);
+	return 0;
+    }
+
+    RFALSE( tb->rnum[0], 
+	    "PAP-12065: bad rnum parameter must be 0 (%d)", tb->rnum[0]);
+    return 0;
+}
+
+
+static int balance_leaf (struct tree_balance * tb,
+			 struct item_head * ih,		/* item header of inserted item (this is on little endian) */
+			 const char * body,		/* body  of inserted item or bytes to paste */
+			 int flag,			/* i - insert, d - delete, c - cut, p - paste
+							   (see comment to do_balance) */
+			 struct item_head * insert_key,  /* in our processing of one level we sometimes determine what
+							    must be inserted into the next higher level.  This insertion
+							    consists of a key or two keys and their corresponding
+							    pointers */
+			 struct buffer_head ** insert_ptr /* inserted node-ptrs for the next level */
+    )
+{
+    struct buffer_head * tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+    int item_pos = PATH_LAST_POSITION (tb->tb_path);	/*  index into the array of item headers in S[0] 
+							    of the affected item */
+    struct buffer_info bi;
+    struct buffer_head *S_new[2];  /* new nodes allocated to hold what could not fit into S */
+    int snum[2];	    /* number of items that will be placed
+                               into S_new (includes partially shifted
+                               items) */
+    int sbytes[2];          /* if an item is partially shifted into S_new then 
+			       if it is a directory item 
+			       it is the number of entries from the item that are shifted into S_new
+			       else
+			       it is the number of bytes from the item that are shifted into S_new
+			    */
+    int n, i;
+    int ret_val;
+    int pos_in_item;
+    int zeros_num;
+
+    PROC_INFO_INC( tb -> tb_sb, balance_at[ 0 ] );
+
+    /* Make balance in case insert_size[0] < 0 */
+    if ( tb->insert_size[0] < 0 )
+	return balance_leaf_when_delete (tb, flag);
+  
+    zeros_num = 0;
+    if (flag == M_INSERT && body == 0)
+	zeros_num = ih_item_len( ih );
+
+    pos_in_item = tb->tb_path->pos_in_item;
+    /* for indirect item pos_in_item is measured in unformatted node
+       pointers. Recalculate to bytes */
+    if (flag != M_INSERT && is_indirect_le_ih (B_N_PITEM_HEAD (tbS0, item_pos)))
+	pos_in_item *= UNFM_P_SIZE;
+
+    if ( tb->lnum[0] > 0 ) {
+	/* Shift lnum[0] items from S[0] to the left neighbor L[0] */
+	if ( item_pos < tb->lnum[0] ) {
+	    /* new item or it part falls to L[0], shift it too */
+	    n = B_NR_ITEMS(tb->L[0]);
+
+	    switch (flag) {
+	    case M_INSERT:   /* insert item into L[0] */
+
+		if ( item_pos == tb->lnum[0] - 1 && tb->lbytes != -1 ) {
+		    /* part of new item falls into L[0] */
+		    int new_item_len;
+		    int version;
+
+		    ret_val = leaf_shift_left (tb, tb->lnum[0]-1, -1);
+
+		    /* Calculate item length to insert to S[0] */
+		    new_item_len = ih_item_len(ih) - tb->lbytes;
+		    /* Calculate and check item length to insert to L[0] */
+		    put_ih_item_len(ih, ih_item_len(ih) - new_item_len );
+
+		    RFALSE( ih_item_len(ih) <= 0,
+			    "PAP-12080: there is nothing to insert into L[0]: ih_item_len=%d",
+                            ih_item_len(ih));
+
+		    /* Insert new item into L[0] */
+		    bi.tb = tb;
+		    bi.bi_bh = tb->L[0];
+		    bi.bi_parent = tb->FL[0];
+		    bi.bi_position = get_left_neighbor_position (tb, 0);
+		    leaf_insert_into_buf (&bi, n + item_pos - ret_val, ih, body,
+					  zeros_num > ih_item_len(ih) ? ih_item_len(ih) : zeros_num);
+
+		    version = ih_version (ih);
+
+		    /* Calculate key component, item length and body to insert into S[0] */
+                    set_le_ih_k_offset( ih, le_ih_k_offset( ih ) + (tb->lbytes << (is_indirect_le_ih(ih)?tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT:0)) );
+
+		    put_ih_item_len( ih, new_item_len );
+		    if ( tb->lbytes >  zeros_num ) {
+			body += (tb->lbytes - zeros_num);
+			zeros_num = 0;
+		    }
+		    else
+			zeros_num -= tb->lbytes;
+
+		    RFALSE( ih_item_len(ih) <= 0,
+			"PAP-12085: there is nothing to insert into S[0]: ih_item_len=%d",
+			ih_item_len(ih));
+		} else {
+		    /* new item in whole falls into L[0] */
+		    /* Shift lnum[0]-1 items to L[0] */
+		    ret_val = leaf_shift_left(tb, tb->lnum[0]-1, tb->lbytes);
+		    /* Insert new item into L[0] */
+		    bi.tb = tb;
+		    bi.bi_bh = tb->L[0];
+		    bi.bi_parent = tb->FL[0];
+		    bi.bi_position = get_left_neighbor_position (tb, 0);
+		    leaf_insert_into_buf (&bi, n + item_pos - ret_val, ih, body, zeros_num);
+		    tb->insert_size[0] = 0;
+		    zeros_num = 0;
+		}
+		break;
+
+	    case M_PASTE:   /* append item in L[0] */
+
+		if ( item_pos == tb->lnum[0] - 1 && tb->lbytes != -1 ) {
+		    /* we must shift the part of the appended item */
+		    if ( is_direntry_le_ih (B_N_PITEM_HEAD (tbS0, item_pos))) {
+
+			RFALSE( zeros_num,
+				"PAP-12090: invalid parameter in case of a directory");
+			/* directory item */
+			if ( tb->lbytes > pos_in_item ) {
+			    /* new directory entry falls into L[0] */
+			    struct item_head * pasted;
+			    int l_pos_in_item = pos_in_item;
+							  
+			    /* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 entries from given directory item */
+			    ret_val = leaf_shift_left(tb, tb->lnum[0], tb->lbytes - 1);
+			    if ( ret_val && ! item_pos ) {
+				pasted =  B_N_PITEM_HEAD(tb->L[0],B_NR_ITEMS(tb->L[0])-1);
+				l_pos_in_item += I_ENTRY_COUNT(pasted) - (tb->lbytes-1);
+			    }
+
+			    /* Append given directory entry to directory item */
+			    bi.tb = tb;
+			    bi.bi_bh = tb->L[0];
+			    bi.bi_parent = tb->FL[0];
+			    bi.bi_position = get_left_neighbor_position (tb, 0);
+			    leaf_paste_in_buffer (&bi, n + item_pos - ret_val, l_pos_in_item,
+						  tb->insert_size[0], body, zeros_num);
+
+			    /* previous string prepared space for pasting new entry, following string pastes this entry */
+
+			    /* when we have merge directory item, pos_in_item has been changed too */
+
+			    /* paste new directory entry. 1 is entry number */
+			    leaf_paste_entries (bi.bi_bh, n + item_pos - ret_val, l_pos_in_item, 1,
+						(struct reiserfs_de_head *)body, 
+						body + DEH_SIZE, tb->insert_size[0]
+				);
+			    tb->insert_size[0] = 0;
+			} else {
+			    /* new directory item doesn't fall into L[0] */
+			    /* Shift lnum[0]-1 items in whole. Shift lbytes directory entries from directory item number lnum[0] */
+			    leaf_shift_left (tb, tb->lnum[0], tb->lbytes);
+			}
+			/* Calculate new position to append in item body */
+			pos_in_item -= tb->lbytes;
+		    }
+		    else {
+			/* regular object */
+			RFALSE( tb->lbytes <= 0,
+			        "PAP-12095: there is nothing to shift to L[0]. lbytes=%d",
+				tb->lbytes);
+			RFALSE( pos_in_item != ih_item_len(B_N_PITEM_HEAD(tbS0, item_pos)),
+                                "PAP-12100: incorrect position to paste: item_len=%d, pos_in_item=%d",
+				ih_item_len(B_N_PITEM_HEAD(tbS0,item_pos)), pos_in_item);
+
+			if ( tb->lbytes >= pos_in_item ) {
+			    /* appended item will be in L[0] in whole */
+			    int l_n;
+
+			    /* this bytes number must be appended to the last item of L[h] */
+			    l_n = tb->lbytes - pos_in_item;
+
+			    /* Calculate new insert_size[0] */
+			    tb->insert_size[0] -= l_n;
+
+			    RFALSE( tb->insert_size[0] <= 0,
+				    "PAP-12105: there is nothing to paste into L[0]. insert_size=%d",
+				    tb->insert_size[0]);
+			    ret_val =  leaf_shift_left(tb,tb->lnum[0], 
+						       ih_item_len(B_N_PITEM_HEAD(tbS0,item_pos)));
+			    /* Append to body of item in L[0] */
+			    bi.tb = tb;
+			    bi.bi_bh = tb->L[0];
+			    bi.bi_parent = tb->FL[0];
+			    bi.bi_position = get_left_neighbor_position (tb, 0);
+			    leaf_paste_in_buffer(
+				&bi,n + item_pos - ret_val,
+				ih_item_len( B_N_PITEM_HEAD(tb->L[0],n+item_pos-ret_val)),
+				l_n,body, zeros_num > l_n ? l_n : zeros_num
+				);
+			    /* 0-th item in S0 can be only of DIRECT type when l_n != 0*/
+			    {
+				int version;
+				int temp_l = l_n;
+				
+				RFALSE (ih_item_len (B_N_PITEM_HEAD (tbS0, 0)),
+					"PAP-12106: item length must be 0");
+				RFALSE (comp_short_le_keys (B_N_PKEY (tbS0, 0),
+							    B_N_PKEY (tb->L[0],
+									    n + item_pos - ret_val)),
+					"PAP-12107: items must be of the same file");
+				if (is_indirect_le_ih(B_N_PITEM_HEAD (tb->L[0],
+								      n + item_pos - ret_val)))	{
+				    temp_l = l_n << (tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT);
+				}
+				/* update key of first item in S0 */
+				version = ih_version (B_N_PITEM_HEAD (tbS0, 0));
+				set_le_key_k_offset (version, B_N_PKEY (tbS0, 0), 
+						     le_key_k_offset (version, B_N_PKEY (tbS0, 0)) + temp_l);
+				/* update left delimiting key */
+				set_le_key_k_offset (version, B_N_PDELIM_KEY(tb->CFL[0],tb->lkey[0]),
+						     le_key_k_offset (version, B_N_PDELIM_KEY(tb->CFL[0],tb->lkey[0])) + temp_l);
+			    }
+
+			    /* Calculate new body, position in item and insert_size[0] */
+			    if ( l_n > zeros_num ) {
+				body += (l_n - zeros_num);
+				zeros_num = 0;
+			    }
+			    else
+				zeros_num -= l_n;
+			    pos_in_item = 0;	
+
+			    RFALSE( comp_short_le_keys 
+				    (B_N_PKEY(tbS0,0),
+				     B_N_PKEY(tb->L[0],B_NR_ITEMS(tb->L[0])-1)) ||
+				
+				    !op_is_left_mergeable 
+				    (B_N_PKEY (tbS0, 0), tbS0->b_size) ||
+				    !op_is_left_mergeable
+				    (B_N_PDELIM_KEY(tb->CFL[0],tb->lkey[0]), 
+				     tbS0->b_size),
+				    "PAP-12120: item must be merge-able with left neighboring item");
+			}
+			else /* only part of the appended item will be in L[0] */
+			{
+			    /* Calculate position in item for append in S[0] */
+			    pos_in_item -= tb->lbytes;
+
+			    RFALSE( pos_in_item <= 0,
+				    "PAP-12125: no place for paste. pos_in_item=%d", pos_in_item);
+
+			    /* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
+			    leaf_shift_left(tb,tb->lnum[0],tb->lbytes);
+			}
+		    }
+		}
+		else /* appended item will be in L[0] in whole */
+		{
+		    struct item_head * pasted;
+
+			if ( ! item_pos  && op_is_left_mergeable (B_N_PKEY (tbS0, 0), tbS0->b_size) )
+			{ /* if we paste into first item of S[0] and it is left mergable */
+			    /* then increment pos_in_item by the size of the last item in L[0] */
+			    pasted = B_N_PITEM_HEAD(tb->L[0],n-1);
+			    if ( is_direntry_le_ih (pasted) )
+				pos_in_item += ih_entry_count(pasted);
+			    else
+				pos_in_item += ih_item_len(pasted);
+			}
+
+		    /* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
+		    ret_val = leaf_shift_left(tb,tb->lnum[0],tb->lbytes);
+		    /* Append to body of item in L[0] */
+		    bi.tb = tb;
+		    bi.bi_bh = tb->L[0];
+		    bi.bi_parent = tb->FL[0];
+		    bi.bi_position = get_left_neighbor_position (tb, 0);
+		    leaf_paste_in_buffer (&bi, n + item_pos - ret_val, pos_in_item, tb->insert_size[0],
+					  body, zeros_num);
+
+		    /* if appended item is directory, paste entry */
+		    pasted = B_N_PITEM_HEAD (tb->L[0], n + item_pos - ret_val);
+		    if (is_direntry_le_ih (pasted))
+			leaf_paste_entries (
+			    bi.bi_bh, n + item_pos - ret_val, pos_in_item, 1, 
+			    (struct reiserfs_de_head *)body, body + DEH_SIZE, tb->insert_size[0]
+			    );
+		    /* if appended item is indirect item, put unformatted node into un list */
+		    if (is_indirect_le_ih (pasted))
+			set_ih_free_space (pasted, 0);
+		    tb->insert_size[0] = 0;
+		    zeros_num = 0;
+		}
+		break;
+	    default:    /* cases d and t */
+		reiserfs_panic (tb->tb_sb, "PAP-12130: balance_leaf: lnum > 0: unexpectable mode: %s(%d)",
+				(flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
+	    }
+	} else { 
+	    /* new item doesn't fall into L[0] */
+	    leaf_shift_left(tb,tb->lnum[0],tb->lbytes);
+	}
+    }	/* tb->lnum[0] > 0 */
+
+    /* Calculate new item position */
+    item_pos -= ( tb->lnum[0] - (( tb->lbytes != -1 ) ? 1 : 0));
+
+    if ( tb->rnum[0] > 0 ) {
+	/* shift rnum[0] items from S[0] to the right neighbor R[0] */
+	n = B_NR_ITEMS(tbS0);
+	switch ( flag ) {
+
+	case M_INSERT:   /* insert item */
+	    if ( n - tb->rnum[0] < item_pos )
+	    { /* new item or its part falls to R[0] */
+		if ( item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1 )
+		{ /* part of new item falls into R[0] */
+		    loff_t old_key_comp, old_len, r_zeros_number;
+		    const char * r_body;
+		    int version;
+		    loff_t offset;
+
+		    leaf_shift_right(tb,tb->rnum[0]-1,-1);
+
+		    version = ih_version(ih);
+		    /* Remember key component and item length */
+                    old_key_comp = le_ih_k_offset( ih );
+		    old_len = ih_item_len(ih);
+
+		    /* Calculate key component and item length to insert into R[0] */
+                    offset = le_ih_k_offset( ih ) + ((old_len - tb->rbytes )<<(is_indirect_le_ih(ih)?tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT:0));
+                    set_le_ih_k_offset( ih, offset );
+		    put_ih_item_len( ih, tb->rbytes);
+		    /* Insert part of the item into R[0] */
+		    bi.tb = tb;
+		    bi.bi_bh = tb->R[0];
+		    bi.bi_parent = tb->FR[0];
+		    bi.bi_position = get_right_neighbor_position (tb, 0);
+		    if ( (old_len - tb->rbytes) > zeros_num ) {
+			r_zeros_number = 0;
+			r_body = body + (old_len - tb->rbytes) - zeros_num;
+		    }
+		    else {
+			r_body = body;
+			r_zeros_number = zeros_num - (old_len - tb->rbytes);
+			zeros_num -= r_zeros_number;
+		    }
+
+		    leaf_insert_into_buf (&bi, 0, ih, r_body, r_zeros_number);
+
+		    /* Replace right delimiting key by first key in R[0] */
+		    replace_key(tb, tb->CFR[0],tb->rkey[0],tb->R[0],0);
+
+		    /* Calculate key component and item length to insert into S[0] */
+                    set_le_ih_k_offset( ih, old_key_comp );
+		    put_ih_item_len( ih, old_len - tb->rbytes );
+
+		    tb->insert_size[0] -= tb->rbytes;
+
+		}
+		else /* whole new item falls into R[0] */
+		{					  
+		    /* Shift rnum[0]-1 items to R[0] */
+		    ret_val = leaf_shift_right(tb,tb->rnum[0]-1,tb->rbytes);
+		    /* Insert new item into R[0] */
+		    bi.tb = tb;
+		    bi.bi_bh = tb->R[0];
+		    bi.bi_parent = tb->FR[0];
+		    bi.bi_position = get_right_neighbor_position (tb, 0);
+		    leaf_insert_into_buf (&bi, item_pos - n + tb->rnum[0] - 1, ih, body, zeros_num);
+
+		    if ( item_pos - n + tb->rnum[0] - 1 == 0 ) {
+			replace_key(tb, tb->CFR[0],tb->rkey[0],tb->R[0],0);
+
+		    }
+		    zeros_num = tb->insert_size[0] = 0;
+		}
+	    }
+	    else /* new item or part of it doesn't fall into R[0] */
+	    {
+		leaf_shift_right(tb,tb->rnum[0],tb->rbytes);
+	    }
+	    break;
+
+	case M_PASTE:   /* append item */
+
+	    if ( n - tb->rnum[0] <= item_pos )  /* pasted item or part of it falls to R[0] */
+	    {
+		if ( item_pos == n - tb->rnum[0] && tb->rbytes != -1 )
+		{ /* we must shift the part of the appended item */
+		    if ( is_direntry_le_ih (B_N_PITEM_HEAD(tbS0, item_pos)))
+		    { /* we append to directory item */
+			int entry_count;
+
+			RFALSE( zeros_num,
+				"PAP-12145: invalid parameter in case of a directory");
+			entry_count = I_ENTRY_COUNT(B_N_PITEM_HEAD(tbS0, item_pos));
+			if ( entry_count - tb->rbytes < pos_in_item )
+			    /* new directory entry falls into R[0] */
+			{
+			    int paste_entry_position;
+
+			    RFALSE( tb->rbytes - 1 >= entry_count || 
+				    ! tb->insert_size[0],
+				    "PAP-12150: no enough of entries to shift to R[0]: rbytes=%d, entry_count=%d",
+				    tb->rbytes, entry_count);
+			    /* Shift rnum[0]-1 items in whole. Shift rbytes-1 directory entries from directory item number rnum[0] */
+			    leaf_shift_right(tb,tb->rnum[0],tb->rbytes - 1);
+			    /* Paste given directory entry to directory item */
+			    paste_entry_position = pos_in_item - entry_count + tb->rbytes - 1;
+			    bi.tb = tb;
+			    bi.bi_bh = tb->R[0];
+			    bi.bi_parent = tb->FR[0];
+			    bi.bi_position = get_right_neighbor_position (tb, 0);
+			    leaf_paste_in_buffer (&bi, 0, paste_entry_position,
+						  tb->insert_size[0],body,zeros_num);
+			    /* paste entry */
+			    leaf_paste_entries (
+				bi.bi_bh, 0, paste_entry_position, 1, (struct reiserfs_de_head *)body, 
+				body + DEH_SIZE, tb->insert_size[0]
+				);								
+						
+			    if ( paste_entry_position == 0 ) {
+				/* change delimiting keys */
+				replace_key(tb, tb->CFR[0],tb->rkey[0],tb->R[0],0);
+			    }
+
+			    tb->insert_size[0] = 0;
+			    pos_in_item++;
+			}
+			else /* new directory entry doesn't fall into R[0] */
+			{
+			    leaf_shift_right(tb,tb->rnum[0],tb->rbytes);
+			}
+		    }
+		    else /* regular object */
+		    {
+			int n_shift, n_rem, r_zeros_number;
+			const char * r_body;
+
+			/* Calculate number of bytes which must be shifted from appended item */
+			if ( (n_shift = tb->rbytes - tb->insert_size[0]) < 0 )
+			    n_shift = 0;
+
+			RFALSE(pos_in_item != ih_item_len(B_N_PITEM_HEAD (tbS0, item_pos)),
+			       "PAP-12155: invalid position to paste. ih_item_len=%d, pos_in_item=%d",
+                               pos_in_item, ih_item_len( B_N_PITEM_HEAD(tbS0,item_pos)));
+
+			leaf_shift_right(tb,tb->rnum[0],n_shift);
+			/* Calculate number of bytes which must remain in body after appending to R[0] */
+			if ( (n_rem = tb->insert_size[0] - tb->rbytes) < 0 )
+			    n_rem = 0;
+			
+			{
+			  int version;
+			  unsigned long temp_rem = n_rem;
+			  
+			  version = ih_version (B_N_PITEM_HEAD (tb->R[0],0));
+			  if (is_indirect_le_key(version,B_N_PKEY(tb->R[0],0))){
+			      temp_rem = n_rem << (tb->tb_sb->s_blocksize_bits -
+					 UNFM_P_SHIFT);
+			  }
+			  set_le_key_k_offset (version, B_N_PKEY(tb->R[0],0), 
+					       le_key_k_offset (version, B_N_PKEY(tb->R[0],0)) + temp_rem);
+			  set_le_key_k_offset (version, B_N_PDELIM_KEY(tb->CFR[0],tb->rkey[0]), 
+					       le_key_k_offset (version, B_N_PDELIM_KEY(tb->CFR[0],tb->rkey[0])) + temp_rem);
+			}
+/*		  k_offset (B_N_PKEY(tb->R[0],0)) += n_rem;
+		  k_offset (B_N_PDELIM_KEY(tb->CFR[0],tb->rkey[0])) += n_rem;*/
+			do_balance_mark_internal_dirty (tb, tb->CFR[0], 0);
+
+			/* Append part of body into R[0] */
+			bi.tb = tb;
+			bi.bi_bh = tb->R[0];
+			bi.bi_parent = tb->FR[0];
+			bi.bi_position = get_right_neighbor_position (tb, 0);
+			if ( n_rem > zeros_num ) {
+			    r_zeros_number = 0;
+			    r_body = body + n_rem - zeros_num;
+			}
+			else {
+			    r_body = body;
+			    r_zeros_number = zeros_num - n_rem;
+			    zeros_num -= r_zeros_number;
+			}
+
+			leaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem, r_body, r_zeros_number);
+
+			if (is_indirect_le_ih (B_N_PITEM_HEAD(tb->R[0],0))) {
+#if 0
+			    RFALSE( n_rem,
+				    "PAP-12160: paste more than one unformatted node pointer");
+#endif
+			    set_ih_free_space (B_N_PITEM_HEAD(tb->R[0],0), 0);
+			}
+			tb->insert_size[0] = n_rem;
+			if ( ! n_rem )
+			    pos_in_item ++;
+		    }
+		}
+		else /* pasted item in whole falls into R[0] */
+		{
+		    struct item_head * pasted;
+
+		    ret_val = leaf_shift_right(tb,tb->rnum[0],tb->rbytes);
+		    /* append item in R[0] */
+		    if ( pos_in_item >= 0 ) {
+			bi.tb = tb;
+			bi.bi_bh = tb->R[0];
+			bi.bi_parent = tb->FR[0];
+			bi.bi_position = get_right_neighbor_position (tb, 0);
+			leaf_paste_in_buffer(&bi,item_pos - n + tb->rnum[0], pos_in_item,
+					     tb->insert_size[0],body, zeros_num);
+		    }
+
+		    /* paste new entry, if item is directory item */
+		    pasted = B_N_PITEM_HEAD(tb->R[0], item_pos - n + tb->rnum[0]);
+		    if (is_direntry_le_ih (pasted) && pos_in_item >= 0 ) {
+			leaf_paste_entries (
+			    bi.bi_bh, item_pos - n + tb->rnum[0], pos_in_item, 1, 
+			    (struct reiserfs_de_head *)body, body + DEH_SIZE, tb->insert_size[0]
+			    );
+			if ( ! pos_in_item ) {
+
+			    RFALSE( item_pos - n + tb->rnum[0],
+				    "PAP-12165: directory item must be first item of node when pasting is in 0th position");
+
+			    /* update delimiting keys */
+			    replace_key(tb, tb->CFR[0],tb->rkey[0],tb->R[0],0);
+			}
+		    }
+
+		    if (is_indirect_le_ih (pasted))
+			set_ih_free_space (pasted, 0);
+		    zeros_num = tb->insert_size[0] = 0;
+		}
+	    }
+	    else /* new item doesn't fall into R[0] */
+	    {
+		leaf_shift_right(tb,tb->rnum[0],tb->rbytes);
+	    }
+	    break;
+	default:    /* cases d and t */
+	    reiserfs_panic (tb->tb_sb, "PAP-12175: balance_leaf: rnum > 0: unexpectable mode: %s(%d)",
+			    (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
+	}
+    
+    }	/* tb->rnum[0] > 0 */
+
+
+    RFALSE( tb->blknum[0] > 3,
+	    "PAP-12180: blknum can not be %d. It must be <= 3",  tb->blknum[0]);
+    RFALSE( tb->blknum[0] < 0,
+	    "PAP-12185: blknum can not be %d. It must be >= 0",  tb->blknum[0]);
+
+    /* if while adding to a node we discover that it is possible to split
+       it in two, and merge the left part into the left neighbor and the
+       right part into the right neighbor, eliminating the node */
+    if ( tb->blknum[0] == 0 ) { /* node S[0] is empty now */
+
+	RFALSE( ! tb->lnum[0] || ! tb->rnum[0],
+	        "PAP-12190: lnum and rnum must not be zero");
+	/* if insertion was done before 0-th position in R[0], right
+	   delimiting key of the tb->L[0]'s and left delimiting key are
+	   not set correctly */
+	if (tb->CFL[0]) {
+	    if (!tb->CFR[0])
+		reiserfs_panic (tb->tb_sb, "vs-12195: balance_leaf: CFR not initialized");
+	    copy_key (B_N_PDELIM_KEY (tb->CFL[0], tb->lkey[0]), B_N_PDELIM_KEY (tb->CFR[0], tb->rkey[0]));
+	    do_balance_mark_internal_dirty (tb, tb->CFL[0], 0);
+	}
+
+	reiserfs_invalidate_buffer(tb,tbS0);									
+	return 0;
+    }
+
+
+    /* Fill new nodes that appear in place of S[0] */
+
+    /* I am told that this copying is because we need an array to enable
+       the looping code. -Hans */
+    snum[0] = tb->s1num,
+	snum[1] = tb->s2num;
+    sbytes[0] = tb->s1bytes;
+    sbytes[1] = tb->s2bytes;
+    for( i = tb->blknum[0] - 2; i >= 0; i-- ) {
+
+	RFALSE( !snum[i], "PAP-12200: snum[%d] == %d. Must be > 0", i, snum[i]);
+
+	/* here we shift from S to S_new nodes */
+
+	S_new[i] = get_FEB(tb);
+
+	/* initialized block type and tree level */
+        set_blkh_level( B_BLK_HEAD(S_new[i]), DISK_LEAF_NODE_LEVEL );
+
+
+	n = B_NR_ITEMS(tbS0);
+	
+	switch (flag) {
+	case M_INSERT:   /* insert item */
+
+	    if ( n - snum[i] < item_pos )
+	    { /* new item or it's part falls to first new node S_new[i]*/
+		if ( item_pos == n - snum[i] + 1 && sbytes[i] != -1 )
+		{ /* part of new item falls into S_new[i] */
+		    int old_key_comp, old_len, r_zeros_number;
+		    const char * r_body;
+		    int version;
+
+		    /* Move snum[i]-1 items from S[0] to S_new[i] */
+		    leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i] - 1, -1, S_new[i]);
+		    /* Remember key component and item length */
+		    version = ih_version (ih);
+                    old_key_comp = le_ih_k_offset( ih );
+		    old_len = ih_item_len(ih);
+
+		    /* Calculate key component and item length to insert into S_new[i] */
+                    set_le_ih_k_offset( ih,
+                                le_ih_k_offset(ih) + ((old_len - sbytes[i] )<<(is_indirect_le_ih(ih)?tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT:0)) );
+
+		    put_ih_item_len( ih, sbytes[i] );
+
+		    /* Insert part of the item into S_new[i] before 0-th item */
+		    bi.tb = tb;
+		    bi.bi_bh = S_new[i];
+		    bi.bi_parent = NULL;
+		    bi.bi_position = 0;
+
+		    if ( (old_len - sbytes[i]) > zeros_num ) {
+			r_zeros_number = 0;
+			r_body = body + (old_len - sbytes[i]) - zeros_num;
+		    }
+		    else {
+			r_body = body;
+			r_zeros_number = zeros_num - (old_len - sbytes[i]);
+			zeros_num -= r_zeros_number;
+		    }
+
+		    leaf_insert_into_buf (&bi, 0, ih, r_body, r_zeros_number);
+
+		    /* Calculate key component and item length to insert into S[i] */
+                    set_le_ih_k_offset( ih, old_key_comp );
+		    put_ih_item_len( ih, old_len - sbytes[i] );
+		    tb->insert_size[0] -= sbytes[i];
+		}
+		else /* whole new item falls into S_new[i] */
+		{
+		    /* Shift snum[0] - 1 items to S_new[i] (sbytes[i] of split item) */
+		    leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i] - 1, sbytes[i], S_new[i]);
+
+		    /* Insert new item into S_new[i] */
+		    bi.tb = tb;
+		    bi.bi_bh = S_new[i];
+		    bi.bi_parent = NULL;
+		    bi.bi_position = 0;
+		    leaf_insert_into_buf (&bi, item_pos - n + snum[i] - 1, ih, body, zeros_num);
+
+		    zeros_num = tb->insert_size[0] = 0;
+		}
+	    }
+
+	    else /* new item or it part don't falls into S_new[i] */
+	    {
+		leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i], S_new[i]);
+	    }
+	    break;
+
+	case M_PASTE:   /* append item */
+
+	    if ( n - snum[i] <= item_pos )  /* pasted item or part if it falls to S_new[i] */
+	    {
+		if ( item_pos == n - snum[i] && sbytes[i] != -1 )
+		{ /* we must shift part of the appended item */
+		    struct item_head * aux_ih;
+
+		    RFALSE( ih, "PAP-12210: ih must be 0");
+
+		    if ( is_direntry_le_ih (aux_ih = B_N_PITEM_HEAD(tbS0,item_pos))) {
+			/* we append to directory item */
+
+			int entry_count;
+		
+			entry_count = ih_entry_count(aux_ih);
+
+			if ( entry_count - sbytes[i] < pos_in_item  && pos_in_item <= entry_count ) {
+			    /* new directory entry falls into S_new[i] */
+		  
+			    RFALSE( ! tb->insert_size[0],
+				    "PAP-12215: insert_size is already 0");
+			    RFALSE( sbytes[i] - 1 >= entry_count,
+				    "PAP-12220: there are no so much entries (%d), only %d",
+				    sbytes[i] - 1, entry_count);
+
+			    /* Shift snum[i]-1 items in whole. Shift sbytes[i] directory entries from directory item number snum[i] */
+			    leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i]-1, S_new[i]);
+			    /* Paste given directory entry to directory item */
+			    bi.tb = tb;
+			    bi.bi_bh = S_new[i];
+			    bi.bi_parent = NULL;
+			    bi.bi_position = 0;
+			    leaf_paste_in_buffer (&bi, 0, pos_in_item - entry_count + sbytes[i] - 1,
+						  tb->insert_size[0], body,zeros_num);
+			    /* paste new directory entry */
+			    leaf_paste_entries (
+				bi.bi_bh, 0, pos_in_item - entry_count + sbytes[i] - 1,
+				1, (struct reiserfs_de_head *)body, body + DEH_SIZE,
+				tb->insert_size[0]
+				);
+			    tb->insert_size[0] = 0;
+			    pos_in_item++;
+			} else { /* new directory entry doesn't fall into S_new[i] */
+			    leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i], S_new[i]);
+			}
+		    }
+		    else /* regular object */
+		    {
+			int n_shift, n_rem, r_zeros_number;
+			const char * r_body;
+
+			RFALSE( pos_in_item != ih_item_len(B_N_PITEM_HEAD(tbS0,item_pos)) ||
+			        tb->insert_size[0] <= 0,
+			        "PAP-12225: item too short or insert_size <= 0");
+
+			/* Calculate number of bytes which must be shifted from appended item */
+			n_shift = sbytes[i] - tb->insert_size[0];
+			if ( n_shift < 0 )
+			    n_shift = 0;
+			leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], n_shift, S_new[i]);
+
+			/* Calculate number of bytes which must remain in body after append to S_new[i] */
+			n_rem = tb->insert_size[0] - sbytes[i];
+			if ( n_rem < 0 )
+			    n_rem = 0;
+			/* Append part of body into S_new[0] */
+			bi.tb = tb;
+			bi.bi_bh = S_new[i];
+			bi.bi_parent = NULL;
+			bi.bi_position = 0;
+
+			if ( n_rem > zeros_num ) {
+			    r_zeros_number = 0;
+			    r_body = body + n_rem - zeros_num;
+			}
+			else {
+			    r_body = body;
+			    r_zeros_number = zeros_num - n_rem;
+			    zeros_num -= r_zeros_number;
+			}
+
+			leaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0]-n_rem, r_body,r_zeros_number);
+			{
+			    struct item_head * tmp;
+
+			    tmp = B_N_PITEM_HEAD(S_new[i],0);
+			    if (is_indirect_le_ih (tmp)) {
+				set_ih_free_space (tmp, 0);
+				set_le_ih_k_offset( tmp, le_ih_k_offset(tmp) + 
+					            (n_rem << (tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT)));
+			    } else {
+				set_le_ih_k_offset( tmp, le_ih_k_offset(tmp) + 
+				                    n_rem );
+			    }
+			}
+
+			tb->insert_size[0] = n_rem;
+			if ( ! n_rem )
+			    pos_in_item++;
+		    }
+		}
+		else
+		    /* item falls wholly into S_new[i] */
+		{
+		    int ret_val;
+		    struct item_head * pasted;
+
+#ifdef CONFIG_REISERFS_CHECK
+		    struct item_head * ih = B_N_PITEM_HEAD(tbS0,item_pos);
+
+		    if ( ! is_direntry_le_ih(ih) && (pos_in_item != ih_item_len(ih) ||
+						     tb->insert_size[0] <= 0) )
+			reiserfs_panic (tb->tb_sb, "PAP-12235: balance_leaf: pos_in_item must be equal to ih_item_len");
+#endif /* CONFIG_REISERFS_CHECK */
+
+		    ret_val = leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i], S_new[i]);
+
+		    RFALSE( ret_val,
+			    "PAP-12240: unexpected value returned by leaf_move_items (%d)",
+			    ret_val);
+
+		    /* paste into item */
+		    bi.tb = tb;
+		    bi.bi_bh = S_new[i];
+		    bi.bi_parent = NULL;
+		    bi.bi_position = 0;
+		    leaf_paste_in_buffer(&bi, item_pos - n + snum[i], pos_in_item, tb->insert_size[0], body, zeros_num);
+
+		    pasted = B_N_PITEM_HEAD(S_new[i], item_pos - n + snum[i]);
+		    if (is_direntry_le_ih (pasted))
+		    {
+			leaf_paste_entries (
+			    bi.bi_bh, item_pos - n + snum[i], pos_in_item, 1, 
+			    (struct reiserfs_de_head *)body, body + DEH_SIZE, tb->insert_size[0]
+			    );
+		    }
+
+		    /* if we paste to indirect item update ih_free_space */
+		    if (is_indirect_le_ih (pasted))
+			set_ih_free_space (pasted, 0);
+		    zeros_num = tb->insert_size[0] = 0;
+		}
+	    }
+
+	    else /* pasted item doesn't fall into S_new[i] */
+	    {
+		leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i], S_new[i]);
+	    }
+	    break;
+	default:    /* cases d and t */
+	    reiserfs_panic (tb->tb_sb, "PAP-12245: balance_leaf: blknum > 2: unexpectable mode: %s(%d)",
+			    (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
+	}
+
+	memcpy (insert_key + i,B_N_PKEY(S_new[i],0),KEY_SIZE);
+	insert_ptr[i] = S_new[i];
+
+	RFALSE (!buffer_journaled (S_new [i]) || buffer_journal_dirty (S_new [i]) ||
+		buffer_dirty (S_new [i]),
+		"PAP-12247: S_new[%d] : (%b)", i, S_new[i]);
+    }
+
+    /* if the affected item was not wholly shifted then we perform all necessary operations on that part or whole of the
+       affected item which remains in S */
+    if ( 0 <= item_pos && item_pos < tb->s0num )
+    { /* if we must insert or append into buffer S[0] */
+
+	switch (flag)
+	{
+	case M_INSERT:   /* insert item into S[0] */
+	    bi.tb = tb;
+	    bi.bi_bh = tbS0;
+	    bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
+	    bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
+	    leaf_insert_into_buf (&bi, item_pos, ih, body, zeros_num);
+
+	    /* If we insert the first key change the delimiting key */
+	    if( item_pos == 0 ) {
+		if (tb->CFL[0]) /* can be 0 in reiserfsck */
+		    replace_key(tb, tb->CFL[0], tb->lkey[0],tbS0,0);
+
+	    }
+	    break;
+
+	case M_PASTE: {  /* append item in S[0] */
+	    struct item_head * pasted;
+
+	    pasted = B_N_PITEM_HEAD (tbS0, item_pos);
+	    /* when directory, may be new entry already pasted */
+	    if (is_direntry_le_ih (pasted)) {
+		if ( pos_in_item >= 0 &&
+		    pos_in_item <= ih_entry_count(pasted) ) {
+
+		    RFALSE( ! tb->insert_size[0], 
+			    "PAP-12260: insert_size is 0 already");
+
+		    /* prepare space */
+		    bi.tb = tb;
+		    bi.bi_bh = tbS0;
+		    bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
+		    bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
+		    leaf_paste_in_buffer(&bi, item_pos, pos_in_item, tb->insert_size[0], body, zeros_num);
+
+		    /* paste entry */
+		    leaf_paste_entries (
+			bi.bi_bh, item_pos, pos_in_item, 1, (struct reiserfs_de_head *)body,
+			body + DEH_SIZE, tb->insert_size[0]
+			);
+		    if ( ! item_pos && ! pos_in_item ) {
+			RFALSE( !tb->CFL[0] || !tb->L[0], 
+				"PAP-12270: CFL[0]/L[0] must be specified");
+			if (tb->CFL[0]) {
+			    replace_key(tb, tb->CFL[0], tb->lkey[0],tbS0,0);
+
+			}
+		    }
+		    tb->insert_size[0] = 0;
+		}
+	    } else { /* regular object */
+		if ( pos_in_item == ih_item_len(pasted) ) {
+
+		    RFALSE( tb->insert_size[0] <= 0,
+			    "PAP-12275: insert size must not be %d",
+                            tb->insert_size[0]);
+		    bi.tb = tb;
+		    bi.bi_bh = tbS0;
+		    bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
+		    bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
+		    leaf_paste_in_buffer (&bi, item_pos, pos_in_item, tb->insert_size[0], body, zeros_num);
+
+		    if (is_indirect_le_ih (pasted)) {
+#if 0
+			RFALSE( tb->insert_size[0] != UNFM_P_SIZE,
+				"PAP-12280: insert_size for indirect item must be %d, not %d",
+				UNFM_P_SIZE, tb->insert_size[0]);
+#endif
+			set_ih_free_space (pasted, 0);
+		    }
+		    tb->insert_size[0] = 0;
+		}
+
+#ifdef CONFIG_REISERFS_CHECK
+		else {
+		    if ( tb->insert_size[0] ) {
+			print_cur_tb ("12285");
+			reiserfs_panic (tb->tb_sb, "PAP-12285: balance_leaf: insert_size must be 0 (%d)", tb->insert_size[0]);
+		    }
+		}
+#endif /* CONFIG_REISERFS_CHECK */
+	    
+	    }
+	} /* case M_PASTE: */
+	}
+    }
+
+#ifdef CONFIG_REISERFS_CHECK
+    if ( flag == M_PASTE && tb->insert_size[0] ) {
+	print_cur_tb ("12290");
+	reiserfs_panic (tb->tb_sb, "PAP-12290: balance_leaf: insert_size is still not 0 (%d)", tb->insert_size[0]);
+    }
+#endif /* CONFIG_REISERFS_CHECK */
+
+    return 0;
+} /* Leaf level of the tree is balanced (end of balance_leaf) */
+
+
+
+/* Make empty node */
+void make_empty_node (struct buffer_info * bi)
+{
+    struct block_head * blkh;
+
+    RFALSE( bi->bi_bh == NULL, "PAP-12295: pointer to the buffer is NULL");
+
+    blkh = B_BLK_HEAD(bi->bi_bh);
+    set_blkh_nr_item( blkh, 0 );
+    set_blkh_free_space( blkh, MAX_CHILD_SIZE(bi->bi_bh) );
+
+    if (bi->bi_parent)
+	B_N_CHILD (bi->bi_parent, bi->bi_position)->dc_size = 0; /* Endian safe if 0 */
+}
+
+
+/* Get first empty buffer */
+struct buffer_head * get_FEB (struct tree_balance * tb)
+{
+    int i;
+    struct buffer_head * first_b;
+    struct buffer_info bi;
+
+    for (i = 0; i < MAX_FEB_SIZE; i ++)
+	if (tb->FEB[i] != 0)
+	    break;
+
+    if (i == MAX_FEB_SIZE)
+	reiserfs_panic(tb->tb_sb, "vs-12300: get_FEB: FEB list is empty");
+
+    bi.tb = tb;
+    bi.bi_bh = first_b = tb->FEB[i];
+    bi.bi_parent = NULL;
+    bi.bi_position = 0;
+    make_empty_node (&bi);
+    set_buffer_uptodate(first_b);
+    tb->FEB[i] = NULL;
+    tb->used[i] = first_b;
+
+    return(first_b);
+}
+
+
+/* This is now used because reiserfs_free_block has to be able to
+** schedule.
+*/
+static void store_thrown (struct tree_balance * tb, struct buffer_head * bh)
+{
+    int i;
+
+    if (buffer_dirty (bh))
+      reiserfs_warning (tb->tb_sb, "store_thrown deals with dirty buffer");
+    for (i = 0; i < sizeof (tb->thrown)/sizeof (tb->thrown[0]); i ++)
+	if (!tb->thrown[i]) {
+	    tb->thrown[i] = bh;
+	    get_bh(bh) ; /* free_thrown puts this */
+	    return;
+	}
+    reiserfs_warning (tb->tb_sb, "store_thrown: too many thrown buffers");
+}
+
+static void free_thrown(struct tree_balance *tb) {
+    int i ;
+    b_blocknr_t blocknr ;
+    for (i = 0; i < sizeof (tb->thrown)/sizeof (tb->thrown[0]); i++) {
+	if (tb->thrown[i]) {
+	    blocknr = tb->thrown[i]->b_blocknr ;
+	    if (buffer_dirty (tb->thrown[i]))
+	      reiserfs_warning (tb->tb_sb,
+				"free_thrown deals with dirty buffer %d",
+				blocknr);
+	    brelse(tb->thrown[i]) ; /* incremented in store_thrown */
+	    reiserfs_free_block (tb->transaction_handle, NULL, blocknr, 0);
+	}
+    }
+}
+
+void reiserfs_invalidate_buffer (struct tree_balance * tb, struct buffer_head * bh)
+{
+    struct block_head *blkh;
+    blkh = B_BLK_HEAD(bh);
+    set_blkh_level( blkh, FREE_LEVEL );
+    set_blkh_nr_item( blkh, 0 );
+    
+    clear_buffer_dirty(bh);
+    store_thrown (tb, bh);
+}
+
+/* Replace n_dest'th key in buffer dest by n_src'th key of buffer src.*/
+void replace_key (struct tree_balance * tb, struct buffer_head * dest, int n_dest,
+		  struct buffer_head * src, int n_src)
+{
+
+    RFALSE( dest == NULL || src == NULL,
+	    "vs-12305: source or destination buffer is 0 (src=%p, dest=%p)",
+	    src, dest);
+    RFALSE( ! B_IS_KEYS_LEVEL (dest),
+	    "vs-12310: invalid level (%z) for destination buffer. dest must be leaf",
+	    dest);
+    RFALSE( n_dest < 0 || n_src < 0,
+	    "vs-12315: src(%d) or dest(%d) key number < 0", n_src, n_dest);
+    RFALSE( n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),
+	    "vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big",
+	    n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));
+   
+    if (B_IS_ITEMS_LEVEL (src))
+	/* source buffer contains leaf node */
+	memcpy (B_N_PDELIM_KEY(dest,n_dest), B_N_PITEM_HEAD(src,n_src), KEY_SIZE);
+    else
+	memcpy (B_N_PDELIM_KEY(dest,n_dest), B_N_PDELIM_KEY(src,n_src), KEY_SIZE);
+
+    do_balance_mark_internal_dirty (tb, dest, 0);
+}
+
+
+int get_left_neighbor_position (
+				struct tree_balance * tb, 
+				int h
+				)
+{
+  int Sh_position = PATH_H_POSITION (tb->tb_path, h + 1);
+
+  RFALSE( PATH_H_PPARENT (tb->tb_path, h) == 0 || tb->FL[h] == 0,
+	  "vs-12325: FL[%d](%p) or F[%d](%p) does not exist", 
+	  h, tb->FL[h], h, PATH_H_PPARENT (tb->tb_path, h));
+
+  if (Sh_position == 0)
+    return B_NR_ITEMS (tb->FL[h]);
+  else
+    return Sh_position - 1;
+}
+
+
+int get_right_neighbor_position (struct tree_balance * tb, int h)
+{
+  int Sh_position = PATH_H_POSITION (tb->tb_path, h + 1);
+
+  RFALSE( PATH_H_PPARENT (tb->tb_path, h) == 0 || tb->FR[h] == 0,
+	  "vs-12330: F[%d](%p) or FR[%d](%p) does not exist", 
+	  h, PATH_H_PPARENT (tb->tb_path, h), h, tb->FR[h]);
+
+  if (Sh_position == B_NR_ITEMS (PATH_H_PPARENT (tb->tb_path, h)))
+    return 0;
+  else
+    return Sh_position + 1;
+}
+
+
+#ifdef CONFIG_REISERFS_CHECK
+
+int is_reusable (struct super_block * s, b_blocknr_t block, int bit_value);
+static void check_internal_node (struct super_block * s, struct buffer_head * bh, char * mes)
+{
+  struct disk_child * dc;
+  int i;
+
+  RFALSE( !bh, "PAP-12336: bh == 0");
+
+  if (!bh || !B_IS_IN_TREE (bh))
+    return;
+ 
+  RFALSE( !buffer_dirty (bh) && 
+	  !(buffer_journaled(bh) || buffer_journal_dirty(bh)),
+	  "PAP-12337: buffer (%b) must be dirty", bh);
+  dc = B_N_CHILD (bh, 0);
+
+  for (i = 0; i <= B_NR_ITEMS (bh); i ++, dc ++) {
+    if (!is_reusable (s, dc_block_number(dc), 1) ) {
+      print_cur_tb (mes);
+      reiserfs_panic (s, "PAP-12338: check_internal_node: invalid child pointer %y in %b", dc, bh);
+    }
+  }
+}
+
+
+static int locked_or_not_in_tree (struct buffer_head * bh, char * which)
+{
+  if ( (!buffer_journal_prepared (bh) && buffer_locked (bh)) ||
+        !B_IS_IN_TREE (bh) ) {
+    reiserfs_warning (NULL, "vs-12339: locked_or_not_in_tree: %s (%b)",
+                      which, bh);
+    return 1;
+  } 
+  return 0;
+}
+
+
+static int check_before_balancing (struct tree_balance * tb)
+{
+  int retval = 0;	
+
+  if ( cur_tb ) {
+    reiserfs_panic (tb->tb_sb, "vs-12335: check_before_balancing: "
+		    "suspect that schedule occurred based on cur_tb not being null at this point in code. "
+		    "do_balance cannot properly handle schedule occurring while it runs.");
+  }
+  
+  /* double check that buffers that we will modify are unlocked. (fix_nodes should already have
+     prepped all of these for us). */
+  if ( tb->lnum[0] ) {
+    retval |= locked_or_not_in_tree (tb->L[0], "L[0]");
+    retval |= locked_or_not_in_tree (tb->FL[0], "FL[0]");
+    retval |= locked_or_not_in_tree (tb->CFL[0], "CFL[0]");
+    check_leaf (tb->L[0]);
+  }
+  if ( tb->rnum[0] ) {
+    retval |= locked_or_not_in_tree (tb->R[0], "R[0]");
+    retval |= locked_or_not_in_tree (tb->FR[0], "FR[0]");
+    retval |= locked_or_not_in_tree (tb->CFR[0], "CFR[0]");
+    check_leaf (tb->R[0]);
+  }
+  retval |= locked_or_not_in_tree (PATH_PLAST_BUFFER (tb->tb_path), "S[0]");
+  check_leaf (PATH_PLAST_BUFFER (tb->tb_path));
+
+  return retval;
+}
+
+
+static void check_after_balance_leaf (struct tree_balance * tb)
+{
+    if (tb->lnum[0]) {
+	if (B_FREE_SPACE (tb->L[0]) != 
+	    MAX_CHILD_SIZE (tb->L[0]) - dc_size(B_N_CHILD (tb->FL[0], get_left_neighbor_position (tb, 0)))) {
+	    print_cur_tb ("12221");
+	    reiserfs_panic (tb->tb_sb, "PAP-12355: check_after_balance_leaf: shift to left was incorrect");
+	}
+    }
+    if (tb->rnum[0]) {
+	if (B_FREE_SPACE (tb->R[0]) != 
+	    MAX_CHILD_SIZE (tb->R[0]) - dc_size(B_N_CHILD (tb->FR[0], get_right_neighbor_position (tb, 0)))) {
+	    print_cur_tb ("12222");
+	    reiserfs_panic (tb->tb_sb, "PAP-12360: check_after_balance_leaf: shift to right was incorrect");
+	}
+    }
+    if (PATH_H_PBUFFER(tb->tb_path,1) &&
+	(B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) != 
+		    (MAX_CHILD_SIZE (PATH_H_PBUFFER(tb->tb_path,0)) -
+		    dc_size(B_N_CHILD (PATH_H_PBUFFER(tb->tb_path,1),
+		    PATH_H_POSITION (tb->tb_path, 1)))) )) {
+	int left = B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0));
+	int right = (MAX_CHILD_SIZE (PATH_H_PBUFFER(tb->tb_path,0)) -
+		    dc_size(B_N_CHILD (PATH_H_PBUFFER(tb->tb_path,1),
+			PATH_H_POSITION (tb->tb_path, 1))));
+	print_cur_tb ("12223");
+	reiserfs_warning (tb->tb_sb,
+	    "B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) = %d; "
+    	    "MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d",
+	    left,
+	    MAX_CHILD_SIZE (PATH_H_PBUFFER(tb->tb_path,0)),
+	    PATH_H_PBUFFER(tb->tb_path,1),
+	    PATH_H_POSITION (tb->tb_path, 1),
+	    dc_size(B_N_CHILD (PATH_H_PBUFFER(tb->tb_path,1), PATH_H_POSITION (tb->tb_path, 1 )) ),
+	    right );
+	reiserfs_panic (tb->tb_sb, "PAP-12365: check_after_balance_leaf: S is incorrect");
+    }
+}
+
+
+static void check_leaf_level (struct tree_balance * tb)
+{
+  check_leaf (tb->L[0]);
+  check_leaf (tb->R[0]);
+  check_leaf (PATH_PLAST_BUFFER (tb->tb_path));
+}
+
+static void check_internal_levels (struct tree_balance * tb)
+{
+  int h;
+
+  /* check all internal nodes */
+  for (h = 1; tb->insert_size[h]; h ++) {
+    check_internal_node (tb->tb_sb, PATH_H_PBUFFER (tb->tb_path, h), "BAD BUFFER ON PATH");
+    if (tb->lnum[h])
+      check_internal_node (tb->tb_sb, tb->L[h], "BAD L");
+    if (tb->rnum[h])
+      check_internal_node (tb->tb_sb, tb->R[h], "BAD R");
+  }
+
+}
+
+#endif
+
+
+
+
+
+
+/* Now we have all of the buffers that must be used in balancing of
+   the tree.  We rely on the assumption that schedule() will not occur
+   while do_balance works. ( Only interrupt handlers are acceptable.)
+   We balance the tree according to the analysis made before this,
+   using buffers already obtained.  For SMP support it will someday be
+   necessary to add ordered locking of tb. */
+
+/* Some interesting rules of balancing:
+
+   we delete a maximum of two nodes per level per balancing: we never
+   delete R, when we delete two of three nodes L, S, R then we move
+   them into R.
+
+   we only delete L if we are deleting two nodes, if we delete only
+   one node we delete S
+
+   if we shift leaves then we shift as much as we can: this is a
+   deliberate policy of extremism in node packing which results in
+   higher average utilization after repeated random balance operations
+   at the cost of more memory copies and more balancing as a result of
+   small insertions to full nodes.
+
+   if we shift internal nodes we try to evenly balance the node
+   utilization, with consequent less balancing at the cost of lower
+   utilization.
+
+   one could argue that the policy for directories in leaves should be
+   that of internal nodes, but we will wait until another day to
+   evaluate this....  It would be nice to someday measure and prove
+   these assumptions as to what is optimal....
+
+*/
+
+static inline void do_balance_starts (struct tree_balance *tb)
+{
+    /* use print_cur_tb() to see initial state of struct
+       tree_balance */
+
+    /* store_print_tb (tb); */
+
+    /* do not delete, just comment it out */
+/*    print_tb(flag, PATH_LAST_POSITION(tb->tb_path), tb->tb_path->pos_in_item, tb, 
+	     "check");*/
+    RFALSE( check_before_balancing (tb), "PAP-12340: locked buffers in TB");
+#ifdef CONFIG_REISERFS_CHECK
+    cur_tb = tb;
+#endif
+}
+
+
+static inline void do_balance_completed (struct tree_balance * tb)
+{
+    
+#ifdef CONFIG_REISERFS_CHECK
+    check_leaf_level (tb);
+    check_internal_levels (tb);
+    cur_tb = NULL;
+#endif
+
+    /* reiserfs_free_block is no longer schedule safe.  So, we need to
+    ** put the buffers we want freed on the thrown list during do_balance,
+    ** and then free them now
+    */
+
+    REISERFS_SB(tb->tb_sb)->s_do_balance ++;
+
+
+    /* release all nodes hold to perform the balancing */
+    unfix_nodes(tb);
+
+    free_thrown(tb) ;
+}
+
+
+
+
+
+void do_balance (struct tree_balance * tb, /* tree_balance structure */
+		 struct item_head * ih,	   /* item header of inserted item */
+		 const char * body,  /* body  of inserted item or bytes to paste */
+		 int flag)  /* i - insert, d - delete
+			       c - cut, p - paste
+						      
+			       Cut means delete part of an item
+			       (includes removing an entry from a
+			       directory).
+						      
+			       Delete means delete whole item.
+						      
+			       Insert means add a new item into the
+			       tree.
+						      						      
+			       Paste means to append to the end of an
+			       existing file or to insert a directory
+			       entry.  */
+{
+    int child_pos, /* position of a child node in its parent */
+	h;	   /* level of the tree being processed */
+    struct item_head insert_key[2]; /* in our processing of one level
+				       we sometimes determine what
+				       must be inserted into the next
+				       higher level.  This insertion
+				       consists of a key or two keys
+				       and their corresponding
+				       pointers */
+    struct buffer_head *insert_ptr[2]; /* inserted node-ptrs for the next
+					  level */
+
+    tb->tb_mode = flag;
+    tb->need_balance_dirty = 0;
+
+    if (FILESYSTEM_CHANGED_TB(tb)) {
+        reiserfs_panic(tb->tb_sb, "clm-6000: do_balance, fs generation has changed\n") ;
+    }
+    /* if we have no real work to do  */
+    if ( ! tb->insert_size[0] ) {
+	reiserfs_warning (tb->tb_sb,
+			  "PAP-12350: do_balance: insert_size == 0, mode == %c",
+			  flag);
+	unfix_nodes(tb);
+	return;
+    }
+
+    atomic_inc (&(fs_generation (tb->tb_sb)));
+    do_balance_starts (tb);
+    
+	/* balance leaf returns 0 except if combining L R and S into
+	   one node.  see balance_internal() for explanation of this
+	   line of code.*/
+	child_pos = PATH_H_B_ITEM_ORDER (tb->tb_path, 0) +
+	  balance_leaf (tb, ih, body, flag, insert_key, insert_ptr);
+
+#ifdef CONFIG_REISERFS_CHECK
+    check_after_balance_leaf (tb);
+#endif
+
+    /* Balance internal level of the tree. */
+    for ( h = 1; h < MAX_HEIGHT && tb->insert_size[h]; h++ )
+	child_pos = balance_internal (tb, h, child_pos, insert_key, insert_ptr);
+
+
+    do_balance_completed (tb);
+
+}
