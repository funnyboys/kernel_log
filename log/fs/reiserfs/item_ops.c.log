commit 5b1d149c895b3229d70c0d4c69e14bdbe5fe8226
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Aug 21 21:59:30 2018 -0700

    reiserfs: remove obsolete print_time function
    
    Before linux-2.4.6, print_time() was used to pretty-print an inode time
    when running reiserfs in user space, after that it has become obsolete and
    is still a bit incorrect: It behaves differently on 32-bit and 64-bit
    machines, and uses a static buffer to hold a string, which could lead to
    undefined behavior if we ever called this from multiple places
    simultaneously.
    
    Since we always want to treat the timestamps as 'unsigned' anyway, simply
    printing them as an integer is both simpler and safer while avoiding the
    deprecated time_t type.
    
    Link: http://lkml.kernel.org/r/20180620142522.27639-3-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
index e3c558d1b78c..3a5a752d96c7 100644
--- a/fs/reiserfs/item_ops.c
+++ b/fs/reiserfs/item_ops.c
@@ -33,30 +33,22 @@ static int sd_is_left_mergeable(struct reiserfs_key *key, unsigned long bsize)
 	return 0;
 }
 
-static char *print_time(time_t t)
-{
-	static char timebuf[256];
-
-	sprintf(timebuf, "%ld", t);
-	return timebuf;
-}
-
 static void sd_print_item(struct item_head *ih, char *item)
 {
 	printk("\tmode | size | nlinks | first direct | mtime\n");
 	if (stat_data_v1(ih)) {
 		struct stat_data_v1 *sd = (struct stat_data_v1 *)item;
 
-		printk("\t0%-6o | %6u | %2u | %d | %s\n", sd_v1_mode(sd),
+		printk("\t0%-6o | %6u | %2u | %d | %u\n", sd_v1_mode(sd),
 		       sd_v1_size(sd), sd_v1_nlink(sd),
 		       sd_v1_first_direct_byte(sd),
-		       print_time(sd_v1_mtime(sd)));
+		       sd_v1_mtime(sd));
 	} else {
 		struct stat_data *sd = (struct stat_data *)item;
 
-		printk("\t0%-6o | %6llu | %2u | %d | %s\n", sd_v2_mode(sd),
+		printk("\t0%-6o | %6llu | %2u | %d | %u\n", sd_v2_mode(sd),
 		       (unsigned long long)sd_v2_size(sd), sd_v2_nlink(sd),
-		       sd_v2_rdev(sd), print_time(sd_v2_mtime(sd)));
+		       sd_v2_rdev(sd), sd_v2_mtime(sd));
 	}
 }
 

commit 7fe6a42e87ef20edd7faf1b2f4bf18d95922d1e4
Author: Kees Cook <keescook@chromium.org>
Date:   Mon May 8 15:56:08 2017 -0700

    reiserfs: use designated initializers
    
    Prepare to mark sensitive kernel structures for randomization by making
    sure they're using designated initializers.  These were identified
    during allyesconfig builds of x86, arm, and arm64, with most initializer
    fixes extracted from grsecurity.
    
    Link: http://lkml.kernel.org/r/20170329210419.GA40066@beast
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
index aca73dd73906..e3c558d1b78c 100644
--- a/fs/reiserfs/item_ops.c
+++ b/fs/reiserfs/item_ops.c
@@ -724,18 +724,18 @@ static void errcatch_print_vi(struct virtual_item *vi)
 }
 
 static struct item_operations errcatch_ops = {
-	errcatch_bytes_number,
-	errcatch_decrement_key,
-	errcatch_is_left_mergeable,
-	errcatch_print_item,
-	errcatch_check_item,
-
-	errcatch_create_vi,
-	errcatch_check_left,
-	errcatch_check_right,
-	errcatch_part_size,
-	errcatch_unit_num,
-	errcatch_print_vi
+	.bytes_number = errcatch_bytes_number,
+	.decrement_key = errcatch_decrement_key,
+	.is_left_mergeable = errcatch_is_left_mergeable,
+	.print_item = errcatch_print_item,
+	.check_item = errcatch_check_item,
+
+	.create_vi = errcatch_create_vi,
+	.check_left = errcatch_check_left,
+	.check_right = errcatch_check_right,
+	.part_size = errcatch_part_size,
+	.unit_num = errcatch_unit_num,
+	.print_vi = errcatch_print_vi
 };
 
 #if ! (TYPE_STAT_DATA == 0 && TYPE_INDIRECT == 1 && TYPE_DIRECT == 2 && TYPE_DIRENTRY == 3)

commit 53872ed07786714bff3642ee9ee61afd3f4eb749
Author: Fabian Frederick <fabf@skynet.be>
Date:   Fri Aug 8 14:21:10 2014 -0700

    fs/reiserfs: replace not-standard %Lu/%Ld
    
    Fixes checkpatch warnings:
    
    "WARNING: %Ld/%Lu are not-standard C, use %lld/%llu"
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
index cfaee912ee09..aca73dd73906 100644
--- a/fs/reiserfs/item_ops.c
+++ b/fs/reiserfs/item_ops.c
@@ -54,7 +54,7 @@ static void sd_print_item(struct item_head *ih, char *item)
 	} else {
 		struct stat_data *sd = (struct stat_data *)item;
 
-		printk("\t0%-6o | %6Lu | %2u | %d | %s\n", sd_v2_mode(sd),
+		printk("\t0%-6o | %6llu | %2u | %d | %s\n", sd_v2_mode(sd),
 		       (unsigned long long)sd_v2_size(sd), sd_v2_nlink(sd),
 		       sd_v2_rdev(sd), print_time(sd_v2_mtime(sd)));
 	}
@@ -408,7 +408,7 @@ static void direntry_print_item(struct item_head *ih, char *item)
 			namebuf[namelen + 2] = 0;
 		}
 
-		printk("%d:  %-15s%-15d%-15d%-15Ld%-15Ld(%s)\n",
+		printk("%d:  %-15s%-15d%-15d%-15lld%-15lld(%s)\n",
 		       i, namebuf,
 		       deh_dir_id(deh), deh_objectid(deh),
 		       GET_HASH_VALUE(deh_offset(deh)),

commit a228bf8f0a3e5f1406edbd61f7400e87e23af5f7
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:42 2014 -0400

    reiserfs: cleanup, remove unnecessary parens
    
    The reiserfs code is littered with extra parens in places where the authors
    may not have been certain about precedence of & vs ->. This patch cleans them
    out.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
index cb6b826ca5e9..cfaee912ee09 100644
--- a/fs/reiserfs/item_ops.c
+++ b/fs/reiserfs/item_ops.c
@@ -491,8 +491,8 @@ static int direntry_create_vi(struct virtual_node *vn,
 		j = old_entry_num(is_affected, i, vn->vn_pos_in_item,
 				  vn->vn_mode);
 		dir_u->entry_sizes[i] =
-		    (j ? deh_location(&(deh[j - 1])) : ih_item_len(vi->vi_ih)) -
-		    deh_location(&(deh[j])) + DEH_SIZE;
+		    (j ? deh_location(&deh[j - 1]) : ih_item_len(vi->vi_ih)) -
+		    deh_location(&deh[j]) + DEH_SIZE;
 	}
 
 	size += (dir_u->entry_count * sizeof(short));

commit 098297b27d23ad9d0fc302e3417474d9342c6c14
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:36 2014 -0400

    reiserfs: cleanup, reformat comments to normal kernel style
    
    This patch reformats comments in the reiserfs code to fit in 80 columns and
    to follow the style rules.
    
    There is no functional change but it helps make my eyes bleed less.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
index c9f136527386..cb6b826ca5e9 100644
--- a/fs/reiserfs/item_ops.c
+++ b/fs/reiserfs/item_ops.c
@@ -5,15 +5,17 @@
 #include <linux/time.h>
 #include "reiserfs.h"
 
-// this contains item handlers for old item types: sd, direct,
-// indirect, directory
+/*
+ * this contains item handlers for old item types: sd, direct,
+ * indirect, directory
+ */
 
-/* and where are the comments? how about saying where we can find an
-   explanation of each item handler method? -Hans */
+/*
+ * and where are the comments? how about saying where we can find an
+ * explanation of each item handler method? -Hans
+ */
 
-//////////////////////////////////////////////////////////////////////////////
-// stat data functions
-//
+/* stat data functions */
 static int sd_bytes_number(struct item_head *ih, int block_size)
 {
 	return 0;
@@ -60,7 +62,7 @@ static void sd_print_item(struct item_head *ih, char *item)
 
 static void sd_check_item(struct item_head *ih, char *item)
 {
-	// FIXME: type something here!
+	/* unused */
 }
 
 static int sd_create_vi(struct virtual_node *vn,
@@ -68,7 +70,6 @@ static int sd_create_vi(struct virtual_node *vn,
 			int is_affected, int insert_size)
 {
 	vi->vi_index = TYPE_STAT_DATA;
-	//vi->vi_type |= VI_TYPE_STAT_DATA;// not needed?
 	return 0;
 }
 
@@ -117,15 +118,13 @@ static struct item_operations stat_data_ops = {
 	.print_vi = sd_print_vi
 };
 
-//////////////////////////////////////////////////////////////////////////////
-// direct item functions
-//
+/* direct item functions */
 static int direct_bytes_number(struct item_head *ih, int block_size)
 {
 	return ih_item_len(ih);
 }
 
-// FIXME: this should probably switch to indirect as well
+/* FIXME: this should probably switch to indirect as well */
 static void direct_decrement_key(struct cpu_key *key)
 {
 	cpu_key_k_offset_dec(key);
@@ -144,7 +143,7 @@ static void direct_print_item(struct item_head *ih, char *item)
 {
 	int j = 0;
 
-//    return;
+/*    return; */
 	printk("\"");
 	while (j < ih_item_len(ih))
 		printk("%c", item[j++]);
@@ -153,7 +152,7 @@ static void direct_print_item(struct item_head *ih, char *item)
 
 static void direct_check_item(struct item_head *ih, char *item)
 {
-	// FIXME: type something here!
+	/* unused */
 }
 
 static int direct_create_vi(struct virtual_node *vn,
@@ -161,7 +160,6 @@ static int direct_create_vi(struct virtual_node *vn,
 			    int is_affected, int insert_size)
 {
 	vi->vi_index = TYPE_DIRECT;
-	//vi->vi_type |= VI_TYPE_DIRECT;
 	return 0;
 }
 
@@ -211,16 +209,13 @@ static struct item_operations direct_ops = {
 	.print_vi = direct_print_vi
 };
 
-//////////////////////////////////////////////////////////////////////////////
-// indirect item functions
-//
-
+/* indirect item functions */
 static int indirect_bytes_number(struct item_head *ih, int block_size)
 {
-	return ih_item_len(ih) / UNFM_P_SIZE * block_size;	//- get_ih_free_space (ih);
+	return ih_item_len(ih) / UNFM_P_SIZE * block_size;
 }
 
-// decrease offset, if it becomes 0, change type to stat data
+/* decrease offset, if it becomes 0, change type to stat data */
 static void indirect_decrement_key(struct cpu_key *key)
 {
 	cpu_key_k_offset_dec(key);
@@ -228,7 +223,7 @@ static void indirect_decrement_key(struct cpu_key *key)
 		set_cpu_key_k_type(key, TYPE_STAT_DATA);
 }
 
-// if it is not first item of the body, then it is mergeable
+/* if it is not first item of the body, then it is mergeable */
 static int indirect_is_left_mergeable(struct reiserfs_key *key,
 				      unsigned long bsize)
 {
@@ -236,7 +231,7 @@ static int indirect_is_left_mergeable(struct reiserfs_key *key,
 	return (le_key_k_offset(version, key) != 1);
 }
 
-// printing of indirect item
+/* printing of indirect item */
 static void start_new_sequence(__u32 * start, int *len, __u32 new)
 {
 	*start = new;
@@ -295,7 +290,7 @@ static void indirect_print_item(struct item_head *ih, char *item)
 
 static void indirect_check_item(struct item_head *ih, char *item)
 {
-	// FIXME: type something here!
+	/* unused */
 }
 
 static int indirect_create_vi(struct virtual_node *vn,
@@ -303,7 +298,6 @@ static int indirect_create_vi(struct virtual_node *vn,
 			      int is_affected, int insert_size)
 {
 	vi->vi_index = TYPE_INDIRECT;
-	//vi->vi_type |= VI_TYPE_INDIRECT;
 	return 0;
 }
 
@@ -321,16 +315,19 @@ static int indirect_check_right(struct virtual_item *vi, int free)
 	return indirect_check_left(vi, free, 0, 0);
 }
 
-// return size in bytes of 'units' units. If first == 0 - calculate from the head (left), otherwise - from tail (right)
+/*
+ * return size in bytes of 'units' units. If first == 0 - calculate
+ * from the head (left), otherwise - from tail (right)
+ */
 static int indirect_part_size(struct virtual_item *vi, int first, int units)
 {
-	// unit of indirect item is byte (yet)
+	/* unit of indirect item is byte (yet) */
 	return units;
 }
 
 static int indirect_unit_num(struct virtual_item *vi)
 {
-	// unit of indirect item is byte (yet)
+	/* unit of indirect item is byte (yet) */
 	return vi->vi_item_len - IH_SIZE;
 }
 
@@ -356,10 +353,7 @@ static struct item_operations indirect_ops = {
 	.print_vi = indirect_print_vi
 };
 
-//////////////////////////////////////////////////////////////////////////////
-// direntry functions
-//
-
+/* direntry functions */
 static int direntry_bytes_number(struct item_head *ih, int block_size)
 {
 	reiserfs_warning(NULL, "vs-16090",
@@ -428,7 +422,7 @@ static void direntry_check_item(struct item_head *ih, char *item)
 	int i;
 	struct reiserfs_de_head *deh;
 
-	// FIXME: type something here!
+	/* unused */
 	deh = (struct reiserfs_de_head *)item;
 	for (i = 0; i < ih_entry_count(ih); i++, deh++) {
 		;
@@ -439,7 +433,8 @@ static void direntry_check_item(struct item_head *ih, char *item)
 
 /*
  * function returns old entry number in directory item in real node
- * using new entry number in virtual item in virtual node */
+ * using new entry number in virtual item in virtual node
+ */
 static inline int old_entry_num(int is_affected, int virtual_entry_num,
 				int pos_in_item, int mode)
 {
@@ -463,9 +458,11 @@ static inline int old_entry_num(int is_affected, int virtual_entry_num,
 	return virtual_entry_num - 1;
 }
 
-/* Create an array of sizes of directory entries for virtual
-   item. Return space used by an item. FIXME: no control over
-   consuming of space used by this item handler */
+/*
+ * Create an array of sizes of directory entries for virtual
+ * item. Return space used by an item. FIXME: no control over
+ * consuming of space used by this item handler
+ */
 static int direntry_create_vi(struct virtual_node *vn,
 			      struct virtual_item *vi,
 			      int is_affected, int insert_size)
@@ -529,10 +526,10 @@ static int direntry_create_vi(struct virtual_node *vn,
 
 }
 
-//
-// return number of entries which may fit into specified amount of
-// free space, or -1 if free space is not enough even for 1 entry
-//
+/*
+ * return number of entries which may fit into specified amount of
+ * free space, or -1 if free space is not enough even for 1 entry
+ */
 static int direntry_check_left(struct virtual_item *vi, int free,
 			       int start_skip, int end_skip)
 {
@@ -541,8 +538,8 @@ static int direntry_check_left(struct virtual_item *vi, int free,
 	struct direntry_uarea *dir_u = vi->vi_uarea;
 
 	for (i = start_skip; i < dir_u->entry_count - end_skip; i++) {
+		/* i-th entry doesn't fit into the remaining free space */
 		if (dir_u->entry_sizes[i] > free)
-			/* i-th entry doesn't fit into the remaining free space */
 			break;
 
 		free -= dir_u->entry_sizes[i];
@@ -570,8 +567,8 @@ static int direntry_check_right(struct virtual_item *vi, int free)
 	struct direntry_uarea *dir_u = vi->vi_uarea;
 
 	for (i = dir_u->entry_count - 1; i >= 0; i--) {
+		/* i-th entry doesn't fit into the remaining free space */
 		if (dir_u->entry_sizes[i] > free)
-			/* i-th entry doesn't fit into the remaining free space */
 			break;
 
 		free -= dir_u->entry_sizes[i];
@@ -643,9 +640,7 @@ static struct item_operations direntry_ops = {
 	.print_vi = direntry_print_vi
 };
 
-//////////////////////////////////////////////////////////////////////////////
-// Error catching functions to catch errors caused by incorrect item types.
-//
+/* Error catching functions to catch errors caused by incorrect item types. */
 static int errcatch_bytes_number(struct item_head *ih, int block_size)
 {
 	reiserfs_warning(NULL, "green-16001",
@@ -685,8 +680,12 @@ static int errcatch_create_vi(struct virtual_node *vn,
 {
 	reiserfs_warning(NULL, "green-16006",
 			 "Invalid item type observed, run fsck ASAP");
-	return 0;		// We might return -1 here as well, but it won't help as create_virtual_node() from where
-	// this operation is called from is of return type void.
+	/*
+	 * We might return -1 here as well, but it won't help as
+	 * create_virtual_node() from where this operation is called
+	 * from is of return type void.
+	 */
+	return 0;
 }
 
 static int errcatch_check_left(struct virtual_item *vi, int free,
@@ -739,9 +738,6 @@ static struct item_operations errcatch_ops = {
 	errcatch_print_vi
 };
 
-//////////////////////////////////////////////////////////////////////////////
-//
-//
 #if ! (TYPE_STAT_DATA == 0 && TYPE_INDIRECT == 1 && TYPE_DIRECT == 2 && TYPE_DIRENTRY == 3)
 #error Item types must use disk-format assigned values.
 #endif

commit 4cf5f7addf18ecae2ea49b11944976cbd26d5281
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:35 2014 -0400

    reiserfs: cleanup, rename key and item accessors to more friendly names
    
    This patch does a quick search and replace:
    B_N_PITEM_HEAD() -> item_head()
    B_N_PDELIM_KEY() -> internal_key()
    B_N_PKEY() -> leaf_key()
    B_N_PITEM() -> item_body()
    
    And the item_head version:
    B_I_PITEM() -> ih_item_body()
    I_ENTRY_COUNT() -> ih_entry_count()
    
    And the treepath variants:
    get_ih() -> tp_item_head()
    PATH_PITEM_HEAD() -> tp_item_head()
    get_item() -> tp_item_body()
    
    ... which makes the code much easier on the eyes.
    
    I've also removed a few unused macros.
    
    Checkpatch will complain about the 80 character limit for do_balan.c.
    I've addressed that in a later patchset to split up balance_leaf().
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
index ee382ef3d300..c9f136527386 100644
--- a/fs/reiserfs/item_ops.c
+++ b/fs/reiserfs/item_ops.c
@@ -396,7 +396,7 @@ static void direntry_print_item(struct item_head *ih, char *item)
 
 	deh = (struct reiserfs_de_head *)item;
 
-	for (i = 0; i < I_ENTRY_COUNT(ih); i++, deh++) {
+	for (i = 0; i < ih_entry_count(ih); i++, deh++) {
 		namelen =
 		    (i ? (deh_location(deh - 1)) : ih_item_len(ih)) -
 		    deh_location(deh);
@@ -430,7 +430,7 @@ static void direntry_check_item(struct item_head *ih, char *item)
 
 	// FIXME: type something here!
 	deh = (struct reiserfs_de_head *)item;
-	for (i = 0; i < I_ENTRY_COUNT(ih); i++, deh++) {
+	for (i = 0; i < ih_entry_count(ih); i++, deh++) {
 		;
 	}
 }

commit f466c6fdb3b1f043ff1977a8d2a1d0cd4dc164fa
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 17 01:16:43 2012 -0400

    move private bits of reiserfs_fs.h to fs/reiserfs/reiserfs.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
index 72cb1cc51b87..ee382ef3d300 100644
--- a/fs/reiserfs/item_ops.c
+++ b/fs/reiserfs/item_ops.c
@@ -3,7 +3,7 @@
  */
 
 #include <linux/time.h>
-#include <linux/reiserfs_fs.h>
+#include "reiserfs.h"
 
 // this contains item handlers for old item types: sd, direct,
 // indirect, directory

commit c3a9c2109f84882b9b3178f6b1838d550d3df0ec
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:25 2009 -0400

    reiserfs: rework reiserfs_panic
    
    ReiserFS panics can be somewhat inconsistent.
    In some cases:
     * a unique identifier may be associated with it
     * the function name may be included
     * the device may be printed separately
    
    This patch aims to make warnings more consistent. reiserfs_warning() prints
    the device name, so printing it a second time is not required. The function
    name for a warning is always helpful in debugging, so it is now automatically
    inserted into the output. Hans has stated that every warning should have
    a unique identifier. Some cases lack them, others really shouldn't have them.
    reiserfs_warning() now expects an id associated with each message. In the
    rare case where one isn't needed, "" will suffice.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
index 8a11cf39f57b..72cb1cc51b87 100644
--- a/fs/reiserfs/item_ops.c
+++ b/fs/reiserfs/item_ops.c
@@ -517,8 +517,9 @@ static int direntry_create_vi(struct virtual_node *vn,
 		    ((is_affected
 		      && (vn->vn_mode == M_PASTE
 			  || vn->vn_mode == M_CUT)) ? insert_size : 0)) {
-			reiserfs_panic(NULL,
-				       "vs-8025: set_entry_sizes: (mode==%c, insert_size==%d), invalid length of directory item",
+			reiserfs_panic(NULL, "vs-8025", "(mode==%c, "
+				       "insert_size==%d), invalid length of "
+				       "directory item",
 				       vn->vn_mode, insert_size);
 		}
 	}
@@ -549,7 +550,8 @@ static int direntry_check_left(struct virtual_item *vi, int free,
 	}
 
 	if (entries == dir_u->entry_count) {
-		reiserfs_panic(NULL, "free space %d, entry_count %d\n", free,
+		reiserfs_panic(NULL, "item_ops-1",
+			       "free space %d, entry_count %d", free,
 			       dir_u->entry_count);
 	}
 

commit 45b03d5e8e674eb6555b767e1c8eb40b671ff892
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:21 2009 -0400

    reiserfs: rework reiserfs_warning
    
    ReiserFS warnings can be somewhat inconsistent.
    In some cases:
     * a unique identifier may be associated with it
     * the function name may be included
     * the device may be printed separately
    
    This patch aims to make warnings more consistent. reiserfs_warning() prints
    the device name, so printing it a second time is not required. The function
    name for a warning is always helpful in debugging, so it is now automatically
    inserted into the output. Hans has stated that every warning should have
    a unique identifier. Some cases lack them, others really shouldn't have them.
    reiserfs_warning() now expects an id associated with each message. In the
    rare case where one isn't needed, "" will suffice.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
index 9475557ab499..8a11cf39f57b 100644
--- a/fs/reiserfs/item_ops.c
+++ b/fs/reiserfs/item_ops.c
@@ -97,7 +97,8 @@ static int sd_unit_num(struct virtual_item *vi)
 
 static void sd_print_vi(struct virtual_item *vi)
 {
-	reiserfs_warning(NULL, "STATDATA, index %d, type 0x%x, %h",
+	reiserfs_warning(NULL, "reiserfs-16100",
+			 "STATDATA, index %d, type 0x%x, %h",
 			 vi->vi_index, vi->vi_type, vi->vi_ih);
 }
 
@@ -190,7 +191,8 @@ static int direct_unit_num(struct virtual_item *vi)
 
 static void direct_print_vi(struct virtual_item *vi)
 {
-	reiserfs_warning(NULL, "DIRECT, index %d, type 0x%x, %h",
+	reiserfs_warning(NULL, "reiserfs-16101",
+			 "DIRECT, index %d, type 0x%x, %h",
 			 vi->vi_index, vi->vi_type, vi->vi_ih);
 }
 
@@ -278,7 +280,7 @@ static void indirect_print_item(struct item_head *ih, char *item)
 	unp = (__le32 *) item;
 
 	if (ih_item_len(ih) % UNFM_P_SIZE)
-		reiserfs_warning(NULL, "indirect_print_item: invalid item len");
+		reiserfs_warning(NULL, "reiserfs-16102", "invalid item len");
 
 	printk("%d pointers\n[ ", (int)I_UNFM_NUM(ih));
 	for (j = 0; j < I_UNFM_NUM(ih); j++) {
@@ -334,7 +336,8 @@ static int indirect_unit_num(struct virtual_item *vi)
 
 static void indirect_print_vi(struct virtual_item *vi)
 {
-	reiserfs_warning(NULL, "INDIRECT, index %d, type 0x%x, %h",
+	reiserfs_warning(NULL, "reiserfs-16103",
+			 "INDIRECT, index %d, type 0x%x, %h",
 			 vi->vi_index, vi->vi_type, vi->vi_ih);
 }
 
@@ -359,7 +362,7 @@ static struct item_operations indirect_ops = {
 
 static int direntry_bytes_number(struct item_head *ih, int block_size)
 {
-	reiserfs_warning(NULL, "vs-16090: direntry_bytes_number: "
+	reiserfs_warning(NULL, "vs-16090",
 			 "bytes number is asked for direntry");
 	return 0;
 }
@@ -614,7 +617,8 @@ static void direntry_print_vi(struct virtual_item *vi)
 	int i;
 	struct direntry_uarea *dir_u = vi->vi_uarea;
 
-	reiserfs_warning(NULL, "DIRENTRY, index %d, type 0x%x, %h, flags 0x%x",
+	reiserfs_warning(NULL, "reiserfs-16104",
+			 "DIRENTRY, index %d, type 0x%x, %h, flags 0x%x",
 			 vi->vi_index, vi->vi_type, vi->vi_ih, dir_u->flags);
 	printk("%d entries: ", dir_u->entry_count);
 	for (i = 0; i < dir_u->entry_count; i++)
@@ -642,43 +646,43 @@ static struct item_operations direntry_ops = {
 //
 static int errcatch_bytes_number(struct item_head *ih, int block_size)
 {
-	reiserfs_warning(NULL,
-			 "green-16001: Invalid item type observed, run fsck ASAP");
+	reiserfs_warning(NULL, "green-16001",
+			 "Invalid item type observed, run fsck ASAP");
 	return 0;
 }
 
 static void errcatch_decrement_key(struct cpu_key *key)
 {
-	reiserfs_warning(NULL,
-			 "green-16002: Invalid item type observed, run fsck ASAP");
+	reiserfs_warning(NULL, "green-16002",
+			 "Invalid item type observed, run fsck ASAP");
 }
 
 static int errcatch_is_left_mergeable(struct reiserfs_key *key,
 				      unsigned long bsize)
 {
-	reiserfs_warning(NULL,
-			 "green-16003: Invalid item type observed, run fsck ASAP");
+	reiserfs_warning(NULL, "green-16003",
+			 "Invalid item type observed, run fsck ASAP");
 	return 0;
 }
 
 static void errcatch_print_item(struct item_head *ih, char *item)
 {
-	reiserfs_warning(NULL,
-			 "green-16004: Invalid item type observed, run fsck ASAP");
+	reiserfs_warning(NULL, "green-16004",
+			 "Invalid item type observed, run fsck ASAP");
 }
 
 static void errcatch_check_item(struct item_head *ih, char *item)
 {
-	reiserfs_warning(NULL,
-			 "green-16005: Invalid item type observed, run fsck ASAP");
+	reiserfs_warning(NULL, "green-16005",
+			 "Invalid item type observed, run fsck ASAP");
 }
 
 static int errcatch_create_vi(struct virtual_node *vn,
 			      struct virtual_item *vi,
 			      int is_affected, int insert_size)
 {
-	reiserfs_warning(NULL,
-			 "green-16006: Invalid item type observed, run fsck ASAP");
+	reiserfs_warning(NULL, "green-16006",
+			 "Invalid item type observed, run fsck ASAP");
 	return 0;		// We might return -1 here as well, but it won't help as create_virtual_node() from where
 	// this operation is called from is of return type void.
 }
@@ -686,36 +690,36 @@ static int errcatch_create_vi(struct virtual_node *vn,
 static int errcatch_check_left(struct virtual_item *vi, int free,
 			       int start_skip, int end_skip)
 {
-	reiserfs_warning(NULL,
-			 "green-16007: Invalid item type observed, run fsck ASAP");
+	reiserfs_warning(NULL, "green-16007",
+			 "Invalid item type observed, run fsck ASAP");
 	return -1;
 }
 
 static int errcatch_check_right(struct virtual_item *vi, int free)
 {
-	reiserfs_warning(NULL,
-			 "green-16008: Invalid item type observed, run fsck ASAP");
+	reiserfs_warning(NULL, "green-16008",
+			 "Invalid item type observed, run fsck ASAP");
 	return -1;
 }
 
 static int errcatch_part_size(struct virtual_item *vi, int first, int count)
 {
-	reiserfs_warning(NULL,
-			 "green-16009: Invalid item type observed, run fsck ASAP");
+	reiserfs_warning(NULL, "green-16009",
+			 "Invalid item type observed, run fsck ASAP");
 	return 0;
 }
 
 static int errcatch_unit_num(struct virtual_item *vi)
 {
-	reiserfs_warning(NULL,
-			 "green-16010: Invalid item type observed, run fsck ASAP");
+	reiserfs_warning(NULL, "green-16010",
+			 "Invalid item type observed, run fsck ASAP");
 	return 0;
 }
 
 static void errcatch_print_vi(struct virtual_item *vi)
 {
-	reiserfs_warning(NULL,
-			 "green-16011: Invalid item type observed, run fsck ASAP");
+	reiserfs_warning(NULL, "green-16011",
+			 "Invalid item type observed, run fsck ASAP");
 }
 
 static struct item_operations errcatch_ops = {

commit 6d205f120547043de663315698dcf5f0eaa31b5c
Author: Vladimir Saveliev <vs@namesys.com>
Date:   Wed Apr 11 23:28:44 2007 -0700

    [PATCH] reiserfs: fix key decrementing
    
    This patch fixes a bug in function decrementing a key of stat data item.
    
    Offset of reiserfs keys are compared as signed values.  To set key offset
    to maximal possible value maximal signed value has to be used.
    
    This bug is responsible for severe reiserfs filesystem corruption which
    shows itself as warning vs-13060.  reiserfsck fixes this corruption by
    filesystem tree rebuilding.
    
    Signed-off-by: Vladimir Saveliev <vs@namesys.com>
    Cc: <reiserfs-dev@namesys.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
index b9b423b22a8b..9475557ab499 100644
--- a/fs/reiserfs/item_ops.c
+++ b/fs/reiserfs/item_ops.c
@@ -23,7 +23,7 @@ static void sd_decrement_key(struct cpu_key *key)
 {
 	key->on_disk_key.k_objectid--;
 	set_cpu_key_k_type(key, TYPE_ANY);
-	set_cpu_key_k_offset(key, (loff_t) (-1));
+	set_cpu_key_k_offset(key, (loff_t)(~0ULL >> 1));
 }
 
 static int sd_is_left_mergeable(struct reiserfs_key *key, unsigned long bsize)

commit 14a61442c2203d2a49f2f954bfa9259c0ddac1aa
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Tue Oct 3 23:36:38 2006 +0200

    BUG_ON conversion for fs/reiserfs
    
    This patch converts several if () BUG(); construct to BUG_ON();
    which occupies less space, uses unlikely and is safer when
    BUG() is disabled. S_ISREG() has no side effects, so the
    conversion is safe.
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
index 7a88adbceef6..b9b423b22a8b 100644
--- a/fs/reiserfs/item_ops.c
+++ b/fs/reiserfs/item_ops.c
@@ -75,8 +75,7 @@ static int sd_create_vi(struct virtual_node *vn,
 static int sd_check_left(struct virtual_item *vi, int free,
 			 int start_skip, int end_skip)
 {
-	if (start_skip || end_skip)
-		BUG();
+	BUG_ON(start_skip || end_skip);
 	return -1;
 }
 
@@ -87,8 +86,7 @@ static int sd_check_right(struct virtual_item *vi, int free)
 
 static int sd_part_size(struct virtual_item *vi, int first, int count)
 {
-	if (count)
-		BUG();
+	BUG_ON(count);
 	return 0;
 }
 
@@ -476,8 +474,7 @@ static int direntry_create_vi(struct virtual_node *vn,
 
 	vi->vi_index = TYPE_DIRENTRY;
 
-	if (!(vi->vi_ih) || !vi->vi_item)
-		BUG();
+	BUG_ON(!(vi->vi_ih) || !vi->vi_item);
 
 	dir_u->flags = 0;
 	if (le_ih_k_offset(vi->vi_ih) == DOT_OFFSET)
@@ -575,8 +572,7 @@ static int direntry_check_right(struct virtual_item *vi, int free)
 		free -= dir_u->entry_sizes[i];
 		entries++;
 	}
-	if (entries == dir_u->entry_count)
-		BUG();
+	BUG_ON(entries == dir_u->entry_count);
 
 	/* "." and ".." can not be separated from each other */
 	if ((dir_u->flags & DIRENTRY_VI_FIRST_DIRENTRY_ITEM)

commit d5ee4ea8334368b7d284a7d82855f6f16ba599b4
Author: Benoit Boissinot <benoit.boissinot@ens-lyon.org>
Date:   Sat Mar 25 03:07:54 2006 -0800

    [PATCH] indirect_print_item() warning fix
    
    fs/reiserfs/item_ops.c: In function 'indirect_print_item':
    fs/reiserfs/item_ops.c:278: warning: 'num' may be used uninitialized in this function
    
    (akpm: this is probably just gcc being dumb)
    
    Signed-off-by: Benoit Boissinot <benoit.boissinot@ens-lyon.fr>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
index e237cd668e5b..7a88adbceef6 100644
--- a/fs/reiserfs/item_ops.c
+++ b/fs/reiserfs/item_ops.c
@@ -275,7 +275,7 @@ static void indirect_print_item(struct item_head *ih, char *item)
 	int j;
 	__le32 *unp;
 	__u32 prev = INT_MAX;
-	int num;
+	int num = 0;
 
 	unp = (__le32 *) item;
 

commit bd4c625c061c2a38568d0add3478f59172455159
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Tue Jul 12 20:21:28 2005 -0700

    reiserfs: run scripts/Lindent on reiserfs code
    
    This was a pure indentation change, using:
    
            scripts/Lindent fs/reiserfs/*.c include/linux/reiserfs_*.h
    
    to make reiserfs match the regular Linux indentation style.  As Jeff
    Mahoney <jeffm@suse.com> writes:
    
     The ReiserFS code is a mix of a number of different coding styles, sometimes
     different even from line-to-line. Since the code has been relatively stable
     for quite some time and there are few outstanding patches to be applied, it
     is time to reformat the code to conform to the Linux style standard outlined
     in Documentation/CodingStyle.
    
     This patch contains the result of running scripts/Lindent against
     fs/reiserfs/*.c and include/linux/reiserfs_*.h. There are places where the
     code can be made to look better, but I'd rather keep those patches separate
     so that there isn't a subtle by-hand hand accident in the middle of a huge
     patch. To be clear: This patch is reformatting *only*.
    
     A number of patches may follow that continue to make the code more consistent
     with the Linux coding style.
    
     Hans wasn't particularly enthusiastic about these patches, but said he
     wouldn't really oppose them either.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
index e477aeba8c92..e237cd668e5b 100644
--- a/fs/reiserfs/item_ops.c
+++ b/fs/reiserfs/item_ops.c
@@ -14,760 +14,729 @@
 //////////////////////////////////////////////////////////////////////////////
 // stat data functions
 //
-static int sd_bytes_number (struct item_head * ih, int block_size)
+static int sd_bytes_number(struct item_head *ih, int block_size)
 {
-  return 0;
+	return 0;
 }
 
-static void sd_decrement_key (struct cpu_key * key)
+static void sd_decrement_key(struct cpu_key *key)
 {
-    key->on_disk_key.k_objectid --;
-    set_cpu_key_k_type (key, TYPE_ANY);
-    set_cpu_key_k_offset(key, (loff_t)(-1));
+	key->on_disk_key.k_objectid--;
+	set_cpu_key_k_type(key, TYPE_ANY);
+	set_cpu_key_k_offset(key, (loff_t) (-1));
 }
 
-static int sd_is_left_mergeable (struct reiserfs_key * key, unsigned long bsize)
+static int sd_is_left_mergeable(struct reiserfs_key *key, unsigned long bsize)
 {
-    return 0;
+	return 0;
 }
 
-
-
-static char * print_time (time_t t)
+static char *print_time(time_t t)
 {
-    static char timebuf[256];
+	static char timebuf[256];
 
-    sprintf (timebuf, "%ld", t);
-    return timebuf;
+	sprintf(timebuf, "%ld", t);
+	return timebuf;
 }
 
-
-static void sd_print_item (struct item_head * ih, char * item)
+static void sd_print_item(struct item_head *ih, char *item)
 {
-    printk ("\tmode | size | nlinks | first direct | mtime\n");
-    if (stat_data_v1 (ih)) {
-      	struct stat_data_v1 * sd = (struct stat_data_v1 *)item;
+	printk("\tmode | size | nlinks | first direct | mtime\n");
+	if (stat_data_v1(ih)) {
+		struct stat_data_v1 *sd = (struct stat_data_v1 *)item;
 
-	printk ("\t0%-6o | %6u | %2u | %d | %s\n", sd_v1_mode(sd),
-                sd_v1_size(sd), sd_v1_nlink(sd), sd_v1_first_direct_byte(sd),
-                print_time( sd_v1_mtime(sd) ) );
-    } else {
-	struct stat_data * sd = (struct stat_data *)item;
+		printk("\t0%-6o | %6u | %2u | %d | %s\n", sd_v1_mode(sd),
+		       sd_v1_size(sd), sd_v1_nlink(sd),
+		       sd_v1_first_direct_byte(sd),
+		       print_time(sd_v1_mtime(sd)));
+	} else {
+		struct stat_data *sd = (struct stat_data *)item;
 
-	printk ("\t0%-6o | %6Lu | %2u | %d | %s\n", sd_v2_mode(sd),
-            (unsigned long long)sd_v2_size(sd), sd_v2_nlink(sd),
-            sd_v2_rdev(sd), print_time(sd_v2_mtime(sd)));
-    }
+		printk("\t0%-6o | %6Lu | %2u | %d | %s\n", sd_v2_mode(sd),
+		       (unsigned long long)sd_v2_size(sd), sd_v2_nlink(sd),
+		       sd_v2_rdev(sd), print_time(sd_v2_mtime(sd)));
+	}
 }
 
-static void sd_check_item (struct item_head * ih, char * item)
+static void sd_check_item(struct item_head *ih, char *item)
 {
-    // FIXME: type something here!
+	// FIXME: type something here!
 }
 
-
-static int sd_create_vi (struct virtual_node * vn,
-			 struct virtual_item * vi, 
-			 int is_affected, 
-			 int insert_size)
+static int sd_create_vi(struct virtual_node *vn,
+			struct virtual_item *vi,
+			int is_affected, int insert_size)
 {
-    vi->vi_index = TYPE_STAT_DATA;
-    //vi->vi_type |= VI_TYPE_STAT_DATA;// not needed?
-    return 0;
+	vi->vi_index = TYPE_STAT_DATA;
+	//vi->vi_type |= VI_TYPE_STAT_DATA;// not needed?
+	return 0;
 }
 
-
-static int sd_check_left (struct virtual_item * vi, int free, 
-			  int start_skip, int end_skip)
+static int sd_check_left(struct virtual_item *vi, int free,
+			 int start_skip, int end_skip)
 {
-    if (start_skip || end_skip)
-	BUG ();
-    return -1;
+	if (start_skip || end_skip)
+		BUG();
+	return -1;
 }
 
-
-static int sd_check_right (struct virtual_item * vi, int free)
+static int sd_check_right(struct virtual_item *vi, int free)
 {
-    return -1;
+	return -1;
 }
 
-static int sd_part_size (struct virtual_item * vi, int first, int count)
+static int sd_part_size(struct virtual_item *vi, int first, int count)
 {
-    if (count)
-	BUG ();
-    return 0;
+	if (count)
+		BUG();
+	return 0;
 }
 
-static int sd_unit_num (struct virtual_item * vi)
+static int sd_unit_num(struct virtual_item *vi)
 {
-    return vi->vi_item_len - IH_SIZE;
+	return vi->vi_item_len - IH_SIZE;
 }
 
-
-static void sd_print_vi (struct virtual_item * vi)
+static void sd_print_vi(struct virtual_item *vi)
 {
-    reiserfs_warning (NULL, "STATDATA, index %d, type 0x%x, %h",
-		      vi->vi_index, vi->vi_type, vi->vi_ih);
+	reiserfs_warning(NULL, "STATDATA, index %d, type 0x%x, %h",
+			 vi->vi_index, vi->vi_type, vi->vi_ih);
 }
 
 static struct item_operations stat_data_ops = {
-	.bytes_number		= sd_bytes_number,
-	.decrement_key		= sd_decrement_key,
-	.is_left_mergeable	= sd_is_left_mergeable,
-	.print_item		= sd_print_item,
-	.check_item		= sd_check_item,
-
-	.create_vi		= sd_create_vi,
-	.check_left		= sd_check_left,
-	.check_right		= sd_check_right,
-	.part_size		= sd_part_size,
-	.unit_num		= sd_unit_num,
-	.print_vi		= sd_print_vi
+	.bytes_number = sd_bytes_number,
+	.decrement_key = sd_decrement_key,
+	.is_left_mergeable = sd_is_left_mergeable,
+	.print_item = sd_print_item,
+	.check_item = sd_check_item,
+
+	.create_vi = sd_create_vi,
+	.check_left = sd_check_left,
+	.check_right = sd_check_right,
+	.part_size = sd_part_size,
+	.unit_num = sd_unit_num,
+	.print_vi = sd_print_vi
 };
 
-
-
 //////////////////////////////////////////////////////////////////////////////
 // direct item functions
 //
-static int direct_bytes_number (struct item_head * ih, int block_size)
+static int direct_bytes_number(struct item_head *ih, int block_size)
 {
-  return ih_item_len(ih);
+	return ih_item_len(ih);
 }
 
-
 // FIXME: this should probably switch to indirect as well
-static void direct_decrement_key (struct cpu_key * key)
+static void direct_decrement_key(struct cpu_key *key)
 {
-    cpu_key_k_offset_dec (key);
-    if (cpu_key_k_offset (key) == 0)
-	set_cpu_key_k_type (key, TYPE_STAT_DATA);	
+	cpu_key_k_offset_dec(key);
+	if (cpu_key_k_offset(key) == 0)
+		set_cpu_key_k_type(key, TYPE_STAT_DATA);
 }
 
-
-static int direct_is_left_mergeable (struct reiserfs_key * key, unsigned long bsize)
+static int direct_is_left_mergeable(struct reiserfs_key *key,
+				    unsigned long bsize)
 {
-    int version = le_key_version (key);
-    return ((le_key_k_offset (version, key) & (bsize - 1)) != 1);
+	int version = le_key_version(key);
+	return ((le_key_k_offset(version, key) & (bsize - 1)) != 1);
 }
 
-
-static void direct_print_item (struct item_head * ih, char * item)
+static void direct_print_item(struct item_head *ih, char *item)
 {
-    int j = 0;
+	int j = 0;
 
 //    return;
-    printk ("\"");
-    while (j < ih_item_len(ih))
-	printk ("%c", item[j++]);
-    printk ("\"\n");
+	printk("\"");
+	while (j < ih_item_len(ih))
+		printk("%c", item[j++]);
+	printk("\"\n");
 }
 
-
-static void direct_check_item (struct item_head * ih, char * item)
+static void direct_check_item(struct item_head *ih, char *item)
 {
-    // FIXME: type something here!
+	// FIXME: type something here!
 }
 
-
-static int direct_create_vi (struct virtual_node * vn,
-			     struct virtual_item * vi, 
-			     int is_affected, 
-			     int insert_size)
+static int direct_create_vi(struct virtual_node *vn,
+			    struct virtual_item *vi,
+			    int is_affected, int insert_size)
 {
-    vi->vi_index = TYPE_DIRECT;
-    //vi->vi_type |= VI_TYPE_DIRECT;
-    return 0;
+	vi->vi_index = TYPE_DIRECT;
+	//vi->vi_type |= VI_TYPE_DIRECT;
+	return 0;
 }
 
-static int direct_check_left (struct virtual_item * vi, int free,
-			      int start_skip, int end_skip)
+static int direct_check_left(struct virtual_item *vi, int free,
+			     int start_skip, int end_skip)
 {
-    int bytes;
+	int bytes;
 
-    bytes = free - free % 8;
-    return bytes ?: -1;    
+	bytes = free - free % 8;
+	return bytes ? : -1;
 }
 
-
-static int direct_check_right (struct virtual_item * vi, int free)
+static int direct_check_right(struct virtual_item *vi, int free)
 {
-    return direct_check_left (vi, free, 0, 0);
+	return direct_check_left(vi, free, 0, 0);
 }
 
-static int direct_part_size (struct virtual_item * vi, int first, int count)
+static int direct_part_size(struct virtual_item *vi, int first, int count)
 {
-    return count;
+	return count;
 }
 
-
-static int direct_unit_num (struct virtual_item * vi)
+static int direct_unit_num(struct virtual_item *vi)
 {
-    return vi->vi_item_len - IH_SIZE;
+	return vi->vi_item_len - IH_SIZE;
 }
 
-
-static void direct_print_vi (struct virtual_item * vi)
+static void direct_print_vi(struct virtual_item *vi)
 {
-    reiserfs_warning (NULL, "DIRECT, index %d, type 0x%x, %h",
-		      vi->vi_index, vi->vi_type, vi->vi_ih);
+	reiserfs_warning(NULL, "DIRECT, index %d, type 0x%x, %h",
+			 vi->vi_index, vi->vi_type, vi->vi_ih);
 }
 
 static struct item_operations direct_ops = {
-	.bytes_number		= direct_bytes_number,
-	.decrement_key		= direct_decrement_key,
-	.is_left_mergeable	= direct_is_left_mergeable,
-	.print_item		= direct_print_item,
-	.check_item		= direct_check_item,
-
-	.create_vi		= direct_create_vi,
-	.check_left		= direct_check_left,
-	.check_right		= direct_check_right,
-	.part_size		= direct_part_size,
-	.unit_num		= direct_unit_num,
-	.print_vi		= direct_print_vi
+	.bytes_number = direct_bytes_number,
+	.decrement_key = direct_decrement_key,
+	.is_left_mergeable = direct_is_left_mergeable,
+	.print_item = direct_print_item,
+	.check_item = direct_check_item,
+
+	.create_vi = direct_create_vi,
+	.check_left = direct_check_left,
+	.check_right = direct_check_right,
+	.part_size = direct_part_size,
+	.unit_num = direct_unit_num,
+	.print_vi = direct_print_vi
 };
 
-
-
 //////////////////////////////////////////////////////////////////////////////
 // indirect item functions
 //
 
-static int indirect_bytes_number (struct item_head * ih, int block_size)
+static int indirect_bytes_number(struct item_head *ih, int block_size)
 {
-  return ih_item_len(ih) / UNFM_P_SIZE * block_size; //- get_ih_free_space (ih);
+	return ih_item_len(ih) / UNFM_P_SIZE * block_size;	//- get_ih_free_space (ih);
 }
 
-
 // decrease offset, if it becomes 0, change type to stat data
-static void indirect_decrement_key (struct cpu_key * key)
+static void indirect_decrement_key(struct cpu_key *key)
 {
-    cpu_key_k_offset_dec (key);
-    if (cpu_key_k_offset (key) == 0)
-	set_cpu_key_k_type (key, TYPE_STAT_DATA);
+	cpu_key_k_offset_dec(key);
+	if (cpu_key_k_offset(key) == 0)
+		set_cpu_key_k_type(key, TYPE_STAT_DATA);
 }
 
-
 // if it is not first item of the body, then it is mergeable
-static int indirect_is_left_mergeable (struct reiserfs_key * key, unsigned long bsize)
+static int indirect_is_left_mergeable(struct reiserfs_key *key,
+				      unsigned long bsize)
 {
-    int version = le_key_version (key);
-    return (le_key_k_offset (version, key) != 1);
+	int version = le_key_version(key);
+	return (le_key_k_offset(version, key) != 1);
 }
 
-
 // printing of indirect item
-static void start_new_sequence (__u32 * start, int * len, __u32 new)
+static void start_new_sequence(__u32 * start, int *len, __u32 new)
 {
-    *start = new;
-    *len = 1;
+	*start = new;
+	*len = 1;
 }
 
-
-static int sequence_finished (__u32 start, int * len, __u32 new)
+static int sequence_finished(__u32 start, int *len, __u32 new)
 {
-    if (start == INT_MAX)
-	return 1;
+	if (start == INT_MAX)
+		return 1;
 
-    if (start == 0 && new == 0) {
-	(*len) ++;
-	return 0;
-    }
-    if (start != 0 && (start + *len) == new) {
-	(*len) ++;
-	return 0;
-    }
-    return 1;
+	if (start == 0 && new == 0) {
+		(*len)++;
+		return 0;
+	}
+	if (start != 0 && (start + *len) == new) {
+		(*len)++;
+		return 0;
+	}
+	return 1;
 }
 
-static void print_sequence (__u32 start, int len)
+static void print_sequence(__u32 start, int len)
 {
-    if (start == INT_MAX)
-	return;
+	if (start == INT_MAX)
+		return;
 
-    if (len == 1)
-	printk (" %d", start);
-    else
-	printk (" %d(%d)", start, len);
+	if (len == 1)
+		printk(" %d", start);
+	else
+		printk(" %d(%d)", start, len);
 }
 
-
-static void indirect_print_item (struct item_head * ih, char * item)
+static void indirect_print_item(struct item_head *ih, char *item)
 {
-    int j;
-    __le32 * unp;
-    __u32 prev = INT_MAX;
-    int num;
+	int j;
+	__le32 *unp;
+	__u32 prev = INT_MAX;
+	int num;
 
-    unp = (__le32 *)item;
+	unp = (__le32 *) item;
 
-    if (ih_item_len(ih) % UNFM_P_SIZE)
-	reiserfs_warning (NULL, "indirect_print_item: invalid item len");
+	if (ih_item_len(ih) % UNFM_P_SIZE)
+		reiserfs_warning(NULL, "indirect_print_item: invalid item len");
 
-    printk ("%d pointers\n[ ", (int)I_UNFM_NUM (ih));
-    for (j = 0; j < I_UNFM_NUM (ih); j ++) {
-	if (sequence_finished (prev, &num, get_block_num(unp, j))) {
-	    print_sequence (prev, num);
-	    start_new_sequence (&prev, &num, get_block_num(unp, j));
+	printk("%d pointers\n[ ", (int)I_UNFM_NUM(ih));
+	for (j = 0; j < I_UNFM_NUM(ih); j++) {
+		if (sequence_finished(prev, &num, get_block_num(unp, j))) {
+			print_sequence(prev, num);
+			start_new_sequence(&prev, &num, get_block_num(unp, j));
+		}
 	}
-    }
-    print_sequence (prev, num);
-    printk ("]\n");
+	print_sequence(prev, num);
+	printk("]\n");
 }
 
-static void indirect_check_item (struct item_head * ih, char * item)
+static void indirect_check_item(struct item_head *ih, char *item)
 {
-    // FIXME: type something here!
+	// FIXME: type something here!
 }
 
-
-static int indirect_create_vi (struct virtual_node * vn,
-			       struct virtual_item * vi, 
-			       int is_affected, 
-			       int insert_size)
+static int indirect_create_vi(struct virtual_node *vn,
+			      struct virtual_item *vi,
+			      int is_affected, int insert_size)
 {
-    vi->vi_index = TYPE_INDIRECT;
-    //vi->vi_type |= VI_TYPE_INDIRECT;
-    return 0;
+	vi->vi_index = TYPE_INDIRECT;
+	//vi->vi_type |= VI_TYPE_INDIRECT;
+	return 0;
 }
 
-static int indirect_check_left (struct virtual_item * vi, int free,
-				int start_skip, int end_skip)
+static int indirect_check_left(struct virtual_item *vi, int free,
+			       int start_skip, int end_skip)
 {
-    int bytes;
+	int bytes;
 
-    bytes = free - free % UNFM_P_SIZE;
-    return bytes ?: -1;    
+	bytes = free - free % UNFM_P_SIZE;
+	return bytes ? : -1;
 }
 
-
-static int indirect_check_right (struct virtual_item * vi, int free)
+static int indirect_check_right(struct virtual_item *vi, int free)
 {
-    return indirect_check_left (vi, free, 0, 0);
+	return indirect_check_left(vi, free, 0, 0);
 }
 
-
-
 // return size in bytes of 'units' units. If first == 0 - calculate from the head (left), otherwise - from tail (right)
-static int indirect_part_size (struct virtual_item * vi, int first, int units)
+static int indirect_part_size(struct virtual_item *vi, int first, int units)
 {
-    // unit of indirect item is byte (yet)
-    return units;
+	// unit of indirect item is byte (yet)
+	return units;
 }
 
-static int indirect_unit_num (struct virtual_item * vi)
+static int indirect_unit_num(struct virtual_item *vi)
 {
-    // unit of indirect item is byte (yet)
-    return vi->vi_item_len - IH_SIZE;
+	// unit of indirect item is byte (yet)
+	return vi->vi_item_len - IH_SIZE;
 }
 
-static void indirect_print_vi (struct virtual_item * vi)
+static void indirect_print_vi(struct virtual_item *vi)
 {
-    reiserfs_warning (NULL, "INDIRECT, index %d, type 0x%x, %h",
-		      vi->vi_index, vi->vi_type, vi->vi_ih);
+	reiserfs_warning(NULL, "INDIRECT, index %d, type 0x%x, %h",
+			 vi->vi_index, vi->vi_type, vi->vi_ih);
 }
 
 static struct item_operations indirect_ops = {
-	.bytes_number		= indirect_bytes_number,
-	.decrement_key		= indirect_decrement_key,
-	.is_left_mergeable	= indirect_is_left_mergeable,
-	.print_item		= indirect_print_item,
-	.check_item		= indirect_check_item,
-
-	.create_vi		= indirect_create_vi,
-	.check_left		= indirect_check_left,
-	.check_right		= indirect_check_right,
-	.part_size		= indirect_part_size,
-	.unit_num		= indirect_unit_num,
-	.print_vi		= indirect_print_vi
+	.bytes_number = indirect_bytes_number,
+	.decrement_key = indirect_decrement_key,
+	.is_left_mergeable = indirect_is_left_mergeable,
+	.print_item = indirect_print_item,
+	.check_item = indirect_check_item,
+
+	.create_vi = indirect_create_vi,
+	.check_left = indirect_check_left,
+	.check_right = indirect_check_right,
+	.part_size = indirect_part_size,
+	.unit_num = indirect_unit_num,
+	.print_vi = indirect_print_vi
 };
 
-
 //////////////////////////////////////////////////////////////////////////////
 // direntry functions
 //
 
-
-static int direntry_bytes_number (struct item_head * ih, int block_size)
+static int direntry_bytes_number(struct item_head *ih, int block_size)
 {
-    reiserfs_warning (NULL, "vs-16090: direntry_bytes_number: "
-		      "bytes number is asked for direntry");
-    return 0;
-}
-
-static void direntry_decrement_key (struct cpu_key * key)
-{
-    cpu_key_k_offset_dec (key);
-    if (cpu_key_k_offset (key) == 0)
-	set_cpu_key_k_type (key, TYPE_STAT_DATA);	
+	reiserfs_warning(NULL, "vs-16090: direntry_bytes_number: "
+			 "bytes number is asked for direntry");
+	return 0;
 }
 
-
-static int direntry_is_left_mergeable (struct reiserfs_key * key, unsigned long bsize)
+static void direntry_decrement_key(struct cpu_key *key)
 {
-    if (le32_to_cpu (key->u.k_offset_v1.k_offset) == DOT_OFFSET)
-	return 0;
-    return 1;
-	
+	cpu_key_k_offset_dec(key);
+	if (cpu_key_k_offset(key) == 0)
+		set_cpu_key_k_type(key, TYPE_STAT_DATA);
 }
 
-
-static void direntry_print_item (struct item_head * ih, char * item)
+static int direntry_is_left_mergeable(struct reiserfs_key *key,
+				      unsigned long bsize)
 {
-    int i;
-    int namelen;
-    struct reiserfs_de_head * deh;
-    char * name;
-    static char namebuf [80];
-
-
-    printk ("\n # %-15s%-30s%-15s%-15s%-15s\n", "Name", "Key of pointed object", "Hash", "Gen number", "Status");
+	if (le32_to_cpu(key->u.k_offset_v1.k_offset) == DOT_OFFSET)
+		return 0;
+	return 1;
 
-    deh = (struct reiserfs_de_head *)item;
+}
 
-    for (i = 0; i < I_ENTRY_COUNT (ih); i ++, deh ++) {
-	namelen = (i ? (deh_location(deh - 1)) : ih_item_len(ih)) - deh_location(deh);
-	name = item + deh_location(deh);
-	if (name[namelen-1] == 0)
-	  namelen = strlen (name);
-	namebuf[0] = '"';
-	if (namelen > sizeof (namebuf) - 3) {
-	    strncpy (namebuf + 1, name, sizeof (namebuf) - 3);
-	    namebuf[sizeof (namebuf) - 2] = '"';
-	    namebuf[sizeof (namebuf) - 1] = 0;
-	} else {
-	    memcpy (namebuf + 1, name, namelen);
-	    namebuf[namelen + 1] = '"';
-	    namebuf[namelen + 2] = 0;
+static void direntry_print_item(struct item_head *ih, char *item)
+{
+	int i;
+	int namelen;
+	struct reiserfs_de_head *deh;
+	char *name;
+	static char namebuf[80];
+
+	printk("\n # %-15s%-30s%-15s%-15s%-15s\n", "Name",
+	       "Key of pointed object", "Hash", "Gen number", "Status");
+
+	deh = (struct reiserfs_de_head *)item;
+
+	for (i = 0; i < I_ENTRY_COUNT(ih); i++, deh++) {
+		namelen =
+		    (i ? (deh_location(deh - 1)) : ih_item_len(ih)) -
+		    deh_location(deh);
+		name = item + deh_location(deh);
+		if (name[namelen - 1] == 0)
+			namelen = strlen(name);
+		namebuf[0] = '"';
+		if (namelen > sizeof(namebuf) - 3) {
+			strncpy(namebuf + 1, name, sizeof(namebuf) - 3);
+			namebuf[sizeof(namebuf) - 2] = '"';
+			namebuf[sizeof(namebuf) - 1] = 0;
+		} else {
+			memcpy(namebuf + 1, name, namelen);
+			namebuf[namelen + 1] = '"';
+			namebuf[namelen + 2] = 0;
+		}
+
+		printk("%d:  %-15s%-15d%-15d%-15Ld%-15Ld(%s)\n",
+		       i, namebuf,
+		       deh_dir_id(deh), deh_objectid(deh),
+		       GET_HASH_VALUE(deh_offset(deh)),
+		       GET_GENERATION_NUMBER((deh_offset(deh))),
+		       (de_hidden(deh)) ? "HIDDEN" : "VISIBLE");
 	}
-
-	printk ("%d:  %-15s%-15d%-15d%-15Ld%-15Ld(%s)\n", 
-		i, namebuf,
-		deh_dir_id(deh), deh_objectid(deh),
-		GET_HASH_VALUE (deh_offset (deh)), GET_GENERATION_NUMBER ((deh_offset (deh))),
-		(de_hidden (deh)) ? "HIDDEN" : "VISIBLE");
-    }
 }
 
-
-static void direntry_check_item (struct item_head * ih, char * item)
+static void direntry_check_item(struct item_head *ih, char *item)
 {
-    int i;
-    struct reiserfs_de_head * deh;
+	int i;
+	struct reiserfs_de_head *deh;
 
-    // FIXME: type something here!
-    deh = (struct reiserfs_de_head *)item;
-    for (i = 0; i < I_ENTRY_COUNT (ih); i ++, deh ++) {
-	;
-    }
+	// FIXME: type something here!
+	deh = (struct reiserfs_de_head *)item;
+	for (i = 0; i < I_ENTRY_COUNT(ih); i++, deh++) {
+		;
+	}
 }
 
-
-
 #define DIRENTRY_VI_FIRST_DIRENTRY_ITEM 1
 
 /*
  * function returns old entry number in directory item in real node
  * using new entry number in virtual item in virtual node */
-static inline int old_entry_num (int is_affected, int virtual_entry_num, int pos_in_item, int mode)
+static inline int old_entry_num(int is_affected, int virtual_entry_num,
+				int pos_in_item, int mode)
 {
-    if ( mode == M_INSERT || mode == M_DELETE)
-	return virtual_entry_num;
-    
-    if (!is_affected)
-	/* cut or paste is applied to another item */
-	return virtual_entry_num;
-
-    if (virtual_entry_num < pos_in_item)
-	return virtual_entry_num;
+	if (mode == M_INSERT || mode == M_DELETE)
+		return virtual_entry_num;
 
-    if (mode == M_CUT)
-	return virtual_entry_num + 1;
+	if (!is_affected)
+		/* cut or paste is applied to another item */
+		return virtual_entry_num;
 
-    RFALSE( mode != M_PASTE || virtual_entry_num == 0,
-	    "vs-8015: old_entry_num: mode must be M_PASTE (mode = \'%c\'", mode);
-    
-    return virtual_entry_num - 1;
-}
+	if (virtual_entry_num < pos_in_item)
+		return virtual_entry_num;
 
+	if (mode == M_CUT)
+		return virtual_entry_num + 1;
 
+	RFALSE(mode != M_PASTE || virtual_entry_num == 0,
+	       "vs-8015: old_entry_num: mode must be M_PASTE (mode = \'%c\'",
+	       mode);
 
+	return virtual_entry_num - 1;
+}
 
 /* Create an array of sizes of directory entries for virtual
    item. Return space used by an item. FIXME: no control over
    consuming of space used by this item handler */
-static int direntry_create_vi (struct virtual_node * vn,
-			       struct virtual_item * vi, 
-			       int is_affected, 
-			       int insert_size)
-{
-    struct direntry_uarea * dir_u = vi->vi_uarea;
-    int i, j;
-    int size = sizeof (struct direntry_uarea);
-    struct reiserfs_de_head * deh;
-  
-    vi->vi_index = TYPE_DIRENTRY;
-
-    if (!(vi->vi_ih) || !vi->vi_item)
-	BUG ();
-
-
-    dir_u->flags = 0;
-    if (le_ih_k_offset (vi->vi_ih) == DOT_OFFSET)
-	dir_u->flags |= DIRENTRY_VI_FIRST_DIRENTRY_ITEM;
-
-    deh = (struct reiserfs_de_head *)(vi->vi_item);
-    
-    
-    /* virtual directory item have this amount of entry after */
-    dir_u->entry_count = ih_entry_count (vi->vi_ih) + 
-	((is_affected) ? ((vn->vn_mode == M_CUT) ? -1 :
-			  (vn->vn_mode == M_PASTE ? 1 : 0)) : 0);
-    
-    for (i = 0; i < dir_u->entry_count; i ++) {
-	j = old_entry_num (is_affected, i, vn->vn_pos_in_item, vn->vn_mode);
-        dir_u->entry_sizes[i] = (j ? deh_location( &(deh[j - 1]) ) :
-                                ih_item_len (vi->vi_ih)) -
-                                deh_location( &(deh[j])) + DEH_SIZE;
-    }
-
-    size += (dir_u->entry_count * sizeof (short));
-    
-    /* set size of pasted entry */
-    if (is_affected && vn->vn_mode == M_PASTE)
-	dir_u->entry_sizes[vn->vn_pos_in_item] = insert_size;
+static int direntry_create_vi(struct virtual_node *vn,
+			      struct virtual_item *vi,
+			      int is_affected, int insert_size)
+{
+	struct direntry_uarea *dir_u = vi->vi_uarea;
+	int i, j;
+	int size = sizeof(struct direntry_uarea);
+	struct reiserfs_de_head *deh;
 
+	vi->vi_index = TYPE_DIRENTRY;
+
+	if (!(vi->vi_ih) || !vi->vi_item)
+		BUG();
+
+	dir_u->flags = 0;
+	if (le_ih_k_offset(vi->vi_ih) == DOT_OFFSET)
+		dir_u->flags |= DIRENTRY_VI_FIRST_DIRENTRY_ITEM;
+
+	deh = (struct reiserfs_de_head *)(vi->vi_item);
+
+	/* virtual directory item have this amount of entry after */
+	dir_u->entry_count = ih_entry_count(vi->vi_ih) +
+	    ((is_affected) ? ((vn->vn_mode == M_CUT) ? -1 :
+			      (vn->vn_mode == M_PASTE ? 1 : 0)) : 0);
+
+	for (i = 0; i < dir_u->entry_count; i++) {
+		j = old_entry_num(is_affected, i, vn->vn_pos_in_item,
+				  vn->vn_mode);
+		dir_u->entry_sizes[i] =
+		    (j ? deh_location(&(deh[j - 1])) : ih_item_len(vi->vi_ih)) -
+		    deh_location(&(deh[j])) + DEH_SIZE;
+	}
+
+	size += (dir_u->entry_count * sizeof(short));
+
+	/* set size of pasted entry */
+	if (is_affected && vn->vn_mode == M_PASTE)
+		dir_u->entry_sizes[vn->vn_pos_in_item] = insert_size;
 
 #ifdef CONFIG_REISERFS_CHECK
-    /* compare total size of entries with item length */
-    {
-	int k, l;
-    
-	l = 0;
-	for (k = 0; k < dir_u->entry_count; k ++)
-	    l += dir_u->entry_sizes[k];
-    
-	if (l + IH_SIZE != vi->vi_item_len + 
-	    ((is_affected && (vn->vn_mode == M_PASTE || vn->vn_mode == M_CUT)) ? insert_size : 0) ) {
-	    reiserfs_panic (NULL, "vs-8025: set_entry_sizes: (mode==%c, insert_size==%d), invalid length of directory item",
-			    vn->vn_mode, insert_size);
+	/* compare total size of entries with item length */
+	{
+		int k, l;
+
+		l = 0;
+		for (k = 0; k < dir_u->entry_count; k++)
+			l += dir_u->entry_sizes[k];
+
+		if (l + IH_SIZE != vi->vi_item_len +
+		    ((is_affected
+		      && (vn->vn_mode == M_PASTE
+			  || vn->vn_mode == M_CUT)) ? insert_size : 0)) {
+			reiserfs_panic(NULL,
+				       "vs-8025: set_entry_sizes: (mode==%c, insert_size==%d), invalid length of directory item",
+				       vn->vn_mode, insert_size);
+		}
 	}
-    }
 #endif
 
-    return size;
-
+	return size;
 
 }
 
-
 //
 // return number of entries which may fit into specified amount of
 // free space, or -1 if free space is not enough even for 1 entry
 //
-static int direntry_check_left (struct virtual_item * vi, int free,
-				int start_skip, int end_skip)
+static int direntry_check_left(struct virtual_item *vi, int free,
+			       int start_skip, int end_skip)
 {
-    int i;
-    int entries = 0;
-    struct direntry_uarea * dir_u = vi->vi_uarea;
+	int i;
+	int entries = 0;
+	struct direntry_uarea *dir_u = vi->vi_uarea;
 
-    for (i = start_skip; i < dir_u->entry_count - end_skip; i ++) {
-	if (dir_u->entry_sizes[i] > free)
-	    /* i-th entry doesn't fit into the remaining free space */
-	    break;
-		  
-	free -= dir_u->entry_sizes[i];
-	entries ++;
-    }
+	for (i = start_skip; i < dir_u->entry_count - end_skip; i++) {
+		if (dir_u->entry_sizes[i] > free)
+			/* i-th entry doesn't fit into the remaining free space */
+			break;
 
-    if (entries == dir_u->entry_count) {
-	reiserfs_panic (NULL, "free space %d, entry_count %d\n", free, dir_u->entry_count);
-    }
+		free -= dir_u->entry_sizes[i];
+		entries++;
+	}
 
-    /* "." and ".." can not be separated from each other */
-    if (start_skip == 0 && (dir_u->flags & DIRENTRY_VI_FIRST_DIRENTRY_ITEM) && entries < 2)
-	entries = 0;
-    
-    return entries ?: -1;
-}
+	if (entries == dir_u->entry_count) {
+		reiserfs_panic(NULL, "free space %d, entry_count %d\n", free,
+			       dir_u->entry_count);
+	}
 
+	/* "." and ".." can not be separated from each other */
+	if (start_skip == 0 && (dir_u->flags & DIRENTRY_VI_FIRST_DIRENTRY_ITEM)
+	    && entries < 2)
+		entries = 0;
 
-static int direntry_check_right (struct virtual_item * vi, int free)
+	return entries ? : -1;
+}
+
+static int direntry_check_right(struct virtual_item *vi, int free)
 {
-    int i;
-    int entries = 0;
-    struct direntry_uarea * dir_u = vi->vi_uarea;
-    
-    for (i = dir_u->entry_count - 1; i >= 0; i --) {
-	if (dir_u->entry_sizes[i] > free)
-	    /* i-th entry doesn't fit into the remaining free space */
-	    break;
-	
-	free -= dir_u->entry_sizes[i];
-	entries ++;
-    }
-    if (entries == dir_u->entry_count)
-	BUG ();
+	int i;
+	int entries = 0;
+	struct direntry_uarea *dir_u = vi->vi_uarea;
 
-    /* "." and ".." can not be separated from each other */
-    if ((dir_u->flags & DIRENTRY_VI_FIRST_DIRENTRY_ITEM) && entries > dir_u->entry_count - 2)
-	entries = dir_u->entry_count - 2;
+	for (i = dir_u->entry_count - 1; i >= 0; i--) {
+		if (dir_u->entry_sizes[i] > free)
+			/* i-th entry doesn't fit into the remaining free space */
+			break;
 
-    return entries ?: -1;
-}
+		free -= dir_u->entry_sizes[i];
+		entries++;
+	}
+	if (entries == dir_u->entry_count)
+		BUG();
 
+	/* "." and ".." can not be separated from each other */
+	if ((dir_u->flags & DIRENTRY_VI_FIRST_DIRENTRY_ITEM)
+	    && entries > dir_u->entry_count - 2)
+		entries = dir_u->entry_count - 2;
+
+	return entries ? : -1;
+}
 
 /* sum of entry sizes between from-th and to-th entries including both edges */
-static int direntry_part_size (struct virtual_item * vi, int first, int count)
+static int direntry_part_size(struct virtual_item *vi, int first, int count)
 {
-    int i, retval;
-    int from, to;
-    struct direntry_uarea * dir_u = vi->vi_uarea;
-    
-    retval = 0;
-    if (first == 0)
-	from = 0;
-    else
-	from = dir_u->entry_count - count;
-    to = from + count - 1;
+	int i, retval;
+	int from, to;
+	struct direntry_uarea *dir_u = vi->vi_uarea;
 
-    for (i = from; i <= to; i ++)
-	retval += dir_u->entry_sizes[i];
+	retval = 0;
+	if (first == 0)
+		from = 0;
+	else
+		from = dir_u->entry_count - count;
+	to = from + count - 1;
 
-    return retval;
-}
+	for (i = from; i <= to; i++)
+		retval += dir_u->entry_sizes[i];
 
-static int direntry_unit_num (struct virtual_item * vi)
-{
-    struct direntry_uarea * dir_u = vi->vi_uarea;
-    
-    return dir_u->entry_count;
+	return retval;
 }
 
+static int direntry_unit_num(struct virtual_item *vi)
+{
+	struct direntry_uarea *dir_u = vi->vi_uarea;
 
+	return dir_u->entry_count;
+}
 
-static void direntry_print_vi (struct virtual_item * vi)
+static void direntry_print_vi(struct virtual_item *vi)
 {
-    int i;
-    struct direntry_uarea * dir_u = vi->vi_uarea;
+	int i;
+	struct direntry_uarea *dir_u = vi->vi_uarea;
 
-    reiserfs_warning (NULL, "DIRENTRY, index %d, type 0x%x, %h, flags 0x%x",
-		      vi->vi_index, vi->vi_type, vi->vi_ih, dir_u->flags);
-    printk ("%d entries: ", dir_u->entry_count);
-    for (i = 0; i < dir_u->entry_count; i ++)
-	printk ("%d ", dir_u->entry_sizes[i]);
-    printk ("\n");
+	reiserfs_warning(NULL, "DIRENTRY, index %d, type 0x%x, %h, flags 0x%x",
+			 vi->vi_index, vi->vi_type, vi->vi_ih, dir_u->flags);
+	printk("%d entries: ", dir_u->entry_count);
+	for (i = 0; i < dir_u->entry_count; i++)
+		printk("%d ", dir_u->entry_sizes[i]);
+	printk("\n");
 }
 
 static struct item_operations direntry_ops = {
-	.bytes_number		= direntry_bytes_number,
-	.decrement_key		= direntry_decrement_key,
-	.is_left_mergeable	= direntry_is_left_mergeable,
-	.print_item		= direntry_print_item,
-	.check_item		= direntry_check_item,
-
-	.create_vi		= direntry_create_vi,
-	.check_left		= direntry_check_left,
-	.check_right		= direntry_check_right,
-	.part_size		= direntry_part_size,
-	.unit_num		= direntry_unit_num,
-	.print_vi		= direntry_print_vi
+	.bytes_number = direntry_bytes_number,
+	.decrement_key = direntry_decrement_key,
+	.is_left_mergeable = direntry_is_left_mergeable,
+	.print_item = direntry_print_item,
+	.check_item = direntry_check_item,
+
+	.create_vi = direntry_create_vi,
+	.check_left = direntry_check_left,
+	.check_right = direntry_check_right,
+	.part_size = direntry_part_size,
+	.unit_num = direntry_unit_num,
+	.print_vi = direntry_print_vi
 };
 
-
 //////////////////////////////////////////////////////////////////////////////
 // Error catching functions to catch errors caused by incorrect item types.
 //
-static int errcatch_bytes_number (struct item_head * ih, int block_size)
+static int errcatch_bytes_number(struct item_head *ih, int block_size)
 {
-    reiserfs_warning (NULL, "green-16001: Invalid item type observed, run fsck ASAP");
-    return 0;
+	reiserfs_warning(NULL,
+			 "green-16001: Invalid item type observed, run fsck ASAP");
+	return 0;
 }
 
-static void errcatch_decrement_key (struct cpu_key * key)
+static void errcatch_decrement_key(struct cpu_key *key)
 {
-    reiserfs_warning (NULL, "green-16002: Invalid item type observed, run fsck ASAP");
+	reiserfs_warning(NULL,
+			 "green-16002: Invalid item type observed, run fsck ASAP");
 }
 
-
-static int errcatch_is_left_mergeable (struct reiserfs_key * key, unsigned long bsize)
+static int errcatch_is_left_mergeable(struct reiserfs_key *key,
+				      unsigned long bsize)
 {
-    reiserfs_warning (NULL, "green-16003: Invalid item type observed, run fsck ASAP");
-    return 0;
+	reiserfs_warning(NULL,
+			 "green-16003: Invalid item type observed, run fsck ASAP");
+	return 0;
 }
 
-
-static void errcatch_print_item (struct item_head * ih, char * item)
+static void errcatch_print_item(struct item_head *ih, char *item)
 {
-    reiserfs_warning (NULL, "green-16004: Invalid item type observed, run fsck ASAP");
+	reiserfs_warning(NULL,
+			 "green-16004: Invalid item type observed, run fsck ASAP");
 }
 
-
-static void errcatch_check_item (struct item_head * ih, char * item)
+static void errcatch_check_item(struct item_head *ih, char *item)
 {
-    reiserfs_warning (NULL, "green-16005: Invalid item type observed, run fsck ASAP");
+	reiserfs_warning(NULL,
+			 "green-16005: Invalid item type observed, run fsck ASAP");
 }
 
-static int errcatch_create_vi (struct virtual_node * vn,
-			       struct virtual_item * vi, 
-			       int is_affected, 
-			       int insert_size)
+static int errcatch_create_vi(struct virtual_node *vn,
+			      struct virtual_item *vi,
+			      int is_affected, int insert_size)
 {
-    reiserfs_warning (NULL, "green-16006: Invalid item type observed, run fsck ASAP");
-    return 0;	// We might return -1 here as well, but it won't help as create_virtual_node() from where
-		// this operation is called from is of return type void.
+	reiserfs_warning(NULL,
+			 "green-16006: Invalid item type observed, run fsck ASAP");
+	return 0;		// We might return -1 here as well, but it won't help as create_virtual_node() from where
+	// this operation is called from is of return type void.
 }
 
-static int errcatch_check_left (struct virtual_item * vi, int free,
-				int start_skip, int end_skip)
+static int errcatch_check_left(struct virtual_item *vi, int free,
+			       int start_skip, int end_skip)
 {
-    reiserfs_warning (NULL, "green-16007: Invalid item type observed, run fsck ASAP");
-    return -1;
+	reiserfs_warning(NULL,
+			 "green-16007: Invalid item type observed, run fsck ASAP");
+	return -1;
 }
 
-
-static int errcatch_check_right (struct virtual_item * vi, int free)
+static int errcatch_check_right(struct virtual_item *vi, int free)
 {
-    reiserfs_warning (NULL, "green-16008: Invalid item type observed, run fsck ASAP");
-    return -1;
+	reiserfs_warning(NULL,
+			 "green-16008: Invalid item type observed, run fsck ASAP");
+	return -1;
 }
 
-static int errcatch_part_size (struct virtual_item * vi, int first, int count)
+static int errcatch_part_size(struct virtual_item *vi, int first, int count)
 {
-    reiserfs_warning (NULL, "green-16009: Invalid item type observed, run fsck ASAP");
-    return 0;
+	reiserfs_warning(NULL,
+			 "green-16009: Invalid item type observed, run fsck ASAP");
+	return 0;
 }
 
-static int errcatch_unit_num (struct virtual_item * vi)
+static int errcatch_unit_num(struct virtual_item *vi)
 {
-    reiserfs_warning (NULL, "green-16010: Invalid item type observed, run fsck ASAP");
-    return 0;
+	reiserfs_warning(NULL,
+			 "green-16010: Invalid item type observed, run fsck ASAP");
+	return 0;
 }
 
-static void errcatch_print_vi (struct virtual_item * vi)
+static void errcatch_print_vi(struct virtual_item *vi)
 {
-    reiserfs_warning (NULL, "green-16011: Invalid item type observed, run fsck ASAP");
+	reiserfs_warning(NULL,
+			 "green-16011: Invalid item type observed, run fsck ASAP");
 }
 
 static struct item_operations errcatch_ops = {
-    errcatch_bytes_number,
-    errcatch_decrement_key,
-    errcatch_is_left_mergeable,
-    errcatch_print_item,
-    errcatch_check_item,
-
-    errcatch_create_vi,
-    errcatch_check_left,
-    errcatch_check_right,
-    errcatch_part_size,
-    errcatch_unit_num,
-    errcatch_print_vi
+	errcatch_bytes_number,
+	errcatch_decrement_key,
+	errcatch_is_left_mergeable,
+	errcatch_print_item,
+	errcatch_check_item,
+
+	errcatch_create_vi,
+	errcatch_check_left,
+	errcatch_check_right,
+	errcatch_part_size,
+	errcatch_unit_num,
+	errcatch_print_vi
 };
 
-
-
 //////////////////////////////////////////////////////////////////////////////
 //
 //
@@ -775,15 +744,11 @@ static struct item_operations errcatch_ops = {
 #error Item types must use disk-format assigned values.
 #endif
 
-struct item_operations * item_ops [TYPE_ANY + 1] = {
-  &stat_data_ops,
-  &indirect_ops,
-  &direct_ops,
-  &direntry_ops,
-  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
-  &errcatch_ops		/* This is to catch errors with invalid type (15th entry for TYPE_ANY) */
+struct item_operations *item_ops[TYPE_ANY + 1] = {
+	&stat_data_ops,
+	&indirect_ops,
+	&direct_ops,
+	&direntry_ops,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	&errcatch_ops		/* This is to catch errors with invalid type (15th entry for TYPE_ANY) */
 };
-
-
-
-

commit 7fa94c8868edfef8cb6a201fcc9a5078b7b961da
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Tue Jul 12 19:19:30 2005 -0400

    [PATCH] reiserfs: fix up case where indent misreads the code
    
     indent(1) doesn't know how to handle the "do not compile" error. It results
     in the item_ops array declaration being indented a tab stop in when it should
     not be. This patch replaces it with a #error that describes why it's failing.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
index 0ce33db1acdf..e477aeba8c92 100644
--- a/fs/reiserfs/item_ops.c
+++ b/fs/reiserfs/item_ops.c
@@ -772,7 +772,7 @@ static struct item_operations errcatch_ops = {
 //
 //
 #if ! (TYPE_STAT_DATA == 0 && TYPE_INDIRECT == 1 && TYPE_DIRECT == 2 && TYPE_DIRENTRY == 3)
-  do not compile
+#error Item types must use disk-format assigned values.
 #endif
 
 struct item_operations * item_ops [TYPE_ANY + 1] = {

commit 3e8962be915bacc1d70e4849a075041838d60a3f
Author: Al Viro <viro@www.linux.org.uk>
Date:   Sun May 1 08:59:18 2005 -0700

    [PATCH] reiserfs endianness: annotate little-endian objects
    
    little-endian objects annotated as such; again, obviously no changes of
    resulting code, we only replace __u16 with __le16, etc.  in relevant places.
    
    Signed-off-by: Al Viro <viro@parcelfarce.linux.theplanet.co.uk>
    Cc: <reiserfs-dev@namesys.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
index 9cf7c13b120d..0ce33db1acdf 100644
--- a/fs/reiserfs/item_ops.c
+++ b/fs/reiserfs/item_ops.c
@@ -296,10 +296,11 @@ static void print_sequence (__u32 start, int len)
 static void indirect_print_item (struct item_head * ih, char * item)
 {
     int j;
-    __u32 * unp, prev = INT_MAX;
+    __le32 * unp;
+    __u32 prev = INT_MAX;
     int num;
 
-    unp = (__u32 *)item;
+    unp = (__le32 *)item;
 
     if (ih_item_len(ih) % UNFM_P_SIZE)
 	reiserfs_warning (NULL, "indirect_print_item: invalid item len");

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/fs/reiserfs/item_ops.c b/fs/reiserfs/item_ops.c
new file mode 100644
index 000000000000..9cf7c13b120d
--- /dev/null
+++ b/fs/reiserfs/item_ops.c
@@ -0,0 +1,788 @@
+/*
+ * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ */
+
+#include <linux/time.h>
+#include <linux/reiserfs_fs.h>
+
+// this contains item handlers for old item types: sd, direct,
+// indirect, directory
+
+/* and where are the comments? how about saying where we can find an
+   explanation of each item handler method? -Hans */
+
+//////////////////////////////////////////////////////////////////////////////
+// stat data functions
+//
+static int sd_bytes_number (struct item_head * ih, int block_size)
+{
+  return 0;
+}
+
+static void sd_decrement_key (struct cpu_key * key)
+{
+    key->on_disk_key.k_objectid --;
+    set_cpu_key_k_type (key, TYPE_ANY);
+    set_cpu_key_k_offset(key, (loff_t)(-1));
+}
+
+static int sd_is_left_mergeable (struct reiserfs_key * key, unsigned long bsize)
+{
+    return 0;
+}
+
+
+
+static char * print_time (time_t t)
+{
+    static char timebuf[256];
+
+    sprintf (timebuf, "%ld", t);
+    return timebuf;
+}
+
+
+static void sd_print_item (struct item_head * ih, char * item)
+{
+    printk ("\tmode | size | nlinks | first direct | mtime\n");
+    if (stat_data_v1 (ih)) {
+      	struct stat_data_v1 * sd = (struct stat_data_v1 *)item;
+
+	printk ("\t0%-6o | %6u | %2u | %d | %s\n", sd_v1_mode(sd),
+                sd_v1_size(sd), sd_v1_nlink(sd), sd_v1_first_direct_byte(sd),
+                print_time( sd_v1_mtime(sd) ) );
+    } else {
+	struct stat_data * sd = (struct stat_data *)item;
+
+	printk ("\t0%-6o | %6Lu | %2u | %d | %s\n", sd_v2_mode(sd),
+            (unsigned long long)sd_v2_size(sd), sd_v2_nlink(sd),
+            sd_v2_rdev(sd), print_time(sd_v2_mtime(sd)));
+    }
+}
+
+static void sd_check_item (struct item_head * ih, char * item)
+{
+    // FIXME: type something here!
+}
+
+
+static int sd_create_vi (struct virtual_node * vn,
+			 struct virtual_item * vi, 
+			 int is_affected, 
+			 int insert_size)
+{
+    vi->vi_index = TYPE_STAT_DATA;
+    //vi->vi_type |= VI_TYPE_STAT_DATA;// not needed?
+    return 0;
+}
+
+
+static int sd_check_left (struct virtual_item * vi, int free, 
+			  int start_skip, int end_skip)
+{
+    if (start_skip || end_skip)
+	BUG ();
+    return -1;
+}
+
+
+static int sd_check_right (struct virtual_item * vi, int free)
+{
+    return -1;
+}
+
+static int sd_part_size (struct virtual_item * vi, int first, int count)
+{
+    if (count)
+	BUG ();
+    return 0;
+}
+
+static int sd_unit_num (struct virtual_item * vi)
+{
+    return vi->vi_item_len - IH_SIZE;
+}
+
+
+static void sd_print_vi (struct virtual_item * vi)
+{
+    reiserfs_warning (NULL, "STATDATA, index %d, type 0x%x, %h",
+		      vi->vi_index, vi->vi_type, vi->vi_ih);
+}
+
+static struct item_operations stat_data_ops = {
+	.bytes_number		= sd_bytes_number,
+	.decrement_key		= sd_decrement_key,
+	.is_left_mergeable	= sd_is_left_mergeable,
+	.print_item		= sd_print_item,
+	.check_item		= sd_check_item,
+
+	.create_vi		= sd_create_vi,
+	.check_left		= sd_check_left,
+	.check_right		= sd_check_right,
+	.part_size		= sd_part_size,
+	.unit_num		= sd_unit_num,
+	.print_vi		= sd_print_vi
+};
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+// direct item functions
+//
+static int direct_bytes_number (struct item_head * ih, int block_size)
+{
+  return ih_item_len(ih);
+}
+
+
+// FIXME: this should probably switch to indirect as well
+static void direct_decrement_key (struct cpu_key * key)
+{
+    cpu_key_k_offset_dec (key);
+    if (cpu_key_k_offset (key) == 0)
+	set_cpu_key_k_type (key, TYPE_STAT_DATA);	
+}
+
+
+static int direct_is_left_mergeable (struct reiserfs_key * key, unsigned long bsize)
+{
+    int version = le_key_version (key);
+    return ((le_key_k_offset (version, key) & (bsize - 1)) != 1);
+}
+
+
+static void direct_print_item (struct item_head * ih, char * item)
+{
+    int j = 0;
+
+//    return;
+    printk ("\"");
+    while (j < ih_item_len(ih))
+	printk ("%c", item[j++]);
+    printk ("\"\n");
+}
+
+
+static void direct_check_item (struct item_head * ih, char * item)
+{
+    // FIXME: type something here!
+}
+
+
+static int direct_create_vi (struct virtual_node * vn,
+			     struct virtual_item * vi, 
+			     int is_affected, 
+			     int insert_size)
+{
+    vi->vi_index = TYPE_DIRECT;
+    //vi->vi_type |= VI_TYPE_DIRECT;
+    return 0;
+}
+
+static int direct_check_left (struct virtual_item * vi, int free,
+			      int start_skip, int end_skip)
+{
+    int bytes;
+
+    bytes = free - free % 8;
+    return bytes ?: -1;    
+}
+
+
+static int direct_check_right (struct virtual_item * vi, int free)
+{
+    return direct_check_left (vi, free, 0, 0);
+}
+
+static int direct_part_size (struct virtual_item * vi, int first, int count)
+{
+    return count;
+}
+
+
+static int direct_unit_num (struct virtual_item * vi)
+{
+    return vi->vi_item_len - IH_SIZE;
+}
+
+
+static void direct_print_vi (struct virtual_item * vi)
+{
+    reiserfs_warning (NULL, "DIRECT, index %d, type 0x%x, %h",
+		      vi->vi_index, vi->vi_type, vi->vi_ih);
+}
+
+static struct item_operations direct_ops = {
+	.bytes_number		= direct_bytes_number,
+	.decrement_key		= direct_decrement_key,
+	.is_left_mergeable	= direct_is_left_mergeable,
+	.print_item		= direct_print_item,
+	.check_item		= direct_check_item,
+
+	.create_vi		= direct_create_vi,
+	.check_left		= direct_check_left,
+	.check_right		= direct_check_right,
+	.part_size		= direct_part_size,
+	.unit_num		= direct_unit_num,
+	.print_vi		= direct_print_vi
+};
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+// indirect item functions
+//
+
+static int indirect_bytes_number (struct item_head * ih, int block_size)
+{
+  return ih_item_len(ih) / UNFM_P_SIZE * block_size; //- get_ih_free_space (ih);
+}
+
+
+// decrease offset, if it becomes 0, change type to stat data
+static void indirect_decrement_key (struct cpu_key * key)
+{
+    cpu_key_k_offset_dec (key);
+    if (cpu_key_k_offset (key) == 0)
+	set_cpu_key_k_type (key, TYPE_STAT_DATA);
+}
+
+
+// if it is not first item of the body, then it is mergeable
+static int indirect_is_left_mergeable (struct reiserfs_key * key, unsigned long bsize)
+{
+    int version = le_key_version (key);
+    return (le_key_k_offset (version, key) != 1);
+}
+
+
+// printing of indirect item
+static void start_new_sequence (__u32 * start, int * len, __u32 new)
+{
+    *start = new;
+    *len = 1;
+}
+
+
+static int sequence_finished (__u32 start, int * len, __u32 new)
+{
+    if (start == INT_MAX)
+	return 1;
+
+    if (start == 0 && new == 0) {
+	(*len) ++;
+	return 0;
+    }
+    if (start != 0 && (start + *len) == new) {
+	(*len) ++;
+	return 0;
+    }
+    return 1;
+}
+
+static void print_sequence (__u32 start, int len)
+{
+    if (start == INT_MAX)
+	return;
+
+    if (len == 1)
+	printk (" %d", start);
+    else
+	printk (" %d(%d)", start, len);
+}
+
+
+static void indirect_print_item (struct item_head * ih, char * item)
+{
+    int j;
+    __u32 * unp, prev = INT_MAX;
+    int num;
+
+    unp = (__u32 *)item;
+
+    if (ih_item_len(ih) % UNFM_P_SIZE)
+	reiserfs_warning (NULL, "indirect_print_item: invalid item len");
+
+    printk ("%d pointers\n[ ", (int)I_UNFM_NUM (ih));
+    for (j = 0; j < I_UNFM_NUM (ih); j ++) {
+	if (sequence_finished (prev, &num, get_block_num(unp, j))) {
+	    print_sequence (prev, num);
+	    start_new_sequence (&prev, &num, get_block_num(unp, j));
+	}
+    }
+    print_sequence (prev, num);
+    printk ("]\n");
+}
+
+static void indirect_check_item (struct item_head * ih, char * item)
+{
+    // FIXME: type something here!
+}
+
+
+static int indirect_create_vi (struct virtual_node * vn,
+			       struct virtual_item * vi, 
+			       int is_affected, 
+			       int insert_size)
+{
+    vi->vi_index = TYPE_INDIRECT;
+    //vi->vi_type |= VI_TYPE_INDIRECT;
+    return 0;
+}
+
+static int indirect_check_left (struct virtual_item * vi, int free,
+				int start_skip, int end_skip)
+{
+    int bytes;
+
+    bytes = free - free % UNFM_P_SIZE;
+    return bytes ?: -1;    
+}
+
+
+static int indirect_check_right (struct virtual_item * vi, int free)
+{
+    return indirect_check_left (vi, free, 0, 0);
+}
+
+
+
+// return size in bytes of 'units' units. If first == 0 - calculate from the head (left), otherwise - from tail (right)
+static int indirect_part_size (struct virtual_item * vi, int first, int units)
+{
+    // unit of indirect item is byte (yet)
+    return units;
+}
+
+static int indirect_unit_num (struct virtual_item * vi)
+{
+    // unit of indirect item is byte (yet)
+    return vi->vi_item_len - IH_SIZE;
+}
+
+static void indirect_print_vi (struct virtual_item * vi)
+{
+    reiserfs_warning (NULL, "INDIRECT, index %d, type 0x%x, %h",
+		      vi->vi_index, vi->vi_type, vi->vi_ih);
+}
+
+static struct item_operations indirect_ops = {
+	.bytes_number		= indirect_bytes_number,
+	.decrement_key		= indirect_decrement_key,
+	.is_left_mergeable	= indirect_is_left_mergeable,
+	.print_item		= indirect_print_item,
+	.check_item		= indirect_check_item,
+
+	.create_vi		= indirect_create_vi,
+	.check_left		= indirect_check_left,
+	.check_right		= indirect_check_right,
+	.part_size		= indirect_part_size,
+	.unit_num		= indirect_unit_num,
+	.print_vi		= indirect_print_vi
+};
+
+
+//////////////////////////////////////////////////////////////////////////////
+// direntry functions
+//
+
+
+static int direntry_bytes_number (struct item_head * ih, int block_size)
+{
+    reiserfs_warning (NULL, "vs-16090: direntry_bytes_number: "
+		      "bytes number is asked for direntry");
+    return 0;
+}
+
+static void direntry_decrement_key (struct cpu_key * key)
+{
+    cpu_key_k_offset_dec (key);
+    if (cpu_key_k_offset (key) == 0)
+	set_cpu_key_k_type (key, TYPE_STAT_DATA);	
+}
+
+
+static int direntry_is_left_mergeable (struct reiserfs_key * key, unsigned long bsize)
+{
+    if (le32_to_cpu (key->u.k_offset_v1.k_offset) == DOT_OFFSET)
+	return 0;
+    return 1;
+	
+}
+
+
+static void direntry_print_item (struct item_head * ih, char * item)
+{
+    int i;
+    int namelen;
+    struct reiserfs_de_head * deh;
+    char * name;
+    static char namebuf [80];
+
+
+    printk ("\n # %-15s%-30s%-15s%-15s%-15s\n", "Name", "Key of pointed object", "Hash", "Gen number", "Status");
+
+    deh = (struct reiserfs_de_head *)item;
+
+    for (i = 0; i < I_ENTRY_COUNT (ih); i ++, deh ++) {
+	namelen = (i ? (deh_location(deh - 1)) : ih_item_len(ih)) - deh_location(deh);
+	name = item + deh_location(deh);
+	if (name[namelen-1] == 0)
+	  namelen = strlen (name);
+	namebuf[0] = '"';
+	if (namelen > sizeof (namebuf) - 3) {
+	    strncpy (namebuf + 1, name, sizeof (namebuf) - 3);
+	    namebuf[sizeof (namebuf) - 2] = '"';
+	    namebuf[sizeof (namebuf) - 1] = 0;
+	} else {
+	    memcpy (namebuf + 1, name, namelen);
+	    namebuf[namelen + 1] = '"';
+	    namebuf[namelen + 2] = 0;
+	}
+
+	printk ("%d:  %-15s%-15d%-15d%-15Ld%-15Ld(%s)\n", 
+		i, namebuf,
+		deh_dir_id(deh), deh_objectid(deh),
+		GET_HASH_VALUE (deh_offset (deh)), GET_GENERATION_NUMBER ((deh_offset (deh))),
+		(de_hidden (deh)) ? "HIDDEN" : "VISIBLE");
+    }
+}
+
+
+static void direntry_check_item (struct item_head * ih, char * item)
+{
+    int i;
+    struct reiserfs_de_head * deh;
+
+    // FIXME: type something here!
+    deh = (struct reiserfs_de_head *)item;
+    for (i = 0; i < I_ENTRY_COUNT (ih); i ++, deh ++) {
+	;
+    }
+}
+
+
+
+#define DIRENTRY_VI_FIRST_DIRENTRY_ITEM 1
+
+/*
+ * function returns old entry number in directory item in real node
+ * using new entry number in virtual item in virtual node */
+static inline int old_entry_num (int is_affected, int virtual_entry_num, int pos_in_item, int mode)
+{
+    if ( mode == M_INSERT || mode == M_DELETE)
+	return virtual_entry_num;
+    
+    if (!is_affected)
+	/* cut or paste is applied to another item */
+	return virtual_entry_num;
+
+    if (virtual_entry_num < pos_in_item)
+	return virtual_entry_num;
+
+    if (mode == M_CUT)
+	return virtual_entry_num + 1;
+
+    RFALSE( mode != M_PASTE || virtual_entry_num == 0,
+	    "vs-8015: old_entry_num: mode must be M_PASTE (mode = \'%c\'", mode);
+    
+    return virtual_entry_num - 1;
+}
+
+
+
+
+/* Create an array of sizes of directory entries for virtual
+   item. Return space used by an item. FIXME: no control over
+   consuming of space used by this item handler */
+static int direntry_create_vi (struct virtual_node * vn,
+			       struct virtual_item * vi, 
+			       int is_affected, 
+			       int insert_size)
+{
+    struct direntry_uarea * dir_u = vi->vi_uarea;
+    int i, j;
+    int size = sizeof (struct direntry_uarea);
+    struct reiserfs_de_head * deh;
+  
+    vi->vi_index = TYPE_DIRENTRY;
+
+    if (!(vi->vi_ih) || !vi->vi_item)
+	BUG ();
+
+
+    dir_u->flags = 0;
+    if (le_ih_k_offset (vi->vi_ih) == DOT_OFFSET)
+	dir_u->flags |= DIRENTRY_VI_FIRST_DIRENTRY_ITEM;
+
+    deh = (struct reiserfs_de_head *)(vi->vi_item);
+    
+    
+    /* virtual directory item have this amount of entry after */
+    dir_u->entry_count = ih_entry_count (vi->vi_ih) + 
+	((is_affected) ? ((vn->vn_mode == M_CUT) ? -1 :
+			  (vn->vn_mode == M_PASTE ? 1 : 0)) : 0);
+    
+    for (i = 0; i < dir_u->entry_count; i ++) {
+	j = old_entry_num (is_affected, i, vn->vn_pos_in_item, vn->vn_mode);
+        dir_u->entry_sizes[i] = (j ? deh_location( &(deh[j - 1]) ) :
+                                ih_item_len (vi->vi_ih)) -
+                                deh_location( &(deh[j])) + DEH_SIZE;
+    }
+
+    size += (dir_u->entry_count * sizeof (short));
+    
+    /* set size of pasted entry */
+    if (is_affected && vn->vn_mode == M_PASTE)
+	dir_u->entry_sizes[vn->vn_pos_in_item] = insert_size;
+
+
+#ifdef CONFIG_REISERFS_CHECK
+    /* compare total size of entries with item length */
+    {
+	int k, l;
+    
+	l = 0;
+	for (k = 0; k < dir_u->entry_count; k ++)
+	    l += dir_u->entry_sizes[k];
+    
+	if (l + IH_SIZE != vi->vi_item_len + 
+	    ((is_affected && (vn->vn_mode == M_PASTE || vn->vn_mode == M_CUT)) ? insert_size : 0) ) {
+	    reiserfs_panic (NULL, "vs-8025: set_entry_sizes: (mode==%c, insert_size==%d), invalid length of directory item",
+			    vn->vn_mode, insert_size);
+	}
+    }
+#endif
+
+    return size;
+
+
+}
+
+
+//
+// return number of entries which may fit into specified amount of
+// free space, or -1 if free space is not enough even for 1 entry
+//
+static int direntry_check_left (struct virtual_item * vi, int free,
+				int start_skip, int end_skip)
+{
+    int i;
+    int entries = 0;
+    struct direntry_uarea * dir_u = vi->vi_uarea;
+
+    for (i = start_skip; i < dir_u->entry_count - end_skip; i ++) {
+	if (dir_u->entry_sizes[i] > free)
+	    /* i-th entry doesn't fit into the remaining free space */
+	    break;
+		  
+	free -= dir_u->entry_sizes[i];
+	entries ++;
+    }
+
+    if (entries == dir_u->entry_count) {
+	reiserfs_panic (NULL, "free space %d, entry_count %d\n", free, dir_u->entry_count);
+    }
+
+    /* "." and ".." can not be separated from each other */
+    if (start_skip == 0 && (dir_u->flags & DIRENTRY_VI_FIRST_DIRENTRY_ITEM) && entries < 2)
+	entries = 0;
+    
+    return entries ?: -1;
+}
+
+
+static int direntry_check_right (struct virtual_item * vi, int free)
+{
+    int i;
+    int entries = 0;
+    struct direntry_uarea * dir_u = vi->vi_uarea;
+    
+    for (i = dir_u->entry_count - 1; i >= 0; i --) {
+	if (dir_u->entry_sizes[i] > free)
+	    /* i-th entry doesn't fit into the remaining free space */
+	    break;
+	
+	free -= dir_u->entry_sizes[i];
+	entries ++;
+    }
+    if (entries == dir_u->entry_count)
+	BUG ();
+
+    /* "." and ".." can not be separated from each other */
+    if ((dir_u->flags & DIRENTRY_VI_FIRST_DIRENTRY_ITEM) && entries > dir_u->entry_count - 2)
+	entries = dir_u->entry_count - 2;
+
+    return entries ?: -1;
+}
+
+
+/* sum of entry sizes between from-th and to-th entries including both edges */
+static int direntry_part_size (struct virtual_item * vi, int first, int count)
+{
+    int i, retval;
+    int from, to;
+    struct direntry_uarea * dir_u = vi->vi_uarea;
+    
+    retval = 0;
+    if (first == 0)
+	from = 0;
+    else
+	from = dir_u->entry_count - count;
+    to = from + count - 1;
+
+    for (i = from; i <= to; i ++)
+	retval += dir_u->entry_sizes[i];
+
+    return retval;
+}
+
+static int direntry_unit_num (struct virtual_item * vi)
+{
+    struct direntry_uarea * dir_u = vi->vi_uarea;
+    
+    return dir_u->entry_count;
+}
+
+
+
+static void direntry_print_vi (struct virtual_item * vi)
+{
+    int i;
+    struct direntry_uarea * dir_u = vi->vi_uarea;
+
+    reiserfs_warning (NULL, "DIRENTRY, index %d, type 0x%x, %h, flags 0x%x",
+		      vi->vi_index, vi->vi_type, vi->vi_ih, dir_u->flags);
+    printk ("%d entries: ", dir_u->entry_count);
+    for (i = 0; i < dir_u->entry_count; i ++)
+	printk ("%d ", dir_u->entry_sizes[i]);
+    printk ("\n");
+}
+
+static struct item_operations direntry_ops = {
+	.bytes_number		= direntry_bytes_number,
+	.decrement_key		= direntry_decrement_key,
+	.is_left_mergeable	= direntry_is_left_mergeable,
+	.print_item		= direntry_print_item,
+	.check_item		= direntry_check_item,
+
+	.create_vi		= direntry_create_vi,
+	.check_left		= direntry_check_left,
+	.check_right		= direntry_check_right,
+	.part_size		= direntry_part_size,
+	.unit_num		= direntry_unit_num,
+	.print_vi		= direntry_print_vi
+};
+
+
+//////////////////////////////////////////////////////////////////////////////
+// Error catching functions to catch errors caused by incorrect item types.
+//
+static int errcatch_bytes_number (struct item_head * ih, int block_size)
+{
+    reiserfs_warning (NULL, "green-16001: Invalid item type observed, run fsck ASAP");
+    return 0;
+}
+
+static void errcatch_decrement_key (struct cpu_key * key)
+{
+    reiserfs_warning (NULL, "green-16002: Invalid item type observed, run fsck ASAP");
+}
+
+
+static int errcatch_is_left_mergeable (struct reiserfs_key * key, unsigned long bsize)
+{
+    reiserfs_warning (NULL, "green-16003: Invalid item type observed, run fsck ASAP");
+    return 0;
+}
+
+
+static void errcatch_print_item (struct item_head * ih, char * item)
+{
+    reiserfs_warning (NULL, "green-16004: Invalid item type observed, run fsck ASAP");
+}
+
+
+static void errcatch_check_item (struct item_head * ih, char * item)
+{
+    reiserfs_warning (NULL, "green-16005: Invalid item type observed, run fsck ASAP");
+}
+
+static int errcatch_create_vi (struct virtual_node * vn,
+			       struct virtual_item * vi, 
+			       int is_affected, 
+			       int insert_size)
+{
+    reiserfs_warning (NULL, "green-16006: Invalid item type observed, run fsck ASAP");
+    return 0;	// We might return -1 here as well, but it won't help as create_virtual_node() from where
+		// this operation is called from is of return type void.
+}
+
+static int errcatch_check_left (struct virtual_item * vi, int free,
+				int start_skip, int end_skip)
+{
+    reiserfs_warning (NULL, "green-16007: Invalid item type observed, run fsck ASAP");
+    return -1;
+}
+
+
+static int errcatch_check_right (struct virtual_item * vi, int free)
+{
+    reiserfs_warning (NULL, "green-16008: Invalid item type observed, run fsck ASAP");
+    return -1;
+}
+
+static int errcatch_part_size (struct virtual_item * vi, int first, int count)
+{
+    reiserfs_warning (NULL, "green-16009: Invalid item type observed, run fsck ASAP");
+    return 0;
+}
+
+static int errcatch_unit_num (struct virtual_item * vi)
+{
+    reiserfs_warning (NULL, "green-16010: Invalid item type observed, run fsck ASAP");
+    return 0;
+}
+
+static void errcatch_print_vi (struct virtual_item * vi)
+{
+    reiserfs_warning (NULL, "green-16011: Invalid item type observed, run fsck ASAP");
+}
+
+static struct item_operations errcatch_ops = {
+    errcatch_bytes_number,
+    errcatch_decrement_key,
+    errcatch_is_left_mergeable,
+    errcatch_print_item,
+    errcatch_check_item,
+
+    errcatch_create_vi,
+    errcatch_check_left,
+    errcatch_check_right,
+    errcatch_part_size,
+    errcatch_unit_num,
+    errcatch_print_vi
+};
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+//
+#if ! (TYPE_STAT_DATA == 0 && TYPE_INDIRECT == 1 && TYPE_DIRECT == 2 && TYPE_DIRENTRY == 3)
+  do not compile
+#endif
+
+struct item_operations * item_ops [TYPE_ANY + 1] = {
+  &stat_data_ops,
+  &indirect_ops,
+  &direct_ops,
+  &direntry_ops,
+  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+  &errcatch_ops		/* This is to catch errors with invalid type (15th entry for TYPE_ANY) */
+};
+
+
+
+
