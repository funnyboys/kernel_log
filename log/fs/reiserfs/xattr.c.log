commit 394440d469413fa9b74f88a11f144d76017221f2
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jan 15 13:00:59 2020 -0500

    reiserfs: fix handling of -EOPNOTSUPP in reiserfs_for_each_xattr
    
    Commit 60e4cf67a58 (reiserfs: fix extended attributes on the root
    directory) introduced a regression open_xa_root started returning
    -EOPNOTSUPP but it was not handled properly in reiserfs_for_each_xattr.
    
    When the reiserfs module is built without CONFIG_REISERFS_FS_XATTR,
    deleting an inode would result in a warning and chowning an inode
    would also result in a warning and then fail to complete.
    
    With CONFIG_REISERFS_FS_XATTR enabled, the xattr root would always be
    present for read-write operations.
    
    This commit handles -EOPNOSUPP in the same way -ENODATA is handled.
    
    Fixes: 60e4cf67a582 ("reiserfs: fix extended attributes on the root directory")
    CC: stable@vger.kernel.org      # Commit 60e4cf67a58 was picked up by stable
    Link: https://lore.kernel.org/r/20200115180059.6935-1-jeffm@suse.com
    Reported-by: Michael Brunnbauer <brunni@netestate.de>
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 62b40df36c98..28b241cd6987 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -319,8 +319,12 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 out_dir:
 	dput(dir);
 out:
-	/* -ENODATA isn't an error */
-	if (err == -ENODATA)
+	/*
+	 * -ENODATA: this object doesn't have any xattrs
+	 * -EOPNOTSUPP: this file system doesn't have xattrs enabled on disk.
+	 * Neither are errors
+	 */
+	if (err == -ENODATA || err == -EOPNOTSUPP)
 		err = 0;
 	return err;
 }

commit 60e4cf67a582d64f07713eda5fcc8ccdaf7833e6
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Oct 24 10:31:27 2019 -0400

    reiserfs: fix extended attributes on the root directory
    
    Since commit d0a5b995a308 (vfs: Add IOP_XATTR inode operations flag)
    extended attributes haven't worked on the root directory in reiserfs.
    
    This is due to reiserfs conditionally setting the sb->s_xattrs handler
    array depending on whether it located or create the internal privroot
    directory.  It necessarily does this after the root inode is already
    read in.  The IOP_XATTR flag is set during inode initialization, so
    it never gets set on the root directory.
    
    This commit unconditionally assigns sb->s_xattrs and clears IOP_XATTR on
    internal inodes.  The old return values due to the conditional assignment
    are handled via open_xa_root, which now returns EOPNOTSUPP as the VFS
    would have done.
    
    Link: https://lore.kernel.org/r/20191024143127.17509-1-jeffm@suse.com
    CC: stable@vger.kernel.org
    Fixes: d0a5b995a308 ("vfs: Add IOP_XATTR inode operations flag")
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index b5b26d8a192c..62b40df36c98 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -122,13 +122,13 @@ static struct dentry *open_xa_root(struct super_block *sb, int flags)
 	struct dentry *xaroot;
 
 	if (d_really_is_negative(privroot))
-		return ERR_PTR(-ENODATA);
+		return ERR_PTR(-EOPNOTSUPP);
 
 	inode_lock_nested(d_inode(privroot), I_MUTEX_XATTR);
 
 	xaroot = dget(REISERFS_SB(sb)->xattr_root);
 	if (!xaroot)
-		xaroot = ERR_PTR(-ENODATA);
+		xaroot = ERR_PTR(-EOPNOTSUPP);
 	else if (d_really_is_negative(xaroot)) {
 		int err = -ENODATA;
 
@@ -619,6 +619,10 @@ int reiserfs_xattr_set(struct inode *inode, const char *name,
 	int error, error2;
 	size_t jbegin_count = reiserfs_xattr_nblocks(inode, buffer_size);
 
+	/* Check before we start a transaction and then do nothing. */
+	if (!d_really_is_positive(REISERFS_SB(inode->i_sb)->priv_root))
+		return -EOPNOTSUPP;
+
 	if (!(flags & XATTR_REPLACE))
 		jbegin_count += reiserfs_xattr_jcreate_nblocks(inode);
 
@@ -841,8 +845,7 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 	if (d_really_is_negative(dentry))
 		return -EINVAL;
 
-	if (!dentry->d_sb->s_xattr ||
-	    get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
+	if (get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
 	dir = open_xa_dir(d_inode(dentry), XATTR_REPLACE);
@@ -882,6 +885,7 @@ static int create_privroot(struct dentry *dentry)
 	}
 
 	d_inode(dentry)->i_flags |= S_PRIVATE;
+	d_inode(dentry)->i_opflags &= ~IOP_XATTR;
 	reiserfs_info(dentry->d_sb, "Created %s - reserved for xattr "
 		      "storage.\n", PRIVROOT_NAME);
 
@@ -895,7 +899,7 @@ static int create_privroot(struct dentry *dentry) { return 0; }
 #endif
 
 /* Actual operations that are exported to VFS-land */
-static const struct xattr_handler *reiserfs_xattr_handlers[] = {
+const struct xattr_handler *reiserfs_xattr_handlers[] = {
 #ifdef CONFIG_REISERFS_FS_XATTR
 	&reiserfs_xattr_user_handler,
 	&reiserfs_xattr_trusted_handler,
@@ -966,8 +970,10 @@ int reiserfs_lookup_privroot(struct super_block *s)
 	if (!IS_ERR(dentry)) {
 		REISERFS_SB(s)->priv_root = dentry;
 		d_set_d_op(dentry, &xattr_lookup_poison_ops);
-		if (d_really_is_positive(dentry))
+		if (d_really_is_positive(dentry)) {
 			d_inode(dentry)->i_flags |= S_PRIVATE;
+			d_inode(dentry)->i_opflags &= ~IOP_XATTR;
+		}
 	} else
 		err = PTR_ERR(dentry);
 	inode_unlock(d_inode(s->s_root));
@@ -996,7 +1002,6 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 	}
 
 	if (d_really_is_positive(privroot)) {
-		s->s_xattr = reiserfs_xattr_handlers;
 		inode_lock(d_inode(privroot));
 		if (!REISERFS_SB(s)->xattr_root) {
 			struct dentry *dentry;

commit 672cdd56f0ae95069e399db790dbf2e303ac72b7
Author: Bharath Vedartham <linux.bhar@gmail.com>
Date:   Tue May 14 15:44:29 2019 -0700

    reiserfs: add comment to explain endianness issue in xattr_hash
    
    csum_partial() gives different results for little-endian and big-endian
    hosts.  This causes images created on little-endian hosts and mounted on
    big endian hosts to see csum mismatches.  This causes an endianness bug.
    Sparse gives a warning as csum_partial returns a restricted integer type
    __wsum_t and xattr_hash expects __u32.  This warning acts as a reminder
    for this bug and should not be suppressed.
    
    This comment aims to convey these endianness issues.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Link: http://lkml.kernel.org/r/20190423161831.GA15387@bharath12345-Inspiron-5559
    Signed-off-by: Bharath Vedartham <linux.bhar@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Jann Horn <jannh@google.com>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 32d8986c26fb..b5b26d8a192c 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -450,6 +450,15 @@ static struct page *reiserfs_get_page(struct inode *dir, size_t n)
 
 static inline __u32 xattr_hash(const char *msg, int len)
 {
+	/*
+	 * csum_partial() gives different results for little-endian and
+	 * big endian hosts. Images created on little-endian hosts and
+	 * mounted on big-endian hosts(and vice versa) will see csum mismatches
+	 * when trying to fetch xattrs. Treating the hash as __wsum_t would
+	 * lower the frequency of mismatch.  This is an endianness bug in
+	 * reiserfs.  The return statement would result in a sparse warning. Do
+	 * not fix the sparse warning so as to not hide a reminder of the bug.
+	 */
 	return csum_partial(msg, len, 0);
 }
 

commit b10298d56c9623f9b173f19959732d3184b35f4f
Author: Jann Horn <jannh@google.com>
Date:   Tue Oct 30 15:06:38 2018 -0700

    reiserfs: propagate errors from fill_with_dentries() properly
    
    fill_with_dentries() failed to propagate errors up to
    reiserfs_for_each_xattr() properly.  Plumb them through.
    
    Note that reiserfs_for_each_xattr() is only used by
    reiserfs_delete_xattrs() and reiserfs_chown_xattrs().  The result of
    reiserfs_delete_xattrs() is discarded anyway, the only difference there is
    whether a warning is printed to dmesg.  The result of
    reiserfs_chown_xattrs() does matter because it can block chowning of the
    file to which the xattrs belong; but either way, the resulting state can
    have misaligned ownership, so my patch doesn't improve things greatly.
    
    Credit for making me look at this code goes to Al Viro, who pointed out
    that the ->actor calling convention is suboptimal and should be changed.
    
    Link: http://lkml.kernel.org/r/20180802163335.83312-1-jannh@google.com
    Signed-off-by: Jann Horn <jannh@google.com>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Eric Biggers <ebiggers@google.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 48cdfc81fe10..32d8986c26fb 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -185,6 +185,7 @@ struct reiserfs_dentry_buf {
 	struct dir_context ctx;
 	struct dentry *xadir;
 	int count;
+	int err;
 	struct dentry *dentries[8];
 };
 
@@ -207,6 +208,7 @@ fill_with_dentries(struct dir_context *ctx, const char *name, int namelen,
 
 	dentry = lookup_one_len(name, dbuf->xadir, namelen);
 	if (IS_ERR(dentry)) {
+		dbuf->err = PTR_ERR(dentry);
 		return PTR_ERR(dentry);
 	} else if (d_really_is_negative(dentry)) {
 		/* A directory entry exists, but no file? */
@@ -215,6 +217,7 @@ fill_with_dentries(struct dir_context *ctx, const char *name, int namelen,
 			       "not found for file %pd.\n",
 			       dentry, dbuf->xadir);
 		dput(dentry);
+		dbuf->err = -EIO;
 		return -EIO;
 	}
 
@@ -262,6 +265,10 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 		err = reiserfs_readdir_inode(d_inode(dir), &buf.ctx);
 		if (err)
 			break;
+		if (buf.err) {
+			err = buf.err;
+			break;
+		}
 		if (!buf.count)
 			break;
 		for (i = 0; !err && i < buf.count && buf.dentries[i]; i++) {

commit a13f085d111e90469faf2d9965eb39b11c114d7e
Author: Jann Horn <jannh@google.com>
Date:   Tue Aug 21 21:59:37 2018 -0700

    reiserfs: fix broken xattr handling (heap corruption, bad retval)
    
    This fixes the following issues:
    
    - When a buffer size is supplied to reiserfs_listxattr() such that each
      individual name fits, but the concatenation of all names doesn't fit,
      reiserfs_listxattr() overflows the supplied buffer.  This leads to a
      kernel heap overflow (verified using KASAN) followed by an out-of-bounds
      usercopy and is therefore a security bug.
    
    - When a buffer size is supplied to reiserfs_listxattr() such that a
      name doesn't fit, -ERANGE should be returned.  But reiserfs instead just
      truncates the list of names; I have verified that if the only xattr on a
      file has a longer name than the supplied buffer length, listxattr()
      incorrectly returns zero.
    
    With my patch applied, -ERANGE is returned in both cases and the memory
    corruption doesn't happen anymore.
    
    Credit for making me clean this code up a bit goes to Al Viro, who pointed
    out that the ->actor calling convention is suboptimal and should be
    changed.
    
    Link: http://lkml.kernel.org/r/20180802151539.5373-1-jannh@google.com
    Fixes: 48b32a3553a5 ("reiserfs: use generic xattr handlers")
    Signed-off-by: Jann Horn <jannh@google.com>
    Acked-by: Jeff Mahoney <jeffm@suse.com>
    Cc: Eric Biggers <ebiggers@google.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index ff94fad477e4..48cdfc81fe10 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -792,8 +792,10 @@ static int listxattr_filler(struct dir_context *ctx, const char *name,
 			return 0;
 		size = namelen + 1;
 		if (b->buf) {
-			if (size > b->size)
+			if (b->pos + size > b->size) {
+				b->pos = -ERANGE;
 				return -ERANGE;
+			}
 			memcpy(b->buf + b->pos, name, namelen);
 			b->buf[b->pos + namelen] = 0;
 		}

commit 95582b00838837fc07e042979320caf917ce3fe6
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Tue May 8 19:36:02 2018 -0700

    vfs: change inode times to use struct timespec64
    
    struct timespec is not y2038 safe. Transition vfs to use
    y2038 safe struct timespec64 instead.
    
    The change was made with the help of the following cocinelle
    script. This catches about 80% of the changes.
    All the header file and logic changes are included in the
    first 5 rules. The rest are trivial substitutions.
    I avoid changing any of the function signatures or any other
    filesystem specific data structures to keep the patch simple
    for review.
    
    The script can be a little shorter by combining different cases.
    But, this version was sufficient for my usecase.
    
    virtual patch
    
    @ depends on patch @
    identifier now;
    @@
    - struct timespec
    + struct timespec64
      current_time ( ... )
      {
    - struct timespec now = current_kernel_time();
    + struct timespec64 now = current_kernel_time64();
      ...
    - return timespec_trunc(
    + return timespec64_trunc(
      ... );
      }
    
    @ depends on patch @
    identifier xtime;
    @@
     struct \( iattr \| inode \| kstat \) {
     ...
    -       struct timespec xtime;
    +       struct timespec64 xtime;
     ...
     }
    
    @ depends on patch @
    identifier t;
    @@
     struct inode_operations {
     ...
    int (*update_time) (...,
    -       struct timespec t,
    +       struct timespec64 t,
    ...);
     ...
     }
    
    @ depends on patch @
    identifier t;
    identifier fn_update_time =~ "update_time$";
    @@
     fn_update_time (...,
    - struct timespec *t,
    + struct timespec64 *t,
     ...) { ... }
    
    @ depends on patch @
    identifier t;
    @@
    lease_get_mtime( ... ,
    - struct timespec *t
    + struct timespec64 *t
      ) { ... }
    
    @te depends on patch forall@
    identifier ts;
    local idexpression struct inode *inode_node;
    identifier i_xtime =~ "^i_[acm]time$";
    identifier ia_xtime =~ "^ia_[acm]time$";
    identifier fn_update_time =~ "update_time$";
    identifier fn;
    expression e, E3;
    local idexpression struct inode *node1;
    local idexpression struct inode *node2;
    local idexpression struct iattr *attr1;
    local idexpression struct iattr *attr2;
    local idexpression struct iattr attr;
    identifier i_xtime1 =~ "^i_[acm]time$";
    identifier i_xtime2 =~ "^i_[acm]time$";
    identifier ia_xtime1 =~ "^ia_[acm]time$";
    identifier ia_xtime2 =~ "^ia_[acm]time$";
    @@
    (
    (
    - struct timespec ts;
    + struct timespec64 ts;
    |
    - struct timespec ts = current_time(inode_node);
    + struct timespec64 ts = current_time(inode_node);
    )
    
    <+... when != ts
    (
    - timespec_equal(&inode_node->i_xtime, &ts)
    + timespec64_equal(&inode_node->i_xtime, &ts)
    |
    - timespec_equal(&ts, &inode_node->i_xtime)
    + timespec64_equal(&ts, &inode_node->i_xtime)
    |
    - timespec_compare(&inode_node->i_xtime, &ts)
    + timespec64_compare(&inode_node->i_xtime, &ts)
    |
    - timespec_compare(&ts, &inode_node->i_xtime)
    + timespec64_compare(&ts, &inode_node->i_xtime)
    |
    ts = current_time(e)
    |
    fn_update_time(..., &ts,...)
    |
    inode_node->i_xtime = ts
    |
    node1->i_xtime = ts
    |
    ts = inode_node->i_xtime
    |
    <+... attr1->ia_xtime ...+> = ts
    |
    ts = attr1->ia_xtime
    |
    ts.tv_sec
    |
    ts.tv_nsec
    |
    btrfs_set_stack_timespec_sec(..., ts.tv_sec)
    |
    btrfs_set_stack_timespec_nsec(..., ts.tv_nsec)
    |
    - ts = timespec64_to_timespec(
    + ts =
    ...
    -)
    |
    - ts = ktime_to_timespec(
    + ts = ktime_to_timespec64(
    ...)
    |
    - ts = E3
    + ts = timespec_to_timespec64(E3)
    |
    - ktime_get_real_ts(&ts)
    + ktime_get_real_ts64(&ts)
    |
    fn(...,
    - ts
    + timespec64_to_timespec(ts)
    ,...)
    )
    ...+>
    (
    <... when != ts
    - return ts;
    + return timespec64_to_timespec(ts);
    ...>
    )
    |
    - timespec_equal(&node1->i_xtime1, &node2->i_xtime2)
    + timespec64_equal(&node1->i_xtime2, &node2->i_xtime2)
    |
    - timespec_equal(&node1->i_xtime1, &attr2->ia_xtime2)
    + timespec64_equal(&node1->i_xtime2, &attr2->ia_xtime2)
    |
    - timespec_compare(&node1->i_xtime1, &node2->i_xtime2)
    + timespec64_compare(&node1->i_xtime1, &node2->i_xtime2)
    |
    node1->i_xtime1 =
    - timespec_trunc(attr1->ia_xtime1,
    + timespec64_trunc(attr1->ia_xtime1,
    ...)
    |
    - attr1->ia_xtime1 = timespec_trunc(attr2->ia_xtime2,
    + attr1->ia_xtime1 =  timespec64_trunc(attr2->ia_xtime2,
    ...)
    |
    - ktime_get_real_ts(&attr1->ia_xtime1)
    + ktime_get_real_ts64(&attr1->ia_xtime1)
    |
    - ktime_get_real_ts(&attr.ia_xtime1)
    + ktime_get_real_ts64(&attr.ia_xtime1)
    )
    
    @ depends on patch @
    struct inode *node;
    struct iattr *attr;
    identifier fn;
    identifier i_xtime =~ "^i_[acm]time$";
    identifier ia_xtime =~ "^ia_[acm]time$";
    expression e;
    @@
    (
    - fn(node->i_xtime);
    + fn(timespec64_to_timespec(node->i_xtime));
    |
     fn(...,
    - node->i_xtime);
    + timespec64_to_timespec(node->i_xtime));
    |
    - e = fn(attr->ia_xtime);
    + e = fn(timespec64_to_timespec(attr->ia_xtime));
    )
    
    @ depends on patch forall @
    struct inode *node;
    struct iattr *attr;
    identifier i_xtime =~ "^i_[acm]time$";
    identifier ia_xtime =~ "^ia_[acm]time$";
    identifier fn;
    @@
    {
    + struct timespec ts;
    <+...
    (
    + ts = timespec64_to_timespec(node->i_xtime);
    fn (...,
    - &node->i_xtime,
    + &ts,
    ...);
    |
    + ts = timespec64_to_timespec(attr->ia_xtime);
    fn (...,
    - &attr->ia_xtime,
    + &ts,
    ...);
    )
    ...+>
    }
    
    @ depends on patch forall @
    struct inode *node;
    struct iattr *attr;
    struct kstat *stat;
    identifier ia_xtime =~ "^ia_[acm]time$";
    identifier i_xtime =~ "^i_[acm]time$";
    identifier xtime =~ "^[acm]time$";
    identifier fn, ret;
    @@
    {
    + struct timespec ts;
    <+...
    (
    + ts = timespec64_to_timespec(node->i_xtime);
    ret = fn (...,
    - &node->i_xtime,
    + &ts,
    ...);
    |
    + ts = timespec64_to_timespec(node->i_xtime);
    ret = fn (...,
    - &node->i_xtime);
    + &ts);
    |
    + ts = timespec64_to_timespec(attr->ia_xtime);
    ret = fn (...,
    - &attr->ia_xtime,
    + &ts,
    ...);
    |
    + ts = timespec64_to_timespec(attr->ia_xtime);
    ret = fn (...,
    - &attr->ia_xtime);
    + &ts);
    |
    + ts = timespec64_to_timespec(stat->xtime);
    ret = fn (...,
    - &stat->xtime);
    + &ts);
    )
    ...+>
    }
    
    @ depends on patch @
    struct inode *node;
    struct inode *node2;
    identifier i_xtime1 =~ "^i_[acm]time$";
    identifier i_xtime2 =~ "^i_[acm]time$";
    identifier i_xtime3 =~ "^i_[acm]time$";
    struct iattr *attrp;
    struct iattr *attrp2;
    struct iattr attr ;
    identifier ia_xtime1 =~ "^ia_[acm]time$";
    identifier ia_xtime2 =~ "^ia_[acm]time$";
    struct kstat *stat;
    struct kstat stat1;
    struct timespec64 ts;
    identifier xtime =~ "^[acmb]time$";
    expression e;
    @@
    (
    ( node->i_xtime2 \| attrp->ia_xtime2 \| attr.ia_xtime2 \) = node->i_xtime1  ;
    |
     node->i_xtime2 = \( node2->i_xtime1 \| timespec64_trunc(...) \);
    |
     node->i_xtime2 = node->i_xtime1 = node->i_xtime3 = \(ts \| current_time(...) \);
    |
     node->i_xtime1 = node->i_xtime3 = \(ts \| current_time(...) \);
    |
     stat->xtime = node2->i_xtime1;
    |
     stat1.xtime = node2->i_xtime1;
    |
    ( node->i_xtime2 \| attrp->ia_xtime2 \) = attrp->ia_xtime1  ;
    |
    ( attrp->ia_xtime1 \| attr.ia_xtime1 \) = attrp2->ia_xtime2;
    |
    - e = node->i_xtime1;
    + e = timespec64_to_timespec( node->i_xtime1 );
    |
    - e = attrp->ia_xtime1;
    + e = timespec64_to_timespec( attrp->ia_xtime1 );
    |
    node->i_xtime1 = current_time(...);
    |
     node->i_xtime2 = node->i_xtime1 = node->i_xtime3 =
    - e;
    + timespec_to_timespec64(e);
    |
     node->i_xtime1 = node->i_xtime3 =
    - e;
    + timespec_to_timespec64(e);
    |
    - node->i_xtime1 = e;
    + node->i_xtime1 = timespec_to_timespec64(e);
    )
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Cc: <anton@tuxera.com>
    Cc: <balbi@kernel.org>
    Cc: <bfields@fieldses.org>
    Cc: <darrick.wong@oracle.com>
    Cc: <dhowells@redhat.com>
    Cc: <dsterba@suse.com>
    Cc: <dwmw2@infradead.org>
    Cc: <hch@lst.de>
    Cc: <hirofumi@mail.parknet.co.jp>
    Cc: <hubcap@omnibond.com>
    Cc: <jack@suse.com>
    Cc: <jaegeuk@kernel.org>
    Cc: <jaharkes@cs.cmu.edu>
    Cc: <jslaby@suse.com>
    Cc: <keescook@chromium.org>
    Cc: <mark@fasheh.com>
    Cc: <miklos@szeredi.hu>
    Cc: <nico@linaro.org>
    Cc: <reiserfs-devel@vger.kernel.org>
    Cc: <richard@nod.at>
    Cc: <sage@redhat.com>
    Cc: <sfrench@samba.org>
    Cc: <swhiteho@redhat.com>
    Cc: <tj@kernel.org>
    Cc: <trond.myklebust@primarydata.com>
    Cc: <tytso@mit.edu>
    Cc: <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 5dbf5324bdda..ff94fad477e4 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -451,10 +451,10 @@ int reiserfs_commit_write(struct file *f, struct page *page,
 
 static void update_ctime(struct inode *inode)
 {
-	struct timespec now = current_time(inode);
+	struct timespec64 now = current_time(inode);
 
 	if (inode_unhashed(inode) || !inode->i_nlink ||
-	    timespec_equal(&inode->i_ctime, &now))
+	    timespec64_equal(&inode->i_ctime, &now))
 		return;
 
 	inode->i_ctime = current_time(inode);

commit 1751e8a6cb935e555fcdbcb9ab4f0446e322ca3e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 27 13:05:09 2017 -0800

    Rename superblock flags (MS_xyz -> SB_xyz)
    
    This is a pure automated search-and-replace of the internal kernel
    superblock flags.
    
    The s_flags are now called SB_*, with the names and the values for the
    moment mirroring the MS_* flags that they're equivalent to.
    
    Note how the MS_xyz flags are the ones passed to the mount system call,
    while the SB_xyz flags are what we then use in sb->s_flags.
    
    The script to do this was:
    
        # places to look in; re security/*: it generally should *not* be
        # touched (that stuff parses mount(2) arguments directly), but
        # there are two places where we really deal with superblock flags.
        FILES="drivers/mtd drivers/staging/lustre fs ipc mm \
                include/linux/fs.h include/uapi/linux/bfs_fs.h \
                security/apparmor/apparmorfs.c security/apparmor/include/lib.h"
        # the list of MS_... constants
        SYMS="RDONLY NOSUID NODEV NOEXEC SYNCHRONOUS REMOUNT MANDLOCK \
              DIRSYNC NOATIME NODIRATIME BIND MOVE REC VERBOSE SILENT \
              POSIXACL UNBINDABLE PRIVATE SLAVE SHARED RELATIME KERNMOUNT \
              I_VERSION STRICTATIME LAZYTIME SUBMOUNT NOREMOTELOCK NOSEC BORN \
              ACTIVE NOUSER"
    
        SED_PROG=
        for i in $SYMS; do SED_PROG="$SED_PROG -e s/MS_$i/SB_$i/g"; done
    
        # we want files that contain at least one of MS_...,
        # with fs/namespace.c and fs/pnode.c excluded.
        L=$(for i in $SYMS; do git grep -w -l MS_$i $FILES; done| sort|uniq|grep -v '^fs/namespace.c'|grep -v '^fs/pnode.c')
    
        for f in $L; do sed -i $f $SED_PROG; done
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 46492fb37a4c..5dbf5324bdda 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -959,7 +959,7 @@ int reiserfs_lookup_privroot(struct super_block *s)
 
 /*
  * We need to take a copy of the mount flags since things like
- * MS_RDONLY don't get set until *after* we're called.
+ * SB_RDONLY don't get set until *after* we're called.
  * mount_flags != mount_options
  */
 int reiserfs_xattr_init(struct super_block *s, int mount_flags)
@@ -971,7 +971,7 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 	if (err)
 		goto error;
 
-	if (d_really_is_negative(privroot) && !(mount_flags & MS_RDONLY)) {
+	if (d_really_is_negative(privroot) && !(mount_flags & SB_RDONLY)) {
 		inode_lock(d_inode(s->s_root));
 		err = create_privroot(REISERFS_SB(s)->priv_root);
 		inode_unlock(d_inode(s->s_root));
@@ -999,11 +999,11 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 		clear_bit(REISERFS_POSIXACL, &REISERFS_SB(s)->s_mount_opt);
 	}
 
-	/* The super_block MS_POSIXACL must mirror the (no)acl mount option. */
+	/* The super_block SB_POSIXACL must mirror the (no)acl mount option. */
 	if (reiserfs_posixacl(s))
-		s->s_flags |= MS_POSIXACL;
+		s->s_flags |= SB_POSIXACL;
 	else
-		s->s_flags &= ~MS_POSIXACL;
+		s->s_flags &= ~SB_POSIXACL;
 
 	return err;
 }

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index e87aa21c30de..46492fb37a4c 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * linux/fs/reiserfs/xattr.c
  *

commit 02027d42c3f747945f19111d3da2092ed2148ac8
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Wed Sep 14 07:48:05 2016 -0700

    fs: Replace CURRENT_TIME_SEC with current_time() for inode timestamps
    
    CURRENT_TIME_SEC is not y2038 safe. current_time() will
    be transitioned to use 64 bit time along with vfs in a
    separate patch.
    There is no plan to transistion CURRENT_TIME_SEC to use
    y2038 safe time interfaces.
    
    current_time() will also be extended to use superblock
    range checking parameters when range checking is introduced.
    
    This works because alloc_super() fills in the the s_time_gran
    in super block to NSEC_PER_SEC.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Acked-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index a33812ae9fad..e87aa21c30de 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -450,13 +450,13 @@ int reiserfs_commit_write(struct file *f, struct page *page,
 
 static void update_ctime(struct inode *inode)
 {
-	struct timespec now = current_fs_time(inode->i_sb);
+	struct timespec now = current_time(inode);
 
 	if (inode_unhashed(inode) || !inode->i_nlink ||
 	    timespec_equal(&inode->i_ctime, &now))
 		return;
 
-	inode->i_ctime = CURRENT_TIME_SEC;
+	inode->i_ctime = current_time(inode);
 	mark_inode_dirty(inode);
 }
 
@@ -575,7 +575,7 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 	new_size = buffer_size + sizeof(struct reiserfs_xattr_header);
 	if (!err && new_size < i_size_read(d_inode(dentry))) {
 		struct iattr newattrs = {
-			.ia_ctime = current_fs_time(inode->i_sb),
+			.ia_ctime = current_time(inode),
 			.ia_size = new_size,
 			.ia_valid = ATTR_SIZE | ATTR_CTIME,
 		};

commit 84695ffee7987ee1e581be4c4696e47e1a29403b
Merge: bf1620068911 ce23e6401334
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon May 2 19:45:47 2016 -0400

    Merge getxattr prototype change into work.lookups
    
    The rest of work.xattr stuff isn't needed for this branch

commit 79a628d14ec7ee9adfdc3ce04343d5ff7ec20c18
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Apr 10 18:50:48 2016 -0400

    reiserfs: switch to generic_{get,set,remove}xattr()
    
    reiserfs_xattr_[sg]et() will fail with -EOPNOTSUPP for V1 inodes anyway,
    and all reiserfs instances of ->[sg]et() call it and so does ->set_acl().
    
    Checks for name length in the instances had been bogus; they should've
    been "bugger off if it's _exactly_ the prefix" (as generic would
    do on its own) and not "bugger off if it's shorter than the prefix" -
    that can't happen.
    
    xattr_full_name() is needed to adjust for the fact that generic instances
    will skip the prefix in the name passed to ->[gs]et(); reiserfs homegrown
    analogues didn't.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 57e0b2310532..02137bbda0ec 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -764,60 +764,6 @@ find_xattr_handler_prefix(const struct xattr_handler **handlers,
 	return xah;
 }
 
-
-/*
- * Inode operation getxattr()
- */
-ssize_t
-reiserfs_getxattr(struct dentry * dentry, const char *name, void *buffer,
-		  size_t size)
-{
-	const struct xattr_handler *handler;
-
-	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
-
-	if (!handler || get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
-		return -EOPNOTSUPP;
-
-	return handler->get(handler, dentry, name, buffer, size);
-}
-
-/*
- * Inode operation setxattr()
- *
- * d_inode(dentry)->i_mutex down
- */
-int
-reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
-		  size_t size, int flags)
-{
-	const struct xattr_handler *handler;
-
-	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
-
-	if (!handler || get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
-		return -EOPNOTSUPP;
-
-	return handler->set(handler, dentry, name, value, size, flags);
-}
-
-/*
- * Inode operation removexattr()
- *
- * d_inode(dentry)->i_mutex down
- */
-int reiserfs_removexattr(struct dentry *dentry, const char *name)
-{
-	const struct xattr_handler *handler;
-
-	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
-
-	if (!handler || get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
-		return -EOPNOTSUPP;
-
-	return handler->set(handler, dentry, name, NULL, 0, XATTR_REPLACE);
-}
-
 struct listxattr_buf {
 	struct dir_context ctx;
 	size_t size;

commit 09cbfeaf1a5a67bfb3201e0c83c810cecb2efa5a
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Fri Apr 1 15:29:47 2016 +0300

    mm, fs: get rid of PAGE_CACHE_* and page_cache_{get,release} macros
    
    PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} macros were introduced *long* time
    ago with promise that one day it will be possible to implement page
    cache with bigger chunks than PAGE_SIZE.
    
    This promise never materialized.  And unlikely will.
    
    We have many places where PAGE_CACHE_SIZE assumed to be equal to
    PAGE_SIZE.  And it's constant source of confusion on whether
    PAGE_CACHE_* or PAGE_* constant should be used in a particular case,
    especially on the border between fs and mm.
    
    Global switching to PAGE_CACHE_SIZE != PAGE_SIZE would cause to much
    breakage to be doable.
    
    Let's stop pretending that pages in page cache are special.  They are
    not.
    
    The changes are pretty straight-forward:
    
     - <foo> << (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - <foo> >> (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} -> PAGE_{SIZE,SHIFT,MASK,ALIGN};
    
     - page_cache_get() -> get_page();
    
     - page_cache_release() -> put_page();
    
    This patch contains automated changes generated with coccinelle using
    script below.  For some reason, coccinelle doesn't patch header files.
    I've called spatch for them manually.
    
    The only adjustment after coccinelle is revert of changes to
    PAGE_CAHCE_ALIGN definition: we are going to drop it later.
    
    There are few places in the code where coccinelle didn't reach.  I'll
    fix them manually in a separate patch.  Comments and documentation also
    will be addressed with the separate patch.
    
    virtual patch
    
    @@
    expression E;
    @@
    - E << (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    expression E;
    @@
    - E >> (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    @@
    - PAGE_CACHE_SHIFT
    + PAGE_SHIFT
    
    @@
    @@
    - PAGE_CACHE_SIZE
    + PAGE_SIZE
    
    @@
    @@
    - PAGE_CACHE_MASK
    + PAGE_MASK
    
    @@
    expression E;
    @@
    - PAGE_CACHE_ALIGN(E)
    + PAGE_ALIGN(E)
    
    @@
    expression E;
    @@
    - page_cache_get(E)
    + get_page(E)
    
    @@
    expression E;
    @@
    - page_cache_release(E)
    + put_page(E)
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 57e0b2310532..28f5f8b11370 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -415,7 +415,7 @@ static struct dentry *xattr_lookup(struct inode *inode, const char *name,
 static inline void reiserfs_put_page(struct page *page)
 {
 	kunmap(page);
-	page_cache_release(page);
+	put_page(page);
 }
 
 static struct page *reiserfs_get_page(struct inode *dir, size_t n)
@@ -427,7 +427,7 @@ static struct page *reiserfs_get_page(struct inode *dir, size_t n)
 	 * and an unlink/rmdir has just occurred - GFP_NOFS avoids this
 	 */
 	mapping_set_gfp_mask(mapping, GFP_NOFS);
-	page = read_mapping_page(mapping, n >> PAGE_CACHE_SHIFT, NULL);
+	page = read_mapping_page(mapping, n >> PAGE_SHIFT, NULL);
 	if (!IS_ERR(page)) {
 		kmap(page);
 		if (PageError(page))
@@ -526,10 +526,10 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 	while (buffer_pos < buffer_size || buffer_pos == 0) {
 		size_t chunk;
 		size_t skip = 0;
-		size_t page_offset = (file_pos & (PAGE_CACHE_SIZE - 1));
+		size_t page_offset = (file_pos & (PAGE_SIZE - 1));
 
-		if (buffer_size - buffer_pos > PAGE_CACHE_SIZE)
-			chunk = PAGE_CACHE_SIZE;
+		if (buffer_size - buffer_pos > PAGE_SIZE)
+			chunk = PAGE_SIZE;
 		else
 			chunk = buffer_size - buffer_pos;
 
@@ -546,8 +546,8 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 			struct reiserfs_xattr_header *rxh;
 
 			skip = file_pos = sizeof(struct reiserfs_xattr_header);
-			if (chunk + skip > PAGE_CACHE_SIZE)
-				chunk = PAGE_CACHE_SIZE - skip;
+			if (chunk + skip > PAGE_SIZE)
+				chunk = PAGE_SIZE - skip;
 			rxh = (struct reiserfs_xattr_header *)data;
 			rxh->h_magic = cpu_to_le32(REISERFS_XATTR_MAGIC);
 			rxh->h_hash = cpu_to_le32(xahash);
@@ -675,8 +675,8 @@ reiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,
 		char *data;
 		size_t skip = 0;
 
-		if (isize - file_pos > PAGE_CACHE_SIZE)
-			chunk = PAGE_CACHE_SIZE;
+		if (isize - file_pos > PAGE_SIZE)
+			chunk = PAGE_SIZE;
 		else
 			chunk = isize - file_pos;
 

commit 5955102c9984fa081b2d570cfac75c97eecf8f3b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jan 22 15:40:57 2016 -0500

    wrappers for ->i_mutex access
    
    parallel to mutex_{lock,unlock,trylock,is_locked,lock_nested},
    inode_foo(inode) being mutex_foo(&inode->i_mutex).
    
    Please, use those for access to ->i_mutex; over the coming cycle
    ->i_mutex will become rwsem, with ->lookup() done with it held
    only shared.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index e5ddb4e5ea94..57e0b2310532 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -64,14 +64,14 @@
 #ifdef CONFIG_REISERFS_FS_XATTR
 static int xattr_create(struct inode *dir, struct dentry *dentry, int mode)
 {
-	BUG_ON(!mutex_is_locked(&dir->i_mutex));
+	BUG_ON(!inode_is_locked(dir));
 	return dir->i_op->create(dir, dentry, mode, true);
 }
 #endif
 
 static int xattr_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 {
-	BUG_ON(!mutex_is_locked(&dir->i_mutex));
+	BUG_ON(!inode_is_locked(dir));
 	return dir->i_op->mkdir(dir, dentry, mode);
 }
 
@@ -85,11 +85,11 @@ static int xattr_unlink(struct inode *dir, struct dentry *dentry)
 {
 	int error;
 
-	BUG_ON(!mutex_is_locked(&dir->i_mutex));
+	BUG_ON(!inode_is_locked(dir));
 
-	mutex_lock_nested(&d_inode(dentry)->i_mutex, I_MUTEX_CHILD);
+	inode_lock_nested(d_inode(dentry), I_MUTEX_CHILD);
 	error = dir->i_op->unlink(dir, dentry);
-	mutex_unlock(&d_inode(dentry)->i_mutex);
+	inode_unlock(d_inode(dentry));
 
 	if (!error)
 		d_delete(dentry);
@@ -100,13 +100,13 @@ static int xattr_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int error;
 
-	BUG_ON(!mutex_is_locked(&dir->i_mutex));
+	BUG_ON(!inode_is_locked(dir));
 
-	mutex_lock_nested(&d_inode(dentry)->i_mutex, I_MUTEX_CHILD);
+	inode_lock_nested(d_inode(dentry), I_MUTEX_CHILD);
 	error = dir->i_op->rmdir(dir, dentry);
 	if (!error)
 		d_inode(dentry)->i_flags |= S_DEAD;
-	mutex_unlock(&d_inode(dentry)->i_mutex);
+	inode_unlock(d_inode(dentry));
 	if (!error)
 		d_delete(dentry);
 
@@ -123,7 +123,7 @@ static struct dentry *open_xa_root(struct super_block *sb, int flags)
 	if (d_really_is_negative(privroot))
 		return ERR_PTR(-ENODATA);
 
-	mutex_lock_nested(&d_inode(privroot)->i_mutex, I_MUTEX_XATTR);
+	inode_lock_nested(d_inode(privroot), I_MUTEX_XATTR);
 
 	xaroot = dget(REISERFS_SB(sb)->xattr_root);
 	if (!xaroot)
@@ -139,7 +139,7 @@ static struct dentry *open_xa_root(struct super_block *sb, int flags)
 		}
 	}
 
-	mutex_unlock(&d_inode(privroot)->i_mutex);
+	inode_unlock(d_inode(privroot));
 	return xaroot;
 }
 
@@ -156,7 +156,7 @@ static struct dentry *open_xa_dir(const struct inode *inode, int flags)
 		 le32_to_cpu(INODE_PKEY(inode)->k_objectid),
 		 inode->i_generation);
 
-	mutex_lock_nested(&d_inode(xaroot)->i_mutex, I_MUTEX_XATTR);
+	inode_lock_nested(d_inode(xaroot), I_MUTEX_XATTR);
 
 	xadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));
 	if (!IS_ERR(xadir) && d_really_is_negative(xadir)) {
@@ -170,7 +170,7 @@ static struct dentry *open_xa_dir(const struct inode *inode, int flags)
 		}
 	}
 
-	mutex_unlock(&d_inode(xaroot)->i_mutex);
+	inode_unlock(d_inode(xaroot));
 	dput(xaroot);
 	return xadir;
 }
@@ -195,7 +195,7 @@ fill_with_dentries(struct dir_context *ctx, const char *name, int namelen,
 		container_of(ctx, struct reiserfs_dentry_buf, ctx);
 	struct dentry *dentry;
 
-	WARN_ON_ONCE(!mutex_is_locked(&d_inode(dbuf->xadir)->i_mutex));
+	WARN_ON_ONCE(!inode_is_locked(d_inode(dbuf->xadir)));
 
 	if (dbuf->count == ARRAY_SIZE(dbuf->dentries))
 		return -ENOSPC;
@@ -254,7 +254,7 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 		goto out_dir;
 	}
 
-	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_XATTR);
+	inode_lock_nested(d_inode(dir), I_MUTEX_XATTR);
 
 	buf.xadir = dir;
 	while (1) {
@@ -276,7 +276,7 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 			break;
 		buf.count = 0;
 	}
-	mutex_unlock(&d_inode(dir)->i_mutex);
+	inode_unlock(d_inode(dir));
 
 	cleanup_dentry_buf(&buf);
 
@@ -298,13 +298,13 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 		if (!err) {
 			int jerror;
 
-			mutex_lock_nested(&d_inode(dir->d_parent)->i_mutex,
+			inode_lock_nested(d_inode(dir->d_parent),
 					  I_MUTEX_XATTR);
 			err = action(dir, data);
 			reiserfs_write_lock(inode->i_sb);
 			jerror = journal_end(&th);
 			reiserfs_write_unlock(inode->i_sb);
-			mutex_unlock(&d_inode(dir->d_parent)->i_mutex);
+			inode_unlock(d_inode(dir->d_parent));
 			err = jerror ?: err;
 		}
 	}
@@ -384,7 +384,7 @@ static struct dentry *xattr_lookup(struct inode *inode, const char *name,
 	if (IS_ERR(xadir))
 		return ERR_CAST(xadir);
 
-	mutex_lock_nested(&d_inode(xadir)->i_mutex, I_MUTEX_XATTR);
+	inode_lock_nested(d_inode(xadir), I_MUTEX_XATTR);
 	xafile = lookup_one_len(name, xadir, strlen(name));
 	if (IS_ERR(xafile)) {
 		err = PTR_ERR(xafile);
@@ -404,7 +404,7 @@ static struct dentry *xattr_lookup(struct inode *inode, const char *name,
 	if (err)
 		dput(xafile);
 out:
-	mutex_unlock(&d_inode(xadir)->i_mutex);
+	inode_unlock(d_inode(xadir));
 	dput(xadir);
 	if (err)
 		return ERR_PTR(err);
@@ -469,7 +469,7 @@ static int lookup_and_delete_xattr(struct inode *inode, const char *name)
 	if (IS_ERR(xadir))
 		return PTR_ERR(xadir);
 
-	mutex_lock_nested(&d_inode(xadir)->i_mutex, I_MUTEX_XATTR);
+	inode_lock_nested(d_inode(xadir), I_MUTEX_XATTR);
 	dentry = lookup_one_len(name, xadir, strlen(name));
 	if (IS_ERR(dentry)) {
 		err = PTR_ERR(dentry);
@@ -483,7 +483,7 @@ static int lookup_and_delete_xattr(struct inode *inode, const char *name)
 
 	dput(dentry);
 out_dput:
-	mutex_unlock(&d_inode(xadir)->i_mutex);
+	inode_unlock(d_inode(xadir));
 	dput(xadir);
 	return err;
 }
@@ -580,11 +580,11 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 			.ia_valid = ATTR_SIZE | ATTR_CTIME,
 		};
 
-		mutex_lock_nested(&d_inode(dentry)->i_mutex, I_MUTEX_XATTR);
+		inode_lock_nested(d_inode(dentry), I_MUTEX_XATTR);
 		inode_dio_wait(d_inode(dentry));
 
 		err = reiserfs_setattr(dentry, &newattrs);
-		mutex_unlock(&d_inode(dentry)->i_mutex);
+		inode_unlock(d_inode(dentry));
 	} else
 		update_ctime(inode);
 out_unlock:
@@ -888,9 +888,9 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 		goto out;
 	}
 
-	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_XATTR);
+	inode_lock_nested(d_inode(dir), I_MUTEX_XATTR);
 	err = reiserfs_readdir_inode(d_inode(dir), &buf.ctx);
-	mutex_unlock(&d_inode(dir)->i_mutex);
+	inode_unlock(d_inode(dir));
 
 	if (!err)
 		err = buf.pos;
@@ -905,7 +905,7 @@ static int create_privroot(struct dentry *dentry)
 	int err;
 	struct inode *inode = d_inode(dentry->d_parent);
 
-	WARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));
+	WARN_ON_ONCE(!inode_is_locked(inode));
 
 	err = xattr_mkdir(inode, dentry, 0700);
 	if (err || d_really_is_negative(dentry)) {
@@ -995,7 +995,7 @@ int reiserfs_lookup_privroot(struct super_block *s)
 	int err = 0;
 
 	/* If we don't have the privroot located yet - go find it */
-	mutex_lock(&d_inode(s->s_root)->i_mutex);
+	inode_lock(d_inode(s->s_root));
 	dentry = lookup_one_len(PRIVROOT_NAME, s->s_root,
 				strlen(PRIVROOT_NAME));
 	if (!IS_ERR(dentry)) {
@@ -1005,7 +1005,7 @@ int reiserfs_lookup_privroot(struct super_block *s)
 			d_inode(dentry)->i_flags |= S_PRIVATE;
 	} else
 		err = PTR_ERR(dentry);
-	mutex_unlock(&d_inode(s->s_root)->i_mutex);
+	inode_unlock(d_inode(s->s_root));
 
 	return err;
 }
@@ -1025,14 +1025,14 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 		goto error;
 
 	if (d_really_is_negative(privroot) && !(mount_flags & MS_RDONLY)) {
-		mutex_lock(&d_inode(s->s_root)->i_mutex);
+		inode_lock(d_inode(s->s_root));
 		err = create_privroot(REISERFS_SB(s)->priv_root);
-		mutex_unlock(&d_inode(s->s_root)->i_mutex);
+		inode_unlock(d_inode(s->s_root));
 	}
 
 	if (d_really_is_positive(privroot)) {
 		s->s_xattr = reiserfs_xattr_handlers;
-		mutex_lock(&d_inode(privroot)->i_mutex);
+		inode_lock(d_inode(privroot));
 		if (!REISERFS_SB(s)->xattr_root) {
 			struct dentry *dentry;
 
@@ -1043,7 +1043,7 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 			else
 				err = PTR_ERR(dentry);
 		}
-		mutex_unlock(&d_inode(privroot)->i_mutex);
+		inode_unlock(d_inode(privroot));
 	}
 
 error:

commit 764a5c6b1fa4306dd7573c1d80914254909cd036
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Wed Dec 2 14:44:43 2015 +0100

    xattr handlers: Simplify list operation
    
    Change the list operation to only return whether or not an attribute
    should be listed.  Copying the attribute names into the buffer is moved
    to the callers.
    
    Since the result only depends on the dentry and not on the attribute
    name, we do not pass the attribute name to list operations.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index efe2ed3c13c5..e5ddb4e5ea94 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -840,19 +840,16 @@ static int listxattr_filler(struct dir_context *ctx, const char *name,
 
 		handler = find_xattr_handler_prefix(b->dentry->d_sb->s_xattr,
 						    name);
-		if (!handler)	/* Unsupported xattr name */
+		if (!handler /* Unsupported xattr name */ ||
+		    (handler->list && !handler->list(b->dentry)))
 			return 0;
+		size = namelen + 1;
 		if (b->buf) {
-			size = handler->list(handler, b->dentry,
-					     b->buf + b->pos, b->size, name,
-					     namelen);
 			if (size > b->size)
 				return -ERANGE;
-		} else {
-			size = handler->list(handler, b->dentry,
-					     NULL, 0, name, namelen);
+			memcpy(b->buf + b->pos, name, namelen);
+			b->buf[b->pos + namelen] = 0;
 		}
-
 		b->pos += size;
 	}
 	return 0;

commit 98e9cb5711c68223f0e4d5201b9a6add255ec550
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Wed Dec 2 14:44:36 2015 +0100

    vfs: Distinguish between full xattr names and proper prefixes
    
    Add an additional "name" field to struct xattr_handler.  When the name
    is set, the handler matches attributes with exactly that name.  When the
    prefix is set instead, the handler matches attributes with the given
    prefix and with a non-empty suffix.
    
    This patch should avoid bugs like the one fixed in commit c361016a in
    the future.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Reviewed-by: James Morris <james.l.morris@oracle.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 66b26fdfff8d..efe2ed3c13c5 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -756,7 +756,8 @@ find_xattr_handler_prefix(const struct xattr_handler **handlers,
 		return NULL;
 
 	for_each_xattr_handler(handlers, xah) {
-		if (strncmp(xah->prefix, name, strlen(xah->prefix)) == 0)
+		const char *prefix = xattr_prefix(xah);
+		if (strncmp(prefix, name, strlen(prefix)) == 0)
 			break;
 	}
 

commit d9a82a04033f87bbd06efb29f78c0170a38154a8
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Sun Oct 4 19:18:51 2015 +0200

    xattr handlers: Pass handler to operations instead of flags
    
    The xattr_handler operations are currently all passed a file system
    specific flags value which the operations can use to disambiguate between
    different handlers; some file systems use that to distinguish the xattr
    namespace, for example.  In some oprations, it would be useful to also have
    access to the handler prefix.  To allow that, pass a pointer to the handler
    to operations instead of the flags value alone.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index e87f9b52bf06..66b26fdfff8d 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -778,7 +778,7 @@ reiserfs_getxattr(struct dentry * dentry, const char *name, void *buffer,
 	if (!handler || get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	return handler->get(dentry, name, buffer, size, handler->flags);
+	return handler->get(handler, dentry, name, buffer, size);
 }
 
 /*
@@ -797,7 +797,7 @@ reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 	if (!handler || get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	return handler->set(dentry, name, value, size, flags, handler->flags);
+	return handler->set(handler, dentry, name, value, size, flags);
 }
 
 /*
@@ -814,7 +814,7 @@ int reiserfs_removexattr(struct dentry *dentry, const char *name)
 	if (!handler || get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	return handler->set(dentry, name, NULL, 0, XATTR_REPLACE, handler->flags);
+	return handler->set(handler, dentry, name, NULL, 0, XATTR_REPLACE);
 }
 
 struct listxattr_buf {
@@ -842,14 +842,14 @@ static int listxattr_filler(struct dir_context *ctx, const char *name,
 		if (!handler)	/* Unsupported xattr name */
 			return 0;
 		if (b->buf) {
-			size = handler->list(b->dentry, b->buf + b->pos,
-					 b->size, name, namelen,
-					 handler->flags);
+			size = handler->list(handler, b->dentry,
+					     b->buf + b->pos, b->size, name,
+					     namelen);
 			if (size > b->size)
 				return -ERANGE;
 		} else {
-			size = handler->list(b->dentry, NULL, 0, name,
-					     namelen, handler->flags);
+			size = handler->list(handler, b->dentry,
+					     NULL, 0, name, namelen);
 		}
 
 		b->pos += size;

commit 2b0143b5c986be1ce8408b3aadc4709e0a94429d
Author: David Howells <dhowells@redhat.com>
Date:   Tue Mar 17 22:25:59 2015 +0000

    VFS: normal filesystems (and lustre): d_inode() annotations
    
    that's the bulk of filesystem drivers dealing with inodes of their own
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 4e781e697c90..e87f9b52bf06 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -87,9 +87,9 @@ static int xattr_unlink(struct inode *dir, struct dentry *dentry)
 
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
 
-	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);
+	mutex_lock_nested(&d_inode(dentry)->i_mutex, I_MUTEX_CHILD);
 	error = dir->i_op->unlink(dir, dentry);
-	mutex_unlock(&dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dentry)->i_mutex);
 
 	if (!error)
 		d_delete(dentry);
@@ -102,11 +102,11 @@ static int xattr_rmdir(struct inode *dir, struct dentry *dentry)
 
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
 
-	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);
+	mutex_lock_nested(&d_inode(dentry)->i_mutex, I_MUTEX_CHILD);
 	error = dir->i_op->rmdir(dir, dentry);
 	if (!error)
-		dentry->d_inode->i_flags |= S_DEAD;
-	mutex_unlock(&dentry->d_inode->i_mutex);
+		d_inode(dentry)->i_flags |= S_DEAD;
+	mutex_unlock(&d_inode(dentry)->i_mutex);
 	if (!error)
 		d_delete(dentry);
 
@@ -120,26 +120,26 @@ static struct dentry *open_xa_root(struct super_block *sb, int flags)
 	struct dentry *privroot = REISERFS_SB(sb)->priv_root;
 	struct dentry *xaroot;
 
-	if (!privroot->d_inode)
+	if (d_really_is_negative(privroot))
 		return ERR_PTR(-ENODATA);
 
-	mutex_lock_nested(&privroot->d_inode->i_mutex, I_MUTEX_XATTR);
+	mutex_lock_nested(&d_inode(privroot)->i_mutex, I_MUTEX_XATTR);
 
 	xaroot = dget(REISERFS_SB(sb)->xattr_root);
 	if (!xaroot)
 		xaroot = ERR_PTR(-ENODATA);
-	else if (!xaroot->d_inode) {
+	else if (d_really_is_negative(xaroot)) {
 		int err = -ENODATA;
 
 		if (xattr_may_create(flags))
-			err = xattr_mkdir(privroot->d_inode, xaroot, 0700);
+			err = xattr_mkdir(d_inode(privroot), xaroot, 0700);
 		if (err) {
 			dput(xaroot);
 			xaroot = ERR_PTR(err);
 		}
 	}
 
-	mutex_unlock(&privroot->d_inode->i_mutex);
+	mutex_unlock(&d_inode(privroot)->i_mutex);
 	return xaroot;
 }
 
@@ -156,21 +156,21 @@ static struct dentry *open_xa_dir(const struct inode *inode, int flags)
 		 le32_to_cpu(INODE_PKEY(inode)->k_objectid),
 		 inode->i_generation);
 
-	mutex_lock_nested(&xaroot->d_inode->i_mutex, I_MUTEX_XATTR);
+	mutex_lock_nested(&d_inode(xaroot)->i_mutex, I_MUTEX_XATTR);
 
 	xadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));
-	if (!IS_ERR(xadir) && !xadir->d_inode) {
+	if (!IS_ERR(xadir) && d_really_is_negative(xadir)) {
 		int err = -ENODATA;
 
 		if (xattr_may_create(flags))
-			err = xattr_mkdir(xaroot->d_inode, xadir, 0700);
+			err = xattr_mkdir(d_inode(xaroot), xadir, 0700);
 		if (err) {
 			dput(xadir);
 			xadir = ERR_PTR(err);
 		}
 	}
 
-	mutex_unlock(&xaroot->d_inode->i_mutex);
+	mutex_unlock(&d_inode(xaroot)->i_mutex);
 	dput(xaroot);
 	return xadir;
 }
@@ -195,7 +195,7 @@ fill_with_dentries(struct dir_context *ctx, const char *name, int namelen,
 		container_of(ctx, struct reiserfs_dentry_buf, ctx);
 	struct dentry *dentry;
 
-	WARN_ON_ONCE(!mutex_is_locked(&dbuf->xadir->d_inode->i_mutex));
+	WARN_ON_ONCE(!mutex_is_locked(&d_inode(dbuf->xadir)->i_mutex));
 
 	if (dbuf->count == ARRAY_SIZE(dbuf->dentries))
 		return -ENOSPC;
@@ -207,7 +207,7 @@ fill_with_dentries(struct dir_context *ctx, const char *name, int namelen,
 	dentry = lookup_one_len(name, dbuf->xadir, namelen);
 	if (IS_ERR(dentry)) {
 		return PTR_ERR(dentry);
-	} else if (!dentry->d_inode) {
+	} else if (d_really_is_negative(dentry)) {
 		/* A directory entry exists, but no file? */
 		reiserfs_error(dentry->d_sb, "xattr-20003",
 			       "Corrupted directory: xattr %pd listed but "
@@ -249,16 +249,16 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 	if (IS_ERR(dir)) {
 		err = PTR_ERR(dir);
 		goto out;
-	} else if (!dir->d_inode) {
+	} else if (d_really_is_negative(dir)) {
 		err = 0;
 		goto out_dir;
 	}
 
-	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
+	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_XATTR);
 
 	buf.xadir = dir;
 	while (1) {
-		err = reiserfs_readdir_inode(dir->d_inode, &buf.ctx);
+		err = reiserfs_readdir_inode(d_inode(dir), &buf.ctx);
 		if (err)
 			break;
 		if (!buf.count)
@@ -276,7 +276,7 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 			break;
 		buf.count = 0;
 	}
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 
 	cleanup_dentry_buf(&buf);
 
@@ -298,13 +298,13 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 		if (!err) {
 			int jerror;
 
-			mutex_lock_nested(&dir->d_parent->d_inode->i_mutex,
+			mutex_lock_nested(&d_inode(dir->d_parent)->i_mutex,
 					  I_MUTEX_XATTR);
 			err = action(dir, data);
 			reiserfs_write_lock(inode->i_sb);
 			jerror = journal_end(&th);
 			reiserfs_write_unlock(inode->i_sb);
-			mutex_unlock(&dir->d_parent->d_inode->i_mutex);
+			mutex_unlock(&d_inode(dir->d_parent)->i_mutex);
 			err = jerror ?: err;
 		}
 	}
@@ -319,7 +319,7 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 
 static int delete_one_xattr(struct dentry *dentry, void *data)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 
 	/* This is the xattr dir, handle specially. */
 	if (d_is_dir(dentry))
@@ -384,27 +384,27 @@ static struct dentry *xattr_lookup(struct inode *inode, const char *name,
 	if (IS_ERR(xadir))
 		return ERR_CAST(xadir);
 
-	mutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);
+	mutex_lock_nested(&d_inode(xadir)->i_mutex, I_MUTEX_XATTR);
 	xafile = lookup_one_len(name, xadir, strlen(name));
 	if (IS_ERR(xafile)) {
 		err = PTR_ERR(xafile);
 		goto out;
 	}
 
-	if (xafile->d_inode && (flags & XATTR_CREATE))
+	if (d_really_is_positive(xafile) && (flags & XATTR_CREATE))
 		err = -EEXIST;
 
-	if (!xafile->d_inode) {
+	if (d_really_is_negative(xafile)) {
 		err = -ENODATA;
 		if (xattr_may_create(flags))
-			err = xattr_create(xadir->d_inode, xafile,
+			err = xattr_create(d_inode(xadir), xafile,
 					      0700|S_IFREG);
 	}
 
 	if (err)
 		dput(xafile);
 out:
-	mutex_unlock(&xadir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(xadir)->i_mutex);
 	dput(xadir);
 	if (err)
 		return ERR_PTR(err);
@@ -469,21 +469,21 @@ static int lookup_and_delete_xattr(struct inode *inode, const char *name)
 	if (IS_ERR(xadir))
 		return PTR_ERR(xadir);
 
-	mutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);
+	mutex_lock_nested(&d_inode(xadir)->i_mutex, I_MUTEX_XATTR);
 	dentry = lookup_one_len(name, xadir, strlen(name));
 	if (IS_ERR(dentry)) {
 		err = PTR_ERR(dentry);
 		goto out_dput;
 	}
 
-	if (dentry->d_inode) {
-		err = xattr_unlink(xadir->d_inode, dentry);
+	if (d_really_is_positive(dentry)) {
+		err = xattr_unlink(d_inode(xadir), dentry);
 		update_ctime(inode);
 	}
 
 	dput(dentry);
 out_dput:
-	mutex_unlock(&xadir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(xadir)->i_mutex);
 	dput(xadir);
 	return err;
 }
@@ -533,7 +533,7 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 		else
 			chunk = buffer_size - buffer_pos;
 
-		page = reiserfs_get_page(dentry->d_inode, file_pos);
+		page = reiserfs_get_page(d_inode(dentry), file_pos);
 		if (IS_ERR(page)) {
 			err = PTR_ERR(page);
 			goto out_unlock;
@@ -573,18 +573,18 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 	}
 
 	new_size = buffer_size + sizeof(struct reiserfs_xattr_header);
-	if (!err && new_size < i_size_read(dentry->d_inode)) {
+	if (!err && new_size < i_size_read(d_inode(dentry))) {
 		struct iattr newattrs = {
 			.ia_ctime = current_fs_time(inode->i_sb),
 			.ia_size = new_size,
 			.ia_valid = ATTR_SIZE | ATTR_CTIME,
 		};
 
-		mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);
-		inode_dio_wait(dentry->d_inode);
+		mutex_lock_nested(&d_inode(dentry)->i_mutex, I_MUTEX_XATTR);
+		inode_dio_wait(d_inode(dentry));
 
 		err = reiserfs_setattr(dentry, &newattrs);
-		mutex_unlock(&dentry->d_inode->i_mutex);
+		mutex_unlock(&d_inode(dentry)->i_mutex);
 	} else
 		update_ctime(inode);
 out_unlock:
@@ -657,7 +657,7 @@ reiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,
 
 	down_read(&REISERFS_I(inode)->i_xattr_sem);
 
-	isize = i_size_read(dentry->d_inode);
+	isize = i_size_read(d_inode(dentry));
 
 	/* Just return the size needed */
 	if (buffer == NULL) {
@@ -680,7 +680,7 @@ reiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,
 		else
 			chunk = isize - file_pos;
 
-		page = reiserfs_get_page(dentry->d_inode, file_pos);
+		page = reiserfs_get_page(d_inode(dentry), file_pos);
 		if (IS_ERR(page)) {
 			err = PTR_ERR(page);
 			goto out_unlock;
@@ -775,7 +775,7 @@ reiserfs_getxattr(struct dentry * dentry, const char *name, void *buffer,
 
 	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
 
-	if (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
+	if (!handler || get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
 	return handler->get(dentry, name, buffer, size, handler->flags);
@@ -784,7 +784,7 @@ reiserfs_getxattr(struct dentry * dentry, const char *name, void *buffer,
 /*
  * Inode operation setxattr()
  *
- * dentry->d_inode->i_mutex down
+ * d_inode(dentry)->i_mutex down
  */
 int
 reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
@@ -794,7 +794,7 @@ reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 
 	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
 
-	if (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
+	if (!handler || get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
 	return handler->set(dentry, name, value, size, flags, handler->flags);
@@ -803,7 +803,7 @@ reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 /*
  * Inode operation removexattr()
  *
- * dentry->d_inode->i_mutex down
+ * d_inode(dentry)->i_mutex down
  */
 int reiserfs_removexattr(struct dentry *dentry, const char *name)
 {
@@ -811,7 +811,7 @@ int reiserfs_removexattr(struct dentry *dentry, const char *name)
 
 	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
 
-	if (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
+	if (!handler || get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
 	return handler->set(dentry, name, NULL, 0, XATTR_REPLACE, handler->flags);
@@ -875,14 +875,14 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 		.size = buffer ? size : 0,
 	};
 
-	if (!dentry->d_inode)
+	if (d_really_is_negative(dentry))
 		return -EINVAL;
 
 	if (!dentry->d_sb->s_xattr ||
-	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
+	    get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	dir = open_xa_dir(dentry->d_inode, XATTR_REPLACE);
+	dir = open_xa_dir(d_inode(dentry), XATTR_REPLACE);
 	if (IS_ERR(dir)) {
 		err = PTR_ERR(dir);
 		if (err == -ENODATA)
@@ -890,9 +890,9 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 		goto out;
 	}
 
-	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
-	err = reiserfs_readdir_inode(dir->d_inode, &buf.ctx);
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_XATTR);
+	err = reiserfs_readdir_inode(d_inode(dir), &buf.ctx);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 
 	if (!err)
 		err = buf.pos;
@@ -905,12 +905,12 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 static int create_privroot(struct dentry *dentry)
 {
 	int err;
-	struct inode *inode = dentry->d_parent->d_inode;
+	struct inode *inode = d_inode(dentry->d_parent);
 
 	WARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));
 
 	err = xattr_mkdir(inode, dentry, 0700);
-	if (err || !dentry->d_inode) {
+	if (err || d_really_is_negative(dentry)) {
 		reiserfs_warning(dentry->d_sb, "jdm-20006",
 				 "xattrs/ACLs enabled and couldn't "
 				 "find/create .reiserfs_priv. "
@@ -918,7 +918,7 @@ static int create_privroot(struct dentry *dentry)
 		return -EOPNOTSUPP;
 	}
 
-	dentry->d_inode->i_flags |= S_PRIVATE;
+	d_inode(dentry)->i_flags |= S_PRIVATE;
 	reiserfs_info(dentry->d_sb, "Created %s - reserved for xattr "
 		      "storage.\n", PRIVROOT_NAME);
 
@@ -997,17 +997,17 @@ int reiserfs_lookup_privroot(struct super_block *s)
 	int err = 0;
 
 	/* If we don't have the privroot located yet - go find it */
-	mutex_lock(&s->s_root->d_inode->i_mutex);
+	mutex_lock(&d_inode(s->s_root)->i_mutex);
 	dentry = lookup_one_len(PRIVROOT_NAME, s->s_root,
 				strlen(PRIVROOT_NAME));
 	if (!IS_ERR(dentry)) {
 		REISERFS_SB(s)->priv_root = dentry;
 		d_set_d_op(dentry, &xattr_lookup_poison_ops);
-		if (dentry->d_inode)
-			dentry->d_inode->i_flags |= S_PRIVATE;
+		if (d_really_is_positive(dentry))
+			d_inode(dentry)->i_flags |= S_PRIVATE;
 	} else
 		err = PTR_ERR(dentry);
-	mutex_unlock(&s->s_root->d_inode->i_mutex);
+	mutex_unlock(&d_inode(s->s_root)->i_mutex);
 
 	return err;
 }
@@ -1026,15 +1026,15 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 	if (err)
 		goto error;
 
-	if (!privroot->d_inode && !(mount_flags & MS_RDONLY)) {
-		mutex_lock(&s->s_root->d_inode->i_mutex);
+	if (d_really_is_negative(privroot) && !(mount_flags & MS_RDONLY)) {
+		mutex_lock(&d_inode(s->s_root)->i_mutex);
 		err = create_privroot(REISERFS_SB(s)->priv_root);
-		mutex_unlock(&s->s_root->d_inode->i_mutex);
+		mutex_unlock(&d_inode(s->s_root)->i_mutex);
 	}
 
-	if (privroot->d_inode) {
+	if (d_really_is_positive(privroot)) {
 		s->s_xattr = reiserfs_xattr_handlers;
-		mutex_lock(&privroot->d_inode->i_mutex);
+		mutex_lock(&d_inode(privroot)->i_mutex);
 		if (!REISERFS_SB(s)->xattr_root) {
 			struct dentry *dentry;
 
@@ -1045,7 +1045,7 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 			else
 				err = PTR_ERR(dentry);
 		}
-		mutex_unlock(&privroot->d_inode->i_mutex);
+		mutex_unlock(&d_inode(privroot)->i_mutex);
 	}
 
 error:

commit e36cb0b89ce20b4f8786a57e8a6bc8476f577650
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jan 29 12:02:35 2015 +0000

    VFS: (Scripted) Convert S_ISLNK/DIR/REG(dentry->d_inode) to d_is_*(dentry)
    
    Convert the following where appropriate:
    
     (1) S_ISLNK(dentry->d_inode) to d_is_symlink(dentry).
    
     (2) S_ISREG(dentry->d_inode) to d_is_reg(dentry).
    
     (3) S_ISDIR(dentry->d_inode) to d_is_dir(dentry).  This is actually more
         complicated than it appears as some calls should be converted to
         d_can_lookup() instead.  The difference is whether the directory in
         question is a real dir with a ->lookup op or whether it's a fake dir with
         a ->d_automount op.
    
    In some circumstances, we can subsume checks for dentry->d_inode not being
    NULL into this, provided we the code isn't in a filesystem that expects
    d_inode to be NULL if the dirent really *is* negative (ie. if we're going to
    use d_inode() rather than d_backing_inode() to get the inode pointer).
    
    Note that the dentry type field may be set to something other than
    DCACHE_MISS_TYPE when d_inode is NULL in the case of unionmount, where the VFS
    manages the fall-through from a negative dentry to a lower layer.  In such a
    case, the dentry type of the negative union dentry is set to the same as the
    type of the lower dentry.
    
    However, if you know d_inode is not NULL at the call site, then you can use
    the d_is_xxx() functions even in a filesystem.
    
    There is one further complication: a 0,0 chardev dentry may be labelled
    DCACHE_WHITEOUT_TYPE rather than DCACHE_SPECIAL_TYPE.  Strictly, this was
    intended for special directory entry types that don't have attached inodes.
    
    The following perl+coccinelle script was used:
    
    use strict;
    
    my @callers;
    open($fd, 'git grep -l \'S_IS[A-Z].*->d_inode\' |') ||
        die "Can't grep for S_ISDIR and co. callers";
    @callers = <$fd>;
    close($fd);
    unless (@callers) {
        print "No matches\n";
        exit(0);
    }
    
    my @cocci = (
        '@@',
        'expression E;',
        '@@',
        '',
        '- S_ISLNK(E->d_inode->i_mode)',
        '+ d_is_symlink(E)',
        '',
        '@@',
        'expression E;',
        '@@',
        '',
        '- S_ISDIR(E->d_inode->i_mode)',
        '+ d_is_dir(E)',
        '',
        '@@',
        'expression E;',
        '@@',
        '',
        '- S_ISREG(E->d_inode->i_mode)',
        '+ d_is_reg(E)' );
    
    my $coccifile = "tmp.sp.cocci";
    open($fd, ">$coccifile") || die $coccifile;
    print($fd "$_\n") || die $coccifile foreach (@cocci);
    close($fd);
    
    foreach my $file (@callers) {
        chomp $file;
        print "Processing ", $file, "\n";
        system("spatch", "--sp-file", $coccifile, $file, "--in-place", "--no-show-diff") == 0 ||
            die "spatch failed";
    }
    
    [AV: overlayfs parts skipped]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 04b06146bae2..4e781e697c90 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -266,7 +266,7 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 		for (i = 0; !err && i < buf.count && buf.dentries[i]; i++) {
 			struct dentry *dentry = buf.dentries[i];
 
-			if (!S_ISDIR(dentry->d_inode->i_mode))
+			if (!d_is_dir(dentry))
 				err = action(dentry, data);
 
 			dput(dentry);
@@ -322,7 +322,7 @@ static int delete_one_xattr(struct dentry *dentry, void *data)
 	struct inode *dir = dentry->d_parent->d_inode;
 
 	/* This is the xattr dir, handle specially. */
-	if (S_ISDIR(dentry->d_inode->i_mode))
+	if (d_is_dir(dentry))
 		return xattr_rmdir(dir, dentry);
 
 	return xattr_unlink(dir, dentry);

commit a455589f181e60439c736c6c6a068bb7e6dc23f0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Oct 21 20:11:25 2014 -0400

    assorted conversions to %p[dD]
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 628248ce2f8b..04b06146bae2 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -210,9 +210,9 @@ fill_with_dentries(struct dir_context *ctx, const char *name, int namelen,
 	} else if (!dentry->d_inode) {
 		/* A directory entry exists, but no file? */
 		reiserfs_error(dentry->d_sb, "xattr-20003",
-			       "Corrupted directory: xattr %s listed but "
-			       "not found for file %s.\n",
-			       dentry->d_name.name, dbuf->xadir->d_name.name);
+			       "Corrupted directory: xattr %pd listed but "
+			       "not found for file %pd.\n",
+			       dentry, dbuf->xadir);
 		dput(dentry);
 		return -EIO;
 	}

commit ac7576f4b1da8c9c6bc1ae026c2b9e86ae617ba5
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Thu Oct 30 17:37:34 2014 +0100

    vfs: make first argument of dir_context.actor typed
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 7c36898af402..628248ce2f8b 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -188,10 +188,11 @@ struct reiserfs_dentry_buf {
 };
 
 static int
-fill_with_dentries(void *buf, const char *name, int namelen, loff_t offset,
-		    u64 ino, unsigned int d_type)
+fill_with_dentries(struct dir_context *ctx, const char *name, int namelen,
+		   loff_t offset, u64 ino, unsigned int d_type)
 {
-	struct reiserfs_dentry_buf *dbuf = buf;
+	struct reiserfs_dentry_buf *dbuf =
+		container_of(ctx, struct reiserfs_dentry_buf, ctx);
 	struct dentry *dentry;
 
 	WARN_ON_ONCE(!mutex_is_locked(&dbuf->xadir->d_inode->i_mutex));
@@ -824,10 +825,12 @@ struct listxattr_buf {
 	struct dentry *dentry;
 };
 
-static int listxattr_filler(void *buf, const char *name, int namelen,
-			    loff_t offset, u64 ino, unsigned int d_type)
+static int listxattr_filler(struct dir_context *ctx, const char *name,
+			    int namelen, loff_t offset, u64 ino,
+			    unsigned int d_type)
 {
-	struct listxattr_buf *b = (struct listxattr_buf *)buf;
+	struct listxattr_buf *b =
+		container_of(ctx, struct listxattr_buf, ctx);
 	size_t size;
 
 	if (name[0] != '.' ||

commit f3fb9e27325c4e1730440820ea8a1e9d9a5af709
Author: Fabian Frederick <fabf@skynet.be>
Date:   Fri Aug 8 14:21:14 2014 -0700

    fs/reiserfs/xattr.c: fix blank line missing after declarations
    
    Fix checkpatch warning:
    
      WARNING: Missing a blank line after declarations
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 40c13dd914a7..7c36898af402 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -84,6 +84,7 @@ static int xattr_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 static int xattr_unlink(struct inode *dir, struct dentry *dentry)
 {
 	int error;
+
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
 
 	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);
@@ -98,6 +99,7 @@ static int xattr_unlink(struct inode *dir, struct dentry *dentry)
 static int xattr_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int error;
+
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
 
 	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);
@@ -117,6 +119,7 @@ static struct dentry *open_xa_root(struct super_block *sb, int flags)
 {
 	struct dentry *privroot = REISERFS_SB(sb)->priv_root;
 	struct dentry *xaroot;
+
 	if (!privroot->d_inode)
 		return ERR_PTR(-ENODATA);
 
@@ -127,6 +130,7 @@ static struct dentry *open_xa_root(struct super_block *sb, int flags)
 		xaroot = ERR_PTR(-ENODATA);
 	else if (!xaroot->d_inode) {
 		int err = -ENODATA;
+
 		if (xattr_may_create(flags))
 			err = xattr_mkdir(privroot->d_inode, xaroot, 0700);
 		if (err) {
@@ -157,6 +161,7 @@ static struct dentry *open_xa_dir(const struct inode *inode, int flags)
 	xadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));
 	if (!IS_ERR(xadir) && !xadir->d_inode) {
 		int err = -ENODATA;
+
 		if (xattr_may_create(flags))
 			err = xattr_mkdir(xaroot->d_inode, xadir, 0700);
 		if (err) {
@@ -188,6 +193,7 @@ fill_with_dentries(void *buf, const char *name, int namelen, loff_t offset,
 {
 	struct reiserfs_dentry_buf *dbuf = buf;
 	struct dentry *dentry;
+
 	WARN_ON_ONCE(!mutex_is_locked(&dbuf->xadir->d_inode->i_mutex));
 
 	if (dbuf->count == ARRAY_SIZE(dbuf->dentries))
@@ -218,6 +224,7 @@ static void
 cleanup_dentry_buf(struct reiserfs_dentry_buf *buf)
 {
 	int i;
+
 	for (i = 0; i < buf->count; i++)
 		if (buf->dentries[i])
 			dput(buf->dentries[i]);
@@ -283,11 +290,13 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 		int blocks = JOURNAL_PER_BALANCE_CNT * 2 + 2 +
 			     4 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);
 		struct reiserfs_transaction_handle th;
+
 		reiserfs_write_lock(inode->i_sb);
 		err = journal_begin(&th, inode->i_sb, blocks);
 		reiserfs_write_unlock(inode->i_sb);
 		if (!err) {
 			int jerror;
+
 			mutex_lock_nested(&dir->d_parent->d_inode->i_mutex,
 					  I_MUTEX_XATTR);
 			err = action(dir, data);
@@ -340,6 +349,7 @@ static int chown_one_xattr(struct dentry *dentry, void *data)
 int reiserfs_delete_xattrs(struct inode *inode)
 {
 	int err = reiserfs_for_each_xattr(inode, delete_one_xattr, NULL);
+
 	if (err)
 		reiserfs_warning(inode->i_sb, "jdm-20004",
 				 "Couldn't delete all xattrs (%d)\n", err);
@@ -350,6 +360,7 @@ int reiserfs_delete_xattrs(struct inode *inode)
 int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)
 {
 	int err = reiserfs_for_each_xattr(inode, chown_one_xattr, attrs);
+
 	if (err)
 		reiserfs_warning(inode->i_sb, "jdm-20007",
 				 "Couldn't chown all xattrs (%d)\n", err);
@@ -439,6 +450,7 @@ int reiserfs_commit_write(struct file *f, struct page *page,
 static void update_ctime(struct inode *inode)
 {
 	struct timespec now = current_fs_time(inode->i_sb);
+
 	if (inode_unhashed(inode) || !inode->i_nlink ||
 	    timespec_equal(&inode->i_ctime, &now))
 		return;
@@ -514,6 +526,7 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 		size_t chunk;
 		size_t skip = 0;
 		size_t page_offset = (file_pos & (PAGE_CACHE_SIZE - 1));
+
 		if (buffer_size - buffer_pos > PAGE_CACHE_SIZE)
 			chunk = PAGE_CACHE_SIZE;
 		else
@@ -530,6 +543,7 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 
 		if (file_pos == 0) {
 			struct reiserfs_xattr_header *rxh;
+
 			skip = file_pos = sizeof(struct reiserfs_xattr_header);
 			if (chunk + skip > PAGE_CACHE_SIZE)
 				chunk = PAGE_CACHE_SIZE - skip;
@@ -659,6 +673,7 @@ reiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,
 		size_t chunk;
 		char *data;
 		size_t skip = 0;
+
 		if (isize - file_pos > PAGE_CACHE_SIZE)
 			chunk = PAGE_CACHE_SIZE;
 		else
@@ -792,6 +807,7 @@ reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 int reiserfs_removexattr(struct dentry *dentry, const char *name)
 {
 	const struct xattr_handler *handler;
+
 	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
 
 	if (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
@@ -813,9 +829,11 @@ static int listxattr_filler(void *buf, const char *name, int namelen,
 {
 	struct listxattr_buf *b = (struct listxattr_buf *)buf;
 	size_t size;
+
 	if (name[0] != '.' ||
 	    (namelen != 1 && (name[1] != '.' || namelen != 2))) {
 		const struct xattr_handler *handler;
+
 		handler = find_xattr_handler_prefix(b->dentry->d_sb->s_xattr,
 						    name);
 		if (!handler)	/* Unsupported xattr name */
@@ -885,6 +903,7 @@ static int create_privroot(struct dentry *dentry)
 {
 	int err;
 	struct inode *inode = dentry->d_parent->d_inode;
+
 	WARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));
 
 	err = xattr_mkdir(inode, dentry, 0700);
@@ -1015,6 +1034,7 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 		mutex_lock(&privroot->d_inode->i_mutex);
 		if (!REISERFS_SB(s)->xattr_root) {
 			struct dentry *dentry;
+
 			dentry = lookup_one_len(XAROOT_NAME, privroot,
 						strlen(XAROOT_NAME));
 			if (!IS_ERR(dentry))

commit 17093991af4995c4b93f6d8ac63aab68fcd9e1be
Author: Fabian Frederick <fabf@skynet.be>
Date:   Fri Aug 8 14:21:12 2014 -0700

    fs/reiserfs: use linux/uaccess.h
    
    Fix checkpatch warning
    
      WARNING: Use #include <linux/uaccess.h> instead of <asm/uaccess.h>
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index ca416d099e7d..40c13dd914a7 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -45,7 +45,7 @@
 #include <linux/xattr.h>
 #include "xattr.h"
 #include "acl.h"
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <net/checksum.h>
 #include <linux/stat.h>
 #include <linux/quotaops.h>

commit a228bf8f0a3e5f1406edbd61f7400e87e23af5f7
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:42 2014 -0400

    reiserfs: cleanup, remove unnecessary parens
    
    The reiserfs code is littered with extra parens in places where the authors
    may not have been certain about precedence of & vs ->. This patch cleans them
    out.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 66a380c2ad39..ca416d099e7d 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -1027,8 +1027,8 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 
 error:
 	if (err) {
-		clear_bit(REISERFS_XATTRS_USER, &(REISERFS_SB(s)->s_mount_opt));
-		clear_bit(REISERFS_POSIXACL, &(REISERFS_SB(s)->s_mount_opt));
+		clear_bit(REISERFS_XATTRS_USER, &REISERFS_SB(s)->s_mount_opt);
+		clear_bit(REISERFS_POSIXACL, &REISERFS_SB(s)->s_mount_opt);
 	}
 
 	/* The super_block MS_POSIXACL must mirror the (no)acl mount option. */

commit cf776a7a4dafa330dd371a6a301ddf9e38747d93
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:41 2014 -0400

    reiserfs: cleanup, remove leading whitespace from labels
    
    This patch moves reiserfs closer to adhering to the style rules by
    removing leading whitespace from labels.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index a827d0b1cdb8..66a380c2ad39 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -423,7 +423,7 @@ static struct page *reiserfs_get_page(struct inode *dir, size_t n)
 	}
 	return page;
 
-      fail:
+fail:
 	reiserfs_put_page(page);
 	return ERR_PTR(-EIO);
 }

commit 58d854265c4c7d9792ecb5aa5ef67ba79b1a4c12
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:38 2014 -0400

    reiserfs: cleanup, remove sb argument from journal_end
    
    journal_end doesn't need a separate sb argument; it's provided by the
    transaction handle.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index b923e6f315e1..a827d0b1cdb8 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -292,7 +292,7 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 					  I_MUTEX_XATTR);
 			err = action(dir, data);
 			reiserfs_write_lock(inode->i_sb);
-			jerror = journal_end(&th, inode->i_sb);
+			jerror = journal_end(&th);
 			reiserfs_write_unlock(inode->i_sb);
 			mutex_unlock(&dir->d_parent->d_inode->i_mutex);
 			err = jerror ?: err;
@@ -601,7 +601,7 @@ int reiserfs_xattr_set(struct inode *inode, const char *name,
 					  buffer, buffer_size, flags);
 
 	reiserfs_write_lock(inode->i_sb);
-	error2 = journal_end(&th, inode->i_sb);
+	error2 = journal_end(&th);
 	reiserfs_write_unlock(inode->i_sb);
 	if (error == 0)
 		error = error2;

commit 706a5323384d9ae973a72005b73987d39e009019
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:37 2014 -0400

    reiserfs: cleanup, remove nblocks argument from journal_end
    
    journal_end takes a block count argument but doesn't actually use it
    for anything. We can remove it.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index f669990376af..b923e6f315e1 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -292,7 +292,7 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 					  I_MUTEX_XATTR);
 			err = action(dir, data);
 			reiserfs_write_lock(inode->i_sb);
-			jerror = journal_end(&th, inode->i_sb, blocks);
+			jerror = journal_end(&th, inode->i_sb);
 			reiserfs_write_unlock(inode->i_sb);
 			mutex_unlock(&dir->d_parent->d_inode->i_mutex);
 			err = jerror ?: err;
@@ -601,7 +601,7 @@ int reiserfs_xattr_set(struct inode *inode, const char *name,
 					  buffer, buffer_size, flags);
 
 	reiserfs_write_lock(inode->i_sb);
-	error2 = journal_end(&th, inode->i_sb, jbegin_count);
+	error2 = journal_end(&th, inode->i_sb);
 	reiserfs_write_unlock(inode->i_sb);
 	if (error == 0)
 		error = error2;

commit 098297b27d23ad9d0fc302e3417474d9342c6c14
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:36 2014 -0400

    reiserfs: cleanup, reformat comments to normal kernel style
    
    This patch reformats comments in the reiserfs code to fit in 80 columns and
    to follow the style rules.
    
    There is no functional change but it helps make my eyes bleed less.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 5cdfbd638b5c..f669990376af 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -56,9 +56,11 @@
 #define XAROOT_NAME   "xattrs"
 
 
-/* Helpers for inode ops. We do this so that we don't have all the VFS
+/*
+ * Helpers for inode ops. We do this so that we don't have all the VFS
  * overhead and also for proper i_mutex annotation.
- * dir->i_mutex must be held for all of them. */
+ * dir->i_mutex must be held for all of them.
+ */
 #ifdef CONFIG_REISERFS_FS_XATTR
 static int xattr_create(struct inode *dir, struct dentry *dentry, int mode)
 {
@@ -73,10 +75,12 @@ static int xattr_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 	return dir->i_op->mkdir(dir, dentry, mode);
 }
 
-/* We use I_MUTEX_CHILD here to silence lockdep. It's safe because xattr
+/*
+ * We use I_MUTEX_CHILD here to silence lockdep. It's safe because xattr
  * mutation ops aren't called during rename or splace, which are the
  * only other users of I_MUTEX_CHILD. It violates the ordering, but that's
- * better than allocating another subclass just for this code. */
+ * better than allocating another subclass just for this code.
+ */
 static int xattr_unlink(struct inode *dir, struct dentry *dentry)
 {
 	int error;
@@ -166,9 +170,11 @@ static struct dentry *open_xa_dir(const struct inode *inode, int flags)
 	return xadir;
 }
 
-/* The following are side effects of other operations that aren't explicitly
+/*
+ * The following are side effects of other operations that aren't explicitly
  * modifying extended attributes. This includes operations such as permissions
- * or ownership changes, object deletions, etc. */
+ * or ownership changes, object deletions, etc.
+ */
 struct reiserfs_dentry_buf {
 	struct dir_context ctx;
 	struct dentry *xadir;
@@ -267,11 +273,13 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 	cleanup_dentry_buf(&buf);
 
 	if (!err) {
-		/* We start a transaction here to avoid a ABBA situation
+		/*
+		 * We start a transaction here to avoid a ABBA situation
 		 * between the xattr root's i_mutex and the journal lock.
 		 * This doesn't incur much additional overhead since the
 		 * new transaction will just nest inside the
-		 * outer transaction. */
+		 * outer transaction.
+		 */
 		int blocks = JOURNAL_PER_BALANCE_CNT * 2 + 2 +
 			     4 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);
 		struct reiserfs_transaction_handle th;
@@ -349,9 +357,11 @@ int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)
 }
 
 #ifdef CONFIG_REISERFS_FS_XATTR
-/* Returns a dentry corresponding to a specific extended attribute file
+/*
+ * Returns a dentry corresponding to a specific extended attribute file
  * for the inode. If flags allow, the file is created. Otherwise, a
- * valid or negative dentry, or an error is returned. */
+ * valid or negative dentry, or an error is returned.
+ */
 static struct dentry *xattr_lookup(struct inode *inode, const char *name,
 				    int flags)
 {
@@ -400,8 +410,10 @@ static struct page *reiserfs_get_page(struct inode *dir, size_t n)
 {
 	struct address_space *mapping = dir->i_mapping;
 	struct page *page;
-	/* We can deadlock if we try to free dentries,
-	   and an unlink/rmdir has just occurred - GFP_NOFS avoids this */
+	/*
+	 * We can deadlock if we try to free dentries,
+	 * and an unlink/rmdir has just occurred - GFP_NOFS avoids this
+	 */
 	mapping_set_gfp_mask(mapping, GFP_NOFS);
 	page = read_mapping_page(mapping, n >> PAGE_CACHE_SHIFT, NULL);
 	if (!IS_ERR(page)) {
@@ -615,8 +627,10 @@ reiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,
 	if (name == NULL)
 		return -EINVAL;
 
-	/* We can't have xattrs attached to v1 items since they don't have
-	 * generation numbers */
+	/*
+	 * We can't have xattrs attached to v1 items since they don't have
+	 * generation numbers
+	 */
 	if (get_inode_sd_version(inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
@@ -913,12 +927,16 @@ static const struct xattr_handler *reiserfs_xattr_handlers[] = {
 
 static int xattr_mount_check(struct super_block *s)
 {
-	/* We need generation numbers to ensure that the oid mapping is correct
-	 * v3.5 filesystems don't have them. */
+	/*
+	 * We need generation numbers to ensure that the oid mapping is correct
+	 * v3.5 filesystems don't have them.
+	 */
 	if (old_format_only(s)) {
 		if (reiserfs_xattrs_optional(s)) {
-			/* Old format filesystem, but optional xattrs have
-			 * been enabled. Error out. */
+			/*
+			 * Old format filesystem, but optional xattrs have
+			 * been enabled. Error out.
+			 */
 			reiserfs_warning(s, "jdm-2005",
 					 "xattrs/ACLs not supported "
 					 "on pre-v3.6 format filesystems. "
@@ -972,9 +990,11 @@ int reiserfs_lookup_privroot(struct super_block *s)
 	return err;
 }
 
-/* We need to take a copy of the mount flags since things like
+/*
+ * We need to take a copy of the mount flags since things like
  * MS_RDONLY don't get set until *after* we're called.
- * mount_flags != mount_options */
+ * mount_flags != mount_options
+ */
 int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 {
 	int err = 0;

commit 47f70d08facf288a9faad6e6c36ac2e670be8195
Author: Christoph Hellwig <hch@infradead.org>
Date:   Fri Dec 20 05:16:49 2013 -0800

    reiserfs: use generic posix ACL infrastructure
    
    Also don't bother to set up a .get_acl method for symlinks as we do not
    support access control (ACLs or even mode bits) for symlinks in Linux.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 8a9e2dcfe004..5cdfbd638b5c 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -50,6 +50,7 @@
 #include <linux/stat.h>
 #include <linux/quotaops.h>
 #include <linux/security.h>
+#include <linux/posix_acl_xattr.h>
 
 #define PRIVROOT_NAME ".reiserfs_priv"
 #define XAROOT_NAME   "xattrs"
@@ -904,8 +905,8 @@ static const struct xattr_handler *reiserfs_xattr_handlers[] = {
 	&reiserfs_xattr_security_handler,
 #endif
 #ifdef CONFIG_REISERFS_FS_POSIX_ACL
-	&reiserfs_posix_acl_access_handler,
-	&reiserfs_posix_acl_default_handler,
+	&posix_acl_access_xattr_handler,
+	&posix_acl_default_xattr_handler,
 #endif
 	NULL
 };

commit 4c05141df57f4ffc1a9a28f1925434924179bfe4
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Aug 8 17:27:19 2013 -0400

    reiserfs: locking, push write lock out of xattr code
    
    The reiserfs xattr code doesn't need the write lock and sleeps all over
    the place. We can simplify the locking by releasing it and reacquiring
    after the xattr call.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index c69cdd749f09..8a9e2dcfe004 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -81,8 +81,7 @@ static int xattr_unlink(struct inode *dir, struct dentry *dentry)
 	int error;
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
 
-	reiserfs_mutex_lock_nested_safe(&dentry->d_inode->i_mutex,
-					I_MUTEX_CHILD, dir->i_sb);
+	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);
 	error = dir->i_op->unlink(dir, dentry);
 	mutex_unlock(&dentry->d_inode->i_mutex);
 
@@ -96,8 +95,7 @@ static int xattr_rmdir(struct inode *dir, struct dentry *dentry)
 	int error;
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
 
-	reiserfs_mutex_lock_nested_safe(&dentry->d_inode->i_mutex,
-					I_MUTEX_CHILD, dir->i_sb);
+	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);
 	error = dir->i_op->rmdir(dir, dentry);
 	if (!error)
 		dentry->d_inode->i_flags |= S_DEAD;
@@ -232,22 +230,17 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 	if (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1)
 		return 0;
 
-	reiserfs_write_unlock(inode->i_sb);
 	dir = open_xa_dir(inode, XATTR_REPLACE);
 	if (IS_ERR(dir)) {
 		err = PTR_ERR(dir);
-		reiserfs_write_lock(inode->i_sb);
 		goto out;
 	} else if (!dir->d_inode) {
 		err = 0;
-		reiserfs_write_lock(inode->i_sb);
 		goto out_dir;
 	}
 
 	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
 
-	reiserfs_write_lock(inode->i_sb);
-
 	buf.xadir = dir;
 	while (1) {
 		err = reiserfs_readdir_inode(dir->d_inode, &buf.ctx);
@@ -281,14 +274,17 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 		int blocks = JOURNAL_PER_BALANCE_CNT * 2 + 2 +
 			     4 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);
 		struct reiserfs_transaction_handle th;
+		reiserfs_write_lock(inode->i_sb);
 		err = journal_begin(&th, inode->i_sb, blocks);
+		reiserfs_write_unlock(inode->i_sb);
 		if (!err) {
 			int jerror;
-			reiserfs_mutex_lock_nested_safe(
-					  &dir->d_parent->d_inode->i_mutex,
-					  I_MUTEX_XATTR, inode->i_sb);
+			mutex_lock_nested(&dir->d_parent->d_inode->i_mutex,
+					  I_MUTEX_XATTR);
 			err = action(dir, data);
+			reiserfs_write_lock(inode->i_sb);
 			jerror = journal_end(&th, inode->i_sb, blocks);
+			reiserfs_write_unlock(inode->i_sb);
 			mutex_unlock(&dir->d_parent->d_inode->i_mutex);
 			err = jerror ?: err;
 		}
@@ -455,9 +451,7 @@ static int lookup_and_delete_xattr(struct inode *inode, const char *name)
 	}
 
 	if (dentry->d_inode) {
-		reiserfs_write_lock(inode->i_sb);
 		err = xattr_unlink(xadir->d_inode, dentry);
-		reiserfs_write_unlock(inode->i_sb);
 		update_ctime(inode);
 	}
 
@@ -491,24 +485,17 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 	if (get_inode_sd_version(inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	reiserfs_write_unlock(inode->i_sb);
-
 	if (!buffer) {
 		err = lookup_and_delete_xattr(inode, name);
-		reiserfs_write_lock(inode->i_sb);
 		return err;
 	}
 
 	dentry = xattr_lookup(inode, name, flags);
-	if (IS_ERR(dentry)) {
-		reiserfs_write_lock(inode->i_sb);
+	if (IS_ERR(dentry))
 		return PTR_ERR(dentry);
-	}
 
 	down_write(&REISERFS_I(inode)->i_xattr_sem);
 
-	reiserfs_write_lock(inode->i_sb);
-
 	xahash = xattr_hash(buffer, buffer_size);
 	while (buffer_pos < buffer_size || buffer_pos == 0) {
 		size_t chunk;
@@ -538,6 +525,7 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 			rxh->h_hash = cpu_to_le32(xahash);
 		}
 
+		reiserfs_write_lock(inode->i_sb);
 		err = __reiserfs_write_begin(page, page_offset, chunk + skip);
 		if (!err) {
 			if (buffer)
@@ -546,6 +534,7 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 						    page_offset + chunk +
 						    skip);
 		}
+		reiserfs_write_unlock(inode->i_sb);
 		unlock_page(page);
 		reiserfs_put_page(page);
 		buffer_pos += chunk;
@@ -563,10 +552,8 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 			.ia_valid = ATTR_SIZE | ATTR_CTIME,
 		};
 
-		reiserfs_write_unlock(inode->i_sb);
 		mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);
 		inode_dio_wait(dentry->d_inode);
-		reiserfs_write_lock(inode->i_sb);
 
 		err = reiserfs_setattr(dentry, &newattrs);
 		mutex_unlock(&dentry->d_inode->i_mutex);
@@ -592,18 +579,19 @@ int reiserfs_xattr_set(struct inode *inode, const char *name,
 
 	reiserfs_write_lock(inode->i_sb);
 	error = journal_begin(&th, inode->i_sb, jbegin_count);
+	reiserfs_write_unlock(inode->i_sb);
 	if (error) {
-		reiserfs_write_unlock(inode->i_sb);
 		return error;
 	}
 
 	error = reiserfs_xattr_set_handle(&th, inode, name,
 					  buffer, buffer_size, flags);
 
+	reiserfs_write_lock(inode->i_sb);
 	error2 = journal_end(&th, inode->i_sb, jbegin_count);
+	reiserfs_write_unlock(inode->i_sb);
 	if (error == 0)
 		error = error2;
-	reiserfs_write_unlock(inode->i_sb);
 
 	return error;
 }
@@ -968,7 +956,7 @@ int reiserfs_lookup_privroot(struct super_block *s)
 	int err = 0;
 
 	/* If we don't have the privroot located yet - go find it */
-	reiserfs_mutex_lock_safe(&s->s_root->d_inode->i_mutex, s);
+	mutex_lock(&s->s_root->d_inode->i_mutex);
 	dentry = lookup_one_len(PRIVROOT_NAME, s->s_root,
 				strlen(PRIVROOT_NAME));
 	if (!IS_ERR(dentry)) {
@@ -996,14 +984,14 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 		goto error;
 
 	if (!privroot->d_inode && !(mount_flags & MS_RDONLY)) {
-		reiserfs_mutex_lock_safe(&s->s_root->d_inode->i_mutex, s);
+		mutex_lock(&s->s_root->d_inode->i_mutex);
 		err = create_privroot(REISERFS_SB(s)->priv_root);
 		mutex_unlock(&s->s_root->d_inode->i_mutex);
 	}
 
 	if (privroot->d_inode) {
 		s->s_xattr = reiserfs_xattr_handlers;
-		reiserfs_mutex_lock_safe(&privroot->d_inode->i_mutex, s);
+		mutex_lock(&privroot->d_inode->i_mutex);
 		if (!REISERFS_SB(s)->xattr_root) {
 			struct dentry *dentry;
 			dentry = lookup_one_len(XAROOT_NAME, privroot,

commit cd62cdae0bd7fb76cae66347dc4fc00e87ffc1c4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri May 17 22:58:58 2013 -0400

    reiserfs: switch reiserfs_readdir_dentry to inode
    
    ... and clean the callers up a bit
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 26648a451e87..c69cdd749f09 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -249,28 +249,27 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 	reiserfs_write_lock(inode->i_sb);
 
 	buf.xadir = dir;
-	err = reiserfs_readdir_dentry(dir, &buf.ctx);
-	while ((err == 0 || err == -ENOSPC) && buf.count) {
-		err = 0;
-
-		for (i = 0; i < buf.count && buf.dentries[i]; i++) {
-			int lerr = 0;
+	while (1) {
+		err = reiserfs_readdir_inode(dir->d_inode, &buf.ctx);
+		if (err)
+			break;
+		if (!buf.count)
+			break;
+		for (i = 0; !err && i < buf.count && buf.dentries[i]; i++) {
 			struct dentry *dentry = buf.dentries[i];
 
-			if (err == 0 && !S_ISDIR(dentry->d_inode->i_mode))
-				lerr = action(dentry, data);
+			if (!S_ISDIR(dentry->d_inode->i_mode))
+				err = action(dentry, data);
 
 			dput(dentry);
 			buf.dentries[i] = NULL;
-			err = lerr ?: err;
 		}
+		if (err)
+			break;
 		buf.count = 0;
-		if (!err)
-			err = reiserfs_readdir_dentry(dir, &buf.ctx);
 	}
 	mutex_unlock(&dir->d_inode->i_mutex);
 
-	/* Clean up after a failed readdir */
 	cleanup_dentry_buf(&buf);
 
 	if (!err) {
@@ -868,7 +867,7 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 	}
 
 	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
-	err = reiserfs_readdir_dentry(dir, &buf.ctx);
+	err = reiserfs_readdir_inode(dir->d_inode, &buf.ctx);
 	mutex_unlock(&dir->d_inode->i_mutex);
 
 	if (!err)

commit 4acf381e1b6c01d6058d353191259c952bd6f3e7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri May 17 22:42:17 2013 -0400

    [readdir] convert reiserfs
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 821bcf70e467..26648a451e87 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -171,6 +171,7 @@ static struct dentry *open_xa_dir(const struct inode *inode, int flags)
  * modifying extended attributes. This includes operations such as permissions
  * or ownership changes, object deletions, etc. */
 struct reiserfs_dentry_buf {
+	struct dir_context ctx;
 	struct dentry *xadir;
 	int count;
 	struct dentry *dentries[8];
@@ -223,9 +224,8 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 {
 	struct dentry *dir;
 	int i, err = 0;
-	loff_t pos = 0;
 	struct reiserfs_dentry_buf buf = {
-		.count = 0,
+		.ctx.actor = fill_with_dentries,
 	};
 
 	/* Skip out, an xattr has no xattrs associated with it */
@@ -249,7 +249,7 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 	reiserfs_write_lock(inode->i_sb);
 
 	buf.xadir = dir;
-	err = reiserfs_readdir_dentry(dir, &buf, fill_with_dentries, &pos);
+	err = reiserfs_readdir_dentry(dir, &buf.ctx);
 	while ((err == 0 || err == -ENOSPC) && buf.count) {
 		err = 0;
 
@@ -266,8 +266,7 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 		}
 		buf.count = 0;
 		if (!err)
-			err = reiserfs_readdir_dentry(dir, &buf,
-						      fill_with_dentries, &pos);
+			err = reiserfs_readdir_dentry(dir, &buf.ctx);
 	}
 	mutex_unlock(&dir->d_inode->i_mutex);
 
@@ -800,6 +799,7 @@ int reiserfs_removexattr(struct dentry *dentry, const char *name)
 }
 
 struct listxattr_buf {
+	struct dir_context ctx;
 	size_t size;
 	size_t pos;
 	char *buf;
@@ -845,8 +845,8 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 {
 	struct dentry *dir;
 	int err = 0;
-	loff_t pos = 0;
 	struct listxattr_buf buf = {
+		.ctx.actor = listxattr_filler,
 		.dentry = dentry,
 		.buf = buffer,
 		.size = buffer ? size : 0,
@@ -868,7 +868,7 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 	}
 
 	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
-	err = reiserfs_readdir_dentry(dir, &buf, listxattr_filler, &pos);
+	err = reiserfs_readdir_dentry(dir, &buf.ctx);
 	mutex_unlock(&dir->d_inode->i_mutex);
 
 	if (!err)

commit 4a8570112b76a63ad21cfcbe2783f98f7fd5ba1b
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri May 31 15:54:17 2013 -0400

    reiserfs: fix problems with chowning setuid file w/ xattrs
    
    reiserfs_chown_xattrs() takes the iattr struct passed into ->setattr
    and uses it to iterate over all the attrs associated with a file to change
    ownership of xattrs (and transfer quota associated with the xattr files).
    
    When the setuid bit is cleared during chown, ATTR_MODE and iattr->ia_mode
    are passed to all the xattrs as well. This means that the xattr directory
    will have S_IFREG added to its mode bits.
    
    This has been prevented in practice by a missing IS_PRIVATE check
    in reiserfs_acl_chmod, which caused a double-lock to occur while holding
    the write lock. Since the file system was completely locked up, the
    writeout of the corrupted mode never happened.
    
    This patch temporarily clears everything but ATTR_UID|ATTR_GID for the
    calls to reiserfs_setattr and adds the missing IS_PRIVATE check.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 4cce1d9552fb..821bcf70e467 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -318,7 +318,19 @@ static int delete_one_xattr(struct dentry *dentry, void *data)
 static int chown_one_xattr(struct dentry *dentry, void *data)
 {
 	struct iattr *attrs = data;
-	return reiserfs_setattr(dentry, attrs);
+	int ia_valid = attrs->ia_valid;
+	int err;
+
+	/*
+	 * We only want the ownership bits. Otherwise, we'll do
+	 * things like change a directory to a regular file if
+	 * ATTR_MODE is set.
+	 */
+	attrs->ia_valid &= (ATTR_UID|ATTR_GID);
+	err = reiserfs_setattr(dentry, attrs);
+	attrs->ia_valid = ia_valid;
+
+	return err;
 }
 
 /* No i_mutex, but the inode is unconnected. */

commit 35e5cbc0af240778e61113286c019837e06aeec6
Author: Jan Kara <jack@suse.cz>
Date:   Fri Mar 29 15:39:16 2013 +0100

    reiserfs: Fix warning and inode leak when deleting inode with xattrs
    
    After commit 21d8a15a (lookup_one_len: don't accept . and ..) reiserfs
    started failing to delete xattrs from inode. This was due to a buggy
    test for '.' and '..' in fill_with_dentries() which resulted in passing
    '.' and '..' entries to lookup_one_len() in some cases. That returned
    error and so we failed to iterate over all xattrs of and inode.
    
    Fix the test in fill_with_dentries() along the lines of the one in
    lookup_one_len().
    
    Reported-by: Pawel Zawora <pzawora@gmail.com>
    CC: stable@vger.kernel.org
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index c196369fe408..4cce1d9552fb 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -187,8 +187,8 @@ fill_with_dentries(void *buf, const char *name, int namelen, loff_t offset,
 	if (dbuf->count == ARRAY_SIZE(dbuf->dentries))
 		return -ENOSPC;
 
-	if (name[0] == '.' && (name[1] == '\0' ||
-			       (name[1] == '.' && name[2] == '\0')))
+	if (name[0] == '.' && (namelen < 2 ||
+			       (namelen == 2 && name[1] == '.')))
 		return 0;
 
 	dentry = lookup_one_len(name, dbuf->xadir, namelen);

commit da02eb72f150bef1d281d93b3e4716ce374c4510
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Thu Aug 23 17:28:57 2012 +0200

    reiserfs: Make reiserfs_xattr_handlers static
    
    Silences the following sparse warning: fs/reiserfs/xattr.c:899:28: warning:
    symbol 'reiserfs_xattr_handlers' was not declared. Should it be static?
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index d319963aeb11..c196369fe408 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -896,7 +896,7 @@ static int create_privroot(struct dentry *dentry) { return 0; }
 #endif
 
 /* Actual operations that are exported to VFS-land */
-const struct xattr_handler *reiserfs_xattr_handlers[] = {
+static const struct xattr_handler *reiserfs_xattr_handlers[] = {
 #ifdef CONFIG_REISERFS_FS_XATTR
 	&reiserfs_xattr_user_handler,
 	&reiserfs_xattr_trusted_handler,

commit ebfc3b49a7ac25920cb5be5445f602e51d2ea559
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jun 10 18:05:36 2012 -0400

    don't pass nameidata to ->create()
    
    boolean "does it have to be exclusive?" flag is passed instead;
    Local filesystem should just ignore it - the object is guaranteed
    not to be there yet.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index e6ad8d7dea64..d319963aeb11 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -62,7 +62,7 @@
 static int xattr_create(struct inode *dir, struct dentry *dentry, int mode)
 {
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
-	return dir->i_op->create(dir, dentry, mode, NULL);
+	return dir->i_op->create(dir, dentry, mode, true);
 }
 #endif
 

commit 0b728e1911cbe6e24020727c3870628b9653f32a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jun 10 16:03:43 2012 -0400

    stop passing nameidata * to ->d_revalidate()
    
    Just the lookup flags.  Die, bastard, die...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 46fc1c20a6b1..e6ad8d7dea64 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -942,7 +942,7 @@ int reiserfs_permission(struct inode *inode, int mask)
 	return generic_permission(inode, mask);
 }
 
-static int xattr_hide_revalidate(struct dentry *dentry, struct nameidata *nd)
+static int xattr_hide_revalidate(struct dentry *dentry, unsigned int flags)
 {
 	return -EPERM;
 }

commit f466c6fdb3b1f043ff1977a8d2a1d0cd4dc164fa
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 17 01:16:43 2012 -0400

    move private bits of reiserfs_fs.h to fs/reiserfs/reiserfs.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 61c9b5633e27..46fc1c20a6b1 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -33,7 +33,7 @@
  * The xattrs themselves are protected by the xattr_sem.
  */
 
-#include <linux/reiserfs_fs.h>
+#include "reiserfs.h"
 #include <linux/capability.h>
 #include <linux/dcache.h>
 #include <linux/namei.h>

commit a3063ab88fcbe5249f841cb95dfd626b8bf2674f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 17 01:03:10 2012 -0400

    move reiserfs_acl.h to fs/reiserfs/acl.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index ead5d8aab440..61c9b5633e27 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -44,7 +44,7 @@
 #include <linux/pagemap.h>
 #include <linux/xattr.h>
 #include "xattr.h"
-#include <linux/reiserfs_acl.h>
+#include "acl.h"
 #include <asm/uaccess.h>
 #include <net/checksum.h>
 #include <linux/stat.h>

commit c45ac8887e778c4fa2b572c51a94a681a0955d4d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 17 00:59:06 2012 -0400

    take private bits of reiserfs_xattr.h to fs/reiserfs/xattr.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index c24deda8a8bc..ead5d8aab440 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -43,7 +43,7 @@
 #include <linux/file.h>
 #include <linux/pagemap.h>
 #include <linux/xattr.h>
-#include <linux/reiserfs_xattr.h>
+#include "xattr.h"
 #include <linux/reiserfs_acl.h>
 #include <asm/uaccess.h>
 #include <net/checksum.h>

commit 18bb1db3e7607e4a997d50991a6f9fa5b0f8722c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 26 01:41:39 2011 -0400

    switch vfs_mkdir() and ->mkdir() to umode_t
    
    vfs_mkdir() gets int, but immediately drops everything that might not
    fit into umode_t and that's the only caller of ->mkdir()...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 6bc346c160e7..c24deda8a8bc 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -66,7 +66,7 @@ static int xattr_create(struct inode *dir, struct dentry *dentry, int mode)
 }
 #endif
 
-static int xattr_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+static int xattr_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 {
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
 	return dir->i_op->mkdir(dir, dentry, mode);

commit 4e34e719e457f2e031297175410fc0bd4016a085
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jul 23 17:37:31 2011 +0200

    fs: take the ACL checks to common code
    
    Replace the ->check_acl method with a ->get_acl method that simply reads an
    ACL from disk after having a cache miss.  This means we can replace the ACL
    checking boilerplate code with a single implementation in namei.c.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 7ba083eb62bd..6bc346c160e7 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -867,24 +867,6 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 	return err;
 }
 
-int reiserfs_check_acl(struct inode *inode, int mask)
-{
-	struct posix_acl *acl;
-	int error = -EAGAIN; /* do regular unix permission checks by default */
-
-	acl = reiserfs_get_acl(inode, ACL_TYPE_ACCESS);
-
-	if (acl) {
-		if (!IS_ERR(acl)) {
-			error = posix_acl_permission(inode, acl, mask);
-			posix_acl_release(acl);
-		} else if (PTR_ERR(acl) != -ENODATA)
-			error = PTR_ERR(acl);
-	}
-
-	return error;
-}
-
 static int create_privroot(struct dentry *dentry)
 {
 	int err;

commit 4482a087d4c5a6ffbc385c56b4a4e2f694d9fd5d
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jul 23 17:37:03 2011 +0200

    reiserfs: cache negative ACLs for v1 stat format
    
    Always set up a negative ACL cache entry if the inode can't have ACLs.
    That behaves much better than doing this check inside ->check_acl.
    
    Also remove the left over MAY_NOT_BLOCK check.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 6938d8c68d6e..7ba083eb62bd 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -872,15 +872,6 @@ int reiserfs_check_acl(struct inode *inode, int mask)
 	struct posix_acl *acl;
 	int error = -EAGAIN; /* do regular unix permission checks by default */
 
-	/*
-	 * Stat data v1 doesn't support ACLs.
-	 */
-	if (get_inode_sd_version(inode) == STAT_DATA_V1)
-		return -EAGAIN;
-
-	if (mask & MAY_NOT_BLOCK)
-		return -ECHILD;
-
 	acl = reiserfs_get_acl(inode, ACL_TYPE_ACCESS);
 
 	if (acl) {

commit bd5fe6c5eb9c548d7f07fe8f89a150bb6705e8e3
Author: Christoph Hellwig <hch@infradead.org>
Date:   Fri Jun 24 14:29:43 2011 -0400

    fs: kill i_alloc_sem
    
    i_alloc_sem is a rather special rw_semaphore.  It's the last one that may
    be released by a non-owner, and it's write side is always mirrored by
    real exclusion.  It's intended use it to wait for all pending direct I/O
    requests to finish before starting a truncate.
    
    Replace it with a hand-grown construct:
    
     - exclusion for truncates is already guaranteed by i_mutex, so it can
       simply fall way
     - the reader side is replaced by an i_dio_count member in struct inode
       that counts the number of pending direct I/O requests.  Truncate can't
       proceed as long as it's non-zero
     - when i_dio_count reaches non-zero we wake up a pending truncate using
       wake_up_bit on a new bit in i_flags
     - new references to i_dio_count can't appear while we are waiting for
       it to read zero because the direct I/O count always needs i_mutex
       (or an equivalent like XFS's i_iolock) for starting a new operation.
    
    This scheme is much simpler, and saves the space of a spinlock_t and a
    struct list_head in struct inode (typically 160 bits on a non-debug 64-bit
    system).
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 4ea2ab41fdee..6938d8c68d6e 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -555,11 +555,10 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 
 		reiserfs_write_unlock(inode->i_sb);
 		mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);
-		down_write(&dentry->d_inode->i_alloc_sem);
+		inode_dio_wait(dentry->d_inode);
 		reiserfs_write_lock(inode->i_sb);
 
 		err = reiserfs_setattr(dentry, &newattrs);
-		up_write(&dentry->d_inode->i_alloc_sem);
 		mutex_unlock(&dentry->d_inode->i_mutex);
 	} else
 		update_ctime(inode);

commit 10556cb21a0d0b24d95f00ea6df16f599a3345b2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 19:28:19 2011 -0400

    ->permission() sanitizing: don't pass flags to ->permission()
    
    not used by the instances anymore.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index f17319613a85..4ea2ab41fdee 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -958,7 +958,7 @@ static int xattr_mount_check(struct super_block *s)
 	return 0;
 }
 
-int reiserfs_permission(struct inode *inode, int mask, unsigned int flags)
+int reiserfs_permission(struct inode *inode, int mask)
 {
 	/*
 	 * We don't do permission checks on the internal objects.

commit 2830ba7f34ebb27c4e5b8b6ef408cd6d74860890
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 19:16:29 2011 -0400

    ->permission() sanitizing: don't pass flags to generic_permission()
    
    redundant; all callers get it duplicated in mask & MAY_NOT_BLOCK and none of
    them removes that bit.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 6ee3c11aa8d9..f17319613a85 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -967,7 +967,7 @@ int reiserfs_permission(struct inode *inode, int mask, unsigned int flags)
 	if (IS_PRIVATE(inode))
 		return 0;
 
-	return generic_permission(inode, mask, flags);
+	return generic_permission(inode, mask);
 }
 
 static int xattr_hide_revalidate(struct dentry *dentry, struct nameidata *nd)

commit 7e40145eb111a5192e6d819f764db9d6828d1abb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 19:12:17 2011 -0400

    ->permission() sanitizing: don't pass flags to ->check_acl()
    
    not used in the instances anymore.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 6747470ec103..6ee3c11aa8d9 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -868,7 +868,7 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 	return err;
 }
 
-int reiserfs_check_acl(struct inode *inode, int mask, unsigned int flags)
+int reiserfs_check_acl(struct inode *inode, int mask)
 {
 	struct posix_acl *acl;
 	int error = -EAGAIN; /* do regular unix permission checks by default */

commit 9c2c703929e4c41210cfa6e3f599514421bab8dc
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 19:06:22 2011 -0400

    ->permission() sanitizing: pass MAY_NOT_BLOCK to ->check_acl()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index ddc5301d2986..6747470ec103 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -879,7 +879,7 @@ int reiserfs_check_acl(struct inode *inode, int mask, unsigned int flags)
 	if (get_inode_sd_version(inode) == STAT_DATA_V1)
 		return -EAGAIN;
 
-	if (flags & IPERM_FLAG_RCU)
+	if (mask & MAY_NOT_BLOCK)
 		return -ECHILD;
 
 	acl = reiserfs_get_acl(inode, ACL_TYPE_ACCESS);

commit 178ea73521d64ba41d7aa5488fb9f549c6d4507d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 11:31:30 2011 -0400

    kill check_acl callback of generic_permission()
    
    its value depends only on inode and does not change; we might as
    well store it in ->i_op->check_acl and be done with that.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index d78089690965..ddc5301d2986 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -868,11 +868,17 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 	return err;
 }
 
-static int reiserfs_check_acl(struct inode *inode, int mask, unsigned int flags)
+int reiserfs_check_acl(struct inode *inode, int mask, unsigned int flags)
 {
 	struct posix_acl *acl;
 	int error = -EAGAIN; /* do regular unix permission checks by default */
 
+	/*
+	 * Stat data v1 doesn't support ACLs.
+	 */
+	if (get_inode_sd_version(inode) == STAT_DATA_V1)
+		return -EAGAIN;
+
 	if (flags & IPERM_FLAG_RCU)
 		return -ECHILD;
 
@@ -961,15 +967,7 @@ int reiserfs_permission(struct inode *inode, int mask, unsigned int flags)
 	if (IS_PRIVATE(inode))
 		return 0;
 
-#ifdef CONFIG_REISERFS_FS_XATTR
-	/*
-	 * Stat data v1 doesn't support ACLs.
-	 */
-	if (get_inode_sd_version(inode) != STAT_DATA_V1)
-		return generic_permission(inode, mask, flags,
-					reiserfs_check_acl);
-#endif
-	return generic_permission(inode, mask, flags, NULL);
+	return generic_permission(inode, mask, flags);
 }
 
 static int xattr_hide_revalidate(struct dentry *dentry, struct nameidata *nd)

commit 1d29b5a2ed7eb8862c9b66daf475f3e4c1a40299
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jun 18 20:37:33 2011 -0400

    reiserfs_permission() doesn't need to bail out in RCU mode
    
    nothing blocking other than generic_permission() (and
    check_acl callback does bail out in RCU mode).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index e8a62f41b458..d78089690965 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -954,8 +954,6 @@ static int xattr_mount_check(struct super_block *s)
 
 int reiserfs_permission(struct inode *inode, int mask, unsigned int flags)
 {
-	if (flags & IPERM_FLAG_RCU)
-		return -ECHILD;
 	/*
 	 * We don't do permission checks on the internal objects.
 	 * Permissions are determined by the "owning" object.

commit cc350c2764a657ee012efd5bd260a6cd5be2f877
Author: Sage Weil <sage@newdream.net>
Date:   Fri May 27 13:42:02 2011 -0700

    reiserfs: remove unnecessary dentry_unhash from rmdir, dir rename
    
    Reiserfs does not have problems with references to unlinked directories.
    
    CC: reiserfs-devel@vger.kernel.org
    Signed-off-by: Sage Weil <sage@newdream.net>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 50f1abccd1cd..e8a62f41b458 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -98,7 +98,6 @@ static int xattr_rmdir(struct inode *dir, struct dentry *dentry)
 
 	reiserfs_mutex_lock_nested_safe(&dentry->d_inode->i_mutex,
 					I_MUTEX_CHILD, dir->i_sb);
-	dentry_unhash(dentry);
 	error = dir->i_op->rmdir(dir, dentry);
 	if (!error)
 		dentry->d_inode->i_flags |= S_DEAD;

commit 64252c75a2196a0cf1e0d3777143ecfe0e3ae650
Author: Sage Weil <sage@newdream.net>
Date:   Tue May 24 13:06:05 2011 -0700

    vfs: remove dget() from dentry_unhash()
    
    This serves no useful purpose that I can discern.  All callers (rename,
    rmdir) hold their own reference to the dentry.
    
    A quick audit of all file systems showed no relevant checks on the value
    of d_count in vfs_rmdir/vfs_rename_dir paths.
    
    Signed-off-by: Sage Weil <sage@newdream.net>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 47d2a4498b03..50f1abccd1cd 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -105,7 +105,6 @@ static int xattr_rmdir(struct inode *dir, struct dentry *dentry)
 	mutex_unlock(&dentry->d_inode->i_mutex);
 	if (!error)
 		d_delete(dentry);
-	dput(dentry);
 
 	return error;
 }

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 5c11ca82b782..47d2a4498b03 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -396,7 +396,7 @@ static struct page *reiserfs_get_page(struct inode *dir, size_t n)
 	struct address_space *mapping = dir->i_mapping;
 	struct page *page;
 	/* We can deadlock if we try to free dentries,
-	   and an unlink/rmdir has just occured - GFP_NOFS avoids this */
+	   and an unlink/rmdir has just occurred - GFP_NOFS avoids this */
 	mapping_set_gfp_mask(mapping, GFP_NOFS);
 	page = read_mapping_page(mapping, n >> PAGE_CACHE_SHIFT, NULL);
 	if (!IS_ERR(page)) {

commit c78f4cc5e7d642c7009089817c12d8984e7ba872
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Feb 16 10:14:56 2011 -0500

    reiserfs xattr ->d_revalidate() shouldn't care about RCU
    
    ... it returns an error unconditionally
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 3cfb2e933644..5c11ca82b782 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -978,8 +978,6 @@ int reiserfs_permission(struct inode *inode, int mask, unsigned int flags)
 
 static int xattr_hide_revalidate(struct dentry *dentry, struct nameidata *nd)
 {
-	if (nd->flags & LOOKUP_RCU)
-		return -ECHILD;
 	return -EPERM;
 }
 

commit b74c79e99389cd79b31fcc08f82c24e492e63c7e
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:49:58 2011 +1100

    fs: provide rcu-walk aware permission i_ops
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 9ea22a56cdf1..3cfb2e933644 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -870,11 +870,14 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 	return err;
 }
 
-static int reiserfs_check_acl(struct inode *inode, int mask)
+static int reiserfs_check_acl(struct inode *inode, int mask, unsigned int flags)
 {
 	struct posix_acl *acl;
 	int error = -EAGAIN; /* do regular unix permission checks by default */
 
+	if (flags & IPERM_FLAG_RCU)
+		return -ECHILD;
+
 	acl = reiserfs_get_acl(inode, ACL_TYPE_ACCESS);
 
 	if (acl) {
@@ -951,8 +954,10 @@ static int xattr_mount_check(struct super_block *s)
 	return 0;
 }
 
-int reiserfs_permission(struct inode *inode, int mask)
+int reiserfs_permission(struct inode *inode, int mask, unsigned int flags)
 {
+	if (flags & IPERM_FLAG_RCU)
+		return -ECHILD;
 	/*
 	 * We don't do permission checks on the internal objects.
 	 * Permissions are determined by the "owning" object.
@@ -965,9 +970,10 @@ int reiserfs_permission(struct inode *inode, int mask)
 	 * Stat data v1 doesn't support ACLs.
 	 */
 	if (get_inode_sd_version(inode) != STAT_DATA_V1)
-		return generic_permission(inode, mask, reiserfs_check_acl);
+		return generic_permission(inode, mask, flags,
+					reiserfs_check_acl);
 #endif
-	return generic_permission(inode, mask, NULL);
+	return generic_permission(inode, mask, flags, NULL);
 }
 
 static int xattr_hide_revalidate(struct dentry *dentry, struct nameidata *nd)

commit 34286d6662308d82aed891852d04c7c3a2649b16
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:49:57 2011 +1100

    fs: rcu-walk aware d_revalidate method
    
    Require filesystems be aware of .d_revalidate being called in rcu-walk
    mode (nd->flags & LOOKUP_RCU). For now do a simple push down, returning
    -ECHILD from all implementations.
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index e0f0d7ea10a1..9ea22a56cdf1 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -972,6 +972,8 @@ int reiserfs_permission(struct inode *inode, int mask)
 
 static int xattr_hide_revalidate(struct dentry *dentry, struct nameidata *nd)
 {
+	if (nd->flags & LOOKUP_RCU)
+		return -ECHILD;
 	return -EPERM;
 }
 

commit fb045adb99d9b7c562dc7fef834857f78249daa1
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:49:55 2011 +1100

    fs: dcache reduce branches in lookup path
    
    Reduce some branches and memory accesses in dcache lookup by adding dentry
    flags to indicate common d_ops are set, rather than having to check them.
    This saves a pointer memory access (dentry->d_op) in common path lookup
    situations, and saves another pointer load and branch in cases where we
    have d_op but not the particular operation.
    
    Patched with:
    
    git grep -E '[.>]([[:space:]])*d_op([[:space:]])*=' | xargs sed -e 's/\([^\t ]*\)->d_op = \(.*\);/d_set_d_op(\1, \2);/' -e 's/\([^\t ]*\)\.d_op = \(.*\);/d_set_d_op(\&\1, \2);/' -i
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 5d04a7828e7a..e0f0d7ea10a1 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -990,7 +990,7 @@ int reiserfs_lookup_privroot(struct super_block *s)
 				strlen(PRIVROOT_NAME));
 	if (!IS_ERR(dentry)) {
 		REISERFS_SB(s)->priv_root = dentry;
-		dentry->d_op = &xattr_lookup_poison_ops;
+		d_set_d_op(dentry, &xattr_lookup_poison_ops);
 		if (dentry->d_inode)
 			dentry->d_inode->i_flags |= S_PRIVATE;
 	} else

commit 1d3382cbf02986e4833849f528d451367ea0b4cb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Oct 23 15:19:20 2010 -0400

    new helper: inode_unhashed()
    
    note: for race-free uses you inode_lock held
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index f7415de13878..5d04a7828e7a 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -422,7 +422,7 @@ int reiserfs_commit_write(struct file *f, struct page *page,
 static void update_ctime(struct inode *inode)
 {
 	struct timespec now = current_fs_time(inode->i_sb);
-	if (hlist_unhashed(&inode->i_hash) || !inode->i_nlink ||
+	if (inode_unhashed(inode) || !inode->i_nlink ||
 	    timespec_equal(&inode->i_ctime, &now))
 		return;
 

commit ebdec241d509cf69f6ebf1ecdc036359d3dbe154
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Oct 6 10:47:23 2010 +0200

    fs: kill block_prepare_write
    
    __block_write_begin and block_prepare_write are identical except for slightly
    different calling conventions.  Convert all callers to the __block_write_begin
    calling conventions and drop block_prepare_write.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 8c4cf273c672..f7415de13878 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -418,8 +418,6 @@ static inline __u32 xattr_hash(const char *msg, int len)
 
 int reiserfs_commit_write(struct file *f, struct page *page,
 			  unsigned from, unsigned to);
-int reiserfs_prepare_write(struct file *f, struct page *page,
-			   unsigned from, unsigned to);
 
 static void update_ctime(struct inode *inode)
 {
@@ -532,8 +530,7 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 			rxh->h_hash = cpu_to_le32(xahash);
 		}
 
-		err = reiserfs_prepare_write(NULL, page, page_offset,
-					    page_offset + chunk + skip);
+		err = __reiserfs_write_begin(page, page_offset, chunk + skip);
 		if (!err) {
 			if (buffer)
 				memcpy(data + skip, buffer + buffer_pos, chunk);

commit 94d09a98cdb163be12fb5c76841fa295f0bee22a
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Thu May 13 17:53:19 2010 -0700

    reiserfs: constify xattr_handler
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index e7cc00e636dc..8c4cf273c672 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -723,11 +723,11 @@ reiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,
 			(handler) = *(handlers)++)
 
 /* This is the implementation for the xattr plugin infrastructure */
-static inline struct xattr_handler *
-find_xattr_handler_prefix(struct xattr_handler **handlers,
+static inline const struct xattr_handler *
+find_xattr_handler_prefix(const struct xattr_handler **handlers,
 			   const char *name)
 {
-	struct xattr_handler *xah;
+	const struct xattr_handler *xah;
 
 	if (!handlers)
 		return NULL;
@@ -748,7 +748,7 @@ ssize_t
 reiserfs_getxattr(struct dentry * dentry, const char *name, void *buffer,
 		  size_t size)
 {
-	struct xattr_handler *handler;
+	const struct xattr_handler *handler;
 
 	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
 
@@ -767,7 +767,7 @@ int
 reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 		  size_t size, int flags)
 {
-	struct xattr_handler *handler;
+	const struct xattr_handler *handler;
 
 	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
 
@@ -784,7 +784,7 @@ reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
  */
 int reiserfs_removexattr(struct dentry *dentry, const char *name)
 {
-	struct xattr_handler *handler;
+	const struct xattr_handler *handler;
 	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
 
 	if (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
@@ -807,7 +807,7 @@ static int listxattr_filler(void *buf, const char *name, int namelen,
 	size_t size;
 	if (name[0] != '.' ||
 	    (namelen != 1 && (name[1] != '.' || namelen != 2))) {
-		struct xattr_handler *handler;
+		const struct xattr_handler *handler;
 		handler = find_xattr_handler_prefix(b->dentry->d_sb->s_xattr,
 						    name);
 		if (!handler)	/* Unsupported xattr name */
@@ -920,7 +920,7 @@ static int create_privroot(struct dentry *dentry) { return 0; }
 #endif
 
 /* Actual operations that are exported to VFS-land */
-struct xattr_handler *reiserfs_xattr_handlers[] = {
+const struct xattr_handler *reiserfs_xattr_handlers[] = {
 #ifdef CONFIG_REISERFS_FS_XATTR
 	&reiserfs_xattr_user_handler,
 	&reiserfs_xattr_trusted_handler,

commit fb2162df74bb19552db3d988fd11c787cf5fad56
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Apr 23 13:17:41 2010 -0400

    reiserfs: fix corruption during shrinking of xattrs
    
    Commit 48b32a3553a54740d236b79a90f20147a25875e3 ("reiserfs: use generic
    xattr handlers") introduced a problem that causes corruption when extended
    attributes are replaced with a smaller value.
    
    The issue is that the reiserfs_setattr to shrink the xattr file was moved
    from before the write to after the write.
    
    The root issue has always been in the reiserfs xattr code, but was papered
    over by the fact that in the shrink case, the file would just be expanded
    again while the xattr was written.
    
    The end result is that the last 8 bytes of xattr data are lost.
    
    This patch fixes it to use new_size.
    
    Addresses https://bugzilla.kernel.org/show_bug.cgi?id=14826
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reported-by: Christian Kujau <lists@nerdbynature.de>
    Tested-by: Christian Kujau <lists@nerdbynature.de>
    Cc: Edward Shishkin <edward.shishkin@gmail.com>
    Cc: Jethro Beekman <kernel@jbeekman.nl>
    Cc: Greg Surbey <gregsurbey@hotmail.com>
    Cc: Marco Gatti <marco.gatti@gmail.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 28f0a448f3c7..e7cc00e636dc 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -554,7 +554,7 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 	if (!err && new_size < i_size_read(dentry->d_inode)) {
 		struct iattr newattrs = {
 			.ia_ctime = current_fs_time(inode->i_sb),
-			.ia_size = buffer_size,
+			.ia_size = new_size,
 			.ia_valid = ATTR_SIZE | ATTR_CTIME,
 		};
 

commit cac36f707119b792b2396aed371d6b5cdc194890
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Apr 23 13:17:37 2010 -0400

    reiserfs: fix permissions on .reiserfs_priv
    
    Commit 677c9b2e393a0cd203bd54e9c18b012b2c73305a ("reiserfs: remove
    privroot hiding in lookup") removed the magic from the lookup code to hide
    the .reiserfs_priv directory since it was getting loaded at mount-time
    instead.  The intent was that the entry would be hidden from the user via
    a poisoned d_compare, but this was faulty.
    
    This introduced a security issue where unprivileged users could access and
    modify extended attributes or ACLs belonging to other users, including
    root.
    
    This patch resolves the issue by properly hiding .reiserfs_priv.  This was
    the intent of the xattr poisoning code, but it appears to have never
    worked as expected.  This is fixed by using d_revalidate instead of
    d_compare.
    
    This patch makes -oexpose_privroot a no-op.  I'm fine leaving it this way.
    The effort involved in working out the corner cases wrt permissions and
    caching outweigh the benefit of the feature.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Acked-by: Edward Shishkin <edward.shishkin@gmail.com>
    Reported-by: Matt McCutchen <matt@mattmccutchen.net>
    Tested-by: Matt McCutchen <matt@mattmccutchen.net>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 4f9586bb7631..28f0a448f3c7 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -973,21 +973,13 @@ int reiserfs_permission(struct inode *inode, int mask)
 	return generic_permission(inode, mask, NULL);
 }
 
-/* This will catch lookups from the fs root to .reiserfs_priv */
-static int
-xattr_lookup_poison(struct dentry *dentry, struct qstr *q1, struct qstr *name)
+static int xattr_hide_revalidate(struct dentry *dentry, struct nameidata *nd)
 {
-	struct dentry *priv_root = REISERFS_SB(dentry->d_sb)->priv_root;
-	if (container_of(q1, struct dentry, d_name) == priv_root)
-		return -ENOENT;
-	if (q1->len == name->len &&
-		   !memcmp(q1->name, name->name, name->len))
-		return 0;
-	return 1;
+	return -EPERM;
 }
 
 static const struct dentry_operations xattr_lookup_poison_ops = {
-	.d_compare = xattr_lookup_poison,
+	.d_revalidate = xattr_hide_revalidate,
 };
 
 int reiserfs_lookup_privroot(struct super_block *s)
@@ -1001,8 +993,7 @@ int reiserfs_lookup_privroot(struct super_block *s)
 				strlen(PRIVROOT_NAME));
 	if (!IS_ERR(dentry)) {
 		REISERFS_SB(s)->priv_root = dentry;
-		if (!reiserfs_expose_privroot(s))
-			s->s_root->d_op = &xattr_lookup_poison_ops;
+		dentry->d_op = &xattr_lookup_poison_ops;
 		if (dentry->d_inode)
 			dentry->d_inode->i_flags |= S_PRIVATE;
 	} else

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 37d034ca7d99..4f9586bb7631 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -38,6 +38,7 @@
 #include <linux/dcache.h>
 #include <linux/namei.h>
 #include <linux/errno.h>
+#include <linux/gfp.h>
 #include <linux/fs.h>
 #include <linux/file.h>
 #include <linux/pagemap.h>

commit 907f4554e2521cb28b0009d17167760650a9561c
Author: Christoph Hellwig <hch@infradead.org>
Date:   Wed Mar 3 09:05:06 2010 -0500

    dquot: move dquot initialization responsibility into the filesystem
    
    Currently various places in the VFS call vfs_dq_init directly.  This means
    we tie the quota code into the VFS.  Get rid of that and make the
    filesystem responsible for the initialization.   For most metadata operations
    this is a straight forward move into the methods, but for truncate and
    open it's a bit more complicated.
    
    For truncate we currently only call vfs_dq_init for the sys_truncate case
    because open already takes care of it for ftruncate and open(O_TRUNC) - the
    new code causes an additional vfs_dq_init for those which is harmless.
    
    For open the initialization is moved from do_filp_open into the open method,
    which means it happens slightly earlier now, and only for regular files.
    The latter is fine because we don't need to initialize it for operations
    on special files, and we already do it as part of the namespace operations
    for directories.
    
    Add a dquot_file_open helper that filesystems that support generic quotas
    can use to fill in ->open.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 81f09fab8ae4..37d034ca7d99 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -61,7 +61,6 @@
 static int xattr_create(struct inode *dir, struct dentry *dentry, int mode)
 {
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
-	vfs_dq_init(dir);
 	return dir->i_op->create(dir, dentry, mode, NULL);
 }
 #endif
@@ -69,7 +68,6 @@ static int xattr_create(struct inode *dir, struct dentry *dentry, int mode)
 static int xattr_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
-	vfs_dq_init(dir);
 	return dir->i_op->mkdir(dir, dentry, mode);
 }
 
@@ -81,7 +79,6 @@ static int xattr_unlink(struct inode *dir, struct dentry *dentry)
 {
 	int error;
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
-	vfs_dq_init(dir);
 
 	reiserfs_mutex_lock_nested_safe(&dentry->d_inode->i_mutex,
 					I_MUTEX_CHILD, dir->i_sb);
@@ -97,7 +94,6 @@ static int xattr_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int error;
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
-	vfs_dq_init(dir);
 
 	reiserfs_mutex_lock_nested_safe(&dentry->d_inode->i_mutex,
 					I_MUTEX_CHILD, dir->i_sb);

commit 82062e7b50280bcf0feca70ac35a44f375602976
Merge: dbd6a7cfead4 31370f62baa1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 8 14:03:55 2010 -0800

    Merge branch 'reiserfs/kill-bkl' of git://git.kernel.org/pub/scm/linux/kernel/git/frederic/random-tracing
    
    * 'reiserfs/kill-bkl' of git://git.kernel.org/pub/scm/linux/kernel/git/frederic/random-tracing:
      reiserfs: Relax reiserfs_xattr_set_handle() while acquiring xattr locks
      reiserfs: Fix unreachable statement
      reiserfs: Don't call reiserfs_get_acl() with the reiserfs lock
      reiserfs: Relax lock on xattr removing
      reiserfs: Relax the lock before truncating pages
      reiserfs: Fix recursive lock on lchown
      reiserfs: Fix mistake in down_write() conversion

commit 31370f62baa1460b785cee9944bdcaf63d19e567
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Thu Jan 7 15:55:31 2010 +0100

    reiserfs: Relax reiserfs_xattr_set_handle() while acquiring xattr locks
    
    Fix remaining xattr locks acquired in reiserfs_xattr_set_handle()
    while we are holding the reiserfs lock to avoid lock inversions.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Christian Kujau <lists@nerdbynature.de>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 4899d789ba67..7fee995c25ab 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -559,8 +559,12 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 			.ia_size = buffer_size,
 			.ia_valid = ATTR_SIZE | ATTR_CTIME,
 		};
+
+		reiserfs_write_unlock(inode->i_sb);
 		mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);
 		down_write(&dentry->d_inode->i_alloc_sem);
+		reiserfs_write_lock(inode->i_sb);
+
 		err = reiserfs_setattr(dentry, &newattrs);
 		up_write(&dentry->d_inode->i_alloc_sem);
 		mutex_unlock(&dentry->d_inode->i_mutex);

commit 4f3be1b5a98587b86cae05aa5d129dd0b3fff466
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Tue Jan 5 02:14:30 2010 +0100

    reiserfs: Relax lock on xattr removing
    
    When we remove an xattr, we call lookup_and_delete_xattr()
    that takes some private xattr inodes mutexes. But we hold
    the reiserfs lock at this time, which leads to dependency
    inversions.
    
    We can safely call lookup_and_delete_xattr() without the
    reiserfs lock, where xattr inodes lookups only need the
    xattr inodes mutexes.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Christian Kujau <lists@nerdbynature.de>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 75d3706734ec..4899d789ba67 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -451,7 +451,9 @@ static int lookup_and_delete_xattr(struct inode *inode, const char *name)
 	}
 
 	if (dentry->d_inode) {
+		reiserfs_write_lock(inode->i_sb);
 		err = xattr_unlink(xadir->d_inode, dentry);
+		reiserfs_write_unlock(inode->i_sb);
 		update_ctime(inode);
 	}
 
@@ -485,10 +487,14 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 	if (get_inode_sd_version(inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	if (!buffer)
-		return lookup_and_delete_xattr(inode, name);
-
 	reiserfs_write_unlock(inode->i_sb);
+
+	if (!buffer) {
+		err = lookup_and_delete_xattr(inode, name);
+		reiserfs_write_lock(inode->i_sb);
+		return err;
+	}
+
 	dentry = xattr_lookup(inode, name, flags);
 	if (IS_ERR(dentry)) {
 		reiserfs_write_lock(inode->i_sb);

commit f3e22f48f37c1e14441c9f72ca8e63b1d4516745
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Sun Jan 3 03:44:53 2010 +0100

    reiserfs: Fix mistake in down_write() conversion
    
    Fix a mistake in commit 0719d3434747889b314a1e8add776418c4148bcf
    (reiserfs: Fix reiserfs lock <-> i_xattr_sem dependency inversion)
    that has converted a down_write() into a down_read() accidentally.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Christian Kujau <lists@nerdbynature.de>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 9623cfe2371c..75d3706734ec 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -495,7 +495,7 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 		return PTR_ERR(dentry);
 	}
 
-	down_read(&REISERFS_I(inode)->i_xattr_sem);
+	down_write(&REISERFS_I(inode)->i_xattr_sem);
 
 	reiserfs_write_lock(inode->i_sb);
 

commit 45d28b097280a78893ce25a5d0db41e6a2717853
Merge: 4207a152bc24 835d5247d98f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 2 11:17:05 2010 -0800

    Merge branch 'reiserfs/kill-bkl' of git://git.kernel.org/pub/scm/linux/kernel/git/frederic/random-tracing
    
    * 'reiserfs/kill-bkl' of git://git.kernel.org/pub/scm/linux/kernel/git/frederic/random-tracing:
      reiserfs: Safely acquire i_mutex from xattr_rmdir
      reiserfs: Safely acquire i_mutex from reiserfs_for_each_xattr
      reiserfs: Fix journal mutex <-> inode mutex lock inversion
      reiserfs: Fix unwanted recursive reiserfs lock in reiserfs_unlink()
      reiserfs: Relax lock before open xattr dir in reiserfs_xattr_set_handle()
      reiserfs: Relax reiserfs lock while freeing the journal
      reiserfs: Fix reiserfs lock <-> i_mutex dependency inversion on xattr
      reiserfs: Warn on lock relax if taken recursively
      reiserfs: Fix reiserfs lock <-> i_xattr_sem dependency inversion
      reiserfs: Fix remaining in-reclaim-fs <-> reclaim-fs-on locking inversion
      reiserfs: Fix reiserfs lock <-> inode mutex dependency inversion
      reiserfs: Fix reiserfs lock and journal lock inversion dependency
      reiserfs: Fix possible recursive lock

commit 835d5247d98f46e35d007dcfa6215e526ca33360
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Dec 30 07:40:39 2009 +0100

    reiserfs: Safely acquire i_mutex from xattr_rmdir
    
    Relax the reiserfs lock before taking the inode mutex from
    xattr_rmdir() to avoid the usual reiserfs lock <-> inode mutex
    bad dependency.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Tested-by: Christian Kujau <lists@nerdbynature.de>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index bfdac66fd8e2..9623cfe2371c 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -98,7 +98,8 @@ static int xattr_rmdir(struct inode *dir, struct dentry *dentry)
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
 	vfs_dq_init(dir);
 
-	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);
+	reiserfs_mutex_lock_nested_safe(&dentry->d_inode->i_mutex,
+					I_MUTEX_CHILD, dir->i_sb);
 	dentry_unhash(dentry);
 	error = dir->i_op->rmdir(dir, dentry);
 	if (!error)

commit 8b513f56d4e117f11cf0760abcc030eedefc45c3
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Dec 30 07:28:58 2009 +0100

    reiserfs: Safely acquire i_mutex from reiserfs_for_each_xattr
    
    Relax the reiserfs lock before taking the inode mutex from
    reiserfs_for_each_xattr() to avoid the usual bad dependencies:
    
    =======================================================
    [ INFO: possible circular locking dependency detected ]
    2.6.32-atom #179
    -------------------------------------------------------
    rm/3242 is trying to acquire lock:
     (&sb->s_type->i_mutex_key#4/3){+.+.+.}, at: [<c11428ef>] reiserfs_for_each_xattr+0x23f/0x290
    
    but task is already holding lock:
     (&REISERFS_SB(s)->lock){+.+.+.}, at: [<c1143389>] reiserfs_write_lock+0x29/0x40
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #1 (&REISERFS_SB(s)->lock){+.+.+.}:
           [<c105ea7f>] __lock_acquire+0x11ff/0x19e0
           [<c105f2c8>] lock_acquire+0x68/0x90
           [<c1401aab>] mutex_lock_nested+0x5b/0x340
           [<c1143339>] reiserfs_write_lock_once+0x29/0x50
           [<c1117022>] reiserfs_lookup+0x62/0x140
           [<c10bd85f>] __lookup_hash+0xef/0x110
           [<c10bf21d>] lookup_one_len+0x8d/0xc0
           [<c1141e3a>] open_xa_dir+0xea/0x1b0
           [<c1142720>] reiserfs_for_each_xattr+0x70/0x290
           [<c11429ba>] reiserfs_delete_xattrs+0x1a/0x60
           [<c111ea2f>] reiserfs_delete_inode+0x9f/0x150
           [<c10c9c32>] generic_delete_inode+0xa2/0x170
           [<c10c9d4f>] generic_drop_inode+0x4f/0x70
           [<c10c8b07>] iput+0x47/0x50
           [<c10c0965>] do_unlinkat+0xd5/0x160
           [<c10c0b13>] sys_unlinkat+0x23/0x40
           [<c1002ec4>] sysenter_do_call+0x12/0x32
    
    -> #0 (&sb->s_type->i_mutex_key#4/3){+.+.+.}:
           [<c105f176>] __lock_acquire+0x18f6/0x19e0
           [<c105f2c8>] lock_acquire+0x68/0x90
           [<c1401aab>] mutex_lock_nested+0x5b/0x340
           [<c11428ef>] reiserfs_for_each_xattr+0x23f/0x290
           [<c11429ba>] reiserfs_delete_xattrs+0x1a/0x60
           [<c111ea2f>] reiserfs_delete_inode+0x9f/0x150
           [<c10c9c32>] generic_delete_inode+0xa2/0x170
           [<c10c9d4f>] generic_drop_inode+0x4f/0x70
           [<c10c8b07>] iput+0x47/0x50
           [<c10c0965>] do_unlinkat+0xd5/0x160
           [<c10c0b13>] sys_unlinkat+0x23/0x40
           [<c1002ec4>] sysenter_do_call+0x12/0x32
    
    other info that might help us debug this:
    
    1 lock held by rm/3242:
     #0:  (&REISERFS_SB(s)->lock){+.+.+.}, at: [<c1143389>] reiserfs_write_lock+0x29/0x40
    
    stack backtrace:
    Pid: 3242, comm: rm Not tainted 2.6.32-atom #179
    Call Trace:
     [<c13ffa13>] ? printk+0x18/0x1a
     [<c105d33a>] print_circular_bug+0xca/0xd0
     [<c105f176>] __lock_acquire+0x18f6/0x19e0
     [<c105c932>] ? mark_held_locks+0x62/0x80
     [<c105cc3b>] ? trace_hardirqs_on+0xb/0x10
     [<c1401098>] ? mutex_unlock+0x8/0x10
     [<c105f2c8>] lock_acquire+0x68/0x90
     [<c11428ef>] ? reiserfs_for_each_xattr+0x23f/0x290
     [<c11428ef>] ? reiserfs_for_each_xattr+0x23f/0x290
     [<c1401aab>] mutex_lock_nested+0x5b/0x340
     [<c11428ef>] ? reiserfs_for_each_xattr+0x23f/0x290
     [<c11428ef>] reiserfs_for_each_xattr+0x23f/0x290
     [<c1143180>] ? delete_one_xattr+0x0/0x100
     [<c11429ba>] reiserfs_delete_xattrs+0x1a/0x60
     [<c1143339>] ? reiserfs_write_lock_once+0x29/0x50
     [<c111ea2f>] reiserfs_delete_inode+0x9f/0x150
     [<c11b0d4f>] ? _atomic_dec_and_lock+0x4f/0x70
     [<c111e990>] ? reiserfs_delete_inode+0x0/0x150
     [<c10c9c32>] generic_delete_inode+0xa2/0x170
     [<c10c9d4f>] generic_drop_inode+0x4f/0x70
     [<c10c8b07>] iput+0x47/0x50
     [<c10c0965>] do_unlinkat+0xd5/0x160
     [<c1401098>] ? mutex_unlock+0x8/0x10
     [<c10c3e0d>] ? vfs_readdir+0x7d/0xb0
     [<c10c3af0>] ? filldir64+0x0/0xf0
     [<c1002ef3>] ? sysenter_exit+0xf/0x16
     [<c105cbe4>] ? trace_hardirqs_on_caller+0x124/0x170
     [<c10c0b13>] sys_unlinkat+0x23/0x40
     [<c1002ec4>] sysenter_do_call+0x12/0x32
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Tested-by: Christian Kujau <lists@nerdbynature.de>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 8b9631d30ffc..bfdac66fd8e2 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -289,8 +289,9 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 		err = journal_begin(&th, inode->i_sb, blocks);
 		if (!err) {
 			int jerror;
-			mutex_lock_nested(&dir->d_parent->d_inode->i_mutex,
-					  I_MUTEX_XATTR);
+			reiserfs_mutex_lock_nested_safe(
+					  &dir->d_parent->d_inode->i_mutex,
+					  I_MUTEX_XATTR, inode->i_sb);
 			err = action(dir, data);
 			jerror = journal_end(&th, inode->i_sb, blocks);
 			mutex_unlock(&dir->d_parent->d_inode->i_mutex);

commit 4dd859697f836cf62c8de08bd9a9f4b4f4beaa91
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Dec 30 07:26:28 2009 +0100

    reiserfs: Fix journal mutex <-> inode mutex lock inversion
    
    We need to relax the reiserfs lock before locking the inode mutex
    from xattr_unlink(), otherwise we'll face the usual bad dependencies:
    
    =======================================================
    [ INFO: possible circular locking dependency detected ]
    2.6.32-atom #178
    -------------------------------------------------------
    rm/3202 is trying to acquire lock:
     (&journal->j_mutex){+.+...}, at: [<c113c234>] do_journal_begin_r+0x94/0x360
    
    but task is already holding lock:
     (&sb->s_type->i_mutex_key#4/2){+.+...}, at: [<c1142a67>] xattr_unlink+0x57/0xb0
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #2 (&sb->s_type->i_mutex_key#4/2){+.+...}:
           [<c105ea7f>] __lock_acquire+0x11ff/0x19e0
           [<c105f2c8>] lock_acquire+0x68/0x90
           [<c1401a7b>] mutex_lock_nested+0x5b/0x340
           [<c1142a67>] xattr_unlink+0x57/0xb0
           [<c1143179>] delete_one_xattr+0x29/0x100
           [<c11427bb>] reiserfs_for_each_xattr+0x10b/0x290
           [<c11429ba>] reiserfs_delete_xattrs+0x1a/0x60
           [<c111ea2f>] reiserfs_delete_inode+0x9f/0x150
           [<c10c9c32>] generic_delete_inode+0xa2/0x170
           [<c10c9d4f>] generic_drop_inode+0x4f/0x70
           [<c10c8b07>] iput+0x47/0x50
           [<c10c0965>] do_unlinkat+0xd5/0x160
           [<c10c0b13>] sys_unlinkat+0x23/0x40
           [<c1002ec4>] sysenter_do_call+0x12/0x32
    
    -> #1 (&REISERFS_SB(s)->lock){+.+.+.}:
           [<c105ea7f>] __lock_acquire+0x11ff/0x19e0
           [<c105f2c8>] lock_acquire+0x68/0x90
           [<c1401a7b>] mutex_lock_nested+0x5b/0x340
           [<c1143359>] reiserfs_write_lock+0x29/0x40
           [<c113c23c>] do_journal_begin_r+0x9c/0x360
           [<c113c680>] journal_begin+0x80/0x130
           [<c1127363>] reiserfs_remount+0x223/0x4e0
           [<c10b6dd6>] do_remount_sb+0xa6/0x140
           [<c10ce6a0>] do_mount+0x560/0x750
           [<c10ce914>] sys_mount+0x84/0xb0
           [<c1002ec4>] sysenter_do_call+0x12/0x32
    
    -> #0 (&journal->j_mutex){+.+...}:
           [<c105f176>] __lock_acquire+0x18f6/0x19e0
           [<c105f2c8>] lock_acquire+0x68/0x90
           [<c1401a7b>] mutex_lock_nested+0x5b/0x340
           [<c113c234>] do_journal_begin_r+0x94/0x360
           [<c113c680>] journal_begin+0x80/0x130
           [<c1116d63>] reiserfs_unlink+0x83/0x2e0
           [<c1142a74>] xattr_unlink+0x64/0xb0
           [<c1143179>] delete_one_xattr+0x29/0x100
           [<c11427bb>] reiserfs_for_each_xattr+0x10b/0x290
           [<c11429ba>] reiserfs_delete_xattrs+0x1a/0x60
           [<c111ea2f>] reiserfs_delete_inode+0x9f/0x150
           [<c10c9c32>] generic_delete_inode+0xa2/0x170
           [<c10c9d4f>] generic_drop_inode+0x4f/0x70
           [<c10c8b07>] iput+0x47/0x50
           [<c10c0965>] do_unlinkat+0xd5/0x160
           [<c10c0b13>] sys_unlinkat+0x23/0x40
           [<c1002ec4>] sysenter_do_call+0x12/0x32
    
    other info that might help us debug this:
    
    2 locks held by rm/3202:
     #0:  (&sb->s_type->i_mutex_key#4/3){+.+.+.}, at: [<c114274b>] reiserfs_for_each_xattr+0x9b/0x290
     #1:  (&sb->s_type->i_mutex_key#4/2){+.+...}, at: [<c1142a67>] xattr_unlink+0x57/0xb0
    
    stack backtrace:
    Pid: 3202, comm: rm Not tainted 2.6.32-atom #178
    Call Trace:
     [<c13ff9e3>] ? printk+0x18/0x1a
     [<c105d33a>] print_circular_bug+0xca/0xd0
     [<c105f176>] __lock_acquire+0x18f6/0x19e0
     [<c1142a67>] ? xattr_unlink+0x57/0xb0
     [<c105f2c8>] lock_acquire+0x68/0x90
     [<c113c234>] ? do_journal_begin_r+0x94/0x360
     [<c113c234>] ? do_journal_begin_r+0x94/0x360
     [<c1401a7b>] mutex_lock_nested+0x5b/0x340
     [<c113c234>] ? do_journal_begin_r+0x94/0x360
     [<c113c234>] do_journal_begin_r+0x94/0x360
     [<c10411b6>] ? run_timer_softirq+0x1a6/0x220
     [<c103cb00>] ? __do_softirq+0x50/0x140
     [<c113c680>] journal_begin+0x80/0x130
     [<c103cba2>] ? __do_softirq+0xf2/0x140
     [<c104f72f>] ? hrtimer_interrupt+0xdf/0x220
     [<c1116d63>] reiserfs_unlink+0x83/0x2e0
     [<c105c932>] ? mark_held_locks+0x62/0x80
     [<c11b8d08>] ? trace_hardirqs_on_thunk+0xc/0x10
     [<c1002fd8>] ? restore_all_notrace+0x0/0x18
     [<c1142a67>] ? xattr_unlink+0x57/0xb0
     [<c1142a74>] xattr_unlink+0x64/0xb0
     [<c1143179>] delete_one_xattr+0x29/0x100
     [<c11427bb>] reiserfs_for_each_xattr+0x10b/0x290
     [<c1143150>] ? delete_one_xattr+0x0/0x100
     [<c1401cb9>] ? mutex_lock_nested+0x299/0x340
     [<c11429ba>] reiserfs_delete_xattrs+0x1a/0x60
     [<c1143309>] ? reiserfs_write_lock_once+0x29/0x50
     [<c111ea2f>] reiserfs_delete_inode+0x9f/0x150
     [<c11b0d1f>] ? _atomic_dec_and_lock+0x4f/0x70
     [<c111e990>] ? reiserfs_delete_inode+0x0/0x150
     [<c10c9c32>] generic_delete_inode+0xa2/0x170
     [<c10c9d4f>] generic_drop_inode+0x4f/0x70
     [<c10c8b07>] iput+0x47/0x50
     [<c10c0965>] do_unlinkat+0xd5/0x160
     [<c1401068>] ? mutex_unlock+0x8/0x10
     [<c10c3e0d>] ? vfs_readdir+0x7d/0xb0
     [<c10c3af0>] ? filldir64+0x0/0xf0
     [<c1002ef3>] ? sysenter_exit+0xf/0x16
     [<c105cbe4>] ? trace_hardirqs_on_caller+0x124/0x170
     [<c10c0b13>] sys_unlinkat+0x23/0x40
     [<c1002ec4>] sysenter_do_call+0x12/0x32
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Tested-by: Christian Kujau <lists@nerdbynature.de>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 78a3f246295c..8b9631d30ffc 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -82,7 +82,8 @@ static int xattr_unlink(struct inode *dir, struct dentry *dentry)
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
 	vfs_dq_init(dir);
 
-	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);
+	reiserfs_mutex_lock_nested_safe(&dentry->d_inode->i_mutex,
+					I_MUTEX_CHILD, dir->i_sb);
 	error = dir->i_op->unlink(dir, dentry);
 	mutex_unlock(&dentry->d_inode->i_mutex);
 

commit 3f14fea6bbd3444dd46a2af3a2e219e792616645
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Dec 30 07:03:53 2009 +0100

    reiserfs: Relax lock before open xattr dir in reiserfs_xattr_set_handle()
    
    We call xattr_lookup() from reiserfs_xattr_get(). We then hold
    the reiserfs lock when we grab the i_mutex. But later, we may
    relax the reiserfs lock, creating dependency inversion between
    both locks.
    
    The lookups and creation jobs ar already protected by the
    inode mutex, so we can safely relax the reiserfs lock, dropping
    the unwanted reiserfs lock -> i_mutex dependency, as shown
    in the following lockdep report:
    
    =======================================================
    [ INFO: possible circular locking dependency detected ]
    2.6.32-atom #173
    -------------------------------------------------------
    cp/3204 is trying to acquire lock:
     (&REISERFS_SB(s)->lock){+.+.+.}, at: [<c11432b9>] reiserfs_write_lock_once+0x29/0x50
    
    but task is already holding lock:
     (&sb->s_type->i_mutex_key#4/3){+.+.+.}, at: [<c1141e18>] open_xa_dir+0xd8/0x1b0
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #1 (&sb->s_type->i_mutex_key#4/3){+.+.+.}:
           [<c105ea7f>] __lock_acquire+0x11ff/0x19e0
           [<c105f2c8>] lock_acquire+0x68/0x90
           [<c1401a2b>] mutex_lock_nested+0x5b/0x340
           [<c1141d83>] open_xa_dir+0x43/0x1b0
           [<c1142722>] reiserfs_for_each_xattr+0x62/0x260
           [<c114299a>] reiserfs_delete_xattrs+0x1a/0x60
           [<c111ea1f>] reiserfs_delete_inode+0x9f/0x150
           [<c10c9c32>] generic_delete_inode+0xa2/0x170
           [<c10c9d4f>] generic_drop_inode+0x4f/0x70
           [<c10c8b07>] iput+0x47/0x50
           [<c10c0965>] do_unlinkat+0xd5/0x160
           [<c10c0a00>] sys_unlink+0x10/0x20
           [<c1002ec4>] sysenter_do_call+0x12/0x32
    
    -> #0 (&REISERFS_SB(s)->lock){+.+.+.}:
           [<c105f176>] __lock_acquire+0x18f6/0x19e0
           [<c105f2c8>] lock_acquire+0x68/0x90
           [<c1401a2b>] mutex_lock_nested+0x5b/0x340
           [<c11432b9>] reiserfs_write_lock_once+0x29/0x50
           [<c1117012>] reiserfs_lookup+0x62/0x140
           [<c10bd85f>] __lookup_hash+0xef/0x110
           [<c10bf21d>] lookup_one_len+0x8d/0xc0
           [<c1141e2a>] open_xa_dir+0xea/0x1b0
           [<c1141fe5>] xattr_lookup+0x15/0x160
           [<c1142476>] reiserfs_xattr_get+0x56/0x2a0
           [<c1144042>] reiserfs_get_acl+0xa2/0x360
           [<c114461a>] reiserfs_cache_default_acl+0x3a/0x160
           [<c111789c>] reiserfs_mkdir+0x6c/0x2c0
           [<c10bea96>] vfs_mkdir+0xd6/0x180
           [<c10c0c10>] sys_mkdirat+0xc0/0xd0
           [<c10c0c40>] sys_mkdir+0x20/0x30
           [<c1002ec4>] sysenter_do_call+0x12/0x32
    
    other info that might help us debug this:
    
    2 locks held by cp/3204:
     #0:  (&sb->s_type->i_mutex_key#4/1){+.+.+.}, at: [<c10bd8d6>] lookup_create+0x26/0xa0
     #1:  (&sb->s_type->i_mutex_key#4/3){+.+.+.}, at: [<c1141e18>] open_xa_dir+0xd8/0x1b0
    
    stack backtrace:
    Pid: 3204, comm: cp Not tainted 2.6.32-atom #173
    Call Trace:
     [<c13ff993>] ? printk+0x18/0x1a
     [<c105d33a>] print_circular_bug+0xca/0xd0
     [<c105f176>] __lock_acquire+0x18f6/0x19e0
     [<c105d3aa>] ? check_usage+0x6a/0x460
     [<c105f2c8>] lock_acquire+0x68/0x90
     [<c11432b9>] ? reiserfs_write_lock_once+0x29/0x50
     [<c11432b9>] ? reiserfs_write_lock_once+0x29/0x50
     [<c1401a2b>] mutex_lock_nested+0x5b/0x340
     [<c11432b9>] ? reiserfs_write_lock_once+0x29/0x50
     [<c11432b9>] reiserfs_write_lock_once+0x29/0x50
     [<c1117012>] reiserfs_lookup+0x62/0x140
     [<c105ccca>] ? debug_check_no_locks_freed+0x8a/0x140
     [<c105cbe4>] ? trace_hardirqs_on_caller+0x124/0x170
     [<c10bd85f>] __lookup_hash+0xef/0x110
     [<c10bf21d>] lookup_one_len+0x8d/0xc0
     [<c1141e2a>] open_xa_dir+0xea/0x1b0
     [<c1141fe5>] xattr_lookup+0x15/0x160
     [<c1142476>] reiserfs_xattr_get+0x56/0x2a0
     [<c1144042>] reiserfs_get_acl+0xa2/0x360
     [<c10ca2e7>] ? new_inode+0x27/0xa0
     [<c114461a>] reiserfs_cache_default_acl+0x3a/0x160
     [<c1402eb7>] ? _spin_unlock+0x27/0x40
     [<c111789c>] reiserfs_mkdir+0x6c/0x2c0
     [<c10c7cb8>] ? __d_lookup+0x108/0x190
     [<c105c932>] ? mark_held_locks+0x62/0x80
     [<c1401c8d>] ? mutex_lock_nested+0x2bd/0x340
     [<c10bd17a>] ? generic_permission+0x1a/0xa0
     [<c11788fe>] ? security_inode_permission+0x1e/0x20
     [<c10bea96>] vfs_mkdir+0xd6/0x180
     [<c10c0c10>] sys_mkdirat+0xc0/0xd0
     [<c10505c6>] ? up_read+0x16/0x30
     [<c1002fd8>] ? restore_all_notrace+0x0/0x18
     [<c10c0c40>] sys_mkdir+0x20/0x30
     [<c1002ec4>] sysenter_do_call+0x12/0x32
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Tested-by: Christian Kujau <lists@nerdbynature.de>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index c320c7792c75..78a3f246295c 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -485,11 +485,16 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 	if (!buffer)
 		return lookup_and_delete_xattr(inode, name);
 
+	reiserfs_write_unlock(inode->i_sb);
 	dentry = xattr_lookup(inode, name, flags);
-	if (IS_ERR(dentry))
+	if (IS_ERR(dentry)) {
+		reiserfs_write_lock(inode->i_sb);
 		return PTR_ERR(dentry);
+	}
 
-	reiserfs_down_read_safe(&REISERFS_I(inode)->i_xattr_sem, inode->i_sb);
+	down_read(&REISERFS_I(inode)->i_xattr_sem);
+
+	reiserfs_write_lock(inode->i_sb);
 
 	xahash = xattr_hash(buffer, buffer_size);
 	while (buffer_pos < buffer_size || buffer_pos == 0) {

commit 27026a05bb805866a3b9068dda8153b72cb942f4
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Dec 30 05:06:21 2009 +0100

    reiserfs: Fix reiserfs lock <-> i_mutex dependency inversion on xattr
    
    While deleting the xattrs of an inode, we hold the reiserfs lock
    and grab the inode->i_mutex of the targeted inode and the root
    private xattr directory.
    
    Later on, we may relax the reiserfs lock for various reasons, this
    creates inverted dependencies.
    
    We can remove the reiserfs lock -> i_mutex dependency by relaxing
    the former before calling open_xa_dir(). This is fine because the
    lookup and creation of xattr private directories done in
    open_xa_dir() are covered by the targeted inode mutexes. And deeper
    operations in the tree are still done under the write lock.
    
    This fixes the following lockdep report:
    
    =======================================================
    [ INFO: possible circular locking dependency detected ]
    2.6.32-atom #173
    -------------------------------------------------------
    cp/3204 is trying to acquire lock:
     (&REISERFS_SB(s)->lock){+.+.+.}, at: [<c11432b9>] reiserfs_write_lock_once+0x29/0x50
    
    but task is already holding lock:
     (&sb->s_type->i_mutex_key#4/3){+.+.+.}, at: [<c1141e18>] open_xa_dir+0xd8/0x1b0
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #1 (&sb->s_type->i_mutex_key#4/3){+.+.+.}:
           [<c105ea7f>] __lock_acquire+0x11ff/0x19e0
           [<c105f2c8>] lock_acquire+0x68/0x90
           [<c1401a2b>] mutex_lock_nested+0x5b/0x340
           [<c1141d83>] open_xa_dir+0x43/0x1b0
           [<c1142722>] reiserfs_for_each_xattr+0x62/0x260
           [<c114299a>] reiserfs_delete_xattrs+0x1a/0x60
           [<c111ea1f>] reiserfs_delete_inode+0x9f/0x150
           [<c10c9c32>] generic_delete_inode+0xa2/0x170
           [<c10c9d4f>] generic_drop_inode+0x4f/0x70
           [<c10c8b07>] iput+0x47/0x50
           [<c10c0965>] do_unlinkat+0xd5/0x160
           [<c10c0a00>] sys_unlink+0x10/0x20
           [<c1002ec4>] sysenter_do_call+0x12/0x32
    
    -> #0 (&REISERFS_SB(s)->lock){+.+.+.}:
           [<c105f176>] __lock_acquire+0x18f6/0x19e0
           [<c105f2c8>] lock_acquire+0x68/0x90
           [<c1401a2b>] mutex_lock_nested+0x5b/0x340
           [<c11432b9>] reiserfs_write_lock_once+0x29/0x50
           [<c1117012>] reiserfs_lookup+0x62/0x140
           [<c10bd85f>] __lookup_hash+0xef/0x110
           [<c10bf21d>] lookup_one_len+0x8d/0xc0
           [<c1141e2a>] open_xa_dir+0xea/0x1b0
           [<c1141fe5>] xattr_lookup+0x15/0x160
           [<c1142476>] reiserfs_xattr_get+0x56/0x2a0
           [<c1144042>] reiserfs_get_acl+0xa2/0x360
           [<c114461a>] reiserfs_cache_default_acl+0x3a/0x160
           [<c111789c>] reiserfs_mkdir+0x6c/0x2c0
           [<c10bea96>] vfs_mkdir+0xd6/0x180
           [<c10c0c10>] sys_mkdirat+0xc0/0xd0
           [<c10c0c40>] sys_mkdir+0x20/0x30
           [<c1002ec4>] sysenter_do_call+0x12/0x32
    
    other info that might help us debug this:
    
    2 locks held by cp/3204:
     #0:  (&sb->s_type->i_mutex_key#4/1){+.+.+.}, at: [<c10bd8d6>] lookup_create+0x26/0xa0
     #1:  (&sb->s_type->i_mutex_key#4/3){+.+.+.}, at: [<c1141e18>] open_xa_dir+0xd8/0x1b0
    
    stack backtrace:
    Pid: 3204, comm: cp Not tainted 2.6.32-atom #173
    Call Trace:
     [<c13ff993>] ? printk+0x18/0x1a
     [<c105d33a>] print_circular_bug+0xca/0xd0
     [<c105f176>] __lock_acquire+0x18f6/0x19e0
     [<c105d3aa>] ? check_usage+0x6a/0x460
     [<c105f2c8>] lock_acquire+0x68/0x90
     [<c11432b9>] ? reiserfs_write_lock_once+0x29/0x50
     [<c11432b9>] ? reiserfs_write_lock_once+0x29/0x50
     [<c1401a2b>] mutex_lock_nested+0x5b/0x340
     [<c11432b9>] ? reiserfs_write_lock_once+0x29/0x50
     [<c11432b9>] reiserfs_write_lock_once+0x29/0x50
     [<c1117012>] reiserfs_lookup+0x62/0x140
     [<c105ccca>] ? debug_check_no_locks_freed+0x8a/0x140
     [<c105cbe4>] ? trace_hardirqs_on_caller+0x124/0x170
     [<c10bd85f>] __lookup_hash+0xef/0x110
     [<c10bf21d>] lookup_one_len+0x8d/0xc0
     [<c1141e2a>] open_xa_dir+0xea/0x1b0
     [<c1141fe5>] xattr_lookup+0x15/0x160
     [<c1142476>] reiserfs_xattr_get+0x56/0x2a0
     [<c1144042>] reiserfs_get_acl+0xa2/0x360
     [<c10ca2e7>] ? new_inode+0x27/0xa0
     [<c114461a>] reiserfs_cache_default_acl+0x3a/0x160
     [<c1402eb7>] ? _spin_unlock+0x27/0x40
     [<c111789c>] reiserfs_mkdir+0x6c/0x2c0
     [<c10c7cb8>] ? __d_lookup+0x108/0x190
     [<c105c932>] ? mark_held_locks+0x62/0x80
     [<c1401c8d>] ? mutex_lock_nested+0x2bd/0x340
     [<c10bd17a>] ? generic_permission+0x1a/0xa0
     [<c11788fe>] ? security_inode_permission+0x1e/0x20
     [<c10bea96>] vfs_mkdir+0xd6/0x180
     [<c10c0c10>] sys_mkdirat+0xc0/0xd0
     [<c10505c6>] ? up_read+0x16/0x30
     [<c1002fd8>] ? restore_all_notrace+0x0/0x18
     [<c10c0c40>] sys_mkdir+0x20/0x30
     [<c1002ec4>] sysenter_do_call+0x12/0x32
    
    v2: Don't drop reiserfs_mutex_lock_nested_safe() as we'll still
        need it later
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Tested-by: Christian Kujau <lists@nerdbynature.de>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index a0e2e7acdc75..c320c7792c75 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -234,17 +234,22 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 	if (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1)
 		return 0;
 
+	reiserfs_write_unlock(inode->i_sb);
 	dir = open_xa_dir(inode, XATTR_REPLACE);
 	if (IS_ERR(dir)) {
 		err = PTR_ERR(dir);
+		reiserfs_write_lock(inode->i_sb);
 		goto out;
 	} else if (!dir->d_inode) {
 		err = 0;
+		reiserfs_write_lock(inode->i_sb);
 		goto out_dir;
 	}
 
-	reiserfs_mutex_lock_nested_safe(&dir->d_inode->i_mutex, I_MUTEX_XATTR,
-					inode->i_sb);
+	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
+
+	reiserfs_write_lock(inode->i_sb);
+
 	buf.xadir = dir;
 	err = reiserfs_readdir_dentry(dir, &buf, fill_with_dentries, &pos);
 	while ((err == 0 || err == -ENOSPC) && buf.count) {

commit 0719d3434747889b314a1e8add776418c4148bcf
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Dec 30 00:39:22 2009 +0100

    reiserfs: Fix reiserfs lock <-> i_xattr_sem dependency inversion
    
    i_xattr_sem depends on the reiserfs lock. But after we grab
    i_xattr_sem, we may relax/relock the reiserfs lock while waiting
    on a freezed filesystem, creating a dependency inversion between
    the two locks.
    
    In order to avoid the i_xattr_sem -> reiserfs lock dependency, let's
    create a reiserfs_down_read_safe() that acts like
    reiserfs_mutex_lock_safe(): relax the reiserfs lock while grabbing
    another lock to avoid undesired dependencies induced by the
    heivyweight reiserfs lock.
    
    This fixes the following warning:
    
    [  990.005931] =======================================================
    [  990.012373] [ INFO: possible circular locking dependency detected ]
    [  990.013233] 2.6.33-rc1 #1
    [  990.013233] -------------------------------------------------------
    [  990.013233] dbench/1891 is trying to acquire lock:
    [  990.013233]  (&REISERFS_SB(s)->lock){+.+.+.}, at: [<ffffffff81159505>] reiserfs_write_lock+0x35/0x50
    [  990.013233]
    [  990.013233] but task is already holding lock:
    [  990.013233]  (&REISERFS_I(inode)->i_xattr_sem){+.+.+.}, at: [<ffffffff8115899a>] reiserfs_xattr_set_handle+0x8a/0x470
    [  990.013233]
    [  990.013233] which lock already depends on the new lock.
    [  990.013233]
    [  990.013233]
    [  990.013233] the existing dependency chain (in reverse order) is:
    [  990.013233]
    [  990.013233] -> #1 (&REISERFS_I(inode)->i_xattr_sem){+.+.+.}:
    [  990.013233]        [<ffffffff81063afc>] __lock_acquire+0xf9c/0x1560
    [  990.013233]        [<ffffffff8106414f>] lock_acquire+0x8f/0xb0
    [  990.013233]        [<ffffffff814ac194>] down_write+0x44/0x80
    [  990.013233]        [<ffffffff8115899a>] reiserfs_xattr_set_handle+0x8a/0x470
    [  990.013233]        [<ffffffff81158e30>] reiserfs_xattr_set+0xb0/0x150
    [  990.013233]        [<ffffffff8115a6aa>] user_set+0x8a/0x90
    [  990.013233]        [<ffffffff8115901a>] reiserfs_setxattr+0xaa/0xb0
    [  990.013233]        [<ffffffff810e2596>] __vfs_setxattr_noperm+0x36/0xa0
    [  990.013233]        [<ffffffff810e26bc>] vfs_setxattr+0xbc/0xc0
    [  990.013233]        [<ffffffff810e2780>] setxattr+0xc0/0x150
    [  990.013233]        [<ffffffff810e289d>] sys_fsetxattr+0x8d/0xa0
    [  990.013233]        [<ffffffff81002dab>] system_call_fastpath+0x16/0x1b
    [  990.013233]
    [  990.013233] -> #0 (&REISERFS_SB(s)->lock){+.+.+.}:
    [  990.013233]        [<ffffffff81063e30>] __lock_acquire+0x12d0/0x1560
    [  990.013233]        [<ffffffff8106414f>] lock_acquire+0x8f/0xb0
    [  990.013233]        [<ffffffff814aba77>] __mutex_lock_common+0x47/0x3b0
    [  990.013233]        [<ffffffff814abebe>] mutex_lock_nested+0x3e/0x50
    [  990.013233]        [<ffffffff81159505>] reiserfs_write_lock+0x35/0x50
    [  990.013233]        [<ffffffff811340e5>] reiserfs_prepare_write+0x45/0x180
    [  990.013233]        [<ffffffff81158bb6>] reiserfs_xattr_set_handle+0x2a6/0x470
    [  990.013233]        [<ffffffff81158e30>] reiserfs_xattr_set+0xb0/0x150
    [  990.013233]        [<ffffffff8115a6aa>] user_set+0x8a/0x90
    [  990.013233]        [<ffffffff8115901a>] reiserfs_setxattr+0xaa/0xb0
    [  990.013233]        [<ffffffff810e2596>] __vfs_setxattr_noperm+0x36/0xa0
    [  990.013233]        [<ffffffff810e26bc>] vfs_setxattr+0xbc/0xc0
    [  990.013233]        [<ffffffff810e2780>] setxattr+0xc0/0x150
    [  990.013233]        [<ffffffff810e289d>] sys_fsetxattr+0x8d/0xa0
    [  990.013233]        [<ffffffff81002dab>] system_call_fastpath+0x16/0x1b
    [  990.013233]
    [  990.013233] other info that might help us debug this:
    [  990.013233]
    [  990.013233] 2 locks held by dbench/1891:
    [  990.013233]  #0:  (&sb->s_type->i_mutex_key#12){+.+.+.}, at: [<ffffffff810e2678>] vfs_setxattr+0x78/0xc0
    [  990.013233]  #1:  (&REISERFS_I(inode)->i_xattr_sem){+.+.+.}, at: [<ffffffff8115899a>] reiserfs_xattr_set_handle+0x8a/0x470
    [  990.013233]
    [  990.013233] stack backtrace:
    [  990.013233] Pid: 1891, comm: dbench Not tainted 2.6.33-rc1 #1
    [  990.013233] Call Trace:
    [  990.013233]  [<ffffffff81061639>] print_circular_bug+0xe9/0xf0
    [  990.013233]  [<ffffffff81063e30>] __lock_acquire+0x12d0/0x1560
    [  990.013233]  [<ffffffff8115899a>] ? reiserfs_xattr_set_handle+0x8a/0x470
    [  990.013233]  [<ffffffff8106414f>] lock_acquire+0x8f/0xb0
    [  990.013233]  [<ffffffff81159505>] ? reiserfs_write_lock+0x35/0x50
    [  990.013233]  [<ffffffff8115899a>] ? reiserfs_xattr_set_handle+0x8a/0x470
    [  990.013233]  [<ffffffff814aba77>] __mutex_lock_common+0x47/0x3b0
    [  990.013233]  [<ffffffff81159505>] ? reiserfs_write_lock+0x35/0x50
    [  990.013233]  [<ffffffff81159505>] ? reiserfs_write_lock+0x35/0x50
    [  990.013233]  [<ffffffff81062592>] ? mark_held_locks+0x72/0xa0
    [  990.013233]  [<ffffffff814ab81d>] ? __mutex_unlock_slowpath+0xbd/0x140
    [  990.013233]  [<ffffffff810628ad>] ? trace_hardirqs_on_caller+0x14d/0x1a0
    [  990.013233]  [<ffffffff814abebe>] mutex_lock_nested+0x3e/0x50
    [  990.013233]  [<ffffffff81159505>] reiserfs_write_lock+0x35/0x50
    [  990.013233]  [<ffffffff811340e5>] reiserfs_prepare_write+0x45/0x180
    [  990.013233]  [<ffffffff81158bb6>] reiserfs_xattr_set_handle+0x2a6/0x470
    [  990.013233]  [<ffffffff81158e30>] reiserfs_xattr_set+0xb0/0x150
    [  990.013233]  [<ffffffff814abcb4>] ? __mutex_lock_common+0x284/0x3b0
    [  990.013233]  [<ffffffff8115a6aa>] user_set+0x8a/0x90
    [  990.013233]  [<ffffffff8115901a>] reiserfs_setxattr+0xaa/0xb0
    [  990.013233]  [<ffffffff810e2596>] __vfs_setxattr_noperm+0x36/0xa0
    [  990.013233]  [<ffffffff810e26bc>] vfs_setxattr+0xbc/0xc0
    [  990.013233]  [<ffffffff810e2780>] setxattr+0xc0/0x150
    [  990.013233]  [<ffffffff81056018>] ? sched_clock_cpu+0xb8/0x100
    [  990.013233]  [<ffffffff8105eded>] ? trace_hardirqs_off+0xd/0x10
    [  990.013233]  [<ffffffff810560a3>] ? cpu_clock+0x43/0x50
    [  990.013233]  [<ffffffff810c6820>] ? fget+0xb0/0x110
    [  990.013233]  [<ffffffff810c6770>] ? fget+0x0/0x110
    [  990.013233]  [<ffffffff81002ddc>] ? sysret_check+0x27/0x62
    [  990.013233]  [<ffffffff810e289d>] sys_fsetxattr+0x8d/0xa0
    [  990.013233]  [<ffffffff81002dab>] system_call_fastpath+0x16/0x1b
    
    Reported-and-tested-by: Christian Kujau <lists@nerdbynature.de>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 8891cd88a3f4..a0e2e7acdc75 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -484,7 +484,7 @@ reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
 	if (IS_ERR(dentry))
 		return PTR_ERR(dentry);
 
-	down_write(&REISERFS_I(inode)->i_xattr_sem);
+	reiserfs_down_read_safe(&REISERFS_I(inode)->i_xattr_sem, inode->i_sb);
 
 	xahash = xattr_hash(buffer, buffer_size);
 	while (buffer_pos < buffer_size || buffer_pos == 0) {

commit 47376ceba54600cec4dd9e7c4fe8b98e4269633a
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Dec 16 23:25:50 2009 +0100

    reiserfs: Fix reiserfs lock <-> inode mutex dependency inversion
    
    The reiserfs lock -> inode mutex dependency gets inverted when we
    relax the lock while walking to the tree.
    
    To fix this, use a specialized version of reiserfs_mutex_lock_safe
    that takes care of mutex subclasses. Then we can grab the inode
    mutex with I_MUTEX_XATTR subclass without any reiserfs lock
    dependency.
    
    This fixes the following report:
    
    [ INFO: possible circular locking dependency detected ]
    2.6.32-06793-gf405425-dirty #2
    -------------------------------------------------------
    mv/18566 is trying to acquire lock:
     (&REISERFS_SB(s)->lock){+.+.+.}, at: [<c1110708>] reiserfs_write_lock+0x28=
    /0x40
    
    but task is already holding lock:
     (&sb->s_type->i_mutex_key#5/3){+.+.+.}, at: [<c111033c>]
    reiserfs_for_each_xattr+0x10c/0x380
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #1 (&sb->s_type->i_mutex_key#5/3){+.+.+.}:
           [<c104f723>] validate_chain+0xa23/0xf70
           [<c1050155>] __lock_acquire+0x4e5/0xa70
           [<c105075a>] lock_acquire+0x7a/0xa0
           [<c134c76f>] mutex_lock_nested+0x5f/0x2b0
           [<c11102b4>] reiserfs_for_each_xattr+0x84/0x380
           [<c1110615>] reiserfs_delete_xattrs+0x15/0x50
           [<c10ef57f>] reiserfs_delete_inode+0x8f/0x140
           [<c10a565c>] generic_delete_inode+0x9c/0x150
           [<c10a574d>] generic_drop_inode+0x3d/0x60
           [<c10a4667>] iput+0x47/0x50
           [<c109cc0b>] do_unlinkat+0xdb/0x160
           [<c109cca0>] sys_unlink+0x10/0x20
           [<c1002c50>] sysenter_do_call+0x12/0x36
    
    -> #0 (&REISERFS_SB(s)->lock){+.+.+.}:
           [<c104fc68>] validate_chain+0xf68/0xf70
           [<c1050155>] __lock_acquire+0x4e5/0xa70
           [<c105075a>] lock_acquire+0x7a/0xa0
           [<c134c76f>] mutex_lock_nested+0x5f/0x2b0
           [<c1110708>] reiserfs_write_lock+0x28/0x40
           [<c1103d6b>] search_by_key+0x1f7b/0x21b0
           [<c10e73ef>] search_by_entry_key+0x1f/0x3b0
           [<c10e77f7>] reiserfs_find_entry+0x77/0x400
           [<c10e81e5>] reiserfs_lookup+0x85/0x130
           [<c109a144>] __lookup_hash+0xb4/0x110
           [<c109b763>] lookup_one_len+0xb3/0x100
           [<c1110350>] reiserfs_for_each_xattr+0x120/0x380
           [<c1110615>] reiserfs_delete_xattrs+0x15/0x50
           [<c10ef57f>] reiserfs_delete_inode+0x8f/0x140
           [<c10a565c>] generic_delete_inode+0x9c/0x150
           [<c10a574d>] generic_drop_inode+0x3d/0x60
           [<c10a4667>] iput+0x47/0x50
           [<c10a1c4f>] dentry_iput+0x6f/0xf0
           [<c10a1d74>] d_kill+0x24/0x50
           [<c10a396b>] dput+0x5b/0x120
           [<c109ca89>] sys_renameat+0x1b9/0x230
           [<c109cb28>] sys_rename+0x28/0x30
           [<c1002c50>] sysenter_do_call+0x12/0x36
    
    other info that might help us debug this:
    
    2 locks held by mv/18566:
     #0:  (&sb->s_type->i_mutex_key#5/1){+.+.+.}, at: [<c109b6ac>]
    lock_rename+0xcc/0xd0
     #1:  (&sb->s_type->i_mutex_key#5/3){+.+.+.}, at: [<c111033c>]
    reiserfs_for_each_xattr+0x10c/0x380
    
    stack backtrace:
    Pid: 18566, comm: mv Tainted: G         C 2.6.32-06793-gf405425-dirty #2
    Call Trace:
     [<c134b252>] ? printk+0x18/0x1e
     [<c104e790>] print_circular_bug+0xc0/0xd0
     [<c104fc68>] validate_chain+0xf68/0xf70
     [<c104c8cb>] ? trace_hardirqs_off+0xb/0x10
     [<c1050155>] __lock_acquire+0x4e5/0xa70
     [<c105075a>] lock_acquire+0x7a/0xa0
     [<c1110708>] ? reiserfs_write_lock+0x28/0x40
     [<c134c76f>] mutex_lock_nested+0x5f/0x2b0
     [<c1110708>] ? reiserfs_write_lock+0x28/0x40
     [<c1110708>] ? reiserfs_write_lock+0x28/0x40
     [<c134b60a>] ? schedule+0x27a/0x440
     [<c1110708>] reiserfs_write_lock+0x28/0x40
     [<c1103d6b>] search_by_key+0x1f7b/0x21b0
     [<c1050176>] ? __lock_acquire+0x506/0xa70
     [<c1051267>] ? lock_release_non_nested+0x1e7/0x340
     [<c1110708>] ? reiserfs_write_lock+0x28/0x40
     [<c104e354>] ? trace_hardirqs_on_caller+0x124/0x170
     [<c104e3ab>] ? trace_hardirqs_on+0xb/0x10
     [<c1042a55>] ? T.316+0x15/0x1a0
     [<c1042d2d>] ? sched_clock_cpu+0x9d/0x100
     [<c10e73ef>] search_by_entry_key+0x1f/0x3b0
     [<c134bf2a>] ? __mutex_unlock_slowpath+0x9a/0x120
     [<c104e354>] ? trace_hardirqs_on_caller+0x124/0x170
     [<c10e77f7>] reiserfs_find_entry+0x77/0x400
     [<c10e81e5>] reiserfs_lookup+0x85/0x130
     [<c1042d2d>] ? sched_clock_cpu+0x9d/0x100
     [<c109a144>] __lookup_hash+0xb4/0x110
     [<c109b763>] lookup_one_len+0xb3/0x100
     [<c1110350>] reiserfs_for_each_xattr+0x120/0x380
     [<c110ffe0>] ? delete_one_xattr+0x0/0x1c0
     [<c1003342>] ? math_error+0x22/0x150
     [<c1110708>] ? reiserfs_write_lock+0x28/0x40
     [<c1110615>] reiserfs_delete_xattrs+0x15/0x50
     [<c1110708>] ? reiserfs_write_lock+0x28/0x40
     [<c10ef57f>] reiserfs_delete_inode+0x8f/0x140
     [<c10a561f>] ? generic_delete_inode+0x5f/0x150
     [<c10ef4f0>] ? reiserfs_delete_inode+0x0/0x140
     [<c10a565c>] generic_delete_inode+0x9c/0x150
     [<c10a574d>] generic_drop_inode+0x3d/0x60
     [<c10a4667>] iput+0x47/0x50
     [<c10a1c4f>] dentry_iput+0x6f/0xf0
     [<c10a1d74>] d_kill+0x24/0x50
     [<c10a396b>] dput+0x5b/0x120
     [<c109ca89>] sys_renameat+0x1b9/0x230
     [<c1042d2d>] ? sched_clock_cpu+0x9d/0x100
     [<c104c8cb>] ? trace_hardirqs_off+0xb/0x10
     [<c1042dde>] ? cpu_clock+0x4e/0x60
     [<c1350825>] ? do_page_fault+0x155/0x370
     [<c1041816>] ? up_read+0x16/0x30
     [<c1350825>] ? do_page_fault+0x155/0x370
     [<c109cb28>] sys_rename+0x28/0x30
     [<c1002c50>] sysenter_do_call+0x12/0x36
    
    Reported-by: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 58aa8e75f7f5..8891cd88a3f4 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -243,7 +243,8 @@ static int reiserfs_for_each_xattr(struct inode *inode,
 		goto out_dir;
 	}
 
-	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
+	reiserfs_mutex_lock_nested_safe(&dir->d_inode->i_mutex, I_MUTEX_XATTR,
+					inode->i_sb);
 	buf.xadir = dir;
 	err = reiserfs_readdir_dentry(dir, &buf, fill_with_dentries, &pos);
 	while ((err == 0 || err == -ENOSPC) && buf.count) {

commit 431547b3c4533b8c7fd150ab36980b9a3147797b
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Nov 13 09:52:56 2009 +0000

    sanitize xattr handler prototypes
    
    Add a flags argument to struct xattr_handler and pass it to all xattr
    handler methods.  This allows using the same methods for multiple
    handlers, e.g. for the ACL methods which perform exactly the same action
    for the access and default ACLs, just using a different underlying
    attribute.  With a little more groundwork it'll also allow sharing the
    methods for the regular user/trusted/secure handlers in extN, ocfs2 and
    jffs2 like it's already done for xfs in this patch.
    
    Also change the inode argument to the handlers to a dentry to allow
    using the handlers mechnism for filesystems that require it later,
    e.g. cifs.
    
    [with GFS2 bits updated by Steven Whitehouse <swhiteho@redhat.com>]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: James Morris <jmorris@namei.org>
    Acked-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 58aa8e75f7f5..8c7033a8b67e 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -48,6 +48,7 @@
 #include <net/checksum.h>
 #include <linux/stat.h>
 #include <linux/quotaops.h>
+#include <linux/security.h>
 
 #define PRIVROOT_NAME ".reiserfs_priv"
 #define XAROOT_NAME   "xattrs"
@@ -726,15 +727,14 @@ ssize_t
 reiserfs_getxattr(struct dentry * dentry, const char *name, void *buffer,
 		  size_t size)
 {
-	struct inode *inode = dentry->d_inode;
 	struct xattr_handler *handler;
 
-	handler = find_xattr_handler_prefix(inode->i_sb->s_xattr, name);
+	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
 
-	if (!handler || get_inode_sd_version(inode) == STAT_DATA_V1)
+	if (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	return handler->get(inode, name, buffer, size);
+	return handler->get(dentry, name, buffer, size, handler->flags);
 }
 
 /*
@@ -746,15 +746,14 @@ int
 reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 		  size_t size, int flags)
 {
-	struct inode *inode = dentry->d_inode;
 	struct xattr_handler *handler;
 
-	handler = find_xattr_handler_prefix(inode->i_sb->s_xattr, name);
+	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
 
-	if (!handler || get_inode_sd_version(inode) == STAT_DATA_V1)
+	if (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	return handler->set(inode, name, value, size, flags);
+	return handler->set(dentry, name, value, size, flags, handler->flags);
 }
 
 /*
@@ -764,21 +763,20 @@ reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
  */
 int reiserfs_removexattr(struct dentry *dentry, const char *name)
 {
-	struct inode *inode = dentry->d_inode;
 	struct xattr_handler *handler;
-	handler = find_xattr_handler_prefix(inode->i_sb->s_xattr, name);
+	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
 
-	if (!handler || get_inode_sd_version(inode) == STAT_DATA_V1)
+	if (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	return handler->set(inode, name, NULL, 0, XATTR_REPLACE);
+	return handler->set(dentry, name, NULL, 0, XATTR_REPLACE, handler->flags);
 }
 
 struct listxattr_buf {
 	size_t size;
 	size_t pos;
 	char *buf;
-	struct inode *inode;
+	struct dentry *dentry;
 };
 
 static int listxattr_filler(void *buf, const char *name, int namelen,
@@ -789,17 +787,19 @@ static int listxattr_filler(void *buf, const char *name, int namelen,
 	if (name[0] != '.' ||
 	    (namelen != 1 && (name[1] != '.' || namelen != 2))) {
 		struct xattr_handler *handler;
-		handler = find_xattr_handler_prefix(b->inode->i_sb->s_xattr,
+		handler = find_xattr_handler_prefix(b->dentry->d_sb->s_xattr,
 						    name);
 		if (!handler)	/* Unsupported xattr name */
 			return 0;
 		if (b->buf) {
-			size = handler->list(b->inode, b->buf + b->pos,
-					 b->size, name, namelen);
+			size = handler->list(b->dentry, b->buf + b->pos,
+					 b->size, name, namelen,
+					 handler->flags);
 			if (size > b->size)
 				return -ERANGE;
 		} else {
-			size = handler->list(b->inode, NULL, 0, name, namelen);
+			size = handler->list(b->dentry, NULL, 0, name,
+					     namelen, handler->flags);
 		}
 
 		b->pos += size;
@@ -820,7 +820,7 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 	int err = 0;
 	loff_t pos = 0;
 	struct listxattr_buf buf = {
-		.inode = dentry->d_inode,
+		.dentry = dentry,
 		.buf = buffer,
 		.size = buffer ? size : 0,
 	};

commit ae635c0bbd6c10aa62bf5149c6f41add59fbf4d2
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Tue Aug 25 02:24:45 2009 +0200

    kill-the-bkl/reiserfs: fix "reiserfs lock" / "inode mutex" lock inversion dependency
    
    reiserfs_xattr_init is called with the reiserfs write lock held, but
    if the ".reiserfs_priv" entry is not created, we take the superblock
    root directory inode mutex until .reiserfs_priv is created.
    
    This creates a lock dependency inversion against other sites such as
    reiserfs_file_release() which takes an inode mutex and the reiserfs
    lock after.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Cc: Laurent Riffard <laurent.riffard@free.fr>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 59870a4751cc..58aa8e75f7f5 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -1004,7 +1004,7 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 		goto error;
 
 	if (!privroot->d_inode && !(mount_flags & MS_RDONLY)) {
-		mutex_lock(&s->s_root->d_inode->i_mutex);
+		reiserfs_mutex_lock_safe(&s->s_root->d_inode->i_mutex, s);
 		err = create_privroot(REISERFS_SB(s)->priv_root);
 		mutex_unlock(&s->s_root->d_inode->i_mutex);
 	}

commit c72e05756b900b3be24cd73a16de52bab80984c0
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Sat May 16 18:12:08 2009 +0200

    kill-the-bkl/reiserfs: acquire the inode mutex safely
    
    While searching a pathname, an inode mutex can be acquired
    in do_lookup() which calls reiserfs_lookup() which in turn
    acquires the write lock.
    
    On the other side reiserfs_fill_super() can acquire the write_lock
    and then call reiserfs_lookup_privroot() which can acquire an
    inode mutex (the root of the mount point).
    
    So we theoretically risk an AB - BA lock inversion that could lead
    to a deadlock.
    
    As for other lock dependencies found since the bkl to mutex
    conversion, the fix is to use reiserfs_mutex_lock_safe() which
    drops the lock dependency to the write lock.
    
    [ Impact: fix a possible deadlock with reiserfs ]
    
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 6925b835a43b..59870a4751cc 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -975,7 +975,7 @@ int reiserfs_lookup_privroot(struct super_block *s)
 	int err = 0;
 
 	/* If we don't have the privroot located yet - go find it */
-	mutex_lock(&s->s_root->d_inode->i_mutex);
+	reiserfs_mutex_lock_safe(&s->s_root->d_inode->i_mutex, s);
 	dentry = lookup_one_len(PRIVROOT_NAME, s->s_root,
 				strlen(PRIVROOT_NAME));
 	if (!IS_ERR(dentry)) {
@@ -1011,7 +1011,7 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 
 	if (privroot->d_inode) {
 		s->s_xattr = reiserfs_xattr_handlers;
-		mutex_lock(&privroot->d_inode->i_mutex);
+		reiserfs_mutex_lock_safe(&privroot->d_inode->i_mutex, s);
 		if (!REISERFS_SB(s)->xattr_root) {
 			struct dentry *dentry;
 			dentry = lookup_one_len(XAROOT_NAME, privroot,

commit 405f55712dfe464b3240d7816cc4fe4174831be2
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Jul 11 22:08:37 2009 +0400

    headers: smp_lock.h redux
    
    * Remove smp_lock.h from files which don't need it (including some headers!)
    * Add smp_lock.h to files which do need it
    * Make smp_lock.h include conditional in hardirq.h
      It's needed only for one kernel_locked() usage which is under CONFIG_PREEMPT
    
      This will make hardirq.h inclusion cheaper for every PREEMPT=n config
      (which includes allmodconfig/allyesconfig, BTW)
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index f3d47d856848..6925b835a43b 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -46,7 +46,6 @@
 #include <linux/reiserfs_acl.h>
 #include <asm/uaccess.h>
 #include <net/checksum.h>
-#include <linux/smp_lock.h>
 #include <linux/stat.h>
 #include <linux/quotaops.h>
 

commit 73422811d290c628b4ddbf6830e5cd6fa42e84f1
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Sun May 10 16:05:39 2009 -0400

    reiserfs: allow exposing privroot w/ xattrs enabled
    
    This patch adds an -oexpose_privroot option to allow access to the privroot.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 8e7deb0e6964..f3d47d856848 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -981,7 +981,8 @@ int reiserfs_lookup_privroot(struct super_block *s)
 				strlen(PRIVROOT_NAME));
 	if (!IS_ERR(dentry)) {
 		REISERFS_SB(s)->priv_root = dentry;
-		s->s_root->d_op = &xattr_lookup_poison_ops;
+		if (!reiserfs_expose_privroot(s))
+			s->s_root->d_op = &xattr_lookup_poison_ops;
 		if (dentry->d_inode)
 			dentry->d_inode->i_flags |= S_PRIVATE;
 	} else

commit b83674c0da6558e357c6b482ccf299eeea77d8ef
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Sun May 17 01:02:03 2009 -0400

    reiserfs: fixup perms when xattrs are disabled
    
    This adds CONFIG_REISERFS_FS_XATTR protection from reiserfs_permission.
    
    This is needed to avoid warnings during file deletions and chowns with
    xattrs disabled.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 628075ca82c1..8e7deb0e6964 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -871,23 +871,6 @@ static int reiserfs_check_acl(struct inode *inode, int mask)
 	return error;
 }
 
-int reiserfs_permission(struct inode *inode, int mask)
-{
-	/*
-	 * We don't do permission checks on the internal objects.
-	 * Permissions are determined by the "owning" object.
-	 */
-	if (IS_PRIVATE(inode))
-		return 0;
-	/*
-	 * Stat data v1 doesn't support ACLs.
-	 */
-	if (get_inode_sd_version(inode) == STAT_DATA_V1)
-		return generic_permission(inode, mask, NULL);
-	else
-		return generic_permission(inode, mask, reiserfs_check_acl);
-}
-
 static int create_privroot(struct dentry *dentry)
 {
 	int err;
@@ -951,6 +934,25 @@ static int xattr_mount_check(struct super_block *s)
 	return 0;
 }
 
+int reiserfs_permission(struct inode *inode, int mask)
+{
+	/*
+	 * We don't do permission checks on the internal objects.
+	 * Permissions are determined by the "owning" object.
+	 */
+	if (IS_PRIVATE(inode))
+		return 0;
+
+#ifdef CONFIG_REISERFS_FS_XATTR
+	/*
+	 * Stat data v1 doesn't support ACLs.
+	 */
+	if (get_inode_sd_version(inode) != STAT_DATA_V1)
+		return generic_permission(inode, mask, reiserfs_check_acl);
+#endif
+	return generic_permission(inode, mask, NULL);
+}
+
 /* This will catch lookups from the fs root to .reiserfs_priv */
 static int
 xattr_lookup_poison(struct dentry *dentry, struct qstr *q1, struct qstr *name)

commit ceb5edc457f07956c82dccfb54ca8ae7e2a399f0
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Sun May 17 01:02:02 2009 -0400

    reiserfs: deal with NULL xattr root w/ xattrs disabled
    
    This avoids an Oops in open_xa_root that can occur when deleting a file
    with xattrs disabled.  It assumes that the xattr root will be there, and
    that is not guaranteed.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index cf949646dd57..628075ca82c1 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -123,7 +123,9 @@ static struct dentry *open_xa_root(struct super_block *sb, int flags)
 	mutex_lock_nested(&privroot->d_inode->i_mutex, I_MUTEX_XATTR);
 
 	xaroot = dget(REISERFS_SB(sb)->xattr_root);
-	if (!xaroot->d_inode) {
+	if (!xaroot)
+		xaroot = ERR_PTR(-ENODATA);
+	else if (!xaroot->d_inode) {
 		int err = -ENODATA;
 		if (xattr_may_create(flags))
 			err = xattr_mkdir(privroot->d_inode, xaroot, 0700);

commit 12abb35a03e32c97235fcefdcf2d851be9f82dc2
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Sun May 17 01:02:01 2009 -0400

    reiserfs: clean up ifdefs
    
    With xattr cleanup even with xattrs disabled, much of the initial setup
    is still performed.  Some #ifdefs are just not needed since the options
    they protect wouldn't be available anyway.
    
    This cleans those up.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 2237e10c7c7c..cf949646dd57 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -685,20 +685,6 @@ reiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,
 	return err;
 }
 
-/* Actual operations that are exported to VFS-land */
-struct xattr_handler *reiserfs_xattr_handlers[] = {
-	&reiserfs_xattr_user_handler,
-	&reiserfs_xattr_trusted_handler,
-#ifdef CONFIG_REISERFS_FS_SECURITY
-	&reiserfs_xattr_security_handler,
-#endif
-#ifdef CONFIG_REISERFS_FS_POSIX_ACL
-	&reiserfs_posix_acl_access_handler,
-	&reiserfs_posix_acl_default_handler,
-#endif
-	NULL
-};
-
 /*
  * In order to implement different sets of xattr operations for each xattr
  * prefix with the generic xattr API, a filesystem should create a
@@ -922,6 +908,28 @@ static int create_privroot(struct dentry *dentry)
 	return 0;
 }
 
+#else
+int __init reiserfs_xattr_register_handlers(void) { return 0; }
+void reiserfs_xattr_unregister_handlers(void) {}
+static int create_privroot(struct dentry *dentry) { return 0; }
+#endif
+
+/* Actual operations that are exported to VFS-land */
+struct xattr_handler *reiserfs_xattr_handlers[] = {
+#ifdef CONFIG_REISERFS_FS_XATTR
+	&reiserfs_xattr_user_handler,
+	&reiserfs_xattr_trusted_handler,
+#endif
+#ifdef CONFIG_REISERFS_FS_SECURITY
+	&reiserfs_xattr_security_handler,
+#endif
+#ifdef CONFIG_REISERFS_FS_POSIX_ACL
+	&reiserfs_posix_acl_access_handler,
+	&reiserfs_posix_acl_default_handler,
+#endif
+	NULL
+};
+
 static int xattr_mount_check(struct super_block *s)
 {
 	/* We need generation numbers to ensure that the oid mapping is correct
@@ -941,11 +949,6 @@ static int xattr_mount_check(struct super_block *s)
 	return 0;
 }
 
-#else
-int __init reiserfs_xattr_register_handlers(void) { return 0; }
-void reiserfs_xattr_unregister_handlers(void) {}
-#endif
-
 /* This will catch lookups from the fs root to .reiserfs_priv */
 static int
 xattr_lookup_poison(struct dentry *dentry, struct qstr *q1, struct qstr *name)
@@ -992,7 +995,6 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 	int err = 0;
 	struct dentry *privroot = REISERFS_SB(s)->priv_root;
 
-#ifdef CONFIG_REISERFS_FS_XATTR
 	err = xattr_mount_check(s);
 	if (err)
 		goto error;
@@ -1023,14 +1025,11 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 		clear_bit(REISERFS_XATTRS_USER, &(REISERFS_SB(s)->s_mount_opt));
 		clear_bit(REISERFS_POSIXACL, &(REISERFS_SB(s)->s_mount_opt));
 	}
-#endif
 
 	/* The super_block MS_POSIXACL must mirror the (no)acl mount option. */
-#ifdef CONFIG_REISERFS_FS_POSIX_ACL
 	if (reiserfs_posixacl(s))
 		s->s_flags |= MS_POSIXACL;
 	else
-#endif
 		s->s_flags &= ~MS_POSIXACL;
 
 	return err;

commit 677c9b2e393a0cd203bd54e9c18b012b2c73305a
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Tue May 5 15:30:17 2009 -0400

    reiserfs: remove privroot hiding in lookup
    
     With Al Viro's patch to move privroot lookup to fs mount, there's no need
     to have special code to hide the privroot in reiserfs_lookup.
    
     I've also cleaned up the privroot hiding in reiserfs_readdir_dentry and
     removed the last user of reiserfs_xattrs().
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index c77984473db9..2237e10c7c7c 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -841,7 +841,7 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 	if (!dentry->d_inode)
 		return -EINVAL;
 
-	if (!reiserfs_xattrs(dentry->d_sb) ||
+	if (!dentry->d_sb->s_xattr ||
 	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 

commit ab17c4f02156c4f75d7fa43a5aa2a7f942d47201
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Tue May 5 15:30:15 2009 -0400

    reiserfs: fixup xattr_root caching
    
     The xattr_root caching was broken from my previous patch set. It wouldn't
     cause corruption, but could cause decreased performance due to allocating
     a larger chunk of the journal (~ 27 blocks) than it would actually use.
    
     This patch loads the xattr root dentry at xattr initialization and creates
     it on-demand. Since we're using the cached dentry, there's no point
     in keeping lookup_or_create_dir around, so that's removed.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 2891f789f545..c77984473db9 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -113,36 +113,28 @@ static int xattr_rmdir(struct inode *dir, struct dentry *dentry)
 
 #define xattr_may_create(flags)	(!flags || flags & XATTR_CREATE)
 
-/* Returns and possibly creates the xattr dir. */
-static struct dentry *lookup_or_create_dir(struct dentry *parent,
-					    const char *name, int flags)
+static struct dentry *open_xa_root(struct super_block *sb, int flags)
 {
-	struct dentry *dentry;
-	BUG_ON(!parent);
+	struct dentry *privroot = REISERFS_SB(sb)->priv_root;
+	struct dentry *xaroot;
+	if (!privroot->d_inode)
+		return ERR_PTR(-ENODATA);
 
-	mutex_lock_nested(&parent->d_inode->i_mutex, I_MUTEX_XATTR);
-	dentry = lookup_one_len(name, parent, strlen(name));
-	if (!IS_ERR(dentry) && !dentry->d_inode) {
-		int err = -ENODATA;
+	mutex_lock_nested(&privroot->d_inode->i_mutex, I_MUTEX_XATTR);
 
+	xaroot = dget(REISERFS_SB(sb)->xattr_root);
+	if (!xaroot->d_inode) {
+		int err = -ENODATA;
 		if (xattr_may_create(flags))
-			err = xattr_mkdir(parent->d_inode, dentry, 0700);
-
+			err = xattr_mkdir(privroot->d_inode, xaroot, 0700);
 		if (err) {
-			dput(dentry);
-			dentry = ERR_PTR(err);
+			dput(xaroot);
+			xaroot = ERR_PTR(err);
 		}
 	}
-	mutex_unlock(&parent->d_inode->i_mutex);
-	return dentry;
-}
 
-static struct dentry *open_xa_root(struct super_block *sb, int flags)
-{
-	struct dentry *privroot = REISERFS_SB(sb)->priv_root;
-	if (!privroot)
-		return ERR_PTR(-ENODATA);
-	return lookup_or_create_dir(privroot, XAROOT_NAME, flags);
+	mutex_unlock(&privroot->d_inode->i_mutex);
+	return xaroot;
 }
 
 static struct dentry *open_xa_dir(const struct inode *inode, int flags)
@@ -158,10 +150,22 @@ static struct dentry *open_xa_dir(const struct inode *inode, int flags)
 		 le32_to_cpu(INODE_PKEY(inode)->k_objectid),
 		 inode->i_generation);
 
-	xadir = lookup_or_create_dir(xaroot, namebuf, flags);
+	mutex_lock_nested(&xaroot->d_inode->i_mutex, I_MUTEX_XATTR);
+
+	xadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));
+	if (!IS_ERR(xadir) && !xadir->d_inode) {
+		int err = -ENODATA;
+		if (xattr_may_create(flags))
+			err = xattr_mkdir(xaroot->d_inode, xadir, 0700);
+		if (err) {
+			dput(xadir);
+			xadir = ERR_PTR(err);
+		}
+	}
+
+	mutex_unlock(&xaroot->d_inode->i_mutex);
 	dput(xaroot);
 	return xadir;
-
 }
 
 /* The following are side effects of other operations that aren't explicitly
@@ -986,19 +990,33 @@ int reiserfs_lookup_privroot(struct super_block *s)
 int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 {
 	int err = 0;
+	struct dentry *privroot = REISERFS_SB(s)->priv_root;
 
 #ifdef CONFIG_REISERFS_FS_XATTR
 	err = xattr_mount_check(s);
 	if (err)
 		goto error;
 
-	if (!REISERFS_SB(s)->priv_root->d_inode && !(mount_flags & MS_RDONLY)) {
+	if (!privroot->d_inode && !(mount_flags & MS_RDONLY)) {
 		mutex_lock(&s->s_root->d_inode->i_mutex);
 		err = create_privroot(REISERFS_SB(s)->priv_root);
 		mutex_unlock(&s->s_root->d_inode->i_mutex);
 	}
-	if (!err)
+
+	if (privroot->d_inode) {
 		s->s_xattr = reiserfs_xattr_handlers;
+		mutex_lock(&privroot->d_inode->i_mutex);
+		if (!REISERFS_SB(s)->xattr_root) {
+			struct dentry *dentry;
+			dentry = lookup_one_len(XAROOT_NAME, privroot,
+						strlen(XAROOT_NAME));
+			if (!IS_ERR(dentry))
+				REISERFS_SB(s)->xattr_root = dentry;
+			else
+				err = PTR_ERR(dentry);
+		}
+		mutex_unlock(&privroot->d_inode->i_mutex);
+	}
 
 error:
 	if (err) {
@@ -1008,11 +1026,12 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 #endif
 
 	/* The super_block MS_POSIXACL must mirror the (no)acl mount option. */
-	s->s_flags = s->s_flags & ~MS_POSIXACL;
 #ifdef CONFIG_REISERFS_FS_POSIX_ACL
 	if (reiserfs_posixacl(s))
 		s->s_flags |= MS_POSIXACL;
+	else
 #endif
+		s->s_flags &= ~MS_POSIXACL;
 
 	return err;
 }

commit edcc37a0478836b4a51eafb1bcec6a52708f681d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun May 3 06:00:05 2009 -0400

    Always lookup priv_root on reiserfs mount and keep it
    
    ... even if it's a negative dentry.  That way we can set ->d_op on
    root before anyone could race with us.  Simplify d_compare(), while
    we are at it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 31a3dbb120e1..2891f789f545 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -903,16 +903,19 @@ static int create_privroot(struct dentry *dentry)
 	WARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));
 
 	err = xattr_mkdir(inode, dentry, 0700);
-	if (err) {
-		dput(dentry);
-		dentry = NULL;
+	if (err || !dentry->d_inode) {
+		reiserfs_warning(dentry->d_sb, "jdm-20006",
+				 "xattrs/ACLs enabled and couldn't "
+				 "find/create .reiserfs_priv. "
+				 "Failing mount.");
+		return -EOPNOTSUPP;
 	}
 
-	if (dentry && dentry->d_inode)
-		reiserfs_info(dentry->d_sb, "Created %s - reserved for xattr "
-			      "storage.\n", PRIVROOT_NAME);
+	dentry->d_inode->i_flags |= S_PRIVATE;
+	reiserfs_info(dentry->d_sb, "Created %s - reserved for xattr "
+		      "storage.\n", PRIVROOT_NAME);
 
-	return err;
+	return 0;
 }
 
 static int xattr_mount_check(struct super_block *s)
@@ -944,11 +947,9 @@ static int
 xattr_lookup_poison(struct dentry *dentry, struct qstr *q1, struct qstr *name)
 {
 	struct dentry *priv_root = REISERFS_SB(dentry->d_sb)->priv_root;
-	if (name->len == priv_root->d_name.len &&
-	    name->hash == priv_root->d_name.hash &&
-	    !memcmp(name->name, priv_root->d_name.name, name->len)) {
+	if (container_of(q1, struct dentry, d_name) == priv_root)
 		return -ENOENT;
-	} else if (q1->len == name->len &&
+	if (q1->len == name->len &&
 		   !memcmp(q1->name, name->name, name->len))
 		return 0;
 	return 1;
@@ -958,6 +959,27 @@ static const struct dentry_operations xattr_lookup_poison_ops = {
 	.d_compare = xattr_lookup_poison,
 };
 
+int reiserfs_lookup_privroot(struct super_block *s)
+{
+	struct dentry *dentry;
+	int err = 0;
+
+	/* If we don't have the privroot located yet - go find it */
+	mutex_lock(&s->s_root->d_inode->i_mutex);
+	dentry = lookup_one_len(PRIVROOT_NAME, s->s_root,
+				strlen(PRIVROOT_NAME));
+	if (!IS_ERR(dentry)) {
+		REISERFS_SB(s)->priv_root = dentry;
+		s->s_root->d_op = &xattr_lookup_poison_ops;
+		if (dentry->d_inode)
+			dentry->d_inode->i_flags |= S_PRIVATE;
+	} else
+		err = PTR_ERR(dentry);
+	mutex_unlock(&s->s_root->d_inode->i_mutex);
+
+	return err;
+}
+
 /* We need to take a copy of the mount flags since things like
  * MS_RDONLY don't get set until *after* we're called.
  * mount_flags != mount_options */
@@ -969,48 +991,12 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 	err = xattr_mount_check(s);
 	if (err)
 		goto error;
-#endif
 
-	/* If we don't have the privroot located yet - go find it */
-	if (!REISERFS_SB(s)->priv_root) {
-		struct dentry *dentry;
-		mutex_lock_nested(&s->s_root->d_inode->i_mutex, I_MUTEX_CHILD);
-		dentry = lookup_one_len(PRIVROOT_NAME, s->s_root,
-					strlen(PRIVROOT_NAME));
-		if (!IS_ERR(dentry)) {
-#ifdef CONFIG_REISERFS_FS_XATTR
-			if (!(mount_flags & MS_RDONLY) && !dentry->d_inode)
-				err = create_privroot(dentry);
-#endif
-			if (!dentry->d_inode) {
-				dput(dentry);
-				dentry = NULL;
-			}
-		} else
-			err = PTR_ERR(dentry);
+	if (!REISERFS_SB(s)->priv_root->d_inode && !(mount_flags & MS_RDONLY)) {
+		mutex_lock(&s->s_root->d_inode->i_mutex);
+		err = create_privroot(REISERFS_SB(s)->priv_root);
 		mutex_unlock(&s->s_root->d_inode->i_mutex);
-
-		if (!err && dentry) {
-			s->s_root->d_op = &xattr_lookup_poison_ops;
-			dentry->d_inode->i_flags |= S_PRIVATE;
-			REISERFS_SB(s)->priv_root = dentry;
-#ifdef CONFIG_REISERFS_FS_XATTR
-		/* xattrs are unavailable */
-		} else if (!(mount_flags & MS_RDONLY)) {
-			/* If we're read-only it just means that the dir
-			 * hasn't been created. Not an error -- just no
-			 * xattrs on the fs. We'll check again if we
-			 * go read-write */
-			reiserfs_warning(s, "jdm-20006",
-					 "xattrs/ACLs enabled and couldn't "
-					 "find/create .reiserfs_priv. "
-					 "Failing mount.");
-			err = -EOPNOTSUPP;
-#endif
-		}
 	}
-
-#ifdef CONFIG_REISERFS_FS_XATTR
 	if (!err)
 		s->s_xattr = reiserfs_xattr_handlers;
 

commit 5a6059c358d3b3004cb6b8562e3b049b1f8564f9
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri May 1 12:11:12 2009 -0400

    reiserfs: Expand i_mutex to enclose lookup_one_len
    
     2.6.30-rc3 introduced some sanity checks in the VFS code to avoid NFS
     bugs by ensuring that lookup_one_len is always called under i_mutex.
    
     This patch expands the i_mutex locking to enclose lookup_one_len. This was
     always required, but not not enforced in the reiserfs code since it
     does locking around the xattr interactions with the xattr_sem.
    
     This is obvious enough, and it survived an overnight 50 thread ACL test.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index f83f52bae390..31a3dbb120e1 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -120,25 +120,20 @@ static struct dentry *lookup_or_create_dir(struct dentry *parent,
 	struct dentry *dentry;
 	BUG_ON(!parent);
 
+	mutex_lock_nested(&parent->d_inode->i_mutex, I_MUTEX_XATTR);
 	dentry = lookup_one_len(name, parent, strlen(name));
-	if (IS_ERR(dentry))
-		return dentry;
-	else if (!dentry->d_inode) {
+	if (!IS_ERR(dentry) && !dentry->d_inode) {
 		int err = -ENODATA;
 
-		if (xattr_may_create(flags)) {
-			mutex_lock_nested(&parent->d_inode->i_mutex,
-					  I_MUTEX_XATTR);
+		if (xattr_may_create(flags))
 			err = xattr_mkdir(parent->d_inode, dentry, 0700);
-			mutex_unlock(&parent->d_inode->i_mutex);
-		}
 
 		if (err) {
 			dput(dentry);
 			dentry = ERR_PTR(err);
 		}
 	}
-
+	mutex_unlock(&parent->d_inode->i_mutex);
 	return dentry;
 }
 
@@ -184,6 +179,7 @@ fill_with_dentries(void *buf, const char *name, int namelen, loff_t offset,
 {
 	struct reiserfs_dentry_buf *dbuf = buf;
 	struct dentry *dentry;
+	WARN_ON_ONCE(!mutex_is_locked(&dbuf->xadir->d_inode->i_mutex));
 
 	if (dbuf->count == ARRAY_SIZE(dbuf->dentries))
 		return -ENOSPC;
@@ -349,6 +345,7 @@ static struct dentry *xattr_lookup(struct inode *inode, const char *name,
 	if (IS_ERR(xadir))
 		return ERR_CAST(xadir);
 
+	mutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);
 	xafile = lookup_one_len(name, xadir, strlen(name));
 	if (IS_ERR(xafile)) {
 		err = PTR_ERR(xafile);
@@ -360,18 +357,15 @@ static struct dentry *xattr_lookup(struct inode *inode, const char *name,
 
 	if (!xafile->d_inode) {
 		err = -ENODATA;
-		if (xattr_may_create(flags)) {
-			mutex_lock_nested(&xadir->d_inode->i_mutex,
-					  I_MUTEX_XATTR);
+		if (xattr_may_create(flags))
 			err = xattr_create(xadir->d_inode, xafile,
 					      0700|S_IFREG);
-			mutex_unlock(&xadir->d_inode->i_mutex);
-		}
 	}
 
 	if (err)
 		dput(xafile);
 out:
+	mutex_unlock(&xadir->d_inode->i_mutex);
 	dput(xadir);
 	if (err)
 		return ERR_PTR(err);
@@ -435,6 +429,7 @@ static int lookup_and_delete_xattr(struct inode *inode, const char *name)
 	if (IS_ERR(xadir))
 		return PTR_ERR(xadir);
 
+	mutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);
 	dentry = lookup_one_len(name, xadir, strlen(name));
 	if (IS_ERR(dentry)) {
 		err = PTR_ERR(dentry);
@@ -442,14 +437,13 @@ static int lookup_and_delete_xattr(struct inode *inode, const char *name)
 	}
 
 	if (dentry->d_inode) {
-		mutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);
 		err = xattr_unlink(xadir->d_inode, dentry);
-		mutex_unlock(&xadir->d_inode->i_mutex);
 		update_ctime(inode);
 	}
 
 	dput(dentry);
 out_dput:
+	mutex_unlock(&xadir->d_inode->i_mutex);
 	dput(xadir);
 	return err;
 }
@@ -906,9 +900,9 @@ static int create_privroot(struct dentry *dentry)
 {
 	int err;
 	struct inode *inode = dentry->d_parent->d_inode;
-	mutex_lock_nested(&inode->i_mutex, I_MUTEX_XATTR);
+	WARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));
+
 	err = xattr_mkdir(inode, dentry, 0700);
-	mutex_unlock(&inode->i_mutex);
 	if (err) {
 		dput(dentry);
 		dentry = NULL;
@@ -980,6 +974,7 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 	/* If we don't have the privroot located yet - go find it */
 	if (!REISERFS_SB(s)->priv_root) {
 		struct dentry *dentry;
+		mutex_lock_nested(&s->s_root->d_inode->i_mutex, I_MUTEX_CHILD);
 		dentry = lookup_one_len(PRIVROOT_NAME, s->s_root,
 					strlen(PRIVROOT_NAME));
 		if (!IS_ERR(dentry)) {
@@ -993,6 +988,7 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 			}
 		} else
 			err = PTR_ERR(dentry);
+		mutex_unlock(&s->s_root->d_inode->i_mutex);
 
 		if (!err && dentry) {
 			s->s_root->d_op = &xattr_lookup_poison_ops;

commit 3a355cc61d41bc31cc23a57247df63dba80a6018
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 16:49:58 2009 -0400

    reiserfs: xattr_create is unused with xattrs disabled
    
    This patch ifdefs xattr_create when xattrs aren't enabled.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index e52743e77000..f83f52bae390 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -57,12 +57,14 @@
 /* Helpers for inode ops. We do this so that we don't have all the VFS
  * overhead and also for proper i_mutex annotation.
  * dir->i_mutex must be held for all of them. */
+#ifdef CONFIG_REISERFS_FS_XATTR
 static int xattr_create(struct inode *dir, struct dentry *dentry, int mode)
 {
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
 	vfs_dq_init(dir);
 	return dir->i_op->create(dir, dentry, mode, NULL);
 }
+#endif
 
 static int xattr_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {

commit e1c502482853f84606928f5a2f2eb6da1993cda1
Merge: 019abbc87025 ee93961be1fa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 30 12:29:21 2009 -0700

    Merge branch 'reiserfs-updates' from Jeff Mahoney
    
    * reiserfs-updates: (35 commits)
      reiserfs: rename [cn]_* variables
      reiserfs: rename p_._ variables
      reiserfs: rename p_s_tb to tb
      reiserfs: rename p_s_inode to inode
      reiserfs: rename p_s_bh to bh
      reiserfs: rename p_s_sb to sb
      reiserfs: strip trailing whitespace
      reiserfs: cleanup path functions
      reiserfs: factor out buffer_info initialization
      reiserfs: add atomic addition of selinux attributes during inode creation
      reiserfs: use generic readdir for operations across all xattrs
      reiserfs: journaled xattrs
      reiserfs: use generic xattr handlers
      reiserfs: remove i_has_xattr_dir
      reiserfs: make per-inode xattr locking more fine grained
      reiserfs: eliminate per-super xattr lock
      reiserfs: simplify xattr internal file lookups/opens
      reiserfs: Clean up xattrs when REISERFS_FS_XATTR is unset
      reiserfs: remove IS_PRIVATE helpers
      reiserfs: remove link detection code
      ...
    
    Fixed up conflicts manually due to:
     - quota name cleanups vs variable naming changes:
            fs/reiserfs/inode.c
            fs/reiserfs/namei.c
            fs/reiserfs/stree.c
            fs/reiserfs/xattr.c
     - exported include header cleanups
            include/linux/reiserfs_fs.h

commit a41f1a4715f26f7bc4d047d0bc7710145c8e69c7
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:40 2009 -0400

    reiserfs: use generic readdir for operations across all xattrs
    
    The current reiserfs xattr implementation open codes reiserfs_readdir
    and frees the path before calling the filldir function.  Typically, the
    filldir function is something that modifies the file system, such as a
    chown or an inode deletion that also require reading of an inode
    associated with each direntry.  Since the file system is modified, the
    path retained becomes invalid for the next run.  In addition, it runs
    backwards in attempt to minimize activity.
    
    This is clearly suboptimal from a code cleanliness perspective as well
    as performance-wise.
    
    This patch implements a generic reiserfs_for_each_xattr that uses the
    generic readdir and a specific filldir routine that simply populates an
    array of dentries and then performs a specific operation on them.  When
    all files have been operated on, it then calls the operation on the
    directory itself.
    
    The result is a noticable code reduction and better performance.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index c2e3a92aaf2b..1baafec64331 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -167,218 +167,65 @@ static struct dentry *open_xa_dir(const struct inode *inode, int flags)
 
 }
 
-/*
- * this is very similar to fs/reiserfs/dir.c:reiserfs_readdir, but
- * we need to drop the path before calling the filldir struct.  That
- * would be a big performance hit to the non-xattr case, so I've copied
- * the whole thing for now. --clm
- *
- * the big difference is that I go backwards through the directory,
- * and don't mess with f->f_pos, but the idea is the same.  Do some
- * action on each and every entry in the directory.
- *
- * we're called with i_mutex held, so there are no worries about the directory
- * changing underneath us.
- */
-static int __xattr_readdir(struct inode *inode, void *dirent, filldir_t filldir)
-{
-	struct cpu_key pos_key;	/* key of current position in the directory (key of directory entry) */
-	INITIALIZE_PATH(path_to_entry);
-	struct buffer_head *bh;
-	int entry_num;
-	struct item_head *ih, tmp_ih;
-	int search_res;
-	char *local_buf;
-	loff_t next_pos;
-	char small_buf[32];	/* avoid kmalloc if we can */
-	struct reiserfs_de_head *deh;
-	int d_reclen;
-	char *d_name;
-	off_t d_off;
-	ino_t d_ino;
-	struct reiserfs_dir_entry de;
-
-	/* form key for search the next directory entry using f_pos field of
-	   file structure */
-	next_pos = max_reiserfs_offset(inode);
-
-	while (1) {
-	      research:
-		if (next_pos <= DOT_DOT_OFFSET)
-			break;
-		make_cpu_key(&pos_key, inode, next_pos, TYPE_DIRENTRY, 3);
-
-		search_res =
-		    search_by_entry_key(inode->i_sb, &pos_key, &path_to_entry,
-					&de);
-		if (search_res == IO_ERROR) {
-			// FIXME: we could just skip part of directory which could
-			// not be read
-			pathrelse(&path_to_entry);
-			return -EIO;
-		}
-
-		if (search_res == NAME_NOT_FOUND)
-			de.de_entry_num--;
-
-		set_de_name_and_namelen(&de);
-		entry_num = de.de_entry_num;
-		deh = &(de.de_deh[entry_num]);
-
-		bh = de.de_bh;
-		ih = de.de_ih;
-
-		if (!is_direntry_le_ih(ih)) {
-			reiserfs_error(inode->i_sb, "jdm-20000",
-				       "not direntry %h", ih);
-			break;
-		}
-		copy_item_head(&tmp_ih, ih);
-
-		/* we must have found item, that is item of this directory, */
-		RFALSE(COMP_SHORT_KEYS(&(ih->ih_key), &pos_key),
-		       "vs-9000: found item %h does not match to dir we readdir %K",
-		       ih, &pos_key);
-
-		if (deh_offset(deh) <= DOT_DOT_OFFSET) {
-			break;
-		}
-
-		/* look for the previous entry in the directory */
-		next_pos = deh_offset(deh) - 1;
-
-		if (!de_visible(deh))
-			/* it is hidden entry */
-			continue;
-
-		d_reclen = entry_length(bh, ih, entry_num);
-		d_name = B_I_DEH_ENTRY_FILE_NAME(bh, ih, deh);
-		d_off = deh_offset(deh);
-		d_ino = deh_objectid(deh);
-
-		if (!d_name[d_reclen - 1])
-			d_reclen = strlen(d_name);
-
-		if (d_reclen > REISERFS_MAX_NAME(inode->i_sb->s_blocksize)) {
-			/* too big to send back to VFS */
-			continue;
-		}
-
-		/* Ignore the .reiserfs_priv entry */
-		if (reiserfs_xattrs(inode->i_sb) &&
-		    !old_format_only(inode->i_sb) &&
-		    deh_objectid(deh) ==
-		    le32_to_cpu(INODE_PKEY
-				(REISERFS_SB(inode->i_sb)->priv_root->d_inode)->
-				k_objectid))
-			continue;
-
-		if (d_reclen <= 32) {
-			local_buf = small_buf;
-		} else {
-			local_buf = kmalloc(d_reclen, GFP_NOFS);
-			if (!local_buf) {
-				pathrelse(&path_to_entry);
-				return -ENOMEM;
-			}
-			if (item_moved(&tmp_ih, &path_to_entry)) {
-				kfree(local_buf);
-
-				/* sigh, must retry.  Do this same offset again */
-				next_pos = d_off;
-				goto research;
-			}
-		}
-
-		// Note, that we copy name to user space via temporary
-		// buffer (local_buf) because filldir will block if
-		// user space buffer is swapped out. At that time
-		// entry can move to somewhere else
-		memcpy(local_buf, d_name, d_reclen);
-
-		/* the filldir function might need to start transactions,
-		 * or do who knows what.  Release the path now that we've
-		 * copied all the important stuff out of the deh
-		 */
-		pathrelse(&path_to_entry);
-
-		if (filldir(dirent, local_buf, d_reclen, d_off, d_ino,
-			    DT_UNKNOWN) < 0) {
-			if (local_buf != small_buf) {
-				kfree(local_buf);
-			}
-			goto end;
-		}
-		if (local_buf != small_buf) {
-			kfree(local_buf);
-		}
-	}			/* while */
-
-      end:
-	pathrelse(&path_to_entry);
-	return 0;
-}
-
-/*
- * this could be done with dedicated readdir ops for the xattr files,
- * but I want to get something working asap
- * this is stolen from vfs_readdir
- *
- */
-static
-int xattr_readdir(struct inode *inode, filldir_t filler, void *buf)
-{
-	int res = -ENOENT;
-	if (!IS_DEADDIR(inode)) {
-		lock_kernel();
-		res = __xattr_readdir(inode, buf, filler);
-		unlock_kernel();
-	}
-	return res;
-}
-
 /* The following are side effects of other operations that aren't explicitly
  * modifying extended attributes. This includes operations such as permissions
  * or ownership changes, object deletions, etc. */
+struct reiserfs_dentry_buf {
+	struct dentry *xadir;
+	int count;
+	struct dentry *dentries[8];
+};
 
 static int
-reiserfs_delete_xattrs_filler(void *buf, const char *name, int namelen,
-			      loff_t offset, u64 ino, unsigned int d_type)
+fill_with_dentries(void *buf, const char *name, int namelen, loff_t offset,
+		    u64 ino, unsigned int d_type)
 {
-	struct dentry *xadir = (struct dentry *)buf;
+	struct reiserfs_dentry_buf *dbuf = buf;
 	struct dentry *dentry;
-	int err = 0;
 
-	dentry = lookup_one_len(name, xadir, namelen);
+	if (dbuf->count == ARRAY_SIZE(dbuf->dentries))
+		return -ENOSPC;
+
+	if (name[0] == '.' && (name[1] == '\0' ||
+			       (name[1] == '.' && name[2] == '\0')))
+		return 0;
+
+	dentry = lookup_one_len(name, dbuf->xadir, namelen);
 	if (IS_ERR(dentry)) {
-		err = PTR_ERR(dentry);
-		goto out;
+		return PTR_ERR(dentry);
 	} else if (!dentry->d_inode) {
-		err = -ENODATA;
-		goto out_file;
+		/* A directory entry exists, but no file? */
+		reiserfs_error(dentry->d_sb, "xattr-20003",
+			       "Corrupted directory: xattr %s listed but "
+			       "not found for file %s.\n",
+			       dentry->d_name.name, dbuf->xadir->d_name.name);
+		dput(dentry);
+		return -EIO;
 	}
 
-	/* Skip directories.. */
-	if (S_ISDIR(dentry->d_inode->i_mode))
-		goto out_file;
-
-	err = xattr_unlink(xadir->d_inode, dentry);
-
-out_file:
-	dput(dentry);
+	dbuf->dentries[dbuf->count++] = dentry;
+	return 0;
+}
 
-out:
-	return err;
+static void
+cleanup_dentry_buf(struct reiserfs_dentry_buf *buf)
+{
+	int i;
+	for (i = 0; i < buf->count; i++)
+		if (buf->dentries[i])
+			dput(buf->dentries[i]);
 }
 
-/* This is called w/ inode->i_mutex downed */
-int reiserfs_delete_xattrs(struct inode *inode)
+static int reiserfs_for_each_xattr(struct inode *inode,
+				   int (*action)(struct dentry *, void *),
+				   void *data)
 {
-	int err = -ENODATA;
-	struct dentry *dir, *root;
-	struct reiserfs_transaction_handle th;
-	int blocks = JOURNAL_PER_BALANCE_CNT * 2 + 2 +
-		     4 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);
+	struct dentry *dir;
+	int i, err = 0;
+	loff_t pos = 0;
+	struct reiserfs_dentry_buf buf = {
+		.count = 0,
+	};
 
 	/* Skip out, an xattr has no xattrs associated with it */
 	if (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1)
@@ -389,117 +236,97 @@ int reiserfs_delete_xattrs(struct inode *inode)
 		err = PTR_ERR(dir);
 		goto out;
 	} else if (!dir->d_inode) {
-		dput(dir);
-		goto out;
+		err = 0;
+		goto out_dir;
 	}
 
 	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
-	err = xattr_readdir(dir->d_inode, reiserfs_delete_xattrs_filler, dir);
-	mutex_unlock(&dir->d_inode->i_mutex);
-	if (err) {
-		dput(dir);
-		goto out;
+	buf.xadir = dir;
+	err = reiserfs_readdir_dentry(dir, &buf, fill_with_dentries, &pos);
+	while ((err == 0 || err == -ENOSPC) && buf.count) {
+		err = 0;
+
+		for (i = 0; i < buf.count && buf.dentries[i]; i++) {
+			int lerr = 0;
+			struct dentry *dentry = buf.dentries[i];
+
+			if (err == 0 && !S_ISDIR(dentry->d_inode->i_mode))
+				lerr = action(dentry, data);
+
+			dput(dentry);
+			buf.dentries[i] = NULL;
+			err = lerr ?: err;
+		}
+		buf.count = 0;
+		if (!err)
+			err = reiserfs_readdir_dentry(dir, &buf,
+						      fill_with_dentries, &pos);
 	}
+	mutex_unlock(&dir->d_inode->i_mutex);
 
-	root = dget(dir->d_parent);
-	dput(dir);
+	/* Clean up after a failed readdir */
+	cleanup_dentry_buf(&buf);
 
-	/* We start a transaction here to avoid a ABBA situation
-	 * between the xattr root's i_mutex and the journal lock.
-	 * Inode creation will inherit an ACL, which requires a
-	 * lookup. The lookup locks the xattr root i_mutex with a
-	 * transaction open.  Inode deletion takes teh xattr root
-	 * i_mutex to delete the directory and then starts a
-	 * transaction inside it. Boom. This doesn't incur much
-	 * additional overhead since the reiserfs_rmdir transaction
-	 * will just nest inside the outer transaction. */
-	err = journal_begin(&th, inode->i_sb, blocks);
 	if (!err) {
-		int jerror;
-		mutex_lock_nested(&root->d_inode->i_mutex, I_MUTEX_XATTR);
-		err = xattr_rmdir(root->d_inode, dir);
-		jerror = journal_end(&th, inode->i_sb, blocks);
-		mutex_unlock(&root->d_inode->i_mutex);
-		err = jerror ?: err;
+		/* We start a transaction here to avoid a ABBA situation
+		 * between the xattr root's i_mutex and the journal lock.
+		 * This doesn't incur much additional overhead since the
+		 * new transaction will just nest inside the
+		 * outer transaction. */
+		int blocks = JOURNAL_PER_BALANCE_CNT * 2 + 2 +
+			     4 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);
+		struct reiserfs_transaction_handle th;
+		err = journal_begin(&th, inode->i_sb, blocks);
+		if (!err) {
+			int jerror;
+			mutex_lock_nested(&dir->d_parent->d_inode->i_mutex,
+					  I_MUTEX_XATTR);
+			err = action(dir, data);
+			jerror = journal_end(&th, inode->i_sb, blocks);
+			mutex_unlock(&dir->d_parent->d_inode->i_mutex);
+			err = jerror ?: err;
+		}
 	}
-
-	dput(root);
+out_dir:
+	dput(dir);
 out:
-	if (err)
-		reiserfs_warning(inode->i_sb, "jdm-20004",
-				 "Couldn't remove all xattrs (%d)\n", err);
+	/* -ENODATA isn't an error */
+	if (err == -ENODATA)
+		err = 0;
 	return err;
 }
 
-struct reiserfs_chown_buf {
-	struct inode *inode;
-	struct dentry *xadir;
-	struct iattr *attrs;
-};
-
-/* XXX: If there is a better way to do this, I'd love to hear about it */
-static int
-reiserfs_chown_xattrs_filler(void *buf, const char *name, int namelen,
-			     loff_t offset, u64 ino, unsigned int d_type)
+static int delete_one_xattr(struct dentry *dentry, void *data)
 {
-	struct reiserfs_chown_buf *chown_buf = (struct reiserfs_chown_buf *)buf;
-	struct dentry *xafile, *xadir = chown_buf->xadir;
-	struct iattr *attrs = chown_buf->attrs;
-	int err = 0;
+	struct inode *dir = dentry->d_parent->d_inode;
 
-	xafile = lookup_one_len(name, xadir, namelen);
-	if (IS_ERR(xafile))
-		return PTR_ERR(xafile);
-	else if (!xafile->d_inode) {
-		dput(xafile);
-		return -ENODATA;
-	}
+	/* This is the xattr dir, handle specially. */
+	if (S_ISDIR(dentry->d_inode->i_mode))
+		return xattr_rmdir(dir, dentry);
 
-	if (!S_ISDIR(xafile->d_inode->i_mode)) {
-		mutex_lock_nested(&xafile->d_inode->i_mutex, I_MUTEX_CHILD);
-		err = reiserfs_setattr(xafile, attrs);
-		mutex_unlock(&xafile->d_inode->i_mutex);
-	}
-	dput(xafile);
+	return xattr_unlink(dir, dentry);
+}
+
+static int chown_one_xattr(struct dentry *dentry, void *data)
+{
+	struct iattr *attrs = data;
+	return reiserfs_setattr(dentry, attrs);
+}
 
+/* No i_mutex, but the inode is unconnected. */
+int reiserfs_delete_xattrs(struct inode *inode)
+{
+	int err = reiserfs_for_each_xattr(inode, delete_one_xattr, NULL);
+	if (err)
+		reiserfs_warning(inode->i_sb, "jdm-20004",
+				 "Couldn't delete all xattrs (%d)\n", err);
 	return err;
 }
 
+/* inode->i_mutex: down */
 int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)
 {
-	struct dentry *dir;
-	int err = 0;
-	struct reiserfs_chown_buf buf;
-	unsigned int ia_valid = attrs->ia_valid;
-
-	/* Skip out, an xattr has no xattrs associated with it */
-	if (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1)
-		return 0;
-
-	dir = open_xa_dir(inode, XATTR_REPLACE);
-	if (IS_ERR(dir)) {
-		if (PTR_ERR(dir) != -ENODATA)
-			err = PTR_ERR(dir);
-		goto out;
-	} else if (!dir->d_inode)
-		goto out_dir;
-
-	attrs->ia_valid &= (ATTR_UID | ATTR_GID | ATTR_CTIME);
-	buf.xadir = dir;
-	buf.attrs = attrs;
-	buf.inode = inode;
-
-	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
-	err = xattr_readdir(dir->d_inode, reiserfs_chown_xattrs_filler, &buf);
-
-	if (!err)
-		err = reiserfs_setattr(dir, attrs);
-	mutex_unlock(&dir->d_inode->i_mutex);
-
-	attrs->ia_valid = ia_valid;
-out_dir:
-	dput(dir);
-out:
+	int err = reiserfs_for_each_xattr(inode, chown_one_xattr, attrs);
 	if (err)
 		reiserfs_warning(inode->i_sb, "jdm-20007",
 				 "Couldn't chown all xattrs (%d)\n", err);
@@ -1004,6 +831,7 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 {
 	struct dentry *dir;
 	int err = 0;
+	loff_t pos = 0;
 	struct listxattr_buf buf = {
 		.inode = dentry->d_inode,
 		.buf = buffer,
@@ -1026,7 +854,7 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 	}
 
 	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
-	err = xattr_readdir(dir->d_inode, listxattr_filler, &buf);
+	err = reiserfs_readdir_dentry(dir, &buf, listxattr_filler, &pos);
 	mutex_unlock(&dir->d_inode->i_mutex);
 
 	if (!err)

commit 0ab2621ebd9a28bf7a524ecd50d492a10579dfcc
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:39 2009 -0400

    reiserfs: journaled xattrs
    
    Deadlocks are possible in the xattr code between the journal lock and the
    xattr sems.
    
    This patch implements journalling for xattr operations. The benefit is
    twofold:
     * It gets rid of the deadlock possibility by always ensuring that xattr
       write operations are initiated inside a transaction.
     * It corrects the problem where xattr backing files aren't considered any
       differently than normal files, despite the fact they are metadata.
    
    I discussed the added journal load with Chris Mason, and we decided that
    since xattrs (versus other journal activity) is fairly rare, the introduction
    of larger transactions to support journaled xattrs wouldn't be too big a deal.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index d3ce27436605..c2e3a92aaf2b 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -632,8 +632,9 @@ static int lookup_and_delete_xattr(struct inode *inode, const char *name)
  * inode->i_mutex: down
  */
 int
-__reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
-		     size_t buffer_size, int flags)
+reiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,
+			  struct inode *inode, const char *name,
+			  const void *buffer, size_t buffer_size, int flags)
 {
 	int err = 0;
 	struct dentry *dentry;
@@ -723,14 +724,34 @@ __reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	return err;
 }
 
-int
-reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
-		     size_t buffer_size, int flags)
+/* We need to start a transaction to maintain lock ordering */
+int reiserfs_xattr_set(struct inode *inode, const char *name,
+		       const void *buffer, size_t buffer_size, int flags)
 {
-	int err = __reiserfs_xattr_set(inode, name, buffer, buffer_size, flags);
-	if (err == -ENODATA)
-		err = 0;
-	return err;
+
+	struct reiserfs_transaction_handle th;
+	int error, error2;
+	size_t jbegin_count = reiserfs_xattr_nblocks(inode, buffer_size);
+
+	if (!(flags & XATTR_REPLACE))
+		jbegin_count += reiserfs_xattr_jcreate_nblocks(inode);
+
+	reiserfs_write_lock(inode->i_sb);
+	error = journal_begin(&th, inode->i_sb, jbegin_count);
+	if (error) {
+		reiserfs_write_unlock(inode->i_sb);
+		return error;
+	}
+
+	error = reiserfs_xattr_set_handle(&th, inode, name,
+					  buffer, buffer_size, flags);
+
+	error2 = journal_end(&th, inode->i_sb, jbegin_count);
+	if (error == 0)
+		error = error2;
+	reiserfs_write_unlock(inode->i_sb);
+
+	return error;
 }
 
 /*

commit 48b32a3553a54740d236b79a90f20147a25875e3
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:38 2009 -0400

    reiserfs: use generic xattr handlers
    
    Christoph Hellwig had asked me quite some time ago to port the reiserfs
    xattrs to the generic xattr interface.
    
    This patch replaces the reiserfs-specific xattr handling code with the
    generic struct xattr_handler.
    
    However, since reiserfs doesn't split the prefix and name when accessing
    xattrs, it can't leverage generic_{set,get,list,remove}xattr without
    needlessly reconstructing the name on the back end.
    
    Update 7/26/07: Added missing dput() to deletion path.
    Update 8/30/07: Added missing mark_inode_dirty when i_mode is used to
                    represent an ACL and no previous ACL existed.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 8d7e5d9ae17c..d3ce27436605 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -53,7 +53,6 @@
 #define PRIVROOT_NAME ".reiserfs_priv"
 #define XAROOT_NAME   "xattrs"
 
-static struct reiserfs_xattr_handler *find_xattr_handler_prefix(const char *);
 
 /* Helpers for inode ops. We do this so that we don't have all the VFS
  * overhead and also for proper i_mutex annotation.
@@ -110,7 +109,6 @@ static int xattr_rmdir(struct inode *dir, struct dentry *dentry)
 	return error;
 }
 
-
 #define xattr_may_create(flags)	(!flags || flags & XATTR_CREATE)
 
 /* Returns and possibly creates the xattr dir. */
@@ -339,14 +337,17 @@ int xattr_readdir(struct inode *inode, filldir_t filler, void *buf)
 	return res;
 }
 
-/* expects xadir->d_inode->i_mutex to be locked */
+/* The following are side effects of other operations that aren't explicitly
+ * modifying extended attributes. This includes operations such as permissions
+ * or ownership changes, object deletions, etc. */
+
 static int
-__reiserfs_xattr_del(struct dentry *xadir, const char *name, int namelen)
+reiserfs_delete_xattrs_filler(void *buf, const char *name, int namelen,
+			      loff_t offset, u64 ino, unsigned int d_type)
 {
+	struct dentry *xadir = (struct dentry *)buf;
 	struct dentry *dentry;
-	struct inode *dir = xadir->d_inode;
 	int err = 0;
-	struct reiserfs_xattr_handler *xah;
 
 	dentry = lookup_one_len(name, xadir, namelen);
 	if (IS_ERR(dentry)) {
@@ -361,28 +362,7 @@ __reiserfs_xattr_del(struct dentry *xadir, const char *name, int namelen)
 	if (S_ISDIR(dentry->d_inode->i_mode))
 		goto out_file;
 
-	if (!IS_PRIVATE(dentry->d_inode)) {
-		reiserfs_error(dir->i_sb, "jdm-20003",
-			       "OID %08x [%.*s/%.*s] doesn't have "
-			       "priv flag set [parent is %sset].",
-			       le32_to_cpu(INODE_PKEY(dentry->d_inode)->
-					   k_objectid), xadir->d_name.len,
-			       xadir->d_name.name, namelen, name,
-			       IS_PRIVATE(xadir->d_inode) ? "" :
-			       "not ");
-		dput(dentry);
-		return -EIO;
-	}
-
-	/* Deletion pre-operation */
-	xah = find_xattr_handler_prefix(name);
-	if (xah && xah->del) {
-		err = xah->del(dentry->d_inode, name);
-		if (err)
-			goto out;
-	}
-
-	err = xattr_unlink(dir, dentry);
+	err = xattr_unlink(xadir->d_inode, dentry);
 
 out_file:
 	dput(dentry);
@@ -391,20 +371,6 @@ __reiserfs_xattr_del(struct dentry *xadir, const char *name, int namelen)
 	return err;
 }
 
-/* The following are side effects of other operations that aren't explicitly
- * modifying extended attributes. This includes operations such as permissions
- * or ownership changes, object deletions, etc. */
-
-static int
-reiserfs_delete_xattrs_filler(void *buf, const char *name, int namelen,
-			      loff_t offset, u64 ino, unsigned int d_type)
-{
-	struct dentry *xadir = (struct dentry *)buf;
-
-	return __reiserfs_xattr_del(xadir, name, namelen);
-
-}
-
 /* This is called w/ inode->i_mutex downed */
 int reiserfs_delete_xattrs(struct inode *inode)
 {
@@ -541,14 +507,11 @@ int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)
 }
 
 #ifdef CONFIG_REISERFS_FS_XATTR
-static struct reiserfs_xattr_handler *find_xattr_handler_prefix(const char
-								*prefix);
-
 /* Returns a dentry corresponding to a specific extended attribute file
  * for the inode. If flags allow, the file is created. Otherwise, a
  * valid or negative dentry, or an error is returned. */
-static struct dentry *get_xa_file_dentry(const struct inode *inode,
-					 const char *name, int flags)
+static struct dentry *xattr_lookup(struct inode *inode, const char *name,
+				    int flags)
 {
 	struct dentry *xadir, *xafile;
 	int err = 0;
@@ -623,6 +586,45 @@ int reiserfs_commit_write(struct file *f, struct page *page,
 int reiserfs_prepare_write(struct file *f, struct page *page,
 			   unsigned from, unsigned to);
 
+static void update_ctime(struct inode *inode)
+{
+	struct timespec now = current_fs_time(inode->i_sb);
+	if (hlist_unhashed(&inode->i_hash) || !inode->i_nlink ||
+	    timespec_equal(&inode->i_ctime, &now))
+		return;
+
+	inode->i_ctime = CURRENT_TIME_SEC;
+	mark_inode_dirty(inode);
+}
+
+static int lookup_and_delete_xattr(struct inode *inode, const char *name)
+{
+	int err = 0;
+	struct dentry *dentry, *xadir;
+
+	xadir = open_xa_dir(inode, XATTR_REPLACE);
+	if (IS_ERR(xadir))
+		return PTR_ERR(xadir);
+
+	dentry = lookup_one_len(name, xadir, strlen(name));
+	if (IS_ERR(dentry)) {
+		err = PTR_ERR(dentry);
+		goto out_dput;
+	}
+
+	if (dentry->d_inode) {
+		mutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);
+		err = xattr_unlink(xadir->d_inode, dentry);
+		mutex_unlock(&xadir->d_inode->i_mutex);
+		update_ctime(inode);
+	}
+
+	dput(dentry);
+out_dput:
+	dput(xadir);
+	return err;
+}
+
 
 /* Generic extended attribute operations that can be used by xa plugins */
 
@@ -630,8 +632,8 @@ int reiserfs_prepare_write(struct file *f, struct page *page,
  * inode->i_mutex: down
  */
 int
-reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
-		   size_t buffer_size, int flags)
+__reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
+		     size_t buffer_size, int flags)
 {
 	int err = 0;
 	struct dentry *dentry;
@@ -639,37 +641,22 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	char *data;
 	size_t file_pos = 0;
 	size_t buffer_pos = 0;
-	struct iattr newattrs;
+	size_t new_size;
 	__u32 xahash = 0;
 
 	if (get_inode_sd_version(inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
 	if (!buffer)
-		return reiserfs_xattr_del(inode, name);
+		return lookup_and_delete_xattr(inode, name);
 
-	dentry = get_xa_file_dentry(inode, name, flags);
-	if (IS_ERR(dentry)) {
-		err = PTR_ERR(dentry);
-		goto out;
-	}
+	dentry = xattr_lookup(inode, name, flags);
+	if (IS_ERR(dentry))
+		return PTR_ERR(dentry);
 
 	down_write(&REISERFS_I(inode)->i_xattr_sem);
 
 	xahash = xattr_hash(buffer, buffer_size);
-
-	/* Resize it so we're ok to write there */
-	newattrs.ia_size = buffer_size;
-	newattrs.ia_ctime = current_fs_time(inode->i_sb);
-	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
-	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);
-	down_write(&dentry->d_inode->i_alloc_sem);
-	err = reiserfs_setattr(dentry, &newattrs);
-	up_write(&dentry->d_inode->i_alloc_sem);
-	mutex_unlock(&dentry->d_inode->i_mutex);
-	if (err)
-		goto out_filp;
-
 	while (buffer_pos < buffer_size || buffer_pos == 0) {
 		size_t chunk;
 		size_t skip = 0;
@@ -682,7 +669,7 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 		page = reiserfs_get_page(dentry->d_inode, file_pos);
 		if (IS_ERR(page)) {
 			err = PTR_ERR(page);
-			goto out_filp;
+			goto out_unlock;
 		}
 
 		lock_page(page);
@@ -716,20 +703,33 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 			break;
 	}
 
-	/* We can't mark the inode dirty if it's not hashed. This is the case
-	 * when we're inheriting the default ACL. If we dirty it, the inode
-	 * gets marked dirty, but won't (ever) make it onto the dirty list until
-	 * it's synced explicitly to clear I_DIRTY. This is bad. */
-	if (!hlist_unhashed(&inode->i_hash)) {
-		inode->i_ctime = CURRENT_TIME_SEC;
-		mark_inode_dirty(inode);
-	}
-
-      out_filp:
+	new_size = buffer_size + sizeof(struct reiserfs_xattr_header);
+	if (!err && new_size < i_size_read(dentry->d_inode)) {
+		struct iattr newattrs = {
+			.ia_ctime = current_fs_time(inode->i_sb),
+			.ia_size = buffer_size,
+			.ia_valid = ATTR_SIZE | ATTR_CTIME,
+		};
+		mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);
+		down_write(&dentry->d_inode->i_alloc_sem);
+		err = reiserfs_setattr(dentry, &newattrs);
+		up_write(&dentry->d_inode->i_alloc_sem);
+		mutex_unlock(&dentry->d_inode->i_mutex);
+	} else
+		update_ctime(inode);
+out_unlock:
 	up_write(&REISERFS_I(inode)->i_xattr_sem);
 	dput(dentry);
+	return err;
+}
 
-      out:
+int
+reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
+		     size_t buffer_size, int flags)
+{
+	int err = __reiserfs_xattr_set(inode, name, buffer, buffer_size, flags);
+	if (err == -ENODATA)
+		err = 0;
 	return err;
 }
 
@@ -737,7 +737,7 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
  * inode->i_mutex: down
  */
 int
-reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
+reiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,
 		   size_t buffer_size)
 {
 	ssize_t err = 0;
@@ -756,7 +756,7 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 	if (get_inode_sd_version(inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	dentry = get_xa_file_dentry(inode, name, XATTR_REPLACE);
+	dentry = xattr_lookup(inode, name, XATTR_REPLACE);
 	if (IS_ERR(dentry)) {
 		err = PTR_ERR(dentry);
 		goto out;
@@ -837,32 +837,53 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 	return err;
 }
 
-int reiserfs_xattr_del(struct inode *inode, const char *name)
-{
-	struct dentry *dir;
-	int err;
+/* Actual operations that are exported to VFS-land */
+struct xattr_handler *reiserfs_xattr_handlers[] = {
+	&reiserfs_xattr_user_handler,
+	&reiserfs_xattr_trusted_handler,
+#ifdef CONFIG_REISERFS_FS_SECURITY
+	&reiserfs_xattr_security_handler,
+#endif
+#ifdef CONFIG_REISERFS_FS_POSIX_ACL
+	&reiserfs_posix_acl_access_handler,
+	&reiserfs_posix_acl_default_handler,
+#endif
+	NULL
+};
 
-	dir = open_xa_dir(inode, XATTR_REPLACE);
-	if (IS_ERR(dir)) {
-		err = PTR_ERR(dir);
-		goto out;
-	}
+/*
+ * In order to implement different sets of xattr operations for each xattr
+ * prefix with the generic xattr API, a filesystem should create a
+ * null-terminated array of struct xattr_handler (one for each prefix) and
+ * hang a pointer to it off of the s_xattr field of the superblock.
+ *
+ * The generic_fooxattr() functions will use this list to dispatch xattr
+ * operations to the correct xattr_handler.
+ */
+#define for_each_xattr_handler(handlers, handler)		\
+		for ((handler) = *(handlers)++;			\
+			(handler) != NULL;			\
+			(handler) = *(handlers)++)
 
-	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
-	err = __reiserfs_xattr_del(dir, name, strlen(name));
-	mutex_unlock(&dir->d_inode->i_mutex);
-	dput(dir);
+/* This is the implementation for the xattr plugin infrastructure */
+static inline struct xattr_handler *
+find_xattr_handler_prefix(struct xattr_handler **handlers,
+			   const char *name)
+{
+	struct xattr_handler *xah;
 
-	if (!err) {
-		inode->i_ctime = CURRENT_TIME_SEC;
-		mark_inode_dirty(inode);
+	if (!handlers)
+		return NULL;
+
+	for_each_xattr_handler(handlers, xah) {
+		if (strncmp(xah->prefix, name, strlen(xah->prefix)) == 0)
+			break;
 	}
 
-      out:
-	return err;
+	return xah;
 }
 
-/* Actual operations that are exported to VFS-land */
+
 /*
  * Inode operation getxattr()
  */
@@ -870,15 +891,15 @@ ssize_t
 reiserfs_getxattr(struct dentry * dentry, const char *name, void *buffer,
 		  size_t size)
 {
-	struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix(name);
-	int err;
+	struct inode *inode = dentry->d_inode;
+	struct xattr_handler *handler;
 
-	if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
-	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
+	handler = find_xattr_handler_prefix(inode->i_sb->s_xattr, name);
+
+	if (!handler || get_inode_sd_version(inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	err = xah->get(dentry->d_inode, name, buffer, size);
-	return err;
+	return handler->get(inode, name, buffer, size);
 }
 
 /*
@@ -890,15 +911,15 @@ int
 reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 		  size_t size, int flags)
 {
-	struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix(name);
-	int err;
+	struct inode *inode = dentry->d_inode;
+	struct xattr_handler *handler;
 
-	if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
-	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
+	handler = find_xattr_handler_prefix(inode->i_sb->s_xattr, name);
+
+	if (!handler || get_inode_sd_version(inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	err = xah->set(dentry->d_inode, name, value, size, flags);
-	return err;
+	return handler->set(inode, name, value, size, flags);
 }
 
 /*
@@ -908,71 +929,65 @@ reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
  */
 int reiserfs_removexattr(struct dentry *dentry, const char *name)
 {
-	int err;
-	struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix(name);
+	struct inode *inode = dentry->d_inode;
+	struct xattr_handler *handler;
+	handler = find_xattr_handler_prefix(inode->i_sb->s_xattr, name);
 
-	if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
-	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
+	if (!handler || get_inode_sd_version(inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	err = reiserfs_xattr_del(dentry->d_inode, name);
-
-	dentry->d_inode->i_ctime = CURRENT_TIME_SEC;
-	mark_inode_dirty(dentry->d_inode);
-
-	return err;
+	return handler->set(inode, name, NULL, 0, XATTR_REPLACE);
 }
 
-/* This is what filldir will use:
- * r_pos will always contain the amount of space required for the entire
- * list. If r_pos becomes larger than r_size, we need more space and we
- * return an error indicating this. If r_pos is less than r_size, then we've
- * filled the buffer successfully and we return success */
-struct reiserfs_listxattr_buf {
-	int r_pos;
-	int r_size;
-	char *r_buf;
-	struct inode *r_inode;
+struct listxattr_buf {
+	size_t size;
+	size_t pos;
+	char *buf;
+	struct inode *inode;
 };
 
-static int
-reiserfs_listxattr_filler(void *buf, const char *name, int namelen,
-			  loff_t offset, u64 ino, unsigned int d_type)
+static int listxattr_filler(void *buf, const char *name, int namelen,
+			    loff_t offset, u64 ino, unsigned int d_type)
 {
-	struct reiserfs_listxattr_buf *b = (struct reiserfs_listxattr_buf *)buf;
-	int len = 0;
-	if (name[0] != '.'
-	    || (namelen != 1 && (name[1] != '.' || namelen != 2))) {
-		struct reiserfs_xattr_handler *xah =
-		    find_xattr_handler_prefix(name);
-		if (!xah)
-			return 0;	/* Unsupported xattr name, skip it */
-
-		/* We call ->list() twice because the operation isn't required to just
-		 * return the name back - we want to make sure we have enough space */
-		len += xah->list(b->r_inode, name, namelen, NULL);
-
-		if (len) {
-			if (b->r_pos + len + 1 <= b->r_size) {
-				char *p = b->r_buf + b->r_pos;
-				p += xah->list(b->r_inode, name, namelen, p);
-				*p++ = '\0';
-			}
-			b->r_pos += len + 1;
+	struct listxattr_buf *b = (struct listxattr_buf *)buf;
+	size_t size;
+	if (name[0] != '.' ||
+	    (namelen != 1 && (name[1] != '.' || namelen != 2))) {
+		struct xattr_handler *handler;
+		handler = find_xattr_handler_prefix(b->inode->i_sb->s_xattr,
+						    name);
+		if (!handler)	/* Unsupported xattr name */
+			return 0;
+		if (b->buf) {
+			size = handler->list(b->inode, b->buf + b->pos,
+					 b->size, name, namelen);
+			if (size > b->size)
+				return -ERANGE;
+		} else {
+			size = handler->list(b->inode, NULL, 0, name, namelen);
 		}
-	}
 
+		b->pos += size;
+	}
 	return 0;
 }
 
 /*
  * Inode operation listxattr()
+ *
+ * We totally ignore the generic listxattr here because it would be stupid
+ * not to. Since the xattrs are organized in a directory, we can just
+ * readdir to find them.
  */
 ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 {
 	struct dentry *dir;
 	int err = 0;
-	struct reiserfs_listxattr_buf buf;
+	struct listxattr_buf buf = {
+		.inode = dentry->d_inode,
+		.buf = buffer,
+		.size = buffer ? size : 0,
+	};
 
 	if (!dentry->d_inode)
 		return -EINVAL;
@@ -985,120 +1000,22 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 	if (IS_ERR(dir)) {
 		err = PTR_ERR(dir);
 		if (err == -ENODATA)
-			err = 0;	/* Not an error if there aren't any xattrs */
+			err = 0;  /* Not an error if there aren't any xattrs */
 		goto out;
 	}
 
-	buf.r_buf = buffer;
-	buf.r_size = buffer ? size : 0;
-	buf.r_pos = 0;
-	buf.r_inode = dentry->d_inode;
-
 	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
-	err = xattr_readdir(dir->d_inode, reiserfs_listxattr_filler, &buf);
+	err = xattr_readdir(dir->d_inode, listxattr_filler, &buf);
 	mutex_unlock(&dir->d_inode->i_mutex);
 
-	if (!err) {
-		if (buf.r_pos > buf.r_size && buffer != NULL)
-			err = -ERANGE;
-		else
-			err = buf.r_pos;
-	}
+	if (!err)
+		err = buf.pos;
 
 	dput(dir);
 out:
 	return err;
 }
 
-/* This is the implementation for the xattr plugin infrastructure */
-static LIST_HEAD(xattr_handlers);
-static DEFINE_RWLOCK(handler_lock);
-
-static struct reiserfs_xattr_handler *find_xattr_handler_prefix(const char
-								*prefix)
-{
-	struct reiserfs_xattr_handler *xah = NULL;
-	struct list_head *p;
-
-	read_lock(&handler_lock);
-	list_for_each(p, &xattr_handlers) {
-		xah = list_entry(p, struct reiserfs_xattr_handler, handlers);
-		if (strncmp(xah->prefix, prefix, strlen(xah->prefix)) == 0)
-			break;
-		xah = NULL;
-	}
-
-	read_unlock(&handler_lock);
-	return xah;
-}
-
-static void __unregister_handlers(void)
-{
-	struct reiserfs_xattr_handler *xah;
-	struct list_head *p, *tmp;
-
-	list_for_each_safe(p, tmp, &xattr_handlers) {
-		xah = list_entry(p, struct reiserfs_xattr_handler, handlers);
-		if (xah->exit)
-			xah->exit();
-
-		list_del_init(p);
-	}
-	INIT_LIST_HEAD(&xattr_handlers);
-}
-
-int __init reiserfs_xattr_register_handlers(void)
-{
-	int err = 0;
-	struct reiserfs_xattr_handler *xah;
-	struct list_head *p;
-
-	write_lock(&handler_lock);
-
-	/* If we're already initialized, nothing to do */
-	if (!list_empty(&xattr_handlers)) {
-		write_unlock(&handler_lock);
-		return 0;
-	}
-
-	/* Add the handlers */
-	list_add_tail(&user_handler.handlers, &xattr_handlers);
-	list_add_tail(&trusted_handler.handlers, &xattr_handlers);
-#ifdef CONFIG_REISERFS_FS_SECURITY
-	list_add_tail(&security_handler.handlers, &xattr_handlers);
-#endif
-#ifdef CONFIG_REISERFS_FS_POSIX_ACL
-	list_add_tail(&posix_acl_access_handler.handlers, &xattr_handlers);
-	list_add_tail(&posix_acl_default_handler.handlers, &xattr_handlers);
-#endif
-
-	/* Run initializers, if available */
-	list_for_each(p, &xattr_handlers) {
-		xah = list_entry(p, struct reiserfs_xattr_handler, handlers);
-		if (xah->init) {
-			err = xah->init();
-			if (err) {
-				list_del_init(p);
-				break;
-			}
-		}
-	}
-
-	/* Clean up other handlers, if any failed */
-	if (err)
-		__unregister_handlers();
-
-	write_unlock(&handler_lock);
-	return err;
-}
-
-void reiserfs_xattr_unregister_handlers(void)
-{
-	write_lock(&handler_lock);
-	__unregister_handlers();
-	write_unlock(&handler_lock);
-}
-
 static int reiserfs_check_acl(struct inode *inode, int mask)
 {
 	struct posix_acl *acl;
@@ -1157,20 +1074,16 @@ static int xattr_mount_check(struct super_block *s)
 {
 	/* We need generation numbers to ensure that the oid mapping is correct
 	 * v3.5 filesystems don't have them. */
-	if (!old_format_only(s)) {
-		set_bit(REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
-	} else if (reiserfs_xattrs_optional(s)) {
-		/* Old format filesystem, but optional xattrs have been enabled
-		 * at mount time. Error out. */
-		reiserfs_warning(s, "jdm-20005",
-				 "xattrs/ACLs not supported on pre v3.6 "
-				 "format filesystem. Failing mount.");
-		return -EOPNOTSUPP;
-	} else {
-		/* Old format filesystem, but no optional xattrs have
-		 * been enabled. This means we silently disable xattrs
-		 * on the filesystem. */
-		clear_bit(REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
+	if (old_format_only(s)) {
+		if (reiserfs_xattrs_optional(s)) {
+			/* Old format filesystem, but optional xattrs have
+			 * been enabled. Error out. */
+			reiserfs_warning(s, "jdm-2005",
+					 "xattrs/ACLs not supported "
+					 "on pre-v3.6 format filesystems. "
+					 "Failing mount.");
+			return -EOPNOTSUPP;
+		}
 	}
 
 	return 0;
@@ -1251,9 +1164,11 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 	}
 
 #ifdef CONFIG_REISERFS_FS_XATTR
+	if (!err)
+		s->s_xattr = reiserfs_xattr_handlers;
+
 error:
 	if (err) {
-		clear_bit(REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
 		clear_bit(REISERFS_XATTRS_USER, &(REISERFS_SB(s)->s_mount_opt));
 		clear_bit(REISERFS_POSIXACL, &(REISERFS_SB(s)->s_mount_opt));
 	}

commit 8ecbe550a142fe604874afa477ea68986f89b86c
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:37 2009 -0400

    reiserfs: remove i_has_xattr_dir
    
    With the changes to xattr root locking, the i_has_xattr_dir flag
    is no longer needed. This patch removes it.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index ccb8e4d4c032..8d7e5d9ae17c 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -459,10 +459,7 @@ int reiserfs_delete_xattrs(struct inode *inode)
 
 	dput(root);
 out:
-	if (!err)
-		REISERFS_I(inode)->i_flags =
-		    REISERFS_I(inode)->i_flags & ~i_has_xattr_dir;
-	else
+	if (err)
 		reiserfs_warning(inode->i_sb, "jdm-20004",
 				 "Couldn't remove all xattrs (%d)\n", err);
 	return err;
@@ -660,7 +657,6 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	down_write(&REISERFS_I(inode)->i_xattr_sem);
 
 	xahash = xattr_hash(buffer, buffer_size);
-	REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
 
 	/* Resize it so we're ok to write there */
 	newattrs.ia_size = buffer_size;
@@ -769,7 +765,6 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 	down_read(&REISERFS_I(inode)->i_xattr_sem);
 
 	isize = i_size_read(dentry->d_inode);
-	REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
 
 	/* Just return the size needed */
 	if (buffer == NULL) {
@@ -999,8 +994,6 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 	buf.r_pos = 0;
 	buf.r_inode = dentry->d_inode;
 
-	REISERFS_I(dentry->d_inode)->i_flags |= i_has_xattr_dir;
-
 	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
 	err = xattr_readdir(dir->d_inode, reiserfs_listxattr_filler, &buf);
 	mutex_unlock(&dir->d_inode->i_mutex);

commit 8b6dd72a441a683cef7ace93de0a57ced4367f00
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:36 2009 -0400

    reiserfs: make per-inode xattr locking more fine grained
    
    The per-inode locking can be made more fine-grained to surround just the
    interaction with the filesystem itself.  This really only applies to
    protecting reads during a write, since concurrent writes are barred with
    inode->i_mutex at the vfs level.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 62c98829c545..ccb8e4d4c032 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -29,10 +29,8 @@
  * to the inode so that unnecessary lookups are avoided.
  *
  * Locking works like so:
- * The xattr root (/.reiserfs_priv/xattrs) is protected by its i_mutex.
- * The xattr dir (/.reiserfs_priv/xattrs/<oid>.<gen>) is protected by
- * inode->xattr_sem.
- * The xattrs themselves are likewise protected by the xattr_sem.
+ * Directory components (xattr root, xattr dir) are protectd by their i_mutex.
+ * The xattrs themselves are protected by the xattr_sem.
  */
 
 #include <linux/reiserfs_fs.h>
@@ -55,6 +53,8 @@
 #define PRIVROOT_NAME ".reiserfs_priv"
 #define XAROOT_NAME   "xattrs"
 
+static struct reiserfs_xattr_handler *find_xattr_handler_prefix(const char *);
+
 /* Helpers for inode ops. We do this so that we don't have all the VFS
  * overhead and also for proper i_mutex annotation.
  * dir->i_mutex must be held for all of them. */
@@ -339,12 +339,14 @@ int xattr_readdir(struct inode *inode, filldir_t filler, void *buf)
 	return res;
 }
 
+/* expects xadir->d_inode->i_mutex to be locked */
 static int
 __reiserfs_xattr_del(struct dentry *xadir, const char *name, int namelen)
 {
 	struct dentry *dentry;
 	struct inode *dir = xadir->d_inode;
 	int err = 0;
+	struct reiserfs_xattr_handler *xah;
 
 	dentry = lookup_one_len(name, xadir, namelen);
 	if (IS_ERR(dentry)) {
@@ -372,6 +374,14 @@ __reiserfs_xattr_del(struct dentry *xadir, const char *name, int namelen)
 		return -EIO;
 	}
 
+	/* Deletion pre-operation */
+	xah = find_xattr_handler_prefix(name);
+	if (xah && xah->del) {
+		err = xah->del(dentry->d_inode, name);
+		if (err)
+			goto out;
+	}
+
 	err = xattr_unlink(dir, dentry);
 
 out_file:
@@ -398,7 +408,7 @@ reiserfs_delete_xattrs_filler(void *buf, const char *name, int namelen,
 /* This is called w/ inode->i_mutex downed */
 int reiserfs_delete_xattrs(struct inode *inode)
 {
-	int err = 0;
+	int err = -ENODATA;
 	struct dentry *dir, *root;
 	struct reiserfs_transaction_handle th;
 	int blocks = JOURNAL_PER_BALANCE_CNT * 2 + 2 +
@@ -414,14 +424,19 @@ int reiserfs_delete_xattrs(struct inode *inode)
 		goto out;
 	} else if (!dir->d_inode) {
 		dput(dir);
-		return 0;
+		goto out;
 	}
 
 	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
 	err = xattr_readdir(dir->d_inode, reiserfs_delete_xattrs_filler, dir);
 	mutex_unlock(&dir->d_inode->i_mutex);
-	if (err)
-		goto out_dir;
+	if (err) {
+		dput(dir);
+		goto out;
+	}
+
+	root = dget(dir->d_parent);
+	dput(dir);
 
 	/* We start a transaction here to avoid a ABBA situation
 	 * between the xattr root's i_mutex and the journal lock.
@@ -435,19 +450,14 @@ int reiserfs_delete_xattrs(struct inode *inode)
 	err = journal_begin(&th, inode->i_sb, blocks);
 	if (!err) {
 		int jerror;
-		root = dget(dir->d_parent);
 		mutex_lock_nested(&root->d_inode->i_mutex, I_MUTEX_XATTR);
 		err = xattr_rmdir(root->d_inode, dir);
 		jerror = journal_end(&th, inode->i_sb, blocks);
 		mutex_unlock(&root->d_inode->i_mutex);
-		dput(root);
-
 		err = jerror ?: err;
 	}
 
-out_dir:
-	dput(dir);
-
+	dput(root);
 out:
 	if (!err)
 		REISERFS_I(inode)->i_flags =
@@ -484,7 +494,7 @@ reiserfs_chown_xattrs_filler(void *buf, const char *name, int namelen,
 
 	if (!S_ISDIR(xafile->d_inode->i_mode)) {
 		mutex_lock_nested(&xafile->d_inode->i_mutex, I_MUTEX_CHILD);
-		err = notify_change(xafile, attrs);
+		err = reiserfs_setattr(xafile, attrs);
 		mutex_unlock(&xafile->d_inode->i_mutex);
 	}
 	dput(xafile);
@@ -520,13 +530,16 @@ int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)
 	err = xattr_readdir(dir->d_inode, reiserfs_chown_xattrs_filler, &buf);
 
 	if (!err)
-		err = notify_change(dir, attrs);
+		err = reiserfs_setattr(dir, attrs);
 	mutex_unlock(&dir->d_inode->i_mutex);
 
 	attrs->ia_valid = ia_valid;
 out_dir:
 	dput(dir);
 out:
+	if (err)
+		reiserfs_warning(inode->i_sb, "jdm-20007",
+				 "Couldn't chown all xattrs (%d)\n", err);
 	return err;
 }
 
@@ -635,9 +648,8 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	if (get_inode_sd_version(inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	/* Empty xattrs are ok, they're just empty files, no hash */
-	if (buffer && buffer_size)
-		xahash = xattr_hash(buffer, buffer_size);
+	if (!buffer)
+		return reiserfs_xattr_del(inode, name);
 
 	dentry = get_xa_file_dentry(inode, name, flags);
 	if (IS_ERR(dentry)) {
@@ -645,13 +657,19 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 		goto out;
 	}
 
+	down_write(&REISERFS_I(inode)->i_xattr_sem);
+
+	xahash = xattr_hash(buffer, buffer_size);
 	REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
 
 	/* Resize it so we're ok to write there */
 	newattrs.ia_size = buffer_size;
+	newattrs.ia_ctime = current_fs_time(inode->i_sb);
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
 	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);
-	err = notify_change(dentry, &newattrs);
+	down_write(&dentry->d_inode->i_alloc_sem);
+	err = reiserfs_setattr(dentry, &newattrs);
+	up_write(&dentry->d_inode->i_alloc_sem);
 	mutex_unlock(&dentry->d_inode->i_mutex);
 	if (err)
 		goto out_filp;
@@ -712,6 +730,7 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	}
 
       out_filp:
+	up_write(&REISERFS_I(inode)->i_xattr_sem);
 	dput(dentry);
 
       out:
@@ -747,10 +766,7 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 		goto out;
 	}
 
-	/* protect against concurrent access. xattrs are backed by
-	 * regular files, but they're not regular files. The updates
-	 * must be atomic from the perspective of the user. */
-	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);
+	down_read(&REISERFS_I(inode)->i_xattr_sem);
 
 	isize = i_size_read(dentry->d_inode);
 	REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
@@ -758,12 +774,12 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 	/* Just return the size needed */
 	if (buffer == NULL) {
 		err = isize - sizeof(struct reiserfs_xattr_header);
-		goto out_dput;
+		goto out_unlock;
 	}
 
 	if (buffer_size < isize - sizeof(struct reiserfs_xattr_header)) {
 		err = -ERANGE;
-		goto out_dput;
+		goto out_unlock;
 	}
 
 	while (file_pos < isize) {
@@ -778,7 +794,7 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 		page = reiserfs_get_page(dentry->d_inode, file_pos);
 		if (IS_ERR(page)) {
 			err = PTR_ERR(page);
-			goto out_dput;
+			goto out_unlock;
 		}
 
 		lock_page(page);
@@ -797,7 +813,7 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 						 "associated with %k", name,
 						 INODE_PKEY(inode));
 				err = -EIO;
-				goto out_dput;
+				goto out_unlock;
 			}
 			hash = le32_to_cpu(rxh->h_hash);
 		}
@@ -818,8 +834,8 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 		err = -EIO;
 	}
 
-out_dput:
-	mutex_unlock(&dentry->d_inode->i_mutex);
+out_unlock:
+	up_read(&REISERFS_I(inode)->i_xattr_sem);
 	dput(dentry);
 
 out:
@@ -852,8 +868,6 @@ int reiserfs_xattr_del(struct inode *inode, const char *name)
 }
 
 /* Actual operations that are exported to VFS-land */
-
-static struct reiserfs_xattr_handler *find_xattr_handler_prefix(const char *);
 /*
  * Inode operation getxattr()
  */
@@ -868,9 +882,7 @@ reiserfs_getxattr(struct dentry * dentry, const char *name, void *buffer,
 	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	reiserfs_read_lock_xattr_i(dentry->d_inode);
 	err = xah->get(dentry->d_inode, name, buffer, size);
-	reiserfs_read_unlock_xattr_i(dentry->d_inode);
 	return err;
 }
 
@@ -890,9 +902,7 @@ reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	reiserfs_write_lock_xattr_i(dentry->d_inode);
 	err = xah->set(dentry->d_inode, name, value, size, flags);
-	reiserfs_write_unlock_xattr_i(dentry->d_inode);
 	return err;
 }
 
@@ -910,21 +920,11 @@ int reiserfs_removexattr(struct dentry *dentry, const char *name)
 	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	reiserfs_write_lock_xattr_i(dentry->d_inode);
-	/* Deletion pre-operation */
-	if (xah->del) {
-		err = xah->del(dentry->d_inode, name);
-		if (err)
-			goto out;
-	}
-
 	err = reiserfs_xattr_del(dentry->d_inode, name);
 
 	dentry->d_inode->i_ctime = CURRENT_TIME_SEC;
 	mark_inode_dirty(dentry->d_inode);
 
-      out:
-	reiserfs_write_unlock_xattr_i(dentry->d_inode);
 	return err;
 }
 
@@ -986,7 +986,6 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	reiserfs_read_lock_xattr_i(dentry->d_inode);
 	dir = open_xa_dir(dentry->d_inode, XATTR_REPLACE);
 	if (IS_ERR(dir)) {
 		err = PTR_ERR(dir);
@@ -1005,19 +1004,16 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
 	err = xattr_readdir(dir->d_inode, reiserfs_listxattr_filler, &buf);
 	mutex_unlock(&dir->d_inode->i_mutex);
-	if (err)
-		goto out_dir;
 
-	if (buf.r_pos > buf.r_size && buffer != NULL)
-		err = -ERANGE;
-	else
-		err = buf.r_pos;
+	if (!err) {
+		if (buf.r_pos > buf.r_size && buffer != NULL)
+			err = -ERANGE;
+		else
+			err = buf.r_pos;
+	}
 
-      out_dir:
 	dput(dir);
-
-      out:
-	reiserfs_read_unlock_xattr_i(dentry->d_inode);
+out:
 	return err;
 }
 
@@ -1115,12 +1111,8 @@ static int reiserfs_check_acl(struct inode *inode, int mask)
 	struct posix_acl *acl;
 	int error = -EAGAIN; /* do regular unix permission checks by default */
 
-	reiserfs_read_lock_xattr_i(inode);
-
 	acl = reiserfs_get_acl(inode, ACL_TYPE_ACCESS);
 
-	reiserfs_read_unlock_xattr_i(inode);
-
 	if (acl) {
 		if (!IS_ERR(acl)) {
 			error = posix_acl_permission(inode, acl, mask);

commit d984561b326cd0fe0d1183d11b9b4fa1d011d21d
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:35 2009 -0400

    reiserfs: eliminate per-super xattr lock
    
    With the switch to using inode->i_mutex locking during lookups/creation
    in the xattr root, the per-super xattr lock is no longer needed.
    
    This patch removes it.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 57920a4df7a4..62c98829c545 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -27,6 +27,12 @@
  * these are special cases for filesystem ACLs, they are interpreted by the
  * kernel, in addition, they are negatively and positively cached and attached
  * to the inode so that unnecessary lookups are avoided.
+ *
+ * Locking works like so:
+ * The xattr root (/.reiserfs_priv/xattrs) is protected by its i_mutex.
+ * The xattr dir (/.reiserfs_priv/xattrs/<oid>.<gen>) is protected by
+ * inode->xattr_sem.
+ * The xattrs themselves are likewise protected by the xattr_sem.
  */
 
 #include <linux/reiserfs_fs.h>
@@ -392,16 +398,17 @@ reiserfs_delete_xattrs_filler(void *buf, const char *name, int namelen,
 /* This is called w/ inode->i_mutex downed */
 int reiserfs_delete_xattrs(struct inode *inode)
 {
-	struct dentry *dir, *root;
 	int err = 0;
+	struct dentry *dir, *root;
+	struct reiserfs_transaction_handle th;
+	int blocks = JOURNAL_PER_BALANCE_CNT * 2 + 2 +
+		     4 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);
 
 	/* Skip out, an xattr has no xattrs associated with it */
 	if (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1)
 		return 0;
 
-	reiserfs_read_lock_xattrs(inode->i_sb);
 	dir = open_xa_dir(inode, XATTR_REPLACE);
-	reiserfs_read_unlock_xattrs(inode->i_sb);
 	if (IS_ERR(dir)) {
 		err = PTR_ERR(dir);
 		goto out;
@@ -416,18 +423,26 @@ int reiserfs_delete_xattrs(struct inode *inode)
 	if (err)
 		goto out_dir;
 
-	/* Leftovers besides . and .. -- that's not good. */
-	if (dir->d_inode->i_nlink <= 2) {
-		root = open_xa_root(inode->i_sb, XATTR_REPLACE);
-		reiserfs_write_lock_xattrs(inode->i_sb);
+	/* We start a transaction here to avoid a ABBA situation
+	 * between the xattr root's i_mutex and the journal lock.
+	 * Inode creation will inherit an ACL, which requires a
+	 * lookup. The lookup locks the xattr root i_mutex with a
+	 * transaction open.  Inode deletion takes teh xattr root
+	 * i_mutex to delete the directory and then starts a
+	 * transaction inside it. Boom. This doesn't incur much
+	 * additional overhead since the reiserfs_rmdir transaction
+	 * will just nest inside the outer transaction. */
+	err = journal_begin(&th, inode->i_sb, blocks);
+	if (!err) {
+		int jerror;
+		root = dget(dir->d_parent);
 		mutex_lock_nested(&root->d_inode->i_mutex, I_MUTEX_XATTR);
 		err = xattr_rmdir(root->d_inode, dir);
+		jerror = journal_end(&th, inode->i_sb, blocks);
 		mutex_unlock(&root->d_inode->i_mutex);
-		reiserfs_write_unlock_xattrs(inode->i_sb);
 		dput(root);
-	} else {
-		reiserfs_warning(inode->i_sb, "jdm-20006",
-				 "Couldn't remove all entries in directory");
+
+		err = jerror ?: err;
 	}
 
 out_dir:
@@ -437,6 +452,9 @@ int reiserfs_delete_xattrs(struct inode *inode)
 	if (!err)
 		REISERFS_I(inode)->i_flags =
 		    REISERFS_I(inode)->i_flags & ~i_has_xattr_dir;
+	else
+		reiserfs_warning(inode->i_sb, "jdm-20004",
+				 "Couldn't remove all xattrs (%d)\n", err);
 	return err;
 }
 
@@ -485,9 +503,7 @@ int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)
 	if (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1)
 		return 0;
 
-	reiserfs_read_lock_xattrs(inode->i_sb);
 	dir = open_xa_dir(inode, XATTR_REPLACE);
-	reiserfs_read_unlock_xattrs(inode->i_sb);
 	if (IS_ERR(dir)) {
 		if (PTR_ERR(dir) != -ENODATA)
 			err = PTR_ERR(dir);
@@ -731,6 +747,11 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 		goto out;
 	}
 
+	/* protect against concurrent access. xattrs are backed by
+	 * regular files, but they're not regular files. The updates
+	 * must be atomic from the perspective of the user. */
+	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);
+
 	isize = i_size_read(dentry->d_inode);
 	REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
 
@@ -798,6 +819,7 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 	}
 
 out_dput:
+	mutex_unlock(&dentry->d_inode->i_mutex);
 	dput(dentry);
 
 out:
@@ -834,7 +856,6 @@ int reiserfs_xattr_del(struct inode *inode, const char *name)
 static struct reiserfs_xattr_handler *find_xattr_handler_prefix(const char *);
 /*
  * Inode operation getxattr()
- * Preliminary locking: we down dentry->d_inode->i_mutex
  */
 ssize_t
 reiserfs_getxattr(struct dentry * dentry, const char *name, void *buffer,
@@ -848,9 +869,7 @@ reiserfs_getxattr(struct dentry * dentry, const char *name, void *buffer,
 		return -EOPNOTSUPP;
 
 	reiserfs_read_lock_xattr_i(dentry->d_inode);
-	reiserfs_read_lock_xattrs(dentry->d_sb);
 	err = xah->get(dentry->d_inode, name, buffer, size);
-	reiserfs_read_unlock_xattrs(dentry->d_sb);
 	reiserfs_read_unlock_xattr_i(dentry->d_inode);
 	return err;
 }
@@ -866,23 +885,13 @@ reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 {
 	struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix(name);
 	int err;
-	int lock;
 
 	if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
 	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
 	reiserfs_write_lock_xattr_i(dentry->d_inode);
-	lock = !has_xattr_dir(dentry->d_inode);
-	if (lock)
-		reiserfs_write_lock_xattrs(dentry->d_sb);
-	else
-		reiserfs_read_lock_xattrs(dentry->d_sb);
 	err = xah->set(dentry->d_inode, name, value, size, flags);
-	if (lock)
-		reiserfs_write_unlock_xattrs(dentry->d_sb);
-	else
-		reiserfs_read_unlock_xattrs(dentry->d_sb);
 	reiserfs_write_unlock_xattr_i(dentry->d_inode);
 	return err;
 }
@@ -902,8 +911,6 @@ int reiserfs_removexattr(struct dentry *dentry, const char *name)
 		return -EOPNOTSUPP;
 
 	reiserfs_write_lock_xattr_i(dentry->d_inode);
-	reiserfs_read_lock_xattrs(dentry->d_sb);
-
 	/* Deletion pre-operation */
 	if (xah->del) {
 		err = xah->del(dentry->d_inode, name);
@@ -917,7 +924,6 @@ int reiserfs_removexattr(struct dentry *dentry, const char *name)
 	mark_inode_dirty(dentry->d_inode);
 
       out:
-	reiserfs_read_unlock_xattrs(dentry->d_sb);
 	reiserfs_write_unlock_xattr_i(dentry->d_inode);
 	return err;
 }
@@ -966,8 +972,6 @@ reiserfs_listxattr_filler(void *buf, const char *name, int namelen,
 
 /*
  * Inode operation listxattr()
- *
- * Preliminary locking: we down dentry->d_inode->i_mutex
  */
 ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 {
@@ -983,9 +987,7 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 		return -EOPNOTSUPP;
 
 	reiserfs_read_lock_xattr_i(dentry->d_inode);
-	reiserfs_read_lock_xattrs(dentry->d_sb);
 	dir = open_xa_dir(dentry->d_inode, XATTR_REPLACE);
-	reiserfs_read_unlock_xattrs(dentry->d_sb);
 	if (IS_ERR(dir)) {
 		err = PTR_ERR(dir);
 		if (err == -ENODATA)
@@ -1114,11 +1116,9 @@ static int reiserfs_check_acl(struct inode *inode, int mask)
 	int error = -EAGAIN; /* do regular unix permission checks by default */
 
 	reiserfs_read_lock_xattr_i(inode);
-	reiserfs_read_lock_xattrs(inode->i_sb);
 
 	acl = reiserfs_get_acl(inode, ACL_TYPE_ACCESS);
 
-	reiserfs_read_unlock_xattrs(inode->i_sb);
 	reiserfs_read_unlock_xattr_i(inode);
 
 	if (acl) {

commit 6c17675e1e02ebde220ef639a3fb1333928ec2f4
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:34 2009 -0400

    reiserfs: simplify xattr internal file lookups/opens
    
    The xattr file open/lookup code is needlessly complex.  We can use
    vfs-level operations to perform the same work, and also simplify the
    locking constraints.  The locking advantages will be exploited in future
    patches.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index f9bcdd5750f7..57920a4df7a4 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -44,100 +44,123 @@
 #include <net/checksum.h>
 #include <linux/smp_lock.h>
 #include <linux/stat.h>
+#include <linux/quotaops.h>
 
-#define FL_READONLY 128
-#define FL_DIR_SEM_HELD 256
 #define PRIVROOT_NAME ".reiserfs_priv"
 #define XAROOT_NAME   "xattrs"
 
-/* Returns the dentry referring to the root of the extended attribute
- * directory tree. If it has already been retrieved, it is used. If it
- * hasn't been created and the flags indicate creation is allowed, we
- * attempt to create it. On error, we return a pointer-encoded error.
- */
-static struct dentry *get_xa_root(struct super_block *sb, int flags)
+/* Helpers for inode ops. We do this so that we don't have all the VFS
+ * overhead and also for proper i_mutex annotation.
+ * dir->i_mutex must be held for all of them. */
+static int xattr_create(struct inode *dir, struct dentry *dentry, int mode)
 {
-	struct dentry *privroot = dget(REISERFS_SB(sb)->priv_root);
-	struct dentry *xaroot;
+	BUG_ON(!mutex_is_locked(&dir->i_mutex));
+	DQUOT_INIT(dir);
+	return dir->i_op->create(dir, dentry, mode, NULL);
+}
 
-	/* This needs to be created at mount-time */
-	if (!privroot)
-		return ERR_PTR(-ENODATA);
+static int xattr_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	BUG_ON(!mutex_is_locked(&dir->i_mutex));
+	DQUOT_INIT(dir);
+	return dir->i_op->mkdir(dir, dentry, mode);
+}
 
-	mutex_lock_nested(&privroot->d_inode->i_mutex, I_MUTEX_XATTR);
-	if (REISERFS_SB(sb)->xattr_root) {
-		xaroot = dget(REISERFS_SB(sb)->xattr_root);
-		goto out;
-	}
+/* We use I_MUTEX_CHILD here to silence lockdep. It's safe because xattr
+ * mutation ops aren't called during rename or splace, which are the
+ * only other users of I_MUTEX_CHILD. It violates the ordering, but that's
+ * better than allocating another subclass just for this code. */
+static int xattr_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int error;
+	BUG_ON(!mutex_is_locked(&dir->i_mutex));
+	DQUOT_INIT(dir);
 
-	xaroot = lookup_one_len(XAROOT_NAME, privroot, strlen(XAROOT_NAME));
-	if (IS_ERR(xaroot)) {
-		goto out;
-	} else if (!xaroot->d_inode) {
+	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);
+	error = dir->i_op->unlink(dir, dentry);
+	mutex_unlock(&dentry->d_inode->i_mutex);
+
+	if (!error)
+		d_delete(dentry);
+	return error;
+}
+
+static int xattr_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	int error;
+	BUG_ON(!mutex_is_locked(&dir->i_mutex));
+	DQUOT_INIT(dir);
+
+	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);
+	dentry_unhash(dentry);
+	error = dir->i_op->rmdir(dir, dentry);
+	if (!error)
+		dentry->d_inode->i_flags |= S_DEAD;
+	mutex_unlock(&dentry->d_inode->i_mutex);
+	if (!error)
+		d_delete(dentry);
+	dput(dentry);
+
+	return error;
+}
+
+
+#define xattr_may_create(flags)	(!flags || flags & XATTR_CREATE)
+
+/* Returns and possibly creates the xattr dir. */
+static struct dentry *lookup_or_create_dir(struct dentry *parent,
+					    const char *name, int flags)
+{
+	struct dentry *dentry;
+	BUG_ON(!parent);
+
+	dentry = lookup_one_len(name, parent, strlen(name));
+	if (IS_ERR(dentry))
+		return dentry;
+	else if (!dentry->d_inode) {
 		int err = -ENODATA;
-		if (flags == 0 || flags & XATTR_CREATE)
-			err = privroot->d_inode->i_op->mkdir(privroot->d_inode,
-			                                     xaroot, 0700);
+
+		if (xattr_may_create(flags)) {
+			mutex_lock_nested(&parent->d_inode->i_mutex,
+					  I_MUTEX_XATTR);
+			err = xattr_mkdir(parent->d_inode, dentry, 0700);
+			mutex_unlock(&parent->d_inode->i_mutex);
+		}
+
 		if (err) {
-			dput(xaroot);
-			xaroot = ERR_PTR(err);
-			goto out;
+			dput(dentry);
+			dentry = ERR_PTR(err);
 		}
 	}
-	REISERFS_SB(sb)->xattr_root = dget(xaroot);
 
-      out:
-	mutex_unlock(&privroot->d_inode->i_mutex);
-	dput(privroot);
-	return xaroot;
+	return dentry;
+}
+
+static struct dentry *open_xa_root(struct super_block *sb, int flags)
+{
+	struct dentry *privroot = REISERFS_SB(sb)->priv_root;
+	if (!privroot)
+		return ERR_PTR(-ENODATA);
+	return lookup_or_create_dir(privroot, XAROOT_NAME, flags);
 }
 
-/* Opens the directory corresponding to the inode's extended attribute store.
- * If flags allow, the tree to the directory may be created. If creation is
- * prohibited, -ENODATA is returned. */
 static struct dentry *open_xa_dir(const struct inode *inode, int flags)
 {
 	struct dentry *xaroot, *xadir;
 	char namebuf[17];
 
-	xaroot = get_xa_root(inode->i_sb, flags);
+	xaroot = open_xa_root(inode->i_sb, flags);
 	if (IS_ERR(xaroot))
 		return xaroot;
 
-	/* ok, we have xaroot open */
 	snprintf(namebuf, sizeof(namebuf), "%X.%X",
 		 le32_to_cpu(INODE_PKEY(inode)->k_objectid),
 		 inode->i_generation);
-	xadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));
-	if (IS_ERR(xadir)) {
-		dput(xaroot);
-		return xadir;
-	}
-
-	if (!xadir->d_inode) {
-		int err;
-		if (flags == 0 || flags & XATTR_CREATE) {
-			/* Although there is nothing else trying to create this directory,
-			 * another directory with the same hash may be created, so we need
-			 * to protect against that */
-			err =
-			    xaroot->d_inode->i_op->mkdir(xaroot->d_inode, xadir,
-							 0700);
-			if (err) {
-				dput(xaroot);
-				dput(xadir);
-				return ERR_PTR(err);
-			}
-		}
-		if (!xadir->d_inode) {
-			dput(xaroot);
-			dput(xadir);
-			return ERR_PTR(-ENODATA);
-		}
-	}
 
+	xadir = lookup_or_create_dir(xaroot, namebuf, flags);
 	dput(xaroot);
 	return xadir;
+
 }
 
 /*
@@ -302,13 +325,11 @@ static
 int xattr_readdir(struct inode *inode, filldir_t filler, void *buf)
 {
 	int res = -ENOENT;
-	mutex_lock_nested(&inode->i_mutex, I_MUTEX_XATTR);
 	if (!IS_DEADDIR(inode)) {
 		lock_kernel();
 		res = __xattr_readdir(inode, buf, filler);
 		unlock_kernel();
 	}
-	mutex_unlock(&inode->i_mutex);
 	return res;
 }
 
@@ -345,9 +366,7 @@ __reiserfs_xattr_del(struct dentry *xadir, const char *name, int namelen)
 		return -EIO;
 	}
 
-	err = dir->i_op->unlink(dir, dentry);
-	if (!err)
-		d_delete(dentry);
+	err = xattr_unlink(dir, dentry);
 
 out_file:
 	dput(dentry);
@@ -381,7 +400,7 @@ int reiserfs_delete_xattrs(struct inode *inode)
 		return 0;
 
 	reiserfs_read_lock_xattrs(inode->i_sb);
-	dir = open_xa_dir(inode, FL_READONLY);
+	dir = open_xa_dir(inode, XATTR_REPLACE);
 	reiserfs_read_unlock_xattrs(inode->i_sb);
 	if (IS_ERR(dir)) {
 		err = PTR_ERR(dir);
@@ -391,25 +410,25 @@ int reiserfs_delete_xattrs(struct inode *inode)
 		return 0;
 	}
 
-	lock_kernel();
+	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
 	err = xattr_readdir(dir->d_inode, reiserfs_delete_xattrs_filler, dir);
-	if (err) {
-		unlock_kernel();
+	mutex_unlock(&dir->d_inode->i_mutex);
+	if (err)
 		goto out_dir;
-	}
 
 	/* Leftovers besides . and .. -- that's not good. */
 	if (dir->d_inode->i_nlink <= 2) {
-		root = get_xa_root(inode->i_sb, XATTR_REPLACE);
+		root = open_xa_root(inode->i_sb, XATTR_REPLACE);
 		reiserfs_write_lock_xattrs(inode->i_sb);
-		err = vfs_rmdir(root->d_inode, dir);
+		mutex_lock_nested(&root->d_inode->i_mutex, I_MUTEX_XATTR);
+		err = xattr_rmdir(root->d_inode, dir);
+		mutex_unlock(&root->d_inode->i_mutex);
 		reiserfs_write_unlock_xattrs(inode->i_sb);
 		dput(root);
 	} else {
 		reiserfs_warning(inode->i_sb, "jdm-20006",
 				 "Couldn't remove all entries in directory");
 	}
-	unlock_kernel();
 
 out_dir:
 	dput(dir);
@@ -445,8 +464,11 @@ reiserfs_chown_xattrs_filler(void *buf, const char *name, int namelen,
 		return -ENODATA;
 	}
 
-	if (!S_ISDIR(xafile->d_inode->i_mode))
+	if (!S_ISDIR(xafile->d_inode->i_mode)) {
+		mutex_lock_nested(&xafile->d_inode->i_mutex, I_MUTEX_CHILD);
 		err = notify_change(xafile, attrs);
+		mutex_unlock(&xafile->d_inode->i_mutex);
+	}
 	dput(xafile);
 
 	return err;
@@ -464,38 +486,31 @@ int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)
 		return 0;
 
 	reiserfs_read_lock_xattrs(inode->i_sb);
-	dir = open_xa_dir(inode, FL_READONLY);
+	dir = open_xa_dir(inode, XATTR_REPLACE);
 	reiserfs_read_unlock_xattrs(inode->i_sb);
 	if (IS_ERR(dir)) {
 		if (PTR_ERR(dir) != -ENODATA)
 			err = PTR_ERR(dir);
 		goto out;
-	} else if (!dir->d_inode) {
-		dput(dir);
-		goto out;
-	}
-
-	lock_kernel();
+	} else if (!dir->d_inode)
+		goto out_dir;
 
 	attrs->ia_valid &= (ATTR_UID | ATTR_GID | ATTR_CTIME);
 	buf.xadir = dir;
 	buf.attrs = attrs;
 	buf.inode = inode;
 
+	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
 	err = xattr_readdir(dir->d_inode, reiserfs_chown_xattrs_filler, &buf);
-	if (err) {
-		unlock_kernel();
-		goto out_dir;
-	}
 
-	err = notify_change(dir, attrs);
-	unlock_kernel();
+	if (!err)
+		err = notify_change(dir, attrs);
+	mutex_unlock(&dir->d_inode->i_mutex);
 
+	attrs->ia_valid = ia_valid;
 out_dir:
 	dput(dir);
-
 out:
-	attrs->ia_valid = ia_valid;
 	return err;
 }
 
@@ -513,47 +528,35 @@ static struct dentry *get_xa_file_dentry(const struct inode *inode,
 	int err = 0;
 
 	xadir = open_xa_dir(inode, flags);
-	if (IS_ERR(xadir)) {
+	if (IS_ERR(xadir))
 		return ERR_CAST(xadir);
-	} else if (xadir && !xadir->d_inode) {
-		dput(xadir);
-		return ERR_PTR(-ENODATA);
-	}
 
 	xafile = lookup_one_len(name, xadir, strlen(name));
 	if (IS_ERR(xafile)) {
-		dput(xadir);
-		return ERR_CAST(xafile);
+		err = PTR_ERR(xafile);
+		goto out;
 	}
 
-	if (xafile->d_inode) {	/* file exists */
-		if (flags & XATTR_CREATE) {
-			err = -EEXIST;
-			dput(xafile);
-			goto out;
-		}
-	} else if (flags & XATTR_REPLACE || flags & FL_READONLY) {
-		goto out;
-	} else {
-		/* inode->i_mutex is down, so nothing else can try to create
-		 * the same xattr */
-		err = xadir->d_inode->i_op->create(xadir->d_inode, xafile,
-						   0700 | S_IFREG, NULL);
+	if (xafile->d_inode && (flags & XATTR_CREATE))
+		err = -EEXIST;
 
-		if (err) {
-			dput(xafile);
-			goto out;
+	if (!xafile->d_inode) {
+		err = -ENODATA;
+		if (xattr_may_create(flags)) {
+			mutex_lock_nested(&xadir->d_inode->i_mutex,
+					  I_MUTEX_XATTR);
+			err = xattr_create(xadir->d_inode, xafile,
+					      0700|S_IFREG);
+			mutex_unlock(&xadir->d_inode->i_mutex);
 		}
 	}
 
+	if (err)
+		dput(xafile);
 out:
 	dput(xadir);
 	if (err)
-		xafile = ERR_PTR(err);
-	else if (!xafile->d_inode) {
-		dput(xafile);
-		xafile = ERR_PTR(-ENODATA);
-	}
+		return ERR_PTR(err);
 	return xafile;
 }
 
@@ -633,6 +636,7 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
 	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);
 	err = notify_change(dentry, &newattrs);
+	mutex_unlock(&dentry->d_inode->i_mutex);
 	if (err)
 		goto out_filp;
 
@@ -692,7 +696,6 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	}
 
       out_filp:
-	mutex_unlock(&dentry->d_inode->i_mutex);
 	dput(dentry);
 
       out:
@@ -722,7 +725,7 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 	if (get_inode_sd_version(inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	dentry = get_xa_file_dentry(inode, name, FL_READONLY);
+	dentry = get_xa_file_dentry(inode, name, XATTR_REPLACE);
 	if (IS_ERR(dentry)) {
 		err = PTR_ERR(dentry);
 		goto out;
@@ -806,13 +809,15 @@ int reiserfs_xattr_del(struct inode *inode, const char *name)
 	struct dentry *dir;
 	int err;
 
-	dir = open_xa_dir(inode, FL_READONLY);
+	dir = open_xa_dir(inode, XATTR_REPLACE);
 	if (IS_ERR(dir)) {
 		err = PTR_ERR(dir);
 		goto out;
 	}
 
+	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
 	err = __reiserfs_xattr_del(dir, name, strlen(name));
+	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(dir);
 
 	if (!err) {
@@ -826,6 +831,7 @@ int reiserfs_xattr_del(struct inode *inode, const char *name)
 
 /* Actual operations that are exported to VFS-land */
 
+static struct reiserfs_xattr_handler *find_xattr_handler_prefix(const char *);
 /*
  * Inode operation getxattr()
  * Preliminary locking: we down dentry->d_inode->i_mutex
@@ -978,7 +984,7 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 
 	reiserfs_read_lock_xattr_i(dentry->d_inode);
 	reiserfs_read_lock_xattrs(dentry->d_sb);
-	dir = open_xa_dir(dentry->d_inode, FL_READONLY);
+	dir = open_xa_dir(dentry->d_inode, XATTR_REPLACE);
 	reiserfs_read_unlock_xattrs(dentry->d_sb);
 	if (IS_ERR(dir)) {
 		err = PTR_ERR(dir);
@@ -994,7 +1000,9 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 
 	REISERFS_I(dentry->d_inode)->i_flags |= i_has_xattr_dir;
 
+	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
 	err = xattr_readdir(dir->d_inode, reiserfs_listxattr_filler, &buf);
+	mutex_unlock(&dir->d_inode->i_mutex);
 	if (err)
 		goto out_dir;
 
@@ -1146,7 +1154,7 @@ static int create_privroot(struct dentry *dentry)
 	int err;
 	struct inode *inode = dentry->d_parent->d_inode;
 	mutex_lock_nested(&inode->i_mutex, I_MUTEX_XATTR);
-	err = inode->i_op->mkdir(inode, dentry, 0700);
+	err = xattr_mkdir(inode, dentry, 0700);
 	mutex_unlock(&inode->i_mutex);
 	if (err) {
 		dput(dentry);

commit a72bdb1cd244725ff47b3a29662e2cb820d8c60f
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:33 2009 -0400

    reiserfs: Clean up xattrs when REISERFS_FS_XATTR is unset
    
    The current reiserfs xattr implementation will not clean up old xattr
    files if files are deleted when REISERFS_FS_XATTR is unset.  This
    results in inaccessible lost files, wasting space.
    
    This patch compiles in basic xattr knowledge, such as how to delete them
    and change ownership for quota tracking.  If the file system has never
    used xattrs, then the operation is quite fast: it returns immediately
    when it sees there is no .reiserfs_priv directory.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index c5fc207e529c..f9bcdd5750f7 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -50,9 +50,6 @@
 #define PRIVROOT_NAME ".reiserfs_priv"
 #define XAROOT_NAME   "xattrs"
 
-static struct reiserfs_xattr_handler *find_xattr_handler_prefix(const char
-								*prefix);
-
 /* Returns the dentry referring to the root of the extended attribute
  * directory tree. If it has already been retrieved, it is used. If it
  * hasn't been created and the flags indicate creation is allowed, we
@@ -143,60 +140,6 @@ static struct dentry *open_xa_dir(const struct inode *inode, int flags)
 	return xadir;
 }
 
-/* Returns a dentry corresponding to a specific extended attribute file
- * for the inode. If flags allow, the file is created. Otherwise, a
- * valid or negative dentry, or an error is returned. */
-static struct dentry *get_xa_file_dentry(const struct inode *inode,
-					 const char *name, int flags)
-{
-	struct dentry *xadir, *xafile;
-	int err = 0;
-
-	xadir = open_xa_dir(inode, flags);
-	if (IS_ERR(xadir)) {
-		return ERR_CAST(xadir);
-	} else if (!xadir->d_inode) {
-		dput(xadir);
-		return ERR_PTR(-ENODATA);
-	}
-
-	xafile = lookup_one_len(name, xadir, strlen(name));
-	if (IS_ERR(xafile)) {
-		dput(xadir);
-		return ERR_CAST(xafile);
-	}
-
-	if (xafile->d_inode) {	/* file exists */
-		if (flags & XATTR_CREATE) {
-			err = -EEXIST;
-			dput(xafile);
-			goto out;
-		}
-	} else if (flags & XATTR_REPLACE || flags & FL_READONLY) {
-		goto out;
-	} else {
-		/* inode->i_mutex is down, so nothing else can try to create
-		 * the same xattr */
-		err = xadir->d_inode->i_op->create(xadir->d_inode, xafile,
-						   0700 | S_IFREG, NULL);
-
-		if (err) {
-			dput(xafile);
-			goto out;
-		}
-	}
-
-      out:
-	dput(xadir);
-	if (err)
-		xafile = ERR_PTR(err);
-	else if (!xafile->d_inode) {
-		dput(xafile);
-		xafile = ERR_PTR(-ENODATA);
-	}
-	return xafile;
-}
-
 /*
  * this is very similar to fs/reiserfs/dir.c:reiserfs_readdir, but
  * we need to drop the path before calling the filldir struct.  That
@@ -369,6 +312,251 @@ int xattr_readdir(struct inode *inode, filldir_t filler, void *buf)
 	return res;
 }
 
+static int
+__reiserfs_xattr_del(struct dentry *xadir, const char *name, int namelen)
+{
+	struct dentry *dentry;
+	struct inode *dir = xadir->d_inode;
+	int err = 0;
+
+	dentry = lookup_one_len(name, xadir, namelen);
+	if (IS_ERR(dentry)) {
+		err = PTR_ERR(dentry);
+		goto out;
+	} else if (!dentry->d_inode) {
+		err = -ENODATA;
+		goto out_file;
+	}
+
+	/* Skip directories.. */
+	if (S_ISDIR(dentry->d_inode->i_mode))
+		goto out_file;
+
+	if (!IS_PRIVATE(dentry->d_inode)) {
+		reiserfs_error(dir->i_sb, "jdm-20003",
+			       "OID %08x [%.*s/%.*s] doesn't have "
+			       "priv flag set [parent is %sset].",
+			       le32_to_cpu(INODE_PKEY(dentry->d_inode)->
+					   k_objectid), xadir->d_name.len,
+			       xadir->d_name.name, namelen, name,
+			       IS_PRIVATE(xadir->d_inode) ? "" :
+			       "not ");
+		dput(dentry);
+		return -EIO;
+	}
+
+	err = dir->i_op->unlink(dir, dentry);
+	if (!err)
+		d_delete(dentry);
+
+out_file:
+	dput(dentry);
+
+out:
+	return err;
+}
+
+/* The following are side effects of other operations that aren't explicitly
+ * modifying extended attributes. This includes operations such as permissions
+ * or ownership changes, object deletions, etc. */
+
+static int
+reiserfs_delete_xattrs_filler(void *buf, const char *name, int namelen,
+			      loff_t offset, u64 ino, unsigned int d_type)
+{
+	struct dentry *xadir = (struct dentry *)buf;
+
+	return __reiserfs_xattr_del(xadir, name, namelen);
+
+}
+
+/* This is called w/ inode->i_mutex downed */
+int reiserfs_delete_xattrs(struct inode *inode)
+{
+	struct dentry *dir, *root;
+	int err = 0;
+
+	/* Skip out, an xattr has no xattrs associated with it */
+	if (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1)
+		return 0;
+
+	reiserfs_read_lock_xattrs(inode->i_sb);
+	dir = open_xa_dir(inode, FL_READONLY);
+	reiserfs_read_unlock_xattrs(inode->i_sb);
+	if (IS_ERR(dir)) {
+		err = PTR_ERR(dir);
+		goto out;
+	} else if (!dir->d_inode) {
+		dput(dir);
+		return 0;
+	}
+
+	lock_kernel();
+	err = xattr_readdir(dir->d_inode, reiserfs_delete_xattrs_filler, dir);
+	if (err) {
+		unlock_kernel();
+		goto out_dir;
+	}
+
+	/* Leftovers besides . and .. -- that's not good. */
+	if (dir->d_inode->i_nlink <= 2) {
+		root = get_xa_root(inode->i_sb, XATTR_REPLACE);
+		reiserfs_write_lock_xattrs(inode->i_sb);
+		err = vfs_rmdir(root->d_inode, dir);
+		reiserfs_write_unlock_xattrs(inode->i_sb);
+		dput(root);
+	} else {
+		reiserfs_warning(inode->i_sb, "jdm-20006",
+				 "Couldn't remove all entries in directory");
+	}
+	unlock_kernel();
+
+out_dir:
+	dput(dir);
+
+out:
+	if (!err)
+		REISERFS_I(inode)->i_flags =
+		    REISERFS_I(inode)->i_flags & ~i_has_xattr_dir;
+	return err;
+}
+
+struct reiserfs_chown_buf {
+	struct inode *inode;
+	struct dentry *xadir;
+	struct iattr *attrs;
+};
+
+/* XXX: If there is a better way to do this, I'd love to hear about it */
+static int
+reiserfs_chown_xattrs_filler(void *buf, const char *name, int namelen,
+			     loff_t offset, u64 ino, unsigned int d_type)
+{
+	struct reiserfs_chown_buf *chown_buf = (struct reiserfs_chown_buf *)buf;
+	struct dentry *xafile, *xadir = chown_buf->xadir;
+	struct iattr *attrs = chown_buf->attrs;
+	int err = 0;
+
+	xafile = lookup_one_len(name, xadir, namelen);
+	if (IS_ERR(xafile))
+		return PTR_ERR(xafile);
+	else if (!xafile->d_inode) {
+		dput(xafile);
+		return -ENODATA;
+	}
+
+	if (!S_ISDIR(xafile->d_inode->i_mode))
+		err = notify_change(xafile, attrs);
+	dput(xafile);
+
+	return err;
+}
+
+int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)
+{
+	struct dentry *dir;
+	int err = 0;
+	struct reiserfs_chown_buf buf;
+	unsigned int ia_valid = attrs->ia_valid;
+
+	/* Skip out, an xattr has no xattrs associated with it */
+	if (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1)
+		return 0;
+
+	reiserfs_read_lock_xattrs(inode->i_sb);
+	dir = open_xa_dir(inode, FL_READONLY);
+	reiserfs_read_unlock_xattrs(inode->i_sb);
+	if (IS_ERR(dir)) {
+		if (PTR_ERR(dir) != -ENODATA)
+			err = PTR_ERR(dir);
+		goto out;
+	} else if (!dir->d_inode) {
+		dput(dir);
+		goto out;
+	}
+
+	lock_kernel();
+
+	attrs->ia_valid &= (ATTR_UID | ATTR_GID | ATTR_CTIME);
+	buf.xadir = dir;
+	buf.attrs = attrs;
+	buf.inode = inode;
+
+	err = xattr_readdir(dir->d_inode, reiserfs_chown_xattrs_filler, &buf);
+	if (err) {
+		unlock_kernel();
+		goto out_dir;
+	}
+
+	err = notify_change(dir, attrs);
+	unlock_kernel();
+
+out_dir:
+	dput(dir);
+
+out:
+	attrs->ia_valid = ia_valid;
+	return err;
+}
+
+#ifdef CONFIG_REISERFS_FS_XATTR
+static struct reiserfs_xattr_handler *find_xattr_handler_prefix(const char
+								*prefix);
+
+/* Returns a dentry corresponding to a specific extended attribute file
+ * for the inode. If flags allow, the file is created. Otherwise, a
+ * valid or negative dentry, or an error is returned. */
+static struct dentry *get_xa_file_dentry(const struct inode *inode,
+					 const char *name, int flags)
+{
+	struct dentry *xadir, *xafile;
+	int err = 0;
+
+	xadir = open_xa_dir(inode, flags);
+	if (IS_ERR(xadir)) {
+		return ERR_CAST(xadir);
+	} else if (xadir && !xadir->d_inode) {
+		dput(xadir);
+		return ERR_PTR(-ENODATA);
+	}
+
+	xafile = lookup_one_len(name, xadir, strlen(name));
+	if (IS_ERR(xafile)) {
+		dput(xadir);
+		return ERR_CAST(xafile);
+	}
+
+	if (xafile->d_inode) {	/* file exists */
+		if (flags & XATTR_CREATE) {
+			err = -EEXIST;
+			dput(xafile);
+			goto out;
+		}
+	} else if (flags & XATTR_REPLACE || flags & FL_READONLY) {
+		goto out;
+	} else {
+		/* inode->i_mutex is down, so nothing else can try to create
+		 * the same xattr */
+		err = xadir->d_inode->i_op->create(xadir->d_inode, xafile,
+						   0700 | S_IFREG, NULL);
+
+		if (err) {
+			dput(xafile);
+			goto out;
+		}
+	}
+
+out:
+	dput(xadir);
+	if (err)
+		xafile = ERR_PTR(err);
+	else if (!xafile->d_inode) {
+		dput(xafile);
+		xafile = ERR_PTR(-ENODATA);
+	}
+	return xafile;
+}
+
 /* Internal operations on file data */
 static inline void reiserfs_put_page(struct page *page)
 {
@@ -554,274 +742,85 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 		goto out_dput;
 	}
 
-	while (file_pos < isize) {
-		size_t chunk;
-		char *data;
-		size_t skip = 0;
-		if (isize - file_pos > PAGE_CACHE_SIZE)
-			chunk = PAGE_CACHE_SIZE;
-		else
-			chunk = isize - file_pos;
-
-		page = reiserfs_get_page(dentry->d_inode, file_pos);
-		if (IS_ERR(page)) {
-			err = PTR_ERR(page);
-			goto out_dput;
-		}
-
-		lock_page(page);
-		data = page_address(page);
-		if (file_pos == 0) {
-			struct reiserfs_xattr_header *rxh =
-			    (struct reiserfs_xattr_header *)data;
-			skip = file_pos = sizeof(struct reiserfs_xattr_header);
-			chunk -= skip;
-			/* Magic doesn't match up.. */
-			if (rxh->h_magic != cpu_to_le32(REISERFS_XATTR_MAGIC)) {
-				unlock_page(page);
-				reiserfs_put_page(page);
-				reiserfs_warning(inode->i_sb, "jdm-20001",
-						 "Invalid magic for xattr (%s) "
-						 "associated with %k", name,
-						 INODE_PKEY(inode));
-				err = -EIO;
-				goto out_dput;
-			}
-			hash = le32_to_cpu(rxh->h_hash);
-		}
-		memcpy(buffer + buffer_pos, data + skip, chunk);
-		unlock_page(page);
-		reiserfs_put_page(page);
-		file_pos += chunk;
-		buffer_pos += chunk;
-		skip = 0;
-	}
-	err = isize - sizeof(struct reiserfs_xattr_header);
-
-	if (xattr_hash(buffer, isize - sizeof(struct reiserfs_xattr_header)) !=
-	    hash) {
-		reiserfs_warning(inode->i_sb, "jdm-20002",
-				 "Invalid hash for xattr (%s) associated "
-				 "with %k", name, INODE_PKEY(inode));
-		err = -EIO;
-	}
-
-      out_dput:
-	dput(dentry);
-
-      out:
-	return err;
-}
-
-static int
-__reiserfs_xattr_del(struct dentry *xadir, const char *name, int namelen)
-{
-	struct dentry *dentry;
-	struct inode *dir = xadir->d_inode;
-	int err = 0;
-
-	dentry = lookup_one_len(name, xadir, namelen);
-	if (IS_ERR(dentry)) {
-		err = PTR_ERR(dentry);
-		goto out;
-	} else if (!dentry->d_inode) {
-		err = -ENODATA;
-		goto out_file;
-	}
-
-	/* Skip directories.. */
-	if (S_ISDIR(dentry->d_inode->i_mode))
-		goto out_file;
-
-	if (!IS_PRIVATE(dentry->d_inode)) {
-		reiserfs_error(dir->i_sb, "jdm-20003",
-			       "OID %08x [%.*s/%.*s] doesn't have "
-			       "priv flag set [parent is %sset].",
-			       le32_to_cpu(INODE_PKEY(dentry->d_inode)->
-					   k_objectid), xadir->d_name.len,
-			       xadir->d_name.name, namelen, name,
-			       IS_PRIVATE(xadir->d_inode) ? "" :
-			       "not ");
-		dput(dentry);
-		return -EIO;
-	}
-
-	err = dir->i_op->unlink(dir, dentry);
-	if (!err)
-		d_delete(dentry);
-
-      out_file:
-	dput(dentry);
-
-      out:
-	return err;
-}
-
-int reiserfs_xattr_del(struct inode *inode, const char *name)
-{
-	struct dentry *dir;
-	int err;
-
-	dir = open_xa_dir(inode, FL_READONLY);
-	if (IS_ERR(dir)) {
-		err = PTR_ERR(dir);
-		goto out;
-	}
-
-	err = __reiserfs_xattr_del(dir, name, strlen(name));
-	dput(dir);
-
-	if (!err) {
-		inode->i_ctime = CURRENT_TIME_SEC;
-		mark_inode_dirty(inode);
-	}
-
-      out:
-	return err;
-}
-
-/* The following are side effects of other operations that aren't explicitly
- * modifying extended attributes. This includes operations such as permissions
- * or ownership changes, object deletions, etc. */
-
-static int
-reiserfs_delete_xattrs_filler(void *buf, const char *name, int namelen,
-			      loff_t offset, u64 ino, unsigned int d_type)
-{
-	struct dentry *xadir = (struct dentry *)buf;
-
-	return __reiserfs_xattr_del(xadir, name, namelen);
-
-}
-
-/* This is called w/ inode->i_mutex downed */
-int reiserfs_delete_xattrs(struct inode *inode)
-{
-	struct dentry *dir, *root;
-	int err = 0;
-
-	/* Skip out, an xattr has no xattrs associated with it */
-	if (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1 ||
-	    !reiserfs_xattrs(inode->i_sb)) {
-		return 0;
-	}
-	reiserfs_read_lock_xattrs(inode->i_sb);
-	dir = open_xa_dir(inode, FL_READONLY);
-	reiserfs_read_unlock_xattrs(inode->i_sb);
-	if (IS_ERR(dir)) {
-		err = PTR_ERR(dir);
-		goto out;
-	} else if (!dir->d_inode) {
-		dput(dir);
-		return 0;
-	}
-
-	lock_kernel();
-	err = xattr_readdir(dir->d_inode, reiserfs_delete_xattrs_filler, dir);
-	if (err) {
-		unlock_kernel();
-		goto out_dir;
-	}
-
-	/* Leftovers besides . and .. -- that's not good. */
-	if (dir->d_inode->i_nlink <= 2) {
-		root = get_xa_root(inode->i_sb, XATTR_REPLACE);
-		reiserfs_write_lock_xattrs(inode->i_sb);
-		err = vfs_rmdir(root->d_inode, dir);
-		reiserfs_write_unlock_xattrs(inode->i_sb);
-		dput(root);
-	} else {
-		reiserfs_warning(inode->i_sb, "jdm-20006",
-				 "Couldn't remove all entries in directory");
-	}
-	unlock_kernel();
-
-      out_dir:
-	dput(dir);
-
-      out:
-	if (!err)
-		REISERFS_I(inode)->i_flags =
-		    REISERFS_I(inode)->i_flags & ~i_has_xattr_dir;
-	return err;
-}
+	while (file_pos < isize) {
+		size_t chunk;
+		char *data;
+		size_t skip = 0;
+		if (isize - file_pos > PAGE_CACHE_SIZE)
+			chunk = PAGE_CACHE_SIZE;
+		else
+			chunk = isize - file_pos;
 
-struct reiserfs_chown_buf {
-	struct inode *inode;
-	struct dentry *xadir;
-	struct iattr *attrs;
-};
+		page = reiserfs_get_page(dentry->d_inode, file_pos);
+		if (IS_ERR(page)) {
+			err = PTR_ERR(page);
+			goto out_dput;
+		}
 
-/* XXX: If there is a better way to do this, I'd love to hear about it */
-static int
-reiserfs_chown_xattrs_filler(void *buf, const char *name, int namelen,
-			     loff_t offset, u64 ino, unsigned int d_type)
-{
-	struct reiserfs_chown_buf *chown_buf = (struct reiserfs_chown_buf *)buf;
-	struct dentry *xafile, *xadir = chown_buf->xadir;
-	struct iattr *attrs = chown_buf->attrs;
-	int err = 0;
+		lock_page(page);
+		data = page_address(page);
+		if (file_pos == 0) {
+			struct reiserfs_xattr_header *rxh =
+			    (struct reiserfs_xattr_header *)data;
+			skip = file_pos = sizeof(struct reiserfs_xattr_header);
+			chunk -= skip;
+			/* Magic doesn't match up.. */
+			if (rxh->h_magic != cpu_to_le32(REISERFS_XATTR_MAGIC)) {
+				unlock_page(page);
+				reiserfs_put_page(page);
+				reiserfs_warning(inode->i_sb, "jdm-20001",
+						 "Invalid magic for xattr (%s) "
+						 "associated with %k", name,
+						 INODE_PKEY(inode));
+				err = -EIO;
+				goto out_dput;
+			}
+			hash = le32_to_cpu(rxh->h_hash);
+		}
+		memcpy(buffer + buffer_pos, data + skip, chunk);
+		unlock_page(page);
+		reiserfs_put_page(page);
+		file_pos += chunk;
+		buffer_pos += chunk;
+		skip = 0;
+	}
+	err = isize - sizeof(struct reiserfs_xattr_header);
 
-	xafile = lookup_one_len(name, xadir, namelen);
-	if (IS_ERR(xafile))
-		return PTR_ERR(xafile);
-	else if (!xafile->d_inode) {
-		dput(xafile);
-		return -ENODATA;
+	if (xattr_hash(buffer, isize - sizeof(struct reiserfs_xattr_header)) !=
+	    hash) {
+		reiserfs_warning(inode->i_sb, "jdm-20002",
+				 "Invalid hash for xattr (%s) associated "
+				 "with %k", name, INODE_PKEY(inode));
+		err = -EIO;
 	}
 
-	if (!S_ISDIR(xafile->d_inode->i_mode))
-		err = notify_change(xafile, attrs);
-	dput(xafile);
+out_dput:
+	dput(dentry);
 
+out:
 	return err;
 }
 
-int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)
+int reiserfs_xattr_del(struct inode *inode, const char *name)
 {
 	struct dentry *dir;
-	int err = 0;
-	struct reiserfs_chown_buf buf;
-	unsigned int ia_valid = attrs->ia_valid;
+	int err;
 
-	/* Skip out, an xattr has no xattrs associated with it */
-	if (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1 ||
-	    !reiserfs_xattrs(inode->i_sb)) {
-		return 0;
-	}
-	reiserfs_read_lock_xattrs(inode->i_sb);
 	dir = open_xa_dir(inode, FL_READONLY);
-	reiserfs_read_unlock_xattrs(inode->i_sb);
 	if (IS_ERR(dir)) {
-		if (PTR_ERR(dir) != -ENODATA)
-			err = PTR_ERR(dir);
-		goto out;
-	} else if (!dir->d_inode) {
-		dput(dir);
+		err = PTR_ERR(dir);
 		goto out;
 	}
 
-	lock_kernel();
-
-	attrs->ia_valid &= (ATTR_UID | ATTR_GID | ATTR_CTIME);
-	buf.xadir = dir;
-	buf.attrs = attrs;
-	buf.inode = inode;
+	err = __reiserfs_xattr_del(dir, name, strlen(name));
+	dput(dir);
 
-	err = xattr_readdir(dir->d_inode, reiserfs_chown_xattrs_filler, &buf);
-	if (err) {
-		unlock_kernel();
-		goto out_dir;
+	if (!err) {
+		inode->i_ctime = CURRENT_TIME_SEC;
+		mark_inode_dirty(inode);
 	}
 
-	err = notify_change(dir, attrs);
-	unlock_kernel();
-
-      out_dir:
-	dput(dir);
-
       out:
-	attrs->ia_valid = ia_valid;
 	return err;
 }
 
@@ -1101,6 +1100,94 @@ void reiserfs_xattr_unregister_handlers(void)
 	write_unlock(&handler_lock);
 }
 
+static int reiserfs_check_acl(struct inode *inode, int mask)
+{
+	struct posix_acl *acl;
+	int error = -EAGAIN; /* do regular unix permission checks by default */
+
+	reiserfs_read_lock_xattr_i(inode);
+	reiserfs_read_lock_xattrs(inode->i_sb);
+
+	acl = reiserfs_get_acl(inode, ACL_TYPE_ACCESS);
+
+	reiserfs_read_unlock_xattrs(inode->i_sb);
+	reiserfs_read_unlock_xattr_i(inode);
+
+	if (acl) {
+		if (!IS_ERR(acl)) {
+			error = posix_acl_permission(inode, acl, mask);
+			posix_acl_release(acl);
+		} else if (PTR_ERR(acl) != -ENODATA)
+			error = PTR_ERR(acl);
+	}
+
+	return error;
+}
+
+int reiserfs_permission(struct inode *inode, int mask)
+{
+	/*
+	 * We don't do permission checks on the internal objects.
+	 * Permissions are determined by the "owning" object.
+	 */
+	if (IS_PRIVATE(inode))
+		return 0;
+	/*
+	 * Stat data v1 doesn't support ACLs.
+	 */
+	if (get_inode_sd_version(inode) == STAT_DATA_V1)
+		return generic_permission(inode, mask, NULL);
+	else
+		return generic_permission(inode, mask, reiserfs_check_acl);
+}
+
+static int create_privroot(struct dentry *dentry)
+{
+	int err;
+	struct inode *inode = dentry->d_parent->d_inode;
+	mutex_lock_nested(&inode->i_mutex, I_MUTEX_XATTR);
+	err = inode->i_op->mkdir(inode, dentry, 0700);
+	mutex_unlock(&inode->i_mutex);
+	if (err) {
+		dput(dentry);
+		dentry = NULL;
+	}
+
+	if (dentry && dentry->d_inode)
+		reiserfs_info(dentry->d_sb, "Created %s - reserved for xattr "
+			      "storage.\n", PRIVROOT_NAME);
+
+	return err;
+}
+
+static int xattr_mount_check(struct super_block *s)
+{
+	/* We need generation numbers to ensure that the oid mapping is correct
+	 * v3.5 filesystems don't have them. */
+	if (!old_format_only(s)) {
+		set_bit(REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
+	} else if (reiserfs_xattrs_optional(s)) {
+		/* Old format filesystem, but optional xattrs have been enabled
+		 * at mount time. Error out. */
+		reiserfs_warning(s, "jdm-20005",
+				 "xattrs/ACLs not supported on pre v3.6 "
+				 "format filesystem. Failing mount.");
+		return -EOPNOTSUPP;
+	} else {
+		/* Old format filesystem, but no optional xattrs have
+		 * been enabled. This means we silently disable xattrs
+		 * on the filesystem. */
+		clear_bit(REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
+	}
+
+	return 0;
+}
+
+#else
+int __init reiserfs_xattr_register_handlers(void) { return 0; }
+void reiserfs_xattr_unregister_handlers(void) {}
+#endif
+
 /* This will catch lookups from the fs root to .reiserfs_priv */
 static int
 xattr_lookup_poison(struct dentry *dentry, struct qstr *q1, struct qstr *name)
@@ -1127,47 +1214,23 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 {
 	int err = 0;
 
-	/* We need generation numbers to ensure that the oid mapping is correct
-	 * v3.5 filesystems don't have them. */
-	if (!old_format_only(s)) {
-		set_bit(REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
-	} else if (reiserfs_xattrs_optional(s)) {
-		/* Old format filesystem, but optional xattrs have been enabled
-		 * at mount time. Error out. */
-		reiserfs_warning(s, "jdm-20005",
-				 "xattrs/ACLs not supported on pre v3.6 "
-				 "format filesystem. Failing mount.");
-		err = -EOPNOTSUPP;
+#ifdef CONFIG_REISERFS_FS_XATTR
+	err = xattr_mount_check(s);
+	if (err)
 		goto error;
-	} else {
-		/* Old format filesystem, but no optional xattrs have been enabled. This
-		 * means we silently disable xattrs on the filesystem. */
-		clear_bit(REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
-	}
+#endif
 
 	/* If we don't have the privroot located yet - go find it */
-	if (reiserfs_xattrs(s) && !REISERFS_SB(s)->priv_root) {
+	if (!REISERFS_SB(s)->priv_root) {
 		struct dentry *dentry;
 		dentry = lookup_one_len(PRIVROOT_NAME, s->s_root,
 					strlen(PRIVROOT_NAME));
 		if (!IS_ERR(dentry)) {
-			if (!(mount_flags & MS_RDONLY) && !dentry->d_inode) {
-				struct inode *inode = dentry->d_parent->d_inode;
-				mutex_lock_nested(&inode->i_mutex,
-						  I_MUTEX_XATTR);
-				err = inode->i_op->mkdir(inode, dentry, 0700);
-				mutex_unlock(&inode->i_mutex);
-				if (err) {
-					dput(dentry);
-					dentry = NULL;
-				}
-
-				if (dentry && dentry->d_inode)
-					reiserfs_info(s, "Created %s - "
-						      "reserved for xattr "
-						      "storage.\n",
-						      PRIVROOT_NAME);
-			} else if (!dentry->d_inode) {
+#ifdef CONFIG_REISERFS_FS_XATTR
+			if (!(mount_flags & MS_RDONLY) && !dentry->d_inode)
+				err = create_privroot(dentry);
+#endif
+			if (!dentry->d_inode) {
 				dput(dentry);
 				dentry = NULL;
 			}
@@ -1178,73 +1241,37 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 			s->s_root->d_op = &xattr_lookup_poison_ops;
 			dentry->d_inode->i_flags |= S_PRIVATE;
 			REISERFS_SB(s)->priv_root = dentry;
-		} else if (!(mount_flags & MS_RDONLY)) {	/* xattrs are unavailable */
-			/* If we're read-only it just means that the dir hasn't been
-			 * created. Not an error -- just no xattrs on the fs. We'll
-			 * check again if we go read-write */
+#ifdef CONFIG_REISERFS_FS_XATTR
+		/* xattrs are unavailable */
+		} else if (!(mount_flags & MS_RDONLY)) {
+			/* If we're read-only it just means that the dir
+			 * hasn't been created. Not an error -- just no
+			 * xattrs on the fs. We'll check again if we
+			 * go read-write */
 			reiserfs_warning(s, "jdm-20006",
 					 "xattrs/ACLs enabled and couldn't "
 					 "find/create .reiserfs_priv. "
 					 "Failing mount.");
 			err = -EOPNOTSUPP;
+#endif
 		}
 	}
 
-      error:
-	/* This is only nonzero if there was an error initializing the xattr
-	 * directory or if there is a condition where we don't support them. */
+#ifdef CONFIG_REISERFS_FS_XATTR
+error:
 	if (err) {
 		clear_bit(REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
 		clear_bit(REISERFS_XATTRS_USER, &(REISERFS_SB(s)->s_mount_opt));
 		clear_bit(REISERFS_POSIXACL, &(REISERFS_SB(s)->s_mount_opt));
 	}
+#endif
 
 	/* The super_block MS_POSIXACL must mirror the (no)acl mount option. */
 	s->s_flags = s->s_flags & ~MS_POSIXACL;
+#ifdef CONFIG_REISERFS_FS_POSIX_ACL
 	if (reiserfs_posixacl(s))
 		s->s_flags |= MS_POSIXACL;
+#endif
 
 	return err;
 }
-
-static int reiserfs_check_acl(struct inode *inode, int mask)
-{
-	struct posix_acl *acl;
-	int error = -EAGAIN; /* do regular unix permission checks by default */
-
-	reiserfs_read_lock_xattr_i(inode);
-	reiserfs_read_lock_xattrs(inode->i_sb);
-
-	acl = reiserfs_get_acl(inode, ACL_TYPE_ACCESS);
-
-	reiserfs_read_unlock_xattrs(inode->i_sb);
-	reiserfs_read_unlock_xattr_i(inode);
-
-	if (acl) {
-		if (!IS_ERR(acl)) {
-			error = posix_acl_permission(inode, acl, mask);
-			posix_acl_release(acl);
-		} else if (PTR_ERR(acl) != -ENODATA)
-			error = PTR_ERR(acl);
-	}
-
-	return error;
-}
-
-int reiserfs_permission(struct inode *inode, int mask)
-{
-	/*
-	 * We don't do permission checks on the internal objects.
-	 * Permissions are determined by the "owning" object.
-	 */
-	if (IS_PRIVATE(inode))
-		return 0;
-
-	/*
-	 * Stat data v1 doesn't support ACLs.
-	 */
-	if (get_inode_sd_version(inode) == STAT_DATA_V1)
-		return generic_permission(inode, mask, NULL);
-	else
-		return generic_permission(inode, mask, reiserfs_check_acl);
-}

commit 6dfede696391133eadd7ce90b61c9573ee6e5a90
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:32 2009 -0400

    reiserfs: remove IS_PRIVATE helpers
    
    There are a number of helper functions for marking a reiserfs inode
    private that were leftover from reiserfs did its own thing wrt to
    private inodes.  S_PRIVATE has been in the kernel for some time, so this
    patch removes the helpers and uses IS_PRIVATE instead.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 3e9e82ca3ba2..c5fc207e529c 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -633,14 +633,14 @@ __reiserfs_xattr_del(struct dentry *xadir, const char *name, int namelen)
 	if (S_ISDIR(dentry->d_inode->i_mode))
 		goto out_file;
 
-	if (!is_reiserfs_priv_object(dentry->d_inode)) {
+	if (!IS_PRIVATE(dentry->d_inode)) {
 		reiserfs_error(dir->i_sb, "jdm-20003",
 			       "OID %08x [%.*s/%.*s] doesn't have "
 			       "priv flag set [parent is %sset].",
 			       le32_to_cpu(INODE_PKEY(dentry->d_inode)->
 					   k_objectid), xadir->d_name.len,
 			       xadir->d_name.name, namelen, name,
-			       is_reiserfs_priv_object(xadir->d_inode) ? "" :
+			       IS_PRIVATE(xadir->d_inode) ? "" :
 			       "not ");
 		dput(dentry);
 		return -EIO;
@@ -701,8 +701,7 @@ int reiserfs_delete_xattrs(struct inode *inode)
 	int err = 0;
 
 	/* Skip out, an xattr has no xattrs associated with it */
-	if (is_reiserfs_priv_object(inode) ||
-	    get_inode_sd_version(inode) == STAT_DATA_V1 ||
+	if (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1 ||
 	    !reiserfs_xattrs(inode->i_sb)) {
 		return 0;
 	}
@@ -786,8 +785,7 @@ int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)
 	unsigned int ia_valid = attrs->ia_valid;
 
 	/* Skip out, an xattr has no xattrs associated with it */
-	if (is_reiserfs_priv_object(inode) ||
-	    get_inode_sd_version(inode) == STAT_DATA_V1 ||
+	if (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1 ||
 	    !reiserfs_xattrs(inode->i_sb)) {
 		return 0;
 	}
@@ -1178,7 +1176,7 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 
 		if (!err && dentry) {
 			s->s_root->d_op = &xattr_lookup_poison_ops;
-			reiserfs_mark_inode_private(dentry->d_inode);
+			dentry->d_inode->i_flags |= S_PRIVATE;
 			REISERFS_SB(s)->priv_root = dentry;
 		} else if (!(mount_flags & MS_RDONLY)) {	/* xattrs are unavailable */
 			/* If we're read-only it just means that the dir hasn't been
@@ -1239,7 +1237,7 @@ int reiserfs_permission(struct inode *inode, int mask)
 	 * We don't do permission checks on the internal objects.
 	 * Permissions are determined by the "owning" object.
 	 */
-	if (is_reiserfs_priv_object(inode))
+	if (IS_PRIVATE(inode))
 		return 0;
 
 	/*

commit 010f5a21a323e7383e067009a7785462883fe5ea
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:31 2009 -0400

    reiserfs: remove link detection code
    
    Early in the reiserfs xattr development, there was a plan to use
    hardlinks to save disk space for identical xattrs.  That code never
    materialized and isn't going to, so this patch removes the detection
    code.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 132d901da08f..3e9e82ca3ba2 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -432,7 +432,6 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	if (buffer && buffer_size)
 		xahash = xattr_hash(buffer, buffer_size);
 
-      open_file:
 	dentry = get_xa_file_dentry(inode, name, flags);
 	if (IS_ERR(dentry)) {
 		err = PTR_ERR(dentry);
@@ -441,18 +440,6 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 
 	REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
 
-	/* we need to copy it off.. */
-	if (dentry->d_inode->i_nlink > 1) {
-		dput(dentry);
-		err = reiserfs_xattr_del(inode, name);
-		if (err < 0)
-			goto out;
-		/* We just killed the old one, we're not replacing anymore */
-		if (flags & XATTR_REPLACE)
-			flags &= ~XATTR_REPLACE;
-		goto open_file;
-	}
-
 	/* Resize it so we're ok to write there */
 	newattrs.ia_size = buffer_size;
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;

commit ec6ea56b2f1d3811815e53131e85fd1fc9b51873
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:30 2009 -0400

    reiserfs: xattr reiserfs_get_page takes offset instead of index
    
    This patch changes reiserfs_get_page to take an offset rather than an
    index since no callers calculate the index differently.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 59b0850e885f..132d901da08f 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -376,14 +376,14 @@ static inline void reiserfs_put_page(struct page *page)
 	page_cache_release(page);
 }
 
-static struct page *reiserfs_get_page(struct inode *dir, unsigned long n)
+static struct page *reiserfs_get_page(struct inode *dir, size_t n)
 {
 	struct address_space *mapping = dir->i_mapping;
 	struct page *page;
 	/* We can deadlock if we try to free dentries,
 	   and an unlink/rmdir has just occured - GFP_NOFS avoids this */
 	mapping_set_gfp_mask(mapping, GFP_NOFS);
-	page = read_mapping_page(mapping, n, NULL);
+	page = read_mapping_page(mapping, n >> PAGE_CACHE_SHIFT, NULL);
 	if (!IS_ERR(page)) {
 		kmap(page);
 		if (PageError(page))
@@ -470,8 +470,7 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 		else
 			chunk = buffer_size - buffer_pos;
 
-		page = reiserfs_get_page(dentry->d_inode,
-					 file_pos >> PAGE_CACHE_SHIFT);
+		page = reiserfs_get_page(dentry->d_inode, file_pos);
 		if (IS_ERR(page)) {
 			err = PTR_ERR(page);
 			goto out_filp;
@@ -577,8 +576,7 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 		else
 			chunk = isize - file_pos;
 
-		page = reiserfs_get_page(dentry->d_inode,
-					 file_pos >> PAGE_CACHE_SHIFT);
+		page = reiserfs_get_page(dentry->d_inode, file_pos);
 		if (IS_ERR(page)) {
 			err = PTR_ERR(page);
 			goto out_dput;

commit f437c529e3cd4853c1edff6fe3b191ad32304e8f
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:29 2009 -0400

    reiserfs: small variable cleanup
    
    This patch removes the xinode and mapping variables from
    reiserfs_xattr_{get,set}.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index bab77fe5f177..59b0850e885f 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -420,10 +420,8 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	struct dentry *dentry;
 	struct page *page;
 	char *data;
-	struct address_space *mapping;
 	size_t file_pos = 0;
 	size_t buffer_pos = 0;
-	struct inode *xinode;
 	struct iattr newattrs;
 	__u32 xahash = 0;
 
@@ -441,11 +439,10 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 		goto out;
 	}
 
-	xinode = dentry->d_inode;
 	REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
 
 	/* we need to copy it off.. */
-	if (xinode->i_nlink > 1) {
+	if (dentry->d_inode->i_nlink > 1) {
 		dput(dentry);
 		err = reiserfs_xattr_del(inode, name);
 		if (err < 0)
@@ -459,12 +456,11 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	/* Resize it so we're ok to write there */
 	newattrs.ia_size = buffer_size;
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
-	mutex_lock_nested(&xinode->i_mutex, I_MUTEX_XATTR);
+	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);
 	err = notify_change(dentry, &newattrs);
 	if (err)
 		goto out_filp;
 
-	mapping = xinode->i_mapping;
 	while (buffer_pos < buffer_size || buffer_pos == 0) {
 		size_t chunk;
 		size_t skip = 0;
@@ -474,7 +470,8 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 		else
 			chunk = buffer_size - buffer_pos;
 
-		page = reiserfs_get_page(xinode, file_pos >> PAGE_CACHE_SHIFT);
+		page = reiserfs_get_page(dentry->d_inode,
+					 file_pos >> PAGE_CACHE_SHIFT);
 		if (IS_ERR(page)) {
 			err = PTR_ERR(page);
 			goto out_filp;
@@ -521,7 +518,7 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	}
 
       out_filp:
-	mutex_unlock(&xinode->i_mutex);
+	mutex_unlock(&dentry->d_inode->i_mutex);
 	dput(dentry);
 
       out:
@@ -541,7 +538,6 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 	size_t file_pos = 0;
 	size_t buffer_pos = 0;
 	struct page *page;
-	struct inode *xinode;
 	__u32 hash = 0;
 
 	if (name == NULL)
@@ -558,8 +554,7 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 		goto out;
 	}
 
-	xinode = dentry->d_inode;
-	isize = xinode->i_size;
+	isize = i_size_read(dentry->d_inode);
 	REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
 
 	/* Just return the size needed */
@@ -582,7 +577,8 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 		else
 			chunk = isize - file_pos;
 
-		page = reiserfs_get_page(xinode, file_pos >> PAGE_CACHE_SHIFT);
+		page = reiserfs_get_page(dentry->d_inode,
+					 file_pos >> PAGE_CACHE_SHIFT);
 		if (IS_ERR(page)) {
 			err = PTR_ERR(page);
 			goto out_dput;

commit 0030b64570c862f04c1550ba4a0bf7a9c128162a
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:28 2009 -0400

    reiserfs: use reiserfs_error()
    
    This patch makes many paths that are currently using warnings to handle
    the error.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index d14f5c2c0e4a..bab77fe5f177 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -259,8 +259,8 @@ static int __xattr_readdir(struct inode *inode, void *dirent, filldir_t filldir)
 		ih = de.de_ih;
 
 		if (!is_direntry_le_ih(ih)) {
-			reiserfs_warning(inode->i_sb, "jdm-20000",
-					 "not direntry %h", ih);
+			reiserfs_error(inode->i_sb, "jdm-20000",
+				       "not direntry %h", ih);
 			break;
 		}
 		copy_item_head(&tmp_ih, ih);
@@ -653,15 +653,14 @@ __reiserfs_xattr_del(struct dentry *xadir, const char *name, int namelen)
 		goto out_file;
 
 	if (!is_reiserfs_priv_object(dentry->d_inode)) {
-		reiserfs_warning(dir->i_sb, "jdm-20003",
-				 "OID %08x [%.*s/%.*s] doesn't have "
-				 "priv flag set [parent is %sset].",
-				 le32_to_cpu(INODE_PKEY(dentry->d_inode)->
-					     k_objectid), xadir->d_name.len,
-				 xadir->d_name.name, namelen, name,
-				 is_reiserfs_priv_object(xadir->
-							 d_inode) ? "" :
-				 "not ");
+		reiserfs_error(dir->i_sb, "jdm-20003",
+			       "OID %08x [%.*s/%.*s] doesn't have "
+			       "priv flag set [parent is %sset].",
+			       le32_to_cpu(INODE_PKEY(dentry->d_inode)->
+					   k_objectid), xadir->d_name.len,
+			       xadir->d_name.name, namelen, name,
+			       is_reiserfs_priv_object(xadir->d_inode) ? "" :
+			       "not ");
 		dput(dentry);
 		return -EIO;
 	}

commit 45b03d5e8e674eb6555b767e1c8eb40b671ff892
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:21 2009 -0400

    reiserfs: rework reiserfs_warning
    
    ReiserFS warnings can be somewhat inconsistent.
    In some cases:
     * a unique identifier may be associated with it
     * the function name may be included
     * the device may be printed separately
    
    This patch aims to make warnings more consistent. reiserfs_warning() prints
    the device name, so printing it a second time is not required. The function
    name for a warning is always helpful in debugging, so it is now automatically
    inserted into the output. Hans has stated that every warning should have
    a unique identifier. Some cases lack them, others really shouldn't have them.
    reiserfs_warning() now expects an id associated with each message. In the
    rare case where one isn't needed, "" will suffice.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index e11b00472361..d14f5c2c0e4a 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -259,7 +259,8 @@ static int __xattr_readdir(struct inode *inode, void *dirent, filldir_t filldir)
 		ih = de.de_ih;
 
 		if (!is_direntry_le_ih(ih)) {
-			reiserfs_warning(inode->i_sb, "not direntry %h", ih);
+			reiserfs_warning(inode->i_sb, "jdm-20000",
+					 "not direntry %h", ih);
 			break;
 		}
 		copy_item_head(&tmp_ih, ih);
@@ -598,7 +599,7 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 			if (rxh->h_magic != cpu_to_le32(REISERFS_XATTR_MAGIC)) {
 				unlock_page(page);
 				reiserfs_put_page(page);
-				reiserfs_warning(inode->i_sb,
+				reiserfs_warning(inode->i_sb, "jdm-20001",
 						 "Invalid magic for xattr (%s) "
 						 "associated with %k", name,
 						 INODE_PKEY(inode));
@@ -618,7 +619,7 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 
 	if (xattr_hash(buffer, isize - sizeof(struct reiserfs_xattr_header)) !=
 	    hash) {
-		reiserfs_warning(inode->i_sb,
+		reiserfs_warning(inode->i_sb, "jdm-20002",
 				 "Invalid hash for xattr (%s) associated "
 				 "with %k", name, INODE_PKEY(inode));
 		err = -EIO;
@@ -652,7 +653,8 @@ __reiserfs_xattr_del(struct dentry *xadir, const char *name, int namelen)
 		goto out_file;
 
 	if (!is_reiserfs_priv_object(dentry->d_inode)) {
-		reiserfs_warning(dir->i_sb, "OID %08x [%.*s/%.*s] doesn't have "
+		reiserfs_warning(dir->i_sb, "jdm-20003",
+				 "OID %08x [%.*s/%.*s] doesn't have "
 				 "priv flag set [parent is %sset].",
 				 le32_to_cpu(INODE_PKEY(dentry->d_inode)->
 					     k_objectid), xadir->d_name.len,
@@ -750,7 +752,7 @@ int reiserfs_delete_xattrs(struct inode *inode)
 		reiserfs_write_unlock_xattrs(inode->i_sb);
 		dput(root);
 	} else {
-		reiserfs_warning(inode->i_sb,
+		reiserfs_warning(inode->i_sb, "jdm-20006",
 				 "Couldn't remove all entries in directory");
 	}
 	unlock_kernel();
@@ -1154,7 +1156,8 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 	} else if (reiserfs_xattrs_optional(s)) {
 		/* Old format filesystem, but optional xattrs have been enabled
 		 * at mount time. Error out. */
-		reiserfs_warning(s, "xattrs/ACLs not supported on pre v3.6 "
+		reiserfs_warning(s, "jdm-20005",
+				 "xattrs/ACLs not supported on pre v3.6 "
 				 "format filesystem. Failing mount.");
 		err = -EOPNOTSUPP;
 		goto error;
@@ -1201,8 +1204,10 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 			/* If we're read-only it just means that the dir hasn't been
 			 * created. Not an error -- just no xattrs on the fs. We'll
 			 * check again if we go read-write */
-			reiserfs_warning(s, "xattrs/ACLs enabled and couldn't "
-					 "find/create .reiserfs_priv. Failing mount.");
+			reiserfs_warning(s, "jdm-20006",
+					 "xattrs/ACLs enabled and couldn't "
+					 "find/create .reiserfs_priv. "
+					 "Failing mount.");
 			err = -EOPNOTSUPP;
 		}
 	}

commit 1d889d9958490888b3fad1d486145d9a03559cbc
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:20 2009 -0400

    reiserfs: make some warnings informational
    
    In several places, reiserfs_warning is used when there is no warning, just
    a notice. This patch changes some of them to indicate that the message
    is merely informational.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index ad92461cbfc3..e11b00472361 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -1182,12 +1182,10 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 				}
 
 				if (dentry && dentry->d_inode)
-					reiserfs_warning(s,
-							 "Created %s on %s - reserved for "
-							 "xattr storage.",
-							 PRIVROOT_NAME,
-							 reiserfs_bdevname
-							 (inode->i_sb));
+					reiserfs_info(s, "Created %s - "
+						      "reserved for xattr "
+						      "storage.\n",
+						      PRIVROOT_NAME);
 			} else if (!dentry->d_inode) {
 				dput(dentry);
 				dentry = NULL;

commit e16404ed0f3f330dc3e99b95cef69bb60bcd27f7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Feb 20 05:55:13 2009 +0000

    constify dentry_operations: misc filesystems
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index ad92461cbfc3..ae881ccd2f03 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -1136,7 +1136,7 @@ xattr_lookup_poison(struct dentry *dentry, struct qstr *q1, struct qstr *name)
 	return 1;
 }
 
-static struct dentry_operations xattr_lookup_poison_ops = {
+static const struct dentry_operations xattr_lookup_poison_ops = {
 	.d_compare = xattr_lookup_poison,
 };
 

commit 67b172c097177835fbf5b0666885c4059a4f67ff
Author: Julien Brunel <brunel@diku.dk>
Date:   Wed Oct 15 22:04:12 2008 -0700

    fs/reiserfs: use an IS_ERR test rather than a NULL test
    
    In case of error, the function open_xa_dir returns an ERR pointer, but
    never returns a NULL pointer.  So a NULL test that comes after an IS_ERR
    test should be deleted.
    
    The semantic match that finds this problem is as follows:
    (http://www.emn.fr/x-info/coccinelle/)
    
    // <smpl>
    @match_bad_null_test@
    expression x, E;
    statement S1,S2;
    @@
    x = open_xa_dir(...)
    ... when != x = E
    (
    *  if (x == NULL && ...) S1 else S2
    |
    *  if (x == NULL || ...) S1 else S2
    )
    // </smpl>
    
    Signed-off-by: Julien Brunel <brunel@diku.dk>
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Jan Kara <jack@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index bb3cb5b7cdb2..ad92461cbfc3 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -155,7 +155,7 @@ static struct dentry *get_xa_file_dentry(const struct inode *inode,
 	xadir = open_xa_dir(inode, flags);
 	if (IS_ERR(xadir)) {
 		return ERR_CAST(xadir);
-	} else if (xadir && !xadir->d_inode) {
+	} else if (!xadir->d_inode) {
 		dput(xadir);
 		return ERR_PTR(-ENODATA);
 	}

commit e6305c43eda10ebfd2ad9e35d6e172ccc7bb3695
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 15 21:03:57 2008 -0400

    [PATCH] sanitize ->permission() prototype
    
    * kill nameidata * argument; map the 3 bits in ->flags anybody cares
      about to new MAY_... ones and pass with the mask.
    * kill redundant gfs2_iop_permission()
    * sanitize ecryptfs_permission()
    * fix remaining places where ->permission() instances might barf on new
      MAY_... found in mask.
    
    The obvious next target in that direction is permission(9)
    
    folded fix for nfs_permission() breakage from Miklos Szeredi <mszeredi@suse.cz>
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index d7c4935c1034..bb3cb5b7cdb2 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -1250,7 +1250,7 @@ static int reiserfs_check_acl(struct inode *inode, int mask)
 	return error;
 }
 
-int reiserfs_permission(struct inode *inode, int mask, struct nameidata *nd)
+int reiserfs_permission(struct inode *inode, int mask)
 {
 	/*
 	 * We don't do permission checks on the internal objects.

commit cb688371e27880d86c42323826846d1cd7caad8f
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Feb 26 09:59:26 2008 -0500

    fs: Remove unnecessary inclusions of asm/semaphore.h
    
    None of these files use any of the functionality promised by
    asm/semaphore.h.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 344b9b96cc56..d7c4935c1034 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -44,7 +44,6 @@
 #include <net/checksum.h>
 #include <linux/smp_lock.h>
 #include <linux/stat.h>
-#include <asm/semaphore.h>
 
 #define FL_READONLY 128
 #define FL_DIR_SEM_HELD 256

commit 3227e14c3cab5ef7972c72eb13c13de444b5bfbc
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Feb 15 14:37:22 2008 -0800

    [PATCH] reiserfs: eliminate private use of struct file in xattr
    
    After several posts and bug reports regarding interaction with the NULL
    nameidata, here's a patch to clean up the mess with struct file in the
    reiserfs xattr code.
    
    As observed in several of the posts, there's really no need for struct file
    to exist in the xattr code.  It was really only passed around due to the
    f_op->readdir() and a_ops->{prepare,commit}_write prototypes requiring it.
    
    reiserfs_prepare_write() and reiserfs_commit_write() don't actually use the
    struct file passed to it, and the xattr code uses a private version of
    reiserfs_readdir() to enumerate the xattr directories.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Acked-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dave Hansen <haveblue@us.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index eba037b3338f..344b9b96cc56 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -191,28 +191,11 @@ static struct dentry *get_xa_file_dentry(const struct inode *inode,
 	dput(xadir);
 	if (err)
 		xafile = ERR_PTR(err);
-	return xafile;
-}
-
-/* Opens a file pointer to the attribute associated with inode */
-static struct file *open_xa_file(const struct inode *inode, const char *name,
-				 int flags)
-{
-	struct dentry *xafile;
-	struct file *fp;
-
-	xafile = get_xa_file_dentry(inode, name, flags);
-	if (IS_ERR(xafile))
-		return ERR_PTR(PTR_ERR(xafile));
 	else if (!xafile->d_inode) {
 		dput(xafile);
-		return ERR_PTR(-ENODATA);
+		xafile = ERR_PTR(-ENODATA);
 	}
-
-	fp = dentry_open(xafile, NULL, O_RDWR);
-	/* dentry_open dputs the dentry if it fails */
-
-	return fp;
+	return xafile;
 }
 
 /*
@@ -228,9 +211,8 @@ static struct file *open_xa_file(const struct inode *inode, const char *name,
  * we're called with i_mutex held, so there are no worries about the directory
  * changing underneath us.
  */
-static int __xattr_readdir(struct file *filp, void *dirent, filldir_t filldir)
+static int __xattr_readdir(struct inode *inode, void *dirent, filldir_t filldir)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
 	struct cpu_key pos_key;	/* key of current position in the directory (key of directory entry) */
 	INITIALIZE_PATH(path_to_entry);
 	struct buffer_head *bh;
@@ -374,23 +356,16 @@ static int __xattr_readdir(struct file *filp, void *dirent, filldir_t filldir)
  *
  */
 static
-int xattr_readdir(struct file *file, filldir_t filler, void *buf)
+int xattr_readdir(struct inode *inode, filldir_t filler, void *buf)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
-	int res = -ENOTDIR;
-	if (!file->f_op || !file->f_op->readdir)
-		goto out;
+	int res = -ENOENT;
 	mutex_lock_nested(&inode->i_mutex, I_MUTEX_XATTR);
-//        down(&inode->i_zombie);
-	res = -ENOENT;
 	if (!IS_DEADDIR(inode)) {
 		lock_kernel();
-		res = __xattr_readdir(file, buf, filler);
+		res = __xattr_readdir(inode, buf, filler);
 		unlock_kernel();
 	}
-//        up(&inode->i_zombie);
 	mutex_unlock(&inode->i_mutex);
-      out:
 	return res;
 }
 
@@ -442,7 +417,7 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 		   size_t buffer_size, int flags)
 {
 	int err = 0;
-	struct file *fp;
+	struct dentry *dentry;
 	struct page *page;
 	char *data;
 	struct address_space *mapping;
@@ -460,18 +435,18 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 		xahash = xattr_hash(buffer, buffer_size);
 
       open_file:
-	fp = open_xa_file(inode, name, flags);
-	if (IS_ERR(fp)) {
-		err = PTR_ERR(fp);
+	dentry = get_xa_file_dentry(inode, name, flags);
+	if (IS_ERR(dentry)) {
+		err = PTR_ERR(dentry);
 		goto out;
 	}
 
-	xinode = fp->f_path.dentry->d_inode;
+	xinode = dentry->d_inode;
 	REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
 
 	/* we need to copy it off.. */
 	if (xinode->i_nlink > 1) {
-		fput(fp);
+		dput(dentry);
 		err = reiserfs_xattr_del(inode, name);
 		if (err < 0)
 			goto out;
@@ -485,7 +460,7 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	newattrs.ia_size = buffer_size;
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
 	mutex_lock_nested(&xinode->i_mutex, I_MUTEX_XATTR);
-	err = notify_change(fp->f_path.dentry, &newattrs);
+	err = notify_change(dentry, &newattrs);
 	if (err)
 		goto out_filp;
 
@@ -518,15 +493,14 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 			rxh->h_hash = cpu_to_le32(xahash);
 		}
 
-		err = reiserfs_prepare_write(fp, page, page_offset,
+		err = reiserfs_prepare_write(NULL, page, page_offset,
 					    page_offset + chunk + skip);
 		if (!err) {
 			if (buffer)
 				memcpy(data + skip, buffer + buffer_pos, chunk);
-			err =
-			    reiserfs_commit_write(fp, page, page_offset,
-						  page_offset + chunk +
-						  skip);
+			err = reiserfs_commit_write(NULL, page, page_offset,
+						    page_offset + chunk +
+						    skip);
 		}
 		unlock_page(page);
 		reiserfs_put_page(page);
@@ -548,7 +522,7 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 
       out_filp:
 	mutex_unlock(&xinode->i_mutex);
-	fput(fp);
+	dput(dentry);
 
       out:
 	return err;
@@ -562,7 +536,7 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 		   size_t buffer_size)
 {
 	ssize_t err = 0;
-	struct file *fp;
+	struct dentry *dentry;
 	size_t isize;
 	size_t file_pos = 0;
 	size_t buffer_pos = 0;
@@ -578,13 +552,13 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 	if (get_inode_sd_version(inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	fp = open_xa_file(inode, name, FL_READONLY);
-	if (IS_ERR(fp)) {
-		err = PTR_ERR(fp);
+	dentry = get_xa_file_dentry(inode, name, FL_READONLY);
+	if (IS_ERR(dentry)) {
+		err = PTR_ERR(dentry);
 		goto out;
 	}
 
-	xinode = fp->f_path.dentry->d_inode;
+	xinode = dentry->d_inode;
 	isize = xinode->i_size;
 	REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
 
@@ -652,7 +626,7 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 	}
 
       out_dput:
-	fput(fp);
+	dput(dentry);
 
       out:
 	return err;
@@ -742,7 +716,6 @@ reiserfs_delete_xattrs_filler(void *buf, const char *name, int namelen,
 /* This is called w/ inode->i_mutex downed */
 int reiserfs_delete_xattrs(struct inode *inode)
 {
-	struct file *fp;
 	struct dentry *dir, *root;
 	int err = 0;
 
@@ -763,15 +736,8 @@ int reiserfs_delete_xattrs(struct inode *inode)
 		return 0;
 	}
 
-	fp = dentry_open(dir, NULL, O_RDWR);
-	if (IS_ERR(fp)) {
-		err = PTR_ERR(fp);
-		/* dentry_open dputs the dentry if it fails */
-		goto out;
-	}
-
 	lock_kernel();
-	err = xattr_readdir(fp, reiserfs_delete_xattrs_filler, dir);
+	err = xattr_readdir(dir->d_inode, reiserfs_delete_xattrs_filler, dir);
 	if (err) {
 		unlock_kernel();
 		goto out_dir;
@@ -791,7 +757,7 @@ int reiserfs_delete_xattrs(struct inode *inode)
 	unlock_kernel();
 
       out_dir:
-	fput(fp);
+	dput(dir);
 
       out:
 	if (!err)
@@ -833,7 +799,6 @@ reiserfs_chown_xattrs_filler(void *buf, const char *name, int namelen,
 
 int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)
 {
-	struct file *fp;
 	struct dentry *dir;
 	int err = 0;
 	struct reiserfs_chown_buf buf;
@@ -857,13 +822,6 @@ int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)
 		goto out;
 	}
 
-	fp = dentry_open(dir, NULL, O_RDWR);
-	if (IS_ERR(fp)) {
-		err = PTR_ERR(fp);
-		/* dentry_open dputs the dentry if it fails */
-		goto out;
-	}
-
 	lock_kernel();
 
 	attrs->ia_valid &= (ATTR_UID | ATTR_GID | ATTR_CTIME);
@@ -871,7 +829,7 @@ int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)
 	buf.attrs = attrs;
 	buf.inode = inode;
 
-	err = xattr_readdir(fp, reiserfs_chown_xattrs_filler, &buf);
+	err = xattr_readdir(dir->d_inode, reiserfs_chown_xattrs_filler, &buf);
 	if (err) {
 		unlock_kernel();
 		goto out_dir;
@@ -881,7 +839,7 @@ int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)
 	unlock_kernel();
 
       out_dir:
-	fput(fp);
+	dput(dir);
 
       out:
 	attrs->ia_valid = ia_valid;
@@ -1029,7 +987,6 @@ reiserfs_listxattr_filler(void *buf, const char *name, int namelen,
  */
 ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 {
-	struct file *fp;
 	struct dentry *dir;
 	int err = 0;
 	struct reiserfs_listxattr_buf buf;
@@ -1052,13 +1009,6 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 		goto out;
 	}
 
-	fp = dentry_open(dir, NULL, O_RDWR);
-	if (IS_ERR(fp)) {
-		err = PTR_ERR(fp);
-		/* dentry_open dputs the dentry if it fails */
-		goto out;
-	}
-
 	buf.r_buf = buffer;
 	buf.r_size = buffer ? size : 0;
 	buf.r_pos = 0;
@@ -1066,7 +1016,7 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 
 	REISERFS_I(dentry->d_inode)->i_flags |= i_has_xattr_dir;
 
-	err = xattr_readdir(fp, reiserfs_listxattr_filler, &buf);
+	err = xattr_readdir(dir->d_inode, reiserfs_listxattr_filler, &buf);
 	if (err)
 		goto out_dir;
 
@@ -1076,7 +1026,7 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 		err = buf.r_pos;
 
       out_dir:
-	fput(fp);
+	dput(dir);
 
       out:
 	reiserfs_read_unlock_xattr_i(dentry->d_inode);

commit e231c2ee64eb1c5cd3c63c31da9dac7d888dcf7f
Author: David Howells <dhowells@redhat.com>
Date:   Thu Feb 7 00:15:26 2008 -0800

    Convert ERR_PTR(PTR_ERR(p)) instances to ERR_CAST(p)
    
    Convert instances of ERR_PTR(PTR_ERR(p)) to ERR_CAST(p) using:
    
    perl -spi -e 's/ERR_PTR[(]PTR_ERR[(](.*)[)][)]/ERR_CAST(\1)/' `grep -rl 'ERR_PTR[(]*PTR_ERR' fs crypto net security`
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index a5bd23ce0e46..eba037b3338f 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -155,7 +155,7 @@ static struct dentry *get_xa_file_dentry(const struct inode *inode,
 
 	xadir = open_xa_dir(inode, flags);
 	if (IS_ERR(xadir)) {
-		return ERR_PTR(PTR_ERR(xadir));
+		return ERR_CAST(xadir);
 	} else if (xadir && !xadir->d_inode) {
 		dput(xadir);
 		return ERR_PTR(-ENODATA);
@@ -164,7 +164,7 @@ static struct dentry *get_xa_file_dentry(const struct inode *inode,
 	xafile = lookup_one_len(name, xadir, strlen(name));
 	if (IS_ERR(xafile)) {
 		dput(xadir);
-		return ERR_PTR(PTR_ERR(xafile));
+		return ERR_CAST(xafile);
 	}
 
 	if (xafile->d_inode) {	/* file exists */

commit bcf11cbeccd7d981d68567942ba6ec184890bc29
Author: Denis Cheng <crquan@gmail.com>
Date:   Wed Feb 6 01:37:40 2008 -0800

    fs/reiserfs/xattr.c: use LIST_HEAD instead of LIST_HEAD_INIT
    
    Signed-off-by: Denis Cheng <crquan@gmail.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 1597f6b649e0..a5bd23ce0e46 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -1084,7 +1084,7 @@ ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 }
 
 /* This is the implementation for the xattr plugin infrastructure */
-static struct list_head xattr_handlers = LIST_HEAD_INIT(xattr_handlers);
+static LIST_HEAD(xattr_handlers);
 static DEFINE_RWLOCK(handler_lock);
 
 static struct reiserfs_xattr_handler *find_xattr_handler_prefix(const char

commit 7598392894f6455cf2114f29a98a0289df788056
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Oct 18 23:39:23 2007 -0700

    reiserfs: fix up lockdep warnings
    
    Add I_MUTEX_XATTR annotations to the inode locking in the reiserfs xattr code.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index fab4b9b2664f..1597f6b649e0 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -484,7 +484,7 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	/* Resize it so we're ok to write there */
 	newattrs.ia_size = buffer_size;
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
-	mutex_lock(&xinode->i_mutex);
+	mutex_lock_nested(&xinode->i_mutex, I_MUTEX_XATTR);
 	err = notify_change(fp->f_path.dentry, &newattrs);
 	if (err)
 		goto out_filp;
@@ -1223,7 +1223,8 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 		if (!IS_ERR(dentry)) {
 			if (!(mount_flags & MS_RDONLY) && !dentry->d_inode) {
 				struct inode *inode = dentry->d_parent->d_inode;
-				mutex_lock(&inode->i_mutex);
+				mutex_lock_nested(&inode->i_mutex,
+						  I_MUTEX_XATTR);
 				err = inode->i_op->mkdir(inode, dentry, 0700);
 				mutex_unlock(&inode->i_mutex);
 				if (err) {

commit ba9d8cec6c7165e440f9b2413a0464cf3c12fb25
Author: Vladimir Saveliev <vs@namesys.com>
Date:   Tue Oct 16 01:25:14 2007 -0700

    reiserfs: convert to new aops
    
    Convert reiserfs to new aops
    
    Signed-off-by: Vladimir Saveliev <vs@namesys.com>
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index bf6e58214538..fab4b9b2664f 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -426,6 +426,12 @@ static inline __u32 xattr_hash(const char *msg, int len)
 	return csum_partial(msg, len, 0);
 }
 
+int reiserfs_commit_write(struct file *f, struct page *page,
+			  unsigned from, unsigned to);
+int reiserfs_prepare_write(struct file *f, struct page *page,
+			   unsigned from, unsigned to);
+
+
 /* Generic extended attribute operations that can be used by xa plugins */
 
 /*
@@ -512,15 +518,15 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 			rxh->h_hash = cpu_to_le32(xahash);
 		}
 
-		err = mapping->a_ops->prepare_write(fp, page, page_offset,
-						    page_offset + chunk + skip);
+		err = reiserfs_prepare_write(fp, page, page_offset,
+					    page_offset + chunk + skip);
 		if (!err) {
 			if (buffer)
 				memcpy(data + skip, buffer + buffer_pos, chunk);
 			err =
-			    mapping->a_ops->commit_write(fp, page, page_offset,
-							 page_offset + chunk +
-							 skip);
+			    reiserfs_commit_write(fp, page, page_offset,
+						  page_offset + chunk +
+						  skip);
 		}
 		unlock_page(page);
 		reiserfs_put_page(page);

commit 6fe6900e1e5b6fa9e5c59aa5061f244fe3f467e2
Author: Nick Piggin <npiggin@suse.de>
Date:   Sun May 6 14:49:04 2007 -0700

    mm: make read_cache_page synchronous
    
    Ensure pages are uptodate after returning from read_cache_page, which allows
    us to cut out most of the filesystem-internal PageUptodate calls.
    
    I didn't have a great look down the call chains, but this appears to fixes 7
    possible use-before uptodate in hfs, 2 in hfsplus, 1 in jfs, a few in
    ecryptfs, 1 in jffs2, and a possible cleared data overwritten with readpage in
    block2mtd.  All depending on whether the filler is async and/or can return
    with a !uptodate page.
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Cc: Hugh Dickins <hugh@veritas.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 2cac56210e2b..bf6e58214538 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -410,11 +410,7 @@ static struct page *reiserfs_get_page(struct inode *dir, unsigned long n)
 	mapping_set_gfp_mask(mapping, GFP_NOFS);
 	page = read_mapping_page(mapping, n, NULL);
 	if (!IS_ERR(page)) {
-		wait_on_page_locked(page);
 		kmap(page);
-		if (!PageUptodate(page))
-			goto fail;
-
 		if (PageError(page))
 			goto fail;
 	}

commit 1173a729fc3ce2fa0d698bd39be8ff7bf6c70bf1
Author: Jeff Mahoney <jeffm@suse.de>
Date:   Mon Apr 30 15:09:50 2007 -0700

    reiserfs: suppress lockdep warning
    
    We're getting lockdep warnings due to a post-2.6.21-rc7 bugfix.
    
    The xattr_sem can never be taken in the manner described. Internal inodes
    are protected by I_PRIVATE.  Add the appropriate annotation.
    
    Cc: <stable@kernel.org>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index c8178b7b9212..2cac56210e2b 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -68,7 +68,7 @@ static struct dentry *get_xa_root(struct super_block *sb, int flags)
 	if (!privroot)
 		return ERR_PTR(-ENODATA);
 
-	mutex_lock(&privroot->d_inode->i_mutex);
+	mutex_lock_nested(&privroot->d_inode->i_mutex, I_MUTEX_XATTR);
 	if (REISERFS_SB(sb)->xattr_root) {
 		xaroot = dget(REISERFS_SB(sb)->xattr_root);
 		goto out;

commit 9b7f375505f5611efb562065b57814b28a81abc3
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Apr 23 14:41:17 2007 -0700

    reiserfs: fix xattr root locking/refcount bug
    
    The listxattr() and getxattr() operations are only protected by a read
    lock.  As a result, if either of these operations run in parallel, a race
    condition exists where the xattr_root will end up being cached twice, which
    results in the leaking of a reference and a BUG() on umount.
    
    This patch refactors get_xa_root(), __get_xa_root(), and create_xa_root(),
    into one get_xa_root() function that takes the appropriate locking around
    the entire critical section.
    
    Reported, diagnosed and tested by Andrea Righi <a.righi@cineca.it>
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Cc: Andrea Righi <a.righi@cineca.it>
    Cc: "Vladimir V. Saveliev" <vs@namesys.com>
    Cc: Edward Shishkin <edward@namesys.com>
    Cc: Alex Zarochentsev <zam@namesys.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index f01389fd162e..c8178b7b9212 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -54,82 +54,48 @@
 static struct reiserfs_xattr_handler *find_xattr_handler_prefix(const char
 								*prefix);
 
-static struct dentry *create_xa_root(struct super_block *sb)
+/* Returns the dentry referring to the root of the extended attribute
+ * directory tree. If it has already been retrieved, it is used. If it
+ * hasn't been created and the flags indicate creation is allowed, we
+ * attempt to create it. On error, we return a pointer-encoded error.
+ */
+static struct dentry *get_xa_root(struct super_block *sb, int flags)
 {
 	struct dentry *privroot = dget(REISERFS_SB(sb)->priv_root);
 	struct dentry *xaroot;
 
 	/* This needs to be created at mount-time */
 	if (!privroot)
-		return ERR_PTR(-EOPNOTSUPP);
+		return ERR_PTR(-ENODATA);
 
-	xaroot = lookup_one_len(XAROOT_NAME, privroot, strlen(XAROOT_NAME));
-	if (IS_ERR(xaroot)) {
+	mutex_lock(&privroot->d_inode->i_mutex);
+	if (REISERFS_SB(sb)->xattr_root) {
+		xaroot = dget(REISERFS_SB(sb)->xattr_root);
 		goto out;
-	} else if (!xaroot->d_inode) {
-		int err;
-		mutex_lock(&privroot->d_inode->i_mutex);
-		err =
-		    privroot->d_inode->i_op->mkdir(privroot->d_inode, xaroot,
-						   0700);
-		mutex_unlock(&privroot->d_inode->i_mutex);
-
-		if (err) {
-			dput(xaroot);
-			dput(privroot);
-			return ERR_PTR(err);
-		}
-		REISERFS_SB(sb)->xattr_root = dget(xaroot);
 	}
 
-      out:
-	dput(privroot);
-	return xaroot;
-}
-
-/* This will return a dentry, or error, refering to the xa root directory.
- * If the xa root doesn't exist yet, the dentry will be returned without
- * an associated inode. This dentry can be used with ->mkdir to create
- * the xa directory. */
-static struct dentry *__get_xa_root(struct super_block *s)
-{
-	struct dentry *privroot = dget(REISERFS_SB(s)->priv_root);
-	struct dentry *xaroot = NULL;
-
-	if (IS_ERR(privroot) || !privroot)
-		return privroot;
-
 	xaroot = lookup_one_len(XAROOT_NAME, privroot, strlen(XAROOT_NAME));
 	if (IS_ERR(xaroot)) {
 		goto out;
 	} else if (!xaroot->d_inode) {
-		dput(xaroot);
-		xaroot = NULL;
-		goto out;
+		int err = -ENODATA;
+		if (flags == 0 || flags & XATTR_CREATE)
+			err = privroot->d_inode->i_op->mkdir(privroot->d_inode,
+			                                     xaroot, 0700);
+		if (err) {
+			dput(xaroot);
+			xaroot = ERR_PTR(err);
+			goto out;
+		}
 	}
-
-	REISERFS_SB(s)->xattr_root = dget(xaroot);
+	REISERFS_SB(sb)->xattr_root = dget(xaroot);
 
       out:
+	mutex_unlock(&privroot->d_inode->i_mutex);
 	dput(privroot);
 	return xaroot;
 }
 
-/* Returns the dentry (or NULL) referring to the root of the extended
- * attribute directory tree. If it has already been retrieved, it is used.
- * Otherwise, we attempt to retrieve it from disk. It may also return
- * a pointer-encoded error.
- */
-static inline struct dentry *get_xa_root(struct super_block *s)
-{
-	struct dentry *dentry = dget(REISERFS_SB(s)->xattr_root);
-
-	if (!dentry)
-		dentry = __get_xa_root(s);
-
-	return dentry;
-}
-
 /* Opens the directory corresponding to the inode's extended attribute store.
  * If flags allow, the tree to the directory may be created. If creation is
  * prohibited, -ENODATA is returned. */
@@ -138,21 +104,11 @@ static struct dentry *open_xa_dir(const struct inode *inode, int flags)
 	struct dentry *xaroot, *xadir;
 	char namebuf[17];
 
-	xaroot = get_xa_root(inode->i_sb);
-	if (IS_ERR(xaroot)) {
+	xaroot = get_xa_root(inode->i_sb, flags);
+	if (IS_ERR(xaroot))
 		return xaroot;
-	} else if (!xaroot) {
-		if (flags == 0 || flags & XATTR_CREATE) {
-			xaroot = create_xa_root(inode->i_sb);
-			if (IS_ERR(xaroot))
-				return xaroot;
-		}
-		if (!xaroot)
-			return ERR_PTR(-ENODATA);
-	}
 
 	/* ok, we have xaroot open */
-
 	snprintf(namebuf, sizeof(namebuf), "%X.%X",
 		 le32_to_cpu(INODE_PKEY(inode)->k_objectid),
 		 inode->i_generation);
@@ -821,7 +777,7 @@ int reiserfs_delete_xattrs(struct inode *inode)
 
 	/* Leftovers besides . and .. -- that's not good. */
 	if (dir->d_inode->i_nlink <= 2) {
-		root = get_xa_root(inode->i_sb);
+		root = get_xa_root(inode->i_sb, XATTR_REPLACE);
 		reiserfs_write_lock_xattrs(inode->i_sb);
 		err = vfs_rmdir(root->d_inode, dir);
 		reiserfs_write_unlock_xattrs(inode->i_sb);

commit 1fc5adbd1916793c19d25347f484806c124d9be7
Author: Josef Sipek <jsipek@fsl.cs.sunysb.edu>
Date:   Fri Dec 8 02:37:33 2006 -0800

    [PATCH] struct path: convert reiserfs
    
    Signed-off-by: Josef Sipek <jsipek@fsl.cs.sunysb.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 1e4d68590178..f01389fd162e 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -274,7 +274,7 @@ static struct file *open_xa_file(const struct inode *inode, const char *name,
  */
 static int __xattr_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode *inode = filp->f_dentry->d_inode;
+	struct inode *inode = filp->f_path.dentry->d_inode;
 	struct cpu_key pos_key;	/* key of current position in the directory (key of directory entry) */
 	INITIALIZE_PATH(path_to_entry);
 	struct buffer_head *bh;
@@ -420,7 +420,7 @@ static int __xattr_readdir(struct file *filp, void *dirent, filldir_t filldir)
 static
 int xattr_readdir(struct file *file, filldir_t filler, void *buf)
 {
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = file->f_path.dentry->d_inode;
 	int res = -ENOTDIR;
 	if (!file->f_op || !file->f_op->readdir)
 		goto out;
@@ -508,7 +508,7 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 		goto out;
 	}
 
-	xinode = fp->f_dentry->d_inode;
+	xinode = fp->f_path.dentry->d_inode;
 	REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
 
 	/* we need to copy it off.. */
@@ -527,7 +527,7 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	newattrs.ia_size = buffer_size;
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
 	mutex_lock(&xinode->i_mutex);
-	err = notify_change(fp->f_dentry, &newattrs);
+	err = notify_change(fp->f_path.dentry, &newattrs);
 	if (err)
 		goto out_filp;
 
@@ -626,7 +626,7 @@ reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
 		goto out;
 	}
 
-	xinode = fp->f_dentry->d_inode;
+	xinode = fp->f_path.dentry->d_inode;
 	isize = xinode->i_size;
 	REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
 

commit 3277c39f8d706afb6fefc02f49563a73bbd405b9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Nov 14 21:13:53 2006 -0800

    [NET]: Kill direct includes of asm/checksum.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 7bdb0ed443e1..1e4d68590178 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -41,7 +41,7 @@
 #include <linux/reiserfs_xattr.h>
 #include <linux/reiserfs_acl.h>
 #include <asm/uaccess.h>
-#include <asm/checksum.h>
+#include <net/checksum.h>
 #include <linux/smp_lock.h>
 #include <linux/stat.h>
 #include <asm/semaphore.h>

commit afefdbb28a0a2af689926c30b94a14aea6036719
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 3 01:13:46 2006 -0700

    [PATCH] VFS: Make filldir_t and struct kstat deal in 64-bit inode numbers
    
    These patches make the kernel pass 64-bit inode numbers internally when
    communicating to userspace, even on a 32-bit system.  They are required
    because some filesystems have intrinsic 64-bit inode numbers: NFS3+ and XFS
    for example.  The 64-bit inode numbers are then propagated to userspace
    automatically where the arch supports it.
    
    Problems have been seen with userspace (eg: ld.so) using the 64-bit inode
    number returned by stat64() or getdents64() to differentiate files, and
    failing because the 64-bit inode number space was compressed to 32-bits, and
    so overlaps occur.
    
    This patch:
    
    Make filldir_t take a 64-bit inode number and struct kstat carry a 64-bit
    inode number so that 64-bit inode numbers can be passed back to userspace.
    
    The stat functions then returns the full 64-bit inode number where
    available and where possible.  If it is not possible to represent the inode
    number supplied by the filesystem in the field provided by userspace, then
    error EOVERFLOW will be issued.
    
    Similarly, the getdents/readdir functions now pass the full 64-bit inode
    number to userspace where possible, returning EOVERFLOW instead when a
    directory entry is encountered that can't be properly represented.
    
    Note that this means that some inodes will not be stat'able on a 32-bit
    system with old libraries where they were before - but it does mean that
    there will be no ambiguity over what a 32-bit inode number refers to.
    
    Note similarly that directory scans may be cut short with an error on a
    32-bit system with old libraries where the scan would work before for the
    same reasons.
    
    It is judged unlikely that this situation will occur because modern glibc
    uses 64-bit capable versions of stat and getdents class functions
    exclusively, and that older systems are unlikely to encounter
    unrepresentable inode numbers anyway.
    
    [akpm: alpha build fix]
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index d935fb9394e3..7bdb0ed443e1 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -773,7 +773,7 @@ int reiserfs_xattr_del(struct inode *inode, const char *name)
 
 static int
 reiserfs_delete_xattrs_filler(void *buf, const char *name, int namelen,
-			      loff_t offset, ino_t ino, unsigned int d_type)
+			      loff_t offset, u64 ino, unsigned int d_type)
 {
 	struct dentry *xadir = (struct dentry *)buf;
 
@@ -851,7 +851,7 @@ struct reiserfs_chown_buf {
 /* XXX: If there is a better way to do this, I'd love to hear about it */
 static int
 reiserfs_chown_xattrs_filler(void *buf, const char *name, int namelen,
-			     loff_t offset, ino_t ino, unsigned int d_type)
+			     loff_t offset, u64 ino, unsigned int d_type)
 {
 	struct reiserfs_chown_buf *chown_buf = (struct reiserfs_chown_buf *)buf;
 	struct dentry *xafile, *xadir = chown_buf->xadir;
@@ -1036,7 +1036,7 @@ struct reiserfs_listxattr_buf {
 
 static int
 reiserfs_listxattr_filler(void *buf, const char *name, int namelen,
-			  loff_t offset, ino_t ino, unsigned int d_type)
+			  loff_t offset, u64 ino, unsigned int d_type)
 {
 	struct reiserfs_listxattr_buf *b = (struct reiserfs_listxattr_buf *)buf;
 	int len = 0;

commit 4df46240a1312161e3c794f6ace50ef7eb5ff3d7
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Aug 27 01:23:56 2006 -0700

    [PATCH] lockdep: annotate reiserfs
    
    reiserfs seems to have another locking level layer for the i_mutex due to the
    xattrs-are-a-directory thing.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 39fedaa88a0c..d935fb9394e3 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -424,7 +424,7 @@ int xattr_readdir(struct file *file, filldir_t filler, void *buf)
 	int res = -ENOTDIR;
 	if (!file->f_op || !file->f_op->readdir)
 		goto out;
-	mutex_lock(&inode->i_mutex);
+	mutex_lock_nested(&inode->i_mutex, I_MUTEX_XATTR);
 //        down(&inode->i_zombie);
 	res = -ENOENT;
 	if (!IS_DEADDIR(inode)) {

commit 090d2b185d8680fc26a2eaf4245d4171dcf4baf1
Author: Pekka Enberg <penberg@cs.helsinki.fi>
Date:   Fri Jun 23 02:05:08 2006 -0700

    [PATCH] read_mapping_page for address space
    
    Add read_mapping_page() which is used for callers that pass
    mapping->a_ops->readpage as the filler for read_cache_page.  This removes
    some duplication from filesystem code.
    
    Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index ffb79c48c5bf..39fedaa88a0c 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -452,8 +452,7 @@ static struct page *reiserfs_get_page(struct inode *dir, unsigned long n)
 	/* We can deadlock if we try to free dentries,
 	   and an unlink/rmdir has just occured - GFP_NOFS avoids this */
 	mapping_set_gfp_mask(mapping, GFP_NOFS);
-	page = read_cache_page(mapping, n,
-			       (filler_t *) mapping->a_ops->readpage, NULL);
+	page = read_mapping_page(mapping, n, NULL);
 	if (!IS_ERR(page)) {
 		wait_on_page_locked(page);
 		kmap(page);

commit ec191574b9c3cb7bfb95e4f803b63f7c8dc52690
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Feb 1 03:06:46 2006 -0800

    [PATCH] reiserfs: use generic_permission
    
    Use the generic_permission code with a proper wrapper and callback instead
    of having a local copy.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Chris Mason <mason@suse.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 2f085845f670..ffb79c48c5bf 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -1319,95 +1319,44 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 	return err;
 }
 
-int reiserfs_permission(struct inode *inode, int mask, struct nameidata *nd)
+static int reiserfs_check_acl(struct inode *inode, int mask)
 {
-	umode_t mode = inode->i_mode;
-
-	if (mask & MAY_WRITE) {
-		/*
-		 * Nobody gets write access to a read-only fs.
-		 */
-		if (IS_RDONLY(inode) &&
-		    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
-			return -EROFS;
-
-		/*
-		 * Nobody gets write access to an immutable file.
-		 */
-		if (IS_IMMUTABLE(inode))
-			return -EACCES;
-	}
-
-	/* We don't do permission checks on the internal objects.
-	 * Permissions are determined by the "owning" object. */
-	if (is_reiserfs_priv_object(inode))
-		return 0;
-
-	if (current->fsuid == inode->i_uid) {
-		mode >>= 6;
-#ifdef CONFIG_REISERFS_FS_POSIX_ACL
-	} else if (reiserfs_posixacl(inode->i_sb) &&
-		   get_inode_sd_version(inode) != STAT_DATA_V1) {
-		struct posix_acl *acl;
-
-		/* ACL can't contain additional permissions if
-		   the ACL_MASK entry is 0 */
-		if (!(mode & S_IRWXG))
-			goto check_groups;
+	struct posix_acl *acl;
+	int error = -EAGAIN; /* do regular unix permission checks by default */
 
-		reiserfs_read_lock_xattr_i(inode);
-		reiserfs_read_lock_xattrs(inode->i_sb);
-
-		acl = reiserfs_get_acl(inode, ACL_TYPE_ACCESS);
+	reiserfs_read_lock_xattr_i(inode);
+	reiserfs_read_lock_xattrs(inode->i_sb);
 
-		reiserfs_read_unlock_xattrs(inode->i_sb);
-		reiserfs_read_unlock_xattr_i(inode);
+	acl = reiserfs_get_acl(inode, ACL_TYPE_ACCESS);
 
-		if (IS_ERR(acl)) {
-			if (PTR_ERR(acl) == -ENODATA)
-				goto check_groups;
-			return PTR_ERR(acl);
-		}
+	reiserfs_read_unlock_xattrs(inode->i_sb);
+	reiserfs_read_unlock_xattr_i(inode);
 
-		if (acl) {
-			int err = posix_acl_permission(inode, acl, mask);
+	if (acl) {
+		if (!IS_ERR(acl)) {
+			error = posix_acl_permission(inode, acl, mask);
 			posix_acl_release(acl);
-			if (err == -EACCES) {
-				goto check_capabilities;
-			}
-			return err;
-		} else {
-			goto check_groups;
-		}
-#endif
-	} else {
-	      check_groups:
-		if (in_group_p(inode->i_gid))
-			mode >>= 3;
+		} else if (PTR_ERR(acl) != -ENODATA)
+			error = PTR_ERR(acl);
 	}
 
-	/*
-	 * If the DACs are ok we don't need any capability check.
-	 */
-	if (((mode & mask & (MAY_READ | MAY_WRITE | MAY_EXEC)) == mask))
-		return 0;
+	return error;
+}
 
-      check_capabilities:
+int reiserfs_permission(struct inode *inode, int mask, struct nameidata *nd)
+{
 	/*
-	 * Read/write DACs are always overridable.
-	 * Executable DACs are overridable if at least one exec bit is set.
+	 * We don't do permission checks on the internal objects.
+	 * Permissions are determined by the "owning" object.
 	 */
-	if (!(mask & MAY_EXEC) ||
-	    (inode->i_mode & S_IXUGO) || S_ISDIR(inode->i_mode))
-		if (capable(CAP_DAC_OVERRIDE))
-			return 0;
+	if (is_reiserfs_priv_object(inode))
+		return 0;
 
 	/*
-	 * Searching includes executable on directories, else just read.
+	 * Stat data v1 doesn't support ACLs.
 	 */
-	if (mask == MAY_READ || (S_ISDIR(inode->i_mode) && !(mask & MAY_WRITE)))
-		if (capable(CAP_DAC_READ_SEARCH))
-			return 0;
-
-	return -EACCES;
+	if (get_inode_sd_version(inode) == STAT_DATA_V1)
+		return generic_permission(inode, mask, NULL);
+	else
+		return generic_permission(inode, mask, reiserfs_check_acl);
 }

commit c87d0c07ea198db1ce451421904edd60b7d385ee
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Feb 1 03:06:45 2006 -0800

    [PATCH] reiserfs: remove reiserfs_permission_locked
    
    This function is completely unused since the xattr permission checking
    changes.  Remove it and fold __reiserfs_permission into
    reiserfs_permission.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Chris Mason <mason@suse.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 4f0db4e54517..2f085845f670 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -1319,9 +1319,7 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 	return err;
 }
 
-static int
-__reiserfs_permission(struct inode *inode, int mask, struct nameidata *nd,
-		      int need_lock)
+int reiserfs_permission(struct inode *inode, int mask, struct nameidata *nd)
 {
 	umode_t mode = inode->i_mode;
 
@@ -1357,15 +1355,14 @@ __reiserfs_permission(struct inode *inode, int mask, struct nameidata *nd,
 		if (!(mode & S_IRWXG))
 			goto check_groups;
 
-		if (need_lock) {
-			reiserfs_read_lock_xattr_i(inode);
-			reiserfs_read_lock_xattrs(inode->i_sb);
-		}
+		reiserfs_read_lock_xattr_i(inode);
+		reiserfs_read_lock_xattrs(inode->i_sb);
+
 		acl = reiserfs_get_acl(inode, ACL_TYPE_ACCESS);
-		if (need_lock) {
-			reiserfs_read_unlock_xattrs(inode->i_sb);
-			reiserfs_read_unlock_xattr_i(inode);
-		}
+
+		reiserfs_read_unlock_xattrs(inode->i_sb);
+		reiserfs_read_unlock_xattr_i(inode);
+
 		if (IS_ERR(acl)) {
 			if (PTR_ERR(acl) == -ENODATA)
 				goto check_groups;
@@ -1414,14 +1411,3 @@ __reiserfs_permission(struct inode *inode, int mask, struct nameidata *nd,
 
 	return -EACCES;
 }
-
-int reiserfs_permission(struct inode *inode, int mask, struct nameidata *nd)
-{
-	return __reiserfs_permission(inode, mask, nd, 1);
-}
-
-int
-reiserfs_permission_locked(struct inode *inode, int mask, struct nameidata *nd)
-{
-	return __reiserfs_permission(inode, mask, nd, 0);
-}

commit d739b42b82773206297db1fc0d96ef895a5d9688
Author: Pekka Enberg <penberg@cs.helsinki.fi>
Date:   Wed Feb 1 03:06:43 2006 -0800

    [PATCH] reiserfs: remove kmalloc wrapper
    
    Remove kmalloc() wrapper from fs/reiserfs/.  Please note that a reiserfs
    /proc entry format is changed because kmalloc statistics is removed.
    
    Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index cc061bfd437b..4f0db4e54517 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -368,15 +368,13 @@ static int __xattr_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		if (d_reclen <= 32) {
 			local_buf = small_buf;
 		} else {
-			local_buf =
-			    reiserfs_kmalloc(d_reclen, GFP_NOFS, inode->i_sb);
+			local_buf = kmalloc(d_reclen, GFP_NOFS);
 			if (!local_buf) {
 				pathrelse(&path_to_entry);
 				return -ENOMEM;
 			}
 			if (item_moved(&tmp_ih, &path_to_entry)) {
-				reiserfs_kfree(local_buf, d_reclen,
-					       inode->i_sb);
+				kfree(local_buf);
 
 				/* sigh, must retry.  Do this same offset again */
 				next_pos = d_off;
@@ -399,13 +397,12 @@ static int __xattr_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		if (filldir(dirent, local_buf, d_reclen, d_off, d_ino,
 			    DT_UNKNOWN) < 0) {
 			if (local_buf != small_buf) {
-				reiserfs_kfree(local_buf, d_reclen,
-					       inode->i_sb);
+				kfree(local_buf);
 			}
 			goto end;
 		}
 		if (local_buf != small_buf) {
-			reiserfs_kfree(local_buf, d_reclen, inode->i_sb);
+			kfree(local_buf);
 		}
 	}			/* while */
 

commit 16f7e0fe2ecc30f30652e8185e1772cdebe39109
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Wed Jan 11 12:17:46 2006 -0800

    [PATCH] capable/capability.h (fs/)
    
    fs: Use <linux/capability.h> where capable() is used.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Acked-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 6f99e01f94ab..cc061bfd437b 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -30,6 +30,7 @@
  */
 
 #include <linux/reiserfs_fs.h>
+#include <linux/capability.h>
 #include <linux/dcache.h>
 #include <linux/namei.h>
 #include <linux/errno.h>

commit b98932cb514eef404c6168c9a15cf28851498dea
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 9 20:51:59 2006 -0800

    [PATCH] remove reiserfs xattr permission checks
    
    remove checks now in the VFS
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index f1895f0a278e..6f99e01f94ab 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -497,12 +497,6 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	struct iattr newattrs;
 	__u32 xahash = 0;
 
-	if (IS_RDONLY(inode))
-		return -EROFS;
-
-	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
-		return -EPERM;
-
 	if (get_inode_sd_version(inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
@@ -758,9 +752,6 @@ int reiserfs_xattr_del(struct inode *inode, const char *name)
 	struct dentry *dir;
 	int err;
 
-	if (IS_RDONLY(inode))
-		return -EROFS;
-
 	dir = open_xa_dir(inode, FL_READONLY);
 	if (IS_ERR(dir)) {
 		err = PTR_ERR(dir);
@@ -984,12 +975,6 @@ reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	if (IS_RDONLY(dentry->d_inode))
-		return -EROFS;
-
-	if (IS_IMMUTABLE(dentry->d_inode) || IS_APPEND(dentry->d_inode))
-		return -EROFS;
-
 	reiserfs_write_lock_xattr_i(dentry->d_inode);
 	lock = !has_xattr_dir(dentry->d_inode);
 	if (lock)
@@ -1019,12 +1004,6 @@ int reiserfs_removexattr(struct dentry *dentry, const char *name)
 	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	if (IS_RDONLY(dentry->d_inode))
-		return -EROFS;
-
-	if (IS_IMMUTABLE(dentry->d_inode) || IS_APPEND(dentry->d_inode))
-		return -EPERM;
-
 	reiserfs_write_lock_xattr_i(dentry->d_inode);
 	reiserfs_read_lock_xattrs(dentry->d_sb);
 

commit 1b1dcc1b57a49136f118a0f16367256ff9994a69
Author: Jes Sorensen <jes@sgi.com>
Date:   Mon Jan 9 15:59:24 2006 -0800

    [PATCH] mutex subsystem, semaphore to mutex: VFS, ->i_sem
    
    This patch converts the inode semaphore to a mutex. I have tested it on
    XFS and compiled as much as one can consider on an ia64. Anyway your
    luck with it might be different.
    
    Modified-by: Ingo Molnar <mingo@elte.hu>
    
    (finished the conversion)
    
    Signed-off-by: Jes Sorensen <jes@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 02091eaac0b4..f1895f0a278e 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -67,11 +67,11 @@ static struct dentry *create_xa_root(struct super_block *sb)
 		goto out;
 	} else if (!xaroot->d_inode) {
 		int err;
-		down(&privroot->d_inode->i_sem);
+		mutex_lock(&privroot->d_inode->i_mutex);
 		err =
 		    privroot->d_inode->i_op->mkdir(privroot->d_inode, xaroot,
 						   0700);
-		up(&privroot->d_inode->i_sem);
+		mutex_unlock(&privroot->d_inode->i_mutex);
 
 		if (err) {
 			dput(xaroot);
@@ -219,7 +219,7 @@ static struct dentry *get_xa_file_dentry(const struct inode *inode,
 	} else if (flags & XATTR_REPLACE || flags & FL_READONLY) {
 		goto out;
 	} else {
-		/* inode->i_sem is down, so nothing else can try to create
+		/* inode->i_mutex is down, so nothing else can try to create
 		 * the same xattr */
 		err = xadir->d_inode->i_op->create(xadir->d_inode, xafile,
 						   0700 | S_IFREG, NULL);
@@ -268,7 +268,7 @@ static struct file *open_xa_file(const struct inode *inode, const char *name,
  * and don't mess with f->f_pos, but the idea is the same.  Do some
  * action on each and every entry in the directory.
  *
- * we're called with i_sem held, so there are no worries about the directory
+ * we're called with i_mutex held, so there are no worries about the directory
  * changing underneath us.
  */
 static int __xattr_readdir(struct file *filp, void *dirent, filldir_t filldir)
@@ -426,7 +426,7 @@ int xattr_readdir(struct file *file, filldir_t filler, void *buf)
 	int res = -ENOTDIR;
 	if (!file->f_op || !file->f_op->readdir)
 		goto out;
-	down(&inode->i_sem);
+	mutex_lock(&inode->i_mutex);
 //        down(&inode->i_zombie);
 	res = -ENOENT;
 	if (!IS_DEADDIR(inode)) {
@@ -435,7 +435,7 @@ int xattr_readdir(struct file *file, filldir_t filler, void *buf)
 		unlock_kernel();
 	}
 //        up(&inode->i_zombie);
-	up(&inode->i_sem);
+	mutex_unlock(&inode->i_mutex);
       out:
 	return res;
 }
@@ -480,7 +480,7 @@ static inline __u32 xattr_hash(const char *msg, int len)
 /* Generic extended attribute operations that can be used by xa plugins */
 
 /*
- * inode->i_sem: down
+ * inode->i_mutex: down
  */
 int
 reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
@@ -535,7 +535,7 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	/* Resize it so we're ok to write there */
 	newattrs.ia_size = buffer_size;
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
-	down(&xinode->i_sem);
+	mutex_lock(&xinode->i_mutex);
 	err = notify_change(fp->f_dentry, &newattrs);
 	if (err)
 		goto out_filp;
@@ -598,7 +598,7 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 	}
 
       out_filp:
-	up(&xinode->i_sem);
+	mutex_unlock(&xinode->i_mutex);
 	fput(fp);
 
       out:
@@ -606,7 +606,7 @@ reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
 }
 
 /*
- * inode->i_sem: down
+ * inode->i_mutex: down
  */
 int
 reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
@@ -793,7 +793,7 @@ reiserfs_delete_xattrs_filler(void *buf, const char *name, int namelen,
 
 }
 
-/* This is called w/ inode->i_sem downed */
+/* This is called w/ inode->i_mutex downed */
 int reiserfs_delete_xattrs(struct inode *inode)
 {
 	struct file *fp;
@@ -946,7 +946,7 @@ int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)
 
 /*
  * Inode operation getxattr()
- * Preliminary locking: we down dentry->d_inode->i_sem
+ * Preliminary locking: we down dentry->d_inode->i_mutex
  */
 ssize_t
 reiserfs_getxattr(struct dentry * dentry, const char *name, void *buffer,
@@ -970,7 +970,7 @@ reiserfs_getxattr(struct dentry * dentry, const char *name, void *buffer,
 /*
  * Inode operation setxattr()
  *
- * dentry->d_inode->i_sem down
+ * dentry->d_inode->i_mutex down
  */
 int
 reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
@@ -1008,7 +1008,7 @@ reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 /*
  * Inode operation removexattr()
  *
- * dentry->d_inode->i_sem down
+ * dentry->d_inode->i_mutex down
  */
 int reiserfs_removexattr(struct dentry *dentry, const char *name)
 {
@@ -1091,7 +1091,7 @@ reiserfs_listxattr_filler(void *buf, const char *name, int namelen,
 /*
  * Inode operation listxattr()
  *
- * Preliminary locking: we down dentry->d_inode->i_sem
+ * Preliminary locking: we down dentry->d_inode->i_mutex
  */
 ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 {
@@ -1289,9 +1289,9 @@ int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 		if (!IS_ERR(dentry)) {
 			if (!(mount_flags & MS_RDONLY) && !dentry->d_inode) {
 				struct inode *inode = dentry->d_parent->d_inode;
-				down(&inode->i_sem);
+				mutex_lock(&inode->i_mutex);
 				err = inode->i_op->mkdir(inode, dentry, 0700);
-				up(&inode->i_sem);
+				mutex_unlock(&inode->i_mutex);
 				if (err) {
 					dput(dentry);
 					dentry = NULL;

commit 4a4efbdee278b2f4ed91aad2db5c006ff754276e
Author: Matt Mackall <mpm@selenic.com>
Date:   Tue Jan 3 13:27:11 2006 +0100

    s/retreiv/retriev/g
    
    As everyone knows, the rule is: "i before e.. um.. always."
    
    Signed-off-by: Matt Mackall <mpm@selenic.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 72e120798677..02091eaac0b4 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -115,8 +115,8 @@ static struct dentry *__get_xa_root(struct super_block *s)
 }
 
 /* Returns the dentry (or NULL) referring to the root of the extended
- * attribute directory tree. If it has already been retreived, it is used.
- * Otherwise, we attempt to retreive it from disk. It may also return
+ * attribute directory tree. If it has already been retrieved, it is used.
+ * Otherwise, we attempt to retrieve it from disk. It may also return
  * a pointer-encoded error.
  */
 static inline struct dentry *get_xa_root(struct super_block *s)

commit c4cdd038318863e912e9b992489f61497f98b442
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 21 03:22:39 2005 -0400

    [PATCH] gfp_t: reiserfs mapping_set_gfp_mask() use
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 87ac9dc8b381..72e120798677 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -453,7 +453,7 @@ static struct page *reiserfs_get_page(struct inode *dir, unsigned long n)
 	struct page *page;
 	/* We can deadlock if we try to free dentries,
 	   and an unlink/rmdir has just occured - GFP_NOFS avoids this */
-	mapping->flags = (mapping->flags & ~__GFP_BITS_MASK) | GFP_NOFS;
+	mapping_set_gfp_mask(mapping, GFP_NOFS);
 	page = read_cache_page(mapping, n,
 			       (filler_t *) mapping->a_ops->readpage, NULL);
 	if (!IS_ERR(page)) {

commit 02b775696fee75a04041d8d94db26a9462216d24
Author: Andreas Gruenbacher <agruen@suse.de>
Date:   Wed Jul 27 11:45:16 2005 -0700

    [PATCH] reiserfs doesn't use mbcache
    
    reiserfs doesn't use the mbcache, so this can go.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index e386d3db3051..87ac9dc8b381 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -39,7 +39,6 @@
 #include <linux/xattr.h>
 #include <linux/reiserfs_xattr.h>
 #include <linux/reiserfs_acl.h>
-#include <linux/mbcache.h>
 #include <asm/uaccess.h>
 #include <asm/checksum.h>
 #include <linux/smp_lock.h>

commit bd4c625c061c2a38568d0add3478f59172455159
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Tue Jul 12 20:21:28 2005 -0700

    reiserfs: run scripts/Lindent on reiserfs code
    
    This was a pure indentation change, using:
    
            scripts/Lindent fs/reiserfs/*.c include/linux/reiserfs_*.h
    
    to make reiserfs match the regular Linux indentation style.  As Jeff
    Mahoney <jeffm@suse.com> writes:
    
     The ReiserFS code is a mix of a number of different coding styles, sometimes
     different even from line-to-line. Since the code has been relatively stable
     for quite some time and there are few outstanding patches to be applied, it
     is time to reformat the code to conform to the Linux style standard outlined
     in Documentation/CodingStyle.
    
     This patch contains the result of running scripts/Lindent against
     fs/reiserfs/*.c and include/linux/reiserfs_*.h. There are places where the
     code can be made to look better, but I'd rather keep those patches separate
     so that there isn't a subtle by-hand hand accident in the middle of a huge
     patch. To be clear: This patch is reformatting *only*.
    
     A number of patches may follow that continue to make the code more consistent
     with the Linux coding style.
    
     Hans wasn't particularly enthusiastic about these patches, but said he
     wouldn't really oppose them either.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 45582fe8b466..e386d3db3051 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -51,67 +51,68 @@
 #define PRIVROOT_NAME ".reiserfs_priv"
 #define XAROOT_NAME   "xattrs"
 
-static struct reiserfs_xattr_handler *find_xattr_handler_prefix (const char *prefix);
+static struct reiserfs_xattr_handler *find_xattr_handler_prefix(const char
+								*prefix);
 
-static struct dentry *
-create_xa_root (struct super_block *sb)
+static struct dentry *create_xa_root(struct super_block *sb)
 {
-    struct dentry *privroot = dget (REISERFS_SB(sb)->priv_root);
-    struct dentry *xaroot;
-
-    /* This needs to be created at mount-time */
-    if (!privroot)
-        return ERR_PTR(-EOPNOTSUPP);
-
-    xaroot = lookup_one_len (XAROOT_NAME, privroot, strlen (XAROOT_NAME));
-    if (IS_ERR (xaroot)) {
-        goto out;
-    } else if (!xaroot->d_inode) {
-        int err;
-        down (&privroot->d_inode->i_sem);
-        err = privroot->d_inode->i_op->mkdir (privroot->d_inode, xaroot, 0700);
-        up (&privroot->d_inode->i_sem);
-
-        if (err) {
-            dput (xaroot);
-            dput (privroot);
-            return ERR_PTR (err);
-        }
-        REISERFS_SB(sb)->xattr_root = dget (xaroot);
-    }
-
-out:
-    dput (privroot);
-    return xaroot;
+	struct dentry *privroot = dget(REISERFS_SB(sb)->priv_root);
+	struct dentry *xaroot;
+
+	/* This needs to be created at mount-time */
+	if (!privroot)
+		return ERR_PTR(-EOPNOTSUPP);
+
+	xaroot = lookup_one_len(XAROOT_NAME, privroot, strlen(XAROOT_NAME));
+	if (IS_ERR(xaroot)) {
+		goto out;
+	} else if (!xaroot->d_inode) {
+		int err;
+		down(&privroot->d_inode->i_sem);
+		err =
+		    privroot->d_inode->i_op->mkdir(privroot->d_inode, xaroot,
+						   0700);
+		up(&privroot->d_inode->i_sem);
+
+		if (err) {
+			dput(xaroot);
+			dput(privroot);
+			return ERR_PTR(err);
+		}
+		REISERFS_SB(sb)->xattr_root = dget(xaroot);
+	}
+
+      out:
+	dput(privroot);
+	return xaroot;
 }
 
 /* This will return a dentry, or error, refering to the xa root directory.
  * If the xa root doesn't exist yet, the dentry will be returned without
  * an associated inode. This dentry can be used with ->mkdir to create
  * the xa directory. */
-static struct dentry *
-__get_xa_root (struct super_block *s)
+static struct dentry *__get_xa_root(struct super_block *s)
 {
-    struct dentry *privroot = dget (REISERFS_SB(s)->priv_root);
-    struct dentry *xaroot = NULL;
-
-    if (IS_ERR (privroot) || !privroot)
-        return privroot;
-
-    xaroot = lookup_one_len (XAROOT_NAME, privroot, strlen (XAROOT_NAME));
-    if (IS_ERR (xaroot)) {
-        goto out;
-    } else if (!xaroot->d_inode) {
-        dput (xaroot);
-        xaroot = NULL;
-        goto out;
-    }
-
-    REISERFS_SB(s)->xattr_root = dget (xaroot);
-
-out:
-    dput (privroot);
-    return xaroot;
+	struct dentry *privroot = dget(REISERFS_SB(s)->priv_root);
+	struct dentry *xaroot = NULL;
+
+	if (IS_ERR(privroot) || !privroot)
+		return privroot;
+
+	xaroot = lookup_one_len(XAROOT_NAME, privroot, strlen(XAROOT_NAME));
+	if (IS_ERR(xaroot)) {
+		goto out;
+	} else if (!xaroot->d_inode) {
+		dput(xaroot);
+		xaroot = NULL;
+		goto out;
+	}
+
+	REISERFS_SB(s)->xattr_root = dget(xaroot);
+
+      out:
+	dput(privroot);
+	return xaroot;
 }
 
 /* Returns the dentry (or NULL) referring to the root of the extended
@@ -119,147 +120,145 @@ __get_xa_root (struct super_block *s)
  * Otherwise, we attempt to retreive it from disk. It may also return
  * a pointer-encoded error.
  */
-static inline struct dentry *
-get_xa_root (struct super_block *s)
+static inline struct dentry *get_xa_root(struct super_block *s)
 {
-    struct dentry *dentry = dget (REISERFS_SB(s)->xattr_root);
+	struct dentry *dentry = dget(REISERFS_SB(s)->xattr_root);
 
-    if (!dentry)
-        dentry = __get_xa_root (s);
+	if (!dentry)
+		dentry = __get_xa_root(s);
 
-    return dentry;
+	return dentry;
 }
 
 /* Opens the directory corresponding to the inode's extended attribute store.
  * If flags allow, the tree to the directory may be created. If creation is
  * prohibited, -ENODATA is returned. */
-static struct dentry *
-open_xa_dir (const struct inode *inode, int flags)
+static struct dentry *open_xa_dir(const struct inode *inode, int flags)
 {
-    struct dentry *xaroot, *xadir;
-    char namebuf[17];
-
-    xaroot = get_xa_root (inode->i_sb);
-    if (IS_ERR (xaroot)) {
-        return xaroot;
-    } else if (!xaroot) {
-        if (flags == 0 || flags & XATTR_CREATE) {
-            xaroot = create_xa_root (inode->i_sb);
-            if (IS_ERR (xaroot))
-                return xaroot;
-        }
-        if (!xaroot)
-            return ERR_PTR (-ENODATA);
-    }
-
-    /* ok, we have xaroot open */
-
-    snprintf (namebuf, sizeof (namebuf), "%X.%X",
-              le32_to_cpu (INODE_PKEY (inode)->k_objectid),
-              inode->i_generation);
-    xadir = lookup_one_len (namebuf, xaroot, strlen (namebuf));
-    if (IS_ERR (xadir)) {
-        dput (xaroot);
-        return xadir;
-    }
-
-    if (!xadir->d_inode) {
-        int err;
-        if (flags == 0 || flags & XATTR_CREATE) {
-            /* Although there is nothing else trying to create this directory,
-             * another directory with the same hash may be created, so we need
-             * to protect against that */
-            err = xaroot->d_inode->i_op->mkdir (xaroot->d_inode, xadir, 0700);
-            if (err) {
-                dput (xaroot);
-                dput (xadir);
-                return ERR_PTR (err);
-            }
-        }
-        if (!xadir->d_inode) {
-            dput (xaroot);
-            dput (xadir);
-            return ERR_PTR (-ENODATA);
-        }
-    }
-
-    dput (xaroot);
-    return xadir;
+	struct dentry *xaroot, *xadir;
+	char namebuf[17];
+
+	xaroot = get_xa_root(inode->i_sb);
+	if (IS_ERR(xaroot)) {
+		return xaroot;
+	} else if (!xaroot) {
+		if (flags == 0 || flags & XATTR_CREATE) {
+			xaroot = create_xa_root(inode->i_sb);
+			if (IS_ERR(xaroot))
+				return xaroot;
+		}
+		if (!xaroot)
+			return ERR_PTR(-ENODATA);
+	}
+
+	/* ok, we have xaroot open */
+
+	snprintf(namebuf, sizeof(namebuf), "%X.%X",
+		 le32_to_cpu(INODE_PKEY(inode)->k_objectid),
+		 inode->i_generation);
+	xadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));
+	if (IS_ERR(xadir)) {
+		dput(xaroot);
+		return xadir;
+	}
+
+	if (!xadir->d_inode) {
+		int err;
+		if (flags == 0 || flags & XATTR_CREATE) {
+			/* Although there is nothing else trying to create this directory,
+			 * another directory with the same hash may be created, so we need
+			 * to protect against that */
+			err =
+			    xaroot->d_inode->i_op->mkdir(xaroot->d_inode, xadir,
+							 0700);
+			if (err) {
+				dput(xaroot);
+				dput(xadir);
+				return ERR_PTR(err);
+			}
+		}
+		if (!xadir->d_inode) {
+			dput(xaroot);
+			dput(xadir);
+			return ERR_PTR(-ENODATA);
+		}
+	}
+
+	dput(xaroot);
+	return xadir;
 }
 
 /* Returns a dentry corresponding to a specific extended attribute file
  * for the inode. If flags allow, the file is created. Otherwise, a
  * valid or negative dentry, or an error is returned. */
-static struct dentry *
-get_xa_file_dentry (const struct inode *inode, const char *name, int flags)
+static struct dentry *get_xa_file_dentry(const struct inode *inode,
+					 const char *name, int flags)
 {
-    struct dentry *xadir, *xafile;
-    int err = 0;
-
-    xadir = open_xa_dir (inode, flags);
-    if (IS_ERR (xadir)) {
-        return ERR_PTR (PTR_ERR (xadir));
-    } else if (xadir && !xadir->d_inode) {
-        dput (xadir);
-        return ERR_PTR (-ENODATA);
-    }
-
-    xafile = lookup_one_len (name, xadir, strlen (name));
-    if (IS_ERR (xafile)) {
-        dput (xadir);
-        return ERR_PTR (PTR_ERR (xafile));
-    }
-
-    if (xafile->d_inode) { /* file exists */
-        if (flags & XATTR_CREATE) {
-            err = -EEXIST;
-            dput (xafile);
-            goto out;
-        }
-    } else if (flags & XATTR_REPLACE || flags & FL_READONLY) {
-        goto out;
-    } else {
-        /* inode->i_sem is down, so nothing else can try to create
-         * the same xattr */
-        err = xadir->d_inode->i_op->create (xadir->d_inode, xafile,
-                                            0700|S_IFREG, NULL);
-
-        if (err) {
-            dput (xafile);
-            goto out;
-        }
-    }
-
-out:
-    dput (xadir);
-    if (err)
-        xafile = ERR_PTR (err);
-    return xafile;
-}
+	struct dentry *xadir, *xafile;
+	int err = 0;
+
+	xadir = open_xa_dir(inode, flags);
+	if (IS_ERR(xadir)) {
+		return ERR_PTR(PTR_ERR(xadir));
+	} else if (xadir && !xadir->d_inode) {
+		dput(xadir);
+		return ERR_PTR(-ENODATA);
+	}
+
+	xafile = lookup_one_len(name, xadir, strlen(name));
+	if (IS_ERR(xafile)) {
+		dput(xadir);
+		return ERR_PTR(PTR_ERR(xafile));
+	}
+
+	if (xafile->d_inode) {	/* file exists */
+		if (flags & XATTR_CREATE) {
+			err = -EEXIST;
+			dput(xafile);
+			goto out;
+		}
+	} else if (flags & XATTR_REPLACE || flags & FL_READONLY) {
+		goto out;
+	} else {
+		/* inode->i_sem is down, so nothing else can try to create
+		 * the same xattr */
+		err = xadir->d_inode->i_op->create(xadir->d_inode, xafile,
+						   0700 | S_IFREG, NULL);
+
+		if (err) {
+			dput(xafile);
+			goto out;
+		}
+	}
 
+      out:
+	dput(xadir);
+	if (err)
+		xafile = ERR_PTR(err);
+	return xafile;
+}
 
 /* Opens a file pointer to the attribute associated with inode */
-static struct file *
-open_xa_file (const struct inode *inode, const char *name, int flags)
+static struct file *open_xa_file(const struct inode *inode, const char *name,
+				 int flags)
 {
-    struct dentry *xafile;
-    struct file *fp;
-
-    xafile = get_xa_file_dentry (inode, name, flags);
-    if (IS_ERR (xafile))
-        return ERR_PTR (PTR_ERR (xafile));
-    else if (!xafile->d_inode) {
-        dput (xafile);
-        return ERR_PTR (-ENODATA);
-    }
+	struct dentry *xafile;
+	struct file *fp;
+
+	xafile = get_xa_file_dentry(inode, name, flags);
+	if (IS_ERR(xafile))
+		return ERR_PTR(PTR_ERR(xafile));
+	else if (!xafile->d_inode) {
+		dput(xafile);
+		return ERR_PTR(-ENODATA);
+	}
 
-    fp = dentry_open (xafile, NULL, O_RDWR);
-    /* dentry_open dputs the dentry if it fails */
+	fp = dentry_open(xafile, NULL, O_RDWR);
+	/* dentry_open dputs the dentry if it fails */
 
-    return fp;
+	return fp;
 }
 
-
 /*
  * this is very similar to fs/reiserfs/dir.c:reiserfs_readdir, but
  * we need to drop the path before calling the filldir struct.  That
@@ -273,139 +272,146 @@ open_xa_file (const struct inode *inode, const char *name, int flags)
  * we're called with i_sem held, so there are no worries about the directory
  * changing underneath us.
  */
-static int __xattr_readdir(struct file * filp, void * dirent, filldir_t filldir)
+static int __xattr_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-    struct inode *inode = filp->f_dentry->d_inode;
-    struct cpu_key pos_key;	/* key of current position in the directory (key of directory entry) */
-    INITIALIZE_PATH (path_to_entry);
-    struct buffer_head * bh;
-    int entry_num;
-    struct item_head * ih, tmp_ih;
-    int search_res;
-    char * local_buf;
-    loff_t next_pos;
-    char small_buf[32] ; /* avoid kmalloc if we can */
-    struct reiserfs_de_head *deh;
-    int d_reclen;
-    char * d_name;
-    off_t d_off;
-    ino_t d_ino;
-    struct reiserfs_dir_entry de;
-
-
-    /* form key for search the next directory entry using f_pos field of
-       file structure */
-    next_pos = max_reiserfs_offset(inode);
-
-    while (1) {
-research:
-	if (next_pos <= DOT_DOT_OFFSET)
-	    break;
-	make_cpu_key (&pos_key, inode, next_pos, TYPE_DIRENTRY, 3);
-
-	search_res = search_by_entry_key(inode->i_sb, &pos_key, &path_to_entry, &de);
-	if (search_res == IO_ERROR) {
-	    // FIXME: we could just skip part of directory which could
-	    // not be read
-	    pathrelse(&path_to_entry);
-	    return -EIO;
-	}
-
-	if (search_res == NAME_NOT_FOUND)
-	    de.de_entry_num--;
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct cpu_key pos_key;	/* key of current position in the directory (key of directory entry) */
+	INITIALIZE_PATH(path_to_entry);
+	struct buffer_head *bh;
+	int entry_num;
+	struct item_head *ih, tmp_ih;
+	int search_res;
+	char *local_buf;
+	loff_t next_pos;
+	char small_buf[32];	/* avoid kmalloc if we can */
+	struct reiserfs_de_head *deh;
+	int d_reclen;
+	char *d_name;
+	off_t d_off;
+	ino_t d_ino;
+	struct reiserfs_dir_entry de;
+
+	/* form key for search the next directory entry using f_pos field of
+	   file structure */
+	next_pos = max_reiserfs_offset(inode);
+
+	while (1) {
+	      research:
+		if (next_pos <= DOT_DOT_OFFSET)
+			break;
+		make_cpu_key(&pos_key, inode, next_pos, TYPE_DIRENTRY, 3);
+
+		search_res =
+		    search_by_entry_key(inode->i_sb, &pos_key, &path_to_entry,
+					&de);
+		if (search_res == IO_ERROR) {
+			// FIXME: we could just skip part of directory which could
+			// not be read
+			pathrelse(&path_to_entry);
+			return -EIO;
+		}
 
-	set_de_name_and_namelen(&de);
-	entry_num = de.de_entry_num;
-	deh = &(de.de_deh[entry_num]);
+		if (search_res == NAME_NOT_FOUND)
+			de.de_entry_num--;
 
-	bh = de.de_bh;
-	ih = de.de_ih;
+		set_de_name_and_namelen(&de);
+		entry_num = de.de_entry_num;
+		deh = &(de.de_deh[entry_num]);
 
-	if (!is_direntry_le_ih(ih)) {
-            reiserfs_warning(inode->i_sb, "not direntry %h", ih);
-	    break;
-        }
-	copy_item_head(&tmp_ih, ih);
+		bh = de.de_bh;
+		ih = de.de_ih;
 
-	/* we must have found item, that is item of this directory, */
-	RFALSE( COMP_SHORT_KEYS (&(ih->ih_key), &pos_key),
-		"vs-9000: found item %h does not match to dir we readdir %K",
-		ih, &pos_key);
+		if (!is_direntry_le_ih(ih)) {
+			reiserfs_warning(inode->i_sb, "not direntry %h", ih);
+			break;
+		}
+		copy_item_head(&tmp_ih, ih);
 
-	if (deh_offset(deh) <= DOT_DOT_OFFSET) {
-	    break;
-	}
+		/* we must have found item, that is item of this directory, */
+		RFALSE(COMP_SHORT_KEYS(&(ih->ih_key), &pos_key),
+		       "vs-9000: found item %h does not match to dir we readdir %K",
+		       ih, &pos_key);
 
-	/* look for the previous entry in the directory */
-	next_pos = deh_offset (deh) - 1;
+		if (deh_offset(deh) <= DOT_DOT_OFFSET) {
+			break;
+		}
 
-	if (!de_visible (deh))
-	    /* it is hidden entry */
-	    continue;
+		/* look for the previous entry in the directory */
+		next_pos = deh_offset(deh) - 1;
 
-	d_reclen = entry_length(bh, ih, entry_num);
-	d_name = B_I_DEH_ENTRY_FILE_NAME (bh, ih, deh);
-	d_off = deh_offset (deh);
-	d_ino = deh_objectid (deh);
+		if (!de_visible(deh))
+			/* it is hidden entry */
+			continue;
 
-	if (!d_name[d_reclen - 1])
-	    d_reclen = strlen (d_name);
+		d_reclen = entry_length(bh, ih, entry_num);
+		d_name = B_I_DEH_ENTRY_FILE_NAME(bh, ih, deh);
+		d_off = deh_offset(deh);
+		d_ino = deh_objectid(deh);
 
-	if (d_reclen > REISERFS_MAX_NAME(inode->i_sb->s_blocksize)){
-	    /* too big to send back to VFS */
-	    continue ;
-	}
+		if (!d_name[d_reclen - 1])
+			d_reclen = strlen(d_name);
 
-        /* Ignore the .reiserfs_priv entry */
-        if (reiserfs_xattrs (inode->i_sb) &&
-            !old_format_only(inode->i_sb) &&
-            deh_objectid (deh) == le32_to_cpu (INODE_PKEY(REISERFS_SB(inode->i_sb)->priv_root->d_inode)->k_objectid))
-          continue;
+		if (d_reclen > REISERFS_MAX_NAME(inode->i_sb->s_blocksize)) {
+			/* too big to send back to VFS */
+			continue;
+		}
 
-	if (d_reclen <= 32) {
-	  local_buf = small_buf ;
-	} else {
-	    local_buf = reiserfs_kmalloc(d_reclen, GFP_NOFS, inode->i_sb) ;
-	    if (!local_buf) {
-		pathrelse (&path_to_entry);
-		return -ENOMEM ;
-	    }
-	    if (item_moved (&tmp_ih, &path_to_entry)) {
-		reiserfs_kfree(local_buf, d_reclen, inode->i_sb) ;
-
-		/* sigh, must retry.  Do this same offset again */
-		next_pos = d_off;
-		goto research;
-	    }
-	}
+		/* Ignore the .reiserfs_priv entry */
+		if (reiserfs_xattrs(inode->i_sb) &&
+		    !old_format_only(inode->i_sb) &&
+		    deh_objectid(deh) ==
+		    le32_to_cpu(INODE_PKEY
+				(REISERFS_SB(inode->i_sb)->priv_root->d_inode)->
+				k_objectid))
+			continue;
+
+		if (d_reclen <= 32) {
+			local_buf = small_buf;
+		} else {
+			local_buf =
+			    reiserfs_kmalloc(d_reclen, GFP_NOFS, inode->i_sb);
+			if (!local_buf) {
+				pathrelse(&path_to_entry);
+				return -ENOMEM;
+			}
+			if (item_moved(&tmp_ih, &path_to_entry)) {
+				reiserfs_kfree(local_buf, d_reclen,
+					       inode->i_sb);
+
+				/* sigh, must retry.  Do this same offset again */
+				next_pos = d_off;
+				goto research;
+			}
+		}
 
-	// Note, that we copy name to user space via temporary
-	// buffer (local_buf) because filldir will block if
-	// user space buffer is swapped out. At that time
-	// entry can move to somewhere else
-	memcpy (local_buf, d_name, d_reclen);
+		// Note, that we copy name to user space via temporary
+		// buffer (local_buf) because filldir will block if
+		// user space buffer is swapped out. At that time
+		// entry can move to somewhere else
+		memcpy(local_buf, d_name, d_reclen);
 
-	/* the filldir function might need to start transactions,
-	 * or do who knows what.  Release the path now that we've
-	 * copied all the important stuff out of the deh
-	 */
-	pathrelse (&path_to_entry);
-
-	if (filldir (dirent, local_buf, d_reclen, d_off, d_ino,
-		     DT_UNKNOWN) < 0) {
-	    if (local_buf != small_buf) {
-		reiserfs_kfree(local_buf, d_reclen, inode->i_sb) ;
-	    }
-	    goto end;
-	}
-	if (local_buf != small_buf) {
-	    reiserfs_kfree(local_buf, d_reclen, inode->i_sb) ;
-	}
-    } /* while */
+		/* the filldir function might need to start transactions,
+		 * or do who knows what.  Release the path now that we've
+		 * copied all the important stuff out of the deh
+		 */
+		pathrelse(&path_to_entry);
+
+		if (filldir(dirent, local_buf, d_reclen, d_off, d_ino,
+			    DT_UNKNOWN) < 0) {
+			if (local_buf != small_buf) {
+				reiserfs_kfree(local_buf, d_reclen,
+					       inode->i_sb);
+			}
+			goto end;
+		}
+		if (local_buf != small_buf) {
+			reiserfs_kfree(local_buf, d_reclen, inode->i_sb);
+		}
+	}			/* while */
 
-end:
-    pathrelse (&path_to_entry);
-    return 0;
+      end:
+	pathrelse(&path_to_entry);
+	return 0;
 }
 
 /*
@@ -417,63 +423,59 @@ static int __xattr_readdir(struct file * filp, void * dirent, filldir_t filldir)
 static
 int xattr_readdir(struct file *file, filldir_t filler, void *buf)
 {
-        struct inode *inode = file->f_dentry->d_inode;
-        int res = -ENOTDIR;
-        if (!file->f_op || !file->f_op->readdir)
-                goto out;
-        down(&inode->i_sem);
+	struct inode *inode = file->f_dentry->d_inode;
+	int res = -ENOTDIR;
+	if (!file->f_op || !file->f_op->readdir)
+		goto out;
+	down(&inode->i_sem);
 //        down(&inode->i_zombie);
-        res = -ENOENT;
-        if (!IS_DEADDIR(inode)) {
-                lock_kernel();
-                res = __xattr_readdir(file, buf, filler);
-                unlock_kernel();
-        }
+	res = -ENOENT;
+	if (!IS_DEADDIR(inode)) {
+		lock_kernel();
+		res = __xattr_readdir(file, buf, filler);
+		unlock_kernel();
+	}
 //        up(&inode->i_zombie);
-        up(&inode->i_sem);
-out:
-        return res;
+	up(&inode->i_sem);
+      out:
+	return res;
 }
 
-
 /* Internal operations on file data */
-static inline void
-reiserfs_put_page(struct page *page)
+static inline void reiserfs_put_page(struct page *page)
 {
-        kunmap(page);
-        page_cache_release(page);
+	kunmap(page);
+	page_cache_release(page);
 }
 
-static struct page *
-reiserfs_get_page(struct inode *dir, unsigned long n)
+static struct page *reiserfs_get_page(struct inode *dir, unsigned long n)
 {
-        struct address_space *mapping = dir->i_mapping;
-        struct page *page;
-        /* We can deadlock if we try to free dentries,
-           and an unlink/rmdir has just occured - GFP_NOFS avoids this */
-        mapping->flags = (mapping->flags & ~__GFP_BITS_MASK) | GFP_NOFS;
-        page = read_cache_page (mapping, n,
-                                (filler_t*)mapping->a_ops->readpage, NULL);
-        if (!IS_ERR(page)) {
-                wait_on_page_locked(page);
-                kmap(page);
-                if (!PageUptodate(page))
-                        goto fail;
-
-                if (PageError(page))
-                        goto fail;
-        }
-        return page;
-
-fail:
-        reiserfs_put_page(page);
-        return ERR_PTR(-EIO);
+	struct address_space *mapping = dir->i_mapping;
+	struct page *page;
+	/* We can deadlock if we try to free dentries,
+	   and an unlink/rmdir has just occured - GFP_NOFS avoids this */
+	mapping->flags = (mapping->flags & ~__GFP_BITS_MASK) | GFP_NOFS;
+	page = read_cache_page(mapping, n,
+			       (filler_t *) mapping->a_ops->readpage, NULL);
+	if (!IS_ERR(page)) {
+		wait_on_page_locked(page);
+		kmap(page);
+		if (!PageUptodate(page))
+			goto fail;
+
+		if (PageError(page))
+			goto fail;
+	}
+	return page;
+
+      fail:
+	reiserfs_put_page(page);
+	return ERR_PTR(-EIO);
 }
 
-static inline __u32
-xattr_hash (const char *msg, int len)
+static inline __u32 xattr_hash(const char *msg, int len)
 {
-    return csum_partial (msg, len, 0);
+	return csum_partial(msg, len, 0);
 }
 
 /* Generic extended attribute operations that can be used by xa plugins */
@@ -482,294 +484,300 @@ xattr_hash (const char *msg, int len)
  * inode->i_sem: down
  */
 int
-reiserfs_xattr_set (struct inode *inode, const char *name, const void *buffer,
-                    size_t buffer_size, int flags)
+reiserfs_xattr_set(struct inode *inode, const char *name, const void *buffer,
+		   size_t buffer_size, int flags)
 {
-    int err = 0;
-    struct file *fp;
-    struct page *page;
-    char *data;
-    struct address_space *mapping;
-    size_t file_pos = 0;
-    size_t buffer_pos = 0;
-    struct inode *xinode;
-    struct iattr newattrs;
-    __u32 xahash = 0;
-
-    if (IS_RDONLY (inode))
-        return -EROFS;
-
-    if (IS_IMMUTABLE (inode) || IS_APPEND (inode))
-        return -EPERM;
-
-    if (get_inode_sd_version (inode) == STAT_DATA_V1)
-        return -EOPNOTSUPP;
-
-    /* Empty xattrs are ok, they're just empty files, no hash */
-    if (buffer && buffer_size)
-        xahash = xattr_hash (buffer, buffer_size);
-
-open_file:
-    fp = open_xa_file (inode, name, flags);
-    if (IS_ERR (fp)) {
-        err = PTR_ERR (fp);
-        goto out;
-    }
-
-    xinode = fp->f_dentry->d_inode;
-    REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
-
-    /* we need to copy it off.. */
-    if (xinode->i_nlink > 1) {
-	fput(fp);
-        err = reiserfs_xattr_del (inode, name);
-        if (err < 0)
-            goto out;
-        /* We just killed the old one, we're not replacing anymore */
-        if (flags & XATTR_REPLACE)
-            flags &= ~XATTR_REPLACE;
-        goto open_file;
-    }
-
-    /* Resize it so we're ok to write there */
-    newattrs.ia_size = buffer_size;
-    newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
-    down (&xinode->i_sem);
-    err = notify_change(fp->f_dentry, &newattrs);
-    if (err)
-        goto out_filp;
-
-    mapping = xinode->i_mapping;
-    while (buffer_pos < buffer_size || buffer_pos == 0) {
-        size_t chunk;
-        size_t skip = 0;
-        size_t page_offset = (file_pos & (PAGE_CACHE_SIZE - 1));
-        if (buffer_size - buffer_pos > PAGE_CACHE_SIZE)
-            chunk = PAGE_CACHE_SIZE;
-        else
-            chunk = buffer_size - buffer_pos;
-
-        page = reiserfs_get_page (xinode, file_pos >> PAGE_CACHE_SHIFT);
-        if (IS_ERR (page)) {
-            err = PTR_ERR (page);
-            goto out_filp;
-        }
-
-        lock_page (page);
-        data = page_address (page);
-
-        if (file_pos == 0) {
-            struct reiserfs_xattr_header *rxh;
-            skip = file_pos = sizeof (struct reiserfs_xattr_header);
-            if (chunk + skip > PAGE_CACHE_SIZE)
-                chunk = PAGE_CACHE_SIZE - skip;
-            rxh = (struct reiserfs_xattr_header *)data;
-            rxh->h_magic = cpu_to_le32 (REISERFS_XATTR_MAGIC);
-            rxh->h_hash = cpu_to_le32 (xahash);
-        }
-
-        err = mapping->a_ops->prepare_write (fp, page, page_offset,
-                                             page_offset + chunk + skip);
-        if (!err) {
-	    if (buffer)
-		memcpy (data + skip, buffer + buffer_pos, chunk);
-            err = mapping->a_ops->commit_write (fp, page, page_offset,
-                                                page_offset + chunk + skip);
+	int err = 0;
+	struct file *fp;
+	struct page *page;
+	char *data;
+	struct address_space *mapping;
+	size_t file_pos = 0;
+	size_t buffer_pos = 0;
+	struct inode *xinode;
+	struct iattr newattrs;
+	__u32 xahash = 0;
+
+	if (IS_RDONLY(inode))
+		return -EROFS;
+
+	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
+		return -EPERM;
+
+	if (get_inode_sd_version(inode) == STAT_DATA_V1)
+		return -EOPNOTSUPP;
+
+	/* Empty xattrs are ok, they're just empty files, no hash */
+	if (buffer && buffer_size)
+		xahash = xattr_hash(buffer, buffer_size);
+
+      open_file:
+	fp = open_xa_file(inode, name, flags);
+	if (IS_ERR(fp)) {
+		err = PTR_ERR(fp);
+		goto out;
+	}
+
+	xinode = fp->f_dentry->d_inode;
+	REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
+
+	/* we need to copy it off.. */
+	if (xinode->i_nlink > 1) {
+		fput(fp);
+		err = reiserfs_xattr_del(inode, name);
+		if (err < 0)
+			goto out;
+		/* We just killed the old one, we're not replacing anymore */
+		if (flags & XATTR_REPLACE)
+			flags &= ~XATTR_REPLACE;
+		goto open_file;
+	}
+
+	/* Resize it so we're ok to write there */
+	newattrs.ia_size = buffer_size;
+	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
+	down(&xinode->i_sem);
+	err = notify_change(fp->f_dentry, &newattrs);
+	if (err)
+		goto out_filp;
+
+	mapping = xinode->i_mapping;
+	while (buffer_pos < buffer_size || buffer_pos == 0) {
+		size_t chunk;
+		size_t skip = 0;
+		size_t page_offset = (file_pos & (PAGE_CACHE_SIZE - 1));
+		if (buffer_size - buffer_pos > PAGE_CACHE_SIZE)
+			chunk = PAGE_CACHE_SIZE;
+		else
+			chunk = buffer_size - buffer_pos;
+
+		page = reiserfs_get_page(xinode, file_pos >> PAGE_CACHE_SHIFT);
+		if (IS_ERR(page)) {
+			err = PTR_ERR(page);
+			goto out_filp;
+		}
+
+		lock_page(page);
+		data = page_address(page);
+
+		if (file_pos == 0) {
+			struct reiserfs_xattr_header *rxh;
+			skip = file_pos = sizeof(struct reiserfs_xattr_header);
+			if (chunk + skip > PAGE_CACHE_SIZE)
+				chunk = PAGE_CACHE_SIZE - skip;
+			rxh = (struct reiserfs_xattr_header *)data;
+			rxh->h_magic = cpu_to_le32(REISERFS_XATTR_MAGIC);
+			rxh->h_hash = cpu_to_le32(xahash);
+		}
+
+		err = mapping->a_ops->prepare_write(fp, page, page_offset,
+						    page_offset + chunk + skip);
+		if (!err) {
+			if (buffer)
+				memcpy(data + skip, buffer + buffer_pos, chunk);
+			err =
+			    mapping->a_ops->commit_write(fp, page, page_offset,
+							 page_offset + chunk +
+							 skip);
+		}
+		unlock_page(page);
+		reiserfs_put_page(page);
+		buffer_pos += chunk;
+		file_pos += chunk;
+		skip = 0;
+		if (err || buffer_size == 0 || !buffer)
+			break;
+	}
+
+	/* We can't mark the inode dirty if it's not hashed. This is the case
+	 * when we're inheriting the default ACL. If we dirty it, the inode
+	 * gets marked dirty, but won't (ever) make it onto the dirty list until
+	 * it's synced explicitly to clear I_DIRTY. This is bad. */
+	if (!hlist_unhashed(&inode->i_hash)) {
+		inode->i_ctime = CURRENT_TIME_SEC;
+		mark_inode_dirty(inode);
 	}
-        unlock_page (page);
-        reiserfs_put_page (page);
-        buffer_pos += chunk;
-        file_pos += chunk;
-        skip = 0;
-        if (err || buffer_size == 0 || !buffer)
-            break;
-    }
-
-    /* We can't mark the inode dirty if it's not hashed. This is the case
-     * when we're inheriting the default ACL. If we dirty it, the inode
-     * gets marked dirty, but won't (ever) make it onto the dirty list until
-     * it's synced explicitly to clear I_DIRTY. This is bad. */
-    if (!hlist_unhashed(&inode->i_hash)) {
-        inode->i_ctime = CURRENT_TIME_SEC;
-        mark_inode_dirty (inode);
-    }
-
-out_filp:
-    up (&xinode->i_sem);
-    fput(fp);
-
-out:
-    return err;
+
+      out_filp:
+	up(&xinode->i_sem);
+	fput(fp);
+
+      out:
+	return err;
 }
 
 /*
  * inode->i_sem: down
  */
 int
-reiserfs_xattr_get (const struct inode *inode, const char *name, void *buffer,
-                    size_t buffer_size)
+reiserfs_xattr_get(const struct inode *inode, const char *name, void *buffer,
+		   size_t buffer_size)
 {
-    ssize_t err = 0;
-    struct file *fp;
-    size_t isize;
-    size_t file_pos = 0;
-    size_t buffer_pos = 0;
-    struct page *page;
-    struct inode *xinode;
-    __u32 hash = 0;
-
-    if (name == NULL)
-        return -EINVAL;
-
-    /* We can't have xattrs attached to v1 items since they don't have
-     * generation numbers */
-    if (get_inode_sd_version (inode) == STAT_DATA_V1)
-        return -EOPNOTSUPP;
-
-    fp = open_xa_file (inode, name, FL_READONLY);
-    if (IS_ERR (fp)) {
-        err = PTR_ERR (fp);
-        goto out;
-    }
-
-    xinode = fp->f_dentry->d_inode;
-    isize = xinode->i_size;
-    REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
-
-    /* Just return the size needed */
-    if (buffer == NULL) {
-        err = isize - sizeof (struct reiserfs_xattr_header);
-        goto out_dput;
-    }
-
-    if (buffer_size < isize - sizeof (struct reiserfs_xattr_header)) {
-        err = -ERANGE;
-        goto out_dput;
-    }
-
-    while (file_pos < isize) {
-        size_t chunk;
-        char *data;
-        size_t skip = 0;
-        if (isize - file_pos > PAGE_CACHE_SIZE)
-            chunk = PAGE_CACHE_SIZE;
-        else
-            chunk = isize - file_pos;
-
-        page = reiserfs_get_page (xinode, file_pos >> PAGE_CACHE_SHIFT);
-        if (IS_ERR (page)) {
-            err = PTR_ERR (page);
-            goto out_dput;
-        }
-
-        lock_page (page);
-        data = page_address (page);
-        if (file_pos == 0) {
-            struct reiserfs_xattr_header *rxh =
-                                        (struct reiserfs_xattr_header *)data;
-            skip = file_pos = sizeof (struct reiserfs_xattr_header);
-            chunk -= skip;
-            /* Magic doesn't match up.. */
-            if (rxh->h_magic != cpu_to_le32 (REISERFS_XATTR_MAGIC)) {
-                unlock_page (page);
-                reiserfs_put_page (page);
-                reiserfs_warning (inode->i_sb, "Invalid magic for xattr (%s) "
-                                  "associated with %k", name,
-                                  INODE_PKEY (inode));
-                err = -EIO;
-                goto out_dput;
-            }
-            hash = le32_to_cpu (rxh->h_hash);
-        }
-        memcpy (buffer + buffer_pos, data + skip, chunk);
-        unlock_page (page);
-        reiserfs_put_page (page);
-        file_pos += chunk;
-        buffer_pos += chunk;
-        skip = 0;
-    }
-    err = isize - sizeof (struct reiserfs_xattr_header);
-
-    if (xattr_hash (buffer, isize - sizeof (struct reiserfs_xattr_header)) != hash) {
-        reiserfs_warning (inode->i_sb, "Invalid hash for xattr (%s) associated "
-                          "with %k", name, INODE_PKEY (inode));
-        err = -EIO;
-    }
-
-out_dput:
-    fput(fp);
-
-out:
-    return err;
+	ssize_t err = 0;
+	struct file *fp;
+	size_t isize;
+	size_t file_pos = 0;
+	size_t buffer_pos = 0;
+	struct page *page;
+	struct inode *xinode;
+	__u32 hash = 0;
+
+	if (name == NULL)
+		return -EINVAL;
+
+	/* We can't have xattrs attached to v1 items since they don't have
+	 * generation numbers */
+	if (get_inode_sd_version(inode) == STAT_DATA_V1)
+		return -EOPNOTSUPP;
+
+	fp = open_xa_file(inode, name, FL_READONLY);
+	if (IS_ERR(fp)) {
+		err = PTR_ERR(fp);
+		goto out;
+	}
+
+	xinode = fp->f_dentry->d_inode;
+	isize = xinode->i_size;
+	REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
+
+	/* Just return the size needed */
+	if (buffer == NULL) {
+		err = isize - sizeof(struct reiserfs_xattr_header);
+		goto out_dput;
+	}
+
+	if (buffer_size < isize - sizeof(struct reiserfs_xattr_header)) {
+		err = -ERANGE;
+		goto out_dput;
+	}
+
+	while (file_pos < isize) {
+		size_t chunk;
+		char *data;
+		size_t skip = 0;
+		if (isize - file_pos > PAGE_CACHE_SIZE)
+			chunk = PAGE_CACHE_SIZE;
+		else
+			chunk = isize - file_pos;
+
+		page = reiserfs_get_page(xinode, file_pos >> PAGE_CACHE_SHIFT);
+		if (IS_ERR(page)) {
+			err = PTR_ERR(page);
+			goto out_dput;
+		}
+
+		lock_page(page);
+		data = page_address(page);
+		if (file_pos == 0) {
+			struct reiserfs_xattr_header *rxh =
+			    (struct reiserfs_xattr_header *)data;
+			skip = file_pos = sizeof(struct reiserfs_xattr_header);
+			chunk -= skip;
+			/* Magic doesn't match up.. */
+			if (rxh->h_magic != cpu_to_le32(REISERFS_XATTR_MAGIC)) {
+				unlock_page(page);
+				reiserfs_put_page(page);
+				reiserfs_warning(inode->i_sb,
+						 "Invalid magic for xattr (%s) "
+						 "associated with %k", name,
+						 INODE_PKEY(inode));
+				err = -EIO;
+				goto out_dput;
+			}
+			hash = le32_to_cpu(rxh->h_hash);
+		}
+		memcpy(buffer + buffer_pos, data + skip, chunk);
+		unlock_page(page);
+		reiserfs_put_page(page);
+		file_pos += chunk;
+		buffer_pos += chunk;
+		skip = 0;
+	}
+	err = isize - sizeof(struct reiserfs_xattr_header);
+
+	if (xattr_hash(buffer, isize - sizeof(struct reiserfs_xattr_header)) !=
+	    hash) {
+		reiserfs_warning(inode->i_sb,
+				 "Invalid hash for xattr (%s) associated "
+				 "with %k", name, INODE_PKEY(inode));
+		err = -EIO;
+	}
+
+      out_dput:
+	fput(fp);
+
+      out:
+	return err;
 }
 
 static int
-__reiserfs_xattr_del (struct dentry *xadir, const char *name, int namelen)
+__reiserfs_xattr_del(struct dentry *xadir, const char *name, int namelen)
 {
-    struct dentry *dentry;
-    struct inode *dir = xadir->d_inode;
-    int err = 0;
-
-    dentry = lookup_one_len (name, xadir, namelen);
-    if (IS_ERR (dentry)) {
-        err = PTR_ERR (dentry);
-        goto out;
-    } else if (!dentry->d_inode) {
-        err = -ENODATA;
-        goto out_file;
-    }
-
-    /* Skip directories.. */
-    if (S_ISDIR (dentry->d_inode->i_mode))
-        goto out_file;
-
-    if (!is_reiserfs_priv_object (dentry->d_inode)) {
-        reiserfs_warning (dir->i_sb, "OID %08x [%.*s/%.*s] doesn't have "
-                                     "priv flag set [parent is %sset].",
-                        le32_to_cpu (INODE_PKEY (dentry->d_inode)->k_objectid),
-                        xadir->d_name.len, xadir->d_name.name, namelen, name,
-                        is_reiserfs_priv_object (xadir->d_inode) ? "" : "not ");
-        dput (dentry);
-        return -EIO;
-    }
-
-    err = dir->i_op->unlink (dir, dentry);
-    if (!err)
-        d_delete (dentry);
-
-out_file:
-    dput (dentry);
-
-out:
-    return err;
-}
+	struct dentry *dentry;
+	struct inode *dir = xadir->d_inode;
+	int err = 0;
+
+	dentry = lookup_one_len(name, xadir, namelen);
+	if (IS_ERR(dentry)) {
+		err = PTR_ERR(dentry);
+		goto out;
+	} else if (!dentry->d_inode) {
+		err = -ENODATA;
+		goto out_file;
+	}
+
+	/* Skip directories.. */
+	if (S_ISDIR(dentry->d_inode->i_mode))
+		goto out_file;
+
+	if (!is_reiserfs_priv_object(dentry->d_inode)) {
+		reiserfs_warning(dir->i_sb, "OID %08x [%.*s/%.*s] doesn't have "
+				 "priv flag set [parent is %sset].",
+				 le32_to_cpu(INODE_PKEY(dentry->d_inode)->
+					     k_objectid), xadir->d_name.len,
+				 xadir->d_name.name, namelen, name,
+				 is_reiserfs_priv_object(xadir->
+							 d_inode) ? "" :
+				 "not ");
+		dput(dentry);
+		return -EIO;
+	}
 
+	err = dir->i_op->unlink(dir, dentry);
+	if (!err)
+		d_delete(dentry);
 
-int
-reiserfs_xattr_del (struct inode *inode, const char *name)
+      out_file:
+	dput(dentry);
+
+      out:
+	return err;
+}
+
+int reiserfs_xattr_del(struct inode *inode, const char *name)
 {
-    struct dentry *dir;
-    int err;
+	struct dentry *dir;
+	int err;
 
-    if (IS_RDONLY (inode))
-        return -EROFS;
+	if (IS_RDONLY(inode))
+		return -EROFS;
 
-    dir = open_xa_dir (inode, FL_READONLY);
-    if (IS_ERR (dir)) {
-        err = PTR_ERR (dir);
-        goto out;
-    }
+	dir = open_xa_dir(inode, FL_READONLY);
+	if (IS_ERR(dir)) {
+		err = PTR_ERR(dir);
+		goto out;
+	}
 
-    err = __reiserfs_xattr_del (dir, name, strlen (name));
-    dput (dir);
+	err = __reiserfs_xattr_del(dir, name, strlen(name));
+	dput(dir);
 
-    if (!err) {
-        inode->i_ctime = CURRENT_TIME_SEC;
-        mark_inode_dirty (inode);
-    }
+	if (!err) {
+		inode->i_ctime = CURRENT_TIME_SEC;
+		mark_inode_dirty(inode);
+	}
 
-out:
-    return err;
+      out:
+	return err;
 }
 
 /* The following are side effects of other operations that aren't explicitly
@@ -777,167 +785,163 @@ reiserfs_xattr_del (struct inode *inode, const char *name)
  * or ownership changes, object deletions, etc. */
 
 static int
-reiserfs_delete_xattrs_filler (void *buf, const char *name, int namelen,
-                               loff_t offset, ino_t ino, unsigned int d_type)
+reiserfs_delete_xattrs_filler(void *buf, const char *name, int namelen,
+			      loff_t offset, ino_t ino, unsigned int d_type)
 {
-    struct dentry *xadir = (struct dentry *)buf;
+	struct dentry *xadir = (struct dentry *)buf;
 
-    return __reiserfs_xattr_del (xadir, name, namelen);
+	return __reiserfs_xattr_del(xadir, name, namelen);
 
 }
 
 /* This is called w/ inode->i_sem downed */
-int
-reiserfs_delete_xattrs (struct inode *inode)
+int reiserfs_delete_xattrs(struct inode *inode)
 {
-    struct file *fp;
-    struct dentry *dir, *root;
-    int err = 0;
-
-    /* Skip out, an xattr has no xattrs associated with it */
-    if (is_reiserfs_priv_object (inode) ||
-        get_inode_sd_version (inode) == STAT_DATA_V1 ||
-        !reiserfs_xattrs(inode->i_sb))
-    {
-        return 0;
-    }
-    reiserfs_read_lock_xattrs (inode->i_sb);
-    dir = open_xa_dir (inode, FL_READONLY);
-    reiserfs_read_unlock_xattrs (inode->i_sb);
-    if (IS_ERR (dir)) {
-        err = PTR_ERR (dir);
-        goto out;
-    } else if (!dir->d_inode) {
-        dput (dir);
-        return 0;
-    }
-
-    fp = dentry_open (dir, NULL, O_RDWR);
-    if (IS_ERR (fp)) {
-        err = PTR_ERR (fp);
-        /* dentry_open dputs the dentry if it fails */
-        goto out;
-    }
-
-    lock_kernel ();
-    err = xattr_readdir (fp, reiserfs_delete_xattrs_filler, dir);
-    if (err) {
-        unlock_kernel ();
-        goto out_dir;
-    }
-
-    /* Leftovers besides . and .. -- that's not good. */
-    if (dir->d_inode->i_nlink <= 2) {
-        root = get_xa_root (inode->i_sb);
-        reiserfs_write_lock_xattrs (inode->i_sb);
-        err = vfs_rmdir (root->d_inode, dir);
-        reiserfs_write_unlock_xattrs (inode->i_sb);
-        dput (root);
-    } else {
-        reiserfs_warning (inode->i_sb,
-                          "Couldn't remove all entries in directory");
-    }
-    unlock_kernel ();
-
-out_dir:
-    fput(fp);
-
-out:
-    if (!err)
-        REISERFS_I(inode)->i_flags = REISERFS_I(inode)->i_flags & ~i_has_xattr_dir;
-    return err;
+	struct file *fp;
+	struct dentry *dir, *root;
+	int err = 0;
+
+	/* Skip out, an xattr has no xattrs associated with it */
+	if (is_reiserfs_priv_object(inode) ||
+	    get_inode_sd_version(inode) == STAT_DATA_V1 ||
+	    !reiserfs_xattrs(inode->i_sb)) {
+		return 0;
+	}
+	reiserfs_read_lock_xattrs(inode->i_sb);
+	dir = open_xa_dir(inode, FL_READONLY);
+	reiserfs_read_unlock_xattrs(inode->i_sb);
+	if (IS_ERR(dir)) {
+		err = PTR_ERR(dir);
+		goto out;
+	} else if (!dir->d_inode) {
+		dput(dir);
+		return 0;
+	}
+
+	fp = dentry_open(dir, NULL, O_RDWR);
+	if (IS_ERR(fp)) {
+		err = PTR_ERR(fp);
+		/* dentry_open dputs the dentry if it fails */
+		goto out;
+	}
+
+	lock_kernel();
+	err = xattr_readdir(fp, reiserfs_delete_xattrs_filler, dir);
+	if (err) {
+		unlock_kernel();
+		goto out_dir;
+	}
+
+	/* Leftovers besides . and .. -- that's not good. */
+	if (dir->d_inode->i_nlink <= 2) {
+		root = get_xa_root(inode->i_sb);
+		reiserfs_write_lock_xattrs(inode->i_sb);
+		err = vfs_rmdir(root->d_inode, dir);
+		reiserfs_write_unlock_xattrs(inode->i_sb);
+		dput(root);
+	} else {
+		reiserfs_warning(inode->i_sb,
+				 "Couldn't remove all entries in directory");
+	}
+	unlock_kernel();
+
+      out_dir:
+	fput(fp);
+
+      out:
+	if (!err)
+		REISERFS_I(inode)->i_flags =
+		    REISERFS_I(inode)->i_flags & ~i_has_xattr_dir;
+	return err;
 }
 
 struct reiserfs_chown_buf {
-    struct inode *inode;
-    struct dentry *xadir;
-    struct iattr *attrs;
+	struct inode *inode;
+	struct dentry *xadir;
+	struct iattr *attrs;
 };
 
 /* XXX: If there is a better way to do this, I'd love to hear about it */
 static int
-reiserfs_chown_xattrs_filler (void *buf, const char *name, int namelen,
-                               loff_t offset, ino_t ino, unsigned int d_type)
+reiserfs_chown_xattrs_filler(void *buf, const char *name, int namelen,
+			     loff_t offset, ino_t ino, unsigned int d_type)
 {
-    struct reiserfs_chown_buf *chown_buf = (struct reiserfs_chown_buf *)buf;
-    struct dentry *xafile, *xadir = chown_buf->xadir;
-    struct iattr *attrs = chown_buf->attrs;
-    int err = 0;
-
-    xafile = lookup_one_len (name, xadir, namelen);
-    if (IS_ERR (xafile))
-        return PTR_ERR (xafile);
-    else if (!xafile->d_inode) {
-        dput (xafile);
-        return -ENODATA;
-    }
-
-    if (!S_ISDIR (xafile->d_inode->i_mode))
-        err = notify_change (xafile, attrs);
-    dput (xafile);
-
-    return err;
+	struct reiserfs_chown_buf *chown_buf = (struct reiserfs_chown_buf *)buf;
+	struct dentry *xafile, *xadir = chown_buf->xadir;
+	struct iattr *attrs = chown_buf->attrs;
+	int err = 0;
+
+	xafile = lookup_one_len(name, xadir, namelen);
+	if (IS_ERR(xafile))
+		return PTR_ERR(xafile);
+	else if (!xafile->d_inode) {
+		dput(xafile);
+		return -ENODATA;
+	}
+
+	if (!S_ISDIR(xafile->d_inode->i_mode))
+		err = notify_change(xafile, attrs);
+	dput(xafile);
+
+	return err;
 }
 
-int
-reiserfs_chown_xattrs (struct inode *inode, struct iattr *attrs)
+int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)
 {
-    struct file *fp;
-    struct dentry *dir;
-    int err = 0;
-    struct reiserfs_chown_buf buf;
-    unsigned int ia_valid = attrs->ia_valid;
-
-    /* Skip out, an xattr has no xattrs associated with it */
-    if (is_reiserfs_priv_object (inode) ||
-        get_inode_sd_version (inode) == STAT_DATA_V1 ||
-        !reiserfs_xattrs(inode->i_sb))
-    {
-        return 0;
-    }
-    reiserfs_read_lock_xattrs (inode->i_sb);
-    dir = open_xa_dir (inode, FL_READONLY);
-    reiserfs_read_unlock_xattrs (inode->i_sb);
-    if (IS_ERR (dir)) {
-        if (PTR_ERR (dir) != -ENODATA)
-            err = PTR_ERR (dir);
-        goto out;
-    } else if (!dir->d_inode) {
-        dput (dir);
-        goto out;
-    }
-
-    fp = dentry_open (dir, NULL, O_RDWR);
-    if (IS_ERR (fp)) {
-        err = PTR_ERR (fp);
-        /* dentry_open dputs the dentry if it fails */
-        goto out;
-    }
-
-    lock_kernel ();
-
-    attrs->ia_valid &= (ATTR_UID | ATTR_GID | ATTR_CTIME);
-    buf.xadir = dir;
-    buf.attrs = attrs;
-    buf.inode = inode;
-
-    err = xattr_readdir (fp, reiserfs_chown_xattrs_filler, &buf);
-    if (err) {
-        unlock_kernel ();
-        goto out_dir;
-    }
-
-    err = notify_change (dir, attrs);
-    unlock_kernel ();
-
-out_dir:
-    fput(fp);
-
-out:
-    attrs->ia_valid = ia_valid;
-    return err;
-}
+	struct file *fp;
+	struct dentry *dir;
+	int err = 0;
+	struct reiserfs_chown_buf buf;
+	unsigned int ia_valid = attrs->ia_valid;
+
+	/* Skip out, an xattr has no xattrs associated with it */
+	if (is_reiserfs_priv_object(inode) ||
+	    get_inode_sd_version(inode) == STAT_DATA_V1 ||
+	    !reiserfs_xattrs(inode->i_sb)) {
+		return 0;
+	}
+	reiserfs_read_lock_xattrs(inode->i_sb);
+	dir = open_xa_dir(inode, FL_READONLY);
+	reiserfs_read_unlock_xattrs(inode->i_sb);
+	if (IS_ERR(dir)) {
+		if (PTR_ERR(dir) != -ENODATA)
+			err = PTR_ERR(dir);
+		goto out;
+	} else if (!dir->d_inode) {
+		dput(dir);
+		goto out;
+	}
+
+	fp = dentry_open(dir, NULL, O_RDWR);
+	if (IS_ERR(fp)) {
+		err = PTR_ERR(fp);
+		/* dentry_open dputs the dentry if it fails */
+		goto out;
+	}
 
+	lock_kernel();
+
+	attrs->ia_valid &= (ATTR_UID | ATTR_GID | ATTR_CTIME);
+	buf.xadir = dir;
+	buf.attrs = attrs;
+	buf.inode = inode;
+
+	err = xattr_readdir(fp, reiserfs_chown_xattrs_filler, &buf);
+	if (err) {
+		unlock_kernel();
+		goto out_dir;
+	}
+
+	err = notify_change(dir, attrs);
+	unlock_kernel();
+
+      out_dir:
+	fput(fp);
+
+      out:
+	attrs->ia_valid = ia_valid;
+	return err;
+}
 
 /* Actual operations that are exported to VFS-land */
 
@@ -946,61 +950,60 @@ reiserfs_chown_xattrs (struct inode *inode, struct iattr *attrs)
  * Preliminary locking: we down dentry->d_inode->i_sem
  */
 ssize_t
-reiserfs_getxattr (struct dentry *dentry, const char *name, void *buffer,
-                   size_t size)
+reiserfs_getxattr(struct dentry * dentry, const char *name, void *buffer,
+		  size_t size)
 {
-    struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
-    int err;
-
-    if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
-        get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
-        return -EOPNOTSUPP;
-
-    reiserfs_read_lock_xattr_i (dentry->d_inode);
-    reiserfs_read_lock_xattrs (dentry->d_sb);
-    err = xah->get (dentry->d_inode, name, buffer, size);
-    reiserfs_read_unlock_xattrs (dentry->d_sb);
-    reiserfs_read_unlock_xattr_i (dentry->d_inode);
-    return err;
+	struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix(name);
+	int err;
+
+	if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
+	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
+		return -EOPNOTSUPP;
+
+	reiserfs_read_lock_xattr_i(dentry->d_inode);
+	reiserfs_read_lock_xattrs(dentry->d_sb);
+	err = xah->get(dentry->d_inode, name, buffer, size);
+	reiserfs_read_unlock_xattrs(dentry->d_sb);
+	reiserfs_read_unlock_xattr_i(dentry->d_inode);
+	return err;
 }
 
-
 /*
  * Inode operation setxattr()
  *
  * dentry->d_inode->i_sem down
  */
 int
-reiserfs_setxattr (struct dentry *dentry, const char *name, const void *value,
-                   size_t size, int flags)
+reiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,
+		  size_t size, int flags)
 {
-    struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
-    int err;
-    int lock;
-
-    if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
-        get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
-        return -EOPNOTSUPP;
-
-    if (IS_RDONLY (dentry->d_inode))
-        return -EROFS;
-
-    if (IS_IMMUTABLE (dentry->d_inode) || IS_APPEND (dentry->d_inode))
-        return -EROFS;
-
-    reiserfs_write_lock_xattr_i (dentry->d_inode);
-    lock = !has_xattr_dir (dentry->d_inode);
-    if (lock)
-        reiserfs_write_lock_xattrs (dentry->d_sb);
-    else
-        reiserfs_read_lock_xattrs (dentry->d_sb);
-    err = xah->set (dentry->d_inode, name, value, size, flags);
-    if (lock)
-        reiserfs_write_unlock_xattrs (dentry->d_sb);
-    else
-        reiserfs_read_unlock_xattrs (dentry->d_sb);
-    reiserfs_write_unlock_xattr_i (dentry->d_inode);
-    return err;
+	struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix(name);
+	int err;
+	int lock;
+
+	if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
+	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
+		return -EOPNOTSUPP;
+
+	if (IS_RDONLY(dentry->d_inode))
+		return -EROFS;
+
+	if (IS_IMMUTABLE(dentry->d_inode) || IS_APPEND(dentry->d_inode))
+		return -EROFS;
+
+	reiserfs_write_lock_xattr_i(dentry->d_inode);
+	lock = !has_xattr_dir(dentry->d_inode);
+	if (lock)
+		reiserfs_write_lock_xattrs(dentry->d_sb);
+	else
+		reiserfs_read_lock_xattrs(dentry->d_sb);
+	err = xah->set(dentry->d_inode, name, value, size, flags);
+	if (lock)
+		reiserfs_write_unlock_xattrs(dentry->d_sb);
+	else
+		reiserfs_read_unlock_xattrs(dentry->d_sb);
+	reiserfs_write_unlock_xattr_i(dentry->d_inode);
+	return err;
 }
 
 /*
@@ -1008,344 +1011,343 @@ reiserfs_setxattr (struct dentry *dentry, const char *name, const void *value,
  *
  * dentry->d_inode->i_sem down
  */
-int
-reiserfs_removexattr (struct dentry *dentry, const char *name)
+int reiserfs_removexattr(struct dentry *dentry, const char *name)
 {
-    int err;
-    struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
+	int err;
+	struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix(name);
 
-    if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
-        get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
-        return -EOPNOTSUPP;
+	if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
+	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
+		return -EOPNOTSUPP;
 
-    if (IS_RDONLY (dentry->d_inode))
-        return -EROFS;
+	if (IS_RDONLY(dentry->d_inode))
+		return -EROFS;
 
-    if (IS_IMMUTABLE (dentry->d_inode) || IS_APPEND (dentry->d_inode))
-        return -EPERM;
+	if (IS_IMMUTABLE(dentry->d_inode) || IS_APPEND(dentry->d_inode))
+		return -EPERM;
 
-    reiserfs_write_lock_xattr_i (dentry->d_inode);
-    reiserfs_read_lock_xattrs (dentry->d_sb);
+	reiserfs_write_lock_xattr_i(dentry->d_inode);
+	reiserfs_read_lock_xattrs(dentry->d_sb);
 
-    /* Deletion pre-operation */
-    if (xah->del) {
-        err = xah->del (dentry->d_inode, name);
-        if (err)
-            goto out;
-    }
+	/* Deletion pre-operation */
+	if (xah->del) {
+		err = xah->del(dentry->d_inode, name);
+		if (err)
+			goto out;
+	}
 
-    err = reiserfs_xattr_del (dentry->d_inode, name);
+	err = reiserfs_xattr_del(dentry->d_inode, name);
 
-    dentry->d_inode->i_ctime = CURRENT_TIME_SEC;
-    mark_inode_dirty (dentry->d_inode);
+	dentry->d_inode->i_ctime = CURRENT_TIME_SEC;
+	mark_inode_dirty(dentry->d_inode);
 
-out:
-    reiserfs_read_unlock_xattrs (dentry->d_sb);
-    reiserfs_write_unlock_xattr_i (dentry->d_inode);
-    return err;
+      out:
+	reiserfs_read_unlock_xattrs(dentry->d_sb);
+	reiserfs_write_unlock_xattr_i(dentry->d_inode);
+	return err;
 }
 
-
 /* This is what filldir will use:
  * r_pos will always contain the amount of space required for the entire
  * list. If r_pos becomes larger than r_size, we need more space and we
  * return an error indicating this. If r_pos is less than r_size, then we've
  * filled the buffer successfully and we return success */
 struct reiserfs_listxattr_buf {
-    int r_pos;
-    int r_size;
-    char *r_buf;
-    struct inode *r_inode;
+	int r_pos;
+	int r_size;
+	char *r_buf;
+	struct inode *r_inode;
 };
 
 static int
-reiserfs_listxattr_filler (void *buf, const char *name, int namelen,
-                           loff_t offset, ino_t ino, unsigned int d_type)
+reiserfs_listxattr_filler(void *buf, const char *name, int namelen,
+			  loff_t offset, ino_t ino, unsigned int d_type)
 {
-    struct reiserfs_listxattr_buf *b = (struct reiserfs_listxattr_buf *)buf;
-    int len = 0;
-    if (name[0] != '.' || (namelen != 1 && (name[1] != '.' || namelen != 2))) {
-        struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
-        if (!xah) return 0; /* Unsupported xattr name, skip it */
-
-        /* We call ->list() twice because the operation isn't required to just
-         * return the name back - we want to make sure we have enough space */
-        len += xah->list (b->r_inode, name, namelen, NULL);
-
-        if (len) {
-            if (b->r_pos + len + 1 <= b->r_size) {
-                char *p = b->r_buf + b->r_pos;
-                p += xah->list (b->r_inode, name, namelen, p);
-                *p++ = '\0';
-            }
-            b->r_pos += len + 1;
-        }
-    }
-
-    return 0;
+	struct reiserfs_listxattr_buf *b = (struct reiserfs_listxattr_buf *)buf;
+	int len = 0;
+	if (name[0] != '.'
+	    || (namelen != 1 && (name[1] != '.' || namelen != 2))) {
+		struct reiserfs_xattr_handler *xah =
+		    find_xattr_handler_prefix(name);
+		if (!xah)
+			return 0;	/* Unsupported xattr name, skip it */
+
+		/* We call ->list() twice because the operation isn't required to just
+		 * return the name back - we want to make sure we have enough space */
+		len += xah->list(b->r_inode, name, namelen, NULL);
+
+		if (len) {
+			if (b->r_pos + len + 1 <= b->r_size) {
+				char *p = b->r_buf + b->r_pos;
+				p += xah->list(b->r_inode, name, namelen, p);
+				*p++ = '\0';
+			}
+			b->r_pos += len + 1;
+		}
+	}
+
+	return 0;
 }
+
 /*
  * Inode operation listxattr()
  *
  * Preliminary locking: we down dentry->d_inode->i_sem
  */
-ssize_t
-reiserfs_listxattr (struct dentry *dentry, char *buffer, size_t size)
+ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)
 {
-    struct file *fp;
-    struct dentry *dir;
-    int err = 0;
-    struct reiserfs_listxattr_buf buf;
-
-    if (!dentry->d_inode)
-        return -EINVAL;
-
-    if (!reiserfs_xattrs(dentry->d_sb) ||
-        get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
-        return -EOPNOTSUPP;
-
-    reiserfs_read_lock_xattr_i (dentry->d_inode);
-    reiserfs_read_lock_xattrs (dentry->d_sb);
-    dir = open_xa_dir (dentry->d_inode, FL_READONLY);
-    reiserfs_read_unlock_xattrs (dentry->d_sb);
-    if (IS_ERR (dir)) {
-        err = PTR_ERR (dir);
-        if (err == -ENODATA)
-            err = 0; /* Not an error if there aren't any xattrs */
-        goto out;
-    }
-
-    fp = dentry_open (dir, NULL, O_RDWR);
-    if (IS_ERR (fp)) {
-        err = PTR_ERR (fp);
-        /* dentry_open dputs the dentry if it fails */
-        goto out;
-    }
-
-    buf.r_buf = buffer;
-    buf.r_size = buffer ? size : 0;
-    buf.r_pos = 0;
-    buf.r_inode = dentry->d_inode;
-
-    REISERFS_I(dentry->d_inode)->i_flags |= i_has_xattr_dir;
-
-    err = xattr_readdir (fp, reiserfs_listxattr_filler, &buf);
-    if (err)
-        goto out_dir;
-
-    if (buf.r_pos > buf.r_size && buffer != NULL)
-        err = -ERANGE;
-    else
-        err = buf.r_pos;
-
-out_dir:
-    fput(fp);
-
-out:
-    reiserfs_read_unlock_xattr_i (dentry->d_inode);
-    return err;
+	struct file *fp;
+	struct dentry *dir;
+	int err = 0;
+	struct reiserfs_listxattr_buf buf;
+
+	if (!dentry->d_inode)
+		return -EINVAL;
+
+	if (!reiserfs_xattrs(dentry->d_sb) ||
+	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
+		return -EOPNOTSUPP;
+
+	reiserfs_read_lock_xattr_i(dentry->d_inode);
+	reiserfs_read_lock_xattrs(dentry->d_sb);
+	dir = open_xa_dir(dentry->d_inode, FL_READONLY);
+	reiserfs_read_unlock_xattrs(dentry->d_sb);
+	if (IS_ERR(dir)) {
+		err = PTR_ERR(dir);
+		if (err == -ENODATA)
+			err = 0;	/* Not an error if there aren't any xattrs */
+		goto out;
+	}
+
+	fp = dentry_open(dir, NULL, O_RDWR);
+	if (IS_ERR(fp)) {
+		err = PTR_ERR(fp);
+		/* dentry_open dputs the dentry if it fails */
+		goto out;
+	}
+
+	buf.r_buf = buffer;
+	buf.r_size = buffer ? size : 0;
+	buf.r_pos = 0;
+	buf.r_inode = dentry->d_inode;
+
+	REISERFS_I(dentry->d_inode)->i_flags |= i_has_xattr_dir;
+
+	err = xattr_readdir(fp, reiserfs_listxattr_filler, &buf);
+	if (err)
+		goto out_dir;
+
+	if (buf.r_pos > buf.r_size && buffer != NULL)
+		err = -ERANGE;
+	else
+		err = buf.r_pos;
+
+      out_dir:
+	fput(fp);
+
+      out:
+	reiserfs_read_unlock_xattr_i(dentry->d_inode);
+	return err;
 }
 
 /* This is the implementation for the xattr plugin infrastructure */
-static struct list_head xattr_handlers = LIST_HEAD_INIT (xattr_handlers);
+static struct list_head xattr_handlers = LIST_HEAD_INIT(xattr_handlers);
 static DEFINE_RWLOCK(handler_lock);
 
-static struct reiserfs_xattr_handler *
-find_xattr_handler_prefix (const char *prefix)
+static struct reiserfs_xattr_handler *find_xattr_handler_prefix(const char
+								*prefix)
 {
-    struct reiserfs_xattr_handler *xah = NULL;
-    struct list_head *p;
-
-    read_lock (&handler_lock);
-    list_for_each (p, &xattr_handlers) {
-        xah = list_entry (p, struct reiserfs_xattr_handler, handlers);
-        if (strncmp (xah->prefix, prefix, strlen (xah->prefix)) == 0)
-            break;
-        xah = NULL;
-    }
-
-    read_unlock (&handler_lock);
-    return xah;
+	struct reiserfs_xattr_handler *xah = NULL;
+	struct list_head *p;
+
+	read_lock(&handler_lock);
+	list_for_each(p, &xattr_handlers) {
+		xah = list_entry(p, struct reiserfs_xattr_handler, handlers);
+		if (strncmp(xah->prefix, prefix, strlen(xah->prefix)) == 0)
+			break;
+		xah = NULL;
+	}
+
+	read_unlock(&handler_lock);
+	return xah;
 }
 
-static void
-__unregister_handlers (void)
+static void __unregister_handlers(void)
 {
-    struct reiserfs_xattr_handler *xah;
-    struct list_head *p, *tmp;
+	struct reiserfs_xattr_handler *xah;
+	struct list_head *p, *tmp;
 
-    list_for_each_safe (p, tmp, &xattr_handlers) {
-        xah = list_entry (p, struct reiserfs_xattr_handler, handlers);
-        if (xah->exit)
-            xah->exit();
+	list_for_each_safe(p, tmp, &xattr_handlers) {
+		xah = list_entry(p, struct reiserfs_xattr_handler, handlers);
+		if (xah->exit)
+			xah->exit();
 
-        list_del_init (p);
-    }
-    INIT_LIST_HEAD (&xattr_handlers);
+		list_del_init(p);
+	}
+	INIT_LIST_HEAD(&xattr_handlers);
 }
 
-int __init
-reiserfs_xattr_register_handlers (void)
+int __init reiserfs_xattr_register_handlers(void)
 {
-    int err = 0;
-    struct reiserfs_xattr_handler *xah;
-    struct list_head *p;
+	int err = 0;
+	struct reiserfs_xattr_handler *xah;
+	struct list_head *p;
 
-    write_lock (&handler_lock);
+	write_lock(&handler_lock);
 
-    /* If we're already initialized, nothing to do */
-    if (!list_empty (&xattr_handlers)) {
-        write_unlock (&handler_lock);
-        return 0;
-    }
+	/* If we're already initialized, nothing to do */
+	if (!list_empty(&xattr_handlers)) {
+		write_unlock(&handler_lock);
+		return 0;
+	}
 
-    /* Add the handlers */
-    list_add_tail (&user_handler.handlers, &xattr_handlers);
-    list_add_tail (&trusted_handler.handlers, &xattr_handlers);
+	/* Add the handlers */
+	list_add_tail(&user_handler.handlers, &xattr_handlers);
+	list_add_tail(&trusted_handler.handlers, &xattr_handlers);
 #ifdef CONFIG_REISERFS_FS_SECURITY
-    list_add_tail (&security_handler.handlers, &xattr_handlers);
+	list_add_tail(&security_handler.handlers, &xattr_handlers);
 #endif
 #ifdef CONFIG_REISERFS_FS_POSIX_ACL
-    list_add_tail (&posix_acl_access_handler.handlers, &xattr_handlers);
-    list_add_tail (&posix_acl_default_handler.handlers, &xattr_handlers);
+	list_add_tail(&posix_acl_access_handler.handlers, &xattr_handlers);
+	list_add_tail(&posix_acl_default_handler.handlers, &xattr_handlers);
 #endif
 
-    /* Run initializers, if available */
-    list_for_each (p, &xattr_handlers) {
-        xah = list_entry (p, struct reiserfs_xattr_handler, handlers);
-        if (xah->init) {
-            err = xah->init ();
-            if (err) {
-                list_del_init (p);
-                break;
-            }
-        }
-    }
-
-    /* Clean up other handlers, if any failed */
-    if (err)
-        __unregister_handlers ();
-
-    write_unlock (&handler_lock);
-    return err;
+	/* Run initializers, if available */
+	list_for_each(p, &xattr_handlers) {
+		xah = list_entry(p, struct reiserfs_xattr_handler, handlers);
+		if (xah->init) {
+			err = xah->init();
+			if (err) {
+				list_del_init(p);
+				break;
+			}
+		}
+	}
+
+	/* Clean up other handlers, if any failed */
+	if (err)
+		__unregister_handlers();
+
+	write_unlock(&handler_lock);
+	return err;
 }
 
-void
-reiserfs_xattr_unregister_handlers (void)
+void reiserfs_xattr_unregister_handlers(void)
 {
-    write_lock (&handler_lock);
-    __unregister_handlers ();
-    write_unlock (&handler_lock);
+	write_lock(&handler_lock);
+	__unregister_handlers();
+	write_unlock(&handler_lock);
 }
 
 /* This will catch lookups from the fs root to .reiserfs_priv */
 static int
-xattr_lookup_poison (struct dentry *dentry, struct qstr *q1, struct qstr *name)
+xattr_lookup_poison(struct dentry *dentry, struct qstr *q1, struct qstr *name)
 {
-    struct dentry *priv_root = REISERFS_SB(dentry->d_sb)->priv_root;
-    if (name->len == priv_root->d_name.len &&
-        name->hash == priv_root->d_name.hash &&
-        !memcmp (name->name, priv_root->d_name.name, name->len)) {
-            return -ENOENT;
-    } else if (q1->len == name->len &&
-               !memcmp(q1->name, name->name, name->len))
-        return 0;
-    return 1;
+	struct dentry *priv_root = REISERFS_SB(dentry->d_sb)->priv_root;
+	if (name->len == priv_root->d_name.len &&
+	    name->hash == priv_root->d_name.hash &&
+	    !memcmp(name->name, priv_root->d_name.name, name->len)) {
+		return -ENOENT;
+	} else if (q1->len == name->len &&
+		   !memcmp(q1->name, name->name, name->len))
+		return 0;
+	return 1;
 }
 
 static struct dentry_operations xattr_lookup_poison_ops = {
-    .d_compare = xattr_lookup_poison,
+	.d_compare = xattr_lookup_poison,
 };
 
-
 /* We need to take a copy of the mount flags since things like
  * MS_RDONLY don't get set until *after* we're called.
  * mount_flags != mount_options */
-int
-reiserfs_xattr_init (struct super_block *s, int mount_flags)
+int reiserfs_xattr_init(struct super_block *s, int mount_flags)
 {
-  int err = 0;
-
-  /* We need generation numbers to ensure that the oid mapping is correct
-   * v3.5 filesystems don't have them. */
-  if (!old_format_only (s)) {
-    set_bit (REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
-  } else if (reiserfs_xattrs_optional (s)) {
-    /* Old format filesystem, but optional xattrs have been enabled
-     * at mount time. Error out. */
-    reiserfs_warning (s, "xattrs/ACLs not supported on pre v3.6 "
-                      "format filesystem. Failing mount.");
-    err = -EOPNOTSUPP;
-    goto error;
-  } else {
-    /* Old format filesystem, but no optional xattrs have been enabled. This
-     * means we silently disable xattrs on the filesystem. */
-    clear_bit (REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
-  }
-
-  /* If we don't have the privroot located yet - go find it */
-  if (reiserfs_xattrs (s) && !REISERFS_SB(s)->priv_root) {
-      struct dentry *dentry;
-      dentry = lookup_one_len (PRIVROOT_NAME, s->s_root,
-                               strlen (PRIVROOT_NAME));
-      if (!IS_ERR (dentry)) {
-        if (!(mount_flags & MS_RDONLY) && !dentry->d_inode) {
-            struct inode *inode = dentry->d_parent->d_inode;
-            down (&inode->i_sem);
-            err = inode->i_op->mkdir (inode, dentry, 0700);
-            up (&inode->i_sem);
-            if (err) {
-                dput (dentry);
-                dentry = NULL;
-            }
-
-            if (dentry && dentry->d_inode)
-                reiserfs_warning (s, "Created %s on %s - reserved for "
-                                  "xattr storage.", PRIVROOT_NAME,
-                                  reiserfs_bdevname (inode->i_sb));
-        } else if (!dentry->d_inode) {
-            dput (dentry);
-            dentry = NULL;
-        }
-      } else
-        err = PTR_ERR (dentry);
-
-      if (!err && dentry) {
-          s->s_root->d_op = &xattr_lookup_poison_ops;
-          reiserfs_mark_inode_private (dentry->d_inode);
-          REISERFS_SB(s)->priv_root = dentry;
-      } else if (!(mount_flags & MS_RDONLY)) { /* xattrs are unavailable */
-          /* If we're read-only it just means that the dir hasn't been
-           * created. Not an error -- just no xattrs on the fs. We'll
-           * check again if we go read-write */
-          reiserfs_warning (s, "xattrs/ACLs enabled and couldn't "
-                            "find/create .reiserfs_priv. Failing mount.");
-          err = -EOPNOTSUPP;
-      }
-  }
-
-error:
-   /* This is only nonzero if there was an error initializing the xattr
-    * directory or if there is a condition where we don't support them. */
-    if (err) {
-          clear_bit (REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
-          clear_bit (REISERFS_XATTRS_USER, &(REISERFS_SB(s)->s_mount_opt));
-          clear_bit (REISERFS_POSIXACL, &(REISERFS_SB(s)->s_mount_opt));
-    }
-
-    /* The super_block MS_POSIXACL must mirror the (no)acl mount option. */
-    s->s_flags = s->s_flags & ~MS_POSIXACL;
-    if (reiserfs_posixacl (s))
-	s->s_flags |= MS_POSIXACL;
-
-    return err;
+	int err = 0;
+
+	/* We need generation numbers to ensure that the oid mapping is correct
+	 * v3.5 filesystems don't have them. */
+	if (!old_format_only(s)) {
+		set_bit(REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
+	} else if (reiserfs_xattrs_optional(s)) {
+		/* Old format filesystem, but optional xattrs have been enabled
+		 * at mount time. Error out. */
+		reiserfs_warning(s, "xattrs/ACLs not supported on pre v3.6 "
+				 "format filesystem. Failing mount.");
+		err = -EOPNOTSUPP;
+		goto error;
+	} else {
+		/* Old format filesystem, but no optional xattrs have been enabled. This
+		 * means we silently disable xattrs on the filesystem. */
+		clear_bit(REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
+	}
+
+	/* If we don't have the privroot located yet - go find it */
+	if (reiserfs_xattrs(s) && !REISERFS_SB(s)->priv_root) {
+		struct dentry *dentry;
+		dentry = lookup_one_len(PRIVROOT_NAME, s->s_root,
+					strlen(PRIVROOT_NAME));
+		if (!IS_ERR(dentry)) {
+			if (!(mount_flags & MS_RDONLY) && !dentry->d_inode) {
+				struct inode *inode = dentry->d_parent->d_inode;
+				down(&inode->i_sem);
+				err = inode->i_op->mkdir(inode, dentry, 0700);
+				up(&inode->i_sem);
+				if (err) {
+					dput(dentry);
+					dentry = NULL;
+				}
+
+				if (dentry && dentry->d_inode)
+					reiserfs_warning(s,
+							 "Created %s on %s - reserved for "
+							 "xattr storage.",
+							 PRIVROOT_NAME,
+							 reiserfs_bdevname
+							 (inode->i_sb));
+			} else if (!dentry->d_inode) {
+				dput(dentry);
+				dentry = NULL;
+			}
+		} else
+			err = PTR_ERR(dentry);
+
+		if (!err && dentry) {
+			s->s_root->d_op = &xattr_lookup_poison_ops;
+			reiserfs_mark_inode_private(dentry->d_inode);
+			REISERFS_SB(s)->priv_root = dentry;
+		} else if (!(mount_flags & MS_RDONLY)) {	/* xattrs are unavailable */
+			/* If we're read-only it just means that the dir hasn't been
+			 * created. Not an error -- just no xattrs on the fs. We'll
+			 * check again if we go read-write */
+			reiserfs_warning(s, "xattrs/ACLs enabled and couldn't "
+					 "find/create .reiserfs_priv. Failing mount.");
+			err = -EOPNOTSUPP;
+		}
+	}
+
+      error:
+	/* This is only nonzero if there was an error initializing the xattr
+	 * directory or if there is a condition where we don't support them. */
+	if (err) {
+		clear_bit(REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
+		clear_bit(REISERFS_XATTRS_USER, &(REISERFS_SB(s)->s_mount_opt));
+		clear_bit(REISERFS_POSIXACL, &(REISERFS_SB(s)->s_mount_opt));
+	}
+
+	/* The super_block MS_POSIXACL must mirror the (no)acl mount option. */
+	s->s_flags = s->s_flags & ~MS_POSIXACL;
+	if (reiserfs_posixacl(s))
+		s->s_flags |= MS_POSIXACL;
+
+	return err;
 }
 
 static int
-__reiserfs_permission (struct inode *inode, int mask, struct nameidata *nd,
-                       int need_lock)
+__reiserfs_permission(struct inode *inode, int mask, struct nameidata *nd,
+		      int need_lock)
 {
-	umode_t			mode = inode->i_mode;
+	umode_t mode = inode->i_mode;
 
 	if (mask & MAY_WRITE) {
 		/*
@@ -1363,50 +1365,50 @@ __reiserfs_permission (struct inode *inode, int mask, struct nameidata *nd,
 	}
 
 	/* We don't do permission checks on the internal objects.
-	* Permissions are determined by the "owning" object. */
-        if (is_reiserfs_priv_object (inode))
+	 * Permissions are determined by the "owning" object. */
+	if (is_reiserfs_priv_object(inode))
 		return 0;
 
 	if (current->fsuid == inode->i_uid) {
 		mode >>= 6;
 #ifdef CONFIG_REISERFS_FS_POSIX_ACL
 	} else if (reiserfs_posixacl(inode->i_sb) &&
-                   get_inode_sd_version (inode) != STAT_DATA_V1) {
-                struct posix_acl *acl;
+		   get_inode_sd_version(inode) != STAT_DATA_V1) {
+		struct posix_acl *acl;
 
 		/* ACL can't contain additional permissions if
 		   the ACL_MASK entry is 0 */
 		if (!(mode & S_IRWXG))
 			goto check_groups;
 
-                if (need_lock) {
-		    reiserfs_read_lock_xattr_i (inode);
-                    reiserfs_read_lock_xattrs (inode->i_sb);
+		if (need_lock) {
+			reiserfs_read_lock_xattr_i(inode);
+			reiserfs_read_lock_xattrs(inode->i_sb);
+		}
+		acl = reiserfs_get_acl(inode, ACL_TYPE_ACCESS);
+		if (need_lock) {
+			reiserfs_read_unlock_xattrs(inode->i_sb);
+			reiserfs_read_unlock_xattr_i(inode);
 		}
-                acl = reiserfs_get_acl (inode, ACL_TYPE_ACCESS);
-                if (need_lock) {
-                    reiserfs_read_unlock_xattrs (inode->i_sb);
-		    reiserfs_read_unlock_xattr_i (inode);
+		if (IS_ERR(acl)) {
+			if (PTR_ERR(acl) == -ENODATA)
+				goto check_groups;
+			return PTR_ERR(acl);
 		}
-                if (IS_ERR (acl)) {
-                    if (PTR_ERR (acl) == -ENODATA)
-                        goto check_groups;
-                    return PTR_ERR (acl);
-                }
-
-                if (acl) {
-                    int err = posix_acl_permission (inode, acl, mask);
-                    posix_acl_release (acl);
-                    if (err == -EACCES) {
-                        goto check_capabilities;
-                    }
-                    return err;
+
+		if (acl) {
+			int err = posix_acl_permission(inode, acl, mask);
+			posix_acl_release(acl);
+			if (err == -EACCES) {
+				goto check_capabilities;
+			}
+			return err;
 		} else {
 			goto check_groups;
-                }
+		}
 #endif
 	} else {
-check_groups:
+	      check_groups:
 		if (in_group_p(inode->i_gid))
 			mode >>= 3;
 	}
@@ -1414,10 +1416,10 @@ __reiserfs_permission (struct inode *inode, int mask, struct nameidata *nd,
 	/*
 	 * If the DACs are ok we don't need any capability check.
 	 */
-	if (((mode & mask & (MAY_READ|MAY_WRITE|MAY_EXEC)) == mask))
+	if (((mode & mask & (MAY_READ | MAY_WRITE | MAY_EXEC)) == mask))
 		return 0;
 
-check_capabilities:
+      check_capabilities:
 	/*
 	 * Read/write DACs are always overridable.
 	 * Executable DACs are overridable if at least one exec bit is set.
@@ -1437,14 +1439,13 @@ __reiserfs_permission (struct inode *inode, int mask, struct nameidata *nd,
 	return -EACCES;
 }
 
-int
-reiserfs_permission (struct inode *inode, int mask, struct nameidata *nd)
+int reiserfs_permission(struct inode *inode, int mask, struct nameidata *nd)
 {
-    return __reiserfs_permission (inode, mask, nd, 1);
+	return __reiserfs_permission(inode, mask, nd, 1);
 }
 
 int
-reiserfs_permission_locked (struct inode *inode, int mask, struct nameidata *nd)
+reiserfs_permission_locked(struct inode *inode, int mask, struct nameidata *nd)
 {
-    return __reiserfs_permission (inode, mask, nd, 0);
+	return __reiserfs_permission(inode, mask, nd, 0);
 }

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
new file mode 100644
index 000000000000..45582fe8b466
--- /dev/null
+++ b/fs/reiserfs/xattr.c
@@ -0,0 +1,1450 @@
+/*
+ * linux/fs/reiserfs/xattr.c
+ *
+ * Copyright (c) 2002 by Jeff Mahoney, <jeffm@suse.com>
+ *
+ */
+
+/*
+ * In order to implement EA/ACLs in a clean, backwards compatible manner,
+ * they are implemented as files in a "private" directory.
+ * Each EA is in it's own file, with the directory layout like so (/ is assumed
+ * to be relative to fs root). Inside the /.reiserfs_priv/xattrs directory,
+ * directories named using the capital-hex form of the objectid and
+ * generation number are used. Inside each directory are individual files
+ * named with the name of the extended attribute.
+ *
+ * So, for objectid 12648430, we could have:
+ * /.reiserfs_priv/xattrs/C0FFEE.0/system.posix_acl_access
+ * /.reiserfs_priv/xattrs/C0FFEE.0/system.posix_acl_default
+ * /.reiserfs_priv/xattrs/C0FFEE.0/user.Content-Type
+ * .. or similar.
+ *
+ * The file contents are the text of the EA. The size is known based on the
+ * stat data describing the file.
+ *
+ * In the case of system.posix_acl_access and system.posix_acl_default, since
+ * these are special cases for filesystem ACLs, they are interpreted by the
+ * kernel, in addition, they are negatively and positively cached and attached
+ * to the inode so that unnecessary lookups are avoided.
+ */
+
+#include <linux/reiserfs_fs.h>
+#include <linux/dcache.h>
+#include <linux/namei.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/pagemap.h>
+#include <linux/xattr.h>
+#include <linux/reiserfs_xattr.h>
+#include <linux/reiserfs_acl.h>
+#include <linux/mbcache.h>
+#include <asm/uaccess.h>
+#include <asm/checksum.h>
+#include <linux/smp_lock.h>
+#include <linux/stat.h>
+#include <asm/semaphore.h>
+
+#define FL_READONLY 128
+#define FL_DIR_SEM_HELD 256
+#define PRIVROOT_NAME ".reiserfs_priv"
+#define XAROOT_NAME   "xattrs"
+
+static struct reiserfs_xattr_handler *find_xattr_handler_prefix (const char *prefix);
+
+static struct dentry *
+create_xa_root (struct super_block *sb)
+{
+    struct dentry *privroot = dget (REISERFS_SB(sb)->priv_root);
+    struct dentry *xaroot;
+
+    /* This needs to be created at mount-time */
+    if (!privroot)
+        return ERR_PTR(-EOPNOTSUPP);
+
+    xaroot = lookup_one_len (XAROOT_NAME, privroot, strlen (XAROOT_NAME));
+    if (IS_ERR (xaroot)) {
+        goto out;
+    } else if (!xaroot->d_inode) {
+        int err;
+        down (&privroot->d_inode->i_sem);
+        err = privroot->d_inode->i_op->mkdir (privroot->d_inode, xaroot, 0700);
+        up (&privroot->d_inode->i_sem);
+
+        if (err) {
+            dput (xaroot);
+            dput (privroot);
+            return ERR_PTR (err);
+        }
+        REISERFS_SB(sb)->xattr_root = dget (xaroot);
+    }
+
+out:
+    dput (privroot);
+    return xaroot;
+}
+
+/* This will return a dentry, or error, refering to the xa root directory.
+ * If the xa root doesn't exist yet, the dentry will be returned without
+ * an associated inode. This dentry can be used with ->mkdir to create
+ * the xa directory. */
+static struct dentry *
+__get_xa_root (struct super_block *s)
+{
+    struct dentry *privroot = dget (REISERFS_SB(s)->priv_root);
+    struct dentry *xaroot = NULL;
+
+    if (IS_ERR (privroot) || !privroot)
+        return privroot;
+
+    xaroot = lookup_one_len (XAROOT_NAME, privroot, strlen (XAROOT_NAME));
+    if (IS_ERR (xaroot)) {
+        goto out;
+    } else if (!xaroot->d_inode) {
+        dput (xaroot);
+        xaroot = NULL;
+        goto out;
+    }
+
+    REISERFS_SB(s)->xattr_root = dget (xaroot);
+
+out:
+    dput (privroot);
+    return xaroot;
+}
+
+/* Returns the dentry (or NULL) referring to the root of the extended
+ * attribute directory tree. If it has already been retreived, it is used.
+ * Otherwise, we attempt to retreive it from disk. It may also return
+ * a pointer-encoded error.
+ */
+static inline struct dentry *
+get_xa_root (struct super_block *s)
+{
+    struct dentry *dentry = dget (REISERFS_SB(s)->xattr_root);
+
+    if (!dentry)
+        dentry = __get_xa_root (s);
+
+    return dentry;
+}
+
+/* Opens the directory corresponding to the inode's extended attribute store.
+ * If flags allow, the tree to the directory may be created. If creation is
+ * prohibited, -ENODATA is returned. */
+static struct dentry *
+open_xa_dir (const struct inode *inode, int flags)
+{
+    struct dentry *xaroot, *xadir;
+    char namebuf[17];
+
+    xaroot = get_xa_root (inode->i_sb);
+    if (IS_ERR (xaroot)) {
+        return xaroot;
+    } else if (!xaroot) {
+        if (flags == 0 || flags & XATTR_CREATE) {
+            xaroot = create_xa_root (inode->i_sb);
+            if (IS_ERR (xaroot))
+                return xaroot;
+        }
+        if (!xaroot)
+            return ERR_PTR (-ENODATA);
+    }
+
+    /* ok, we have xaroot open */
+
+    snprintf (namebuf, sizeof (namebuf), "%X.%X",
+              le32_to_cpu (INODE_PKEY (inode)->k_objectid),
+              inode->i_generation);
+    xadir = lookup_one_len (namebuf, xaroot, strlen (namebuf));
+    if (IS_ERR (xadir)) {
+        dput (xaroot);
+        return xadir;
+    }
+
+    if (!xadir->d_inode) {
+        int err;
+        if (flags == 0 || flags & XATTR_CREATE) {
+            /* Although there is nothing else trying to create this directory,
+             * another directory with the same hash may be created, so we need
+             * to protect against that */
+            err = xaroot->d_inode->i_op->mkdir (xaroot->d_inode, xadir, 0700);
+            if (err) {
+                dput (xaroot);
+                dput (xadir);
+                return ERR_PTR (err);
+            }
+        }
+        if (!xadir->d_inode) {
+            dput (xaroot);
+            dput (xadir);
+            return ERR_PTR (-ENODATA);
+        }
+    }
+
+    dput (xaroot);
+    return xadir;
+}
+
+/* Returns a dentry corresponding to a specific extended attribute file
+ * for the inode. If flags allow, the file is created. Otherwise, a
+ * valid or negative dentry, or an error is returned. */
+static struct dentry *
+get_xa_file_dentry (const struct inode *inode, const char *name, int flags)
+{
+    struct dentry *xadir, *xafile;
+    int err = 0;
+
+    xadir = open_xa_dir (inode, flags);
+    if (IS_ERR (xadir)) {
+        return ERR_PTR (PTR_ERR (xadir));
+    } else if (xadir && !xadir->d_inode) {
+        dput (xadir);
+        return ERR_PTR (-ENODATA);
+    }
+
+    xafile = lookup_one_len (name, xadir, strlen (name));
+    if (IS_ERR (xafile)) {
+        dput (xadir);
+        return ERR_PTR (PTR_ERR (xafile));
+    }
+
+    if (xafile->d_inode) { /* file exists */
+        if (flags & XATTR_CREATE) {
+            err = -EEXIST;
+            dput (xafile);
+            goto out;
+        }
+    } else if (flags & XATTR_REPLACE || flags & FL_READONLY) {
+        goto out;
+    } else {
+        /* inode->i_sem is down, so nothing else can try to create
+         * the same xattr */
+        err = xadir->d_inode->i_op->create (xadir->d_inode, xafile,
+                                            0700|S_IFREG, NULL);
+
+        if (err) {
+            dput (xafile);
+            goto out;
+        }
+    }
+
+out:
+    dput (xadir);
+    if (err)
+        xafile = ERR_PTR (err);
+    return xafile;
+}
+
+
+/* Opens a file pointer to the attribute associated with inode */
+static struct file *
+open_xa_file (const struct inode *inode, const char *name, int flags)
+{
+    struct dentry *xafile;
+    struct file *fp;
+
+    xafile = get_xa_file_dentry (inode, name, flags);
+    if (IS_ERR (xafile))
+        return ERR_PTR (PTR_ERR (xafile));
+    else if (!xafile->d_inode) {
+        dput (xafile);
+        return ERR_PTR (-ENODATA);
+    }
+
+    fp = dentry_open (xafile, NULL, O_RDWR);
+    /* dentry_open dputs the dentry if it fails */
+
+    return fp;
+}
+
+
+/*
+ * this is very similar to fs/reiserfs/dir.c:reiserfs_readdir, but
+ * we need to drop the path before calling the filldir struct.  That
+ * would be a big performance hit to the non-xattr case, so I've copied
+ * the whole thing for now. --clm
+ *
+ * the big difference is that I go backwards through the directory,
+ * and don't mess with f->f_pos, but the idea is the same.  Do some
+ * action on each and every entry in the directory.
+ *
+ * we're called with i_sem held, so there are no worries about the directory
+ * changing underneath us.
+ */
+static int __xattr_readdir(struct file * filp, void * dirent, filldir_t filldir)
+{
+    struct inode *inode = filp->f_dentry->d_inode;
+    struct cpu_key pos_key;	/* key of current position in the directory (key of directory entry) */
+    INITIALIZE_PATH (path_to_entry);
+    struct buffer_head * bh;
+    int entry_num;
+    struct item_head * ih, tmp_ih;
+    int search_res;
+    char * local_buf;
+    loff_t next_pos;
+    char small_buf[32] ; /* avoid kmalloc if we can */
+    struct reiserfs_de_head *deh;
+    int d_reclen;
+    char * d_name;
+    off_t d_off;
+    ino_t d_ino;
+    struct reiserfs_dir_entry de;
+
+
+    /* form key for search the next directory entry using f_pos field of
+       file structure */
+    next_pos = max_reiserfs_offset(inode);
+
+    while (1) {
+research:
+	if (next_pos <= DOT_DOT_OFFSET)
+	    break;
+	make_cpu_key (&pos_key, inode, next_pos, TYPE_DIRENTRY, 3);
+
+	search_res = search_by_entry_key(inode->i_sb, &pos_key, &path_to_entry, &de);
+	if (search_res == IO_ERROR) {
+	    // FIXME: we could just skip part of directory which could
+	    // not be read
+	    pathrelse(&path_to_entry);
+	    return -EIO;
+	}
+
+	if (search_res == NAME_NOT_FOUND)
+	    de.de_entry_num--;
+
+	set_de_name_and_namelen(&de);
+	entry_num = de.de_entry_num;
+	deh = &(de.de_deh[entry_num]);
+
+	bh = de.de_bh;
+	ih = de.de_ih;
+
+	if (!is_direntry_le_ih(ih)) {
+            reiserfs_warning(inode->i_sb, "not direntry %h", ih);
+	    break;
+        }
+	copy_item_head(&tmp_ih, ih);
+
+	/* we must have found item, that is item of this directory, */
+	RFALSE( COMP_SHORT_KEYS (&(ih->ih_key), &pos_key),
+		"vs-9000: found item %h does not match to dir we readdir %K",
+		ih, &pos_key);
+
+	if (deh_offset(deh) <= DOT_DOT_OFFSET) {
+	    break;
+	}
+
+	/* look for the previous entry in the directory */
+	next_pos = deh_offset (deh) - 1;
+
+	if (!de_visible (deh))
+	    /* it is hidden entry */
+	    continue;
+
+	d_reclen = entry_length(bh, ih, entry_num);
+	d_name = B_I_DEH_ENTRY_FILE_NAME (bh, ih, deh);
+	d_off = deh_offset (deh);
+	d_ino = deh_objectid (deh);
+
+	if (!d_name[d_reclen - 1])
+	    d_reclen = strlen (d_name);
+
+	if (d_reclen > REISERFS_MAX_NAME(inode->i_sb->s_blocksize)){
+	    /* too big to send back to VFS */
+	    continue ;
+	}
+
+        /* Ignore the .reiserfs_priv entry */
+        if (reiserfs_xattrs (inode->i_sb) &&
+            !old_format_only(inode->i_sb) &&
+            deh_objectid (deh) == le32_to_cpu (INODE_PKEY(REISERFS_SB(inode->i_sb)->priv_root->d_inode)->k_objectid))
+          continue;
+
+	if (d_reclen <= 32) {
+	  local_buf = small_buf ;
+	} else {
+	    local_buf = reiserfs_kmalloc(d_reclen, GFP_NOFS, inode->i_sb) ;
+	    if (!local_buf) {
+		pathrelse (&path_to_entry);
+		return -ENOMEM ;
+	    }
+	    if (item_moved (&tmp_ih, &path_to_entry)) {
+		reiserfs_kfree(local_buf, d_reclen, inode->i_sb) ;
+
+		/* sigh, must retry.  Do this same offset again */
+		next_pos = d_off;
+		goto research;
+	    }
+	}
+
+	// Note, that we copy name to user space via temporary
+	// buffer (local_buf) because filldir will block if
+	// user space buffer is swapped out. At that time
+	// entry can move to somewhere else
+	memcpy (local_buf, d_name, d_reclen);
+
+	/* the filldir function might need to start transactions,
+	 * or do who knows what.  Release the path now that we've
+	 * copied all the important stuff out of the deh
+	 */
+	pathrelse (&path_to_entry);
+
+	if (filldir (dirent, local_buf, d_reclen, d_off, d_ino,
+		     DT_UNKNOWN) < 0) {
+	    if (local_buf != small_buf) {
+		reiserfs_kfree(local_buf, d_reclen, inode->i_sb) ;
+	    }
+	    goto end;
+	}
+	if (local_buf != small_buf) {
+	    reiserfs_kfree(local_buf, d_reclen, inode->i_sb) ;
+	}
+    } /* while */
+
+end:
+    pathrelse (&path_to_entry);
+    return 0;
+}
+
+/*
+ * this could be done with dedicated readdir ops for the xattr files,
+ * but I want to get something working asap
+ * this is stolen from vfs_readdir
+ *
+ */
+static
+int xattr_readdir(struct file *file, filldir_t filler, void *buf)
+{
+        struct inode *inode = file->f_dentry->d_inode;
+        int res = -ENOTDIR;
+        if (!file->f_op || !file->f_op->readdir)
+                goto out;
+        down(&inode->i_sem);
+//        down(&inode->i_zombie);
+        res = -ENOENT;
+        if (!IS_DEADDIR(inode)) {
+                lock_kernel();
+                res = __xattr_readdir(file, buf, filler);
+                unlock_kernel();
+        }
+//        up(&inode->i_zombie);
+        up(&inode->i_sem);
+out:
+        return res;
+}
+
+
+/* Internal operations on file data */
+static inline void
+reiserfs_put_page(struct page *page)
+{
+        kunmap(page);
+        page_cache_release(page);
+}
+
+static struct page *
+reiserfs_get_page(struct inode *dir, unsigned long n)
+{
+        struct address_space *mapping = dir->i_mapping;
+        struct page *page;
+        /* We can deadlock if we try to free dentries,
+           and an unlink/rmdir has just occured - GFP_NOFS avoids this */
+        mapping->flags = (mapping->flags & ~__GFP_BITS_MASK) | GFP_NOFS;
+        page = read_cache_page (mapping, n,
+                                (filler_t*)mapping->a_ops->readpage, NULL);
+        if (!IS_ERR(page)) {
+                wait_on_page_locked(page);
+                kmap(page);
+                if (!PageUptodate(page))
+                        goto fail;
+
+                if (PageError(page))
+                        goto fail;
+        }
+        return page;
+
+fail:
+        reiserfs_put_page(page);
+        return ERR_PTR(-EIO);
+}
+
+static inline __u32
+xattr_hash (const char *msg, int len)
+{
+    return csum_partial (msg, len, 0);
+}
+
+/* Generic extended attribute operations that can be used by xa plugins */
+
+/*
+ * inode->i_sem: down
+ */
+int
+reiserfs_xattr_set (struct inode *inode, const char *name, const void *buffer,
+                    size_t buffer_size, int flags)
+{
+    int err = 0;
+    struct file *fp;
+    struct page *page;
+    char *data;
+    struct address_space *mapping;
+    size_t file_pos = 0;
+    size_t buffer_pos = 0;
+    struct inode *xinode;
+    struct iattr newattrs;
+    __u32 xahash = 0;
+
+    if (IS_RDONLY (inode))
+        return -EROFS;
+
+    if (IS_IMMUTABLE (inode) || IS_APPEND (inode))
+        return -EPERM;
+
+    if (get_inode_sd_version (inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+
+    /* Empty xattrs are ok, they're just empty files, no hash */
+    if (buffer && buffer_size)
+        xahash = xattr_hash (buffer, buffer_size);
+
+open_file:
+    fp = open_xa_file (inode, name, flags);
+    if (IS_ERR (fp)) {
+        err = PTR_ERR (fp);
+        goto out;
+    }
+
+    xinode = fp->f_dentry->d_inode;
+    REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
+
+    /* we need to copy it off.. */
+    if (xinode->i_nlink > 1) {
+	fput(fp);
+        err = reiserfs_xattr_del (inode, name);
+        if (err < 0)
+            goto out;
+        /* We just killed the old one, we're not replacing anymore */
+        if (flags & XATTR_REPLACE)
+            flags &= ~XATTR_REPLACE;
+        goto open_file;
+    }
+
+    /* Resize it so we're ok to write there */
+    newattrs.ia_size = buffer_size;
+    newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
+    down (&xinode->i_sem);
+    err = notify_change(fp->f_dentry, &newattrs);
+    if (err)
+        goto out_filp;
+
+    mapping = xinode->i_mapping;
+    while (buffer_pos < buffer_size || buffer_pos == 0) {
+        size_t chunk;
+        size_t skip = 0;
+        size_t page_offset = (file_pos & (PAGE_CACHE_SIZE - 1));
+        if (buffer_size - buffer_pos > PAGE_CACHE_SIZE)
+            chunk = PAGE_CACHE_SIZE;
+        else
+            chunk = buffer_size - buffer_pos;
+
+        page = reiserfs_get_page (xinode, file_pos >> PAGE_CACHE_SHIFT);
+        if (IS_ERR (page)) {
+            err = PTR_ERR (page);
+            goto out_filp;
+        }
+
+        lock_page (page);
+        data = page_address (page);
+
+        if (file_pos == 0) {
+            struct reiserfs_xattr_header *rxh;
+            skip = file_pos = sizeof (struct reiserfs_xattr_header);
+            if (chunk + skip > PAGE_CACHE_SIZE)
+                chunk = PAGE_CACHE_SIZE - skip;
+            rxh = (struct reiserfs_xattr_header *)data;
+            rxh->h_magic = cpu_to_le32 (REISERFS_XATTR_MAGIC);
+            rxh->h_hash = cpu_to_le32 (xahash);
+        }
+
+        err = mapping->a_ops->prepare_write (fp, page, page_offset,
+                                             page_offset + chunk + skip);
+        if (!err) {
+	    if (buffer)
+		memcpy (data + skip, buffer + buffer_pos, chunk);
+            err = mapping->a_ops->commit_write (fp, page, page_offset,
+                                                page_offset + chunk + skip);
+	}
+        unlock_page (page);
+        reiserfs_put_page (page);
+        buffer_pos += chunk;
+        file_pos += chunk;
+        skip = 0;
+        if (err || buffer_size == 0 || !buffer)
+            break;
+    }
+
+    /* We can't mark the inode dirty if it's not hashed. This is the case
+     * when we're inheriting the default ACL. If we dirty it, the inode
+     * gets marked dirty, but won't (ever) make it onto the dirty list until
+     * it's synced explicitly to clear I_DIRTY. This is bad. */
+    if (!hlist_unhashed(&inode->i_hash)) {
+        inode->i_ctime = CURRENT_TIME_SEC;
+        mark_inode_dirty (inode);
+    }
+
+out_filp:
+    up (&xinode->i_sem);
+    fput(fp);
+
+out:
+    return err;
+}
+
+/*
+ * inode->i_sem: down
+ */
+int
+reiserfs_xattr_get (const struct inode *inode, const char *name, void *buffer,
+                    size_t buffer_size)
+{
+    ssize_t err = 0;
+    struct file *fp;
+    size_t isize;
+    size_t file_pos = 0;
+    size_t buffer_pos = 0;
+    struct page *page;
+    struct inode *xinode;
+    __u32 hash = 0;
+
+    if (name == NULL)
+        return -EINVAL;
+
+    /* We can't have xattrs attached to v1 items since they don't have
+     * generation numbers */
+    if (get_inode_sd_version (inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+
+    fp = open_xa_file (inode, name, FL_READONLY);
+    if (IS_ERR (fp)) {
+        err = PTR_ERR (fp);
+        goto out;
+    }
+
+    xinode = fp->f_dentry->d_inode;
+    isize = xinode->i_size;
+    REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
+
+    /* Just return the size needed */
+    if (buffer == NULL) {
+        err = isize - sizeof (struct reiserfs_xattr_header);
+        goto out_dput;
+    }
+
+    if (buffer_size < isize - sizeof (struct reiserfs_xattr_header)) {
+        err = -ERANGE;
+        goto out_dput;
+    }
+
+    while (file_pos < isize) {
+        size_t chunk;
+        char *data;
+        size_t skip = 0;
+        if (isize - file_pos > PAGE_CACHE_SIZE)
+            chunk = PAGE_CACHE_SIZE;
+        else
+            chunk = isize - file_pos;
+
+        page = reiserfs_get_page (xinode, file_pos >> PAGE_CACHE_SHIFT);
+        if (IS_ERR (page)) {
+            err = PTR_ERR (page);
+            goto out_dput;
+        }
+
+        lock_page (page);
+        data = page_address (page);
+        if (file_pos == 0) {
+            struct reiserfs_xattr_header *rxh =
+                                        (struct reiserfs_xattr_header *)data;
+            skip = file_pos = sizeof (struct reiserfs_xattr_header);
+            chunk -= skip;
+            /* Magic doesn't match up.. */
+            if (rxh->h_magic != cpu_to_le32 (REISERFS_XATTR_MAGIC)) {
+                unlock_page (page);
+                reiserfs_put_page (page);
+                reiserfs_warning (inode->i_sb, "Invalid magic for xattr (%s) "
+                                  "associated with %k", name,
+                                  INODE_PKEY (inode));
+                err = -EIO;
+                goto out_dput;
+            }
+            hash = le32_to_cpu (rxh->h_hash);
+        }
+        memcpy (buffer + buffer_pos, data + skip, chunk);
+        unlock_page (page);
+        reiserfs_put_page (page);
+        file_pos += chunk;
+        buffer_pos += chunk;
+        skip = 0;
+    }
+    err = isize - sizeof (struct reiserfs_xattr_header);
+
+    if (xattr_hash (buffer, isize - sizeof (struct reiserfs_xattr_header)) != hash) {
+        reiserfs_warning (inode->i_sb, "Invalid hash for xattr (%s) associated "
+                          "with %k", name, INODE_PKEY (inode));
+        err = -EIO;
+    }
+
+out_dput:
+    fput(fp);
+
+out:
+    return err;
+}
+
+static int
+__reiserfs_xattr_del (struct dentry *xadir, const char *name, int namelen)
+{
+    struct dentry *dentry;
+    struct inode *dir = xadir->d_inode;
+    int err = 0;
+
+    dentry = lookup_one_len (name, xadir, namelen);
+    if (IS_ERR (dentry)) {
+        err = PTR_ERR (dentry);
+        goto out;
+    } else if (!dentry->d_inode) {
+        err = -ENODATA;
+        goto out_file;
+    }
+
+    /* Skip directories.. */
+    if (S_ISDIR (dentry->d_inode->i_mode))
+        goto out_file;
+
+    if (!is_reiserfs_priv_object (dentry->d_inode)) {
+        reiserfs_warning (dir->i_sb, "OID %08x [%.*s/%.*s] doesn't have "
+                                     "priv flag set [parent is %sset].",
+                        le32_to_cpu (INODE_PKEY (dentry->d_inode)->k_objectid),
+                        xadir->d_name.len, xadir->d_name.name, namelen, name,
+                        is_reiserfs_priv_object (xadir->d_inode) ? "" : "not ");
+        dput (dentry);
+        return -EIO;
+    }
+
+    err = dir->i_op->unlink (dir, dentry);
+    if (!err)
+        d_delete (dentry);
+
+out_file:
+    dput (dentry);
+
+out:
+    return err;
+}
+
+
+int
+reiserfs_xattr_del (struct inode *inode, const char *name)
+{
+    struct dentry *dir;
+    int err;
+
+    if (IS_RDONLY (inode))
+        return -EROFS;
+
+    dir = open_xa_dir (inode, FL_READONLY);
+    if (IS_ERR (dir)) {
+        err = PTR_ERR (dir);
+        goto out;
+    }
+
+    err = __reiserfs_xattr_del (dir, name, strlen (name));
+    dput (dir);
+
+    if (!err) {
+        inode->i_ctime = CURRENT_TIME_SEC;
+        mark_inode_dirty (inode);
+    }
+
+out:
+    return err;
+}
+
+/* The following are side effects of other operations that aren't explicitly
+ * modifying extended attributes. This includes operations such as permissions
+ * or ownership changes, object deletions, etc. */
+
+static int
+reiserfs_delete_xattrs_filler (void *buf, const char *name, int namelen,
+                               loff_t offset, ino_t ino, unsigned int d_type)
+{
+    struct dentry *xadir = (struct dentry *)buf;
+
+    return __reiserfs_xattr_del (xadir, name, namelen);
+
+}
+
+/* This is called w/ inode->i_sem downed */
+int
+reiserfs_delete_xattrs (struct inode *inode)
+{
+    struct file *fp;
+    struct dentry *dir, *root;
+    int err = 0;
+
+    /* Skip out, an xattr has no xattrs associated with it */
+    if (is_reiserfs_priv_object (inode) ||
+        get_inode_sd_version (inode) == STAT_DATA_V1 ||
+        !reiserfs_xattrs(inode->i_sb))
+    {
+        return 0;
+    }
+    reiserfs_read_lock_xattrs (inode->i_sb);
+    dir = open_xa_dir (inode, FL_READONLY);
+    reiserfs_read_unlock_xattrs (inode->i_sb);
+    if (IS_ERR (dir)) {
+        err = PTR_ERR (dir);
+        goto out;
+    } else if (!dir->d_inode) {
+        dput (dir);
+        return 0;
+    }
+
+    fp = dentry_open (dir, NULL, O_RDWR);
+    if (IS_ERR (fp)) {
+        err = PTR_ERR (fp);
+        /* dentry_open dputs the dentry if it fails */
+        goto out;
+    }
+
+    lock_kernel ();
+    err = xattr_readdir (fp, reiserfs_delete_xattrs_filler, dir);
+    if (err) {
+        unlock_kernel ();
+        goto out_dir;
+    }
+
+    /* Leftovers besides . and .. -- that's not good. */
+    if (dir->d_inode->i_nlink <= 2) {
+        root = get_xa_root (inode->i_sb);
+        reiserfs_write_lock_xattrs (inode->i_sb);
+        err = vfs_rmdir (root->d_inode, dir);
+        reiserfs_write_unlock_xattrs (inode->i_sb);
+        dput (root);
+    } else {
+        reiserfs_warning (inode->i_sb,
+                          "Couldn't remove all entries in directory");
+    }
+    unlock_kernel ();
+
+out_dir:
+    fput(fp);
+
+out:
+    if (!err)
+        REISERFS_I(inode)->i_flags = REISERFS_I(inode)->i_flags & ~i_has_xattr_dir;
+    return err;
+}
+
+struct reiserfs_chown_buf {
+    struct inode *inode;
+    struct dentry *xadir;
+    struct iattr *attrs;
+};
+
+/* XXX: If there is a better way to do this, I'd love to hear about it */
+static int
+reiserfs_chown_xattrs_filler (void *buf, const char *name, int namelen,
+                               loff_t offset, ino_t ino, unsigned int d_type)
+{
+    struct reiserfs_chown_buf *chown_buf = (struct reiserfs_chown_buf *)buf;
+    struct dentry *xafile, *xadir = chown_buf->xadir;
+    struct iattr *attrs = chown_buf->attrs;
+    int err = 0;
+
+    xafile = lookup_one_len (name, xadir, namelen);
+    if (IS_ERR (xafile))
+        return PTR_ERR (xafile);
+    else if (!xafile->d_inode) {
+        dput (xafile);
+        return -ENODATA;
+    }
+
+    if (!S_ISDIR (xafile->d_inode->i_mode))
+        err = notify_change (xafile, attrs);
+    dput (xafile);
+
+    return err;
+}
+
+int
+reiserfs_chown_xattrs (struct inode *inode, struct iattr *attrs)
+{
+    struct file *fp;
+    struct dentry *dir;
+    int err = 0;
+    struct reiserfs_chown_buf buf;
+    unsigned int ia_valid = attrs->ia_valid;
+
+    /* Skip out, an xattr has no xattrs associated with it */
+    if (is_reiserfs_priv_object (inode) ||
+        get_inode_sd_version (inode) == STAT_DATA_V1 ||
+        !reiserfs_xattrs(inode->i_sb))
+    {
+        return 0;
+    }
+    reiserfs_read_lock_xattrs (inode->i_sb);
+    dir = open_xa_dir (inode, FL_READONLY);
+    reiserfs_read_unlock_xattrs (inode->i_sb);
+    if (IS_ERR (dir)) {
+        if (PTR_ERR (dir) != -ENODATA)
+            err = PTR_ERR (dir);
+        goto out;
+    } else if (!dir->d_inode) {
+        dput (dir);
+        goto out;
+    }
+
+    fp = dentry_open (dir, NULL, O_RDWR);
+    if (IS_ERR (fp)) {
+        err = PTR_ERR (fp);
+        /* dentry_open dputs the dentry if it fails */
+        goto out;
+    }
+
+    lock_kernel ();
+
+    attrs->ia_valid &= (ATTR_UID | ATTR_GID | ATTR_CTIME);
+    buf.xadir = dir;
+    buf.attrs = attrs;
+    buf.inode = inode;
+
+    err = xattr_readdir (fp, reiserfs_chown_xattrs_filler, &buf);
+    if (err) {
+        unlock_kernel ();
+        goto out_dir;
+    }
+
+    err = notify_change (dir, attrs);
+    unlock_kernel ();
+
+out_dir:
+    fput(fp);
+
+out:
+    attrs->ia_valid = ia_valid;
+    return err;
+}
+
+
+/* Actual operations that are exported to VFS-land */
+
+/*
+ * Inode operation getxattr()
+ * Preliminary locking: we down dentry->d_inode->i_sem
+ */
+ssize_t
+reiserfs_getxattr (struct dentry *dentry, const char *name, void *buffer,
+                   size_t size)
+{
+    struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
+    int err;
+
+    if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
+        get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+
+    reiserfs_read_lock_xattr_i (dentry->d_inode);
+    reiserfs_read_lock_xattrs (dentry->d_sb);
+    err = xah->get (dentry->d_inode, name, buffer, size);
+    reiserfs_read_unlock_xattrs (dentry->d_sb);
+    reiserfs_read_unlock_xattr_i (dentry->d_inode);
+    return err;
+}
+
+
+/*
+ * Inode operation setxattr()
+ *
+ * dentry->d_inode->i_sem down
+ */
+int
+reiserfs_setxattr (struct dentry *dentry, const char *name, const void *value,
+                   size_t size, int flags)
+{
+    struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
+    int err;
+    int lock;
+
+    if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
+        get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+
+    if (IS_RDONLY (dentry->d_inode))
+        return -EROFS;
+
+    if (IS_IMMUTABLE (dentry->d_inode) || IS_APPEND (dentry->d_inode))
+        return -EROFS;
+
+    reiserfs_write_lock_xattr_i (dentry->d_inode);
+    lock = !has_xattr_dir (dentry->d_inode);
+    if (lock)
+        reiserfs_write_lock_xattrs (dentry->d_sb);
+    else
+        reiserfs_read_lock_xattrs (dentry->d_sb);
+    err = xah->set (dentry->d_inode, name, value, size, flags);
+    if (lock)
+        reiserfs_write_unlock_xattrs (dentry->d_sb);
+    else
+        reiserfs_read_unlock_xattrs (dentry->d_sb);
+    reiserfs_write_unlock_xattr_i (dentry->d_inode);
+    return err;
+}
+
+/*
+ * Inode operation removexattr()
+ *
+ * dentry->d_inode->i_sem down
+ */
+int
+reiserfs_removexattr (struct dentry *dentry, const char *name)
+{
+    int err;
+    struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
+
+    if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
+        get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+
+    if (IS_RDONLY (dentry->d_inode))
+        return -EROFS;
+
+    if (IS_IMMUTABLE (dentry->d_inode) || IS_APPEND (dentry->d_inode))
+        return -EPERM;
+
+    reiserfs_write_lock_xattr_i (dentry->d_inode);
+    reiserfs_read_lock_xattrs (dentry->d_sb);
+
+    /* Deletion pre-operation */
+    if (xah->del) {
+        err = xah->del (dentry->d_inode, name);
+        if (err)
+            goto out;
+    }
+
+    err = reiserfs_xattr_del (dentry->d_inode, name);
+
+    dentry->d_inode->i_ctime = CURRENT_TIME_SEC;
+    mark_inode_dirty (dentry->d_inode);
+
+out:
+    reiserfs_read_unlock_xattrs (dentry->d_sb);
+    reiserfs_write_unlock_xattr_i (dentry->d_inode);
+    return err;
+}
+
+
+/* This is what filldir will use:
+ * r_pos will always contain the amount of space required for the entire
+ * list. If r_pos becomes larger than r_size, we need more space and we
+ * return an error indicating this. If r_pos is less than r_size, then we've
+ * filled the buffer successfully and we return success */
+struct reiserfs_listxattr_buf {
+    int r_pos;
+    int r_size;
+    char *r_buf;
+    struct inode *r_inode;
+};
+
+static int
+reiserfs_listxattr_filler (void *buf, const char *name, int namelen,
+                           loff_t offset, ino_t ino, unsigned int d_type)
+{
+    struct reiserfs_listxattr_buf *b = (struct reiserfs_listxattr_buf *)buf;
+    int len = 0;
+    if (name[0] != '.' || (namelen != 1 && (name[1] != '.' || namelen != 2))) {
+        struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
+        if (!xah) return 0; /* Unsupported xattr name, skip it */
+
+        /* We call ->list() twice because the operation isn't required to just
+         * return the name back - we want to make sure we have enough space */
+        len += xah->list (b->r_inode, name, namelen, NULL);
+
+        if (len) {
+            if (b->r_pos + len + 1 <= b->r_size) {
+                char *p = b->r_buf + b->r_pos;
+                p += xah->list (b->r_inode, name, namelen, p);
+                *p++ = '\0';
+            }
+            b->r_pos += len + 1;
+        }
+    }
+
+    return 0;
+}
+/*
+ * Inode operation listxattr()
+ *
+ * Preliminary locking: we down dentry->d_inode->i_sem
+ */
+ssize_t
+reiserfs_listxattr (struct dentry *dentry, char *buffer, size_t size)
+{
+    struct file *fp;
+    struct dentry *dir;
+    int err = 0;
+    struct reiserfs_listxattr_buf buf;
+
+    if (!dentry->d_inode)
+        return -EINVAL;
+
+    if (!reiserfs_xattrs(dentry->d_sb) ||
+        get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+
+    reiserfs_read_lock_xattr_i (dentry->d_inode);
+    reiserfs_read_lock_xattrs (dentry->d_sb);
+    dir = open_xa_dir (dentry->d_inode, FL_READONLY);
+    reiserfs_read_unlock_xattrs (dentry->d_sb);
+    if (IS_ERR (dir)) {
+        err = PTR_ERR (dir);
+        if (err == -ENODATA)
+            err = 0; /* Not an error if there aren't any xattrs */
+        goto out;
+    }
+
+    fp = dentry_open (dir, NULL, O_RDWR);
+    if (IS_ERR (fp)) {
+        err = PTR_ERR (fp);
+        /* dentry_open dputs the dentry if it fails */
+        goto out;
+    }
+
+    buf.r_buf = buffer;
+    buf.r_size = buffer ? size : 0;
+    buf.r_pos = 0;
+    buf.r_inode = dentry->d_inode;
+
+    REISERFS_I(dentry->d_inode)->i_flags |= i_has_xattr_dir;
+
+    err = xattr_readdir (fp, reiserfs_listxattr_filler, &buf);
+    if (err)
+        goto out_dir;
+
+    if (buf.r_pos > buf.r_size && buffer != NULL)
+        err = -ERANGE;
+    else
+        err = buf.r_pos;
+
+out_dir:
+    fput(fp);
+
+out:
+    reiserfs_read_unlock_xattr_i (dentry->d_inode);
+    return err;
+}
+
+/* This is the implementation for the xattr plugin infrastructure */
+static struct list_head xattr_handlers = LIST_HEAD_INIT (xattr_handlers);
+static DEFINE_RWLOCK(handler_lock);
+
+static struct reiserfs_xattr_handler *
+find_xattr_handler_prefix (const char *prefix)
+{
+    struct reiserfs_xattr_handler *xah = NULL;
+    struct list_head *p;
+
+    read_lock (&handler_lock);
+    list_for_each (p, &xattr_handlers) {
+        xah = list_entry (p, struct reiserfs_xattr_handler, handlers);
+        if (strncmp (xah->prefix, prefix, strlen (xah->prefix)) == 0)
+            break;
+        xah = NULL;
+    }
+
+    read_unlock (&handler_lock);
+    return xah;
+}
+
+static void
+__unregister_handlers (void)
+{
+    struct reiserfs_xattr_handler *xah;
+    struct list_head *p, *tmp;
+
+    list_for_each_safe (p, tmp, &xattr_handlers) {
+        xah = list_entry (p, struct reiserfs_xattr_handler, handlers);
+        if (xah->exit)
+            xah->exit();
+
+        list_del_init (p);
+    }
+    INIT_LIST_HEAD (&xattr_handlers);
+}
+
+int __init
+reiserfs_xattr_register_handlers (void)
+{
+    int err = 0;
+    struct reiserfs_xattr_handler *xah;
+    struct list_head *p;
+
+    write_lock (&handler_lock);
+
+    /* If we're already initialized, nothing to do */
+    if (!list_empty (&xattr_handlers)) {
+        write_unlock (&handler_lock);
+        return 0;
+    }
+
+    /* Add the handlers */
+    list_add_tail (&user_handler.handlers, &xattr_handlers);
+    list_add_tail (&trusted_handler.handlers, &xattr_handlers);
+#ifdef CONFIG_REISERFS_FS_SECURITY
+    list_add_tail (&security_handler.handlers, &xattr_handlers);
+#endif
+#ifdef CONFIG_REISERFS_FS_POSIX_ACL
+    list_add_tail (&posix_acl_access_handler.handlers, &xattr_handlers);
+    list_add_tail (&posix_acl_default_handler.handlers, &xattr_handlers);
+#endif
+
+    /* Run initializers, if available */
+    list_for_each (p, &xattr_handlers) {
+        xah = list_entry (p, struct reiserfs_xattr_handler, handlers);
+        if (xah->init) {
+            err = xah->init ();
+            if (err) {
+                list_del_init (p);
+                break;
+            }
+        }
+    }
+
+    /* Clean up other handlers, if any failed */
+    if (err)
+        __unregister_handlers ();
+
+    write_unlock (&handler_lock);
+    return err;
+}
+
+void
+reiserfs_xattr_unregister_handlers (void)
+{
+    write_lock (&handler_lock);
+    __unregister_handlers ();
+    write_unlock (&handler_lock);
+}
+
+/* This will catch lookups from the fs root to .reiserfs_priv */
+static int
+xattr_lookup_poison (struct dentry *dentry, struct qstr *q1, struct qstr *name)
+{
+    struct dentry *priv_root = REISERFS_SB(dentry->d_sb)->priv_root;
+    if (name->len == priv_root->d_name.len &&
+        name->hash == priv_root->d_name.hash &&
+        !memcmp (name->name, priv_root->d_name.name, name->len)) {
+            return -ENOENT;
+    } else if (q1->len == name->len &&
+               !memcmp(q1->name, name->name, name->len))
+        return 0;
+    return 1;
+}
+
+static struct dentry_operations xattr_lookup_poison_ops = {
+    .d_compare = xattr_lookup_poison,
+};
+
+
+/* We need to take a copy of the mount flags since things like
+ * MS_RDONLY don't get set until *after* we're called.
+ * mount_flags != mount_options */
+int
+reiserfs_xattr_init (struct super_block *s, int mount_flags)
+{
+  int err = 0;
+
+  /* We need generation numbers to ensure that the oid mapping is correct
+   * v3.5 filesystems don't have them. */
+  if (!old_format_only (s)) {
+    set_bit (REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
+  } else if (reiserfs_xattrs_optional (s)) {
+    /* Old format filesystem, but optional xattrs have been enabled
+     * at mount time. Error out. */
+    reiserfs_warning (s, "xattrs/ACLs not supported on pre v3.6 "
+                      "format filesystem. Failing mount.");
+    err = -EOPNOTSUPP;
+    goto error;
+  } else {
+    /* Old format filesystem, but no optional xattrs have been enabled. This
+     * means we silently disable xattrs on the filesystem. */
+    clear_bit (REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
+  }
+
+  /* If we don't have the privroot located yet - go find it */
+  if (reiserfs_xattrs (s) && !REISERFS_SB(s)->priv_root) {
+      struct dentry *dentry;
+      dentry = lookup_one_len (PRIVROOT_NAME, s->s_root,
+                               strlen (PRIVROOT_NAME));
+      if (!IS_ERR (dentry)) {
+        if (!(mount_flags & MS_RDONLY) && !dentry->d_inode) {
+            struct inode *inode = dentry->d_parent->d_inode;
+            down (&inode->i_sem);
+            err = inode->i_op->mkdir (inode, dentry, 0700);
+            up (&inode->i_sem);
+            if (err) {
+                dput (dentry);
+                dentry = NULL;
+            }
+
+            if (dentry && dentry->d_inode)
+                reiserfs_warning (s, "Created %s on %s - reserved for "
+                                  "xattr storage.", PRIVROOT_NAME,
+                                  reiserfs_bdevname (inode->i_sb));
+        } else if (!dentry->d_inode) {
+            dput (dentry);
+            dentry = NULL;
+        }
+      } else
+        err = PTR_ERR (dentry);
+
+      if (!err && dentry) {
+          s->s_root->d_op = &xattr_lookup_poison_ops;
+          reiserfs_mark_inode_private (dentry->d_inode);
+          REISERFS_SB(s)->priv_root = dentry;
+      } else if (!(mount_flags & MS_RDONLY)) { /* xattrs are unavailable */
+          /* If we're read-only it just means that the dir hasn't been
+           * created. Not an error -- just no xattrs on the fs. We'll
+           * check again if we go read-write */
+          reiserfs_warning (s, "xattrs/ACLs enabled and couldn't "
+                            "find/create .reiserfs_priv. Failing mount.");
+          err = -EOPNOTSUPP;
+      }
+  }
+
+error:
+   /* This is only nonzero if there was an error initializing the xattr
+    * directory or if there is a condition where we don't support them. */
+    if (err) {
+          clear_bit (REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
+          clear_bit (REISERFS_XATTRS_USER, &(REISERFS_SB(s)->s_mount_opt));
+          clear_bit (REISERFS_POSIXACL, &(REISERFS_SB(s)->s_mount_opt));
+    }
+
+    /* The super_block MS_POSIXACL must mirror the (no)acl mount option. */
+    s->s_flags = s->s_flags & ~MS_POSIXACL;
+    if (reiserfs_posixacl (s))
+	s->s_flags |= MS_POSIXACL;
+
+    return err;
+}
+
+static int
+__reiserfs_permission (struct inode *inode, int mask, struct nameidata *nd,
+                       int need_lock)
+{
+	umode_t			mode = inode->i_mode;
+
+	if (mask & MAY_WRITE) {
+		/*
+		 * Nobody gets write access to a read-only fs.
+		 */
+		if (IS_RDONLY(inode) &&
+		    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
+			return -EROFS;
+
+		/*
+		 * Nobody gets write access to an immutable file.
+		 */
+		if (IS_IMMUTABLE(inode))
+			return -EACCES;
+	}
+
+	/* We don't do permission checks on the internal objects.
+	* Permissions are determined by the "owning" object. */
+        if (is_reiserfs_priv_object (inode))
+		return 0;
+
+	if (current->fsuid == inode->i_uid) {
+		mode >>= 6;
+#ifdef CONFIG_REISERFS_FS_POSIX_ACL
+	} else if (reiserfs_posixacl(inode->i_sb) &&
+                   get_inode_sd_version (inode) != STAT_DATA_V1) {
+                struct posix_acl *acl;
+
+		/* ACL can't contain additional permissions if
+		   the ACL_MASK entry is 0 */
+		if (!(mode & S_IRWXG))
+			goto check_groups;
+
+                if (need_lock) {
+		    reiserfs_read_lock_xattr_i (inode);
+                    reiserfs_read_lock_xattrs (inode->i_sb);
+		}
+                acl = reiserfs_get_acl (inode, ACL_TYPE_ACCESS);
+                if (need_lock) {
+                    reiserfs_read_unlock_xattrs (inode->i_sb);
+		    reiserfs_read_unlock_xattr_i (inode);
+		}
+                if (IS_ERR (acl)) {
+                    if (PTR_ERR (acl) == -ENODATA)
+                        goto check_groups;
+                    return PTR_ERR (acl);
+                }
+
+                if (acl) {
+                    int err = posix_acl_permission (inode, acl, mask);
+                    posix_acl_release (acl);
+                    if (err == -EACCES) {
+                        goto check_capabilities;
+                    }
+                    return err;
+		} else {
+			goto check_groups;
+                }
+#endif
+	} else {
+check_groups:
+		if (in_group_p(inode->i_gid))
+			mode >>= 3;
+	}
+
+	/*
+	 * If the DACs are ok we don't need any capability check.
+	 */
+	if (((mode & mask & (MAY_READ|MAY_WRITE|MAY_EXEC)) == mask))
+		return 0;
+
+check_capabilities:
+	/*
+	 * Read/write DACs are always overridable.
+	 * Executable DACs are overridable if at least one exec bit is set.
+	 */
+	if (!(mask & MAY_EXEC) ||
+	    (inode->i_mode & S_IXUGO) || S_ISDIR(inode->i_mode))
+		if (capable(CAP_DAC_OVERRIDE))
+			return 0;
+
+	/*
+	 * Searching includes executable on directories, else just read.
+	 */
+	if (mask == MAY_READ || (S_ISDIR(inode->i_mode) && !(mask & MAY_WRITE)))
+		if (capable(CAP_DAC_READ_SEARCH))
+			return 0;
+
+	return -EACCES;
+}
+
+int
+reiserfs_permission (struct inode *inode, int mask, struct nameidata *nd)
+{
+    return __reiserfs_permission (inode, mask, nd, 1);
+}
+
+int
+reiserfs_permission_locked (struct inode *inode, int mask, struct nameidata *nd)
+{
+    return __reiserfs_permission (inode, mask, nd, 0);
+}
