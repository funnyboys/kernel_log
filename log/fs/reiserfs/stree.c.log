commit 7eec11d3a784a283f916590e5aa30b855c2ccfd7
Merge: ddaefe8947b4 43e76af85fa7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 31 12:16:36 2020 -0800

    Merge branch 'akpm' (patches from Andrew)
    
    Pull updates from Andrew Morton:
     "Most of -mm and quite a number of other subsystems: hotfixes, scripts,
      ocfs2, misc, lib, binfmt, init, reiserfs, exec, dma-mapping, kcov.
    
      MM is fairly quiet this time.  Holidays, I assume"
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (118 commits)
      kcov: ignore fault-inject and stacktrace
      include/linux/io-mapping.h-mapping: use PHYS_PFN() macro in io_mapping_map_atomic_wc()
      execve: warn if process starts with executable stack
      reiserfs: prevent NULL pointer dereference in reiserfs_insert_item()
      init/main.c: fix misleading "This architecture does not have kernel memory protection" message
      init/main.c: fix quoted value handling in unknown_bootoption
      init/main.c: remove unnecessary repair_env_string in do_initcall_level
      init/main.c: log arguments and environment passed to init
      fs/binfmt_elf.c: coredump: allow process with empty address space to coredump
      fs/binfmt_elf.c: coredump: delete duplicated overflow check
      fs/binfmt_elf.c: coredump: allocate core ELF header on stack
      fs/binfmt_elf.c: make BAD_ADDR() unlikely
      fs/binfmt_elf.c: better codegen around current->mm
      fs/binfmt_elf.c: don't copy ELF header around
      fs/binfmt_elf.c: fix ->start_code calculation
      fs/binfmt_elf.c: smaller code generation around auxv vector fill
      lib/find_bit.c: uninline helper _find_next_bit()
      lib/find_bit.c: join _find_next_bit{_le}
      uapi: rename ext2_swab() to swab() and share globally in swab.h
      lib/scatterlist.c: adjust indentation in __sg_alloc_table
      ...

commit aacee5446a2a1aa35d0a49dab289552578657fb4
Author: Yunfeng Ye <yeyunfeng@huawei.com>
Date:   Thu Jan 30 22:17:26 2020 -0800

    reiserfs: prevent NULL pointer dereference in reiserfs_insert_item()
    
    The variable inode may be NULL in reiserfs_insert_item(), but there is
    no check before accessing the member of inode.
    
    Fix this by adding NULL pointer check before calling reiserfs_debug().
    
    Link: http://lkml.kernel.org/r/79c5135d-ff25-1cc9-4e99-9f572b88cc00@huawei.com
    Signed-off-by: Yunfeng Ye <yeyunfeng@huawei.com>
    Cc: zhengbin <zhengbin13@huawei.com>
    Cc: Hu Shiyuan <hushiyuan@huawei.com>
    Cc: Feilong Lin <linfeilong@huawei.com>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index da9ebe33882b..bb4973aefbb1 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -2246,7 +2246,8 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th,
 	/* also releases the path */
 	unfix_nodes(&s_ins_balance);
 #ifdef REISERQUOTA_DEBUG
-	reiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,
+	if (inode)
+		reiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,
 		       "reiserquota insert_item(): freeing %u id=%u type=%c",
 		       quota_bytes, inode->i_uid, head2type(ih));
 #endif

commit 154a4dcfc95f9dfcb2fda3ddf24c0602060d1120
Author: Alex Shi <alex.shi@linux.alibaba.com>
Date:   Tue Jan 21 18:25:38 2020 +0800

    fs/reiserfs: remove unused macros
    
    these macros are never used from introduced. better to
    remove them.
    
    Link: https://lore.kernel.org/r/1579602338-57079-1-git-send-email-alex.shi@linux.alibaba.com
    Signed-off-by: Alex Shi <alex.shi@linux.alibaba.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Bharath Vedartham <linux.bhar@gmail.com>
    Cc: Hariprasad Kelam <hariprasad.kelam@gmail.com>
    Cc: Jason Yan <yanaijie@huawei.com>
    Cc: zhengbin <zhengbin13@huawei.com>
    Cc: Jia-Ju Bai <baijiaju1990@gmail.com>
    Cc: reiserfs-devel@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index da9ebe33882b..6051e7bbc221 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -918,12 +918,6 @@ int comp_items(const struct item_head *stored_ih, const struct treepath *path)
 	return memcmp(stored_ih, ih, IH_SIZE);
 }
 
-/* unformatted nodes are not logged anymore, ever.  This is safe now */
-#define held_by_others(bh) (atomic_read(&(bh)->b_count) > 1)
-
-/* block can not be forgotten as it is in I/O or held by someone */
-#define block_in_use(bh) (buffer_locked(bh) || (held_by_others(bh)))
-
 /* prepare for delete or cut of direct item */
 static inline int prepare_for_direct_item(struct treepath *path,
 					  struct item_head *le_ih,

commit 66985cb9ee107f2596e9d721252b679249c41858
Author: zhengbin <zhengbin13@huawei.com>
Date:   Wed Sep 25 16:47:01 2019 -0700

    fs/reiserfs/stree.c: remove set but not used variables
    
    Fixes gcc '-Wunused-but-set-variable' warning:
    
    fs/reiserfs/stree.c: In function search_by_key:
    fs/reiserfs/stree.c:596:6: warning: variable right_neighbor_of_leaf_node set but not used [-Wunused-but-set-variable]
    
    Link: http://lkml.kernel.org/r/1566379929-118398-3-git-send-email-zhengbin13@huawei.com
    Signed-off-by: zhengbin <zhengbin13@huawei.com>
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 0037aea97d39..da9ebe33882b 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -593,7 +593,6 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,
 	struct buffer_head *bh;
 	struct path_element *last_element;
 	int node_level, retval;
-	int right_neighbor_of_leaf_node;
 	int fs_gen;
 	struct buffer_head *reada_bh[SEARCH_BY_KEY_READA];
 	b_blocknr_t reada_blocks[SEARCH_BY_KEY_READA];
@@ -614,8 +613,6 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,
 
 	pathrelse(search_path);
 
-	right_neighbor_of_leaf_node = 0;
-
 	/*
 	 * With each iteration of this loop we search through the items in the
 	 * current node, and calculate the next current node(next path element)
@@ -701,7 +698,6 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,
 			 */
 			block_number = SB_ROOT_BLOCK(sb);
 			expected_level = -1;
-			right_neighbor_of_leaf_node = 0;
 
 			/* repeat search from the root */
 			continue;

commit 2f8b544477e627a42e66902e948d87f86554aeca
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 1 07:40:13 2016 -0600

    block,fs: untangle fs.h and blk_types.h
    
    Nothing in fs.h should require blk_types.h to be included.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index a97e352d05d3..0037aea97d39 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -11,6 +11,7 @@
 #include <linux/time.h>
 #include <linux/string.h>
 #include <linux/pagemap.h>
+#include <linux/bio.h>
 #include "reiserfs.h"
 #include <linux/buffer_head.h>
 #include <linux/quotaops.h>

commit 02027d42c3f747945f19111d3da2092ed2148ac8
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Wed Sep 14 07:48:05 2016 -0700

    fs: Replace CURRENT_TIME_SEC with current_time() for inode timestamps
    
    CURRENT_TIME_SEC is not y2038 safe. current_time() will
    be transitioned to use 64 bit time along with vfs in a
    separate patch.
    There is no plan to transistion CURRENT_TIME_SEC to use
    y2038 safe time interfaces.
    
    current_time() will also be extended to use superblock
    range checking parameters when range checking is introduced.
    
    This works because alloc_super() fills in the the s_time_gran
    in super block to NSEC_PER_SEC.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Acked-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 4032d1e87c8f..a97e352d05d3 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1987,8 +1987,8 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 			pathrelse(&s_search_path);
 
 			if (update_timestamps) {
-				inode->i_mtime = CURRENT_TIME_SEC;
-				inode->i_ctime = CURRENT_TIME_SEC;
+				inode->i_mtime = current_time(inode);
+				inode->i_ctime = current_time(inode);
 			}
 			reiserfs_update_sd(th, inode);
 
@@ -2012,8 +2012,8 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 update_and_out:
 	if (update_timestamps) {
 		/* this is truncate, not file closing */
-		inode->i_mtime = CURRENT_TIME_SEC;
-		inode->i_ctime = CURRENT_TIME_SEC;
+		inode->i_mtime = current_time(inode);
+		inode->i_ctime = current_time(inode);
 	}
 	reiserfs_update_sd(th, inode);
 

commit 70246286e94c335b5bea0cbc68a17a96dd620281
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jul 19 11:28:41 2016 +0200

    block: get rid of bio_rw and READA
    
    These two are confusing leftover of the old world order, combining
    values of the REQ_OP_ and REQ_ namespaces.  For callers that don't
    special case we mostly just replace bi_rw with bio_data_dir or
    op_is_write, except for the few cases where a switch over the REQ_OP_
    values makes more sense.  Any check for READA is replaced with an
    explicit check for REQ_RAHEAD.  Also remove the READA alias for
    REQ_RAHEAD.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Mike Christie <mchristi@redhat.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 64b29b592d86..4032d1e87c8f 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -551,7 +551,7 @@ static int search_by_key_reada(struct super_block *s,
 		if (!buffer_uptodate(bh[j])) {
 			if (depth == -1)
 				depth = reiserfs_write_unlock_nested(s);
-			ll_rw_block(REQ_OP_READ, READA, 1, bh + j);
+			ll_rw_block(REQ_OP_READ, REQ_RAHEAD, 1, bh + j);
 		}
 		brelse(bh[j]);
 	}

commit dfec8a14fc9043039e3c04807caf39dc71102816
Author: Mike Christie <mchristi@redhat.com>
Date:   Sun Jun 5 14:31:44 2016 -0500

    fs: have ll_rw_block users pass in op and flags separately
    
    This has ll_rw_block users pass in the operation and flags separately,
    so ll_rw_block can setup the bio op and bi_rw flags on the bio that
    is submitted.
    
    Signed-off-by: Mike Christie <mchristi@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 5feacd689241..64b29b592d86 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -551,7 +551,7 @@ static int search_by_key_reada(struct super_block *s,
 		if (!buffer_uptodate(bh[j])) {
 			if (depth == -1)
 				depth = reiserfs_write_unlock_nested(s);
-			ll_rw_block(READA, 1, bh + j);
+			ll_rw_block(REQ_OP_READ, READA, 1, bh + j);
 		}
 		brelse(bh[j]);
 	}
@@ -660,7 +660,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,
 			if (!buffer_uptodate(bh) && depth == -1)
 				depth = reiserfs_write_unlock_nested(sb);
 
-			ll_rw_block(READ, 1, &bh);
+			ll_rw_block(REQ_OP_READ, 0, 1, &bh);
 			wait_on_buffer(bh);
 
 			if (depth != -1)

commit 09cbfeaf1a5a67bfb3201e0c83c810cecb2efa5a
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Fri Apr 1 15:29:47 2016 +0300

    mm, fs: get rid of PAGE_CACHE_* and page_cache_{get,release} macros
    
    PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} macros were introduced *long* time
    ago with promise that one day it will be possible to implement page
    cache with bigger chunks than PAGE_SIZE.
    
    This promise never materialized.  And unlikely will.
    
    We have many places where PAGE_CACHE_SIZE assumed to be equal to
    PAGE_SIZE.  And it's constant source of confusion on whether
    PAGE_CACHE_* or PAGE_* constant should be used in a particular case,
    especially on the border between fs and mm.
    
    Global switching to PAGE_CACHE_SIZE != PAGE_SIZE would cause to much
    breakage to be doable.
    
    Let's stop pretending that pages in page cache are special.  They are
    not.
    
    The changes are pretty straight-forward:
    
     - <foo> << (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - <foo> >> (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} -> PAGE_{SIZE,SHIFT,MASK,ALIGN};
    
     - page_cache_get() -> get_page();
    
     - page_cache_release() -> put_page();
    
    This patch contains automated changes generated with coccinelle using
    script below.  For some reason, coccinelle doesn't patch header files.
    I've called spatch for them manually.
    
    The only adjustment after coccinelle is revert of changes to
    PAGE_CAHCE_ALIGN definition: we are going to drop it later.
    
    There are few places in the code where coccinelle didn't reach.  I'll
    fix them manually in a separate patch.  Comments and documentation also
    will be addressed with the separate patch.
    
    virtual patch
    
    @@
    expression E;
    @@
    - E << (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    expression E;
    @@
    - E >> (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    @@
    - PAGE_CACHE_SHIFT
    + PAGE_SHIFT
    
    @@
    @@
    - PAGE_CACHE_SIZE
    + PAGE_SIZE
    
    @@
    @@
    - PAGE_CACHE_MASK
    + PAGE_MASK
    
    @@
    expression E;
    @@
    - PAGE_CACHE_ALIGN(E)
    + PAGE_ALIGN(E)
    
    @@
    expression E;
    @@
    - page_cache_get(E)
    + get_page(E)
    
    @@
    expression E;
    @@
    - page_cache_release(E)
    + put_page(E)
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 24cbe013240f..5feacd689241 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1342,7 +1342,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 		 */
 
 		data = kmap_atomic(un_bh->b_page);
-		off = ((le_ih_k_offset(&s_ih) - 1) & (PAGE_CACHE_SIZE - 1));
+		off = ((le_ih_k_offset(&s_ih) - 1) & (PAGE_SIZE - 1));
 		memcpy(data + off,
 		       ih_item_body(PATH_PLAST_BUFFER(path), &s_ih),
 		       ret_value);
@@ -1511,7 +1511,7 @@ static void unmap_buffers(struct page *page, loff_t pos)
 
 	if (page) {
 		if (page_has_buffers(page)) {
-			tail_index = pos & (PAGE_CACHE_SIZE - 1);
+			tail_index = pos & (PAGE_SIZE - 1);
 			cur_index = 0;
 			head = page_buffers(page);
 			bh = head;

commit 53872ed07786714bff3642ee9ee61afd3f4eb749
Author: Fabian Frederick <fabf@skynet.be>
Date:   Fri Aug 8 14:21:10 2014 -0700

    fs/reiserfs: replace not-standard %Lu/%Ld
    
    Fixes checkpatch warnings:
    
    "WARNING: %Ld/%Lu are not-standard C, use %lld/%llu"
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index dd44468edc2b..24cbe013240f 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -2006,7 +2006,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 					    &s_search_path) == POSITION_FOUND);
 
 	RFALSE(file_size > ROUND_UP(new_file_size),
-	       "PAP-5680: truncate did not finish: new_file_size %Ld, current %Ld, oid %d",
+	       "PAP-5680: truncate did not finish: new_file_size %lld, current %lld, oid %d",
 	       new_file_size, file_size, s_item_key.on_disk_key.k_objectid);
 
 update_and_out:

commit afd54c6881a51fe9cef843b36d289ae74a8f14bb
Author: Fabian Frederick <fabf@skynet.be>
Date:   Sat May 3 22:33:24 2014 +0200

    reiserfs: remove obsolete __constant_cpu_to_le32
    
    __constant_cpu_to_le32 converted to cpu_to_le32
    
    Cc: reiserfs-devel@vger.kernel.org
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index dfb02febf814..dd44468edc2b 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -197,10 +197,10 @@ const struct reiserfs_key MIN_KEY = { 0, 0, {{0, 0},} };
 
 /* Maximal possible key. It is never in the tree. */
 static const struct reiserfs_key MAX_KEY = {
-	__constant_cpu_to_le32(0xffffffff),
-	__constant_cpu_to_le32(0xffffffff),
-	{{__constant_cpu_to_le32(0xffffffff),
-	  __constant_cpu_to_le32(0xffffffff)},}
+	cpu_to_le32(0xffffffff),
+	cpu_to_le32(0xffffffff),
+	{{cpu_to_le32(0xffffffff),
+	  cpu_to_le32(0xffffffff)},}
 };
 
 /*

commit a228bf8f0a3e5f1406edbd61f7400e87e23af5f7
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:42 2014 -0400

    reiserfs: cleanup, remove unnecessary parens
    
    The reiserfs code is littered with extra parens in places where the authors
    may not have been certain about precedence of & vs ->. This patch cleans them
    out.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index ebfebc5b7dd6..dfb02febf814 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -748,7 +748,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,
 				      (node_level ==
 				       DISK_LEAF_NODE_LEVEL) ? IH_SIZE :
 				      KEY_SIZE,
-				      &(last_element->pe_position));
+				      &last_element->pe_position);
 		if (node_level == stop_level) {
 			return retval;
 		}
@@ -871,9 +871,8 @@ int search_for_position_by_key(struct super_block *sb,
 			   --PATH_LAST_POSITION(search_path));
 	blk_size = sb->s_blocksize;
 
-	if (comp_short_keys(&(p_le_ih->ih_key), p_cpu_key)) {
+	if (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))
 		return FILE_NOT_FOUND;
-	}
 
 	/* FIXME: quite ugly this far */
 
@@ -2088,7 +2087,7 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th,
 	reiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,
 		       "reiserquota paste_into_item(): allocating %u id=%u type=%c",
 		       pasted_size, inode->i_uid,
-		       key2type(&(key->on_disk_key)));
+		       key2type(&key->on_disk_key));
 #endif
 
 	depth = reiserfs_write_unlock_nested(sb);
@@ -2150,7 +2149,7 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th,
 	reiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,
 		       "reiserquota paste_into_item(): freeing %u id=%u type=%c",
 		       pasted_size, inode->i_uid,
-		       key2type(&(key->on_disk_key)));
+		       key2type(&key->on_disk_key));
 #endif
 	depth = reiserfs_write_unlock_nested(sb);
 	dquot_free_space_nodirty(inode, pasted_size);

commit cf776a7a4dafa330dd371a6a301ddf9e38747d93
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:41 2014 -0400

    reiserfs: cleanup, remove leading whitespace from labels
    
    This patch moves reiserfs closer to adhering to the style rules by
    removing leading whitespace from labels.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 6d697d7328a0..ebfebc5b7dd6 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -668,7 +668,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,
 			if (!buffer_uptodate(bh))
 				goto io_error;
 		} else {
-		      io_error:
+io_error:
 			search_path->path_length--;
 			pathrelse(search_path);
 			return IO_ERROR;
@@ -2010,7 +2010,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 	       "PAP-5680: truncate did not finish: new_file_size %Ld, current %Ld, oid %d",
 	       new_file_size, file_size, s_item_key.on_disk_key.k_objectid);
 
-      update_and_out:
+update_and_out:
 	if (update_timestamps) {
 		/* this is truncate, not file closing */
 		inode->i_mtime = CURRENT_TIME_SEC;
@@ -2018,7 +2018,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 	}
 	reiserfs_update_sd(th, inode);
 
-      out:
+out:
 	pathrelse(&s_search_path);
 	return err;
 }
@@ -2112,7 +2112,7 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th,
 	while ((retval =
 		fix_nodes(M_PASTE, &s_paste_balance, NULL,
 			  body)) == REPEAT_SEARCH) {
-	      search_again:
+search_again:
 		/* file system changed while we were in the fix_nodes */
 		PROC_INFO_INC(th->t_super, paste_into_item_restarted);
 		retval =
@@ -2143,7 +2143,7 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th,
 		return 0;
 	}
 	retval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;
-      error_out:
+error_out:
 	/* this also releases the path */
 	unfix_nodes(&s_paste_balance);
 #ifdef REISERQUOTA_DEBUG
@@ -2222,7 +2222,7 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th,
 	while ((retval =
 		fix_nodes(M_INSERT, &s_ins_balance, ih,
 			  body)) == REPEAT_SEARCH) {
-	      search_again:
+search_again:
 		/* file system changed while we were in the fix_nodes */
 		PROC_INFO_INC(th->t_super, insert_item_restarted);
 		retval = search_item(th->t_super, key, path);
@@ -2246,7 +2246,7 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th,
 	}
 
 	retval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;
-      error_out:
+error_out:
 	/* also releases the path */
 	unfix_nodes(&s_ins_balance);
 #ifdef REISERQUOTA_DEBUG

commit 09f1b80ba8c967b6e17c0516e95578d5da18115f
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:39 2014 -0400

    reiserfs: cleanup, remove sb argument from journal_mark_dirty
    
    journal_mark_dirty doesn't need a separate sb argument; It's provided
    by the transaction handle.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 28c593a75c7a..6d697d7328a0 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1101,7 +1101,7 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th,
 		    if (block != 0) {
 			reiserfs_prepare_for_journal(sb, bh, 1);
 			put_block_num(unfm, 0, 0);
-			journal_mark_dirty(th, sb, bh);
+			journal_mark_dirty(th, bh);
 			reiserfs_free_block(th, inode, block, 1);
 		    }
 

commit 58d854265c4c7d9792ecb5aa5ef67ba79b1a4c12
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:38 2014 -0400

    reiserfs: cleanup, remove sb argument from journal_end
    
    journal_end doesn't need a separate sb argument; it's provided by the
    transaction handle.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 5bc9825114ff..28c593a75c7a 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1993,7 +1993,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 			}
 			reiserfs_update_sd(th, inode);
 
-			err = journal_end(th, inode->i_sb);
+			err = journal_end(th);
 			if (err)
 				goto out;
 			err = journal_begin(th, inode->i_sb,

commit 706a5323384d9ae973a72005b73987d39e009019
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:37 2014 -0400

    reiserfs: cleanup, remove nblocks argument from journal_end
    
    journal_end takes a block count argument but doesn't actually use it
    for anything. We can remove it.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index aa86757e48f8..5bc9825114ff 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1985,7 +1985,6 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 		 */
 		if (journal_transaction_should_end(th, 0) ||
 		    reiserfs_transaction_free_space(th) <= JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD) {
-			int orig_len_alloc = th->t_blocks_allocated;
 			pathrelse(&s_search_path);
 
 			if (update_timestamps) {
@@ -1994,7 +1993,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 			}
 			reiserfs_update_sd(th, inode);
 
-			err = journal_end(th, inode->i_sb, orig_len_alloc);
+			err = journal_end(th, inode->i_sb);
 			if (err)
 				goto out;
 			err = journal_begin(th, inode->i_sb,

commit 098297b27d23ad9d0fc302e3417474d9342c6c14
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:36 2014 -0400

    reiserfs: cleanup, reformat comments to normal kernel style
    
    This patch reformats comments in the reiserfs code to fit in 80 columns and
    to follow the style rules.
    
    There is no functional change but it helps make my eyes bleed less.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 40b3e77c8ff3..aa86757e48f8 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -8,46 +8,6 @@
  *  Pereslavl-Zalessky Russia
  */
 
-/*
- *  This file contains functions dealing with S+tree
- *
- * B_IS_IN_TREE
- * copy_item_head
- * comp_short_keys
- * comp_keys
- * comp_short_le_keys
- * le_key2cpu_key
- * comp_le_keys
- * bin_search
- * get_lkey
- * get_rkey
- * key_in_buffer
- * decrement_bcount
- * reiserfs_check_path
- * pathrelse_and_restore
- * pathrelse
- * search_by_key_reada
- * search_by_key
- * search_for_position_by_key
- * comp_items
- * prepare_for_direct_item
- * prepare_for_direntry_item
- * prepare_for_delete_or_cut
- * calc_deleted_bytes_number
- * init_tb_struct
- * padd_item
- * reiserfs_delete_item
- * reiserfs_delete_solid_item
- * reiserfs_delete_object
- * maybe_indirect_to_direct
- * indirect_to_direct_roll_back
- * reiserfs_cut_from_item
- * truncate_directory
- * reiserfs_do_truncate
- * reiserfs_paste_into_item
- * reiserfs_insert_item
- */
-
 #include <linux/time.h>
 #include <linux/string.h>
 #include <linux/pagemap.h>
@@ -65,21 +25,21 @@ inline int B_IS_IN_TREE(const struct buffer_head *bh)
 	return (B_LEVEL(bh) != FREE_LEVEL);
 }
 
-//
-// to gets item head in le form
-//
+/* to get item head in le form */
 inline void copy_item_head(struct item_head *to,
 			   const struct item_head *from)
 {
 	memcpy(to, from, IH_SIZE);
 }
 
-/* k1 is pointer to on-disk structure which is stored in little-endian
-   form. k2 is pointer to cpu variable. For key of items of the same
-   object this returns 0.
-   Returns: -1 if key1 < key2
-   0 if key1 == key2
-   1 if key1 > key2 */
+/*
+ * k1 is pointer to on-disk structure which is stored in little-endian
+ * form. k2 is pointer to cpu variable. For key of items of the same
+ * object this returns 0.
+ * Returns: -1 if key1 < key2
+ * 0 if key1 == key2
+ * 1 if key1 > key2
+ */
 inline int comp_short_keys(const struct reiserfs_key *le_key,
 			   const struct cpu_key *cpu_key)
 {
@@ -97,11 +57,13 @@ inline int comp_short_keys(const struct reiserfs_key *le_key,
 	return 0;
 }
 
-/* k1 is pointer to on-disk structure which is stored in little-endian
-   form. k2 is pointer to cpu variable.
-   Compare keys using all 4 key fields.
-   Returns: -1 if key1 < key2 0
-   if key1 = key2 1 if key1 > key2 */
+/*
+ * k1 is pointer to on-disk structure which is stored in little-endian
+ * form. k2 is pointer to cpu variable.
+ * Compare keys using all 4 key fields.
+ * Returns: -1 if key1 < key2 0
+ * if key1 = key2 1 if key1 > key2
+ */
 static inline int comp_keys(const struct reiserfs_key *le_key,
 			    const struct cpu_key *cpu_key)
 {
@@ -155,15 +117,17 @@ inline void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from)
 	to->on_disk_key.k_dir_id = le32_to_cpu(from->k_dir_id);
 	to->on_disk_key.k_objectid = le32_to_cpu(from->k_objectid);
 
-	// find out version of the key
+	/* find out version of the key */
 	version = le_key_version(from);
 	to->version = version;
 	to->on_disk_key.k_offset = le_key_k_offset(version, from);
 	to->on_disk_key.k_type = le_key_k_type(version, from);
 }
 
-// this does not say which one is bigger, it only returns 1 if keys
-// are not equal, 0 otherwise
+/*
+ * this does not say which one is bigger, it only returns 1 if keys
+ * are not equal, 0 otherwise
+ */
 inline int comp_le_keys(const struct reiserfs_key *k1,
 			const struct reiserfs_key *k2)
 {
@@ -177,24 +141,27 @@ inline int comp_le_keys(const struct reiserfs_key *k1,
  *        *pos = number of the searched element if found, else the        *
  *        number of the first element that is larger than key.            *
  **************************************************************************/
-/* For those not familiar with binary search: lbound is the leftmost item that it
- could be, rbound the rightmost item that it could be.  We examine the item
- halfway between lbound and rbound, and that tells us either that we can increase
- lbound, or decrease rbound, or that we have found it, or if lbound <= rbound that
- there are no possible items, and we have not found it. With each examination we
- cut the number of possible items it could be by one more than half rounded down,
- or we find it. */
+/*
+ * For those not familiar with binary search: lbound is the leftmost item
+ * that it could be, rbound the rightmost item that it could be.  We examine
+ * the item halfway between lbound and rbound, and that tells us either
+ * that we can increase lbound, or decrease rbound, or that we have found it,
+ * or if lbound <= rbound that there are no possible items, and we have not
+ * found it. With each examination we cut the number of possible items it
+ * could be by one more than half rounded down, or we find it.
+ */
 static inline int bin_search(const void *key,	/* Key to search for. */
 			     const void *base,	/* First item in the array. */
 			     int num,	/* Number of items in the array. */
-			     int width,	/* Item size in the array.
-					   searched. Lest the reader be
-					   confused, note that this is crafted
-					   as a general function, and when it
-					   is applied specifically to the array
-					   of item headers in a node, width
-					   is actually the item header size not
-					   the item size. */
+			     /*
+			      * Item size in the array.  searched. Lest the
+			      * reader be confused, note that this is crafted
+			      * as a general function, and when it is applied
+			      * specifically to the array of item headers in a
+			      * node, width is actually the item header size
+			      * not the item size.
+			      */
+			     int width,
 			     int *pos /* Number of the searched for element. */
     )
 {
@@ -216,8 +183,10 @@ static inline int bin_search(const void *key,	/* Key to search for. */
 			return ITEM_FOUND;	/* Key found in the array.  */
 		}
 
-	/* bin_search did not find given key, it returns position of key,
-	   that is minimal and greater than the given one. */
+	/*
+	 * bin_search did not find given key, it returns position of key,
+	 * that is minimal and greater than the given one.
+	 */
 	*pos = lbound;
 	return ITEM_NOT_FOUND;
 }
@@ -234,10 +203,14 @@ static const struct reiserfs_key MAX_KEY = {
 	  __constant_cpu_to_le32(0xffffffff)},}
 };
 
-/* Get delimiting key of the buffer by looking for it in the buffers in the path, starting from the bottom
-   of the path, and going upwards.  We must check the path's validity at each step.  If the key is not in
-   the path, there is no delimiting key in the tree (buffer is first or last buffer in tree), and in this
-   case we return a special key, either MIN_KEY or MAX_KEY. */
+/*
+ * Get delimiting key of the buffer by looking for it in the buffers in the
+ * path, starting from the bottom of the path, and going upwards.  We must
+ * check the path's validity at each step.  If the key is not in the path,
+ * there is no delimiting key in the tree (buffer is first or last buffer
+ * in tree), and in this case we return a special key, either MIN_KEY or
+ * MAX_KEY.
+ */
 static inline const struct reiserfs_key *get_lkey(const struct treepath *chk_path,
 						  const struct super_block *sb)
 {
@@ -270,7 +243,10 @@ static inline const struct reiserfs_key *get_lkey(const struct treepath *chk_pat
 		    PATH_OFFSET_PBUFFER(chk_path,
 					path_offset + 1)->b_blocknr)
 			return &MAX_KEY;
-		/* Return delimiting key if position in the parent is not equal to zero. */
+		/*
+		 * Return delimiting key if position in the parent
+		 * is not equal to zero.
+		 */
 		if (position)
 			return internal_key(parent, position - 1);
 	}
@@ -308,15 +284,23 @@ inline const struct reiserfs_key *get_rkey(const struct treepath *chk_path,
 					  path_offset)) >
 		    B_NR_ITEMS(parent))
 			return &MIN_KEY;
-		/* Check whether parent at the path really points to the child. */
+		/*
+		 * Check whether parent at the path really points
+		 * to the child.
+		 */
 		if (B_N_CHILD_NUM(parent, position) !=
 		    PATH_OFFSET_PBUFFER(chk_path,
 					path_offset + 1)->b_blocknr)
 			return &MIN_KEY;
-		/* Return delimiting key if position in the parent is not the last one. */
+
+		/*
+		 * Return delimiting key if position in the parent
+		 * is not the last one.
+		 */
 		if (position != B_NR_ITEMS(parent))
 			return internal_key(parent, position);
 	}
+
 	/* Return MAX_KEY if we are in the root of the buffer tree. */
 	if (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->
 	    b_blocknr == SB_ROOT_BLOCK(sb))
@@ -324,13 +308,20 @@ inline const struct reiserfs_key *get_rkey(const struct treepath *chk_path,
 	return &MIN_KEY;
 }
 
-/* Check whether a key is contained in the tree rooted from a buffer at a path. */
-/* This works by looking at the left and right delimiting keys for the buffer in the last path_element in
-   the path.  These delimiting keys are stored at least one level above that buffer in the tree. If the
-   buffer is the first or last node in the tree order then one of the delimiting keys may be absent, and in
-   this case get_lkey and get_rkey return a special key which is MIN_KEY or MAX_KEY. */
-static inline int key_in_buffer(struct treepath *chk_path,	/* Path which should be checked.  */
-				const struct cpu_key *key,	/* Key which should be checked.   */
+/*
+ * Check whether a key is contained in the tree rooted from a buffer at a path.
+ * This works by looking at the left and right delimiting keys for the buffer
+ * in the last path_element in the path.  These delimiting keys are stored
+ * at least one level above that buffer in the tree. If the buffer is the
+ * first or last node in the tree order then one of the delimiting keys may
+ * be absent, and in this case get_lkey and get_rkey return a special key
+ * which is MIN_KEY or MAX_KEY.
+ */
+static inline int key_in_buffer(
+				/* Path which should be checked. */
+				struct treepath *chk_path,
+				/* Key which should be checked. */
+				const struct cpu_key *key,
 				struct super_block *sb
     )
 {
@@ -359,9 +350,11 @@ int reiserfs_check_path(struct treepath *p)
 	return 0;
 }
 
-/* Drop the reference to each buffer in a path and restore
+/*
+ * Drop the reference to each buffer in a path and restore
  * dirty bits clean when preparing the buffer for the log.
- * This version should only be called from fix_nodes() */
+ * This version should only be called from fix_nodes()
+ */
 void pathrelse_and_restore(struct super_block *sb,
 			   struct treepath *search_path)
 {
@@ -418,14 +411,17 @@ static int is_leaf(char *buf, int blocksize, struct buffer_head *bh)
 	}
 	ih = (struct item_head *)(buf + BLKH_SIZE) + nr - 1;
 	used_space = BLKH_SIZE + IH_SIZE * nr + (blocksize - ih_location(ih));
+
+	/* free space does not match to calculated amount of use space */
 	if (used_space != blocksize - blkh_free_space(blkh)) {
-		/* free space does not match to calculated amount of use space */
 		reiserfs_warning(NULL, "reiserfs-5082",
 				 "free space seems wrong: %z", bh);
 		return 0;
 	}
-	// FIXME: it is_leaf will hit performance too much - we may have
-	// return 1 here
+	/*
+	 * FIXME: it is_leaf will hit performance too much - we may have
+	 * return 1 here
+	 */
 
 	/* check tables of item heads */
 	ih = (struct item_head *)(buf + BLKH_SIZE);
@@ -460,7 +456,7 @@ static int is_leaf(char *buf, int blocksize, struct buffer_head *bh)
 		prev_location = ih_location(ih);
 	}
 
-	// one may imagine much more checks
+	/* one may imagine many more checks */
 	return 1;
 }
 
@@ -481,8 +477,8 @@ static int is_internal(char *buf, int blocksize, struct buffer_head *bh)
 	}
 
 	nr = blkh_nr_item(blkh);
+	/* for internal which is not root we might check min number of keys */
 	if (nr > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE)) {
-		/* for internal which is not root we might check min number of keys */
 		reiserfs_warning(NULL, "reiserfs-5088",
 				 "number of key seems wrong: %z", bh);
 		return 0;
@@ -494,12 +490,15 @@ static int is_internal(char *buf, int blocksize, struct buffer_head *bh)
 				 "free space seems wrong: %z", bh);
 		return 0;
 	}
-	// one may imagine much more checks
+
+	/* one may imagine many more checks */
 	return 1;
 }
 
-// make sure that bh contains formatted node of reiserfs tree of
-// 'level'-th level
+/*
+ * make sure that bh contains formatted node of reiserfs tree of
+ * 'level'-th level
+ */
 static int is_tree_node(struct buffer_head *bh, int level)
 {
 	if (B_LEVEL(bh) != level) {
@@ -546,7 +545,8 @@ static int search_by_key_reada(struct super_block *s,
 	for (j = 0; j < i; j++) {
 		/*
 		 * note, this needs attention if we are getting rid of the BKL
-		 * you have to make sure the prepared bit isn't set on this buffer
+		 * you have to make sure the prepared bit isn't set on this
+		 * buffer
 		 */
 		if (!buffer_uptodate(bh[j])) {
 			if (depth == -1)
@@ -558,39 +558,34 @@ static int search_by_key_reada(struct super_block *s,
 	return depth;
 }
 
-/**************************************************************************
- * Algorithm   SearchByKey                                                *
- *             look for item in the Disk S+Tree by its key                *
- * Input:  sb   -  super block                                            *
- *         key  - pointer to the key to search                            *
- * Output: ITEM_FOUND, ITEM_NOT_FOUND or IO_ERROR                         *
- *         search_path - path from the root to the needed leaf            *
- **************************************************************************/
-
-/* This function fills up the path from the root to the leaf as it
-   descends the tree looking for the key.  It uses reiserfs_bread to
-   try to find buffers in the cache given their block number.  If it
-   does not find them in the cache it reads them from disk.  For each
-   node search_by_key finds using reiserfs_bread it then uses
-   bin_search to look through that node.  bin_search will find the
-   position of the block_number of the next node if it is looking
-   through an internal node.  If it is looking through a leaf node
-   bin_search will find the position of the item which has key either
-   equal to given key, or which is the maximal key less than the given
-   key.  search_by_key returns a path that must be checked for the
-   correctness of the top of the path but need not be checked for the
-   correctness of the bottom of the path */
-/* The function is NOT SCHEDULE-SAFE! */
-int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to search. */
-		  struct treepath *search_path,/* This structure was
-						   allocated and initialized
-						   by the calling
-						   function. It is filled up
-						   by this function.  */
-		  int stop_level	/* How far down the tree to search. To
-					   stop at leaf level - set to
-					   DISK_LEAF_NODE_LEVEL */
-    )
+/*
+ * This function fills up the path from the root to the leaf as it
+ * descends the tree looking for the key.  It uses reiserfs_bread to
+ * try to find buffers in the cache given their block number.  If it
+ * does not find them in the cache it reads them from disk.  For each
+ * node search_by_key finds using reiserfs_bread it then uses
+ * bin_search to look through that node.  bin_search will find the
+ * position of the block_number of the next node if it is looking
+ * through an internal node.  If it is looking through a leaf node
+ * bin_search will find the position of the item which has key either
+ * equal to given key, or which is the maximal key less than the given
+ * key.  search_by_key returns a path that must be checked for the
+ * correctness of the top of the path but need not be checked for the
+ * correctness of the bottom of the path
+ */
+/*
+ * search_by_key - search for key (and item) in stree
+ * @sb: superblock
+ * @key: pointer to key to search for
+ * @search_path: Allocated and initialized struct treepath; Returned filled
+ *		 on success.
+ * @stop_level: How far down the tree to search, Use DISK_LEAF_NODE_LEVEL to
+ *		stop at leaf level.
+ *
+ * The function is NOT SCHEDULE-SAFE!
+ */
+int search_by_key(struct super_block *sb, const struct cpu_key *key,
+		  struct treepath *search_path, int stop_level)
 {
 	b_blocknr_t block_number;
 	int expected_level;
@@ -609,17 +604,22 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 
 	PROC_INFO_INC(sb, search_by_key);
 
-	/* As we add each node to a path we increase its count.  This means that
-	   we must be careful to release all nodes in a path before we either
-	   discard the path struct or re-use the path struct, as we do here. */
+	/*
+	 * As we add each node to a path we increase its count.  This means
+	 * that we must be careful to release all nodes in a path before we
+	 * either discard the path struct or re-use the path struct, as we
+	 * do here.
+	 */
 
 	pathrelse(search_path);
 
 	right_neighbor_of_leaf_node = 0;
 
-	/* With each iteration of this loop we search through the items in the
-	   current node, and calculate the next current node(next path element)
-	   for the next iteration of this loop.. */
+	/*
+	 * With each iteration of this loop we search through the items in the
+	 * current node, and calculate the next current node(next path element)
+	 * for the next iteration of this loop..
+	 */
 	block_number = SB_ROOT_BLOCK(sb);
 	expected_level = -1;
 	while (1) {
@@ -639,8 +639,10 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 					 ++search_path->path_length);
 		fs_gen = get_generation(sb);
 
-		/* Read the next tree node, and set the last element in the path to
-		   have a pointer to it. */
+		/*
+		 * Read the next tree node, and set the last element
+		 * in the path to have a pointer to it.
+		 */
 		if ((bh = last_element->pe_buffer =
 		     sb_getblk(sb, block_number))) {
 
@@ -676,9 +678,12 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 			expected_level = SB_TREE_HEIGHT(sb);
 		expected_level--;
 
-		/* It is possible that schedule occurred. We must check whether the key
-		   to search is still in the tree rooted from the current buffer. If
-		   not then repeat search from the root. */
+		/*
+		 * It is possible that schedule occurred. We must check
+		 * whether the key to search is still in the tree rooted
+		 * from the current buffer. If not then repeat search
+		 * from the root.
+		 */
 		if (fs_changed(fs_gen, sb) &&
 		    (!B_IS_IN_TREE(bh) ||
 		     B_LEVEL(bh) != expected_level ||
@@ -689,8 +694,10 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 				      sbk_restarted[expected_level - 1]);
 			pathrelse(search_path);
 
-			/* Get the root block number so that we can repeat the search
-			   starting from the root. */
+			/*
+			 * Get the root block number so that we can
+			 * repeat the search starting from the root.
+			 */
 			block_number = SB_ROOT_BLOCK(sb);
 			expected_level = -1;
 			right_neighbor_of_leaf_node = 0;
@@ -699,9 +706,11 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 			continue;
 		}
 
-		/* only check that the key is in the buffer if key is not
-		   equal to the MAX_KEY. Latter case is only possible in
-		   "finish_unfinished()" processing during mount. */
+		/*
+		 * only check that the key is in the buffer if key is not
+		 * equal to the MAX_KEY. Latter case is only possible in
+		 * "finish_unfinished()" processing during mount.
+		 */
 		RFALSE(comp_keys(&MAX_KEY, key) &&
 		       !key_in_buffer(search_path, key, sb),
 		       "PAP-5130: key is not in the buffer");
@@ -713,8 +722,10 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 		}
 #endif
 
-		// make sure, that the node contents look like a node of
-		// certain level
+		/*
+		 * make sure, that the node contents look like a node of
+		 * certain level
+		 */
 		if (!is_tree_node(bh, expected_level)) {
 			reiserfs_error(sb, "vs-5150",
 				       "invalid format found in block %ld. "
@@ -743,21 +754,31 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 		}
 
 		/* we are not in the stop level */
+		/*
+		 * item has been found, so we choose the pointer which
+		 * is to the right of the found one
+		 */
 		if (retval == ITEM_FOUND)
-			/* item has been found, so we choose the pointer which is to the right of the found one */
 			last_element->pe_position++;
 
-		/* if item was not found we choose the position which is to
-		   the left of the found item. This requires no code,
-		   bin_search did it already. */
+		/*
+		 * if item was not found we choose the position which is to
+		 * the left of the found item. This requires no code,
+		 * bin_search did it already.
+		 */
 
-		/* So we have chosen a position in the current node which is
-		   an internal node.  Now we calculate child block number by
-		   position in the node. */
+		/*
+		 * So we have chosen a position in the current node which is
+		 * an internal node.  Now we calculate child block number by
+		 * position in the node.
+		 */
 		block_number =
 		    B_N_CHILD_NUM(bh, last_element->pe_position);
 
-		/* if we are going to read leaf nodes, try for read ahead as well */
+		/*
+		 * if we are going to read leaf nodes, try for read
+		 * ahead as well
+		 */
 		if ((search_path->reada & PATH_READA) &&
 		    node_level == DISK_LEAF_NODE_LEVEL + 1) {
 			int pos = last_element->pe_position;
@@ -789,26 +810,28 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 	}
 }
 
-/* Form the path to an item and position in this item which contains
-   file byte defined by key. If there is no such item
-   corresponding to the key, we point the path to the item with
-   maximal key less than key, and *pos_in_item is set to one
-   past the last entry/byte in the item.  If searching for entry in a
-   directory item, and it is not found, *pos_in_item is set to one
-   entry more than the entry with maximal key which is less than the
-   sought key.
-
-   Note that if there is no entry in this same node which is one more,
-   then we point to an imaginary entry.  for direct items, the
-   position is in units of bytes, for indirect items the position is
-   in units of blocknr entries, for directory items the position is in
-   units of directory entries.  */
-
+/*
+ * Form the path to an item and position in this item which contains
+ * file byte defined by key. If there is no such item
+ * corresponding to the key, we point the path to the item with
+ * maximal key less than key, and *pos_in_item is set to one
+ * past the last entry/byte in the item.  If searching for entry in a
+ * directory item, and it is not found, *pos_in_item is set to one
+ * entry more than the entry with maximal key which is less than the
+ * sought key.
+ *
+ * Note that if there is no entry in this same node which is one more,
+ * then we point to an imaginary entry.  for direct items, the
+ * position is in units of bytes, for indirect items the position is
+ * in units of blocknr entries, for directory items the position is in
+ * units of directory entries.
+ */
 /* The function is NOT SCHEDULE-SAFE! */
-int search_for_position_by_key(struct super_block *sb,	/* Pointer to the super block.          */
-			       const struct cpu_key *p_cpu_key,	/* Key to search (cpu variable)         */
-			       struct treepath *search_path	/* Filled up by this function.          */
-    )
+int search_for_position_by_key(struct super_block *sb,
+			       /* Key to search (cpu variable) */
+			       const struct cpu_key *p_cpu_key,
+			       /* Filled up by this function. */
+			       struct treepath *search_path)
 {
 	struct item_head *p_le_ih;	/* pointer to on-disk structure */
 	int blk_size;
@@ -851,7 +874,8 @@ int search_for_position_by_key(struct super_block *sb,	/* Pointer to the super b
 	if (comp_short_keys(&(p_le_ih->ih_key), p_cpu_key)) {
 		return FILE_NOT_FOUND;
 	}
-	// FIXME: quite ugly this far
+
+	/* FIXME: quite ugly this far */
 
 	item_offset = le_ih_k_offset(p_le_ih);
 	offset = cpu_key_k_offset(p_cpu_key);
@@ -866,8 +890,10 @@ int search_for_position_by_key(struct super_block *sb,	/* Pointer to the super b
 		return POSITION_FOUND;
 	}
 
-	/* Needed byte is not contained in the item pointed to by the
-	   path. Set pos_in_item out of the item. */
+	/*
+	 * Needed byte is not contained in the item pointed to by the
+	 * path. Set pos_in_item out of the item.
+	 */
 	if (is_indirect_le_ih(p_le_ih))
 		pos_in_item(search_path) =
 		    ih_item_len(p_le_ih) / UNFM_P_SIZE;
@@ -896,15 +922,13 @@ int comp_items(const struct item_head *stored_ih, const struct treepath *path)
 	return memcmp(stored_ih, ih, IH_SIZE);
 }
 
-/* unformatted nodes are not logged anymore, ever.  This is safe
-** now
-*/
+/* unformatted nodes are not logged anymore, ever.  This is safe now */
 #define held_by_others(bh) (atomic_read(&(bh)->b_count) > 1)
 
-// block can not be forgotten as it is in I/O or held by someone
+/* block can not be forgotten as it is in I/O or held by someone */
 #define block_in_use(bh) (buffer_locked(bh) || (held_by_others(bh)))
 
-// prepare for delete or cut of direct item
+/* prepare for delete or cut of direct item */
 static inline int prepare_for_direct_item(struct treepath *path,
 					  struct item_head *le_ih,
 					  struct inode *inode,
@@ -917,9 +941,8 @@ static inline int prepare_for_direct_item(struct treepath *path,
 		*cut_size = -(IH_SIZE + ih_item_len(le_ih));
 		return M_DELETE;
 	}
-	// new file gets truncated
+	/* new file gets truncated */
 	if (get_inode_item_key_version(inode) == KEY_FORMAT_3_6) {
-		//
 		round_len = ROUND_UP(new_file_length);
 		/* this was new_file_length < le_ih ... */
 		if (round_len < le_ih_k_offset(le_ih)) {
@@ -933,12 +956,13 @@ static inline int prepare_for_direct_item(struct treepath *path,
 		return M_CUT;	/* Cut from this item. */
 	}
 
-	// old file: items may have any length
+	/* old file: items may have any length */
 
 	if (new_file_length < le_ih_k_offset(le_ih)) {
 		*cut_size = -(IH_SIZE + ih_item_len(le_ih));
 		return M_DELETE;	/* Delete this item. */
 	}
+
 	/* Calculate first position and size for cutting from item. */
 	*cut_size = -(ih_item_len(le_ih) -
 		      (pos_in_item(path) =
@@ -957,12 +981,15 @@ static inline int prepare_for_direntry_item(struct treepath *path,
 		RFALSE(ih_entry_count(le_ih) != 2,
 		       "PAP-5220: incorrect empty directory item (%h)", le_ih);
 		*cut_size = -(IH_SIZE + ih_item_len(le_ih));
-		return M_DELETE;	/* Delete the directory item containing "." and ".." entry. */
+		/* Delete the directory item containing "." and ".." entry. */
+		return M_DELETE;
 	}
 
 	if (ih_entry_count(le_ih) == 1) {
-		/* Delete the directory item such as there is one record only
-		   in this item */
+		/*
+		 * Delete the directory item such as there is one record only
+		 * in this item
+		 */
 		*cut_size = -(IH_SIZE + ih_item_len(le_ih));
 		return M_DELETE;
 	}
@@ -976,14 +1003,30 @@ static inline int prepare_for_direntry_item(struct treepath *path,
 
 #define JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD (2 * JOURNAL_PER_BALANCE_CNT + 1)
 
-/*  If the path points to a directory or direct item, calculate mode and the size cut, for balance.
-    If the path points to an indirect item, remove some number of its unformatted nodes.
-    In case of file truncate calculate whether this item must be deleted/truncated or last
-    unformatted node of this item will be converted to a direct item.
-    This function returns a determination of what balance mode the calling function should employ. */
-static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, struct inode *inode, struct treepath *path, const struct cpu_key *item_key, int *removed,	/* Number of unformatted nodes which were removed
-																						   from end of the file. */
-				      int *cut_size, unsigned long long new_file_length	/* MAX_KEY_OFFSET in case of delete. */
+/*
+ * If the path points to a directory or direct item, calculate mode
+ * and the size cut, for balance.
+ * If the path points to an indirect item, remove some number of its
+ * unformatted nodes.
+ * In case of file truncate calculate whether this item must be
+ * deleted/truncated or last unformatted node of this item will be
+ * converted to a direct item.
+ * This function returns a determination of what balance mode the
+ * calling function should employ.
+ */
+static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th,
+				      struct inode *inode,
+				      struct treepath *path,
+				      const struct cpu_key *item_key,
+				      /*
+				       * Number of unformatted nodes
+				       * which were removed from end
+				       * of the file.
+				       */
+				      int *removed,
+				      int *cut_size,
+				      /* MAX_KEY_OFFSET in case of delete. */
+				      unsigned long long new_file_length
     )
 {
 	struct super_block *sb = inode->i_sb;
@@ -1023,8 +1066,10 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 	    int pos = 0;
 
 	    if ( new_file_length == max_reiserfs_offset (inode) ) {
-		/* prepare_for_delete_or_cut() is called by
-		 * reiserfs_delete_item() */
+		/*
+		 * prepare_for_delete_or_cut() is called by
+		 * reiserfs_delete_item()
+		 */
 		new_file_length = 0;
 		delete = 1;
 	    }
@@ -1040,9 +1085,12 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 		    __le32 *unfm;
 		    __u32 block;
 
-		    /* Each unformatted block deletion may involve one additional
-		     * bitmap block into the transaction, thereby the initial
-		     * journal space reservation might not be enough. */
+		    /*
+		     * Each unformatted block deletion may involve
+		     * one additional bitmap block into the transaction,
+		     * thereby the initial journal space reservation
+		     * might not be enough.
+		     */
 		    if (!delete && (*cut_size) != 0 &&
 			reiserfs_transaction_free_space(th) < JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD)
 			break;
@@ -1074,17 +1122,21 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 			break;
 		    }
 		}
-		/* a trick.  If the buffer has been logged, this will do nothing.  If
-		** we've broken the loop without logging it, it will restore the
-		** buffer */
+		/*
+		 * a trick.  If the buffer has been logged, this will
+		 * do nothing.  If we've broken the loop without logging
+		 * it, it will restore the buffer
+		 */
 		reiserfs_restore_prepared_buffer(sb, bh);
 	    } while (need_re_search &&
 		     search_for_position_by_key(sb, item_key, path) == POSITION_FOUND);
 	    pos_in_item(path) = pos * UNFM_P_SIZE;
 
 	    if (*cut_size == 0) {
-		/* Nothing were cut. maybe convert last unformatted node to the
-		 * direct item? */
+		/*
+		 * Nothing was cut. maybe convert last unformatted node to the
+		 * direct item?
+		 */
 		result = M_CONVERT;
 	    }
 	    return result;
@@ -1104,9 +1156,11 @@ static int calc_deleted_bytes_number(struct tree_balance *tb, char mode)
 	    (mode ==
 	     M_DELETE) ? ih_item_len(p_le_ih) : -tb->insert_size[0];
 	if (is_direntry_le_ih(p_le_ih)) {
-		/* return EMPTY_DIR_SIZE; We delete emty directoris only.
-		 * we can't use EMPTY_DIR_SIZE, as old format dirs have a different
-		 * empty size.  ick. FIXME, is this right? */
+		/*
+		 * return EMPTY_DIR_SIZE; We delete emty directories only.
+		 * we can't use EMPTY_DIR_SIZE, as old format dirs have a
+		 * different empty size.  ick. FIXME, is this right?
+		 */
 		return del_size;
 	}
 
@@ -1169,7 +1223,8 @@ char head2type(struct item_head *ih)
 }
 #endif
 
-/* Delete object item.
+/*
+ * Delete object item.
  * th       - active transaction handle
  * path     - path to the deleted item
  * item_key - key to search for the deleted item
@@ -1221,7 +1276,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 
 		PROC_INFO_INC(sb, delete_item_restarted);
 
-		// file system changed, repeat search
+		/* file system changed, repeat search */
 		ret_value =
 		    search_for_position_by_key(sb, item_key, path);
 		if (ret_value == IO_ERROR)
@@ -1238,16 +1293,18 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 		unfix_nodes(&s_del_balance);
 		return 0;
 	}
-	// reiserfs_delete_item returns item length when success
+
+	/* reiserfs_delete_item returns item length when success */
 	ret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);
 	q_ih = tp_item_head(path);
 	quota_cut_bytes = ih_item_len(q_ih);
 
-	/* hack so the quota code doesn't have to guess if the file
-	 ** has a tail.  On tail insert, we allocate quota for 1 unformatted node.
-	 ** We test the offset because the tail might have been
-	 ** split into multiple items, and we only want to decrement for
-	 ** the unfm node once
+	/*
+	 * hack so the quota code doesn't have to guess if the file has a
+	 * tail.  On tail insert, we allocate quota for 1 unformatted node.
+	 * We test the offset because the tail might have been
+	 * split into multiple items, and we only want to decrement for
+	 * the unfm node once
 	 */
 	if (!S_ISLNK(inode->i_mode) && is_direct_le_ih(q_ih)) {
 		if ((le_ih_k_offset(q_ih) & (sb->s_blocksize - 1)) == 1) {
@@ -1261,24 +1318,28 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 		int off;
 		char *data;
 
-		/* We are in direct2indirect conversion, so move tail contents
-		   to the unformatted node */
-		/* note, we do the copy before preparing the buffer because we
-		 ** don't care about the contents of the unformatted node yet.
-		 ** the only thing we really care about is the direct item's data
-		 ** is in the unformatted node.
-		 **
-		 ** Otherwise, we would have to call reiserfs_prepare_for_journal on
-		 ** the unformatted node, which might schedule, meaning we'd have to
-		 ** loop all the way back up to the start of the while loop.
-		 **
-		 ** The unformatted node must be dirtied later on.  We can't be
-		 ** sure here if the entire tail has been deleted yet.
-		 **
-		 ** un_bh is from the page cache (all unformatted nodes are
-		 ** from the page cache) and might be a highmem page.  So, we
-		 ** can't use un_bh->b_data.
-		 ** -clm
+		/*
+		 * We are in direct2indirect conversion, so move tail contents
+		 * to the unformatted node
+		 */
+		/*
+		 * note, we do the copy before preparing the buffer because we
+		 * don't care about the contents of the unformatted node yet.
+		 * the only thing we really care about is the direct item's
+		 * data is in the unformatted node.
+		 *
+		 * Otherwise, we would have to call
+		 * reiserfs_prepare_for_journal on the unformatted node,
+		 * which might schedule, meaning we'd have to loop all the
+		 * way back up to the start of the while loop.
+		 *
+		 * The unformatted node must be dirtied later on.  We can't be
+		 * sure here if the entire tail has been deleted yet.
+		 *
+		 * un_bh is from the page cache (all unformatted nodes are
+		 * from the page cache) and might be a highmem page.  So, we
+		 * can't use un_bh->b_data.
+		 * -clm
 		 */
 
 		data = kmap_atomic(un_bh->b_page);
@@ -1288,6 +1349,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 		       ret_value);
 		kunmap_atomic(data);
 	}
+
 	/* Perform balancing after all resources have been collected at once. */
 	do_balance(&s_del_balance, NULL, NULL, M_DELETE);
 
@@ -1304,20 +1366,21 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 	return ret_value;
 }
 
-/* Summary Of Mechanisms For Handling Collisions Between Processes:
-
- deletion of the body of the object is performed by iput(), with the
- result that if multiple processes are operating on a file, the
- deletion of the body of the file is deferred until the last process
- that has an open inode performs its iput().
-
- writes and truncates are protected from collisions by use of
- semaphores.
-
- creates, linking, and mknod are protected from collisions with other
- processes by making the reiserfs_add_entry() the last step in the
- creation, and then rolling back all changes if there was a collision.
- - Hans
+/*
+ * Summary Of Mechanisms For Handling Collisions Between Processes:
+ *
+ *  deletion of the body of the object is performed by iput(), with the
+ *  result that if multiple processes are operating on a file, the
+ *  deletion of the body of the file is deferred until the last process
+ *  that has an open inode performs its iput().
+ *
+ *  writes and truncates are protected from collisions by use of
+ *  semaphores.
+ *
+ *  creates, linking, and mknod are protected from collisions with other
+ *  processes by making the reiserfs_add_entry() the last step in the
+ *  creation, and then rolling back all changes if there was a collision.
+ *  - Hans
 */
 
 /* this deletes item which never gets split */
@@ -1347,7 +1410,11 @@ void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,
 		}
 		if (retval != ITEM_FOUND) {
 			pathrelse(&path);
-			// No need for a warning, if there is just no free space to insert '..' item into the newly-created subdir
+			/*
+			 * No need for a warning, if there is just no free
+			 * space to insert '..' item into the
+			 * newly-created subdir
+			 */
 			if (!
 			    ((unsigned long long)
 			     GET_HASH_VALUE(le_key_k_offset
@@ -1376,7 +1443,11 @@ void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,
 
 		if (retval == CARRY_ON) {
 			do_balance(&tb, NULL, NULL, M_DELETE);
-			if (inode) {	/* Should we count quota for item? (we don't count quotas for save-links) */
+			/*
+			 * Should we count quota for item? (we don't
+			 * count quotas for save-links)
+			 */
+			if (inode) {
 				int depth;
 #ifdef REISERQUOTA_DEBUG
 				reiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,
@@ -1391,7 +1462,8 @@ void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,
 			}
 			break;
 		}
-		// IO_ERROR, NO_DISK_SPACE, etc
+
+		/* IO_ERROR, NO_DISK_SPACE, etc */
 		reiserfs_warning(th->t_super, "vs-5360",
 				 "could not delete %K due to fix_nodes failure",
 				 &cpu_key);
@@ -1447,11 +1519,13 @@ static void unmap_buffers(struct page *page, loff_t pos)
 			do {
 				next = bh->b_this_page;
 
-				/* we want to unmap the buffers that contain the tail, and
-				 ** all the buffers after it (since the tail must be at the
-				 ** end of the file).  We don't want to unmap file data
-				 ** before the tail, since it might be dirty and waiting to
-				 ** reach disk
+				/*
+				 * we want to unmap the buffers that contain
+				 * the tail, and all the buffers after it
+				 * (since the tail must be at the end of the
+				 * file).  We don't want to unmap file data
+				 * before the tail, since it might be dirty
+				 * and waiting to reach disk
 				 */
 				cur_index += bh->b_size;
 				if (cur_index > tail_index) {
@@ -1476,9 +1550,10 @@ static int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,
 	BUG_ON(!th->t_trans_id);
 	BUG_ON(new_file_size != inode->i_size);
 
-	/* the page being sent in could be NULL if there was an i/o error
-	 ** reading in the last block.  The user will hit problems trying to
-	 ** read the file, but for now we just skip the indirect2direct
+	/*
+	 * the page being sent in could be NULL if there was an i/o error
+	 * reading in the last block.  The user will hit problems trying to
+	 * read the file, but for now we just skip the indirect2direct
 	 */
 	if (atomic_read(&inode->i_count) > 1 ||
 	    !tail_has_to_be_packed(inode) ||
@@ -1490,17 +1565,18 @@ static int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,
 		pathrelse(path);
 		return cut_bytes;
 	}
+
 	/* Perform the conversion to a direct_item. */
-	/* return indirect_to_direct(inode, path, item_key,
-				  new_file_size, mode); */
 	return indirect2direct(th, inode, page, path, item_key,
 			       new_file_size, mode);
 }
 
-/* we did indirect_to_direct conversion. And we have inserted direct
-   item successesfully, but there were no disk space to cut unfm
-   pointer being converted. Therefore we have to delete inserted
-   direct item(s) */
+/*
+ * we did indirect_to_direct conversion. And we have inserted direct
+ * item successesfully, but there were no disk space to cut unfm
+ * pointer being converted. Therefore we have to delete inserted
+ * direct item(s)
+ */
 static void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,
 					 struct inode *inode, struct treepath *path)
 {
@@ -1509,7 +1585,7 @@ static void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,
 	int removed;
 	BUG_ON(!th->t_trans_id);
 
-	make_cpu_key(&tail_key, inode, inode->i_size + 1, TYPE_DIRECT, 4);	// !!!!
+	make_cpu_key(&tail_key, inode, inode->i_size + 1, TYPE_DIRECT, 4);
 	tail_key.key_length = 4;
 
 	tail_len =
@@ -1539,7 +1615,6 @@ static void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,
 	reiserfs_warning(inode->i_sb, "reiserfs-5091", "indirect_to_direct "
 			 "conversion has been rolled back due to "
 			 "lack of disk space");
-	//mark_file_without_tail (inode);
 	mark_inode_dirty(inode);
 }
 
@@ -1551,15 +1626,18 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 			   struct page *page, loff_t new_file_size)
 {
 	struct super_block *sb = inode->i_sb;
-	/* Every function which is going to call do_balance must first
-	   create a tree_balance structure.  Then it must fill up this
-	   structure by using the init_tb_struct and fix_nodes functions.
-	   After that we can make tree balancing. */
+	/*
+	 * Every function which is going to call do_balance must first
+	 * create a tree_balance structure.  Then it must fill up this
+	 * structure by using the init_tb_struct and fix_nodes functions.
+	 * After that we can make tree balancing.
+	 */
 	struct tree_balance s_cut_balance;
 	struct item_head *p_le_ih;
-	int cut_size = 0,	/* Amount to be cut. */
-	    ret_value = CARRY_ON, removed = 0,	/* Number of the removed unformatted nodes. */
-	    is_inode_locked = 0;
+	int cut_size = 0;	/* Amount to be cut. */
+	int ret_value = CARRY_ON;
+	int removed = 0;	/* Number of the removed unformatted nodes. */
+	int is_inode_locked = 0;
 	char mode;		/* Mode of the balance. */
 	int retval2 = -1;
 	int quota_cut_bytes;
@@ -1571,21 +1649,27 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 	init_tb_struct(th, &s_cut_balance, inode->i_sb, path,
 		       cut_size);
 
-	/* Repeat this loop until we either cut the item without needing
-	   to balance, or we fix_nodes without schedule occurring */
+	/*
+	 * Repeat this loop until we either cut the item without needing
+	 * to balance, or we fix_nodes without schedule occurring
+	 */
 	while (1) {
-		/* Determine the balance mode, position of the first byte to
-		   be cut, and size to be cut.  In case of the indirect item
-		   free unformatted nodes which are pointed to by the cut
-		   pointers. */
+		/*
+		 * Determine the balance mode, position of the first byte to
+		 * be cut, and size to be cut.  In case of the indirect item
+		 * free unformatted nodes which are pointed to by the cut
+		 * pointers.
+		 */
 
 		mode =
 		    prepare_for_delete_or_cut(th, inode, path,
 					      item_key, &removed,
 					      &cut_size, new_file_size);
 		if (mode == M_CONVERT) {
-			/* convert last unformatted node to direct item or leave
-			   tail in the unformatted node */
+			/*
+			 * convert last unformatted node to direct item or
+			 * leave tail in the unformatted node
+			 */
 			RFALSE(ret_value != CARRY_ON,
 			       "PAP-5570: can not convert twice");
 
@@ -1599,15 +1683,20 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 
 			is_inode_locked = 1;
 
-			/* removing of last unformatted node will change value we
-			   have to return to truncate. Save it */
+			/*
+			 * removing of last unformatted node will
+			 * change value we have to return to truncate.
+			 * Save it
+			 */
 			retval2 = ret_value;
-			/*retval2 = sb->s_blocksize - (new_file_size & (sb->s_blocksize - 1)); */
 
-			/* So, we have performed the first part of the conversion:
-			   inserting the new direct item.  Now we are removing the
-			   last unformatted node pointer. Set key to search for
-			   it. */
+			/*
+			 * So, we have performed the first part of the
+			 * conversion:
+			 * inserting the new direct item.  Now we are
+			 * removing the last unformatted node pointer.
+			 * Set key to search for it.
+			 */
 			set_cpu_key_k_type(item_key, TYPE_INDIRECT);
 			item_key->key_length = 4;
 			new_file_size -=
@@ -1650,11 +1739,13 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		return (ret_value == IO_ERROR) ? -EIO : -ENOENT;
 	}			/* while */
 
-	// check fix_nodes results (IO_ERROR or NO_DISK_SPACE)
+	/* check fix_nodes results (IO_ERROR or NO_DISK_SPACE) */
 	if (ret_value != CARRY_ON) {
 		if (is_inode_locked) {
-			// FIXME: this seems to be not needed: we are always able
-			// to cut item
+			/*
+			 * FIXME: this seems to be not needed: we are always
+			 * able to cut item
+			 */
 			indirect_to_direct_roll_back(th, inode, path);
 		}
 		if (ret_value == NO_DISK_SPACE)
@@ -1678,15 +1769,16 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 	else
 		ret_value = retval2;
 
-	/* For direct items, we only change the quota when deleting the last
-	 ** item.
+	/*
+	 * For direct items, we only change the quota when deleting the last
+	 * item.
 	 */
 	p_le_ih = tp_item_head(s_cut_balance.tb_path);
 	if (!S_ISLNK(inode->i_mode) && is_direct_le_ih(p_le_ih)) {
 		if (mode == M_DELETE &&
 		    (le_ih_k_offset(p_le_ih) & (sb->s_blocksize - 1)) ==
 		    1) {
-			// FIXME: this is to keep 3.5 happy
+			/* FIXME: this is to keep 3.5 happy */
 			REISERFS_I(inode)->i_first_direct_byte = U32_MAX;
 			quota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;
 		} else {
@@ -1697,9 +1789,11 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 	if (is_inode_locked) {
 		struct item_head *le_ih =
 		    tp_item_head(s_cut_balance.tb_path);
-		/* we are going to complete indirect2direct conversion. Make
-		   sure, that we exactly remove last unformatted node pointer
-		   of the item */
+		/*
+		 * we are going to complete indirect2direct conversion. Make
+		 * sure, that we exactly remove last unformatted node pointer
+		 * of the item
+		 */
 		if (!is_indirect_le_ih(le_ih))
 			reiserfs_panic(sb, "vs-5652",
 				       "item must be indirect %h", le_ih);
@@ -1717,17 +1811,20 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 				       "(CUT, insert_size==%d)",
 				       le_ih, s_cut_balance.insert_size[0]);
 		}
-		/* it would be useful to make sure, that right neighboring
-		   item is direct item of this file */
+		/*
+		 * it would be useful to make sure, that right neighboring
+		 * item is direct item of this file
+		 */
 	}
 #endif
 
 	do_balance(&s_cut_balance, NULL, NULL, mode);
 	if (is_inode_locked) {
-		/* we've done an indirect->direct conversion.  when the data block
-		 ** was freed, it was removed from the list of blocks that must
-		 ** be flushed before the transaction commits, make sure to
-		 ** unmap and invalidate it
+		/*
+		 * we've done an indirect->direct conversion.  when the
+		 * data block was freed, it was removed from the list of
+		 * blocks that must be flushed before the transaction
+		 * commits, make sure to unmap and invalidate it
 		 */
 		unmap_buffers(page, tail_pos);
 		REISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;
@@ -1758,20 +1855,25 @@ static void truncate_directory(struct reiserfs_transaction_handle *th,
 	set_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_STAT_DATA);
 }
 
-/* Truncate file to the new size. Note, this must be called with a transaction
-   already started */
+/*
+ * Truncate file to the new size. Note, this must be called with a
+ * transaction already started
+ */
 int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
-			  struct inode *inode,	/* ->i_size contains new size */
+			 struct inode *inode,	/* ->i_size contains new size */
 			 struct page *page,	/* up to date for last block */
-			 int update_timestamps	/* when it is called by
-						   file_release to convert
-						   the tail - no timestamps
-						   should be updated */
+			 /*
+			  * when it is called by file_release to convert
+			  * the tail - no timestamps should be updated
+			  */
+			 int update_timestamps
     )
 {
 	INITIALIZE_PATH(s_search_path);	/* Path to the current object item. */
 	struct item_head *p_le_ih;	/* Pointer to an item header. */
-	struct cpu_key s_item_key;	/* Key to search for a previous file item. */
+
+	/* Key to search for a previous file item. */
+	struct cpu_key s_item_key;
 	loff_t file_size,	/* Old file size. */
 	 new_file_size;	/* New file size. */
 	int deleted;		/* Number of deleted or truncated bytes. */
@@ -1784,8 +1886,8 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 	     || S_ISLNK(inode->i_mode)))
 		return 0;
 
+	/* deletion of directory - no need to update timestamps */
 	if (S_ISDIR(inode->i_mode)) {
-		// deletion of directory - no need to update timestamps
 		truncate_directory(th, inode);
 		return 0;
 	}
@@ -1793,7 +1895,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 	/* Get new file size. */
 	new_file_size = inode->i_size;
 
-	// FIXME: note, that key type is unimportant here
+	/* FIXME: note, that key type is unimportant here */
 	make_cpu_key(&s_item_key, inode, max_reiserfs_offset(inode),
 		     TYPE_DIRECT, 3);
 
@@ -1827,9 +1929,11 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 		int bytes =
 		    op_bytes_number(p_le_ih, inode->i_sb->s_blocksize);
 
-		/* this may mismatch with real file size: if last direct item
-		   had no padding zeros and last unformatted node had no free
-		   space, this file would have this file size */
+		/*
+		 * this may mismatch with real file size: if last direct item
+		 * had no padding zeros and last unformatted node had no free
+		 * space, this file would have this file size
+		 */
 		file_size = offset + bytes - 1;
 	}
 	/*
@@ -1867,14 +1971,17 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 
 		set_cpu_key_k_offset(&s_item_key, file_size);
 
-		/* While there are bytes to truncate and previous file item is presented in the tree. */
+		/*
+		 * While there are bytes to truncate and previous
+		 * file item is presented in the tree.
+		 */
 
 		/*
-		 ** This loop could take a really long time, and could log
-		 ** many more blocks than a transaction can hold.  So, we do a polite
-		 ** journal end here, and if the transaction needs ending, we make
-		 ** sure the file is consistent before ending the current trans
-		 ** and starting a new one
+		 * This loop could take a really long time, and could log
+		 * many more blocks than a transaction can hold.  So, we do
+		 * a polite journal end here, and if the transaction needs
+		 * ending, we make sure the file is consistent before ending
+		 * the current trans and starting a new one
 		 */
 		if (journal_transaction_should_end(th, 0) ||
 		    reiserfs_transaction_free_space(th) <= JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD) {
@@ -1906,7 +2013,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 
       update_and_out:
 	if (update_timestamps) {
-		// this is truncate, not file closing
+		/* this is truncate, not file closing */
 		inode->i_mtime = CURRENT_TIME_SEC;
 		inode->i_ctime = CURRENT_TIME_SEC;
 	}
@@ -1918,7 +2025,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 }
 
 #ifdef CONFIG_REISERFS_CHECK
-// this makes sure, that we __append__, not overwrite or add holes
+/* this makes sure, that we __append__, not overwrite or add holes */
 static void check_research_for_paste(struct treepath *path,
 				     const struct cpu_key *key)
 {
@@ -1952,13 +2059,22 @@ static void check_research_for_paste(struct treepath *path,
 }
 #endif				/* config reiserfs check */
 
-/* Paste bytes to the existing item. Returns bytes number pasted into the item. */
-int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct treepath *search_path,	/* Path to the pasted item.	  */
-			     const struct cpu_key *key,	/* Key to search for the needed item. */
-			     struct inode *inode,	/* Inode item belongs to */
-			     const char *body,	/* Pointer to the bytes to paste.    */
+/*
+ * Paste bytes to the existing item.
+ * Returns bytes number pasted into the item.
+ */
+int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th,
+			     /* Path to the pasted item. */
+			     struct treepath *search_path,
+			     /* Key to search for the needed item. */
+			     const struct cpu_key *key,
+			     /* Inode item belongs to */
+			     struct inode *inode,
+			     /* Pointer to the bytes to paste. */
+			     const char *body,
+			     /* Size of pasted bytes. */
 			     int pasted_size)
-{				/* Size of pasted bytes.             */
+{
 	struct super_block *sb = inode->i_sb;
 	struct tree_balance s_paste_balance;
 	int retval;
@@ -2019,8 +2135,10 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 #endif
 	}
 
-	/* Perform balancing after all resources are collected by fix_nodes, and
-	   accessing them will not risk triggering schedule. */
+	/*
+	 * Perform balancing after all resources are collected by fix_nodes,
+	 * and accessing them will not risk triggering schedule.
+	 */
 	if (retval == CARRY_ON) {
 		do_balance(&s_paste_balance, NULL /*ih */ , body, M_PASTE);
 		return 0;
@@ -2041,7 +2159,8 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 	return retval;
 }
 
-/* Insert new item into the buffer at the path.
+/*
+ * Insert new item into the buffer at the path.
  * th   - active transaction handle
  * path - path to the inserted item
  * ih   - pointer to the item header to insert
@@ -2064,8 +2183,10 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th,
 		fs_gen = get_generation(inode->i_sb);
 		quota_bytes = ih_item_len(ih);
 
-		/* hack so the quota code doesn't have to guess if the file has
-		 ** a tail, links are always tails, so there's no guessing needed
+		/*
+		 * hack so the quota code doesn't have to guess
+		 * if the file has a tail, links are always tails,
+		 * so there's no guessing needed
 		 */
 		if (!S_ISLNK(inode->i_mode) && is_direct_le_ih(ih))
 			quota_bytes = inode->i_sb->s_blocksize + UNFM_P_SIZE;
@@ -2074,8 +2195,10 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th,
 			       "reiserquota insert_item(): allocating %u id=%u type=%c",
 			       quota_bytes, inode->i_uid, head2type(ih));
 #endif
-		/* We can't dirty inode here. It would be immediately written but
-		 * appropriate stat item isn't inserted yet... */
+		/*
+		 * We can't dirty inode here. It would be immediately
+		 * written but appropriate stat item isn't inserted yet...
+		 */
 		depth = reiserfs_write_unlock_nested(inode->i_sb);
 		retval = dquot_alloc_space_nodirty(inode, quota_bytes);
 		reiserfs_write_lock_nested(inode->i_sb, depth);
@@ -2089,7 +2212,10 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th,
 #ifdef DISPLACE_NEW_PACKING_LOCALITIES
 	s_ins_balance.key = key->on_disk_key;
 #endif
-	/* DQUOT_* can schedule, must check to be sure calling fix_nodes is safe */
+	/*
+	 * DQUOT_* can schedule, must check to be sure calling
+	 * fix_nodes is safe
+	 */
 	if (inode && fs_changed(fs_gen, inode->i_sb)) {
 		goto search_again;
 	}

commit 4cf5f7addf18ecae2ea49b11944976cbd26d5281
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Apr 23 10:00:35 2014 -0400

    reiserfs: cleanup, rename key and item accessors to more friendly names
    
    This patch does a quick search and replace:
    B_N_PITEM_HEAD() -> item_head()
    B_N_PDELIM_KEY() -> internal_key()
    B_N_PKEY() -> leaf_key()
    B_N_PITEM() -> item_body()
    
    And the item_head version:
    B_I_PITEM() -> ih_item_body()
    I_ENTRY_COUNT() -> ih_entry_count()
    
    And the treepath variants:
    get_ih() -> tp_item_head()
    PATH_PITEM_HEAD() -> tp_item_head()
    get_item() -> tp_item_body()
    
    ... which makes the code much easier on the eyes.
    
    I've also removed a few unused macros.
    
    Checkpatch will complain about the 80 character limit for do_balan.c.
    I've addressed that in a later patchset to split up balance_leaf().
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index b14706a05d52..40b3e77c8ff3 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -272,7 +272,7 @@ static inline const struct reiserfs_key *get_lkey(const struct treepath *chk_pat
 			return &MAX_KEY;
 		/* Return delimiting key if position in the parent is not equal to zero. */
 		if (position)
-			return B_N_PDELIM_KEY(parent, position - 1);
+			return internal_key(parent, position - 1);
 	}
 	/* Return MIN_KEY if we are in the root of the buffer tree. */
 	if (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->
@@ -315,7 +315,7 @@ inline const struct reiserfs_key *get_rkey(const struct treepath *chk_path,
 			return &MIN_KEY;
 		/* Return delimiting key if position in the parent is not the last one. */
 		if (position != B_NR_ITEMS(parent))
-			return B_N_PDELIM_KEY(parent, position);
+			return internal_key(parent, position);
 	}
 	/* Return MAX_KEY if we are in the root of the buffer tree. */
 	if (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->
@@ -732,7 +732,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 		       "vs-5152: tree level (%d) is less than stop level (%d)",
 		       node_level, stop_level);
 
-		retval = bin_search(key, B_N_PITEM_HEAD(bh, 0),
+		retval = bin_search(key, item_head(bh, 0),
 				      B_NR_ITEMS(bh),
 				      (node_level ==
 				       DISK_LEAF_NODE_LEVEL) ? IH_SIZE :
@@ -779,7 +779,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 				/*
 				 * check to make sure we're in the same object
 				 */
-				le_key = B_N_PDELIM_KEY(bh, pos);
+				le_key = internal_key(bh, pos);
 				if (le32_to_cpu(le_key->k_objectid) !=
 				    key->on_disk_key.k_objectid) {
 					break;
@@ -830,7 +830,7 @@ int search_for_position_by_key(struct super_block *sb,	/* Pointer to the super b
 	if (retval == ITEM_FOUND) {
 
 		RFALSE(!ih_item_len
-		       (B_N_PITEM_HEAD
+		       (item_head
 			(PATH_PLAST_BUFFER(search_path),
 			 PATH_LAST_POSITION(search_path))),
 		       "PAP-5165: item length equals zero");
@@ -844,7 +844,7 @@ int search_for_position_by_key(struct super_block *sb,	/* Pointer to the super b
 
 	/* Item is not found. Set path to the previous item. */
 	p_le_ih =
-	    B_N_PITEM_HEAD(PATH_PLAST_BUFFER(search_path),
+	    item_head(PATH_PLAST_BUFFER(search_path),
 			   --PATH_LAST_POSITION(search_path));
 	blk_size = sb->s_blocksize;
 
@@ -892,7 +892,7 @@ int comp_items(const struct item_head *stored_ih, const struct treepath *path)
 		return 1;
 
 	/* we need only to know, whether it is the same item */
-	ih = get_ih(path);
+	ih = tp_item_head(path);
 	return memcmp(stored_ih, ih, IH_SIZE);
 }
 
@@ -987,7 +987,7 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
     )
 {
 	struct super_block *sb = inode->i_sb;
-	struct item_head *p_le_ih = PATH_PITEM_HEAD(path);
+	struct item_head *p_le_ih = tp_item_head(path);
 	struct buffer_head *bh = PATH_PLAST_BUFFER(path);
 
 	BUG_ON(!th->t_trans_id);
@@ -1033,7 +1033,7 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 		need_re_search = 0;
 		*cut_size = 0;
 		bh = PATH_PLAST_BUFFER(path);
-		copy_item_head(&s_ih, PATH_PITEM_HEAD(path));
+		copy_item_head(&s_ih, tp_item_head(path));
 		pos = I_UNFM_NUM(&s_ih);
 
 		while (le_ih_k_offset (&s_ih) + (pos - 1) * blk_size > new_file_length) {
@@ -1047,7 +1047,7 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 			reiserfs_transaction_free_space(th) < JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD)
 			break;
 
-		    unfm = (__le32 *)B_I_PITEM(bh, &s_ih) + pos - 1;
+		    unfm = (__le32 *)ih_item_body(bh, &s_ih) + pos - 1;
 		    block = get_block_num(unfm, 0);
 
 		    if (block != 0) {
@@ -1095,7 +1095,7 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 static int calc_deleted_bytes_number(struct tree_balance *tb, char mode)
 {
 	int del_size;
-	struct item_head *p_le_ih = PATH_PITEM_HEAD(tb->tb_path);
+	struct item_head *p_le_ih = tp_item_head(tb->tb_path);
 
 	if (is_statdata_le_ih(p_le_ih))
 		return 0;
@@ -1212,7 +1212,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 
 		RFALSE(mode != M_DELETE, "PAP-5320: mode must be M_DELETE");
 
-		copy_item_head(&s_ih, PATH_PITEM_HEAD(path));
+		copy_item_head(&s_ih, tp_item_head(path));
 		s_del_balance.insert_size[0] = del_size;
 
 		ret_value = fix_nodes(M_DELETE, &s_del_balance, NULL, NULL);
@@ -1240,7 +1240,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 	}
 	// reiserfs_delete_item returns item length when success
 	ret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);
-	q_ih = get_ih(path);
+	q_ih = tp_item_head(path);
 	quota_cut_bytes = ih_item_len(q_ih);
 
 	/* hack so the quota code doesn't have to guess if the file
@@ -1284,7 +1284,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 		data = kmap_atomic(un_bh->b_page);
 		off = ((le_ih_k_offset(&s_ih) - 1) & (PAGE_CACHE_SIZE - 1));
 		memcpy(data + off,
-		       B_I_PITEM(PATH_PLAST_BUFFER(path), &s_ih),
+		       ih_item_body(PATH_PLAST_BUFFER(path), &s_ih),
 		       ret_value);
 		kunmap_atomic(data);
 	}
@@ -1362,11 +1362,11 @@ void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,
 		}
 		if (!tb_init) {
 			tb_init = 1;
-			item_len = ih_item_len(PATH_PITEM_HEAD(&path));
+			item_len = ih_item_len(tp_item_head(&path));
 			init_tb_struct(th, &tb, th->t_super, &path,
 				       -(IH_SIZE + item_len));
 		}
-		quota_cut_bytes = ih_item_len(PATH_PITEM_HEAD(&path));
+		quota_cut_bytes = ih_item_len(tp_item_head(&path));
 
 		retval = fix_nodes(M_DELETE, &tb, NULL, NULL);
 		if (retval == REPEAT_SEARCH) {
@@ -1521,7 +1521,7 @@ static void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,
 			reiserfs_panic(inode->i_sb, "vs-5615",
 				       "found invalid item");
 		RFALSE(path->pos_in_item !=
-		       ih_item_len(PATH_PITEM_HEAD(path)) - 1,
+		       ih_item_len(tp_item_head(path)) - 1,
 		       "vs-5616: appended bytes found");
 		PATH_LAST_POSITION(path)--;
 
@@ -1671,7 +1671,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 	/* Calculate number of bytes that need to be cut from the item. */
 	quota_cut_bytes =
 	    (mode ==
-	     M_DELETE) ? ih_item_len(get_ih(path)) : -s_cut_balance.
+	     M_DELETE) ? ih_item_len(tp_item_head(path)) : -s_cut_balance.
 	    insert_size[0];
 	if (retval2 == -1)
 		ret_value = calc_deleted_bytes_number(&s_cut_balance, mode);
@@ -1681,7 +1681,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 	/* For direct items, we only change the quota when deleting the last
 	 ** item.
 	 */
-	p_le_ih = PATH_PITEM_HEAD(s_cut_balance.tb_path);
+	p_le_ih = tp_item_head(s_cut_balance.tb_path);
 	if (!S_ISLNK(inode->i_mode) && is_direct_le_ih(p_le_ih)) {
 		if (mode == M_DELETE &&
 		    (le_ih_k_offset(p_le_ih) & (sb->s_blocksize - 1)) ==
@@ -1696,7 +1696,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 #ifdef CONFIG_REISERFS_CHECK
 	if (is_inode_locked) {
 		struct item_head *le_ih =
-		    PATH_PITEM_HEAD(s_cut_balance.tb_path);
+		    tp_item_head(s_cut_balance.tb_path);
 		/* we are going to complete indirect2direct conversion. Make
 		   sure, that we exactly remove last unformatted node pointer
 		   of the item */
@@ -1819,7 +1819,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 	s_search_path.pos_in_item--;
 
 	/* Get real file size (total length of all file items) */
-	p_le_ih = PATH_PITEM_HEAD(&s_search_path);
+	p_le_ih = tp_item_head(&s_search_path);
 	if (is_statdata_le_ih(p_le_ih))
 		file_size = 0;
 	else {
@@ -1922,7 +1922,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 static void check_research_for_paste(struct treepath *path,
 				     const struct cpu_key *key)
 {
-	struct item_head *found_ih = get_ih(path);
+	struct item_head *found_ih = tp_item_head(path);
 
 	if (is_direct_le_ih(found_ih)) {
 		if (le_ih_k_offset(found_ih) +

commit d2d0395fd1778d4bf714adc5bfd23a5d748d7802
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Aug 8 17:34:47 2013 -0400

    reiserfs: locking, release lock around quota operations
    
    Previous commits released the write lock across quota operations but
    missed several places.  In particular, the free operations can also
    call into the file system code and take the write lock, causing
    deadlocks.
    
    This patch introduces some more helpers and uses them for quota call
    sites.  Without this patch applied, reiserfs + quotas runs into deadlocks
    under anything more than trivial load.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 4d7d476d7bff..b14706a05d52 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1186,6 +1186,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 	struct item_head *q_ih;
 	int quota_cut_bytes;
 	int ret_value, del_size, removed;
+	int depth;
 
 #ifdef CONFIG_REISERFS_CHECK
 	char mode;
@@ -1295,7 +1296,9 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 		       "reiserquota delete_item(): freeing %u, id=%u type=%c",
 		       quota_cut_bytes, inode->i_uid, head2type(&s_ih));
 #endif
+	depth = reiserfs_write_unlock_nested(inode->i_sb);
 	dquot_free_space_nodirty(inode, quota_cut_bytes);
+	reiserfs_write_lock_nested(inode->i_sb, depth);
 
 	/* Return deleted body length */
 	return ret_value;
@@ -1321,6 +1324,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,
 				struct inode *inode, struct reiserfs_key *key)
 {
+	struct super_block *sb = th->t_super;
 	struct tree_balance tb;
 	INITIALIZE_PATH(path);
 	int item_len = 0;
@@ -1373,14 +1377,17 @@ void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,
 		if (retval == CARRY_ON) {
 			do_balance(&tb, NULL, NULL, M_DELETE);
 			if (inode) {	/* Should we count quota for item? (we don't count quotas for save-links) */
+				int depth;
 #ifdef REISERQUOTA_DEBUG
 				reiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,
 					       "reiserquota delete_solid_item(): freeing %u id=%u type=%c",
 					       quota_cut_bytes, inode->i_uid,
 					       key2type(key));
 #endif
+				depth = reiserfs_write_unlock_nested(sb);
 				dquot_free_space_nodirty(inode,
 							 quota_cut_bytes);
+				reiserfs_write_lock_nested(sb, depth);
 			}
 			break;
 		}
@@ -1557,6 +1564,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 	int retval2 = -1;
 	int quota_cut_bytes;
 	loff_t tail_pos = 0;
+	int depth;
 
 	BUG_ON(!th->t_trans_id);
 
@@ -1729,7 +1737,9 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		       "reiserquota cut_from_item(): freeing %u id=%u type=%c",
 		       quota_cut_bytes, inode->i_uid, '?');
 #endif
+	depth = reiserfs_write_unlock_nested(sb);
 	dquot_free_space_nodirty(inode, quota_cut_bytes);
+	reiserfs_write_lock_nested(sb, depth);
 	return ret_value;
 }
 
@@ -1949,9 +1959,11 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 			     const char *body,	/* Pointer to the bytes to paste.    */
 			     int pasted_size)
 {				/* Size of pasted bytes.             */
+	struct super_block *sb = inode->i_sb;
 	struct tree_balance s_paste_balance;
 	int retval;
 	int fs_gen;
+	int depth;
 
 	BUG_ON(!th->t_trans_id);
 
@@ -1964,9 +1976,9 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 		       key2type(&(key->on_disk_key)));
 #endif
 
-	reiserfs_write_unlock(inode->i_sb);
+	depth = reiserfs_write_unlock_nested(sb);
 	retval = dquot_alloc_space_nodirty(inode, pasted_size);
-	reiserfs_write_lock(inode->i_sb);
+	reiserfs_write_lock_nested(sb, depth);
 	if (retval) {
 		pathrelse(search_path);
 		return retval;
@@ -2023,7 +2035,9 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 		       pasted_size, inode->i_uid,
 		       key2type(&(key->on_disk_key)));
 #endif
+	depth = reiserfs_write_unlock_nested(sb);
 	dquot_free_space_nodirty(inode, pasted_size);
+	reiserfs_write_lock_nested(sb, depth);
 	return retval;
 }
 
@@ -2046,6 +2060,7 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th,
 	BUG_ON(!th->t_trans_id);
 
 	if (inode) {		/* Do we count quotas for item? */
+		int depth;
 		fs_gen = get_generation(inode->i_sb);
 		quota_bytes = ih_item_len(ih);
 
@@ -2059,11 +2074,11 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th,
 			       "reiserquota insert_item(): allocating %u id=%u type=%c",
 			       quota_bytes, inode->i_uid, head2type(ih));
 #endif
-		reiserfs_write_unlock(inode->i_sb);
 		/* We can't dirty inode here. It would be immediately written but
 		 * appropriate stat item isn't inserted yet... */
+		depth = reiserfs_write_unlock_nested(inode->i_sb);
 		retval = dquot_alloc_space_nodirty(inode, quota_bytes);
-		reiserfs_write_lock(inode->i_sb);
+		reiserfs_write_lock_nested(inode->i_sb, depth);
 		if (retval) {
 			pathrelse(path);
 			return retval;
@@ -2114,7 +2129,10 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th,
 		       "reiserquota insert_item(): freeing %u id=%u type=%c",
 		       quota_bytes, inode->i_uid, head2type(ih));
 #endif
-	if (inode)
+	if (inode) {
+		int depth = reiserfs_write_unlock_nested(inode->i_sb);
 		dquot_free_space_nodirty(inode, quota_bytes);
+		reiserfs_write_lock_nested(inode->i_sb, depth);
+	}
 	return retval;
 }

commit 278f6679f454bf185a07d9a4ca355b153482d17a
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Aug 8 17:34:46 2013 -0400

    reiserfs: locking, handle nested locks properly
    
    The reiserfs write lock replaced the BKL and uses similar semantics.
    
    Frederic's locking code makes a distinction between when the lock is nested
    and when it's being acquired/released, but I don't think that's the right
    distinction to make.
    
    The right distinction is between the lock being released at end-of-use and
    the lock being released for a schedule. The unlock should return the depth
    and the lock should restore it, rather than the other way around as it is now.
    
    This patch implements that and adds a number of places where the lock
    should be dropped.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 2f40a4c70a4d..4d7d476d7bff 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -524,14 +524,14 @@ static int is_tree_node(struct buffer_head *bh, int level)
  * the caller (search_by_key) will perform other schedule-unsafe
  * operations just after calling this function.
  *
- * @return true if we have unlocked
+ * @return depth of lock to be restored after read completes
  */
-static bool search_by_key_reada(struct super_block *s,
+static int search_by_key_reada(struct super_block *s,
 				struct buffer_head **bh,
 				b_blocknr_t *b, int num)
 {
 	int i, j;
-	bool unlocked = false;
+	int depth = -1;
 
 	for (i = 0; i < num; i++) {
 		bh[i] = sb_getblk(s, b[i]);
@@ -549,15 +549,13 @@ static bool search_by_key_reada(struct super_block *s,
 		 * you have to make sure the prepared bit isn't set on this buffer
 		 */
 		if (!buffer_uptodate(bh[j])) {
-			if (!unlocked) {
-				reiserfs_write_unlock(s);
-				unlocked = true;
-			}
+			if (depth == -1)
+				depth = reiserfs_write_unlock_nested(s);
 			ll_rw_block(READA, 1, bh + j);
 		}
 		brelse(bh[j]);
 	}
-	return unlocked;
+	return depth;
 }
 
 /**************************************************************************
@@ -645,26 +643,26 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 		   have a pointer to it. */
 		if ((bh = last_element->pe_buffer =
 		     sb_getblk(sb, block_number))) {
-			bool unlocked = false;
 
-			if (!buffer_uptodate(bh) && reada_count > 1)
-				/* may unlock the write lock */
-				unlocked = search_by_key_reada(sb, reada_bh,
-						    reada_blocks, reada_count);
 			/*
-			 * If we haven't already unlocked the write lock,
-			 * then we need to do that here before reading
-			 * the current block
+			 * We'll need to drop the lock if we encounter any
+			 * buffers that need to be read. If all of them are
+			 * already up to date, we don't need to drop the lock.
 			 */
-			if (!buffer_uptodate(bh) && !unlocked) {
-				reiserfs_write_unlock(sb);
-				unlocked = true;
-			}
+			int depth = -1;
+
+			if (!buffer_uptodate(bh) && reada_count > 1)
+				depth = search_by_key_reada(sb, reada_bh,
+						    reada_blocks, reada_count);
+
+			if (!buffer_uptodate(bh) && depth == -1)
+				depth = reiserfs_write_unlock_nested(sb);
+
 			ll_rw_block(READ, 1, &bh);
 			wait_on_buffer(bh);
 
-			if (unlocked)
-				reiserfs_write_lock(sb);
+			if (depth != -1)
+				reiserfs_write_lock_nested(sb, depth);
 			if (!buffer_uptodate(bh))
 				goto io_error;
 		} else {
@@ -1059,9 +1057,7 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 			reiserfs_free_block(th, inode, block, 1);
 		    }
 
-		    reiserfs_write_unlock(sb);
-		    cond_resched();
-		    reiserfs_write_lock(sb);
+		    reiserfs_cond_resched(sb);
 
 		    if (item_moved (&s_ih, path))  {
 			need_re_search = 1;

commit 7af11686933726e99af22901d622f9e161404e6b
Author: Jan Kara <jack@suse.cz>
Date:   Tue Nov 13 17:05:14 2012 +0100

    reiserfs: Move quota calls out of write lock
    
    Calls into highlevel quota code cannot happen under the write lock. These
    calls take dqio_mutex which ranks above write lock. So drop write lock
    before calling back into quota code.
    
    CC: stable@vger.kernel.org # >= 3.0
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index f8afa4b162b8..2f40a4c70a4d 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1968,7 +1968,9 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 		       key2type(&(key->on_disk_key)));
 #endif
 
+	reiserfs_write_unlock(inode->i_sb);
 	retval = dquot_alloc_space_nodirty(inode, pasted_size);
+	reiserfs_write_lock(inode->i_sb);
 	if (retval) {
 		pathrelse(search_path);
 		return retval;
@@ -2061,9 +2063,11 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th,
 			       "reiserquota insert_item(): allocating %u id=%u type=%c",
 			       quota_bytes, inode->i_uid, head2type(ih));
 #endif
+		reiserfs_write_unlock(inode->i_sb);
 		/* We can't dirty inode here. It would be immediately written but
 		 * appropriate stat item isn't inserted yet... */
 		retval = dquot_alloc_space_nodirty(inode, quota_bytes);
+		reiserfs_write_lock(inode->i_sb);
 		if (retval) {
 			pathrelse(path);
 			return retval;

commit e2a0883e4071237d09b604a342c28b96b44a04b3
Merge: 3a990a52f9f2 07c0c5d8b8c1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 21 13:36:41 2012 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs pile 1 from Al Viro:
     "This is _not_ all; in particular, Miklos' and Jan's stuff is not there
      yet."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (64 commits)
      ext4: initialization of ext4_li_mtx needs to be done earlier
      debugfs-related mode_t whack-a-mole
      hfsplus: add an ioctl to bless files
      hfsplus: change finder_info to u32
      hfsplus: initialise userflags
      qnx4: new helper - try_extent()
      qnx4: get rid of qnx4_bread/qnx4_getblk
      take removal of PF_FORKNOEXEC to flush_old_exec()
      trim includes in inode.c
      um: uml_dup_mmap() relies on ->mmap_sem being held, but activate_mm() doesn't hold it
      um: embed ->stub_pages[] into mmu_context
      gadgetfs: list_for_each_safe() misuse
      ocfs2: fix leaks on failure exits in module_init
      ecryptfs: make register_filesystem() the last potential failure exit
      ntfs: forgets to unregister sysctls on register_filesystem() failure
      logfs: missing cleanup on register_filesystem() failure
      jfs: mising cleanup on register_filesystem() failure
      make configfs_pin_fs() return root dentry on success
      configfs: configfs_create_dir() has parent dentry in dentry->d_parent
      configfs: sanitize configfs_create()
      ...

commit f466c6fdb3b1f043ff1977a8d2a1d0cd4dc164fa
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 17 01:16:43 2012 -0400

    move private bits of reiserfs_fs.h to fs/reiserfs/reiserfs.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 313d39d639eb..f1b68afc268f 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -51,7 +51,7 @@
 #include <linux/time.h>
 #include <linux/string.h>
 #include <linux/pagemap.h>
-#include <linux/reiserfs_fs.h>
+#include "reiserfs.h"
 #include <linux/buffer_head.h>
 #include <linux/quotaops.h>
 

commit 883da600b00eb6fa9f8db5687759732b3c6dd357
Author: Cong Wang <amwang@redhat.com>
Date:   Fri Nov 25 23:14:35 2011 +0800

    reiserfs: remove the second argument of k[un]map_atomic()
    
    Signed-off-by: Cong Wang <amwang@redhat.com>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 313d39d639eb..77df82f9e70a 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1284,12 +1284,12 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 		 ** -clm
 		 */
 
-		data = kmap_atomic(un_bh->b_page, KM_USER0);
+		data = kmap_atomic(un_bh->b_page);
 		off = ((le_ih_k_offset(&s_ih) - 1) & (PAGE_CACHE_SIZE - 1));
 		memcpy(data + off,
 		       B_I_PITEM(PATH_PLAST_BUFFER(path), &s_ih),
 		       ret_value);
-		kunmap_atomic(data, KM_USER0);
+		kunmap_atomic(data);
 	}
 	/* Perform balancing after all resources have been collected at once. */
 	do_balance(&s_del_balance, NULL, NULL, M_DELETE);

commit 5dd4056db84387975140ff2568eaa0406f07985e
Author: Christoph Hellwig <hch@infradead.org>
Date:   Wed Mar 3 09:05:00 2010 -0500

    dquot: cleanup space allocation / freeing routines
    
    Get rid of the alloc_space, free_space, reserve_space, claim_space and
    release_rsv dquot operations - they are always called from the filesystem
    and if a filesystem really needs their own (which none currently does)
    it can just call into it's own routine directly.
    
    Move shared logic into the common __dquot_alloc_space,
    dquot_claim_space_nodirty and __dquot_free_space low-level methods,
    and rationalize the wrappers around it to move as much as possible
    code into the common block for CONFIG_QUOTA vs not.  Also rename
    all these helpers to be named dquot_* instead of vfs_dq_*.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 5fa7118f04e1..313d39d639eb 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1299,7 +1299,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 		       "reiserquota delete_item(): freeing %u, id=%u type=%c",
 		       quota_cut_bytes, inode->i_uid, head2type(&s_ih));
 #endif
-	vfs_dq_free_space_nodirty(inode, quota_cut_bytes);
+	dquot_free_space_nodirty(inode, quota_cut_bytes);
 
 	/* Return deleted body length */
 	return ret_value;
@@ -1383,7 +1383,7 @@ void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,
 					       quota_cut_bytes, inode->i_uid,
 					       key2type(key));
 #endif
-				vfs_dq_free_space_nodirty(inode,
+				dquot_free_space_nodirty(inode,
 							 quota_cut_bytes);
 			}
 			break;
@@ -1733,7 +1733,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		       "reiserquota cut_from_item(): freeing %u id=%u type=%c",
 		       quota_cut_bytes, inode->i_uid, '?');
 #endif
-	vfs_dq_free_space_nodirty(inode, quota_cut_bytes);
+	dquot_free_space_nodirty(inode, quota_cut_bytes);
 	return ret_value;
 }
 
@@ -1968,9 +1968,10 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 		       key2type(&(key->on_disk_key)));
 #endif
 
-	if (vfs_dq_alloc_space_nodirty(inode, pasted_size)) {
+	retval = dquot_alloc_space_nodirty(inode, pasted_size);
+	if (retval) {
 		pathrelse(search_path);
-		return -EDQUOT;
+		return retval;
 	}
 	init_tb_struct(th, &s_paste_balance, th->t_super, search_path,
 		       pasted_size);
@@ -2024,7 +2025,7 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 		       pasted_size, inode->i_uid,
 		       key2type(&(key->on_disk_key)));
 #endif
-	vfs_dq_free_space_nodirty(inode, pasted_size);
+	dquot_free_space_nodirty(inode, pasted_size);
 	return retval;
 }
 
@@ -2062,9 +2063,10 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th,
 #endif
 		/* We can't dirty inode here. It would be immediately written but
 		 * appropriate stat item isn't inserted yet... */
-		if (vfs_dq_alloc_space_nodirty(inode, quota_bytes)) {
+		retval = dquot_alloc_space_nodirty(inode, quota_bytes);
+		if (retval) {
 			pathrelse(path);
-			return -EDQUOT;
+			return retval;
 		}
 	}
 	init_tb_struct(th, &s_ins_balance, th->t_super, path,
@@ -2113,6 +2115,6 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th,
 		       quota_bytes, inode->i_uid, head2type(ih));
 #endif
 	if (inode)
-		vfs_dq_free_space_nodirty(inode, quota_bytes);
+		dquot_free_space_nodirty(inode, quota_bytes);
 	return retval;
 }

commit 08f14fc8963e585e65b71212ce8050607b9b6c36
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Sat May 16 19:10:38 2009 +0200

    kill-the-bkl/reiserfs: move the concurrent tree accesses checks per superblock
    
    When do_balance() balances the tree, a trick is performed to
    provide the ability for other tree writers/readers to check whether
    do_balance() is executing concurrently (requires CONFIG_REISERFS_CHECK).
    
    This is done to protect concurrent accesses to the tree. The trick
    is the following:
    
    When do_balance is called, a unique global variable called cur_tb
    takes a pointer to the current tree to be rebalanced.
    Once do_balance finishes its work, cur_tb takes the NULL value.
    
    Then, concurrent tree readers/writers just have to check the value
    of cur_tb to ensure do_balance isn't executing concurrently.
    If it is, then it proves that schedule() occured on do_balance(),
    which then relaxed the bkl that protected the tree.
    
    Now that the bkl has be turned into a mutex, this check is still
    fine even though do_balance() becomes preemptible: the write lock
    will not be automatically released on schedule(), so the tree is
    still protected.
    
    But this is only fine if we have a single reiserfs mountpoint.
    Indeed, because the bkl is a global lock, it didn't allowed
    concurrent executions between a tree reader/writer in a mount point
    and a do_balance() on another tree from another mountpoint.
    
    So assuming all these readers/writers weren't supposed to be
    reentrant, the current check now sometimes detect false positives with
    the current per-superblock mutex which allows this reentrancy.
    
    This patch keeps the concurrent tree accesses check but moves it
    per superblock, so that only trees from a same mount point are
    checked to be not accessed concurrently.
    
    [ Impact: fix spurious panic while running several reiserfs mount-points ]
    
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 6b025a42d510..5fa7118f04e1 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -222,9 +222,6 @@ static inline int bin_search(const void *key,	/* Key to search for. */
 	return ITEM_NOT_FOUND;
 }
 
-#ifdef CONFIG_REISERFS_CHECK
-extern struct tree_balance *cur_tb;
-#endif
 
 /* Minimal possible key. It is never in the tree. */
 const struct reiserfs_key MIN_KEY = { 0, 0, {{0, 0},} };
@@ -711,7 +708,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 		       !key_in_buffer(search_path, key, sb),
 		       "PAP-5130: key is not in the buffer");
 #ifdef CONFIG_REISERFS_CHECK
-		if (cur_tb) {
+		if (REISERFS_SB(sb)->cur_tb) {
 			print_cur_tb("5140");
 			reiserfs_panic(sb, "PAP-5140",
 				       "schedule occurred in do_balance!");

commit 2ac626955ed62ee8596f00581f959cc86e6198d1
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Thu May 14 02:56:39 2009 +0200

    kill-the-bkl/reiserfs: unlock only when needed in search_by_key
    
    search_by_key() is the site which most requires the lock.
    This is mostly because it is a very central function and also
    because it releases/reaqcuires the write lock at least once each
    time it is called.
    
    Such release/reacquire creates a lot of contention in this place and
    also opens more the window which let another thread changing the tree.
    When it happens, the current path searching over the tree must be
    retried from the beggining (the root) which is a wasteful and
    time consuming recovery.
    
    This patch factorizes two release/reacquire sequences:
    
    - reading leaf nodes blocks
    - reading current block
    
    The latter immediately follows the former.
    
    The whole sequence is safe as a single unlocked section because
    we check just after if the tree has changed during these operations.
    
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 960c9114f6d3..6b025a42d510 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -519,12 +519,22 @@ static int is_tree_node(struct buffer_head *bh, int level)
 
 #define SEARCH_BY_KEY_READA 16
 
-/* The function is NOT SCHEDULE-SAFE! */
-static void search_by_key_reada(struct super_block *s,
+/*
+ * The function is NOT SCHEDULE-SAFE!
+ * It might unlock the write lock if we needed to wait for a block
+ * to be read. Note that in this case it won't recover the lock to avoid
+ * high contention resulting from too much lock requests, especially
+ * the caller (search_by_key) will perform other schedule-unsafe
+ * operations just after calling this function.
+ *
+ * @return true if we have unlocked
+ */
+static bool search_by_key_reada(struct super_block *s,
 				struct buffer_head **bh,
 				b_blocknr_t *b, int num)
 {
 	int i, j;
+	bool unlocked = false;
 
 	for (i = 0; i < num; i++) {
 		bh[i] = sb_getblk(s, b[i]);
@@ -536,16 +546,21 @@ static void search_by_key_reada(struct super_block *s,
 	 * the lock. But it's still fine because we check later
 	 * if the tree changed
 	 */
-	reiserfs_write_unlock(s);
 	for (j = 0; j < i; j++) {
 		/*
 		 * note, this needs attention if we are getting rid of the BKL
 		 * you have to make sure the prepared bit isn't set on this buffer
 		 */
-		if (!buffer_uptodate(bh[j]))
+		if (!buffer_uptodate(bh[j])) {
+			if (!unlocked) {
+				reiserfs_write_unlock(s);
+				unlocked = true;
+			}
 			ll_rw_block(READA, 1, bh + j);
+		}
 		brelse(bh[j]);
 	}
+	return unlocked;
 }
 
 /**************************************************************************
@@ -633,15 +648,26 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 		   have a pointer to it. */
 		if ((bh = last_element->pe_buffer =
 		     sb_getblk(sb, block_number))) {
+			bool unlocked = false;
+
 			if (!buffer_uptodate(bh) && reada_count > 1)
-				/* will unlock the write lock */
-				search_by_key_reada(sb, reada_bh,
+				/* may unlock the write lock */
+				unlocked = search_by_key_reada(sb, reada_bh,
 						    reada_blocks, reada_count);
-			else
+			/*
+			 * If we haven't already unlocked the write lock,
+			 * then we need to do that here before reading
+			 * the current block
+			 */
+			if (!buffer_uptodate(bh) && !unlocked) {
 				reiserfs_write_unlock(sb);
+				unlocked = true;
+			}
 			ll_rw_block(READ, 1, &bh);
 			wait_on_buffer(bh);
-			reiserfs_write_lock(sb);
+
+			if (unlocked)
+				reiserfs_write_lock(sb);
 			if (!buffer_uptodate(bh))
 				goto io_error;
 		} else {

commit 09eb47a7c52ad535aafca889e0b936c445c375ce
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Fri May 8 14:21:33 2009 +0200

    kill-the-bkl/reiserfs: reduce number of contentions in search_by_key()
    
    search_by_key() is a central function in reiserfs which searches
    the patch in the fs tree from the root to a node given its key.
    
    It is the function that is most requesting the write lock
    because it's a path very often used.
    
    Also we forget to release the lock while reading the next tree node,
    making us holding the lock in a wasteful way.
    
    Then we release the lock while reading the current node and its childs,
    all-in-one. It should be safe because we have a reference to these
    blocks and even if we read a block that will be concurrently changed,
    we have an fs_changed check later that will make us retry the path from
    the root.
    
    [ Impact: release the write lock while unused in a hot path ]
    
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 6ddcecb4e8ab..960c9114f6d3 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -529,6 +529,14 @@ static void search_by_key_reada(struct super_block *s,
 	for (i = 0; i < num; i++) {
 		bh[i] = sb_getblk(s, b[i]);
 	}
+	/*
+	 * We are going to read some blocks on which we
+	 * have a reference. It's safe, though we might be
+	 * reading blocks concurrently changed if we release
+	 * the lock. But it's still fine because we check later
+	 * if the tree changed
+	 */
+	reiserfs_write_unlock(s);
 	for (j = 0; j < i; j++) {
 		/*
 		 * note, this needs attention if we are getting rid of the BKL
@@ -626,10 +634,12 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 		if ((bh = last_element->pe_buffer =
 		     sb_getblk(sb, block_number))) {
 			if (!buffer_uptodate(bh) && reada_count > 1)
+				/* will unlock the write lock */
 				search_by_key_reada(sb, reada_bh,
 						    reada_blocks, reada_count);
+			else
+				reiserfs_write_unlock(sb);
 			ll_rw_block(READ, 1, &bh);
-			reiserfs_write_unlock(sb);
 			wait_on_buffer(bh);
 			reiserfs_write_lock(sb);
 			if (!buffer_uptodate(bh))

commit 5e69e3a4492ea5abfd2e8ddc575448becf28e4d9
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Thu Apr 30 23:36:33 2009 +0200

    kill-the-BKL/reiserfs: release write lock while rescheduling on prepare_for_delete_or_cut()
    
    prepare_for_delete_or_cut() can process several types of items, including
    indirect items, ie: items which contain no file data but pointers to
    unformatted nodes scattering the datas of a file.
    
    In this case it has to zero out these pointers to block numbers of
    unformatted nodes and release the bitmap from these block numbers.
    
    It can take some time, so a rescheduling() is performed between each
    block processed. We can safely release the write lock while
    rescheduling(), like the bkl did, because the code checks just after
    if the item has moved after sleeping.
    
    [ Impact: release the reiserfs write lock when it is not needed ]
    
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 6bd99a99a652..6ddcecb4e8ab 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1026,7 +1026,9 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 			reiserfs_free_block(th, inode, block, 1);
 		    }
 
+		    reiserfs_write_unlock(sb);
 		    cond_resched();
+		    reiserfs_write_lock(sb);
 
 		    if (item_moved (&s_ih, path))  {
 			need_re_search = 1;

commit 8ebc423238341b52912c7295b045a32477b33f09
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Tue Apr 7 04:19:49 2009 +0200

    reiserfs: kill-the-BKL
    
    This patch is an attempt to remove the Bkl based locking scheme from
    reiserfs and is intended.
    
    It is a bit inspired from an old attempt by Peter Zijlstra:
    
       http://lkml.indiana.edu/hypermail/linux/kernel/0704.2/2174.html
    
    The bkl is heavily used in this filesystem to prevent from
    concurrent write accesses on the filesystem.
    
    Reiserfs makes a deep use of the specific properties of the Bkl:
    
    - It can be acqquired recursively by a same task
    - It is released on the schedule() calls and reacquired when schedule() returns
    
    The two properties above are a roadmap for the reiserfs write locking so it's
    very hard to simply replace it with a common mutex.
    
    - We need a recursive-able locking unless we want to restructure several blocks
      of the code.
    - We need to identify the sites where the bkl was implictly relaxed
      (schedule, wait, sync, etc...) so that we can in turn release and
      reacquire our new lock explicitly.
      Such implicit releases of the lock are often required to let other
      resources producer/consumer do their job or we can suffer unexpected
      starvations or deadlocks.
    
    So the new lock that replaces the bkl here is a per superblock mutex with a
    specific property: it can be acquired recursively by a same task, like the
    bkl.
    
    For such purpose, we integrate a lock owner and a lock depth field on the
    superblock information structure.
    
    The first axis on this patch is to turn reiserfs_write_(un)lock() function
    into a wrapper to manage this mutex. Also some explicit calls to
    lock_kernel() have been converted to reiserfs_write_lock() helpers.
    
    The second axis is to find the important blocking sites (schedule...(),
    wait_on_buffer(), sync_dirty_buffer(), etc...) and then apply an explicit
    release of the write lock on these locations before blocking. Then we can
    safely wait for those who can give us resources or those who need some.
    Typically this is a fight between the current writer, the reiserfs workqueue
    (aka the async commiter) and the pdflush threads.
    
    The third axis is a consequence of the second. The write lock is usually
    on top of a lock dependency chain which can include the journal lock, the
    flush lock or the commit lock. So it's dangerous to release and trying to
    reacquire the write lock while we still hold other locks.
    
    This is fine with the bkl:
    
          T1                       T2
    
    lock_kernel()
        mutex_lock(A)
        unlock_kernel()
        // do something
                                lock_kernel()
                                    mutex_lock(A) -> already locked by T1
                                    schedule() (and then unlock_kernel())
        lock_kernel()
        mutex_unlock(A)
        ....
    
    This is not fine with a mutex:
    
          T1                       T2
    
    mutex_lock(write)
        mutex_lock(A)
        mutex_unlock(write)
        // do something
                               mutex_lock(write)
                                  mutex_lock(A) -> already locked by T1
                                  schedule()
    
        mutex_lock(write) -> already locked by T2
        deadlock
    
    The solution in this patch is to provide a helper which releases the write
    lock and sleep a bit if we can't lock a mutex that depend on it. It's another
    simulation of the bkl behaviour.
    
    The last axis is to locate the fs callbacks that are called with the bkl held,
    according to Documentation/filesystem/Locking.
    
    Those are:
    
    - reiserfs_remount
    - reiserfs_fill_super
    - reiserfs_put_super
    
    Reiserfs didn't need to explicitly lock because of the context of these callbacks.
    But now we must take care of that with the new locking.
    
    After this patch, reiserfs suffers from a slight performance regression (for now).
    On UP, a high volume write with dd reports an average of 27 MB/s instead
    of 30 MB/s without the patch applied.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Bron Gondwana <brong@fastmail.fm>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    LKML-Reference: <1239070789-13354-1-git-send-email-fweisbec@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index d036ee5b1c81..6bd99a99a652 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -629,7 +629,9 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 				search_by_key_reada(sb, reada_bh,
 						    reada_blocks, reada_count);
 			ll_rw_block(READ, 1, &bh);
+			reiserfs_write_unlock(sb);
 			wait_on_buffer(bh);
+			reiserfs_write_lock(sb);
 			if (!buffer_uptodate(bh))
 				goto io_error;
 		} else {

commit e1c502482853f84606928f5a2f2eb6da1993cda1
Merge: 019abbc87025 ee93961be1fa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 30 12:29:21 2009 -0700

    Merge branch 'reiserfs-updates' from Jeff Mahoney
    
    * reiserfs-updates: (35 commits)
      reiserfs: rename [cn]_* variables
      reiserfs: rename p_._ variables
      reiserfs: rename p_s_tb to tb
      reiserfs: rename p_s_inode to inode
      reiserfs: rename p_s_bh to bh
      reiserfs: rename p_s_sb to sb
      reiserfs: strip trailing whitespace
      reiserfs: cleanup path functions
      reiserfs: factor out buffer_info initialization
      reiserfs: add atomic addition of selinux attributes during inode creation
      reiserfs: use generic readdir for operations across all xattrs
      reiserfs: journaled xattrs
      reiserfs: use generic xattr handlers
      reiserfs: remove i_has_xattr_dir
      reiserfs: make per-inode xattr locking more fine grained
      reiserfs: eliminate per-super xattr lock
      reiserfs: simplify xattr internal file lookups/opens
      reiserfs: Clean up xattrs when REISERFS_FS_XATTR is unset
      reiserfs: remove IS_PRIVATE helpers
      reiserfs: remove link detection code
      ...
    
    Fixed up conflicts manually due to:
     - quota name cleanups vs variable naming changes:
            fs/reiserfs/inode.c
            fs/reiserfs/namei.c
            fs/reiserfs/stree.c
            fs/reiserfs/xattr.c
     - exported include header cleanups
            include/linux/reiserfs_fs.h

commit ee93961be1faddf9e9a638bc519145c20f0cfeba
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:50 2009 -0400

    reiserfs: rename [cn]_* variables
    
    This patch renames n_, c_, etc variables to something more sane.  This
    is the sixth in a series of patches to rip out some of the awful
    variable naming in reiserfs.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index fd769c8dac32..e23303daa868 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -136,11 +136,11 @@ inline int comp_short_le_keys(const struct reiserfs_key *key1,
 			      const struct reiserfs_key *key2)
 {
 	__u32 *k1_u32, *k2_u32;
-	int n_key_length = REISERFS_SHORT_KEY_LEN;
+	int key_length = REISERFS_SHORT_KEY_LEN;
 
 	k1_u32 = (__u32 *) key1;
 	k2_u32 = (__u32 *) key2;
-	for (; n_key_length--; ++k1_u32, ++k2_u32) {
+	for (; key_length--; ++k1_u32, ++k2_u32) {
 		if (le32_to_cpu(*k1_u32) < le32_to_cpu(*k2_u32))
 			return -1;
 		if (le32_to_cpu(*k1_u32) > le32_to_cpu(*k2_u32))
@@ -177,10 +177,10 @@ inline int comp_le_keys(const struct reiserfs_key *k1,
  *        *pos = number of the searched element if found, else the        *
  *        number of the first element that is larger than key.            *
  **************************************************************************/
-/* For those not familiar with binary search: n_lbound is the leftmost item that it
- could be, n_rbound the rightmost item that it could be.  We examine the item
- halfway between n_lbound and n_rbound, and that tells us either that we can increase
- n_lbound, or decrease n_rbound, or that we have found it, or if n_lbound <= n_rbound that
+/* For those not familiar with binary search: lbound is the leftmost item that it
+ could be, rbound the rightmost item that it could be.  We examine the item
+ halfway between lbound and rbound, and that tells us either that we can increase
+ lbound, or decrease rbound, or that we have found it, or if lbound <= rbound that
  there are no possible items, and we have not found it. With each examination we
  cut the number of possible items it could be by one more than half rounded down,
  or we find it. */
@@ -198,28 +198,27 @@ static inline int bin_search(const void *key,	/* Key to search for. */
 			     int *pos /* Number of the searched for element. */
     )
 {
-	int n_rbound, n_lbound, n_j;
+	int rbound, lbound, j;
 
-	for (n_j = ((n_rbound = num - 1) + (n_lbound = 0)) / 2;
-	     n_lbound <= n_rbound; n_j = (n_rbound + n_lbound) / 2)
+	for (j = ((rbound = num - 1) + (lbound = 0)) / 2;
+	     lbound <= rbound; j = (rbound + lbound) / 2)
 		switch (comp_keys
-			((struct reiserfs_key *)((char *)base +
-						 n_j * width),
+			((struct reiserfs_key *)((char *)base + j * width),
 			 (struct cpu_key *)key)) {
 		case -1:
-			n_lbound = n_j + 1;
+			lbound = j + 1;
 			continue;
 		case 1:
-			n_rbound = n_j - 1;
+			rbound = j - 1;
 			continue;
 		case 0:
-			*pos = n_j;
+			*pos = j;
 			return ITEM_FOUND;	/* Key found in the array.  */
 		}
 
 	/* bin_search did not find given key, it returns position of key,
 	   that is minimal and greater than the given one. */
-	*pos = n_lbound;
+	*pos = lbound;
 	return ITEM_NOT_FOUND;
 }
 
@@ -242,43 +241,41 @@ static const struct reiserfs_key MAX_KEY = {
    of the path, and going upwards.  We must check the path's validity at each step.  If the key is not in
    the path, there is no delimiting key in the tree (buffer is first or last buffer in tree), and in this
    case we return a special key, either MIN_KEY or MAX_KEY. */
-static inline const struct reiserfs_key *get_lkey(const struct treepath
-						  *chk_path,
-						  const struct super_block
-						  *sb)
+static inline const struct reiserfs_key *get_lkey(const struct treepath *chk_path,
+						  const struct super_block *sb)
 {
-	int n_position, n_path_offset = chk_path->path_length;
+	int position, path_offset = chk_path->path_length;
 	struct buffer_head *parent;
 
-	RFALSE(n_path_offset < FIRST_PATH_ELEMENT_OFFSET,
+	RFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET,
 	       "PAP-5010: invalid offset in the path");
 
 	/* While not higher in path than first element. */
-	while (n_path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {
+	while (path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {
 
 		RFALSE(!buffer_uptodate
-		       (PATH_OFFSET_PBUFFER(chk_path, n_path_offset)),
+		       (PATH_OFFSET_PBUFFER(chk_path, path_offset)),
 		       "PAP-5020: parent is not uptodate");
 
 		/* Parent at the path is not in the tree now. */
 		if (!B_IS_IN_TREE
 		    (parent =
-		     PATH_OFFSET_PBUFFER(chk_path, n_path_offset)))
+		     PATH_OFFSET_PBUFFER(chk_path, path_offset)))
 			return &MAX_KEY;
 		/* Check whether position in the parent is correct. */
-		if ((n_position =
+		if ((position =
 		     PATH_OFFSET_POSITION(chk_path,
-					  n_path_offset)) >
+					  path_offset)) >
 		    B_NR_ITEMS(parent))
 			return &MAX_KEY;
 		/* Check whether parent at the path really points to the child. */
-		if (B_N_CHILD_NUM(parent, n_position) !=
+		if (B_N_CHILD_NUM(parent, position) !=
 		    PATH_OFFSET_PBUFFER(chk_path,
-					n_path_offset + 1)->b_blocknr)
+					path_offset + 1)->b_blocknr)
 			return &MAX_KEY;
 		/* Return delimiting key if position in the parent is not equal to zero. */
-		if (n_position)
-			return B_N_PDELIM_KEY(parent, n_position - 1);
+		if (position)
+			return B_N_PDELIM_KEY(parent, position - 1);
 	}
 	/* Return MIN_KEY if we are in the root of the buffer tree. */
 	if (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->
@@ -291,37 +288,37 @@ static inline const struct reiserfs_key *get_lkey(const struct treepath
 inline const struct reiserfs_key *get_rkey(const struct treepath *chk_path,
 					   const struct super_block *sb)
 {
-	int n_position, n_path_offset = chk_path->path_length;
+	int position, path_offset = chk_path->path_length;
 	struct buffer_head *parent;
 
-	RFALSE(n_path_offset < FIRST_PATH_ELEMENT_OFFSET,
+	RFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET,
 	       "PAP-5030: invalid offset in the path");
 
-	while (n_path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {
+	while (path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {
 
 		RFALSE(!buffer_uptodate
-		       (PATH_OFFSET_PBUFFER(chk_path, n_path_offset)),
+		       (PATH_OFFSET_PBUFFER(chk_path, path_offset)),
 		       "PAP-5040: parent is not uptodate");
 
 		/* Parent at the path is not in the tree now. */
 		if (!B_IS_IN_TREE
 		    (parent =
-		     PATH_OFFSET_PBUFFER(chk_path, n_path_offset)))
+		     PATH_OFFSET_PBUFFER(chk_path, path_offset)))
 			return &MIN_KEY;
 		/* Check whether position in the parent is correct. */
-		if ((n_position =
+		if ((position =
 		     PATH_OFFSET_POSITION(chk_path,
-					  n_path_offset)) >
+					  path_offset)) >
 		    B_NR_ITEMS(parent))
 			return &MIN_KEY;
 		/* Check whether parent at the path really points to the child. */
-		if (B_N_CHILD_NUM(parent, n_position) !=
+		if (B_N_CHILD_NUM(parent, position) !=
 		    PATH_OFFSET_PBUFFER(chk_path,
-					n_path_offset + 1)->b_blocknr)
+					path_offset + 1)->b_blocknr)
 			return &MIN_KEY;
 		/* Return delimiting key if position in the parent is not the last one. */
-		if (n_position != B_NR_ITEMS(parent))
-			return B_N_PDELIM_KEY(parent, n_position);
+		if (position != B_NR_ITEMS(parent))
+			return B_N_PDELIM_KEY(parent, position);
 	}
 	/* Return MAX_KEY if we are in the root of the buffer tree. */
 	if (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->
@@ -371,14 +368,14 @@ int reiserfs_check_path(struct treepath *p)
 void pathrelse_and_restore(struct super_block *sb,
 			   struct treepath *search_path)
 {
-	int n_path_offset = search_path->path_length;
+	int path_offset = search_path->path_length;
 
-	RFALSE(n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,
+	RFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,
 	       "clm-4000: invalid path offset");
 
-	while (n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {
+	while (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {
 		struct buffer_head *bh;
-		bh = PATH_OFFSET_PBUFFER(search_path, n_path_offset--);
+		bh = PATH_OFFSET_PBUFFER(search_path, path_offset--);
 		reiserfs_restore_prepared_buffer(sb, bh);
 		brelse(bh);
 	}
@@ -388,13 +385,13 @@ void pathrelse_and_restore(struct super_block *sb,
 /* Drop the reference to each buffer in a path */
 void pathrelse(struct treepath *search_path)
 {
-	int n_path_offset = search_path->path_length;
+	int path_offset = search_path->path_length;
 
-	RFALSE(n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,
+	RFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,
 	       "PAP-5090: invalid path offset");
 
-	while (n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)
-		brelse(PATH_OFFSET_PBUFFER(search_path, n_path_offset--));
+	while (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)
+		brelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));
 
 	search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
 }
@@ -572,16 +569,16 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 						   by the calling
 						   function. It is filled up
 						   by this function.  */
-		  int n_stop_level	/* How far down the tree to search. To
+		  int stop_level	/* How far down the tree to search. To
 					   stop at leaf level - set to
 					   DISK_LEAF_NODE_LEVEL */
     )
 {
-	b_blocknr_t n_block_number;
+	b_blocknr_t block_number;
 	int expected_level;
 	struct buffer_head *bh;
 	struct path_element *last_element;
-	int n_node_level, n_retval;
+	int node_level, retval;
 	int right_neighbor_of_leaf_node;
 	int fs_gen;
 	struct buffer_head *reada_bh[SEARCH_BY_KEY_READA];
@@ -589,7 +586,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 	int reada_count = 0;
 
 #ifdef CONFIG_REISERFS_CHECK
-	int n_repeat_counter = 0;
+	int repeat_counter = 0;
 #endif
 
 	PROC_INFO_INC(sb, search_by_key);
@@ -605,16 +602,16 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 	/* With each iteration of this loop we search through the items in the
 	   current node, and calculate the next current node(next path element)
 	   for the next iteration of this loop.. */
-	n_block_number = SB_ROOT_BLOCK(sb);
+	block_number = SB_ROOT_BLOCK(sb);
 	expected_level = -1;
 	while (1) {
 
 #ifdef CONFIG_REISERFS_CHECK
-		if (!(++n_repeat_counter % 50000))
+		if (!(++repeat_counter % 50000))
 			reiserfs_warning(sb, "PAP-5100",
 					 "%s: there were %d iterations of "
 					 "while loop looking for key %K",
-					 current->comm, n_repeat_counter,
+					 current->comm, repeat_counter,
 					 key);
 #endif
 
@@ -627,7 +624,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 		/* Read the next tree node, and set the last element in the path to
 		   have a pointer to it. */
 		if ((bh = last_element->pe_buffer =
-		     sb_getblk(sb, n_block_number))) {
+		     sb_getblk(sb, block_number))) {
 			if (!buffer_uptodate(bh) && reada_count > 1)
 				search_by_key_reada(sb, reada_bh,
 						    reada_blocks, reada_count);
@@ -661,7 +658,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 
 			/* Get the root block number so that we can repeat the search
 			   starting from the root. */
-			n_block_number = SB_ROOT_BLOCK(sb);
+			block_number = SB_ROOT_BLOCK(sb);
 			expected_level = -1;
 			right_neighbor_of_leaf_node = 0;
 
@@ -694,26 +691,26 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 		}
 
 		/* ok, we have acquired next formatted node in the tree */
-		n_node_level = B_LEVEL(bh);
+		node_level = B_LEVEL(bh);
 
-		PROC_INFO_BH_STAT(sb, bh, n_node_level - 1);
+		PROC_INFO_BH_STAT(sb, bh, node_level - 1);
 
-		RFALSE(n_node_level < n_stop_level,
+		RFALSE(node_level < stop_level,
 		       "vs-5152: tree level (%d) is less than stop level (%d)",
-		       n_node_level, n_stop_level);
+		       node_level, stop_level);
 
-		n_retval = bin_search(key, B_N_PITEM_HEAD(bh, 0),
+		retval = bin_search(key, B_N_PITEM_HEAD(bh, 0),
 				      B_NR_ITEMS(bh),
-				      (n_node_level ==
+				      (node_level ==
 				       DISK_LEAF_NODE_LEVEL) ? IH_SIZE :
 				      KEY_SIZE,
 				      &(last_element->pe_position));
-		if (n_node_level == n_stop_level) {
-			return n_retval;
+		if (node_level == stop_level) {
+			return retval;
 		}
 
 		/* we are not in the stop level */
-		if (n_retval == ITEM_FOUND)
+		if (retval == ITEM_FOUND)
 			/* item has been found, so we choose the pointer which is to the right of the found one */
 			last_element->pe_position++;
 
@@ -724,12 +721,12 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to s
 		/* So we have chosen a position in the current node which is
 		   an internal node.  Now we calculate child block number by
 		   position in the node. */
-		n_block_number =
+		block_number =
 		    B_N_CHILD_NUM(bh, last_element->pe_position);
 
 		/* if we are going to read leaf nodes, try for read ahead as well */
 		if ((search_path->reada & PATH_READA) &&
-		    n_node_level == DISK_LEAF_NODE_LEVEL + 1) {
+		    node_level == DISK_LEAF_NODE_LEVEL + 1) {
 			int pos = last_element->pe_position;
 			int limit = B_NR_ITEMS(bh);
 			struct reiserfs_key *le_key;
@@ -781,7 +778,7 @@ int search_for_position_by_key(struct super_block *sb,	/* Pointer to the super b
     )
 {
 	struct item_head *p_le_ih;	/* pointer to on-disk structure */
-	int n_blk_size;
+	int blk_size;
 	loff_t item_offset, offset;
 	struct reiserfs_dir_entry de;
 	int retval;
@@ -816,7 +813,7 @@ int search_for_position_by_key(struct super_block *sb,	/* Pointer to the super b
 	p_le_ih =
 	    B_N_PITEM_HEAD(PATH_PLAST_BUFFER(search_path),
 			   --PATH_LAST_POSITION(search_path));
-	n_blk_size = sb->s_blocksize;
+	blk_size = sb->s_blocksize;
 
 	if (comp_short_keys(&(p_le_ih->ih_key), p_cpu_key)) {
 		return FILE_NOT_FOUND;
@@ -828,10 +825,10 @@ int search_for_position_by_key(struct super_block *sb,	/* Pointer to the super b
 
 	/* Needed byte is contained in the item pointed to by the path. */
 	if (item_offset <= offset &&
-	    item_offset + op_bytes_number(p_le_ih, n_blk_size) > offset) {
+	    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {
 		pos_in_item(search_path) = offset - item_offset;
 		if (is_indirect_le_ih(p_le_ih)) {
-			pos_in_item(search_path) /= n_blk_size;
+			pos_in_item(search_path) /= blk_size;
 		}
 		return POSITION_FOUND;
 	}
@@ -891,7 +888,7 @@ static inline int prepare_for_direct_item(struct treepath *path,
 	if (get_inode_item_key_version(inode) == KEY_FORMAT_3_6) {
 		//
 		round_len = ROUND_UP(new_file_length);
-		/* this was n_new_file_length < le_ih ... */
+		/* this was new_file_length < le_ih ... */
 		if (round_len < le_ih_k_offset(le_ih)) {
 			*cut_size = -(IH_SIZE + ih_item_len(le_ih));
 			return M_DELETE;	/* Delete this item. */
@@ -953,7 +950,7 @@ static inline int prepare_for_direntry_item(struct treepath *path,
     This function returns a determination of what balance mode the calling function should employ. */
 static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, struct inode *inode, struct treepath *path, const struct cpu_key *item_key, int *removed,	/* Number of unformatted nodes which were removed
 																						   from end of the file. */
-				      int *cut_size, unsigned long long n_new_file_length	/* MAX_KEY_OFFSET in case of delete. */
+				      int *cut_size, unsigned long long new_file_length	/* MAX_KEY_OFFSET in case of delete. */
     )
 {
 	struct super_block *sb = inode->i_sb;
@@ -965,7 +962,7 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 	/* Stat_data item. */
 	if (is_statdata_le_ih(p_le_ih)) {
 
-		RFALSE(n_new_file_length != max_reiserfs_offset(inode),
+		RFALSE(new_file_length != max_reiserfs_offset(inode),
 		       "PAP-5210: mode must be M_DELETE");
 
 		*cut_size = -(IH_SIZE + ih_item_len(p_le_ih));
@@ -975,13 +972,13 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 	/* Directory item. */
 	if (is_direntry_le_ih(p_le_ih))
 		return prepare_for_direntry_item(path, p_le_ih, inode,
-						 n_new_file_length,
+						 new_file_length,
 						 cut_size);
 
 	/* Direct item. */
 	if (is_direct_le_ih(p_le_ih))
 		return prepare_for_direct_item(path, p_le_ih, inode,
-					       n_new_file_length, cut_size);
+					       new_file_length, cut_size);
 
 	/* Case of an indirect item. */
 	{
@@ -992,10 +989,10 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 	    int result = M_CUT;
 	    int pos = 0;
 
-	    if ( n_new_file_length == max_reiserfs_offset (inode) ) {
+	    if ( new_file_length == max_reiserfs_offset (inode) ) {
 		/* prepare_for_delete_or_cut() is called by
 		 * reiserfs_delete_item() */
-		n_new_file_length = 0;
+		new_file_length = 0;
 		delete = 1;
 	    }
 
@@ -1006,7 +1003,7 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 		copy_item_head(&s_ih, PATH_PITEM_HEAD(path));
 		pos = I_UNFM_NUM(&s_ih);
 
-		while (le_ih_k_offset (&s_ih) + (pos - 1) * blk_size > n_new_file_length) {
+		while (le_ih_k_offset (&s_ih) + (pos - 1) * blk_size > new_file_length) {
 		    __le32 *unfm;
 		    __u32 block;
 
@@ -1062,35 +1059,34 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 }
 
 /* Calculate number of bytes which will be deleted or cut during balance */
-static int calc_deleted_bytes_number(struct tree_balance *tb, char c_mode)
+static int calc_deleted_bytes_number(struct tree_balance *tb, char mode)
 {
-	int n_del_size;
+	int del_size;
 	struct item_head *p_le_ih = PATH_PITEM_HEAD(tb->tb_path);
 
 	if (is_statdata_le_ih(p_le_ih))
 		return 0;
 
-	n_del_size =
-	    (c_mode ==
+	del_size =
+	    (mode ==
 	     M_DELETE) ? ih_item_len(p_le_ih) : -tb->insert_size[0];
 	if (is_direntry_le_ih(p_le_ih)) {
-		// return EMPTY_DIR_SIZE; /* We delete emty directoris only. */
-		// we can't use EMPTY_DIR_SIZE, as old format dirs have a different
-		// empty size.  ick. FIXME, is this right?
-		//
-		return n_del_size;
+		/* return EMPTY_DIR_SIZE; We delete emty directoris only.
+		 * we can't use EMPTY_DIR_SIZE, as old format dirs have a different
+		 * empty size.  ick. FIXME, is this right? */
+		return del_size;
 	}
 
 	if (is_indirect_le_ih(p_le_ih))
-		n_del_size = (n_del_size / UNFM_P_SIZE) *
+		del_size = (del_size / UNFM_P_SIZE) *
 				(PATH_PLAST_BUFFER(tb->tb_path)->b_size);
-	return n_del_size;
+	return del_size;
 }
 
 static void init_tb_struct(struct reiserfs_transaction_handle *th,
 			   struct tree_balance *tb,
 			   struct super_block *sb,
-			   struct treepath *path, int n_size)
+			   struct treepath *path, int size)
 {
 
 	BUG_ON(!th->t_trans_id);
@@ -1101,7 +1097,7 @@ static void init_tb_struct(struct reiserfs_transaction_handle *th,
 	tb->tb_path = path;
 	PATH_OFFSET_PBUFFER(path, ILLEGAL_PATH_ELEMENT_OFFSET) = NULL;
 	PATH_OFFSET_POSITION(path, ILLEGAL_PATH_ELEMENT_OFFSET) = 0;
-	tb->insert_size[0] = n_size;
+	tb->insert_size[0] = size;
 }
 
 void padd_item(char *item, int total_length, int length)
@@ -1156,11 +1152,11 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 	struct item_head s_ih;
 	struct item_head *q_ih;
 	int quota_cut_bytes;
-	int n_ret_value, n_del_size, n_removed;
+	int ret_value, del_size, removed;
 
 #ifdef CONFIG_REISERFS_CHECK
-	char c_mode;
-	int n_iter = 0;
+	char mode;
+	int iter = 0;
 #endif
 
 	BUG_ON(!th->t_trans_id);
@@ -1169,34 +1165,34 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 		       0 /*size is unknown */ );
 
 	while (1) {
-		n_removed = 0;
+		removed = 0;
 
 #ifdef CONFIG_REISERFS_CHECK
-		n_iter++;
-		c_mode =
+		iter++;
+		mode =
 #endif
 		    prepare_for_delete_or_cut(th, inode, path,
-					      item_key, &n_removed,
-					      &n_del_size,
+					      item_key, &removed,
+					      &del_size,
 					      max_reiserfs_offset(inode));
 
-		RFALSE(c_mode != M_DELETE, "PAP-5320: mode must be M_DELETE");
+		RFALSE(mode != M_DELETE, "PAP-5320: mode must be M_DELETE");
 
 		copy_item_head(&s_ih, PATH_PITEM_HEAD(path));
-		s_del_balance.insert_size[0] = n_del_size;
+		s_del_balance.insert_size[0] = del_size;
 
-		n_ret_value = fix_nodes(M_DELETE, &s_del_balance, NULL, NULL);
-		if (n_ret_value != REPEAT_SEARCH)
+		ret_value = fix_nodes(M_DELETE, &s_del_balance, NULL, NULL);
+		if (ret_value != REPEAT_SEARCH)
 			break;
 
 		PROC_INFO_INC(sb, delete_item_restarted);
 
 		// file system changed, repeat search
-		n_ret_value =
+		ret_value =
 		    search_for_position_by_key(sb, item_key, path);
-		if (n_ret_value == IO_ERROR)
+		if (ret_value == IO_ERROR)
 			break;
-		if (n_ret_value == FILE_NOT_FOUND) {
+		if (ret_value == FILE_NOT_FOUND) {
 			reiserfs_warning(sb, "vs-5340",
 					 "no items of the file %K found",
 					 item_key);
@@ -1204,12 +1200,12 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 		}
 	}			/* while (1) */
 
-	if (n_ret_value != CARRY_ON) {
+	if (ret_value != CARRY_ON) {
 		unfix_nodes(&s_del_balance);
 		return 0;
 	}
 	// reiserfs_delete_item returns item length when success
-	n_ret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);
+	ret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);
 	q_ih = get_ih(path);
 	quota_cut_bytes = ih_item_len(q_ih);
 
@@ -1255,7 +1251,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 		off = ((le_ih_k_offset(&s_ih) - 1) & (PAGE_CACHE_SIZE - 1));
 		memcpy(data + off,
 		       B_I_PITEM(PATH_PLAST_BUFFER(path), &s_ih),
-		       n_ret_value);
+		       ret_value);
 		kunmap_atomic(data, KM_USER0);
 	}
 	/* Perform balancing after all resources have been collected at once. */
@@ -1269,7 +1265,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
 	DQUOT_FREE_SPACE_NODIRTY(inode, quota_cut_bytes);
 
 	/* Return deleted body length */
-	return n_ret_value;
+	return ret_value;
 }
 
 /* Summary Of Mechanisms For Handling Collisions Between Processes:
@@ -1432,13 +1428,13 @@ static int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,
 				    struct page *page,
 				    struct treepath *path,
 				    const struct cpu_key *item_key,
-				    loff_t n_new_file_size, char *mode)
+				    loff_t new_file_size, char *mode)
 {
 	struct super_block *sb = inode->i_sb;
-	int n_block_size = sb->s_blocksize;
+	int block_size = sb->s_blocksize;
 	int cut_bytes;
 	BUG_ON(!th->t_trans_id);
-	BUG_ON(n_new_file_size != inode->i_size);
+	BUG_ON(new_file_size != inode->i_size);
 
 	/* the page being sent in could be NULL if there was an i/o error
 	 ** reading in the last block.  The user will hit problems trying to
@@ -1450,15 +1446,15 @@ static int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,
 		/* leave tail in an unformatted node */
 		*mode = M_SKIP_BALANCING;
 		cut_bytes =
-		    n_block_size - (n_new_file_size & (n_block_size - 1));
+		    block_size - (new_file_size & (block_size - 1));
 		pathrelse(path);
 		return cut_bytes;
 	}
 	/* Perform the conversion to a direct_item. */
 	/* return indirect_to_direct(inode, path, item_key,
-				  n_new_file_size, mode); */
+				  new_file_size, mode); */
 	return indirect2direct(th, inode, page, path, item_key,
-			       n_new_file_size, mode);
+			       new_file_size, mode);
 }
 
 /* we did indirect_to_direct conversion. And we have inserted direct
@@ -1512,7 +1508,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 			   struct treepath *path,
 			   struct cpu_key *item_key,
 			   struct inode *inode,
-			   struct page *page, loff_t n_new_file_size)
+			   struct page *page, loff_t new_file_size)
 {
 	struct super_block *sb = inode->i_sb;
 	/* Every function which is going to call do_balance must first
@@ -1521,10 +1517,10 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 	   After that we can make tree balancing. */
 	struct tree_balance s_cut_balance;
 	struct item_head *p_le_ih;
-	int n_cut_size = 0,	/* Amount to be cut. */
-	    n_ret_value = CARRY_ON, n_removed = 0,	/* Number of the removed unformatted nodes. */
-	    n_is_inode_locked = 0;
-	char c_mode;		/* Mode of the balance. */
+	int cut_size = 0,	/* Amount to be cut. */
+	    ret_value = CARRY_ON, removed = 0,	/* Number of the removed unformatted nodes. */
+	    is_inode_locked = 0;
+	char mode;		/* Mode of the balance. */
 	int retval2 = -1;
 	int quota_cut_bytes;
 	loff_t tail_pos = 0;
@@ -1532,7 +1528,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 	BUG_ON(!th->t_trans_id);
 
 	init_tb_struct(th, &s_cut_balance, inode->i_sb, path,
-		       n_cut_size);
+		       cut_size);
 
 	/* Repeat this loop until we either cut the item without needing
 	   to balance, or we fix_nodes without schedule occurring */
@@ -1542,30 +1538,30 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		   free unformatted nodes which are pointed to by the cut
 		   pointers. */
 
-		c_mode =
+		mode =
 		    prepare_for_delete_or_cut(th, inode, path,
-					      item_key, &n_removed,
-					      &n_cut_size, n_new_file_size);
-		if (c_mode == M_CONVERT) {
+					      item_key, &removed,
+					      &cut_size, new_file_size);
+		if (mode == M_CONVERT) {
 			/* convert last unformatted node to direct item or leave
 			   tail in the unformatted node */
-			RFALSE(n_ret_value != CARRY_ON,
+			RFALSE(ret_value != CARRY_ON,
 			       "PAP-5570: can not convert twice");
 
-			n_ret_value =
+			ret_value =
 			    maybe_indirect_to_direct(th, inode, page,
 						     path, item_key,
-						     n_new_file_size, &c_mode);
-			if (c_mode == M_SKIP_BALANCING)
+						     new_file_size, &mode);
+			if (mode == M_SKIP_BALANCING)
 				/* tail has been left in the unformatted node */
-				return n_ret_value;
+				return ret_value;
 
-			n_is_inode_locked = 1;
+			is_inode_locked = 1;
 
 			/* removing of last unformatted node will change value we
 			   have to return to truncate. Save it */
-			retval2 = n_ret_value;
-			/*retval2 = sb->s_blocksize - (n_new_file_size & (sb->s_blocksize - 1)); */
+			retval2 = ret_value;
+			/*retval2 = sb->s_blocksize - (new_file_size & (sb->s_blocksize - 1)); */
 
 			/* So, we have performed the first part of the conversion:
 			   inserting the new direct item.  Now we are removing the
@@ -1573,10 +1569,10 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 			   it. */
 			set_cpu_key_k_type(item_key, TYPE_INDIRECT);
 			item_key->key_length = 4;
-			n_new_file_size -=
-			    (n_new_file_size & (sb->s_blocksize - 1));
-			tail_pos = n_new_file_size;
-			set_cpu_key_k_offset(item_key, n_new_file_size + 1);
+			new_file_size -=
+			    (new_file_size & (sb->s_blocksize - 1));
+			tail_pos = new_file_size;
+			set_cpu_key_k_offset(item_key, new_file_size + 1);
 			if (search_for_position_by_key
 			    (sb, item_key,
 			     path) == POSITION_NOT_FOUND) {
@@ -1589,38 +1585,38 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 			}
 			continue;
 		}
-		if (n_cut_size == 0) {
+		if (cut_size == 0) {
 			pathrelse(path);
 			return 0;
 		}
 
-		s_cut_balance.insert_size[0] = n_cut_size;
+		s_cut_balance.insert_size[0] = cut_size;
 
-		n_ret_value = fix_nodes(c_mode, &s_cut_balance, NULL, NULL);
-		if (n_ret_value != REPEAT_SEARCH)
+		ret_value = fix_nodes(mode, &s_cut_balance, NULL, NULL);
+		if (ret_value != REPEAT_SEARCH)
 			break;
 
 		PROC_INFO_INC(sb, cut_from_item_restarted);
 
-		n_ret_value =
+		ret_value =
 		    search_for_position_by_key(sb, item_key, path);
-		if (n_ret_value == POSITION_FOUND)
+		if (ret_value == POSITION_FOUND)
 			continue;
 
 		reiserfs_warning(sb, "PAP-5610", "item %K not found",
 				 item_key);
 		unfix_nodes(&s_cut_balance);
-		return (n_ret_value == IO_ERROR) ? -EIO : -ENOENT;
+		return (ret_value == IO_ERROR) ? -EIO : -ENOENT;
 	}			/* while */
 
 	// check fix_nodes results (IO_ERROR or NO_DISK_SPACE)
-	if (n_ret_value != CARRY_ON) {
-		if (n_is_inode_locked) {
+	if (ret_value != CARRY_ON) {
+		if (is_inode_locked) {
 			// FIXME: this seems to be not needed: we are always able
 			// to cut item
 			indirect_to_direct_roll_back(th, inode, path);
 		}
-		if (n_ret_value == NO_DISK_SPACE)
+		if (ret_value == NO_DISK_SPACE)
 			reiserfs_warning(sb, "reiserfs-5092",
 					 "NO_DISK_SPACE");
 		unfix_nodes(&s_cut_balance);
@@ -1629,24 +1625,24 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 
 	/* go ahead and perform balancing */
 
-	RFALSE(c_mode == M_PASTE || c_mode == M_INSERT, "invalid mode");
+	RFALSE(mode == M_PASTE || mode == M_INSERT, "invalid mode");
 
 	/* Calculate number of bytes that need to be cut from the item. */
 	quota_cut_bytes =
-	    (c_mode ==
+	    (mode ==
 	     M_DELETE) ? ih_item_len(get_ih(path)) : -s_cut_balance.
 	    insert_size[0];
 	if (retval2 == -1)
-		n_ret_value = calc_deleted_bytes_number(&s_cut_balance, c_mode);
+		ret_value = calc_deleted_bytes_number(&s_cut_balance, mode);
 	else
-		n_ret_value = retval2;
+		ret_value = retval2;
 
 	/* For direct items, we only change the quota when deleting the last
 	 ** item.
 	 */
 	p_le_ih = PATH_PITEM_HEAD(s_cut_balance.tb_path);
 	if (!S_ISLNK(inode->i_mode) && is_direct_le_ih(p_le_ih)) {
-		if (c_mode == M_DELETE &&
+		if (mode == M_DELETE &&
 		    (le_ih_k_offset(p_le_ih) & (sb->s_blocksize - 1)) ==
 		    1) {
 			// FIXME: this is to keep 3.5 happy
@@ -1657,7 +1653,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		}
 	}
 #ifdef CONFIG_REISERFS_CHECK
-	if (n_is_inode_locked) {
+	if (is_inode_locked) {
 		struct item_head *le_ih =
 		    PATH_PITEM_HEAD(s_cut_balance.tb_path);
 		/* we are going to complete indirect2direct conversion. Make
@@ -1667,13 +1663,13 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 			reiserfs_panic(sb, "vs-5652",
 				       "item must be indirect %h", le_ih);
 
-		if (c_mode == M_DELETE && ih_item_len(le_ih) != UNFM_P_SIZE)
+		if (mode == M_DELETE && ih_item_len(le_ih) != UNFM_P_SIZE)
 			reiserfs_panic(sb, "vs-5653", "completing "
 				       "indirect2direct conversion indirect "
 				       "item %h being deleted must be of "
 				       "4 byte long", le_ih);
 
-		if (c_mode == M_CUT
+		if (mode == M_CUT
 		    && s_cut_balance.insert_size[0] != -UNFM_P_SIZE) {
 			reiserfs_panic(sb, "vs-5654", "can not complete "
 				       "indirect2direct conversion of %h "
@@ -1685,8 +1681,8 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 	}
 #endif
 
-	do_balance(&s_cut_balance, NULL, NULL, c_mode);
-	if (n_is_inode_locked) {
+	do_balance(&s_cut_balance, NULL, NULL, mode);
+	if (is_inode_locked) {
 		/* we've done an indirect->direct conversion.  when the data block
 		 ** was freed, it was removed from the list of blocks that must
 		 ** be flushed before the transaction commits, make sure to
@@ -1701,7 +1697,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		       quota_cut_bytes, inode->i_uid, '?');
 #endif
 	DQUOT_FREE_SPACE_NODIRTY(inode, quota_cut_bytes);
-	return n_ret_value;
+	return ret_value;
 }
 
 static void truncate_directory(struct reiserfs_transaction_handle *th,
@@ -1733,9 +1729,9 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 	INITIALIZE_PATH(s_search_path);	/* Path to the current object item. */
 	struct item_head *p_le_ih;	/* Pointer to an item header. */
 	struct cpu_key s_item_key;	/* Key to search for a previous file item. */
-	loff_t n_file_size,	/* Old file size. */
-	 n_new_file_size;	/* New file size. */
-	int n_deleted;		/* Number of deleted or truncated bytes. */
+	loff_t file_size,	/* Old file size. */
+	 new_file_size;	/* New file size. */
+	int deleted;		/* Number of deleted or truncated bytes. */
 	int retval;
 	int err = 0;
 
@@ -1752,7 +1748,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 	}
 
 	/* Get new file size. */
-	n_new_file_size = inode->i_size;
+	new_file_size = inode->i_size;
 
 	// FIXME: note, that key type is unimportant here
 	make_cpu_key(&s_item_key, inode, max_reiserfs_offset(inode),
@@ -1782,7 +1778,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 	/* Get real file size (total length of all file items) */
 	p_le_ih = PATH_PITEM_HEAD(&s_search_path);
 	if (is_statdata_le_ih(p_le_ih))
-		n_file_size = 0;
+		file_size = 0;
 	else {
 		loff_t offset = le_ih_k_offset(p_le_ih);
 		int bytes =
@@ -1791,42 +1787,42 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 		/* this may mismatch with real file size: if last direct item
 		   had no padding zeros and last unformatted node had no free
 		   space, this file would have this file size */
-		n_file_size = offset + bytes - 1;
+		file_size = offset + bytes - 1;
 	}
 	/*
 	 * are we doing a full truncate or delete, if so
 	 * kick in the reada code
 	 */
-	if (n_new_file_size == 0)
+	if (new_file_size == 0)
 		s_search_path.reada = PATH_READA | PATH_READA_BACK;
 
-	if (n_file_size == 0 || n_file_size < n_new_file_size) {
+	if (file_size == 0 || file_size < new_file_size) {
 		goto update_and_out;
 	}
 
 	/* Update key to search for the last file item. */
-	set_cpu_key_k_offset(&s_item_key, n_file_size);
+	set_cpu_key_k_offset(&s_item_key, file_size);
 
 	do {
 		/* Cut or delete file item. */
-		n_deleted =
+		deleted =
 		    reiserfs_cut_from_item(th, &s_search_path, &s_item_key,
-					   inode, page, n_new_file_size);
-		if (n_deleted < 0) {
+					   inode, page, new_file_size);
+		if (deleted < 0) {
 			reiserfs_warning(inode->i_sb, "vs-5665",
 					 "reiserfs_cut_from_item failed");
 			reiserfs_check_path(&s_search_path);
 			return 0;
 		}
 
-		RFALSE(n_deleted > n_file_size,
+		RFALSE(deleted > file_size,
 		       "PAP-5670: reiserfs_cut_from_item: too many bytes deleted: deleted %d, file_size %lu, item_key %K",
-		       n_deleted, n_file_size, &s_item_key);
+		       deleted, file_size, &s_item_key);
 
 		/* Change key to search the last file item. */
-		n_file_size -= n_deleted;
+		file_size -= deleted;
 
-		set_cpu_key_k_offset(&s_item_key, n_file_size);
+		set_cpu_key_k_offset(&s_item_key, file_size);
 
 		/* While there are bytes to truncate and previous file item is presented in the tree. */
 
@@ -1857,13 +1853,13 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 				goto out;
 			reiserfs_update_inode_transaction(inode);
 		}
-	} while (n_file_size > ROUND_UP(n_new_file_size) &&
+	} while (file_size > ROUND_UP(new_file_size) &&
 		 search_for_position_by_key(inode->i_sb, &s_item_key,
 					    &s_search_path) == POSITION_FOUND);
 
-	RFALSE(n_file_size > ROUND_UP(n_new_file_size),
+	RFALSE(file_size > ROUND_UP(new_file_size),
 	       "PAP-5680: truncate did not finish: new_file_size %Ld, current %Ld, oid %d",
-	       n_new_file_size, n_file_size, s_item_key.on_disk_key.k_objectid);
+	       new_file_size, file_size, s_item_key.on_disk_key.k_objectid);
 
       update_and_out:
 	if (update_timestamps) {
@@ -1918,7 +1914,7 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 			     const struct cpu_key *key,	/* Key to search for the needed item. */
 			     struct inode *inode,	/* Inode item belongs to */
 			     const char *body,	/* Pointer to the bytes to paste.    */
-			     int n_pasted_size)
+			     int pasted_size)
 {				/* Size of pasted bytes.             */
 	struct tree_balance s_paste_balance;
 	int retval;
@@ -1931,16 +1927,16 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 #ifdef REISERQUOTA_DEBUG
 	reiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,
 		       "reiserquota paste_into_item(): allocating %u id=%u type=%c",
-		       n_pasted_size, inode->i_uid,
+		       pasted_size, inode->i_uid,
 		       key2type(&(key->on_disk_key)));
 #endif
 
-	if (DQUOT_ALLOC_SPACE_NODIRTY(inode, n_pasted_size)) {
+	if (DQUOT_ALLOC_SPACE_NODIRTY(inode, pasted_size)) {
 		pathrelse(search_path);
 		return -EDQUOT;
 	}
 	init_tb_struct(th, &s_paste_balance, th->t_super, search_path,
-		       n_pasted_size);
+		       pasted_size);
 #ifdef DISPLACE_NEW_PACKING_LOCALITIES
 	s_paste_balance.key = key->on_disk_key;
 #endif
@@ -1988,10 +1984,10 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 #ifdef REISERQUOTA_DEBUG
 	reiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,
 		       "reiserquota paste_into_item(): freeing %u id=%u type=%c",
-		       n_pasted_size, inode->i_uid,
+		       pasted_size, inode->i_uid,
 		       key2type(&(key->on_disk_key)));
 #endif
-	DQUOT_FREE_SPACE_NODIRTY(inode, n_pasted_size);
+	DQUOT_FREE_SPACE_NODIRTY(inode, pasted_size);
 	return retval;
 }
 

commit d68caa9530a8ba54f97002e02bf6a0ad2462b8c0
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:49 2009 -0400

    reiserfs: rename p_._ variables
    
    This patch is a simple s/p_._//g to the reiserfs code.  This is the
    fifth in a series of patches to rip out some of the awful variable
    naming in reiserfs.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 5e867be559ea..fd769c8dac32 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -68,10 +68,10 @@ inline int B_IS_IN_TREE(const struct buffer_head *bh)
 //
 // to gets item head in le form
 //
-inline void copy_item_head(struct item_head *p_v_to,
-			   const struct item_head *p_v_from)
+inline void copy_item_head(struct item_head *to,
+			   const struct item_head *from)
 {
-	memcpy(p_v_to, p_v_from, IH_SIZE);
+	memcpy(to, from, IH_SIZE);
 }
 
 /* k1 is pointer to on-disk structure which is stored in little-endian
@@ -135,15 +135,15 @@ static inline int comp_keys(const struct reiserfs_key *le_key,
 inline int comp_short_le_keys(const struct reiserfs_key *key1,
 			      const struct reiserfs_key *key2)
 {
-	__u32 *p_s_1_u32, *p_s_2_u32;
+	__u32 *k1_u32, *k2_u32;
 	int n_key_length = REISERFS_SHORT_KEY_LEN;
 
-	p_s_1_u32 = (__u32 *) key1;
-	p_s_2_u32 = (__u32 *) key2;
-	for (; n_key_length--; ++p_s_1_u32, ++p_s_2_u32) {
-		if (le32_to_cpu(*p_s_1_u32) < le32_to_cpu(*p_s_2_u32))
+	k1_u32 = (__u32 *) key1;
+	k2_u32 = (__u32 *) key2;
+	for (; n_key_length--; ++k1_u32, ++k2_u32) {
+		if (le32_to_cpu(*k1_u32) < le32_to_cpu(*k2_u32))
 			return -1;
-		if (le32_to_cpu(*p_s_1_u32) > le32_to_cpu(*p_s_2_u32))
+		if (le32_to_cpu(*k1_u32) > le32_to_cpu(*k2_u32))
 			return 1;
 	}
 	return 0;
@@ -174,8 +174,8 @@ inline int comp_le_keys(const struct reiserfs_key *k1,
  *  Binary search toolkit function                                        *
  *  Search for an item in the array by the item key                       *
  *  Returns:    1 if found,  0 if not found;                              *
- *        *p_n_pos = number of the searched element if found, else the    *
- *        number of the first element that is larger than p_v_key.        *
+ *        *pos = number of the searched element if found, else the        *
+ *        number of the first element that is larger than key.            *
  **************************************************************************/
 /* For those not familiar with binary search: n_lbound is the leftmost item that it
  could be, n_rbound the rightmost item that it could be.  We examine the item
@@ -184,28 +184,28 @@ inline int comp_le_keys(const struct reiserfs_key *k1,
  there are no possible items, and we have not found it. With each examination we
  cut the number of possible items it could be by one more than half rounded down,
  or we find it. */
-static inline int bin_search(const void *p_v_key,	/* Key to search for.                   */
-			     const void *p_v_base,	/* First item in the array.             */
-			     int p_n_num,	/* Number of items in the array.        */
-			     int p_n_width,	/* Item size in the array.
-						   searched. Lest the reader be
-						   confused, note that this is crafted
-						   as a general function, and when it
-						   is applied specifically to the array
-						   of item headers in a node, p_n_width
-						   is actually the item header size not
-						   the item size.                      */
-			     int *p_n_pos	/* Number of the searched for element. */
+static inline int bin_search(const void *key,	/* Key to search for. */
+			     const void *base,	/* First item in the array. */
+			     int num,	/* Number of items in the array. */
+			     int width,	/* Item size in the array.
+					   searched. Lest the reader be
+					   confused, note that this is crafted
+					   as a general function, and when it
+					   is applied specifically to the array
+					   of item headers in a node, width
+					   is actually the item header size not
+					   the item size. */
+			     int *pos /* Number of the searched for element. */
     )
 {
 	int n_rbound, n_lbound, n_j;
 
-	for (n_j = ((n_rbound = p_n_num - 1) + (n_lbound = 0)) / 2;
+	for (n_j = ((n_rbound = num - 1) + (n_lbound = 0)) / 2;
 	     n_lbound <= n_rbound; n_j = (n_rbound + n_lbound) / 2)
 		switch (comp_keys
-			((struct reiserfs_key *)((char *)p_v_base +
-						 n_j * p_n_width),
-			 (struct cpu_key *)p_v_key)) {
+			((struct reiserfs_key *)((char *)base +
+						 n_j * width),
+			 (struct cpu_key *)key)) {
 		case -1:
 			n_lbound = n_j + 1;
 			continue;
@@ -213,13 +213,13 @@ static inline int bin_search(const void *p_v_key,	/* Key to search for.
 			n_rbound = n_j - 1;
 			continue;
 		case 0:
-			*p_n_pos = n_j;
+			*pos = n_j;
 			return ITEM_FOUND;	/* Key found in the array.  */
 		}
 
 	/* bin_search did not find given key, it returns position of key,
 	   that is minimal and greater than the given one. */
-	*p_n_pos = n_lbound;
+	*pos = n_lbound;
 	return ITEM_NOT_FOUND;
 }
 
@@ -243,12 +243,12 @@ static const struct reiserfs_key MAX_KEY = {
    the path, there is no delimiting key in the tree (buffer is first or last buffer in tree), and in this
    case we return a special key, either MIN_KEY or MAX_KEY. */
 static inline const struct reiserfs_key *get_lkey(const struct treepath
-						  *p_s_chk_path,
+						  *chk_path,
 						  const struct super_block
 						  *sb)
 {
-	int n_position, n_path_offset = p_s_chk_path->path_length;
-	struct buffer_head *p_s_parent;
+	int n_position, n_path_offset = chk_path->path_length;
+	struct buffer_head *parent;
 
 	RFALSE(n_path_offset < FIRST_PATH_ELEMENT_OFFSET,
 	       "PAP-5010: invalid offset in the path");
@@ -257,42 +257,42 @@ static inline const struct reiserfs_key *get_lkey(const struct treepath
 	while (n_path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {
 
 		RFALSE(!buffer_uptodate
-		       (PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)),
+		       (PATH_OFFSET_PBUFFER(chk_path, n_path_offset)),
 		       "PAP-5020: parent is not uptodate");
 
 		/* Parent at the path is not in the tree now. */
 		if (!B_IS_IN_TREE
-		    (p_s_parent =
-		     PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)))
+		    (parent =
+		     PATH_OFFSET_PBUFFER(chk_path, n_path_offset)))
 			return &MAX_KEY;
 		/* Check whether position in the parent is correct. */
 		if ((n_position =
-		     PATH_OFFSET_POSITION(p_s_chk_path,
+		     PATH_OFFSET_POSITION(chk_path,
 					  n_path_offset)) >
-		    B_NR_ITEMS(p_s_parent))
+		    B_NR_ITEMS(parent))
 			return &MAX_KEY;
 		/* Check whether parent at the path really points to the child. */
-		if (B_N_CHILD_NUM(p_s_parent, n_position) !=
-		    PATH_OFFSET_PBUFFER(p_s_chk_path,
+		if (B_N_CHILD_NUM(parent, n_position) !=
+		    PATH_OFFSET_PBUFFER(chk_path,
 					n_path_offset + 1)->b_blocknr)
 			return &MAX_KEY;
 		/* Return delimiting key if position in the parent is not equal to zero. */
 		if (n_position)
-			return B_N_PDELIM_KEY(p_s_parent, n_position - 1);
+			return B_N_PDELIM_KEY(parent, n_position - 1);
 	}
 	/* Return MIN_KEY if we are in the root of the buffer tree. */
-	if (PATH_OFFSET_PBUFFER(p_s_chk_path, FIRST_PATH_ELEMENT_OFFSET)->
+	if (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->
 	    b_blocknr == SB_ROOT_BLOCK(sb))
 		return &MIN_KEY;
 	return &MAX_KEY;
 }
 
 /* Get delimiting key of the buffer at the path and its right neighbor. */
-inline const struct reiserfs_key *get_rkey(const struct treepath *p_s_chk_path,
+inline const struct reiserfs_key *get_rkey(const struct treepath *chk_path,
 					   const struct super_block *sb)
 {
-	int n_position, n_path_offset = p_s_chk_path->path_length;
-	struct buffer_head *p_s_parent;
+	int n_position, n_path_offset = chk_path->path_length;
+	struct buffer_head *parent;
 
 	RFALSE(n_path_offset < FIRST_PATH_ELEMENT_OFFSET,
 	       "PAP-5030: invalid offset in the path");
@@ -300,31 +300,31 @@ inline const struct reiserfs_key *get_rkey(const struct treepath *p_s_chk_path,
 	while (n_path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {
 
 		RFALSE(!buffer_uptodate
-		       (PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)),
+		       (PATH_OFFSET_PBUFFER(chk_path, n_path_offset)),
 		       "PAP-5040: parent is not uptodate");
 
 		/* Parent at the path is not in the tree now. */
 		if (!B_IS_IN_TREE
-		    (p_s_parent =
-		     PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)))
+		    (parent =
+		     PATH_OFFSET_PBUFFER(chk_path, n_path_offset)))
 			return &MIN_KEY;
 		/* Check whether position in the parent is correct. */
 		if ((n_position =
-		     PATH_OFFSET_POSITION(p_s_chk_path,
+		     PATH_OFFSET_POSITION(chk_path,
 					  n_path_offset)) >
-		    B_NR_ITEMS(p_s_parent))
+		    B_NR_ITEMS(parent))
 			return &MIN_KEY;
 		/* Check whether parent at the path really points to the child. */
-		if (B_N_CHILD_NUM(p_s_parent, n_position) !=
-		    PATH_OFFSET_PBUFFER(p_s_chk_path,
+		if (B_N_CHILD_NUM(parent, n_position) !=
+		    PATH_OFFSET_PBUFFER(chk_path,
 					n_path_offset + 1)->b_blocknr)
 			return &MIN_KEY;
 		/* Return delimiting key if position in the parent is not the last one. */
-		if (n_position != B_NR_ITEMS(p_s_parent))
-			return B_N_PDELIM_KEY(p_s_parent, n_position);
+		if (n_position != B_NR_ITEMS(parent))
+			return B_N_PDELIM_KEY(parent, n_position);
 	}
 	/* Return MAX_KEY if we are in the root of the buffer tree. */
-	if (PATH_OFFSET_PBUFFER(p_s_chk_path, FIRST_PATH_ELEMENT_OFFSET)->
+	if (PATH_OFFSET_PBUFFER(chk_path, FIRST_PATH_ELEMENT_OFFSET)->
 	    b_blocknr == SB_ROOT_BLOCK(sb))
 		return &MAX_KEY;
 	return &MIN_KEY;
@@ -335,25 +335,25 @@ inline const struct reiserfs_key *get_rkey(const struct treepath *p_s_chk_path,
    the path.  These delimiting keys are stored at least one level above that buffer in the tree. If the
    buffer is the first or last node in the tree order then one of the delimiting keys may be absent, and in
    this case get_lkey and get_rkey return a special key which is MIN_KEY or MAX_KEY. */
-static inline int key_in_buffer(struct treepath *p_s_chk_path,	/* Path which should be checked.  */
-				const struct cpu_key *p_s_key,	/* Key which should be checked.   */
-				struct super_block *sb	/* Super block pointer.	   */
+static inline int key_in_buffer(struct treepath *chk_path,	/* Path which should be checked.  */
+				const struct cpu_key *key,	/* Key which should be checked.   */
+				struct super_block *sb
     )
 {
 
-	RFALSE(!p_s_key || p_s_chk_path->path_length < FIRST_PATH_ELEMENT_OFFSET
-	       || p_s_chk_path->path_length > MAX_HEIGHT,
+	RFALSE(!key || chk_path->path_length < FIRST_PATH_ELEMENT_OFFSET
+	       || chk_path->path_length > MAX_HEIGHT,
 	       "PAP-5050: pointer to the key(%p) is NULL or invalid path length(%d)",
-	       p_s_key, p_s_chk_path->path_length);
-	RFALSE(!PATH_PLAST_BUFFER(p_s_chk_path)->b_bdev,
+	       key, chk_path->path_length);
+	RFALSE(!PATH_PLAST_BUFFER(chk_path)->b_bdev,
 	       "PAP-5060: device must not be NODEV");
 
-	if (comp_keys(get_lkey(p_s_chk_path, sb), p_s_key) == 1)
+	if (comp_keys(get_lkey(chk_path, sb), key) == 1)
 		/* left delimiting key is bigger, that the key we look for */
 		return 0;
-	//  if ( comp_keys(p_s_key, get_rkey(p_s_chk_path, sb)) != -1 )
-	if (comp_keys(get_rkey(p_s_chk_path, sb), p_s_key) != 1)
-		/* p_s_key must be less than right delimitiing key */
+	/*  if ( comp_keys(key, get_rkey(chk_path, sb)) != -1 ) */
+	if (comp_keys(get_rkey(chk_path, sb), key) != 1)
+		/* key must be less than right delimitiing key */
 		return 0;
 	return 1;
 }
@@ -369,34 +369,34 @@ int reiserfs_check_path(struct treepath *p)
  * dirty bits clean when preparing the buffer for the log.
  * This version should only be called from fix_nodes() */
 void pathrelse_and_restore(struct super_block *sb,
-			   struct treepath *p_s_search_path)
+			   struct treepath *search_path)
 {
-	int n_path_offset = p_s_search_path->path_length;
+	int n_path_offset = search_path->path_length;
 
 	RFALSE(n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,
 	       "clm-4000: invalid path offset");
 
 	while (n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {
 		struct buffer_head *bh;
-		bh = PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--);
+		bh = PATH_OFFSET_PBUFFER(search_path, n_path_offset--);
 		reiserfs_restore_prepared_buffer(sb, bh);
 		brelse(bh);
 	}
-	p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
+	search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
 }
 
 /* Drop the reference to each buffer in a path */
-void pathrelse(struct treepath *p_s_search_path)
+void pathrelse(struct treepath *search_path)
 {
-	int n_path_offset = p_s_search_path->path_length;
+	int n_path_offset = search_path->path_length;
 
 	RFALSE(n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,
 	       "PAP-5090: invalid path offset");
 
 	while (n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)
-		brelse(PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--));
+		brelse(PATH_OFFSET_PBUFFER(search_path, n_path_offset--));
 
-	p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
+	search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
 }
 
 static int is_leaf(char *buf, int blocksize, struct buffer_head *bh)
@@ -547,9 +547,9 @@ static void search_by_key_reada(struct super_block *s,
  * Algorithm   SearchByKey                                                *
  *             look for item in the Disk S+Tree by its key                *
  * Input:  sb   -  super block                                            *
- *         p_s_key  - pointer to the key to search                        *
+ *         key  - pointer to the key to search                            *
  * Output: ITEM_FOUND, ITEM_NOT_FOUND or IO_ERROR                         *
- *         p_s_search_path - path from the root to the needed leaf        *
+ *         search_path - path from the root to the needed leaf            *
  **************************************************************************/
 
 /* This function fills up the path from the root to the leaf as it
@@ -566,8 +566,8 @@ static void search_by_key_reada(struct super_block *s,
    correctness of the top of the path but need not be checked for the
    correctness of the bottom of the path */
 /* The function is NOT SCHEDULE-SAFE! */
-int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key to search. */
-		  struct treepath *p_s_search_path,/* This structure was
+int search_by_key(struct super_block *sb, const struct cpu_key *key,	/* Key to search. */
+		  struct treepath *search_path,/* This structure was
 						   allocated and initialized
 						   by the calling
 						   function. It is filled up
@@ -580,7 +580,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 	b_blocknr_t n_block_number;
 	int expected_level;
 	struct buffer_head *bh;
-	struct path_element *p_s_last_element;
+	struct path_element *last_element;
 	int n_node_level, n_retval;
 	int right_neighbor_of_leaf_node;
 	int fs_gen;
@@ -598,7 +598,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 	   we must be careful to release all nodes in a path before we either
 	   discard the path struct or re-use the path struct, as we do here. */
 
-	pathrelse(p_s_search_path);
+	pathrelse(search_path);
 
 	right_neighbor_of_leaf_node = 0;
 
@@ -615,18 +615,18 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 					 "%s: there were %d iterations of "
 					 "while loop looking for key %K",
 					 current->comm, n_repeat_counter,
-					 p_s_key);
+					 key);
 #endif
 
 		/* prep path to have another element added to it. */
-		p_s_last_element =
-		    PATH_OFFSET_PELEMENT(p_s_search_path,
-					 ++p_s_search_path->path_length);
+		last_element =
+		    PATH_OFFSET_PELEMENT(search_path,
+					 ++search_path->path_length);
 		fs_gen = get_generation(sb);
 
 		/* Read the next tree node, and set the last element in the path to
 		   have a pointer to it. */
-		if ((bh = p_s_last_element->pe_buffer =
+		if ((bh = last_element->pe_buffer =
 		     sb_getblk(sb, n_block_number))) {
 			if (!buffer_uptodate(bh) && reada_count > 1)
 				search_by_key_reada(sb, reada_bh,
@@ -637,8 +637,8 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 				goto io_error;
 		} else {
 		      io_error:
-			p_s_search_path->path_length--;
-			pathrelse(p_s_search_path);
+			search_path->path_length--;
+			pathrelse(search_path);
 			return IO_ERROR;
 		}
 		reada_count = 0;
@@ -652,12 +652,12 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 		if (fs_changed(fs_gen, sb) &&
 		    (!B_IS_IN_TREE(bh) ||
 		     B_LEVEL(bh) != expected_level ||
-		     !key_in_buffer(p_s_search_path, p_s_key, sb))) {
+		     !key_in_buffer(search_path, key, sb))) {
 			PROC_INFO_INC(sb, search_by_key_fs_changed);
 			PROC_INFO_INC(sb, search_by_key_restarted);
 			PROC_INFO_INC(sb,
 				      sbk_restarted[expected_level - 1]);
-			pathrelse(p_s_search_path);
+			pathrelse(search_path);
 
 			/* Get the root block number so that we can repeat the search
 			   starting from the root. */
@@ -669,11 +669,11 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 			continue;
 		}
 
-		/* only check that the key is in the buffer if p_s_key is not
+		/* only check that the key is in the buffer if key is not
 		   equal to the MAX_KEY. Latter case is only possible in
 		   "finish_unfinished()" processing during mount. */
-		RFALSE(comp_keys(&MAX_KEY, p_s_key) &&
-		       !key_in_buffer(p_s_search_path, p_s_key, sb),
+		RFALSE(comp_keys(&MAX_KEY, key) &&
+		       !key_in_buffer(search_path, key, sb),
 		       "PAP-5130: key is not in the buffer");
 #ifdef CONFIG_REISERFS_CHECK
 		if (cur_tb) {
@@ -689,7 +689,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 			reiserfs_error(sb, "vs-5150",
 				       "invalid format found in block %ld. "
 				       "Fsck?", bh->b_blocknr);
-			pathrelse(p_s_search_path);
+			pathrelse(search_path);
 			return IO_ERROR;
 		}
 
@@ -702,12 +702,12 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 		       "vs-5152: tree level (%d) is less than stop level (%d)",
 		       n_node_level, n_stop_level);
 
-		n_retval = bin_search(p_s_key, B_N_PITEM_HEAD(bh, 0),
+		n_retval = bin_search(key, B_N_PITEM_HEAD(bh, 0),
 				      B_NR_ITEMS(bh),
 				      (n_node_level ==
 				       DISK_LEAF_NODE_LEVEL) ? IH_SIZE :
 				      KEY_SIZE,
-				      &(p_s_last_element->pe_position));
+				      &(last_element->pe_position));
 		if (n_node_level == n_stop_level) {
 			return n_retval;
 		}
@@ -715,7 +715,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 		/* we are not in the stop level */
 		if (n_retval == ITEM_FOUND)
 			/* item has been found, so we choose the pointer which is to the right of the found one */
-			p_s_last_element->pe_position++;
+			last_element->pe_position++;
 
 		/* if item was not found we choose the position which is to
 		   the left of the found item. This requires no code,
@@ -725,23 +725,23 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 		   an internal node.  Now we calculate child block number by
 		   position in the node. */
 		n_block_number =
-		    B_N_CHILD_NUM(bh, p_s_last_element->pe_position);
+		    B_N_CHILD_NUM(bh, last_element->pe_position);
 
 		/* if we are going to read leaf nodes, try for read ahead as well */
-		if ((p_s_search_path->reada & PATH_READA) &&
+		if ((search_path->reada & PATH_READA) &&
 		    n_node_level == DISK_LEAF_NODE_LEVEL + 1) {
-			int pos = p_s_last_element->pe_position;
+			int pos = last_element->pe_position;
 			int limit = B_NR_ITEMS(bh);
 			struct reiserfs_key *le_key;
 
-			if (p_s_search_path->reada & PATH_READA_BACK)
+			if (search_path->reada & PATH_READA_BACK)
 				limit = 0;
 			while (reada_count < SEARCH_BY_KEY_READA) {
 				if (pos == limit)
 					break;
 				reada_blocks[reada_count++] =
 				    B_N_CHILD_NUM(bh, pos);
-				if (p_s_search_path->reada & PATH_READA_BACK)
+				if (search_path->reada & PATH_READA_BACK)
 					pos--;
 				else
 					pos++;
@@ -751,7 +751,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 				 */
 				le_key = B_N_PDELIM_KEY(bh, pos);
 				if (le32_to_cpu(le_key->k_objectid) !=
-				    p_s_key->on_disk_key.k_objectid) {
+				    key->on_disk_key.k_objectid) {
 					break;
 				}
 			}
@@ -760,11 +760,11 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 }
 
 /* Form the path to an item and position in this item which contains
-   file byte defined by p_s_key. If there is no such item
+   file byte defined by key. If there is no such item
    corresponding to the key, we point the path to the item with
-   maximal key less than p_s_key, and *p_n_pos_in_item is set to one
+   maximal key less than key, and *pos_in_item is set to one
    past the last entry/byte in the item.  If searching for entry in a
-   directory item, and it is not found, *p_n_pos_in_item is set to one
+   directory item, and it is not found, *pos_in_item is set to one
    entry more than the entry with maximal key which is less than the
    sought key.
 
@@ -777,7 +777,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 /* The function is NOT SCHEDULE-SAFE! */
 int search_for_position_by_key(struct super_block *sb,	/* Pointer to the super block.          */
 			       const struct cpu_key *p_cpu_key,	/* Key to search (cpu variable)         */
-			       struct treepath *p_s_search_path	/* Filled up by this function.          */
+			       struct treepath *search_path	/* Filled up by this function.          */
     )
 {
 	struct item_head *p_le_ih;	/* pointer to on-disk structure */
@@ -788,34 +788,34 @@ int search_for_position_by_key(struct super_block *sb,	/* Pointer to the super b
 
 	/* If searching for directory entry. */
 	if (is_direntry_cpu_key(p_cpu_key))
-		return search_by_entry_key(sb, p_cpu_key, p_s_search_path,
+		return search_by_entry_key(sb, p_cpu_key, search_path,
 					   &de);
 
 	/* If not searching for directory entry. */
 
 	/* If item is found. */
-	retval = search_item(sb, p_cpu_key, p_s_search_path);
+	retval = search_item(sb, p_cpu_key, search_path);
 	if (retval == IO_ERROR)
 		return retval;
 	if (retval == ITEM_FOUND) {
 
 		RFALSE(!ih_item_len
 		       (B_N_PITEM_HEAD
-			(PATH_PLAST_BUFFER(p_s_search_path),
-			 PATH_LAST_POSITION(p_s_search_path))),
+			(PATH_PLAST_BUFFER(search_path),
+			 PATH_LAST_POSITION(search_path))),
 		       "PAP-5165: item length equals zero");
 
-		pos_in_item(p_s_search_path) = 0;
+		pos_in_item(search_path) = 0;
 		return POSITION_FOUND;
 	}
 
-	RFALSE(!PATH_LAST_POSITION(p_s_search_path),
+	RFALSE(!PATH_LAST_POSITION(search_path),
 	       "PAP-5170: position equals zero");
 
 	/* Item is not found. Set path to the previous item. */
 	p_le_ih =
-	    B_N_PITEM_HEAD(PATH_PLAST_BUFFER(p_s_search_path),
-			   --PATH_LAST_POSITION(p_s_search_path));
+	    B_N_PITEM_HEAD(PATH_PLAST_BUFFER(search_path),
+			   --PATH_LAST_POSITION(search_path));
 	n_blk_size = sb->s_blocksize;
 
 	if (comp_short_keys(&(p_le_ih->ih_key), p_cpu_key)) {
@@ -829,9 +829,9 @@ int search_for_position_by_key(struct super_block *sb,	/* Pointer to the super b
 	/* Needed byte is contained in the item pointed to by the path. */
 	if (item_offset <= offset &&
 	    item_offset + op_bytes_number(p_le_ih, n_blk_size) > offset) {
-		pos_in_item(p_s_search_path) = offset - item_offset;
+		pos_in_item(search_path) = offset - item_offset;
 		if (is_indirect_le_ih(p_le_ih)) {
-			pos_in_item(p_s_search_path) /= n_blk_size;
+			pos_in_item(search_path) /= n_blk_size;
 		}
 		return POSITION_FOUND;
 	}
@@ -839,18 +839,18 @@ int search_for_position_by_key(struct super_block *sb,	/* Pointer to the super b
 	/* Needed byte is not contained in the item pointed to by the
 	   path. Set pos_in_item out of the item. */
 	if (is_indirect_le_ih(p_le_ih))
-		pos_in_item(p_s_search_path) =
+		pos_in_item(search_path) =
 		    ih_item_len(p_le_ih) / UNFM_P_SIZE;
 	else
-		pos_in_item(p_s_search_path) = ih_item_len(p_le_ih);
+		pos_in_item(search_path) = ih_item_len(p_le_ih);
 
 	return POSITION_NOT_FOUND;
 }
 
 /* Compare given item and item pointed to by the path. */
-int comp_items(const struct item_head *stored_ih, const struct treepath *p_s_path)
+int comp_items(const struct item_head *stored_ih, const struct treepath *path)
 {
-	struct buffer_head *bh = PATH_PLAST_BUFFER(p_s_path);
+	struct buffer_head *bh = PATH_PLAST_BUFFER(path);
 	struct item_head *ih;
 
 	/* Last buffer at the path is not in the tree. */
@@ -858,11 +858,11 @@ int comp_items(const struct item_head *stored_ih, const struct treepath *p_s_pat
 		return 1;
 
 	/* Last path position is invalid. */
-	if (PATH_LAST_POSITION(p_s_path) >= B_NR_ITEMS(bh))
+	if (PATH_LAST_POSITION(path) >= B_NR_ITEMS(bh))
 		return 1;
 
 	/* we need only to know, whether it is the same item */
-	ih = get_ih(p_s_path);
+	ih = get_ih(path);
 	return memcmp(stored_ih, ih, IH_SIZE);
 }
 
@@ -951,14 +951,14 @@ static inline int prepare_for_direntry_item(struct treepath *path,
     In case of file truncate calculate whether this item must be deleted/truncated or last
     unformatted node of this item will be converted to a direct item.
     This function returns a determination of what balance mode the calling function should employ. */
-static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, struct inode *inode, struct treepath *p_s_path, const struct cpu_key *p_s_item_key, int *p_n_removed,	/* Number of unformatted nodes which were removed
+static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, struct inode *inode, struct treepath *path, const struct cpu_key *item_key, int *removed,	/* Number of unformatted nodes which were removed
 																						   from end of the file. */
-				      int *p_n_cut_size, unsigned long long n_new_file_length	/* MAX_KEY_OFFSET in case of delete. */
+				      int *cut_size, unsigned long long n_new_file_length	/* MAX_KEY_OFFSET in case of delete. */
     )
 {
 	struct super_block *sb = inode->i_sb;
-	struct item_head *p_le_ih = PATH_PITEM_HEAD(p_s_path);
-	struct buffer_head *bh = PATH_PLAST_BUFFER(p_s_path);
+	struct item_head *p_le_ih = PATH_PITEM_HEAD(path);
+	struct buffer_head *bh = PATH_PLAST_BUFFER(path);
 
 	BUG_ON(!th->t_trans_id);
 
@@ -968,20 +968,20 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 		RFALSE(n_new_file_length != max_reiserfs_offset(inode),
 		       "PAP-5210: mode must be M_DELETE");
 
-		*p_n_cut_size = -(IH_SIZE + ih_item_len(p_le_ih));
+		*cut_size = -(IH_SIZE + ih_item_len(p_le_ih));
 		return M_DELETE;
 	}
 
 	/* Directory item. */
 	if (is_direntry_le_ih(p_le_ih))
-		return prepare_for_direntry_item(p_s_path, p_le_ih, inode,
+		return prepare_for_direntry_item(path, p_le_ih, inode,
 						 n_new_file_length,
-						 p_n_cut_size);
+						 cut_size);
 
 	/* Direct item. */
 	if (is_direct_le_ih(p_le_ih))
-		return prepare_for_direct_item(p_s_path, p_le_ih, inode,
-					       n_new_file_length, p_n_cut_size);
+		return prepare_for_direct_item(path, p_le_ih, inode,
+					       n_new_file_length, cut_size);
 
 	/* Case of an indirect item. */
 	{
@@ -1001,9 +1001,9 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 
 	    do {
 		need_re_search = 0;
-		*p_n_cut_size = 0;
-		bh = PATH_PLAST_BUFFER(p_s_path);
-		copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path));
+		*cut_size = 0;
+		bh = PATH_PLAST_BUFFER(path);
+		copy_item_head(&s_ih, PATH_PITEM_HEAD(path));
 		pos = I_UNFM_NUM(&s_ih);
 
 		while (le_ih_k_offset (&s_ih) + (pos - 1) * blk_size > n_new_file_length) {
@@ -1013,10 +1013,9 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 		    /* Each unformatted block deletion may involve one additional
 		     * bitmap block into the transaction, thereby the initial
 		     * journal space reservation might not be enough. */
-		    if (!delete && (*p_n_cut_size) != 0 &&
-			reiserfs_transaction_free_space(th) < JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD) {
+		    if (!delete && (*cut_size) != 0 &&
+			reiserfs_transaction_free_space(th) < JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD)
 			break;
-		    }
 
 		    unfm = (__le32 *)B_I_PITEM(bh, &s_ih) + pos - 1;
 		    block = get_block_num(unfm, 0);
@@ -1030,17 +1029,17 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 
 		    cond_resched();
 
-		    if (item_moved (&s_ih, p_s_path))  {
+		    if (item_moved (&s_ih, path))  {
 			need_re_search = 1;
 			break;
 		    }
 
 		    pos --;
-		    (*p_n_removed) ++;
-		    (*p_n_cut_size) -= UNFM_P_SIZE;
+		    (*removed)++;
+		    (*cut_size) -= UNFM_P_SIZE;
 
 		    if (pos == 0) {
-			(*p_n_cut_size) -= IH_SIZE;
+			(*cut_size) -= IH_SIZE;
 			result = M_DELETE;
 			break;
 		    }
@@ -1050,10 +1049,10 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 		** buffer */
 		reiserfs_restore_prepared_buffer(sb, bh);
 	    } while (need_re_search &&
-		     search_for_position_by_key(sb, p_s_item_key, p_s_path) == POSITION_FOUND);
-	    pos_in_item(p_s_path) = pos * UNFM_P_SIZE;
+		     search_for_position_by_key(sb, item_key, path) == POSITION_FOUND);
+	    pos_in_item(path) = pos * UNFM_P_SIZE;
 
-	    if (*p_n_cut_size == 0) {
+	    if (*cut_size == 0) {
 		/* Nothing were cut. maybe convert last unformatted node to the
 		 * direct item? */
 		result = M_CONVERT;
@@ -1091,7 +1090,7 @@ static int calc_deleted_bytes_number(struct tree_balance *tb, char c_mode)
 static void init_tb_struct(struct reiserfs_transaction_handle *th,
 			   struct tree_balance *tb,
 			   struct super_block *sb,
-			   struct treepath *p_s_path, int n_size)
+			   struct treepath *path, int n_size)
 {
 
 	BUG_ON(!th->t_trans_id);
@@ -1099,9 +1098,9 @@ static void init_tb_struct(struct reiserfs_transaction_handle *th,
 	memset(tb, '\0', sizeof(struct tree_balance));
 	tb->transaction_handle = th;
 	tb->tb_sb = sb;
-	tb->tb_path = p_s_path;
-	PATH_OFFSET_PBUFFER(p_s_path, ILLEGAL_PATH_ELEMENT_OFFSET) = NULL;
-	PATH_OFFSET_POSITION(p_s_path, ILLEGAL_PATH_ELEMENT_OFFSET) = 0;
+	tb->tb_path = path;
+	PATH_OFFSET_PBUFFER(path, ILLEGAL_PATH_ELEMENT_OFFSET) = NULL;
+	PATH_OFFSET_POSITION(path, ILLEGAL_PATH_ELEMENT_OFFSET) = 0;
 	tb->insert_size[0] = n_size;
 }
 
@@ -1141,13 +1140,17 @@ char head2type(struct item_head *ih)
 }
 #endif
 
-/* Delete object item. */
-int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath *p_s_path,	/* Path to the deleted item. */
-			 const struct cpu_key *p_s_item_key,	/* Key to search for the deleted item.  */
-			 struct inode *inode,	/* inode is here just to update
-						 * i_blocks and quotas */
-			 struct buffer_head *p_s_un_bh)
-{				/* NULL or unformatted node pointer.    */
+/* Delete object item.
+ * th       - active transaction handle
+ * path     - path to the deleted item
+ * item_key - key to search for the deleted item
+ * indode   - used for updating i_blocks and quotas
+ * un_bh    - NULL or unformatted node pointer
+ */
+int reiserfs_delete_item(struct reiserfs_transaction_handle *th,
+			 struct treepath *path, const struct cpu_key *item_key,
+			 struct inode *inode, struct buffer_head *un_bh)
+{
 	struct super_block *sb = inode->i_sb;
 	struct tree_balance s_del_balance;
 	struct item_head s_ih;
@@ -1162,7 +1165,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath
 
 	BUG_ON(!th->t_trans_id);
 
-	init_tb_struct(th, &s_del_balance, sb, p_s_path,
+	init_tb_struct(th, &s_del_balance, sb, path,
 		       0 /*size is unknown */ );
 
 	while (1) {
@@ -1172,14 +1175,14 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath
 		n_iter++;
 		c_mode =
 #endif
-		    prepare_for_delete_or_cut(th, inode, p_s_path,
-					      p_s_item_key, &n_removed,
+		    prepare_for_delete_or_cut(th, inode, path,
+					      item_key, &n_removed,
 					      &n_del_size,
 					      max_reiserfs_offset(inode));
 
 		RFALSE(c_mode != M_DELETE, "PAP-5320: mode must be M_DELETE");
 
-		copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path));
+		copy_item_head(&s_ih, PATH_PITEM_HEAD(path));
 		s_del_balance.insert_size[0] = n_del_size;
 
 		n_ret_value = fix_nodes(M_DELETE, &s_del_balance, NULL, NULL);
@@ -1190,13 +1193,13 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath
 
 		// file system changed, repeat search
 		n_ret_value =
-		    search_for_position_by_key(sb, p_s_item_key, p_s_path);
+		    search_for_position_by_key(sb, item_key, path);
 		if (n_ret_value == IO_ERROR)
 			break;
 		if (n_ret_value == FILE_NOT_FOUND) {
 			reiserfs_warning(sb, "vs-5340",
 					 "no items of the file %K found",
-					 p_s_item_key);
+					 item_key);
 			break;
 		}
 	}			/* while (1) */
@@ -1207,7 +1210,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath
 	}
 	// reiserfs_delete_item returns item length when success
 	n_ret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);
-	q_ih = get_ih(p_s_path);
+	q_ih = get_ih(path);
 	quota_cut_bytes = ih_item_len(q_ih);
 
 	/* hack so the quota code doesn't have to guess if the file
@@ -1224,7 +1227,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath
 		}
 	}
 
-	if (p_s_un_bh) {
+	if (un_bh) {
 		int off;
 		char *data;
 
@@ -1242,16 +1245,16 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath
 		 ** The unformatted node must be dirtied later on.  We can't be
 		 ** sure here if the entire tail has been deleted yet.
 		 **
-		 ** p_s_un_bh is from the page cache (all unformatted nodes are
+		 ** un_bh is from the page cache (all unformatted nodes are
 		 ** from the page cache) and might be a highmem page.  So, we
-		 ** can't use p_s_un_bh->b_data.
+		 ** can't use un_bh->b_data.
 		 ** -clm
 		 */
 
-		data = kmap_atomic(p_s_un_bh->b_page, KM_USER0);
+		data = kmap_atomic(un_bh->b_page, KM_USER0);
 		off = ((le_ih_k_offset(&s_ih) - 1) & (PAGE_CACHE_SIZE - 1));
 		memcpy(data + off,
-		       B_I_PITEM(PATH_PLAST_BUFFER(p_s_path), &s_ih),
+		       B_I_PITEM(PATH_PLAST_BUFFER(path), &s_ih),
 		       n_ret_value);
 		kunmap_atomic(data, KM_USER0);
 	}
@@ -1427,9 +1430,9 @@ static void unmap_buffers(struct page *page, loff_t pos)
 static int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,
 				    struct inode *inode,
 				    struct page *page,
-				    struct treepath *p_s_path,
-				    const struct cpu_key *p_s_item_key,
-				    loff_t n_new_file_size, char *p_c_mode)
+				    struct treepath *path,
+				    const struct cpu_key *item_key,
+				    loff_t n_new_file_size, char *mode)
 {
 	struct super_block *sb = inode->i_sb;
 	int n_block_size = sb->s_blocksize;
@@ -1445,17 +1448,17 @@ static int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,
 	    !tail_has_to_be_packed(inode) ||
 	    !page || (REISERFS_I(inode)->i_flags & i_nopack_mask)) {
 		/* leave tail in an unformatted node */
-		*p_c_mode = M_SKIP_BALANCING;
+		*mode = M_SKIP_BALANCING;
 		cut_bytes =
 		    n_block_size - (n_new_file_size & (n_block_size - 1));
-		pathrelse(p_s_path);
+		pathrelse(path);
 		return cut_bytes;
 	}
-	/* Permorm the conversion to a direct_item. */
-	/* return indirect_to_direct(inode, p_s_path, p_s_item_key,
-				  n_new_file_size, p_c_mode); */
-	return indirect2direct(th, inode, page, p_s_path, p_s_item_key,
-			       n_new_file_size, p_c_mode);
+	/* Perform the conversion to a direct_item. */
+	/* return indirect_to_direct(inode, path, item_key,
+				  n_new_file_size, mode); */
+	return indirect2direct(th, inode, page, path, item_key,
+			       n_new_file_size, mode);
 }
 
 /* we did indirect_to_direct conversion. And we have inserted direct
@@ -1506,8 +1509,8 @@ static void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,
 
 /* (Truncate or cut entry) or delete object item. Returns < 0 on failure */
 int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
-			   struct treepath *p_s_path,
-			   struct cpu_key *p_s_item_key,
+			   struct treepath *path,
+			   struct cpu_key *item_key,
 			   struct inode *inode,
 			   struct page *page, loff_t n_new_file_size)
 {
@@ -1528,7 +1531,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 
 	BUG_ON(!th->t_trans_id);
 
-	init_tb_struct(th, &s_cut_balance, inode->i_sb, p_s_path,
+	init_tb_struct(th, &s_cut_balance, inode->i_sb, path,
 		       n_cut_size);
 
 	/* Repeat this loop until we either cut the item without needing
@@ -1540,8 +1543,8 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		   pointers. */
 
 		c_mode =
-		    prepare_for_delete_or_cut(th, inode, p_s_path,
-					      p_s_item_key, &n_removed,
+		    prepare_for_delete_or_cut(th, inode, path,
+					      item_key, &n_removed,
 					      &n_cut_size, n_new_file_size);
 		if (c_mode == M_CONVERT) {
 			/* convert last unformatted node to direct item or leave
@@ -1551,7 +1554,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 
 			n_ret_value =
 			    maybe_indirect_to_direct(th, inode, page,
-						     p_s_path, p_s_item_key,
+						     path, item_key,
 						     n_new_file_size, &c_mode);
 			if (c_mode == M_SKIP_BALANCING)
 				/* tail has been left in the unformatted node */
@@ -1568,26 +1571,26 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 			   inserting the new direct item.  Now we are removing the
 			   last unformatted node pointer. Set key to search for
 			   it. */
-			set_cpu_key_k_type(p_s_item_key, TYPE_INDIRECT);
-			p_s_item_key->key_length = 4;
+			set_cpu_key_k_type(item_key, TYPE_INDIRECT);
+			item_key->key_length = 4;
 			n_new_file_size -=
 			    (n_new_file_size & (sb->s_blocksize - 1));
 			tail_pos = n_new_file_size;
-			set_cpu_key_k_offset(p_s_item_key, n_new_file_size + 1);
+			set_cpu_key_k_offset(item_key, n_new_file_size + 1);
 			if (search_for_position_by_key
-			    (sb, p_s_item_key,
-			     p_s_path) == POSITION_NOT_FOUND) {
-				print_block(PATH_PLAST_BUFFER(p_s_path), 3,
-					    PATH_LAST_POSITION(p_s_path) - 1,
-					    PATH_LAST_POSITION(p_s_path) + 1);
+			    (sb, item_key,
+			     path) == POSITION_NOT_FOUND) {
+				print_block(PATH_PLAST_BUFFER(path), 3,
+					    PATH_LAST_POSITION(path) - 1,
+					    PATH_LAST_POSITION(path) + 1);
 				reiserfs_panic(sb, "PAP-5580", "item to "
 					       "convert does not exist (%K)",
-					       p_s_item_key);
+					       item_key);
 			}
 			continue;
 		}
 		if (n_cut_size == 0) {
-			pathrelse(p_s_path);
+			pathrelse(path);
 			return 0;
 		}
 
@@ -1600,12 +1603,12 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		PROC_INFO_INC(sb, cut_from_item_restarted);
 
 		n_ret_value =
-		    search_for_position_by_key(sb, p_s_item_key, p_s_path);
+		    search_for_position_by_key(sb, item_key, path);
 		if (n_ret_value == POSITION_FOUND)
 			continue;
 
 		reiserfs_warning(sb, "PAP-5610", "item %K not found",
-				 p_s_item_key);
+				 item_key);
 		unfix_nodes(&s_cut_balance);
 		return (n_ret_value == IO_ERROR) ? -EIO : -ENOENT;
 	}			/* while */
@@ -1615,7 +1618,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		if (n_is_inode_locked) {
 			// FIXME: this seems to be not needed: we are always able
 			// to cut item
-			indirect_to_direct_roll_back(th, inode, p_s_path);
+			indirect_to_direct_roll_back(th, inode, path);
 		}
 		if (n_ret_value == NO_DISK_SPACE)
 			reiserfs_warning(sb, "reiserfs-5092",
@@ -1631,7 +1634,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 	/* Calculate number of bytes that need to be cut from the item. */
 	quota_cut_bytes =
 	    (c_mode ==
-	     M_DELETE) ? ih_item_len(get_ih(p_s_path)) : -s_cut_balance.
+	     M_DELETE) ? ih_item_len(get_ih(path)) : -s_cut_balance.
 	    insert_size[0];
 	if (retval2 == -1)
 		n_ret_value = calc_deleted_bytes_number(&s_cut_balance, c_mode);
@@ -1878,7 +1881,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
 #ifdef CONFIG_REISERFS_CHECK
 // this makes sure, that we __append__, not overwrite or add holes
 static void check_research_for_paste(struct treepath *path,
-				     const struct cpu_key *p_s_key)
+				     const struct cpu_key *key)
 {
 	struct item_head *found_ih = get_ih(path);
 
@@ -1886,35 +1889,35 @@ static void check_research_for_paste(struct treepath *path,
 		if (le_ih_k_offset(found_ih) +
 		    op_bytes_number(found_ih,
 				    get_last_bh(path)->b_size) !=
-		    cpu_key_k_offset(p_s_key)
+		    cpu_key_k_offset(key)
 		    || op_bytes_number(found_ih,
 				       get_last_bh(path)->b_size) !=
 		    pos_in_item(path))
 			reiserfs_panic(NULL, "PAP-5720", "found direct item "
 				       "%h or position (%d) does not match "
 				       "to key %K", found_ih,
-				       pos_in_item(path), p_s_key);
+				       pos_in_item(path), key);
 	}
 	if (is_indirect_le_ih(found_ih)) {
 		if (le_ih_k_offset(found_ih) +
 		    op_bytes_number(found_ih,
 				    get_last_bh(path)->b_size) !=
-		    cpu_key_k_offset(p_s_key)
+		    cpu_key_k_offset(key)
 		    || I_UNFM_NUM(found_ih) != pos_in_item(path)
 		    || get_ih_free_space(found_ih) != 0)
 			reiserfs_panic(NULL, "PAP-5730", "found indirect "
 				       "item (%h) or position (%d) does not "
 				       "match to key (%K)",
-				       found_ih, pos_in_item(path), p_s_key);
+				       found_ih, pos_in_item(path), key);
 	}
 }
 #endif				/* config reiserfs check */
 
 /* Paste bytes to the existing item. Returns bytes number pasted into the item. */
-int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct treepath *p_s_search_path,	/* Path to the pasted item.          */
-			     const struct cpu_key *p_s_key,	/* Key to search for the needed item. */
+int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct treepath *search_path,	/* Path to the pasted item.	  */
+			     const struct cpu_key *key,	/* Key to search for the needed item. */
 			     struct inode *inode,	/* Inode item belongs to */
-			     const char *p_c_body,	/* Pointer to the bytes to paste.    */
+			     const char *body,	/* Pointer to the bytes to paste.    */
 			     int n_pasted_size)
 {				/* Size of pasted bytes.             */
 	struct tree_balance s_paste_balance;
@@ -1929,17 +1932,17 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 	reiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,
 		       "reiserquota paste_into_item(): allocating %u id=%u type=%c",
 		       n_pasted_size, inode->i_uid,
-		       key2type(&(p_s_key->on_disk_key)));
+		       key2type(&(key->on_disk_key)));
 #endif
 
 	if (DQUOT_ALLOC_SPACE_NODIRTY(inode, n_pasted_size)) {
-		pathrelse(p_s_search_path);
+		pathrelse(search_path);
 		return -EDQUOT;
 	}
-	init_tb_struct(th, &s_paste_balance, th->t_super, p_s_search_path,
+	init_tb_struct(th, &s_paste_balance, th->t_super, search_path,
 		       n_pasted_size);
 #ifdef DISPLACE_NEW_PACKING_LOCALITIES
-	s_paste_balance.key = p_s_key->on_disk_key;
+	s_paste_balance.key = key->on_disk_key;
 #endif
 
 	/* DQUOT_* can schedule, must check before the fix_nodes */
@@ -1949,13 +1952,13 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 
 	while ((retval =
 		fix_nodes(M_PASTE, &s_paste_balance, NULL,
-			  p_c_body)) == REPEAT_SEARCH) {
+			  body)) == REPEAT_SEARCH) {
 	      search_again:
 		/* file system changed while we were in the fix_nodes */
 		PROC_INFO_INC(th->t_super, paste_into_item_restarted);
 		retval =
-		    search_for_position_by_key(th->t_super, p_s_key,
-					       p_s_search_path);
+		    search_for_position_by_key(th->t_super, key,
+					       search_path);
 		if (retval == IO_ERROR) {
 			retval = -EIO;
 			goto error_out;
@@ -1963,19 +1966,19 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 		if (retval == POSITION_FOUND) {
 			reiserfs_warning(inode->i_sb, "PAP-5710",
 					 "entry or pasted byte (%K) exists",
-					 p_s_key);
+					 key);
 			retval = -EEXIST;
 			goto error_out;
 		}
 #ifdef CONFIG_REISERFS_CHECK
-		check_research_for_paste(p_s_search_path, p_s_key);
+		check_research_for_paste(search_path, key);
 #endif
 	}
 
 	/* Perform balancing after all resources are collected by fix_nodes, and
 	   accessing them will not risk triggering schedule. */
 	if (retval == CARRY_ON) {
-		do_balance(&s_paste_balance, NULL /*ih */ , p_c_body, M_PASTE);
+		do_balance(&s_paste_balance, NULL /*ih */ , body, M_PASTE);
 		return 0;
 	}
 	retval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;
@@ -1986,17 +1989,23 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 	reiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,
 		       "reiserquota paste_into_item(): freeing %u id=%u type=%c",
 		       n_pasted_size, inode->i_uid,
-		       key2type(&(p_s_key->on_disk_key)));
+		       key2type(&(key->on_disk_key)));
 #endif
 	DQUOT_FREE_SPACE_NODIRTY(inode, n_pasted_size);
 	return retval;
 }
 
-/* Insert new item into the buffer at the path. */
-int reiserfs_insert_item(struct reiserfs_transaction_handle *th, struct treepath *p_s_path,	/* Path to the inserteded item.         */
-			 const struct cpu_key *key, struct item_head *p_s_ih,	/* Pointer to the item header to insert. */
-			 struct inode *inode, const char *p_c_body)
-{				/* Pointer to the bytes to insert.      */
+/* Insert new item into the buffer at the path.
+ * th   - active transaction handle
+ * path - path to the inserted item
+ * ih   - pointer to the item header to insert
+ * body - pointer to the bytes to insert
+ */
+int reiserfs_insert_item(struct reiserfs_transaction_handle *th,
+			 struct treepath *path, const struct cpu_key *key,
+			 struct item_head *ih, struct inode *inode,
+			 const char *body)
+{
 	struct tree_balance s_ins_balance;
 	int retval;
 	int fs_gen = 0;
@@ -2006,28 +2015,27 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th, struct treepath
 
 	if (inode) {		/* Do we count quotas for item? */
 		fs_gen = get_generation(inode->i_sb);
-		quota_bytes = ih_item_len(p_s_ih);
+		quota_bytes = ih_item_len(ih);
 
 		/* hack so the quota code doesn't have to guess if the file has
 		 ** a tail, links are always tails, so there's no guessing needed
 		 */
-		if (!S_ISLNK(inode->i_mode) && is_direct_le_ih(p_s_ih)) {
+		if (!S_ISLNK(inode->i_mode) && is_direct_le_ih(ih))
 			quota_bytes = inode->i_sb->s_blocksize + UNFM_P_SIZE;
-		}
 #ifdef REISERQUOTA_DEBUG
 		reiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,
 			       "reiserquota insert_item(): allocating %u id=%u type=%c",
-			       quota_bytes, inode->i_uid, head2type(p_s_ih));
+			       quota_bytes, inode->i_uid, head2type(ih));
 #endif
 		/* We can't dirty inode here. It would be immediately written but
 		 * appropriate stat item isn't inserted yet... */
 		if (DQUOT_ALLOC_SPACE_NODIRTY(inode, quota_bytes)) {
-			pathrelse(p_s_path);
+			pathrelse(path);
 			return -EDQUOT;
 		}
 	}
-	init_tb_struct(th, &s_ins_balance, th->t_super, p_s_path,
-		       IH_SIZE + ih_item_len(p_s_ih));
+	init_tb_struct(th, &s_ins_balance, th->t_super, path,
+		       IH_SIZE + ih_item_len(ih));
 #ifdef DISPLACE_NEW_PACKING_LOCALITIES
 	s_ins_balance.key = key->on_disk_key;
 #endif
@@ -2037,12 +2045,12 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th, struct treepath
 	}
 
 	while ((retval =
-		fix_nodes(M_INSERT, &s_ins_balance, p_s_ih,
-			  p_c_body)) == REPEAT_SEARCH) {
+		fix_nodes(M_INSERT, &s_ins_balance, ih,
+			  body)) == REPEAT_SEARCH) {
 	      search_again:
 		/* file system changed while we were in the fix_nodes */
 		PROC_INFO_INC(th->t_super, insert_item_restarted);
-		retval = search_item(th->t_super, key, p_s_path);
+		retval = search_item(th->t_super, key, path);
 		if (retval == IO_ERROR) {
 			retval = -EIO;
 			goto error_out;
@@ -2058,7 +2066,7 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th, struct treepath
 
 	/* make balancing after all resources will be collected at a time */
 	if (retval == CARRY_ON) {
-		do_balance(&s_ins_balance, p_s_ih, p_c_body, M_INSERT);
+		do_balance(&s_ins_balance, ih, body, M_INSERT);
 		return 0;
 	}
 
@@ -2069,7 +2077,7 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th, struct treepath
 #ifdef REISERQUOTA_DEBUG
 	reiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,
 		       "reiserquota insert_item(): freeing %u id=%u type=%c",
-		       quota_bytes, inode->i_uid, head2type(p_s_ih));
+		       quota_bytes, inode->i_uid, head2type(ih));
 #endif
 	if (inode)
 		DQUOT_FREE_SPACE_NODIRTY(inode, quota_bytes);

commit a063ae17925cafabe55ebe1957ca0e8c480bd132
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:48 2009 -0400

    reiserfs: rename p_s_tb to tb
    
    This patch is a simple s/p_s_tb/tb/g to the reiserfs code.  This is the
    fourth in a series of patches to rip out some of the awful variable
    naming in reiserfs.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 8f220fb777d7..5e867be559ea 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1063,17 +1063,17 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 }
 
 /* Calculate number of bytes which will be deleted or cut during balance */
-static int calc_deleted_bytes_number(struct tree_balance *p_s_tb, char c_mode)
+static int calc_deleted_bytes_number(struct tree_balance *tb, char c_mode)
 {
 	int n_del_size;
-	struct item_head *p_le_ih = PATH_PITEM_HEAD(p_s_tb->tb_path);
+	struct item_head *p_le_ih = PATH_PITEM_HEAD(tb->tb_path);
 
 	if (is_statdata_le_ih(p_le_ih))
 		return 0;
 
 	n_del_size =
 	    (c_mode ==
-	     M_DELETE) ? ih_item_len(p_le_ih) : -p_s_tb->insert_size[0];
+	     M_DELETE) ? ih_item_len(p_le_ih) : -tb->insert_size[0];
 	if (is_direntry_le_ih(p_le_ih)) {
 		// return EMPTY_DIR_SIZE; /* We delete emty directoris only. */
 		// we can't use EMPTY_DIR_SIZE, as old format dirs have a different
@@ -1083,25 +1083,26 @@ static int calc_deleted_bytes_number(struct tree_balance *p_s_tb, char c_mode)
 	}
 
 	if (is_indirect_le_ih(p_le_ih))
-		n_del_size = (n_del_size / UNFM_P_SIZE) * (PATH_PLAST_BUFFER(p_s_tb->tb_path)->b_size);	// - get_ih_free_space (p_le_ih);
+		n_del_size = (n_del_size / UNFM_P_SIZE) *
+				(PATH_PLAST_BUFFER(tb->tb_path)->b_size);
 	return n_del_size;
 }
 
 static void init_tb_struct(struct reiserfs_transaction_handle *th,
-			   struct tree_balance *p_s_tb,
+			   struct tree_balance *tb,
 			   struct super_block *sb,
 			   struct treepath *p_s_path, int n_size)
 {
 
 	BUG_ON(!th->t_trans_id);
 
-	memset(p_s_tb, '\0', sizeof(struct tree_balance));
-	p_s_tb->transaction_handle = th;
-	p_s_tb->tb_sb = sb;
-	p_s_tb->tb_path = p_s_path;
+	memset(tb, '\0', sizeof(struct tree_balance));
+	tb->transaction_handle = th;
+	tb->tb_sb = sb;
+	tb->tb_path = p_s_path;
 	PATH_OFFSET_PBUFFER(p_s_path, ILLEGAL_PATH_ELEMENT_OFFSET) = NULL;
 	PATH_OFFSET_POSITION(p_s_path, ILLEGAL_PATH_ELEMENT_OFFSET) = 0;
-	p_s_tb->insert_size[0] = n_size;
+	tb->insert_size[0] = n_size;
 }
 
 void padd_item(char *item, int total_length, int length)

commit 995c762ea486b48c9777522071fbf132dea96807
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:47 2009 -0400

    reiserfs: rename p_s_inode to inode
    
    This patch is a simple s/p_s_inode/inode/g to the reiserfs code.  This
    is the third in a series of patches to rip out some of the awful
    variable naming in reiserfs.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index eb6856f6d323..8f220fb777d7 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1143,10 +1143,11 @@ char head2type(struct item_head *ih)
 /* Delete object item. */
 int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath *p_s_path,	/* Path to the deleted item. */
 			 const struct cpu_key *p_s_item_key,	/* Key to search for the deleted item.  */
-			 struct inode *p_s_inode,	/* inode is here just to update i_blocks and quotas */
+			 struct inode *inode,	/* inode is here just to update
+						 * i_blocks and quotas */
 			 struct buffer_head *p_s_un_bh)
 {				/* NULL or unformatted node pointer.    */
-	struct super_block *sb = p_s_inode->i_sb;
+	struct super_block *sb = inode->i_sb;
 	struct tree_balance s_del_balance;
 	struct item_head s_ih;
 	struct item_head *q_ih;
@@ -1170,10 +1171,10 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath
 		n_iter++;
 		c_mode =
 #endif
-		    prepare_for_delete_or_cut(th, p_s_inode, p_s_path,
+		    prepare_for_delete_or_cut(th, inode, p_s_path,
 					      p_s_item_key, &n_removed,
 					      &n_del_size,
-					      max_reiserfs_offset(p_s_inode));
+					      max_reiserfs_offset(inode));
 
 		RFALSE(c_mode != M_DELETE, "PAP-5320: mode must be M_DELETE");
 
@@ -1214,7 +1215,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath
 	 ** split into multiple items, and we only want to decrement for
 	 ** the unfm node once
 	 */
-	if (!S_ISLNK(p_s_inode->i_mode) && is_direct_le_ih(q_ih)) {
+	if (!S_ISLNK(inode->i_mode) && is_direct_le_ih(q_ih)) {
 		if ((le_ih_k_offset(q_ih) & (sb->s_blocksize - 1)) == 1) {
 			quota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;
 		} else {
@@ -1259,9 +1260,9 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath
 #ifdef REISERQUOTA_DEBUG
 	reiserfs_debug(sb, REISERFS_DEBUG_CODE,
 		       "reiserquota delete_item(): freeing %u, id=%u type=%c",
-		       quota_cut_bytes, p_s_inode->i_uid, head2type(&s_ih));
+		       quota_cut_bytes, inode->i_uid, head2type(&s_ih));
 #endif
-	DQUOT_FREE_SPACE_NODIRTY(p_s_inode, quota_cut_bytes);
+	DQUOT_FREE_SPACE_NODIRTY(inode, quota_cut_bytes);
 
 	/* Return deleted body length */
 	return n_ret_value;
@@ -1423,25 +1424,25 @@ static void unmap_buffers(struct page *page, loff_t pos)
 }
 
 static int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,
-				    struct inode *p_s_inode,
+				    struct inode *inode,
 				    struct page *page,
 				    struct treepath *p_s_path,
 				    const struct cpu_key *p_s_item_key,
 				    loff_t n_new_file_size, char *p_c_mode)
 {
-	struct super_block *sb = p_s_inode->i_sb;
+	struct super_block *sb = inode->i_sb;
 	int n_block_size = sb->s_blocksize;
 	int cut_bytes;
 	BUG_ON(!th->t_trans_id);
-	BUG_ON(n_new_file_size != p_s_inode->i_size);
+	BUG_ON(n_new_file_size != inode->i_size);
 
 	/* the page being sent in could be NULL if there was an i/o error
 	 ** reading in the last block.  The user will hit problems trying to
 	 ** read the file, but for now we just skip the indirect2direct
 	 */
-	if (atomic_read(&p_s_inode->i_count) > 1 ||
-	    !tail_has_to_be_packed(p_s_inode) ||
-	    !page || (REISERFS_I(p_s_inode)->i_flags & i_nopack_mask)) {
+	if (atomic_read(&inode->i_count) > 1 ||
+	    !tail_has_to_be_packed(inode) ||
+	    !page || (REISERFS_I(inode)->i_flags & i_nopack_mask)) {
 		/* leave tail in an unformatted node */
 		*p_c_mode = M_SKIP_BALANCING;
 		cut_bytes =
@@ -1450,8 +1451,9 @@ static int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,
 		return cut_bytes;
 	}
 	/* Permorm the conversion to a direct_item. */
-	/*return indirect_to_direct (p_s_inode, p_s_path, p_s_item_key, n_new_file_size, p_c_mode); */
-	return indirect2direct(th, p_s_inode, page, p_s_path, p_s_item_key,
+	/* return indirect_to_direct(inode, p_s_path, p_s_item_key,
+				  n_new_file_size, p_c_mode); */
+	return indirect2direct(th, inode, page, p_s_path, p_s_item_key,
 			       n_new_file_size, p_c_mode);
 }
 
@@ -1505,10 +1507,10 @@ static void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,
 int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 			   struct treepath *p_s_path,
 			   struct cpu_key *p_s_item_key,
-			   struct inode *p_s_inode,
+			   struct inode *inode,
 			   struct page *page, loff_t n_new_file_size)
 {
-	struct super_block *sb = p_s_inode->i_sb;
+	struct super_block *sb = inode->i_sb;
 	/* Every function which is going to call do_balance must first
 	   create a tree_balance structure.  Then it must fill up this
 	   structure by using the init_tb_struct and fix_nodes functions.
@@ -1525,7 +1527,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 
 	BUG_ON(!th->t_trans_id);
 
-	init_tb_struct(th, &s_cut_balance, p_s_inode->i_sb, p_s_path,
+	init_tb_struct(th, &s_cut_balance, inode->i_sb, p_s_path,
 		       n_cut_size);
 
 	/* Repeat this loop until we either cut the item without needing
@@ -1537,7 +1539,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		   pointers. */
 
 		c_mode =
-		    prepare_for_delete_or_cut(th, p_s_inode, p_s_path,
+		    prepare_for_delete_or_cut(th, inode, p_s_path,
 					      p_s_item_key, &n_removed,
 					      &n_cut_size, n_new_file_size);
 		if (c_mode == M_CONVERT) {
@@ -1547,7 +1549,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 			       "PAP-5570: can not convert twice");
 
 			n_ret_value =
-			    maybe_indirect_to_direct(th, p_s_inode, page,
+			    maybe_indirect_to_direct(th, inode, page,
 						     p_s_path, p_s_item_key,
 						     n_new_file_size, &c_mode);
 			if (c_mode == M_SKIP_BALANCING)
@@ -1612,7 +1614,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		if (n_is_inode_locked) {
 			// FIXME: this seems to be not needed: we are always able
 			// to cut item
-			indirect_to_direct_roll_back(th, p_s_inode, p_s_path);
+			indirect_to_direct_roll_back(th, inode, p_s_path);
 		}
 		if (n_ret_value == NO_DISK_SPACE)
 			reiserfs_warning(sb, "reiserfs-5092",
@@ -1639,12 +1641,12 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 	 ** item.
 	 */
 	p_le_ih = PATH_PITEM_HEAD(s_cut_balance.tb_path);
-	if (!S_ISLNK(p_s_inode->i_mode) && is_direct_le_ih(p_le_ih)) {
+	if (!S_ISLNK(inode->i_mode) && is_direct_le_ih(p_le_ih)) {
 		if (c_mode == M_DELETE &&
 		    (le_ih_k_offset(p_le_ih) & (sb->s_blocksize - 1)) ==
 		    1) {
 			// FIXME: this is to keep 3.5 happy
-			REISERFS_I(p_s_inode)->i_first_direct_byte = U32_MAX;
+			REISERFS_I(inode)->i_first_direct_byte = U32_MAX;
 			quota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;
 		} else {
 			quota_cut_bytes = 0;
@@ -1687,14 +1689,14 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		 ** unmap and invalidate it
 		 */
 		unmap_buffers(page, tail_pos);
-		REISERFS_I(p_s_inode)->i_flags &= ~i_pack_on_close_mask;
+		REISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;
 	}
 #ifdef REISERQUOTA_DEBUG
-	reiserfs_debug(p_s_inode->i_sb, REISERFS_DEBUG_CODE,
+	reiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,
 		       "reiserquota cut_from_item(): freeing %u id=%u type=%c",
-		       quota_cut_bytes, p_s_inode->i_uid, '?');
+		       quota_cut_bytes, inode->i_uid, '?');
 #endif
-	DQUOT_FREE_SPACE_NODIRTY(p_s_inode, quota_cut_bytes);
+	DQUOT_FREE_SPACE_NODIRTY(inode, quota_cut_bytes);
 	return n_ret_value;
 }
 
@@ -1715,8 +1717,8 @@ static void truncate_directory(struct reiserfs_transaction_handle *th,
 
 /* Truncate file to the new size. Note, this must be called with a transaction
    already started */
-int reiserfs_do_truncate(struct reiserfs_transaction_handle *th, struct inode *p_s_inode,	/* ->i_size contains new
-												   size */
+int reiserfs_do_truncate(struct reiserfs_transaction_handle *th,
+			  struct inode *inode,	/* ->i_size contains new size */
 			 struct page *page,	/* up to date for last block */
 			 int update_timestamps	/* when it is called by
 						   file_release to convert
@@ -1735,35 +1737,35 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th, struct inode *p
 
 	BUG_ON(!th->t_trans_id);
 	if (!
-	    (S_ISREG(p_s_inode->i_mode) || S_ISDIR(p_s_inode->i_mode)
-	     || S_ISLNK(p_s_inode->i_mode)))
+	    (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)
+	     || S_ISLNK(inode->i_mode)))
 		return 0;
 
-	if (S_ISDIR(p_s_inode->i_mode)) {
+	if (S_ISDIR(inode->i_mode)) {
 		// deletion of directory - no need to update timestamps
-		truncate_directory(th, p_s_inode);
+		truncate_directory(th, inode);
 		return 0;
 	}
 
 	/* Get new file size. */
-	n_new_file_size = p_s_inode->i_size;
+	n_new_file_size = inode->i_size;
 
 	// FIXME: note, that key type is unimportant here
-	make_cpu_key(&s_item_key, p_s_inode, max_reiserfs_offset(p_s_inode),
+	make_cpu_key(&s_item_key, inode, max_reiserfs_offset(inode),
 		     TYPE_DIRECT, 3);
 
 	retval =
-	    search_for_position_by_key(p_s_inode->i_sb, &s_item_key,
+	    search_for_position_by_key(inode->i_sb, &s_item_key,
 				       &s_search_path);
 	if (retval == IO_ERROR) {
-		reiserfs_error(p_s_inode->i_sb, "vs-5657",
+		reiserfs_error(inode->i_sb, "vs-5657",
 			       "i/o failure occurred trying to truncate %K",
 			       &s_item_key);
 		err = -EIO;
 		goto out;
 	}
 	if (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {
-		reiserfs_error(p_s_inode->i_sb, "PAP-5660",
+		reiserfs_error(inode->i_sb, "PAP-5660",
 			       "wrong result %d of search for %K", retval,
 			       &s_item_key);
 
@@ -1780,7 +1782,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th, struct inode *p
 	else {
 		loff_t offset = le_ih_k_offset(p_le_ih);
 		int bytes =
-		    op_bytes_number(p_le_ih, p_s_inode->i_sb->s_blocksize);
+		    op_bytes_number(p_le_ih, inode->i_sb->s_blocksize);
 
 		/* this may mismatch with real file size: if last direct item
 		   had no padding zeros and last unformatted node had no free
@@ -1805,9 +1807,9 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th, struct inode *p
 		/* Cut or delete file item. */
 		n_deleted =
 		    reiserfs_cut_from_item(th, &s_search_path, &s_item_key,
-					   p_s_inode, page, n_new_file_size);
+					   inode, page, n_new_file_size);
 		if (n_deleted < 0) {
-			reiserfs_warning(p_s_inode->i_sb, "vs-5665",
+			reiserfs_warning(inode->i_sb, "vs-5665",
 					 "reiserfs_cut_from_item failed");
 			reiserfs_check_path(&s_search_path);
 			return 0;
@@ -1837,22 +1839,22 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th, struct inode *p
 			pathrelse(&s_search_path);
 
 			if (update_timestamps) {
-				p_s_inode->i_mtime = p_s_inode->i_ctime =
-				    CURRENT_TIME_SEC;
+				inode->i_mtime = CURRENT_TIME_SEC;
+				inode->i_ctime = CURRENT_TIME_SEC;
 			}
-			reiserfs_update_sd(th, p_s_inode);
+			reiserfs_update_sd(th, inode);
 
-			err = journal_end(th, p_s_inode->i_sb, orig_len_alloc);
+			err = journal_end(th, inode->i_sb, orig_len_alloc);
 			if (err)
 				goto out;
-			err = journal_begin(th, p_s_inode->i_sb,
+			err = journal_begin(th, inode->i_sb,
 					    JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD + JOURNAL_PER_BALANCE_CNT * 4) ;
 			if (err)
 				goto out;
-			reiserfs_update_inode_transaction(p_s_inode);
+			reiserfs_update_inode_transaction(inode);
 		}
 	} while (n_file_size > ROUND_UP(n_new_file_size) &&
-		 search_for_position_by_key(p_s_inode->i_sb, &s_item_key,
+		 search_for_position_by_key(inode->i_sb, &s_item_key,
 					    &s_search_path) == POSITION_FOUND);
 
 	RFALSE(n_file_size > ROUND_UP(n_new_file_size),
@@ -1862,9 +1864,10 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th, struct inode *p
       update_and_out:
 	if (update_timestamps) {
 		// this is truncate, not file closing
-		p_s_inode->i_mtime = p_s_inode->i_ctime = CURRENT_TIME_SEC;
+		inode->i_mtime = CURRENT_TIME_SEC;
+		inode->i_ctime = CURRENT_TIME_SEC;
 	}
-	reiserfs_update_sd(th, p_s_inode);
+	reiserfs_update_sd(th, inode);
 
       out:
 	pathrelse(&s_search_path);

commit ad31a4fc0386e8590c51ca4b8f1ae1d8b8b2ac5e
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:46 2009 -0400

    reiserfs: rename p_s_bh to bh
    
    This patch is a simple s/p_s_bh/bh/g to the reiserfs code.  This is the
    second in a series of patches to rip out some of the awful variable
    naming in reiserfs.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 00fd879c4a2a..eb6856f6d323 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -56,13 +56,13 @@
 #include <linux/quotaops.h>
 
 /* Does the buffer contain a disk block which is in the tree. */
-inline int B_IS_IN_TREE(const struct buffer_head *p_s_bh)
+inline int B_IS_IN_TREE(const struct buffer_head *bh)
 {
 
-	RFALSE(B_LEVEL(p_s_bh) > MAX_HEIGHT,
-	       "PAP-1010: block (%b) has too big level (%z)", p_s_bh, p_s_bh);
+	RFALSE(B_LEVEL(bh) > MAX_HEIGHT,
+	       "PAP-1010: block (%b) has too big level (%z)", bh, bh);
 
-	return (B_LEVEL(p_s_bh) != FREE_LEVEL);
+	return (B_LEVEL(bh) != FREE_LEVEL);
 }
 
 //
@@ -579,7 +579,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 {
 	b_blocknr_t n_block_number;
 	int expected_level;
-	struct buffer_head *p_s_bh;
+	struct buffer_head *bh;
 	struct path_element *p_s_last_element;
 	int n_node_level, n_retval;
 	int right_neighbor_of_leaf_node;
@@ -626,15 +626,14 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 
 		/* Read the next tree node, and set the last element in the path to
 		   have a pointer to it. */
-		if ((p_s_bh = p_s_last_element->pe_buffer =
+		if ((bh = p_s_last_element->pe_buffer =
 		     sb_getblk(sb, n_block_number))) {
-			if (!buffer_uptodate(p_s_bh) && reada_count > 1) {
+			if (!buffer_uptodate(bh) && reada_count > 1)
 				search_by_key_reada(sb, reada_bh,
 						    reada_blocks, reada_count);
-			}
-			ll_rw_block(READ, 1, &p_s_bh);
-			wait_on_buffer(p_s_bh);
-			if (!buffer_uptodate(p_s_bh))
+			ll_rw_block(READ, 1, &bh);
+			wait_on_buffer(bh);
+			if (!buffer_uptodate(bh))
 				goto io_error;
 		} else {
 		      io_error:
@@ -651,8 +650,8 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 		   to search is still in the tree rooted from the current buffer. If
 		   not then repeat search from the root. */
 		if (fs_changed(fs_gen, sb) &&
-		    (!B_IS_IN_TREE(p_s_bh) ||
-		     B_LEVEL(p_s_bh) != expected_level ||
+		    (!B_IS_IN_TREE(bh) ||
+		     B_LEVEL(bh) != expected_level ||
 		     !key_in_buffer(p_s_search_path, p_s_key, sb))) {
 			PROC_INFO_INC(sb, search_by_key_fs_changed);
 			PROC_INFO_INC(sb, search_by_key_restarted);
@@ -686,25 +685,25 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 
 		// make sure, that the node contents look like a node of
 		// certain level
-		if (!is_tree_node(p_s_bh, expected_level)) {
+		if (!is_tree_node(bh, expected_level)) {
 			reiserfs_error(sb, "vs-5150",
 				       "invalid format found in block %ld. "
-				       "Fsck?", p_s_bh->b_blocknr);
+				       "Fsck?", bh->b_blocknr);
 			pathrelse(p_s_search_path);
 			return IO_ERROR;
 		}
 
 		/* ok, we have acquired next formatted node in the tree */
-		n_node_level = B_LEVEL(p_s_bh);
+		n_node_level = B_LEVEL(bh);
 
-		PROC_INFO_BH_STAT(sb, p_s_bh, n_node_level - 1);
+		PROC_INFO_BH_STAT(sb, bh, n_node_level - 1);
 
 		RFALSE(n_node_level < n_stop_level,
 		       "vs-5152: tree level (%d) is less than stop level (%d)",
 		       n_node_level, n_stop_level);
 
-		n_retval = bin_search(p_s_key, B_N_PITEM_HEAD(p_s_bh, 0),
-				      B_NR_ITEMS(p_s_bh),
+		n_retval = bin_search(p_s_key, B_N_PITEM_HEAD(bh, 0),
+				      B_NR_ITEMS(bh),
 				      (n_node_level ==
 				       DISK_LEAF_NODE_LEVEL) ? IH_SIZE :
 				      KEY_SIZE,
@@ -726,13 +725,13 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 		   an internal node.  Now we calculate child block number by
 		   position in the node. */
 		n_block_number =
-		    B_N_CHILD_NUM(p_s_bh, p_s_last_element->pe_position);
+		    B_N_CHILD_NUM(bh, p_s_last_element->pe_position);
 
 		/* if we are going to read leaf nodes, try for read ahead as well */
 		if ((p_s_search_path->reada & PATH_READA) &&
 		    n_node_level == DISK_LEAF_NODE_LEVEL + 1) {
 			int pos = p_s_last_element->pe_position;
-			int limit = B_NR_ITEMS(p_s_bh);
+			int limit = B_NR_ITEMS(bh);
 			struct reiserfs_key *le_key;
 
 			if (p_s_search_path->reada & PATH_READA_BACK)
@@ -741,7 +740,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 				if (pos == limit)
 					break;
 				reada_blocks[reada_count++] =
-				    B_N_CHILD_NUM(p_s_bh, pos);
+				    B_N_CHILD_NUM(bh, pos);
 				if (p_s_search_path->reada & PATH_READA_BACK)
 					pos--;
 				else
@@ -750,7 +749,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key
 				/*
 				 * check to make sure we're in the same object
 				 */
-				le_key = B_N_PDELIM_KEY(p_s_bh, pos);
+				le_key = B_N_PDELIM_KEY(bh, pos);
 				if (le32_to_cpu(le_key->k_objectid) !=
 				    p_s_key->on_disk_key.k_objectid) {
 					break;
@@ -851,15 +850,15 @@ int search_for_position_by_key(struct super_block *sb,	/* Pointer to the super b
 /* Compare given item and item pointed to by the path. */
 int comp_items(const struct item_head *stored_ih, const struct treepath *p_s_path)
 {
-	struct buffer_head *p_s_bh;
+	struct buffer_head *bh = PATH_PLAST_BUFFER(p_s_path);
 	struct item_head *ih;
 
 	/* Last buffer at the path is not in the tree. */
-	if (!B_IS_IN_TREE(p_s_bh = PATH_PLAST_BUFFER(p_s_path)))
+	if (!B_IS_IN_TREE(bh))
 		return 1;
 
 	/* Last path position is invalid. */
-	if (PATH_LAST_POSITION(p_s_path) >= B_NR_ITEMS(p_s_bh))
+	if (PATH_LAST_POSITION(p_s_path) >= B_NR_ITEMS(bh))
 		return 1;
 
 	/* we need only to know, whether it is the same item */
@@ -959,7 +958,7 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 {
 	struct super_block *sb = inode->i_sb;
 	struct item_head *p_le_ih = PATH_PITEM_HEAD(p_s_path);
-	struct buffer_head *p_s_bh = PATH_PLAST_BUFFER(p_s_path);
+	struct buffer_head *bh = PATH_PLAST_BUFFER(p_s_path);
 
 	BUG_ON(!th->t_trans_id);
 
@@ -1003,7 +1002,7 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 	    do {
 		need_re_search = 0;
 		*p_n_cut_size = 0;
-		p_s_bh = PATH_PLAST_BUFFER(p_s_path);
+		bh = PATH_PLAST_BUFFER(p_s_path);
 		copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path));
 		pos = I_UNFM_NUM(&s_ih);
 
@@ -1019,13 +1018,13 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 			break;
 		    }
 
-		    unfm = (__le32 *)B_I_PITEM(p_s_bh, &s_ih) + pos - 1;
+		    unfm = (__le32 *)B_I_PITEM(bh, &s_ih) + pos - 1;
 		    block = get_block_num(unfm, 0);
 
 		    if (block != 0) {
-			reiserfs_prepare_for_journal(sb, p_s_bh, 1);
+			reiserfs_prepare_for_journal(sb, bh, 1);
 			put_block_num(unfm, 0, 0);
-			journal_mark_dirty (th, sb, p_s_bh);
+			journal_mark_dirty(th, sb, bh);
 			reiserfs_free_block(th, inode, block, 1);
 		    }
 
@@ -1049,7 +1048,7 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 		/* a trick.  If the buffer has been logged, this will do nothing.  If
 		** we've broken the loop without logging it, it will restore the
 		** buffer */
-		reiserfs_restore_prepared_buffer(sb, p_s_bh);
+		reiserfs_restore_prepared_buffer(sb, bh);
 	    } while (need_re_search &&
 		     search_for_position_by_key(sb, p_s_item_key, p_s_path) == POSITION_FOUND);
 	    pos_in_item(p_s_path) = pos * UNFM_P_SIZE;

commit a9dd364358fbdc68faee5d20c2d648c320dc3cf0
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:45 2009 -0400

    reiserfs: rename p_s_sb to sb
    
    This patch is a simple s/p_s_sb/sb/g to the reiserfs code.  This is the
    first in a series of patches to rip out some of the awful variable
    naming in reiserfs.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index a65bfee28bb8..00fd879c4a2a 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -245,7 +245,7 @@ static const struct reiserfs_key MAX_KEY = {
 static inline const struct reiserfs_key *get_lkey(const struct treepath
 						  *p_s_chk_path,
 						  const struct super_block
-						  *p_s_sb)
+						  *sb)
 {
 	int n_position, n_path_offset = p_s_chk_path->path_length;
 	struct buffer_head *p_s_parent;
@@ -282,14 +282,14 @@ static inline const struct reiserfs_key *get_lkey(const struct treepath
 	}
 	/* Return MIN_KEY if we are in the root of the buffer tree. */
 	if (PATH_OFFSET_PBUFFER(p_s_chk_path, FIRST_PATH_ELEMENT_OFFSET)->
-	    b_blocknr == SB_ROOT_BLOCK(p_s_sb))
+	    b_blocknr == SB_ROOT_BLOCK(sb))
 		return &MIN_KEY;
 	return &MAX_KEY;
 }
 
 /* Get delimiting key of the buffer at the path and its right neighbor. */
 inline const struct reiserfs_key *get_rkey(const struct treepath *p_s_chk_path,
-					   const struct super_block *p_s_sb)
+					   const struct super_block *sb)
 {
 	int n_position, n_path_offset = p_s_chk_path->path_length;
 	struct buffer_head *p_s_parent;
@@ -325,7 +325,7 @@ inline const struct reiserfs_key *get_rkey(const struct treepath *p_s_chk_path,
 	}
 	/* Return MAX_KEY if we are in the root of the buffer tree. */
 	if (PATH_OFFSET_PBUFFER(p_s_chk_path, FIRST_PATH_ELEMENT_OFFSET)->
-	    b_blocknr == SB_ROOT_BLOCK(p_s_sb))
+	    b_blocknr == SB_ROOT_BLOCK(sb))
 		return &MAX_KEY;
 	return &MIN_KEY;
 }
@@ -337,7 +337,7 @@ inline const struct reiserfs_key *get_rkey(const struct treepath *p_s_chk_path,
    this case get_lkey and get_rkey return a special key which is MIN_KEY or MAX_KEY. */
 static inline int key_in_buffer(struct treepath *p_s_chk_path,	/* Path which should be checked.  */
 				const struct cpu_key *p_s_key,	/* Key which should be checked.   */
-				struct super_block *p_s_sb	/* Super block pointer.           */
+				struct super_block *sb	/* Super block pointer.	   */
     )
 {
 
@@ -348,11 +348,11 @@ static inline int key_in_buffer(struct treepath *p_s_chk_path,	/* Path which sho
 	RFALSE(!PATH_PLAST_BUFFER(p_s_chk_path)->b_bdev,
 	       "PAP-5060: device must not be NODEV");
 
-	if (comp_keys(get_lkey(p_s_chk_path, p_s_sb), p_s_key) == 1)
+	if (comp_keys(get_lkey(p_s_chk_path, sb), p_s_key) == 1)
 		/* left delimiting key is bigger, that the key we look for */
 		return 0;
-	//  if ( comp_keys(p_s_key, get_rkey(p_s_chk_path, p_s_sb)) != -1 )
-	if (comp_keys(get_rkey(p_s_chk_path, p_s_sb), p_s_key) != 1)
+	//  if ( comp_keys(p_s_key, get_rkey(p_s_chk_path, sb)) != -1 )
+	if (comp_keys(get_rkey(p_s_chk_path, sb), p_s_key) != 1)
 		/* p_s_key must be less than right delimitiing key */
 		return 0;
 	return 1;
@@ -546,7 +546,7 @@ static void search_by_key_reada(struct super_block *s,
 /**************************************************************************
  * Algorithm   SearchByKey                                                *
  *             look for item in the Disk S+Tree by its key                *
- * Input:  p_s_sb   -  super block                                        *
+ * Input:  sb   -  super block                                            *
  *         p_s_key  - pointer to the key to search                        *
  * Output: ITEM_FOUND, ITEM_NOT_FOUND or IO_ERROR                         *
  *         p_s_search_path - path from the root to the needed leaf        *
@@ -566,7 +566,7 @@ static void search_by_key_reada(struct super_block *s,
    correctness of the top of the path but need not be checked for the
    correctness of the bottom of the path */
 /* The function is NOT SCHEDULE-SAFE! */
-int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/* Key to search. */
+int search_by_key(struct super_block *sb, const struct cpu_key *p_s_key,	/* Key to search. */
 		  struct treepath *p_s_search_path,/* This structure was
 						   allocated and initialized
 						   by the calling
@@ -592,7 +592,7 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
 	int n_repeat_counter = 0;
 #endif
 
-	PROC_INFO_INC(p_s_sb, search_by_key);
+	PROC_INFO_INC(sb, search_by_key);
 
 	/* As we add each node to a path we increase its count.  This means that
 	   we must be careful to release all nodes in a path before we either
@@ -605,13 +605,13 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
 	/* With each iteration of this loop we search through the items in the
 	   current node, and calculate the next current node(next path element)
 	   for the next iteration of this loop.. */
-	n_block_number = SB_ROOT_BLOCK(p_s_sb);
+	n_block_number = SB_ROOT_BLOCK(sb);
 	expected_level = -1;
 	while (1) {
 
 #ifdef CONFIG_REISERFS_CHECK
 		if (!(++n_repeat_counter % 50000))
-			reiserfs_warning(p_s_sb, "PAP-5100",
+			reiserfs_warning(sb, "PAP-5100",
 					 "%s: there were %d iterations of "
 					 "while loop looking for key %K",
 					 current->comm, n_repeat_counter,
@@ -622,14 +622,14 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
 		p_s_last_element =
 		    PATH_OFFSET_PELEMENT(p_s_search_path,
 					 ++p_s_search_path->path_length);
-		fs_gen = get_generation(p_s_sb);
+		fs_gen = get_generation(sb);
 
 		/* Read the next tree node, and set the last element in the path to
 		   have a pointer to it. */
 		if ((p_s_bh = p_s_last_element->pe_buffer =
-		     sb_getblk(p_s_sb, n_block_number))) {
+		     sb_getblk(sb, n_block_number))) {
 			if (!buffer_uptodate(p_s_bh) && reada_count > 1) {
-				search_by_key_reada(p_s_sb, reada_bh,
+				search_by_key_reada(sb, reada_bh,
 						    reada_blocks, reada_count);
 			}
 			ll_rw_block(READ, 1, &p_s_bh);
@@ -644,25 +644,25 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
 		}
 		reada_count = 0;
 		if (expected_level == -1)
-			expected_level = SB_TREE_HEIGHT(p_s_sb);
+			expected_level = SB_TREE_HEIGHT(sb);
 		expected_level--;
 
 		/* It is possible that schedule occurred. We must check whether the key
 		   to search is still in the tree rooted from the current buffer. If
 		   not then repeat search from the root. */
-		if (fs_changed(fs_gen, p_s_sb) &&
+		if (fs_changed(fs_gen, sb) &&
 		    (!B_IS_IN_TREE(p_s_bh) ||
 		     B_LEVEL(p_s_bh) != expected_level ||
-		     !key_in_buffer(p_s_search_path, p_s_key, p_s_sb))) {
-			PROC_INFO_INC(p_s_sb, search_by_key_fs_changed);
-			PROC_INFO_INC(p_s_sb, search_by_key_restarted);
-			PROC_INFO_INC(p_s_sb,
+		     !key_in_buffer(p_s_search_path, p_s_key, sb))) {
+			PROC_INFO_INC(sb, search_by_key_fs_changed);
+			PROC_INFO_INC(sb, search_by_key_restarted);
+			PROC_INFO_INC(sb,
 				      sbk_restarted[expected_level - 1]);
 			pathrelse(p_s_search_path);
 
 			/* Get the root block number so that we can repeat the search
 			   starting from the root. */
-			n_block_number = SB_ROOT_BLOCK(p_s_sb);
+			n_block_number = SB_ROOT_BLOCK(sb);
 			expected_level = -1;
 			right_neighbor_of_leaf_node = 0;
 
@@ -674,12 +674,12 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
 		   equal to the MAX_KEY. Latter case is only possible in
 		   "finish_unfinished()" processing during mount. */
 		RFALSE(comp_keys(&MAX_KEY, p_s_key) &&
-		       !key_in_buffer(p_s_search_path, p_s_key, p_s_sb),
+		       !key_in_buffer(p_s_search_path, p_s_key, sb),
 		       "PAP-5130: key is not in the buffer");
 #ifdef CONFIG_REISERFS_CHECK
 		if (cur_tb) {
 			print_cur_tb("5140");
-			reiserfs_panic(p_s_sb, "PAP-5140",
+			reiserfs_panic(sb, "PAP-5140",
 				       "schedule occurred in do_balance!");
 		}
 #endif
@@ -687,7 +687,7 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
 		// make sure, that the node contents look like a node of
 		// certain level
 		if (!is_tree_node(p_s_bh, expected_level)) {
-			reiserfs_error(p_s_sb, "vs-5150",
+			reiserfs_error(sb, "vs-5150",
 				       "invalid format found in block %ld. "
 				       "Fsck?", p_s_bh->b_blocknr);
 			pathrelse(p_s_search_path);
@@ -697,7 +697,7 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
 		/* ok, we have acquired next formatted node in the tree */
 		n_node_level = B_LEVEL(p_s_bh);
 
-		PROC_INFO_BH_STAT(p_s_sb, p_s_bh, n_node_level - 1);
+		PROC_INFO_BH_STAT(sb, p_s_bh, n_node_level - 1);
 
 		RFALSE(n_node_level < n_stop_level,
 		       "vs-5152: tree level (%d) is less than stop level (%d)",
@@ -776,7 +776,7 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
    units of directory entries.  */
 
 /* The function is NOT SCHEDULE-SAFE! */
-int search_for_position_by_key(struct super_block *p_s_sb,	/* Pointer to the super block.          */
+int search_for_position_by_key(struct super_block *sb,	/* Pointer to the super block.          */
 			       const struct cpu_key *p_cpu_key,	/* Key to search (cpu variable)         */
 			       struct treepath *p_s_search_path	/* Filled up by this function.          */
     )
@@ -789,13 +789,13 @@ int search_for_position_by_key(struct super_block *p_s_sb,	/* Pointer to the sup
 
 	/* If searching for directory entry. */
 	if (is_direntry_cpu_key(p_cpu_key))
-		return search_by_entry_key(p_s_sb, p_cpu_key, p_s_search_path,
+		return search_by_entry_key(sb, p_cpu_key, p_s_search_path,
 					   &de);
 
 	/* If not searching for directory entry. */
 
 	/* If item is found. */
-	retval = search_item(p_s_sb, p_cpu_key, p_s_search_path);
+	retval = search_item(sb, p_cpu_key, p_s_search_path);
 	if (retval == IO_ERROR)
 		return retval;
 	if (retval == ITEM_FOUND) {
@@ -817,7 +817,7 @@ int search_for_position_by_key(struct super_block *p_s_sb,	/* Pointer to the sup
 	p_le_ih =
 	    B_N_PITEM_HEAD(PATH_PLAST_BUFFER(p_s_search_path),
 			   --PATH_LAST_POSITION(p_s_search_path));
-	n_blk_size = p_s_sb->s_blocksize;
+	n_blk_size = sb->s_blocksize;
 
 	if (comp_short_keys(&(p_le_ih->ih_key), p_cpu_key)) {
 		return FILE_NOT_FOUND;
@@ -957,7 +957,7 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 				      int *p_n_cut_size, unsigned long long n_new_file_length	/* MAX_KEY_OFFSET in case of delete. */
     )
 {
-	struct super_block *p_s_sb = inode->i_sb;
+	struct super_block *sb = inode->i_sb;
 	struct item_head *p_le_ih = PATH_PITEM_HEAD(p_s_path);
 	struct buffer_head *p_s_bh = PATH_PLAST_BUFFER(p_s_path);
 
@@ -986,7 +986,7 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 
 	/* Case of an indirect item. */
 	{
-	    int blk_size = p_s_sb->s_blocksize;
+	    int blk_size = sb->s_blocksize;
 	    struct item_head s_ih;
 	    int need_re_search;
 	    int delete = 0;
@@ -1023,9 +1023,9 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 		    block = get_block_num(unfm, 0);
 
 		    if (block != 0) {
-			reiserfs_prepare_for_journal(p_s_sb, p_s_bh, 1);
+			reiserfs_prepare_for_journal(sb, p_s_bh, 1);
 			put_block_num(unfm, 0, 0);
-			journal_mark_dirty (th, p_s_sb, p_s_bh);
+			journal_mark_dirty (th, sb, p_s_bh);
 			reiserfs_free_block(th, inode, block, 1);
 		    }
 
@@ -1049,9 +1049,9 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 		/* a trick.  If the buffer has been logged, this will do nothing.  If
 		** we've broken the loop without logging it, it will restore the
 		** buffer */
-		reiserfs_restore_prepared_buffer(p_s_sb, p_s_bh);
+		reiserfs_restore_prepared_buffer(sb, p_s_bh);
 	    } while (need_re_search &&
-		     search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path) == POSITION_FOUND);
+		     search_for_position_by_key(sb, p_s_item_key, p_s_path) == POSITION_FOUND);
 	    pos_in_item(p_s_path) = pos * UNFM_P_SIZE;
 
 	    if (*p_n_cut_size == 0) {
@@ -1090,7 +1090,7 @@ static int calc_deleted_bytes_number(struct tree_balance *p_s_tb, char c_mode)
 
 static void init_tb_struct(struct reiserfs_transaction_handle *th,
 			   struct tree_balance *p_s_tb,
-			   struct super_block *p_s_sb,
+			   struct super_block *sb,
 			   struct treepath *p_s_path, int n_size)
 {
 
@@ -1098,7 +1098,7 @@ static void init_tb_struct(struct reiserfs_transaction_handle *th,
 
 	memset(p_s_tb, '\0', sizeof(struct tree_balance));
 	p_s_tb->transaction_handle = th;
-	p_s_tb->tb_sb = p_s_sb;
+	p_s_tb->tb_sb = sb;
 	p_s_tb->tb_path = p_s_path;
 	PATH_OFFSET_PBUFFER(p_s_path, ILLEGAL_PATH_ELEMENT_OFFSET) = NULL;
 	PATH_OFFSET_POSITION(p_s_path, ILLEGAL_PATH_ELEMENT_OFFSET) = 0;
@@ -1147,7 +1147,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath
 			 struct inode *p_s_inode,	/* inode is here just to update i_blocks and quotas */
 			 struct buffer_head *p_s_un_bh)
 {				/* NULL or unformatted node pointer.    */
-	struct super_block *p_s_sb = p_s_inode->i_sb;
+	struct super_block *sb = p_s_inode->i_sb;
 	struct tree_balance s_del_balance;
 	struct item_head s_ih;
 	struct item_head *q_ih;
@@ -1161,7 +1161,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath
 
 	BUG_ON(!th->t_trans_id);
 
-	init_tb_struct(th, &s_del_balance, p_s_sb, p_s_path,
+	init_tb_struct(th, &s_del_balance, sb, p_s_path,
 		       0 /*size is unknown */ );
 
 	while (1) {
@@ -1185,15 +1185,15 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath
 		if (n_ret_value != REPEAT_SEARCH)
 			break;
 
-		PROC_INFO_INC(p_s_sb, delete_item_restarted);
+		PROC_INFO_INC(sb, delete_item_restarted);
 
 		// file system changed, repeat search
 		n_ret_value =
-		    search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path);
+		    search_for_position_by_key(sb, p_s_item_key, p_s_path);
 		if (n_ret_value == IO_ERROR)
 			break;
 		if (n_ret_value == FILE_NOT_FOUND) {
-			reiserfs_warning(p_s_sb, "vs-5340",
+			reiserfs_warning(sb, "vs-5340",
 					 "no items of the file %K found",
 					 p_s_item_key);
 			break;
@@ -1216,8 +1216,8 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath
 	 ** the unfm node once
 	 */
 	if (!S_ISLNK(p_s_inode->i_mode) && is_direct_le_ih(q_ih)) {
-		if ((le_ih_k_offset(q_ih) & (p_s_sb->s_blocksize - 1)) == 1) {
-			quota_cut_bytes = p_s_sb->s_blocksize + UNFM_P_SIZE;
+		if ((le_ih_k_offset(q_ih) & (sb->s_blocksize - 1)) == 1) {
+			quota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;
 		} else {
 			quota_cut_bytes = 0;
 		}
@@ -1258,7 +1258,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath
 	do_balance(&s_del_balance, NULL, NULL, M_DELETE);
 
 #ifdef REISERQUOTA_DEBUG
-	reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE,
+	reiserfs_debug(sb, REISERFS_DEBUG_CODE,
 		       "reiserquota delete_item(): freeing %u, id=%u type=%c",
 		       quota_cut_bytes, p_s_inode->i_uid, head2type(&s_ih));
 #endif
@@ -1430,8 +1430,8 @@ static int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,
 				    const struct cpu_key *p_s_item_key,
 				    loff_t n_new_file_size, char *p_c_mode)
 {
-	struct super_block *p_s_sb = p_s_inode->i_sb;
-	int n_block_size = p_s_sb->s_blocksize;
+	struct super_block *sb = p_s_inode->i_sb;
+	int n_block_size = sb->s_blocksize;
 	int cut_bytes;
 	BUG_ON(!th->t_trans_id);
 	BUG_ON(n_new_file_size != p_s_inode->i_size);
@@ -1509,7 +1509,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 			   struct inode *p_s_inode,
 			   struct page *page, loff_t n_new_file_size)
 {
-	struct super_block *p_s_sb = p_s_inode->i_sb;
+	struct super_block *sb = p_s_inode->i_sb;
 	/* Every function which is going to call do_balance must first
 	   create a tree_balance structure.  Then it must fill up this
 	   structure by using the init_tb_struct and fix_nodes functions.
@@ -1560,7 +1560,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 			/* removing of last unformatted node will change value we
 			   have to return to truncate. Save it */
 			retval2 = n_ret_value;
-			/*retval2 = p_s_sb->s_blocksize - (n_new_file_size & (p_s_sb->s_blocksize - 1)); */
+			/*retval2 = sb->s_blocksize - (n_new_file_size & (sb->s_blocksize - 1)); */
 
 			/* So, we have performed the first part of the conversion:
 			   inserting the new direct item.  Now we are removing the
@@ -1569,16 +1569,16 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 			set_cpu_key_k_type(p_s_item_key, TYPE_INDIRECT);
 			p_s_item_key->key_length = 4;
 			n_new_file_size -=
-			    (n_new_file_size & (p_s_sb->s_blocksize - 1));
+			    (n_new_file_size & (sb->s_blocksize - 1));
 			tail_pos = n_new_file_size;
 			set_cpu_key_k_offset(p_s_item_key, n_new_file_size + 1);
 			if (search_for_position_by_key
-			    (p_s_sb, p_s_item_key,
+			    (sb, p_s_item_key,
 			     p_s_path) == POSITION_NOT_FOUND) {
 				print_block(PATH_PLAST_BUFFER(p_s_path), 3,
 					    PATH_LAST_POSITION(p_s_path) - 1,
 					    PATH_LAST_POSITION(p_s_path) + 1);
-				reiserfs_panic(p_s_sb, "PAP-5580", "item to "
+				reiserfs_panic(sb, "PAP-5580", "item to "
 					       "convert does not exist (%K)",
 					       p_s_item_key);
 			}
@@ -1595,14 +1595,14 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		if (n_ret_value != REPEAT_SEARCH)
 			break;
 
-		PROC_INFO_INC(p_s_sb, cut_from_item_restarted);
+		PROC_INFO_INC(sb, cut_from_item_restarted);
 
 		n_ret_value =
-		    search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path);
+		    search_for_position_by_key(sb, p_s_item_key, p_s_path);
 		if (n_ret_value == POSITION_FOUND)
 			continue;
 
-		reiserfs_warning(p_s_sb, "PAP-5610", "item %K not found",
+		reiserfs_warning(sb, "PAP-5610", "item %K not found",
 				 p_s_item_key);
 		unfix_nodes(&s_cut_balance);
 		return (n_ret_value == IO_ERROR) ? -EIO : -ENOENT;
@@ -1616,7 +1616,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 			indirect_to_direct_roll_back(th, p_s_inode, p_s_path);
 		}
 		if (n_ret_value == NO_DISK_SPACE)
-			reiserfs_warning(p_s_sb, "reiserfs-5092",
+			reiserfs_warning(sb, "reiserfs-5092",
 					 "NO_DISK_SPACE");
 		unfix_nodes(&s_cut_balance);
 		return -EIO;
@@ -1642,11 +1642,11 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 	p_le_ih = PATH_PITEM_HEAD(s_cut_balance.tb_path);
 	if (!S_ISLNK(p_s_inode->i_mode) && is_direct_le_ih(p_le_ih)) {
 		if (c_mode == M_DELETE &&
-		    (le_ih_k_offset(p_le_ih) & (p_s_sb->s_blocksize - 1)) ==
+		    (le_ih_k_offset(p_le_ih) & (sb->s_blocksize - 1)) ==
 		    1) {
 			// FIXME: this is to keep 3.5 happy
 			REISERFS_I(p_s_inode)->i_first_direct_byte = U32_MAX;
-			quota_cut_bytes = p_s_sb->s_blocksize + UNFM_P_SIZE;
+			quota_cut_bytes = sb->s_blocksize + UNFM_P_SIZE;
 		} else {
 			quota_cut_bytes = 0;
 		}
@@ -1659,18 +1659,18 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		   sure, that we exactly remove last unformatted node pointer
 		   of the item */
 		if (!is_indirect_le_ih(le_ih))
-			reiserfs_panic(p_s_sb, "vs-5652",
+			reiserfs_panic(sb, "vs-5652",
 				       "item must be indirect %h", le_ih);
 
 		if (c_mode == M_DELETE && ih_item_len(le_ih) != UNFM_P_SIZE)
-			reiserfs_panic(p_s_sb, "vs-5653", "completing "
+			reiserfs_panic(sb, "vs-5653", "completing "
 				       "indirect2direct conversion indirect "
 				       "item %h being deleted must be of "
 				       "4 byte long", le_ih);
 
 		if (c_mode == M_CUT
 		    && s_cut_balance.insert_size[0] != -UNFM_P_SIZE) {
-			reiserfs_panic(p_s_sb, "vs-5654", "can not complete "
+			reiserfs_panic(sb, "vs-5654", "can not complete "
 				       "indirect2direct conversion of %h "
 				       "(CUT, insert_size==%d)",
 				       le_ih, s_cut_balance.insert_size[0]);

commit 0222e6571c332563a48d4cf5487b67feabe60b5e
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:44 2009 -0400

    reiserfs: strip trailing whitespace
    
    This patch strips trailing whitespace from the reiserfs code.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index b2eaa0c6b7b7..a65bfee28bb8 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -77,7 +77,7 @@ inline void copy_item_head(struct item_head *p_v_to,
 /* k1 is pointer to on-disk structure which is stored in little-endian
    form. k2 is pointer to cpu variable. For key of items of the same
    object this returns 0.
-   Returns: -1 if key1 < key2 
+   Returns: -1 if key1 < key2
    0 if key1 == key2
    1 if key1 > key2 */
 inline int comp_short_keys(const struct reiserfs_key *le_key,
@@ -890,7 +890,7 @@ static inline int prepare_for_direct_item(struct treepath *path,
 	}
 	// new file gets truncated
 	if (get_inode_item_key_version(inode) == KEY_FORMAT_3_6) {
-		// 
+		//
 		round_len = ROUND_UP(new_file_length);
 		/* this was n_new_file_length < le_ih ... */
 		if (round_len < le_ih_k_offset(le_ih)) {
@@ -1443,7 +1443,7 @@ static int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,
 	if (atomic_read(&p_s_inode->i_count) > 1 ||
 	    !tail_has_to_be_packed(p_s_inode) ||
 	    !page || (REISERFS_I(p_s_inode)->i_flags & i_nopack_mask)) {
-		// leave tail in an unformatted node    
+		/* leave tail in an unformatted node */
 		*p_c_mode = M_SKIP_BALANCING;
 		cut_bytes =
 		    n_block_size - (n_new_file_size & (n_block_size - 1));
@@ -1826,7 +1826,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th, struct inode *p
 		/* While there are bytes to truncate and previous file item is presented in the tree. */
 
 		/*
-		 ** This loop could take a really long time, and could log 
+		 ** This loop could take a really long time, and could log
 		 ** many more blocks than a transaction can hold.  So, we do a polite
 		 ** journal end here, and if the transaction needs ending, we make
 		 ** sure the file is consistent before ending the current trans

commit 3cd6dbe6feb9b32347e6c6f25a27f0cde9d50418
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:43 2009 -0400

    reiserfs: cleanup path functions
    
    This patch cleans up some redundancies in the reiserfs tree path code.
    
    decrement_bcount() is essentially the same function as brelse(), so we use
    that instead.
    
    decrement_counters_in_path() is exactly the same function as pathrelse(), so
    we kill that and use pathrelse() instead.
    
    There's also a bit of cleanup that makes the code a bit more readable.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index ec837a250a4f..b2eaa0c6b7b7 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -23,7 +23,6 @@
  * get_rkey
  * key_in_buffer
  * decrement_bcount
- * decrement_counters_in_path
  * reiserfs_check_path
  * pathrelse_and_restore
  * pathrelse
@@ -359,36 +358,6 @@ static inline int key_in_buffer(struct treepath *p_s_chk_path,	/* Path which sho
 	return 1;
 }
 
-inline void decrement_bcount(struct buffer_head *p_s_bh)
-{
-	if (p_s_bh) {
-		if (atomic_read(&(p_s_bh->b_count))) {
-			put_bh(p_s_bh);
-			return;
-		}
-		reiserfs_panic(NULL, "PAP-5070",
-			       "trying to free free buffer %b", p_s_bh);
-	}
-}
-
-/* Decrement b_count field of the all buffers in the path. */
-void decrement_counters_in_path(struct treepath *p_s_search_path)
-{
-	int n_path_offset = p_s_search_path->path_length;
-
-	RFALSE(n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET ||
-	       n_path_offset > EXTENDED_MAX_HEIGHT - 1,
-	       "PAP-5080: invalid path offset of %d", n_path_offset);
-
-	while (n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {
-		struct buffer_head *bh;
-
-		bh = PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--);
-		decrement_bcount(bh);
-	}
-	p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
-}
-
 int reiserfs_check_path(struct treepath *p)
 {
 	RFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,
@@ -396,12 +365,11 @@ int reiserfs_check_path(struct treepath *p)
 	return 0;
 }
 
-/* Release all buffers in the path. Restore dirty bits clean
-** when preparing the buffer for the log
-**
-** only called from fix_nodes()
-*/
-void pathrelse_and_restore(struct super_block *s, struct treepath *p_s_search_path)
+/* Drop the reference to each buffer in a path and restore
+ * dirty bits clean when preparing the buffer for the log.
+ * This version should only be called from fix_nodes() */
+void pathrelse_and_restore(struct super_block *sb,
+			   struct treepath *p_s_search_path)
 {
 	int n_path_offset = p_s_search_path->path_length;
 
@@ -409,16 +377,15 @@ void pathrelse_and_restore(struct super_block *s, struct treepath *p_s_search_pa
 	       "clm-4000: invalid path offset");
 
 	while (n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {
-		reiserfs_restore_prepared_buffer(s,
-						 PATH_OFFSET_PBUFFER
-						 (p_s_search_path,
-						  n_path_offset));
-		brelse(PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--));
+		struct buffer_head *bh;
+		bh = PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--);
+		reiserfs_restore_prepared_buffer(sb, bh);
+		brelse(bh);
 	}
 	p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
 }
 
-/* Release all buffers in the path. */
+/* Drop the reference to each buffer in a path */
 void pathrelse(struct treepath *p_s_search_path)
 {
 	int n_path_offset = p_s_search_path->path_length;
@@ -631,7 +598,7 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
 	   we must be careful to release all nodes in a path before we either
 	   discard the path struct or re-use the path struct, as we do here. */
 
-	decrement_counters_in_path(p_s_search_path);
+	pathrelse(p_s_search_path);
 
 	right_neighbor_of_leaf_node = 0;
 
@@ -691,7 +658,7 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
 			PROC_INFO_INC(p_s_sb, search_by_key_restarted);
 			PROC_INFO_INC(p_s_sb,
 				      sbk_restarted[expected_level - 1]);
-			decrement_counters_in_path(p_s_search_path);
+			pathrelse(p_s_search_path);
 
 			/* Get the root block number so that we can repeat the search
 			   starting from the root. */
@@ -1868,7 +1835,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th, struct inode *p
 		if (journal_transaction_should_end(th, 0) ||
 		    reiserfs_transaction_free_space(th) <= JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD) {
 			int orig_len_alloc = th->t_blocks_allocated;
-			decrement_counters_in_path(&s_search_path);
+			pathrelse(&s_search_path);
 
 			if (update_timestamps) {
 				p_s_inode->i_mtime = p_s_inode->i_ctime =

commit 0030b64570c862f04c1550ba4a0bf7a9c128162a
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:28 2009 -0400

    reiserfs: use reiserfs_error()
    
    This patch makes many paths that are currently using warnings to handle
    the error.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 2de1e309124b..ec837a250a4f 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -720,9 +720,9 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
 		// make sure, that the node contents look like a node of
 		// certain level
 		if (!is_tree_node(p_s_bh, expected_level)) {
-			reiserfs_warning(p_s_sb, "vs-5150",
-					 "invalid format found in block %ld. "
-					 "Fsck?", p_s_bh->b_blocknr);
+			reiserfs_error(p_s_sb, "vs-5150",
+				       "invalid format found in block %ld. "
+				       "Fsck?", p_s_bh->b_blocknr);
 			pathrelse(p_s_search_path);
 			return IO_ERROR;
 		}
@@ -1336,9 +1336,9 @@ void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,
 	while (1) {
 		retval = search_item(th->t_super, &cpu_key, &path);
 		if (retval == IO_ERROR) {
-			reiserfs_warning(th->t_super, "vs-5350",
-					 "i/o failure occurred trying "
-					 "to delete %K", &cpu_key);
+			reiserfs_error(th->t_super, "vs-5350",
+				       "i/o failure occurred trying "
+				       "to delete %K", &cpu_key);
 			break;
 		}
 		if (retval != ITEM_FOUND) {
@@ -1737,7 +1737,7 @@ static void truncate_directory(struct reiserfs_transaction_handle *th,
 {
 	BUG_ON(!th->t_trans_id);
 	if (inode->i_nlink)
-		reiserfs_warning(inode->i_sb, "vs-5655", "link count != 0");
+		reiserfs_error(inode->i_sb, "vs-5655", "link count != 0");
 
 	set_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), DOT_OFFSET);
 	set_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_DIRENTRY);
@@ -1790,16 +1790,16 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th, struct inode *p
 	    search_for_position_by_key(p_s_inode->i_sb, &s_item_key,
 				       &s_search_path);
 	if (retval == IO_ERROR) {
-		reiserfs_warning(p_s_inode->i_sb, "vs-5657",
-				 "i/o failure occurred trying to truncate %K",
-				 &s_item_key);
+		reiserfs_error(p_s_inode->i_sb, "vs-5657",
+			       "i/o failure occurred trying to truncate %K",
+			       &s_item_key);
 		err = -EIO;
 		goto out;
 	}
 	if (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {
-		reiserfs_warning(p_s_inode->i_sb, "PAP-5660",
-				 "wrong result %d of search for %K", retval,
-				 &s_item_key);
+		reiserfs_error(p_s_inode->i_sb, "PAP-5660",
+			       "wrong result %d of search for %K", retval,
+			       &s_item_key);
 
 		err = -EIO;
 		goto out;

commit c3a9c2109f84882b9b3178f6b1838d550d3df0ec
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:25 2009 -0400

    reiserfs: rework reiserfs_panic
    
    ReiserFS panics can be somewhat inconsistent.
    In some cases:
     * a unique identifier may be associated with it
     * the function name may be included
     * the device may be printed separately
    
    This patch aims to make warnings more consistent. reiserfs_warning() prints
    the device name, so printing it a second time is not required. The function
    name for a warning is always helpful in debugging, so it is now automatically
    inserted into the output. Hans has stated that every warning should have
    a unique identifier. Some cases lack them, others really shouldn't have them.
    reiserfs_warning() now expects an id associated with each message. In the
    rare case where one isn't needed, "" will suffice.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index f328d27a19d5..2de1e309124b 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -366,9 +366,8 @@ inline void decrement_bcount(struct buffer_head *p_s_bh)
 			put_bh(p_s_bh);
 			return;
 		}
-		reiserfs_panic(NULL,
-			       "PAP-5070: decrement_bcount: trying to free free buffer %b",
-			       p_s_bh);
+		reiserfs_panic(NULL, "PAP-5070",
+			       "trying to free free buffer %b", p_s_bh);
 	}
 }
 
@@ -713,8 +712,8 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
 #ifdef CONFIG_REISERFS_CHECK
 		if (cur_tb) {
 			print_cur_tb("5140");
-			reiserfs_panic(p_s_sb,
-				       "PAP-5140: search_by_key: schedule occurred in do_balance!");
+			reiserfs_panic(p_s_sb, "PAP-5140",
+				       "schedule occurred in do_balance!");
 		}
 #endif
 
@@ -1511,8 +1510,8 @@ static void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,
 		/* look for the last byte of the tail */
 		if (search_for_position_by_key(inode->i_sb, &tail_key, path) ==
 		    POSITION_NOT_FOUND)
-			reiserfs_panic(inode->i_sb,
-				       "vs-5615: indirect_to_direct_roll_back: found invalid item");
+			reiserfs_panic(inode->i_sb, "vs-5615",
+				       "found invalid item");
 		RFALSE(path->pos_in_item !=
 		       ih_item_len(PATH_PITEM_HEAD(path)) - 1,
 		       "vs-5616: appended bytes found");
@@ -1612,8 +1611,8 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 				print_block(PATH_PLAST_BUFFER(p_s_path), 3,
 					    PATH_LAST_POSITION(p_s_path) - 1,
 					    PATH_LAST_POSITION(p_s_path) + 1);
-				reiserfs_panic(p_s_sb,
-					       "PAP-5580: reiserfs_cut_from_item: item to convert does not exist (%K)",
+				reiserfs_panic(p_s_sb, "PAP-5580", "item to "
+					       "convert does not exist (%K)",
 					       p_s_item_key);
 			}
 			continue;
@@ -1693,22 +1692,20 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		   sure, that we exactly remove last unformatted node pointer
 		   of the item */
 		if (!is_indirect_le_ih(le_ih))
-			reiserfs_panic(p_s_sb,
-				       "vs-5652: reiserfs_cut_from_item: "
+			reiserfs_panic(p_s_sb, "vs-5652",
 				       "item must be indirect %h", le_ih);
 
 		if (c_mode == M_DELETE && ih_item_len(le_ih) != UNFM_P_SIZE)
-			reiserfs_panic(p_s_sb,
-				       "vs-5653: reiserfs_cut_from_item: "
-				       "completing indirect2direct conversion indirect item %h "
-				       "being deleted must be of 4 byte long",
-				       le_ih);
+			reiserfs_panic(p_s_sb, "vs-5653", "completing "
+				       "indirect2direct conversion indirect "
+				       "item %h being deleted must be of "
+				       "4 byte long", le_ih);
 
 		if (c_mode == M_CUT
 		    && s_cut_balance.insert_size[0] != -UNFM_P_SIZE) {
-			reiserfs_panic(p_s_sb,
-				       "vs-5654: reiserfs_cut_from_item: "
-				       "can not complete indirect2direct conversion of %h (CUT, insert_size==%d)",
+			reiserfs_panic(p_s_sb, "vs-5654", "can not complete "
+				       "indirect2direct conversion of %h "
+				       "(CUT, insert_size==%d)",
 				       le_ih, s_cut_balance.insert_size[0]);
 		}
 		/* it would be useful to make sure, that right neighboring
@@ -1923,10 +1920,10 @@ static void check_research_for_paste(struct treepath *path,
 		    || op_bytes_number(found_ih,
 				       get_last_bh(path)->b_size) !=
 		    pos_in_item(path))
-			reiserfs_panic(NULL,
-				       "PAP-5720: check_research_for_paste: "
-				       "found direct item %h or position (%d) does not match to key %K",
-				       found_ih, pos_in_item(path), p_s_key);
+			reiserfs_panic(NULL, "PAP-5720", "found direct item "
+				       "%h or position (%d) does not match "
+				       "to key %K", found_ih,
+				       pos_in_item(path), p_s_key);
 	}
 	if (is_indirect_le_ih(found_ih)) {
 		if (le_ih_k_offset(found_ih) +
@@ -1935,9 +1932,9 @@ static void check_research_for_paste(struct treepath *path,
 		    cpu_key_k_offset(p_s_key)
 		    || I_UNFM_NUM(found_ih) != pos_in_item(path)
 		    || get_ih_free_space(found_ih) != 0)
-			reiserfs_panic(NULL,
-				       "PAP-5730: check_research_for_paste: "
-				       "found indirect item (%h) or position (%d) does not match to key (%K)",
+			reiserfs_panic(NULL, "PAP-5730", "found indirect "
+				       "item (%h) or position (%d) does not "
+				       "match to key (%K)",
 				       found_ih, pos_in_item(path), p_s_key);
 	}
 }

commit 45b03d5e8e674eb6555b767e1c8eb40b671ff892
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 30 14:02:21 2009 -0400

    reiserfs: rework reiserfs_warning
    
    ReiserFS warnings can be somewhat inconsistent.
    In some cases:
     * a unique identifier may be associated with it
     * the function name may be included
     * the device may be printed separately
    
    This patch aims to make warnings more consistent. reiserfs_warning() prints
    the device name, so printing it a second time is not required. The function
    name for a warning is always helpful in debugging, so it is now automatically
    inserted into the output. Hans has stated that every warning should have
    a unique identifier. Some cases lack them, others really shouldn't have them.
    reiserfs_warning() now expects an id associated with each message. In the
    rare case where one isn't needed, "" will suffice.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index abbc64dcc8d4..f328d27a19d5 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -444,23 +444,24 @@ static int is_leaf(char *buf, int blocksize, struct buffer_head *bh)
 
 	blkh = (struct block_head *)buf;
 	if (blkh_level(blkh) != DISK_LEAF_NODE_LEVEL) {
-		reiserfs_warning(NULL,
-				 "is_leaf: this should be caught earlier");
+		reiserfs_warning(NULL, "reiserfs-5080",
+				 "this should be caught earlier");
 		return 0;
 	}
 
 	nr = blkh_nr_item(blkh);
 	if (nr < 1 || nr > ((blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN))) {
 		/* item number is too big or too small */
-		reiserfs_warning(NULL, "is_leaf: nr_item seems wrong: %z", bh);
+		reiserfs_warning(NULL, "reiserfs-5081",
+				 "nr_item seems wrong: %z", bh);
 		return 0;
 	}
 	ih = (struct item_head *)(buf + BLKH_SIZE) + nr - 1;
 	used_space = BLKH_SIZE + IH_SIZE * nr + (blocksize - ih_location(ih));
 	if (used_space != blocksize - blkh_free_space(blkh)) {
 		/* free space does not match to calculated amount of use space */
-		reiserfs_warning(NULL, "is_leaf: free space seems wrong: %z",
-				 bh);
+		reiserfs_warning(NULL, "reiserfs-5082",
+				 "free space seems wrong: %z", bh);
 		return 0;
 	}
 	// FIXME: it is_leaf will hit performance too much - we may have
@@ -471,29 +472,29 @@ static int is_leaf(char *buf, int blocksize, struct buffer_head *bh)
 	prev_location = blocksize;
 	for (i = 0; i < nr; i++, ih++) {
 		if (le_ih_k_type(ih) == TYPE_ANY) {
-			reiserfs_warning(NULL,
-					 "is_leaf: wrong item type for item %h",
+			reiserfs_warning(NULL, "reiserfs-5083",
+					 "wrong item type for item %h",
 					 ih);
 			return 0;
 		}
 		if (ih_location(ih) >= blocksize
 		    || ih_location(ih) < IH_SIZE * nr) {
-			reiserfs_warning(NULL,
-					 "is_leaf: item location seems wrong: %h",
+			reiserfs_warning(NULL, "reiserfs-5084",
+					 "item location seems wrong: %h",
 					 ih);
 			return 0;
 		}
 		if (ih_item_len(ih) < 1
 		    || ih_item_len(ih) > MAX_ITEM_LEN(blocksize)) {
-			reiserfs_warning(NULL,
-					 "is_leaf: item length seems wrong: %h",
+			reiserfs_warning(NULL, "reiserfs-5085",
+					 "item length seems wrong: %h",
 					 ih);
 			return 0;
 		}
 		if (prev_location - ih_location(ih) != ih_item_len(ih)) {
-			reiserfs_warning(NULL,
-					 "is_leaf: item location seems wrong (second one): %h",
-					 ih);
+			reiserfs_warning(NULL, "reiserfs-5086",
+					 "item location seems wrong "
+					 "(second one): %h", ih);
 			return 0;
 		}
 		prev_location = ih_location(ih);
@@ -514,24 +515,23 @@ static int is_internal(char *buf, int blocksize, struct buffer_head *bh)
 	nr = blkh_level(blkh);
 	if (nr <= DISK_LEAF_NODE_LEVEL || nr > MAX_HEIGHT) {
 		/* this level is not possible for internal nodes */
-		reiserfs_warning(NULL,
-				 "is_internal: this should be caught earlier");
+		reiserfs_warning(NULL, "reiserfs-5087",
+				 "this should be caught earlier");
 		return 0;
 	}
 
 	nr = blkh_nr_item(blkh);
 	if (nr > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE)) {
 		/* for internal which is not root we might check min number of keys */
-		reiserfs_warning(NULL,
-				 "is_internal: number of key seems wrong: %z",
-				 bh);
+		reiserfs_warning(NULL, "reiserfs-5088",
+				 "number of key seems wrong: %z", bh);
 		return 0;
 	}
 
 	used_space = BLKH_SIZE + KEY_SIZE * nr + DC_SIZE * (nr + 1);
 	if (used_space != blocksize - blkh_free_space(blkh)) {
-		reiserfs_warning(NULL,
-				 "is_internal: free space seems wrong: %z", bh);
+		reiserfs_warning(NULL, "reiserfs-5089",
+				 "free space seems wrong: %z", bh);
 		return 0;
 	}
 	// one may imagine much more checks
@@ -543,8 +543,8 @@ static int is_internal(char *buf, int blocksize, struct buffer_head *bh)
 static int is_tree_node(struct buffer_head *bh, int level)
 {
 	if (B_LEVEL(bh) != level) {
-		reiserfs_warning(NULL,
-				 "is_tree_node: node level %d does not match to the expected one %d",
+		reiserfs_warning(NULL, "reiserfs-5090", "node level %d does "
+				 "not match to the expected one %d",
 				 B_LEVEL(bh), level);
 		return 0;
 	}
@@ -645,9 +645,9 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
 
 #ifdef CONFIG_REISERFS_CHECK
 		if (!(++n_repeat_counter % 50000))
-			reiserfs_warning(p_s_sb, "PAP-5100: search_by_key: %s:"
-					 "there were %d iterations of while loop "
-					 "looking for key %K",
+			reiserfs_warning(p_s_sb, "PAP-5100",
+					 "%s: there were %d iterations of "
+					 "while loop looking for key %K",
 					 current->comm, n_repeat_counter,
 					 p_s_key);
 #endif
@@ -721,9 +721,9 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
 		// make sure, that the node contents look like a node of
 		// certain level
 		if (!is_tree_node(p_s_bh, expected_level)) {
-			reiserfs_warning(p_s_sb, "vs-5150: search_by_key: "
-					 "invalid format found in block %ld. Fsck?",
-					 p_s_bh->b_blocknr);
+			reiserfs_warning(p_s_sb, "vs-5150",
+					 "invalid format found in block %ld. "
+					 "Fsck?", p_s_bh->b_blocknr);
 			pathrelse(p_s_search_path);
 			return IO_ERROR;
 		}
@@ -1227,8 +1227,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath
 		if (n_ret_value == IO_ERROR)
 			break;
 		if (n_ret_value == FILE_NOT_FOUND) {
-			reiserfs_warning(p_s_sb,
-					 "vs-5340: reiserfs_delete_item: "
+			reiserfs_warning(p_s_sb, "vs-5340",
 					 "no items of the file %K found",
 					 p_s_item_key);
 			break;
@@ -1338,10 +1337,9 @@ void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,
 	while (1) {
 		retval = search_item(th->t_super, &cpu_key, &path);
 		if (retval == IO_ERROR) {
-			reiserfs_warning(th->t_super,
-					 "vs-5350: reiserfs_delete_solid_item: "
-					 "i/o failure occurred trying to delete %K",
-					 &cpu_key);
+			reiserfs_warning(th->t_super, "vs-5350",
+					 "i/o failure occurred trying "
+					 "to delete %K", &cpu_key);
 			break;
 		}
 		if (retval != ITEM_FOUND) {
@@ -1355,9 +1353,8 @@ void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,
 			     GET_GENERATION_NUMBER(le_key_k_offset
 						   (le_key_version(key),
 						    key)) == 1))
-				reiserfs_warning(th->t_super,
-						 "vs-5355: reiserfs_delete_solid_item: %k not found",
-						 key);
+				reiserfs_warning(th->t_super, "vs-5355",
+						 "%k not found", key);
 			break;
 		}
 		if (!tb_init) {
@@ -1389,8 +1386,7 @@ void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,
 			break;
 		}
 		// IO_ERROR, NO_DISK_SPACE, etc
-		reiserfs_warning(th->t_super,
-				 "vs-5360: reiserfs_delete_solid_item: "
+		reiserfs_warning(th->t_super, "vs-5360",
 				 "could not delete %K due to fix_nodes failure",
 				 &cpu_key);
 		unfix_nodes(&tb);
@@ -1533,8 +1529,9 @@ static void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,
 		set_cpu_key_k_offset(&tail_key,
 				     cpu_key_k_offset(&tail_key) - removed);
 	}
-	reiserfs_warning(inode->i_sb,
-			 "indirect_to_direct_roll_back: indirect_to_direct conversion has been rolled back due to lack of disk space");
+	reiserfs_warning(inode->i_sb, "reiserfs-5091", "indirect_to_direct "
+			 "conversion has been rolled back due to "
+			 "lack of disk space");
 	//mark_file_without_tail (inode);
 	mark_inode_dirty(inode);
 }
@@ -1639,8 +1636,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		if (n_ret_value == POSITION_FOUND)
 			continue;
 
-		reiserfs_warning(p_s_sb,
-				 "PAP-5610: reiserfs_cut_from_item: item %K not found",
+		reiserfs_warning(p_s_sb, "PAP-5610", "item %K not found",
 				 p_s_item_key);
 		unfix_nodes(&s_cut_balance);
 		return (n_ret_value == IO_ERROR) ? -EIO : -ENOENT;
@@ -1654,7 +1650,8 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 			indirect_to_direct_roll_back(th, p_s_inode, p_s_path);
 		}
 		if (n_ret_value == NO_DISK_SPACE)
-			reiserfs_warning(p_s_sb, "NO_DISK_SPACE");
+			reiserfs_warning(p_s_sb, "reiserfs-5092",
+					 "NO_DISK_SPACE");
 		unfix_nodes(&s_cut_balance);
 		return -EIO;
 	}
@@ -1743,8 +1740,7 @@ static void truncate_directory(struct reiserfs_transaction_handle *th,
 {
 	BUG_ON(!th->t_trans_id);
 	if (inode->i_nlink)
-		reiserfs_warning(inode->i_sb,
-				 "vs-5655: truncate_directory: link count != 0");
+		reiserfs_warning(inode->i_sb, "vs-5655", "link count != 0");
 
 	set_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), DOT_OFFSET);
 	set_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_DIRENTRY);
@@ -1797,16 +1793,14 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th, struct inode *p
 	    search_for_position_by_key(p_s_inode->i_sb, &s_item_key,
 				       &s_search_path);
 	if (retval == IO_ERROR) {
-		reiserfs_warning(p_s_inode->i_sb,
-				 "vs-5657: reiserfs_do_truncate: "
+		reiserfs_warning(p_s_inode->i_sb, "vs-5657",
 				 "i/o failure occurred trying to truncate %K",
 				 &s_item_key);
 		err = -EIO;
 		goto out;
 	}
 	if (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {
-		reiserfs_warning(p_s_inode->i_sb,
-				 "PAP-5660: reiserfs_do_truncate: "
+		reiserfs_warning(p_s_inode->i_sb, "PAP-5660",
 				 "wrong result %d of search for %K", retval,
 				 &s_item_key);
 
@@ -1850,8 +1844,8 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th, struct inode *p
 		    reiserfs_cut_from_item(th, &s_search_path, &s_item_key,
 					   p_s_inode, page, n_new_file_size);
 		if (n_deleted < 0) {
-			reiserfs_warning(p_s_inode->i_sb,
-					 "vs-5665: reiserfs_do_truncate: reiserfs_cut_from_item failed");
+			reiserfs_warning(p_s_inode->i_sb, "vs-5665",
+					 "reiserfs_cut_from_item failed");
 			reiserfs_check_path(&s_search_path);
 			return 0;
 		}
@@ -2000,8 +1994,8 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 			goto error_out;
 		}
 		if (retval == POSITION_FOUND) {
-			reiserfs_warning(inode->i_sb,
-					 "PAP-5710: reiserfs_paste_into_item: entry or pasted byte (%K) exists",
+			reiserfs_warning(inode->i_sb, "PAP-5710",
+					 "entry or pasted byte (%K) exists",
 					 p_s_key);
 			retval = -EEXIST;
 			goto error_out;
@@ -2087,8 +2081,7 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th, struct treepath
 			goto error_out;
 		}
 		if (retval == ITEM_FOUND) {
-			reiserfs_warning(th->t_super,
-					 "PAP-5760: reiserfs_insert_item: "
+			reiserfs_warning(th->t_super, "PAP-5760",
 					 "key %K already exists in the tree",
 					 key);
 			retval = -EEXIST;

commit 77db4f25bca22ce96be0cd3c5a3160599817ff45
Author: Jan Kara <jack@suse.cz>
Date:   Mon Jan 26 17:14:18 2009 +0100

    reiserfs: Use lowercase names of quota functions
    
    Use lowercase names of quota functions instead of old uppercase ones.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    CC: reiserfs-devel@vger.kernel.org

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index abbc64dcc8d4..73aaa33f6735 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1297,7 +1297,7 @@ int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath
 		       "reiserquota delete_item(): freeing %u, id=%u type=%c",
 		       quota_cut_bytes, p_s_inode->i_uid, head2type(&s_ih));
 #endif
-	DQUOT_FREE_SPACE_NODIRTY(p_s_inode, quota_cut_bytes);
+	vfs_dq_free_space_nodirty(p_s_inode, quota_cut_bytes);
 
 	/* Return deleted body length */
 	return n_ret_value;
@@ -1383,7 +1383,7 @@ void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,
 					       quota_cut_bytes, inode->i_uid,
 					       key2type(key));
 #endif
-				DQUOT_FREE_SPACE_NODIRTY(inode,
+				vfs_dq_free_space_nodirty(inode,
 							 quota_cut_bytes);
 			}
 			break;
@@ -1734,7 +1734,7 @@ int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
 		       "reiserquota cut_from_item(): freeing %u id=%u type=%c",
 		       quota_cut_bytes, p_s_inode->i_uid, '?');
 #endif
-	DQUOT_FREE_SPACE_NODIRTY(p_s_inode, quota_cut_bytes);
+	vfs_dq_free_space_nodirty(p_s_inode, quota_cut_bytes);
 	return n_ret_value;
 }
 
@@ -1971,7 +1971,7 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 		       key2type(&(p_s_key->on_disk_key)));
 #endif
 
-	if (DQUOT_ALLOC_SPACE_NODIRTY(inode, n_pasted_size)) {
+	if (vfs_dq_alloc_space_nodirty(inode, n_pasted_size)) {
 		pathrelse(p_s_search_path);
 		return -EDQUOT;
 	}
@@ -2027,7 +2027,7 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct tree
 		       n_pasted_size, inode->i_uid,
 		       key2type(&(p_s_key->on_disk_key)));
 #endif
-	DQUOT_FREE_SPACE_NODIRTY(inode, n_pasted_size);
+	vfs_dq_free_space_nodirty(inode, n_pasted_size);
 	return retval;
 }
 
@@ -2060,7 +2060,7 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th, struct treepath
 #endif
 		/* We can't dirty inode here. It would be immediately written but
 		 * appropriate stat item isn't inserted yet... */
-		if (DQUOT_ALLOC_SPACE_NODIRTY(inode, quota_bytes)) {
+		if (vfs_dq_alloc_space_nodirty(inode, quota_bytes)) {
 			pathrelse(p_s_path);
 			return -EDQUOT;
 		}
@@ -2112,6 +2112,6 @@ int reiserfs_insert_item(struct reiserfs_transaction_handle *th, struct treepath
 		       quota_bytes, inode->i_uid, head2type(p_s_ih));
 #endif
 	if (inode)
-		DQUOT_FREE_SPACE_NODIRTY(inode, quota_bytes);
+		vfs_dq_free_space_nodirty(inode, quota_bytes);
 	return retval;
 }

commit 9e902df6be2cb7444e5a0f7e2e72bcbf3b978f3e
Author: Marcin Slusarz <marcin.slusarz@gmail.com>
Date:   Mon Apr 28 02:16:20 2008 -0700

    reiserfs: le*_add_cpu conversion
    
    replace all:
    little_endian_variable = cpu_to_leX(leX_to_cpu(little_endian_variable) +
                                            expression_in_cpu_byteorder);
    with:
            leX_add_cpu(&little_endian_variable, expression_in_cpu_byteorder);
    generated with semantic patch
    
    Signed-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index d2db2417b2bd..abbc64dcc8d4 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1419,8 +1419,7 @@ int reiserfs_delete_object(struct reiserfs_transaction_handle *th,
 
 		inode_generation =
 		    &REISERFS_SB(th->t_super)->s_rs->s_inode_generation;
-		*inode_generation =
-		    cpu_to_le32(le32_to_cpu(*inode_generation) + 1);
+		le32_add_cpu(inode_generation, 1);
 	}
 /* USE_INODE_GENERATION_COUNTER */
 #endif

commit c06a018fa5362fa9ed0768bd747c0fab26bc8849
Author: Fengguang Wu <wfg@mail.ustc.edu.cn>
Date:   Wed Nov 14 16:59:54 2007 -0800

    reiserfs: don't drop PG_dirty when releasing sub-page-sized dirty file
    
    This is not a new problem in 2.6.23-git17.  2.6.22/2.6.23 is buggy in the
    same way.
    
    Reiserfs could accumulate dirty sub-page-size files until umount time.
    They cannot be synced to disk by pdflush routines or explicit `sync'
    commands.  Only `umount' can do the trick.
    
    The direct cause is: the dirty page's PG_dirty is wrongly _cleared_.
    Call trace:
             [<ffffffff8027e920>] cancel_dirty_page+0xd0/0xf0
             [<ffffffff8816d470>] :reiserfs:reiserfs_cut_from_item+0x660/0x710
             [<ffffffff8816d791>] :reiserfs:reiserfs_do_truncate+0x271/0x530
             [<ffffffff8815872d>] :reiserfs:reiserfs_truncate_file+0xfd/0x3b0
             [<ffffffff8815d3d0>] :reiserfs:reiserfs_file_release+0x1e0/0x340
             [<ffffffff802a187c>] __fput+0xcc/0x1b0
             [<ffffffff802a1ba6>] fput+0x16/0x20
             [<ffffffff8029e676>] filp_close+0x56/0x90
             [<ffffffff8029fe0d>] sys_close+0xad/0x110
             [<ffffffff8020c41e>] system_call+0x7e/0x83
    
    Fix the bug by removing the cancel_dirty_page() call. Tests show that
    it causes no bad behaviors on various write sizes.
    
    === for the patient ===
    Here are more detailed demonstrations of the problem.
    
    1) the page has both PG_dirty(D)/PAGECACHE_TAG_DIRTY(d) after being written to;
       and then only PAGECACHE_TAG_DIRTY(d) remains after the file is closed.
    
    ------------------------------ screen 0 ------------------------------
    [T0] root /home/wfg# cat > /test/tiny
    [T1] hi
    [T2] root /home/wfg#
    
    ------------------------------ screen 1 ------------------------------
    [T1] root /home/wfg# echo /test/tiny > /proc/filecache
    [T1] root /home/wfg# cat /proc/filecache
         # file /test/tiny
         # flags R:referenced A:active M:mmap U:uptodate D:dirty W:writeback O:owner B:buffer d:dirty w:writeback
         # idx   len     state   refcnt
         0       1       ___UD__Bd_      2
    [T2] root /home/wfg# cat /proc/filecache
         # file /test/tiny
         # flags R:referenced A:active M:mmap U:uptodate D:dirty W:writeback O:owner B:buffer d:dirty w:writeback
         # idx   len     state   refcnt
         0       1       ___U___Bd_      2
    
    2) note the non-zero 'cancelled_write_bytes' after /tmp/hi is copied.
    
    ------------------------------ screen 0 ------------------------------
    [T0] root /home/wfg# echo hi > /tmp/hi
    [T1] root /home/wfg# cp /tmp/hi /dev/stdin /test
    [T2] hi
    [T3] root /home/wfg#
    
    ------------------------------ screen 1 ------------------------------
    [T1] root /proc/4397# cd /proc/`pidof cp`
    [T1] root /proc/4713# cat io
         rchar: 8396
         wchar: 3
         syscr: 20
         syscw: 1
         read_bytes: 0
         write_bytes: 20480
         cancelled_write_bytes: 4096
    [T2] root /proc/4713# cat io
         rchar: 8399
         wchar: 6
         syscr: 21
         syscw: 2
         read_bytes: 0
         write_bytes: 24576
         cancelled_write_bytes: 4096
    
    //Question: the 'write_bytes' is a bit more than expected ;-)
    
    Tested-by: Maxim Levitsky <maximlevitsky@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Fengguang Wu <wfg@mail.ustc.edu.cn>
    Reviewed-by: Chris Mason <chris.mason@oracle.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index ca41567d7890..d2db2417b2bd 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1458,9 +1458,6 @@ static void unmap_buffers(struct page *page, loff_t pos)
 				}
 				bh = next;
 			} while (bh != head);
-			if (PAGE_SIZE == bh->b_size) {
-				cancel_dirty_page(page, PAGE_CACHE_SIZE);
-			}
 		}
 	}
 }

commit 3ee1667042c350003b9d3f35e5666cc8c43ce8aa
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Oct 18 23:39:25 2007 -0700

    reiserfs: fix usage of signed ints for block numbers
    
    Do a quick signedness check for block numbers.  There are a number of places
    where signed integers are used for block numbers, which limits the usable file
    system size to 8 TiB.  The disk format, excepting a problem which will be
    fixed in the following patch, supports file systems up to 16 TiB in size.
    This patch cleans up those sites so that we can enable the full usable size.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 981027d1187b..ca41567d7890 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -559,7 +559,7 @@ static int is_tree_node(struct buffer_head *bh, int level)
 /* The function is NOT SCHEDULE-SAFE! */
 static void search_by_key_reada(struct super_block *s,
 				struct buffer_head **bh,
-				unsigned long *b, int num)
+				b_blocknr_t *b, int num)
 {
 	int i, j;
 
@@ -611,7 +611,7 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
 					   DISK_LEAF_NODE_LEVEL */
     )
 {
-	int n_block_number;
+	b_blocknr_t n_block_number;
 	int expected_level;
 	struct buffer_head *p_s_bh;
 	struct path_element *p_s_last_element;
@@ -619,7 +619,7 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
 	int right_neighbor_of_leaf_node;
 	int fs_gen;
 	struct buffer_head *reada_bh[SEARCH_BY_KEY_READA];
-	unsigned long reada_blocks[SEARCH_BY_KEY_READA];
+	b_blocknr_t reada_blocks[SEARCH_BY_KEY_READA];
 	int reada_count = 0;
 
 #ifdef CONFIG_REISERFS_CHECK

commit 87588dd6663b6f306f03f2deaec0d0fd3f0cb26e
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Jul 26 17:47:03 2007 +0100

    more reiserfs endianness annotations
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index b6f12593c39d..981027d1187b 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1042,7 +1042,8 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 		pos = I_UNFM_NUM(&s_ih);
 
 		while (le_ih_k_offset (&s_ih) + (pos - 1) * blk_size > n_new_file_length) {
-		    __u32 *unfm, block;
+		    __le32 *unfm;
+		    __u32 block;
 
 		    /* Each unformatted block deletion may involve one additional
 		     * bitmap block into the transaction, thereby the initial
@@ -1052,7 +1053,7 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 			break;
 		    }
 
-		    unfm = (__u32 *)B_I_PITEM(p_s_bh, &s_ih) + pos - 1;
+		    unfm = (__le32 *)B_I_PITEM(p_s_bh, &s_ih) + pos - 1;
 		    block = get_block_num(unfm, 0);
 
 		    if (block != 0) {

commit e63340ae6b6205fef26b40a75673d1c9c0c8bb90
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue May 8 00:28:08 2007 -0700

    header cleaning: don't include smp_lock.h when not used
    
    Remove includes of <linux/smp_lock.h> where it is not used/needed.
    Suggested by Al Viro.
    
    Builds cleanly on x86_64, i386, alpha, ia64, powerpc, sparc,
    sparc64, and arm (all 59 defconfigs).
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index afb21ea45302..b6f12593c39d 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -53,7 +53,6 @@
 #include <linux/string.h>
 #include <linux/pagemap.h>
 #include <linux/reiserfs_fs.h>
-#include <linux/smp_lock.h>
 #include <linux/buffer_head.h>
 #include <linux/quotaops.h>
 

commit ffaa82008f1aad52a6d3979f49d2a76c2928b60f
Author: Linus Torvalds <torvalds@woody.osdl.org>
Date:   Sat Dec 23 09:32:45 2006 -0800

    Fix reiserfs after "test_clear_page_dirty()" removal
    
    Thanks to Len Brown for testing this fix, since while they have in the
    past, none of my machines run reiserfs at the moment.
    
    Cc: Vladimir V. Saveliev <vs@namesys.com>
    Acked-by: Len Brown <lenb@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 47e7027ea39f..afb21ea45302 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1459,7 +1459,7 @@ static void unmap_buffers(struct page *page, loff_t pos)
 				bh = next;
 			} while (bh != head);
 			if (PAGE_SIZE == bh->b_size) {
-				clear_page_dirty(page);
+				cancel_dirty_page(page, PAGE_CACHE_SIZE);
 			}
 		}
 	}

commit fec6d055da71fb02a76f9c2c12427fa79974018b
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Fri Dec 8 02:36:32 2006 -0800

    [PATCH] struct path: rename Reiserfs's struct path
    
    Rename Reiserfs's struct path to struct treepath to prevent name collision
    between it and struct path from fs/namei.c.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Cc: <reiserfs-dev@namesys.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 5240abe1a709..47e7027ea39f 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -244,7 +244,7 @@ static const struct reiserfs_key MAX_KEY = {
    of the path, and going upwards.  We must check the path's validity at each step.  If the key is not in
    the path, there is no delimiting key in the tree (buffer is first or last buffer in tree), and in this
    case we return a special key, either MIN_KEY or MAX_KEY. */
-static inline const struct reiserfs_key *get_lkey(const struct path
+static inline const struct reiserfs_key *get_lkey(const struct treepath
 						  *p_s_chk_path,
 						  const struct super_block
 						  *p_s_sb)
@@ -290,7 +290,7 @@ static inline const struct reiserfs_key *get_lkey(const struct path
 }
 
 /* Get delimiting key of the buffer at the path and its right neighbor. */
-inline const struct reiserfs_key *get_rkey(const struct path *p_s_chk_path,
+inline const struct reiserfs_key *get_rkey(const struct treepath *p_s_chk_path,
 					   const struct super_block *p_s_sb)
 {
 	int n_position, n_path_offset = p_s_chk_path->path_length;
@@ -337,7 +337,7 @@ inline const struct reiserfs_key *get_rkey(const struct path *p_s_chk_path,
    the path.  These delimiting keys are stored at least one level above that buffer in the tree. If the
    buffer is the first or last node in the tree order then one of the delimiting keys may be absent, and in
    this case get_lkey and get_rkey return a special key which is MIN_KEY or MAX_KEY. */
-static inline int key_in_buffer(struct path *p_s_chk_path,	/* Path which should be checked.  */
+static inline int key_in_buffer(struct treepath *p_s_chk_path,	/* Path which should be checked.  */
 				const struct cpu_key *p_s_key,	/* Key which should be checked.   */
 				struct super_block *p_s_sb	/* Super block pointer.           */
     )
@@ -374,7 +374,7 @@ inline void decrement_bcount(struct buffer_head *p_s_bh)
 }
 
 /* Decrement b_count field of the all buffers in the path. */
-void decrement_counters_in_path(struct path *p_s_search_path)
+void decrement_counters_in_path(struct treepath *p_s_search_path)
 {
 	int n_path_offset = p_s_search_path->path_length;
 
@@ -391,7 +391,7 @@ void decrement_counters_in_path(struct path *p_s_search_path)
 	p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
 }
 
-int reiserfs_check_path(struct path *p)
+int reiserfs_check_path(struct treepath *p)
 {
 	RFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,
 	       "path not properly relsed");
@@ -403,7 +403,7 @@ int reiserfs_check_path(struct path *p)
 **
 ** only called from fix_nodes()
 */
-void pathrelse_and_restore(struct super_block *s, struct path *p_s_search_path)
+void pathrelse_and_restore(struct super_block *s, struct treepath *p_s_search_path)
 {
 	int n_path_offset = p_s_search_path->path_length;
 
@@ -421,7 +421,7 @@ void pathrelse_and_restore(struct super_block *s, struct path *p_s_search_path)
 }
 
 /* Release all buffers in the path. */
-void pathrelse(struct path *p_s_search_path)
+void pathrelse(struct treepath *p_s_search_path)
 {
 	int n_path_offset = p_s_search_path->path_length;
 
@@ -602,7 +602,7 @@ static void search_by_key_reada(struct super_block *s,
    correctness of the bottom of the path */
 /* The function is NOT SCHEDULE-SAFE! */
 int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/* Key to search. */
-		  struct path *p_s_search_path,	/* This structure was
+		  struct treepath *p_s_search_path,/* This structure was
 						   allocated and initialized
 						   by the calling
 						   function. It is filled up
@@ -813,7 +813,7 @@ int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/*
 /* The function is NOT SCHEDULE-SAFE! */
 int search_for_position_by_key(struct super_block *p_s_sb,	/* Pointer to the super block.          */
 			       const struct cpu_key *p_cpu_key,	/* Key to search (cpu variable)         */
-			       struct path *p_s_search_path	/* Filled up by this function.          */
+			       struct treepath *p_s_search_path	/* Filled up by this function.          */
     )
 {
 	struct item_head *p_le_ih;	/* pointer to on-disk structure */
@@ -884,7 +884,7 @@ int search_for_position_by_key(struct super_block *p_s_sb,	/* Pointer to the sup
 }
 
 /* Compare given item and item pointed to by the path. */
-int comp_items(const struct item_head *stored_ih, const struct path *p_s_path)
+int comp_items(const struct item_head *stored_ih, const struct treepath *p_s_path)
 {
 	struct buffer_head *p_s_bh;
 	struct item_head *ih;
@@ -911,7 +911,7 @@ int comp_items(const struct item_head *stored_ih, const struct path *p_s_path)
 #define block_in_use(bh) (buffer_locked(bh) || (held_by_others(bh)))
 
 // prepare for delete or cut of direct item
-static inline int prepare_for_direct_item(struct path *path,
+static inline int prepare_for_direct_item(struct treepath *path,
 					  struct item_head *le_ih,
 					  struct inode *inode,
 					  loff_t new_file_length, int *cut_size)
@@ -952,7 +952,7 @@ static inline int prepare_for_direct_item(struct path *path,
 	return M_CUT;		/* Cut from this item. */
 }
 
-static inline int prepare_for_direntry_item(struct path *path,
+static inline int prepare_for_direntry_item(struct treepath *path,
 					    struct item_head *le_ih,
 					    struct inode *inode,
 					    loff_t new_file_length,
@@ -987,7 +987,7 @@ static inline int prepare_for_direntry_item(struct path *path,
     In case of file truncate calculate whether this item must be deleted/truncated or last
     unformatted node of this item will be converted to a direct item.
     This function returns a determination of what balance mode the calling function should employ. */
-static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, struct inode *inode, struct path *p_s_path, const struct cpu_key *p_s_item_key, int *p_n_removed,	/* Number of unformatted nodes which were removed
+static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, struct inode *inode, struct treepath *p_s_path, const struct cpu_key *p_s_item_key, int *p_n_removed,	/* Number of unformatted nodes which were removed
 																						   from end of the file. */
 				      int *p_n_cut_size, unsigned long long n_new_file_length	/* MAX_KEY_OFFSET in case of delete. */
     )
@@ -1125,7 +1125,7 @@ static int calc_deleted_bytes_number(struct tree_balance *p_s_tb, char c_mode)
 static void init_tb_struct(struct reiserfs_transaction_handle *th,
 			   struct tree_balance *p_s_tb,
 			   struct super_block *p_s_sb,
-			   struct path *p_s_path, int n_size)
+			   struct treepath *p_s_path, int n_size)
 {
 
 	BUG_ON(!th->t_trans_id);
@@ -1176,7 +1176,7 @@ char head2type(struct item_head *ih)
 #endif
 
 /* Delete object item. */
-int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct path *p_s_path,	/* Path to the deleted item. */
+int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct treepath *p_s_path,	/* Path to the deleted item. */
 			 const struct cpu_key *p_s_item_key,	/* Key to search for the deleted item.  */
 			 struct inode *p_s_inode,	/* inode is here just to update i_blocks and quotas */
 			 struct buffer_head *p_s_un_bh)
@@ -1468,7 +1468,7 @@ static void unmap_buffers(struct page *page, loff_t pos)
 static int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,
 				    struct inode *p_s_inode,
 				    struct page *page,
-				    struct path *p_s_path,
+				    struct treepath *p_s_path,
 				    const struct cpu_key *p_s_item_key,
 				    loff_t n_new_file_size, char *p_c_mode)
 {
@@ -1503,7 +1503,7 @@ static int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,
    pointer being converted. Therefore we have to delete inserted
    direct item(s) */
 static void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,
-					 struct inode *inode, struct path *path)
+					 struct inode *inode, struct treepath *path)
 {
 	struct cpu_key tail_key;
 	int tail_len;
@@ -1545,7 +1545,7 @@ static void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,
 
 /* (Truncate or cut entry) or delete object item. Returns < 0 on failure */
 int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
-			   struct path *p_s_path,
+			   struct treepath *p_s_path,
 			   struct cpu_key *p_s_item_key,
 			   struct inode *p_s_inode,
 			   struct page *page, loff_t n_new_file_size)
@@ -1920,7 +1920,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th, struct inode *p
 
 #ifdef CONFIG_REISERFS_CHECK
 // this makes sure, that we __append__, not overwrite or add holes
-static void check_research_for_paste(struct path *path,
+static void check_research_for_paste(struct treepath *path,
 				     const struct cpu_key *p_s_key)
 {
 	struct item_head *found_ih = get_ih(path);
@@ -1954,7 +1954,7 @@ static void check_research_for_paste(struct path *path,
 #endif				/* config reiserfs check */
 
 /* Paste bytes to the existing item. Returns bytes number pasted into the item. */
-int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct path *p_s_search_path,	/* Path to the pasted item.          */
+int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct treepath *p_s_search_path,	/* Path to the pasted item.          */
 			     const struct cpu_key *p_s_key,	/* Key to search for the needed item. */
 			     struct inode *inode,	/* Inode item belongs to */
 			     const char *p_c_body,	/* Pointer to the bytes to paste.    */
@@ -2036,7 +2036,7 @@ int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct path
 }
 
 /* Insert new item into the buffer at the path. */
-int reiserfs_insert_item(struct reiserfs_transaction_handle *th, struct path *p_s_path,	/* Path to the inserteded item.         */
+int reiserfs_insert_item(struct reiserfs_transaction_handle *th, struct treepath *p_s_path,	/* Path to the inserteded item.         */
 			 const struct cpu_key *key, struct item_head *p_s_ih,	/* Pointer to the item header to insert. */
 			 struct inode *inode, const char *p_c_body)
 {				/* Pointer to the bytes to insert.      */

commit 14a61442c2203d2a49f2f954bfa9259c0ddac1aa
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Tue Oct 3 23:36:38 2006 +0200

    BUG_ON conversion for fs/reiserfs
    
    This patch converts several if () BUG(); construct to BUG_ON();
    which occupies less space, uses unlikely and is safer when
    BUG() is disabled. S_ISREG() has no side effects, so the
    conversion is safe.
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 8b9b13127136..5240abe1a709 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -1476,9 +1476,7 @@ static int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,
 	int n_block_size = p_s_sb->s_blocksize;
 	int cut_bytes;
 	BUG_ON(!th->t_trans_id);
-
-	if (n_new_file_size != p_s_inode->i_size)
-		BUG();
+	BUG_ON(n_new_file_size != p_s_inode->i_size);
 
 	/* the page being sent in could be NULL if there was an i/o error
 	 ** reading in the last block.  The user will hit problems trying to

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index d2b25e1ba6e9..8b9b13127136 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -49,7 +49,6 @@
  * reiserfs_insert_item
  */
 
-#include <linux/config.h>
 #include <linux/time.h>
 #include <linux/string.h>
 #include <linux/pagemap.h>

commit 23f9e0f891c9b159a199629d4426f6ae0c383508
Author: Alexander Zarochentzev <zam@namesys.com>
Date:   Sat Mar 25 03:06:57 2006 -0800

    [PATCH] reiserfs: fix transaction overflowing
    
    This patch fixes a bug in reiserfs truncate.  A transaction might overflow
    when truncating long highly fragmented file.  The fix is to split
    truncation into several transactions to avoid overflowing.
    
    Signed-off-by: Vladimir V. Saveliev <vs@namesys.com>
    Cc; Charles McColgan <cm@chuck.net>
    Cc: Alexander Zarochentsev <zam@namesys.com>
    Cc: Hans Reiser <reiser@namesys.com>
    Cc: Chris Mason <mason@suse.com>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index e2d08d7bcffc..d2b25e1ba6e9 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -981,6 +981,8 @@ static inline int prepare_for_direntry_item(struct path *path,
 	return M_CUT;
 }
 
+#define JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD (2 * JOURNAL_PER_BALANCE_CNT + 1)
+
 /*  If the path points to a directory or direct item, calculate mode and the size cut, for balance.
     If the path points to an indirect item, remove some number of its unformatted nodes.
     In case of file truncate calculate whether this item must be deleted/truncated or last
@@ -1020,148 +1022,79 @@ static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, st
 
 	/* Case of an indirect item. */
 	{
-		int n_unfm_number,	/* Number of the item unformatted nodes. */
-		 n_counter, n_blk_size;
-		__le32 *p_n_unfm_pointer;	/* Pointer to the unformatted node number. */
-		__u32 tmp;
-		struct item_head s_ih;	/* Item header. */
-		char c_mode;	/* Returned mode of the balance. */
-		int need_research;
-
-		n_blk_size = p_s_sb->s_blocksize;
-
-		/* Search for the needed object indirect item until there are no unformatted nodes to be removed. */
-		do {
-			need_research = 0;
-			p_s_bh = PATH_PLAST_BUFFER(p_s_path);
-			/* Copy indirect item header to a temp variable. */
-			copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path));
-			/* Calculate number of unformatted nodes in this item. */
-			n_unfm_number = I_UNFM_NUM(&s_ih);
-
-			RFALSE(!is_indirect_le_ih(&s_ih) || !n_unfm_number ||
-			       pos_in_item(p_s_path) + 1 != n_unfm_number,
-			       "PAP-5240: invalid item %h "
-			       "n_unfm_number = %d *p_n_pos_in_item = %d",
-			       &s_ih, n_unfm_number, pos_in_item(p_s_path));
-
-			/* Calculate balance mode and position in the item to remove unformatted nodes. */
-			if (n_new_file_length == max_reiserfs_offset(inode)) {	/* Case of delete. */
-				pos_in_item(p_s_path) = 0;
-				*p_n_cut_size = -(IH_SIZE + ih_item_len(&s_ih));
-				c_mode = M_DELETE;
-			} else {	/* Case of truncate. */
-				if (n_new_file_length < le_ih_k_offset(&s_ih)) {
-					pos_in_item(p_s_path) = 0;
-					*p_n_cut_size =
-					    -(IH_SIZE + ih_item_len(&s_ih));
-					c_mode = M_DELETE;	/* Delete this item. */
-				} else {
-					/* indirect item must be truncated starting from *p_n_pos_in_item-th position */
-					pos_in_item(p_s_path) =
-					    (n_new_file_length + n_blk_size -
-					     le_ih_k_offset(&s_ih)) >> p_s_sb->
-					    s_blocksize_bits;
-
-					RFALSE(pos_in_item(p_s_path) >
-					       n_unfm_number,
-					       "PAP-5250: invalid position in the item");
-
-					/* Either convert last unformatted node of indirect item to direct item or increase
-					   its free space.  */
-					if (pos_in_item(p_s_path) ==
-					    n_unfm_number) {
-						*p_n_cut_size = 0;	/* Nothing to cut. */
-						return M_CONVERT;	/* Maybe convert last unformatted node to the direct item. */
-					}
-					/* Calculate size to cut. */
-					*p_n_cut_size =
-					    -(ih_item_len(&s_ih) -
-					      pos_in_item(p_s_path) *
-					      UNFM_P_SIZE);
-
-					c_mode = M_CUT;	/* Cut from this indirect item. */
-				}
-			}
+	    int blk_size = p_s_sb->s_blocksize;
+	    struct item_head s_ih;
+	    int need_re_search;
+	    int delete = 0;
+	    int result = M_CUT;
+	    int pos = 0;
+
+	    if ( n_new_file_length == max_reiserfs_offset (inode) ) {
+		/* prepare_for_delete_or_cut() is called by
+		 * reiserfs_delete_item() */
+		n_new_file_length = 0;
+		delete = 1;
+	    }
+
+	    do {
+		need_re_search = 0;
+		*p_n_cut_size = 0;
+		p_s_bh = PATH_PLAST_BUFFER(p_s_path);
+		copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path));
+		pos = I_UNFM_NUM(&s_ih);
 
-			RFALSE(n_unfm_number <= pos_in_item(p_s_path),
-			       "PAP-5260: invalid position in the indirect item");
-
-			/* pointers to be cut */
-			n_unfm_number -= pos_in_item(p_s_path);
-			/* Set pointer to the last unformatted node pointer that is to be cut. */
-			p_n_unfm_pointer =
-			    (__le32 *) B_I_PITEM(p_s_bh,
-						 &s_ih) + I_UNFM_NUM(&s_ih) -
-			    1 - *p_n_removed;
-
-			/* We go through the unformatted nodes pointers of the indirect
-			   item and look for the unformatted nodes in the cache. If we
-			   found some of them we free it, zero corresponding indirect item
-			   entry and log buffer containing that indirect item. For this we
-			   need to prepare last path element for logging. If some
-			   unformatted node has b_count > 1 we must not free this
-			   unformatted node since it is in use. */
-			reiserfs_prepare_for_journal(p_s_sb, p_s_bh, 1);
-			// note: path could be changed, first line in for loop takes care
-			// of it
+		while (le_ih_k_offset (&s_ih) + (pos - 1) * blk_size > n_new_file_length) {
+		    __u32 *unfm, block;
 
-			for (n_counter = *p_n_removed;
-			     n_counter < n_unfm_number;
-			     n_counter++, p_n_unfm_pointer--) {
+		    /* Each unformatted block deletion may involve one additional
+		     * bitmap block into the transaction, thereby the initial
+		     * journal space reservation might not be enough. */
+		    if (!delete && (*p_n_cut_size) != 0 &&
+			reiserfs_transaction_free_space(th) < JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD) {
+			break;
+		    }
 
-				cond_resched();
-				if (item_moved(&s_ih, p_s_path)) {
-					need_research = 1;
-					break;
-				}
-				RFALSE(p_n_unfm_pointer <
-				       (__le32 *) B_I_PITEM(p_s_bh, &s_ih)
-				       || p_n_unfm_pointer >
-				       (__le32 *) B_I_PITEM(p_s_bh,
-							    &s_ih) +
-				       I_UNFM_NUM(&s_ih) - 1,
-				       "vs-5265: pointer out of range");
-
-				/* Hole, nothing to remove. */
-				if (!get_block_num(p_n_unfm_pointer, 0)) {
-					(*p_n_removed)++;
-					continue;
-				}
+		    unfm = (__u32 *)B_I_PITEM(p_s_bh, &s_ih) + pos - 1;
+		    block = get_block_num(unfm, 0);
 
-				(*p_n_removed)++;
+		    if (block != 0) {
+			reiserfs_prepare_for_journal(p_s_sb, p_s_bh, 1);
+			put_block_num(unfm, 0, 0);
+			journal_mark_dirty (th, p_s_sb, p_s_bh);
+			reiserfs_free_block(th, inode, block, 1);
+		    }
 
-				tmp = get_block_num(p_n_unfm_pointer, 0);
-				put_block_num(p_n_unfm_pointer, 0, 0);
-				journal_mark_dirty(th, p_s_sb, p_s_bh);
-				reiserfs_free_block(th, inode, tmp, 1);
-				if (item_moved(&s_ih, p_s_path)) {
-					need_research = 1;
-					break;
-				}
-			}
+		    cond_resched();
 
-			/* a trick.  If the buffer has been logged, this
-			 ** will do nothing.  If we've broken the loop without
-			 ** logging it, it will restore the buffer
-			 **
-			 */
-			reiserfs_restore_prepared_buffer(p_s_sb, p_s_bh);
-
-			/* This loop can be optimized. */
-		} while ((*p_n_removed < n_unfm_number || need_research) &&
-			 search_for_position_by_key(p_s_sb, p_s_item_key,
-						    p_s_path) ==
-			 POSITION_FOUND);
-
-		RFALSE(*p_n_removed < n_unfm_number,
-		       "PAP-5310: indirect item is not found");
-		RFALSE(item_moved(&s_ih, p_s_path),
-		       "after while, comp failed, retry");
-
-		if (c_mode == M_CUT)
-			pos_in_item(p_s_path) *= UNFM_P_SIZE;
-		return c_mode;
+		    if (item_moved (&s_ih, p_s_path))  {
+			need_re_search = 1;
+			break;
+		    }
+
+		    pos --;
+		    (*p_n_removed) ++;
+		    (*p_n_cut_size) -= UNFM_P_SIZE;
+
+		    if (pos == 0) {
+			(*p_n_cut_size) -= IH_SIZE;
+			result = M_DELETE;
+			break;
+		    }
+		}
+		/* a trick.  If the buffer has been logged, this will do nothing.  If
+		** we've broken the loop without logging it, it will restore the
+		** buffer */
+		reiserfs_restore_prepared_buffer(p_s_sb, p_s_bh);
+	    } while (need_re_search &&
+		     search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path) == POSITION_FOUND);
+	    pos_in_item(p_s_path) = pos * UNFM_P_SIZE;
+
+	    if (*p_n_cut_size == 0) {
+		/* Nothing were cut. maybe convert last unformatted node to the
+		 * direct item? */
+		result = M_CONVERT;
+	    }
+	    return result;
 	}
 }
 
@@ -1948,7 +1881,8 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th, struct inode *p
 		 ** sure the file is consistent before ending the current trans
 		 ** and starting a new one
 		 */
-		if (journal_transaction_should_end(th, th->t_blocks_allocated)) {
+		if (journal_transaction_should_end(th, 0) ||
+		    reiserfs_transaction_free_space(th) <= JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD) {
 			int orig_len_alloc = th->t_blocks_allocated;
 			decrement_counters_in_path(&s_search_path);
 
@@ -1962,7 +1896,7 @@ int reiserfs_do_truncate(struct reiserfs_transaction_handle *th, struct inode *p
 			if (err)
 				goto out;
 			err = journal_begin(th, p_s_inode->i_sb,
-					    JOURNAL_PER_BALANCE_CNT * 6);
+					    JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD + JOURNAL_PER_BALANCE_CNT * 4) ;
 			if (err)
 				goto out;
 			reiserfs_update_inode_transaction(p_s_inode);

commit bd4c625c061c2a38568d0add3478f59172455159
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Tue Jul 12 20:21:28 2005 -0700

    reiserfs: run scripts/Lindent on reiserfs code
    
    This was a pure indentation change, using:
    
            scripts/Lindent fs/reiserfs/*.c include/linux/reiserfs_*.h
    
    to make reiserfs match the regular Linux indentation style.  As Jeff
    Mahoney <jeffm@suse.com> writes:
    
     The ReiserFS code is a mix of a number of different coding styles, sometimes
     different even from line-to-line. Since the code has been relatively stable
     for quite some time and there are few outstanding patches to be applied, it
     is time to reformat the code to conform to the Linux style standard outlined
     in Documentation/CodingStyle.
    
     This patch contains the result of running scripts/Lindent against
     fs/reiserfs/*.c and include/linux/reiserfs_*.h. There are places where the
     code can be made to look better, but I'd rather keep those patches separate
     so that there isn't a subtle by-hand hand accident in the middle of a huge
     patch. To be clear: This patch is reformatting *only*.
    
     A number of patches may follow that continue to make the code more consistent
     with the Linux coding style.
    
     Hans wasn't particularly enthusiastic about these patches, but said he
     wouldn't really oppose them either.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 63158491e152..e2d08d7bcffc 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -59,46 +59,45 @@
 #include <linux/quotaops.h>
 
 /* Does the buffer contain a disk block which is in the tree. */
-inline int B_IS_IN_TREE (const struct buffer_head * p_s_bh)
+inline int B_IS_IN_TREE(const struct buffer_head *p_s_bh)
 {
 
-  RFALSE( B_LEVEL (p_s_bh) > MAX_HEIGHT,
-	  "PAP-1010: block (%b) has too big level (%z)", p_s_bh, p_s_bh);
+	RFALSE(B_LEVEL(p_s_bh) > MAX_HEIGHT,
+	       "PAP-1010: block (%b) has too big level (%z)", p_s_bh, p_s_bh);
 
-  return ( B_LEVEL (p_s_bh) != FREE_LEVEL );
+	return (B_LEVEL(p_s_bh) != FREE_LEVEL);
 }
 
 //
 // to gets item head in le form
 //
-inline void copy_item_head(struct item_head * p_v_to, 
-			   const struct item_head * p_v_from)
+inline void copy_item_head(struct item_head *p_v_to,
+			   const struct item_head *p_v_from)
 {
-  memcpy (p_v_to, p_v_from, IH_SIZE);
+	memcpy(p_v_to, p_v_from, IH_SIZE);
 }
 
-
 /* k1 is pointer to on-disk structure which is stored in little-endian
    form. k2 is pointer to cpu variable. For key of items of the same
    object this returns 0.
    Returns: -1 if key1 < key2 
    0 if key1 == key2
    1 if key1 > key2 */
-inline int  comp_short_keys (const struct reiserfs_key * le_key,
-			     const struct cpu_key * cpu_key)
+inline int comp_short_keys(const struct reiserfs_key *le_key,
+			   const struct cpu_key *cpu_key)
 {
-  __u32 n;
-  n = le32_to_cpu(le_key->k_dir_id);
-  if (n < cpu_key->on_disk_key.k_dir_id)
-      return -1;
-  if (n > cpu_key->on_disk_key.k_dir_id)
-      return 1;
-  n = le32_to_cpu(le_key->k_objectid);
-  if (n < cpu_key->on_disk_key.k_objectid)
-      return -1;
-  if (n > cpu_key->on_disk_key.k_objectid)
-      return 1;
-  return 0;
+	__u32 n;
+	n = le32_to_cpu(le_key->k_dir_id);
+	if (n < cpu_key->on_disk_key.k_dir_id)
+		return -1;
+	if (n > cpu_key->on_disk_key.k_dir_id)
+		return 1;
+	n = le32_to_cpu(le_key->k_objectid);
+	if (n < cpu_key->on_disk_key.k_objectid)
+		return -1;
+	if (n > cpu_key->on_disk_key.k_objectid)
+		return 1;
+	return 0;
 }
 
 /* k1 is pointer to on-disk structure which is stored in little-endian
@@ -106,68 +105,72 @@ inline int  comp_short_keys (const struct reiserfs_key * le_key,
    Compare keys using all 4 key fields.
    Returns: -1 if key1 < key2 0
    if key1 = key2 1 if key1 > key2 */
-static inline int  comp_keys (const struct reiserfs_key * le_key, const struct cpu_key * cpu_key)
+static inline int comp_keys(const struct reiserfs_key *le_key,
+			    const struct cpu_key *cpu_key)
 {
-  int retval;
-
-  retval = comp_short_keys (le_key, cpu_key);
-  if (retval)
-      return retval;
-  if (le_key_k_offset (le_key_version(le_key), le_key) < cpu_key_k_offset (cpu_key))
-      return -1;
-  if (le_key_k_offset (le_key_version(le_key), le_key) > cpu_key_k_offset (cpu_key))
-      return 1;
-
-  if (cpu_key->key_length == 3)
-      return 0;
-
-  /* this part is needed only when tail conversion is in progress */
-  if (le_key_k_type (le_key_version(le_key), le_key) < cpu_key_k_type (cpu_key))
-    return -1;
+	int retval;
+
+	retval = comp_short_keys(le_key, cpu_key);
+	if (retval)
+		return retval;
+	if (le_key_k_offset(le_key_version(le_key), le_key) <
+	    cpu_key_k_offset(cpu_key))
+		return -1;
+	if (le_key_k_offset(le_key_version(le_key), le_key) >
+	    cpu_key_k_offset(cpu_key))
+		return 1;
+
+	if (cpu_key->key_length == 3)
+		return 0;
+
+	/* this part is needed only when tail conversion is in progress */
+	if (le_key_k_type(le_key_version(le_key), le_key) <
+	    cpu_key_k_type(cpu_key))
+		return -1;
+
+	if (le_key_k_type(le_key_version(le_key), le_key) >
+	    cpu_key_k_type(cpu_key))
+		return 1;
 
-  if (le_key_k_type (le_key_version(le_key), le_key) > cpu_key_k_type (cpu_key))
-    return 1;
-
-  return 0;
+	return 0;
 }
 
-
-inline int comp_short_le_keys (const struct reiserfs_key * key1, const struct reiserfs_key * key2)
+inline int comp_short_le_keys(const struct reiserfs_key *key1,
+			      const struct reiserfs_key *key2)
 {
-  __u32 * p_s_1_u32, * p_s_2_u32;
-  int n_key_length = REISERFS_SHORT_KEY_LEN;
-
-  p_s_1_u32 = (__u32 *)key1;
-  p_s_2_u32 = (__u32 *)key2;
-  for( ; n_key_length--; ++p_s_1_u32, ++p_s_2_u32 ) {
-    if ( le32_to_cpu (*p_s_1_u32) < le32_to_cpu (*p_s_2_u32) )
-      return -1;
-    if ( le32_to_cpu (*p_s_1_u32) > le32_to_cpu (*p_s_2_u32) )
-      return 1;
-  }
-  return 0;
+	__u32 *p_s_1_u32, *p_s_2_u32;
+	int n_key_length = REISERFS_SHORT_KEY_LEN;
+
+	p_s_1_u32 = (__u32 *) key1;
+	p_s_2_u32 = (__u32 *) key2;
+	for (; n_key_length--; ++p_s_1_u32, ++p_s_2_u32) {
+		if (le32_to_cpu(*p_s_1_u32) < le32_to_cpu(*p_s_2_u32))
+			return -1;
+		if (le32_to_cpu(*p_s_1_u32) > le32_to_cpu(*p_s_2_u32))
+			return 1;
+	}
+	return 0;
 }
 
-inline void le_key2cpu_key (struct cpu_key * to, const struct reiserfs_key * from)
+inline void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from)
 {
-    int version;
-    to->on_disk_key.k_dir_id = le32_to_cpu (from->k_dir_id);
-    to->on_disk_key.k_objectid = le32_to_cpu (from->k_objectid);
-    
-    // find out version of the key
-    version = le_key_version (from);
-    to->version = version;
-    to->on_disk_key.k_offset = le_key_k_offset(version, from);
-    to->on_disk_key.k_type = le_key_k_type(version, from);
+	int version;
+	to->on_disk_key.k_dir_id = le32_to_cpu(from->k_dir_id);
+	to->on_disk_key.k_objectid = le32_to_cpu(from->k_objectid);
+
+	// find out version of the key
+	version = le_key_version(from);
+	to->version = version;
+	to->on_disk_key.k_offset = le_key_k_offset(version, from);
+	to->on_disk_key.k_type = le_key_k_type(version, from);
 }
 
-
-
 // this does not say which one is bigger, it only returns 1 if keys
 // are not equal, 0 otherwise
-inline int comp_le_keys (const struct reiserfs_key * k1, const struct reiserfs_key * k2)
+inline int comp_le_keys(const struct reiserfs_key *k1,
+			const struct reiserfs_key *k2)
 {
-    return memcmp (k1, k2, sizeof (struct reiserfs_key));
+	return memcmp(k1, k2, sizeof(struct reiserfs_key));
 }
 
 /**************************************************************************
@@ -184,373 +187,396 @@ inline int comp_le_keys (const struct reiserfs_key * k1, const struct reiserfs_k
  there are no possible items, and we have not found it. With each examination we
  cut the number of possible items it could be by one more than half rounded down,
  or we find it. */
-static inline	int bin_search (
-              const void * p_v_key, /* Key to search for.                   */
-	      const void * p_v_base,/* First item in the array.             */
-	      int       p_n_num,    /* Number of items in the array.        */
-	      int       p_n_width,  /* Item size in the array.
-				       searched. Lest the reader be
-				       confused, note that this is crafted
-				       as a general function, and when it
-				       is applied specifically to the array
-				       of item headers in a node, p_n_width
-				       is actually the item header size not
-				       the item size.                      */
-	      int     * p_n_pos     /* Number of the searched for element. */
-            ) {
-    int   n_rbound, n_lbound, n_j;
-
-   for ( n_j = ((n_rbound = p_n_num - 1) + (n_lbound = 0))/2; n_lbound <= n_rbound; n_j = (n_rbound + n_lbound)/2 )
-     switch( comp_keys((struct reiserfs_key *)((char * )p_v_base + n_j * p_n_width), (struct cpu_key *)p_v_key) )  {
-     case -1: n_lbound = n_j + 1; continue;
-     case  1: n_rbound = n_j - 1; continue;
-     case  0: *p_n_pos = n_j;     return ITEM_FOUND; /* Key found in the array.  */
-        }
-
-    /* bin_search did not find given key, it returns position of key,
-        that is minimal and greater than the given one. */
-    *p_n_pos = n_lbound;
-    return ITEM_NOT_FOUND;
+static inline int bin_search(const void *p_v_key,	/* Key to search for.                   */
+			     const void *p_v_base,	/* First item in the array.             */
+			     int p_n_num,	/* Number of items in the array.        */
+			     int p_n_width,	/* Item size in the array.
+						   searched. Lest the reader be
+						   confused, note that this is crafted
+						   as a general function, and when it
+						   is applied specifically to the array
+						   of item headers in a node, p_n_width
+						   is actually the item header size not
+						   the item size.                      */
+			     int *p_n_pos	/* Number of the searched for element. */
+    )
+{
+	int n_rbound, n_lbound, n_j;
+
+	for (n_j = ((n_rbound = p_n_num - 1) + (n_lbound = 0)) / 2;
+	     n_lbound <= n_rbound; n_j = (n_rbound + n_lbound) / 2)
+		switch (comp_keys
+			((struct reiserfs_key *)((char *)p_v_base +
+						 n_j * p_n_width),
+			 (struct cpu_key *)p_v_key)) {
+		case -1:
+			n_lbound = n_j + 1;
+			continue;
+		case 1:
+			n_rbound = n_j - 1;
+			continue;
+		case 0:
+			*p_n_pos = n_j;
+			return ITEM_FOUND;	/* Key found in the array.  */
+		}
+
+	/* bin_search did not find given key, it returns position of key,
+	   that is minimal and greater than the given one. */
+	*p_n_pos = n_lbound;
+	return ITEM_NOT_FOUND;
 }
 
 #ifdef CONFIG_REISERFS_CHECK
-extern struct tree_balance * cur_tb;
+extern struct tree_balance *cur_tb;
 #endif
 
-
-
 /* Minimal possible key. It is never in the tree. */
-const struct reiserfs_key  MIN_KEY = {0, 0, {{0, 0},}};
+const struct reiserfs_key MIN_KEY = { 0, 0, {{0, 0},} };
 
 /* Maximal possible key. It is never in the tree. */
-static const struct reiserfs_key  MAX_KEY = {
+static const struct reiserfs_key MAX_KEY = {
 	__constant_cpu_to_le32(0xffffffff),
 	__constant_cpu_to_le32(0xffffffff),
 	{{__constant_cpu_to_le32(0xffffffff),
-	__constant_cpu_to_le32(0xffffffff)},}
+	  __constant_cpu_to_le32(0xffffffff)},}
 };
 
-
 /* Get delimiting key of the buffer by looking for it in the buffers in the path, starting from the bottom
    of the path, and going upwards.  We must check the path's validity at each step.  If the key is not in
    the path, there is no delimiting key in the tree (buffer is first or last buffer in tree), and in this
    case we return a special key, either MIN_KEY or MAX_KEY. */
-static inline	const struct  reiserfs_key * get_lkey  (
-	                const struct path         * p_s_chk_path,
-                        const struct super_block  * p_s_sb
-                      ) {
-  int                   n_position, n_path_offset = p_s_chk_path->path_length;
-  struct buffer_head  * p_s_parent;
-  
-  RFALSE( n_path_offset < FIRST_PATH_ELEMENT_OFFSET, 
-	  "PAP-5010: invalid offset in the path");
-
-  /* While not higher in path than first element. */
-  while ( n_path_offset-- > FIRST_PATH_ELEMENT_OFFSET ) {
-
-    RFALSE( ! buffer_uptodate(PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)),
-	    "PAP-5020: parent is not uptodate");
-
-    /* Parent at the path is not in the tree now. */
-    if ( ! B_IS_IN_TREE(p_s_parent = PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)) )
-      return &MAX_KEY;
-    /* Check whether position in the parent is correct. */
-    if ( (n_position = PATH_OFFSET_POSITION(p_s_chk_path, n_path_offset)) > B_NR_ITEMS(p_s_parent) )
-       return &MAX_KEY;
-    /* Check whether parent at the path really points to the child. */
-    if ( B_N_CHILD_NUM(p_s_parent, n_position) !=
-	 PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset + 1)->b_blocknr )
-      return &MAX_KEY;
-    /* Return delimiting key if position in the parent is not equal to zero. */
-    if ( n_position )
-      return B_N_PDELIM_KEY(p_s_parent, n_position - 1);
-  }
-  /* Return MIN_KEY if we are in the root of the buffer tree. */
-  if ( PATH_OFFSET_PBUFFER(p_s_chk_path, FIRST_PATH_ELEMENT_OFFSET)->b_blocknr ==
-       SB_ROOT_BLOCK (p_s_sb) )
-    return &MIN_KEY;
-  return  &MAX_KEY;
+static inline const struct reiserfs_key *get_lkey(const struct path
+						  *p_s_chk_path,
+						  const struct super_block
+						  *p_s_sb)
+{
+	int n_position, n_path_offset = p_s_chk_path->path_length;
+	struct buffer_head *p_s_parent;
+
+	RFALSE(n_path_offset < FIRST_PATH_ELEMENT_OFFSET,
+	       "PAP-5010: invalid offset in the path");
+
+	/* While not higher in path than first element. */
+	while (n_path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {
+
+		RFALSE(!buffer_uptodate
+		       (PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)),
+		       "PAP-5020: parent is not uptodate");
+
+		/* Parent at the path is not in the tree now. */
+		if (!B_IS_IN_TREE
+		    (p_s_parent =
+		     PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)))
+			return &MAX_KEY;
+		/* Check whether position in the parent is correct. */
+		if ((n_position =
+		     PATH_OFFSET_POSITION(p_s_chk_path,
+					  n_path_offset)) >
+		    B_NR_ITEMS(p_s_parent))
+			return &MAX_KEY;
+		/* Check whether parent at the path really points to the child. */
+		if (B_N_CHILD_NUM(p_s_parent, n_position) !=
+		    PATH_OFFSET_PBUFFER(p_s_chk_path,
+					n_path_offset + 1)->b_blocknr)
+			return &MAX_KEY;
+		/* Return delimiting key if position in the parent is not equal to zero. */
+		if (n_position)
+			return B_N_PDELIM_KEY(p_s_parent, n_position - 1);
+	}
+	/* Return MIN_KEY if we are in the root of the buffer tree. */
+	if (PATH_OFFSET_PBUFFER(p_s_chk_path, FIRST_PATH_ELEMENT_OFFSET)->
+	    b_blocknr == SB_ROOT_BLOCK(p_s_sb))
+		return &MIN_KEY;
+	return &MAX_KEY;
 }
 
-
 /* Get delimiting key of the buffer at the path and its right neighbor. */
-inline	const struct  reiserfs_key * get_rkey  (
-	                const struct path         * p_s_chk_path,
-                        const struct super_block  * p_s_sb
-                      ) {
-  int                   n_position,
-    			n_path_offset = p_s_chk_path->path_length;
-  struct buffer_head  * p_s_parent;
-
-  RFALSE( n_path_offset < FIRST_PATH_ELEMENT_OFFSET,
-	  "PAP-5030: invalid offset in the path");
-
-  while ( n_path_offset-- > FIRST_PATH_ELEMENT_OFFSET ) {
-
-    RFALSE( ! buffer_uptodate(PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)),
-	    "PAP-5040: parent is not uptodate");
-
-    /* Parent at the path is not in the tree now. */
-    if ( ! B_IS_IN_TREE(p_s_parent = PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)) )
-      return &MIN_KEY;
-    /* Check whether position in the parent is correct. */
-    if ( (n_position = PATH_OFFSET_POSITION(p_s_chk_path, n_path_offset)) > B_NR_ITEMS(p_s_parent) )
-      return &MIN_KEY;
-    /* Check whether parent at the path really points to the child. */
-    if ( B_N_CHILD_NUM(p_s_parent, n_position) !=
-                                        PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset + 1)->b_blocknr )
-      return &MIN_KEY;
-    /* Return delimiting key if position in the parent is not the last one. */
-    if ( n_position != B_NR_ITEMS(p_s_parent) )
-      return B_N_PDELIM_KEY(p_s_parent, n_position);
-  }
-  /* Return MAX_KEY if we are in the root of the buffer tree. */
-  if ( PATH_OFFSET_PBUFFER(p_s_chk_path, FIRST_PATH_ELEMENT_OFFSET)->b_blocknr ==
-       SB_ROOT_BLOCK (p_s_sb) )
-    return &MAX_KEY;
-  return  &MIN_KEY;
+inline const struct reiserfs_key *get_rkey(const struct path *p_s_chk_path,
+					   const struct super_block *p_s_sb)
+{
+	int n_position, n_path_offset = p_s_chk_path->path_length;
+	struct buffer_head *p_s_parent;
+
+	RFALSE(n_path_offset < FIRST_PATH_ELEMENT_OFFSET,
+	       "PAP-5030: invalid offset in the path");
+
+	while (n_path_offset-- > FIRST_PATH_ELEMENT_OFFSET) {
+
+		RFALSE(!buffer_uptodate
+		       (PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)),
+		       "PAP-5040: parent is not uptodate");
+
+		/* Parent at the path is not in the tree now. */
+		if (!B_IS_IN_TREE
+		    (p_s_parent =
+		     PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)))
+			return &MIN_KEY;
+		/* Check whether position in the parent is correct. */
+		if ((n_position =
+		     PATH_OFFSET_POSITION(p_s_chk_path,
+					  n_path_offset)) >
+		    B_NR_ITEMS(p_s_parent))
+			return &MIN_KEY;
+		/* Check whether parent at the path really points to the child. */
+		if (B_N_CHILD_NUM(p_s_parent, n_position) !=
+		    PATH_OFFSET_PBUFFER(p_s_chk_path,
+					n_path_offset + 1)->b_blocknr)
+			return &MIN_KEY;
+		/* Return delimiting key if position in the parent is not the last one. */
+		if (n_position != B_NR_ITEMS(p_s_parent))
+			return B_N_PDELIM_KEY(p_s_parent, n_position);
+	}
+	/* Return MAX_KEY if we are in the root of the buffer tree. */
+	if (PATH_OFFSET_PBUFFER(p_s_chk_path, FIRST_PATH_ELEMENT_OFFSET)->
+	    b_blocknr == SB_ROOT_BLOCK(p_s_sb))
+		return &MAX_KEY;
+	return &MIN_KEY;
 }
 
-
 /* Check whether a key is contained in the tree rooted from a buffer at a path. */
 /* This works by looking at the left and right delimiting keys for the buffer in the last path_element in
    the path.  These delimiting keys are stored at least one level above that buffer in the tree. If the
    buffer is the first or last node in the tree order then one of the delimiting keys may be absent, and in
    this case get_lkey and get_rkey return a special key which is MIN_KEY or MAX_KEY. */
-static  inline  int key_in_buffer (
-                      struct path         * p_s_chk_path, /* Path which should be checked.  */
-                      const struct cpu_key      * p_s_key,      /* Key which should be checked.   */
-                      struct super_block  * p_s_sb        /* Super block pointer.           */
-		      ) {
-
-  RFALSE( ! p_s_key || p_s_chk_path->path_length < FIRST_PATH_ELEMENT_OFFSET ||
-	  p_s_chk_path->path_length > MAX_HEIGHT,
-	  "PAP-5050: pointer to the key(%p) is NULL or invalid path length(%d)",
-	  p_s_key, p_s_chk_path->path_length);
-  RFALSE( !PATH_PLAST_BUFFER(p_s_chk_path)->b_bdev,
-	  "PAP-5060: device must not be NODEV");
-
-  if ( comp_keys(get_lkey(p_s_chk_path, p_s_sb), p_s_key) == 1 )
-    /* left delimiting key is bigger, that the key we look for */
-    return 0;
-  //  if ( comp_keys(p_s_key, get_rkey(p_s_chk_path, p_s_sb)) != -1 )
-  if ( comp_keys(get_rkey(p_s_chk_path, p_s_sb), p_s_key) != 1 )
-    /* p_s_key must be less than right delimitiing key */
-    return 0;
-  return 1;
-}
-
+static inline int key_in_buffer(struct path *p_s_chk_path,	/* Path which should be checked.  */
+				const struct cpu_key *p_s_key,	/* Key which should be checked.   */
+				struct super_block *p_s_sb	/* Super block pointer.           */
+    )
+{
 
-inline void decrement_bcount(
-              struct buffer_head  * p_s_bh
-            ) { 
-  if ( p_s_bh ) {
-    if ( atomic_read (&(p_s_bh->b_count)) ) {
-      put_bh(p_s_bh) ;
-      return;
-    }
-    reiserfs_panic(NULL, "PAP-5070: decrement_bcount: trying to free free buffer %b", p_s_bh);
-  }
+	RFALSE(!p_s_key || p_s_chk_path->path_length < FIRST_PATH_ELEMENT_OFFSET
+	       || p_s_chk_path->path_length > MAX_HEIGHT,
+	       "PAP-5050: pointer to the key(%p) is NULL or invalid path length(%d)",
+	       p_s_key, p_s_chk_path->path_length);
+	RFALSE(!PATH_PLAST_BUFFER(p_s_chk_path)->b_bdev,
+	       "PAP-5060: device must not be NODEV");
+
+	if (comp_keys(get_lkey(p_s_chk_path, p_s_sb), p_s_key) == 1)
+		/* left delimiting key is bigger, that the key we look for */
+		return 0;
+	//  if ( comp_keys(p_s_key, get_rkey(p_s_chk_path, p_s_sb)) != -1 )
+	if (comp_keys(get_rkey(p_s_chk_path, p_s_sb), p_s_key) != 1)
+		/* p_s_key must be less than right delimitiing key */
+		return 0;
+	return 1;
 }
 
+inline void decrement_bcount(struct buffer_head *p_s_bh)
+{
+	if (p_s_bh) {
+		if (atomic_read(&(p_s_bh->b_count))) {
+			put_bh(p_s_bh);
+			return;
+		}
+		reiserfs_panic(NULL,
+			       "PAP-5070: decrement_bcount: trying to free free buffer %b",
+			       p_s_bh);
+	}
+}
 
 /* Decrement b_count field of the all buffers in the path. */
-void decrement_counters_in_path (
-              struct path * p_s_search_path
-            ) {
-  int n_path_offset = p_s_search_path->path_length;
-
-  RFALSE( n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET ||
-	  n_path_offset > EXTENDED_MAX_HEIGHT - 1,
-	  "PAP-5080: invalid path offset of %d", n_path_offset);
-
-  while ( n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET ) {
-    struct buffer_head * bh;
-
-    bh = PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--);
-    decrement_bcount (bh);
-  }
-  p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
-}
+void decrement_counters_in_path(struct path *p_s_search_path)
+{
+	int n_path_offset = p_s_search_path->path_length;
+
+	RFALSE(n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET ||
+	       n_path_offset > EXTENDED_MAX_HEIGHT - 1,
+	       "PAP-5080: invalid path offset of %d", n_path_offset);
 
+	while (n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {
+		struct buffer_head *bh;
 
-int reiserfs_check_path(struct path *p) {
-  RFALSE( p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,
-	  "path not properly relsed") ;
-  return 0 ;
+		bh = PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--);
+		decrement_bcount(bh);
+	}
+	p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
 }
 
+int reiserfs_check_path(struct path *p)
+{
+	RFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,
+	       "path not properly relsed");
+	return 0;
+}
 
 /* Release all buffers in the path. Restore dirty bits clean
 ** when preparing the buffer for the log
 **
 ** only called from fix_nodes()
 */
-void  pathrelse_and_restore (
-	struct super_block *s, 
-        struct path * p_s_search_path
-      ) {
-  int n_path_offset = p_s_search_path->path_length;
-
-  RFALSE( n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET, 
-	  "clm-4000: invalid path offset");
-  
-  while ( n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET )  {
-    reiserfs_restore_prepared_buffer(s, PATH_OFFSET_PBUFFER(p_s_search_path, 
-                                     n_path_offset));
-    brelse(PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--));
-  }
-  p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
+void pathrelse_and_restore(struct super_block *s, struct path *p_s_search_path)
+{
+	int n_path_offset = p_s_search_path->path_length;
+
+	RFALSE(n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,
+	       "clm-4000: invalid path offset");
+
+	while (n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {
+		reiserfs_restore_prepared_buffer(s,
+						 PATH_OFFSET_PBUFFER
+						 (p_s_search_path,
+						  n_path_offset));
+		brelse(PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--));
+	}
+	p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
 }
 
 /* Release all buffers in the path. */
-void  pathrelse (
-        struct path * p_s_search_path
-      ) {
-  int n_path_offset = p_s_search_path->path_length;
-
-  RFALSE( n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,
-	  "PAP-5090: invalid path offset");
-  
-  while ( n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET )  
-    brelse(PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--));
-
-  p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
-}
+void pathrelse(struct path *p_s_search_path)
+{
+	int n_path_offset = p_s_search_path->path_length;
 
+	RFALSE(n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,
+	       "PAP-5090: invalid path offset");
 
+	while (n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)
+		brelse(PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--));
 
-static int is_leaf (char * buf, int blocksize, struct buffer_head * bh)
-{
-    struct block_head * blkh;
-    struct item_head * ih;
-    int used_space;
-    int prev_location;
-    int i;
-    int nr;
-
-    blkh = (struct block_head *)buf;
-    if ( blkh_level(blkh) != DISK_LEAF_NODE_LEVEL) {
-	reiserfs_warning (NULL, "is_leaf: this should be caught earlier");
-	return 0;
-    }
+	p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
+}
 
-    nr = blkh_nr_item(blkh);
-    if (nr < 1 || nr > ((blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN))) {
-	/* item number is too big or too small */
-	reiserfs_warning (NULL, "is_leaf: nr_item seems wrong: %z", bh);
-	return 0;
-    }
-    ih = (struct item_head *)(buf + BLKH_SIZE) + nr - 1;
-    used_space = BLKH_SIZE + IH_SIZE * nr + (blocksize - ih_location (ih));
-    if (used_space != blocksize - blkh_free_space(blkh)) {
-	/* free space does not match to calculated amount of use space */
-	reiserfs_warning (NULL, "is_leaf: free space seems wrong: %z", bh);
-	return 0;
-    }
-
-    // FIXME: it is_leaf will hit performance too much - we may have
-    // return 1 here
-
-    /* check tables of item heads */
-    ih = (struct item_head *)(buf + BLKH_SIZE);
-    prev_location = blocksize;
-    for (i = 0; i < nr; i ++, ih ++) {
-	if ( le_ih_k_type(ih) == TYPE_ANY) {
-	    reiserfs_warning (NULL, "is_leaf: wrong item type for item %h",ih);
-	    return 0;
+static int is_leaf(char *buf, int blocksize, struct buffer_head *bh)
+{
+	struct block_head *blkh;
+	struct item_head *ih;
+	int used_space;
+	int prev_location;
+	int i;
+	int nr;
+
+	blkh = (struct block_head *)buf;
+	if (blkh_level(blkh) != DISK_LEAF_NODE_LEVEL) {
+		reiserfs_warning(NULL,
+				 "is_leaf: this should be caught earlier");
+		return 0;
 	}
-	if (ih_location (ih) >= blocksize || ih_location (ih) < IH_SIZE * nr) {
-	    reiserfs_warning (NULL, "is_leaf: item location seems wrong: %h", ih);
-	    return 0;
+
+	nr = blkh_nr_item(blkh);
+	if (nr < 1 || nr > ((blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN))) {
+		/* item number is too big or too small */
+		reiserfs_warning(NULL, "is_leaf: nr_item seems wrong: %z", bh);
+		return 0;
 	}
-	if (ih_item_len (ih) < 1 || ih_item_len (ih) > MAX_ITEM_LEN (blocksize)) {
-	    reiserfs_warning (NULL, "is_leaf: item length seems wrong: %h", ih);
-	    return 0;
+	ih = (struct item_head *)(buf + BLKH_SIZE) + nr - 1;
+	used_space = BLKH_SIZE + IH_SIZE * nr + (blocksize - ih_location(ih));
+	if (used_space != blocksize - blkh_free_space(blkh)) {
+		/* free space does not match to calculated amount of use space */
+		reiserfs_warning(NULL, "is_leaf: free space seems wrong: %z",
+				 bh);
+		return 0;
 	}
-	if (prev_location - ih_location (ih) != ih_item_len (ih)) {
-	    reiserfs_warning (NULL, "is_leaf: item location seems wrong (second one): %h", ih);
-	    return 0;
+	// FIXME: it is_leaf will hit performance too much - we may have
+	// return 1 here
+
+	/* check tables of item heads */
+	ih = (struct item_head *)(buf + BLKH_SIZE);
+	prev_location = blocksize;
+	for (i = 0; i < nr; i++, ih++) {
+		if (le_ih_k_type(ih) == TYPE_ANY) {
+			reiserfs_warning(NULL,
+					 "is_leaf: wrong item type for item %h",
+					 ih);
+			return 0;
+		}
+		if (ih_location(ih) >= blocksize
+		    || ih_location(ih) < IH_SIZE * nr) {
+			reiserfs_warning(NULL,
+					 "is_leaf: item location seems wrong: %h",
+					 ih);
+			return 0;
+		}
+		if (ih_item_len(ih) < 1
+		    || ih_item_len(ih) > MAX_ITEM_LEN(blocksize)) {
+			reiserfs_warning(NULL,
+					 "is_leaf: item length seems wrong: %h",
+					 ih);
+			return 0;
+		}
+		if (prev_location - ih_location(ih) != ih_item_len(ih)) {
+			reiserfs_warning(NULL,
+					 "is_leaf: item location seems wrong (second one): %h",
+					 ih);
+			return 0;
+		}
+		prev_location = ih_location(ih);
 	}
-	prev_location = ih_location (ih);
-    }
 
-    // one may imagine much more checks
-    return 1;
+	// one may imagine much more checks
+	return 1;
 }
 
-
 /* returns 1 if buf looks like an internal node, 0 otherwise */
-static int is_internal (char * buf, int blocksize, struct buffer_head * bh)
+static int is_internal(char *buf, int blocksize, struct buffer_head *bh)
 {
-    struct block_head * blkh;
-    int nr;
-    int used_space;
-
-    blkh = (struct block_head *)buf;
-    nr = blkh_level(blkh);
-    if (nr <= DISK_LEAF_NODE_LEVEL || nr > MAX_HEIGHT) {
-	/* this level is not possible for internal nodes */
-	reiserfs_warning (NULL, "is_internal: this should be caught earlier");
-	return 0;
-    }
-    
-    nr = blkh_nr_item(blkh);
-    if (nr > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE)) {
-	/* for internal which is not root we might check min number of keys */
-	reiserfs_warning (NULL, "is_internal: number of key seems wrong: %z", bh);
-	return 0;
-    }
+	struct block_head *blkh;
+	int nr;
+	int used_space;
+
+	blkh = (struct block_head *)buf;
+	nr = blkh_level(blkh);
+	if (nr <= DISK_LEAF_NODE_LEVEL || nr > MAX_HEIGHT) {
+		/* this level is not possible for internal nodes */
+		reiserfs_warning(NULL,
+				 "is_internal: this should be caught earlier");
+		return 0;
+	}
 
-    used_space = BLKH_SIZE + KEY_SIZE * nr + DC_SIZE * (nr + 1);
-    if (used_space != blocksize - blkh_free_space(blkh)) {
-	reiserfs_warning (NULL, "is_internal: free space seems wrong: %z", bh);
-	return 0;
-    }
+	nr = blkh_nr_item(blkh);
+	if (nr > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE)) {
+		/* for internal which is not root we might check min number of keys */
+		reiserfs_warning(NULL,
+				 "is_internal: number of key seems wrong: %z",
+				 bh);
+		return 0;
+	}
 
-    // one may imagine much more checks
-    return 1;
+	used_space = BLKH_SIZE + KEY_SIZE * nr + DC_SIZE * (nr + 1);
+	if (used_space != blocksize - blkh_free_space(blkh)) {
+		reiserfs_warning(NULL,
+				 "is_internal: free space seems wrong: %z", bh);
+		return 0;
+	}
+	// one may imagine much more checks
+	return 1;
 }
 
-
 // make sure that bh contains formatted node of reiserfs tree of
 // 'level'-th level
-static int is_tree_node (struct buffer_head * bh, int level)
+static int is_tree_node(struct buffer_head *bh, int level)
 {
-    if (B_LEVEL (bh) != level) {
-	reiserfs_warning (NULL, "is_tree_node: node level %d does not match to the expected one %d",
-		B_LEVEL (bh), level);
-	return 0;
-    }
-    if (level == DISK_LEAF_NODE_LEVEL)
-	return is_leaf (bh->b_data, bh->b_size, bh);
+	if (B_LEVEL(bh) != level) {
+		reiserfs_warning(NULL,
+				 "is_tree_node: node level %d does not match to the expected one %d",
+				 B_LEVEL(bh), level);
+		return 0;
+	}
+	if (level == DISK_LEAF_NODE_LEVEL)
+		return is_leaf(bh->b_data, bh->b_size, bh);
 
-    return is_internal (bh->b_data, bh->b_size, bh);
+	return is_internal(bh->b_data, bh->b_size, bh);
 }
 
-
-
 #define SEARCH_BY_KEY_READA 16
 
 /* The function is NOT SCHEDULE-SAFE! */
-static void search_by_key_reada (struct super_block * s,
-                                 struct buffer_head **bh,
-				 unsigned long *b, int num)
+static void search_by_key_reada(struct super_block *s,
+				struct buffer_head **bh,
+				unsigned long *b, int num)
 {
-    int i,j;
-  
-    for (i = 0 ; i < num ; i++) {
-	bh[i] = sb_getblk (s, b[i]);
-    }
-    for (j = 0 ; j < i ; j++) {
-	/*
-	 * note, this needs attention if we are getting rid of the BKL
-	 * you have to make sure the prepared bit isn't set on this buffer
-	 */
-	if (!buffer_uptodate(bh[j]))
-	    ll_rw_block(READA, 1, bh + j);
-    	brelse(bh[j]);
-    }
+	int i, j;
+
+	for (i = 0; i < num; i++) {
+		bh[i] = sb_getblk(s, b[i]);
+	}
+	for (j = 0; j < i; j++) {
+		/*
+		 * note, this needs attention if we are getting rid of the BKL
+		 * you have to make sure the prepared bit isn't set on this buffer
+		 */
+		if (!buffer_uptodate(bh[j]))
+			ll_rw_block(READA, 1, bh + j);
+		brelse(bh[j]);
+	}
 }
 
 /**************************************************************************
@@ -576,194 +602,200 @@ static void search_by_key_reada (struct super_block * s,
    correctness of the top of the path but need not be checked for the
    correctness of the bottom of the path */
 /* The function is NOT SCHEDULE-SAFE! */
-int search_by_key (struct super_block * p_s_sb,
-		   const struct cpu_key * p_s_key, /* Key to search. */
-		   struct path * p_s_search_path, /* This structure was
-						     allocated and initialized
-						     by the calling
-						     function. It is filled up
-						     by this function.  */
-		   int n_stop_level /* How far down the tree to search. To
-                                       stop at leaf level - set to
-                                       DISK_LEAF_NODE_LEVEL */
-    ) {
-    int  n_block_number;
-    int  expected_level;
-    struct buffer_head  *       p_s_bh;
-    struct path_element *       p_s_last_element;
-    int				n_node_level, n_retval;
-    int 			right_neighbor_of_leaf_node;
-    int				fs_gen;
-    struct buffer_head *reada_bh[SEARCH_BY_KEY_READA];
-    unsigned long      reada_blocks[SEARCH_BY_KEY_READA];
-    int reada_count = 0;
+int search_by_key(struct super_block *p_s_sb, const struct cpu_key *p_s_key,	/* Key to search. */
+		  struct path *p_s_search_path,	/* This structure was
+						   allocated and initialized
+						   by the calling
+						   function. It is filled up
+						   by this function.  */
+		  int n_stop_level	/* How far down the tree to search. To
+					   stop at leaf level - set to
+					   DISK_LEAF_NODE_LEVEL */
+    )
+{
+	int n_block_number;
+	int expected_level;
+	struct buffer_head *p_s_bh;
+	struct path_element *p_s_last_element;
+	int n_node_level, n_retval;
+	int right_neighbor_of_leaf_node;
+	int fs_gen;
+	struct buffer_head *reada_bh[SEARCH_BY_KEY_READA];
+	unsigned long reada_blocks[SEARCH_BY_KEY_READA];
+	int reada_count = 0;
 
 #ifdef CONFIG_REISERFS_CHECK
-    int n_repeat_counter = 0;
+	int n_repeat_counter = 0;
 #endif
-    
-    PROC_INFO_INC( p_s_sb, search_by_key );
-    
-    /* As we add each node to a path we increase its count.  This means that
-       we must be careful to release all nodes in a path before we either
-       discard the path struct or re-use the path struct, as we do here. */
 
-    decrement_counters_in_path(p_s_search_path);
+	PROC_INFO_INC(p_s_sb, search_by_key);
+
+	/* As we add each node to a path we increase its count.  This means that
+	   we must be careful to release all nodes in a path before we either
+	   discard the path struct or re-use the path struct, as we do here. */
 
-    right_neighbor_of_leaf_node = 0;
+	decrement_counters_in_path(p_s_search_path);
 
-    /* With each iteration of this loop we search through the items in the
-       current node, and calculate the next current node(next path element)
-       for the next iteration of this loop.. */
-    n_block_number = SB_ROOT_BLOCK (p_s_sb);
-    expected_level = -1;
-    while ( 1 ) {
+	right_neighbor_of_leaf_node = 0;
+
+	/* With each iteration of this loop we search through the items in the
+	   current node, and calculate the next current node(next path element)
+	   for the next iteration of this loop.. */
+	n_block_number = SB_ROOT_BLOCK(p_s_sb);
+	expected_level = -1;
+	while (1) {
 
 #ifdef CONFIG_REISERFS_CHECK
-	if ( !(++n_repeat_counter % 50000) )
-	    reiserfs_warning (p_s_sb, "PAP-5100: search_by_key: %s:"
-			      "there were %d iterations of while loop "
-			      "looking for key %K",
-			      current->comm, n_repeat_counter, p_s_key);
+		if (!(++n_repeat_counter % 50000))
+			reiserfs_warning(p_s_sb, "PAP-5100: search_by_key: %s:"
+					 "there were %d iterations of while loop "
+					 "looking for key %K",
+					 current->comm, n_repeat_counter,
+					 p_s_key);
 #endif
 
-	/* prep path to have another element added to it. */
-	p_s_last_element = PATH_OFFSET_PELEMENT(p_s_search_path, ++p_s_search_path->path_length);
-	fs_gen = get_generation (p_s_sb);
-
-	/* Read the next tree node, and set the last element in the path to
-           have a pointer to it. */
-	if ((p_s_bh = p_s_last_element->pe_buffer =
-	     sb_getblk(p_s_sb, n_block_number)) ) {
-	    if (!buffer_uptodate(p_s_bh) && reada_count > 1) {
-		search_by_key_reada (p_s_sb, reada_bh,
-		                     reada_blocks, reada_count);
-	    }
-	    ll_rw_block(READ, 1, &p_s_bh);
-	    wait_on_buffer(p_s_bh);
-	    if (!buffer_uptodate(p_s_bh))
-	        goto io_error;
-	} else {
-io_error:
-	    p_s_search_path->path_length --;
-	    pathrelse(p_s_search_path);
-	    return IO_ERROR;
-	}
-	reada_count = 0;
-	if (expected_level == -1)
-		expected_level = SB_TREE_HEIGHT (p_s_sb);
-	expected_level --;
-
-	/* It is possible that schedule occurred. We must check whether the key
-	   to search is still in the tree rooted from the current buffer. If
-	   not then repeat search from the root. */
-	if ( fs_changed (fs_gen, p_s_sb) && 
-	    (!B_IS_IN_TREE (p_s_bh) ||
-	     B_LEVEL(p_s_bh) != expected_level ||
-	     !key_in_buffer(p_s_search_path, p_s_key, p_s_sb))) {
-	    PROC_INFO_INC( p_s_sb, search_by_key_fs_changed );
-	    PROC_INFO_INC( p_s_sb, search_by_key_restarted );
-	    PROC_INFO_INC( p_s_sb, sbk_restarted[ expected_level - 1 ] );
-	    decrement_counters_in_path(p_s_search_path);
-	    
-	    /* Get the root block number so that we can repeat the search
-	       starting from the root. */
-	    n_block_number = SB_ROOT_BLOCK (p_s_sb);
-	    expected_level = -1;
-	    right_neighbor_of_leaf_node = 0;
-	    
-	    /* repeat search from the root */
-	    continue;
-	}
+		/* prep path to have another element added to it. */
+		p_s_last_element =
+		    PATH_OFFSET_PELEMENT(p_s_search_path,
+					 ++p_s_search_path->path_length);
+		fs_gen = get_generation(p_s_sb);
+
+		/* Read the next tree node, and set the last element in the path to
+		   have a pointer to it. */
+		if ((p_s_bh = p_s_last_element->pe_buffer =
+		     sb_getblk(p_s_sb, n_block_number))) {
+			if (!buffer_uptodate(p_s_bh) && reada_count > 1) {
+				search_by_key_reada(p_s_sb, reada_bh,
+						    reada_blocks, reada_count);
+			}
+			ll_rw_block(READ, 1, &p_s_bh);
+			wait_on_buffer(p_s_bh);
+			if (!buffer_uptodate(p_s_bh))
+				goto io_error;
+		} else {
+		      io_error:
+			p_s_search_path->path_length--;
+			pathrelse(p_s_search_path);
+			return IO_ERROR;
+		}
+		reada_count = 0;
+		if (expected_level == -1)
+			expected_level = SB_TREE_HEIGHT(p_s_sb);
+		expected_level--;
+
+		/* It is possible that schedule occurred. We must check whether the key
+		   to search is still in the tree rooted from the current buffer. If
+		   not then repeat search from the root. */
+		if (fs_changed(fs_gen, p_s_sb) &&
+		    (!B_IS_IN_TREE(p_s_bh) ||
+		     B_LEVEL(p_s_bh) != expected_level ||
+		     !key_in_buffer(p_s_search_path, p_s_key, p_s_sb))) {
+			PROC_INFO_INC(p_s_sb, search_by_key_fs_changed);
+			PROC_INFO_INC(p_s_sb, search_by_key_restarted);
+			PROC_INFO_INC(p_s_sb,
+				      sbk_restarted[expected_level - 1]);
+			decrement_counters_in_path(p_s_search_path);
+
+			/* Get the root block number so that we can repeat the search
+			   starting from the root. */
+			n_block_number = SB_ROOT_BLOCK(p_s_sb);
+			expected_level = -1;
+			right_neighbor_of_leaf_node = 0;
+
+			/* repeat search from the root */
+			continue;
+		}
 
-        /* only check that the key is in the buffer if p_s_key is not
-           equal to the MAX_KEY. Latter case is only possible in
-           "finish_unfinished()" processing during mount. */
-        RFALSE( comp_keys( &MAX_KEY, p_s_key ) &&
-                ! key_in_buffer(p_s_search_path, p_s_key, p_s_sb),
-		"PAP-5130: key is not in the buffer");
+		/* only check that the key is in the buffer if p_s_key is not
+		   equal to the MAX_KEY. Latter case is only possible in
+		   "finish_unfinished()" processing during mount. */
+		RFALSE(comp_keys(&MAX_KEY, p_s_key) &&
+		       !key_in_buffer(p_s_search_path, p_s_key, p_s_sb),
+		       "PAP-5130: key is not in the buffer");
 #ifdef CONFIG_REISERFS_CHECK
-	if ( cur_tb ) {
-	    print_cur_tb ("5140");
-	    reiserfs_panic(p_s_sb, "PAP-5140: search_by_key: schedule occurred in do_balance!");
-	}
+		if (cur_tb) {
+			print_cur_tb("5140");
+			reiserfs_panic(p_s_sb,
+				       "PAP-5140: search_by_key: schedule occurred in do_balance!");
+		}
 #endif
 
-	// make sure, that the node contents look like a node of
-	// certain level
-	if (!is_tree_node (p_s_bh, expected_level)) {
-	    reiserfs_warning (p_s_sb, "vs-5150: search_by_key: "
-			      "invalid format found in block %ld. Fsck?",
-			      p_s_bh->b_blocknr);
-	    pathrelse (p_s_search_path);
-	    return IO_ERROR;
-	}
-	
-	/* ok, we have acquired next formatted node in the tree */
-	n_node_level = B_LEVEL (p_s_bh);
-
-	PROC_INFO_BH_STAT( p_s_sb, p_s_bh, n_node_level - 1 );
-
-	RFALSE( n_node_level < n_stop_level,
-		"vs-5152: tree level (%d) is less than stop level (%d)",
-		n_node_level, n_stop_level);
-
-	n_retval = bin_search( p_s_key, B_N_PITEM_HEAD(p_s_bh, 0),
-                B_NR_ITEMS(p_s_bh),
-                ( n_node_level == DISK_LEAF_NODE_LEVEL ) ? IH_SIZE : KEY_SIZE,
-                &(p_s_last_element->pe_position));
-	if (n_node_level == n_stop_level) {
-	    return n_retval;
-	}
+		// make sure, that the node contents look like a node of
+		// certain level
+		if (!is_tree_node(p_s_bh, expected_level)) {
+			reiserfs_warning(p_s_sb, "vs-5150: search_by_key: "
+					 "invalid format found in block %ld. Fsck?",
+					 p_s_bh->b_blocknr);
+			pathrelse(p_s_search_path);
+			return IO_ERROR;
+		}
 
-	/* we are not in the stop level */
-	if (n_retval == ITEM_FOUND)
-	    /* item has been found, so we choose the pointer which is to the right of the found one */
-	    p_s_last_element->pe_position++;
+		/* ok, we have acquired next formatted node in the tree */
+		n_node_level = B_LEVEL(p_s_bh);
 
-	/* if item was not found we choose the position which is to
-	   the left of the found item. This requires no code,
-	   bin_search did it already.*/
+		PROC_INFO_BH_STAT(p_s_sb, p_s_bh, n_node_level - 1);
 
-	/* So we have chosen a position in the current node which is
-	   an internal node.  Now we calculate child block number by
-	   position in the node. */
-	n_block_number = B_N_CHILD_NUM(p_s_bh, p_s_last_element->pe_position);
+		RFALSE(n_node_level < n_stop_level,
+		       "vs-5152: tree level (%d) is less than stop level (%d)",
+		       n_node_level, n_stop_level);
 
-	/* if we are going to read leaf nodes, try for read ahead as well */
-	if ((p_s_search_path->reada & PATH_READA) &&
-	    n_node_level == DISK_LEAF_NODE_LEVEL + 1)
-	{
-	    int pos = p_s_last_element->pe_position;
-	    int limit = B_NR_ITEMS(p_s_bh);
-	    struct reiserfs_key *le_key;
-
-	    if (p_s_search_path->reada & PATH_READA_BACK)
-		limit = 0;
-	    while(reada_count < SEARCH_BY_KEY_READA) {
-		if (pos == limit)
-		    break;
-	        reada_blocks[reada_count++] = B_N_CHILD_NUM(p_s_bh, pos);
-		if (p_s_search_path->reada & PATH_READA_BACK)
-		    pos--;
-		else
-		    pos++;
+		n_retval = bin_search(p_s_key, B_N_PITEM_HEAD(p_s_bh, 0),
+				      B_NR_ITEMS(p_s_bh),
+				      (n_node_level ==
+				       DISK_LEAF_NODE_LEVEL) ? IH_SIZE :
+				      KEY_SIZE,
+				      &(p_s_last_element->pe_position));
+		if (n_node_level == n_stop_level) {
+			return n_retval;
+		}
 
-		/*
-		 * check to make sure we're in the same object
-		 */
-		le_key = B_N_PDELIM_KEY(p_s_bh, pos);
-		if (le32_to_cpu(le_key->k_objectid) !=
-		    p_s_key->on_disk_key.k_objectid)
-		{
-		    break;
+		/* we are not in the stop level */
+		if (n_retval == ITEM_FOUND)
+			/* item has been found, so we choose the pointer which is to the right of the found one */
+			p_s_last_element->pe_position++;
+
+		/* if item was not found we choose the position which is to
+		   the left of the found item. This requires no code,
+		   bin_search did it already. */
+
+		/* So we have chosen a position in the current node which is
+		   an internal node.  Now we calculate child block number by
+		   position in the node. */
+		n_block_number =
+		    B_N_CHILD_NUM(p_s_bh, p_s_last_element->pe_position);
+
+		/* if we are going to read leaf nodes, try for read ahead as well */
+		if ((p_s_search_path->reada & PATH_READA) &&
+		    n_node_level == DISK_LEAF_NODE_LEVEL + 1) {
+			int pos = p_s_last_element->pe_position;
+			int limit = B_NR_ITEMS(p_s_bh);
+			struct reiserfs_key *le_key;
+
+			if (p_s_search_path->reada & PATH_READA_BACK)
+				limit = 0;
+			while (reada_count < SEARCH_BY_KEY_READA) {
+				if (pos == limit)
+					break;
+				reada_blocks[reada_count++] =
+				    B_N_CHILD_NUM(p_s_bh, pos);
+				if (p_s_search_path->reada & PATH_READA_BACK)
+					pos--;
+				else
+					pos++;
+
+				/*
+				 * check to make sure we're in the same object
+				 */
+				le_key = B_N_PDELIM_KEY(p_s_bh, pos);
+				if (le32_to_cpu(le_key->k_objectid) !=
+				    p_s_key->on_disk_key.k_objectid) {
+					break;
+				}
+			}
 		}
-	    }
-        }
-    }
+	}
 }
 
-
 /* Form the path to an item and position in this item which contains
    file byte defined by p_s_key. If there is no such item
    corresponding to the key, we point the path to the item with
@@ -780,94 +812,97 @@ int search_by_key (struct super_block * p_s_sb,
    units of directory entries.  */
 
 /* The function is NOT SCHEDULE-SAFE! */
-int search_for_position_by_key (struct super_block  * p_s_sb,         /* Pointer to the super block.          */
-				const struct cpu_key  * p_cpu_key,      /* Key to search (cpu variable)         */
-				struct path         * p_s_search_path /* Filled up by this function.          */
-    ) {
-    struct item_head    * p_le_ih; /* pointer to on-disk structure */
-    int                   n_blk_size;
-    loff_t item_offset, offset;
-    struct reiserfs_dir_entry de;
-    int retval;
-
-    /* If searching for directory entry. */
-    if ( is_direntry_cpu_key (p_cpu_key) )
-	return  search_by_entry_key (p_s_sb, p_cpu_key, p_s_search_path, &de);
-
-    /* If not searching for directory entry. */
-    
-    /* If item is found. */
-    retval = search_item (p_s_sb, p_cpu_key, p_s_search_path);
-    if (retval == IO_ERROR)
-	return retval;
-    if ( retval == ITEM_FOUND )  {
-
-	RFALSE( ! ih_item_len(
-                B_N_PITEM_HEAD(PATH_PLAST_BUFFER(p_s_search_path),
-			       PATH_LAST_POSITION(p_s_search_path))),
-	        "PAP-5165: item length equals zero");
+int search_for_position_by_key(struct super_block *p_s_sb,	/* Pointer to the super block.          */
+			       const struct cpu_key *p_cpu_key,	/* Key to search (cpu variable)         */
+			       struct path *p_s_search_path	/* Filled up by this function.          */
+    )
+{
+	struct item_head *p_le_ih;	/* pointer to on-disk structure */
+	int n_blk_size;
+	loff_t item_offset, offset;
+	struct reiserfs_dir_entry de;
+	int retval;
+
+	/* If searching for directory entry. */
+	if (is_direntry_cpu_key(p_cpu_key))
+		return search_by_entry_key(p_s_sb, p_cpu_key, p_s_search_path,
+					   &de);
+
+	/* If not searching for directory entry. */
+
+	/* If item is found. */
+	retval = search_item(p_s_sb, p_cpu_key, p_s_search_path);
+	if (retval == IO_ERROR)
+		return retval;
+	if (retval == ITEM_FOUND) {
 
-	pos_in_item(p_s_search_path) = 0;
-	return POSITION_FOUND;
-    }
+		RFALSE(!ih_item_len
+		       (B_N_PITEM_HEAD
+			(PATH_PLAST_BUFFER(p_s_search_path),
+			 PATH_LAST_POSITION(p_s_search_path))),
+		       "PAP-5165: item length equals zero");
 
-    RFALSE( ! PATH_LAST_POSITION(p_s_search_path),
-	    "PAP-5170: position equals zero");
+		pos_in_item(p_s_search_path) = 0;
+		return POSITION_FOUND;
+	}
 
-    /* Item is not found. Set path to the previous item. */
-    p_le_ih = B_N_PITEM_HEAD(PATH_PLAST_BUFFER(p_s_search_path), --PATH_LAST_POSITION(p_s_search_path));
-    n_blk_size = p_s_sb->s_blocksize;
+	RFALSE(!PATH_LAST_POSITION(p_s_search_path),
+	       "PAP-5170: position equals zero");
 
-    if (comp_short_keys (&(p_le_ih->ih_key), p_cpu_key)) {
-	return FILE_NOT_FOUND;
-    }
+	/* Item is not found. Set path to the previous item. */
+	p_le_ih =
+	    B_N_PITEM_HEAD(PATH_PLAST_BUFFER(p_s_search_path),
+			   --PATH_LAST_POSITION(p_s_search_path));
+	n_blk_size = p_s_sb->s_blocksize;
 
-    // FIXME: quite ugly this far
+	if (comp_short_keys(&(p_le_ih->ih_key), p_cpu_key)) {
+		return FILE_NOT_FOUND;
+	}
+	// FIXME: quite ugly this far
 
-    item_offset = le_ih_k_offset (p_le_ih);
-    offset = cpu_key_k_offset (p_cpu_key);
+	item_offset = le_ih_k_offset(p_le_ih);
+	offset = cpu_key_k_offset(p_cpu_key);
 
-    /* Needed byte is contained in the item pointed to by the path.*/
-    if (item_offset <= offset &&
-	item_offset + op_bytes_number (p_le_ih, n_blk_size) > offset) {
-	pos_in_item (p_s_search_path) = offset - item_offset;
-	if ( is_indirect_le_ih(p_le_ih) ) {
-	    pos_in_item (p_s_search_path) /= n_blk_size;
+	/* Needed byte is contained in the item pointed to by the path. */
+	if (item_offset <= offset &&
+	    item_offset + op_bytes_number(p_le_ih, n_blk_size) > offset) {
+		pos_in_item(p_s_search_path) = offset - item_offset;
+		if (is_indirect_le_ih(p_le_ih)) {
+			pos_in_item(p_s_search_path) /= n_blk_size;
+		}
+		return POSITION_FOUND;
 	}
-	return POSITION_FOUND;
-    }
-
-    /* Needed byte is not contained in the item pointed to by the
-     path. Set pos_in_item out of the item. */
-    if ( is_indirect_le_ih (p_le_ih) )
-	pos_in_item (p_s_search_path) = ih_item_len(p_le_ih) / UNFM_P_SIZE;
-    else
-        pos_in_item (p_s_search_path) = ih_item_len( p_le_ih );
-  
-    return POSITION_NOT_FOUND;
-}
 
+	/* Needed byte is not contained in the item pointed to by the
+	   path. Set pos_in_item out of the item. */
+	if (is_indirect_le_ih(p_le_ih))
+		pos_in_item(p_s_search_path) =
+		    ih_item_len(p_le_ih) / UNFM_P_SIZE;
+	else
+		pos_in_item(p_s_search_path) = ih_item_len(p_le_ih);
+
+	return POSITION_NOT_FOUND;
+}
 
 /* Compare given item and item pointed to by the path. */
-int comp_items (const struct item_head * stored_ih, const struct path * p_s_path)
+int comp_items(const struct item_head *stored_ih, const struct path *p_s_path)
 {
-    struct buffer_head  * p_s_bh;
-    struct item_head    * ih;
+	struct buffer_head *p_s_bh;
+	struct item_head *ih;
 
-    /* Last buffer at the path is not in the tree. */
-    if ( ! B_IS_IN_TREE(p_s_bh = PATH_PLAST_BUFFER(p_s_path)) )
-	return 1;
+	/* Last buffer at the path is not in the tree. */
+	if (!B_IS_IN_TREE(p_s_bh = PATH_PLAST_BUFFER(p_s_path)))
+		return 1;
 
-    /* Last path position is invalid. */
-    if ( PATH_LAST_POSITION(p_s_path) >= B_NR_ITEMS(p_s_bh) )
-	return 1;
+	/* Last path position is invalid. */
+	if (PATH_LAST_POSITION(p_s_path) >= B_NR_ITEMS(p_s_bh))
+		return 1;
 
-    /* we need only to know, whether it is the same item */
-    ih = get_ih (p_s_path);
-    return memcmp (stored_ih, ih, IH_SIZE);
+	/* we need only to know, whether it is the same item */
+	ih = get_ih(p_s_path);
+	return memcmp(stored_ih, ih, IH_SIZE);
 }
 
-
 /* unformatted nodes are not logged anymore, ever.  This is safe
 ** now
 */
@@ -876,461 +911,466 @@ int comp_items (const struct item_head * stored_ih, const struct path * p_s_path
 // block can not be forgotten as it is in I/O or held by someone
 #define block_in_use(bh) (buffer_locked(bh) || (held_by_others(bh)))
 
-
-
 // prepare for delete or cut of direct item
-static inline int prepare_for_direct_item (struct path * path,
-					   struct item_head * le_ih,
-					   struct inode * inode,
-					   loff_t new_file_length,
-					   int * cut_size)
+static inline int prepare_for_direct_item(struct path *path,
+					  struct item_head *le_ih,
+					  struct inode *inode,
+					  loff_t new_file_length, int *cut_size)
 {
-    loff_t round_len;
-
-
-    if ( new_file_length == max_reiserfs_offset (inode) ) {
-	/* item has to be deleted */
-	*cut_size = -(IH_SIZE + ih_item_len(le_ih));
-	return M_DELETE;
-    }
-	
-    // new file gets truncated
-    if (get_inode_item_key_version (inode) == KEY_FORMAT_3_6) {
-	// 
-	round_len = ROUND_UP (new_file_length); 
-	/* this was n_new_file_length < le_ih ... */
-	if ( round_len < le_ih_k_offset (le_ih) )  {
-	    *cut_size = -(IH_SIZE + ih_item_len(le_ih));
-	    return M_DELETE; /* Delete this item. */
+	loff_t round_len;
+
+	if (new_file_length == max_reiserfs_offset(inode)) {
+		/* item has to be deleted */
+		*cut_size = -(IH_SIZE + ih_item_len(le_ih));
+		return M_DELETE;
+	}
+	// new file gets truncated
+	if (get_inode_item_key_version(inode) == KEY_FORMAT_3_6) {
+		// 
+		round_len = ROUND_UP(new_file_length);
+		/* this was n_new_file_length < le_ih ... */
+		if (round_len < le_ih_k_offset(le_ih)) {
+			*cut_size = -(IH_SIZE + ih_item_len(le_ih));
+			return M_DELETE;	/* Delete this item. */
+		}
+		/* Calculate first position and size for cutting from item. */
+		pos_in_item(path) = round_len - (le_ih_k_offset(le_ih) - 1);
+		*cut_size = -(ih_item_len(le_ih) - pos_in_item(path));
+
+		return M_CUT;	/* Cut from this item. */
+	}
+
+	// old file: items may have any length
+
+	if (new_file_length < le_ih_k_offset(le_ih)) {
+		*cut_size = -(IH_SIZE + ih_item_len(le_ih));
+		return M_DELETE;	/* Delete this item. */
 	}
 	/* Calculate first position and size for cutting from item. */
-	pos_in_item (path) = round_len - (le_ih_k_offset (le_ih) - 1);
-	*cut_size = -(ih_item_len(le_ih) - pos_in_item(path));
-	
-	return M_CUT; /* Cut from this item. */
-    }
-
-
-    // old file: items may have any length
-
-    if ( new_file_length < le_ih_k_offset (le_ih) )  {
-	*cut_size = -(IH_SIZE + ih_item_len(le_ih));
-	return M_DELETE; /* Delete this item. */
-    }
-    /* Calculate first position and size for cutting from item. */
-    *cut_size = -(ih_item_len(le_ih) -
-		      (pos_in_item (path) = new_file_length + 1 - le_ih_k_offset (le_ih)));
-    return M_CUT; /* Cut from this item. */
+	*cut_size = -(ih_item_len(le_ih) -
+		      (pos_in_item(path) =
+		       new_file_length + 1 - le_ih_k_offset(le_ih)));
+	return M_CUT;		/* Cut from this item. */
 }
 
-
-static inline int prepare_for_direntry_item (struct path * path,
-					     struct item_head * le_ih,
-					     struct inode * inode,
-					     loff_t new_file_length,
-					     int * cut_size)
+static inline int prepare_for_direntry_item(struct path *path,
+					    struct item_head *le_ih,
+					    struct inode *inode,
+					    loff_t new_file_length,
+					    int *cut_size)
 {
-    if (le_ih_k_offset (le_ih) == DOT_OFFSET && 
-	new_file_length == max_reiserfs_offset (inode)) {
-	RFALSE( ih_entry_count (le_ih) != 2,
-	        "PAP-5220: incorrect empty directory item (%h)", le_ih);
-	*cut_size = -(IH_SIZE + ih_item_len(le_ih));
-	return M_DELETE; /* Delete the directory item containing "." and ".." entry. */
-    }
-    
-    if ( ih_entry_count (le_ih) == 1 )  {
-	/* Delete the directory item such as there is one record only
-	   in this item*/
-	*cut_size = -(IH_SIZE + ih_item_len(le_ih));
-	return M_DELETE;
-    }
-    
-    /* Cut one record from the directory item. */
-    *cut_size = -(DEH_SIZE + entry_length (get_last_bh (path), le_ih, pos_in_item (path)));
-    return M_CUT; 
-}
+	if (le_ih_k_offset(le_ih) == DOT_OFFSET &&
+	    new_file_length == max_reiserfs_offset(inode)) {
+		RFALSE(ih_entry_count(le_ih) != 2,
+		       "PAP-5220: incorrect empty directory item (%h)", le_ih);
+		*cut_size = -(IH_SIZE + ih_item_len(le_ih));
+		return M_DELETE;	/* Delete the directory item containing "." and ".." entry. */
+	}
 
+	if (ih_entry_count(le_ih) == 1) {
+		/* Delete the directory item such as there is one record only
+		   in this item */
+		*cut_size = -(IH_SIZE + ih_item_len(le_ih));
+		return M_DELETE;
+	}
+
+	/* Cut one record from the directory item. */
+	*cut_size =
+	    -(DEH_SIZE +
+	      entry_length(get_last_bh(path), le_ih, pos_in_item(path)));
+	return M_CUT;
+}
 
 /*  If the path points to a directory or direct item, calculate mode and the size cut, for balance.
     If the path points to an indirect item, remove some number of its unformatted nodes.
     In case of file truncate calculate whether this item must be deleted/truncated or last
     unformatted node of this item will be converted to a direct item.
     This function returns a determination of what balance mode the calling function should employ. */
-static char  prepare_for_delete_or_cut(
-				       struct reiserfs_transaction_handle *th, 
-				       struct inode * inode,
-				       struct path         * p_s_path,
-				       const struct cpu_key      * p_s_item_key,
-				       int                 * p_n_removed,      /* Number of unformatted nodes which were removed
-										  from end of the file. */
-				       int                 * p_n_cut_size,
-				       unsigned long long    n_new_file_length /* MAX_KEY_OFFSET in case of delete. */
-    ) {
-    struct super_block  * p_s_sb = inode->i_sb;
-    struct item_head    * p_le_ih = PATH_PITEM_HEAD(p_s_path);
-    struct buffer_head  * p_s_bh = PATH_PLAST_BUFFER(p_s_path);
-
-    BUG_ON (!th->t_trans_id);
-
-    /* Stat_data item. */
-    if ( is_statdata_le_ih (p_le_ih) ) {
-
-	RFALSE( n_new_file_length != max_reiserfs_offset (inode),
-		"PAP-5210: mode must be M_DELETE");
-
-	*p_n_cut_size = -(IH_SIZE + ih_item_len(p_le_ih));
-	return M_DELETE;
-    }
-
-
-    /* Directory item. */
-    if ( is_direntry_le_ih (p_le_ih) )
-	return prepare_for_direntry_item (p_s_path, p_le_ih, inode, n_new_file_length, p_n_cut_size);
-
-    /* Direct item. */
-    if ( is_direct_le_ih (p_le_ih) )
-	return prepare_for_direct_item (p_s_path, p_le_ih, inode, n_new_file_length, p_n_cut_size);
-
-
-    /* Case of an indirect item. */
-    {
-	int                   n_unfm_number,    /* Number of the item unformatted nodes. */
-	    n_counter,
-	    n_blk_size;
-	__le32               * p_n_unfm_pointer; /* Pointer to the unformatted node number. */
-	__u32 tmp;
-	struct item_head      s_ih;           /* Item header. */
-	char                  c_mode;           /* Returned mode of the balance. */
-	int need_research;
+static char prepare_for_delete_or_cut(struct reiserfs_transaction_handle *th, struct inode *inode, struct path *p_s_path, const struct cpu_key *p_s_item_key, int *p_n_removed,	/* Number of unformatted nodes which were removed
+																						   from end of the file. */
+				      int *p_n_cut_size, unsigned long long n_new_file_length	/* MAX_KEY_OFFSET in case of delete. */
+    )
+{
+	struct super_block *p_s_sb = inode->i_sb;
+	struct item_head *p_le_ih = PATH_PITEM_HEAD(p_s_path);
+	struct buffer_head *p_s_bh = PATH_PLAST_BUFFER(p_s_path);
 
+	BUG_ON(!th->t_trans_id);
 
-	n_blk_size = p_s_sb->s_blocksize;
+	/* Stat_data item. */
+	if (is_statdata_le_ih(p_le_ih)) {
 
-	/* Search for the needed object indirect item until there are no unformatted nodes to be removed. */
-	do  {
-	    need_research = 0;
-            p_s_bh = PATH_PLAST_BUFFER(p_s_path);
-	    /* Copy indirect item header to a temp variable. */
-	    copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path));
-	    /* Calculate number of unformatted nodes in this item. */
-	    n_unfm_number = I_UNFM_NUM(&s_ih);
-
-	    RFALSE( ! is_indirect_le_ih(&s_ih) || ! n_unfm_number ||
-		    pos_in_item (p_s_path) + 1 !=  n_unfm_number,
-		    "PAP-5240: invalid item %h "
-		    "n_unfm_number = %d *p_n_pos_in_item = %d", 
-		    &s_ih, n_unfm_number, pos_in_item (p_s_path));
-
-	    /* Calculate balance mode and position in the item to remove unformatted nodes. */
-	    if ( n_new_file_length == max_reiserfs_offset (inode) ) {/* Case of delete. */
-		pos_in_item (p_s_path) = 0;
-		*p_n_cut_size = -(IH_SIZE + ih_item_len(&s_ih));
-		c_mode = M_DELETE;
-	    }
-	    else  { /* Case of truncate. */
-		if ( n_new_file_length < le_ih_k_offset (&s_ih) )  {
-		    pos_in_item (p_s_path) = 0;
-		    *p_n_cut_size = -(IH_SIZE + ih_item_len(&s_ih));
-		    c_mode = M_DELETE; /* Delete this item. */
-		}
-		else  {
-		    /* indirect item must be truncated starting from *p_n_pos_in_item-th position */
-		    pos_in_item (p_s_path) = (n_new_file_length + n_blk_size - le_ih_k_offset (&s_ih) ) >> p_s_sb->s_blocksize_bits;
-
-		    RFALSE( pos_in_item (p_s_path) > n_unfm_number,
-			    "PAP-5250: invalid position in the item");
-
-		    /* Either convert last unformatted node of indirect item to direct item or increase
-		       its free space.  */
-		    if ( pos_in_item (p_s_path) == n_unfm_number )  {
-			*p_n_cut_size = 0; /* Nothing to cut. */
-			return M_CONVERT; /* Maybe convert last unformatted node to the direct item. */
-		    }
-		    /* Calculate size to cut. */
-		    *p_n_cut_size = -(ih_item_len(&s_ih) - pos_in_item(p_s_path) * UNFM_P_SIZE);
-
-		    c_mode = M_CUT;     /* Cut from this indirect item. */
-		}
-	    }
-
-	    RFALSE( n_unfm_number <= pos_in_item (p_s_path),
-		    "PAP-5260: invalid position in the indirect item");
-
-	    /* pointers to be cut */
-	    n_unfm_number -= pos_in_item (p_s_path);
-	    /* Set pointer to the last unformatted node pointer that is to be cut. */
-	    p_n_unfm_pointer = (__le32 *)B_I_PITEM(p_s_bh, &s_ih) + I_UNFM_NUM(&s_ih) - 1 - *p_n_removed;
-
-
-	    /* We go through the unformatted nodes pointers of the indirect
-	       item and look for the unformatted nodes in the cache. If we
-	       found some of them we free it, zero corresponding indirect item
-	       entry and log buffer containing that indirect item. For this we
-	       need to prepare last path element for logging. If some
-	       unformatted node has b_count > 1 we must not free this
-	       unformatted node since it is in use. */
-	    reiserfs_prepare_for_journal(p_s_sb, p_s_bh, 1);
-	    // note: path could be changed, first line in for loop takes care
-	    // of it
-
-	    for (n_counter = *p_n_removed;
-		 n_counter < n_unfm_number; n_counter++, p_n_unfm_pointer-- ) {
-
-		cond_resched();
-		if (item_moved (&s_ih, p_s_path)) {
-		    need_research = 1 ;
-		    break;
-		}
-		RFALSE( p_n_unfm_pointer < (__le32 *)B_I_PITEM(p_s_bh, &s_ih) ||
-			p_n_unfm_pointer > (__le32 *)B_I_PITEM(p_s_bh, &s_ih) + I_UNFM_NUM(&s_ih) - 1,
-			"vs-5265: pointer out of range");
+		RFALSE(n_new_file_length != max_reiserfs_offset(inode),
+		       "PAP-5210: mode must be M_DELETE");
 
-		/* Hole, nothing to remove. */
-		if ( ! get_block_num(p_n_unfm_pointer,0) )  {
-			(*p_n_removed)++;
-			continue;
-		}
+		*p_n_cut_size = -(IH_SIZE + ih_item_len(p_le_ih));
+		return M_DELETE;
+	}
 
-		(*p_n_removed)++;
+	/* Directory item. */
+	if (is_direntry_le_ih(p_le_ih))
+		return prepare_for_direntry_item(p_s_path, p_le_ih, inode,
+						 n_new_file_length,
+						 p_n_cut_size);
 
-		tmp = get_block_num(p_n_unfm_pointer,0);
-		put_block_num(p_n_unfm_pointer, 0, 0);
-		journal_mark_dirty (th, p_s_sb, p_s_bh);
-		reiserfs_free_block(th, inode, tmp, 1);
-		if ( item_moved (&s_ih, p_s_path) )  {
-			need_research = 1;
-			break ;
-		}
-	    }
-
-	    /* a trick.  If the buffer has been logged, this
-	    ** will do nothing.  If we've broken the loop without
-	    ** logging it, it will restore the buffer
-	    **
-	    */
-	    reiserfs_restore_prepared_buffer(p_s_sb, p_s_bh);
-
-	    /* This loop can be optimized. */
-	} while ( (*p_n_removed < n_unfm_number || need_research) &&
-		  search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path) == POSITION_FOUND );
-
-	RFALSE( *p_n_removed < n_unfm_number, 
-		"PAP-5310: indirect item is not found");
-	RFALSE( item_moved (&s_ih, p_s_path), 
-		"after while, comp failed, retry") ;
-
-	if (c_mode == M_CUT)
-	    pos_in_item (p_s_path) *= UNFM_P_SIZE;
-	return c_mode;
-    }
+	/* Direct item. */
+	if (is_direct_le_ih(p_le_ih))
+		return prepare_for_direct_item(p_s_path, p_le_ih, inode,
+					       n_new_file_length, p_n_cut_size);
+
+	/* Case of an indirect item. */
+	{
+		int n_unfm_number,	/* Number of the item unformatted nodes. */
+		 n_counter, n_blk_size;
+		__le32 *p_n_unfm_pointer;	/* Pointer to the unformatted node number. */
+		__u32 tmp;
+		struct item_head s_ih;	/* Item header. */
+		char c_mode;	/* Returned mode of the balance. */
+		int need_research;
+
+		n_blk_size = p_s_sb->s_blocksize;
+
+		/* Search for the needed object indirect item until there are no unformatted nodes to be removed. */
+		do {
+			need_research = 0;
+			p_s_bh = PATH_PLAST_BUFFER(p_s_path);
+			/* Copy indirect item header to a temp variable. */
+			copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path));
+			/* Calculate number of unformatted nodes in this item. */
+			n_unfm_number = I_UNFM_NUM(&s_ih);
+
+			RFALSE(!is_indirect_le_ih(&s_ih) || !n_unfm_number ||
+			       pos_in_item(p_s_path) + 1 != n_unfm_number,
+			       "PAP-5240: invalid item %h "
+			       "n_unfm_number = %d *p_n_pos_in_item = %d",
+			       &s_ih, n_unfm_number, pos_in_item(p_s_path));
+
+			/* Calculate balance mode and position in the item to remove unformatted nodes. */
+			if (n_new_file_length == max_reiserfs_offset(inode)) {	/* Case of delete. */
+				pos_in_item(p_s_path) = 0;
+				*p_n_cut_size = -(IH_SIZE + ih_item_len(&s_ih));
+				c_mode = M_DELETE;
+			} else {	/* Case of truncate. */
+				if (n_new_file_length < le_ih_k_offset(&s_ih)) {
+					pos_in_item(p_s_path) = 0;
+					*p_n_cut_size =
+					    -(IH_SIZE + ih_item_len(&s_ih));
+					c_mode = M_DELETE;	/* Delete this item. */
+				} else {
+					/* indirect item must be truncated starting from *p_n_pos_in_item-th position */
+					pos_in_item(p_s_path) =
+					    (n_new_file_length + n_blk_size -
+					     le_ih_k_offset(&s_ih)) >> p_s_sb->
+					    s_blocksize_bits;
+
+					RFALSE(pos_in_item(p_s_path) >
+					       n_unfm_number,
+					       "PAP-5250: invalid position in the item");
+
+					/* Either convert last unformatted node of indirect item to direct item or increase
+					   its free space.  */
+					if (pos_in_item(p_s_path) ==
+					    n_unfm_number) {
+						*p_n_cut_size = 0;	/* Nothing to cut. */
+						return M_CONVERT;	/* Maybe convert last unformatted node to the direct item. */
+					}
+					/* Calculate size to cut. */
+					*p_n_cut_size =
+					    -(ih_item_len(&s_ih) -
+					      pos_in_item(p_s_path) *
+					      UNFM_P_SIZE);
+
+					c_mode = M_CUT;	/* Cut from this indirect item. */
+				}
+			}
+
+			RFALSE(n_unfm_number <= pos_in_item(p_s_path),
+			       "PAP-5260: invalid position in the indirect item");
+
+			/* pointers to be cut */
+			n_unfm_number -= pos_in_item(p_s_path);
+			/* Set pointer to the last unformatted node pointer that is to be cut. */
+			p_n_unfm_pointer =
+			    (__le32 *) B_I_PITEM(p_s_bh,
+						 &s_ih) + I_UNFM_NUM(&s_ih) -
+			    1 - *p_n_removed;
+
+			/* We go through the unformatted nodes pointers of the indirect
+			   item and look for the unformatted nodes in the cache. If we
+			   found some of them we free it, zero corresponding indirect item
+			   entry and log buffer containing that indirect item. For this we
+			   need to prepare last path element for logging. If some
+			   unformatted node has b_count > 1 we must not free this
+			   unformatted node since it is in use. */
+			reiserfs_prepare_for_journal(p_s_sb, p_s_bh, 1);
+			// note: path could be changed, first line in for loop takes care
+			// of it
+
+			for (n_counter = *p_n_removed;
+			     n_counter < n_unfm_number;
+			     n_counter++, p_n_unfm_pointer--) {
+
+				cond_resched();
+				if (item_moved(&s_ih, p_s_path)) {
+					need_research = 1;
+					break;
+				}
+				RFALSE(p_n_unfm_pointer <
+				       (__le32 *) B_I_PITEM(p_s_bh, &s_ih)
+				       || p_n_unfm_pointer >
+				       (__le32 *) B_I_PITEM(p_s_bh,
+							    &s_ih) +
+				       I_UNFM_NUM(&s_ih) - 1,
+				       "vs-5265: pointer out of range");
+
+				/* Hole, nothing to remove. */
+				if (!get_block_num(p_n_unfm_pointer, 0)) {
+					(*p_n_removed)++;
+					continue;
+				}
+
+				(*p_n_removed)++;
+
+				tmp = get_block_num(p_n_unfm_pointer, 0);
+				put_block_num(p_n_unfm_pointer, 0, 0);
+				journal_mark_dirty(th, p_s_sb, p_s_bh);
+				reiserfs_free_block(th, inode, tmp, 1);
+				if (item_moved(&s_ih, p_s_path)) {
+					need_research = 1;
+					break;
+				}
+			}
+
+			/* a trick.  If the buffer has been logged, this
+			 ** will do nothing.  If we've broken the loop without
+			 ** logging it, it will restore the buffer
+			 **
+			 */
+			reiserfs_restore_prepared_buffer(p_s_sb, p_s_bh);
+
+			/* This loop can be optimized. */
+		} while ((*p_n_removed < n_unfm_number || need_research) &&
+			 search_for_position_by_key(p_s_sb, p_s_item_key,
+						    p_s_path) ==
+			 POSITION_FOUND);
+
+		RFALSE(*p_n_removed < n_unfm_number,
+		       "PAP-5310: indirect item is not found");
+		RFALSE(item_moved(&s_ih, p_s_path),
+		       "after while, comp failed, retry");
+
+		if (c_mode == M_CUT)
+			pos_in_item(p_s_path) *= UNFM_P_SIZE;
+		return c_mode;
+	}
 }
 
 /* Calculate number of bytes which will be deleted or cut during balance */
-static int calc_deleted_bytes_number(
-    struct  tree_balance  * p_s_tb,
-    char                    c_mode
-    ) {
-    int                     n_del_size;
-    struct  item_head     * p_le_ih = PATH_PITEM_HEAD(p_s_tb->tb_path);
-
-    if ( is_statdata_le_ih (p_le_ih) )
-	return 0;
+static int calc_deleted_bytes_number(struct tree_balance *p_s_tb, char c_mode)
+{
+	int n_del_size;
+	struct item_head *p_le_ih = PATH_PITEM_HEAD(p_s_tb->tb_path);
+
+	if (is_statdata_le_ih(p_le_ih))
+		return 0;
+
+	n_del_size =
+	    (c_mode ==
+	     M_DELETE) ? ih_item_len(p_le_ih) : -p_s_tb->insert_size[0];
+	if (is_direntry_le_ih(p_le_ih)) {
+		// return EMPTY_DIR_SIZE; /* We delete emty directoris only. */
+		// we can't use EMPTY_DIR_SIZE, as old format dirs have a different
+		// empty size.  ick. FIXME, is this right?
+		//
+		return n_del_size;
+	}
 
-    n_del_size = ( c_mode == M_DELETE ) ? ih_item_len(p_le_ih) : -p_s_tb->insert_size[0];
-    if ( is_direntry_le_ih (p_le_ih) ) {
-	// return EMPTY_DIR_SIZE; /* We delete emty directoris only. */
-	// we can't use EMPTY_DIR_SIZE, as old format dirs have a different
-	// empty size.  ick. FIXME, is this right?
-	//
-	return n_del_size ;
-    }
-
-    if ( is_indirect_le_ih (p_le_ih) )
-	n_del_size = (n_del_size/UNFM_P_SIZE)*
-	  (PATH_PLAST_BUFFER(p_s_tb->tb_path)->b_size);// - get_ih_free_space (p_le_ih);
-    return n_del_size;
+	if (is_indirect_le_ih(p_le_ih))
+		n_del_size = (n_del_size / UNFM_P_SIZE) * (PATH_PLAST_BUFFER(p_s_tb->tb_path)->b_size);	// - get_ih_free_space (p_le_ih);
+	return n_del_size;
 }
 
-static void init_tb_struct(
-    struct reiserfs_transaction_handle *th,
-    struct tree_balance * p_s_tb,
-    struct super_block  * p_s_sb,
-    struct path         * p_s_path,
-    int                   n_size
-    ) {
-
-    BUG_ON (!th->t_trans_id);
-
-    memset (p_s_tb,'\0',sizeof(struct tree_balance));
-    p_s_tb->transaction_handle = th ;
-    p_s_tb->tb_sb = p_s_sb;
-    p_s_tb->tb_path = p_s_path;
-    PATH_OFFSET_PBUFFER(p_s_path, ILLEGAL_PATH_ELEMENT_OFFSET) = NULL;
-    PATH_OFFSET_POSITION(p_s_path, ILLEGAL_PATH_ELEMENT_OFFSET) = 0;
-    p_s_tb->insert_size[0] = n_size;
-}
+static void init_tb_struct(struct reiserfs_transaction_handle *th,
+			   struct tree_balance *p_s_tb,
+			   struct super_block *p_s_sb,
+			   struct path *p_s_path, int n_size)
+{
 
+	BUG_ON(!th->t_trans_id);
 
+	memset(p_s_tb, '\0', sizeof(struct tree_balance));
+	p_s_tb->transaction_handle = th;
+	p_s_tb->tb_sb = p_s_sb;
+	p_s_tb->tb_path = p_s_path;
+	PATH_OFFSET_PBUFFER(p_s_path, ILLEGAL_PATH_ELEMENT_OFFSET) = NULL;
+	PATH_OFFSET_POSITION(p_s_path, ILLEGAL_PATH_ELEMENT_OFFSET) = 0;
+	p_s_tb->insert_size[0] = n_size;
+}
 
-void padd_item (char * item, int total_length, int length)
+void padd_item(char *item, int total_length, int length)
 {
-    int i;
+	int i;
 
-    for (i = total_length; i > length; )
-	item [--i] = 0;
+	for (i = total_length; i > length;)
+		item[--i] = 0;
 }
 
 #ifdef REISERQUOTA_DEBUG
 char key2type(struct reiserfs_key *ih)
 {
-  if (is_direntry_le_key(2, ih))
-    return 'd';
-  if (is_direct_le_key(2, ih))
-    return 'D';
-  if (is_indirect_le_key(2, ih))
-    return 'i';
-  if (is_statdata_le_key(2, ih))
-    return 's';
-  return 'u';
+	if (is_direntry_le_key(2, ih))
+		return 'd';
+	if (is_direct_le_key(2, ih))
+		return 'D';
+	if (is_indirect_le_key(2, ih))
+		return 'i';
+	if (is_statdata_le_key(2, ih))
+		return 's';
+	return 'u';
 }
 
 char head2type(struct item_head *ih)
 {
-  if (is_direntry_le_ih(ih))
-    return 'd';
-  if (is_direct_le_ih(ih))
-    return 'D';
-  if (is_indirect_le_ih(ih))
-    return 'i';
-  if (is_statdata_le_ih(ih))
-    return 's';
-  return 'u';
+	if (is_direntry_le_ih(ih))
+		return 'd';
+	if (is_direct_le_ih(ih))
+		return 'D';
+	if (is_indirect_le_ih(ih))
+		return 'i';
+	if (is_statdata_le_ih(ih))
+		return 's';
+	return 'u';
 }
 #endif
 
 /* Delete object item. */
-int reiserfs_delete_item (struct reiserfs_transaction_handle *th, 
-			  struct path * p_s_path, /* Path to the deleted item. */
-			  const struct cpu_key * p_s_item_key, /* Key to search for the deleted item.  */
-			  struct inode * p_s_inode,/* inode is here just to update i_blocks and quotas */
-			  struct buffer_head  * p_s_un_bh)    /* NULL or unformatted node pointer.    */
-{
-    struct super_block * p_s_sb = p_s_inode->i_sb;
-    struct tree_balance   s_del_balance;
-    struct item_head      s_ih;
-    struct item_head      *q_ih;
-    int			  quota_cut_bytes;
-    int                   n_ret_value,
-	n_del_size,
-	n_removed;
+int reiserfs_delete_item(struct reiserfs_transaction_handle *th, struct path *p_s_path,	/* Path to the deleted item. */
+			 const struct cpu_key *p_s_item_key,	/* Key to search for the deleted item.  */
+			 struct inode *p_s_inode,	/* inode is here just to update i_blocks and quotas */
+			 struct buffer_head *p_s_un_bh)
+{				/* NULL or unformatted node pointer.    */
+	struct super_block *p_s_sb = p_s_inode->i_sb;
+	struct tree_balance s_del_balance;
+	struct item_head s_ih;
+	struct item_head *q_ih;
+	int quota_cut_bytes;
+	int n_ret_value, n_del_size, n_removed;
 
 #ifdef CONFIG_REISERFS_CHECK
-    char                  c_mode;
-    int			n_iter = 0;
+	char c_mode;
+	int n_iter = 0;
 #endif
 
-    BUG_ON (!th->t_trans_id);
+	BUG_ON(!th->t_trans_id);
 
-    init_tb_struct(th, &s_del_balance, p_s_sb, p_s_path, 0/*size is unknown*/);
+	init_tb_struct(th, &s_del_balance, p_s_sb, p_s_path,
+		       0 /*size is unknown */ );
 
-    while ( 1 ) {
-	n_removed = 0;
+	while (1) {
+		n_removed = 0;
 
 #ifdef CONFIG_REISERFS_CHECK
-	n_iter++;
-	c_mode =
+		n_iter++;
+		c_mode =
 #endif
-	    prepare_for_delete_or_cut(th, p_s_inode, p_s_path, p_s_item_key, &n_removed, &n_del_size, max_reiserfs_offset (p_s_inode));
-
-	RFALSE( c_mode != M_DELETE, "PAP-5320: mode must be M_DELETE");
-
-	copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path));
-	s_del_balance.insert_size[0] = n_del_size;
-
-	n_ret_value = fix_nodes(M_DELETE, &s_del_balance, NULL, NULL);
-	if ( n_ret_value != REPEAT_SEARCH )
-	    break;
-
-	PROC_INFO_INC( p_s_sb, delete_item_restarted );
+		    prepare_for_delete_or_cut(th, p_s_inode, p_s_path,
+					      p_s_item_key, &n_removed,
+					      &n_del_size,
+					      max_reiserfs_offset(p_s_inode));
+
+		RFALSE(c_mode != M_DELETE, "PAP-5320: mode must be M_DELETE");
+
+		copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path));
+		s_del_balance.insert_size[0] = n_del_size;
+
+		n_ret_value = fix_nodes(M_DELETE, &s_del_balance, NULL, NULL);
+		if (n_ret_value != REPEAT_SEARCH)
+			break;
+
+		PROC_INFO_INC(p_s_sb, delete_item_restarted);
+
+		// file system changed, repeat search
+		n_ret_value =
+		    search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path);
+		if (n_ret_value == IO_ERROR)
+			break;
+		if (n_ret_value == FILE_NOT_FOUND) {
+			reiserfs_warning(p_s_sb,
+					 "vs-5340: reiserfs_delete_item: "
+					 "no items of the file %K found",
+					 p_s_item_key);
+			break;
+		}
+	}			/* while (1) */
 
-	// file system changed, repeat search
-	n_ret_value = search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path);
-	if (n_ret_value == IO_ERROR)
-	    break;
-	if (n_ret_value == FILE_NOT_FOUND) {
-	    reiserfs_warning (p_s_sb, "vs-5340: reiserfs_delete_item: "
-			      "no items of the file %K found", p_s_item_key);
-	    break;
+	if (n_ret_value != CARRY_ON) {
+		unfix_nodes(&s_del_balance);
+		return 0;
+	}
+	// reiserfs_delete_item returns item length when success
+	n_ret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);
+	q_ih = get_ih(p_s_path);
+	quota_cut_bytes = ih_item_len(q_ih);
+
+	/* hack so the quota code doesn't have to guess if the file
+	 ** has a tail.  On tail insert, we allocate quota for 1 unformatted node.
+	 ** We test the offset because the tail might have been
+	 ** split into multiple items, and we only want to decrement for
+	 ** the unfm node once
+	 */
+	if (!S_ISLNK(p_s_inode->i_mode) && is_direct_le_ih(q_ih)) {
+		if ((le_ih_k_offset(q_ih) & (p_s_sb->s_blocksize - 1)) == 1) {
+			quota_cut_bytes = p_s_sb->s_blocksize + UNFM_P_SIZE;
+		} else {
+			quota_cut_bytes = 0;
+		}
 	}
-    } /* while (1) */
 
-    if ( n_ret_value != CARRY_ON ) {
-	unfix_nodes(&s_del_balance);
-	return 0;
-    }
-
-    // reiserfs_delete_item returns item length when success
-    n_ret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);
-    q_ih = get_ih(p_s_path) ;
-    quota_cut_bytes = ih_item_len(q_ih) ;
-
-    /* hack so the quota code doesn't have to guess if the file
-    ** has a tail.  On tail insert, we allocate quota for 1 unformatted node.
-    ** We test the offset because the tail might have been
-    ** split into multiple items, and we only want to decrement for
-    ** the unfm node once
-    */
-    if (!S_ISLNK (p_s_inode->i_mode) && is_direct_le_ih(q_ih)) {
-        if ((le_ih_k_offset(q_ih) & (p_s_sb->s_blocksize - 1)) == 1) {
-            quota_cut_bytes = p_s_sb->s_blocksize + UNFM_P_SIZE;
-        } else {
-	    quota_cut_bytes = 0 ;
+	if (p_s_un_bh) {
+		int off;
+		char *data;
+
+		/* We are in direct2indirect conversion, so move tail contents
+		   to the unformatted node */
+		/* note, we do the copy before preparing the buffer because we
+		 ** don't care about the contents of the unformatted node yet.
+		 ** the only thing we really care about is the direct item's data
+		 ** is in the unformatted node.
+		 **
+		 ** Otherwise, we would have to call reiserfs_prepare_for_journal on
+		 ** the unformatted node, which might schedule, meaning we'd have to
+		 ** loop all the way back up to the start of the while loop.
+		 **
+		 ** The unformatted node must be dirtied later on.  We can't be
+		 ** sure here if the entire tail has been deleted yet.
+		 **
+		 ** p_s_un_bh is from the page cache (all unformatted nodes are
+		 ** from the page cache) and might be a highmem page.  So, we
+		 ** can't use p_s_un_bh->b_data.
+		 ** -clm
+		 */
+
+		data = kmap_atomic(p_s_un_bh->b_page, KM_USER0);
+		off = ((le_ih_k_offset(&s_ih) - 1) & (PAGE_CACHE_SIZE - 1));
+		memcpy(data + off,
+		       B_I_PITEM(PATH_PLAST_BUFFER(p_s_path), &s_ih),
+		       n_ret_value);
+		kunmap_atomic(data, KM_USER0);
 	}
-    }
-
-    if ( p_s_un_bh )  {
-	int off;
-        char *data ;
-
-	/* We are in direct2indirect conversion, so move tail contents
-           to the unformatted node */
-	/* note, we do the copy before preparing the buffer because we
-	** don't care about the contents of the unformatted node yet.
-	** the only thing we really care about is the direct item's data
-	** is in the unformatted node.
-	**
-	** Otherwise, we would have to call reiserfs_prepare_for_journal on
-	** the unformatted node, which might schedule, meaning we'd have to
-	** loop all the way back up to the start of the while loop.
-	**
-	** The unformatted node must be dirtied later on.  We can't be
-	** sure here if the entire tail has been deleted yet.
-        **
-        ** p_s_un_bh is from the page cache (all unformatted nodes are
-        ** from the page cache) and might be a highmem page.  So, we
-        ** can't use p_s_un_bh->b_data.
-	** -clm
-	*/
-
-        data = kmap_atomic(p_s_un_bh->b_page, KM_USER0);
-	off = ((le_ih_k_offset (&s_ih) - 1) & (PAGE_CACHE_SIZE - 1));
-	memcpy(data + off,
-	       B_I_PITEM(PATH_PLAST_BUFFER(p_s_path), &s_ih), n_ret_value);
-	kunmap_atomic(data, KM_USER0);
-    }
-    /* Perform balancing after all resources have been collected at once. */ 
-    do_balance(&s_del_balance, NULL, NULL, M_DELETE);
+	/* Perform balancing after all resources have been collected at once. */
+	do_balance(&s_del_balance, NULL, NULL, M_DELETE);
 
 #ifdef REISERQUOTA_DEBUG
-    reiserfs_debug (p_s_sb, REISERFS_DEBUG_CODE, "reiserquota delete_item(): freeing %u, id=%u type=%c", quota_cut_bytes, p_s_inode->i_uid, head2type(&s_ih));
+	reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE,
+		       "reiserquota delete_item(): freeing %u, id=%u type=%c",
+		       quota_cut_bytes, p_s_inode->i_uid, head2type(&s_ih));
 #endif
-    DQUOT_FREE_SPACE_NODIRTY(p_s_inode, quota_cut_bytes);
+	DQUOT_FREE_SPACE_NODIRTY(p_s_inode, quota_cut_bytes);
 
-    /* Return deleted body length */
-    return n_ret_value;
+	/* Return deleted body length */
+	return n_ret_value;
 }
 
-
 /* Summary Of Mechanisms For Handling Collisions Between Processes:
 
  deletion of the body of the object is performed by iput(), with the
@@ -1347,727 +1387,804 @@ int reiserfs_delete_item (struct reiserfs_transaction_handle *th,
  - Hans
 */
 
-
 /* this deletes item which never gets split */
-void reiserfs_delete_solid_item (struct reiserfs_transaction_handle *th,
-				 struct inode *inode,
-				 struct reiserfs_key * key)
+void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,
+				struct inode *inode, struct reiserfs_key *key)
 {
-    struct tree_balance tb;
-    INITIALIZE_PATH (path);
-    int item_len = 0;
-    int tb_init = 0 ;
-    struct cpu_key cpu_key;
-    int retval;
-    int quota_cut_bytes = 0;
-
-    BUG_ON (!th->t_trans_id);
-    
-    le_key2cpu_key (&cpu_key, key);
-    
-    while (1) {
-	retval = search_item (th->t_super, &cpu_key, &path);
-	if (retval == IO_ERROR) {
-	    reiserfs_warning (th->t_super,
-			      "vs-5350: reiserfs_delete_solid_item: "
-			      "i/o failure occurred trying to delete %K",
-			      &cpu_key);
-	    break;
-	}
-	if (retval != ITEM_FOUND) {
-	    pathrelse (&path);
-	    // No need for a warning, if there is just no free space to insert '..' item into the newly-created subdir
-	    if ( !( (unsigned long long) GET_HASH_VALUE (le_key_k_offset (le_key_version (key), key)) == 0 && \
-		 (unsigned long long) GET_GENERATION_NUMBER (le_key_k_offset (le_key_version (key), key)) == 1 ) )
-		reiserfs_warning (th->t_super, "vs-5355: reiserfs_delete_solid_item: %k not found", key);
-	    break;
-	}
-	if (!tb_init) {
-	    tb_init = 1 ;
-	    item_len = ih_item_len( PATH_PITEM_HEAD(&path) );
-	    init_tb_struct (th, &tb, th->t_super, &path, - (IH_SIZE + item_len));
-	}
-	quota_cut_bytes = ih_item_len(PATH_PITEM_HEAD(&path)) ;
+	struct tree_balance tb;
+	INITIALIZE_PATH(path);
+	int item_len = 0;
+	int tb_init = 0;
+	struct cpu_key cpu_key;
+	int retval;
+	int quota_cut_bytes = 0;
+
+	BUG_ON(!th->t_trans_id);
+
+	le_key2cpu_key(&cpu_key, key);
+
+	while (1) {
+		retval = search_item(th->t_super, &cpu_key, &path);
+		if (retval == IO_ERROR) {
+			reiserfs_warning(th->t_super,
+					 "vs-5350: reiserfs_delete_solid_item: "
+					 "i/o failure occurred trying to delete %K",
+					 &cpu_key);
+			break;
+		}
+		if (retval != ITEM_FOUND) {
+			pathrelse(&path);
+			// No need for a warning, if there is just no free space to insert '..' item into the newly-created subdir
+			if (!
+			    ((unsigned long long)
+			     GET_HASH_VALUE(le_key_k_offset
+					    (le_key_version(key), key)) == 0
+			     && (unsigned long long)
+			     GET_GENERATION_NUMBER(le_key_k_offset
+						   (le_key_version(key),
+						    key)) == 1))
+				reiserfs_warning(th->t_super,
+						 "vs-5355: reiserfs_delete_solid_item: %k not found",
+						 key);
+			break;
+		}
+		if (!tb_init) {
+			tb_init = 1;
+			item_len = ih_item_len(PATH_PITEM_HEAD(&path));
+			init_tb_struct(th, &tb, th->t_super, &path,
+				       -(IH_SIZE + item_len));
+		}
+		quota_cut_bytes = ih_item_len(PATH_PITEM_HEAD(&path));
 
-	retval = fix_nodes (M_DELETE, &tb, NULL, NULL);
-	if (retval == REPEAT_SEARCH) {
-	    PROC_INFO_INC( th -> t_super, delete_solid_item_restarted );
-	    continue;
-	}
+		retval = fix_nodes(M_DELETE, &tb, NULL, NULL);
+		if (retval == REPEAT_SEARCH) {
+			PROC_INFO_INC(th->t_super, delete_solid_item_restarted);
+			continue;
+		}
 
-	if (retval == CARRY_ON) {
-	    do_balance (&tb, NULL, NULL, M_DELETE);
-	    if (inode) {	/* Should we count quota for item? (we don't count quotas for save-links) */
+		if (retval == CARRY_ON) {
+			do_balance(&tb, NULL, NULL, M_DELETE);
+			if (inode) {	/* Should we count quota for item? (we don't count quotas for save-links) */
 #ifdef REISERQUOTA_DEBUG
-		reiserfs_debug (th->t_super, REISERFS_DEBUG_CODE, "reiserquota delete_solid_item(): freeing %u id=%u type=%c", quota_cut_bytes, inode->i_uid, key2type(key));
+				reiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,
+					       "reiserquota delete_solid_item(): freeing %u id=%u type=%c",
+					       quota_cut_bytes, inode->i_uid,
+					       key2type(key));
 #endif
-		DQUOT_FREE_SPACE_NODIRTY(inode, quota_cut_bytes);
-	    }
-	    break;
+				DQUOT_FREE_SPACE_NODIRTY(inode,
+							 quota_cut_bytes);
+			}
+			break;
+		}
+		// IO_ERROR, NO_DISK_SPACE, etc
+		reiserfs_warning(th->t_super,
+				 "vs-5360: reiserfs_delete_solid_item: "
+				 "could not delete %K due to fix_nodes failure",
+				 &cpu_key);
+		unfix_nodes(&tb);
+		break;
 	}
 
-	// IO_ERROR, NO_DISK_SPACE, etc
-	reiserfs_warning (th->t_super, "vs-5360: reiserfs_delete_solid_item: "
-			  "could not delete %K due to fix_nodes failure", &cpu_key);
-	unfix_nodes (&tb);
-	break;
-    }
-
-    reiserfs_check_path(&path) ;
+	reiserfs_check_path(&path);
 }
 
-
-int reiserfs_delete_object (struct reiserfs_transaction_handle *th, struct inode * inode)
+int reiserfs_delete_object(struct reiserfs_transaction_handle *th,
+			   struct inode *inode)
 {
-    int err;
-    inode->i_size = 0;
-    BUG_ON (!th->t_trans_id);
-
-    /* for directory this deletes item containing "." and ".." */
-    err = reiserfs_do_truncate (th, inode, NULL, 0/*no timestamp updates*/);
-    if (err)
-        return err;
-    
+	int err;
+	inode->i_size = 0;
+	BUG_ON(!th->t_trans_id);
+
+	/* for directory this deletes item containing "." and ".." */
+	err =
+	    reiserfs_do_truncate(th, inode, NULL, 0 /*no timestamp updates */ );
+	if (err)
+		return err;
+
 #if defined( USE_INODE_GENERATION_COUNTER )
-    if( !old_format_only ( th -> t_super ) )
-      {
-       __le32 *inode_generation;
-       
-       inode_generation = 
-         &REISERFS_SB(th -> t_super) -> s_rs -> s_inode_generation;
-       *inode_generation = cpu_to_le32( le32_to_cpu( *inode_generation ) + 1 );
-      }
+	if (!old_format_only(th->t_super)) {
+		__le32 *inode_generation;
+
+		inode_generation =
+		    &REISERFS_SB(th->t_super)->s_rs->s_inode_generation;
+		*inode_generation =
+		    cpu_to_le32(le32_to_cpu(*inode_generation) + 1);
+	}
 /* USE_INODE_GENERATION_COUNTER */
 #endif
-    reiserfs_delete_solid_item (th, inode, INODE_PKEY (inode));
+	reiserfs_delete_solid_item(th, inode, INODE_PKEY(inode));
 
-    return err;
+	return err;
 }
 
-static void
-unmap_buffers(struct page *page, loff_t pos) {
-    struct buffer_head *bh ;
-    struct buffer_head *head ;
-    struct buffer_head *next ;
-    unsigned long tail_index ;
-    unsigned long cur_index ;
-
-    if (page) {
-	if (page_has_buffers(page)) {
-	    tail_index = pos & (PAGE_CACHE_SIZE - 1) ;
-	    cur_index = 0 ;
-	    head = page_buffers(page) ;
-	    bh = head ;
-	    do {
-		next = bh->b_this_page ;
-
-		/* we want to unmap the buffers that contain the tail, and
-		** all the buffers after it (since the tail must be at the
-		** end of the file).  We don't want to unmap file data
-		** before the tail, since it might be dirty and waiting to
-		** reach disk
-		*/
-		cur_index += bh->b_size ;
-		if (cur_index > tail_index) {
-		    reiserfs_unmap_buffer(bh) ;
+static void unmap_buffers(struct page *page, loff_t pos)
+{
+	struct buffer_head *bh;
+	struct buffer_head *head;
+	struct buffer_head *next;
+	unsigned long tail_index;
+	unsigned long cur_index;
+
+	if (page) {
+		if (page_has_buffers(page)) {
+			tail_index = pos & (PAGE_CACHE_SIZE - 1);
+			cur_index = 0;
+			head = page_buffers(page);
+			bh = head;
+			do {
+				next = bh->b_this_page;
+
+				/* we want to unmap the buffers that contain the tail, and
+				 ** all the buffers after it (since the tail must be at the
+				 ** end of the file).  We don't want to unmap file data
+				 ** before the tail, since it might be dirty and waiting to
+				 ** reach disk
+				 */
+				cur_index += bh->b_size;
+				if (cur_index > tail_index) {
+					reiserfs_unmap_buffer(bh);
+				}
+				bh = next;
+			} while (bh != head);
+			if (PAGE_SIZE == bh->b_size) {
+				clear_page_dirty(page);
+			}
 		}
-		bh = next ;
-	    } while (bh != head) ;
-	    if ( PAGE_SIZE == bh->b_size ) {
-		clear_page_dirty(page);
-	    }
 	}
-    }
 }
 
-static int maybe_indirect_to_direct (struct reiserfs_transaction_handle *th, 
-			      struct inode * p_s_inode,
-			      struct page *page, 
-			      struct path         * p_s_path,
-			      const struct cpu_key      * p_s_item_key,
-			      loff_t         n_new_file_size,
-			      char                * p_c_mode
-			      ) {
-    struct super_block * p_s_sb = p_s_inode->i_sb;
-    int n_block_size = p_s_sb->s_blocksize;
-    int cut_bytes;
-    BUG_ON (!th->t_trans_id);
-
-    if (n_new_file_size != p_s_inode->i_size)
-	BUG ();
-
-    /* the page being sent in could be NULL if there was an i/o error
-    ** reading in the last block.  The user will hit problems trying to
-    ** read the file, but for now we just skip the indirect2direct
-    */
-    if (atomic_read(&p_s_inode->i_count) > 1 || 
-        !tail_has_to_be_packed (p_s_inode) || 
-	!page || (REISERFS_I(p_s_inode)->i_flags & i_nopack_mask)) {
-	// leave tail in an unformatted node	
-	*p_c_mode = M_SKIP_BALANCING;
-	cut_bytes = n_block_size - (n_new_file_size & (n_block_size - 1));
-	pathrelse(p_s_path);
-	return cut_bytes;
-    }
-    /* Permorm the conversion to a direct_item. */
-    /*return indirect_to_direct (p_s_inode, p_s_path, p_s_item_key, n_new_file_size, p_c_mode);*/
-    return indirect2direct (th, p_s_inode, page, p_s_path, p_s_item_key, n_new_file_size, p_c_mode);
-}
+static int maybe_indirect_to_direct(struct reiserfs_transaction_handle *th,
+				    struct inode *p_s_inode,
+				    struct page *page,
+				    struct path *p_s_path,
+				    const struct cpu_key *p_s_item_key,
+				    loff_t n_new_file_size, char *p_c_mode)
+{
+	struct super_block *p_s_sb = p_s_inode->i_sb;
+	int n_block_size = p_s_sb->s_blocksize;
+	int cut_bytes;
+	BUG_ON(!th->t_trans_id);
+
+	if (n_new_file_size != p_s_inode->i_size)
+		BUG();
 
+	/* the page being sent in could be NULL if there was an i/o error
+	 ** reading in the last block.  The user will hit problems trying to
+	 ** read the file, but for now we just skip the indirect2direct
+	 */
+	if (atomic_read(&p_s_inode->i_count) > 1 ||
+	    !tail_has_to_be_packed(p_s_inode) ||
+	    !page || (REISERFS_I(p_s_inode)->i_flags & i_nopack_mask)) {
+		// leave tail in an unformatted node    
+		*p_c_mode = M_SKIP_BALANCING;
+		cut_bytes =
+		    n_block_size - (n_new_file_size & (n_block_size - 1));
+		pathrelse(p_s_path);
+		return cut_bytes;
+	}
+	/* Permorm the conversion to a direct_item. */
+	/*return indirect_to_direct (p_s_inode, p_s_path, p_s_item_key, n_new_file_size, p_c_mode); */
+	return indirect2direct(th, p_s_inode, page, p_s_path, p_s_item_key,
+			       n_new_file_size, p_c_mode);
+}
 
 /* we did indirect_to_direct conversion. And we have inserted direct
    item successesfully, but there were no disk space to cut unfm
    pointer being converted. Therefore we have to delete inserted
    direct item(s) */
-static void indirect_to_direct_roll_back (struct reiserfs_transaction_handle *th, struct inode * inode, struct path * path)
+static void indirect_to_direct_roll_back(struct reiserfs_transaction_handle *th,
+					 struct inode *inode, struct path *path)
 {
-    struct cpu_key tail_key;
-    int tail_len;
-    int removed;
-    BUG_ON (!th->t_trans_id);
-
-    make_cpu_key (&tail_key, inode, inode->i_size + 1, TYPE_DIRECT, 4);// !!!!
-    tail_key.key_length = 4;
-
-    tail_len = (cpu_key_k_offset (&tail_key) & (inode->i_sb->s_blocksize - 1)) - 1;
-    while (tail_len) {
-	/* look for the last byte of the tail */
-	if (search_for_position_by_key (inode->i_sb, &tail_key, path) == POSITION_NOT_FOUND)
-	    reiserfs_panic (inode->i_sb, "vs-5615: indirect_to_direct_roll_back: found invalid item");
-	RFALSE( path->pos_in_item != ih_item_len(PATH_PITEM_HEAD (path)) - 1,
-	        "vs-5616: appended bytes found");
-	PATH_LAST_POSITION (path) --;
-	
-	removed = reiserfs_delete_item (th, path, &tail_key, inode, NULL/*unbh not needed*/);
-	RFALSE( removed <= 0 || removed > tail_len,
-	        "vs-5617: there was tail %d bytes, removed item length %d bytes",
-                tail_len, removed);
-	tail_len -= removed;
-	set_cpu_key_k_offset (&tail_key, cpu_key_k_offset (&tail_key) - removed);
-    }
-    reiserfs_warning (inode->i_sb, "indirect_to_direct_roll_back: indirect_to_direct conversion has been rolled back due to lack of disk space");
-    //mark_file_without_tail (inode);
-    mark_inode_dirty (inode);
+	struct cpu_key tail_key;
+	int tail_len;
+	int removed;
+	BUG_ON(!th->t_trans_id);
+
+	make_cpu_key(&tail_key, inode, inode->i_size + 1, TYPE_DIRECT, 4);	// !!!!
+	tail_key.key_length = 4;
+
+	tail_len =
+	    (cpu_key_k_offset(&tail_key) & (inode->i_sb->s_blocksize - 1)) - 1;
+	while (tail_len) {
+		/* look for the last byte of the tail */
+		if (search_for_position_by_key(inode->i_sb, &tail_key, path) ==
+		    POSITION_NOT_FOUND)
+			reiserfs_panic(inode->i_sb,
+				       "vs-5615: indirect_to_direct_roll_back: found invalid item");
+		RFALSE(path->pos_in_item !=
+		       ih_item_len(PATH_PITEM_HEAD(path)) - 1,
+		       "vs-5616: appended bytes found");
+		PATH_LAST_POSITION(path)--;
+
+		removed =
+		    reiserfs_delete_item(th, path, &tail_key, inode,
+					 NULL /*unbh not needed */ );
+		RFALSE(removed <= 0
+		       || removed > tail_len,
+		       "vs-5617: there was tail %d bytes, removed item length %d bytes",
+		       tail_len, removed);
+		tail_len -= removed;
+		set_cpu_key_k_offset(&tail_key,
+				     cpu_key_k_offset(&tail_key) - removed);
+	}
+	reiserfs_warning(inode->i_sb,
+			 "indirect_to_direct_roll_back: indirect_to_direct conversion has been rolled back due to lack of disk space");
+	//mark_file_without_tail (inode);
+	mark_inode_dirty(inode);
 }
 
-
 /* (Truncate or cut entry) or delete object item. Returns < 0 on failure */
-int reiserfs_cut_from_item (struct reiserfs_transaction_handle *th, 
-			    struct path * p_s_path,
-			    struct cpu_key * p_s_item_key,
-			    struct inode * p_s_inode,
-			    struct page *page, 
-			    loff_t n_new_file_size)
+int reiserfs_cut_from_item(struct reiserfs_transaction_handle *th,
+			   struct path *p_s_path,
+			   struct cpu_key *p_s_item_key,
+			   struct inode *p_s_inode,
+			   struct page *page, loff_t n_new_file_size)
 {
-    struct super_block * p_s_sb = p_s_inode->i_sb;
-    /* Every function which is going to call do_balance must first
-       create a tree_balance structure.  Then it must fill up this
-       structure by using the init_tb_struct and fix_nodes functions.
-       After that we can make tree balancing. */
-    struct tree_balance s_cut_balance;
-    struct item_head *p_le_ih;
-    int n_cut_size = 0,        /* Amount to be cut. */
-	n_ret_value = CARRY_ON,
-	n_removed = 0,     /* Number of the removed unformatted nodes. */
-	n_is_inode_locked = 0;
-    char                c_mode;            /* Mode of the balance. */
-    int retval2 = -1;
-    int quota_cut_bytes;
-    loff_t tail_pos = 0;
-
-    BUG_ON (!th->t_trans_id);
-    
-    init_tb_struct(th, &s_cut_balance, p_s_inode->i_sb, p_s_path, n_cut_size);
-
-
-    /* Repeat this loop until we either cut the item without needing
-       to balance, or we fix_nodes without schedule occurring */
-    while ( 1 ) {
-	/* Determine the balance mode, position of the first byte to
-	   be cut, and size to be cut.  In case of the indirect item
-	   free unformatted nodes which are pointed to by the cut
-	   pointers. */
-      
-	c_mode = prepare_for_delete_or_cut(th, p_s_inode, p_s_path, p_s_item_key, &n_removed, 
-					   &n_cut_size, n_new_file_size);
-	if ( c_mode == M_CONVERT )  {
-	    /* convert last unformatted node to direct item or leave
-               tail in the unformatted node */
-	    RFALSE( n_ret_value != CARRY_ON, "PAP-5570: can not convert twice");
-
-	    n_ret_value = maybe_indirect_to_direct (th, p_s_inode, page, p_s_path, p_s_item_key,
-						    n_new_file_size, &c_mode);
-	    if ( c_mode == M_SKIP_BALANCING )
-		/* tail has been left in the unformatted node */
-		return n_ret_value;
-
-	    n_is_inode_locked = 1;
-	  
-	    /* removing of last unformatted node will change value we
-               have to return to truncate. Save it */
-	    retval2 = n_ret_value;
-	    /*retval2 = p_s_sb->s_blocksize - (n_new_file_size & (p_s_sb->s_blocksize - 1));*/
-	  
-	    /* So, we have performed the first part of the conversion:
-	       inserting the new direct item.  Now we are removing the
-	       last unformatted node pointer. Set key to search for
-	       it. */
-      	    set_cpu_key_k_type (p_s_item_key, TYPE_INDIRECT);
-	    p_s_item_key->key_length = 4;
-	    n_new_file_size -= (n_new_file_size & (p_s_sb->s_blocksize - 1));
-	    tail_pos = n_new_file_size;
-	    set_cpu_key_k_offset (p_s_item_key, n_new_file_size + 1);
-	    if ( search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path) == POSITION_NOT_FOUND ){
-		print_block (PATH_PLAST_BUFFER (p_s_path), 3, PATH_LAST_POSITION (p_s_path) - 1, PATH_LAST_POSITION (p_s_path) + 1);
-		reiserfs_panic(p_s_sb, "PAP-5580: reiserfs_cut_from_item: item to convert does not exist (%K)", p_s_item_key);
-	    }
-	    continue;
-	}
-	if (n_cut_size == 0) {
-	    pathrelse (p_s_path);
-	    return 0;
-	}
+	struct super_block *p_s_sb = p_s_inode->i_sb;
+	/* Every function which is going to call do_balance must first
+	   create a tree_balance structure.  Then it must fill up this
+	   structure by using the init_tb_struct and fix_nodes functions.
+	   After that we can make tree balancing. */
+	struct tree_balance s_cut_balance;
+	struct item_head *p_le_ih;
+	int n_cut_size = 0,	/* Amount to be cut. */
+	    n_ret_value = CARRY_ON, n_removed = 0,	/* Number of the removed unformatted nodes. */
+	    n_is_inode_locked = 0;
+	char c_mode;		/* Mode of the balance. */
+	int retval2 = -1;
+	int quota_cut_bytes;
+	loff_t tail_pos = 0;
+
+	BUG_ON(!th->t_trans_id);
+
+	init_tb_struct(th, &s_cut_balance, p_s_inode->i_sb, p_s_path,
+		       n_cut_size);
+
+	/* Repeat this loop until we either cut the item without needing
+	   to balance, or we fix_nodes without schedule occurring */
+	while (1) {
+		/* Determine the balance mode, position of the first byte to
+		   be cut, and size to be cut.  In case of the indirect item
+		   free unformatted nodes which are pointed to by the cut
+		   pointers. */
+
+		c_mode =
+		    prepare_for_delete_or_cut(th, p_s_inode, p_s_path,
+					      p_s_item_key, &n_removed,
+					      &n_cut_size, n_new_file_size);
+		if (c_mode == M_CONVERT) {
+			/* convert last unformatted node to direct item or leave
+			   tail in the unformatted node */
+			RFALSE(n_ret_value != CARRY_ON,
+			       "PAP-5570: can not convert twice");
+
+			n_ret_value =
+			    maybe_indirect_to_direct(th, p_s_inode, page,
+						     p_s_path, p_s_item_key,
+						     n_new_file_size, &c_mode);
+			if (c_mode == M_SKIP_BALANCING)
+				/* tail has been left in the unformatted node */
+				return n_ret_value;
+
+			n_is_inode_locked = 1;
+
+			/* removing of last unformatted node will change value we
+			   have to return to truncate. Save it */
+			retval2 = n_ret_value;
+			/*retval2 = p_s_sb->s_blocksize - (n_new_file_size & (p_s_sb->s_blocksize - 1)); */
+
+			/* So, we have performed the first part of the conversion:
+			   inserting the new direct item.  Now we are removing the
+			   last unformatted node pointer. Set key to search for
+			   it. */
+			set_cpu_key_k_type(p_s_item_key, TYPE_INDIRECT);
+			p_s_item_key->key_length = 4;
+			n_new_file_size -=
+			    (n_new_file_size & (p_s_sb->s_blocksize - 1));
+			tail_pos = n_new_file_size;
+			set_cpu_key_k_offset(p_s_item_key, n_new_file_size + 1);
+			if (search_for_position_by_key
+			    (p_s_sb, p_s_item_key,
+			     p_s_path) == POSITION_NOT_FOUND) {
+				print_block(PATH_PLAST_BUFFER(p_s_path), 3,
+					    PATH_LAST_POSITION(p_s_path) - 1,
+					    PATH_LAST_POSITION(p_s_path) + 1);
+				reiserfs_panic(p_s_sb,
+					       "PAP-5580: reiserfs_cut_from_item: item to convert does not exist (%K)",
+					       p_s_item_key);
+			}
+			continue;
+		}
+		if (n_cut_size == 0) {
+			pathrelse(p_s_path);
+			return 0;
+		}
+
+		s_cut_balance.insert_size[0] = n_cut_size;
+
+		n_ret_value = fix_nodes(c_mode, &s_cut_balance, NULL, NULL);
+		if (n_ret_value != REPEAT_SEARCH)
+			break;
+
+		PROC_INFO_INC(p_s_sb, cut_from_item_restarted);
+
+		n_ret_value =
+		    search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path);
+		if (n_ret_value == POSITION_FOUND)
+			continue;
 
-	s_cut_balance.insert_size[0] = n_cut_size;
-	
-	n_ret_value = fix_nodes(c_mode, &s_cut_balance, NULL, NULL);
-      	if ( n_ret_value != REPEAT_SEARCH )
-	    break;
-	
-	PROC_INFO_INC( p_s_sb, cut_from_item_restarted );
-
-	n_ret_value = search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path);
-	if (n_ret_value == POSITION_FOUND)
-	    continue;
-
-	reiserfs_warning (p_s_sb, "PAP-5610: reiserfs_cut_from_item: item %K not found", p_s_item_key);
-	unfix_nodes (&s_cut_balance);
-	return (n_ret_value == IO_ERROR) ? -EIO : -ENOENT;
-    } /* while */
-  
-    // check fix_nodes results (IO_ERROR or NO_DISK_SPACE)
-    if ( n_ret_value != CARRY_ON ) {
-	if ( n_is_inode_locked ) {
-	    // FIXME: this seems to be not needed: we are always able
-	    // to cut item
-	    indirect_to_direct_roll_back (th, p_s_inode, p_s_path);
+		reiserfs_warning(p_s_sb,
+				 "PAP-5610: reiserfs_cut_from_item: item %K not found",
+				 p_s_item_key);
+		unfix_nodes(&s_cut_balance);
+		return (n_ret_value == IO_ERROR) ? -EIO : -ENOENT;
+	}			/* while */
+
+	// check fix_nodes results (IO_ERROR or NO_DISK_SPACE)
+	if (n_ret_value != CARRY_ON) {
+		if (n_is_inode_locked) {
+			// FIXME: this seems to be not needed: we are always able
+			// to cut item
+			indirect_to_direct_roll_back(th, p_s_inode, p_s_path);
+		}
+		if (n_ret_value == NO_DISK_SPACE)
+			reiserfs_warning(p_s_sb, "NO_DISK_SPACE");
+		unfix_nodes(&s_cut_balance);
+		return -EIO;
 	}
-	if (n_ret_value == NO_DISK_SPACE)
-	    reiserfs_warning (p_s_sb, "NO_DISK_SPACE");
-	unfix_nodes (&s_cut_balance);
-	return -EIO;
-    }
-
-    /* go ahead and perform balancing */
-    
-    RFALSE( c_mode == M_PASTE || c_mode == M_INSERT, "invalid mode");
-
-    /* Calculate number of bytes that need to be cut from the item. */
-    quota_cut_bytes = ( c_mode == M_DELETE ) ? ih_item_len(get_ih(p_s_path)) : -s_cut_balance.insert_size[0];
-    if (retval2 == -1)
-	n_ret_value = calc_deleted_bytes_number(&s_cut_balance, c_mode);
-    else
-	n_ret_value = retval2;
-
-
-    /* For direct items, we only change the quota when deleting the last
-    ** item.
-    */
-    p_le_ih = PATH_PITEM_HEAD (s_cut_balance.tb_path);
-    if (!S_ISLNK (p_s_inode->i_mode) && is_direct_le_ih(p_le_ih)) {
-        if (c_mode == M_DELETE &&
-	   (le_ih_k_offset (p_le_ih) & (p_s_sb->s_blocksize - 1)) == 1 ) {
-	    // FIXME: this is to keep 3.5 happy
-	    REISERFS_I(p_s_inode)->i_first_direct_byte = U32_MAX;
-	    quota_cut_bytes = p_s_sb->s_blocksize + UNFM_P_SIZE ;
-        } else {
-	    quota_cut_bytes = 0 ;
+
+	/* go ahead and perform balancing */
+
+	RFALSE(c_mode == M_PASTE || c_mode == M_INSERT, "invalid mode");
+
+	/* Calculate number of bytes that need to be cut from the item. */
+	quota_cut_bytes =
+	    (c_mode ==
+	     M_DELETE) ? ih_item_len(get_ih(p_s_path)) : -s_cut_balance.
+	    insert_size[0];
+	if (retval2 == -1)
+		n_ret_value = calc_deleted_bytes_number(&s_cut_balance, c_mode);
+	else
+		n_ret_value = retval2;
+
+	/* For direct items, we only change the quota when deleting the last
+	 ** item.
+	 */
+	p_le_ih = PATH_PITEM_HEAD(s_cut_balance.tb_path);
+	if (!S_ISLNK(p_s_inode->i_mode) && is_direct_le_ih(p_le_ih)) {
+		if (c_mode == M_DELETE &&
+		    (le_ih_k_offset(p_le_ih) & (p_s_sb->s_blocksize - 1)) ==
+		    1) {
+			// FIXME: this is to keep 3.5 happy
+			REISERFS_I(p_s_inode)->i_first_direct_byte = U32_MAX;
+			quota_cut_bytes = p_s_sb->s_blocksize + UNFM_P_SIZE;
+		} else {
+			quota_cut_bytes = 0;
+		}
 	}
-    }
 #ifdef CONFIG_REISERFS_CHECK
-    if (n_is_inode_locked) {
-	struct item_head * le_ih = PATH_PITEM_HEAD (s_cut_balance.tb_path);
-	/* we are going to complete indirect2direct conversion. Make
-           sure, that we exactly remove last unformatted node pointer
-           of the item */
-	if (!is_indirect_le_ih (le_ih))
-	    reiserfs_panic (p_s_sb, "vs-5652: reiserfs_cut_from_item: "
-			    "item must be indirect %h", le_ih);
-
-	if (c_mode == M_DELETE && ih_item_len(le_ih) != UNFM_P_SIZE)
-	    reiserfs_panic (p_s_sb, "vs-5653: reiserfs_cut_from_item: "
-			    "completing indirect2direct conversion indirect item %h "
-			    "being deleted must be of 4 byte long", le_ih);
-
-	if (c_mode == M_CUT && s_cut_balance.insert_size[0] != -UNFM_P_SIZE) {
-	    reiserfs_panic (p_s_sb, "vs-5654: reiserfs_cut_from_item: "
-			    "can not complete indirect2direct conversion of %h (CUT, insert_size==%d)",
-			    le_ih, s_cut_balance.insert_size[0]);
+	if (n_is_inode_locked) {
+		struct item_head *le_ih =
+		    PATH_PITEM_HEAD(s_cut_balance.tb_path);
+		/* we are going to complete indirect2direct conversion. Make
+		   sure, that we exactly remove last unformatted node pointer
+		   of the item */
+		if (!is_indirect_le_ih(le_ih))
+			reiserfs_panic(p_s_sb,
+				       "vs-5652: reiserfs_cut_from_item: "
+				       "item must be indirect %h", le_ih);
+
+		if (c_mode == M_DELETE && ih_item_len(le_ih) != UNFM_P_SIZE)
+			reiserfs_panic(p_s_sb,
+				       "vs-5653: reiserfs_cut_from_item: "
+				       "completing indirect2direct conversion indirect item %h "
+				       "being deleted must be of 4 byte long",
+				       le_ih);
+
+		if (c_mode == M_CUT
+		    && s_cut_balance.insert_size[0] != -UNFM_P_SIZE) {
+			reiserfs_panic(p_s_sb,
+				       "vs-5654: reiserfs_cut_from_item: "
+				       "can not complete indirect2direct conversion of %h (CUT, insert_size==%d)",
+				       le_ih, s_cut_balance.insert_size[0]);
+		}
+		/* it would be useful to make sure, that right neighboring
+		   item is direct item of this file */
 	}
-	/* it would be useful to make sure, that right neighboring
-           item is direct item of this file */
-    }
 #endif
-    
-    do_balance(&s_cut_balance, NULL, NULL, c_mode);
-    if ( n_is_inode_locked ) {
-	/* we've done an indirect->direct conversion.  when the data block
-	** was freed, it was removed from the list of blocks that must
-	** be flushed before the transaction commits, make sure to
-	** unmap and invalidate it
-	*/
-	unmap_buffers(page, tail_pos);
-	REISERFS_I(p_s_inode)->i_flags &= ~i_pack_on_close_mask ;
-    }
+
+	do_balance(&s_cut_balance, NULL, NULL, c_mode);
+	if (n_is_inode_locked) {
+		/* we've done an indirect->direct conversion.  when the data block
+		 ** was freed, it was removed from the list of blocks that must
+		 ** be flushed before the transaction commits, make sure to
+		 ** unmap and invalidate it
+		 */
+		unmap_buffers(page, tail_pos);
+		REISERFS_I(p_s_inode)->i_flags &= ~i_pack_on_close_mask;
+	}
 #ifdef REISERQUOTA_DEBUG
-    reiserfs_debug (p_s_inode->i_sb, REISERFS_DEBUG_CODE, "reiserquota cut_from_item(): freeing %u id=%u type=%c", quota_cut_bytes, p_s_inode->i_uid, '?');
+	reiserfs_debug(p_s_inode->i_sb, REISERFS_DEBUG_CODE,
+		       "reiserquota cut_from_item(): freeing %u id=%u type=%c",
+		       quota_cut_bytes, p_s_inode->i_uid, '?');
 #endif
-    DQUOT_FREE_SPACE_NODIRTY(p_s_inode, quota_cut_bytes);
-    return n_ret_value;
+	DQUOT_FREE_SPACE_NODIRTY(p_s_inode, quota_cut_bytes);
+	return n_ret_value;
 }
 
-static void truncate_directory (struct reiserfs_transaction_handle *th, struct inode * inode)
+static void truncate_directory(struct reiserfs_transaction_handle *th,
+			       struct inode *inode)
 {
-    BUG_ON (!th->t_trans_id);
-    if (inode->i_nlink)
-	reiserfs_warning (inode->i_sb,
-			  "vs-5655: truncate_directory: link count != 0");
-
-    set_le_key_k_offset (KEY_FORMAT_3_5, INODE_PKEY (inode), DOT_OFFSET);
-    set_le_key_k_type (KEY_FORMAT_3_5, INODE_PKEY (inode), TYPE_DIRENTRY);
-    reiserfs_delete_solid_item (th, inode, INODE_PKEY (inode));
-    reiserfs_update_sd(th, inode) ;
-    set_le_key_k_offset (KEY_FORMAT_3_5, INODE_PKEY (inode), SD_OFFSET);
-    set_le_key_k_type (KEY_FORMAT_3_5, INODE_PKEY (inode), TYPE_STAT_DATA);    
+	BUG_ON(!th->t_trans_id);
+	if (inode->i_nlink)
+		reiserfs_warning(inode->i_sb,
+				 "vs-5655: truncate_directory: link count != 0");
+
+	set_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), DOT_OFFSET);
+	set_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_DIRENTRY);
+	reiserfs_delete_solid_item(th, inode, INODE_PKEY(inode));
+	reiserfs_update_sd(th, inode);
+	set_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), SD_OFFSET);
+	set_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_STAT_DATA);
 }
 
+/* Truncate file to the new size. Note, this must be called with a transaction
+   already started */
+int reiserfs_do_truncate(struct reiserfs_transaction_handle *th, struct inode *p_s_inode,	/* ->i_size contains new
+												   size */
+			 struct page *page,	/* up to date for last block */
+			 int update_timestamps	/* when it is called by
+						   file_release to convert
+						   the tail - no timestamps
+						   should be updated */
+    )
+{
+	INITIALIZE_PATH(s_search_path);	/* Path to the current object item. */
+	struct item_head *p_le_ih;	/* Pointer to an item header. */
+	struct cpu_key s_item_key;	/* Key to search for a previous file item. */
+	loff_t n_file_size,	/* Old file size. */
+	 n_new_file_size;	/* New file size. */
+	int n_deleted;		/* Number of deleted or truncated bytes. */
+	int retval;
+	int err = 0;
+
+	BUG_ON(!th->t_trans_id);
+	if (!
+	    (S_ISREG(p_s_inode->i_mode) || S_ISDIR(p_s_inode->i_mode)
+	     || S_ISLNK(p_s_inode->i_mode)))
+		return 0;
+
+	if (S_ISDIR(p_s_inode->i_mode)) {
+		// deletion of directory - no need to update timestamps
+		truncate_directory(th, p_s_inode);
+		return 0;
+	}
 
+	/* Get new file size. */
+	n_new_file_size = p_s_inode->i_size;
 
+	// FIXME: note, that key type is unimportant here
+	make_cpu_key(&s_item_key, p_s_inode, max_reiserfs_offset(p_s_inode),
+		     TYPE_DIRECT, 3);
 
-/* Truncate file to the new size. Note, this must be called with a transaction
-   already started */
-int reiserfs_do_truncate (struct reiserfs_transaction_handle *th,
-			   struct  inode * p_s_inode, /* ->i_size contains new
-                                                         size */
-			   struct page *page, /* up to date for last block */
-			   int update_timestamps  /* when it is called by
-						     file_release to convert
-						     the tail - no timestamps
-						     should be updated */
-    ) {
-    INITIALIZE_PATH (s_search_path);       /* Path to the current object item. */
-    struct item_head    * p_le_ih;         /* Pointer to an item header. */
-    struct cpu_key      s_item_key;     /* Key to search for a previous file item. */
-    loff_t         n_file_size,    /* Old file size. */
-	n_new_file_size;/* New file size. */
-    int                   n_deleted;      /* Number of deleted or truncated bytes. */
-    int retval;
-    int err = 0;
-
-    BUG_ON (!th->t_trans_id);
-    if ( ! (S_ISREG(p_s_inode->i_mode) || S_ISDIR(p_s_inode->i_mode) || S_ISLNK(p_s_inode->i_mode)) )
-	return 0;
+	retval =
+	    search_for_position_by_key(p_s_inode->i_sb, &s_item_key,
+				       &s_search_path);
+	if (retval == IO_ERROR) {
+		reiserfs_warning(p_s_inode->i_sb,
+				 "vs-5657: reiserfs_do_truncate: "
+				 "i/o failure occurred trying to truncate %K",
+				 &s_item_key);
+		err = -EIO;
+		goto out;
+	}
+	if (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {
+		reiserfs_warning(p_s_inode->i_sb,
+				 "PAP-5660: reiserfs_do_truncate: "
+				 "wrong result %d of search for %K", retval,
+				 &s_item_key);
+
+		err = -EIO;
+		goto out;
+	}
 
-    if (S_ISDIR(p_s_inode->i_mode)) {
-	// deletion of directory - no need to update timestamps
-	truncate_directory (th, p_s_inode);
-	return 0;
-    }
-
-    /* Get new file size. */
-    n_new_file_size = p_s_inode->i_size;
-
-    // FIXME: note, that key type is unimportant here
-    make_cpu_key (&s_item_key, p_s_inode, max_reiserfs_offset (p_s_inode), TYPE_DIRECT, 3);
-
-    retval = search_for_position_by_key(p_s_inode->i_sb, &s_item_key, &s_search_path);
-    if (retval == IO_ERROR) {
-	reiserfs_warning (p_s_inode->i_sb, "vs-5657: reiserfs_do_truncate: "
-			  "i/o failure occurred trying to truncate %K", &s_item_key);
-        err = -EIO;
-        goto out;
-    }
-    if (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {
-	reiserfs_warning (p_s_inode->i_sb, "PAP-5660: reiserfs_do_truncate: "
-			  "wrong result %d of search for %K", retval, &s_item_key);
-
-        err = -EIO;
-        goto out;
-    }
-
-    s_search_path.pos_in_item --;
-
-    /* Get real file size (total length of all file items) */
-    p_le_ih = PATH_PITEM_HEAD(&s_search_path);
-    if ( is_statdata_le_ih (p_le_ih) )
-	n_file_size = 0;
-    else {
-	loff_t offset = le_ih_k_offset (p_le_ih);
-	int bytes = op_bytes_number (p_le_ih,p_s_inode->i_sb->s_blocksize);
-
-	/* this may mismatch with real file size: if last direct item
-           had no padding zeros and last unformatted node had no free
-           space, this file would have this file size */
-	n_file_size = offset + bytes - 1;
-    }
-    /*
-     * are we doing a full truncate or delete, if so
-     * kick in the reada code
-     */
-    if (n_new_file_size == 0)
-        s_search_path.reada = PATH_READA | PATH_READA_BACK;
-
-    if ( n_file_size == 0 || n_file_size < n_new_file_size ) {
-	goto update_and_out ;
-    }
-
-    /* Update key to search for the last file item. */
-    set_cpu_key_k_offset (&s_item_key, n_file_size);
-
-    do  {
-	/* Cut or delete file item. */
-	n_deleted = reiserfs_cut_from_item(th, &s_search_path, &s_item_key, p_s_inode,  page, n_new_file_size);
-	if (n_deleted < 0) {
-	    reiserfs_warning (p_s_inode->i_sb, "vs-5665: reiserfs_do_truncate: reiserfs_cut_from_item failed");
-	    reiserfs_check_path(&s_search_path) ;
-	    return 0;
+	s_search_path.pos_in_item--;
+
+	/* Get real file size (total length of all file items) */
+	p_le_ih = PATH_PITEM_HEAD(&s_search_path);
+	if (is_statdata_le_ih(p_le_ih))
+		n_file_size = 0;
+	else {
+		loff_t offset = le_ih_k_offset(p_le_ih);
+		int bytes =
+		    op_bytes_number(p_le_ih, p_s_inode->i_sb->s_blocksize);
+
+		/* this may mismatch with real file size: if last direct item
+		   had no padding zeros and last unformatted node had no free
+		   space, this file would have this file size */
+		n_file_size = offset + bytes - 1;
+	}
+	/*
+	 * are we doing a full truncate or delete, if so
+	 * kick in the reada code
+	 */
+	if (n_new_file_size == 0)
+		s_search_path.reada = PATH_READA | PATH_READA_BACK;
+
+	if (n_file_size == 0 || n_file_size < n_new_file_size) {
+		goto update_and_out;
 	}
 
-	RFALSE( n_deleted > n_file_size,
-		"PAP-5670: reiserfs_cut_from_item: too many bytes deleted: deleted %d, file_size %lu, item_key %K",
-		n_deleted, n_file_size, &s_item_key);
+	/* Update key to search for the last file item. */
+	set_cpu_key_k_offset(&s_item_key, n_file_size);
+
+	do {
+		/* Cut or delete file item. */
+		n_deleted =
+		    reiserfs_cut_from_item(th, &s_search_path, &s_item_key,
+					   p_s_inode, page, n_new_file_size);
+		if (n_deleted < 0) {
+			reiserfs_warning(p_s_inode->i_sb,
+					 "vs-5665: reiserfs_do_truncate: reiserfs_cut_from_item failed");
+			reiserfs_check_path(&s_search_path);
+			return 0;
+		}
 
-	/* Change key to search the last file item. */
-	n_file_size -= n_deleted;
+		RFALSE(n_deleted > n_file_size,
+		       "PAP-5670: reiserfs_cut_from_item: too many bytes deleted: deleted %d, file_size %lu, item_key %K",
+		       n_deleted, n_file_size, &s_item_key);
 
-	set_cpu_key_k_offset (&s_item_key, n_file_size);
+		/* Change key to search the last file item. */
+		n_file_size -= n_deleted;
 
-	/* While there are bytes to truncate and previous file item is presented in the tree. */
+		set_cpu_key_k_offset(&s_item_key, n_file_size);
 
-	/*
-	** This loop could take a really long time, and could log 
-	** many more blocks than a transaction can hold.  So, we do a polite
-	** journal end here, and if the transaction needs ending, we make
-	** sure the file is consistent before ending the current trans
-	** and starting a new one
-	*/
-        if (journal_transaction_should_end(th, th->t_blocks_allocated)) {
-	  int orig_len_alloc = th->t_blocks_allocated ;
-	  decrement_counters_in_path(&s_search_path) ;
-
-	  if (update_timestamps) {
-	      p_s_inode->i_mtime = p_s_inode->i_ctime = CURRENT_TIME_SEC;
-	  } 
-	  reiserfs_update_sd(th, p_s_inode) ;
-
-	  err = journal_end(th, p_s_inode->i_sb, orig_len_alloc) ;
-	  if (err)
-	    goto out;
-	  err = journal_begin (th, p_s_inode->i_sb,
-                               JOURNAL_PER_BALANCE_CNT * 6);
-	  if (err)
-	    goto out;
-	  reiserfs_update_inode_transaction(p_s_inode) ;
+		/* While there are bytes to truncate and previous file item is presented in the tree. */
+
+		/*
+		 ** This loop could take a really long time, and could log 
+		 ** many more blocks than a transaction can hold.  So, we do a polite
+		 ** journal end here, and if the transaction needs ending, we make
+		 ** sure the file is consistent before ending the current trans
+		 ** and starting a new one
+		 */
+		if (journal_transaction_should_end(th, th->t_blocks_allocated)) {
+			int orig_len_alloc = th->t_blocks_allocated;
+			decrement_counters_in_path(&s_search_path);
+
+			if (update_timestamps) {
+				p_s_inode->i_mtime = p_s_inode->i_ctime =
+				    CURRENT_TIME_SEC;
+			}
+			reiserfs_update_sd(th, p_s_inode);
+
+			err = journal_end(th, p_s_inode->i_sb, orig_len_alloc);
+			if (err)
+				goto out;
+			err = journal_begin(th, p_s_inode->i_sb,
+					    JOURNAL_PER_BALANCE_CNT * 6);
+			if (err)
+				goto out;
+			reiserfs_update_inode_transaction(p_s_inode);
+		}
+	} while (n_file_size > ROUND_UP(n_new_file_size) &&
+		 search_for_position_by_key(p_s_inode->i_sb, &s_item_key,
+					    &s_search_path) == POSITION_FOUND);
+
+	RFALSE(n_file_size > ROUND_UP(n_new_file_size),
+	       "PAP-5680: truncate did not finish: new_file_size %Ld, current %Ld, oid %d",
+	       n_new_file_size, n_file_size, s_item_key.on_disk_key.k_objectid);
+
+      update_and_out:
+	if (update_timestamps) {
+		// this is truncate, not file closing
+		p_s_inode->i_mtime = p_s_inode->i_ctime = CURRENT_TIME_SEC;
 	}
-    } while ( n_file_size > ROUND_UP (n_new_file_size) &&
-	      search_for_position_by_key(p_s_inode->i_sb, &s_item_key, &s_search_path) == POSITION_FOUND )  ;
-
-    RFALSE( n_file_size > ROUND_UP (n_new_file_size),
-	    "PAP-5680: truncate did not finish: new_file_size %Ld, current %Ld, oid %d",
-	    n_new_file_size, n_file_size, s_item_key.on_disk_key.k_objectid);
-
-update_and_out:
-    if (update_timestamps) {
-	// this is truncate, not file closing
-	    p_s_inode->i_mtime = p_s_inode->i_ctime = CURRENT_TIME_SEC;
-    }
-    reiserfs_update_sd (th, p_s_inode);
-
-out:
-    pathrelse(&s_search_path) ;
-    return err;
-}
+	reiserfs_update_sd(th, p_s_inode);
 
+      out:
+	pathrelse(&s_search_path);
+	return err;
+}
 
 #ifdef CONFIG_REISERFS_CHECK
 // this makes sure, that we __append__, not overwrite or add holes
-static void check_research_for_paste (struct path * path, 
-				      const struct cpu_key * p_s_key)
+static void check_research_for_paste(struct path *path,
+				     const struct cpu_key *p_s_key)
 {
-    struct item_head * found_ih = get_ih (path);
-    
-    if (is_direct_le_ih (found_ih)) {
-	if (le_ih_k_offset (found_ih) + op_bytes_number (found_ih, get_last_bh (path)->b_size) !=
-	    cpu_key_k_offset (p_s_key) ||
-	    op_bytes_number (found_ih, get_last_bh (path)->b_size) != pos_in_item (path))
-	    reiserfs_panic (NULL, "PAP-5720: check_research_for_paste: "
-			    "found direct item %h or position (%d) does not match to key %K",
-			    found_ih, pos_in_item (path), p_s_key);
-    }
-    if (is_indirect_le_ih (found_ih)) {
-	if (le_ih_k_offset (found_ih) + op_bytes_number (found_ih, get_last_bh (path)->b_size) != cpu_key_k_offset (p_s_key) || 
-	    I_UNFM_NUM (found_ih) != pos_in_item (path) ||
-	    get_ih_free_space (found_ih) != 0)
-	    reiserfs_panic (NULL, "PAP-5730: check_research_for_paste: "
-			    "found indirect item (%h) or position (%d) does not match to key (%K)",
-			    found_ih, pos_in_item (path), p_s_key);
-    }
+	struct item_head *found_ih = get_ih(path);
+
+	if (is_direct_le_ih(found_ih)) {
+		if (le_ih_k_offset(found_ih) +
+		    op_bytes_number(found_ih,
+				    get_last_bh(path)->b_size) !=
+		    cpu_key_k_offset(p_s_key)
+		    || op_bytes_number(found_ih,
+				       get_last_bh(path)->b_size) !=
+		    pos_in_item(path))
+			reiserfs_panic(NULL,
+				       "PAP-5720: check_research_for_paste: "
+				       "found direct item %h or position (%d) does not match to key %K",
+				       found_ih, pos_in_item(path), p_s_key);
+	}
+	if (is_indirect_le_ih(found_ih)) {
+		if (le_ih_k_offset(found_ih) +
+		    op_bytes_number(found_ih,
+				    get_last_bh(path)->b_size) !=
+		    cpu_key_k_offset(p_s_key)
+		    || I_UNFM_NUM(found_ih) != pos_in_item(path)
+		    || get_ih_free_space(found_ih) != 0)
+			reiserfs_panic(NULL,
+				       "PAP-5730: check_research_for_paste: "
+				       "found indirect item (%h) or position (%d) does not match to key (%K)",
+				       found_ih, pos_in_item(path), p_s_key);
+	}
 }
-#endif /* config reiserfs check */
-
+#endif				/* config reiserfs check */
 
 /* Paste bytes to the existing item. Returns bytes number pasted into the item. */
-int reiserfs_paste_into_item (struct reiserfs_transaction_handle *th, 
-			      struct path         * p_s_search_path,	/* Path to the pasted item.          */
-			      const struct cpu_key      * p_s_key,        	/* Key to search for the needed item.*/
-			      struct inode	  * inode,		/* Inode item belongs to */
-			      const char          * p_c_body,       	/* Pointer to the bytes to paste.    */
-			      int                   n_pasted_size)  	/* Size of pasted bytes.             */
-{
-    struct tree_balance s_paste_balance;
-    int                 retval;
-    int			fs_gen;
+int reiserfs_paste_into_item(struct reiserfs_transaction_handle *th, struct path *p_s_search_path,	/* Path to the pasted item.          */
+			     const struct cpu_key *p_s_key,	/* Key to search for the needed item. */
+			     struct inode *inode,	/* Inode item belongs to */
+			     const char *p_c_body,	/* Pointer to the bytes to paste.    */
+			     int n_pasted_size)
+{				/* Size of pasted bytes.             */
+	struct tree_balance s_paste_balance;
+	int retval;
+	int fs_gen;
+
+	BUG_ON(!th->t_trans_id);
 
-    BUG_ON (!th->t_trans_id);
-
-    fs_gen = get_generation(inode->i_sb) ;
+	fs_gen = get_generation(inode->i_sb);
 
 #ifdef REISERQUOTA_DEBUG
-    reiserfs_debug (inode->i_sb, REISERFS_DEBUG_CODE, "reiserquota paste_into_item(): allocating %u id=%u type=%c", n_pasted_size, inode->i_uid, key2type(&(p_s_key->on_disk_key)));
+	reiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,
+		       "reiserquota paste_into_item(): allocating %u id=%u type=%c",
+		       n_pasted_size, inode->i_uid,
+		       key2type(&(p_s_key->on_disk_key)));
 #endif
 
-    if (DQUOT_ALLOC_SPACE_NODIRTY(inode, n_pasted_size)) {
-	pathrelse(p_s_search_path);
-	return -EDQUOT;
-    }
-    init_tb_struct(th, &s_paste_balance, th->t_super, p_s_search_path, n_pasted_size);
+	if (DQUOT_ALLOC_SPACE_NODIRTY(inode, n_pasted_size)) {
+		pathrelse(p_s_search_path);
+		return -EDQUOT;
+	}
+	init_tb_struct(th, &s_paste_balance, th->t_super, p_s_search_path,
+		       n_pasted_size);
 #ifdef DISPLACE_NEW_PACKING_LOCALITIES
-    s_paste_balance.key = p_s_key->on_disk_key;
+	s_paste_balance.key = p_s_key->on_disk_key;
 #endif
 
-    /* DQUOT_* can schedule, must check before the fix_nodes */
-    if (fs_changed(fs_gen, inode->i_sb)) {
-	goto search_again;
-    }
-
-    while ((retval = fix_nodes(M_PASTE, &s_paste_balance, NULL, p_c_body)) ==
-REPEAT_SEARCH ) {
-search_again:
-	/* file system changed while we were in the fix_nodes */
-	PROC_INFO_INC( th -> t_super, paste_into_item_restarted );
-	retval = search_for_position_by_key (th->t_super, p_s_key, p_s_search_path);
-	if (retval == IO_ERROR) {
-	    retval = -EIO ;
-	    goto error_out ;
+	/* DQUOT_* can schedule, must check before the fix_nodes */
+	if (fs_changed(fs_gen, inode->i_sb)) {
+		goto search_again;
 	}
-	if (retval == POSITION_FOUND) {
-	    reiserfs_warning (inode->i_sb, "PAP-5710: reiserfs_paste_into_item: entry or pasted byte (%K) exists", p_s_key);
-	    retval = -EEXIST ;
-	    goto error_out ;
-	}
-	
+
+	while ((retval =
+		fix_nodes(M_PASTE, &s_paste_balance, NULL,
+			  p_c_body)) == REPEAT_SEARCH) {
+	      search_again:
+		/* file system changed while we were in the fix_nodes */
+		PROC_INFO_INC(th->t_super, paste_into_item_restarted);
+		retval =
+		    search_for_position_by_key(th->t_super, p_s_key,
+					       p_s_search_path);
+		if (retval == IO_ERROR) {
+			retval = -EIO;
+			goto error_out;
+		}
+		if (retval == POSITION_FOUND) {
+			reiserfs_warning(inode->i_sb,
+					 "PAP-5710: reiserfs_paste_into_item: entry or pasted byte (%K) exists",
+					 p_s_key);
+			retval = -EEXIST;
+			goto error_out;
+		}
 #ifdef CONFIG_REISERFS_CHECK
-	check_research_for_paste (p_s_search_path, p_s_key);
+		check_research_for_paste(p_s_search_path, p_s_key);
 #endif
-    }
+	}
 
-    /* Perform balancing after all resources are collected by fix_nodes, and
-       accessing them will not risk triggering schedule. */
-    if ( retval == CARRY_ON ) {
-	do_balance(&s_paste_balance, NULL/*ih*/, p_c_body, M_PASTE);
-	return 0;
-    }
-    retval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;
-error_out:
-    /* this also releases the path */
-    unfix_nodes(&s_paste_balance);
+	/* Perform balancing after all resources are collected by fix_nodes, and
+	   accessing them will not risk triggering schedule. */
+	if (retval == CARRY_ON) {
+		do_balance(&s_paste_balance, NULL /*ih */ , p_c_body, M_PASTE);
+		return 0;
+	}
+	retval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;
+      error_out:
+	/* this also releases the path */
+	unfix_nodes(&s_paste_balance);
 #ifdef REISERQUOTA_DEBUG
-    reiserfs_debug (inode->i_sb, REISERFS_DEBUG_CODE, "reiserquota paste_into_item(): freeing %u id=%u type=%c", n_pasted_size, inode->i_uid, key2type(&(p_s_key->on_disk_key)));
+	reiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,
+		       "reiserquota paste_into_item(): freeing %u id=%u type=%c",
+		       n_pasted_size, inode->i_uid,
+		       key2type(&(p_s_key->on_disk_key)));
 #endif
-    DQUOT_FREE_SPACE_NODIRTY(inode, n_pasted_size);
-    return retval ;
+	DQUOT_FREE_SPACE_NODIRTY(inode, n_pasted_size);
+	return retval;
 }
 
-
 /* Insert new item into the buffer at the path. */
-int reiserfs_insert_item(struct reiserfs_transaction_handle *th, 
-			 struct path         * 	p_s_path,         /* Path to the inserteded item.         */
-			 const struct cpu_key      * key,
-			 struct item_head    * 	p_s_ih,           /* Pointer to the item header to insert.*/
-			 struct inode        * inode,
-			 const char          * 	p_c_body)         /* Pointer to the bytes to insert.      */
-{
-    struct tree_balance s_ins_balance;
-    int                 retval;
-    int fs_gen = 0 ;
-    int quota_bytes = 0 ;
-
-    BUG_ON (!th->t_trans_id);
-
-    if (inode) {      /* Do we count quotas for item? */
-	fs_gen = get_generation(inode->i_sb);
-	quota_bytes = ih_item_len(p_s_ih);
-
-	/* hack so the quota code doesn't have to guess if the file has
-	 ** a tail, links are always tails, so there's no guessing needed
-	 */
-	if (!S_ISLNK (inode->i_mode) && is_direct_le_ih(p_s_ih)) {
-	    quota_bytes = inode->i_sb->s_blocksize + UNFM_P_SIZE ;
-	}
+int reiserfs_insert_item(struct reiserfs_transaction_handle *th, struct path *p_s_path,	/* Path to the inserteded item.         */
+			 const struct cpu_key *key, struct item_head *p_s_ih,	/* Pointer to the item header to insert. */
+			 struct inode *inode, const char *p_c_body)
+{				/* Pointer to the bytes to insert.      */
+	struct tree_balance s_ins_balance;
+	int retval;
+	int fs_gen = 0;
+	int quota_bytes = 0;
+
+	BUG_ON(!th->t_trans_id);
+
+	if (inode) {		/* Do we count quotas for item? */
+		fs_gen = get_generation(inode->i_sb);
+		quota_bytes = ih_item_len(p_s_ih);
+
+		/* hack so the quota code doesn't have to guess if the file has
+		 ** a tail, links are always tails, so there's no guessing needed
+		 */
+		if (!S_ISLNK(inode->i_mode) && is_direct_le_ih(p_s_ih)) {
+			quota_bytes = inode->i_sb->s_blocksize + UNFM_P_SIZE;
+		}
 #ifdef REISERQUOTA_DEBUG
-	reiserfs_debug (inode->i_sb, REISERFS_DEBUG_CODE, "reiserquota insert_item(): allocating %u id=%u type=%c", quota_bytes, inode->i_uid, head2type(p_s_ih));
+		reiserfs_debug(inode->i_sb, REISERFS_DEBUG_CODE,
+			       "reiserquota insert_item(): allocating %u id=%u type=%c",
+			       quota_bytes, inode->i_uid, head2type(p_s_ih));
 #endif
-	/* We can't dirty inode here. It would be immediately written but
-	 * appropriate stat item isn't inserted yet... */
-	if (DQUOT_ALLOC_SPACE_NODIRTY(inode, quota_bytes)) {
-	    pathrelse(p_s_path);
-	    return -EDQUOT;
+		/* We can't dirty inode here. It would be immediately written but
+		 * appropriate stat item isn't inserted yet... */
+		if (DQUOT_ALLOC_SPACE_NODIRTY(inode, quota_bytes)) {
+			pathrelse(p_s_path);
+			return -EDQUOT;
+		}
 	}
-    }
-    init_tb_struct(th, &s_ins_balance, th->t_super, p_s_path, IH_SIZE + ih_item_len(p_s_ih));
+	init_tb_struct(th, &s_ins_balance, th->t_super, p_s_path,
+		       IH_SIZE + ih_item_len(p_s_ih));
 #ifdef DISPLACE_NEW_PACKING_LOCALITIES
-    s_ins_balance.key = key->on_disk_key;
+	s_ins_balance.key = key->on_disk_key;
 #endif
-    /* DQUOT_* can schedule, must check to be sure calling fix_nodes is safe */
-    if (inode && fs_changed(fs_gen, inode->i_sb)) {
-	goto search_again;
-    }
-
-    while ( (retval = fix_nodes(M_INSERT, &s_ins_balance, p_s_ih, p_c_body)) == REPEAT_SEARCH) {
-search_again:
-	/* file system changed while we were in the fix_nodes */
-	PROC_INFO_INC( th -> t_super, insert_item_restarted );
-	retval = search_item (th->t_super, key, p_s_path);
-	if (retval == IO_ERROR) {
-	    retval = -EIO;
-	    goto error_out ;
+	/* DQUOT_* can schedule, must check to be sure calling fix_nodes is safe */
+	if (inode && fs_changed(fs_gen, inode->i_sb)) {
+		goto search_again;
 	}
-	if (retval == ITEM_FOUND) {
-	    reiserfs_warning (th->t_super, "PAP-5760: reiserfs_insert_item: "
-			      "key %K already exists in the tree", key);
-	    retval = -EEXIST ;
-	    goto error_out; 
+
+	while ((retval =
+		fix_nodes(M_INSERT, &s_ins_balance, p_s_ih,
+			  p_c_body)) == REPEAT_SEARCH) {
+	      search_again:
+		/* file system changed while we were in the fix_nodes */
+		PROC_INFO_INC(th->t_super, insert_item_restarted);
+		retval = search_item(th->t_super, key, p_s_path);
+		if (retval == IO_ERROR) {
+			retval = -EIO;
+			goto error_out;
+		}
+		if (retval == ITEM_FOUND) {
+			reiserfs_warning(th->t_super,
+					 "PAP-5760: reiserfs_insert_item: "
+					 "key %K already exists in the tree",
+					 key);
+			retval = -EEXIST;
+			goto error_out;
+		}
 	}
-    }
 
-    /* make balancing after all resources will be collected at a time */ 
-    if ( retval == CARRY_ON ) {
-	do_balance (&s_ins_balance, p_s_ih, p_c_body, M_INSERT);
-	return 0;
-    }
+	/* make balancing after all resources will be collected at a time */
+	if (retval == CARRY_ON) {
+		do_balance(&s_ins_balance, p_s_ih, p_c_body, M_INSERT);
+		return 0;
+	}
 
-    retval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;
-error_out:
-    /* also releases the path */
-    unfix_nodes(&s_ins_balance);
+	retval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;
+      error_out:
+	/* also releases the path */
+	unfix_nodes(&s_ins_balance);
 #ifdef REISERQUOTA_DEBUG
-    reiserfs_debug (th->t_super, REISERFS_DEBUG_CODE, "reiserquota insert_item(): freeing %u id=%u type=%c", quota_bytes, inode->i_uid, head2type(p_s_ih));
+	reiserfs_debug(th->t_super, REISERFS_DEBUG_CODE,
+		       "reiserquota insert_item(): freeing %u id=%u type=%c",
+		       quota_bytes, inode->i_uid, head2type(p_s_ih));
 #endif
-    if (inode)
-	DQUOT_FREE_SPACE_NODIRTY(inode, quota_bytes) ;
-    return retval; 
+	if (inode)
+		DQUOT_FREE_SPACE_NODIRTY(inode, quota_bytes);
+	return retval;
 }
-
-
-
-

commit 52c1da39534fb382c061de58b65f678ad74b59f5
Author: Adrian Bunk <bunk@stusta.de>
Date:   Thu Jun 23 22:05:33 2005 -0700

    [PATCH] make various thing static
    
    Another rollup of patches which give various symbols static scope
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index c47f8fd31a2d..63158491e152 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -223,7 +223,7 @@ extern struct tree_balance * cur_tb;
 const struct reiserfs_key  MIN_KEY = {0, 0, {{0, 0},}};
 
 /* Maximal possible key. It is never in the tree. */
-const struct reiserfs_key  MAX_KEY = {
+static const struct reiserfs_key  MAX_KEY = {
 	__constant_cpu_to_le32(0xffffffff),
 	__constant_cpu_to_le32(0xffffffff),
 	{{__constant_cpu_to_le32(0xffffffff),

commit f359b74c80bc76c1f6c2cb8f2837882f2335ba0c
Author: Vladimir Saveliev <vs@namesys.com>
Date:   Sat May 21 16:33:34 2005 -0700

    [PATCH] reiserfs: max_key fix
    
    This patch fixes a bug introduced by Al Viro's patch: [patch 136/174]
    reiserfs endianness: clone struct reiserfs_key
    
    The problem is MAX_KEY and MAX_IN_CORE_KEY defined in this patch do not
    look equal from reiserfs comp_key's point of view.  This caused reiserfs'
    sanity check to complain.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index da23ba75f3d5..c47f8fd31a2d 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -230,7 +230,6 @@ const struct reiserfs_key  MAX_KEY = {
 	__constant_cpu_to_le32(0xffffffff)},}
 };
 
-const struct in_core_key  MAX_IN_CORE_KEY = {~0U, ~0U, ~0ULL>>4, 15};
 
 /* Get delimiting key of the buffer by looking for it in the buffers in the path, starting from the bottom
    of the path, and going upwards.  We must check the path's validity at each step.  If the key is not in

commit 6b9f5829e6e3af44f20c681e26524c637d4f82ff
Author: Al Viro <viro@www.linux.org.uk>
Date:   Sun May 1 08:59:19 2005 -0700

    [PATCH] reiserfs endianness: comp_short_keys() cleanup
    
    comp_short_keys() massaged into sane form, which kills the last place where
    pointer to in_core_key (or any object containing such) would be cast to or
    from something else.  At that point we are free to change layout of
    in_core_key - nothing depends on it anymore.
    
    So we drop the mess with union in there and simply use (unconditional) __u64
    k_offset and __u8 k_type instead; places using in_core_key switched to those.
    That gives _far_ better code than current mess - on all platforms.
    
    Signed-off-by: Al Viro <viro@parcelfarce.linux.theplanet.co.uk>
    Cc: <reiserfs-dev@namesys.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 15fa4cbdce3e..da23ba75f3d5 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -87,23 +87,20 @@ inline void copy_item_head(struct item_head * p_v_to,
 inline int  comp_short_keys (const struct reiserfs_key * le_key,
 			     const struct cpu_key * cpu_key)
 {
-  __le32 * p_s_le_u32;
-  __u32 * p_s_cpu_u32;
-  int n_key_length = REISERFS_SHORT_KEY_LEN;
-
-  p_s_le_u32 = (__le32 *)le_key;
-  p_s_cpu_u32 = (__u32 *)&cpu_key->on_disk_key;
-  for( ; n_key_length--; ++p_s_le_u32, ++p_s_cpu_u32 ) {
-    if ( le32_to_cpu (*p_s_le_u32) < *p_s_cpu_u32 )
+  __u32 n;
+  n = le32_to_cpu(le_key->k_dir_id);
+  if (n < cpu_key->on_disk_key.k_dir_id)
       return -1;
-    if ( le32_to_cpu (*p_s_le_u32) > *p_s_cpu_u32 )
+  if (n > cpu_key->on_disk_key.k_dir_id)
+      return 1;
+  n = le32_to_cpu(le_key->k_objectid);
+  if (n < cpu_key->on_disk_key.k_objectid)
+      return -1;
+  if (n > cpu_key->on_disk_key.k_objectid)
       return 1;
-  }
-
   return 0;
 }
 
-
 /* k1 is pointer to on-disk structure which is stored in little-endian
    form. k2 is pointer to cpu variable.
    Compare keys using all 4 key fields.
@@ -153,18 +150,15 @@ inline int comp_short_le_keys (const struct reiserfs_key * key1, const struct re
 
 inline void le_key2cpu_key (struct cpu_key * to, const struct reiserfs_key * from)
 {
+    int version;
     to->on_disk_key.k_dir_id = le32_to_cpu (from->k_dir_id);
     to->on_disk_key.k_objectid = le32_to_cpu (from->k_objectid);
     
     // find out version of the key
-    to->version = le_key_version (from);
-    if (to->version == KEY_FORMAT_3_5) {
-	to->on_disk_key.u.k_offset_v1.k_offset = le32_to_cpu (from->u.k_offset_v1.k_offset);
-	to->on_disk_key.u.k_offset_v1.k_uniqueness = le32_to_cpu (from->u.k_offset_v1.k_uniqueness);
-    } else {
-	to->on_disk_key.u.k_offset_v2.k_offset = offset_v2_k_offset(&from->u.k_offset_v2);
-	to->on_disk_key.u.k_offset_v2.k_type = offset_v2_k_type(&from->u.k_offset_v2);
-    } 
+    version = le_key_version (from);
+    to->version = version;
+    to->on_disk_key.k_offset = le_key_k_offset(version, from);
+    to->on_disk_key.k_type = le_key_k_type(version, from);
 }
 
 
@@ -235,8 +229,8 @@ const struct reiserfs_key  MAX_KEY = {
 	{{__constant_cpu_to_le32(0xffffffff),
 	__constant_cpu_to_le32(0xffffffff)},}
 };
-const struct in_core_key  MAX_IN_CORE_KEY = {0xffffffff, 0xffffffff, {{0xffffffff, 0xffffffff},}};
 
+const struct in_core_key  MAX_IN_CORE_KEY = {~0U, ~0U, ~0ULL>>4, 15};
 
 /* Get delimiting key of the buffer by looking for it in the buffers in the path, starting from the bottom
    of the path, and going upwards.  We must check the path's validity at each step.  If the key is not in

commit 3e8962be915bacc1d70e4849a075041838d60a3f
Author: Al Viro <viro@www.linux.org.uk>
Date:   Sun May 1 08:59:18 2005 -0700

    [PATCH] reiserfs endianness: annotate little-endian objects
    
    little-endian objects annotated as such; again, obviously no changes of
    resulting code, we only replace __u16 with __le16, etc.  in relevant places.
    
    Signed-off-by: Al Viro <viro@parcelfarce.linux.theplanet.co.uk>
    Cc: <reiserfs-dev@namesys.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 1d380a5da39c..15fa4cbdce3e 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -87,10 +87,11 @@ inline void copy_item_head(struct item_head * p_v_to,
 inline int  comp_short_keys (const struct reiserfs_key * le_key,
 			     const struct cpu_key * cpu_key)
 {
-  __u32 * p_s_le_u32, * p_s_cpu_u32;
+  __le32 * p_s_le_u32;
+  __u32 * p_s_cpu_u32;
   int n_key_length = REISERFS_SHORT_KEY_LEN;
 
-  p_s_le_u32 = (__u32 *)le_key;
+  p_s_le_u32 = (__le32 *)le_key;
   p_s_cpu_u32 = (__u32 *)&cpu_key->on_disk_key;
   for( ; n_key_length--; ++p_s_le_u32, ++p_s_cpu_u32 ) {
     if ( le32_to_cpu (*p_s_le_u32) < *p_s_cpu_u32 )
@@ -228,7 +229,12 @@ extern struct tree_balance * cur_tb;
 const struct reiserfs_key  MIN_KEY = {0, 0, {{0, 0},}};
 
 /* Maximal possible key. It is never in the tree. */
-const struct reiserfs_key  MAX_KEY = {0xffffffff, 0xffffffff, {{0xffffffff, 0xffffffff},}};
+const struct reiserfs_key  MAX_KEY = {
+	__constant_cpu_to_le32(0xffffffff),
+	__constant_cpu_to_le32(0xffffffff),
+	{{__constant_cpu_to_le32(0xffffffff),
+	__constant_cpu_to_le32(0xffffffff)},}
+};
 const struct in_core_key  MAX_IN_CORE_KEY = {0xffffffff, 0xffffffff, {{0xffffffff, 0xffffffff},}};
 
 
@@ -998,7 +1004,7 @@ static char  prepare_for_delete_or_cut(
 	int                   n_unfm_number,    /* Number of the item unformatted nodes. */
 	    n_counter,
 	    n_blk_size;
-	__u32               * p_n_unfm_pointer; /* Pointer to the unformatted node number. */
+	__le32               * p_n_unfm_pointer; /* Pointer to the unformatted node number. */
 	__u32 tmp;
 	struct item_head      s_ih;           /* Item header. */
 	char                  c_mode;           /* Returned mode of the balance. */
@@ -1060,7 +1066,7 @@ static char  prepare_for_delete_or_cut(
 	    /* pointers to be cut */
 	    n_unfm_number -= pos_in_item (p_s_path);
 	    /* Set pointer to the last unformatted node pointer that is to be cut. */
-	    p_n_unfm_pointer = (__u32 *)B_I_PITEM(p_s_bh, &s_ih) + I_UNFM_NUM(&s_ih) - 1 - *p_n_removed;
+	    p_n_unfm_pointer = (__le32 *)B_I_PITEM(p_s_bh, &s_ih) + I_UNFM_NUM(&s_ih) - 1 - *p_n_removed;
 
 
 	    /* We go through the unformatted nodes pointers of the indirect
@@ -1082,8 +1088,8 @@ static char  prepare_for_delete_or_cut(
 		    need_research = 1 ;
 		    break;
 		}
-		RFALSE( p_n_unfm_pointer < (__u32 *)B_I_PITEM(p_s_bh, &s_ih) ||
-			p_n_unfm_pointer > (__u32 *)B_I_PITEM(p_s_bh, &s_ih) + I_UNFM_NUM(&s_ih) - 1,
+		RFALSE( p_n_unfm_pointer < (__le32 *)B_I_PITEM(p_s_bh, &s_ih) ||
+			p_n_unfm_pointer > (__le32 *)B_I_PITEM(p_s_bh, &s_ih) + I_UNFM_NUM(&s_ih) - 1,
 			"vs-5265: pointer out of range");
 
 		/* Hole, nothing to remove. */
@@ -1432,7 +1438,7 @@ int reiserfs_delete_object (struct reiserfs_transaction_handle *th, struct inode
 #if defined( USE_INODE_GENERATION_COUNTER )
     if( !old_format_only ( th -> t_super ) )
       {
-       __u32 *inode_generation;
+       __le32 *inode_generation;
        
        inode_generation = 
          &REISERFS_SB(th -> t_super) -> s_rs -> s_inode_generation;

commit 6a3a16f2ef6f335286e2b2bf8284b0ab4ff38ec0
Author: Al Viro <viro@www.linux.org.uk>
Date:   Sun May 1 08:59:17 2005 -0700

    [PATCH] reiserfs endianness: clone struct reiserfs_key
    
    struct reiserfs_key cloned; (currently) identical struct in_core_key added.
    Places that expect host-endian data in reiserfs_key switched to in_core_key.
    Basically, we get annotation of reiserfs_key users and keep the resulting tree
    obviously equivalent to original.
    
    Signed-off-by: Al Viro <viro@parcelfarce.linux.theplanet.co.uk>
    Cc: <reiserfs-dev@namesys.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index 73ec5212178b..1d380a5da39c 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -229,6 +229,7 @@ const struct reiserfs_key  MIN_KEY = {0, 0, {{0, 0},}};
 
 /* Maximal possible key. It is never in the tree. */
 const struct reiserfs_key  MAX_KEY = {0xffffffff, 0xffffffff, {{0xffffffff, 0xffffffff},}};
+const struct in_core_key  MAX_IN_CORE_KEY = {0xffffffff, 0xffffffff, {{0xffffffff, 0xffffffff},}};
 
 
 /* Get delimiting key of the buffer by looking for it in the buffers in the path, starting from the bottom

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
new file mode 100644
index 000000000000..73ec5212178b
--- /dev/null
+++ b/fs/reiserfs/stree.c
@@ -0,0 +1,2073 @@
+/*
+ *  Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
+ */
+
+/*
+ *  Written by Anatoly P. Pinchuk pap@namesys.botik.ru
+ *  Programm System Institute
+ *  Pereslavl-Zalessky Russia
+ */
+
+/*
+ *  This file contains functions dealing with S+tree
+ *
+ * B_IS_IN_TREE
+ * copy_item_head
+ * comp_short_keys
+ * comp_keys
+ * comp_short_le_keys
+ * le_key2cpu_key
+ * comp_le_keys
+ * bin_search
+ * get_lkey
+ * get_rkey
+ * key_in_buffer
+ * decrement_bcount
+ * decrement_counters_in_path
+ * reiserfs_check_path
+ * pathrelse_and_restore
+ * pathrelse
+ * search_by_key_reada
+ * search_by_key
+ * search_for_position_by_key
+ * comp_items
+ * prepare_for_direct_item
+ * prepare_for_direntry_item
+ * prepare_for_delete_or_cut
+ * calc_deleted_bytes_number
+ * init_tb_struct
+ * padd_item
+ * reiserfs_delete_item
+ * reiserfs_delete_solid_item
+ * reiserfs_delete_object
+ * maybe_indirect_to_direct
+ * indirect_to_direct_roll_back
+ * reiserfs_cut_from_item
+ * truncate_directory
+ * reiserfs_do_truncate
+ * reiserfs_paste_into_item
+ * reiserfs_insert_item
+ */
+
+#include <linux/config.h>
+#include <linux/time.h>
+#include <linux/string.h>
+#include <linux/pagemap.h>
+#include <linux/reiserfs_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/buffer_head.h>
+#include <linux/quotaops.h>
+
+/* Does the buffer contain a disk block which is in the tree. */
+inline int B_IS_IN_TREE (const struct buffer_head * p_s_bh)
+{
+
+  RFALSE( B_LEVEL (p_s_bh) > MAX_HEIGHT,
+	  "PAP-1010: block (%b) has too big level (%z)", p_s_bh, p_s_bh);
+
+  return ( B_LEVEL (p_s_bh) != FREE_LEVEL );
+}
+
+//
+// to gets item head in le form
+//
+inline void copy_item_head(struct item_head * p_v_to, 
+			   const struct item_head * p_v_from)
+{
+  memcpy (p_v_to, p_v_from, IH_SIZE);
+}
+
+
+/* k1 is pointer to on-disk structure which is stored in little-endian
+   form. k2 is pointer to cpu variable. For key of items of the same
+   object this returns 0.
+   Returns: -1 if key1 < key2 
+   0 if key1 == key2
+   1 if key1 > key2 */
+inline int  comp_short_keys (const struct reiserfs_key * le_key,
+			     const struct cpu_key * cpu_key)
+{
+  __u32 * p_s_le_u32, * p_s_cpu_u32;
+  int n_key_length = REISERFS_SHORT_KEY_LEN;
+
+  p_s_le_u32 = (__u32 *)le_key;
+  p_s_cpu_u32 = (__u32 *)&cpu_key->on_disk_key;
+  for( ; n_key_length--; ++p_s_le_u32, ++p_s_cpu_u32 ) {
+    if ( le32_to_cpu (*p_s_le_u32) < *p_s_cpu_u32 )
+      return -1;
+    if ( le32_to_cpu (*p_s_le_u32) > *p_s_cpu_u32 )
+      return 1;
+  }
+
+  return 0;
+}
+
+
+/* k1 is pointer to on-disk structure which is stored in little-endian
+   form. k2 is pointer to cpu variable.
+   Compare keys using all 4 key fields.
+   Returns: -1 if key1 < key2 0
+   if key1 = key2 1 if key1 > key2 */
+static inline int  comp_keys (const struct reiserfs_key * le_key, const struct cpu_key * cpu_key)
+{
+  int retval;
+
+  retval = comp_short_keys (le_key, cpu_key);
+  if (retval)
+      return retval;
+  if (le_key_k_offset (le_key_version(le_key), le_key) < cpu_key_k_offset (cpu_key))
+      return -1;
+  if (le_key_k_offset (le_key_version(le_key), le_key) > cpu_key_k_offset (cpu_key))
+      return 1;
+
+  if (cpu_key->key_length == 3)
+      return 0;
+
+  /* this part is needed only when tail conversion is in progress */
+  if (le_key_k_type (le_key_version(le_key), le_key) < cpu_key_k_type (cpu_key))
+    return -1;
+
+  if (le_key_k_type (le_key_version(le_key), le_key) > cpu_key_k_type (cpu_key))
+    return 1;
+
+  return 0;
+}
+
+
+inline int comp_short_le_keys (const struct reiserfs_key * key1, const struct reiserfs_key * key2)
+{
+  __u32 * p_s_1_u32, * p_s_2_u32;
+  int n_key_length = REISERFS_SHORT_KEY_LEN;
+
+  p_s_1_u32 = (__u32 *)key1;
+  p_s_2_u32 = (__u32 *)key2;
+  for( ; n_key_length--; ++p_s_1_u32, ++p_s_2_u32 ) {
+    if ( le32_to_cpu (*p_s_1_u32) < le32_to_cpu (*p_s_2_u32) )
+      return -1;
+    if ( le32_to_cpu (*p_s_1_u32) > le32_to_cpu (*p_s_2_u32) )
+      return 1;
+  }
+  return 0;
+}
+
+inline void le_key2cpu_key (struct cpu_key * to, const struct reiserfs_key * from)
+{
+    to->on_disk_key.k_dir_id = le32_to_cpu (from->k_dir_id);
+    to->on_disk_key.k_objectid = le32_to_cpu (from->k_objectid);
+    
+    // find out version of the key
+    to->version = le_key_version (from);
+    if (to->version == KEY_FORMAT_3_5) {
+	to->on_disk_key.u.k_offset_v1.k_offset = le32_to_cpu (from->u.k_offset_v1.k_offset);
+	to->on_disk_key.u.k_offset_v1.k_uniqueness = le32_to_cpu (from->u.k_offset_v1.k_uniqueness);
+    } else {
+	to->on_disk_key.u.k_offset_v2.k_offset = offset_v2_k_offset(&from->u.k_offset_v2);
+	to->on_disk_key.u.k_offset_v2.k_type = offset_v2_k_type(&from->u.k_offset_v2);
+    } 
+}
+
+
+
+// this does not say which one is bigger, it only returns 1 if keys
+// are not equal, 0 otherwise
+inline int comp_le_keys (const struct reiserfs_key * k1, const struct reiserfs_key * k2)
+{
+    return memcmp (k1, k2, sizeof (struct reiserfs_key));
+}
+
+/**************************************************************************
+ *  Binary search toolkit function                                        *
+ *  Search for an item in the array by the item key                       *
+ *  Returns:    1 if found,  0 if not found;                              *
+ *        *p_n_pos = number of the searched element if found, else the    *
+ *        number of the first element that is larger than p_v_key.        *
+ **************************************************************************/
+/* For those not familiar with binary search: n_lbound is the leftmost item that it
+ could be, n_rbound the rightmost item that it could be.  We examine the item
+ halfway between n_lbound and n_rbound, and that tells us either that we can increase
+ n_lbound, or decrease n_rbound, or that we have found it, or if n_lbound <= n_rbound that
+ there are no possible items, and we have not found it. With each examination we
+ cut the number of possible items it could be by one more than half rounded down,
+ or we find it. */
+static inline	int bin_search (
+              const void * p_v_key, /* Key to search for.                   */
+	      const void * p_v_base,/* First item in the array.             */
+	      int       p_n_num,    /* Number of items in the array.        */
+	      int       p_n_width,  /* Item size in the array.
+				       searched. Lest the reader be
+				       confused, note that this is crafted
+				       as a general function, and when it
+				       is applied specifically to the array
+				       of item headers in a node, p_n_width
+				       is actually the item header size not
+				       the item size.                      */
+	      int     * p_n_pos     /* Number of the searched for element. */
+            ) {
+    int   n_rbound, n_lbound, n_j;
+
+   for ( n_j = ((n_rbound = p_n_num - 1) + (n_lbound = 0))/2; n_lbound <= n_rbound; n_j = (n_rbound + n_lbound)/2 )
+     switch( comp_keys((struct reiserfs_key *)((char * )p_v_base + n_j * p_n_width), (struct cpu_key *)p_v_key) )  {
+     case -1: n_lbound = n_j + 1; continue;
+     case  1: n_rbound = n_j - 1; continue;
+     case  0: *p_n_pos = n_j;     return ITEM_FOUND; /* Key found in the array.  */
+        }
+
+    /* bin_search did not find given key, it returns position of key,
+        that is minimal and greater than the given one. */
+    *p_n_pos = n_lbound;
+    return ITEM_NOT_FOUND;
+}
+
+#ifdef CONFIG_REISERFS_CHECK
+extern struct tree_balance * cur_tb;
+#endif
+
+
+
+/* Minimal possible key. It is never in the tree. */
+const struct reiserfs_key  MIN_KEY = {0, 0, {{0, 0},}};
+
+/* Maximal possible key. It is never in the tree. */
+const struct reiserfs_key  MAX_KEY = {0xffffffff, 0xffffffff, {{0xffffffff, 0xffffffff},}};
+
+
+/* Get delimiting key of the buffer by looking for it in the buffers in the path, starting from the bottom
+   of the path, and going upwards.  We must check the path's validity at each step.  If the key is not in
+   the path, there is no delimiting key in the tree (buffer is first or last buffer in tree), and in this
+   case we return a special key, either MIN_KEY or MAX_KEY. */
+static inline	const struct  reiserfs_key * get_lkey  (
+	                const struct path         * p_s_chk_path,
+                        const struct super_block  * p_s_sb
+                      ) {
+  int                   n_position, n_path_offset = p_s_chk_path->path_length;
+  struct buffer_head  * p_s_parent;
+  
+  RFALSE( n_path_offset < FIRST_PATH_ELEMENT_OFFSET, 
+	  "PAP-5010: invalid offset in the path");
+
+  /* While not higher in path than first element. */
+  while ( n_path_offset-- > FIRST_PATH_ELEMENT_OFFSET ) {
+
+    RFALSE( ! buffer_uptodate(PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)),
+	    "PAP-5020: parent is not uptodate");
+
+    /* Parent at the path is not in the tree now. */
+    if ( ! B_IS_IN_TREE(p_s_parent = PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)) )
+      return &MAX_KEY;
+    /* Check whether position in the parent is correct. */
+    if ( (n_position = PATH_OFFSET_POSITION(p_s_chk_path, n_path_offset)) > B_NR_ITEMS(p_s_parent) )
+       return &MAX_KEY;
+    /* Check whether parent at the path really points to the child. */
+    if ( B_N_CHILD_NUM(p_s_parent, n_position) !=
+	 PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset + 1)->b_blocknr )
+      return &MAX_KEY;
+    /* Return delimiting key if position in the parent is not equal to zero. */
+    if ( n_position )
+      return B_N_PDELIM_KEY(p_s_parent, n_position - 1);
+  }
+  /* Return MIN_KEY if we are in the root of the buffer tree. */
+  if ( PATH_OFFSET_PBUFFER(p_s_chk_path, FIRST_PATH_ELEMENT_OFFSET)->b_blocknr ==
+       SB_ROOT_BLOCK (p_s_sb) )
+    return &MIN_KEY;
+  return  &MAX_KEY;
+}
+
+
+/* Get delimiting key of the buffer at the path and its right neighbor. */
+inline	const struct  reiserfs_key * get_rkey  (
+	                const struct path         * p_s_chk_path,
+                        const struct super_block  * p_s_sb
+                      ) {
+  int                   n_position,
+    			n_path_offset = p_s_chk_path->path_length;
+  struct buffer_head  * p_s_parent;
+
+  RFALSE( n_path_offset < FIRST_PATH_ELEMENT_OFFSET,
+	  "PAP-5030: invalid offset in the path");
+
+  while ( n_path_offset-- > FIRST_PATH_ELEMENT_OFFSET ) {
+
+    RFALSE( ! buffer_uptodate(PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)),
+	    "PAP-5040: parent is not uptodate");
+
+    /* Parent at the path is not in the tree now. */
+    if ( ! B_IS_IN_TREE(p_s_parent = PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)) )
+      return &MIN_KEY;
+    /* Check whether position in the parent is correct. */
+    if ( (n_position = PATH_OFFSET_POSITION(p_s_chk_path, n_path_offset)) > B_NR_ITEMS(p_s_parent) )
+      return &MIN_KEY;
+    /* Check whether parent at the path really points to the child. */
+    if ( B_N_CHILD_NUM(p_s_parent, n_position) !=
+                                        PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset + 1)->b_blocknr )
+      return &MIN_KEY;
+    /* Return delimiting key if position in the parent is not the last one. */
+    if ( n_position != B_NR_ITEMS(p_s_parent) )
+      return B_N_PDELIM_KEY(p_s_parent, n_position);
+  }
+  /* Return MAX_KEY if we are in the root of the buffer tree. */
+  if ( PATH_OFFSET_PBUFFER(p_s_chk_path, FIRST_PATH_ELEMENT_OFFSET)->b_blocknr ==
+       SB_ROOT_BLOCK (p_s_sb) )
+    return &MAX_KEY;
+  return  &MIN_KEY;
+}
+
+
+/* Check whether a key is contained in the tree rooted from a buffer at a path. */
+/* This works by looking at the left and right delimiting keys for the buffer in the last path_element in
+   the path.  These delimiting keys are stored at least one level above that buffer in the tree. If the
+   buffer is the first or last node in the tree order then one of the delimiting keys may be absent, and in
+   this case get_lkey and get_rkey return a special key which is MIN_KEY or MAX_KEY. */
+static  inline  int key_in_buffer (
+                      struct path         * p_s_chk_path, /* Path which should be checked.  */
+                      const struct cpu_key      * p_s_key,      /* Key which should be checked.   */
+                      struct super_block  * p_s_sb        /* Super block pointer.           */
+		      ) {
+
+  RFALSE( ! p_s_key || p_s_chk_path->path_length < FIRST_PATH_ELEMENT_OFFSET ||
+	  p_s_chk_path->path_length > MAX_HEIGHT,
+	  "PAP-5050: pointer to the key(%p) is NULL or invalid path length(%d)",
+	  p_s_key, p_s_chk_path->path_length);
+  RFALSE( !PATH_PLAST_BUFFER(p_s_chk_path)->b_bdev,
+	  "PAP-5060: device must not be NODEV");
+
+  if ( comp_keys(get_lkey(p_s_chk_path, p_s_sb), p_s_key) == 1 )
+    /* left delimiting key is bigger, that the key we look for */
+    return 0;
+  //  if ( comp_keys(p_s_key, get_rkey(p_s_chk_path, p_s_sb)) != -1 )
+  if ( comp_keys(get_rkey(p_s_chk_path, p_s_sb), p_s_key) != 1 )
+    /* p_s_key must be less than right delimitiing key */
+    return 0;
+  return 1;
+}
+
+
+inline void decrement_bcount(
+              struct buffer_head  * p_s_bh
+            ) { 
+  if ( p_s_bh ) {
+    if ( atomic_read (&(p_s_bh->b_count)) ) {
+      put_bh(p_s_bh) ;
+      return;
+    }
+    reiserfs_panic(NULL, "PAP-5070: decrement_bcount: trying to free free buffer %b", p_s_bh);
+  }
+}
+
+
+/* Decrement b_count field of the all buffers in the path. */
+void decrement_counters_in_path (
+              struct path * p_s_search_path
+            ) {
+  int n_path_offset = p_s_search_path->path_length;
+
+  RFALSE( n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET ||
+	  n_path_offset > EXTENDED_MAX_HEIGHT - 1,
+	  "PAP-5080: invalid path offset of %d", n_path_offset);
+
+  while ( n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET ) {
+    struct buffer_head * bh;
+
+    bh = PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--);
+    decrement_bcount (bh);
+  }
+  p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
+}
+
+
+int reiserfs_check_path(struct path *p) {
+  RFALSE( p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,
+	  "path not properly relsed") ;
+  return 0 ;
+}
+
+
+/* Release all buffers in the path. Restore dirty bits clean
+** when preparing the buffer for the log
+**
+** only called from fix_nodes()
+*/
+void  pathrelse_and_restore (
+	struct super_block *s, 
+        struct path * p_s_search_path
+      ) {
+  int n_path_offset = p_s_search_path->path_length;
+
+  RFALSE( n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET, 
+	  "clm-4000: invalid path offset");
+  
+  while ( n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET )  {
+    reiserfs_restore_prepared_buffer(s, PATH_OFFSET_PBUFFER(p_s_search_path, 
+                                     n_path_offset));
+    brelse(PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--));
+  }
+  p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
+}
+
+/* Release all buffers in the path. */
+void  pathrelse (
+        struct path * p_s_search_path
+      ) {
+  int n_path_offset = p_s_search_path->path_length;
+
+  RFALSE( n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,
+	  "PAP-5090: invalid path offset");
+  
+  while ( n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET )  
+    brelse(PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--));
+
+  p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
+}
+
+
+
+static int is_leaf (char * buf, int blocksize, struct buffer_head * bh)
+{
+    struct block_head * blkh;
+    struct item_head * ih;
+    int used_space;
+    int prev_location;
+    int i;
+    int nr;
+
+    blkh = (struct block_head *)buf;
+    if ( blkh_level(blkh) != DISK_LEAF_NODE_LEVEL) {
+	reiserfs_warning (NULL, "is_leaf: this should be caught earlier");
+	return 0;
+    }
+
+    nr = blkh_nr_item(blkh);
+    if (nr < 1 || nr > ((blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN))) {
+	/* item number is too big or too small */
+	reiserfs_warning (NULL, "is_leaf: nr_item seems wrong: %z", bh);
+	return 0;
+    }
+    ih = (struct item_head *)(buf + BLKH_SIZE) + nr - 1;
+    used_space = BLKH_SIZE + IH_SIZE * nr + (blocksize - ih_location (ih));
+    if (used_space != blocksize - blkh_free_space(blkh)) {
+	/* free space does not match to calculated amount of use space */
+	reiserfs_warning (NULL, "is_leaf: free space seems wrong: %z", bh);
+	return 0;
+    }
+
+    // FIXME: it is_leaf will hit performance too much - we may have
+    // return 1 here
+
+    /* check tables of item heads */
+    ih = (struct item_head *)(buf + BLKH_SIZE);
+    prev_location = blocksize;
+    for (i = 0; i < nr; i ++, ih ++) {
+	if ( le_ih_k_type(ih) == TYPE_ANY) {
+	    reiserfs_warning (NULL, "is_leaf: wrong item type for item %h",ih);
+	    return 0;
+	}
+	if (ih_location (ih) >= blocksize || ih_location (ih) < IH_SIZE * nr) {
+	    reiserfs_warning (NULL, "is_leaf: item location seems wrong: %h", ih);
+	    return 0;
+	}
+	if (ih_item_len (ih) < 1 || ih_item_len (ih) > MAX_ITEM_LEN (blocksize)) {
+	    reiserfs_warning (NULL, "is_leaf: item length seems wrong: %h", ih);
+	    return 0;
+	}
+	if (prev_location - ih_location (ih) != ih_item_len (ih)) {
+	    reiserfs_warning (NULL, "is_leaf: item location seems wrong (second one): %h", ih);
+	    return 0;
+	}
+	prev_location = ih_location (ih);
+    }
+
+    // one may imagine much more checks
+    return 1;
+}
+
+
+/* returns 1 if buf looks like an internal node, 0 otherwise */
+static int is_internal (char * buf, int blocksize, struct buffer_head * bh)
+{
+    struct block_head * blkh;
+    int nr;
+    int used_space;
+
+    blkh = (struct block_head *)buf;
+    nr = blkh_level(blkh);
+    if (nr <= DISK_LEAF_NODE_LEVEL || nr > MAX_HEIGHT) {
+	/* this level is not possible for internal nodes */
+	reiserfs_warning (NULL, "is_internal: this should be caught earlier");
+	return 0;
+    }
+    
+    nr = blkh_nr_item(blkh);
+    if (nr > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE)) {
+	/* for internal which is not root we might check min number of keys */
+	reiserfs_warning (NULL, "is_internal: number of key seems wrong: %z", bh);
+	return 0;
+    }
+
+    used_space = BLKH_SIZE + KEY_SIZE * nr + DC_SIZE * (nr + 1);
+    if (used_space != blocksize - blkh_free_space(blkh)) {
+	reiserfs_warning (NULL, "is_internal: free space seems wrong: %z", bh);
+	return 0;
+    }
+
+    // one may imagine much more checks
+    return 1;
+}
+
+
+// make sure that bh contains formatted node of reiserfs tree of
+// 'level'-th level
+static int is_tree_node (struct buffer_head * bh, int level)
+{
+    if (B_LEVEL (bh) != level) {
+	reiserfs_warning (NULL, "is_tree_node: node level %d does not match to the expected one %d",
+		B_LEVEL (bh), level);
+	return 0;
+    }
+    if (level == DISK_LEAF_NODE_LEVEL)
+	return is_leaf (bh->b_data, bh->b_size, bh);
+
+    return is_internal (bh->b_data, bh->b_size, bh);
+}
+
+
+
+#define SEARCH_BY_KEY_READA 16
+
+/* The function is NOT SCHEDULE-SAFE! */
+static void search_by_key_reada (struct super_block * s,
+                                 struct buffer_head **bh,
+				 unsigned long *b, int num)
+{
+    int i,j;
+  
+    for (i = 0 ; i < num ; i++) {
+	bh[i] = sb_getblk (s, b[i]);
+    }
+    for (j = 0 ; j < i ; j++) {
+	/*
+	 * note, this needs attention if we are getting rid of the BKL
+	 * you have to make sure the prepared bit isn't set on this buffer
+	 */
+	if (!buffer_uptodate(bh[j]))
+	    ll_rw_block(READA, 1, bh + j);
+    	brelse(bh[j]);
+    }
+}
+
+/**************************************************************************
+ * Algorithm   SearchByKey                                                *
+ *             look for item in the Disk S+Tree by its key                *
+ * Input:  p_s_sb   -  super block                                        *
+ *         p_s_key  - pointer to the key to search                        *
+ * Output: ITEM_FOUND, ITEM_NOT_FOUND or IO_ERROR                         *
+ *         p_s_search_path - path from the root to the needed leaf        *
+ **************************************************************************/
+
+/* This function fills up the path from the root to the leaf as it
+   descends the tree looking for the key.  It uses reiserfs_bread to
+   try to find buffers in the cache given their block number.  If it
+   does not find them in the cache it reads them from disk.  For each
+   node search_by_key finds using reiserfs_bread it then uses
+   bin_search to look through that node.  bin_search will find the
+   position of the block_number of the next node if it is looking
+   through an internal node.  If it is looking through a leaf node
+   bin_search will find the position of the item which has key either
+   equal to given key, or which is the maximal key less than the given
+   key.  search_by_key returns a path that must be checked for the
+   correctness of the top of the path but need not be checked for the
+   correctness of the bottom of the path */
+/* The function is NOT SCHEDULE-SAFE! */
+int search_by_key (struct super_block * p_s_sb,
+		   const struct cpu_key * p_s_key, /* Key to search. */
+		   struct path * p_s_search_path, /* This structure was
+						     allocated and initialized
+						     by the calling
+						     function. It is filled up
+						     by this function.  */
+		   int n_stop_level /* How far down the tree to search. To
+                                       stop at leaf level - set to
+                                       DISK_LEAF_NODE_LEVEL */
+    ) {
+    int  n_block_number;
+    int  expected_level;
+    struct buffer_head  *       p_s_bh;
+    struct path_element *       p_s_last_element;
+    int				n_node_level, n_retval;
+    int 			right_neighbor_of_leaf_node;
+    int				fs_gen;
+    struct buffer_head *reada_bh[SEARCH_BY_KEY_READA];
+    unsigned long      reada_blocks[SEARCH_BY_KEY_READA];
+    int reada_count = 0;
+
+#ifdef CONFIG_REISERFS_CHECK
+    int n_repeat_counter = 0;
+#endif
+    
+    PROC_INFO_INC( p_s_sb, search_by_key );
+    
+    /* As we add each node to a path we increase its count.  This means that
+       we must be careful to release all nodes in a path before we either
+       discard the path struct or re-use the path struct, as we do here. */
+
+    decrement_counters_in_path(p_s_search_path);
+
+    right_neighbor_of_leaf_node = 0;
+
+    /* With each iteration of this loop we search through the items in the
+       current node, and calculate the next current node(next path element)
+       for the next iteration of this loop.. */
+    n_block_number = SB_ROOT_BLOCK (p_s_sb);
+    expected_level = -1;
+    while ( 1 ) {
+
+#ifdef CONFIG_REISERFS_CHECK
+	if ( !(++n_repeat_counter % 50000) )
+	    reiserfs_warning (p_s_sb, "PAP-5100: search_by_key: %s:"
+			      "there were %d iterations of while loop "
+			      "looking for key %K",
+			      current->comm, n_repeat_counter, p_s_key);
+#endif
+
+	/* prep path to have another element added to it. */
+	p_s_last_element = PATH_OFFSET_PELEMENT(p_s_search_path, ++p_s_search_path->path_length);
+	fs_gen = get_generation (p_s_sb);
+
+	/* Read the next tree node, and set the last element in the path to
+           have a pointer to it. */
+	if ((p_s_bh = p_s_last_element->pe_buffer =
+	     sb_getblk(p_s_sb, n_block_number)) ) {
+	    if (!buffer_uptodate(p_s_bh) && reada_count > 1) {
+		search_by_key_reada (p_s_sb, reada_bh,
+		                     reada_blocks, reada_count);
+	    }
+	    ll_rw_block(READ, 1, &p_s_bh);
+	    wait_on_buffer(p_s_bh);
+	    if (!buffer_uptodate(p_s_bh))
+	        goto io_error;
+	} else {
+io_error:
+	    p_s_search_path->path_length --;
+	    pathrelse(p_s_search_path);
+	    return IO_ERROR;
+	}
+	reada_count = 0;
+	if (expected_level == -1)
+		expected_level = SB_TREE_HEIGHT (p_s_sb);
+	expected_level --;
+
+	/* It is possible that schedule occurred. We must check whether the key
+	   to search is still in the tree rooted from the current buffer. If
+	   not then repeat search from the root. */
+	if ( fs_changed (fs_gen, p_s_sb) && 
+	    (!B_IS_IN_TREE (p_s_bh) ||
+	     B_LEVEL(p_s_bh) != expected_level ||
+	     !key_in_buffer(p_s_search_path, p_s_key, p_s_sb))) {
+	    PROC_INFO_INC( p_s_sb, search_by_key_fs_changed );
+	    PROC_INFO_INC( p_s_sb, search_by_key_restarted );
+	    PROC_INFO_INC( p_s_sb, sbk_restarted[ expected_level - 1 ] );
+	    decrement_counters_in_path(p_s_search_path);
+	    
+	    /* Get the root block number so that we can repeat the search
+	       starting from the root. */
+	    n_block_number = SB_ROOT_BLOCK (p_s_sb);
+	    expected_level = -1;
+	    right_neighbor_of_leaf_node = 0;
+	    
+	    /* repeat search from the root */
+	    continue;
+	}
+
+        /* only check that the key is in the buffer if p_s_key is not
+           equal to the MAX_KEY. Latter case is only possible in
+           "finish_unfinished()" processing during mount. */
+        RFALSE( comp_keys( &MAX_KEY, p_s_key ) &&
+                ! key_in_buffer(p_s_search_path, p_s_key, p_s_sb),
+		"PAP-5130: key is not in the buffer");
+#ifdef CONFIG_REISERFS_CHECK
+	if ( cur_tb ) {
+	    print_cur_tb ("5140");
+	    reiserfs_panic(p_s_sb, "PAP-5140: search_by_key: schedule occurred in do_balance!");
+	}
+#endif
+
+	// make sure, that the node contents look like a node of
+	// certain level
+	if (!is_tree_node (p_s_bh, expected_level)) {
+	    reiserfs_warning (p_s_sb, "vs-5150: search_by_key: "
+			      "invalid format found in block %ld. Fsck?",
+			      p_s_bh->b_blocknr);
+	    pathrelse (p_s_search_path);
+	    return IO_ERROR;
+	}
+	
+	/* ok, we have acquired next formatted node in the tree */
+	n_node_level = B_LEVEL (p_s_bh);
+
+	PROC_INFO_BH_STAT( p_s_sb, p_s_bh, n_node_level - 1 );
+
+	RFALSE( n_node_level < n_stop_level,
+		"vs-5152: tree level (%d) is less than stop level (%d)",
+		n_node_level, n_stop_level);
+
+	n_retval = bin_search( p_s_key, B_N_PITEM_HEAD(p_s_bh, 0),
+                B_NR_ITEMS(p_s_bh),
+                ( n_node_level == DISK_LEAF_NODE_LEVEL ) ? IH_SIZE : KEY_SIZE,
+                &(p_s_last_element->pe_position));
+	if (n_node_level == n_stop_level) {
+	    return n_retval;
+	}
+
+	/* we are not in the stop level */
+	if (n_retval == ITEM_FOUND)
+	    /* item has been found, so we choose the pointer which is to the right of the found one */
+	    p_s_last_element->pe_position++;
+
+	/* if item was not found we choose the position which is to
+	   the left of the found item. This requires no code,
+	   bin_search did it already.*/
+
+	/* So we have chosen a position in the current node which is
+	   an internal node.  Now we calculate child block number by
+	   position in the node. */
+	n_block_number = B_N_CHILD_NUM(p_s_bh, p_s_last_element->pe_position);
+
+	/* if we are going to read leaf nodes, try for read ahead as well */
+	if ((p_s_search_path->reada & PATH_READA) &&
+	    n_node_level == DISK_LEAF_NODE_LEVEL + 1)
+	{
+	    int pos = p_s_last_element->pe_position;
+	    int limit = B_NR_ITEMS(p_s_bh);
+	    struct reiserfs_key *le_key;
+
+	    if (p_s_search_path->reada & PATH_READA_BACK)
+		limit = 0;
+	    while(reada_count < SEARCH_BY_KEY_READA) {
+		if (pos == limit)
+		    break;
+	        reada_blocks[reada_count++] = B_N_CHILD_NUM(p_s_bh, pos);
+		if (p_s_search_path->reada & PATH_READA_BACK)
+		    pos--;
+		else
+		    pos++;
+
+		/*
+		 * check to make sure we're in the same object
+		 */
+		le_key = B_N_PDELIM_KEY(p_s_bh, pos);
+		if (le32_to_cpu(le_key->k_objectid) !=
+		    p_s_key->on_disk_key.k_objectid)
+		{
+		    break;
+		}
+	    }
+        }
+    }
+}
+
+
+/* Form the path to an item and position in this item which contains
+   file byte defined by p_s_key. If there is no such item
+   corresponding to the key, we point the path to the item with
+   maximal key less than p_s_key, and *p_n_pos_in_item is set to one
+   past the last entry/byte in the item.  If searching for entry in a
+   directory item, and it is not found, *p_n_pos_in_item is set to one
+   entry more than the entry with maximal key which is less than the
+   sought key.
+
+   Note that if there is no entry in this same node which is one more,
+   then we point to an imaginary entry.  for direct items, the
+   position is in units of bytes, for indirect items the position is
+   in units of blocknr entries, for directory items the position is in
+   units of directory entries.  */
+
+/* The function is NOT SCHEDULE-SAFE! */
+int search_for_position_by_key (struct super_block  * p_s_sb,         /* Pointer to the super block.          */
+				const struct cpu_key  * p_cpu_key,      /* Key to search (cpu variable)         */
+				struct path         * p_s_search_path /* Filled up by this function.          */
+    ) {
+    struct item_head    * p_le_ih; /* pointer to on-disk structure */
+    int                   n_blk_size;
+    loff_t item_offset, offset;
+    struct reiserfs_dir_entry de;
+    int retval;
+
+    /* If searching for directory entry. */
+    if ( is_direntry_cpu_key (p_cpu_key) )
+	return  search_by_entry_key (p_s_sb, p_cpu_key, p_s_search_path, &de);
+
+    /* If not searching for directory entry. */
+    
+    /* If item is found. */
+    retval = search_item (p_s_sb, p_cpu_key, p_s_search_path);
+    if (retval == IO_ERROR)
+	return retval;
+    if ( retval == ITEM_FOUND )  {
+
+	RFALSE( ! ih_item_len(
+                B_N_PITEM_HEAD(PATH_PLAST_BUFFER(p_s_search_path),
+			       PATH_LAST_POSITION(p_s_search_path))),
+	        "PAP-5165: item length equals zero");
+
+	pos_in_item(p_s_search_path) = 0;
+	return POSITION_FOUND;
+    }
+
+    RFALSE( ! PATH_LAST_POSITION(p_s_search_path),
+	    "PAP-5170: position equals zero");
+
+    /* Item is not found. Set path to the previous item. */
+    p_le_ih = B_N_PITEM_HEAD(PATH_PLAST_BUFFER(p_s_search_path), --PATH_LAST_POSITION(p_s_search_path));
+    n_blk_size = p_s_sb->s_blocksize;
+
+    if (comp_short_keys (&(p_le_ih->ih_key), p_cpu_key)) {
+	return FILE_NOT_FOUND;
+    }
+
+    // FIXME: quite ugly this far
+
+    item_offset = le_ih_k_offset (p_le_ih);
+    offset = cpu_key_k_offset (p_cpu_key);
+
+    /* Needed byte is contained in the item pointed to by the path.*/
+    if (item_offset <= offset &&
+	item_offset + op_bytes_number (p_le_ih, n_blk_size) > offset) {
+	pos_in_item (p_s_search_path) = offset - item_offset;
+	if ( is_indirect_le_ih(p_le_ih) ) {
+	    pos_in_item (p_s_search_path) /= n_blk_size;
+	}
+	return POSITION_FOUND;
+    }
+
+    /* Needed byte is not contained in the item pointed to by the
+     path. Set pos_in_item out of the item. */
+    if ( is_indirect_le_ih (p_le_ih) )
+	pos_in_item (p_s_search_path) = ih_item_len(p_le_ih) / UNFM_P_SIZE;
+    else
+        pos_in_item (p_s_search_path) = ih_item_len( p_le_ih );
+  
+    return POSITION_NOT_FOUND;
+}
+
+
+/* Compare given item and item pointed to by the path. */
+int comp_items (const struct item_head * stored_ih, const struct path * p_s_path)
+{
+    struct buffer_head  * p_s_bh;
+    struct item_head    * ih;
+
+    /* Last buffer at the path is not in the tree. */
+    if ( ! B_IS_IN_TREE(p_s_bh = PATH_PLAST_BUFFER(p_s_path)) )
+	return 1;
+
+    /* Last path position is invalid. */
+    if ( PATH_LAST_POSITION(p_s_path) >= B_NR_ITEMS(p_s_bh) )
+	return 1;
+
+    /* we need only to know, whether it is the same item */
+    ih = get_ih (p_s_path);
+    return memcmp (stored_ih, ih, IH_SIZE);
+}
+
+
+/* unformatted nodes are not logged anymore, ever.  This is safe
+** now
+*/
+#define held_by_others(bh) (atomic_read(&(bh)->b_count) > 1)
+
+// block can not be forgotten as it is in I/O or held by someone
+#define block_in_use(bh) (buffer_locked(bh) || (held_by_others(bh)))
+
+
+
+// prepare for delete or cut of direct item
+static inline int prepare_for_direct_item (struct path * path,
+					   struct item_head * le_ih,
+					   struct inode * inode,
+					   loff_t new_file_length,
+					   int * cut_size)
+{
+    loff_t round_len;
+
+
+    if ( new_file_length == max_reiserfs_offset (inode) ) {
+	/* item has to be deleted */
+	*cut_size = -(IH_SIZE + ih_item_len(le_ih));
+	return M_DELETE;
+    }
+	
+    // new file gets truncated
+    if (get_inode_item_key_version (inode) == KEY_FORMAT_3_6) {
+	// 
+	round_len = ROUND_UP (new_file_length); 
+	/* this was n_new_file_length < le_ih ... */
+	if ( round_len < le_ih_k_offset (le_ih) )  {
+	    *cut_size = -(IH_SIZE + ih_item_len(le_ih));
+	    return M_DELETE; /* Delete this item. */
+	}
+	/* Calculate first position and size for cutting from item. */
+	pos_in_item (path) = round_len - (le_ih_k_offset (le_ih) - 1);
+	*cut_size = -(ih_item_len(le_ih) - pos_in_item(path));
+	
+	return M_CUT; /* Cut from this item. */
+    }
+
+
+    // old file: items may have any length
+
+    if ( new_file_length < le_ih_k_offset (le_ih) )  {
+	*cut_size = -(IH_SIZE + ih_item_len(le_ih));
+	return M_DELETE; /* Delete this item. */
+    }
+    /* Calculate first position and size for cutting from item. */
+    *cut_size = -(ih_item_len(le_ih) -
+		      (pos_in_item (path) = new_file_length + 1 - le_ih_k_offset (le_ih)));
+    return M_CUT; /* Cut from this item. */
+}
+
+
+static inline int prepare_for_direntry_item (struct path * path,
+					     struct item_head * le_ih,
+					     struct inode * inode,
+					     loff_t new_file_length,
+					     int * cut_size)
+{
+    if (le_ih_k_offset (le_ih) == DOT_OFFSET && 
+	new_file_length == max_reiserfs_offset (inode)) {
+	RFALSE( ih_entry_count (le_ih) != 2,
+	        "PAP-5220: incorrect empty directory item (%h)", le_ih);
+	*cut_size = -(IH_SIZE + ih_item_len(le_ih));
+	return M_DELETE; /* Delete the directory item containing "." and ".." entry. */
+    }
+    
+    if ( ih_entry_count (le_ih) == 1 )  {
+	/* Delete the directory item such as there is one record only
+	   in this item*/
+	*cut_size = -(IH_SIZE + ih_item_len(le_ih));
+	return M_DELETE;
+    }
+    
+    /* Cut one record from the directory item. */
+    *cut_size = -(DEH_SIZE + entry_length (get_last_bh (path), le_ih, pos_in_item (path)));
+    return M_CUT; 
+}
+
+
+/*  If the path points to a directory or direct item, calculate mode and the size cut, for balance.
+    If the path points to an indirect item, remove some number of its unformatted nodes.
+    In case of file truncate calculate whether this item must be deleted/truncated or last
+    unformatted node of this item will be converted to a direct item.
+    This function returns a determination of what balance mode the calling function should employ. */
+static char  prepare_for_delete_or_cut(
+				       struct reiserfs_transaction_handle *th, 
+				       struct inode * inode,
+				       struct path         * p_s_path,
+				       const struct cpu_key      * p_s_item_key,
+				       int                 * p_n_removed,      /* Number of unformatted nodes which were removed
+										  from end of the file. */
+				       int                 * p_n_cut_size,
+				       unsigned long long    n_new_file_length /* MAX_KEY_OFFSET in case of delete. */
+    ) {
+    struct super_block  * p_s_sb = inode->i_sb;
+    struct item_head    * p_le_ih = PATH_PITEM_HEAD(p_s_path);
+    struct buffer_head  * p_s_bh = PATH_PLAST_BUFFER(p_s_path);
+
+    BUG_ON (!th->t_trans_id);
+
+    /* Stat_data item. */
+    if ( is_statdata_le_ih (p_le_ih) ) {
+
+	RFALSE( n_new_file_length != max_reiserfs_offset (inode),
+		"PAP-5210: mode must be M_DELETE");
+
+	*p_n_cut_size = -(IH_SIZE + ih_item_len(p_le_ih));
+	return M_DELETE;
+    }
+
+
+    /* Directory item. */
+    if ( is_direntry_le_ih (p_le_ih) )
+	return prepare_for_direntry_item (p_s_path, p_le_ih, inode, n_new_file_length, p_n_cut_size);
+
+    /* Direct item. */
+    if ( is_direct_le_ih (p_le_ih) )
+	return prepare_for_direct_item (p_s_path, p_le_ih, inode, n_new_file_length, p_n_cut_size);
+
+
+    /* Case of an indirect item. */
+    {
+	int                   n_unfm_number,    /* Number of the item unformatted nodes. */
+	    n_counter,
+	    n_blk_size;
+	__u32               * p_n_unfm_pointer; /* Pointer to the unformatted node number. */
+	__u32 tmp;
+	struct item_head      s_ih;           /* Item header. */
+	char                  c_mode;           /* Returned mode of the balance. */
+	int need_research;
+
+
+	n_blk_size = p_s_sb->s_blocksize;
+
+	/* Search for the needed object indirect item until there are no unformatted nodes to be removed. */
+	do  {
+	    need_research = 0;
+            p_s_bh = PATH_PLAST_BUFFER(p_s_path);
+	    /* Copy indirect item header to a temp variable. */
+	    copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path));
+	    /* Calculate number of unformatted nodes in this item. */
+	    n_unfm_number = I_UNFM_NUM(&s_ih);
+
+	    RFALSE( ! is_indirect_le_ih(&s_ih) || ! n_unfm_number ||
+		    pos_in_item (p_s_path) + 1 !=  n_unfm_number,
+		    "PAP-5240: invalid item %h "
+		    "n_unfm_number = %d *p_n_pos_in_item = %d", 
+		    &s_ih, n_unfm_number, pos_in_item (p_s_path));
+
+	    /* Calculate balance mode and position in the item to remove unformatted nodes. */
+	    if ( n_new_file_length == max_reiserfs_offset (inode) ) {/* Case of delete. */
+		pos_in_item (p_s_path) = 0;
+		*p_n_cut_size = -(IH_SIZE + ih_item_len(&s_ih));
+		c_mode = M_DELETE;
+	    }
+	    else  { /* Case of truncate. */
+		if ( n_new_file_length < le_ih_k_offset (&s_ih) )  {
+		    pos_in_item (p_s_path) = 0;
+		    *p_n_cut_size = -(IH_SIZE + ih_item_len(&s_ih));
+		    c_mode = M_DELETE; /* Delete this item. */
+		}
+		else  {
+		    /* indirect item must be truncated starting from *p_n_pos_in_item-th position */
+		    pos_in_item (p_s_path) = (n_new_file_length + n_blk_size - le_ih_k_offset (&s_ih) ) >> p_s_sb->s_blocksize_bits;
+
+		    RFALSE( pos_in_item (p_s_path) > n_unfm_number,
+			    "PAP-5250: invalid position in the item");
+
+		    /* Either convert last unformatted node of indirect item to direct item or increase
+		       its free space.  */
+		    if ( pos_in_item (p_s_path) == n_unfm_number )  {
+			*p_n_cut_size = 0; /* Nothing to cut. */
+			return M_CONVERT; /* Maybe convert last unformatted node to the direct item. */
+		    }
+		    /* Calculate size to cut. */
+		    *p_n_cut_size = -(ih_item_len(&s_ih) - pos_in_item(p_s_path) * UNFM_P_SIZE);
+
+		    c_mode = M_CUT;     /* Cut from this indirect item. */
+		}
+	    }
+
+	    RFALSE( n_unfm_number <= pos_in_item (p_s_path),
+		    "PAP-5260: invalid position in the indirect item");
+
+	    /* pointers to be cut */
+	    n_unfm_number -= pos_in_item (p_s_path);
+	    /* Set pointer to the last unformatted node pointer that is to be cut. */
+	    p_n_unfm_pointer = (__u32 *)B_I_PITEM(p_s_bh, &s_ih) + I_UNFM_NUM(&s_ih) - 1 - *p_n_removed;
+
+
+	    /* We go through the unformatted nodes pointers of the indirect
+	       item and look for the unformatted nodes in the cache. If we
+	       found some of them we free it, zero corresponding indirect item
+	       entry and log buffer containing that indirect item. For this we
+	       need to prepare last path element for logging. If some
+	       unformatted node has b_count > 1 we must not free this
+	       unformatted node since it is in use. */
+	    reiserfs_prepare_for_journal(p_s_sb, p_s_bh, 1);
+	    // note: path could be changed, first line in for loop takes care
+	    // of it
+
+	    for (n_counter = *p_n_removed;
+		 n_counter < n_unfm_number; n_counter++, p_n_unfm_pointer-- ) {
+
+		cond_resched();
+		if (item_moved (&s_ih, p_s_path)) {
+		    need_research = 1 ;
+		    break;
+		}
+		RFALSE( p_n_unfm_pointer < (__u32 *)B_I_PITEM(p_s_bh, &s_ih) ||
+			p_n_unfm_pointer > (__u32 *)B_I_PITEM(p_s_bh, &s_ih) + I_UNFM_NUM(&s_ih) - 1,
+			"vs-5265: pointer out of range");
+
+		/* Hole, nothing to remove. */
+		if ( ! get_block_num(p_n_unfm_pointer,0) )  {
+			(*p_n_removed)++;
+			continue;
+		}
+
+		(*p_n_removed)++;
+
+		tmp = get_block_num(p_n_unfm_pointer,0);
+		put_block_num(p_n_unfm_pointer, 0, 0);
+		journal_mark_dirty (th, p_s_sb, p_s_bh);
+		reiserfs_free_block(th, inode, tmp, 1);
+		if ( item_moved (&s_ih, p_s_path) )  {
+			need_research = 1;
+			break ;
+		}
+	    }
+
+	    /* a trick.  If the buffer has been logged, this
+	    ** will do nothing.  If we've broken the loop without
+	    ** logging it, it will restore the buffer
+	    **
+	    */
+	    reiserfs_restore_prepared_buffer(p_s_sb, p_s_bh);
+
+	    /* This loop can be optimized. */
+	} while ( (*p_n_removed < n_unfm_number || need_research) &&
+		  search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path) == POSITION_FOUND );
+
+	RFALSE( *p_n_removed < n_unfm_number, 
+		"PAP-5310: indirect item is not found");
+	RFALSE( item_moved (&s_ih, p_s_path), 
+		"after while, comp failed, retry") ;
+
+	if (c_mode == M_CUT)
+	    pos_in_item (p_s_path) *= UNFM_P_SIZE;
+	return c_mode;
+    }
+}
+
+/* Calculate number of bytes which will be deleted or cut during balance */
+static int calc_deleted_bytes_number(
+    struct  tree_balance  * p_s_tb,
+    char                    c_mode
+    ) {
+    int                     n_del_size;
+    struct  item_head     * p_le_ih = PATH_PITEM_HEAD(p_s_tb->tb_path);
+
+    if ( is_statdata_le_ih (p_le_ih) )
+	return 0;
+
+    n_del_size = ( c_mode == M_DELETE ) ? ih_item_len(p_le_ih) : -p_s_tb->insert_size[0];
+    if ( is_direntry_le_ih (p_le_ih) ) {
+	// return EMPTY_DIR_SIZE; /* We delete emty directoris only. */
+	// we can't use EMPTY_DIR_SIZE, as old format dirs have a different
+	// empty size.  ick. FIXME, is this right?
+	//
+	return n_del_size ;
+    }
+
+    if ( is_indirect_le_ih (p_le_ih) )
+	n_del_size = (n_del_size/UNFM_P_SIZE)*
+	  (PATH_PLAST_BUFFER(p_s_tb->tb_path)->b_size);// - get_ih_free_space (p_le_ih);
+    return n_del_size;
+}
+
+static void init_tb_struct(
+    struct reiserfs_transaction_handle *th,
+    struct tree_balance * p_s_tb,
+    struct super_block  * p_s_sb,
+    struct path         * p_s_path,
+    int                   n_size
+    ) {
+
+    BUG_ON (!th->t_trans_id);
+
+    memset (p_s_tb,'\0',sizeof(struct tree_balance));
+    p_s_tb->transaction_handle = th ;
+    p_s_tb->tb_sb = p_s_sb;
+    p_s_tb->tb_path = p_s_path;
+    PATH_OFFSET_PBUFFER(p_s_path, ILLEGAL_PATH_ELEMENT_OFFSET) = NULL;
+    PATH_OFFSET_POSITION(p_s_path, ILLEGAL_PATH_ELEMENT_OFFSET) = 0;
+    p_s_tb->insert_size[0] = n_size;
+}
+
+
+
+void padd_item (char * item, int total_length, int length)
+{
+    int i;
+
+    for (i = total_length; i > length; )
+	item [--i] = 0;
+}
+
+#ifdef REISERQUOTA_DEBUG
+char key2type(struct reiserfs_key *ih)
+{
+  if (is_direntry_le_key(2, ih))
+    return 'd';
+  if (is_direct_le_key(2, ih))
+    return 'D';
+  if (is_indirect_le_key(2, ih))
+    return 'i';
+  if (is_statdata_le_key(2, ih))
+    return 's';
+  return 'u';
+}
+
+char head2type(struct item_head *ih)
+{
+  if (is_direntry_le_ih(ih))
+    return 'd';
+  if (is_direct_le_ih(ih))
+    return 'D';
+  if (is_indirect_le_ih(ih))
+    return 'i';
+  if (is_statdata_le_ih(ih))
+    return 's';
+  return 'u';
+}
+#endif
+
+/* Delete object item. */
+int reiserfs_delete_item (struct reiserfs_transaction_handle *th, 
+			  struct path * p_s_path, /* Path to the deleted item. */
+			  const struct cpu_key * p_s_item_key, /* Key to search for the deleted item.  */
+			  struct inode * p_s_inode,/* inode is here just to update i_blocks and quotas */
+			  struct buffer_head  * p_s_un_bh)    /* NULL or unformatted node pointer.    */
+{
+    struct super_block * p_s_sb = p_s_inode->i_sb;
+    struct tree_balance   s_del_balance;
+    struct item_head      s_ih;
+    struct item_head      *q_ih;
+    int			  quota_cut_bytes;
+    int                   n_ret_value,
+	n_del_size,
+	n_removed;
+
+#ifdef CONFIG_REISERFS_CHECK
+    char                  c_mode;
+    int			n_iter = 0;
+#endif
+
+    BUG_ON (!th->t_trans_id);
+
+    init_tb_struct(th, &s_del_balance, p_s_sb, p_s_path, 0/*size is unknown*/);
+
+    while ( 1 ) {
+	n_removed = 0;
+
+#ifdef CONFIG_REISERFS_CHECK
+	n_iter++;
+	c_mode =
+#endif
+	    prepare_for_delete_or_cut(th, p_s_inode, p_s_path, p_s_item_key, &n_removed, &n_del_size, max_reiserfs_offset (p_s_inode));
+
+	RFALSE( c_mode != M_DELETE, "PAP-5320: mode must be M_DELETE");
+
+	copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path));
+	s_del_balance.insert_size[0] = n_del_size;
+
+	n_ret_value = fix_nodes(M_DELETE, &s_del_balance, NULL, NULL);
+	if ( n_ret_value != REPEAT_SEARCH )
+	    break;
+
+	PROC_INFO_INC( p_s_sb, delete_item_restarted );
+
+	// file system changed, repeat search
+	n_ret_value = search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path);
+	if (n_ret_value == IO_ERROR)
+	    break;
+	if (n_ret_value == FILE_NOT_FOUND) {
+	    reiserfs_warning (p_s_sb, "vs-5340: reiserfs_delete_item: "
+			      "no items of the file %K found", p_s_item_key);
+	    break;
+	}
+    } /* while (1) */
+
+    if ( n_ret_value != CARRY_ON ) {
+	unfix_nodes(&s_del_balance);
+	return 0;
+    }
+
+    // reiserfs_delete_item returns item length when success
+    n_ret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);
+    q_ih = get_ih(p_s_path) ;
+    quota_cut_bytes = ih_item_len(q_ih) ;
+
+    /* hack so the quota code doesn't have to guess if the file
+    ** has a tail.  On tail insert, we allocate quota for 1 unformatted node.
+    ** We test the offset because the tail might have been
+    ** split into multiple items, and we only want to decrement for
+    ** the unfm node once
+    */
+    if (!S_ISLNK (p_s_inode->i_mode) && is_direct_le_ih(q_ih)) {
+        if ((le_ih_k_offset(q_ih) & (p_s_sb->s_blocksize - 1)) == 1) {
+            quota_cut_bytes = p_s_sb->s_blocksize + UNFM_P_SIZE;
+        } else {
+	    quota_cut_bytes = 0 ;
+	}
+    }
+
+    if ( p_s_un_bh )  {
+	int off;
+        char *data ;
+
+	/* We are in direct2indirect conversion, so move tail contents
+           to the unformatted node */
+	/* note, we do the copy before preparing the buffer because we
+	** don't care about the contents of the unformatted node yet.
+	** the only thing we really care about is the direct item's data
+	** is in the unformatted node.
+	**
+	** Otherwise, we would have to call reiserfs_prepare_for_journal on
+	** the unformatted node, which might schedule, meaning we'd have to
+	** loop all the way back up to the start of the while loop.
+	**
+	** The unformatted node must be dirtied later on.  We can't be
+	** sure here if the entire tail has been deleted yet.
+        **
+        ** p_s_un_bh is from the page cache (all unformatted nodes are
+        ** from the page cache) and might be a highmem page.  So, we
+        ** can't use p_s_un_bh->b_data.
+	** -clm
+	*/
+
+        data = kmap_atomic(p_s_un_bh->b_page, KM_USER0);
+	off = ((le_ih_k_offset (&s_ih) - 1) & (PAGE_CACHE_SIZE - 1));
+	memcpy(data + off,
+	       B_I_PITEM(PATH_PLAST_BUFFER(p_s_path), &s_ih), n_ret_value);
+	kunmap_atomic(data, KM_USER0);
+    }
+    /* Perform balancing after all resources have been collected at once. */ 
+    do_balance(&s_del_balance, NULL, NULL, M_DELETE);
+
+#ifdef REISERQUOTA_DEBUG
+    reiserfs_debug (p_s_sb, REISERFS_DEBUG_CODE, "reiserquota delete_item(): freeing %u, id=%u type=%c", quota_cut_bytes, p_s_inode->i_uid, head2type(&s_ih));
+#endif
+    DQUOT_FREE_SPACE_NODIRTY(p_s_inode, quota_cut_bytes);
+
+    /* Return deleted body length */
+    return n_ret_value;
+}
+
+
+/* Summary Of Mechanisms For Handling Collisions Between Processes:
+
+ deletion of the body of the object is performed by iput(), with the
+ result that if multiple processes are operating on a file, the
+ deletion of the body of the file is deferred until the last process
+ that has an open inode performs its iput().
+
+ writes and truncates are protected from collisions by use of
+ semaphores.
+
+ creates, linking, and mknod are protected from collisions with other
+ processes by making the reiserfs_add_entry() the last step in the
+ creation, and then rolling back all changes if there was a collision.
+ - Hans
+*/
+
+
+/* this deletes item which never gets split */
+void reiserfs_delete_solid_item (struct reiserfs_transaction_handle *th,
+				 struct inode *inode,
+				 struct reiserfs_key * key)
+{
+    struct tree_balance tb;
+    INITIALIZE_PATH (path);
+    int item_len = 0;
+    int tb_init = 0 ;
+    struct cpu_key cpu_key;
+    int retval;
+    int quota_cut_bytes = 0;
+
+    BUG_ON (!th->t_trans_id);
+    
+    le_key2cpu_key (&cpu_key, key);
+    
+    while (1) {
+	retval = search_item (th->t_super, &cpu_key, &path);
+	if (retval == IO_ERROR) {
+	    reiserfs_warning (th->t_super,
+			      "vs-5350: reiserfs_delete_solid_item: "
+			      "i/o failure occurred trying to delete %K",
+			      &cpu_key);
+	    break;
+	}
+	if (retval != ITEM_FOUND) {
+	    pathrelse (&path);
+	    // No need for a warning, if there is just no free space to insert '..' item into the newly-created subdir
+	    if ( !( (unsigned long long) GET_HASH_VALUE (le_key_k_offset (le_key_version (key), key)) == 0 && \
+		 (unsigned long long) GET_GENERATION_NUMBER (le_key_k_offset (le_key_version (key), key)) == 1 ) )
+		reiserfs_warning (th->t_super, "vs-5355: reiserfs_delete_solid_item: %k not found", key);
+	    break;
+	}
+	if (!tb_init) {
+	    tb_init = 1 ;
+	    item_len = ih_item_len( PATH_PITEM_HEAD(&path) );
+	    init_tb_struct (th, &tb, th->t_super, &path, - (IH_SIZE + item_len));
+	}
+	quota_cut_bytes = ih_item_len(PATH_PITEM_HEAD(&path)) ;
+
+	retval = fix_nodes (M_DELETE, &tb, NULL, NULL);
+	if (retval == REPEAT_SEARCH) {
+	    PROC_INFO_INC( th -> t_super, delete_solid_item_restarted );
+	    continue;
+	}
+
+	if (retval == CARRY_ON) {
+	    do_balance (&tb, NULL, NULL, M_DELETE);
+	    if (inode) {	/* Should we count quota for item? (we don't count quotas for save-links) */
+#ifdef REISERQUOTA_DEBUG
+		reiserfs_debug (th->t_super, REISERFS_DEBUG_CODE, "reiserquota delete_solid_item(): freeing %u id=%u type=%c", quota_cut_bytes, inode->i_uid, key2type(key));
+#endif
+		DQUOT_FREE_SPACE_NODIRTY(inode, quota_cut_bytes);
+	    }
+	    break;
+	}
+
+	// IO_ERROR, NO_DISK_SPACE, etc
+	reiserfs_warning (th->t_super, "vs-5360: reiserfs_delete_solid_item: "
+			  "could not delete %K due to fix_nodes failure", &cpu_key);
+	unfix_nodes (&tb);
+	break;
+    }
+
+    reiserfs_check_path(&path) ;
+}
+
+
+int reiserfs_delete_object (struct reiserfs_transaction_handle *th, struct inode * inode)
+{
+    int err;
+    inode->i_size = 0;
+    BUG_ON (!th->t_trans_id);
+
+    /* for directory this deletes item containing "." and ".." */
+    err = reiserfs_do_truncate (th, inode, NULL, 0/*no timestamp updates*/);
+    if (err)
+        return err;
+    
+#if defined( USE_INODE_GENERATION_COUNTER )
+    if( !old_format_only ( th -> t_super ) )
+      {
+       __u32 *inode_generation;
+       
+       inode_generation = 
+         &REISERFS_SB(th -> t_super) -> s_rs -> s_inode_generation;
+       *inode_generation = cpu_to_le32( le32_to_cpu( *inode_generation ) + 1 );
+      }
+/* USE_INODE_GENERATION_COUNTER */
+#endif
+    reiserfs_delete_solid_item (th, inode, INODE_PKEY (inode));
+
+    return err;
+}
+
+static void
+unmap_buffers(struct page *page, loff_t pos) {
+    struct buffer_head *bh ;
+    struct buffer_head *head ;
+    struct buffer_head *next ;
+    unsigned long tail_index ;
+    unsigned long cur_index ;
+
+    if (page) {
+	if (page_has_buffers(page)) {
+	    tail_index = pos & (PAGE_CACHE_SIZE - 1) ;
+	    cur_index = 0 ;
+	    head = page_buffers(page) ;
+	    bh = head ;
+	    do {
+		next = bh->b_this_page ;
+
+		/* we want to unmap the buffers that contain the tail, and
+		** all the buffers after it (since the tail must be at the
+		** end of the file).  We don't want to unmap file data
+		** before the tail, since it might be dirty and waiting to
+		** reach disk
+		*/
+		cur_index += bh->b_size ;
+		if (cur_index > tail_index) {
+		    reiserfs_unmap_buffer(bh) ;
+		}
+		bh = next ;
+	    } while (bh != head) ;
+	    if ( PAGE_SIZE == bh->b_size ) {
+		clear_page_dirty(page);
+	    }
+	}
+    }
+}
+
+static int maybe_indirect_to_direct (struct reiserfs_transaction_handle *th, 
+			      struct inode * p_s_inode,
+			      struct page *page, 
+			      struct path         * p_s_path,
+			      const struct cpu_key      * p_s_item_key,
+			      loff_t         n_new_file_size,
+			      char                * p_c_mode
+			      ) {
+    struct super_block * p_s_sb = p_s_inode->i_sb;
+    int n_block_size = p_s_sb->s_blocksize;
+    int cut_bytes;
+    BUG_ON (!th->t_trans_id);
+
+    if (n_new_file_size != p_s_inode->i_size)
+	BUG ();
+
+    /* the page being sent in could be NULL if there was an i/o error
+    ** reading in the last block.  The user will hit problems trying to
+    ** read the file, but for now we just skip the indirect2direct
+    */
+    if (atomic_read(&p_s_inode->i_count) > 1 || 
+        !tail_has_to_be_packed (p_s_inode) || 
+	!page || (REISERFS_I(p_s_inode)->i_flags & i_nopack_mask)) {
+	// leave tail in an unformatted node	
+	*p_c_mode = M_SKIP_BALANCING;
+	cut_bytes = n_block_size - (n_new_file_size & (n_block_size - 1));
+	pathrelse(p_s_path);
+	return cut_bytes;
+    }
+    /* Permorm the conversion to a direct_item. */
+    /*return indirect_to_direct (p_s_inode, p_s_path, p_s_item_key, n_new_file_size, p_c_mode);*/
+    return indirect2direct (th, p_s_inode, page, p_s_path, p_s_item_key, n_new_file_size, p_c_mode);
+}
+
+
+/* we did indirect_to_direct conversion. And we have inserted direct
+   item successesfully, but there were no disk space to cut unfm
+   pointer being converted. Therefore we have to delete inserted
+   direct item(s) */
+static void indirect_to_direct_roll_back (struct reiserfs_transaction_handle *th, struct inode * inode, struct path * path)
+{
+    struct cpu_key tail_key;
+    int tail_len;
+    int removed;
+    BUG_ON (!th->t_trans_id);
+
+    make_cpu_key (&tail_key, inode, inode->i_size + 1, TYPE_DIRECT, 4);// !!!!
+    tail_key.key_length = 4;
+
+    tail_len = (cpu_key_k_offset (&tail_key) & (inode->i_sb->s_blocksize - 1)) - 1;
+    while (tail_len) {
+	/* look for the last byte of the tail */
+	if (search_for_position_by_key (inode->i_sb, &tail_key, path) == POSITION_NOT_FOUND)
+	    reiserfs_panic (inode->i_sb, "vs-5615: indirect_to_direct_roll_back: found invalid item");
+	RFALSE( path->pos_in_item != ih_item_len(PATH_PITEM_HEAD (path)) - 1,
+	        "vs-5616: appended bytes found");
+	PATH_LAST_POSITION (path) --;
+	
+	removed = reiserfs_delete_item (th, path, &tail_key, inode, NULL/*unbh not needed*/);
+	RFALSE( removed <= 0 || removed > tail_len,
+	        "vs-5617: there was tail %d bytes, removed item length %d bytes",
+                tail_len, removed);
+	tail_len -= removed;
+	set_cpu_key_k_offset (&tail_key, cpu_key_k_offset (&tail_key) - removed);
+    }
+    reiserfs_warning (inode->i_sb, "indirect_to_direct_roll_back: indirect_to_direct conversion has been rolled back due to lack of disk space");
+    //mark_file_without_tail (inode);
+    mark_inode_dirty (inode);
+}
+
+
+/* (Truncate or cut entry) or delete object item. Returns < 0 on failure */
+int reiserfs_cut_from_item (struct reiserfs_transaction_handle *th, 
+			    struct path * p_s_path,
+			    struct cpu_key * p_s_item_key,
+			    struct inode * p_s_inode,
+			    struct page *page, 
+			    loff_t n_new_file_size)
+{
+    struct super_block * p_s_sb = p_s_inode->i_sb;
+    /* Every function which is going to call do_balance must first
+       create a tree_balance structure.  Then it must fill up this
+       structure by using the init_tb_struct and fix_nodes functions.
+       After that we can make tree balancing. */
+    struct tree_balance s_cut_balance;
+    struct item_head *p_le_ih;
+    int n_cut_size = 0,        /* Amount to be cut. */
+	n_ret_value = CARRY_ON,
+	n_removed = 0,     /* Number of the removed unformatted nodes. */
+	n_is_inode_locked = 0;
+    char                c_mode;            /* Mode of the balance. */
+    int retval2 = -1;
+    int quota_cut_bytes;
+    loff_t tail_pos = 0;
+
+    BUG_ON (!th->t_trans_id);
+    
+    init_tb_struct(th, &s_cut_balance, p_s_inode->i_sb, p_s_path, n_cut_size);
+
+
+    /* Repeat this loop until we either cut the item without needing
+       to balance, or we fix_nodes without schedule occurring */
+    while ( 1 ) {
+	/* Determine the balance mode, position of the first byte to
+	   be cut, and size to be cut.  In case of the indirect item
+	   free unformatted nodes which are pointed to by the cut
+	   pointers. */
+      
+	c_mode = prepare_for_delete_or_cut(th, p_s_inode, p_s_path, p_s_item_key, &n_removed, 
+					   &n_cut_size, n_new_file_size);
+	if ( c_mode == M_CONVERT )  {
+	    /* convert last unformatted node to direct item or leave
+               tail in the unformatted node */
+	    RFALSE( n_ret_value != CARRY_ON, "PAP-5570: can not convert twice");
+
+	    n_ret_value = maybe_indirect_to_direct (th, p_s_inode, page, p_s_path, p_s_item_key,
+						    n_new_file_size, &c_mode);
+	    if ( c_mode == M_SKIP_BALANCING )
+		/* tail has been left in the unformatted node */
+		return n_ret_value;
+
+	    n_is_inode_locked = 1;
+	  
+	    /* removing of last unformatted node will change value we
+               have to return to truncate. Save it */
+	    retval2 = n_ret_value;
+	    /*retval2 = p_s_sb->s_blocksize - (n_new_file_size & (p_s_sb->s_blocksize - 1));*/
+	  
+	    /* So, we have performed the first part of the conversion:
+	       inserting the new direct item.  Now we are removing the
+	       last unformatted node pointer. Set key to search for
+	       it. */
+      	    set_cpu_key_k_type (p_s_item_key, TYPE_INDIRECT);
+	    p_s_item_key->key_length = 4;
+	    n_new_file_size -= (n_new_file_size & (p_s_sb->s_blocksize - 1));
+	    tail_pos = n_new_file_size;
+	    set_cpu_key_k_offset (p_s_item_key, n_new_file_size + 1);
+	    if ( search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path) == POSITION_NOT_FOUND ){
+		print_block (PATH_PLAST_BUFFER (p_s_path), 3, PATH_LAST_POSITION (p_s_path) - 1, PATH_LAST_POSITION (p_s_path) + 1);
+		reiserfs_panic(p_s_sb, "PAP-5580: reiserfs_cut_from_item: item to convert does not exist (%K)", p_s_item_key);
+	    }
+	    continue;
+	}
+	if (n_cut_size == 0) {
+	    pathrelse (p_s_path);
+	    return 0;
+	}
+
+	s_cut_balance.insert_size[0] = n_cut_size;
+	
+	n_ret_value = fix_nodes(c_mode, &s_cut_balance, NULL, NULL);
+      	if ( n_ret_value != REPEAT_SEARCH )
+	    break;
+	
+	PROC_INFO_INC( p_s_sb, cut_from_item_restarted );
+
+	n_ret_value = search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path);
+	if (n_ret_value == POSITION_FOUND)
+	    continue;
+
+	reiserfs_warning (p_s_sb, "PAP-5610: reiserfs_cut_from_item: item %K not found", p_s_item_key);
+	unfix_nodes (&s_cut_balance);
+	return (n_ret_value == IO_ERROR) ? -EIO : -ENOENT;
+    } /* while */
+  
+    // check fix_nodes results (IO_ERROR or NO_DISK_SPACE)
+    if ( n_ret_value != CARRY_ON ) {
+	if ( n_is_inode_locked ) {
+	    // FIXME: this seems to be not needed: we are always able
+	    // to cut item
+	    indirect_to_direct_roll_back (th, p_s_inode, p_s_path);
+	}
+	if (n_ret_value == NO_DISK_SPACE)
+	    reiserfs_warning (p_s_sb, "NO_DISK_SPACE");
+	unfix_nodes (&s_cut_balance);
+	return -EIO;
+    }
+
+    /* go ahead and perform balancing */
+    
+    RFALSE( c_mode == M_PASTE || c_mode == M_INSERT, "invalid mode");
+
+    /* Calculate number of bytes that need to be cut from the item. */
+    quota_cut_bytes = ( c_mode == M_DELETE ) ? ih_item_len(get_ih(p_s_path)) : -s_cut_balance.insert_size[0];
+    if (retval2 == -1)
+	n_ret_value = calc_deleted_bytes_number(&s_cut_balance, c_mode);
+    else
+	n_ret_value = retval2;
+
+
+    /* For direct items, we only change the quota when deleting the last
+    ** item.
+    */
+    p_le_ih = PATH_PITEM_HEAD (s_cut_balance.tb_path);
+    if (!S_ISLNK (p_s_inode->i_mode) && is_direct_le_ih(p_le_ih)) {
+        if (c_mode == M_DELETE &&
+	   (le_ih_k_offset (p_le_ih) & (p_s_sb->s_blocksize - 1)) == 1 ) {
+	    // FIXME: this is to keep 3.5 happy
+	    REISERFS_I(p_s_inode)->i_first_direct_byte = U32_MAX;
+	    quota_cut_bytes = p_s_sb->s_blocksize + UNFM_P_SIZE ;
+        } else {
+	    quota_cut_bytes = 0 ;
+	}
+    }
+#ifdef CONFIG_REISERFS_CHECK
+    if (n_is_inode_locked) {
+	struct item_head * le_ih = PATH_PITEM_HEAD (s_cut_balance.tb_path);
+	/* we are going to complete indirect2direct conversion. Make
+           sure, that we exactly remove last unformatted node pointer
+           of the item */
+	if (!is_indirect_le_ih (le_ih))
+	    reiserfs_panic (p_s_sb, "vs-5652: reiserfs_cut_from_item: "
+			    "item must be indirect %h", le_ih);
+
+	if (c_mode == M_DELETE && ih_item_len(le_ih) != UNFM_P_SIZE)
+	    reiserfs_panic (p_s_sb, "vs-5653: reiserfs_cut_from_item: "
+			    "completing indirect2direct conversion indirect item %h "
+			    "being deleted must be of 4 byte long", le_ih);
+
+	if (c_mode == M_CUT && s_cut_balance.insert_size[0] != -UNFM_P_SIZE) {
+	    reiserfs_panic (p_s_sb, "vs-5654: reiserfs_cut_from_item: "
+			    "can not complete indirect2direct conversion of %h (CUT, insert_size==%d)",
+			    le_ih, s_cut_balance.insert_size[0]);
+	}
+	/* it would be useful to make sure, that right neighboring
+           item is direct item of this file */
+    }
+#endif
+    
+    do_balance(&s_cut_balance, NULL, NULL, c_mode);
+    if ( n_is_inode_locked ) {
+	/* we've done an indirect->direct conversion.  when the data block
+	** was freed, it was removed from the list of blocks that must
+	** be flushed before the transaction commits, make sure to
+	** unmap and invalidate it
+	*/
+	unmap_buffers(page, tail_pos);
+	REISERFS_I(p_s_inode)->i_flags &= ~i_pack_on_close_mask ;
+    }
+#ifdef REISERQUOTA_DEBUG
+    reiserfs_debug (p_s_inode->i_sb, REISERFS_DEBUG_CODE, "reiserquota cut_from_item(): freeing %u id=%u type=%c", quota_cut_bytes, p_s_inode->i_uid, '?');
+#endif
+    DQUOT_FREE_SPACE_NODIRTY(p_s_inode, quota_cut_bytes);
+    return n_ret_value;
+}
+
+static void truncate_directory (struct reiserfs_transaction_handle *th, struct inode * inode)
+{
+    BUG_ON (!th->t_trans_id);
+    if (inode->i_nlink)
+	reiserfs_warning (inode->i_sb,
+			  "vs-5655: truncate_directory: link count != 0");
+
+    set_le_key_k_offset (KEY_FORMAT_3_5, INODE_PKEY (inode), DOT_OFFSET);
+    set_le_key_k_type (KEY_FORMAT_3_5, INODE_PKEY (inode), TYPE_DIRENTRY);
+    reiserfs_delete_solid_item (th, inode, INODE_PKEY (inode));
+    reiserfs_update_sd(th, inode) ;
+    set_le_key_k_offset (KEY_FORMAT_3_5, INODE_PKEY (inode), SD_OFFSET);
+    set_le_key_k_type (KEY_FORMAT_3_5, INODE_PKEY (inode), TYPE_STAT_DATA);    
+}
+
+
+
+
+/* Truncate file to the new size. Note, this must be called with a transaction
+   already started */
+int reiserfs_do_truncate (struct reiserfs_transaction_handle *th,
+			   struct  inode * p_s_inode, /* ->i_size contains new
+                                                         size */
+			   struct page *page, /* up to date for last block */
+			   int update_timestamps  /* when it is called by
+						     file_release to convert
+						     the tail - no timestamps
+						     should be updated */
+    ) {
+    INITIALIZE_PATH (s_search_path);       /* Path to the current object item. */
+    struct item_head    * p_le_ih;         /* Pointer to an item header. */
+    struct cpu_key      s_item_key;     /* Key to search for a previous file item. */
+    loff_t         n_file_size,    /* Old file size. */
+	n_new_file_size;/* New file size. */
+    int                   n_deleted;      /* Number of deleted or truncated bytes. */
+    int retval;
+    int err = 0;
+
+    BUG_ON (!th->t_trans_id);
+    if ( ! (S_ISREG(p_s_inode->i_mode) || S_ISDIR(p_s_inode->i_mode) || S_ISLNK(p_s_inode->i_mode)) )
+	return 0;
+
+    if (S_ISDIR(p_s_inode->i_mode)) {
+	// deletion of directory - no need to update timestamps
+	truncate_directory (th, p_s_inode);
+	return 0;
+    }
+
+    /* Get new file size. */
+    n_new_file_size = p_s_inode->i_size;
+
+    // FIXME: note, that key type is unimportant here
+    make_cpu_key (&s_item_key, p_s_inode, max_reiserfs_offset (p_s_inode), TYPE_DIRECT, 3);
+
+    retval = search_for_position_by_key(p_s_inode->i_sb, &s_item_key, &s_search_path);
+    if (retval == IO_ERROR) {
+	reiserfs_warning (p_s_inode->i_sb, "vs-5657: reiserfs_do_truncate: "
+			  "i/o failure occurred trying to truncate %K", &s_item_key);
+        err = -EIO;
+        goto out;
+    }
+    if (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {
+	reiserfs_warning (p_s_inode->i_sb, "PAP-5660: reiserfs_do_truncate: "
+			  "wrong result %d of search for %K", retval, &s_item_key);
+
+        err = -EIO;
+        goto out;
+    }
+
+    s_search_path.pos_in_item --;
+
+    /* Get real file size (total length of all file items) */
+    p_le_ih = PATH_PITEM_HEAD(&s_search_path);
+    if ( is_statdata_le_ih (p_le_ih) )
+	n_file_size = 0;
+    else {
+	loff_t offset = le_ih_k_offset (p_le_ih);
+	int bytes = op_bytes_number (p_le_ih,p_s_inode->i_sb->s_blocksize);
+
+	/* this may mismatch with real file size: if last direct item
+           had no padding zeros and last unformatted node had no free
+           space, this file would have this file size */
+	n_file_size = offset + bytes - 1;
+    }
+    /*
+     * are we doing a full truncate or delete, if so
+     * kick in the reada code
+     */
+    if (n_new_file_size == 0)
+        s_search_path.reada = PATH_READA | PATH_READA_BACK;
+
+    if ( n_file_size == 0 || n_file_size < n_new_file_size ) {
+	goto update_and_out ;
+    }
+
+    /* Update key to search for the last file item. */
+    set_cpu_key_k_offset (&s_item_key, n_file_size);
+
+    do  {
+	/* Cut or delete file item. */
+	n_deleted = reiserfs_cut_from_item(th, &s_search_path, &s_item_key, p_s_inode,  page, n_new_file_size);
+	if (n_deleted < 0) {
+	    reiserfs_warning (p_s_inode->i_sb, "vs-5665: reiserfs_do_truncate: reiserfs_cut_from_item failed");
+	    reiserfs_check_path(&s_search_path) ;
+	    return 0;
+	}
+
+	RFALSE( n_deleted > n_file_size,
+		"PAP-5670: reiserfs_cut_from_item: too many bytes deleted: deleted %d, file_size %lu, item_key %K",
+		n_deleted, n_file_size, &s_item_key);
+
+	/* Change key to search the last file item. */
+	n_file_size -= n_deleted;
+
+	set_cpu_key_k_offset (&s_item_key, n_file_size);
+
+	/* While there are bytes to truncate and previous file item is presented in the tree. */
+
+	/*
+	** This loop could take a really long time, and could log 
+	** many more blocks than a transaction can hold.  So, we do a polite
+	** journal end here, and if the transaction needs ending, we make
+	** sure the file is consistent before ending the current trans
+	** and starting a new one
+	*/
+        if (journal_transaction_should_end(th, th->t_blocks_allocated)) {
+	  int orig_len_alloc = th->t_blocks_allocated ;
+	  decrement_counters_in_path(&s_search_path) ;
+
+	  if (update_timestamps) {
+	      p_s_inode->i_mtime = p_s_inode->i_ctime = CURRENT_TIME_SEC;
+	  } 
+	  reiserfs_update_sd(th, p_s_inode) ;
+
+	  err = journal_end(th, p_s_inode->i_sb, orig_len_alloc) ;
+	  if (err)
+	    goto out;
+	  err = journal_begin (th, p_s_inode->i_sb,
+                               JOURNAL_PER_BALANCE_CNT * 6);
+	  if (err)
+	    goto out;
+	  reiserfs_update_inode_transaction(p_s_inode) ;
+	}
+    } while ( n_file_size > ROUND_UP (n_new_file_size) &&
+	      search_for_position_by_key(p_s_inode->i_sb, &s_item_key, &s_search_path) == POSITION_FOUND )  ;
+
+    RFALSE( n_file_size > ROUND_UP (n_new_file_size),
+	    "PAP-5680: truncate did not finish: new_file_size %Ld, current %Ld, oid %d",
+	    n_new_file_size, n_file_size, s_item_key.on_disk_key.k_objectid);
+
+update_and_out:
+    if (update_timestamps) {
+	// this is truncate, not file closing
+	    p_s_inode->i_mtime = p_s_inode->i_ctime = CURRENT_TIME_SEC;
+    }
+    reiserfs_update_sd (th, p_s_inode);
+
+out:
+    pathrelse(&s_search_path) ;
+    return err;
+}
+
+
+#ifdef CONFIG_REISERFS_CHECK
+// this makes sure, that we __append__, not overwrite or add holes
+static void check_research_for_paste (struct path * path, 
+				      const struct cpu_key * p_s_key)
+{
+    struct item_head * found_ih = get_ih (path);
+    
+    if (is_direct_le_ih (found_ih)) {
+	if (le_ih_k_offset (found_ih) + op_bytes_number (found_ih, get_last_bh (path)->b_size) !=
+	    cpu_key_k_offset (p_s_key) ||
+	    op_bytes_number (found_ih, get_last_bh (path)->b_size) != pos_in_item (path))
+	    reiserfs_panic (NULL, "PAP-5720: check_research_for_paste: "
+			    "found direct item %h or position (%d) does not match to key %K",
+			    found_ih, pos_in_item (path), p_s_key);
+    }
+    if (is_indirect_le_ih (found_ih)) {
+	if (le_ih_k_offset (found_ih) + op_bytes_number (found_ih, get_last_bh (path)->b_size) != cpu_key_k_offset (p_s_key) || 
+	    I_UNFM_NUM (found_ih) != pos_in_item (path) ||
+	    get_ih_free_space (found_ih) != 0)
+	    reiserfs_panic (NULL, "PAP-5730: check_research_for_paste: "
+			    "found indirect item (%h) or position (%d) does not match to key (%K)",
+			    found_ih, pos_in_item (path), p_s_key);
+    }
+}
+#endif /* config reiserfs check */
+
+
+/* Paste bytes to the existing item. Returns bytes number pasted into the item. */
+int reiserfs_paste_into_item (struct reiserfs_transaction_handle *th, 
+			      struct path         * p_s_search_path,	/* Path to the pasted item.          */
+			      const struct cpu_key      * p_s_key,        	/* Key to search for the needed item.*/
+			      struct inode	  * inode,		/* Inode item belongs to */
+			      const char          * p_c_body,       	/* Pointer to the bytes to paste.    */
+			      int                   n_pasted_size)  	/* Size of pasted bytes.             */
+{
+    struct tree_balance s_paste_balance;
+    int                 retval;
+    int			fs_gen;
+
+    BUG_ON (!th->t_trans_id);
+
+    fs_gen = get_generation(inode->i_sb) ;
+
+#ifdef REISERQUOTA_DEBUG
+    reiserfs_debug (inode->i_sb, REISERFS_DEBUG_CODE, "reiserquota paste_into_item(): allocating %u id=%u type=%c", n_pasted_size, inode->i_uid, key2type(&(p_s_key->on_disk_key)));
+#endif
+
+    if (DQUOT_ALLOC_SPACE_NODIRTY(inode, n_pasted_size)) {
+	pathrelse(p_s_search_path);
+	return -EDQUOT;
+    }
+    init_tb_struct(th, &s_paste_balance, th->t_super, p_s_search_path, n_pasted_size);
+#ifdef DISPLACE_NEW_PACKING_LOCALITIES
+    s_paste_balance.key = p_s_key->on_disk_key;
+#endif
+
+    /* DQUOT_* can schedule, must check before the fix_nodes */
+    if (fs_changed(fs_gen, inode->i_sb)) {
+	goto search_again;
+    }
+
+    while ((retval = fix_nodes(M_PASTE, &s_paste_balance, NULL, p_c_body)) ==
+REPEAT_SEARCH ) {
+search_again:
+	/* file system changed while we were in the fix_nodes */
+	PROC_INFO_INC( th -> t_super, paste_into_item_restarted );
+	retval = search_for_position_by_key (th->t_super, p_s_key, p_s_search_path);
+	if (retval == IO_ERROR) {
+	    retval = -EIO ;
+	    goto error_out ;
+	}
+	if (retval == POSITION_FOUND) {
+	    reiserfs_warning (inode->i_sb, "PAP-5710: reiserfs_paste_into_item: entry or pasted byte (%K) exists", p_s_key);
+	    retval = -EEXIST ;
+	    goto error_out ;
+	}
+	
+#ifdef CONFIG_REISERFS_CHECK
+	check_research_for_paste (p_s_search_path, p_s_key);
+#endif
+    }
+
+    /* Perform balancing after all resources are collected by fix_nodes, and
+       accessing them will not risk triggering schedule. */
+    if ( retval == CARRY_ON ) {
+	do_balance(&s_paste_balance, NULL/*ih*/, p_c_body, M_PASTE);
+	return 0;
+    }
+    retval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;
+error_out:
+    /* this also releases the path */
+    unfix_nodes(&s_paste_balance);
+#ifdef REISERQUOTA_DEBUG
+    reiserfs_debug (inode->i_sb, REISERFS_DEBUG_CODE, "reiserquota paste_into_item(): freeing %u id=%u type=%c", n_pasted_size, inode->i_uid, key2type(&(p_s_key->on_disk_key)));
+#endif
+    DQUOT_FREE_SPACE_NODIRTY(inode, n_pasted_size);
+    return retval ;
+}
+
+
+/* Insert new item into the buffer at the path. */
+int reiserfs_insert_item(struct reiserfs_transaction_handle *th, 
+			 struct path         * 	p_s_path,         /* Path to the inserteded item.         */
+			 const struct cpu_key      * key,
+			 struct item_head    * 	p_s_ih,           /* Pointer to the item header to insert.*/
+			 struct inode        * inode,
+			 const char          * 	p_c_body)         /* Pointer to the bytes to insert.      */
+{
+    struct tree_balance s_ins_balance;
+    int                 retval;
+    int fs_gen = 0 ;
+    int quota_bytes = 0 ;
+
+    BUG_ON (!th->t_trans_id);
+
+    if (inode) {      /* Do we count quotas for item? */
+	fs_gen = get_generation(inode->i_sb);
+	quota_bytes = ih_item_len(p_s_ih);
+
+	/* hack so the quota code doesn't have to guess if the file has
+	 ** a tail, links are always tails, so there's no guessing needed
+	 */
+	if (!S_ISLNK (inode->i_mode) && is_direct_le_ih(p_s_ih)) {
+	    quota_bytes = inode->i_sb->s_blocksize + UNFM_P_SIZE ;
+	}
+#ifdef REISERQUOTA_DEBUG
+	reiserfs_debug (inode->i_sb, REISERFS_DEBUG_CODE, "reiserquota insert_item(): allocating %u id=%u type=%c", quota_bytes, inode->i_uid, head2type(p_s_ih));
+#endif
+	/* We can't dirty inode here. It would be immediately written but
+	 * appropriate stat item isn't inserted yet... */
+	if (DQUOT_ALLOC_SPACE_NODIRTY(inode, quota_bytes)) {
+	    pathrelse(p_s_path);
+	    return -EDQUOT;
+	}
+    }
+    init_tb_struct(th, &s_ins_balance, th->t_super, p_s_path, IH_SIZE + ih_item_len(p_s_ih));
+#ifdef DISPLACE_NEW_PACKING_LOCALITIES
+    s_ins_balance.key = key->on_disk_key;
+#endif
+    /* DQUOT_* can schedule, must check to be sure calling fix_nodes is safe */
+    if (inode && fs_changed(fs_gen, inode->i_sb)) {
+	goto search_again;
+    }
+
+    while ( (retval = fix_nodes(M_INSERT, &s_ins_balance, p_s_ih, p_c_body)) == REPEAT_SEARCH) {
+search_again:
+	/* file system changed while we were in the fix_nodes */
+	PROC_INFO_INC( th -> t_super, insert_item_restarted );
+	retval = search_item (th->t_super, key, p_s_path);
+	if (retval == IO_ERROR) {
+	    retval = -EIO;
+	    goto error_out ;
+	}
+	if (retval == ITEM_FOUND) {
+	    reiserfs_warning (th->t_super, "PAP-5760: reiserfs_insert_item: "
+			      "key %K already exists in the tree", key);
+	    retval = -EEXIST ;
+	    goto error_out; 
+	}
+    }
+
+    /* make balancing after all resources will be collected at a time */ 
+    if ( retval == CARRY_ON ) {
+	do_balance (&s_ins_balance, p_s_ih, p_c_body, M_INSERT);
+	return 0;
+    }
+
+    retval = (retval == NO_DISK_SPACE) ? -ENOSPC : -EIO;
+error_out:
+    /* also releases the path */
+    unfix_nodes(&s_ins_balance);
+#ifdef REISERQUOTA_DEBUG
+    reiserfs_debug (th->t_super, REISERFS_DEBUG_CODE, "reiserquota insert_item(): freeing %u id=%u type=%c", quota_bytes, inode->i_uid, head2type(p_s_ih));
+#endif
+    if (inode)
+	DQUOT_FREE_SPACE_NODIRTY(inode, quota_bytes) ;
+    return retval; 
+}
+
+
+
+
