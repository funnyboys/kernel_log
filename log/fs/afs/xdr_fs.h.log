commit b4d0d230ccfb5d1a9ea85da64aa584df7c148ee9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:08:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 36
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public licence as published by
      the free software foundation either version 2 of the licence or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 114 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170857.552531963@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/afs/xdr_fs.h b/fs/afs/xdr_fs.h
index aa21f3068d52..94f1f398eefa 100644
--- a/fs/afs/xdr_fs.h
+++ b/fs/afs/xdr_fs.h
@@ -1,12 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* AFS fileserver XDR types
  *
  * Copyright (C) 2018 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public Licence
- * as published by the Free Software Foundation; either version
- * 2 of the Licence, or (at your option) any later version.
  */
 
 #ifndef XDR_FS_H

commit 0031763698d197d779fcafe5685f6e7818b70d32
Author: David Howells <dhowells@redhat.com>
Date:   Fri Apr 6 14:17:25 2018 +0100

    afs: Adjust the directory XDR structures
    
    Adjust the AFS directory XDR structures in a number of superficial ways:
    
     (1) Rename them to all begin afs_xdr_.
    
     (2) Use u8 instead of uint8_t.
    
     (3) Mark the structures as __packed so they don't get rearranged by the
         compiler.
    
     (4) Rename the hdr member of afs_xdr_dir_block to meta.
    
     (5) Rename the pagehdr member of afs_xdr_dir_block to hdr.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/afs/xdr_fs.h b/fs/afs/xdr_fs.h
index 63e87ccbb55b..aa21f3068d52 100644
--- a/fs/afs/xdr_fs.h
+++ b/fs/afs/xdr_fs.h
@@ -51,53 +51,53 @@ struct afs_xdr_AFSFetchStatus {
 /*
  * Directory entry structure.
  */
-union afs_dirent {
+union afs_xdr_dirent {
 	struct {
-		uint8_t		valid;
-		uint8_t		unused[1];
+		u8		valid;
+		u8		unused[1];
 		__be16		hash_next;
 		__be32		vnode;
 		__be32		unique;
-		uint8_t		name[16];
-		uint8_t		overflow[4];	/* if any char of the name (inc
+		u8		name[16];
+		u8		overflow[4];	/* if any char of the name (inc
 						 * NUL) reaches here, consume
 						 * the next dirent too */
 	} u;
-	uint8_t	extended_name[32];
-};
+	u8			extended_name[32];
+} __packed;
 
 /*
- * Directory page header (one at the beginning of every 2048-byte chunk).
+ * Directory block header (one at the beginning of every 2048-byte block).
  */
-struct afs_dir_pagehdr {
+struct afs_xdr_dir_hdr {
 	__be16		npages;
 	__be16		magic;
 #define AFS_DIR_MAGIC htons(1234)
-	uint8_t		reserved;
-	uint8_t		bitmap[8];
-	uint8_t		pad[19];
-};
+	u8		reserved;
+	u8		bitmap[8];
+	u8		pad[19];
+} __packed;
 
 /*
  * Directory block layout
  */
-union afs_dir_block {
-	struct afs_dir_pagehdr	pagehdr;
+union afs_xdr_dir_block {
+	struct afs_xdr_dir_hdr		hdr;
 
 	struct {
-		struct afs_dir_pagehdr	pagehdr;
-		uint8_t			alloc_ctrs[AFS_DIR_MAX_BLOCKS];
+		struct afs_xdr_dir_hdr	hdr;
+		u8			alloc_ctrs[AFS_DIR_MAX_BLOCKS];
 		__be16			hashtable[AFS_DIR_HASHTBL_SIZE];
-	} hdr;
+	} meta;
 
-	union afs_dirent	dirents[AFS_DIR_SLOTS_PER_BLOCK];
-};
+	union afs_xdr_dirent	dirents[AFS_DIR_SLOTS_PER_BLOCK];
+} __packed;
 
 /*
  * Directory layout on a linux VM page.
  */
-struct afs_dir_page {
-	union afs_dir_block	blocks[AFS_DIR_BLOCKS_PER_PAGE];
+struct afs_xdr_dir_page {
+	union afs_xdr_dir_block	blocks[AFS_DIR_BLOCKS_PER_PAGE];
 };
 
 #endif /* XDR_FS_H */

commit 4ea219a839bf85cf774299e2f817e609ba7ef331
Author: David Howells <dhowells@redhat.com>
Date:   Fri Apr 6 14:17:25 2018 +0100

    afs: Split the directory content defs into a header
    
    Split the directory content definitions into a header file so that they can
    be used by multiple .c files.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/afs/xdr_fs.h b/fs/afs/xdr_fs.h
index 24e23e40c979..63e87ccbb55b 100644
--- a/fs/afs/xdr_fs.h
+++ b/fs/afs/xdr_fs.h
@@ -37,4 +37,67 @@ struct afs_xdr_AFSFetchStatus {
 	__be32	abort_code;
 } __packed;
 
+#define AFS_DIR_HASHTBL_SIZE	128
+#define AFS_DIR_DIRENT_SIZE	32
+#define AFS_DIR_SLOTS_PER_BLOCK	64
+#define AFS_DIR_BLOCK_SIZE	2048
+#define AFS_DIR_BLOCKS_PER_PAGE	(PAGE_SIZE / AFS_DIR_BLOCK_SIZE)
+#define AFS_DIR_MAX_SLOTS	65536
+#define AFS_DIR_BLOCKS_WITH_CTR	128
+#define AFS_DIR_MAX_BLOCKS	1023
+#define AFS_DIR_RESV_BLOCKS	1
+#define AFS_DIR_RESV_BLOCKS0	13
+
+/*
+ * Directory entry structure.
+ */
+union afs_dirent {
+	struct {
+		uint8_t		valid;
+		uint8_t		unused[1];
+		__be16		hash_next;
+		__be32		vnode;
+		__be32		unique;
+		uint8_t		name[16];
+		uint8_t		overflow[4];	/* if any char of the name (inc
+						 * NUL) reaches here, consume
+						 * the next dirent too */
+	} u;
+	uint8_t	extended_name[32];
+};
+
+/*
+ * Directory page header (one at the beginning of every 2048-byte chunk).
+ */
+struct afs_dir_pagehdr {
+	__be16		npages;
+	__be16		magic;
+#define AFS_DIR_MAGIC htons(1234)
+	uint8_t		reserved;
+	uint8_t		bitmap[8];
+	uint8_t		pad[19];
+};
+
+/*
+ * Directory block layout
+ */
+union afs_dir_block {
+	struct afs_dir_pagehdr	pagehdr;
+
+	struct {
+		struct afs_dir_pagehdr	pagehdr;
+		uint8_t			alloc_ctrs[AFS_DIR_MAX_BLOCKS];
+		__be16			hashtable[AFS_DIR_HASHTBL_SIZE];
+	} hdr;
+
+	union afs_dirent	dirents[AFS_DIR_SLOTS_PER_BLOCK];
+};
+
+/*
+ * Directory layout on a linux VM page.
+ */
+struct afs_dir_page {
+	union afs_dir_block	blocks[AFS_DIR_BLOCKS_PER_PAGE];
+};
+
 #endif /* XDR_FS_H */

commit dd9fbcb8e10349fbd640aaa5942455912004f284
Author: David Howells <dhowells@redhat.com>
Date:   Fri Apr 6 14:17:24 2018 +0100

    afs: Rearrange status mapping
    
    Rearrange the AFSFetchStatus to inode attribute mapping code in a number of
    ways:
    
     (1) Use an XDR structure rather than a series of incremented pointer
         accesses when decoding an AFSFetchStatus object.  This allows
         out-of-order decode.
    
     (2) Don't store the if_version value but rather just check it and abort if
         it's not something we can handle.
    
     (3) Store the owner and group in the status record as raw values rather
         than converting them to kuid/kgid.  Do that when they're mapped into
         i_uid/i_gid.
    
     (4) Validate the type and abort code up front and abort if they're wrong.
    
     (5) Split the inode attribute setting out into its own function from the
         XDR decode of an AFSFetchStatus object.  This allows it to be called
         from elsewhere too.
    
     (6) Differentiate changes to data from changes to metadata.
    
     (7) Use the split-out attribute mapping function from afs_iget().
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/afs/xdr_fs.h b/fs/afs/xdr_fs.h
new file mode 100644
index 000000000000..24e23e40c979
--- /dev/null
+++ b/fs/afs/xdr_fs.h
@@ -0,0 +1,40 @@
+/* AFS fileserver XDR types
+ *
+ * Copyright (C) 2018 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+
+#ifndef XDR_FS_H
+#define XDR_FS_H
+
+struct afs_xdr_AFSFetchStatus {
+	__be32	if_version;
+#define AFS_FSTATUS_VERSION	1
+	__be32	type;
+	__be32	nlink;
+	__be32	size_lo;
+	__be32	data_version_lo;
+	__be32	author;
+	__be32	owner;
+	__be32	caller_access;
+	__be32	anon_access;
+	__be32	mode;
+	__be32	parent_vnode;
+	__be32	parent_unique;
+	__be32	seg_size;
+	__be32	mtime_client;
+	__be32	mtime_server;
+	__be32	group;
+	__be32	sync_counter;
+	__be32	data_version_hi;
+	__be32	lock_count;
+	__be32	size_hi;
+	__be32	abort_code;
+} __packed;
+
+#endif /* XDR_FS_H */
