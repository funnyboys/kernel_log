commit 70fbdfef4ba63eeef83b2c94eac9a5a9f913e442
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 5 11:34:35 2020 -0700

    sysfs: remove redundant __compat_only_sysfs_link_entry_to_kobj fn
    
    Commit 9255782f7061 ("sysfs: Wrap __compat_only_sysfs_link_entry_to_kobj
    function to change the symlink name") made this function a wrapper
    around a new non-underscored function, which is a bit odd.  The normal
    naming convention is the other way around: the underscored function is
    the wrappee, and the non-underscored function is the wrapper.
    
    There's only one single user (well, two call-sites in that user) of the
    more limited double underscore version of this function, so just remove
    the oddly named wrapper entirely and just add the extra NULL argument to
    the user.
    
    I considered just doing that in the merge, but that tends to make
    history really hard to read.
    
    Link: https://lore.kernel.org/lkml/CAHk-=wgkkmNV5tMzQDmPAQuNJBuMcry--Jb+h8H1o4RA3kF7QQ@mail.gmail.com/
    Cc: Sourabh Jain <sourabhjain@linux.ibm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index fbb117757c52..64e6a6698935 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -415,22 +415,6 @@ void sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,
 }
 EXPORT_SYMBOL_GPL(sysfs_remove_link_from_group);
 
-/**
- * __compat_only_sysfs_link_entry_to_kobj - add a symlink to a kobject pointing
- * to a group or an attribute
- * @kobj:		The kobject containing the group.
- * @target_kobj:	The target kobject.
- * @target_name:	The name of the target group or attribute.
- */
-int __compat_only_sysfs_link_entry_to_kobj(struct kobject *kobj,
-				      struct kobject *target_kobj,
-				      const char *target_name)
-{
-	return compat_only_sysfs_link_entry_to_kobj(kobj, target_kobj,
-						    target_name, NULL);
-}
-EXPORT_SYMBOL_GPL(__compat_only_sysfs_link_entry_to_kobj);
-
 /**
  * compat_only_sysfs_link_entry_to_kobj - add a symlink to a kobject pointing
  * to a group or an attribute

commit d38c07afc356ddebaa3ed8ecb3f553340e05c969
Merge: 31c0aa87ec8a c17eb4dca5a3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 5 11:12:59 2020 -0700

    Merge tag 'powerpc-5.7-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux
    
    Pull powerpc updates from Michael Ellerman:
     "Slightly late as I had to rebase mid-week to insert a bug fix:
    
       - A large series from Nick for 64-bit to further rework our exception
         vectors, and rewrite portions of the syscall entry/exit and
         interrupt return in C. The result is much easier to follow code
         that is also faster in general.
    
       - Cleanup of our ptrace code to split various parts out that had
         become badly intertwined with #ifdefs over the years.
    
       - Changes to our NUMA setup under the PowerVM hypervisor which should
         hopefully avoid non-sensical topologies which can lead to warnings
         from the workqueue code and other problems.
    
       - MAINTAINERS updates to remove some of our old orphan entries and
         update the status of others.
    
       - Quite a few other small changes and fixes all over the map.
    
      Thanks to: Abdul Haleem, afzal mohammed, Alexey Kardashevskiy, Andrew
      Donnellan, Aneesh Kumar K.V, Balamuruhan S, Cédric Le Goater, Chen
      Zhou, Christophe JAILLET, Christophe Leroy, Christoph Hellwig, Clement
      Courbet, Daniel Axtens, David Gibson, Douglas Miller, Fabiano Rosas,
      Fangrui Song, Ganesh Goudar, Gautham R. Shenoy, Greg Kroah-Hartman,
      Greg Kurz, Gustavo Luiz Duarte, Hari Bathini, Ilie Halip, Jan Kara,
      Joe Lawrence, Joe Perches, Kajol Jain, Larry Finger, Laurentiu Tudor,
      Leonardo Bras, Libor Pechacek, Madhavan Srinivasan, Mahesh Salgaonkar,
      Masahiro Yamada, Masami Hiramatsu, Mauricio Faria de Oliveira, Michael
      Neuling, Michal Suchanek, Mike Rapoport, Nageswara R Sastry, Nathan
      Chancellor, Nathan Lynch, Naveen N. Rao, Nicholas Piggin, Nick
      Desaulniers, Oliver O'Halloran, Po-Hsu Lin, Pratik Rajesh Sampat,
      Rasmus Villemoes, Ravi Bangoria, Roman Bolshakov, Sam Bobroff,
      Sandipan Das, Santosh S, Sedat Dilek, Segher Boessenkool, Shilpasri G
      Bhat, Sourabh Jain, Srikar Dronamraju, Stephen Rothwell, Tyrel
      Datwyler, Vaibhav Jain, YueHaibing"
    
    * tag 'powerpc-5.7-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux: (158 commits)
      powerpc: Make setjmp/longjmp signature standard
      powerpc/cputable: Remove unnecessary copy of cpu_spec->oprofile_type
      powerpc: Suppress .eh_frame generation
      powerpc: Drop -fno-dwarf2-cfi-asm
      powerpc/32: drop unused ISA_DMA_THRESHOLD
      powerpc/powernv: Add documentation for the opal sensor_groups sysfs interfaces
      selftests/powerpc: Fix try-run when source tree is not writable
      powerpc/vmlinux.lds: Explicitly retain .gnu.hash
      powerpc/ptrace: move ptrace_triggered() into hw_breakpoint.c
      powerpc/ptrace: create ppc_gethwdinfo()
      powerpc/ptrace: create ptrace_get_debugreg()
      powerpc/ptrace: split out ADV_DEBUG_REGS related functions.
      powerpc/ptrace: move register viewing functions out of ptrace.c
      powerpc/ptrace: split out TRANSACTIONAL_MEM related functions.
      powerpc/ptrace: split out SPE related functions.
      powerpc/ptrace: split out ALTIVEC related functions.
      powerpc/ptrace: split out VSX related functions.
      powerpc/ptrace: drop PARAMETER_SAVE_AREA_OFFSET
      powerpc/ptrace: drop unnecessary #ifdefs CONFIG_PPC64
      powerpc/ptrace: remove unused header includes
      ...

commit 303a42769c4c4d8e5e3ad928df87eb36f8c1fa60
Author: Christian Brauner <christian.brauner@ubuntu.com>
Date:   Thu Feb 27 04:37:13 2020 +0100

    sysfs: add sysfs_group{s}_change_owner()
    
    Add helpers to change the owner of sysfs groups.
    This function will be used to correctly account for kobject ownership
    changes, e.g. when moving network devices between network namespaces.
    
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index c4ab045926b7..5afe0e7ff7cd 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -13,6 +13,7 @@
 #include <linux/dcache.h>
 #include <linux/namei.h>
 #include <linux/err.h>
+#include <linux/fs.h>
 #include "sysfs.h"
 
 
@@ -457,3 +458,117 @@ int __compat_only_sysfs_link_entry_to_kobj(struct kobject *kobj,
 	return PTR_ERR_OR_ZERO(link);
 }
 EXPORT_SYMBOL_GPL(__compat_only_sysfs_link_entry_to_kobj);
+
+static int sysfs_group_attrs_change_owner(struct kernfs_node *grp_kn,
+					  const struct attribute_group *grp,
+					  struct iattr *newattrs)
+{
+	struct kernfs_node *kn;
+	int error;
+
+	if (grp->attrs) {
+		struct attribute *const *attr;
+
+		for (attr = grp->attrs; *attr; attr++) {
+			kn = kernfs_find_and_get(grp_kn, (*attr)->name);
+			if (!kn)
+				return -ENOENT;
+
+			error = kernfs_setattr(kn, newattrs);
+			kernfs_put(kn);
+			if (error)
+				return error;
+		}
+	}
+
+	if (grp->bin_attrs) {
+		struct bin_attribute *const *bin_attr;
+
+		for (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++) {
+			kn = kernfs_find_and_get(grp_kn, (*bin_attr)->attr.name);
+			if (!kn)
+				return -ENOENT;
+
+			error = kernfs_setattr(kn, newattrs);
+			kernfs_put(kn);
+			if (error)
+				return error;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * sysfs_group_change_owner - change owner of an attribute group.
+ * @kobj:	The kobject containing the group.
+ * @grp:	The attribute group.
+ * @kuid:	new owner's kuid
+ * @kgid:	new owner's kgid
+ *
+ * Returns 0 on success or error code on failure.
+ */
+int sysfs_group_change_owner(struct kobject *kobj,
+			     const struct attribute_group *grp, kuid_t kuid,
+			     kgid_t kgid)
+{
+	struct kernfs_node *grp_kn;
+	int error;
+	struct iattr newattrs = {
+		.ia_valid = ATTR_UID | ATTR_GID,
+		.ia_uid = kuid,
+		.ia_gid = kgid,
+	};
+
+	if (!kobj->state_in_sysfs)
+		return -EINVAL;
+
+	if (grp->name) {
+		grp_kn = kernfs_find_and_get(kobj->sd, grp->name);
+	} else {
+		kernfs_get(kobj->sd);
+		grp_kn = kobj->sd;
+	}
+	if (!grp_kn)
+		return -ENOENT;
+
+	error = kernfs_setattr(grp_kn, &newattrs);
+	if (!error)
+		error = sysfs_group_attrs_change_owner(grp_kn, grp, &newattrs);
+
+	kernfs_put(grp_kn);
+
+	return error;
+}
+EXPORT_SYMBOL_GPL(sysfs_group_change_owner);
+
+/**
+ * sysfs_groups_change_owner - change owner of a set of attribute groups.
+ * @kobj:	The kobject containing the groups.
+ * @groups:	The attribute groups.
+ * @kuid:	new owner's kuid
+ * @kgid:	new owner's kgid
+ *
+ * Returns 0 on success or error code on failure.
+ */
+int sysfs_groups_change_owner(struct kobject *kobj,
+			      const struct attribute_group **groups,
+			      kuid_t kuid, kgid_t kgid)
+{
+	int error = 0, i;
+
+	if (!kobj->state_in_sysfs)
+		return -EINVAL;
+
+	if (!groups)
+		return 0;
+
+	for (i = 0; groups[i]; i++) {
+		error = sysfs_group_change_owner(kobj, groups[i], kuid, kgid);
+		if (error)
+			break;
+	}
+
+	return error;
+}
+EXPORT_SYMBOL_GPL(sysfs_groups_change_owner);

commit 9255782f70614c89b1a15ec6997c4b72ce9e630a
Author: Sourabh Jain <sourabhjain@linux.ibm.com>
Date:   Wed Dec 11 21:39:06 2019 +0530

    sysfs: Wrap __compat_only_sysfs_link_entry_to_kobj function to change the symlink name
    
    The __compat_only_sysfs_link_entry_to_kobj function creates a symlink
    to a kobject but doesn't provide an option to change the symlink file
    name.
    
    This patch adds a wrapper function compat_only_sysfs_link_entry_to_kobj
    that extends the __compat_only_sysfs_link_entry_to_kobj functionality
    which allows function caller to customize the symlink name.
    
    Signed-off-by: Sourabh Jain <sourabhjain@linux.ibm.com>
    [mpe: Fix compile error when CONFIG_SYSFS=n]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20191211160910.21656-3-sourabhjain@linux.ibm.com

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index c4ab045926b7..1e2a096057bc 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -424,6 +424,25 @@ EXPORT_SYMBOL_GPL(sysfs_remove_link_from_group);
 int __compat_only_sysfs_link_entry_to_kobj(struct kobject *kobj,
 				      struct kobject *target_kobj,
 				      const char *target_name)
+{
+	return compat_only_sysfs_link_entry_to_kobj(kobj, target_kobj,
+						    target_name, NULL);
+}
+EXPORT_SYMBOL_GPL(__compat_only_sysfs_link_entry_to_kobj);
+
+/**
+ * compat_only_sysfs_link_entry_to_kobj - add a symlink to a kobject pointing
+ * to a group or an attribute
+ * @kobj:		The kobject containing the group.
+ * @target_kobj:	The target kobject.
+ * @target_name:	The name of the target group or attribute.
+ * @symlink_name:	The name of the symlink file (target_name will be
+ *			considered if symlink_name is NULL).
+ */
+int compat_only_sysfs_link_entry_to_kobj(struct kobject *kobj,
+					 struct kobject *target_kobj,
+					 const char *target_name,
+					 const char *symlink_name)
 {
 	struct kernfs_node *target;
 	struct kernfs_node *entry;
@@ -448,12 +467,15 @@ int __compat_only_sysfs_link_entry_to_kobj(struct kobject *kobj,
 		return -ENOENT;
 	}
 
-	link = kernfs_create_link(kobj->sd, target_name, entry);
+	if (!symlink_name)
+		symlink_name = target_name;
+
+	link = kernfs_create_link(kobj->sd, symlink_name, entry);
 	if (PTR_ERR(link) == -EEXIST)
-		sysfs_warn_dup(kobj->sd, target_name);
+		sysfs_warn_dup(kobj->sd, symlink_name);
 
 	kernfs_put(entry);
 	kernfs_put(target);
 	return PTR_ERR_OR_ZERO(link);
 }
-EXPORT_SYMBOL_GPL(__compat_only_sysfs_link_entry_to_kobj);
+EXPORT_SYMBOL_GPL(compat_only_sysfs_link_entry_to_kobj);

commit 45586c7078d42b932c5399953d21746800083691
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Feb 3 17:37:45 2020 -0800

    treewide: remove redundant IS_ERR() before error code check
    
    'PTR_ERR(p) == -E*' is a stronger condition than IS_ERR(p).
    Hence, IS_ERR(p) is unneeded.
    
    The semantic patch that generates this commit is as follows:
    
    // <smpl>
    @@
    expression ptr;
    constant error_code;
    @@
    -IS_ERR(ptr) && (PTR_ERR(ptr) == - error_code)
    +PTR_ERR(ptr) == - error_code
    // </smpl>
    
    Link: http://lkml.kernel.org/r/20200106045833.1725-1-masahiroy@kernel.org
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>
    Cc: Julia Lawall <julia.lawall@lip6.fr>
    Acked-by: Stephen Boyd <sboyd@kernel.org> [drivers/clk/clk.c]
    Acked-by: Bartosz Golaszewski <bgolaszewski@baylibre.com> [GPIO]
    Acked-by: Wolfram Sang <wsa@the-dreams.de> [drivers/i2c]
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com> [acpi/scan.c]
    Acked-by: Rob Herring <robh@kernel.org>
    Cc: Eric Biggers <ebiggers@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index d41c21fef138..c4ab045926b7 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -449,7 +449,7 @@ int __compat_only_sysfs_link_entry_to_kobj(struct kobject *kobj,
 	}
 
 	link = kernfs_create_link(kobj->sd, target_name, entry);
-	if (IS_ERR(link) && PTR_ERR(link) == -EEXIST)
+	if (PTR_ERR(link) == -EEXIST)
 		sysfs_warn_dup(kobj->sd, target_name);
 
 	kernfs_put(entry);

commit aac1f7f95f115d5a5329be05b80022e72df7d080
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Sun May 12 17:55:10 2019 +0200

    sysfs: Add sysfs_update_groups function
    
    Adding sysfs_update_groups function to update
    multiple groups.
    
      sysfs_update_groups - given a directory kobject, create a bunch of attribute groups
      @kobj:      The kobject to update the group on
      @groups:    The attribute groups to update, NULL terminated
    
    This function update a bunch of attribute groups.  If an error occurs when
    updating a group, all previously updated groups will be removed together
    with already existing (not updated) attributes.
    
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20190512155518.21468-2-jolsa@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 57038604d4a8..d41c21fef138 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -175,6 +175,26 @@ int sysfs_create_group(struct kobject *kobj,
 }
 EXPORT_SYMBOL_GPL(sysfs_create_group);
 
+static int internal_create_groups(struct kobject *kobj, int update,
+				  const struct attribute_group **groups)
+{
+	int error = 0;
+	int i;
+
+	if (!groups)
+		return 0;
+
+	for (i = 0; groups[i]; i++) {
+		error = internal_create_group(kobj, update, groups[i]);
+		if (error) {
+			while (--i >= 0)
+				sysfs_remove_group(kobj, groups[i]);
+			break;
+		}
+	}
+	return error;
+}
+
 /**
  * sysfs_create_groups - given a directory kobject, create a bunch of attribute groups
  * @kobj:	The kobject to create the group on
@@ -191,24 +211,28 @@ EXPORT_SYMBOL_GPL(sysfs_create_group);
 int sysfs_create_groups(struct kobject *kobj,
 			const struct attribute_group **groups)
 {
-	int error = 0;
-	int i;
-
-	if (!groups)
-		return 0;
-
-	for (i = 0; groups[i]; i++) {
-		error = sysfs_create_group(kobj, groups[i]);
-		if (error) {
-			while (--i >= 0)
-				sysfs_remove_group(kobj, groups[i]);
-			break;
-		}
-	}
-	return error;
+	return internal_create_groups(kobj, 0, groups);
 }
 EXPORT_SYMBOL_GPL(sysfs_create_groups);
 
+/**
+ * sysfs_update_groups - given a directory kobject, create a bunch of attribute groups
+ * @kobj:	The kobject to update the group on
+ * @groups:	The attribute groups to update, NULL terminated
+ *
+ * This function update a bunch of attribute groups.  If an error occurs when
+ * updating a group, all previously updated groups will be removed together
+ * with already existing (not updated) attributes.
+ *
+ * Returns 0 on success or error code from sysfs_update_group on failure.
+ */
+int sysfs_update_groups(struct kobject *kobj,
+			const struct attribute_group **groups)
+{
+	return internal_create_groups(kobj, 1, groups);
+}
+EXPORT_SYMBOL_GPL(sysfs_update_groups);
+
 /**
  * sysfs_update_group - given a directory kobject, update an attribute group
  * @kobj:	The kobject to update the group on

commit de96e9fea7ba56042f105b6fe163447b280eb800
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jan 3 10:23:47 2019 +0100

    sysfs: convert BUG_ON to WARN_ON
    
    It's rude to crash the system just because the developer did something
    wrong, as it prevents them from usually even seeing what went wrong.
    
    So convert the few BUG_ON() calls that have snuck into the sysfs code
    over the years to WARN_ON() to make it more "friendly".  All of these
    are able to be recovered from, so it makes no sense to crash.
    
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 1eb2d6307663..57038604d4a8 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -112,7 +112,8 @@ static int internal_create_group(struct kobject *kobj, int update,
 	kgid_t gid;
 	int error;
 
-	BUG_ON(!kobj || (!update && !kobj->sd));
+	if (WARN_ON(!kobj || (!update && !kobj->sd)))
+		return -EINVAL;
 
 	/* Updates may happen before the object has been instantiated */
 	if (unlikely(update && !kobj->sd))

commit a18d783fedfe6f9b720afe901db9501ce116ed81
Merge: d5acba26bfa0 d2fc88a61b4e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 18 11:44:53 2018 -0700

    Merge tag 'driver-core-4.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here are all of the driver core and related patches for 4.19-rc1.
    
      Nothing huge here, just a number of small cleanups and the ability to
      now stop the deferred probing after init happens.
    
      All of these have been in linux-next for a while with only a merge
      issue reported"
    
    * tag 'driver-core-4.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (21 commits)
      base: core: Remove WARN_ON from link dependencies check
      drivers/base: stop new probing during shutdown
      drivers: core: Remove glue dirs from sysfs earlier
      driver core: remove unnecessary function extern declare
      sysfs.h: fix non-kernel-doc comment
      PM / Domains: Stop deferring probe at the end of initcall
      iommu: Remove IOMMU_OF_DECLARE
      iommu: Stop deferring probe at end of initcalls
      pinctrl: Support stopping deferred probe after initcalls
      dt-bindings: pinctrl: add a 'pinctrl-use-default' property
      driver core: allow stopping deferred probe after init
      driver core: add a debugfs entry to show deferred devices
      sysfs: Fix internal_create_group() for named group updates
      base: fix order of OF initialization
      linux/device.h: fix kernel-doc notation warning
      Documentation: update firmware loader fallback reference
      kobject: Replace strncpy with memcpy
      drivers: base: cacheinfo: use OF property_read_u32 instead of get_property,read_number
      kernfs: Replace strncpy with memcpy
      device: Add #define dev_fmt similar to #define pr_fmt
      ...

commit 5f81880d5204ee2388fd9a75bb850ccd526885b7
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Jul 20 21:56:48 2018 +0000

    sysfs, kobject: allow creating kobject belonging to arbitrary users
    
    Normally kobjects and their sysfs representation belong to global root,
    however it is not necessarily the case for objects in separate namespaces.
    For example, objects in separate network namespace logically belong to the
    container's root and not global root.
    
    This change lays groundwork for allowing network namespace objects
    ownership to be transferred to container's root user by defining
    get_ownership() callback in ktype structure and using it in sysfs code to
    retrieve desired uid/gid when creating sysfs objects for given kobject.
    
    Co-Developed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 4802ec0e1e3a..c7a716c4acc9 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -31,6 +31,7 @@ static void remove_files(struct kernfs_node *parent,
 }
 
 static int create_files(struct kernfs_node *parent, struct kobject *kobj,
+			kuid_t uid, kgid_t gid,
 			const struct attribute_group *grp, int update)
 {
 	struct attribute *const *attr;
@@ -60,7 +61,7 @@ static int create_files(struct kernfs_node *parent, struct kobject *kobj,
 
 			mode &= SYSFS_PREALLOC | 0664;
 			error = sysfs_add_file_mode_ns(parent, *attr, false,
-						       mode, NULL);
+						       mode, uid, gid, NULL);
 			if (unlikely(error))
 				break;
 		}
@@ -90,7 +91,8 @@ static int create_files(struct kernfs_node *parent, struct kobject *kobj,
 			mode &= SYSFS_PREALLOC | 0664;
 			error = sysfs_add_file_mode_ns(parent,
 					&(*bin_attr)->attr, true,
-					mode, NULL);
+					mode,
+					uid, gid, NULL);
 			if (error)
 				break;
 		}
@@ -106,6 +108,8 @@ static int internal_create_group(struct kobject *kobj, int update,
 				 const struct attribute_group *grp)
 {
 	struct kernfs_node *kn;
+	kuid_t uid;
+	kgid_t gid;
 	int error;
 
 	BUG_ON(!kobj || (!update && !kobj->sd));
@@ -118,9 +122,11 @@ static int internal_create_group(struct kobject *kobj, int update,
 			kobj->name, grp->name ?: "");
 		return -EINVAL;
 	}
+	kobject_get_ownership(kobj, &uid, &gid);
 	if (grp->name) {
-		kn = kernfs_create_dir(kobj->sd, grp->name,
-				       S_IRWXU | S_IRUGO | S_IXUGO, kobj);
+		kn = kernfs_create_dir_ns(kobj->sd, grp->name,
+					  S_IRWXU | S_IRUGO | S_IXUGO,
+					  uid, gid, kobj, NULL);
 		if (IS_ERR(kn)) {
 			if (PTR_ERR(kn) == -EEXIST)
 				sysfs_warn_dup(kobj->sd, grp->name);
@@ -129,7 +135,7 @@ static int internal_create_group(struct kobject *kobj, int update,
 	} else
 		kn = kobj->sd;
 	kernfs_get(kn);
-	error = create_files(kn, kobj, grp, update);
+	error = create_files(kn, kobj, uid, gid, grp, update);
 	if (error) {
 		if (grp->name)
 			kernfs_remove(kn);
@@ -281,6 +287,8 @@ int sysfs_merge_group(struct kobject *kobj,
 		       const struct attribute_group *grp)
 {
 	struct kernfs_node *parent;
+	kuid_t uid;
+	kgid_t gid;
 	int error = 0;
 	struct attribute *const *attr;
 	int i;
@@ -289,8 +297,11 @@ int sysfs_merge_group(struct kobject *kobj,
 	if (!parent)
 		return -ENOENT;
 
+	kobject_get_ownership(kobj, &uid, &gid);
+
 	for ((i = 0, attr = grp->attrs); *attr && !error; (++i, ++attr))
-		error = sysfs_add_file(parent, *attr, false);
+		error = sysfs_add_file_mode_ns(parent, *attr, false,
+					       (*attr)->mode, uid, gid, NULL);
 	if (error) {
 		while (--i >= 0)
 			kernfs_remove_by_name(parent, (*--attr)->name);

commit c855cf2759d27142f771173d9fd8e7fdf9cf5138
Author: Rajat Jain <rajatja@google.com>
Date:   Sat Jun 16 10:49:46 2018 -0700

    sysfs: Fix internal_create_group() for named group updates
    
    There are a couple of problems with named group updates in the code
    today:
    
    * sysfs_update_group() will always fail for a named group, because
      internal_create_group() will try to create a new sysfs directory
      unconditionally, which will ofcourse fail with -EEXIST.
    
    * We can leak the kernfs_node for grp->name if some one tries to:
      - rename a group (change grp->name), or
      - update a named group, to an unnamed group
    
    It appears that the whole purpose of sysfs_update_group() was to
    allow changing the permissions or visibility of attributes and not
    the names. So make it clear in the comments, and allow it to update
    an existing named group.
    
    Signed-off-by: Rajat Jain <rajatja@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 4802ec0e1e3a..38240410f831 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -119,12 +119,22 @@ static int internal_create_group(struct kobject *kobj, int update,
 		return -EINVAL;
 	}
 	if (grp->name) {
-		kn = kernfs_create_dir(kobj->sd, grp->name,
-				       S_IRWXU | S_IRUGO | S_IXUGO, kobj);
-		if (IS_ERR(kn)) {
-			if (PTR_ERR(kn) == -EEXIST)
-				sysfs_warn_dup(kobj->sd, grp->name);
-			return PTR_ERR(kn);
+		if (update) {
+			kn = kernfs_find_and_get(kobj->sd, grp->name);
+			if (!kn) {
+				pr_warn("Can't update unknown attr grp name: %s/%s\n",
+					kobj->name, grp->name);
+				return -EINVAL;
+			}
+		} else {
+			kn = kernfs_create_dir(kobj->sd, grp->name,
+					       S_IRWXU | S_IRUGO | S_IXUGO,
+					       kobj);
+			if (IS_ERR(kn)) {
+				if (PTR_ERR(kn) == -EEXIST)
+					sysfs_warn_dup(kobj->sd, grp->name);
+				return PTR_ERR(kn);
+			}
 		}
 	} else
 		kn = kobj->sd;
@@ -135,6 +145,10 @@ static int internal_create_group(struct kobject *kobj, int update,
 			kernfs_remove(kn);
 	}
 	kernfs_put(kn);
+
+	if (grp->name && update)
+		kernfs_put(kn);
+
 	return error;
 }
 
@@ -199,7 +213,8 @@ EXPORT_SYMBOL_GPL(sysfs_create_groups);
  * of the attribute files being created already exist.  Furthermore,
  * if the visibility of the files has changed through the is_visible()
  * callback, it will update the permissions and add or remove the
- * relevant files.
+ * relevant files. Changing a group's name (subdirectory name under
+ * kobj's directory in sysfs) is not allowed.
  *
  * The primary use for this function is to call it after making a change
  * that affects group visibility.

commit 619daeeeb80f39bb037434598e489a88db14a95b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 22 16:18:13 2018 +0100

    sysfs: use SPDX identifiers
    
    Move the license "mark" of the sysfs files to be in SPDX form, instead
    of the custom text that it currently is in.  This is in a quest to get
    rid of the 700+ different ways we say "GPLv2" in the kernel tree.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 3f8efe8f387b..4802ec0e1e3a 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * fs/sysfs/group.c - Operations for adding/removing multiple files at once.
  *
@@ -5,9 +6,6 @@
  * Copyright (c) 2003 Open Source Development Lab
  * Copyright (c) 2013 Greg Kroah-Hartman
  * Copyright (c) 2013 The Linux Foundation
- *
- * This file is released undert the GPL v2.
- *
  */
 
 #include <linux/kobject.h>

commit 90b3d2f6c036042863c62a4314f0fce38cf395a4
Author: Vasyl Gomonovych <gomonovych@gmail.com>
Date:   Tue Nov 28 00:10:32 2017 +0100

    sysfs: Use PTR_ERR_OR_ZERO()
    
    Fix ptr_ret.cocci warnings:
    fs/sysfs/group.c:409:8-14: WARNING: PTR_ERR_OR_ZERO can be used
    
    Use PTR_ERR_OR_ZERO rather than if(IS_ERR(...)) + PTR_ERR
    
    Generated by: scripts/coccinelle/api/ptr_ret.cocci
    
    Signed-off-by: Vasyl Gomonovych <gomonovych@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index ac2de0ed69ad..3f8efe8f387b 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -406,6 +406,6 @@ int __compat_only_sysfs_link_entry_to_kobj(struct kobject *kobj,
 
 	kernfs_put(entry);
 	kernfs_put(target);
-	return IS_ERR(link) ? PTR_ERR(link) : 0;
+	return PTR_ERR_OR_ZERO(link);
 }
 EXPORT_SYMBOL_GPL(__compat_only_sysfs_link_entry_to_kobj);

commit 78618d395b65fadb2937a985308c3a4d2897ade2
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Mon Sep 19 10:14:54 2016 +0200

    sysfs print name of undiscoverable attribute group
    
    Print the name of an undiscoverable attribute group and not the
    pointer's address.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index dc1358b5ec95..ac2de0ed69ad 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -233,8 +233,8 @@ void sysfs_remove_group(struct kobject *kobj,
 		kn = kernfs_find_and_get(parent, grp->name);
 		if (!kn) {
 			WARN(!kn, KERN_WARNING
-			     "sysfs group %p not found for kobject '%s'\n",
-			     grp, kobject_name(kobj));
+			     "sysfs group '%s' not found for kobject '%s'\n",
+			     grp->name, kobject_name(kobj));
 			return;
 		}
 	} else {

commit 63f4f7e8df6c504f39c6493799b54775916030d6
Merge: 4bfc89d26a0d ebaf31c46cce
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 13 21:53:18 2015 -0800

    Merge tag 'chrome-platform-4.4' of git://git.kernel.org/pub/scm/linux/kernel/git/olof/chrome-platform
    
    Pull chrome platform updates from Olof Johansson:
     "Here's the branch of chrome platform changes for v4.4.  Some have been
      queued up for the full 4.3 release cycle since I forgot to send them
      in for that round (rebased early on to deal with fixes conflicts).
    
      Most of these enable EC communication stuff -- Pixel 2015 support,
      enabling building for ARM64 platforms, and a few fixes for memory
      leaks.
    
      There's also a patch in here to allow reading/writing the verified
      boot context, which depends on a sysfs patch acked by Greg"
    
    * tag 'chrome-platform-4.4' of git://git.kernel.org/pub/scm/linux/kernel/git/olof/chrome-platform:
      platform/chrome: Fix i2c-designware adapter name
      platform/chrome: Support reading/writing the vboot context
      sysfs: Support is_visible() on binary attributes
      platform/chrome: cros_ec: Fix possible leak in led_rgb_store()
      platform/chrome: cros_ec: Fix leak in sequence_store()
      platform/chrome: Enable Chrome platforms on 64-bit ARM
      platform/chrome: cros_ec_dev - Add a platform device ID table
      platform/chrome: cros_ec_lpc - Add support for Google Pixel 2
      platform/chrome: cros_ec_lpc - Use existing function to check EC result
      platform/chrome: Make depends on MFD_CROS_EC instead CROS_EC_PROTO
      Revert "platform/chrome: Don't make CHROME_PLATFORMS depends on X86 || ARM"

commit 37c1c04cca920de8a68285751b2c7b3d937ad50c
Author: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Date:   Wed Apr 22 19:36:06 2015 +0300

    sysfs: added __compat_only_sysfs_link_entry_to_kobj()
    
    Added a new function __compat_only_sysfs_link_group_to_kobj() that adds
    a symlink from attribute or group to a kobject. This needed for
    maintaining backwards compatibility with PPI attributes in the TPM
    driver.
    
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 39a019936768..e1236594fffe 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -352,3 +352,47 @@ void sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,
 	}
 }
 EXPORT_SYMBOL_GPL(sysfs_remove_link_from_group);
+
+/**
+ * __compat_only_sysfs_link_entry_to_kobj - add a symlink to a kobject pointing
+ * to a group or an attribute
+ * @kobj:		The kobject containing the group.
+ * @target_kobj:	The target kobject.
+ * @target_name:	The name of the target group or attribute.
+ */
+int __compat_only_sysfs_link_entry_to_kobj(struct kobject *kobj,
+				      struct kobject *target_kobj,
+				      const char *target_name)
+{
+	struct kernfs_node *target;
+	struct kernfs_node *entry;
+	struct kernfs_node *link;
+
+	/*
+	 * We don't own @target_kobj and it may be removed at any time.
+	 * Synchronize using sysfs_symlink_target_lock. See sysfs_remove_dir()
+	 * for details.
+	 */
+	spin_lock(&sysfs_symlink_target_lock);
+	target = target_kobj->sd;
+	if (target)
+		kernfs_get(target);
+	spin_unlock(&sysfs_symlink_target_lock);
+	if (!target)
+		return -ENOENT;
+
+	entry = kernfs_find_and_get(target_kobj->sd, target_name);
+	if (!entry) {
+		kernfs_put(target);
+		return -ENOENT;
+	}
+
+	link = kernfs_create_link(kobj->sd, target_name, entry);
+	if (IS_ERR(link) && PTR_ERR(link) == -EEXIST)
+		sysfs_warn_dup(kobj->sd, target_name);
+
+	kernfs_put(entry);
+	kernfs_put(target);
+	return IS_ERR(link) ? PTR_ERR(link) : 0;
+}
+EXPORT_SYMBOL_GPL(__compat_only_sysfs_link_entry_to_kobj);

commit 7f5028cf6190407b7a632b0f30b83187577824cc
Author: Emilio López <emilio.lopez@collabora.co.uk>
Date:   Mon Sep 21 10:38:20 2015 -0300

    sysfs: Support is_visible() on binary attributes
    
    According to the sysfs header file:
    
        "The returned value will replace static permissions defined in
         struct attribute or struct bin_attribute."
    
    but this isn't the case, as is_visible is only called on struct attribute
    only. This patch introduces a new is_bin_visible() function to implement
    the same functionality for binary attributes, and updates documentation
    accordingly.
    
    Note that to keep functionality and code similar to that of normal
    attributes, the mode is now checked as well to ensure it contains only
    read/write permissions or SYSFS_PREALLOC.
    
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Emilio López <emilio.lopez@collabora.co.uk>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 39a019936768..51b56e6d9537 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -73,13 +73,26 @@ static int create_files(struct kernfs_node *parent, struct kobject *kobj,
 	}
 
 	if (grp->bin_attrs) {
-		for (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++) {
+		for (i = 0, bin_attr = grp->bin_attrs; *bin_attr; i++, bin_attr++) {
+			umode_t mode = (*bin_attr)->attr.mode;
+
 			if (update)
 				kernfs_remove_by_name(parent,
 						(*bin_attr)->attr.name);
+			if (grp->is_bin_visible) {
+				mode = grp->is_bin_visible(kobj, *bin_attr, i);
+				if (!mode)
+					continue;
+			}
+
+			WARN(mode & ~(SYSFS_PREALLOC | 0664),
+			     "Attribute %s: Invalid permissions 0%o\n",
+			     (*bin_attr)->attr.name, mode);
+
+			mode &= SYSFS_PREALLOC | 0664;
 			error = sysfs_add_file_mode_ns(parent,
 					&(*bin_attr)->attr, true,
-					(*bin_attr)->attr.mode, NULL);
+					mode, NULL);
 			if (error)
 				break;
 		}

commit ed1dc8a89454218a2471f67284765e8c03bdfc6b
Author: Antonio Ospite <ao2@ao2.it>
Date:   Wed Apr 29 10:55:46 2015 +0200

    sysfs: disambiguate between "error code" and "failure" in comments
    
    The sentence "Returns 0 on success or error" might be misinterpreted as
    "the function will always returns 0", make it less ambiguous.
    
    Also, use the word "failure" as the contrary of "success".
    
    Signed-off-by: Antonio Ospite <ao2@ao2.it>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: linux-doc@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index b400c04371f0..39a019936768 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -135,7 +135,7 @@ static int internal_create_group(struct kobject *kobj, int update,
  * This function creates a group for the first time.  It will explicitly
  * warn and error if any of the attribute files being created already exist.
  *
- * Returns 0 on success or error.
+ * Returns 0 on success or error code on failure.
  */
 int sysfs_create_group(struct kobject *kobj,
 		       const struct attribute_group *grp)
@@ -155,7 +155,7 @@ EXPORT_SYMBOL_GPL(sysfs_create_group);
  * It will explicitly warn and error if any of the attribute files being
  * created already exist.
  *
- * Returns 0 on success or error code from sysfs_create_group on error.
+ * Returns 0 on success or error code from sysfs_create_group on failure.
  */
 int sysfs_create_groups(struct kobject *kobj,
 			const struct attribute_group **groups)
@@ -193,7 +193,7 @@ EXPORT_SYMBOL_GPL(sysfs_create_groups);
  * The primary use for this function is to call it after making a change
  * that affects group visibility.
  *
- * Returns 0 on success or error.
+ * Returns 0 on success or error code on failure.
  */
 int sysfs_update_group(struct kobject *kobj,
 		       const struct attribute_group *grp)

commit d8bf8c92e80fed9119eb222c7e5cc88acf57c12c
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Thu Mar 12 09:58:27 2015 -0400

    sysfs: Only accept read/write permissions for file attributes
    
    For sysfs file attributes, only read and write permissions make sense.
    Mask provided attribute permissions accordingly and send a warning
    to the console if invalid permission bits are set.
    
    This patch is originally from Guenter [1] and includes the fixup
    explained in the thread, that is printing permissions in octal format
    and limiting the scope of attributes to SYSFS_PREALLOC | 0664.
    
    [1] https://lkml.org/lkml/2015/1/19/599
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 3fdccd99a9d9..b400c04371f0 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -55,6 +55,12 @@ static int create_files(struct kernfs_node *parent, struct kobject *kobj,
 				if (!mode)
 					continue;
 			}
+
+			WARN(mode & ~(SYSFS_PREALLOC | 0664),
+			     "Attribute %s: Invalid permissions 0%o\n",
+			     (*attr)->name, mode);
+
+			mode &= SYSFS_PREALLOC | 0664;
 			error = sysfs_add_file_mode_ns(parent, *attr, false,
 						       mode, NULL);
 			if (unlikely(error))

commit da4759c73b0f1aac79f37bdb39ad2124439c30e7
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Thu Mar 12 09:58:26 2015 -0400

    sysfs: Use only return value from is_visible for the file mode
    
    Up to now, is_visible can only be used to either remove visibility
    of a file entirely or to add permissions, but not to reduce permissions.
    This makes it impossible, for example, to use DEVICE_ATTR_RW to define
    file attributes and reduce permissions to read-only.
    
    This behavior is undesirable and unnecessarily complicates code which
    needs to reduce permissions; instead of just returning the desired
    permissions, it has to ensure that the permissions in the attribute
    variable declaration only reflect the minimal permissions ever needed.
    
    Change semantics of is_visible to only use the permissions returned
    from it instead of oring the returned value with the hard-coded
    permissions.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 2554d8835b48..3fdccd99a9d9 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -41,7 +41,7 @@ static int create_files(struct kernfs_node *parent, struct kobject *kobj,
 
 	if (grp->attrs) {
 		for (i = 0, attr = grp->attrs; *attr && !error; i++, attr++) {
-			umode_t mode = 0;
+			umode_t mode = (*attr)->mode;
 
 			/*
 			 * In update mode, we're changing the permissions or
@@ -56,8 +56,7 @@ static int create_files(struct kernfs_node *parent, struct kobject *kobj,
 					continue;
 			}
 			error = sysfs_add_file_mode_ns(parent, *attr, false,
-						       (*attr)->mode | mode,
-						       NULL);
+						       mode, NULL);
 			if (unlikely(error))
 				break;
 		}

commit adf305f77878880fa5868a7179979da93be68d83
Author: Javi Merino <javi.merino@arm.com>
Date:   Thu Jan 15 16:17:45 2015 +0000

    sysfs: fix warning when creating a sysfs group without attributes
    
    When attempting to create a gropu without attrs, the warning prints the
    name of the group.  However, the check for name being a NULL pointer is
    wrong: it uses the pointer to the name when it's NULL.  Fix it to use
    the name if present, otherwise just put an empty string.
    
    Cc: Bruno Prémont <bonbons@linux-vserver.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Javi Merino <javi.merino@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 7d2a860ba788..2554d8835b48 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -99,7 +99,7 @@ static int internal_create_group(struct kobject *kobj, int update,
 		return -EINVAL;
 	if (!grp->attrs && !grp->bin_attrs) {
 		WARN(1, "sysfs: (bin_)attrs not set by subsystem for group: %s/%s\n",
-			kobj->name, grp->name ? "" : grp->name);
+			kobj->name, grp->name ?: "");
 		return -EINVAL;
 	}
 	if (grp->name) {

commit 9f70a40128a4ddceffb6d21dd490f6ab4bc34c97
Author: Robert ABEL <rabel@cit-ec.uni-bielefeld.de>
Date:   Mon May 5 15:17:20 2014 +0200

    sysfs: fix attribute_group bin file path on removal
    
    Cody Schafer already fixed binary file creation for attribute groups, see [1].
    This patch makes the appropriate changes for binary file removal
    of attribute groups.
    [1]: http://lkml.org/lkml/2014/2/27/832
    
    Signed-off-by: Robert ABEL <rabel@cit-ec.uni-bielefeld.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index aa0406895b53..7d2a860ba788 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -18,7 +18,7 @@
 #include "sysfs.h"
 
 
-static void remove_files(struct kernfs_node *parent, struct kobject *kobj,
+static void remove_files(struct kernfs_node *parent,
 			 const struct attribute_group *grp)
 {
 	struct attribute *const *attr;
@@ -29,7 +29,7 @@ static void remove_files(struct kernfs_node *parent, struct kobject *kobj,
 			kernfs_remove_by_name(parent, (*attr)->name);
 	if (grp->bin_attrs)
 		for (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++)
-			sysfs_remove_bin_file(kobj, *bin_attr);
+			kernfs_remove_by_name(parent, (*bin_attr)->attr.name);
 }
 
 static int create_files(struct kernfs_node *parent, struct kobject *kobj,
@@ -62,7 +62,7 @@ static int create_files(struct kernfs_node *parent, struct kobject *kobj,
 				break;
 		}
 		if (error) {
-			remove_files(parent, kobj, grp);
+			remove_files(parent, grp);
 			goto exit;
 		}
 	}
@@ -79,7 +79,7 @@ static int create_files(struct kernfs_node *parent, struct kobject *kobj,
 				break;
 		}
 		if (error)
-			remove_files(parent, kobj, grp);
+			remove_files(parent, grp);
 	}
 exit:
 	return error;
@@ -224,7 +224,7 @@ void sysfs_remove_group(struct kobject *kobj,
 		kernfs_get(kn);
 	}
 
-	remove_files(kn, kobj, grp);
+	remove_files(kn, grp);
 	if (grp->name)
 		kernfs_remove(kn);
 

commit aabaf4c2050d21d39fe11eec889c508e84d6a328
Author: Cody P Schafer <cody@linux.vnet.ibm.com>
Date:   Fri Feb 14 14:02:07 2014 -0800

    sysfs: create bin_attributes under the requested group
    
    bin_attributes created/updated in create_files() (such as those listed
    via (struct device).attribute_groups) were not placed under the
    specified group, and instead appeared in the base kobj directory.
    
    Fix this by making bin_attributes use creating code similar to normal
    attributes.
    
    A quick grep shows that no one is using bin_attrs in a named attribute
    group yet, so we can do this without breaking anything in usespace.
    
    Note that I do not add is_visible() support to
    bin_attributes, though that could be done as well.
    
    Signed-off-by: Cody P Schafer <cody@linux.vnet.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 6b579387c67a..aa0406895b53 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -70,8 +70,11 @@ static int create_files(struct kernfs_node *parent, struct kobject *kobj,
 	if (grp->bin_attrs) {
 		for (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++) {
 			if (update)
-				sysfs_remove_bin_file(kobj, *bin_attr);
-			error = sysfs_create_bin_file(kobj, *bin_attr);
+				kernfs_remove_by_name(parent,
+						(*bin_attr)->attr.name);
+			error = sysfs_add_file_mode_ns(parent,
+					&(*bin_attr)->attr, true,
+					(*bin_attr)->attr.mode, NULL);
 			if (error)
 				break;
 		}

commit bb8b9d095c5c56cce99576cfef0cf9b989f7120d
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 16:02:55 2013 -0500

    kernfs: add @mode to kernfs_create_dir[_ns]()
    
    sysfs assumed 0755 for all newly created directories and kernfs
    inherited it.  This assumption is unnecessarily restrictive and
    inconsistent with kernfs_create_file[_ns]().  This patch adds @mode
    parameter to kernfs_create_dir[_ns]() and update uses in sysfs
    accordingly.  Among others, this will be useful for implementations of
    the planned ->mkdir() method.
    
    This patch doesn't introduce any behavior differences.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 4d00d3996477..6b579387c67a 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -100,7 +100,8 @@ static int internal_create_group(struct kobject *kobj, int update,
 		return -EINVAL;
 	}
 	if (grp->name) {
-		kn = kernfs_create_dir(kobj->sd, grp->name, kobj);
+		kn = kernfs_create_dir(kobj->sd, grp->name,
+				       S_IRWXU | S_IRUGO | S_IXUGO, kobj);
 		if (IS_ERR(kn)) {
 			if (PTR_ERR(kn) == -EEXIST)
 				sysfs_warn_dup(kobj->sd, grp->name);

commit 324a56e16e44baecac3ca799fd216154145c14bf
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:53 2013 -0500

    kernfs: s/sysfs_dirent/kernfs_node/ and rename its friends accordingly
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/sysfs_elem_dir/kernfs_elem_dir/
    * s/sysfs_elem_symlink/kernfs_elem_symlink/
    * s/sysfs_elem_attr/kernfs_elem_file/
    * s/sysfs_dirent/kernfs_node/
    * s/sd/kn/ in kernfs proper
    * s/parent_sd/parent/
    * s/target_sd/target/
    * s/dir_sd/parent/
    * s/to_sysfs_dirent()/rb_to_kn()/
    * misc renames of local vars when they conflict with the above
    
    Because md, mic and gpio dig into sysfs details, this patch ends up
    modifying them.  All are sysfs_dirent renames and trivial.  While we
    can avoid these by introducing a dummy wrapping struct sysfs_dirent
    around kernfs_node, given the limited usage outside kernfs and sysfs
    proper, I don't think such workaround is called for.
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    - mic / gpio renames were missing.  Spotted by kbuild test robot.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Ashutosh Dixit <ashutosh.dixit@intel.com>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 7177532b8f7b..4d00d3996477 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -18,7 +18,7 @@
 #include "sysfs.h"
 
 
-static void remove_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
+static void remove_files(struct kernfs_node *parent, struct kobject *kobj,
 			 const struct attribute_group *grp)
 {
 	struct attribute *const *attr;
@@ -26,13 +26,13 @@ static void remove_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 
 	if (grp->attrs)
 		for (attr = grp->attrs; *attr; attr++)
-			kernfs_remove_by_name(dir_sd, (*attr)->name);
+			kernfs_remove_by_name(parent, (*attr)->name);
 	if (grp->bin_attrs)
 		for (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++)
 			sysfs_remove_bin_file(kobj, *bin_attr);
 }
 
-static int create_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
+static int create_files(struct kernfs_node *parent, struct kobject *kobj,
 			const struct attribute_group *grp, int update)
 {
 	struct attribute *const *attr;
@@ -49,20 +49,20 @@ static int create_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 			 * re-adding (if required) the file.
 			 */
 			if (update)
-				kernfs_remove_by_name(dir_sd, (*attr)->name);
+				kernfs_remove_by_name(parent, (*attr)->name);
 			if (grp->is_visible) {
 				mode = grp->is_visible(kobj, *attr, i);
 				if (!mode)
 					continue;
 			}
-			error = sysfs_add_file_mode_ns(dir_sd, *attr, false,
+			error = sysfs_add_file_mode_ns(parent, *attr, false,
 						       (*attr)->mode | mode,
 						       NULL);
 			if (unlikely(error))
 				break;
 		}
 		if (error) {
-			remove_files(dir_sd, kobj, grp);
+			remove_files(parent, kobj, grp);
 			goto exit;
 		}
 	}
@@ -76,7 +76,7 @@ static int create_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 				break;
 		}
 		if (error)
-			remove_files(dir_sd, kobj, grp);
+			remove_files(parent, kobj, grp);
 	}
 exit:
 	return error;
@@ -86,7 +86,7 @@ static int create_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 static int internal_create_group(struct kobject *kobj, int update,
 				 const struct attribute_group *grp)
 {
-	struct sysfs_dirent *sd;
+	struct kernfs_node *kn;
 	int error;
 
 	BUG_ON(!kobj || (!update && !kobj->sd));
@@ -100,21 +100,21 @@ static int internal_create_group(struct kobject *kobj, int update,
 		return -EINVAL;
 	}
 	if (grp->name) {
-		sd = kernfs_create_dir(kobj->sd, grp->name, kobj);
-		if (IS_ERR(sd)) {
-			if (PTR_ERR(sd) == -EEXIST)
+		kn = kernfs_create_dir(kobj->sd, grp->name, kobj);
+		if (IS_ERR(kn)) {
+			if (PTR_ERR(kn) == -EEXIST)
 				sysfs_warn_dup(kobj->sd, grp->name);
-			return PTR_ERR(sd);
+			return PTR_ERR(kn);
 		}
 	} else
-		sd = kobj->sd;
-	kernfs_get(sd);
-	error = create_files(sd, kobj, grp, update);
+		kn = kobj->sd;
+	kernfs_get(kn);
+	error = create_files(kn, kobj, grp, update);
 	if (error) {
 		if (grp->name)
-			kernfs_remove(sd);
+			kernfs_remove(kn);
 	}
-	kernfs_put(sd);
+	kernfs_put(kn);
 	return error;
 }
 
@@ -204,27 +204,27 @@ EXPORT_SYMBOL_GPL(sysfs_update_group);
 void sysfs_remove_group(struct kobject *kobj,
 			const struct attribute_group *grp)
 {
-	struct sysfs_dirent *dir_sd = kobj->sd;
-	struct sysfs_dirent *sd;
+	struct kernfs_node *parent = kobj->sd;
+	struct kernfs_node *kn;
 
 	if (grp->name) {
-		sd = kernfs_find_and_get(dir_sd, grp->name);
-		if (!sd) {
-			WARN(!sd, KERN_WARNING
+		kn = kernfs_find_and_get(parent, grp->name);
+		if (!kn) {
+			WARN(!kn, KERN_WARNING
 			     "sysfs group %p not found for kobject '%s'\n",
 			     grp, kobject_name(kobj));
 			return;
 		}
 	} else {
-		sd = dir_sd;
-		kernfs_get(sd);
+		kn = parent;
+		kernfs_get(kn);
 	}
 
-	remove_files(sd, kobj, grp);
+	remove_files(kn, kobj, grp);
 	if (grp->name)
-		kernfs_remove(sd);
+		kernfs_remove(kn);
 
-	kernfs_put(sd);
+	kernfs_put(kn);
 }
 EXPORT_SYMBOL_GPL(sysfs_remove_group);
 
@@ -260,22 +260,22 @@ EXPORT_SYMBOL_GPL(sysfs_remove_groups);
 int sysfs_merge_group(struct kobject *kobj,
 		       const struct attribute_group *grp)
 {
-	struct sysfs_dirent *dir_sd;
+	struct kernfs_node *parent;
 	int error = 0;
 	struct attribute *const *attr;
 	int i;
 
-	dir_sd = kernfs_find_and_get(kobj->sd, grp->name);
-	if (!dir_sd)
+	parent = kernfs_find_and_get(kobj->sd, grp->name);
+	if (!parent)
 		return -ENOENT;
 
 	for ((i = 0, attr = grp->attrs); *attr && !error; (++i, ++attr))
-		error = sysfs_add_file(dir_sd, *attr, false);
+		error = sysfs_add_file(parent, *attr, false);
 	if (error) {
 		while (--i >= 0)
-			kernfs_remove_by_name(dir_sd, (*--attr)->name);
+			kernfs_remove_by_name(parent, (*--attr)->name);
 	}
-	kernfs_put(dir_sd);
+	kernfs_put(parent);
 
 	return error;
 }
@@ -289,14 +289,14 @@ EXPORT_SYMBOL_GPL(sysfs_merge_group);
 void sysfs_unmerge_group(struct kobject *kobj,
 		       const struct attribute_group *grp)
 {
-	struct sysfs_dirent *dir_sd;
+	struct kernfs_node *parent;
 	struct attribute *const *attr;
 
-	dir_sd = kernfs_find_and_get(kobj->sd, grp->name);
-	if (dir_sd) {
+	parent = kernfs_find_and_get(kobj->sd, grp->name);
+	if (parent) {
 		for (attr = grp->attrs; *attr; ++attr)
-			kernfs_remove_by_name(dir_sd, (*attr)->name);
-		kernfs_put(dir_sd);
+			kernfs_remove_by_name(parent, (*attr)->name);
+		kernfs_put(parent);
 	}
 }
 EXPORT_SYMBOL_GPL(sysfs_unmerge_group);
@@ -311,15 +311,15 @@ EXPORT_SYMBOL_GPL(sysfs_unmerge_group);
 int sysfs_add_link_to_group(struct kobject *kobj, const char *group_name,
 			    struct kobject *target, const char *link_name)
 {
-	struct sysfs_dirent *dir_sd;
+	struct kernfs_node *parent;
 	int error = 0;
 
-	dir_sd = kernfs_find_and_get(kobj->sd, group_name);
-	if (!dir_sd)
+	parent = kernfs_find_and_get(kobj->sd, group_name);
+	if (!parent)
 		return -ENOENT;
 
-	error = sysfs_create_link_sd(dir_sd, target, link_name);
-	kernfs_put(dir_sd);
+	error = sysfs_create_link_sd(parent, target, link_name);
+	kernfs_put(parent);
 
 	return error;
 }
@@ -334,12 +334,12 @@ EXPORT_SYMBOL_GPL(sysfs_add_link_to_group);
 void sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,
 				  const char *link_name)
 {
-	struct sysfs_dirent *dir_sd;
+	struct kernfs_node *parent;
 
-	dir_sd = kernfs_find_and_get(kobj->sd, group_name);
-	if (dir_sd) {
-		kernfs_remove_by_name(dir_sd, link_name);
-		kernfs_put(dir_sd);
+	parent = kernfs_find_and_get(kobj->sd, group_name);
+	if (parent) {
+		kernfs_remove_by_name(parent, link_name);
+		kernfs_put(parent);
 	}
 }
 EXPORT_SYMBOL_GPL(sysfs_remove_link_from_group);

commit ccf73cf336dc55bc52748205dee998d2fd4a8808
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:30 2013 -0500

    sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put()
    
    Introduce kernfs interface for finding, getting and putting
    sysfs_dirents.
    
    * sysfs_find_dirent() is renamed to kernfs_find_ns() and lockdep
      assertion for sysfs_mutex is added.
    
    * sysfs_get_dirent_ns() is renamed to kernfs_find_and_get().
    
    * Macro inline dancing around __sysfs_get/put() are removed and
      kernfs_get/put() are made proper functions implemented in
      fs/sysfs/dir.c.
    
    While the conversions are mostly equivalent, there's one difference -
    kernfs_get() doesn't return the input param as its return value.  This
    change is intentional.  While passing through the input increases
    writability in some areas, it is unnecessary and has been shown to
    cause confusion regarding how the last ref is handled.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 9f65cd97a2d7..7177532b8f7b 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -108,13 +108,13 @@ static int internal_create_group(struct kobject *kobj, int update,
 		}
 	} else
 		sd = kobj->sd;
-	sysfs_get(sd);
+	kernfs_get(sd);
 	error = create_files(sd, kobj, grp, update);
 	if (error) {
 		if (grp->name)
 			kernfs_remove(sd);
 	}
-	sysfs_put(sd);
+	kernfs_put(sd);
 	return error;
 }
 
@@ -208,21 +208,23 @@ void sysfs_remove_group(struct kobject *kobj,
 	struct sysfs_dirent *sd;
 
 	if (grp->name) {
-		sd = sysfs_get_dirent(dir_sd, grp->name);
+		sd = kernfs_find_and_get(dir_sd, grp->name);
 		if (!sd) {
 			WARN(!sd, KERN_WARNING
 			     "sysfs group %p not found for kobject '%s'\n",
 			     grp, kobject_name(kobj));
 			return;
 		}
-	} else
-		sd = sysfs_get(dir_sd);
+	} else {
+		sd = dir_sd;
+		kernfs_get(sd);
+	}
 
 	remove_files(sd, kobj, grp);
 	if (grp->name)
 		kernfs_remove(sd);
 
-	sysfs_put(sd);
+	kernfs_put(sd);
 }
 EXPORT_SYMBOL_GPL(sysfs_remove_group);
 
@@ -263,7 +265,7 @@ int sysfs_merge_group(struct kobject *kobj,
 	struct attribute *const *attr;
 	int i;
 
-	dir_sd = sysfs_get_dirent(kobj->sd, grp->name);
+	dir_sd = kernfs_find_and_get(kobj->sd, grp->name);
 	if (!dir_sd)
 		return -ENOENT;
 
@@ -273,7 +275,7 @@ int sysfs_merge_group(struct kobject *kobj,
 		while (--i >= 0)
 			kernfs_remove_by_name(dir_sd, (*--attr)->name);
 	}
-	sysfs_put(dir_sd);
+	kernfs_put(dir_sd);
 
 	return error;
 }
@@ -290,11 +292,11 @@ void sysfs_unmerge_group(struct kobject *kobj,
 	struct sysfs_dirent *dir_sd;
 	struct attribute *const *attr;
 
-	dir_sd = sysfs_get_dirent(kobj->sd, grp->name);
+	dir_sd = kernfs_find_and_get(kobj->sd, grp->name);
 	if (dir_sd) {
 		for (attr = grp->attrs; *attr; ++attr)
 			kernfs_remove_by_name(dir_sd, (*attr)->name);
-		sysfs_put(dir_sd);
+		kernfs_put(dir_sd);
 	}
 }
 EXPORT_SYMBOL_GPL(sysfs_unmerge_group);
@@ -312,12 +314,12 @@ int sysfs_add_link_to_group(struct kobject *kobj, const char *group_name,
 	struct sysfs_dirent *dir_sd;
 	int error = 0;
 
-	dir_sd = sysfs_get_dirent(kobj->sd, group_name);
+	dir_sd = kernfs_find_and_get(kobj->sd, group_name);
 	if (!dir_sd)
 		return -ENOENT;
 
 	error = sysfs_create_link_sd(dir_sd, target, link_name);
-	sysfs_put(dir_sd);
+	kernfs_put(dir_sd);
 
 	return error;
 }
@@ -334,10 +336,10 @@ void sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,
 {
 	struct sysfs_dirent *dir_sd;
 
-	dir_sd = sysfs_get_dirent(kobj->sd, group_name);
+	dir_sd = kernfs_find_and_get(kobj->sd, group_name);
 	if (dir_sd) {
 		kernfs_remove_by_name(dir_sd, link_name);
-		sysfs_put(dir_sd);
+		kernfs_put(dir_sd);
 	}
 }
 EXPORT_SYMBOL_GPL(sysfs_remove_link_from_group);

commit a7dc66dfb4c6d6c1d7c14d5106ce467f1dbd4eba
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:23 2013 -0500

    sysfs, kernfs: remove SYSFS_KOBJ_BIN_ATTR
    
    After kernfs_ops and sysfs_dirent->s_attr.size addition, the
    distinction between SYSFS_KOBJ_BIN_ATTR and SYSFS_KOBJ_ATTR is only
    necessary while creating files to decide which kernfs_ops to use.
    Afterwards, they behave exactly the same.
    
    This patch removes SYSFS_KOBJ_BIN_ATTR along with sysfs_is_bin().
    sysfs_add_file[_mode_ns]() are updated to take bool @is_bin instead of
    @type.
    
    This patch doesn't introduce any behavior changes.  This completely
    isolates the distinction between the two sysfs file types in the sysfs
    layer proper.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 065689ddb4cb..9f65cd97a2d7 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -55,8 +55,7 @@ static int create_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 				if (!mode)
 					continue;
 			}
-			error = sysfs_add_file_mode_ns(dir_sd, *attr,
-						       SYSFS_KOBJ_ATTR,
+			error = sysfs_add_file_mode_ns(dir_sd, *attr, false,
 						       (*attr)->mode | mode,
 						       NULL);
 			if (unlikely(error))
@@ -269,7 +268,7 @@ int sysfs_merge_group(struct kobject *kobj,
 		return -ENOENT;
 
 	for ((i = 0, attr = grp->attrs); *attr && !error; (++i, ++attr))
-		error = sysfs_add_file(dir_sd, *attr, SYSFS_KOBJ_ATTR);
+		error = sysfs_add_file(dir_sd, *attr, false);
 	if (error) {
 		while (--i >= 0)
 			kernfs_remove_by_name(dir_sd, (*--attr)->name);

commit 93b2b8e4aa4317e3fe6414d117deb5f3c362e8bb
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:15 2013 -0500

    sysfs, kernfs: introduce kernfs_create_dir[_ns]()
    
    Introduce kernfs interface to manipulate a directory which takes and
    returns sysfs_dirents.
    
    create_dir() is renamed to kernfs_create_dir_ns() and its argumantes
    and return value are updated.  create_dir() usages are replaced with
    kernfs_create_dir_ns() and sysfs_create_subdir() usages are replaced
    with kernfs_create_dir().  Dup warnings are handled explicitly by
    sysfs users of the kernfs interface.
    
    sysfs_enable_ns() is renamed to kernfs_enable_ns().
    
    This patch doesn't introduce any behavior changes.
    
    v2: Dummy implementation for !CONFIG_SYSFS updated to return -ENOSYS.
    
    v3: kernfs_enable_ns() added.
    
    v4: Refreshed on top of "sysfs: drop kobj_ns_type handling, take #2"
        so that this patch removes sysfs_enable_ns().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 4bd997340830..065689ddb4cb 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -101,9 +101,12 @@ static int internal_create_group(struct kobject *kobj, int update,
 		return -EINVAL;
 	}
 	if (grp->name) {
-		error = sysfs_create_subdir(kobj, grp->name, &sd);
-		if (error)
-			return error;
+		sd = kernfs_create_dir(kobj->sd, grp->name, kobj);
+		if (IS_ERR(sd)) {
+			if (PTR_ERR(sd) == -EEXIST)
+				sysfs_warn_dup(kobj->sd, grp->name);
+			return PTR_ERR(sd);
+		}
 	} else
 		sd = kobj->sd;
 	sysfs_get(sd);

commit 879f40d193bb3c6c13930e88e3e9d5d7baf84d19
Author: Tejun Heo <tj@kernel.org>
Date:   Sat Nov 23 17:21:49 2013 -0500

    sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]()
    
    Introduce kernfs removal interfaces - kernfs_remove() and
    kernfs_remove_by_name[_ns]().
    
    These are just renames of sysfs_remove() and sysfs_hash_and_remove().
    No functional changes.
    
    v2: Dummy kernfs_remove_by_name_ns() for !CONFIG_SYSFS updated to
        return -ENOSYS instead of 0.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 1898a10e38ce..4bd997340830 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -26,7 +26,7 @@ static void remove_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 
 	if (grp->attrs)
 		for (attr = grp->attrs; *attr; attr++)
-			sysfs_hash_and_remove(dir_sd, (*attr)->name, NULL);
+			kernfs_remove_by_name(dir_sd, (*attr)->name);
 	if (grp->bin_attrs)
 		for (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++)
 			sysfs_remove_bin_file(kobj, *bin_attr);
@@ -49,8 +49,7 @@ static int create_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 			 * re-adding (if required) the file.
 			 */
 			if (update)
-				sysfs_hash_and_remove(dir_sd, (*attr)->name,
-						      NULL);
+				kernfs_remove_by_name(dir_sd, (*attr)->name);
 			if (grp->is_visible) {
 				mode = grp->is_visible(kobj, *attr, i);
 				if (!mode)
@@ -111,7 +110,7 @@ static int internal_create_group(struct kobject *kobj, int update,
 	error = create_files(sd, kobj, grp, update);
 	if (error) {
 		if (grp->name)
-			sysfs_remove(sd);
+			kernfs_remove(sd);
 	}
 	sysfs_put(sd);
 	return error;
@@ -219,7 +218,7 @@ void sysfs_remove_group(struct kobject *kobj,
 
 	remove_files(sd, kobj, grp);
 	if (grp->name)
-		sysfs_remove(sd);
+		kernfs_remove(sd);
 
 	sysfs_put(sd);
 }
@@ -270,7 +269,7 @@ int sysfs_merge_group(struct kobject *kobj,
 		error = sysfs_add_file(dir_sd, *attr, SYSFS_KOBJ_ATTR);
 	if (error) {
 		while (--i >= 0)
-			sysfs_hash_and_remove(dir_sd, (*--attr)->name, NULL);
+			kernfs_remove_by_name(dir_sd, (*--attr)->name);
 	}
 	sysfs_put(dir_sd);
 
@@ -292,7 +291,7 @@ void sysfs_unmerge_group(struct kobject *kobj,
 	dir_sd = sysfs_get_dirent(kobj->sd, grp->name);
 	if (dir_sd) {
 		for (attr = grp->attrs; *attr; ++attr)
-			sysfs_hash_and_remove(dir_sd, (*attr)->name, NULL);
+			kernfs_remove_by_name(dir_sd, (*attr)->name);
 		sysfs_put(dir_sd);
 	}
 }
@@ -335,7 +334,7 @@ void sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,
 
 	dir_sd = sysfs_get_dirent(kobj->sd, group_name);
 	if (dir_sd) {
-		sysfs_hash_and_remove(dir_sd, link_name, NULL);
+		kernfs_remove_by_name(dir_sd, link_name);
 		sysfs_put(dir_sd);
 	}
 }

commit 250f7c3fee52b71457b4aa2cafadbd9f8b320b31
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 18 17:15:38 2013 -0400

    sysfs: introduce [__]sysfs_remove()
    
    Given a sysfs_dirent, there is no reason to have multiple versions of
    removal functions.  A function which removes the specified
    sysfs_dirent and its descendants is enough.
    
    This patch intorduces [__}sysfs_remove() which replaces all internal
    variations of removal functions.  This will be the only removal
    function in the planned new sysfs_dirent based interface.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 2dae55c4f7dc..1898a10e38ce 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -111,7 +111,7 @@ static int internal_create_group(struct kobject *kobj, int update,
 	error = create_files(sd, kobj, grp, update);
 	if (error) {
 		if (grp->name)
-			sysfs_remove_subdir(sd);
+			sysfs_remove(sd);
 	}
 	sysfs_put(sd);
 	return error;
@@ -219,7 +219,7 @@ void sysfs_remove_group(struct kobject *kobj,
 
 	remove_files(sd, kobj, grp);
 	if (grp->name)
-		sysfs_remove_subdir(sd);
+		sysfs_remove(sd);
 
 	sysfs_put(sd);
 }

commit cfec0bc835c84d3d3723d4955587f05a94879b26
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 11 22:29:09 2013 -0400

    sysfs: @name comes before @ns
    
    Some internal sysfs functions which take explicit namespace argument
    are weird in that they place the optional @ns in front of @name which
    is contrary to the established convention.  This is confusing and
    error-prone especially as @ns and @name may be interchanged without
    causing compilation warning.
    
    Swap the positions of @name and @ns in the following internal
    functions.
    
     sysfs_find_dirent()
     sysfs_rename()
     sysfs_hash_and_remove()
     sysfs_name_hash()
     sysfs_name_compare()
     create_dir()
    
    This patch doesn't introduce any functional changes.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 21102158ca33..2dae55c4f7dc 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -26,7 +26,7 @@ static void remove_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 
 	if (grp->attrs)
 		for (attr = grp->attrs; *attr; attr++)
-			sysfs_hash_and_remove(dir_sd, NULL, (*attr)->name);
+			sysfs_hash_and_remove(dir_sd, (*attr)->name, NULL);
 	if (grp->bin_attrs)
 		for (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++)
 			sysfs_remove_bin_file(kobj, *bin_attr);
@@ -49,8 +49,8 @@ static int create_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 			 * re-adding (if required) the file.
 			 */
 			if (update)
-				sysfs_hash_and_remove(dir_sd, NULL,
-						      (*attr)->name);
+				sysfs_hash_and_remove(dir_sd, (*attr)->name,
+						      NULL);
 			if (grp->is_visible) {
 				mode = grp->is_visible(kobj, *attr, i);
 				if (!mode)
@@ -270,7 +270,7 @@ int sysfs_merge_group(struct kobject *kobj,
 		error = sysfs_add_file(dir_sd, *attr, SYSFS_KOBJ_ATTR);
 	if (error) {
 		while (--i >= 0)
-			sysfs_hash_and_remove(dir_sd, NULL, (*--attr)->name);
+			sysfs_hash_and_remove(dir_sd, (*--attr)->name, NULL);
 	}
 	sysfs_put(dir_sd);
 
@@ -292,7 +292,7 @@ void sysfs_unmerge_group(struct kobject *kobj,
 	dir_sd = sysfs_get_dirent(kobj->sd, grp->name);
 	if (dir_sd) {
 		for (attr = grp->attrs; *attr; ++attr)
-			sysfs_hash_and_remove(dir_sd, NULL, (*attr)->name);
+			sysfs_hash_and_remove(dir_sd, (*attr)->name, NULL);
 		sysfs_put(dir_sd);
 	}
 }
@@ -335,7 +335,7 @@ void sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,
 
 	dir_sd = sysfs_get_dirent(kobj->sd, group_name);
 	if (dir_sd) {
-		sysfs_hash_and_remove(dir_sd, NULL, link_name);
+		sysfs_hash_and_remove(dir_sd, link_name, NULL);
 		sysfs_put(dir_sd);
 	}
 }

commit 388975cccaaf11abd47525f664c76891c440481a
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 11 23:19:13 2013 -0400

    sysfs: clean up sysfs_get_dirent()
    
    The pre-existing sysfs interfaces which take explicit namespace
    argument are weird in that they place the optional @ns in front of
    @name which is contrary to the established convention.  For example,
    we end up forcing vast majority of sysfs_get_dirent() users to do
    sysfs_get_dirent(parent, NULL, name), which is silly and error-prone
    especially as @ns and @name may be interchanged without causing
    compilation warning.
    
    This renames sysfs_get_dirent() to sysfs_get_dirent_ns() and swap the
    positions of @name and @ns, and sysfs_get_dirent() is now a wrapper
    around sysfs_get_dirent_ns().  This makes confusions a lot less
    likely.
    
    There are other interfaces which take @ns before @name.  They'll be
    updated by following patches.
    
    This patch doesn't introduce any functional changes.
    
    v2: EXPORT_SYMBOL_GPL() wasn't updated leading to undefined symbol
        error on module builds.  Reported by build test robot.  Fixed.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Kay Sievers <kay@vrfy.org>
    Cc: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 25c78f23dae8..21102158ca33 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -207,7 +207,7 @@ void sysfs_remove_group(struct kobject *kobj,
 	struct sysfs_dirent *sd;
 
 	if (grp->name) {
-		sd = sysfs_get_dirent(dir_sd, NULL, grp->name);
+		sd = sysfs_get_dirent(dir_sd, grp->name);
 		if (!sd) {
 			WARN(!sd, KERN_WARNING
 			     "sysfs group %p not found for kobject '%s'\n",
@@ -262,7 +262,7 @@ int sysfs_merge_group(struct kobject *kobj,
 	struct attribute *const *attr;
 	int i;
 
-	dir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);
+	dir_sd = sysfs_get_dirent(kobj->sd, grp->name);
 	if (!dir_sd)
 		return -ENOENT;
 
@@ -289,7 +289,7 @@ void sysfs_unmerge_group(struct kobject *kobj,
 	struct sysfs_dirent *dir_sd;
 	struct attribute *const *attr;
 
-	dir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);
+	dir_sd = sysfs_get_dirent(kobj->sd, grp->name);
 	if (dir_sd) {
 		for (attr = grp->attrs; *attr; ++attr)
 			sysfs_hash_and_remove(dir_sd, NULL, (*attr)->name);
@@ -311,7 +311,7 @@ int sysfs_add_link_to_group(struct kobject *kobj, const char *group_name,
 	struct sysfs_dirent *dir_sd;
 	int error = 0;
 
-	dir_sd = sysfs_get_dirent(kobj->sd, NULL, group_name);
+	dir_sd = sysfs_get_dirent(kobj->sd, group_name);
 	if (!dir_sd)
 		return -ENOENT;
 
@@ -333,7 +333,7 @@ void sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,
 {
 	struct sysfs_dirent *dir_sd;
 
-	dir_sd = sysfs_get_dirent(kobj->sd, NULL, group_name);
+	dir_sd = sysfs_get_dirent(kobj->sd, group_name);
 	if (dir_sd) {
 		sysfs_hash_and_remove(dir_sd, NULL, link_name);
 		sysfs_put(dir_sd);

commit 58292cbe6669d74498a5f08db13e57cb3bcfb81d
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 11 22:29:04 2013 -0400

    sysfs: make attr namespace interface less convoluted
    
    sysfs ns (namespace) implementation became more convoluted than
    necessary while trying to hide ns information from visible interface.
    The relatively recent attr ns support is a good example.
    
    * attr ns tag is determined by sysfs_ops->namespace() callback while
      dir tag is determined by kobj_type->namespace().  The placement is
      arbitrary.
    
    * Instead of performing operations with explicit ns tag, the namespace
      callback is routed through sysfs_attr_ns(), sysfs_ops->namespace(),
      class_attr_namespace(), class_attr->namespace().  It's not simpler
      in any sense.  The only thing this convolution does is traversing
      the whole stack backwards.
    
    The namespace callbacks are unncessary because the operations involved
    are inherently synchronous.  The information can be provided in in
    straight-forward top-down direction and reversing that direction is
    unnecessary and against basic design principles.
    
    This backward interface is unnecessarily convoluted and hinders
    properly separating out sysfs from driver model / kobject for proper
    layering.  This patch updates attr ns support such that
    
    * sysfs_ops->namespace() and class_attr->namespace() are dropped.
    
    * sysfs_{create|remove}_file_ns(), which take explicit @ns param, are
      added and sysfs_{create|remove}_file() are now simple wrappers
      around the ns aware functions.
    
    * ns handling is dropped from sysfs_chmod_file().  Nobody uses it at
      this point.  sysfs_chmod_file_ns() can be added later if necessary.
    
    * Explicit @ns is propagated through class_{create|remove}_file_ns()
      and netdev_class_{create|remove}_file_ns().
    
    * driver/net/bonding which is currently the only user of attr
      namespace is updated to use netdev_class_{create|remove}_file_ns()
      with @bh->net as the ns tag instead of using the namespace callback.
    
    This patch should be an equivalent conversion without any functional
    difference.  It makes the code easier to follow, reduces lines of code
    a bit and helps proper separation and layering.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Kay Sievers <kay@vrfy.org>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 5f92cd2f61c1..25c78f23dae8 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -56,9 +56,10 @@ static int create_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 				if (!mode)
 					continue;
 			}
-			error = sysfs_add_file_mode(dir_sd, *attr,
-						    SYSFS_KOBJ_ATTR,
-						    (*attr)->mode | mode);
+			error = sysfs_add_file_mode_ns(dir_sd, *attr,
+						       SYSFS_KOBJ_ATTR,
+						       (*attr)->mode | mode,
+						       NULL);
 			if (unlikely(error))
 				break;
 		}

commit 09239ed4aa99b2d2fd9b1a51b264661a4a6d469e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Aug 22 09:23:28 2013 -0700

    sysfs: group.c: fix up kerneldoc
    
    Fix up the wording of sysfs_create/remove_groups() a bit.
    
    Reported-by: Anthony Foiani <tkil@scrye.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index cb987e6c9279..5f92cd2f61c1 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -144,7 +144,7 @@ EXPORT_SYMBOL_GPL(sysfs_create_group);
  * It will explicitly warn and error if any of the attribute files being
  * created already exist.
  *
- * Returns 0 on success or error code from sysfs_create_groups on error.
+ * Returns 0 on success or error code from sysfs_create_group on error.
  */
 int sysfs_create_groups(struct kobject *kobj,
 			const struct attribute_group **groups)
@@ -230,7 +230,7 @@ EXPORT_SYMBOL_GPL(sysfs_remove_group);
  * @kobj:	The kobject for the groups to be removed from
  * @groups:	NULL terminated list of groups to be removed
  *
- * If groups is not NULL, the all groups will be removed from the kobject
+ * If groups is not NULL, remove the specified groups from the kobject.
  */
 void sysfs_remove_groups(struct kobject *kobj,
 			 const struct attribute_group **groups)

commit 9e2a47ed6443b7af1e5b91f59e8738c01fde45a9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Aug 21 16:14:11 2013 -0700

    sysfs: group: update copyright to add myself and the LF
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 4633b20b6ec3..cb987e6c9279 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -3,6 +3,8 @@
  *
  * Copyright (c) 2003 Patrick Mochel
  * Copyright (c) 2003 Open Source Development Lab
+ * Copyright (c) 2013 Greg Kroah-Hartman
+ * Copyright (c) 2013 The Linux Foundation
  *
  * This file is released undert the GPL v2.
  *

commit f9ae443b5a1aa3d34d57df966a220a51a854d4c8
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Aug 21 16:12:34 2013 -0700

    sysfs: group.c: add kerneldoc for sysfs_remove_group
    
    sysfs_remove_group() never had kerneldoc, so add it, and fix up the
    kerneldoc for sysfs_remove_groups() which didn't specify the parameters
    properly.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 642700131dd5..4633b20b6ec3 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -189,6 +189,14 @@ int sysfs_update_group(struct kobject *kobj,
 }
 EXPORT_SYMBOL_GPL(sysfs_update_group);
 
+/**
+ * sysfs_remove_group: remove a group from a kobject
+ * @kobj:	kobject to remove the group from
+ * @grp:	group to remove
+ *
+ * This function removes a group of attributes from a kobject.  The attributes
+ * previously have to have been created for this group, otherwise it will fail.
+ */
 void sysfs_remove_group(struct kobject *kobj,
 			const struct attribute_group *grp)
 {
@@ -217,8 +225,8 @@ EXPORT_SYMBOL_GPL(sysfs_remove_group);
 /**
  * sysfs_remove_groups - remove a list of groups
  *
- * kobj:	The kobject for the groups to be removed from
- * groups:	NULL terminated list of groups to be removed
+ * @kobj:	The kobject for the groups to be removed from
+ * @groups:	NULL terminated list of groups to be removed
  *
  * If groups is not NULL, the all groups will be removed from the kobject
  */

commit 16aebf1c5d30701c3e2733d0c1a0ee3236fd9eec
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Aug 21 16:10:02 2013 -0700

    sysfs: group.c: fix up broken string coding style
    
    checkpatch complains about the broken string in the file, and it's
    correct, so fix it up.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index f4a9d221cbe6..642700131dd5 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -198,8 +198,9 @@ void sysfs_remove_group(struct kobject *kobj,
 	if (grp->name) {
 		sd = sysfs_get_dirent(dir_sd, NULL, grp->name);
 		if (!sd) {
-			WARN(!sd, KERN_WARNING "sysfs group %p not found for "
-				"kobject '%s'\n", grp, kobject_name(kobj));
+			WARN(!sd, KERN_WARNING
+			     "sysfs group %p not found for kobject '%s'\n",
+			     grp, kobject_name(kobj));
 			return;
 		}
 	} else

commit 995d8ed943291d2fa1174f5b00d8921c6cf91c98
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Aug 21 16:07:29 2013 -0700

    sysfs: group.c: fix up some * coding style issues
    
    This fixes up the * coding style warnings for the group.c sysfs file.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 14672e9b9172..f4a9d221cbe6 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -19,8 +19,8 @@
 static void remove_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 			 const struct attribute_group *grp)
 {
-	struct attribute *const* attr;
-	struct bin_attribute *const* bin_attr;
+	struct attribute *const *attr;
+	struct bin_attribute *const *bin_attr;
 
 	if (grp->attrs)
 		for (attr = grp->attrs; *attr; attr++)
@@ -33,8 +33,8 @@ static void remove_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 static int create_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 			const struct attribute_group *grp, int update)
 {
-	struct attribute *const* attr;
-	struct bin_attribute *const* bin_attr;
+	struct attribute *const *attr;
+	struct bin_attribute *const *bin_attr;
 	int error = 0, i;
 
 	if (grp->attrs) {
@@ -189,8 +189,8 @@ int sysfs_update_group(struct kobject *kobj,
 }
 EXPORT_SYMBOL_GPL(sysfs_update_group);
 
-void sysfs_remove_group(struct kobject * kobj,
-			const struct attribute_group * grp)
+void sysfs_remove_group(struct kobject *kobj,
+			const struct attribute_group *grp)
 {
 	struct sysfs_dirent *dir_sd = kobj->sd;
 	struct sysfs_dirent *sd;

commit e6c56920fd81f804910360cd487ec78b766b3aa8
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Aug 21 16:06:14 2013 -0700

    sysfs: group.c: fix trailing whitespace
    
    There was some trailing spaces in the file, fix that up.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index c86a1729f537..14672e9b9172 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -4,7 +4,7 @@
  * Copyright (c) 2003 Patrick Mochel
  * Copyright (c) 2003 Open Source Development Lab
  *
- * This file is released undert the GPL v2. 
+ * This file is released undert the GPL v2.
  *
  */
 
@@ -189,7 +189,7 @@ int sysfs_update_group(struct kobject *kobj,
 }
 EXPORT_SYMBOL_GPL(sysfs_update_group);
 
-void sysfs_remove_group(struct kobject * kobj, 
+void sysfs_remove_group(struct kobject * kobj,
 			const struct attribute_group * grp)
 {
 	struct sysfs_dirent *dir_sd = kobj->sd;

commit d363bc53ef4233e02d70791f10fe1f18c6c0f508
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Aug 21 16:04:12 2013 -0700

    sysfs: group.c: move EXPORT_SYMBOL_GPL() to the proper location
    
    This fixes up the coding style issue of incorrectly placing the
    EXPORT_SYMBOL_GPL() macro, it should be right after the function itself,
    not at the end of the file.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 68baf8501552..c86a1729f537 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -129,6 +129,7 @@ int sysfs_create_group(struct kobject *kobj,
 {
 	return internal_create_group(kobj, 0, grp);
 }
+EXPORT_SYMBOL_GPL(sysfs_create_group);
 
 /**
  * sysfs_create_groups - given a directory kobject, create a bunch of attribute groups
@@ -186,8 +187,7 @@ int sysfs_update_group(struct kobject *kobj,
 {
 	return internal_create_group(kobj, 1, grp);
 }
-
-
+EXPORT_SYMBOL_GPL(sysfs_update_group);
 
 void sysfs_remove_group(struct kobject * kobj, 
 			const struct attribute_group * grp)
@@ -211,6 +211,7 @@ void sysfs_remove_group(struct kobject * kobj,
 
 	sysfs_put(sd);
 }
+EXPORT_SYMBOL_GPL(sysfs_remove_group);
 
 /**
  * sysfs_remove_groups - remove a list of groups
@@ -327,7 +328,3 @@ void sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,
 	}
 }
 EXPORT_SYMBOL_GPL(sysfs_remove_link_from_group);
-
-EXPORT_SYMBOL_GPL(sysfs_create_group);
-EXPORT_SYMBOL_GPL(sysfs_update_group);
-EXPORT_SYMBOL_GPL(sysfs_remove_group);

commit 3e9b2bae8369661070622d05570cbcdfa01770e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Aug 21 13:47:50 2013 -0700

    sysfs: add sysfs_create/remove_groups()
    
    These functions are being open-coded in 3 different places in the driver
    core, and other driver subsystems will want to start doing this as well,
    so move it to the sysfs core to keep it all in one place, where we know
    it is written properly.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 09a1a25cd145..68baf8501552 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -130,6 +130,40 @@ int sysfs_create_group(struct kobject *kobj,
 	return internal_create_group(kobj, 0, grp);
 }
 
+/**
+ * sysfs_create_groups - given a directory kobject, create a bunch of attribute groups
+ * @kobj:	The kobject to create the group on
+ * @groups:	The attribute groups to create, NULL terminated
+ *
+ * This function creates a bunch of attribute groups.  If an error occurs when
+ * creating a group, all previously created groups will be removed, unwinding
+ * everything back to the original state when this function was called.
+ * It will explicitly warn and error if any of the attribute files being
+ * created already exist.
+ *
+ * Returns 0 on success or error code from sysfs_create_groups on error.
+ */
+int sysfs_create_groups(struct kobject *kobj,
+			const struct attribute_group **groups)
+{
+	int error = 0;
+	int i;
+
+	if (!groups)
+		return 0;
+
+	for (i = 0; groups[i]; i++) {
+		error = sysfs_create_group(kobj, groups[i]);
+		if (error) {
+			while (--i >= 0)
+				sysfs_remove_group(kobj, groups[i]);
+			break;
+		}
+	}
+	return error;
+}
+EXPORT_SYMBOL_GPL(sysfs_create_groups);
+
 /**
  * sysfs_update_group - given a directory kobject, update an attribute group
  * @kobj:	The kobject to update the group on
@@ -178,6 +212,26 @@ void sysfs_remove_group(struct kobject * kobj,
 	sysfs_put(sd);
 }
 
+/**
+ * sysfs_remove_groups - remove a list of groups
+ *
+ * kobj:	The kobject for the groups to be removed from
+ * groups:	NULL terminated list of groups to be removed
+ *
+ * If groups is not NULL, the all groups will be removed from the kobject
+ */
+void sysfs_remove_groups(struct kobject *kobj,
+			 const struct attribute_group **groups)
+{
+	int i;
+
+	if (!groups)
+		return;
+	for (i = 0; groups[i]; i++)
+		sysfs_remove_group(kobj, groups[i]);
+}
+EXPORT_SYMBOL_GPL(sysfs_remove_groups);
+
 /**
  * sysfs_merge_group - merge files into a pre-existing attribute group.
  * @kobj:	The kobject containing the group.

commit 388a8c353d671d4ea2f638be84cfcbb912afdcf2
Author: Oliver Schinagl <oliver@schinagl.nl>
Date:   Sun Jul 14 16:05:56 2013 -0700

    sysfs: prevent warning when only using binary attributes
    
    When only using bin_attrs instead of attrs the kernel prints a warning
    and refuses to create the sysfs entry. This fixes that.
    
    Signed-off-by: Oliver Schinagl <oliver@schinagl.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index e5719c6095c3..09a1a25cd145 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -93,8 +93,8 @@ static int internal_create_group(struct kobject *kobj, int update,
 	/* Updates may happen before the object has been instantiated */
 	if (unlikely(update && !kobj->sd))
 		return -EINVAL;
-	if (!grp->attrs) {
-		WARN(1, "sysfs: attrs not set by subsystem for group: %s/%s\n",
+	if (!grp->attrs && !grp->bin_attrs) {
+		WARN(1, "sysfs: (bin_)attrs not set by subsystem for group: %s/%s\n",
 			kobj->name, grp->name ? "" : grp->name);
 		return -EINVAL;
 	}

commit 6ab9cea16075ea707022753395f340b67f64304c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Jul 14 16:05:55 2013 -0700

    sysfs: add support for binary attributes in groups
    
    groups should be able to support binary attributes, just like it
    supports "normal" attributes.  This lets us only handle one type of
    structure, groups, throughout the driver core and subsystems, making
    binary attributes a "full fledged" part of the driver model, and not
    something just "tacked on".
    
    Reported-by: Oliver Schinagl <oliver@schinagl.nl>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index aec3d5c98c94..e5719c6095c3 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -20,38 +20,64 @@ static void remove_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 			 const struct attribute_group *grp)
 {
 	struct attribute *const* attr;
-	int i;
+	struct bin_attribute *const* bin_attr;
 
-	for (i = 0, attr = grp->attrs; *attr; i++, attr++)
-		sysfs_hash_and_remove(dir_sd, NULL, (*attr)->name);
+	if (grp->attrs)
+		for (attr = grp->attrs; *attr; attr++)
+			sysfs_hash_and_remove(dir_sd, NULL, (*attr)->name);
+	if (grp->bin_attrs)
+		for (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++)
+			sysfs_remove_bin_file(kobj, *bin_attr);
 }
 
 static int create_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 			const struct attribute_group *grp, int update)
 {
 	struct attribute *const* attr;
+	struct bin_attribute *const* bin_attr;
 	int error = 0, i;
 
-	for (i = 0, attr = grp->attrs; *attr && !error; i++, attr++) {
-		umode_t mode = 0;
+	if (grp->attrs) {
+		for (i = 0, attr = grp->attrs; *attr && !error; i++, attr++) {
+			umode_t mode = 0;
+
+			/*
+			 * In update mode, we're changing the permissions or
+			 * visibility.  Do this by first removing then
+			 * re-adding (if required) the file.
+			 */
+			if (update)
+				sysfs_hash_and_remove(dir_sd, NULL,
+						      (*attr)->name);
+			if (grp->is_visible) {
+				mode = grp->is_visible(kobj, *attr, i);
+				if (!mode)
+					continue;
+			}
+			error = sysfs_add_file_mode(dir_sd, *attr,
+						    SYSFS_KOBJ_ATTR,
+						    (*attr)->mode | mode);
+			if (unlikely(error))
+				break;
+		}
+		if (error) {
+			remove_files(dir_sd, kobj, grp);
+			goto exit;
+		}
+	}
 
-		/* in update mode, we're changing the permissions or
-		 * visibility.  Do this by first removing then
-		 * re-adding (if required) the file */
-		if (update)
-			sysfs_hash_and_remove(dir_sd, NULL, (*attr)->name);
-		if (grp->is_visible) {
-			mode = grp->is_visible(kobj, *attr, i);
-			if (!mode)
-				continue;
+	if (grp->bin_attrs) {
+		for (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++) {
+			if (update)
+				sysfs_remove_bin_file(kobj, *bin_attr);
+			error = sysfs_create_bin_file(kobj, *bin_attr);
+			if (error)
+				break;
 		}
-		error = sysfs_add_file_mode(dir_sd, *attr, SYSFS_KOBJ_ATTR,
-					    (*attr)->mode | mode);
-		if (unlikely(error))
-			break;
+		if (error)
+			remove_files(dir_sd, kobj, grp);
 	}
-	if (error)
-		remove_files(dir_sd, kobj, grp);
+exit:
 	return error;
 }
 

commit 0bb8f3d6ae621945e6fa2102aa894f72b76a023e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 25 21:51:13 2013 +0100

    sysfs: Functions for adding/removing symlinks to/from attribute groups
    
    The most convenient way to expose ACPI power resources lists of a
    device is to put symbolic links to sysfs directories representing
    those resources into special attribute groups in the device's sysfs
    directory.  For this purpose, it is necessary to be able to add
    symbolic links to attribute groups.
    
    For this reason, add sysfs helper functions for adding/removing
    symbolic links to/from attribute groups, sysfs_add_link_to_group()
    and sysfs_remove_link_from_group(), respectively.
    
    This change set includes a build fix from David Rientjes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 2df555c66d57..aec3d5c98c94 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -205,6 +205,48 @@ void sysfs_unmerge_group(struct kobject *kobj,
 }
 EXPORT_SYMBOL_GPL(sysfs_unmerge_group);
 
+/**
+ * sysfs_add_link_to_group - add a symlink to an attribute group.
+ * @kobj:	The kobject containing the group.
+ * @group_name:	The name of the group.
+ * @target:	The target kobject of the symlink to create.
+ * @link_name:	The name of the symlink to create.
+ */
+int sysfs_add_link_to_group(struct kobject *kobj, const char *group_name,
+			    struct kobject *target, const char *link_name)
+{
+	struct sysfs_dirent *dir_sd;
+	int error = 0;
+
+	dir_sd = sysfs_get_dirent(kobj->sd, NULL, group_name);
+	if (!dir_sd)
+		return -ENOENT;
+
+	error = sysfs_create_link_sd(dir_sd, target, link_name);
+	sysfs_put(dir_sd);
+
+	return error;
+}
+EXPORT_SYMBOL_GPL(sysfs_add_link_to_group);
+
+/**
+ * sysfs_remove_link_from_group - remove a symlink from an attribute group.
+ * @kobj:	The kobject containing the group.
+ * @group_name:	The name of the group.
+ * @link_name:	The name of the symlink to remove.
+ */
+void sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,
+				  const char *link_name)
+{
+	struct sysfs_dirent *dir_sd;
+
+	dir_sd = sysfs_get_dirent(kobj->sd, NULL, group_name);
+	if (dir_sd) {
+		sysfs_hash_and_remove(dir_sd, NULL, link_name);
+		sysfs_put(dir_sd);
+	}
+}
+EXPORT_SYMBOL_GPL(sysfs_remove_link_from_group);
 
 EXPORT_SYMBOL_GPL(sysfs_create_group);
 EXPORT_SYMBOL_GPL(sysfs_update_group);

commit 5631f2c18f4b2845b3e97df1c659c5094a17605f
Author: Bruno Prémont <bonbons@linux-vserver.org>
Date:   Tue Apr 3 09:59:48 2012 +0200

    sysfs: Prevent crash on unset sysfs group attributes
    
    Do not let the kernel crash when a device is registered with
    sysfs while group attributes are not set (aka NULL).
    
    Warn about the offender with some information about the offending
    device.
    
    This would warn instead of trying NULL pointer deref like:
     BUG: unable to handle kernel NULL pointer dereference at (null)
     IP: [<ffffffff81152673>] internal_create_group+0x83/0x1a0
     PGD 0
     Oops: 0000 [#1] SMP
     CPU 0
     Modules linked in:
    
     Pid: 1, comm: swapper/0 Not tainted 3.4.0-rc1-x86_64 #3 HP ProLiant DL360 G4
     RIP: 0010:[<ffffffff81152673>]  [<ffffffff81152673>] internal_create_group+0x83/0x1a0
     RSP: 0018:ffff88019485fd70  EFLAGS: 00010202
     RAX: 0000000000000001 RBX: 0000000000000000 RCX: 0000000000000001
     RDX: ffff880192e99908 RSI: ffff880192e99630 RDI: ffffffff81a26c60
     RBP: ffff88019485fdc0 R08: 0000000000000000 R09: 0000000000000000
     R10: ffff880192e99908 R11: 0000000000000000 R12: ffffffff81a16a00
     R13: ffff880192e99908 R14: ffffffff81a16900 R15: 0000000000000000
     FS:  0000000000000000(0000) GS:ffff88019bc00000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
     CR2: 0000000000000000 CR3: 0000000001a0c000 CR4: 00000000000007f0
     DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
     DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
     Process swapper/0 (pid: 1, threadinfo ffff88019485e000, task ffff880194878000)
     Stack:
      ffff88019485fdd0 ffff880192da9d60 0000000000000000 ffff880192e99908
      ffff880192e995d8 0000000000000001 ffffffff81a16a00 ffff880192da9d60
      0000000000000000 0000000000000000 ffff88019485fdd0 ffffffff811527be
     Call Trace:
      [<ffffffff811527be>] sysfs_create_group+0xe/0x10
      [<ffffffff81376ca6>] device_add_groups+0x46/0x80
      [<ffffffff81377d3d>] device_add+0x46d/0x6a0
      ...
    
    Signed-off-by: Bruno Prémont <bonbons@linux-vserver.org>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index dd1701caecc9..2df555c66d57 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -67,7 +67,11 @@ static int internal_create_group(struct kobject *kobj, int update,
 	/* Updates may happen before the object has been instantiated */
 	if (unlikely(update && !kobj->sd))
 		return -EINVAL;
-
+	if (!grp->attrs) {
+		WARN(1, "sysfs: attrs not set by subsystem for group: %s/%s\n",
+			kobj->name, grp->name ? "" : grp->name);
+		return -EINVAL;
+	}
 	if (grp->name) {
 		error = sysfs_create_subdir(kobj, grp->name, &sd);
 		if (error)

commit 587a1f1659e8b330b8738ef4901832a2b63f0bed
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 23 23:11:19 2011 -0400

    switch ->is_visible() to returning umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 194414f8298c..dd1701caecc9 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -33,7 +33,7 @@ static int create_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 	int error = 0, i;
 
 	for (i = 0, attr = grp->attrs; *attr && !error; i++, attr++) {
-		mode_t mode = 0;
+		umode_t mode = 0;
 
 		/* in update mode, we're changing the permissions or
 		 * visibility.  Do this by first removing then

commit 1f8e1cdac616e510eeb2dc2a9226bf597bc6cfd6
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Sat May 7 17:18:20 2011 -0400

    SYSFS: Fix erroneous comments for sysfs_update_group().
    
    Fix what is clearly a simple copy-and-paste error in commenting the
    sysfs_update_group() routine.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index c8769dc222d8..194414f8298c 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -101,9 +101,9 @@ int sysfs_create_group(struct kobject *kobj,
 }
 
 /**
- * sysfs_update_group - given a directory kobject, create an attribute group
- * @kobj:	The kobject to create the group on
- * @grp:	The attribute group to create
+ * sysfs_update_group - given a directory kobject, update an attribute group
+ * @kobj:	The kobject to update the group on
+ * @grp:	The attribute group to update
  *
  * This function updates an attribute group.  Unlike
  * sysfs_create_group(), it will explicitly not warn or error if any

commit e030d58e8860f1c87b17631dbdd70747cbe1fb5b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Nov 15 15:46:07 2010 -0500

    sysfs: remove useless test from sysfs_merge_group
    
    Dan Carpenter pointed out that the new sysfs_merge_group() and
    sysfs_unmerge_group() routines requires their grp argument to be
    non-NULL, because they dereference grp to obtain the list of
    attributes.  Hence it's pointless for the routines to include a test
    and special-case handling for when grp is NULL.  This patch (as1433)
    removes the unneeded tests.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 442f34ff1af8..c8769dc222d8 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -165,10 +165,7 @@ int sysfs_merge_group(struct kobject *kobj,
 	struct attribute *const *attr;
 	int i;
 
-	if (grp)
-		dir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);
-	else
-		dir_sd = sysfs_get(kobj->sd);
+	dir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);
 	if (!dir_sd)
 		return -ENOENT;
 
@@ -195,10 +192,7 @@ void sysfs_unmerge_group(struct kobject *kobj,
 	struct sysfs_dirent *dir_sd;
 	struct attribute *const *attr;
 
-	if (grp)
-		dir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);
-	else
-		dir_sd = sysfs_get(kobj->sd);
+	dir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);
 	if (dir_sd) {
 		for (attr = grp->attrs; *attr; ++attr)
 			sysfs_hash_and_remove(dir_sd, NULL, (*attr)->name);

commit 69d44ffbd772bede8c2a6d182e6e14f94826520b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Sep 25 23:34:22 2010 +0200

    sysfs: Add sysfs_merge_group() and sysfs_unmerge_group()
    
    This patch (as1420) adds sysfs_merge_group() and sysfs_unmerge_group()
    functions, allowing drivers easily to add and remove sets of
    attributes to a pre-existing attribute group directory.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 23c1e598792a..442f34ff1af8 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -148,6 +148,65 @@ void sysfs_remove_group(struct kobject * kobj,
 	sysfs_put(sd);
 }
 
+/**
+ * sysfs_merge_group - merge files into a pre-existing attribute group.
+ * @kobj:	The kobject containing the group.
+ * @grp:	The files to create and the attribute group they belong to.
+ *
+ * This function returns an error if the group doesn't exist or any of the
+ * files already exist in that group, in which case none of the new files
+ * are created.
+ */
+int sysfs_merge_group(struct kobject *kobj,
+		       const struct attribute_group *grp)
+{
+	struct sysfs_dirent *dir_sd;
+	int error = 0;
+	struct attribute *const *attr;
+	int i;
+
+	if (grp)
+		dir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);
+	else
+		dir_sd = sysfs_get(kobj->sd);
+	if (!dir_sd)
+		return -ENOENT;
+
+	for ((i = 0, attr = grp->attrs); *attr && !error; (++i, ++attr))
+		error = sysfs_add_file(dir_sd, *attr, SYSFS_KOBJ_ATTR);
+	if (error) {
+		while (--i >= 0)
+			sysfs_hash_and_remove(dir_sd, NULL, (*--attr)->name);
+	}
+	sysfs_put(dir_sd);
+
+	return error;
+}
+EXPORT_SYMBOL_GPL(sysfs_merge_group);
+
+/**
+ * sysfs_unmerge_group - remove files from a pre-existing attribute group.
+ * @kobj:	The kobject containing the group.
+ * @grp:	The files to remove and the attribute group they belong to.
+ */
+void sysfs_unmerge_group(struct kobject *kobj,
+		       const struct attribute_group *grp)
+{
+	struct sysfs_dirent *dir_sd;
+	struct attribute *const *attr;
+
+	if (grp)
+		dir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);
+	else
+		dir_sd = sysfs_get(kobj->sd);
+	if (dir_sd) {
+		for (attr = grp->attrs; *attr; ++attr)
+			sysfs_hash_and_remove(dir_sd, NULL, (*attr)->name);
+		sysfs_put(dir_sd);
+	}
+}
+EXPORT_SYMBOL_GPL(sysfs_unmerge_group);
+
 
 EXPORT_SYMBOL_GPL(sysfs_create_group);
 EXPORT_SYMBOL_GPL(sysfs_update_group);

commit 3ff195b011d7decf501a4d55aeed312731094796
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Mar 30 11:31:26 2010 -0700

    sysfs: Implement sysfs tagged directory support.
    
    The problem.  When implementing a network namespace I need to be able
    to have multiple network devices with the same name.  Currently this
    is a problem for /sys/class/net/*, /sys/devices/virtual/net/*, and
    potentially a few other directories of the form /sys/ ... /net/*.
    
    What this patch does is to add an additional tag field to the
    sysfs dirent structure.  For directories that should show different
    contents depending on the context such as /sys/class/net/, and
    /sys/devices/virtual/net/ this tag field is used to specify the
    context in which those directories should be visible.  Effectively
    this is the same as creating multiple distinct directories with
    the same name but internally to sysfs the result is nicer.
    
    I am calling the concept of a single directory that looks like multiple
    directories all at the same path in the filesystem tagged directories.
    
    For the networking namespace the set of directories whose contents I need
    to filter with tags can depend on the presence or absence of hotplug
    hardware or which modules are currently loaded.  Which means I need
    a simple race free way to setup those directories as tagged.
    
    To achieve a reace free design all tagged directories are created
    and managed by sysfs itself.
    
    Users of this interface:
    - define a type in the sysfs_tag_type enumeration.
    - call sysfs_register_ns_types with the type and it's operations
    - sysfs_exit_ns when an individual tag is no longer valid
    
    - Implement mount_ns() which returns the ns of the calling process
      so we can attach it to a sysfs superblock.
    - Implement ktype.namespace() which returns the ns of a syfs kobject.
    
    Everything else is left up to sysfs and the driver layer.
    
    For the network namespace mount_ns and namespace() are essentially
    one line functions, and look to remain that.
    
    Tags are currently represented a const void * pointers as that is
    both generic, prevides enough information for equality comparisons,
    and is trivial to create for current users, as it is just the
    existing namespace pointer.
    
    The work needed in sysfs is more extensive.  At each directory
    or symlink creating I need to check if the directory it is being
    created in is a tagged directory and if so generate the appropriate
    tag to place on the sysfs_dirent.  Likewise at each symlink or
    directory removal I need to check if the sysfs directory it is
    being removed from is a tagged directory and if so figure out
    which tag goes along with the name I am deleting.
    
    Currently only directories which hold kobjects, and
    symlinks are supported.  There is not enough information
    in the current file attribute interfaces to give us anything
    to discriminate on which makes it useless, and there are
    no potential users which makes it an uninteresting problem
    to solve.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Benjamin Thery <benjamin.thery@bull.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index fe611949a7f7..23c1e598792a 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -23,7 +23,7 @@ static void remove_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 	int i;
 
 	for (i = 0, attr = grp->attrs; *attr; i++, attr++)
-		sysfs_hash_and_remove(dir_sd, (*attr)->name);
+		sysfs_hash_and_remove(dir_sd, NULL, (*attr)->name);
 }
 
 static int create_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
@@ -39,7 +39,7 @@ static int create_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 		 * visibility.  Do this by first removing then
 		 * re-adding (if required) the file */
 		if (update)
-			sysfs_hash_and_remove(dir_sd, (*attr)->name);
+			sysfs_hash_and_remove(dir_sd, NULL, (*attr)->name);
 		if (grp->is_visible) {
 			mode = grp->is_visible(kobj, *attr, i);
 			if (!mode)
@@ -132,7 +132,7 @@ void sysfs_remove_group(struct kobject * kobj,
 	struct sysfs_dirent *sd;
 
 	if (grp->name) {
-		sd = sysfs_get_dirent(dir_sd, grp->name);
+		sd = sysfs_get_dirent(dir_sd, NULL, grp->name);
 		if (!sd) {
 			WARN(!sd, KERN_WARNING "sysfs group %p not found for "
 				"kobject '%s'\n", grp, kobject_name(kobj));

commit 99fcd77d15357e8ba51005c25cc750b9c28b2688
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Fri Jul 25 19:45:41 2008 -0700

    Use WARN() in fs/sysfs
    
    Use WARN() instead of a printk+WARN_ON() pair; this way the message becomes
    part of the warning section for better reporting/collection.  Also, with this,
    one fo the if() sections collapses entirely into the WARN().
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index eeba38417b1d..fe611949a7f7 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -134,9 +134,8 @@ void sysfs_remove_group(struct kobject * kobj,
 	if (grp->name) {
 		sd = sysfs_get_dirent(dir_sd, grp->name);
 		if (!sd) {
-			printk(KERN_WARNING "sysfs group %p not found for "
+			WARN(!sd, KERN_WARNING "sysfs group %p not found for "
 				"kobject '%s'\n", grp, kobject_name(kobj));
-			WARN_ON(!sd);
 			return;
 		}
 	} else

commit 0f4238958d28044b335644b69df6071cdb04b5ce
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Thu Mar 20 20:47:52 2008 -0500

    [SCSI] sysfs: make group is_valid return a mode_t
    
    We have a problem in scsi_transport_spi in that we need to customise
    not only the visibility of the attributes, but also their mode.  Fix
    this by making the is_visible() callback return a mode, with 0
    indicating is not visible.
    
    Also add a sysfs_update_group() API to allow us to change either the
    visibility or mode of the files at any time on the fly.
    
    Acked-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 477904915032..eeba38417b1d 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -23,35 +23,50 @@ static void remove_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 	int i;
 
 	for (i = 0, attr = grp->attrs; *attr; i++, attr++)
-		if (!grp->is_visible ||
-		    grp->is_visible(kobj, *attr, i))
-			sysfs_hash_and_remove(dir_sd, (*attr)->name);
+		sysfs_hash_and_remove(dir_sd, (*attr)->name);
 }
 
 static int create_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
-			const struct attribute_group *grp)
+			const struct attribute_group *grp, int update)
 {
 	struct attribute *const* attr;
 	int error = 0, i;
 
-	for (i = 0, attr = grp->attrs; *attr && !error; i++, attr++)
-		if (!grp->is_visible ||
-		    grp->is_visible(kobj, *attr, i))
-			error |=
-				sysfs_add_file(dir_sd, *attr, SYSFS_KOBJ_ATTR);
+	for (i = 0, attr = grp->attrs; *attr && !error; i++, attr++) {
+		mode_t mode = 0;
+
+		/* in update mode, we're changing the permissions or
+		 * visibility.  Do this by first removing then
+		 * re-adding (if required) the file */
+		if (update)
+			sysfs_hash_and_remove(dir_sd, (*attr)->name);
+		if (grp->is_visible) {
+			mode = grp->is_visible(kobj, *attr, i);
+			if (!mode)
+				continue;
+		}
+		error = sysfs_add_file_mode(dir_sd, *attr, SYSFS_KOBJ_ATTR,
+					    (*attr)->mode | mode);
+		if (unlikely(error))
+			break;
+	}
 	if (error)
 		remove_files(dir_sd, kobj, grp);
 	return error;
 }
 
 
-int sysfs_create_group(struct kobject * kobj, 
-		       const struct attribute_group * grp)
+static int internal_create_group(struct kobject *kobj, int update,
+				 const struct attribute_group *grp)
 {
 	struct sysfs_dirent *sd;
 	int error;
 
-	BUG_ON(!kobj || !kobj->sd);
+	BUG_ON(!kobj || (!update && !kobj->sd));
+
+	/* Updates may happen before the object has been instantiated */
+	if (unlikely(update && !kobj->sd))
+		return -EINVAL;
 
 	if (grp->name) {
 		error = sysfs_create_subdir(kobj, grp->name, &sd);
@@ -60,7 +75,7 @@ int sysfs_create_group(struct kobject * kobj,
 	} else
 		sd = kobj->sd;
 	sysfs_get(sd);
-	error = create_files(sd, kobj, grp);
+	error = create_files(sd, kobj, grp, update);
 	if (error) {
 		if (grp->name)
 			sysfs_remove_subdir(sd);
@@ -69,6 +84,47 @@ int sysfs_create_group(struct kobject * kobj,
 	return error;
 }
 
+/**
+ * sysfs_create_group - given a directory kobject, create an attribute group
+ * @kobj:	The kobject to create the group on
+ * @grp:	The attribute group to create
+ *
+ * This function creates a group for the first time.  It will explicitly
+ * warn and error if any of the attribute files being created already exist.
+ *
+ * Returns 0 on success or error.
+ */
+int sysfs_create_group(struct kobject *kobj,
+		       const struct attribute_group *grp)
+{
+	return internal_create_group(kobj, 0, grp);
+}
+
+/**
+ * sysfs_update_group - given a directory kobject, create an attribute group
+ * @kobj:	The kobject to create the group on
+ * @grp:	The attribute group to create
+ *
+ * This function updates an attribute group.  Unlike
+ * sysfs_create_group(), it will explicitly not warn or error if any
+ * of the attribute files being created already exist.  Furthermore,
+ * if the visibility of the files has changed through the is_visible()
+ * callback, it will update the permissions and add or remove the
+ * relevant files.
+ *
+ * The primary use for this function is to call it after making a change
+ * that affects group visibility.
+ *
+ * Returns 0 on success or error.
+ */
+int sysfs_update_group(struct kobject *kobj,
+		       const struct attribute_group *grp)
+{
+	return internal_create_group(kobj, 1, grp);
+}
+
+
+
 void sysfs_remove_group(struct kobject * kobj, 
 			const struct attribute_group * grp)
 {
@@ -95,4 +151,5 @@ void sysfs_remove_group(struct kobject * kobj,
 
 
 EXPORT_SYMBOL_GPL(sysfs_create_group);
+EXPORT_SYMBOL_GPL(sysfs_update_group);
 EXPORT_SYMBOL_GPL(sysfs_remove_group);

commit 969affd276dec81a35a5ad10d4e05e62e93b380b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Feb 7 11:58:54 2008 -0500

    sysfs: remove BUG_ON() from sysfs_remove_group()
    
    It's possible that the caller of sysfs_remove_group messed up and passed in an attribute group that was not really registered to this kobject.  But don't panic for such a foolish error, spit out a warning about what happened, and continue on our way safely.
    
    Cc: Roland Dreier <rdreier@cisco.com>
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 0871c3dadce1..477904915032 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -77,7 +77,12 @@ void sysfs_remove_group(struct kobject * kobj,
 
 	if (grp->name) {
 		sd = sysfs_get_dirent(dir_sd, grp->name);
-		BUG_ON(!sd);
+		if (!sd) {
+			printk(KERN_WARNING "sysfs group %p not found for "
+				"kobject '%s'\n", grp, kobject_name(kobj));
+			WARN_ON(!sd);
+			return;
+		}
 	} else
 		sd = sysfs_get(dir_sd);
 

commit d4acd722b7bb5f48b9fc3848e8c2a845b100d84f
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Wed Oct 31 09:38:04 2007 -0500

    [SCSI] sysfs: add filter function to groups
    
    This patch allows the various users of attribute_groups to selectively
    allow the appearance of group attributes.  The primary consumer of
    this will be the transport classes in which we currently have
    elaborate attribute selection algorithms to do this same thing.
    
    Acked-by: Greg KH <greg@kroah.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index d1972374655a..0871c3dadce1 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -16,25 +16,31 @@
 #include "sysfs.h"
 
 
-static void remove_files(struct sysfs_dirent *dir_sd,
+static void remove_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 			 const struct attribute_group *grp)
 {
 	struct attribute *const* attr;
+	int i;
 
-	for (attr = grp->attrs; *attr; attr++)
-		sysfs_hash_and_remove(dir_sd, (*attr)->name);
+	for (i = 0, attr = grp->attrs; *attr; i++, attr++)
+		if (!grp->is_visible ||
+		    grp->is_visible(kobj, *attr, i))
+			sysfs_hash_and_remove(dir_sd, (*attr)->name);
 }
 
-static int create_files(struct sysfs_dirent *dir_sd,
+static int create_files(struct sysfs_dirent *dir_sd, struct kobject *kobj,
 			const struct attribute_group *grp)
 {
 	struct attribute *const* attr;
-	int error = 0;
+	int error = 0, i;
 
-	for (attr = grp->attrs; *attr && !error; attr++)
-		error = sysfs_add_file(dir_sd, *attr, SYSFS_KOBJ_ATTR);
+	for (i = 0, attr = grp->attrs; *attr && !error; i++, attr++)
+		if (!grp->is_visible ||
+		    grp->is_visible(kobj, *attr, i))
+			error |=
+				sysfs_add_file(dir_sd, *attr, SYSFS_KOBJ_ATTR);
 	if (error)
-		remove_files(dir_sd, grp);
+		remove_files(dir_sd, kobj, grp);
 	return error;
 }
 
@@ -54,7 +60,7 @@ int sysfs_create_group(struct kobject * kobj,
 	} else
 		sd = kobj->sd;
 	sysfs_get(sd);
-	error = create_files(sd, grp);
+	error = create_files(sd, kobj, grp);
 	if (error) {
 		if (grp->name)
 			sysfs_remove_subdir(sd);
@@ -75,7 +81,7 @@ void sysfs_remove_group(struct kobject * kobj,
 	} else
 		sd = sysfs_get(dir_sd);
 
-	remove_files(sd, grp);
+	remove_files(sd, kobj, grp);
 	if (grp->name)
 		sysfs_remove_subdir(sd);
 

commit 90bc61359de0148f8627073d68a22edc7ed9893d
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Jul 31 19:15:08 2007 +0900

    sysfs: Remove first pass at shadow directory support
    
    While shadow directories appear to be a good idea, the current scheme
    of controlling their creation and destruction outside of sysfs appears
    to be a locking and maintenance nightmare in the face of sysfs
    directories dynamically coming and going.  Which can now occur for
    directories containing network devices when CONFIG_SYSFS_DEPRECATED is
    not set.
    
    This patch removes everything from the initial shadow directory support
    that allowed the shadow directory creation to be controlled at a higher
    level.  So except for a few bits of sysfs_rename_dir everything from
    commit b592fcfe7f06c15ec11774b5be7ce0de3aa86e73 is now gone.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index e6b904d71633..d1972374655a 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -13,7 +13,6 @@
 #include <linux/dcache.h>
 #include <linux/namei.h>
 #include <linux/err.h>
-#include <linux/fs.h>
 #include "sysfs.h"
 
 

commit 869512ab5ab93e5e82ad7d4aaf4ed098d23bfc3f
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Thu Jul 26 14:53:53 2007 +0000

    sysfs: cleanup semaphore.h
    
    Cleanup semaphore.h
    
    Signed-off-by: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index f318b73c790c..e6b904d71633 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -14,7 +14,6 @@
 #include <linux/namei.h>
 #include <linux/err.h>
 #include <linux/fs.h>
-#include <asm/semaphore.h>
 #include "sysfs.h"
 
 

commit 608e266a2d4e62c1b98c1c573064b6afe8c06a58
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jun 14 04:27:22 2007 +0900

    sysfs: make kobj point to sysfs_dirent instead of dentry
    
    As kobj sysfs dentries and inodes are gonna be made reclaimable,
    dentry can't be used as naming token for sysfs file/directory, replace
    kobj->dentry with kobj->sd.  The only external interface change is
    shadow directory handling.  All other changes are contained in kobj
    and sysfs.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 52eed2a7a5ef..f318b73c790c 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -18,26 +18,25 @@
 #include "sysfs.h"
 
 
-static void remove_files(struct dentry * dir, 
-			 const struct attribute_group * grp)
+static void remove_files(struct sysfs_dirent *dir_sd,
+			 const struct attribute_group *grp)
 {
 	struct attribute *const* attr;
 
 	for (attr = grp->attrs; *attr; attr++)
-		sysfs_hash_and_remove(dir,(*attr)->name);
+		sysfs_hash_and_remove(dir_sd, (*attr)->name);
 }
 
-static int create_files(struct dentry * dir,
-			const struct attribute_group * grp)
+static int create_files(struct sysfs_dirent *dir_sd,
+			const struct attribute_group *grp)
 {
 	struct attribute *const* attr;
 	int error = 0;
 
-	for (attr = grp->attrs; *attr && !error; attr++) {
-		error = sysfs_add_file(dir, *attr, SYSFS_KOBJ_ATTR);
-	}
+	for (attr = grp->attrs; *attr && !error; attr++)
+		error = sysfs_add_file(dir_sd, *attr, SYSFS_KOBJ_ATTR);
 	if (error)
-		remove_files(dir,grp);
+		remove_files(dir_sd, grp);
 	return error;
 }
 
@@ -45,44 +44,44 @@ static int create_files(struct dentry * dir,
 int sysfs_create_group(struct kobject * kobj, 
 		       const struct attribute_group * grp)
 {
-	struct dentry * dir;
+	struct sysfs_dirent *sd;
 	int error;
 
-	BUG_ON(!kobj || !kobj->dentry);
+	BUG_ON(!kobj || !kobj->sd);
 
 	if (grp->name) {
-		error = sysfs_create_subdir(kobj,grp->name,&dir);
+		error = sysfs_create_subdir(kobj, grp->name, &sd);
 		if (error)
 			return error;
 	} else
-		dir = kobj->dentry;
-	dir = dget(dir);
-	if ((error = create_files(dir,grp))) {
+		sd = kobj->sd;
+	sysfs_get(sd);
+	error = create_files(sd, grp);
+	if (error) {
 		if (grp->name)
-			sysfs_remove_subdir(dir);
+			sysfs_remove_subdir(sd);
 	}
-	dput(dir);
+	sysfs_put(sd);
 	return error;
 }
 
 void sysfs_remove_group(struct kobject * kobj, 
 			const struct attribute_group * grp)
 {
-	struct dentry * dir;
+	struct sysfs_dirent *dir_sd = kobj->sd;
+	struct sysfs_dirent *sd;
 
 	if (grp->name) {
-		dir = lookup_one_len_kern(grp->name, kobj->dentry,
-				strlen(grp->name));
-		BUG_ON(IS_ERR(dir));
-	}
-	else
-		dir = dget(kobj->dentry);
+		sd = sysfs_get_dirent(dir_sd, grp->name);
+		BUG_ON(!sd);
+	} else
+		sd = sysfs_get(dir_sd);
 
-	remove_files(dir,grp);
+	remove_files(sd, grp);
 	if (grp->name)
-		sysfs_remove_subdir(dir);
-	/* release the ref. taken in this routine */
-	dput(dir);
+		sysfs_remove_subdir(sd);
+
+	sysfs_put(sd);
 }
 
 

commit 057f6c019fff9ee290641d50647359bb8898918e
Author: James Morris <jmorris@namei.org>
Date:   Thu Apr 26 00:12:05 2007 -0700

    security: prevent permission checking of file removal via sysfs_remove_group()
    
    Prevent permission checking from being performed when the kernel wants to
    unconditionally remove a sysfs group, by introducing an kernel-only variant
    of lookup_one_len(), lookup_one_len_kern().
    
    Additionally, as sysfs_remove_group() does not check the return value of
    the lookup before using it, a BUG_ON has been added to pinpoint the cause
    of any problems potentially caused by this (and as a form of annotation).
    
    Signed-off-by: James Morris <jmorris@namei.org>
    Cc: Nagendra Singh Tomar <nagendra_tomar@adaptec.com>
    Cc: Tejun Heo <htejun@gmail.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Eric Paris <eparis@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index b20951c93761..52eed2a7a5ef 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -70,9 +70,11 @@ void sysfs_remove_group(struct kobject * kobj,
 {
 	struct dentry * dir;
 
-	if (grp->name)
-		dir = lookup_one_len(grp->name, kobj->dentry,
+	if (grp->name) {
+		dir = lookup_one_len_kern(grp->name, kobj->dentry,
 				strlen(grp->name));
+		BUG_ON(IS_ERR(dir));
+	}
 	else
 		dir = dget(kobj->dentry);
 

commit b592fcfe7f06c15ec11774b5be7ce0de3aa86e73
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Jan 24 12:35:52 2007 -0700

    sysfs: Shadow directory support
    
    The problem.  When implementing a network namespace I need to be able
    to have multiple network devices with the same name.  Currently this
    is a problem for /sys/class/net/*.
    
    What I want is a separate /sys/class/net directory in sysfs for each
    network namespace, and I want to name each of them /sys/class/net.
    
    I looked and the VFS actually allows that.  All that is needed is
    for /sys/class/net to implement a follow link method to redirect
    lookups to the real directory you want.
    
    Implementing a follow link method that is sensitive to the current
    network namespace turns out to be 3 lines of code so it looks like a
    clean approach.  Modifying sysfs so it doesn't get in my was is a bit
    trickier.
    
    I am calling the concept of multiple directories all at the same path
    in the filesystem shadow directories.  With the directory entry really
    at that location the shadow master.
    
    The following patch modifies sysfs so it can handle a directory
    structure slightly different from the kobject tree so I can implement
    the shadow directories for handling /sys/class/net/.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Maneesh Soni <maneesh@in.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 46a277b0838e..b20951c93761 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -13,6 +13,7 @@
 #include <linux/dcache.h>
 #include <linux/namei.h>
 #include <linux/err.h>
+#include <linux/fs.h>
 #include <asm/semaphore.h>
 #include "sysfs.h"
 

commit 94bebf4d1b8e7719f0f3944c037a21cfd99a4af7
Author: Oliver Neukum <oliver@neukum.org>
Date:   Wed Dec 20 10:52:44 2006 +0100

    Driver core: fix race in sysfs between sysfs_remove_file() and read()/write()
    
    This patch prevents a race between IO and removing a file from sysfs.
    It introduces a list of sysfs_buffers associated with a file at the inode.
    Upon removal of a file the list is walked and the buffers marked orphaned.
    IO to orphaned buffers fails with -ENODEV. The driver can safely free
    associated data structures or be unloaded.
    
    Signed-off-by: Oliver Neukum <oliver@neukum.name>
    Acked-by: Maneesh Soni <maneesh@in.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 122145b0895c..46a277b0838e 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -13,6 +13,7 @@
 #include <linux/dcache.h>
 #include <linux/namei.h>
 #include <linux/err.h>
+#include <asm/semaphore.h>
 #include "sysfs.h"
 
 

commit 5f45f1a78fbac3cc859ec10c5366e97d20d40fa2
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Jun 23 00:09:12 2005 -0700

    [PATCH] remove duplicate get_dentry functions in various places
    
    Various filesystem drivers have grown a get_dentry() function that's a
    duplicate of lookup_one_len, except that it doesn't take a maximum length
    argument and doesn't check for \0 or / in the passed in filename.
    
    Switch all these places to use lookup_one_len.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Greg KH <greg@kroah.com>
    Cc: Paul Jackson <pj@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index f11ac5ea7021..122145b0895c 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -11,6 +11,7 @@
 #include <linux/kobject.h>
 #include <linux/module.h>
 #include <linux/dcache.h>
+#include <linux/namei.h>
 #include <linux/err.h>
 #include "sysfs.h"
 
@@ -68,7 +69,8 @@ void sysfs_remove_group(struct kobject * kobj,
 	struct dentry * dir;
 
 	if (grp->name)
-		dir = sysfs_get_dentry(kobj->dentry,grp->name);
+		dir = lookup_one_len(grp->name, kobj->dentry,
+				strlen(grp->name));
 	else
 		dir = dget(kobj->dentry);
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
new file mode 100644
index 000000000000..f11ac5ea7021
--- /dev/null
+++ b/fs/sysfs/group.c
@@ -0,0 +1,84 @@
+/*
+ * fs/sysfs/group.c - Operations for adding/removing multiple files at once.
+ *
+ * Copyright (c) 2003 Patrick Mochel
+ * Copyright (c) 2003 Open Source Development Lab
+ *
+ * This file is released undert the GPL v2. 
+ *
+ */
+
+#include <linux/kobject.h>
+#include <linux/module.h>
+#include <linux/dcache.h>
+#include <linux/err.h>
+#include "sysfs.h"
+
+
+static void remove_files(struct dentry * dir, 
+			 const struct attribute_group * grp)
+{
+	struct attribute *const* attr;
+
+	for (attr = grp->attrs; *attr; attr++)
+		sysfs_hash_and_remove(dir,(*attr)->name);
+}
+
+static int create_files(struct dentry * dir,
+			const struct attribute_group * grp)
+{
+	struct attribute *const* attr;
+	int error = 0;
+
+	for (attr = grp->attrs; *attr && !error; attr++) {
+		error = sysfs_add_file(dir, *attr, SYSFS_KOBJ_ATTR);
+	}
+	if (error)
+		remove_files(dir,grp);
+	return error;
+}
+
+
+int sysfs_create_group(struct kobject * kobj, 
+		       const struct attribute_group * grp)
+{
+	struct dentry * dir;
+	int error;
+
+	BUG_ON(!kobj || !kobj->dentry);
+
+	if (grp->name) {
+		error = sysfs_create_subdir(kobj,grp->name,&dir);
+		if (error)
+			return error;
+	} else
+		dir = kobj->dentry;
+	dir = dget(dir);
+	if ((error = create_files(dir,grp))) {
+		if (grp->name)
+			sysfs_remove_subdir(dir);
+	}
+	dput(dir);
+	return error;
+}
+
+void sysfs_remove_group(struct kobject * kobj, 
+			const struct attribute_group * grp)
+{
+	struct dentry * dir;
+
+	if (grp->name)
+		dir = sysfs_get_dentry(kobj->dentry,grp->name);
+	else
+		dir = dget(kobj->dentry);
+
+	remove_files(dir,grp);
+	if (grp->name)
+		sysfs_remove_subdir(dir);
+	/* release the ref. taken in this routine */
+	dput(dir);
+}
+
+
+EXPORT_SYMBOL_GPL(sysfs_create_group);
+EXPORT_SYMBOL_GPL(sysfs_remove_group);
