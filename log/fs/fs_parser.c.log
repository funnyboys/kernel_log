commit c537338c055455040c597eeb305b225fa985711c
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Apr 1 21:04:13 2020 -0700

    fs_parse: remove pr_notice() about each validation
    
    This notice fills my boot logs with scary-looking asterisks but doesn't
    really tell me anything.  Let's just remove it; validation errors are
    already reported separately, so this is just a redundant list of
    filesystems.
    
    $ dmesg | grep VALIDATE
    [    0.306256] *** VALIDATE tmpfs ***
    [    0.307422] *** VALIDATE proc ***
    [    0.308355] *** VALIDATE cgroup ***
    [    0.308741] *** VALIDATE cgroup2 ***
    [    0.813256] *** VALIDATE bpf ***
    [    0.815272] *** VALIDATE ramfs ***
    [    0.815665] *** VALIDATE hugetlbfs ***
    [    0.876970] *** VALIDATE nfs ***
    [    0.877383] *** VALIDATE nfs4 ***
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Seth Arnold <seth.arnold@canonical.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Link: http://lkml.kernel.org/r/202003061617.A8835CAAF@keescook
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
index 7e6fb43f9541..ab53e42a874a 100644
--- a/fs/fs_parser.c
+++ b/fs/fs_parser.c
@@ -368,8 +368,6 @@ bool fs_validate_description(const char *name,
 	const struct fs_parameter_spec *param, *p2;
 	bool good = true;
 
-	pr_notice("*** VALIDATE %s ***\n", name);
-
 	for (param = desc; param->name; param++) {
 		/* Check for duplicate parameter names */
 		for (p2 = desc; p2 < param; p2++) {

commit 328de5287b10abc967c517461cf2948bd8a5b4e9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Dec 18 00:02:31 2019 -0500

    turn fs_param_is_... into functions
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
index db940fac84c3..7e6fb43f9541 100644
--- a/fs/fs_parser.c
+++ b/fs/fs_parser.c
@@ -48,7 +48,7 @@ EXPORT_SYMBOL(lookup_constant);
 
 static inline bool is_flag(const struct fs_parameter_spec *p)
 {
-	return p->type == fs_param_is_flag;
+	return p->type == NULL;
 }
 
 static const struct fs_parameter_spec *fs_lookup_key(
@@ -106,8 +106,6 @@ int __fs_parse(struct p_log *log,
 	     struct fs_parse_result *result)
 {
 	const struct fs_parameter_spec *p;
-	const struct constant_table *e;
-	int ret = -ENOPARAM, b;
 
 	result->uint_64 = 0;
 
@@ -121,96 +119,17 @@ int __fs_parse(struct p_log *log,
 	/* Try to turn the type we were given into the type desired by the
 	 * parameter and give an error if we can't.
 	 */
-	switch (p->type) {
-	case __fs_param_wasnt_defined:
-		return -EINVAL;
-	case fs_param_is_flag:
+	if (is_flag(p)) {
 		if (param->type != fs_value_is_flag)
 			return inval_plog(log, "Unexpected value for '%s'",
 				      param->key);
 		result->boolean = !result->negated;
-		goto okay;
-	case fs_param_is_bool:
-		if (param->type != fs_value_is_string)
-			goto bad_value;
-		b = lookup_constant(bool_names, param->string, -1);
-		if (b == -1)
-			goto bad_value;
-		result->boolean = b;
-		goto okay;
-	case fs_param_is_u32:
-		if (param->type != fs_value_is_string)
-			goto bad_value;
-		ret = kstrtouint(param->string, 0, &result->uint_32);
-		goto maybe_okay;
-	case fs_param_is_u32_octal:
-		if (param->type != fs_value_is_string)
-			goto bad_value;
-		ret = kstrtouint(param->string, 8, &result->uint_32);
-		goto maybe_okay;
-	case fs_param_is_u32_hex:
-		if (param->type != fs_value_is_string)
-			goto bad_value;
-		ret = kstrtouint(param->string, 16, &result->uint_32);
-		goto maybe_okay;
-	case fs_param_is_s32:
-		if (param->type != fs_value_is_string)
-			goto bad_value;
-		ret = kstrtoint(param->string, 0, &result->int_32);
-		goto maybe_okay;
-	case fs_param_is_u64:
-		if (param->type != fs_value_is_string)
-			goto bad_value;
-		ret = kstrtoull(param->string, 0, &result->uint_64);
-		goto maybe_okay;
-	case fs_param_is_enum:
-		if (param->type != fs_value_is_string)
-			goto bad_value;
-		e = __lookup_constant(p->data, param->string);
-		if (e) {
-			result->uint_32 = e->value;
-			goto okay;
-		}
-		goto bad_value;
-	case fs_param_is_string:
-		if (param->type != fs_value_is_string || !*param->string)
-			goto bad_value;
-		goto okay;
-	case fs_param_is_blob:
-		if (param->type != fs_value_is_blob)
-			goto bad_value;
-		goto okay;
-	case fs_param_is_fd: {
-		switch (param->type) {
-		case fs_value_is_string:
-			ret = kstrtouint(param->string, 0, &result->uint_32);
-			break;
-		case fs_value_is_file:
-			result->uint_32 = param->dirfd;
-			ret = 0;
-		default:
-			goto bad_value;
-		}
-
-		if (result->uint_32 > INT_MAX)
-			goto bad_value;
-		goto maybe_okay;
+	} else  {
+		int ret = p->type(log, p, param, result);
+		if (ret)
+			return ret;
 	}
-	case fs_param_is_blockdev:
-	case fs_param_is_path:
-		goto okay;
-	default:
-		BUG();
-	}
-
-maybe_okay:
-	if (ret < 0)
-		goto bad_value;
-okay:
 	return p->opt;
-
-bad_value:
-	return inval_plog(log, "Bad value for '%s'", param->key);
 }
 EXPORT_SYMBOL(__fs_parse);
 
@@ -270,6 +189,124 @@ int fs_lookup_param(struct fs_context *fc,
 }
 EXPORT_SYMBOL(fs_lookup_param);
 
+int fs_param_bad_value(struct p_log *log, struct fs_parameter *param)
+{
+	return inval_plog(log, "Bad value for '%s'", param->key);
+}
+
+int fs_param_is_bool(struct p_log *log, const struct fs_parameter_spec *p,
+		     struct fs_parameter *param, struct fs_parse_result *result)
+{
+	int b;
+	if (param->type != fs_value_is_string)
+		return fs_param_bad_value(log, param);
+	b = lookup_constant(bool_names, param->string, -1);
+	if (b == -1)
+		return fs_param_bad_value(log, param);
+	result->boolean = b;
+	return 0;
+}
+EXPORT_SYMBOL(fs_param_is_bool);
+
+int fs_param_is_u32(struct p_log *log, const struct fs_parameter_spec *p,
+		    struct fs_parameter *param, struct fs_parse_result *result)
+{
+	int base = (unsigned long)p->data;
+	if (param->type != fs_value_is_string ||
+	    kstrtouint(param->string, base, &result->uint_32) < 0)
+		return fs_param_bad_value(log, param);
+	return 0;
+}
+EXPORT_SYMBOL(fs_param_is_u32);
+
+int fs_param_is_s32(struct p_log *log, const struct fs_parameter_spec *p,
+		    struct fs_parameter *param, struct fs_parse_result *result)
+{
+	if (param->type != fs_value_is_string ||
+	    kstrtoint(param->string, 0, &result->int_32) < 0)
+		return fs_param_bad_value(log, param);
+	return 0;
+}
+EXPORT_SYMBOL(fs_param_is_s32);
+
+int fs_param_is_u64(struct p_log *log, const struct fs_parameter_spec *p,
+		    struct fs_parameter *param, struct fs_parse_result *result)
+{
+	if (param->type != fs_value_is_string ||
+	    kstrtoull(param->string, 0, &result->uint_64) < 0)
+		return fs_param_bad_value(log, param);
+	return 0;
+}
+EXPORT_SYMBOL(fs_param_is_u64);
+
+int fs_param_is_enum(struct p_log *log, const struct fs_parameter_spec *p,
+		     struct fs_parameter *param, struct fs_parse_result *result)
+{
+	const struct constant_table *c;
+	if (param->type != fs_value_is_string)
+		return fs_param_bad_value(log, param);
+	c = __lookup_constant(p->data, param->string);
+	if (!c)
+		return fs_param_bad_value(log, param);
+	result->uint_32 = c->value;
+	return 0;
+}
+EXPORT_SYMBOL(fs_param_is_enum);
+
+int fs_param_is_string(struct p_log *log, const struct fs_parameter_spec *p,
+		       struct fs_parameter *param, struct fs_parse_result *result)
+{
+	if (param->type != fs_value_is_string || !*param->string)
+		return fs_param_bad_value(log, param);
+	return 0;
+}
+EXPORT_SYMBOL(fs_param_is_string);
+
+int fs_param_is_blob(struct p_log *log, const struct fs_parameter_spec *p,
+		     struct fs_parameter *param, struct fs_parse_result *result)
+{
+	if (param->type != fs_value_is_blob)
+		return fs_param_bad_value(log, param);
+	return 0;
+}
+EXPORT_SYMBOL(fs_param_is_blob);
+
+int fs_param_is_fd(struct p_log *log, const struct fs_parameter_spec *p,
+		  struct fs_parameter *param, struct fs_parse_result *result)
+{
+	switch (param->type) {
+	case fs_value_is_string:
+		if (kstrtouint(param->string, 0, &result->uint_32) < 0)
+			break;
+		if (result->uint_32 <= INT_MAX)
+			return 0;
+		break;
+	case fs_value_is_file:
+		result->uint_32 = param->dirfd;
+		if (result->uint_32 <= INT_MAX)
+			return 0;
+		break;
+	default:
+		break;
+	}
+	return fs_param_bad_value(log, param);
+}
+EXPORT_SYMBOL(fs_param_is_fd);
+
+int fs_param_is_blockdev(struct p_log *log, const struct fs_parameter_spec *p,
+		  struct fs_parameter *param, struct fs_parse_result *result)
+{
+	return 0;
+}
+EXPORT_SYMBOL(fs_param_is_blockdev);
+
+int fs_param_is_path(struct p_log *log, const struct fs_parameter_spec *p,
+		     struct fs_parameter *param, struct fs_parse_result *result)
+{
+	return 0;
+}
+EXPORT_SYMBOL(fs_param_is_path);
+
 #ifdef CONFIG_VALIDATE_FS_PARSER
 /**
  * validate_constant_table - Validate a constant table
@@ -334,23 +371,6 @@ bool fs_validate_description(const char *name,
 	pr_notice("*** VALIDATE %s ***\n", name);
 
 	for (param = desc; param->name; param++) {
-		enum fs_parameter_type t = param->type;
-
-		/* Check that the type is in range */
-		if (t == __fs_param_wasnt_defined ||
-		    t >= nr__fs_parameter_type) {
-			pr_err("VALIDATE %s: PARAM[%s] Bad type %u\n",
-			       name, param->name, t);
-			good = false;
-		} else if (t == fs_param_is_enum) {
-			const struct constant_table *e = param->data;
-			if (!e || !e->name) {
-				pr_err("VALIDATE %s: PARAM[%s] enum with no values\n",
-				       name, param->name);
-				good = false;
-			}
-		}
-
 		/* Check for duplicate parameter names */
 		for (p2 = desc; p2 < param; p2++) {
 			if (strcmp(param->name, p2->name) == 0) {

commit 48ce73b1bef20331007b35de7ade8fe26cd55e84
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 17 20:03:59 2019 -0500

    fs_parse: handle optional arguments sanely
    
    Don't bother with "mixed" options that would allow both the
    form with and without argument (i.e. both -o foo and -o foo=bar).
    Rather than trying to shove both into a single fs_parameter_spec,
    allow having with-argument and no-argument specs with the same
    name and teach fs_parse to handle that.
    
    There are very few options of that sort, and they are actually
    easier to handle that way - callers end up with less postprocessing.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
index 5f8c06a1fb93..db940fac84c3 100644
--- a/fs/fs_parser.c
+++ b/fs/fs_parser.c
@@ -46,19 +46,40 @@ int lookup_constant(const struct constant_table *tbl, const char *name, int not_
 }
 EXPORT_SYMBOL(lookup_constant);
 
+static inline bool is_flag(const struct fs_parameter_spec *p)
+{
+	return p->type == fs_param_is_flag;
+}
+
 static const struct fs_parameter_spec *fs_lookup_key(
 	const struct fs_parameter_spec *desc,
-	const char *name)
+	struct fs_parameter *param, bool *negated)
 {
-	const struct fs_parameter_spec *p;
-	if (!desc)
-		return NULL;
-
-	for (p = desc; p->name; p++)
-		if (strcmp(p->name, name) == 0)
+	const struct fs_parameter_spec *p, *other = NULL;
+	const char *name = param->key;
+	bool want_flag = param->type == fs_value_is_flag;
+
+	*negated = false;
+	for (p = desc; p->name; p++) {
+		if (strcmp(p->name, name) != 0)
+			continue;
+		if (likely(is_flag(p) == want_flag))
 			return p;
-
-	return NULL;
+		other = p;
+	}
+	if (want_flag) {
+		if (name[0] == 'n' && name[1] == 'o' && name[2]) {
+			for (p = desc; p->name; p++) {
+				if (strcmp(p->name, name + 2) != 0)
+					continue;
+				if (!(p->flags & fs_param_neg_with_no))
+					continue;
+				*negated = true;
+				return p;
+			}
+		}
+	}
+	return other;
 }
 
 /*
@@ -88,123 +109,77 @@ int __fs_parse(struct p_log *log,
 	const struct constant_table *e;
 	int ret = -ENOPARAM, b;
 
-	result->negated = false;
 	result->uint_64 = 0;
 
-	p = fs_lookup_key(desc, param->key);
-	if (!p) {
-		/* If we didn't find something that looks like "noxxx", see if
-		 * "xxx" takes the "no"-form negative - but only if there
-		 * wasn't an value.
-		 */
-		if (param->type != fs_value_is_flag)
-			goto unknown_parameter;
-		if (param->key[0] != 'n' || param->key[1] != 'o' || !param->key[2])
-			goto unknown_parameter;
-
-		p = fs_lookup_key(desc, param->key + 2);
-		if (!p)
-			goto unknown_parameter;
-		if (!(p->flags & fs_param_neg_with_no))
-			goto unknown_parameter;
-		result->boolean = false;
-		result->negated = true;
-	}
+	p = fs_lookup_key(desc, param, &result->negated);
+	if (!p)
+		return -ENOPARAM;
 
 	if (p->flags & fs_param_deprecated)
 		warn_plog(log, "Deprecated parameter '%s'", param->key);
 
-	if (result->negated)
-		goto okay;
-
-	/* Certain parameter types only take a string and convert it. */
-	switch (p->type) {
-	case __fs_param_wasnt_defined:
-		return -EINVAL;
-	case fs_param_is_u32:
-	case fs_param_is_u32_octal:
-	case fs_param_is_u32_hex:
-	case fs_param_is_s32:
-	case fs_param_is_u64:
-	case fs_param_is_enum:
-	case fs_param_is_string:
-		if (param->type == fs_value_is_string) {
-			if (p->flags & fs_param_v_optional)
-				break;
-			if (!*param->string)
-				goto bad_value;
-			break;
-		}
-		if (param->type == fs_value_is_flag) {
-			if (p->flags & fs_param_v_optional)
-				goto okay;
-		}
-		goto bad_value;
-	default:
-		break;
-	}
-
 	/* Try to turn the type we were given into the type desired by the
 	 * parameter and give an error if we can't.
 	 */
 	switch (p->type) {
+	case __fs_param_wasnt_defined:
+		return -EINVAL;
 	case fs_param_is_flag:
 		if (param->type != fs_value_is_flag)
 			return inval_plog(log, "Unexpected value for '%s'",
 				      param->key);
-		result->boolean = true;
+		result->boolean = !result->negated;
 		goto okay;
-
 	case fs_param_is_bool:
-		switch (param->type) {
-		case fs_value_is_flag:
-			result->boolean = true;
-			goto okay;
-		case fs_value_is_string:
-			if (param->size == 0) {
-				result->boolean = true;
-				goto okay;
-			}
-			b = lookup_constant(bool_names, param->string, -1);
-			if (b == -1)
-				goto bad_value;
-			result->boolean = b;
-			goto okay;
-		default:
+		if (param->type != fs_value_is_string)
 			goto bad_value;
-		}
-
+		b = lookup_constant(bool_names, param->string, -1);
+		if (b == -1)
+			goto bad_value;
+		result->boolean = b;
+		goto okay;
 	case fs_param_is_u32:
+		if (param->type != fs_value_is_string)
+			goto bad_value;
 		ret = kstrtouint(param->string, 0, &result->uint_32);
 		goto maybe_okay;
 	case fs_param_is_u32_octal:
+		if (param->type != fs_value_is_string)
+			goto bad_value;
 		ret = kstrtouint(param->string, 8, &result->uint_32);
 		goto maybe_okay;
 	case fs_param_is_u32_hex:
+		if (param->type != fs_value_is_string)
+			goto bad_value;
 		ret = kstrtouint(param->string, 16, &result->uint_32);
 		goto maybe_okay;
 	case fs_param_is_s32:
+		if (param->type != fs_value_is_string)
+			goto bad_value;
 		ret = kstrtoint(param->string, 0, &result->int_32);
 		goto maybe_okay;
 	case fs_param_is_u64:
+		if (param->type != fs_value_is_string)
+			goto bad_value;
 		ret = kstrtoull(param->string, 0, &result->uint_64);
 		goto maybe_okay;
-
 	case fs_param_is_enum:
+		if (param->type != fs_value_is_string)
+			goto bad_value;
 		e = __lookup_constant(p->data, param->string);
 		if (e) {
 			result->uint_32 = e->value;
 			goto okay;
 		}
 		goto bad_value;
-
 	case fs_param_is_string:
+		if (param->type != fs_value_is_string || !*param->string)
+			goto bad_value;
 		goto okay;
 	case fs_param_is_blob:
 		if (param->type != fs_value_is_blob)
 			goto bad_value;
 		goto okay;
-
 	case fs_param_is_fd: {
 		switch (param->type) {
 		case fs_value_is_string:
@@ -221,7 +196,6 @@ int __fs_parse(struct p_log *log,
 			goto bad_value;
 		goto maybe_okay;
 	}
-
 	case fs_param_is_blockdev:
 	case fs_param_is_path:
 		goto okay;
@@ -237,8 +211,6 @@ int __fs_parse(struct p_log *log,
 
 bad_value:
 	return inval_plog(log, "Bad value for '%s'", param->key);
-unknown_parameter:
-	return -ENOPARAM;
 }
 EXPORT_SYMBOL(__fs_parse);
 
@@ -382,6 +354,8 @@ bool fs_validate_description(const char *name,
 		/* Check for duplicate parameter names */
 		for (p2 = desc; p2 < param; p2++) {
 			if (strcmp(param->name, p2->name) == 0) {
+				if (is_flag(param) != is_flag(p2))
+					continue;
 				pr_err("VALIDATE %s: PARAM[%s]: Duplicate\n",
 				       name, param->name);
 				good = false;

commit d7167b149943e38ad610191ecbb0800c78bbced9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Sep 7 07:23:15 2019 -0400

    fs_parse: fold fs_parameter_desc/fs_parameter_spec
    
    The former contains nothing but a pointer to an array of the latter...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
index 3ed1e49d8267..5f8c06a1fb93 100644
--- a/fs/fs_parser.c
+++ b/fs/fs_parser.c
@@ -47,15 +47,14 @@ int lookup_constant(const struct constant_table *tbl, const char *name, int not_
 EXPORT_SYMBOL(lookup_constant);
 
 static const struct fs_parameter_spec *fs_lookup_key(
-	const struct fs_parameter_description *desc,
+	const struct fs_parameter_spec *desc,
 	const char *name)
 {
 	const struct fs_parameter_spec *p;
-
-	if (!desc->specs)
+	if (!desc)
 		return NULL;
 
-	for (p = desc->specs; p->name; p++)
+	for (p = desc; p->name; p++)
 		if (strcmp(p->name, name) == 0)
 			return p;
 
@@ -81,7 +80,7 @@ static const struct fs_parameter_spec *fs_lookup_key(
  * the parameter wasn't recognised and unknowns aren't okay.
  */
 int __fs_parse(struct p_log *log,
-	     const struct fs_parameter_description *desc,
+	     const struct fs_parameter_spec *desc,
 	     struct fs_parameter *param,
 	     struct fs_parse_result *result)
 {
@@ -355,39 +354,37 @@ bool validate_constant_table(const struct constant_table *tbl, size_t tbl_size,
  * @desc: The parameter description to validate.
  */
 bool fs_validate_description(const char *name,
-	const struct fs_parameter_description *desc)
+	const struct fs_parameter_spec *desc)
 {
 	const struct fs_parameter_spec *param, *p2;
 	bool good = true;
 
 	pr_notice("*** VALIDATE %s ***\n", name);
 
-	if (desc->specs) {
-		for (param = desc->specs; param->name; param++) {
-			enum fs_parameter_type t = param->type;
+	for (param = desc; param->name; param++) {
+		enum fs_parameter_type t = param->type;
 
-			/* Check that the type is in range */
-			if (t == __fs_param_wasnt_defined ||
-			    t >= nr__fs_parameter_type) {
-				pr_err("VALIDATE %s: PARAM[%s] Bad type %u\n",
-				       name, param->name, t);
+		/* Check that the type is in range */
+		if (t == __fs_param_wasnt_defined ||
+		    t >= nr__fs_parameter_type) {
+			pr_err("VALIDATE %s: PARAM[%s] Bad type %u\n",
+			       name, param->name, t);
+			good = false;
+		} else if (t == fs_param_is_enum) {
+			const struct constant_table *e = param->data;
+			if (!e || !e->name) {
+				pr_err("VALIDATE %s: PARAM[%s] enum with no values\n",
+				       name, param->name);
 				good = false;
-			} else if (t == fs_param_is_enum) {
-				const struct constant_table *e = param->data;
-				if (!e || !e->name) {
-					pr_err("VALIDATE %s: PARAM[%s] enum with no values\n",
-					       name, param->name);
-					good = false;
-				}
 			}
+		}
 
-			/* Check for duplicate parameter names */
-			for (p2 = desc->specs; p2 < param; p2++) {
-				if (strcmp(param->name, p2->name) == 0) {
-					pr_err("VALIDATE %s: PARAM[%s]: Duplicate\n",
-					       name, param->name);
-					good = false;
-				}
+		/* Check for duplicate parameter names */
+		for (p2 = desc; p2 < param; p2++) {
+			if (strcmp(param->name, p2->name) == 0) {
+				pr_err("VALIDATE %s: PARAM[%s]: Duplicate\n",
+				       name, param->name);
+				good = false;
 			}
 		}
 	}

commit 96cafb9ccb153f6a82ff2c9bde68916d9d65501e
Author: Eric Sandeen <sandeen@sandeen.net>
Date:   Fri Dec 6 10:45:01 2019 -0600

    fs_parser: remove fs_parameter_description name field
    
    Unused now.
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
index 4c410eef0173..3ed1e49d8267 100644
--- a/fs/fs_parser.c
+++ b/fs/fs_parser.c
@@ -354,20 +354,14 @@ bool validate_constant_table(const struct constant_table *tbl, size_t tbl_size,
  * fs_validate_description - Validate a parameter description
  * @desc: The parameter description to validate.
  */
-bool fs_validate_description(const struct fs_parameter_description *desc)
+bool fs_validate_description(const char *name,
+	const struct fs_parameter_description *desc)
 {
 	const struct fs_parameter_spec *param, *p2;
-	const char *name = desc->name;
 	bool good = true;
 
 	pr_notice("*** VALIDATE %s ***\n", name);
 
-	if (!name[0]) {
-		pr_err("VALIDATE Parser: No name\n");
-		name = "Unknown";
-		good = false;
-	}
-
 	if (desc->specs) {
 		for (param = desc->specs; param->name; param++) {
 			enum fs_parameter_type t = param->type;

commit cc3c0b533ab9142eac2e291628fbfca3685f38cd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Dec 21 00:16:49 2019 -0500

    add prefix to fs_context->log
    
    ... turning it into struct p_log embedded into fs_context.  Initialize
    the prefix with fs_type->name, turning fs_parse() into a trivial
    inline wrapper for __fs_parse().
    
    This makes fs_parameter_description->name completely unused.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
index dadb6582874d..4c410eef0173 100644
--- a/fs/fs_parser.c
+++ b/fs/fs_parser.c
@@ -243,16 +243,6 @@ int __fs_parse(struct p_log *log,
 }
 EXPORT_SYMBOL(__fs_parse);
 
-int fs_parse(struct fs_context *fc,
-	     const struct fs_parameter_description *desc,
-	     struct fs_parameter *param,
-	     struct fs_parse_result *result)
-{
-	struct p_log log = {.prefix = desc->name, .log = fc->log};
-	return __fs_parse(&log, desc, param, result);
-}
-EXPORT_SYMBOL(fs_parse);
-
 /**
  * fs_lookup_param - Look up a path referred to by a parameter
  * @fc: The filesystem context to log errors through.

commit 7f5d38141e309bb4ba995d9726928af85a299c50
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Dec 20 23:52:55 2019 -0500

    new primitive: __fs_parse()
    
    fs_parse() analogue taking p_log instead of fs_context.
    fs_parse() turned into a wrapper, callers in ceph_common and rbd
    switched to __fs_parse().
    
    As the result, fs_parse() never gets NULL fs_context and neither
    do fs_context-based logging primitives
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
index dc5c6737c280..dadb6582874d 100644
--- a/fs/fs_parser.c
+++ b/fs/fs_parser.c
@@ -80,7 +80,7 @@ static const struct fs_parameter_spec *fs_lookup_key(
  * unknown parameters are okay and -EINVAL if there was a conversion issue or
  * the parameter wasn't recognised and unknowns aren't okay.
  */
-int fs_parse(struct fs_context *fc,
+int __fs_parse(struct p_log *log,
 	     const struct fs_parameter_description *desc,
 	     struct fs_parameter *param,
 	     struct fs_parse_result *result)
@@ -113,8 +113,7 @@ int fs_parse(struct fs_context *fc,
 	}
 
 	if (p->flags & fs_param_deprecated)
-		warnf(fc, "%s: Deprecated parameter '%s'",
-		      desc->name, param->key);
+		warn_plog(log, "Deprecated parameter '%s'", param->key);
 
 	if (result->negated)
 		goto okay;
@@ -152,8 +151,8 @@ int fs_parse(struct fs_context *fc,
 	switch (p->type) {
 	case fs_param_is_flag:
 		if (param->type != fs_value_is_flag)
-			return invalf(fc, "%s: Unexpected value for '%s'",
-				      desc->name, param->key);
+			return inval_plog(log, "Unexpected value for '%s'",
+				      param->key);
 		result->boolean = true;
 		goto okay;
 
@@ -238,10 +237,20 @@ int fs_parse(struct fs_context *fc,
 	return p->opt;
 
 bad_value:
-	return invalf(fc, "%s: Bad value for '%s'", desc->name, param->key);
+	return inval_plog(log, "Bad value for '%s'", param->key);
 unknown_parameter:
 	return -ENOPARAM;
 }
+EXPORT_SYMBOL(__fs_parse);
+
+int fs_parse(struct fs_context *fc,
+	     const struct fs_parameter_description *desc,
+	     struct fs_parameter *param,
+	     struct fs_parse_result *result)
+{
+	struct p_log log = {.prefix = desc->name, .log = fc->log};
+	return __fs_parse(&log, desc, param, result);
+}
 EXPORT_SYMBOL(fs_parse);
 
 /**

commit aa1918f9491442a007a0cbe41a31539233209777
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 17 20:09:08 2019 -0500

    get rid of fs_value_is_filename_empty
    
    Its behaviour is identical to that of fs_value_is_filename.
    It makes no sense, anyway - LOOKUP_EMPTY affects nothing
    whatsoever once the pathname has been imported from userland.
    And both fs_value_is_filename and fs_value_is_filename_empty
    carry an already imported pathname.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
index 065ce6c22587..dc5c6737c280 100644
--- a/fs/fs_parser.c
+++ b/fs/fs_parser.c
@@ -268,9 +268,6 @@ int fs_lookup_param(struct fs_context *fc,
 			return PTR_ERR(f);
 		put_f = true;
 		break;
-	case fs_value_is_filename_empty:
-		flags = LOOKUP_EMPTY;
-		/* Fall through */
 	case fs_value_is_filename:
 		f = param->name;
 		put_f = false;

commit 34264ae3fa22429ec4fd9151602342d1f21486eb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Dec 16 13:45:41 2019 -0500

    don't bother with explicit length argument for __lookup_constant()
    
    Have the arrays of constant_table self-terminated (by NULL ->name
    in the final entry).  Simplifies lookup_constant() and allows to
    reuse the search for enum params as well.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
index d032ac4a758d..065ce6c22587 100644
--- a/fs/fs_parser.c
+++ b/fs/fs_parser.c
@@ -20,27 +20,31 @@ static const struct constant_table bool_names[] = {
 	{ "no",		false },
 	{ "true",	true },
 	{ "yes",	true },
+	{ },
 };
 
+static const struct constant_table *
+__lookup_constant(const struct constant_table *tbl, const char *name)
+{
+	for ( ; tbl->name; tbl++)
+		if (strcmp(name, tbl->name) == 0)
+			return tbl;
+	return NULL;
+}
+
 /**
  * lookup_constant - Look up a constant by name in an ordered table
  * @tbl: The table of constants to search.
- * @tbl_size: The size of the table.
  * @name: The name to look up.
  * @not_found: The value to return if the name is not found.
  */
-int __lookup_constant(const struct constant_table *tbl, size_t tbl_size,
-		      const char *name, int not_found)
+int lookup_constant(const struct constant_table *tbl, const char *name, int not_found)
 {
-	unsigned int i;
+	const struct constant_table *p = __lookup_constant(tbl, name);
 
-	for (i = 0; i < tbl_size; i++)
-		if (strcmp(name, tbl[i].name) == 0)
-			return tbl[i].value;
-
-	return not_found;
+	return p ? p->value : not_found;
 }
-EXPORT_SYMBOL(__lookup_constant);
+EXPORT_SYMBOL(lookup_constant);
 
 static const struct fs_parameter_spec *fs_lookup_key(
 	const struct fs_parameter_description *desc,
@@ -189,11 +193,10 @@ int fs_parse(struct fs_context *fc,
 		goto maybe_okay;
 
 	case fs_param_is_enum:
-		for (e = p->data; e->name; e++) {
-			if (strcmp(e->name, param->string) == 0) {
-				result->uint_32 = e->value;
-				goto okay;
-			}
+		e = __lookup_constant(p->data, param->string);
+		if (e) {
+			result->uint_32 = e->value;
+			goto okay;
 		}
 		goto bad_value;
 

commit 5eede625297f4d21dc12ea7a7418fd21672f131d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Dec 16 13:33:32 2019 -0500

    fold struct fs_parameter_enum into struct constant_table
    
    no real difference now
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
index 34275191697f..d032ac4a758d 100644
--- a/fs/fs_parser.c
+++ b/fs/fs_parser.c
@@ -82,7 +82,7 @@ int fs_parse(struct fs_context *fc,
 	     struct fs_parse_result *result)
 {
 	const struct fs_parameter_spec *p;
-	const struct fs_parameter_enum *e;
+	const struct constant_table *e;
 	int ret = -ENOPARAM, b;
 
 	result->negated = false;
@@ -380,7 +380,7 @@ bool fs_validate_description(const struct fs_parameter_description *desc)
 				       name, param->name, t);
 				good = false;
 			} else if (t == fs_param_is_enum) {
-				const struct fs_parameter_enum *e = param->data;
+				const struct constant_table *e = param->data;
 				if (!e || !e->name) {
 					pr_err("VALIDATE %s: PARAM[%s] enum with no values\n",
 					       name, param->name);

commit 2710c957a8ef4fb00f21acb306e3bd6bcf80c81f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Sep 6 22:12:08 2019 -0400

    fs_parse: get rid of ->enums
    
    Don't do a single array; attach them to fsparam_enum() entry
    instead.  And don't bother trying to embed the names into those -
    it actually loses memory, with no real speedup worth mentioning.
    
    Simplifies validation as well.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
index 07ae041b83a8..34275191697f 100644
--- a/fs/fs_parser.c
+++ b/fs/fs_parser.c
@@ -189,9 +189,8 @@ int fs_parse(struct fs_context *fc,
 		goto maybe_okay;
 
 	case fs_param_is_enum:
-		for (e = desc->enums; e->name[0]; e++) {
-			if (e->opt == p->opt &&
-			    strcmp(e->name, param->string) == 0) {
+		for (e = p->data; e->name; e++) {
+			if (strcmp(e->name, param->string) == 0) {
 				result->uint_32 = e->value;
 				goto okay;
 			}
@@ -359,10 +358,8 @@ bool validate_constant_table(const struct constant_table *tbl, size_t tbl_size,
 bool fs_validate_description(const struct fs_parameter_description *desc)
 {
 	const struct fs_parameter_spec *param, *p2;
-	const struct fs_parameter_enum *e;
 	const char *name = desc->name;
-	unsigned int nr_params = 0;
-	bool good = true, enums = false;
+	bool good = true;
 
 	pr_notice("*** VALIDATE %s ***\n", name);
 
@@ -383,7 +380,12 @@ bool fs_validate_description(const struct fs_parameter_description *desc)
 				       name, param->name, t);
 				good = false;
 			} else if (t == fs_param_is_enum) {
-				enums = true;
+				const struct fs_parameter_enum *e = param->data;
+				if (!e || !e->name) {
+					pr_err("VALIDATE %s: PARAM[%s] enum with no values\n",
+					       name, param->name);
+					good = false;
+				}
 			}
 
 			/* Check for duplicate parameter names */
@@ -395,63 +397,7 @@ bool fs_validate_description(const struct fs_parameter_description *desc)
 				}
 			}
 		}
-
-		nr_params = param - desc->specs;
-	}
-
-	if (desc->enums) {
-		if (!nr_params) {
-			pr_err("VALIDATE %s: Enum table but no parameters\n",
-			       name);
-			good = false;
-			goto no_enums;
-		}
-		if (!enums) {
-			pr_err("VALIDATE %s: Enum table but no enum-type values\n",
-			       name);
-			good = false;
-			goto no_enums;
-		}
-
-		for (e = desc->enums; e->name[0]; e++) {
-			/* Check that all entries in the enum table have at
-			 * least one parameter that uses them.
-			 */
-			for (param = desc->specs; param->name; param++) {
-				if (param->opt == e->opt &&
-				    param->type != fs_param_is_enum) {
-					pr_err("VALIDATE %s: e[%tu] enum val for %s\n",
-					       name, e - desc->enums, param->name);
-					good = false;
-				}
-			}
-		}
-
-		/* Check that all enum-type parameters have at least one enum
-		 * value in the enum table.
-		 */
-		for (param = desc->specs; param->name; param++) {
-			if (param->type != fs_param_is_enum)
-				continue;
-			for (e = desc->enums; e->name[0]; e++)
-				if (e->opt == param->opt)
-					break;
-			if (!e->name[0]) {
-				pr_err("VALIDATE %s: PARAM[%s] enum with no values\n",
-				       name, param->name);
-				good = false;
-			}
-		}
-	} else {
-		if (enums) {
-			pr_err("VALIDATE %s: enum-type values, but no enum table\n",
-			       name);
-			good = false;
-			goto no_enums;
-		}
 	}
-
-no_enums:
 	return good;
 }
 #endif /* CONFIG_VALIDATE_FS_PARSER */

commit 0f89589a8c6f1033cb847a606517998efb0da8ee
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 17 14:15:04 2019 -0500

    Pass consistent param->type to fs_parse()
    
    As it is, vfs_parse_fs_string() makes "foo" and "foo=" indistinguishable;
    both get fs_value_is_string for ->type and NULL for ->string.  To make
    it even more unpleasant, that combination is impossible to produce with
    fsconfig().
    
    Much saner rules would be
            "foo"           => fs_value_is_flag, NULL
            "foo="          => fs_value_is_string, ""
            "foo=bar"       => fs_value_is_string, "bar"
    All cases are distinguishable, all results are expressable by fsconfig(),
    ->has_value checks are much simpler that way (to the point of the field
    being useless) and quite a few regressions go away (gfs2 has no business
    accepting -o nodebug=, for example).
    
    Partially based upon patches from Miklos.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
index d1930adce68d..07ae041b83a8 100644
--- a/fs/fs_parser.c
+++ b/fs/fs_parser.c
@@ -85,7 +85,6 @@ int fs_parse(struct fs_context *fc,
 	const struct fs_parameter_enum *e;
 	int ret = -ENOPARAM, b;
 
-	result->has_value = !!param->string;
 	result->negated = false;
 	result->uint_64 = 0;
 
@@ -95,7 +94,7 @@ int fs_parse(struct fs_context *fc,
 		 * "xxx" takes the "no"-form negative - but only if there
 		 * wasn't an value.
 		 */
-		if (result->has_value)
+		if (param->type != fs_value_is_flag)
 			goto unknown_parameter;
 		if (param->key[0] != 'n' || param->key[1] != 'o' || !param->key[2])
 			goto unknown_parameter;
@@ -127,14 +126,18 @@ int fs_parse(struct fs_context *fc,
 	case fs_param_is_u64:
 	case fs_param_is_enum:
 	case fs_param_is_string:
-		if (param->type != fs_value_is_string)
-			goto bad_value;
-		if (!result->has_value) {
+		if (param->type == fs_value_is_string) {
+			if (p->flags & fs_param_v_optional)
+				break;
+			if (!*param->string)
+				goto bad_value;
+			break;
+		}
+		if (param->type == fs_value_is_flag) {
 			if (p->flags & fs_param_v_optional)
 				goto okay;
-			goto bad_value;
 		}
-		/* Fall through */
+		goto bad_value;
 	default:
 		break;
 	}
@@ -144,8 +147,7 @@ int fs_parse(struct fs_context *fc,
 	 */
 	switch (p->type) {
 	case fs_param_is_flag:
-		if (param->type != fs_value_is_flag &&
-		    (param->type != fs_value_is_string || result->has_value))
+		if (param->type != fs_value_is_flag)
 			return invalf(fc, "%s: Unexpected value for '%s'",
 				      desc->name, param->key);
 		result->boolean = true;
@@ -206,9 +208,6 @@ int fs_parse(struct fs_context *fc,
 	case fs_param_is_fd: {
 		switch (param->type) {
 		case fs_value_is_string:
-			if (!result->has_value)
-				goto bad_value;
-
 			ret = kstrtouint(param->string, 0, &result->uint_32);
 			break;
 		case fs_value_is_file:

commit 74983ac20aeafc88d9ceed64a8bf2a9024c488d5
Author: David Howells <dhowells@redhat.com>
Date:   Mon Mar 25 16:38:31 2019 +0000

    vfs: Make fs_parse() handle fs_param_is_fd-type params better
    
    Make fs_parse() handle fs_param_is_fd-type parameters that are passed a
    string by converting it to an integer (in addition to handling direct fd
    specification).
    
    Also range check the integer.
    
    [fix from  Yin Fengwei folded]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
index 460ea4206fa2..d1930adce68d 100644
--- a/fs/fs_parser.c
+++ b/fs/fs_parser.c
@@ -204,9 +204,23 @@ int fs_parse(struct fs_context *fc,
 		goto okay;
 
 	case fs_param_is_fd: {
-		if (param->type != fs_value_is_file)
+		switch (param->type) {
+		case fs_value_is_string:
+			if (!result->has_value)
+				goto bad_value;
+
+			ret = kstrtouint(param->string, 0, &result->uint_32);
+			break;
+		case fs_value_is_file:
+			result->uint_32 = param->dirfd;
+			ret = 0;
+		default:
 			goto bad_value;
-		goto okay;
+		}
+
+		if (result->uint_32 > INT_MAX)
+			goto bad_value;
+		goto maybe_okay;
 	}
 
 	case fs_param_is_blockdev:

commit 933a90bf4f3505f8ec83bda21a3c7d70d7c2b426
Merge: 5f4fc6d440d7 037f11b4752f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 19 10:42:02 2019 -0700

    Merge branch 'work.mount0' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs mount updates from Al Viro:
     "The first part of mount updates.
    
      Convert filesystems to use the new mount API"
    
    * 'work.mount0' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (63 commits)
      mnt_init(): call shmem_init() unconditionally
      constify ksys_mount() string arguments
      don't bother with registering rootfs
      init_rootfs(): don't bother with init_ramfs_fs()
      vfs: Convert smackfs to use the new mount API
      vfs: Convert selinuxfs to use the new mount API
      vfs: Convert securityfs to use the new mount API
      vfs: Convert apparmorfs to use the new mount API
      vfs: Convert openpromfs to use the new mount API
      vfs: Convert xenfs to use the new mount API
      vfs: Convert gadgetfs to use the new mount API
      vfs: Convert oprofilefs to use the new mount API
      vfs: Convert ibmasmfs to use the new mount API
      vfs: Convert qib_fs/ipathfs to use the new mount API
      vfs: Convert efivarfs to use the new mount API
      vfs: Convert configfs to use the new mount API
      vfs: Convert binfmt_misc to use the new mount API
      convenience helper: get_tree_single()
      convenience helper get_tree_nodev()
      vfs: Kill sget_userns()
      ...

commit 7cdfa44227b0d8842d46a775cebe4311150cb8f2
Author: David Howells <dhowells@redhat.com>
Date:   Mon Mar 25 16:38:22 2019 +0000

    vfs: Fix refcounting of filenames in fs_parser
    
    Fix an overput in which filename_lookup() unconditionally drops a ref to
    the filename it was given, but this isn't taken account of in the caller,
    fs_lookup_param().
    
    Addresses-Coverity-ID: 1443811 ("Use after free")
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
index 570d71043acf..3a1697c2f72f 100644
--- a/fs/fs_parser.c
+++ b/fs/fs_parser.c
@@ -268,6 +268,7 @@ int fs_lookup_param(struct fs_context *fc,
 		return invalf(fc, "%s: not usable as path", param->key);
 	}
 
+	f->refcnt++; /* filename_lookup() drops our ref. */
 	ret = filename_lookup(param->dirfd, f, flags, _path, NULL);
 	if (ret < 0) {
 		errorf(fc, "%s: Lookup failure for '%s'", param->key, f->name);

commit b4d0d230ccfb5d1a9ea85da64aa584df7c148ee9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:08:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 36
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public licence as published by
      the free software foundation either version 2 of the licence or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 114 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170857.552531963@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
index 570d71043acf..0d388faa25d1 100644
--- a/fs/fs_parser.c
+++ b/fs/fs_parser.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /* Filesystem parameter parser.
  *
  * Copyright (C) 2018 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public Licence
- * as published by the Free Software Foundation; either version
- * 2 of the Licence, or (at your option) any later version.
  */
 
 #include <linux/export.h>

commit 2620327852478e695afb2eebe66c354b3bc456cc
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Thu Mar 28 20:44:36 2019 -0700

    fs: fs_parser: fix printk format warning
    
    Fix printk format warning (seen on i386 builds) by using ptrdiff format
    specifier (%t):
    
      fs/fs_parser.c:413:6: warning: format `%lu' expects argument of type `long unsigned int', but argument 3 has type `int' [-Wformat=]
    
    Link: http://lkml.kernel.org/r/19432668-ffd3-fbb2-af4f-1c8e48f6cc81@infradead.org
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
index 842e8f749db6..570d71043acf 100644
--- a/fs/fs_parser.c
+++ b/fs/fs_parser.c
@@ -410,7 +410,7 @@ bool fs_validate_description(const struct fs_parameter_description *desc)
 			for (param = desc->specs; param->name; param++) {
 				if (param->opt == e->opt &&
 				    param->type != fs_param_is_enum) {
-					pr_err("VALIDATE %s: e[%lu] enum val for %s\n",
+					pr_err("VALIDATE %s: e[%tu] enum val for %s\n",
 					       name, e - desc->enums, param->name);
 					good = false;
 				}

commit 31d921c7fb9691722ba9503b64153cdc322a7fa8
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:07:24 2018 +0000

    vfs: Add configuration parser helpers
    
    Because the new API passes in key,value parameters, match_token() cannot be
    used with it.  Instead, provide three new helpers to aid with parsing:
    
     (1) fs_parse().  This takes a parameter and a simple static description of
         all the parameters and maps the key name to an ID.  It returns 1 on a
         match, 0 on no match if unknowns should be ignored and some other
         negative error code on a parse error.
    
         The parameter description includes a list of key names to IDs, desired
         parameter types and a list of enumeration name -> ID mappings.
    
         [!] Note that for the moment I've required that the key->ID mapping
         array is expected to be sorted and unterminated.  The size of the
         array is noted in the fsconfig_parser struct.  This allows me to use
         bsearch(), but I'm not sure any performance gain is worth the hassle
         of requiring people to keep the array sorted.
    
         The parameter type array is sized according to the number of parameter
         IDs and is indexed directly.  The optional enum mapping array is an
         unterminated, unsorted list and the size goes into the fsconfig_parser
         struct.
    
         The function can do some additional things:
    
            (a) If it's not ambiguous and no value is given, the prefix "no" on
                a key name is permitted to indicate that the parameter should
                be considered negatory.
    
            (b) If the desired type is a single simple integer, it will perform
                an appropriate conversion and store the result in a union in
                the parse result.
    
            (c) If the desired type is an enumeration, {key ID, name} will be
                looked up in the enumeration list and the matching value will
                be stored in the parse result union.
    
            (d) Optionally generate an error if the key is unrecognised.
    
         This is called something like:
    
            enum rdt_param {
                    Opt_cdp,
                    Opt_cdpl2,
                    Opt_mba_mpbs,
                    nr__rdt_params
            };
    
            const struct fs_parameter_spec rdt_param_specs[nr__rdt_params] = {
                    [Opt_cdp]       = { fs_param_is_bool },
                    [Opt_cdpl2]     = { fs_param_is_bool },
                    [Opt_mba_mpbs]  = { fs_param_is_bool },
            };
    
            const const char *const rdt_param_keys[nr__rdt_params] = {
                    [Opt_cdp]       = "cdp",
                    [Opt_cdpl2]     = "cdpl2",
                    [Opt_mba_mpbs]  = "mba_mbps",
            };
    
            const struct fs_parameter_description rdt_parser = {
                    .name           = "rdt",
                    .nr_params      = nr__rdt_params,
                    .keys           = rdt_param_keys,
                    .specs          = rdt_param_specs,
                    .no_source      = true,
            };
    
            int rdt_parse_param(struct fs_context *fc,
                                struct fs_parameter *param)
            {
                    struct fs_parse_result parse;
                    struct rdt_fs_context *ctx = rdt_fc2context(fc);
                    int ret;
    
                    ret = fs_parse(fc, &rdt_parser, param, &parse);
                    if (ret < 0)
                            return ret;
    
                    switch (parse.key) {
                    case Opt_cdp:
                            ctx->enable_cdpl3 = true;
                            return 0;
                    case Opt_cdpl2:
                            ctx->enable_cdpl2 = true;
                            return 0;
                    case Opt_mba_mpbs:
                            ctx->enable_mba_mbps = true;
                            return 0;
                    }
    
                    return -EINVAL;
            }
    
     (2) fs_lookup_param().  This takes a { dirfd, path, LOOKUP_EMPTY? } or
         string value and performs an appropriate path lookup to convert it
         into a path object, which it will then return.
    
         If the desired type was a blockdev, the type of the looked up inode
         will be checked to make sure it is one.
    
         This can be used like:
    
            enum foo_param {
                    Opt_source,
                    nr__foo_params
            };
    
            const struct fs_parameter_spec foo_param_specs[nr__foo_params] = {
                    [Opt_source]    = { fs_param_is_blockdev },
            };
    
            const char *char foo_param_keys[nr__foo_params] = {
                    [Opt_source]    = "source",
            };
    
            const struct constant_table foo_param_alt_keys[] = {
                    { "device",     Opt_source },
            };
    
            const struct fs_parameter_description foo_parser = {
                    .name           = "foo",
                    .nr_params      = nr__foo_params,
                    .nr_alt_keys    = ARRAY_SIZE(foo_param_alt_keys),
                    .keys           = foo_param_keys,
                    .alt_keys       = foo_param_alt_keys,
                    .specs          = foo_param_specs,
            };
    
            int foo_parse_param(struct fs_context *fc,
                                struct fs_parameter *param)
            {
                    struct fs_parse_result parse;
                    struct foo_fs_context *ctx = foo_fc2context(fc);
                    int ret;
    
                    ret = fs_parse(fc, &foo_parser, param, &parse);
                    if (ret < 0)
                            return ret;
    
                    switch (parse.key) {
                    case Opt_source:
                            return fs_lookup_param(fc, &foo_parser, param,
                                                   &parse, &ctx->source);
                    default:
                            return -EINVAL;
                    }
            }
    
     (3) lookup_constant().  This takes a table of named constants and looks up
         the given name within it.  The table is expected to be sorted such
         that bsearch() be used upon it.
    
         Possibly I should require the table be terminated and just use a
         for-loop to scan it instead of using bsearch() to reduce hassle.
    
         Tables look something like:
    
            static const struct constant_table bool_names[] = {
                    { "0",          false },
                    { "1",          true },
                    { "false",      false },
                    { "no",         false },
                    { "true",       true },
                    { "yes",        true },
            };
    
         and a lookup is done with something like:
    
            b = lookup_constant(bool_names, param->string, -1);
    
    Additionally, optional validation routines for the parameter description
    are provided that can be enabled at compile time.  A later patch will
    invoke these when a filesystem is registered.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fs_parser.c b/fs/fs_parser.c
new file mode 100644
index 000000000000..842e8f749db6
--- /dev/null
+++ b/fs/fs_parser.c
@@ -0,0 +1,447 @@
+/* Filesystem parameter parser.
+ *
+ * Copyright (C) 2018 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+
+#include <linux/export.h>
+#include <linux/fs_context.h>
+#include <linux/fs_parser.h>
+#include <linux/slab.h>
+#include <linux/security.h>
+#include <linux/namei.h>
+#include "internal.h"
+
+static const struct constant_table bool_names[] = {
+	{ "0",		false },
+	{ "1",		true },
+	{ "false",	false },
+	{ "no",		false },
+	{ "true",	true },
+	{ "yes",	true },
+};
+
+/**
+ * lookup_constant - Look up a constant by name in an ordered table
+ * @tbl: The table of constants to search.
+ * @tbl_size: The size of the table.
+ * @name: The name to look up.
+ * @not_found: The value to return if the name is not found.
+ */
+int __lookup_constant(const struct constant_table *tbl, size_t tbl_size,
+		      const char *name, int not_found)
+{
+	unsigned int i;
+
+	for (i = 0; i < tbl_size; i++)
+		if (strcmp(name, tbl[i].name) == 0)
+			return tbl[i].value;
+
+	return not_found;
+}
+EXPORT_SYMBOL(__lookup_constant);
+
+static const struct fs_parameter_spec *fs_lookup_key(
+	const struct fs_parameter_description *desc,
+	const char *name)
+{
+	const struct fs_parameter_spec *p;
+
+	if (!desc->specs)
+		return NULL;
+
+	for (p = desc->specs; p->name; p++)
+		if (strcmp(p->name, name) == 0)
+			return p;
+
+	return NULL;
+}
+
+/*
+ * fs_parse - Parse a filesystem configuration parameter
+ * @fc: The filesystem context to log errors through.
+ * @desc: The parameter description to use.
+ * @param: The parameter.
+ * @result: Where to place the result of the parse
+ *
+ * Parse a filesystem configuration parameter and attempt a conversion for a
+ * simple parameter for which this is requested.  If successful, the determined
+ * parameter ID is placed into @result->key, the desired type is indicated in
+ * @result->t and any converted value is placed into an appropriate member of
+ * the union in @result.
+ *
+ * The function returns the parameter number if the parameter was matched,
+ * -ENOPARAM if it wasn't matched and @desc->ignore_unknown indicated that
+ * unknown parameters are okay and -EINVAL if there was a conversion issue or
+ * the parameter wasn't recognised and unknowns aren't okay.
+ */
+int fs_parse(struct fs_context *fc,
+	     const struct fs_parameter_description *desc,
+	     struct fs_parameter *param,
+	     struct fs_parse_result *result)
+{
+	const struct fs_parameter_spec *p;
+	const struct fs_parameter_enum *e;
+	int ret = -ENOPARAM, b;
+
+	result->has_value = !!param->string;
+	result->negated = false;
+	result->uint_64 = 0;
+
+	p = fs_lookup_key(desc, param->key);
+	if (!p) {
+		/* If we didn't find something that looks like "noxxx", see if
+		 * "xxx" takes the "no"-form negative - but only if there
+		 * wasn't an value.
+		 */
+		if (result->has_value)
+			goto unknown_parameter;
+		if (param->key[0] != 'n' || param->key[1] != 'o' || !param->key[2])
+			goto unknown_parameter;
+
+		p = fs_lookup_key(desc, param->key + 2);
+		if (!p)
+			goto unknown_parameter;
+		if (!(p->flags & fs_param_neg_with_no))
+			goto unknown_parameter;
+		result->boolean = false;
+		result->negated = true;
+	}
+
+	if (p->flags & fs_param_deprecated)
+		warnf(fc, "%s: Deprecated parameter '%s'",
+		      desc->name, param->key);
+
+	if (result->negated)
+		goto okay;
+
+	/* Certain parameter types only take a string and convert it. */
+	switch (p->type) {
+	case __fs_param_wasnt_defined:
+		return -EINVAL;
+	case fs_param_is_u32:
+	case fs_param_is_u32_octal:
+	case fs_param_is_u32_hex:
+	case fs_param_is_s32:
+	case fs_param_is_u64:
+	case fs_param_is_enum:
+	case fs_param_is_string:
+		if (param->type != fs_value_is_string)
+			goto bad_value;
+		if (!result->has_value) {
+			if (p->flags & fs_param_v_optional)
+				goto okay;
+			goto bad_value;
+		}
+		/* Fall through */
+	default:
+		break;
+	}
+
+	/* Try to turn the type we were given into the type desired by the
+	 * parameter and give an error if we can't.
+	 */
+	switch (p->type) {
+	case fs_param_is_flag:
+		if (param->type != fs_value_is_flag &&
+		    (param->type != fs_value_is_string || result->has_value))
+			return invalf(fc, "%s: Unexpected value for '%s'",
+				      desc->name, param->key);
+		result->boolean = true;
+		goto okay;
+
+	case fs_param_is_bool:
+		switch (param->type) {
+		case fs_value_is_flag:
+			result->boolean = true;
+			goto okay;
+		case fs_value_is_string:
+			if (param->size == 0) {
+				result->boolean = true;
+				goto okay;
+			}
+			b = lookup_constant(bool_names, param->string, -1);
+			if (b == -1)
+				goto bad_value;
+			result->boolean = b;
+			goto okay;
+		default:
+			goto bad_value;
+		}
+
+	case fs_param_is_u32:
+		ret = kstrtouint(param->string, 0, &result->uint_32);
+		goto maybe_okay;
+	case fs_param_is_u32_octal:
+		ret = kstrtouint(param->string, 8, &result->uint_32);
+		goto maybe_okay;
+	case fs_param_is_u32_hex:
+		ret = kstrtouint(param->string, 16, &result->uint_32);
+		goto maybe_okay;
+	case fs_param_is_s32:
+		ret = kstrtoint(param->string, 0, &result->int_32);
+		goto maybe_okay;
+	case fs_param_is_u64:
+		ret = kstrtoull(param->string, 0, &result->uint_64);
+		goto maybe_okay;
+
+	case fs_param_is_enum:
+		for (e = desc->enums; e->name[0]; e++) {
+			if (e->opt == p->opt &&
+			    strcmp(e->name, param->string) == 0) {
+				result->uint_32 = e->value;
+				goto okay;
+			}
+		}
+		goto bad_value;
+
+	case fs_param_is_string:
+		goto okay;
+	case fs_param_is_blob:
+		if (param->type != fs_value_is_blob)
+			goto bad_value;
+		goto okay;
+
+	case fs_param_is_fd: {
+		if (param->type != fs_value_is_file)
+			goto bad_value;
+		goto okay;
+	}
+
+	case fs_param_is_blockdev:
+	case fs_param_is_path:
+		goto okay;
+	default:
+		BUG();
+	}
+
+maybe_okay:
+	if (ret < 0)
+		goto bad_value;
+okay:
+	return p->opt;
+
+bad_value:
+	return invalf(fc, "%s: Bad value for '%s'", desc->name, param->key);
+unknown_parameter:
+	return -ENOPARAM;
+}
+EXPORT_SYMBOL(fs_parse);
+
+/**
+ * fs_lookup_param - Look up a path referred to by a parameter
+ * @fc: The filesystem context to log errors through.
+ * @param: The parameter.
+ * @want_bdev: T if want a blockdev
+ * @_path: The result of the lookup
+ */
+int fs_lookup_param(struct fs_context *fc,
+		    struct fs_parameter *param,
+		    bool want_bdev,
+		    struct path *_path)
+{
+	struct filename *f;
+	unsigned int flags = 0;
+	bool put_f;
+	int ret;
+
+	switch (param->type) {
+	case fs_value_is_string:
+		f = getname_kernel(param->string);
+		if (IS_ERR(f))
+			return PTR_ERR(f);
+		put_f = true;
+		break;
+	case fs_value_is_filename_empty:
+		flags = LOOKUP_EMPTY;
+		/* Fall through */
+	case fs_value_is_filename:
+		f = param->name;
+		put_f = false;
+		break;
+	default:
+		return invalf(fc, "%s: not usable as path", param->key);
+	}
+
+	ret = filename_lookup(param->dirfd, f, flags, _path, NULL);
+	if (ret < 0) {
+		errorf(fc, "%s: Lookup failure for '%s'", param->key, f->name);
+		goto out;
+	}
+
+	if (want_bdev &&
+	    !S_ISBLK(d_backing_inode(_path->dentry)->i_mode)) {
+		path_put(_path);
+		_path->dentry = NULL;
+		_path->mnt = NULL;
+		errorf(fc, "%s: Non-blockdev passed as '%s'",
+		       param->key, f->name);
+		ret = -ENOTBLK;
+	}
+
+out:
+	if (put_f)
+		putname(f);
+	return ret;
+}
+EXPORT_SYMBOL(fs_lookup_param);
+
+#ifdef CONFIG_VALIDATE_FS_PARSER
+/**
+ * validate_constant_table - Validate a constant table
+ * @name: Name to use in reporting
+ * @tbl: The constant table to validate.
+ * @tbl_size: The size of the table.
+ * @low: The lowest permissible value.
+ * @high: The highest permissible value.
+ * @special: One special permissible value outside of the range.
+ */
+bool validate_constant_table(const struct constant_table *tbl, size_t tbl_size,
+			     int low, int high, int special)
+{
+	size_t i;
+	bool good = true;
+
+	if (tbl_size == 0) {
+		pr_warn("VALIDATE C-TBL: Empty\n");
+		return true;
+	}
+
+	for (i = 0; i < tbl_size; i++) {
+		if (!tbl[i].name) {
+			pr_err("VALIDATE C-TBL[%zu]: Null\n", i);
+			good = false;
+		} else if (i > 0 && tbl[i - 1].name) {
+			int c = strcmp(tbl[i-1].name, tbl[i].name);
+
+			if (c == 0) {
+				pr_err("VALIDATE C-TBL[%zu]: Duplicate %s\n",
+				       i, tbl[i].name);
+				good = false;
+			}
+			if (c > 0) {
+				pr_err("VALIDATE C-TBL[%zu]: Missorted %s>=%s\n",
+				       i, tbl[i-1].name, tbl[i].name);
+				good = false;
+			}
+		}
+
+		if (tbl[i].value != special &&
+		    (tbl[i].value < low || tbl[i].value > high)) {
+			pr_err("VALIDATE C-TBL[%zu]: %s->%d const out of range (%d-%d)\n",
+			       i, tbl[i].name, tbl[i].value, low, high);
+			good = false;
+		}
+	}
+
+	return good;
+}
+
+/**
+ * fs_validate_description - Validate a parameter description
+ * @desc: The parameter description to validate.
+ */
+bool fs_validate_description(const struct fs_parameter_description *desc)
+{
+	const struct fs_parameter_spec *param, *p2;
+	const struct fs_parameter_enum *e;
+	const char *name = desc->name;
+	unsigned int nr_params = 0;
+	bool good = true, enums = false;
+
+	pr_notice("*** VALIDATE %s ***\n", name);
+
+	if (!name[0]) {
+		pr_err("VALIDATE Parser: No name\n");
+		name = "Unknown";
+		good = false;
+	}
+
+	if (desc->specs) {
+		for (param = desc->specs; param->name; param++) {
+			enum fs_parameter_type t = param->type;
+
+			/* Check that the type is in range */
+			if (t == __fs_param_wasnt_defined ||
+			    t >= nr__fs_parameter_type) {
+				pr_err("VALIDATE %s: PARAM[%s] Bad type %u\n",
+				       name, param->name, t);
+				good = false;
+			} else if (t == fs_param_is_enum) {
+				enums = true;
+			}
+
+			/* Check for duplicate parameter names */
+			for (p2 = desc->specs; p2 < param; p2++) {
+				if (strcmp(param->name, p2->name) == 0) {
+					pr_err("VALIDATE %s: PARAM[%s]: Duplicate\n",
+					       name, param->name);
+					good = false;
+				}
+			}
+		}
+
+		nr_params = param - desc->specs;
+	}
+
+	if (desc->enums) {
+		if (!nr_params) {
+			pr_err("VALIDATE %s: Enum table but no parameters\n",
+			       name);
+			good = false;
+			goto no_enums;
+		}
+		if (!enums) {
+			pr_err("VALIDATE %s: Enum table but no enum-type values\n",
+			       name);
+			good = false;
+			goto no_enums;
+		}
+
+		for (e = desc->enums; e->name[0]; e++) {
+			/* Check that all entries in the enum table have at
+			 * least one parameter that uses them.
+			 */
+			for (param = desc->specs; param->name; param++) {
+				if (param->opt == e->opt &&
+				    param->type != fs_param_is_enum) {
+					pr_err("VALIDATE %s: e[%lu] enum val for %s\n",
+					       name, e - desc->enums, param->name);
+					good = false;
+				}
+			}
+		}
+
+		/* Check that all enum-type parameters have at least one enum
+		 * value in the enum table.
+		 */
+		for (param = desc->specs; param->name; param++) {
+			if (param->type != fs_param_is_enum)
+				continue;
+			for (e = desc->enums; e->name[0]; e++)
+				if (e->opt == param->opt)
+					break;
+			if (!e->name[0]) {
+				pr_err("VALIDATE %s: PARAM[%s] enum with no values\n",
+				       name, param->name);
+				good = false;
+			}
+		}
+	} else {
+		if (enums) {
+			pr_err("VALIDATE %s: enum-type values, but no enum table\n",
+			       name);
+			good = false;
+			goto no_enums;
+		}
+	}
+
+no_enums:
+	return good;
+}
+#endif /* CONFIG_VALIDATE_FS_PARSER */
