commit 16a583079e937f6f5e6274ef7fda6dbf7dcb669f
Author: Kees Cook <keescook@chromium.org>
Date:   Fri May 8 08:42:12 2020 -0700

    pstore/ftrace: Provide ftrace log merging routine
    
    Move the ftrace log merging logic out of pstore/ram into pstore/ftrace
    so other backends can use it, like pstore/zone.
    
    Link: https://lore.kernel.org/lkml/20200510202436.63222-7-keescook@chromium.org/
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index 8efd72d93b10..7fb219042f13 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -12,9 +12,18 @@ extern unsigned long kmsg_bytes;
 #ifdef CONFIG_PSTORE_FTRACE
 extern void pstore_register_ftrace(void);
 extern void pstore_unregister_ftrace(void);
+ssize_t pstore_ftrace_combine_log(char **dest_log, size_t *dest_log_size,
+				  const char *src_log, size_t src_log_size);
 #else
 static inline void pstore_register_ftrace(void) {}
 static inline void pstore_unregister_ftrace(void) {}
+static inline ssize_t
+pstore_ftrace_combine_log(char **dest_log, size_t *dest_log_size,
+			  const char *src_log, size_t src_log_size)
+{
+	*dest_log_size = 0;
+	return 0;
+}
 #endif
 
 #ifdef CONFIG_PSTORE_PMSG

commit 609e28bb139e53621521130f0d4aea27a725d465
Author: Kees Cook <keescook@chromium.org>
Date:   Mon May 4 19:46:53 2020 -0700

    pstore: Remove filesystem records when backend is unregistered
    
    If a backend was unloaded without having first removed all its
    associated records in pstorefs, subsequent removals would crash while
    attempting to call into the now missing backend. Add automatic removal
    from the tree in pstore_unregister(), so that no references to the
    backend remain.
    
    Reported-by: Luis Henriques <lhenriques@suse.com>
    Link: https://lore.kernel.org/lkml/87o8yrmv69.fsf@suse.com
    Link: https://lore.kernel.org/lkml/20200506152114.50375-11-keescook@chromium.org/
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index fe5f7ef7323f..8efd72d93b10 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -31,6 +31,7 @@ extern void	pstore_set_kmsg_bytes(int);
 extern void	pstore_get_records(int);
 extern void	pstore_get_backend_records(struct pstore_info *psi,
 					   struct dentry *root, int quiet);
+extern int	pstore_put_backend_records(struct pstore_info *psi);
 extern int	pstore_mkfile(struct dentry *root,
 			      struct pstore_record *record);
 extern void	pstore_record_init(struct pstore_record *record,

commit 27e5041a87e8af2d0b6452dffe053d0253e914cc
Author: Kees Cook <keescook@chromium.org>
Date:   Mon May 4 19:43:41 2020 -0700

    pstore: Add locking around superblock changes
    
    Nothing was protecting changes to the pstorefs superblock. Add locking
    and refactor away is_pstore_mounted(), instead using a helper to add a
    way to safely lock the pstorefs root inode during filesystem changes.
    
    Link: https://lore.kernel.org/lkml/20200506152114.50375-9-keescook@chromium.org/
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index 7062ea4bc57c..fe5f7ef7323f 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -33,7 +33,6 @@ extern void	pstore_get_backend_records(struct pstore_info *psi,
 					   struct dentry *root, int quiet);
 extern int	pstore_mkfile(struct dentry *root,
 			      struct pstore_record *record);
-extern bool	pstore_is_mounted(void);
 extern void	pstore_record_init(struct pstore_record *record,
 				   struct pstore_info *psi);
 

commit cb095afd44768bf495894b9ad063bd078e4bb201
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Oct 18 11:17:42 2018 -0700

    pstore: Centralize init/exit routines
    
    In preparation for having additional actions during init/exit, this moves
    the init/exit into platform.c, centralizing the logic to make call outs
    to the fs init/exit.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Tested-by: Guenter Roeck <groeck@chromium.org>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index fb767e28aeb2..7062ea4bc57c 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -37,7 +37,8 @@ extern bool	pstore_is_mounted(void);
 extern void	pstore_record_init(struct pstore_record *record,
 				   struct pstore_info *psi);
 
-/* Called during module_init() */
-extern void __init pstore_choose_compression(void);
+/* Called during pstore init/exit. */
+int __init	pstore_init_fs(void);
+void __exit	pstore_exit_fs(void);
 
 #endif

commit fe1d475888eecf1319458ee916e642e3e5e41c28
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Mar 6 15:57:38 2018 -0800

    pstore: Select compression at runtime
    
    To allow for easier build test coverage and run-time testing, this allows
    multiple compression algorithms to be built into pstore. Still only one
    is supported to operate at a time (which can be selected at build time
    or at boot time, similar to how LSMs are selected).
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index c029314478fa..fb767e28aeb2 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -37,4 +37,7 @@ extern bool	pstore_is_mounted(void);
 extern void	pstore_record_init(struct pstore_record *record,
 				   struct pstore_info *psi);
 
+/* Called during module_init() */
+extern void __init pstore_choose_compression(void);
+
 #endif

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index 7f4e48c8d188..c029314478fa 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __PSTORE_INTERNAL_H__
 #define __PSTORE_INTERNAL_H__
 

commit 78dcf73421a879d22319d3889119945b85954a68
Merge: 93ff81859733 fdb254db21bb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 15 12:00:42 2017 -0700

    Merge branch 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull ->s_options removal from Al Viro:
     "Preparations for fsmount/fsopen stuff (coming next cycle). Everything
      gets moved to explicit ->show_options(), killing ->s_options off +
      some cosmetic bits around fs/namespace.c and friends. Basically, the
      stuff needed to work with fsmount series with minimum of conflicts
      with other work.
    
      It's not strictly required for this merge window, but it would reduce
      the PITA during the coming cycle, so it would be nice to have those
      bits and pieces out of the way"
    
    * 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      isofs: Fix isofs_show_options()
      VFS: Kill off s_options and helpers
      orangefs: Implement show_options
      9p: Implement show_options
      isofs: Implement show_options
      afs: Implement show_options
      affs: Implement show_options
      befs: Implement show_options
      spufs: Implement show_options
      bpf: Implement show_options
      ramfs: Implement show_options
      pstore: Implement show_options
      omfs: Implement show_options
      hugetlbfs: Implement show_options
      VFS: Don't use save/replace_mount_options if not using generic_show_options
      VFS: Provide empty name qstr
      VFS: Make get_filesystem() return the affected filesystem
      VFS: Clean up whitespace in fs/namespace.c and fs/super.c
      Provide a function to create a NUL-terminated string from unterminated data

commit 349d743895e2371bda9a02a5b465b50cc24d2825
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jul 5 16:24:34 2017 +0100

    pstore: Implement show_options
    
    Implement the show_options superblock op for pstore as part of a bid to get
    rid of s_options and generic_show_options() to make it easier to implement
    a context-based mount where the mount options can be passed individually
    over a file descriptor.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Kees Cook <keescook@chromium.org>
    cc: Anton Vorontsov <anton@enomsg.org>
    cc: Colin Cross <ccross@android.com>
    cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index c416e653dc4f..4d5913130580 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -5,6 +5,9 @@
 #include <linux/time.h>
 #include <linux/pstore.h>
 
+#define PSTORE_DEFAULT_KMSG_BYTES 10240
+extern unsigned long kmsg_bytes;
+
 #ifdef CONFIG_PSTORE_FTRACE
 extern void pstore_register_ftrace(void);
 extern void pstore_unregister_ftrace(void);

commit e581ca813a40a4ee53c862d8f6303f486c4b4c34
Author: Kees Cook <keescook@chromium.org>
Date:   Fri May 19 15:10:31 2017 -0700

    pstore: Create common record initializer
    
    In preparation for setting timestamps in the pstore core, create a common
    initializer routine, instead of using static initializers.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index c416e653dc4f..58051265626f 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -30,5 +30,7 @@ extern void	pstore_get_backend_records(struct pstore_info *psi,
 extern int	pstore_mkfile(struct dentry *root,
 			      struct pstore_record *record);
 extern bool	pstore_is_mounted(void);
+extern void	pstore_record_init(struct pstore_record *record,
+				   struct pstore_info *psi);
 
 #endif

commit 3a7d2fd16c57a1ef47dc2891171514231c9c7c6e
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Apr 27 15:53:21 2017 -0700

    pstore: Solve lockdep warning by moving inode locks
    
    Lockdep complains about a possible deadlock between mount and unlink
    (which is technically impossible), but fixing this improves possible
    future multiple-backend support, and keeps locking in the right order.
    
    The lockdep warning could be triggered by unlinking a file in the
    pstore filesystem:
    
      -> #1 (&sb->s_type->i_mutex_key#14){++++++}:
             lock_acquire+0xc9/0x220
             down_write+0x3f/0x70
             pstore_mkfile+0x1f4/0x460
             pstore_get_records+0x17a/0x320
             pstore_fill_super+0xa4/0xc0
             mount_single+0x89/0xb0
             pstore_mount+0x13/0x20
             mount_fs+0xf/0x90
             vfs_kern_mount+0x66/0x170
             do_mount+0x190/0xd50
             SyS_mount+0x90/0xd0
             entry_SYSCALL_64_fastpath+0x1c/0xb1
    
      -> #0 (&psinfo->read_mutex){+.+.+.}:
             __lock_acquire+0x1ac0/0x1bb0
             lock_acquire+0xc9/0x220
             __mutex_lock+0x6e/0x990
             mutex_lock_nested+0x16/0x20
             pstore_unlink+0x3f/0xa0
             vfs_unlink+0xb5/0x190
             do_unlinkat+0x24c/0x2a0
             SyS_unlinkat+0x16/0x30
             entry_SYSCALL_64_fastpath+0x1c/0xb1
    
      Possible unsafe locking scenario:
    
            CPU0                    CPU1
            ----                    ----
       lock(&sb->s_type->i_mutex_key#14);
                                    lock(&psinfo->read_mutex);
                                    lock(&sb->s_type->i_mutex_key#14);
       lock(&psinfo->read_mutex);
    
    Reported-by: Marta Lofstedt <marta.lofstedt@intel.com>
    Reported-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Namhyung Kim <namhyung@kernel.org>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index af1df5a36d86..c416e653dc4f 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -25,7 +25,10 @@ extern struct pstore_info *psinfo;
 
 extern void	pstore_set_kmsg_bytes(int);
 extern void	pstore_get_records(int);
-extern int	pstore_mkfile(struct pstore_record *record);
+extern void	pstore_get_backend_records(struct pstore_info *psi,
+					   struct dentry *root, int quiet);
+extern int	pstore_mkfile(struct dentry *root,
+			      struct pstore_record *record);
 extern bool	pstore_is_mounted(void);
 
 #endif

commit 1edd1aa397ad3ca5f1fca1961c13910ef53f16e8
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Mar 3 18:16:32 2017 -0800

    pstore: Switch pstore_mkfile to pass record
    
    Instead of the long list of arguments, just pass the new record struct.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index da416e6591c9..af1df5a36d86 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -25,10 +25,7 @@ extern struct pstore_info *psinfo;
 
 extern void	pstore_set_kmsg_bytes(int);
 extern void	pstore_get_records(int);
-extern int	pstore_mkfile(enum pstore_type_id, char *psname, u64 id,
-			      int count, char *data, bool compressed,
-			      size_t size, struct timespec time,
-			      struct pstore_info *psi);
+extern int	pstore_mkfile(struct pstore_record *record);
 extern bool	pstore_is_mounted(void);
 
 #endif

commit fbccdeb8d77d6830556bc4079eeed80298cc97dc
Author: Joel Fernandes <joelaf@google.com>
Date:   Thu Oct 20 00:34:05 2016 -0700

    pstore: Add ftrace timestamp counter
    
    In preparation for merging the per CPU buffers into one buffer when
    we retrieve the pstore ftrace data, we store the timestamp as a
    counter in the ftrace pstore record.  We store the CPU number as well
    if !PSTORE_CPU_IN_IP, in this case we shift the counter and may lose
    ordering there but we preserve the same record size. The timestamp counter
    is also racy, and not doing any locking or synchronization here results
    in the benefit of lower overhead. Since we don't care much here for exact
    ordering of function traces across CPUs, we don't synchronize and may lose
    some counter updates but I'm ok with that.
    
    Using trace_clock() results in much lower performance so avoid using it
    since we don't want accuracy in timestamp and need a rough ordering to
    perform merge.
    
    Signed-off-by: Joel Fernandes <joelaf@google.com>
    [kees: updated commit message, added comments]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index e38a22b31282..da416e6591c9 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -5,40 +5,6 @@
 #include <linux/time.h>
 #include <linux/pstore.h>
 
-#if NR_CPUS <= 2 && defined(CONFIG_ARM_THUMB)
-#define PSTORE_CPU_IN_IP 0x1
-#elif NR_CPUS <= 4 && defined(CONFIG_ARM)
-#define PSTORE_CPU_IN_IP 0x3
-#endif
-
-struct pstore_ftrace_record {
-	unsigned long ip;
-	unsigned long parent_ip;
-#ifndef PSTORE_CPU_IN_IP
-	unsigned int cpu;
-#endif
-};
-
-static inline void
-pstore_ftrace_encode_cpu(struct pstore_ftrace_record *rec, unsigned int cpu)
-{
-#ifndef PSTORE_CPU_IN_IP
-	rec->cpu = cpu;
-#else
-	rec->ip |= cpu;
-#endif
-}
-
-static inline unsigned int
-pstore_ftrace_decode_cpu(struct pstore_ftrace_record *rec)
-{
-#ifndef PSTORE_CPU_IN_IP
-	return rec->cpu;
-#else
-	return rec->ip & PSTORE_CPU_IN_IP;
-#endif
-}
-
 #ifdef CONFIG_PSTORE_FTRACE
 extern void pstore_register_ftrace(void);
 extern void pstore_unregister_ftrace(void);

commit 7e26e9ff0a9301398bd7cf8d896536da3a54aa9a
Author: Geliang Tang <geliangtang@163.com>
Date:   Thu Oct 22 01:02:33 2015 -0700

    pstore: Fix return type of pstore_is_mounted()
    
    This patch changes return type of pstore_is_mounted from int to bool.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index 96253c474ea5..e38a22b31282 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -63,6 +63,6 @@ extern int	pstore_mkfile(enum pstore_type_id, char *psname, u64 id,
 			      int count, char *data, bool compressed,
 			      size_t size, struct timespec time,
 			      struct pstore_info *psi);
-extern int	pstore_is_mounted(void);
+extern bool	pstore_is_mounted(void);
 
 #endif

commit ee1d267423a1f8041e2b1a33fc23e4393c67677e
Author: Geliang Tang <geliangtang@163.com>
Date:   Tue Oct 20 00:39:03 2015 -0700

    pstore: add pstore unregister
    
    pstore doesn't support unregistering yet. It was marked as TODO.
    This patch adds some code to fix it:
     1) Add functions to unregister kmsg/console/ftrace/pmsg.
     2) Add a function to free compression buffer.
     3) Unmap the memory and free it.
     4) Add a function to unregister pstore filesystem.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    [Removed __exit annotation from ramoops_remove(). Reported by Arnd Bergmann]
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index c36ba2cd0b5d..96253c474ea5 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -41,14 +41,18 @@ pstore_ftrace_decode_cpu(struct pstore_ftrace_record *rec)
 
 #ifdef CONFIG_PSTORE_FTRACE
 extern void pstore_register_ftrace(void);
+extern void pstore_unregister_ftrace(void);
 #else
 static inline void pstore_register_ftrace(void) {}
+static inline void pstore_unregister_ftrace(void) {}
 #endif
 
 #ifdef CONFIG_PSTORE_PMSG
 extern void pstore_register_pmsg(void);
+extern void pstore_unregister_pmsg(void);
 #else
 static inline void pstore_register_pmsg(void) {}
+static inline void pstore_unregister_pmsg(void) {}
 #endif
 
 extern struct pstore_info *psinfo;

commit 9d5438f462abd6398cdb7b3211bdcec271873a3b
Author: Mark Salyzyn <salyzyn@android.com>
Date:   Fri Jan 16 16:01:10 2015 -0800

    pstore: Add pmsg - user-space accessible pstore object
    
    A secured user-space accessible pstore object. Writes
    to /dev/pmsg0 are appended to the buffer, on reboot
    the persistent contents are available in
    /sys/fs/pstore/pmsg-ramoops-[ID].
    
    One possible use is syslogd, or other daemon, can
    write messages, then on reboot provides a means to
    triage user-space activities leading up to a panic
    as a companion to the pstore dmesg or console logs.
    
    Signed-off-by: Mark Salyzyn <salyzyn@android.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index 3b3d305277c4..c36ba2cd0b5d 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -45,6 +45,12 @@ extern void pstore_register_ftrace(void);
 static inline void pstore_register_ftrace(void) {}
 #endif
 
+#ifdef CONFIG_PSTORE_PMSG
+extern void pstore_register_pmsg(void);
+#else
+static inline void pstore_register_pmsg(void) {}
+#endif
+
 extern struct pstore_info *psinfo;
 
 extern void	pstore_set_kmsg_bytes(int);

commit 9ad2cbe0a9b88ee6ee895d03b2c63fa1252c8e52
Author: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
Date:   Fri Aug 16 13:53:39 2013 -0700

    pstore: Add file extension to pstore file if compressed
    
    In case decompression fails, add a ".enc.z" to indicate the file has
    compressed data. This will help user space utilities to figure
    out the file contents.
    
    Signed-off-by: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index 937d820f273c..3b3d305277c4 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -50,8 +50,9 @@ extern struct pstore_info *psinfo;
 extern void	pstore_set_kmsg_bytes(int);
 extern void	pstore_get_records(int);
 extern int	pstore_mkfile(enum pstore_type_id, char *psname, u64 id,
-			      int count, char *data, size_t size,
-			      struct timespec time, struct pstore_info *psi);
+			      int count, char *data, bool compressed,
+			      size_t size, struct timespec time,
+			      struct pstore_info *psi);
 extern int	pstore_is_mounted(void);
 
 #endif

commit 755d4fe46529018ae45bc7c86df682de45ace764
Author: Seiji Aguchi <seiji.aguchi@hds.com>
Date:   Mon Nov 26 16:07:44 2012 -0800

    efi_pstore: Add a sequence counter to a variable name
    
    [Issue]
    
    Currently, a variable name, which identifies each entry, consists of type, id and ctime.
    But if multiple events happens in a short time, a second/third event may fail to log because
    efi_pstore can't distinguish each event with current variable name.
    
    [Solution]
    
    A reasonable way to identify all events precisely is introducing a sequence counter to
    the variable name.
    
    The sequence counter has already supported in a pstore layer with "oopscount".
    So, this patch adds it to a variable name.
    Also, it is passed to read/erase callbacks of platform drivers in accordance with
    the modification of the variable name.
    
      <before applying this patch>
     a variable name of first event: dump-type0-1-12345678
     a variable name of second event: dump-type0-1-12345678
    
      type:0
      id:1
      ctime:12345678
    
     If multiple events happen in a short time, efi_pstore can't distinguish them because
     variable names are same among them.
    
      <after applying this patch>
    
     it can be distinguishable by adding a sequence counter as follows.
    
     a variable name of first event: dump-type0-1-1-12345678
     a variable name of Second event: dump-type0-1-2-12345678
    
      type:0
      id:1
      sequence counter: 1(first event), 2(second event)
      ctime:12345678
    
    In case of a write callback executed in pstore_console_write(), "0" is added to
    an argument of the write callback because it just logs all kernel messages and
    doesn't need to care about multiple events.
    
    Signed-off-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Mike Waychison <mikew@google.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index 4847f588b7d5..937d820f273c 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -50,7 +50,7 @@ extern struct pstore_info *psinfo;
 extern void	pstore_set_kmsg_bytes(int);
 extern void	pstore_get_records(int);
 extern int	pstore_mkfile(enum pstore_type_id, char *psname, u64 id,
-			      char *data, size_t size,
+			      int count, char *data, size_t size,
 			      struct timespec time, struct pstore_info *psi);
 extern int	pstore_is_mounted(void);
 

commit 65f8c95e46a1827ae8bbc52a817ea308dd7d65ae
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Tue Jul 17 14:26:15 2012 -0700

    pstore/ftrace: Convert to its own enable/disable debugfs knob
    
    With this patch we no longer reuse function tracer infrastructure, now
    we register our own tracer back-end via a debugfs knob.
    
    It's a bit more code, but that is the only downside. On the bright side we
    have:
    
    - Ability to make persistent_ram module removable (when needed, we can
      move ftrace_ops struct into a module). Note that persistent_ram is still
      not removable for other reasons, but with this patch it's just one
      thing less to worry about;
    
    - Pstore part is more isolated from the generic function tracer. We tried
      it already by registering our own tracer in available_tracers, but that
      way we're loosing ability to see the traces while we record them to
      pstore. This solution is somewhere in the middle: we only register
      "internal ftracer" back-end, but not the "front-end";
    
    - When there is only pstore tracing enabled, the kernel will only write
      to the pstore buffer, omitting function tracer buffer (which, of course,
      still can be enabled via 'echo function > current_tracer').
    
    Suggested-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index 0d0d3b7d5f12..4847f588b7d5 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -39,6 +39,12 @@ pstore_ftrace_decode_cpu(struct pstore_ftrace_record *rec)
 #endif
 }
 
+#ifdef CONFIG_PSTORE_FTRACE
+extern void pstore_register_ftrace(void);
+#else
+static inline void pstore_register_ftrace(void) {}
+#endif
+
 extern struct pstore_info *psinfo;
 
 extern void	pstore_set_kmsg_bytes(int);

commit 67a101f573b0cb1043c8c305112113450cb9fdbf
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Tue Jul 17 11:37:07 2012 -0700

    pstore: Headers should include all stuff they use
    
    Headers should really include all the needed prototypes, types, defines
    etc. to be self-contained. This is a long-standing issue, but apparently
    the new tracing code unearthed it (SMP=n is also a prerequisite):
    
    In file included from fs/pstore/internal.h:4:0,
                     from fs/pstore/ftrace.c:21:
    include/linux/pstore.h:43:15: error: field ‘read_mutex’ has incomplete type
    
    While at it, I also added the following:
    
    linux/types.h -> size_t, phys_addr_t, uXX and friends
    linux/spinlock.h -> spinlock_t
    linux/errno.h -> Exxxx
    linux/time.h -> struct timespec (struct passed by value)
    struct module and rs_control forward declaration (passed via pointers).
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index 958c48d8905c..0d0d3b7d5f12 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -1,6 +1,8 @@
 #ifndef __PSTORE_INTERNAL_H__
 #define __PSTORE_INTERNAL_H__
 
+#include <linux/types.h>
+#include <linux/time.h>
 #include <linux/pstore.h>
 
 #if NR_CPUS <= 2 && defined(CONFIG_ARM_THUMB)

commit 060287b8c467bf49a594d8d669e1986c6d8d76b0
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Mon Jul 9 17:10:41 2012 -0700

    pstore: Add persistent function tracing
    
    With this support kernel can save function call chain log into a
    persistent ram buffer that can be decoded and dumped after reboot
    through pstore filesystem. It can be used to determine what function
    was last called before a reset or panic.
    
    We store the log in a binary format and then decode it at read time.
    
    p.s.
    Mostly the code comes from trace_persistent.c driver found in the
    Android git tree, written by Colin Cross <ccross@android.com>
    (according to sign-off history). I reworked the driver a little bit,
    and ported it to pstore.
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index 3bde461c3f34..958c48d8905c 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -1,6 +1,49 @@
+#ifndef __PSTORE_INTERNAL_H__
+#define __PSTORE_INTERNAL_H__
+
+#include <linux/pstore.h>
+
+#if NR_CPUS <= 2 && defined(CONFIG_ARM_THUMB)
+#define PSTORE_CPU_IN_IP 0x1
+#elif NR_CPUS <= 4 && defined(CONFIG_ARM)
+#define PSTORE_CPU_IN_IP 0x3
+#endif
+
+struct pstore_ftrace_record {
+	unsigned long ip;
+	unsigned long parent_ip;
+#ifndef PSTORE_CPU_IN_IP
+	unsigned int cpu;
+#endif
+};
+
+static inline void
+pstore_ftrace_encode_cpu(struct pstore_ftrace_record *rec, unsigned int cpu)
+{
+#ifndef PSTORE_CPU_IN_IP
+	rec->cpu = cpu;
+#else
+	rec->ip |= cpu;
+#endif
+}
+
+static inline unsigned int
+pstore_ftrace_decode_cpu(struct pstore_ftrace_record *rec)
+{
+#ifndef PSTORE_CPU_IN_IP
+	return rec->cpu;
+#else
+	return rec->ip & PSTORE_CPU_IN_IP;
+#endif
+}
+
+extern struct pstore_info *psinfo;
+
 extern void	pstore_set_kmsg_bytes(int);
 extern void	pstore_get_records(int);
 extern int	pstore_mkfile(enum pstore_type_id, char *psname, u64 id,
 			      char *data, size_t size,
 			      struct timespec time, struct pstore_info *psi);
 extern int	pstore_is_mounted(void);
+
+#endif

commit 6dda9266913ad57e09afc1a10d6473f10c806a63
Author: Luck, Tony <tony.luck@intel.com>
Date:   Thu Aug 11 15:14:39 2011 -0700

    pstore: defer inserting OOPS entries into pstore
    
    Life is simple for all the kernel terminating types of kmsg_dump
    call backs - pstore just saves the tail end of the console log. But
    for "oops" the situation is more complex - the kernel may carry on
    running (possibly for ever).  So we'd like to make the logged copy
    of the oops appear in the pstore filesystem - so that the user has
    a handle to clear the entry from the persistent backing store (if
    we don't, the store may fill with "oops" entries (that are also
    safely stashed in /var/log/messages) leaving no space for real
    errors.
    
    Current code calls pstore_mkfile() immediately. But this may
    not be safe. The oops could have happened with arbitrary locks
    held, or in interrupt or NMI context. So allocating memory and
    calling into generic filesystem code seems unwise.
    
    This patch defers making the entry appear. At the time
    of the oops, we merely set a flag "pstore_new_entry" noting that
    a new entry has been added. A periodic timer checks once a minute
    to see if the flag is set - if so, it schedules a work queue to
    rescan the backing store and make all new entries appear in the
    pstore filesystem.
    
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index 611c1b3c46fa..3bde461c3f34 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -1,5 +1,5 @@
 extern void	pstore_set_kmsg_bytes(int);
-extern void	pstore_get_records(void);
+extern void	pstore_get_records(int);
 extern int	pstore_mkfile(enum pstore_type_id, char *psname, u64 id,
 			      char *data, size_t size,
 			      struct timespec time, struct pstore_info *psi);

commit 638c1fd3033c76778e6d9975ad8a4a9cdd5b96d9
Author: Matthew Garrett <mjg@redhat.com>
Date:   Thu Jul 21 16:57:52 2011 -0400

    pstore: Extend API for more flexibility in new backends
    
    Some pstore implementations may not have a static context, so extend the
    API to pass the pstore_info struct to all calls and allow for a context
    pointer.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index 8c9f23eb1645..611c1b3c46fa 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -2,5 +2,5 @@ extern void	pstore_set_kmsg_bytes(int);
 extern void	pstore_get_records(void);
 extern int	pstore_mkfile(enum pstore_type_id, char *psname, u64 id,
 			      char *data, size_t size,
-			      struct timespec time, int (*erase)(u64));
+			      struct timespec time, struct pstore_info *psi);
 extern int	pstore_is_mounted(void);

commit 366f7e7a79b19bd8c4e8f55fdf12b81538d1a7a4
Author: Luck, Tony <tony.luck@intel.com>
Date:   Fri Mar 18 15:33:43 2011 -0700

    pstore: use mount option instead sysfs to tweak kmsg_bytes
    
    /sys/fs is a somewhat strange way to tweak what could more
    obviously be tuned with a mount option.
    
    Suggested-by: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
index 76c26d2fab29..8c9f23eb1645 100644
--- a/fs/pstore/internal.h
+++ b/fs/pstore/internal.h
@@ -1,7 +1,6 @@
+extern void	pstore_set_kmsg_bytes(int);
 extern void	pstore_get_records(void);
 extern int	pstore_mkfile(enum pstore_type_id, char *psname, u64 id,
 			      char *data, size_t size,
 			      struct timespec time, int (*erase)(u64));
 extern int	pstore_is_mounted(void);
-
-extern struct kobj_attribute pstore_kmsg_bytes_attr;

commit ca01d6dd2d7a2652000307520777538740efc286
Author: Tony Luck <tony.luck@intel.com>
Date:   Tue Dec 28 14:25:21 2010 -0800

    pstore: new filesystem interface to platform persistent storage
    
    Some platforms have a small amount of non-volatile storage that
    can be used to store information useful to diagnose the cause of
    a system crash.  This is the generic part of a file system interface
    that presents information from the crash as a series of files in
    /dev/pstore.  Once the information has been seen, the underlying
    storage is freed by deleting the files.
    
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/internal.h b/fs/pstore/internal.h
new file mode 100644
index 000000000000..76c26d2fab29
--- /dev/null
+++ b/fs/pstore/internal.h
@@ -0,0 +1,7 @@
+extern void	pstore_get_records(void);
+extern int	pstore_mkfile(enum pstore_type_id, char *psname, u64 id,
+			      char *data, size_t size,
+			      struct timespec time, int (*erase)(u64));
+extern int	pstore_is_mounted(void);
+
+extern struct kobj_attribute pstore_kmsg_bytes_attr;
