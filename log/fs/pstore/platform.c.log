commit 3524e688b8ee50b0edc76f0e020727eb6c684dbc
Author: Pavel Tatashin <pasha.tatashin@soleen.com>
Date:   Tue May 5 11:45:07 2020 -0400

    pstore/platform: Pass max_reason to kmesg dump
    
    Add a new member to struct pstore_info for passing information about
    kmesg dump maximum reason. This allows a finer control of what kmesg
    dumps are sent to pstore storage backends.
    
    Those backends that do not explicitly set this field (keeping it equal to
    0), get the default behavior: store only Oopses and Panics, or everything
    if the printk.always_kmsg_dump boot param is set.
    
    Signed-off-by: Pavel Tatashin <pasha.tatashin@soleen.com>
    Link: https://lore.kernel.org/lkml/20200515184434.8470-5-keescook@chromium.org/
    Co-developed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 5e6c6022deb9..a9e297eefdff 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -595,8 +595,10 @@ int pstore_register(struct pstore_info *psi)
 
 	pstore_get_records(0);
 
-	if (psi->flags & PSTORE_FLAGS_DMESG)
+	if (psi->flags & PSTORE_FLAGS_DMESG) {
+		pstore_dumper.max_reason = psinfo->max_reason;
 		pstore_register_kmsg();
+	}
 	if (psi->flags & PSTORE_FLAGS_CONSOLE)
 		pstore_register_console();
 	if (psi->flags & PSTORE_FLAGS_FTRACE)

commit fb13cb8a0482105a415e24042209d02a684255e2
Author: Kees Cook <keescook@chromium.org>
Date:   Thu May 7 19:36:22 2020 -0700

    printk: Introduce kmsg_dump_reason_str()
    
    The pstore subsystem already had a private version of this function.
    With the coming addition of the pstore/zone driver, this needs to be
    shared. As it really should live with printk, move it there instead.
    
    Link: https://lore.kernel.org/lkml/20200515184434.8470-4-keescook@chromium.org/
    Acked-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Pavel Tatashin <pasha.tatashin@soleen.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 90d74ebaa70a..5e6c6022deb9 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -135,22 +135,6 @@ enum pstore_type_id pstore_name_to_type(const char *name)
 }
 EXPORT_SYMBOL_GPL(pstore_name_to_type);
 
-static const char *get_reason_str(enum kmsg_dump_reason reason)
-{
-	switch (reason) {
-	case KMSG_DUMP_PANIC:
-		return "Panic";
-	case KMSG_DUMP_OOPS:
-		return "Oops";
-	case KMSG_DUMP_EMERG:
-		return "Emergency";
-	case KMSG_DUMP_SHUTDOWN:
-		return "Shutdown";
-	default:
-		return "Unknown";
-	}
-}
-
 static void pstore_timer_kick(void)
 {
 	if (pstore_update_ms < 0)
@@ -403,7 +387,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 	unsigned int	part = 1;
 	int		ret;
 
-	why = get_reason_str(reason);
+	why = kmsg_dump_reason_str(reason);
 
 	if (down_trylock(&psinfo->buf_lock)) {
 		/* Failed to acquire lock: give up if we cannot wait. */

commit 6d3cf962dd1a95df868c547b090bfc4c7977f4be
Author: Kees Cook <keescook@chromium.org>
Date:   Fri May 15 11:05:43 2020 -0700

    printk: Collapse shutdown types into a single dump reason
    
    To turn the KMSG_DUMP_* reasons into a more ordered list, collapse
    the redundant KMSG_DUMP_(RESTART|HALT|POWEROFF) reasons into
    KMSG_DUMP_SHUTDOWN. The current users already don't meaningfully
    distinguish between them, so there's no need to, as discussed here:
    https://lore.kernel.org/lkml/CA+CK2bAPv5u1ih5y9t5FUnTyximtFCtDYXJCpuyjOyHNOkRdqw@mail.gmail.com/
    
    Link: https://lore.kernel.org/lkml/20200515184434.8470-2-keescook@chromium.org/
    Reviewed-by: Pavel Tatashin <pasha.tatashin@soleen.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 072440457c08..90d74ebaa70a 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -144,12 +144,8 @@ static const char *get_reason_str(enum kmsg_dump_reason reason)
 		return "Oops";
 	case KMSG_DUMP_EMERG:
 		return "Emergency";
-	case KMSG_DUMP_RESTART:
-		return "Restart";
-	case KMSG_DUMP_HALT:
-		return "Halt";
-	case KMSG_DUMP_POWEROFF:
-		return "Poweroff";
+	case KMSG_DUMP_SHUTDOWN:
+		return "Shutdown";
 	default:
 		return "Unknown";
 	}

commit d973f7d83dc7360597373536b34e80eea306d15f
Author: Kees Cook <keescook@chromium.org>
Date:   Fri May 8 09:25:19 2020 -0700

    pstore/platform: Move module params after declarations
    
    It is easier to see how module params are used if they're near the
    variables they use.
    
    Link: https://lore.kernel.org/lkml/20200510202436.63222-4-keescook@chromium.org/
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index e8690d8606e0..072440457c08 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -77,12 +77,17 @@ static DEFINE_MUTEX(psinfo_lock);
 struct pstore_info *psinfo;
 
 static char *backend;
+module_param(backend, charp, 0444);
+MODULE_PARM_DESC(backend, "specific backend to use");
+
 static char *compress =
 #ifdef CONFIG_PSTORE_COMPRESS_DEFAULT
 		CONFIG_PSTORE_COMPRESS_DEFAULT;
 #else
 		NULL;
 #endif
+module_param(compress, charp, 0444);
+MODULE_PARM_DESC(compress, "compression to use");
 
 /* Compression parameters */
 static struct crypto_comp *tfm;
@@ -853,11 +858,5 @@ static void __exit pstore_exit(void)
 }
 module_exit(pstore_exit)
 
-module_param(compress, charp, 0444);
-MODULE_PARM_DESC(compress, "Pstore compression to use");
-
-module_param(backend, charp, 0444);
-MODULE_PARM_DESC(backend, "Pstore backend to use");
-
 MODULE_AUTHOR("Tony Luck <tony.luck@intel.com>");
 MODULE_LICENSE("GPL");

commit d195c39052d1da278a00a6744ce59c383b67b191
Author: Kees Cook <keescook@chromium.org>
Date:   Fri May 8 09:26:28 2020 -0700

    pstore/platform: Use backend name for console registration
    
    If the pstore backend changes, there's no indication in the logs what
    the console is (it always says "pstore"). Instead, pass through the
    active backend's name. (Also adjust the selftest to match.)
    
    Link: https://lore.kernel.org/lkml/20200510202436.63222-5-keescook@chromium.org/
    Link: https://lore.kernel.org/lkml/20200526135429.GQ12456@shao2-debian
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 715396bef0ea..e8690d8606e0 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -514,13 +514,15 @@ static void pstore_console_write(struct console *con, const char *s, unsigned c)
 }
 
 static struct console pstore_console = {
-	.name	= "pstore",
 	.write	= pstore_console_write,
 	.index	= -1,
 };
 
 static void pstore_register_console(void)
 {
+	/* Show which backend is going to get console writes. */
+	strscpy(pstore_console.name, psinfo->name,
+		sizeof(pstore_console.name));
 	/*
 	 * Always initialize flags here since prior unregister_console()
 	 * calls may have changed settings (specifically CON_ENABLED).

commit 563ca40ddf400dbf8c6254077f9b6887101d0f08
Author: Kees Cook <keescook@chromium.org>
Date:   Fri May 8 09:16:02 2020 -0700

    pstore/platform: Switch pstore_info::name to const
    
    In order to more cleanly pass around backend names, make the "name" member
    const. This means the module param needs to be dynamic (technically, it
    was before, so this actually cleans up a minor memory leak if a backend
    was specified and then gets unloaded.)
    
    Link: https://lore.kernel.org/lkml/20200510202436.63222-3-keescook@chromium.org/
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 8beaeff72386..715396bef0ea 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -624,7 +624,7 @@ int pstore_register(struct pstore_info *psi)
 	 * Update the module parameter backend, so it is visible
 	 * through /sys/module/pstore/parameters/backend
 	 */
-	backend = psi->name;
+	backend = kstrdup(psi->name, GFP_KERNEL);
 
 	pr_info("Registered %s as persistent store backend\n", psi->name);
 
@@ -667,6 +667,7 @@ void pstore_unregister(struct pstore_info *psi)
 	free_buf_for_compression();
 
 	psinfo = NULL;
+	kfree(backend);
 	backend = NULL;
 	mutex_unlock(&psinfo_lock);
 }

commit b7753fc7f6f5626e51ee78156fd801fb52163af0
Author: Kees Cook <keescook@chromium.org>
Date:   Wed May 6 16:34:42 2020 -0700

    pstore: Make sure console capturing will restart
    
    The CON_ENABLED flag gets cleared during unregister_console(), so make
    sure we already reset the console flags before calling register_console(),
    otherwise unloading and reloading a pstore backend will not restart
    console logging.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 398785ab059f..8beaeff72386 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -516,12 +516,16 @@ static void pstore_console_write(struct console *con, const char *s, unsigned c)
 static struct console pstore_console = {
 	.name	= "pstore",
 	.write	= pstore_console_write,
-	.flags	= CON_PRINTBUFFER | CON_ENABLED | CON_ANYTIME,
 	.index	= -1,
 };
 
 static void pstore_register_console(void)
 {
+	/*
+	 * Always initialize flags here since prior unregister_console()
+	 * calls may have changed settings (specifically CON_ENABLED).
+	 */
+	pstore_console.flags = CON_PRINTBUFFER | CON_ENABLED | CON_ANYTIME;
 	register_console(&pstore_console);
 }
 

commit 609e28bb139e53621521130f0d4aea27a725d465
Author: Kees Cook <keescook@chromium.org>
Date:   Mon May 4 19:46:53 2020 -0700

    pstore: Remove filesystem records when backend is unregistered
    
    If a backend was unloaded without having first removed all its
    associated records in pstorefs, subsequent removals would crash while
    attempting to call into the now missing backend. Add automatic removal
    from the tree in pstore_unregister(), so that no references to the
    backend remain.
    
    Reported-by: Luis Henriques <lhenriques@suse.com>
    Link: https://lore.kernel.org/lkml/87o8yrmv69.fsf@suse.com
    Link: https://lore.kernel.org/lkml/20200506152114.50375-11-keescook@chromium.org/
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 327ee70e881d..398785ab059f 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -657,6 +657,9 @@ void pstore_unregister(struct pstore_info *psi)
 	del_timer_sync(&pstore_timer);
 	flush_work(&pstore_work);
 
+	/* Remove all backend records from filesystem tree. */
+	pstore_put_backend_records(psi);
+
 	free_buf_for_compression();
 
 	psinfo = NULL;

commit 78c83c828c043f2e18929137c1e218e8977349b1
Author: Kees Cook <keescook@chromium.org>
Date:   Tue May 5 21:36:15 2020 -0700

    pstore: Do not leave timer disabled for next backend
    
    The pstore.update_ms value was being disabled during pstore_unregister(),
    which would cause any prior value to go unnoticed on the next
    pstore_register(). Instead, just let del_timer() stop the timer, which
    was always sufficient. This additionally refactors the timer reset code
    and allows the timer to be enabled if the module parameter is changed
    away from the default.
    
    Link: https://lore.kernel.org/lkml/20200506152114.50375-10-keescook@chromium.org/
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 624e100fbeca..327ee70e881d 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -44,7 +44,7 @@ static int pstore_update_ms = -1;
 module_param_named(update_ms, pstore_update_ms, int, 0600);
 MODULE_PARM_DESC(update_ms, "milliseconds before pstore updates its content "
 		 "(default is -1, which means runtime updates are disabled; "
-		 "enabling this option is not safe, it may lead to further "
+		 "enabling this option may not be safe; it may lead to further "
 		 "corruption on Oopses)");
 
 /* Names should be in the same order as the enum pstore_type_id */
@@ -150,6 +150,14 @@ static const char *get_reason_str(enum kmsg_dump_reason reason)
 	}
 }
 
+static void pstore_timer_kick(void)
+{
+	if (pstore_update_ms < 0)
+		return;
+
+	mod_timer(&pstore_timer, jiffies + msecs_to_jiffies(pstore_update_ms));
+}
+
 /*
  * Should pstore_dump() wait for a concurrent pstore_dump()? If
  * not, the current pstore_dump() will report a failure to dump
@@ -460,8 +468,10 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		}
 
 		ret = psinfo->write(&record);
-		if (ret == 0 && reason == KMSG_DUMP_OOPS)
+		if (ret == 0 && reason == KMSG_DUMP_OOPS) {
 			pstore_new_entry = 1;
+			pstore_timer_kick();
+		}
 
 		total += record.size;
 		part++;
@@ -604,11 +614,7 @@ int pstore_register(struct pstore_info *psi)
 		pstore_register_pmsg();
 
 	/* Start watching for new records, if desired. */
-	if (pstore_update_ms >= 0) {
-		pstore_timer.expires = jiffies +
-			msecs_to_jiffies(pstore_update_ms);
-		add_timer(&pstore_timer);
-	}
+	pstore_timer_kick();
 
 	/*
 	 * Update the module parameter backend, so it is visible
@@ -637,11 +643,7 @@ void pstore_unregister(struct pstore_info *psi)
 		return;
 	}
 
-	/* Stop timer and make sure all work has finished. */
-	pstore_update_ms = -1;
-	del_timer_sync(&pstore_timer);
-	flush_work(&pstore_work);
-
+	/* Unregister all callbacks. */
 	if (psi->flags & PSTORE_FLAGS_PMSG)
 		pstore_unregister_pmsg();
 	if (psi->flags & PSTORE_FLAGS_FTRACE)
@@ -651,6 +653,10 @@ void pstore_unregister(struct pstore_info *psi)
 	if (psi->flags & PSTORE_FLAGS_DMESG)
 		pstore_unregister_kmsg();
 
+	/* Stop timer and make sure all work has finished. */
+	del_timer_sync(&pstore_timer);
+	flush_work(&pstore_work);
+
 	free_buf_for_compression();
 
 	psinfo = NULL;
@@ -792,9 +798,7 @@ static void pstore_timefunc(struct timer_list *unused)
 		schedule_work(&pstore_work);
 	}
 
-	if (pstore_update_ms >= 0)
-		mod_timer(&pstore_timer,
-			  jiffies + msecs_to_jiffies(pstore_update_ms));
+	pstore_timer_kick();
 }
 
 static void __init pstore_choose_compression(void)

commit 27e5041a87e8af2d0b6452dffe053d0253e914cc
Author: Kees Cook <keescook@chromium.org>
Date:   Mon May 4 19:43:41 2020 -0700

    pstore: Add locking around superblock changes
    
    Nothing was protecting changes to the pstorefs superblock. Add locking
    and refactor away is_pstore_mounted(), instead using a helper to add a
    way to safely lock the pstorefs root inode during filesystem changes.
    
    Link: https://lore.kernel.org/lkml/20200506152114.50375-9-keescook@chromium.org/
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 8c0076a1f896..624e100fbeca 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -460,7 +460,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		}
 
 		ret = psinfo->write(&record);
-		if (ret == 0 && reason == KMSG_DUMP_OOPS && pstore_is_mounted())
+		if (ret == 0 && reason == KMSG_DUMP_OOPS)
 			pstore_new_entry = 1;
 
 		total += record.size;
@@ -592,8 +592,7 @@ int pstore_register(struct pstore_info *psi)
 	if (psi->flags & PSTORE_FLAGS_DMESG)
 		allocate_buf_for_compression();
 
-	if (pstore_is_mounted())
-		pstore_get_records(0);
+	pstore_get_records(0);
 
 	if (psi->flags & PSTORE_FLAGS_DMESG)
 		pstore_register_kmsg();

commit 6248a0666c8a408dcc5bd952536274d5bd0f02cb
Author: Kees Cook <keescook@chromium.org>
Date:   Mon May 4 19:33:54 2020 -0700

    pstore: Add proper unregister lock checking
    
    The pstore backend lock wasn't being used during pstore_unregister().
    Add sanity check and locking.
    
    Link: https://lore.kernel.org/lkml/20200506152114.50375-7-keescook@chromium.org/
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index d0ce22237589..8c0076a1f896 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -69,8 +69,9 @@ static void pstore_dowork(struct work_struct *);
 static DECLARE_WORK(pstore_work, pstore_dowork);
 
 /*
- * psinfo_lock just protects "psinfo" during
- * calls to pstore_register()
+ * psinfo_lock protects "psinfo" during calls to
+ * pstore_register(), pstore_unregister(), and
+ * the filesystem mount/unmount routines.
  */
 static DEFINE_MUTEX(psinfo_lock);
 struct pstore_info *psinfo;
@@ -587,8 +588,6 @@ int pstore_register(struct pstore_info *psi)
 	psinfo = psi;
 	mutex_init(&psinfo->read_mutex);
 	sema_init(&psinfo->buf_lock, 1);
-	mutex_unlock(&psinfo_lock);
-
 
 	if (psi->flags & PSTORE_FLAGS_DMESG)
 		allocate_buf_for_compression();
@@ -620,12 +619,25 @@ int pstore_register(struct pstore_info *psi)
 
 	pr_info("Registered %s as persistent store backend\n", psi->name);
 
+	mutex_unlock(&psinfo_lock);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(pstore_register);
 
 void pstore_unregister(struct pstore_info *psi)
 {
+	/* It's okay to unregister nothing. */
+	if (!psi)
+		return;
+
+	mutex_lock(&psinfo_lock);
+
+	/* Only one backend can be registered at a time. */
+	if (WARN_ON(psi != psinfo)) {
+		mutex_unlock(&psinfo_lock);
+		return;
+	}
+
 	/* Stop timer and make sure all work has finished. */
 	pstore_update_ms = -1;
 	del_timer_sync(&pstore_timer);
@@ -644,6 +656,7 @@ void pstore_unregister(struct pstore_info *psi)
 
 	psinfo = NULL;
 	backend = NULL;
+	mutex_unlock(&psinfo_lock);
 }
 EXPORT_SYMBOL_GPL(pstore_unregister);
 

commit cab12fd049380b1d0c3ac9f534407a8cc0ac4bba
Author: Kees Cook <keescook@chromium.org>
Date:   Mon May 4 19:31:36 2020 -0700

    pstore: Convert "psinfo" locking to mutex
    
    Currently pstore can only have a single backend attached at a time, and it
    tracks the active backend via "psinfo", under a lock. The locking for this
    does not need to be a spinlock, and in order to avoid may_sleep() issues
    during future changes to pstore_unregister(), switch to a mutex instead.
    
    Link: https://lore.kernel.org/lkml/20200506152114.50375-4-keescook@chromium.org/
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 347b6c07f4cf..d0ce22237589 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -72,7 +72,7 @@ static DECLARE_WORK(pstore_work, pstore_dowork);
  * psinfo_lock just protects "psinfo" during
  * calls to pstore_register()
  */
-static DEFINE_SPINLOCK(psinfo_lock);
+static DEFINE_MUTEX(psinfo_lock);
 struct pstore_info *psinfo;
 
 static char *backend;
@@ -574,11 +574,11 @@ int pstore_register(struct pstore_info *psi)
 		return -EINVAL;
 	}
 
-	spin_lock(&psinfo_lock);
+	mutex_lock(&psinfo_lock);
 	if (psinfo) {
 		pr_warn("backend '%s' already loaded: ignoring '%s'\n",
 			psinfo->name, psi->name);
-		spin_unlock(&psinfo_lock);
+		mutex_unlock(&psinfo_lock);
 		return -EBUSY;
 	}
 
@@ -587,7 +587,7 @@ int pstore_register(struct pstore_info *psi)
 	psinfo = psi;
 	mutex_init(&psinfo->read_mutex);
 	sema_init(&psinfo->buf_lock, 1);
-	spin_unlock(&psinfo_lock);
+	mutex_unlock(&psinfo_lock);
 
 
 	if (psi->flags & PSTORE_FLAGS_DMESG)

commit c30b20cd96a7a08e77c12cb3326c6fd801f7fe87
Author: Kees Cook <keescook@chromium.org>
Date:   Tue May 5 23:29:10 2020 -0700

    pstore: Rename "pstore_lock" to "psinfo_lock"
    
    The name "pstore_lock" sounds very global, but it is only supposed to be
    used for managing changes to "psinfo", so rename it accordingly.
    
    Link: https://lore.kernel.org/lkml/20200506152114.50375-3-keescook@chromium.org/
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 44f8b9742263..347b6c07f4cf 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -69,10 +69,10 @@ static void pstore_dowork(struct work_struct *);
 static DECLARE_WORK(pstore_work, pstore_dowork);
 
 /*
- * pstore_lock just protects "psinfo" during
+ * psinfo_lock just protects "psinfo" during
  * calls to pstore_register()
  */
-static DEFINE_SPINLOCK(pstore_lock);
+static DEFINE_SPINLOCK(psinfo_lock);
 struct pstore_info *psinfo;
 
 static char *backend;
@@ -574,11 +574,11 @@ int pstore_register(struct pstore_info *psi)
 		return -EINVAL;
 	}
 
-	spin_lock(&pstore_lock);
+	spin_lock(&psinfo_lock);
 	if (psinfo) {
 		pr_warn("backend '%s' already loaded: ignoring '%s'\n",
 			psinfo->name, psi->name);
-		spin_unlock(&pstore_lock);
+		spin_unlock(&psinfo_lock);
 		return -EBUSY;
 	}
 
@@ -587,7 +587,7 @@ int pstore_register(struct pstore_info *psi)
 	psinfo = psi;
 	mutex_init(&psinfo->read_mutex);
 	sema_init(&psinfo->buf_lock, 1);
-	spin_unlock(&pstore_lock);
+	spin_unlock(&psinfo_lock);
 
 
 	if (psi->flags & PSTORE_FLAGS_DMESG)

commit e7c1c00cf3fafde7496e31cacd718a51d0e7d70c
Author: Kees Cook <keescook@chromium.org>
Date:   Mon May 4 19:21:54 2020 -0700

    pstore: Drop useless try_module_get() for backend
    
    There is no reason to be doing a module get/put in pstore_register(),
    since the module calling pstore_register() cannot be unloaded since it
    hasn't finished its initialization. Remove it so there is no confusion
    about how registration ordering works.
    
    Link: https://lore.kernel.org/lkml/20200506152114.50375-2-keescook@chromium.org/
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 408277ee3cdb..44f8b9742263 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -555,8 +555,6 @@ static int pstore_write_user_compat(struct pstore_record *record,
  */
 int pstore_register(struct pstore_info *psi)
 {
-	struct module *owner = psi->owner;
-
 	if (backend && strcmp(backend, psi->name)) {
 		pr_warn("ignoring unexpected backend '%s'\n", psi->name);
 		return -EPERM;
@@ -591,10 +589,6 @@ int pstore_register(struct pstore_info *psi)
 	sema_init(&psinfo->buf_lock, 1);
 	spin_unlock(&pstore_lock);
 
-	if (owner && !try_module_get(owner)) {
-		psinfo = NULL;
-		return -EINVAL;
-	}
 
 	if (psi->flags & PSTORE_FLAGS_DMESG)
 		allocate_buf_for_compression();
@@ -626,8 +620,6 @@ int pstore_register(struct pstore_info *psi)
 
 	pr_info("Registered %s as persistent store backend\n", psi->name);
 
-	module_put(owner);
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(pstore_register);

commit 8a57d6d4ddfa41c49014e20493152c41a38fcbf8
Author: chenqiwu <chenqiwu@xiaomi.com>
Date:   Fri Feb 7 17:46:39 2020 +0800

    pstore/platform: fix potential mem leak if pstore_init_fs failed
    
    There is a potential mem leak when pstore_init_fs failed,
    since the pstore compression maybe unlikey to initialized
    successfully. We must clean up the allocation once this
    unlikey issue happens.
    
    Signed-off-by: chenqiwu <chenqiwu@xiaomi.com>
    Link: https://lore.kernel.org/r/1581068800-13817-1-git-send-email-qiwuchen55@gmail.com
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index d896457e7c11..408277ee3cdb 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -823,9 +823,9 @@ static int __init pstore_init(void)
 
 	ret = pstore_init_fs();
 	if (ret)
-		return ret;
+		free_buf_for_compression();
 
-	return 0;
+	return ret;
 }
 late_initcall(pstore_init);
 

commit 8d82cee2f8aa8b9bc806907ecd9e1494c6e8526b
Author: Ben Dooks (Codethink) <ben.dooks@codethink.co.uk>
Date:   Wed Oct 16 13:33:17 2019 +0100

    pstore: Make pstore_choose_compression() static
    
    The pstore_choose_compression() function is not exported so make it
    static to avoid the following sparse warning:
    
    fs/pstore/platform.c:796:13: warning: symbol 'pstore_choose_compression' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Link: https://lore.kernel.org/r/20191016123317.3154-1-ben.dooks@codethink.co.uk
    Fixes: cb095afd4476 ("pstore: Centralize init/exit routines")
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 3d7024662d29..d896457e7c11 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -793,7 +793,7 @@ static void pstore_timefunc(struct timer_list *unused)
 			  jiffies + msecs_to_jiffies(pstore_update_ms));
 }
 
-void __init pstore_choose_compression(void)
+static void __init pstore_choose_compression(void)
 {
 	const struct pstore_zbackend *step;
 

commit 9331b6740f86163908de69f4008e434fe0c27691
Merge: 1ce2c85137b1 d925da5c7b09
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 8 12:52:42 2019 -0700

    Merge tag 'spdx-5.2-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull yet more SPDX updates from Greg KH:
     "Another round of SPDX header file fixes for 5.2-rc4
    
      These are all more "GPL-2.0-or-later" or "GPL-2.0-only" tags being
      added, based on the text in the files. We are slowly chipping away at
      the 700+ different ways people tried to write the license text. All of
      these were reviewed on the spdx mailing list by a number of different
      people.
    
      We now have over 60% of the kernel files covered with SPDX tags:
            $ ./scripts/spdxcheck.py -v 2>&1 | grep Files
            Files checked:            64533
            Files with SPDX:          40392
            Files with errors:            0
    
      I think the majority of the "easy" fixups are now done, it's now the
      start of the longer-tail of crazy variants to wade through"
    
    * tag 'spdx-5.2-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (159 commits)
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 450
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 449
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 448
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 446
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 445
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 444
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 443
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 442
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 441
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 440
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 438
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 437
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 436
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 435
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 434
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 433
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 432
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 431
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 430
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 429
      ...

commit 4505153954fdb1465d2b178288a9bf646f2a2166
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:47 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 333
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 136 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.384967451@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 75887a269b64..9f83686db0be 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -1,21 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Persistent Storage - platform driver interface parts.
  *
  * Copyright (C) 2007-2008 Google, Inc.
  * Copyright (C) 2010 Intel Corporation <tony.luck@intel.com>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #define pr_fmt(fmt) "pstore: " fmt

commit 8880fa32c557600f5f624084152668ed3c2ea51e
Author: Kees Cook <keescook@chromium.org>
Date:   Thu May 30 23:37:29 2019 -0700

    pstore/ram: Run without kernel crash dump region
    
    The ram pstore backend has always had the crash dumper frontend enabled
    unconditionally. However, it was possible to effectively disable it
    by setting a record_size=0. All the machinery would run (storing dumps
    to the temporary crash buffer), but 0 bytes would ultimately get stored
    due to there being no przs allocated for dumps. Commit 89d328f637b9
    ("pstore/ram: Correctly calculate usable PRZ bytes"), however, assumed
    that there would always be at least one allocated dprz for calculating
    the size of the temporary crash buffer. This was, of course, not the
    case when record_size=0, and would lead to a NULL deref trying to find
    the dprz buffer size:
    
    BUG: unable to handle kernel NULL pointer dereference at (null)
    ...
    IP: ramoops_probe+0x285/0x37e (fs/pstore/ram.c:808)
    
            cxt->pstore.bufsize = cxt->dprzs[0]->buffer_size;
    
    Instead, we need to only enable the frontends based on the success of the
    prz initialization and only take the needed actions when those zones are
    available. (This also fixes a possible error in detecting if the ftrace
    frontend should be enabled.)
    
    Reported-and-tested-by: Yaro Slav <yaro330@gmail.com>
    Fixes: 89d328f637b9 ("pstore/ram: Correctly calculate usable PRZ bytes")
    Cc: stable@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 8355a46638d0..dca07f239bd1 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -608,7 +608,8 @@ int pstore_register(struct pstore_info *psi)
 		return -EINVAL;
 	}
 
-	allocate_buf_for_compression();
+	if (psi->flags & PSTORE_FLAGS_DMESG)
+		allocate_buf_for_compression();
 
 	if (pstore_is_mounted())
 		pstore_get_records(0);

commit a9fb94a99bb515d8720ba8440ce3aba84aec80f8
Author: Pi-Hsun Shih <pihsun@chromium.org>
Date:   Mon May 20 14:51:19 2019 +0800

    pstore: Set tfm to NULL on free_buf_for_compression
    
    Set tfm to NULL on free_buf_for_compression() after crypto_free_comp().
    
    This avoid a use-after-free when allocate_buf_for_compression()
    and free_buf_for_compression() are called twice. Although
    free_buf_for_compression() freed the tfm, allocate_buf_for_compression()
    won't reinitialize the tfm since the tfm pointer is not NULL.
    
    Fixes: 95047b0519c1 ("pstore: Refactor compression initialization")
    Signed-off-by: Pi-Hsun Shih <pihsun@chromium.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 75887a269b64..8355a46638d0 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -347,8 +347,10 @@ static void allocate_buf_for_compression(void)
 
 static void free_buf_for_compression(void)
 {
-	if (IS_ENABLED(CONFIG_PSTORE_COMPRESS) && tfm)
+	if (IS_ENABLED(CONFIG_PSTORE_COMPRESS) && tfm) {
 		crypto_free_comp(tfm);
+		tfm = NULL;
+	}
 	kfree(big_oops_buf);
 	big_oops_buf = NULL;
 	big_oops_buf_sz = 0;

commit 4c6c4d34536744f2c9e171ef5bb548a06a525501
Author: Yue Hu <huyue2@yulong.com>
Date:   Thu Jan 31 18:12:46 2019 +0800

    pstore: Avoid writing records with zero size
    
    Sometimes pstore_console_write() will write records with zero size
    to persistent ram zone, which is unnecessary. It will only increase
    resource consumption. Also adjust ramoops_write_kmsg_hdr() to have
    same logic if memory allocation fails.
    
    Signed-off-by: Yue Hu <huyue2@yulong.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 2d1066ed3c28..75887a269b64 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -501,6 +501,9 @@ static void pstore_console_write(struct console *con, const char *s, unsigned c)
 {
 	struct pstore_record record;
 
+	if (!c)
+		return;
+
 	pstore_record_init(&record, psinfo);
 	record.type = PSTORE_TYPE_CONSOLE;
 

commit ea84b580b95521644429cc6748b6c2bf27c8b0f3
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Nov 30 14:36:58 2018 -0800

    pstore: Convert buf_lock to semaphore
    
    Instead of running with interrupts disabled, use a semaphore. This should
    make it easier for backends that may need to sleep (e.g. EFI) when
    performing a write:
    
    |BUG: sleeping function called from invalid context at kernel/sched/completion.c:99
    |in_atomic(): 1, irqs_disabled(): 1, pid: 2236, name: sig-xstate-bum
    |Preemption disabled at:
    |[<ffffffff99d60512>] pstore_dump+0x72/0x330
    |CPU: 26 PID: 2236 Comm: sig-xstate-bum Tainted: G      D           4.20.0-rc3 #45
    |Call Trace:
    | dump_stack+0x4f/0x6a
    | ___might_sleep.cold.91+0xd3/0xe4
    | __might_sleep+0x50/0x90
    | wait_for_completion+0x32/0x130
    | virt_efi_query_variable_info+0x14e/0x160
    | efi_query_variable_store+0x51/0x1a0
    | efivar_entry_set_safe+0xa3/0x1b0
    | efi_pstore_write+0x109/0x140
    | pstore_dump+0x11c/0x330
    | kmsg_dump+0xa4/0xd0
    | oops_exit+0x22/0x30
    ...
    
    Reported-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Fixes: 21b3ddd39fee ("efi: Don't use spinlocks for efi vars")
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 2387cb74f729..2d1066ed3c28 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -161,26 +161,27 @@ static const char *get_reason_str(enum kmsg_dump_reason reason)
 	}
 }
 
-bool pstore_cannot_block_path(enum kmsg_dump_reason reason)
+/*
+ * Should pstore_dump() wait for a concurrent pstore_dump()? If
+ * not, the current pstore_dump() will report a failure to dump
+ * and return.
+ */
+static bool pstore_cannot_wait(enum kmsg_dump_reason reason)
 {
-	/*
-	 * In case of NMI path, pstore shouldn't be blocked
-	 * regardless of reason.
-	 */
+	/* In NMI path, pstore shouldn't block regardless of reason. */
 	if (in_nmi())
 		return true;
 
 	switch (reason) {
 	/* In panic case, other cpus are stopped by smp_send_stop(). */
 	case KMSG_DUMP_PANIC:
-	/* Emergency restart shouldn't be blocked by spin lock. */
+	/* Emergency restart shouldn't be blocked. */
 	case KMSG_DUMP_EMERG:
 		return true;
 	default:
 		return false;
 	}
 }
-EXPORT_SYMBOL_GPL(pstore_cannot_block_path);
 
 #if IS_ENABLED(CONFIG_PSTORE_DEFLATE_COMPRESS)
 static int zbufsize_deflate(size_t size)
@@ -400,23 +401,23 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 	unsigned long	total = 0;
 	const char	*why;
 	unsigned int	part = 1;
-	unsigned long	flags = 0;
-	int		is_locked;
 	int		ret;
 
 	why = get_reason_str(reason);
 
-	if (pstore_cannot_block_path(reason)) {
-		is_locked = spin_trylock_irqsave(&psinfo->buf_lock, flags);
-		if (!is_locked) {
-			pr_err("pstore dump routine blocked in %s path, may corrupt error record\n"
-				       , in_nmi() ? "NMI" : why);
+	if (down_trylock(&psinfo->buf_lock)) {
+		/* Failed to acquire lock: give up if we cannot wait. */
+		if (pstore_cannot_wait(reason)) {
+			pr_err("dump skipped in %s path: may corrupt error record\n",
+				in_nmi() ? "NMI" : why);
+			return;
+		}
+		if (down_interruptible(&psinfo->buf_lock)) {
+			pr_err("could not grab semaphore?!\n");
 			return;
 		}
-	} else {
-		spin_lock_irqsave(&psinfo->buf_lock, flags);
-		is_locked = 1;
 	}
+
 	oopscount++;
 	while (total < kmsg_bytes) {
 		char *dst;
@@ -433,7 +434,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		record.part = part;
 		record.buf = psinfo->buf;
 
-		if (big_oops_buf && is_locked) {
+		if (big_oops_buf) {
 			dst = big_oops_buf;
 			dst_size = big_oops_buf_sz;
 		} else {
@@ -451,7 +452,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 					  dst_size, &dump_size))
 			break;
 
-		if (big_oops_buf && is_locked) {
+		if (big_oops_buf) {
 			zipped_len = pstore_compress(dst, psinfo->buf,
 						header_size + dump_size,
 						psinfo->bufsize);
@@ -474,8 +475,8 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		total += record.size;
 		part++;
 	}
-	if (is_locked)
-		spin_unlock_irqrestore(&psinfo->buf_lock, flags);
+
+	up(&psinfo->buf_lock);
 }
 
 static struct kmsg_dumper pstore_dumper = {
@@ -594,6 +595,7 @@ int pstore_register(struct pstore_info *psi)
 		psi->write_user = pstore_write_user_compat;
 	psinfo = psi;
 	mutex_init(&psinfo->read_mutex);
+	sema_init(&psinfo->buf_lock, 1);
 	spin_unlock(&pstore_lock);
 
 	if (owner && !try_module_get(owner)) {

commit f0f23e5469dc80b482d985898a930be0e249a162
Author: Joel Fernandes (Google) <joel@joelfernandes.org>
Date:   Sat Nov 3 16:38:16 2018 -0700

    pstore: Map PSTORE_TYPE_* to strings
    
    In later patches we will need to map types to names, so create a
    constant table for that which can also be used in different parts of
    old and new code. This saves the type in the PRZ which will be useful
    in later patches.
    
    Instead of having an explicit PSTORE_TYPE_UNKNOWN, just use ..._MAX.
    
    This includes removing the now redundant filename templates which can use
    a single format string. Also, there's no reason to limit the "is it still
    compressed?" test to only PSTORE_TYPE_DMESG when building the pstorefs
    filename. Records are zero-initialized, so a backend would need to have
    explicitly set compressed=1.
    
    Signed-off-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    Co-developed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 32340e7dd6a5..2387cb74f729 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -59,6 +59,19 @@ MODULE_PARM_DESC(update_ms, "milliseconds before pstore updates its content "
 		 "enabling this option is not safe, it may lead to further "
 		 "corruption on Oopses)");
 
+/* Names should be in the same order as the enum pstore_type_id */
+static const char * const pstore_type_names[] = {
+	"dmesg",
+	"mce",
+	"console",
+	"ftrace",
+	"rtas",
+	"powerpc-ofw",
+	"powerpc-common",
+	"pmsg",
+	"powerpc-opal",
+};
+
 static int pstore_new_entry;
 
 static void pstore_timefunc(struct timer_list *);
@@ -104,6 +117,30 @@ void pstore_set_kmsg_bytes(int bytes)
 /* Tag each group of saved records with a sequence number */
 static int	oopscount;
 
+const char *pstore_type_to_name(enum pstore_type_id type)
+{
+	BUILD_BUG_ON(ARRAY_SIZE(pstore_type_names) != PSTORE_TYPE_MAX);
+
+	if (WARN_ON_ONCE(type >= PSTORE_TYPE_MAX))
+		return "unknown";
+
+	return pstore_type_names[type];
+}
+EXPORT_SYMBOL_GPL(pstore_type_to_name);
+
+enum pstore_type_id pstore_name_to_type(const char *name)
+{
+	int i;
+
+	for (i = 0; i < PSTORE_TYPE_MAX; i++) {
+		if (!strcmp(pstore_type_names[i], name))
+			return i;
+	}
+
+	return PSTORE_TYPE_MAX;
+}
+EXPORT_SYMBOL_GPL(pstore_name_to_type);
+
 static const char *get_reason_str(enum kmsg_dump_reason reason)
 {
 	switch (reason) {

commit 0eed84ffb094bbddfb4b9378ef0a2eccf4dda99c
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Nov 1 14:03:07 2018 -0700

    pstore: Improve and update some comments and status output
    
    This improves and updates some comments:
     - dump handler comment out of sync from calling convention
     - fix kern-doc typo
    
    and improves status output:
     - reminder that only kernel crash dumps are compressed
     - do not be silent about ECC infrastructure failures
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index a75756c48e10..32340e7dd6a5 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -304,7 +304,7 @@ static void allocate_buf_for_compression(void)
 	big_oops_buf_sz = size;
 	big_oops_buf = buf;
 
-	pr_info("Using compression: %s\n", zbackend->name);
+	pr_info("Using crash dump compression: %s\n", zbackend->name);
 }
 
 static void free_buf_for_compression(void)
@@ -354,9 +354,8 @@ void pstore_record_init(struct pstore_record *record,
 }
 
 /*
- * callback from kmsg_dump. (s2,l2) has the most recently
- * written bytes, older bytes are in (s1,l1). Save as much
- * as we can from the end of the buffer.
+ * callback from kmsg_dump. Save as much as we can (up to kmsg_bytes) from the
+ * end of the buffer.
  */
 static void pstore_dump(struct kmsg_dumper *dumper,
 			enum kmsg_dump_reason reason)

commit b77fa617a2ff4d6beccad3d3d4b3a1f2d10368aa
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Nov 1 14:08:07 2018 -0700

    pstore: Remove needless lock during console writes
    
    Since the console writer does not use the preallocated crash dump buffer
    any more, there is no reason to perform locking around it.
    
    Fixes: 70ad35db3321 ("pstore: Convert console write to use ->write_buf")
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Joel Fernandes (Google) <joel@joelfernandes.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 8b6028948cf3..a75756c48e10 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -462,31 +462,14 @@ static void pstore_unregister_kmsg(void)
 #ifdef CONFIG_PSTORE_CONSOLE
 static void pstore_console_write(struct console *con, const char *s, unsigned c)
 {
-	const char *e = s + c;
+	struct pstore_record record;
 
-	while (s < e) {
-		struct pstore_record record;
-		unsigned long flags;
-
-		pstore_record_init(&record, psinfo);
-		record.type = PSTORE_TYPE_CONSOLE;
-
-		if (c > psinfo->bufsize)
-			c = psinfo->bufsize;
+	pstore_record_init(&record, psinfo);
+	record.type = PSTORE_TYPE_CONSOLE;
 
-		if (oops_in_progress) {
-			if (!spin_trylock_irqsave(&psinfo->buf_lock, flags))
-				break;
-		} else {
-			spin_lock_irqsave(&psinfo->buf_lock, flags);
-		}
-		record.buf = (char *)s;
-		record.size = c;
-		psinfo->write(&record);
-		spin_unlock_irqrestore(&psinfo->buf_lock, flags);
-		s += c;
-		c = e - s;
-	}
+	record.buf = (char *)s;
+	record.size = c;
+	psinfo->write(&record);
 }
 
 static struct console pstore_console = {

commit bdabc8e71c8582cd61314f004b9a0283269585bb
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Oct 26 01:17:07 2018 -0700

    pstore: Do not use crash buffer for decompression
    
    The pre-allocated compression buffer used for crash dumping was also
    being used for decompression. This isn't technically safe, since it's
    possible the kernel may attempt a crashdump while pstore is populating the
    pstore filesystem (and performing decompression). Instead, just allocate
    a separate buffer for decompression. Correctness is preferred over
    performance here.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index b821054ca3ed..8b6028948cf3 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -258,20 +258,6 @@ static int pstore_compress(const void *in, void *out,
 	return outlen;
 }
 
-static int pstore_decompress(void *in, void *out,
-			     unsigned int inlen, unsigned int outlen)
-{
-	int ret;
-
-	ret = crypto_comp_decompress(tfm, in, inlen, out, &outlen);
-	if (ret) {
-		pr_err("crypto_comp_decompress failed, ret = %d!\n", ret);
-		return ret;
-	}
-
-	return outlen;
-}
-
 static void allocate_buf_for_compression(void)
 {
 	struct crypto_comp *ctx;
@@ -656,8 +642,9 @@ EXPORT_SYMBOL_GPL(pstore_unregister);
 
 static void decompress_record(struct pstore_record *record)
 {
+	int ret;
 	int unzipped_len;
-	char *decompressed;
+	char *unzipped, *workspace;
 
 	if (!record->compressed)
 		return;
@@ -668,35 +655,42 @@ static void decompress_record(struct pstore_record *record)
 		return;
 	}
 
-	/* No compression method has created the common buffer. */
+	/* Missing compression buffer means compression was not initialized. */
 	if (!big_oops_buf) {
-		pr_warn("no decompression buffer allocated\n");
+		pr_warn("no decompression method initialized!\n");
 		return;
 	}
 
-	unzipped_len = pstore_decompress(record->buf, big_oops_buf,
-					 record->size, big_oops_buf_sz);
-	if (unzipped_len <= 0) {
-		pr_err("decompression failed: %d\n", unzipped_len);
+	/* Allocate enough space to hold max decompression and ECC. */
+	unzipped_len = big_oops_buf_sz;
+	workspace = kmalloc(unzipped_len + record->ecc_notice_size,
+			    GFP_KERNEL);
+	if (!workspace)
 		return;
-	}
 
-	/* Build new buffer for decompressed contents. */
-	decompressed = kmalloc(unzipped_len + record->ecc_notice_size,
-			       GFP_KERNEL);
-	if (!decompressed) {
-		pr_err("decompression ran out of memory\n");
+	/* After decompression "unzipped_len" is almost certainly smaller. */
+	ret = crypto_comp_decompress(tfm, record->buf, record->size,
+					  workspace, &unzipped_len);
+	if (ret) {
+		pr_err("crypto_comp_decompress failed, ret = %d!\n", ret);
+		kfree(workspace);
 		return;
 	}
-	memcpy(decompressed, big_oops_buf, unzipped_len);
 
 	/* Append ECC notice to decompressed buffer. */
-	memcpy(decompressed + unzipped_len, record->buf + record->size,
+	memcpy(workspace + unzipped_len, record->buf + record->size,
 	       record->ecc_notice_size);
 
-	/* Swap out compresed contents with decompressed contents. */
+	/* Copy decompressed contents into an minimum-sized allocation. */
+	unzipped = kmemdup(workspace, unzipped_len + record->ecc_notice_size,
+			   GFP_KERNEL);
+	kfree(workspace);
+	if (!unzipped)
+		return;
+
+	/* Swap out compressed contents with decompressed contents. */
 	kfree(record->buf);
-	record->buf = decompressed;
+	record->buf = unzipped;
 	record->size = unzipped_len;
 	record->compressed = false;
 }

commit 95047b0519c17a28e09df5f38750f5354e3db4c4
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 17 14:00:12 2018 -0700

    pstore: Refactor compression initialization
    
    This refactors compression initialization slightly to better handle
    getting potentially called twice (via early pstore_register() calls
    and later pstore_init()) and improves the comments and reporting to be
    more verbose.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Tested-by: Guenter Roeck <groeck@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 578f178a695f..b821054ca3ed 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -274,36 +274,56 @@ static int pstore_decompress(void *in, void *out,
 
 static void allocate_buf_for_compression(void)
 {
+	struct crypto_comp *ctx;
+	int size;
+	char *buf;
+
+	/* Skip if not built-in or compression backend not selected yet. */
 	if (!IS_ENABLED(CONFIG_PSTORE_COMPRESS) || !zbackend)
 		return;
 
+	/* Skip if no pstore backend yet or compression init already done. */
+	if (!psinfo || tfm)
+		return;
+
 	if (!crypto_has_comp(zbackend->name, 0, 0)) {
-		pr_err("No %s compression\n", zbackend->name);
+		pr_err("Unknown compression: %s\n", zbackend->name);
 		return;
 	}
 
-	big_oops_buf_sz = zbackend->zbufsize(psinfo->bufsize);
-	if (big_oops_buf_sz <= 0)
+	size = zbackend->zbufsize(psinfo->bufsize);
+	if (size <= 0) {
+		pr_err("Invalid compression size for %s: %d\n",
+		       zbackend->name, size);
 		return;
+	}
 
-	big_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);
-	if (!big_oops_buf) {
-		pr_err("allocate compression buffer error!\n");
+	buf = kmalloc(size, GFP_KERNEL);
+	if (!buf) {
+		pr_err("Failed %d byte compression buffer allocation for: %s\n",
+		       size, zbackend->name);
 		return;
 	}
 
-	tfm = crypto_alloc_comp(zbackend->name, 0, 0);
-	if (IS_ERR_OR_NULL(tfm)) {
-		kfree(big_oops_buf);
-		big_oops_buf = NULL;
-		pr_err("crypto_alloc_comp() failed!\n");
+	ctx = crypto_alloc_comp(zbackend->name, 0, 0);
+	if (IS_ERR_OR_NULL(ctx)) {
+		kfree(buf);
+		pr_err("crypto_alloc_comp('%s') failed: %ld\n", zbackend->name,
+		       PTR_ERR(ctx));
 		return;
 	}
+
+	/* A non-NULL big_oops_buf indicates compression is available. */
+	tfm = ctx;
+	big_oops_buf_sz = size;
+	big_oops_buf = buf;
+
+	pr_info("Using compression: %s\n", zbackend->name);
 }
 
 static void free_buf_for_compression(void)
 {
-	if (IS_ENABLED(CONFIG_PSTORE_COMPRESS) && !IS_ERR_OR_NULL(tfm))
+	if (IS_ENABLED(CONFIG_PSTORE_COMPRESS) && tfm)
 		crypto_free_comp(tfm);
 	kfree(big_oops_buf);
 	big_oops_buf = NULL;
@@ -774,7 +794,6 @@ void __init pstore_choose_compression(void)
 	for (step = zbackends; step->name; step++) {
 		if (!strcmp(compress, step->name)) {
 			zbackend = step;
-			pr_info("using %s compression\n", zbackend->name);
 			return;
 		}
 	}
@@ -791,8 +810,7 @@ static int __init pstore_init(void)
 	 * initialize compression because crypto was not ready. If so,
 	 * initialize compression now.
 	 */
-	if (psinfo && !tfm)
-		allocate_buf_for_compression();
+	allocate_buf_for_compression();
 
 	ret = pstore_init_fs();
 	if (ret)

commit 416031653eb55f844e3547fb8f8576399a800da0
Author: Joel Fernandes (Google) <joel@joelfernandes.org>
Date:   Wed Oct 17 03:13:55 2018 -0700

    pstore: Allocate compression during late_initcall()
    
    ramoops's call of pstore_register() was recently moved to run during
    late_initcall() because the crypto backend may not have been ready during
    postcore_initcall(). This meant early-boot crash dumps were not getting
    caught by pstore any more.
    
    Instead, lets allow calls to pstore_register() earlier, and once crypto
    is ready we can initialize the compression.
    
    Reported-by: Sai Prakash Ranjan <saiprakash.ranjan@codeaurora.org>
    Signed-off-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    Tested-by: Sai Prakash Ranjan <saiprakash.ranjan@codeaurora.org>
    Fixes: cb3bee0369bc ("pstore: Use crypto compress API")
    [kees: trivial rebase]
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Tested-by: Guenter Roeck <groeck@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index d61e26812af6..578f178a695f 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -786,13 +786,21 @@ static int __init pstore_init(void)
 
 	pstore_choose_compression();
 
+	/*
+	 * Check if any pstore backends registered earlier but did not
+	 * initialize compression because crypto was not ready. If so,
+	 * initialize compression now.
+	 */
+	if (psinfo && !tfm)
+		allocate_buf_for_compression();
+
 	ret = pstore_init_fs();
 	if (ret)
 		return ret;
 
 	return 0;
 }
-module_init(pstore_init)
+late_initcall(pstore_init);
 
 static void __exit pstore_exit(void)
 {

commit cb095afd44768bf495894b9ad063bd078e4bb201
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Oct 18 11:17:42 2018 -0700

    pstore: Centralize init/exit routines
    
    In preparation for having additional actions during init/exit, this moves
    the init/exit into platform.c, centralizing the logic to make call outs
    to the fs init/exit.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Tested-by: Guenter Roeck <groeck@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 15e99d5a681d..d61e26812af6 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -780,8 +780,31 @@ void __init pstore_choose_compression(void)
 	}
 }
 
+static int __init pstore_init(void)
+{
+	int ret;
+
+	pstore_choose_compression();
+
+	ret = pstore_init_fs();
+	if (ret)
+		return ret;
+
+	return 0;
+}
+module_init(pstore_init)
+
+static void __exit pstore_exit(void)
+{
+	pstore_exit_fs();
+}
+module_exit(pstore_exit)
+
 module_param(compress, charp, 0444);
 MODULE_PARM_DESC(compress, "Pstore compression to use");
 
 module_param(backend, charp, 0444);
 MODULE_PARM_DESC(backend, "Pstore backend to use");
+
+MODULE_AUTHOR("Tony Luck <tony.luck@intel.com>");
+MODULE_LICENSE("GPL");

commit 1021bcf44d0e876b10f8739594ad7e6e9c746026
Author: Geliang Tang <geliangtang@gmail.com>
Date:   Wed Aug 1 19:23:37 2018 +0800

    pstore: add zstd compression support
    
    This patch added the 6th compression algorithm support for pstore: zstd.
    
    Signed-off-by: Geliang Tang <geliangtang@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index c238ab8ba31d..15e99d5a681d 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -34,6 +34,9 @@
 #if IS_ENABLED(CONFIG_PSTORE_LZ4_COMPRESS) || IS_ENABLED(CONFIG_PSTORE_LZ4HC_COMPRESS)
 #include <linux/lz4.h>
 #endif
+#if IS_ENABLED(CONFIG_PSTORE_ZSTD_COMPRESS)
+#include <linux/zstd.h>
+#endif
 #include <linux/crypto.h>
 #include <linux/string.h>
 #include <linux/timer.h>
@@ -192,6 +195,13 @@ static int zbufsize_842(size_t size)
 }
 #endif
 
+#if IS_ENABLED(CONFIG_PSTORE_ZSTD_COMPRESS)
+static int zbufsize_zstd(size_t size)
+{
+	return ZSTD_compressBound(size);
+}
+#endif
+
 static const struct pstore_zbackend *zbackend __ro_after_init;
 
 static const struct pstore_zbackend zbackends[] = {
@@ -224,6 +234,12 @@ static const struct pstore_zbackend zbackends[] = {
 		.zbufsize	= zbufsize_842,
 		.name		= "842",
 	},
+#endif
+#if IS_ENABLED(CONFIG_PSTORE_ZSTD_COMPRESS)
+	{
+		.zbufsize	= zbufsize_zstd,
+		.name		= "zstd",
+	},
 #endif
 	{ }
 };

commit 7aaa822ed060719bd4ea012609883b6bc6950508
Author: Kees Cook <keescook@chromium.org>
Date:   Mon May 14 15:50:52 2018 -0700

    pstore: Convert internal records to timespec64
    
    This prepares pstore for converting the VFS layer to timespec64.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index dc720573fd53..c238ab8ba31d 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -328,7 +328,7 @@ void pstore_record_init(struct pstore_record *record,
 	record->psi = psinfo;
 
 	/* Report zeroed timestamp if called before timekeeping has resumed. */
-	record->time = ns_to_timespec(ktime_get_real_fast_ns());
+	record->time = ns_to_timespec64(ktime_get_real_fast_ns());
 }
 
 /*

commit e698aaf37f9fac419ac6c1867137cce83c90c80b
Author: Tobias Regnery <tobias.regnery@gmail.com>
Date:   Fri Apr 6 09:25:17 2018 +0200

    pstore: fix crypto dependencies without compression
    
    Commit 58eb5b670747 ("pstore: fix crypto dependencies") fixed up the crypto
    dependencies but missed the case when no compression is selected.
    
    With CONFIG_PSTORE=y, CONFIG_PSTORE_COMPRESS=n  and CONFIG_CRYPTO=m we see
    the following link error:
    
    fs/pstore/platform.o: In function `pstore_register':
    (.text+0x1b1): undefined reference to `crypto_has_alg'
    (.text+0x205): undefined reference to `crypto_alloc_base'
    fs/pstore/platform.o: In function `pstore_unregister':
    (.text+0x3b0): undefined reference to `crypto_destroy_tfm'
    
    Fix this by checking at compile-time if CONFIG_PSTORE_COMPRESS is enabled.
    
    Fixes: 58eb5b670747 ("pstore: fix crypto dependencies")
    Signed-off-by: Tobias Regnery <tobias.regnery@gmail.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 1143ef351c58..dc720573fd53 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -258,7 +258,7 @@ static int pstore_decompress(void *in, void *out,
 
 static void allocate_buf_for_compression(void)
 {
-	if (!zbackend)
+	if (!IS_ENABLED(CONFIG_PSTORE_COMPRESS) || !zbackend)
 		return;
 
 	if (!crypto_has_comp(zbackend->name, 0, 0)) {
@@ -287,7 +287,7 @@ static void allocate_buf_for_compression(void)
 
 static void free_buf_for_compression(void)
 {
-	if (!IS_ERR_OR_NULL(tfm))
+	if (IS_ENABLED(CONFIG_PSTORE_COMPRESS) && !IS_ERR_OR_NULL(tfm))
 		crypto_free_comp(tfm);
 	kfree(big_oops_buf);
 	big_oops_buf = NULL;

commit 58eb5b6707477ff458db3ee522aac317da719e2a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Mar 15 16:34:08 2018 +0100

    pstore: fix crypto dependencies
    
    The new crypto API use causes some problems with Kconfig dependencies,
    including this link error:
    
    fs/pstore/platform.o: In function `pstore_register':
    platform.c:(.text+0x248): undefined reference to `crypto_has_alg'
    platform.c:(.text+0x2a0): undefined reference to `crypto_alloc_base'
    fs/pstore/platform.o: In function `pstore_unregister':
    platform.c:(.text+0x498): undefined reference to `crypto_destroy_tfm'
    crypto/lz4hc.o: In function `lz4hc_sdecompress':
    lz4hc.c:(.text+0x1a): undefined reference to `LZ4_decompress_safe'
    crypto/lz4hc.o: In function `lz4hc_decompress_crypto':
    lz4hc.c:(.text+0x5a): undefined reference to `LZ4_decompress_safe'
    crypto/lz4hc.o: In function `lz4hc_scompress':
    lz4hc.c:(.text+0xaa): undefined reference to `LZ4_compress_HC'
    crypto/lz4hc.o: In function `lz4hc_mod_init':
    lz4hc.c:(.init.text+0xf): undefined reference to `crypto_register_alg'
    lz4hc.c:(.init.text+0x1f): undefined reference to `crypto_register_scomp'
    lz4hc.c:(.init.text+0x2f): undefined reference to `crypto_unregister_alg'
    
    The problem is that with CONFIG_CRYPTO=m, we must not 'select CRYPTO_LZ4'
    from a bool symbol, or call crypto API functions from a built-in
    module.
    
    This turns the sub-options into 'tristate' ones so the dependencies
    are honored, and makes the pstore itself select the crypto core
    if necessary.
    
    Fixes: cb3bee0369bc ("pstore: Use crypto compress API")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 42e111b3bd0c..1143ef351c58 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -28,10 +28,10 @@
 #include <linux/console.h>
 #include <linux/module.h>
 #include <linux/pstore.h>
-#ifdef CONFIG_PSTORE_LZO_COMPRESS
+#if IS_ENABLED(CONFIG_PSTORE_LZO_COMPRESS)
 #include <linux/lzo.h>
 #endif
-#if defined(CONFIG_PSTORE_LZ4_COMPRESS) || defined(CONFIG_PSTORE_LZ4HC_COMPRESS)
+#if IS_ENABLED(CONFIG_PSTORE_LZ4_COMPRESS) || IS_ENABLED(CONFIG_PSTORE_LZ4HC_COMPRESS)
 #include <linux/lz4.h>
 #endif
 #include <linux/crypto.h>
@@ -142,7 +142,7 @@ bool pstore_cannot_block_path(enum kmsg_dump_reason reason)
 }
 EXPORT_SYMBOL_GPL(pstore_cannot_block_path);
 
-#ifdef CONFIG_PSTORE_DEFLATE_COMPRESS
+#if IS_ENABLED(CONFIG_PSTORE_DEFLATE_COMPRESS)
 static int zbufsize_deflate(size_t size)
 {
 	size_t cmpr;
@@ -171,21 +171,21 @@ static int zbufsize_deflate(size_t size)
 }
 #endif
 
-#ifdef CONFIG_PSTORE_LZO_COMPRESS
+#if IS_ENABLED(CONFIG_PSTORE_LZO_COMPRESS)
 static int zbufsize_lzo(size_t size)
 {
 	return lzo1x_worst_compress(size);
 }
 #endif
 
-#if defined(CONFIG_PSTORE_LZ4_COMPRESS) || defined(CONFIG_PSTORE_LZ4HC_COMPRESS)
+#if IS_ENABLED(CONFIG_PSTORE_LZ4_COMPRESS) || IS_ENABLED(CONFIG_PSTORE_LZ4HC_COMPRESS)
 static int zbufsize_lz4(size_t size)
 {
 	return LZ4_compressBound(size);
 }
 #endif
 
-#ifdef CONFIG_PSTORE_842_COMPRESS
+#if IS_ENABLED(CONFIG_PSTORE_842_COMPRESS)
 static int zbufsize_842(size_t size)
 {
 	return size;
@@ -195,31 +195,31 @@ static int zbufsize_842(size_t size)
 static const struct pstore_zbackend *zbackend __ro_after_init;
 
 static const struct pstore_zbackend zbackends[] = {
-#ifdef CONFIG_PSTORE_DEFLATE_COMPRESS
+#if IS_ENABLED(CONFIG_PSTORE_DEFLATE_COMPRESS)
 	{
 		.zbufsize	= zbufsize_deflate,
 		.name		= "deflate",
 	},
 #endif
-#ifdef CONFIG_PSTORE_LZO_COMPRESS
+#if IS_ENABLED(CONFIG_PSTORE_LZO_COMPRESS)
 	{
 		.zbufsize	= zbufsize_lzo,
 		.name		= "lzo",
 	},
 #endif
-#ifdef CONFIG_PSTORE_LZ4_COMPRESS
+#if IS_ENABLED(CONFIG_PSTORE_LZ4_COMPRESS)
 	{
 		.zbufsize	= zbufsize_lz4,
 		.name		= "lz4",
 	},
 #endif
-#ifdef CONFIG_PSTORE_LZ4HC_COMPRESS
+#if IS_ENABLED(CONFIG_PSTORE_LZ4HC_COMPRESS)
 	{
 		.zbufsize	= zbufsize_lz4,
 		.name		= "lz4hc",
 	},
 #endif
-#ifdef CONFIG_PSTORE_842_COMPRESS
+#if IS_ENABLED(CONFIG_PSTORE_842_COMPRESS)
 	{
 		.zbufsize	= zbufsize_842,
 		.name		= "842",

commit cb3bee0369bc9316e47f4ad95a3c33f4e0d50a06
Author: Geliang Tang <geliangtang@gmail.com>
Date:   Fri Mar 9 18:51:07 2018 +0800

    pstore: Use crypto compress API
    
    In the pstore compression part, we use zlib/lzo/lz4/lz4hc/842
    compression algorithm API to implement pstore compression backends. But
    there are many repeat codes in these implementations. This patch uses
    crypto compress API to simplify these codes.
    
    1) rewrite allocate_buf_for_compression, free_buf_for_compression,
    pstore_compress, pstore_decompress functions using crypto compress API.
    2) drop compress, decompress, allocate, free functions in pstore_zbackend,
    and add zbufsize function to get each different compress buffer size.
    3) use late_initcall to call ramoops_init later, to make sure the crypto
    subsystem has already initialized.
    4) use 'unsigned int' type instead of 'size_t' in pstore_compress,
    pstore_decompress functions' length arguments.
    5) rename 'zlib' to 'deflate' to follow the crypto API's name convention.
    
    Signed-off-by: Geliang Tang <geliangtang@gmail.com>
    [kees: tweaked error messages on allocation failures and Kconfig help]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 06e3b280c3a5..42e111b3bd0c 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -28,18 +28,13 @@
 #include <linux/console.h>
 #include <linux/module.h>
 #include <linux/pstore.h>
-#ifdef CONFIG_PSTORE_ZLIB_COMPRESS
-#include <linux/zlib.h>
-#endif
 #ifdef CONFIG_PSTORE_LZO_COMPRESS
 #include <linux/lzo.h>
 #endif
 #if defined(CONFIG_PSTORE_LZ4_COMPRESS) || defined(CONFIG_PSTORE_LZ4HC_COMPRESS)
 #include <linux/lz4.h>
 #endif
-#ifdef CONFIG_PSTORE_842_COMPRESS
-#include <linux/sw842.h>
-#endif
+#include <linux/crypto.h>
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/slab.h>
@@ -85,25 +80,10 @@ static char *compress =
 #endif
 
 /* Compression parameters */
-#ifdef CONFIG_PSTORE_ZLIB_COMPRESS
-#define COMPR_LEVEL 6
-#define WINDOW_BITS 12
-#define MEM_LEVEL 4
-static struct z_stream_s stream;
-#endif
-#if defined(CONFIG_PSTORE_LZO_COMPRESS)   || \
-    defined(CONFIG_PSTORE_LZ4_COMPRESS)   || \
-    defined(CONFIG_PSTORE_LZ4HC_COMPRESS) || \
-    defined(CONFIG_PSTORE_842_COMPRESS)
-static unsigned char *workspace;
-#endif
+static struct crypto_comp *tfm;
 
 struct pstore_zbackend {
-	int (*compress)(const void *in, void *out, size_t inlen, size_t outlen);
-	int (*decompress)(void *in, void *out, size_t inlen, size_t outlen);
-	void (*allocate)(void);
-	void (*free)(void);
-
+	int (*zbufsize)(size_t size);
 	const char *name;
 };
 
@@ -162,77 +142,12 @@ bool pstore_cannot_block_path(enum kmsg_dump_reason reason)
 }
 EXPORT_SYMBOL_GPL(pstore_cannot_block_path);
 
-#ifdef CONFIG_PSTORE_ZLIB_COMPRESS
-/* Derived from logfs_compress() */
-static int compress_zlib(const void *in, void *out, size_t inlen, size_t outlen)
-{
-	int err, ret;
-
-	ret = -EIO;
-	err = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,
-						MEM_LEVEL, Z_DEFAULT_STRATEGY);
-	if (err != Z_OK)
-		goto error;
-
-	stream.next_in = in;
-	stream.avail_in = inlen;
-	stream.total_in = 0;
-	stream.next_out = out;
-	stream.avail_out = outlen;
-	stream.total_out = 0;
-
-	err = zlib_deflate(&stream, Z_FINISH);
-	if (err != Z_STREAM_END)
-		goto error;
-
-	err = zlib_deflateEnd(&stream);
-	if (err != Z_OK)
-		goto error;
-
-	if (stream.total_out >= stream.total_in)
-		goto error;
-
-	ret = stream.total_out;
-error:
-	return ret;
-}
-
-/* Derived from logfs_uncompress */
-static int decompress_zlib(void *in, void *out, size_t inlen, size_t outlen)
-{
-	int err, ret;
-
-	ret = -EIO;
-	err = zlib_inflateInit2(&stream, WINDOW_BITS);
-	if (err != Z_OK)
-		goto error;
-
-	stream.next_in = in;
-	stream.avail_in = inlen;
-	stream.total_in = 0;
-	stream.next_out = out;
-	stream.avail_out = outlen;
-	stream.total_out = 0;
-
-	err = zlib_inflate(&stream, Z_FINISH);
-	if (err != Z_STREAM_END)
-		goto error;
-
-	err = zlib_inflateEnd(&stream);
-	if (err != Z_OK)
-		goto error;
-
-	ret = stream.total_out;
-error:
-	return ret;
-}
-
-static void allocate_zlib(void)
+#ifdef CONFIG_PSTORE_DEFLATE_COMPRESS
+static int zbufsize_deflate(size_t size)
 {
-	size_t size;
 	size_t cmpr;
 
-	switch (psinfo->bufsize) {
+	switch (size) {
 	/* buffer range for efivars */
 	case 1000 ... 2000:
 		cmpr = 56;
@@ -252,287 +167,61 @@ static void allocate_zlib(void)
 		break;
 	}
 
-	big_oops_buf_sz = (psinfo->bufsize * 100) / cmpr;
-	big_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);
-	if (big_oops_buf) {
-		size = max(zlib_deflate_workspacesize(WINDOW_BITS, MEM_LEVEL),
-			zlib_inflate_workspacesize());
-		stream.workspace = kmalloc(size, GFP_KERNEL);
-		if (!stream.workspace) {
-			pr_err("No memory for compression workspace; skipping compression\n");
-			kfree(big_oops_buf);
-			big_oops_buf = NULL;
-		}
-	} else {
-		pr_err("No memory for uncompressed data; skipping compression\n");
-		stream.workspace = NULL;
-	}
-
-}
-
-static void free_zlib(void)
-{
-	kfree(stream.workspace);
-	stream.workspace = NULL;
-	kfree(big_oops_buf);
-	big_oops_buf = NULL;
-	big_oops_buf_sz = 0;
+	return (size * 100) / cmpr;
 }
 #endif
 
 #ifdef CONFIG_PSTORE_LZO_COMPRESS
-static int compress_lzo(const void *in, void *out, size_t inlen, size_t outlen)
+static int zbufsize_lzo(size_t size)
 {
-	int ret;
-
-	ret = lzo1x_1_compress(in, inlen, out, &outlen, workspace);
-	if (ret != LZO_E_OK) {
-		pr_err("lzo_compress error, ret = %d!\n", ret);
-		return -EIO;
-	}
-
-	return outlen;
-}
-
-static int decompress_lzo(void *in, void *out, size_t inlen, size_t outlen)
-{
-	int ret;
-
-	ret = lzo1x_decompress_safe(in, inlen, out, &outlen);
-	if (ret != LZO_E_OK) {
-		pr_err("lzo_decompress error, ret = %d!\n", ret);
-		return -EIO;
-	}
-
-	return outlen;
-}
-
-static void allocate_lzo(void)
-{
-	big_oops_buf_sz = lzo1x_worst_compress(psinfo->bufsize);
-	big_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);
-	if (big_oops_buf) {
-		workspace = kmalloc(LZO1X_MEM_COMPRESS, GFP_KERNEL);
-		if (!workspace) {
-			pr_err("No memory for compression workspace; skipping compression\n");
-			kfree(big_oops_buf);
-			big_oops_buf = NULL;
-		}
-	} else {
-		pr_err("No memory for uncompressed data; skipping compression\n");
-		workspace = NULL;
-	}
-}
-
-static void free_lzo(void)
-{
-	kfree(workspace);
-	kfree(big_oops_buf);
-	big_oops_buf = NULL;
-	big_oops_buf_sz = 0;
+	return lzo1x_worst_compress(size);
 }
 #endif
 
 #if defined(CONFIG_PSTORE_LZ4_COMPRESS) || defined(CONFIG_PSTORE_LZ4HC_COMPRESS)
-static int decompress_lz4(void *in, void *out, size_t inlen, size_t outlen)
-{
-	int ret;
-
-	ret = LZ4_decompress_safe(in, out, inlen, outlen);
-	if (ret < 0) {
-		/*
-		 * LZ4_decompress_safe will return an error code
-		 * (< 0) if decompression failed
-		 */
-		pr_err("LZ4_decompress_safe error, ret = %d!\n", ret);
-		return -EIO;
-	}
-
-	return ret;
-}
-
-static void free_lz4(void)
-{
-	kfree(workspace);
-	kfree(big_oops_buf);
-	big_oops_buf = NULL;
-	big_oops_buf_sz = 0;
-}
-#endif
-
-#ifdef CONFIG_PSTORE_LZ4_COMPRESS
-static int compress_lz4(const void *in, void *out, size_t inlen, size_t outlen)
+static int zbufsize_lz4(size_t size)
 {
-	int ret;
-
-	ret = LZ4_compress_default(in, out, inlen, outlen, workspace);
-	if (!ret) {
-		pr_err("LZ4_compress_default error; compression failed!\n");
-		return -EIO;
-	}
-
-	return ret;
-}
-
-static void allocate_lz4(void)
-{
-	big_oops_buf_sz = LZ4_compressBound(psinfo->bufsize);
-	big_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);
-	if (big_oops_buf) {
-		workspace = kmalloc(LZ4_MEM_COMPRESS, GFP_KERNEL);
-		if (!workspace) {
-			pr_err("No memory for compression workspace; skipping compression\n");
-			kfree(big_oops_buf);
-			big_oops_buf = NULL;
-		}
-	} else {
-		pr_err("No memory for uncompressed data; skipping compression\n");
-		workspace = NULL;
-	}
-}
-#endif
-
-#ifdef CONFIG_PSTORE_LZ4HC_COMPRESS
-static int compress_lz4hc(const void *in, void *out,
-			  size_t inlen, size_t outlen)
-{
-	int ret;
-
-	ret = LZ4_compress_HC(in, out, inlen, outlen,
-			      LZ4HC_DEFAULT_CLEVEL, workspace);
-	if (!ret) {
-		pr_err("LZ4_compress_HC error; compression failed!\n");
-		return -EIO;
-	}
-
-	return ret;
-}
-
-static void allocate_lz4hc(void)
-{
-	big_oops_buf_sz = LZ4_compressBound(psinfo->bufsize);
-	big_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);
-	if (big_oops_buf) {
-		workspace = kmalloc(LZ4HC_MEM_COMPRESS, GFP_KERNEL);
-		if (!workspace) {
-			pr_err("No memory for compression workspace; skipping compression\n");
-			kfree(big_oops_buf);
-			big_oops_buf = NULL;
-		}
-	} else {
-		pr_err("No memory for uncompressed data; skipping compression\n");
-		workspace = NULL;
-	}
+	return LZ4_compressBound(size);
 }
 #endif
 
 #ifdef CONFIG_PSTORE_842_COMPRESS
-static int compress_842(const void *in, void *out, size_t inlen, size_t outlen)
-{
-	int ret;
-	unsigned int size;
-
-	if (outlen > UINT_MAX)
-		return -EIO;
-	size = outlen;
-
-	ret = sw842_compress(in, inlen, out, &size, workspace);
-	if (ret) {
-		pr_err("sw842_compress error; compression failed!\n");
-		return ret;
-	}
-
-	return size;
-}
-
-static int decompress_842(void *in, void *out, size_t inlen, size_t outlen)
+static int zbufsize_842(size_t size)
 {
-	int ret;
-	unsigned int size;
-
-	if (outlen > UINT_MAX)
-		return -EIO;
-	size = outlen;
-
-	ret = sw842_decompress(in, inlen, out, &size);
-	if (ret) {
-		pr_err("sw842_decompress error, ret = %d!\n", ret);
-		return ret;
-	}
-
 	return size;
 }
-
-static void allocate_842(void)
-{
-	big_oops_buf_sz = psinfo->bufsize;
-	big_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);
-	if (big_oops_buf) {
-		workspace = kmalloc(SW842_MEM_COMPRESS, GFP_KERNEL);
-		if (!workspace) {
-			kfree(big_oops_buf);
-			big_oops_buf = NULL;
-		}
-	} else {
-		pr_err("No memory for uncompressed data; skipping compression\n");
-		workspace = NULL;
-	}
-}
-
-static void free_842(void)
-{
-	kfree(workspace);
-	kfree(big_oops_buf);
-	big_oops_buf = NULL;
-	big_oops_buf_sz = 0;
-}
 #endif
 
 static const struct pstore_zbackend *zbackend __ro_after_init;
 
 static const struct pstore_zbackend zbackends[] = {
-#ifdef CONFIG_PSTORE_ZLIB_COMPRESS
+#ifdef CONFIG_PSTORE_DEFLATE_COMPRESS
 	{
-		.compress	= compress_zlib,
-		.decompress	= decompress_zlib,
-		.allocate	= allocate_zlib,
-		.free		= free_zlib,
-		.name		= "zlib",
+		.zbufsize	= zbufsize_deflate,
+		.name		= "deflate",
 	},
 #endif
 #ifdef CONFIG_PSTORE_LZO_COMPRESS
 	{
-		.compress	= compress_lzo,
-		.decompress	= decompress_lzo,
-		.allocate	= allocate_lzo,
-		.free		= free_lzo,
+		.zbufsize	= zbufsize_lzo,
 		.name		= "lzo",
 	},
 #endif
 #ifdef CONFIG_PSTORE_LZ4_COMPRESS
 	{
-		.compress	= compress_lz4,
-		.decompress	= decompress_lz4,
-		.allocate	= allocate_lz4,
-		.free		= free_lz4,
+		.zbufsize	= zbufsize_lz4,
 		.name		= "lz4",
 	},
 #endif
 #ifdef CONFIG_PSTORE_LZ4HC_COMPRESS
 	{
-		.compress	= compress_lz4hc,
-		.decompress	= decompress_lz4,
-		.allocate	= allocate_lz4hc,
-		.free		= free_lz4,
+		.zbufsize	= zbufsize_lz4,
 		.name		= "lz4hc",
 	},
 #endif
 #ifdef CONFIG_PSTORE_842_COMPRESS
 	{
-		.compress	= compress_842,
-		.decompress	= decompress_842,
-		.allocate	= allocate_842,
-		.free		= free_842,
+		.zbufsize	= zbufsize_842,
 		.name		= "842",
 	},
 #endif
@@ -540,37 +229,69 @@ static const struct pstore_zbackend zbackends[] = {
 };
 
 static int pstore_compress(const void *in, void *out,
-			   size_t inlen, size_t outlen)
+			   unsigned int inlen, unsigned int outlen)
 {
-	if (zbackend)
-		return zbackend->compress(in, out, inlen, outlen);
-	else
-		return -EIO;
+	int ret;
+
+	ret = crypto_comp_compress(tfm, in, inlen, out, &outlen);
+	if (ret) {
+		pr_err("crypto_comp_compress failed, ret = %d!\n", ret);
+		return ret;
+	}
+
+	return outlen;
 }
 
-static int pstore_decompress(void *in, void *out, size_t inlen, size_t outlen)
+static int pstore_decompress(void *in, void *out,
+			     unsigned int inlen, unsigned int outlen)
 {
-	if (zbackend)
-		return zbackend->decompress(in, out, inlen, outlen);
-	else
-		return -EIO;
+	int ret;
+
+	ret = crypto_comp_decompress(tfm, in, inlen, out, &outlen);
+	if (ret) {
+		pr_err("crypto_comp_decompress failed, ret = %d!\n", ret);
+		return ret;
+	}
+
+	return outlen;
 }
 
 static void allocate_buf_for_compression(void)
 {
-	if (zbackend) {
-		zbackend->allocate();
-	} else {
+	if (!zbackend)
+		return;
+
+	if (!crypto_has_comp(zbackend->name, 0, 0)) {
+		pr_err("No %s compression\n", zbackend->name);
+		return;
+	}
+
+	big_oops_buf_sz = zbackend->zbufsize(psinfo->bufsize);
+	if (big_oops_buf_sz <= 0)
+		return;
+
+	big_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);
+	if (!big_oops_buf) {
 		pr_err("allocate compression buffer error!\n");
+		return;
+	}
+
+	tfm = crypto_alloc_comp(zbackend->name, 0, 0);
+	if (IS_ERR_OR_NULL(tfm)) {
+		kfree(big_oops_buf);
+		big_oops_buf = NULL;
+		pr_err("crypto_alloc_comp() failed!\n");
+		return;
 	}
 }
 
 static void free_buf_for_compression(void)
 {
-	if (zbackend)
-		zbackend->free();
-	else
-		pr_err("free compression buffer error!\n");
+	if (!IS_ERR_OR_NULL(tfm))
+		crypto_free_comp(tfm);
+	kfree(big_oops_buf);
+	big_oops_buf = NULL;
+	big_oops_buf_sz = 0;
 }
 
 /*

commit fe1d475888eecf1319458ee916e642e3e5e41c28
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Mar 6 15:57:38 2018 -0800

    pstore: Select compression at runtime
    
    To allow for easier build test coverage and run-time testing, this allows
    multiple compression algorithms to be built into pstore. Still only one
    is supported to operate at a time (which can be selected at build time
    or at boot time, similar to how LSMs are selected).
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index df54dd87598a..06e3b280c3a5 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -77,6 +77,12 @@ static DEFINE_SPINLOCK(pstore_lock);
 struct pstore_info *psinfo;
 
 static char *backend;
+static char *compress =
+#ifdef CONFIG_PSTORE_COMPRESS_DEFAULT
+		CONFIG_PSTORE_COMPRESS_DEFAULT;
+#else
+		NULL;
+#endif
 
 /* Compression parameters */
 #ifdef CONFIG_PSTORE_ZLIB_COMPRESS
@@ -84,7 +90,11 @@ static char *backend;
 #define WINDOW_BITS 12
 #define MEM_LEVEL 4
 static struct z_stream_s stream;
-#else
+#endif
+#if defined(CONFIG_PSTORE_LZO_COMPRESS)   || \
+    defined(CONFIG_PSTORE_LZ4_COMPRESS)   || \
+    defined(CONFIG_PSTORE_LZ4HC_COMPRESS) || \
+    defined(CONFIG_PSTORE_842_COMPRESS)
 static unsigned char *workspace;
 #endif
 
@@ -268,14 +278,6 @@ static void free_zlib(void)
 	big_oops_buf = NULL;
 	big_oops_buf_sz = 0;
 }
-
-static const struct pstore_zbackend backend_zlib = {
-	.compress	= compress_zlib,
-	.decompress	= decompress_zlib,
-	.allocate	= allocate_zlib,
-	.free		= free_zlib,
-	.name		= "zlib",
-};
 #endif
 
 #ifdef CONFIG_PSTORE_LZO_COMPRESS
@@ -329,14 +331,6 @@ static void free_lzo(void)
 	big_oops_buf = NULL;
 	big_oops_buf_sz = 0;
 }
-
-static const struct pstore_zbackend backend_lzo = {
-	.compress	= compress_lzo,
-	.decompress	= decompress_lzo,
-	.allocate	= allocate_lzo,
-	.free		= free_lzo,
-	.name		= "lzo",
-};
 #endif
 
 #if defined(CONFIG_PSTORE_LZ4_COMPRESS) || defined(CONFIG_PSTORE_LZ4HC_COMPRESS)
@@ -396,14 +390,6 @@ static void allocate_lz4(void)
 		workspace = NULL;
 	}
 }
-
-static const struct pstore_zbackend backend_lz4 = {
-	.compress	= compress_lz4,
-	.decompress	= decompress_lz4,
-	.allocate	= allocate_lz4,
-	.free		= free_lz4,
-	.name		= "lz4",
-};
 #endif
 
 #ifdef CONFIG_PSTORE_LZ4HC_COMPRESS
@@ -438,14 +424,6 @@ static void allocate_lz4hc(void)
 		workspace = NULL;
 	}
 }
-
-static const struct pstore_zbackend backend_lz4hc = {
-	.compress	= compress_lz4hc,
-	.decompress	= decompress_lz4,
-	.allocate	= allocate_lz4hc,
-	.free		= free_lz4,
-	.name		= "lz4hc",
-};
 #endif
 
 #ifdef CONFIG_PSTORE_842_COMPRESS
@@ -508,30 +486,58 @@ static void free_842(void)
 	big_oops_buf = NULL;
 	big_oops_buf_sz = 0;
 }
-
-static const struct pstore_zbackend backend_842 = {
-	.compress	= compress_842,
-	.decompress	= decompress_842,
-	.allocate	= allocate_842,
-	.free		= free_842,
-	.name		= "842",
-};
 #endif
 
-static const struct pstore_zbackend *zbackend =
-#if defined(CONFIG_PSTORE_ZLIB_COMPRESS)
-	&backend_zlib;
-#elif defined(CONFIG_PSTORE_LZO_COMPRESS)
-	&backend_lzo;
-#elif defined(CONFIG_PSTORE_LZ4_COMPRESS)
-	&backend_lz4;
-#elif defined(CONFIG_PSTORE_LZ4HC_COMPRESS)
-	&backend_lz4hc;
-#elif defined(CONFIG_PSTORE_842_COMPRESS)
-	&backend_842;
-#else
-	NULL;
+static const struct pstore_zbackend *zbackend __ro_after_init;
+
+static const struct pstore_zbackend zbackends[] = {
+#ifdef CONFIG_PSTORE_ZLIB_COMPRESS
+	{
+		.compress	= compress_zlib,
+		.decompress	= decompress_zlib,
+		.allocate	= allocate_zlib,
+		.free		= free_zlib,
+		.name		= "zlib",
+	},
+#endif
+#ifdef CONFIG_PSTORE_LZO_COMPRESS
+	{
+		.compress	= compress_lzo,
+		.decompress	= decompress_lzo,
+		.allocate	= allocate_lzo,
+		.free		= free_lzo,
+		.name		= "lzo",
+	},
+#endif
+#ifdef CONFIG_PSTORE_LZ4_COMPRESS
+	{
+		.compress	= compress_lz4,
+		.decompress	= decompress_lz4,
+		.allocate	= allocate_lz4,
+		.free		= free_lz4,
+		.name		= "lz4",
+	},
+#endif
+#ifdef CONFIG_PSTORE_LZ4HC_COMPRESS
+	{
+		.compress	= compress_lz4hc,
+		.decompress	= decompress_lz4,
+		.allocate	= allocate_lz4hc,
+		.free		= free_lz4,
+		.name		= "lz4hc",
+	},
 #endif
+#ifdef CONFIG_PSTORE_842_COMPRESS
+	{
+		.compress	= compress_842,
+		.decompress	= decompress_842,
+		.allocate	= allocate_842,
+		.free		= free_842,
+		.name		= "842",
+	},
+#endif
+	{ }
+};
 
 static int pstore_compress(const void *in, void *out,
 			   size_t inlen, size_t outlen)
@@ -553,7 +559,6 @@ static int pstore_decompress(void *in, void *out, size_t inlen, size_t outlen)
 static void allocate_buf_for_compression(void)
 {
 	if (zbackend) {
-		pr_info("using %s compression\n", zbackend->name);
 		zbackend->allocate();
 	} else {
 		pr_err("allocate compression buffer error!\n");
@@ -1022,5 +1027,24 @@ static void pstore_timefunc(struct timer_list *unused)
 			  jiffies + msecs_to_jiffies(pstore_update_ms));
 }
 
+void __init pstore_choose_compression(void)
+{
+	const struct pstore_zbackend *step;
+
+	if (!compress)
+		return;
+
+	for (step = zbackends; step->name; step++) {
+		if (!strcmp(compress, step->name)) {
+			zbackend = step;
+			pr_info("using %s compression\n", zbackend->name);
+			return;
+		}
+	}
+}
+
+module_param(compress, charp, 0444);
+MODULE_PARM_DESC(compress, "Pstore compression to use");
+
 module_param(backend, charp, 0444);
 MODULE_PARM_DESC(backend, "Pstore backend to use");

commit 555974068ee533e8e0c6093ec7ca1682057aa4c1
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Mar 6 15:15:24 2018 -0800

    pstore: Avoid size casts for 842 compression
    
    Instead of casting, make sure we don't end up with giant values and just
    perform regular assignments with unsigned int instead of re-cast size_t.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 19aaefeb052f..df54dd87598a 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -452,27 +452,37 @@ static const struct pstore_zbackend backend_lz4hc = {
 static int compress_842(const void *in, void *out, size_t inlen, size_t outlen)
 {
 	int ret;
+	unsigned int size;
 
-	ret = sw842_compress(in, inlen, out, (unsigned int *)&outlen, workspace);
+	if (outlen > UINT_MAX)
+		return -EIO;
+	size = outlen;
+
+	ret = sw842_compress(in, inlen, out, &size, workspace);
 	if (ret) {
 		pr_err("sw842_compress error; compression failed!\n");
 		return ret;
 	}
 
-	return outlen;
+	return size;
 }
 
 static int decompress_842(void *in, void *out, size_t inlen, size_t outlen)
 {
 	int ret;
+	unsigned int size;
 
-	ret = sw842_decompress(in, inlen, out, (unsigned int *)&outlen);
+	if (outlen > UINT_MAX)
+		return -EIO;
+	size = outlen;
+
+	ret = sw842_decompress(in, inlen, out, &size);
 	if (ret) {
 		pr_err("sw842_decompress error, ret = %d!\n", ret);
 		return ret;
 	}
 
-	return outlen;
+	return size;
 }
 
 static void allocate_842(void)

commit 239b716199d9aff0d09444b0086e23aacd6bd445
Author: Geliang Tang <geliangtang@gmail.com>
Date:   Tue Feb 13 14:40:39 2018 +0800

    pstore: Add lz4hc and 842 compression support
    
    Currently, pstore has supported three compression algorithms: zlib,
    lzo and lz4. This patch added two more compression algorithms: lz4hc
    and 842.
    
    Signed-off-by: Geliang Tang <geliangtang@gmail.com>
    [kees: tweaked Kconfig help text slightly]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index c3129b131e4d..19aaefeb052f 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -34,9 +34,12 @@
 #ifdef CONFIG_PSTORE_LZO_COMPRESS
 #include <linux/lzo.h>
 #endif
-#ifdef CONFIG_PSTORE_LZ4_COMPRESS
+#if defined(CONFIG_PSTORE_LZ4_COMPRESS) || defined(CONFIG_PSTORE_LZ4HC_COMPRESS)
 #include <linux/lz4.h>
 #endif
+#ifdef CONFIG_PSTORE_842_COMPRESS
+#include <linux/sw842.h>
+#endif
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/slab.h>
@@ -336,6 +339,33 @@ static const struct pstore_zbackend backend_lzo = {
 };
 #endif
 
+#if defined(CONFIG_PSTORE_LZ4_COMPRESS) || defined(CONFIG_PSTORE_LZ4HC_COMPRESS)
+static int decompress_lz4(void *in, void *out, size_t inlen, size_t outlen)
+{
+	int ret;
+
+	ret = LZ4_decompress_safe(in, out, inlen, outlen);
+	if (ret < 0) {
+		/*
+		 * LZ4_decompress_safe will return an error code
+		 * (< 0) if decompression failed
+		 */
+		pr_err("LZ4_decompress_safe error, ret = %d!\n", ret);
+		return -EIO;
+	}
+
+	return ret;
+}
+
+static void free_lz4(void)
+{
+	kfree(workspace);
+	kfree(big_oops_buf);
+	big_oops_buf = NULL;
+	big_oops_buf_sz = 0;
+}
+#endif
+
 #ifdef CONFIG_PSTORE_LZ4_COMPRESS
 static int compress_lz4(const void *in, void *out, size_t inlen, size_t outlen)
 {
@@ -350,29 +380,54 @@ static int compress_lz4(const void *in, void *out, size_t inlen, size_t outlen)
 	return ret;
 }
 
-static int decompress_lz4(void *in, void *out, size_t inlen, size_t outlen)
+static void allocate_lz4(void)
+{
+	big_oops_buf_sz = LZ4_compressBound(psinfo->bufsize);
+	big_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);
+	if (big_oops_buf) {
+		workspace = kmalloc(LZ4_MEM_COMPRESS, GFP_KERNEL);
+		if (!workspace) {
+			pr_err("No memory for compression workspace; skipping compression\n");
+			kfree(big_oops_buf);
+			big_oops_buf = NULL;
+		}
+	} else {
+		pr_err("No memory for uncompressed data; skipping compression\n");
+		workspace = NULL;
+	}
+}
+
+static const struct pstore_zbackend backend_lz4 = {
+	.compress	= compress_lz4,
+	.decompress	= decompress_lz4,
+	.allocate	= allocate_lz4,
+	.free		= free_lz4,
+	.name		= "lz4",
+};
+#endif
+
+#ifdef CONFIG_PSTORE_LZ4HC_COMPRESS
+static int compress_lz4hc(const void *in, void *out,
+			  size_t inlen, size_t outlen)
 {
 	int ret;
 
-	ret = LZ4_decompress_safe(in, out, inlen, outlen);
-	if (ret < 0) {
-		/*
-		 * LZ4_decompress_safe will return an error code
-		 * (< 0) if decompression failed
-		 */
-		pr_err("LZ4_decompress_safe error, ret = %d!\n", ret);
+	ret = LZ4_compress_HC(in, out, inlen, outlen,
+			      LZ4HC_DEFAULT_CLEVEL, workspace);
+	if (!ret) {
+		pr_err("LZ4_compress_HC error; compression failed!\n");
 		return -EIO;
 	}
 
 	return ret;
 }
 
-static void allocate_lz4(void)
+static void allocate_lz4hc(void)
 {
 	big_oops_buf_sz = LZ4_compressBound(psinfo->bufsize);
 	big_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);
 	if (big_oops_buf) {
-		workspace = kmalloc(LZ4_MEM_COMPRESS, GFP_KERNEL);
+		workspace = kmalloc(LZ4HC_MEM_COMPRESS, GFP_KERNEL);
 		if (!workspace) {
 			pr_err("No memory for compression workspace; skipping compression\n");
 			kfree(big_oops_buf);
@@ -384,7 +439,59 @@ static void allocate_lz4(void)
 	}
 }
 
-static void free_lz4(void)
+static const struct pstore_zbackend backend_lz4hc = {
+	.compress	= compress_lz4hc,
+	.decompress	= decompress_lz4,
+	.allocate	= allocate_lz4hc,
+	.free		= free_lz4,
+	.name		= "lz4hc",
+};
+#endif
+
+#ifdef CONFIG_PSTORE_842_COMPRESS
+static int compress_842(const void *in, void *out, size_t inlen, size_t outlen)
+{
+	int ret;
+
+	ret = sw842_compress(in, inlen, out, (unsigned int *)&outlen, workspace);
+	if (ret) {
+		pr_err("sw842_compress error; compression failed!\n");
+		return ret;
+	}
+
+	return outlen;
+}
+
+static int decompress_842(void *in, void *out, size_t inlen, size_t outlen)
+{
+	int ret;
+
+	ret = sw842_decompress(in, inlen, out, (unsigned int *)&outlen);
+	if (ret) {
+		pr_err("sw842_decompress error, ret = %d!\n", ret);
+		return ret;
+	}
+
+	return outlen;
+}
+
+static void allocate_842(void)
+{
+	big_oops_buf_sz = psinfo->bufsize;
+	big_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);
+	if (big_oops_buf) {
+		workspace = kmalloc(SW842_MEM_COMPRESS, GFP_KERNEL);
+		if (!workspace) {
+			kfree(big_oops_buf);
+			big_oops_buf = NULL;
+		}
+	} else {
+		pr_err("No memory for uncompressed data; skipping compression\n");
+		workspace = NULL;
+	}
+}
+
+static void free_842(void)
 {
 	kfree(workspace);
 	kfree(big_oops_buf);
@@ -392,12 +499,12 @@ static void free_lz4(void)
 	big_oops_buf_sz = 0;
 }
 
-static const struct pstore_zbackend backend_lz4 = {
-	.compress	= compress_lz4,
-	.decompress	= decompress_lz4,
-	.allocate	= allocate_lz4,
-	.free		= free_lz4,
-	.name		= "lz4",
+static const struct pstore_zbackend backend_842 = {
+	.compress	= compress_842,
+	.decompress	= decompress_842,
+	.allocate	= allocate_842,
+	.free		= free_842,
+	.name		= "842",
 };
 #endif
 
@@ -408,6 +515,10 @@ static const struct pstore_zbackend *zbackend =
 	&backend_lzo;
 #elif defined(CONFIG_PSTORE_LZ4_COMPRESS)
 	&backend_lz4;
+#elif defined(CONFIG_PSTORE_LZ4HC_COMPRESS)
+	&backend_lz4hc;
+#elif defined(CONFIG_PSTORE_842_COMPRESS)
+	&backend_842;
 #else
 	NULL;
 #endif

commit a99f41a1b4412a0f27cc0b287ea34b168da750f1
Author: Yang Shi <yang.s@alibaba-inc.com>
Date:   Sat Nov 18 07:02:15 2017 +0800

    fs: pstore: remove unused hardirq.h
    
    Preempt counter APIs have been split out, currently, hardirq.h just
    includes irq_enter/exit APIs which are not used by pstore at all.
    
    So, remove the unused hardirq.h.
    
    Signed-off-by: Yang Shi <yang.s@alibaba-inc.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Anton Vorontsov <anton@enomsg.org>
    Cc: Colin Cross <ccross@android.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 691032107f8c..c3129b131e4d 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -41,7 +41,6 @@
 #include <linux/timer.h>
 #include <linux/slab.h>
 #include <linux/uaccess.h>
-#include <linux/hardirq.h>
 #include <linux/jiffies.h>
 #include <linux/workqueue.h>
 

commit 24ed960abf1d50cb7834e99a0cfc081bc0656712
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Aug 28 11:28:21 2017 -0700

    treewide: Switch DEFINE_TIMER callbacks to struct timer_list *
    
    This changes all DEFINE_TIMER() callbacks to use a struct timer_list
    pointer instead of unsigned long. Since the data argument has already been
    removed, none of these callbacks are using their argument currently, so
    this renames the argument to "unused".
    
    Done using the following semantic patch:
    
    @match_define_timer@
    declarer name DEFINE_TIMER;
    identifier _timer, _callback;
    @@
    
     DEFINE_TIMER(_timer, _callback);
    
    @change_callback depends on match_define_timer@
    identifier match_define_timer._callback;
    type _origtype;
    identifier _origarg;
    @@
    
     void
    -_callback(_origtype _origarg)
    +_callback(struct timer_list *unused)
     { ... }
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 423159abd501..691032107f8c 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -61,7 +61,7 @@ MODULE_PARM_DESC(update_ms, "milliseconds before pstore updates its content "
 
 static int pstore_new_entry;
 
-static void pstore_timefunc(unsigned long);
+static void pstore_timefunc(struct timer_list *);
 static DEFINE_TIMER(pstore_timer, pstore_timefunc);
 
 static void pstore_dowork(struct work_struct *);
@@ -890,7 +890,7 @@ static void pstore_dowork(struct work_struct *work)
 	pstore_get_records(1);
 }
 
-static void pstore_timefunc(unsigned long dummy)
+static void pstore_timefunc(struct timer_list *unused)
 {
 	if (pstore_new_entry) {
 		pstore_new_entry = 0;

commit ca5b857cb0f42986520abd9dbb0c2508067342b2
Merge: a0e136e5da98 c02b1a9b41c2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 17 12:54:01 2017 -0800

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "Assorted stuff, really no common topic here"
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      vfs: grab the lock instead of blocking in __fd_install during resizing
      vfs: stop clearing close on exec when closing a fd
      include/linux/fs.h: fix comment about struct address_space
      fs: make fiemap work from compat_ioctl
      coda: fix 'kernel memory exposure attempt' in fsync
      pstore: remove unneeded unlikely()
      vfs: remove unneeded unlikely()
      stubs for mount_bdev() and kill_block_super() in !CONFIG_BLOCK case
      make vfs_ustat() static
      do_handle_open() should be static
      elf_fdpic: fix unused variable warning
      fold destroy_super() into __put_super()
      new helper: destroy_unused_super()
      fix address space warnings in ipc/
      acct.h: get rid of detritus

commit df27067e6040b51188184876253d93da002433aa
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Nov 10 16:25:04 2017 +0100

    pstore: Use ktime_get_real_fast_ns() instead of __getnstimeofday()
    
    __getnstimeofday() is a rather odd interface, with a number of quirks:
    
    - The caller may come from NMI context, but the implementation is not NMI safe,
      one way to get there from NMI is
    
          NMI handler:
            something bad
              panic()
                kmsg_dump()
                  pstore_dump()
                     pstore_record_init()
                       __getnstimeofday()
    
    - The calling conventions are different from any other timekeeping functions,
      to deal with returning an error code during suspended timekeeping.
    
    Address the above issues by using a completely different method to get the
    time: ktime_get_real_fast_ns() is NMI safe and has a reasonable behavior
    when timekeeping is suspended: it returns the time at which it got
    suspended. As Thomas Gleixner explained, this is safe, as
    ktime_get_real_fast_ns() does not call into the clocksource driver that
    might be suspended.
    
    The result can easily be transformed into a timespec structure. Since
    ktime_get_real_fast_ns() was not exported to modules, add the export.
    
    The pstore behavior for the suspended case changes slightly, as it now
    stores the timestamp at which timekeeping was suspended instead of storing
    a zero timestamp.
    
    This change is not addressing y2038-safety, that's subject to a more
    complex follow up patch.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Anton Vorontsov <anton@enomsg.org>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Colin Cross <ccross@android.com>
    Link: https://lkml.kernel.org/r/20171110152530.1926955-1-arnd@arndb.de

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index ec7199e859d2..086e491faf04 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -482,10 +482,7 @@ void pstore_record_init(struct pstore_record *record,
 	record->psi = psinfo;
 
 	/* Report zeroed timestamp if called before timekeeping has resumed. */
-	if (__getnstimeofday(&record->time)) {
-		record->time.tv_sec = 0;
-		record->time.tv_nsec = 0;
-	}
+	record->time = ns_to_timespec(ktime_get_real_fast_ns());
 }
 
 /*

commit dfd6fa39d96f5049edb7af26578873e65dbafc9a
Author: Hirofumi Nakagawa <nklabs@gmail.com>
Date:   Tue Sep 26 03:21:27 2017 +0900

    pstore: remove unneeded unlikely()
    
    IS_ERR() macro it is already including unlikely().
    
    Signed-off-by: Hirofumi Nakagawa <nklabs@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 2b21d180157c..7256149af306 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -654,7 +654,7 @@ static int pstore_write_user_compat(struct pstore_record *record,
 		return -EINVAL;
 
 	record->buf = memdup_user(buf, record->size);
-	if (unlikely(IS_ERR(record->buf))) {
+	if (IS_ERR(record->buf)) {
 		ret = PTR_ERR(record->buf);
 		goto out;
 	}

commit 1d27e3e2252ba9d949ca82fbdb73cde102cb2067
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 4 16:27:04 2017 -0700

    timer: Remove expires and data arguments from DEFINE_TIMER
    
    Drop the arguments from the macro and adjust all callers with the
    following script:
    
      perl -pi -e 's/DEFINE_TIMER\((.*), 0, 0\);/DEFINE_TIMER($1);/g;' \
        $(git grep DEFINE_TIMER | cut -d: -f1 | sort -u | grep -v timer.h)
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org> # for m68k parts
    Acked-by: Guenter Roeck <linux@roeck-us.net> # for watchdog parts
    Acked-by: David S. Miller <davem@davemloft.net> # for networking parts
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Kalle Valo <kvalo@codeaurora.org> # for wireless parts
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-mips@linux-mips.org
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Lai Jiangshan <jiangshanlai@gmail.com>
    Cc: Sebastian Reichel <sre@kernel.org>
    Cc: Kalle Valo <kvalo@qca.qualcomm.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: linux1394-devel@lists.sourceforge.net
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: linux-s390@vger.kernel.org
    Cc: linux-wireless@vger.kernel.org
    Cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Ursula Braun <ubraun@linux.vnet.ibm.com>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Harish Patil <harish.patil@cavium.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Michael Reed <mdr@sgi.com>
    Cc: Manish Chopra <manish.chopra@cavium.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-pm@vger.kernel.org
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Julian Wiedmann <jwi@linux.vnet.ibm.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: linux-watchdog@vger.kernel.org
    Cc: linux-scsi@vger.kernel.org
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: netdev@vger.kernel.org
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lkml.kernel.org/r/1507159627-127660-11-git-send-email-keescook@chromium.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 2b21d180157c..ec7199e859d2 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -62,7 +62,7 @@ MODULE_PARM_DESC(update_ms, "milliseconds before pstore updates its content "
 static int pstore_new_entry;
 
 static void pstore_timefunc(unsigned long);
-static DEFINE_TIMER(pstore_timer, pstore_timefunc, 0, 0);
+static DEFINE_TIMER(pstore_timer, pstore_timefunc);
 
 static void pstore_dowork(struct work_struct *);
 static DECLARE_WORK(pstore_work, pstore_dowork);

commit 78dcf73421a879d22319d3889119945b85954a68
Merge: 93ff81859733 fdb254db21bb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 15 12:00:42 2017 -0700

    Merge branch 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull ->s_options removal from Al Viro:
     "Preparations for fsmount/fsopen stuff (coming next cycle). Everything
      gets moved to explicit ->show_options(), killing ->s_options off +
      some cosmetic bits around fs/namespace.c and friends. Basically, the
      stuff needed to work with fsmount series with minimum of conflicts
      with other work.
    
      It's not strictly required for this merge window, but it would reduce
      the PITA during the coming cycle, so it would be nice to have those
      bits and pieces out of the way"
    
    * 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      isofs: Fix isofs_show_options()
      VFS: Kill off s_options and helpers
      orangefs: Implement show_options
      9p: Implement show_options
      isofs: Implement show_options
      afs: Implement show_options
      affs: Implement show_options
      befs: Implement show_options
      spufs: Implement show_options
      bpf: Implement show_options
      ramfs: Implement show_options
      pstore: Implement show_options
      omfs: Implement show_options
      hugetlbfs: Implement show_options
      VFS: Don't use save/replace_mount_options if not using generic_show_options
      VFS: Provide empty name qstr
      VFS: Make get_filesystem() return the affected filesystem
      VFS: Clean up whitespace in fs/namespace.c and fs/super.c
      Provide a function to create a NUL-terminated string from unterminated data

commit 349d743895e2371bda9a02a5b465b50cc24d2825
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jul 5 16:24:34 2017 +0100

    pstore: Implement show_options
    
    Implement the show_options superblock op for pstore as part of a bid to get
    rid of s_options and generic_show_options() to make it easier to implement
    a context-based mount where the mount options can be passed individually
    over a file descriptor.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Kees Cook <keescook@chromium.org>
    cc: Anton Vorontsov <anton@enomsg.org>
    cc: Colin Cross <ccross@android.com>
    cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index d468eec9b8a6..6640df40908d 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -99,7 +99,7 @@ static char *big_oops_buf;
 static size_t big_oops_buf_sz;
 
 /* How much of the console log to snapshot */
-static unsigned long kmsg_bytes = 10240;
+unsigned long kmsg_bytes = PSTORE_DEFAULT_KMSG_BYTES;
 
 void pstore_set_kmsg_bytes(int bytes)
 {

commit 077090af337f7d833f82be3d556549512398de66
Author: Geliang Tang <geliangtang@gmail.com>
Date:   Sat Apr 29 09:45:16 2017 +0800

    pstore: use memdup_user
    
    Use memdup_user() helper instead of open-coding to simplify the code.
    
    Signed-off-by: Geliang Tang <geliangtang@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 96fbff7b87c8..1b6e0ff6bff5 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -653,19 +653,16 @@ static int pstore_write_user_compat(struct pstore_record *record,
 	if (record->buf)
 		return -EINVAL;
 
-	record->buf = kmalloc(record->size, GFP_KERNEL);
-	if (!record->buf)
-		return -ENOMEM;
-
-	if (unlikely(copy_from_user(record->buf, buf, record->size))) {
-		ret = -EFAULT;
+	record->buf = memdup_user(buf, record->size);
+	if (unlikely(IS_ERR(record->buf))) {
+		ret = PTR_ERR(record->buf);
 		goto out;
 	}
 
 	ret = record->psi->write(record);
 
-out:
 	kfree(record->buf);
+out:
 	record->buf = NULL;
 
 	return unlikely(ret < 0) ? ret : record->size;

commit c7f3c595f6ff7a1cfbf7ac782722bf5173e27775
Author: Kees Cook <keescook@chromium.org>
Date:   Fri May 19 15:29:10 2017 -0700

    pstore: Populate pstore record->time field
    
    The current time will be initially available in the record->time field
    for all pstore_read() and pstore_write() calls. Backends can either
    update the field during read(), or use the field during write() instead
    of fetching time themselves.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 7798041f3fba..96fbff7b87c8 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -480,6 +480,12 @@ void pstore_record_init(struct pstore_record *record,
 	memset(record, 0, sizeof(*record));
 
 	record->psi = psinfo;
+
+	/* Report zeroed timestamp if called before timekeeping has resumed. */
+	if (__getnstimeofday(&record->time)) {
+		record->time.tv_sec = 0;
+		record->time.tv_nsec = 0;
+	}
 }
 
 /*

commit e581ca813a40a4ee53c862d8f6303f486c4b4c34
Author: Kees Cook <keescook@chromium.org>
Date:   Fri May 19 15:10:31 2017 -0700

    pstore: Create common record initializer
    
    In preparation for setting timestamps in the pstore core, create a common
    initializer routine, instead of using static initializers.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index d8289ce00f99..7798041f3fba 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -474,6 +474,14 @@ static size_t copy_kmsg_to_buffer(int hsize, size_t len)
 	return total_len;
 }
 
+void pstore_record_init(struct pstore_record *record,
+			struct pstore_info *psinfo)
+{
+	memset(record, 0, sizeof(*record));
+
+	record->psi = psinfo;
+}
+
 /*
  * callback from kmsg_dump. (s2,l2) has the most recently
  * written bytes, older bytes are in (s1,l1). Save as much
@@ -509,15 +517,14 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		int header_size;
 		int zipped_len = -1;
 		size_t dump_size;
-		struct pstore_record record = {
-			.type = PSTORE_TYPE_DMESG,
-			.count = oopscount,
-			.reason = reason,
-			.part = part,
-			.compressed = false,
-			.buf = psinfo->buf,
-			.psi = psinfo,
-		};
+		struct pstore_record record;
+
+		pstore_record_init(&record, psinfo);
+		record.type = PSTORE_TYPE_DMESG;
+		record.count = oopscount;
+		record.reason = reason;
+		record.part = part;
+		record.buf = psinfo->buf;
 
 		if (big_oops_buf && is_locked) {
 			dst = big_oops_buf;
@@ -587,12 +594,12 @@ static void pstore_console_write(struct console *con, const char *s, unsigned c)
 	const char *e = s + c;
 
 	while (s < e) {
-		struct pstore_record record = {
-			.type = PSTORE_TYPE_CONSOLE,
-			.psi = psinfo,
-		};
+		struct pstore_record record;
 		unsigned long flags;
 
+		pstore_record_init(&record, psinfo);
+		record.type = PSTORE_TYPE_CONSOLE;
+
 		if (c > psinfo->bufsize)
 			c = psinfo->bufsize;
 
@@ -845,7 +852,7 @@ void pstore_get_backend_records(struct pstore_info *psi,
 			pr_err("out of memory creating record\n");
 			break;
 		}
-		record->psi = psi;
+		pstore_record_init(record, psi);
 
 		record->size = psi->read(record);
 

commit 656de42e83379e5348e3f4236ff1d79353edfb28
Author: Kees Cook <keescook@chromium.org>
Date:   Tue May 16 12:03:31 2017 -0700

    pstore: Avoid potential infinite loop
    
    If a backend does not correctly iterate through its records, pstore will
    get stuck loading entries. Detect this with a large record count, and
    announce if we ever hit the limit. This will let future backend reading
    bugs less annoying to debug. Additionally adjust the error about
    pstore_mkfile() failing.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 4c5cd9368460..d8289ce00f99 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -822,6 +822,7 @@ void pstore_get_backend_records(struct pstore_info *psi,
 				struct dentry *root, int quiet)
 {
 	int failed = 0;
+	unsigned int stop_loop = 65536;
 
 	if (!psi || !root)
 		return;
@@ -835,7 +836,7 @@ void pstore_get_backend_records(struct pstore_info *psi,
 	 * may reallocate record.buf. On success, pstore_mkfile() will keep
 	 * the record.buf, so free it only on failure.
 	 */
-	for (;;) {
+	for (; stop_loop; stop_loop--) {
 		struct pstore_record *record;
 		int rc;
 
@@ -870,8 +871,11 @@ void pstore_get_backend_records(struct pstore_info *psi,
 	mutex_unlock(&psi->read_mutex);
 
 	if (failed)
-		pr_warn("failed to load %d record(s) from '%s'\n",
+		pr_warn("failed to create %d record(s) from '%s'\n",
 			failed, psi->name);
+	if (!stop_loop)
+		pr_err("looping? Too many records seen from '%s'\n",
+			psi->name);
 }
 
 static void pstore_dowork(struct work_struct *work)

commit f6525b96dd9f68efe374e5aef864975e628de991
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue May 30 15:50:38 2017 -0700

    pstore: Fix leaked pstore_record in pstore_get_backend_records()
    
    When the "if (record->size <= 0)" test is true in
    pstore_get_backend_records() it's pretty clear that nobody holds a
    reference to the allocated pstore_record, yet we don't free it.
    
    Let's free it.
    
    Fixes: 2a2b0acf768c ("pstore: Allocate records on heap instead of stack")
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: stable@vger.kernel.org

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index b3045530dd4e..4c5cd9368460 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -849,8 +849,10 @@ void pstore_get_backend_records(struct pstore_info *psi,
 		record->size = psi->read(record);
 
 		/* No more records left in backend? */
-		if (record->size <= 0)
+		if (record->size <= 0) {
+			kfree(record);
 			break;
+		}
 
 		decompress_record(record);
 		rc = pstore_mkfile(root, record);

commit 4a16d1cb245c56e72fd40a28f3cdb394cde4b341
Author: Ankit Kumar <ankit@linux.vnet.ibm.com>
Date:   Tue May 23 11:16:52 2017 +0530

    pstore: Don't warn if data is uncompressed and type is not PSTORE_TYPE_DMESG
    
    commit 9abdcccc3d5f ("pstore: Extract common arguments into structure")
    moved record decompression to function. decompress_record() gets
    called without checking type and compressed flag. Warning will be
    reported if data is uncompressed. Pstore type PSTORE_TYPE_PPC_OPAL,
    PSTORE_TYPE_PPC_COMMON doesn't contain compressed data and warning get
    printed part of dmesg.
    
    Partial dmesg log:
    [   35.848914] pstore: ignored compressed record type 6
    [   35.848927] pstore: ignored compressed record type 8
    
    Above warning should not get printed as it is known that data won't be
    compressed for above type and it is valid condition.
    
    This patch returns if data is not compressed and print warning only if
    data is compressed and type is not PSTORE_TYPE_DMESG.
    
    Reported-by: Anton Blanchard <anton@au1.ibm.com>
    Signed-off-by: Ankit Kumar <ankit@linux.vnet.ibm.com>
    Reviewed-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Fixes: 9abdcccc3d5f ("pstore: Extract common arguments into structure")
    Cc: stable@vger.kernel.org

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index d468eec9b8a6..b3045530dd4e 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -770,8 +770,11 @@ static void decompress_record(struct pstore_record *record)
 	int unzipped_len;
 	char *decompressed;
 
+	if (!record->compressed)
+		return;
+
 	/* Only PSTORE_TYPE_DMESG support compression. */
-	if (!record->compressed || record->type != PSTORE_TYPE_DMESG) {
+	if (record->type != PSTORE_TYPE_DMESG) {
 		pr_warn("ignored compressed record type %d\n", record->type);
 		return;
 	}

commit 3a7d2fd16c57a1ef47dc2891171514231c9c7c6e
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Apr 27 15:53:21 2017 -0700

    pstore: Solve lockdep warning by moving inode locks
    
    Lockdep complains about a possible deadlock between mount and unlink
    (which is technically impossible), but fixing this improves possible
    future multiple-backend support, and keeps locking in the right order.
    
    The lockdep warning could be triggered by unlinking a file in the
    pstore filesystem:
    
      -> #1 (&sb->s_type->i_mutex_key#14){++++++}:
             lock_acquire+0xc9/0x220
             down_write+0x3f/0x70
             pstore_mkfile+0x1f4/0x460
             pstore_get_records+0x17a/0x320
             pstore_fill_super+0xa4/0xc0
             mount_single+0x89/0xb0
             pstore_mount+0x13/0x20
             mount_fs+0xf/0x90
             vfs_kern_mount+0x66/0x170
             do_mount+0x190/0xd50
             SyS_mount+0x90/0xd0
             entry_SYSCALL_64_fastpath+0x1c/0xb1
    
      -> #0 (&psinfo->read_mutex){+.+.+.}:
             __lock_acquire+0x1ac0/0x1bb0
             lock_acquire+0xc9/0x220
             __mutex_lock+0x6e/0x990
             mutex_lock_nested+0x16/0x20
             pstore_unlink+0x3f/0xa0
             vfs_unlink+0xb5/0x190
             do_unlinkat+0x24c/0x2a0
             SyS_unlinkat+0x16/0x30
             entry_SYSCALL_64_fastpath+0x1c/0xb1
    
      Possible unsafe locking scenario:
    
            CPU0                    CPU1
            ----                    ----
       lock(&sb->s_type->i_mutex_key#14);
                                    lock(&psinfo->read_mutex);
                                    lock(&sb->s_type->i_mutex_key#14);
       lock(&psinfo->read_mutex);
    
    Reported-by: Marta Lofstedt <marta.lofstedt@intel.com>
    Reported-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Namhyung Kim <namhyung@kernel.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 43b3ca5e045f..d468eec9b8a6 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -810,17 +810,17 @@ static void decompress_record(struct pstore_record *record)
 }
 
 /*
- * Read all the records from the persistent store. Create
+ * Read all the records from one persistent store backend. Create
  * files in our filesystem.  Don't warn about -EEXIST errors
  * when we are re-scanning the backing store looking to add new
  * error records.
  */
-void pstore_get_records(int quiet)
+void pstore_get_backend_records(struct pstore_info *psi,
+				struct dentry *root, int quiet)
 {
-	struct pstore_info *psi = psinfo;
 	int failed = 0;
 
-	if (!psi)
+	if (!psi || !root)
 		return;
 
 	mutex_lock(&psi->read_mutex);
@@ -850,7 +850,7 @@ void pstore_get_records(int quiet)
 			break;
 
 		decompress_record(record);
-		rc = pstore_mkfile(record);
+		rc = pstore_mkfile(root, record);
 		if (rc) {
 			/* pstore_mkfile() did not take record, so free it. */
 			kfree(record->buf);

commit 30800d9977ec271a7836d777848dba6773d12a3b
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Mar 7 13:57:11 2017 -0800

    pstore: simplify write_user_compat()
    
    Nothing actually uses write_user_compat() currently, but there is no
    reason to reuse the dmesg buffer. Instead, just allocate a new record
    buffer, copy in from userspace, and pass it to write() as normal.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index e79f170fa79b..43b3ca5e045f 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -635,33 +635,27 @@ static void pstore_unregister_console(void) {}
 static int pstore_write_user_compat(struct pstore_record *record,
 				    const char __user *buf)
 {
-	unsigned long flags = 0;
-	size_t i, bufsize, total_size = record->size;
-	long ret = 0;
-
-	if (unlikely(!access_ok(VERIFY_READ, buf, total_size)))
-		return -EFAULT;
-	bufsize = total_size;
-	if (bufsize > psinfo->bufsize)
-		bufsize = psinfo->bufsize;
-	record->buf = psinfo->buf;
-	spin_lock_irqsave(&psinfo->buf_lock, flags);
-	for (i = 0; i < total_size; ) {
-		size_t c = min(total_size - i, bufsize);
-
-		ret = __copy_from_user(record->buf, buf + i, c);
-		if (unlikely(ret != 0)) {
-			ret = -EFAULT;
-			break;
-		}
-		record->size = c;
-		ret = record->psi->write(record);
-		if (unlikely(ret < 0))
-			break;
-		i += c;
+	int ret = 0;
+
+	if (record->buf)
+		return -EINVAL;
+
+	record->buf = kmalloc(record->size, GFP_KERNEL);
+	if (!record->buf)
+		return -ENOMEM;
+
+	if (unlikely(copy_from_user(record->buf, buf, record->size))) {
+		ret = -EFAULT;
+		goto out;
 	}
-	spin_unlock_irqrestore(&psinfo->buf_lock, flags);
-	return unlikely(ret < 0) ? ret : total_size;
+
+	ret = record->psi->write(record);
+
+out:
+	kfree(record->buf);
+	record->buf = NULL;
+
+	return unlikely(ret < 0) ? ret : record->size;
 }
 
 /*

commit 4c9ec219766a217468fb94a281c416455a884dda
Author: Kees Cook <keescook@chromium.org>
Date:   Sun Mar 5 22:41:10 2017 -0800

    pstore: Remove write_buf() callback
    
    Now that write() and write_buf() are functionally identical, this removes
    write_buf(), and renames write_buf_user() to write_user(). Additionally
    adds sanity-checks for pstore_info's declared functions and flags at
    registration time.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 1e6642a2063e..e79f170fa79b 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -604,7 +604,7 @@ static void pstore_console_write(struct console *con, const char *s, unsigned c)
 		}
 		record.buf = (char *)s;
 		record.size = c;
-		psinfo->write_buf(&record);
+		psinfo->write(&record);
 		spin_unlock_irqrestore(&psinfo->buf_lock, flags);
 		s += c;
 		c = e - s;
@@ -632,15 +632,8 @@ static void pstore_register_console(void) {}
 static void pstore_unregister_console(void) {}
 #endif
 
-static int pstore_write_compat(struct pstore_record *record)
-{
-	record->buf = psinfo->buf;
-
-	return record->psi->write_buf(record);
-}
-
-static int pstore_write_buf_user_compat(struct pstore_record *record,
-					const char __user *buf)
+static int pstore_write_user_compat(struct pstore_record *record,
+				    const char __user *buf)
 {
 	unsigned long flags = 0;
 	size_t i, bufsize, total_size = record->size;
@@ -662,7 +655,7 @@ static int pstore_write_buf_user_compat(struct pstore_record *record,
 			break;
 		}
 		record->size = c;
-		ret = record->psi->write_buf(record);
+		ret = record->psi->write(record);
 		if (unlikely(ret < 0))
 			break;
 		i += c;
@@ -687,6 +680,20 @@ int pstore_register(struct pstore_info *psi)
 		return -EPERM;
 	}
 
+	/* Sanity check flags. */
+	if (!psi->flags) {
+		pr_warn("backend '%s' must support at least one frontend\n",
+			psi->name);
+		return -EINVAL;
+	}
+
+	/* Check for required functions. */
+	if (!psi->read || !psi->write) {
+		pr_warn("backend '%s' must implement read() and write()\n",
+			psi->name);
+		return -EINVAL;
+	}
+
 	spin_lock(&pstore_lock);
 	if (psinfo) {
 		pr_warn("backend '%s' already loaded: ignoring '%s'\n",
@@ -695,10 +702,8 @@ int pstore_register(struct pstore_info *psi)
 		return -EBUSY;
 	}
 
-	if (!psi->write)
-		psi->write = pstore_write_compat;
-	if (!psi->write_buf_user)
-		psi->write_buf_user = pstore_write_buf_user_compat;
+	if (!psi->write_user)
+		psi->write_user = pstore_write_user_compat;
 	psinfo = psi;
 	mutex_init(&psinfo->read_mutex);
 	spin_unlock(&pstore_lock);

commit fdd0311863b32b42bb2c54e60c987bbbabc0c430
Author: Kees Cook <keescook@chromium.org>
Date:   Sun Mar 5 00:56:38 2017 -0800

    pstore: Replace arguments for write_buf_user() API
    
    Removes argument list in favor of pstore record, though the user buffer
    remains passed separately since it must carry the __user annotation.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 5eecf9012459..1e6642a2063e 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -639,47 +639,36 @@ static int pstore_write_compat(struct pstore_record *record)
 	return record->psi->write_buf(record);
 }
 
-static int pstore_write_buf_user_compat(enum pstore_type_id type,
-			       enum kmsg_dump_reason reason,
-			       u64 *id, unsigned int part,
-			       const char __user *buf,
-			       bool compressed, size_t size,
-			       struct pstore_info *psi)
+static int pstore_write_buf_user_compat(struct pstore_record *record,
+					const char __user *buf)
 {
 	unsigned long flags = 0;
-	size_t i, bufsize = size;
+	size_t i, bufsize, total_size = record->size;
 	long ret = 0;
 
-	if (unlikely(!access_ok(VERIFY_READ, buf, size)))
+	if (unlikely(!access_ok(VERIFY_READ, buf, total_size)))
 		return -EFAULT;
+	bufsize = total_size;
 	if (bufsize > psinfo->bufsize)
 		bufsize = psinfo->bufsize;
+	record->buf = psinfo->buf;
 	spin_lock_irqsave(&psinfo->buf_lock, flags);
-	for (i = 0; i < size; ) {
-		struct pstore_record record = {
-			.type = type,
-			.reason = reason,
-			.id = id,
-			.part = part,
-			.buf = psinfo->buf,
-			.compressed = compressed,
-			.psi = psi,
-		};
-		size_t c = min(size - i, bufsize);
+	for (i = 0; i < total_size; ) {
+		size_t c = min(total_size - i, bufsize);
 
-		ret = __copy_from_user(psinfo->buf, buf + i, c);
+		ret = __copy_from_user(record->buf, buf + i, c);
 		if (unlikely(ret != 0)) {
 			ret = -EFAULT;
 			break;
 		}
-		record.size = c;
-		ret = psi->write_buf(&record);
+		record->size = c;
+		ret = record->psi->write_buf(record);
 		if (unlikely(ret < 0))
 			break;
 		i += c;
 	}
 	spin_unlock_irqrestore(&psinfo->buf_lock, flags);
-	return unlikely(ret < 0) ? ret : size;
+	return unlikely(ret < 0) ? ret : total_size;
 }
 
 /*

commit b10b471145f28c219d9ddcc309a67e053776865a
Author: Kees Cook <keescook@chromium.org>
Date:   Sun Mar 5 00:27:54 2017 -0800

    pstore: Replace arguments for write_buf() API
    
    As with the other API updates, this removes the long argument list in favor
    of passing a single pstore recaord.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index aa3d6e572ede..5eecf9012459 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -587,8 +587,11 @@ static void pstore_console_write(struct console *con, const char *s, unsigned c)
 	const char *e = s + c;
 
 	while (s < e) {
+		struct pstore_record record = {
+			.type = PSTORE_TYPE_CONSOLE,
+			.psi = psinfo,
+		};
 		unsigned long flags;
-		u64 id;
 
 		if (c > psinfo->bufsize)
 			c = psinfo->bufsize;
@@ -599,8 +602,9 @@ static void pstore_console_write(struct console *con, const char *s, unsigned c)
 		} else {
 			spin_lock_irqsave(&psinfo->buf_lock, flags);
 		}
-		psinfo->write_buf(PSTORE_TYPE_CONSOLE, 0, &id, 0,
-				  s, 0, c, psinfo);
+		record.buf = (char *)s;
+		record.size = c;
+		psinfo->write_buf(&record);
 		spin_unlock_irqrestore(&psinfo->buf_lock, flags);
 		s += c;
 		c = e - s;
@@ -630,10 +634,9 @@ static void pstore_unregister_console(void) {}
 
 static int pstore_write_compat(struct pstore_record *record)
 {
-	return record->psi->write_buf(record->type, record->reason,
-				      &record->id, record->part,
-				      psinfo->buf, record->compressed,
-				      record->size, record->psi);
+	record->buf = psinfo->buf;
+
+	return record->psi->write_buf(record);
 }
 
 static int pstore_write_buf_user_compat(enum pstore_type_id type,
@@ -653,6 +656,15 @@ static int pstore_write_buf_user_compat(enum pstore_type_id type,
 		bufsize = psinfo->bufsize;
 	spin_lock_irqsave(&psinfo->buf_lock, flags);
 	for (i = 0; i < size; ) {
+		struct pstore_record record = {
+			.type = type,
+			.reason = reason,
+			.id = id,
+			.part = part,
+			.buf = psinfo->buf,
+			.compressed = compressed,
+			.psi = psi,
+		};
 		size_t c = min(size - i, bufsize);
 
 		ret = __copy_from_user(psinfo->buf, buf + i, c);
@@ -660,8 +672,8 @@ static int pstore_write_buf_user_compat(enum pstore_type_id type,
 			ret = -EFAULT;
 			break;
 		}
-		ret = psi->write_buf(type, reason, id, part, psinfo->buf,
-				     compressed, c, psi);
+		record.size = c;
+		ret = psi->write_buf(&record);
 		if (unlikely(ret < 0))
 			break;
 		i += c;

commit 83f70f0769ddd8a368cb6346a918102818232962
Author: Kees Cook <keescook@chromium.org>
Date:   Sat Mar 4 23:12:24 2017 -0800

    pstore: Do not duplicate record metadata
    
    This switches the inode-private data from carrying duplicate metadata to
    keeping the record passed in during pstore_mkfile().
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 072326625629..aa3d6e572ede 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -852,14 +852,12 @@ void pstore_get_records(int quiet)
 		decompress_record(record);
 		rc = pstore_mkfile(record);
 		if (rc) {
-			/* pstore_mkfile() did not take buf, so free it. */
+			/* pstore_mkfile() did not take record, so free it. */
 			kfree(record->buf);
+			kfree(record);
 			if (rc != -EEXIST || !quiet)
 				failed++;
 		}
-
-		/* Reset for next record. */
-		kfree(record);
 	}
 	if (psi->close)
 		psi->close(psi);

commit 2a2b0acf768cfb2a9cf6c3b42b0e0eb25cbb5814
Author: Kees Cook <keescook@chromium.org>
Date:   Sat Mar 4 22:57:26 2017 -0800

    pstore: Allocate records on heap instead of stack
    
    In preparation for handling records off to pstore_mkfile(), allocate the
    record instead of reusing stack. This still always frees the record,
    though, since pstore_mkfile() isn't yet keeping it.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index d897e2f11b6a..072326625629 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -818,8 +818,7 @@ static void decompress_record(struct pstore_record *record)
 void pstore_get_records(int quiet)
 {
 	struct pstore_info *psi = psinfo;
-	struct pstore_record	record = { .psi = psi, };
-	int			failed = 0, rc;
+	int failed = 0;
 
 	if (!psi)
 		return;
@@ -833,19 +832,34 @@ void pstore_get_records(int quiet)
 	 * may reallocate record.buf. On success, pstore_mkfile() will keep
 	 * the record.buf, so free it only on failure.
 	 */
-	while ((record.size = psi->read(&record)) > 0) {
-		decompress_record(&record);
-		rc = pstore_mkfile(&record);
+	for (;;) {
+		struct pstore_record *record;
+		int rc;
+
+		record = kzalloc(sizeof(*record), GFP_KERNEL);
+		if (!record) {
+			pr_err("out of memory creating record\n");
+			break;
+		}
+		record->psi = psi;
+
+		record->size = psi->read(record);
+
+		/* No more records left in backend? */
+		if (record->size <= 0)
+			break;
+
+		decompress_record(record);
+		rc = pstore_mkfile(record);
 		if (rc) {
 			/* pstore_mkfile() did not take buf, so free it. */
-			kfree(record.buf);
+			kfree(record->buf);
 			if (rc != -EEXIST || !quiet)
 				failed++;
 		}
 
 		/* Reset for next record. */
-		memset(&record, 0, sizeof(record));
-		record.psi = psi;
+		kfree(record);
 	}
 	if (psi->close)
 		psi->close(psi);

commit 1dfff7dd67d1a3be4d0ab4a5313f0363966bc70d
Author: Kees Cook <keescook@chromium.org>
Date:   Sat Mar 4 22:46:41 2017 -0800

    pstore: Pass record contents instead of copying
    
    pstore_mkfile() shouldn't have to memcpy the record contents. It can use
    the existing copy instead. This adjusts the allocation lifetime management
    and renames the contents variable from "data" to "buf" to assist moving to
    struct pstore_record in the future.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index c0d401e732e6..d897e2f11b6a 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -828,14 +828,22 @@ void pstore_get_records(int quiet)
 	if (psi->open && psi->open(psi))
 		goto out;
 
+	/*
+	 * Backend callback read() allocates record.buf. decompress_record()
+	 * may reallocate record.buf. On success, pstore_mkfile() will keep
+	 * the record.buf, so free it only on failure.
+	 */
 	while ((record.size = psi->read(&record)) > 0) {
 		decompress_record(&record);
 		rc = pstore_mkfile(&record);
+		if (rc) {
+			/* pstore_mkfile() did not take buf, so free it. */
+			kfree(record.buf);
+			if (rc != -EEXIST || !quiet)
+				failed++;
+		}
 
-		if (rc && (rc != -EEXIST || !quiet))
-			failed++;
-
-		kfree(record.buf);
+		/* Reset for next record. */
 		memset(&record, 0, sizeof(record));
 		record.psi = psi;
 	}

commit 7e8cc8dce17574e432945fa75882cd401c3ef673
Author: Kees Cook <keescook@chromium.org>
Date:   Sat Mar 4 22:28:46 2017 -0800

    pstore: Always allocate buffer for decompression
    
    Currently, pstore_mkfile() performs a memcpy() of the record contents,
    so it can live anywhere. However, this is needlessly wasteful. In
    preparation of pstore_mkfile() keeping the record contents, always
    allocate a buffer for the contents.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 879658b4c679..c0d401e732e6 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -768,6 +768,7 @@ EXPORT_SYMBOL_GPL(pstore_unregister);
 static void decompress_record(struct pstore_record *record)
 {
 	int unzipped_len;
+	char *decompressed;
 
 	/* Only PSTORE_TYPE_DMESG support compression. */
 	if (!record->compressed || record->type != PSTORE_TYPE_DMESG) {
@@ -783,17 +784,29 @@ static void decompress_record(struct pstore_record *record)
 
 	unzipped_len = pstore_decompress(record->buf, big_oops_buf,
 					 record->size, big_oops_buf_sz);
-	if (unzipped_len > 0) {
-		if (record->ecc_notice_size)
-			memcpy(big_oops_buf + unzipped_len,
-			       record->buf + record->size,
-			       record->ecc_notice_size);
-		kfree(record->buf);
-		record->buf = big_oops_buf;
-		record->size = unzipped_len;
-		record->compressed = false;
-	} else
+	if (unzipped_len <= 0) {
 		pr_err("decompression failed: %d\n", unzipped_len);
+		return;
+	}
+
+	/* Build new buffer for decompressed contents. */
+	decompressed = kmalloc(unzipped_len + record->ecc_notice_size,
+			       GFP_KERNEL);
+	if (!decompressed) {
+		pr_err("decompression ran out of memory\n");
+		return;
+	}
+	memcpy(decompressed, big_oops_buf, unzipped_len);
+
+	/* Append ECC notice to decompressed buffer. */
+	memcpy(decompressed + unzipped_len, record->buf + record->size,
+	       record->ecc_notice_size);
+
+	/* Swap out compresed contents with decompressed contents. */
+	kfree(record->buf);
+	record->buf = decompressed;
+	record->size = unzipped_len;
+	record->compressed = false;
 }
 
 /*
@@ -819,13 +832,10 @@ void pstore_get_records(int quiet)
 		decompress_record(&record);
 		rc = pstore_mkfile(&record);
 
-		/* Free buffer other than big oops */
-		if (record.buf != big_oops_buf)
-			kfree(record.buf);
-
 		if (rc && (rc != -EEXIST || !quiet))
 			failed++;
 
+		kfree(record.buf);
 		memset(&record, 0, sizeof(record));
 		record.psi = psi;
 	}

commit 76cc9580e3fbd323651d06e8184a5a54e0e1066e
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Mar 3 23:28:53 2017 -0800

    pstore: Replace arguments for write() API
    
    Similar to the pstore_info read() callback, there were too many arguments.
    This switches to the new struct pstore_record pointer instead. This adds
    "reason" and "part" to the record structure as well.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 47968c2f2d0d..879658b4c679 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -484,7 +484,6 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 {
 	unsigned long	total = 0;
 	const char	*why;
-	u64		id;
 	unsigned int	part = 1;
 	unsigned long	flags = 0;
 	int		is_locked;
@@ -506,48 +505,59 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 	oopscount++;
 	while (total < kmsg_bytes) {
 		char *dst;
-		unsigned long size;
-		int hsize;
+		size_t dst_size;
+		int header_size;
 		int zipped_len = -1;
-		size_t len;
-		bool compressed = false;
-		size_t total_len;
+		size_t dump_size;
+		struct pstore_record record = {
+			.type = PSTORE_TYPE_DMESG,
+			.count = oopscount,
+			.reason = reason,
+			.part = part,
+			.compressed = false,
+			.buf = psinfo->buf,
+			.psi = psinfo,
+		};
 
 		if (big_oops_buf && is_locked) {
 			dst = big_oops_buf;
-			size = big_oops_buf_sz;
+			dst_size = big_oops_buf_sz;
 		} else {
 			dst = psinfo->buf;
-			size = psinfo->bufsize;
+			dst_size = psinfo->bufsize;
 		}
 
-		hsize = sprintf(dst, "%s#%d Part%u\n", why, oopscount, part);
-		size -= hsize;
+		/* Write dump header. */
+		header_size = snprintf(dst, dst_size, "%s#%d Part%u\n", why,
+				 oopscount, part);
+		dst_size -= header_size;
 
-		if (!kmsg_dump_get_buffer(dumper, true, dst + hsize,
-					  size, &len))
+		/* Write dump contents. */
+		if (!kmsg_dump_get_buffer(dumper, true, dst + header_size,
+					  dst_size, &dump_size))
 			break;
 
 		if (big_oops_buf && is_locked) {
 			zipped_len = pstore_compress(dst, psinfo->buf,
-						hsize + len, psinfo->bufsize);
+						header_size + dump_size,
+						psinfo->bufsize);
 
 			if (zipped_len > 0) {
-				compressed = true;
-				total_len = zipped_len;
+				record.compressed = true;
+				record.size = zipped_len;
 			} else {
-				total_len = copy_kmsg_to_buffer(hsize, len);
+				record.size = copy_kmsg_to_buffer(header_size,
+								  dump_size);
 			}
 		} else {
-			total_len = hsize + len;
+			record.size = header_size + dump_size;
 		}
 
-		ret = psinfo->write(PSTORE_TYPE_DMESG, reason, &id, part,
-				    oopscount, compressed, total_len, psinfo);
+		ret = psinfo->write(&record);
 		if (ret == 0 && reason == KMSG_DUMP_OOPS && pstore_is_mounted())
 			pstore_new_entry = 1;
 
-		total += total_len;
+		total += record.size;
 		part++;
 	}
 	if (is_locked)
@@ -618,14 +628,12 @@ static void pstore_register_console(void) {}
 static void pstore_unregister_console(void) {}
 #endif
 
-static int pstore_write_compat(enum pstore_type_id type,
-			       enum kmsg_dump_reason reason,
-			       u64 *id, unsigned int part, int count,
-			       bool compressed, size_t size,
-			       struct pstore_info *psi)
+static int pstore_write_compat(struct pstore_record *record)
 {
-	return psi->write_buf(type, reason, id, part, psinfo->buf, compressed,
-			     size, psi);
+	return record->psi->write_buf(record->type, record->reason,
+				      &record->id, record->part,
+				      psinfo->buf, record->compressed,
+				      record->size, record->psi);
 }
 
 static int pstore_write_buf_user_compat(enum pstore_type_id type,

commit 125cc42baf8ab2149c207f8a360ea25668b8422d
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Mar 3 22:09:18 2017 -0800

    pstore: Replace arguments for read() API
    
    The argument list for the pstore_read() interface is unwieldy. This changes
    passes the new struct pstore_record instead. The erst backend was already
    doing something similar internally.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 168e03fd5e58..47968c2f2d0d 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -807,12 +807,7 @@ void pstore_get_records(int quiet)
 	if (psi->open && psi->open(psi))
 		goto out;
 
-	while ((record.size = psi->read(&record.id, &record.type,
-				 &record.count, &record.time,
-				 &record.buf, &record.compressed,
-				 &record.ecc_notice_size,
-				 record.psi)) > 0) {
-
+	while ((record.size = psi->read(&record)) > 0) {
 		decompress_record(&record);
 		rc = pstore_mkfile(&record);
 

commit 1edd1aa397ad3ca5f1fca1961c13910ef53f16e8
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Mar 3 18:16:32 2017 -0800

    pstore: Switch pstore_mkfile to pass record
    
    Instead of the long list of arguments, just pass the new record struct.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 0503380704de..168e03fd5e58 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -814,11 +814,7 @@ void pstore_get_records(int quiet)
 				 record.psi)) > 0) {
 
 		decompress_record(&record);
-		rc = pstore_mkfile(record.type, psi->name, record.id,
-				   record.count, record.buf,
-				   record.compressed,
-				   record.size + record.ecc_notice_size,
-				   record.time, record.psi);
+		rc = pstore_mkfile(&record);
 
 		/* Free buffer other than big oops */
 		if (record.buf != big_oops_buf)

commit 634f8f5167c88052ce6d28e519ff6325172191dc
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Mar 3 17:35:25 2017 -0800

    pstore: Move record decompression to function
    
    This moves the record decompression logic out to a separate function
    to avoid the deep indentation.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index f45228eac3e6..0503380704de 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -757,6 +757,37 @@ void pstore_unregister(struct pstore_info *psi)
 }
 EXPORT_SYMBOL_GPL(pstore_unregister);
 
+static void decompress_record(struct pstore_record *record)
+{
+	int unzipped_len;
+
+	/* Only PSTORE_TYPE_DMESG support compression. */
+	if (!record->compressed || record->type != PSTORE_TYPE_DMESG) {
+		pr_warn("ignored compressed record type %d\n", record->type);
+		return;
+	}
+
+	/* No compression method has created the common buffer. */
+	if (!big_oops_buf) {
+		pr_warn("no decompression buffer allocated\n");
+		return;
+	}
+
+	unzipped_len = pstore_decompress(record->buf, big_oops_buf,
+					 record->size, big_oops_buf_sz);
+	if (unzipped_len > 0) {
+		if (record->ecc_notice_size)
+			memcpy(big_oops_buf + unzipped_len,
+			       record->buf + record->size,
+			       record->ecc_notice_size);
+		kfree(record->buf);
+		record->buf = big_oops_buf;
+		record->size = unzipped_len;
+		record->compressed = false;
+	} else
+		pr_err("decompression failed: %d\n", unzipped_len);
+}
+
 /*
  * Read all the records from the persistent store. Create
  * files in our filesystem.  Don't warn about -EEXIST errors
@@ -768,7 +799,6 @@ void pstore_get_records(int quiet)
 	struct pstore_info *psi = psinfo;
 	struct pstore_record	record = { .psi = psi, };
 	int			failed = 0, rc;
-	int			unzipped_len = -1;
 
 	if (!psi)
 		return;
@@ -782,41 +812,18 @@ void pstore_get_records(int quiet)
 				 &record.buf, &record.compressed,
 				 &record.ecc_notice_size,
 				 record.psi)) > 0) {
-		if (record.compressed &&
-		    record.type == PSTORE_TYPE_DMESG) {
-			if (big_oops_buf)
-				unzipped_len = pstore_decompress(
-							record.buf,
-							big_oops_buf,
-							record.size,
-							big_oops_buf_sz);
-
-			if (unzipped_len > 0) {
-				if (record.ecc_notice_size)
-					memcpy(big_oops_buf + unzipped_len,
-					       record.buf + record.size,
-					       record.ecc_notice_size);
-				kfree(record.buf);
-				record.buf = big_oops_buf;
-				record.size = unzipped_len;
-				record.compressed = false;
-			} else {
-				pr_err("decompression failed;returned %d\n",
-				       unzipped_len);
-				record.compressed = true;
-			}
-		}
+
+		decompress_record(&record);
 		rc = pstore_mkfile(record.type, psi->name, record.id,
 				   record.count, record.buf,
 				   record.compressed,
 				   record.size + record.ecc_notice_size,
 				   record.time, record.psi);
-		if (unzipped_len < 0) {
-			/* Free buffer other than big oops */
+
+		/* Free buffer other than big oops */
+		if (record.buf != big_oops_buf)
 			kfree(record.buf);
-			record.buf = NULL;
-		} else
-			unzipped_len = -1;
+
 		if (rc && (rc != -EEXIST || !quiet))
 			failed++;
 

commit 9abdcccc3d5f3c72f25cd48160f60d911353bee9
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Mar 3 16:59:29 2017 -0800

    pstore: Extract common arguments into structure
    
    The read/mkfile pair pass the same arguments and should be cleared
    between calls. Move to a structure and wipe it after every loop.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 320a673ecb5b..f45228eac3e6 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -766,16 +766,9 @@ EXPORT_SYMBOL_GPL(pstore_unregister);
 void pstore_get_records(int quiet)
 {
 	struct pstore_info *psi = psinfo;
-	char			*buf = NULL;
-	ssize_t			size;
-	u64			id;
-	int			count;
-	enum pstore_type_id	type;
-	struct timespec		time;
+	struct pstore_record	record = { .psi = psi, };
 	int			failed = 0, rc;
-	bool			compressed;
 	int			unzipped_len = -1;
-	ssize_t			ecc_notice_size = 0;
 
 	if (!psi)
 		return;
@@ -784,39 +777,51 @@ void pstore_get_records(int quiet)
 	if (psi->open && psi->open(psi))
 		goto out;
 
-	while ((size = psi->read(&id, &type, &count, &time, &buf, &compressed,
-				 &ecc_notice_size, psi)) > 0) {
-		if (compressed && (type == PSTORE_TYPE_DMESG)) {
+	while ((record.size = psi->read(&record.id, &record.type,
+				 &record.count, &record.time,
+				 &record.buf, &record.compressed,
+				 &record.ecc_notice_size,
+				 record.psi)) > 0) {
+		if (record.compressed &&
+		    record.type == PSTORE_TYPE_DMESG) {
 			if (big_oops_buf)
-				unzipped_len = pstore_decompress(buf,
-							big_oops_buf, size,
+				unzipped_len = pstore_decompress(
+							record.buf,
+							big_oops_buf,
+							record.size,
 							big_oops_buf_sz);
 
 			if (unzipped_len > 0) {
-				if (ecc_notice_size)
+				if (record.ecc_notice_size)
 					memcpy(big_oops_buf + unzipped_len,
-					       buf + size, ecc_notice_size);
-				kfree(buf);
-				buf = big_oops_buf;
-				size = unzipped_len;
-				compressed = false;
+					       record.buf + record.size,
+					       record.ecc_notice_size);
+				kfree(record.buf);
+				record.buf = big_oops_buf;
+				record.size = unzipped_len;
+				record.compressed = false;
 			} else {
 				pr_err("decompression failed;returned %d\n",
 				       unzipped_len);
-				compressed = true;
+				record.compressed = true;
 			}
 		}
-		rc = pstore_mkfile(type, psi->name, id, count, buf,
-				   compressed, size + ecc_notice_size,
-				   time, psi);
+		rc = pstore_mkfile(record.type, psi->name, record.id,
+				   record.count, record.buf,
+				   record.compressed,
+				   record.size + record.ecc_notice_size,
+				   record.time, record.psi);
 		if (unzipped_len < 0) {
 			/* Free buffer other than big oops */
-			kfree(buf);
-			buf = NULL;
+			kfree(record.buf);
+			record.buf = NULL;
 		} else
 			unzipped_len = -1;
 		if (rc && (rc != -EEXIST || !quiet))
 			failed++;
+
+		memset(&record, 0, sizeof(record));
+		record.psi = psi;
 	}
 	if (psi->close)
 		psi->close(psi);

commit 0d7cd09a3dbbdb3d4932cddbef613b2a6de28b75
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Mar 3 12:11:40 2017 -0800

    pstore: Improve register_pstore() error reporting
    
    Uncommon errors are better to get reported to dmesg so developers can
    more easily figure out why pstore is unhappy with a backend attempting
    to register.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index d69ef8a840b9..320a673ecb5b 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -673,11 +673,15 @@ int pstore_register(struct pstore_info *psi)
 {
 	struct module *owner = psi->owner;
 
-	if (backend && strcmp(backend, psi->name))
+	if (backend && strcmp(backend, psi->name)) {
+		pr_warn("ignoring unexpected backend '%s'\n", psi->name);
 		return -EPERM;
+	}
 
 	spin_lock(&pstore_lock);
 	if (psinfo) {
+		pr_warn("backend '%s' already loaded: ignoring '%s'\n",
+			psinfo->name, psi->name);
 		spin_unlock(&pstore_lock);
 		return -EBUSY;
 	}

commit 1344dd86f35c7669c94aceb2273676e356cff848
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Mar 3 17:45:38 2017 -0800

    pstore: Avoid race in module unloading
    
    Technically, it might be possible for struct pstore_info to go out of
    scope after the module_put(), so report the backend name first.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 074fe85a2078..d69ef8a840b9 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -722,10 +722,10 @@ int pstore_register(struct pstore_info *psi)
 	 */
 	backend = psi->name;
 
-	module_put(owner);
-
 	pr_info("Registered %s as persistent store backend\n", psi->name);
 
+	module_put(owner);
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(pstore_register);

commit 6330d5534786d5315d56d558aa6d20740f97d80a
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Mar 6 12:42:12 2017 -0800

    pstore: Shut down worker when unregistering
    
    When built as a module and running with update_ms >= 0, pstore will Oops
    during module unload since the work timer is still running. This makes sure
    the worker is stopped before unloading.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: stable@vger.kernel.org

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index cfc1abd264d9..074fe85a2078 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -709,6 +709,7 @@ int pstore_register(struct pstore_info *psi)
 	if (psi->flags & PSTORE_FLAGS_PMSG)
 		pstore_register_pmsg();
 
+	/* Start watching for new records, if desired. */
 	if (pstore_update_ms >= 0) {
 		pstore_timer.expires = jiffies +
 			msecs_to_jiffies(pstore_update_ms);
@@ -731,6 +732,11 @@ EXPORT_SYMBOL_GPL(pstore_register);
 
 void pstore_unregister(struct pstore_info *psi)
 {
+	/* Stop timer and make sure all work has finished. */
+	pstore_update_ms = -1;
+	del_timer_sync(&pstore_timer);
+	flush_work(&pstore_work);
+
 	if (psi->flags & PSTORE_FLAGS_PMSG)
 		pstore_unregister_pmsg();
 	if (psi->flags & PSTORE_FLAGS_FTRACE)
@@ -830,7 +836,9 @@ static void pstore_timefunc(unsigned long dummy)
 		schedule_work(&pstore_work);
 	}
 
-	mod_timer(&pstore_timer, jiffies + msecs_to_jiffies(pstore_update_ms));
+	if (pstore_update_ms >= 0)
+		mod_timer(&pstore_timer,
+			  jiffies + msecs_to_jiffies(pstore_update_ms));
 }
 
 module_param(backend, charp, 0444);

commit 3faf93543ccb3410bfaf992a0de4a925631a3526
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sun Feb 19 15:07:53 2017 +0530

    pstore: constify pstore_zbackend structures
    
    The references of pstore_zbackend structures are stored into the
    pointer zbackend of type struct pstore_zbackend. The pointer zbackend
    can be made const as it is only dereferenced. After making this change
    the pstore_zbackend structures whose references are stored into the
    pointer zbackend can be made const too.
    
    File size before:
       text    data     bss     dec     hex filename
       4817     541     172    5530    159a fs/pstore/platform.o
    
    File size after:
       text    data     bss     dec     hex filename
       4865     477     172    5514    158a fs/pstore/platform.o
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index efab7b64925b..cfc1abd264d9 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -267,7 +267,7 @@ static void free_zlib(void)
 	big_oops_buf_sz = 0;
 }
 
-static struct pstore_zbackend backend_zlib = {
+static const struct pstore_zbackend backend_zlib = {
 	.compress	= compress_zlib,
 	.decompress	= decompress_zlib,
 	.allocate	= allocate_zlib,
@@ -328,7 +328,7 @@ static void free_lzo(void)
 	big_oops_buf_sz = 0;
 }
 
-static struct pstore_zbackend backend_lzo = {
+static const struct pstore_zbackend backend_lzo = {
 	.compress	= compress_lzo,
 	.decompress	= decompress_lzo,
 	.allocate	= allocate_lzo,
@@ -393,7 +393,7 @@ static void free_lz4(void)
 	big_oops_buf_sz = 0;
 }
 
-static struct pstore_zbackend backend_lz4 = {
+static const struct pstore_zbackend backend_lz4 = {
 	.compress	= compress_lz4,
 	.decompress	= decompress_lz4,
 	.allocate	= allocate_lz4,
@@ -402,7 +402,7 @@ static struct pstore_zbackend backend_lz4 = {
 };
 #endif
 
-static struct pstore_zbackend *zbackend =
+static const struct pstore_zbackend *zbackend =
 #if defined(CONFIG_PSTORE_ZLIB_COMPRESS)
 	&backend_zlib;
 #elif defined(CONFIG_PSTORE_LZO_COMPRESS)

commit d21b5ff12df45a65bb220c7e8103a5f0f5609377
Author: Sven Schmidt <4sschmid@informatik.uni-hamburg.de>
Date:   Fri Feb 24 15:01:22 2017 -0800

    fs/pstore: fs/squashfs: change usage of LZ4 to work with new LZ4 version
    
    Update fs/pstore and fs/squashfs to use the updated functions from the
    new LZ4 module.
    
    Link: http://lkml.kernel.org/r/1486321748-19085-5-git-send-email-4sschmid@informatik.uni-hamburg.de
    Signed-off-by: Sven Schmidt <4sschmid@informatik.uni-hamburg.de>
    Cc: Bongkyu Kim <bongkyu.kim@lge.com>
    Cc: Rui Salvaterra <rsalvaterra@gmail.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Anton Vorontsov <anton@enomsg.org>
    Cc: Colin Cross <ccross@android.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 729677e18e36..efab7b64925b 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -342,31 +342,35 @@ static int compress_lz4(const void *in, void *out, size_t inlen, size_t outlen)
 {
 	int ret;
 
-	ret = lz4_compress(in, inlen, out, &outlen, workspace);
-	if (ret) {
-		pr_err("lz4_compress error, ret = %d!\n", ret);
+	ret = LZ4_compress_default(in, out, inlen, outlen, workspace);
+	if (!ret) {
+		pr_err("LZ4_compress_default error; compression failed!\n");
 		return -EIO;
 	}
 
-	return outlen;
+	return ret;
 }
 
 static int decompress_lz4(void *in, void *out, size_t inlen, size_t outlen)
 {
 	int ret;
 
-	ret = lz4_decompress_unknownoutputsize(in, inlen, out, &outlen);
-	if (ret) {
-		pr_err("lz4_decompress error, ret = %d!\n", ret);
+	ret = LZ4_decompress_safe(in, out, inlen, outlen);
+	if (ret < 0) {
+		/*
+		 * LZ4_decompress_safe will return an error code
+		 * (< 0) if decompression failed
+		 */
+		pr_err("LZ4_decompress_safe error, ret = %d!\n", ret);
 		return -EIO;
 	}
 
-	return outlen;
+	return ret;
 }
 
 static void allocate_lz4(void)
 {
-	big_oops_buf_sz = lz4_compressbound(psinfo->bufsize);
+	big_oops_buf_sz = LZ4_compressBound(psinfo->bufsize);
 	big_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);
 	if (big_oops_buf) {
 		workspace = kmalloc(LZ4_MEM_COMPRESS, GFP_KERNEL);

commit 70ad35db3321a6d129245979de4ac9d06eed897c
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Wed Oct 19 10:23:41 2016 +0900

    pstore: Convert console write to use ->write_buf
    
    Maybe I'm missing something, but I don't know why it needs to copy the
    input buffer to psinfo->buf and then write.  Instead we can write the
    input buffer directly.  The only implementation that supports console
    message (i.e. ramoops) already does it for ftrace messages.
    
    For the upcoming virtio backend driver, it needs to protect psinfo->buf
    overwritten from console messages.  If it could use ->write_buf method
    instead of ->write, the problem will be solved easily.
    
    Cc: Stefan Hajnoczi <stefanha@redhat.com>
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 60e6db6f5da2..729677e18e36 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -585,8 +585,8 @@ static void pstore_console_write(struct console *con, const char *s, unsigned c)
 		} else {
 			spin_lock_irqsave(&psinfo->buf_lock, flags);
 		}
-		memcpy(psinfo->buf, s, c);
-		psinfo->write(PSTORE_TYPE_CONSOLE, 0, &id, 0, 0, 0, c, psinfo);
+		psinfo->write_buf(PSTORE_TYPE_CONSOLE, 0, &id, 0,
+				  s, 0, c, psinfo);
 		spin_unlock_irqrestore(&psinfo->buf_lock, flags);
 		s += c;
 		c = e - s;

commit 959217c84c2765434cd2cbf3d7ffdc09e90834f9
Author: Li Pengcheng <lipengcheng8@huawei.com>
Date:   Sat Nov 5 10:15:59 2016 +0800

    pstore: Actually give up during locking failure
    
    Without a return after the pr_err(), dumps will collide when two threads
    call pstore_dump() at the same time.
    
    Signed-off-by: Liu Hailong <liuhailong5@huawei.com>
    Signed-off-by: Li Pengcheng <lipengcheng8@huawei.com>
    Signed-off-by: Li Zhong <lizhong11@hisilicon.com>
    [kees: improved commit message]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 14984d902a99..60e6db6f5da2 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -493,6 +493,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		if (!is_locked) {
 			pr_err("pstore dump routine blocked in %s path, may corrupt error record\n"
 				       , in_nmi() ? "NMI" : why);
+			return;
 		}
 	} else {
 		spin_lock_irqsave(&psinfo->buf_lock, flags);

commit 5bf6d1b92715f224ef6e1c3abca5dd63eeb4915d
Author: Mark Salyzyn <salyzyn@android.com>
Date:   Thu Sep 1 08:13:46 2016 -0700

    pstore/pmsg: drop bounce buffer
    
    Removing a bounce buffer copy operation in the pmsg driver path is
    always better. We also gain in overall performance by not requesting
    a vmalloc on every write as this can cause precious RT tasks, such
    as user facing media operation, to stall while memory is being
    reclaimed. Added a write_buf_user to the pstore functions, a backup
    platform write_buf_user that uses the small buffer that is part of
    the instance, and implemented a ramoops write_buf_user that only
    supports PSTORE_TYPE_PMSG.
    
    Signed-off-by: Mark Salyzyn <salyzyn@android.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 76dd604a0f2c..14984d902a99 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -623,6 +623,40 @@ static int pstore_write_compat(enum pstore_type_id type,
 			     size, psi);
 }
 
+static int pstore_write_buf_user_compat(enum pstore_type_id type,
+			       enum kmsg_dump_reason reason,
+			       u64 *id, unsigned int part,
+			       const char __user *buf,
+			       bool compressed, size_t size,
+			       struct pstore_info *psi)
+{
+	unsigned long flags = 0;
+	size_t i, bufsize = size;
+	long ret = 0;
+
+	if (unlikely(!access_ok(VERIFY_READ, buf, size)))
+		return -EFAULT;
+	if (bufsize > psinfo->bufsize)
+		bufsize = psinfo->bufsize;
+	spin_lock_irqsave(&psinfo->buf_lock, flags);
+	for (i = 0; i < size; ) {
+		size_t c = min(size - i, bufsize);
+
+		ret = __copy_from_user(psinfo->buf, buf + i, c);
+		if (unlikely(ret != 0)) {
+			ret = -EFAULT;
+			break;
+		}
+		ret = psi->write_buf(type, reason, id, part, psinfo->buf,
+				     compressed, c, psi);
+		if (unlikely(ret < 0))
+			break;
+		i += c;
+	}
+	spin_unlock_irqrestore(&psinfo->buf_lock, flags);
+	return unlikely(ret < 0) ? ret : size;
+}
+
 /*
  * platform specific persistent storage driver registers with
  * us here. If pstore is already mounted, call the platform
@@ -645,6 +679,8 @@ int pstore_register(struct pstore_info *psi)
 
 	if (!psi->write)
 		psi->write = pstore_write_compat;
+	if (!psi->write_buf_user)
+		psi->write_buf_user = pstore_write_buf_user_compat;
 	psinfo = psi;
 	mutex_init(&psinfo->read_mutex);
 	spin_unlock(&pstore_lock);

commit c950fd6f201aea649932898206a850f0a7f25603
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Thu Jul 28 00:08:25 2016 +0900

    pstore: Split pstore fragile flags
    
    This patch adds new PSTORE_FLAGS for each pstore type so that they can
    be enabled separately.  This is a preparation for ongoing virtio-pstore
    work to support those types flexibly.
    
    The PSTORE_FLAGS_FRAGILE is changed to PSTORE_FLAGS_DMESG to preserve the
    original behavior.
    
    Cc: Anton Vorontsov <anton@enomsg.org>
    Cc: Colin Cross <ccross@android.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-efi@vger.kernel.org
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    [kees: retained "FRAGILE" for now to make merges easier]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 16ecca5b72d8..76dd604a0f2c 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -659,13 +659,14 @@ int pstore_register(struct pstore_info *psi)
 	if (pstore_is_mounted())
 		pstore_get_records(0);
 
-	pstore_register_kmsg();
-
-	if ((psi->flags & PSTORE_FLAGS_FRAGILE) == 0) {
+	if (psi->flags & PSTORE_FLAGS_DMESG)
+		pstore_register_kmsg();
+	if (psi->flags & PSTORE_FLAGS_CONSOLE)
 		pstore_register_console();
+	if (psi->flags & PSTORE_FLAGS_FTRACE)
 		pstore_register_ftrace();
+	if (psi->flags & PSTORE_FLAGS_PMSG)
 		pstore_register_pmsg();
-	}
 
 	if (pstore_update_ms >= 0) {
 		pstore_timer.expires = jiffies +
@@ -689,12 +690,14 @@ EXPORT_SYMBOL_GPL(pstore_register);
 
 void pstore_unregister(struct pstore_info *psi)
 {
-	if ((psi->flags & PSTORE_FLAGS_FRAGILE) == 0) {
+	if (psi->flags & PSTORE_FLAGS_PMSG)
 		pstore_unregister_pmsg();
+	if (psi->flags & PSTORE_FLAGS_FTRACE)
 		pstore_unregister_ftrace();
+	if (psi->flags & PSTORE_FLAGS_CONSOLE)
 		pstore_unregister_console();
-	}
-	pstore_unregister_kmsg();
+	if (psi->flags & PSTORE_FLAGS_DMESG)
+		pstore_unregister_kmsg();
 
 	free_buf_for_compression();
 

commit 8cfc8ddc99df9509a46043b14af81f5c6a223eab
Author: Geliang Tang <geliangtang@163.com>
Date:   Thu Feb 18 22:04:22 2016 +0800

    pstore: add lzo/lz4 compression support
    
    Like zlib compression in pstore, this patch added lzo and lz4
    compression support so that users can have more options and better
    compression ratio.
    
    The original code treats the compressed data together with the
    uncompressed ECC correction notice by using zlib decompress. The
    ECC correction notice is missing in the decompression process. The
    treatment also makes lzo and lz4 not working. So I treat them
    separately by using pstore_decompress() to treat the compressed
    data, and memcpy() to treat the uncompressed ECC correction notice.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index fe41d8ec663a..16ecca5b72d8 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -28,7 +28,15 @@
 #include <linux/console.h>
 #include <linux/module.h>
 #include <linux/pstore.h>
+#ifdef CONFIG_PSTORE_ZLIB_COMPRESS
 #include <linux/zlib.h>
+#endif
+#ifdef CONFIG_PSTORE_LZO_COMPRESS
+#include <linux/lzo.h>
+#endif
+#ifdef CONFIG_PSTORE_LZ4_COMPRESS
+#include <linux/lz4.h>
+#endif
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/slab.h>
@@ -69,10 +77,23 @@ struct pstore_info *psinfo;
 static char *backend;
 
 /* Compression parameters */
+#ifdef CONFIG_PSTORE_ZLIB_COMPRESS
 #define COMPR_LEVEL 6
 #define WINDOW_BITS 12
 #define MEM_LEVEL 4
 static struct z_stream_s stream;
+#else
+static unsigned char *workspace;
+#endif
+
+struct pstore_zbackend {
+	int (*compress)(const void *in, void *out, size_t inlen, size_t outlen);
+	int (*decompress)(void *in, void *out, size_t inlen, size_t outlen);
+	void (*allocate)(void);
+	void (*free)(void);
+
+	const char *name;
+};
 
 static char *big_oops_buf;
 static size_t big_oops_buf_sz;
@@ -129,9 +150,9 @@ bool pstore_cannot_block_path(enum kmsg_dump_reason reason)
 }
 EXPORT_SYMBOL_GPL(pstore_cannot_block_path);
 
+#ifdef CONFIG_PSTORE_ZLIB_COMPRESS
 /* Derived from logfs_compress() */
-static int pstore_compress(const void *in, void *out, size_t inlen,
-							size_t outlen)
+static int compress_zlib(const void *in, void *out, size_t inlen, size_t outlen)
 {
 	int err, ret;
 
@@ -165,7 +186,7 @@ static int pstore_compress(const void *in, void *out, size_t inlen,
 }
 
 /* Derived from logfs_uncompress */
-static int pstore_decompress(void *in, void *out, size_t inlen, size_t outlen)
+static int decompress_zlib(void *in, void *out, size_t inlen, size_t outlen)
 {
 	int err, ret;
 
@@ -194,7 +215,7 @@ static int pstore_decompress(void *in, void *out, size_t inlen, size_t outlen)
 	return ret;
 }
 
-static void allocate_buf_for_compression(void)
+static void allocate_zlib(void)
 {
 	size_t size;
 	size_t cmpr;
@@ -237,12 +258,190 @@ static void allocate_buf_for_compression(void)
 
 }
 
-static void free_buf_for_compression(void)
+static void free_zlib(void)
 {
 	kfree(stream.workspace);
 	stream.workspace = NULL;
 	kfree(big_oops_buf);
 	big_oops_buf = NULL;
+	big_oops_buf_sz = 0;
+}
+
+static struct pstore_zbackend backend_zlib = {
+	.compress	= compress_zlib,
+	.decompress	= decompress_zlib,
+	.allocate	= allocate_zlib,
+	.free		= free_zlib,
+	.name		= "zlib",
+};
+#endif
+
+#ifdef CONFIG_PSTORE_LZO_COMPRESS
+static int compress_lzo(const void *in, void *out, size_t inlen, size_t outlen)
+{
+	int ret;
+
+	ret = lzo1x_1_compress(in, inlen, out, &outlen, workspace);
+	if (ret != LZO_E_OK) {
+		pr_err("lzo_compress error, ret = %d!\n", ret);
+		return -EIO;
+	}
+
+	return outlen;
+}
+
+static int decompress_lzo(void *in, void *out, size_t inlen, size_t outlen)
+{
+	int ret;
+
+	ret = lzo1x_decompress_safe(in, inlen, out, &outlen);
+	if (ret != LZO_E_OK) {
+		pr_err("lzo_decompress error, ret = %d!\n", ret);
+		return -EIO;
+	}
+
+	return outlen;
+}
+
+static void allocate_lzo(void)
+{
+	big_oops_buf_sz = lzo1x_worst_compress(psinfo->bufsize);
+	big_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);
+	if (big_oops_buf) {
+		workspace = kmalloc(LZO1X_MEM_COMPRESS, GFP_KERNEL);
+		if (!workspace) {
+			pr_err("No memory for compression workspace; skipping compression\n");
+			kfree(big_oops_buf);
+			big_oops_buf = NULL;
+		}
+	} else {
+		pr_err("No memory for uncompressed data; skipping compression\n");
+		workspace = NULL;
+	}
+}
+
+static void free_lzo(void)
+{
+	kfree(workspace);
+	kfree(big_oops_buf);
+	big_oops_buf = NULL;
+	big_oops_buf_sz = 0;
+}
+
+static struct pstore_zbackend backend_lzo = {
+	.compress	= compress_lzo,
+	.decompress	= decompress_lzo,
+	.allocate	= allocate_lzo,
+	.free		= free_lzo,
+	.name		= "lzo",
+};
+#endif
+
+#ifdef CONFIG_PSTORE_LZ4_COMPRESS
+static int compress_lz4(const void *in, void *out, size_t inlen, size_t outlen)
+{
+	int ret;
+
+	ret = lz4_compress(in, inlen, out, &outlen, workspace);
+	if (ret) {
+		pr_err("lz4_compress error, ret = %d!\n", ret);
+		return -EIO;
+	}
+
+	return outlen;
+}
+
+static int decompress_lz4(void *in, void *out, size_t inlen, size_t outlen)
+{
+	int ret;
+
+	ret = lz4_decompress_unknownoutputsize(in, inlen, out, &outlen);
+	if (ret) {
+		pr_err("lz4_decompress error, ret = %d!\n", ret);
+		return -EIO;
+	}
+
+	return outlen;
+}
+
+static void allocate_lz4(void)
+{
+	big_oops_buf_sz = lz4_compressbound(psinfo->bufsize);
+	big_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);
+	if (big_oops_buf) {
+		workspace = kmalloc(LZ4_MEM_COMPRESS, GFP_KERNEL);
+		if (!workspace) {
+			pr_err("No memory for compression workspace; skipping compression\n");
+			kfree(big_oops_buf);
+			big_oops_buf = NULL;
+		}
+	} else {
+		pr_err("No memory for uncompressed data; skipping compression\n");
+		workspace = NULL;
+	}
+}
+
+static void free_lz4(void)
+{
+	kfree(workspace);
+	kfree(big_oops_buf);
+	big_oops_buf = NULL;
+	big_oops_buf_sz = 0;
+}
+
+static struct pstore_zbackend backend_lz4 = {
+	.compress	= compress_lz4,
+	.decompress	= decompress_lz4,
+	.allocate	= allocate_lz4,
+	.free		= free_lz4,
+	.name		= "lz4",
+};
+#endif
+
+static struct pstore_zbackend *zbackend =
+#if defined(CONFIG_PSTORE_ZLIB_COMPRESS)
+	&backend_zlib;
+#elif defined(CONFIG_PSTORE_LZO_COMPRESS)
+	&backend_lzo;
+#elif defined(CONFIG_PSTORE_LZ4_COMPRESS)
+	&backend_lz4;
+#else
+	NULL;
+#endif
+
+static int pstore_compress(const void *in, void *out,
+			   size_t inlen, size_t outlen)
+{
+	if (zbackend)
+		return zbackend->compress(in, out, inlen, outlen);
+	else
+		return -EIO;
+}
+
+static int pstore_decompress(void *in, void *out, size_t inlen, size_t outlen)
+{
+	if (zbackend)
+		return zbackend->decompress(in, out, inlen, outlen);
+	else
+		return -EIO;
+}
+
+static void allocate_buf_for_compression(void)
+{
+	if (zbackend) {
+		pr_info("using %s compression\n", zbackend->name);
+		zbackend->allocate();
+	} else {
+		pr_err("allocate compression buffer error!\n");
+	}
+}
+
+static void free_buf_for_compression(void)
+{
+	if (zbackend)
+		zbackend->free();
+	else
+		pr_err("free compression buffer error!\n");
 }
 
 /*
@@ -522,6 +721,7 @@ void pstore_get_records(int quiet)
 	int			failed = 0, rc;
 	bool			compressed;
 	int			unzipped_len = -1;
+	ssize_t			ecc_notice_size = 0;
 
 	if (!psi)
 		return;
@@ -531,7 +731,7 @@ void pstore_get_records(int quiet)
 		goto out;
 
 	while ((size = psi->read(&id, &type, &count, &time, &buf, &compressed,
-				psi)) > 0) {
+				 &ecc_notice_size, psi)) > 0) {
 		if (compressed && (type == PSTORE_TYPE_DMESG)) {
 			if (big_oops_buf)
 				unzipped_len = pstore_decompress(buf,
@@ -539,6 +739,9 @@ void pstore_get_records(int quiet)
 							big_oops_buf_sz);
 
 			if (unzipped_len > 0) {
+				if (ecc_notice_size)
+					memcpy(big_oops_buf + unzipped_len,
+					       buf + size, ecc_notice_size);
 				kfree(buf);
 				buf = big_oops_buf;
 				size = unzipped_len;
@@ -550,7 +753,8 @@ void pstore_get_records(int quiet)
 			}
 		}
 		rc = pstore_mkfile(type, psi->name, id, count, buf,
-				  compressed, (size_t)size, time, psi);
+				   compressed, size + ecc_notice_size,
+				   time, psi);
 		if (unzipped_len < 0) {
 			/* Free buffer other than big oops */
 			kfree(buf);

commit 235f6d157d43a761052e643b8799f86fdc87b47f
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Wed May 18 21:00:06 2016 +0900

    pstore: Cleanup pstore_dump()
    
    The code is duplicate between compression is enabled or not.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index ad8ef2298047..fe41d8ec663a 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -306,19 +306,25 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		int hsize;
 		int zipped_len = -1;
 		size_t len;
-		bool compressed;
+		bool compressed = false;
 		size_t total_len;
 
 		if (big_oops_buf && is_locked) {
 			dst = big_oops_buf;
-			hsize = sprintf(dst, "%s#%d Part%u\n", why,
-							oopscount, part);
-			size = big_oops_buf_sz - hsize;
+			size = big_oops_buf_sz;
+		} else {
+			dst = psinfo->buf;
+			size = psinfo->bufsize;
+		}
 
-			if (!kmsg_dump_get_buffer(dumper, true, dst + hsize,
-								size, &len))
-				break;
+		hsize = sprintf(dst, "%s#%d Part%u\n", why, oopscount, part);
+		size -= hsize;
+
+		if (!kmsg_dump_get_buffer(dumper, true, dst + hsize,
+					  size, &len))
+			break;
 
+		if (big_oops_buf && is_locked) {
 			zipped_len = pstore_compress(dst, psinfo->buf,
 						hsize + len, psinfo->bufsize);
 
@@ -326,21 +332,9 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 				compressed = true;
 				total_len = zipped_len;
 			} else {
-				compressed = false;
 				total_len = copy_kmsg_to_buffer(hsize, len);
 			}
 		} else {
-			dst = psinfo->buf;
-			hsize = sprintf(dst, "%s#%d Part%u\n", why, oopscount,
-									part);
-			size = psinfo->bufsize - hsize;
-			dst += hsize;
-
-			if (!kmsg_dump_get_buffer(dumper, true, dst,
-								size, &len))
-				break;
-
-			compressed = false;
 			total_len = hsize + len;
 		}
 

commit 98e44fda2ea19c0e8b0a2e0e4dcd3461251f09ea
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Wed May 18 21:00:05 2016 +0900

    pstore: Enable compression on normal path (again)
    
    The commit f0e2efcfd2717 ("pstore: do not use message compression
    without lock") added a check to 'is_locked' to avoid breakage in
    concurrent accesses.  But it has a side-effect of disabling compression
    on normal path since 'is_locked' variable is not set.  As normal path
    always takes the lock, it should be initialized to 1.
    
    This also makes the unlock code a bit simpler.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index e8c17afdfb41..ad8ef2298047 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -284,7 +284,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 	u64		id;
 	unsigned int	part = 1;
 	unsigned long	flags = 0;
-	int		is_locked = 0;
+	int		is_locked;
 	int		ret;
 
 	why = get_reason_str(reason);
@@ -295,8 +295,10 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 			pr_err("pstore dump routine blocked in %s path, may corrupt error record\n"
 				       , in_nmi() ? "NMI" : why);
 		}
-	} else
+	} else {
 		spin_lock_irqsave(&psinfo->buf_lock, flags);
+		is_locked = 1;
+	}
 	oopscount++;
 	while (total < kmsg_bytes) {
 		char *dst;
@@ -350,10 +352,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		total += total_len;
 		part++;
 	}
-	if (pstore_cannot_block_path(reason)) {
-		if (is_locked)
-			spin_unlock_irqrestore(&psinfo->buf_lock, flags);
-	} else
+	if (is_locked)
 		spin_unlock_irqrestore(&psinfo->buf_lock, flags);
 }
 

commit a1db8060f5c85e33ed810038036f409eed15decc
Author: Kees Cook <keescook@chromium.org>
Date:   Thu May 19 10:59:03 2016 -0400

    ramoops: Only unregister when registered
    
    While none of the "fragile" pstore backends unregister yet, if they
    ever did, the unregistering code for the non-dump targets might get
    confused. This adds a check for fragile backends on unregister.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 588461bb2dd4..e8c17afdfb41 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -497,9 +497,11 @@ EXPORT_SYMBOL_GPL(pstore_register);
 
 void pstore_unregister(struct pstore_info *psi)
 {
-	pstore_unregister_pmsg();
-	pstore_unregister_ftrace();
-	pstore_unregister_console();
+	if ((psi->flags & PSTORE_FLAGS_FRAGILE) == 0) {
+		pstore_unregister_pmsg();
+		pstore_unregister_ftrace();
+		pstore_unregister_console();
+	}
 	pstore_unregister_kmsg();
 
 	free_buf_for_compression();

commit 306e5c2a3cb45a0256ae6677501d1144e93efa2f
Author: Geliang Tang <geliangtang@163.com>
Date:   Sat Oct 31 23:23:15 2015 +0800

    pstore: fix code comment to match code
    
    Fix code comment about kmsg_dump register so it matches the code.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 0aab920efff7..588461bb2dd4 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -361,6 +361,9 @@ static struct kmsg_dumper pstore_dumper = {
 	.dump = pstore_dump,
 };
 
+/*
+ * Register with kmsg_dump to save last part of console log on panic.
+ */
 static void pstore_register_kmsg(void)
 {
 	kmsg_dump_register(&pstore_dumper);
@@ -434,8 +437,6 @@ static int pstore_write_compat(enum pstore_type_id type,
  * read function right away to populate the file system. If not
  * then the pstore mount code will call us later to fill out
  * the file system.
- *
- * Register with kmsg_dump to save last part of console log on panic.
  */
 int pstore_register(struct pstore_info *psi)
 {

commit ee1d267423a1f8041e2b1a33fc23e4393c67677e
Author: Geliang Tang <geliangtang@163.com>
Date:   Tue Oct 20 00:39:03 2015 -0700

    pstore: add pstore unregister
    
    pstore doesn't support unregistering yet. It was marked as TODO.
    This patch adds some code to fix it:
     1) Add functions to unregister kmsg/console/ftrace/pmsg.
     2) Add a function to free compression buffer.
     3) Unmap the memory and free it.
     4) Add a function to unregister pstore filesystem.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    [Removed __exit annotation from ramoops_remove(). Reported by Arnd Bergmann]
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 1b1124942b4e..0aab920efff7 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -237,6 +237,14 @@ static void allocate_buf_for_compression(void)
 
 }
 
+static void free_buf_for_compression(void)
+{
+	kfree(stream.workspace);
+	stream.workspace = NULL;
+	kfree(big_oops_buf);
+	big_oops_buf = NULL;
+}
+
 /*
  * Called when compression fails, since the printk buffer
  * would be fetched for compression calling it again when
@@ -358,6 +366,11 @@ static void pstore_register_kmsg(void)
 	kmsg_dump_register(&pstore_dumper);
 }
 
+static void pstore_unregister_kmsg(void)
+{
+	kmsg_dump_unregister(&pstore_dumper);
+}
+
 #ifdef CONFIG_PSTORE_CONSOLE
 static void pstore_console_write(struct console *con, const char *s, unsigned c)
 {
@@ -395,8 +408,14 @@ static void pstore_register_console(void)
 {
 	register_console(&pstore_console);
 }
+
+static void pstore_unregister_console(void)
+{
+	unregister_console(&pstore_console);
+}
 #else
 static void pstore_register_console(void) {}
+static void pstore_unregister_console(void) {}
 #endif
 
 static int pstore_write_compat(enum pstore_type_id type,
@@ -467,12 +486,28 @@ int pstore_register(struct pstore_info *psi)
 	 */
 	backend = psi->name;
 
+	module_put(owner);
+
 	pr_info("Registered %s as persistent store backend\n", psi->name);
 
 	return 0;
 }
 EXPORT_SYMBOL_GPL(pstore_register);
 
+void pstore_unregister(struct pstore_info *psi)
+{
+	pstore_unregister_pmsg();
+	pstore_unregister_ftrace();
+	pstore_unregister_console();
+	pstore_unregister_kmsg();
+
+	free_buf_for_compression();
+
+	psinfo = NULL;
+	backend = NULL;
+}
+EXPORT_SYMBOL_GPL(pstore_unregister);
+
 /*
  * Read all the records from the persistent store. Create
  * files in our filesystem.  Don't warn about -EEXIST errors

commit 1873041152d2e324e25ddeec5541b90c22c2dc0f
Author: Geliang Tang <geliangtang@163.com>
Date:   Tue Oct 20 00:39:02 2015 -0700

    pstore: add a helper function pstore_register_kmsg
    
    Add a new wrapper function pstore_register_kmsg to keep the
    consistency with other similar pstore_register_* functions.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 791743deedf1..1b1124942b4e 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -353,6 +353,11 @@ static struct kmsg_dumper pstore_dumper = {
 	.dump = pstore_dump,
 };
 
+static void pstore_register_kmsg(void)
+{
+	kmsg_dump_register(&pstore_dumper);
+}
+
 #ifdef CONFIG_PSTORE_CONSOLE
 static void pstore_console_write(struct console *con, const char *s, unsigned c)
 {
@@ -442,7 +447,7 @@ int pstore_register(struct pstore_info *psi)
 	if (pstore_is_mounted())
 		pstore_get_records(0);
 
-	kmsg_dump_register(&pstore_dumper);
+	pstore_register_kmsg();
 
 	if ((psi->flags & PSTORE_FLAGS_FRAGILE) == 0) {
 		pstore_register_console();

commit 42222c2a5d5da7fe4839491d5c44034f40761071
Author: Wang Long <long.wanglong@huawei.com>
Date:   Thu May 21 09:34:22 2015 -0700

    fs/pstore: update the backend parameter in pstore module
    
    This patch update the module parameter backend, so it is visible
    through /sys/module/pstore/parameters/backend.
    
    For example:
    if pstore backend is ramoops, with this patch:
            # cat /sys/module/pstore/parameters/backend
            ramoops
    and without this patch:
            # cat /sys/module/pstore/parameters/backend
            (null)
    
    Signed-off-by: Wang Long <long.wanglong@huawei.com>
    Acked-by: Mark Salyzyn <salyzyn@android.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index de525ec0b490..791743deedf1 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -456,6 +456,12 @@ int pstore_register(struct pstore_info *psi)
 		add_timer(&pstore_timer);
 	}
 
+	/*
+	 * Update the module parameter backend, so it is visible
+	 * through /sys/module/pstore/parameters/backend
+	 */
+	backend = psi->name;
+
 	pr_info("Registered %s as persistent store backend\n", psi->name);
 
 	return 0;

commit f0e2efcfd271733119cfe499f5811968544cbe7b
Author: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
Date:   Thu May 21 09:26:19 2015 -0700

    pstore: do not use message compression without lock
    
    pstore_compress() uses static stream buffer for zlib-deflate which
    easily crashes when several concurrent threads use one shared state.
    
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index c4c9a10c5760..de525ec0b490 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -299,7 +299,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		bool compressed;
 		size_t total_len;
 
-		if (big_oops_buf) {
+		if (big_oops_buf && is_locked) {
 			dst = big_oops_buf;
 			hsize = sprintf(dst, "%s#%d Part%u\n", why,
 							oopscount, part);

commit a6b8978c54b771308f6f1692b9735ac0bb087cc2
Author: alex chen <alex.chen@huawei.com>
Date:   Fri Jan 16 15:52:03 2015 -0800

    pstore: Fix sprintf format specifier in pstore_dump()
    
    We should use sprintf format specifier "%u" instead of "%d" for
    argument of type 'unsigned int' in pstore_dump().
    
    Signed-off-by: Alex Chen <alex.chen@huawei.com>
    Reviewed-by: Joseph Qi <joseph.qi@huawei.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 15ee78c5020b..c4c9a10c5760 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -301,7 +301,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 
 		if (big_oops_buf) {
 			dst = big_oops_buf;
-			hsize = sprintf(dst, "%s#%d Part%d\n", why,
+			hsize = sprintf(dst, "%s#%d Part%u\n", why,
 							oopscount, part);
 			size = big_oops_buf_sz - hsize;
 
@@ -321,7 +321,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 			}
 		} else {
 			dst = psinfo->buf;
-			hsize = sprintf(dst, "%s#%d Part%d\n", why, oopscount,
+			hsize = sprintf(dst, "%s#%d Part%u\n", why, oopscount,
 									part);
 			size = psinfo->bufsize - hsize;
 			dst += hsize;

commit 9d5438f462abd6398cdb7b3211bdcec271873a3b
Author: Mark Salyzyn <salyzyn@android.com>
Date:   Fri Jan 16 16:01:10 2015 -0800

    pstore: Add pmsg - user-space accessible pstore object
    
    A secured user-space accessible pstore object. Writes
    to /dev/pmsg0 are appended to the buffer, on reboot
    the persistent contents are available in
    /sys/fs/pstore/pmsg-ramoops-[ID].
    
    One possible use is syslogd, or other daemon, can
    write messages, then on reboot provides a means to
    triage user-space activities leading up to a panic
    as a companion to the pstore dmesg or console logs.
    
    Signed-off-by: Mark Salyzyn <salyzyn@android.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 0a9b72cdfeca..15ee78c5020b 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -447,6 +447,7 @@ int pstore_register(struct pstore_info *psi)
 	if ((psi->flags & PSTORE_FLAGS_FRAGILE) == 0) {
 		pstore_register_console();
 		pstore_register_ftrace();
+		pstore_register_pmsg();
 	}
 
 	if (pstore_update_ms >= 0) {

commit ef74885353e0ee4d884604148628df3369c76719
Author: Fabian Frederick <fabf@skynet.be>
Date:   Fri Jun 6 14:37:31 2014 -0700

    fs/pstore: logging clean-up
    
    - Define pr_fmt in plateform.c and ram_core.c for global prefix.
    
    - Coalesce format fragments.
    
    - Separate format/arguments on lines > 80 characters.
    
    Note: Some pr_foo() were initially declared without prefix and therefore
    this could break existing log analyzer.
    
    [akpm@linux-foundation.org: missed a couple of prefix removals]
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Joe Perches <joe@perches.com>
    Cc: Anton Vorontsov <anton@enomsg.org>
    Cc: Colin Cross <ccross@android.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 46d269e38706..0a9b72cdfeca 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -18,6 +18,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#define pr_fmt(fmt) "pstore: " fmt
+
 #include <linux/atomic.h>
 #include <linux/types.h>
 #include <linux/errno.h>
@@ -224,14 +226,12 @@ static void allocate_buf_for_compression(void)
 			zlib_inflate_workspacesize());
 		stream.workspace = kmalloc(size, GFP_KERNEL);
 		if (!stream.workspace) {
-			pr_err("pstore: No memory for compression workspace; "
-				"skipping compression\n");
+			pr_err("No memory for compression workspace; skipping compression\n");
 			kfree(big_oops_buf);
 			big_oops_buf = NULL;
 		}
 	} else {
-		pr_err("No memory for uncompressed data; "
-			"skipping compression\n");
+		pr_err("No memory for uncompressed data; skipping compression\n");
 		stream.workspace = NULL;
 	}
 
@@ -455,8 +455,7 @@ int pstore_register(struct pstore_info *psi)
 		add_timer(&pstore_timer);
 	}
 
-	pr_info("pstore: Registered %s as persistent store backend\n",
-		psi->name);
+	pr_info("Registered %s as persistent store backend\n", psi->name);
 
 	return 0;
 }
@@ -502,8 +501,8 @@ void pstore_get_records(int quiet)
 				size = unzipped_len;
 				compressed = false;
 			} else {
-				pr_err("pstore: decompression failed;"
-					"returned %d\n", unzipped_len);
+				pr_err("decompression failed;returned %d\n",
+				       unzipped_len);
 				compressed = true;
 			}
 		}
@@ -524,8 +523,8 @@ void pstore_get_records(int quiet)
 	mutex_unlock(&psi->read_mutex);
 
 	if (failed)
-		printk(KERN_WARNING "pstore: failed to load %d record(s) from '%s'\n",
-		       failed, psi->name);
+		pr_warn("failed to load %d record(s) from '%s'\n",
+			failed, psi->name);
 }
 
 static void pstore_dowork(struct work_struct *work)

commit e32634f5d57f1dce88624b70a6d625915f6ea09e
Author: Liu ShuoX <shuox.liu@intel.com>
Date:   Wed Mar 12 21:34:06 2014 +0800

    pstore: Fix memory leak when decompress using big_oops_buf
    
    After sucessful decompressing, the buffer which pointed by 'buf' will be
    lost as 'buf' is overwrite by 'big_oops_buf' and will never be freed.
    
    Signed-off-by: Liu ShuoX <shuox.liu@intel.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 78c3c2097787..46d269e38706 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -497,6 +497,7 @@ void pstore_get_records(int quiet)
 							big_oops_buf_sz);
 
 			if (unzipped_len > 0) {
+				kfree(buf);
 				buf = big_oops_buf;
 				size = unzipped_len;
 				compressed = false;

commit df36ac1bc2a166eef90785d584e4cfed6f52bd32
Author: Luck, Tony <tony.luck@intel.com>
Date:   Wed Dec 18 15:17:10 2013 -0800

    pstore: Don't allow high traffic options on fragile devices
    
    Some pstore backing devices use on board flash as persistent
    storage. These have limited numbers of write cycles so it
    is a poor idea to use them from high frequency operations.
    
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index b8e93a40a5d3..78c3c2097787 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -443,8 +443,11 @@ int pstore_register(struct pstore_info *psi)
 		pstore_get_records(0);
 
 	kmsg_dump_register(&pstore_dumper);
-	pstore_register_console();
-	pstore_register_ftrace();
+
+	if ((psi->flags & PSTORE_FLAGS_FRAGILE) == 0) {
+		pstore_register_console();
+		pstore_register_ftrace();
+	}
 
 	if (pstore_update_ms >= 0) {
 		pstore_timer.expires = jiffies +

commit 802e4c6f5887205eda110c6bfb90c9bfa93dc8a7
Author: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
Date:   Wed Sep 11 10:58:23 2013 -0700

    pstore: Remove the messages related to compression failure
    
    Remove the messages indicating compression failure as it will
    add to the space during panic path.
    
    Reported-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Tested-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Signed-off-by: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index c853e05cd7f6..b8e93a40a5d3 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -316,10 +316,6 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 				compressed = true;
 				total_len = zipped_len;
 			} else {
-				pr_err("pstore: compression failed for Part %d"
-					" returned %d\n", part, zipped_len);
-				pr_err("pstore: Capture uncompressed"
-					" oops/panic report of Part %d\n", part);
 				compressed = false;
 				total_len = copy_kmsg_to_buffer(hsize, len);
 			}

commit b61edf8e7cf9d8d450b65588b2ff40dfb8c2fd9b
Author: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
Date:   Wed Sep 11 10:58:03 2013 -0700

    pstore: Use zlib_inflateInit2 instead of zlib_inflateInit
    
    Since zlib_deflateInit2() is used for specifying window bit during compression,
    zlib_inflateInit2() is appropriate for decompression.
    
    Reported-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Tested-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Signed-off-by: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 57b4219398cd..c853e05cd7f6 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -168,7 +168,7 @@ static int pstore_decompress(void *in, void *out, size_t inlen, size_t outlen)
 	int err, ret;
 
 	ret = -EIO;
-	err = zlib_inflateInit(&stream);
+	err = zlib_inflateInit2(&stream, WINDOW_BITS);
 	if (err != Z_OK)
 		goto error;
 

commit 7de8fe2fa8f94985a83120f04d41a93425ea66ba
Author: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
Date:   Wed Sep 11 10:57:41 2013 -0700

    pstore: Adjust buffer size for compression for smaller registered buffers
    
    When backends (ex: efivars) have smaller registered buffers, the
    big_oops_buf is too big for them as number of repeated occurences
    in the text captured will be less. What happens is that pstore takes
    too big a bite from the dmesg log and then finds it cannot compress it
    enough to meet the backend block size. Patch takes care of adjusting
    the buffer size based on the registered buffer size. cmpr values have
    been arrived after doing experiments with plain text for buffers of
    size 1k - 4k (Smaller the buffer size repeated occurence will be less)
    and with sample crash log for buffers ranging from 4k - 10k.
    
    Reported-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Tested-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Signed-off-by: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 4ffb7ab5e397..57b4219398cd 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -195,8 +195,29 @@ static int pstore_decompress(void *in, void *out, size_t inlen, size_t outlen)
 static void allocate_buf_for_compression(void)
 {
 	size_t size;
+	size_t cmpr;
+
+	switch (psinfo->bufsize) {
+	/* buffer range for efivars */
+	case 1000 ... 2000:
+		cmpr = 56;
+		break;
+	case 2001 ... 3000:
+		cmpr = 54;
+		break;
+	case 3001 ... 3999:
+		cmpr = 52;
+		break;
+	/* buffer range for nvram, erst */
+	case 4000 ... 10000:
+		cmpr = 45;
+		break;
+	default:
+		cmpr = 60;
+		break;
+	}
 
-	big_oops_buf_sz = (psinfo->bufsize * 100) / 45;
+	big_oops_buf_sz = (psinfo->bufsize * 100) / cmpr;
 	big_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);
 	if (big_oops_buf) {
 		size = max(zlib_deflate_workspacesize(WINDOW_BITS, MEM_LEVEL),

commit 9ad2cbe0a9b88ee6ee895d03b2c63fa1252c8e52
Author: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
Date:   Fri Aug 16 13:53:39 2013 -0700

    pstore: Add file extension to pstore file if compressed
    
    In case decompression fails, add a ".enc.z" to indicate the file has
    compressed data. This will help user space utilities to figure
    out the file contents.
    
    Signed-off-by: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 76bc5c12c0cf..4ffb7ab5e397 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -479,13 +479,15 @@ void pstore_get_records(int quiet)
 			if (unzipped_len > 0) {
 				buf = big_oops_buf;
 				size = unzipped_len;
+				compressed = false;
 			} else {
 				pr_err("pstore: decompression failed;"
 					"returned %d\n", unzipped_len);
+				compressed = true;
 			}
 		}
 		rc = pstore_mkfile(type, psi->name, id, count, buf,
-				  (size_t)size, time, psi);
+				  compressed, (size_t)size, time, psi);
 		if (unzipped_len < 0) {
 			/* Free buffer other than big oops */
 			kfree(buf);

commit adb42f5e105502aff2fc4518b16ba79c203fae4f
Author: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
Date:   Fri Aug 16 13:53:28 2013 -0700

    pstore: Add decompression support to pstore
    
    Based on the flag 'compressed' set or not, pstore will decompress the
    data returning a plain text file. If decompression fails for a particular
    record it will have the compressed data in the file which can be
    decompressed with 'openssl' command line tool.
    
    Signed-off-by: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 6418eb77d64b..76bc5c12c0cf 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -162,6 +162,36 @@ static int pstore_compress(const void *in, void *out, size_t inlen,
 	return ret;
 }
 
+/* Derived from logfs_uncompress */
+static int pstore_decompress(void *in, void *out, size_t inlen, size_t outlen)
+{
+	int err, ret;
+
+	ret = -EIO;
+	err = zlib_inflateInit(&stream);
+	if (err != Z_OK)
+		goto error;
+
+	stream.next_in = in;
+	stream.avail_in = inlen;
+	stream.total_in = 0;
+	stream.next_out = out;
+	stream.avail_out = outlen;
+	stream.total_out = 0;
+
+	err = zlib_inflate(&stream, Z_FINISH);
+	if (err != Z_STREAM_END)
+		goto error;
+
+	err = zlib_inflateEnd(&stream);
+	if (err != Z_OK)
+		goto error;
+
+	ret = stream.total_out;
+error:
+	return ret;
+}
+
 static void allocate_buf_for_compression(void)
 {
 	size_t size;
@@ -429,6 +459,7 @@ void pstore_get_records(int quiet)
 	struct timespec		time;
 	int			failed = 0, rc;
 	bool			compressed;
+	int			unzipped_len = -1;
 
 	if (!psi)
 		return;
@@ -439,10 +470,28 @@ void pstore_get_records(int quiet)
 
 	while ((size = psi->read(&id, &type, &count, &time, &buf, &compressed,
 				psi)) > 0) {
+		if (compressed && (type == PSTORE_TYPE_DMESG)) {
+			if (big_oops_buf)
+				unzipped_len = pstore_decompress(buf,
+							big_oops_buf, size,
+							big_oops_buf_sz);
+
+			if (unzipped_len > 0) {
+				buf = big_oops_buf;
+				size = unzipped_len;
+			} else {
+				pr_err("pstore: decompression failed;"
+					"returned %d\n", unzipped_len);
+			}
+		}
 		rc = pstore_mkfile(type, psi->name, id, count, buf,
 				  (size_t)size, time, psi);
-		kfree(buf);
-		buf = NULL;
+		if (unzipped_len < 0) {
+			/* Free buffer other than big oops */
+			kfree(buf);
+			buf = NULL;
+		} else
+			unzipped_len = -1;
 		if (rc && (rc != -EEXIST || !quiet))
 			failed++;
 	}

commit 9a4e1398208d147a9240731a1f8cfe7d8cc4c553
Author: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
Date:   Fri Aug 16 13:53:19 2013 -0700

    pstore: Introduce new argument 'compressed' in the read callback
    
    Backends will set the flag 'compressed' after reading the log from
    persistent store to indicate the data being returned to pstore is
    compressed or not.
    
    Signed-off-by: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 56218cb35267..6418eb77d64b 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -428,6 +428,7 @@ void pstore_get_records(int quiet)
 	enum pstore_type_id	type;
 	struct timespec		time;
 	int			failed = 0, rc;
+	bool			compressed;
 
 	if (!psi)
 		return;
@@ -436,7 +437,8 @@ void pstore_get_records(int quiet)
 	if (psi->open && psi->open(psi))
 		goto out;
 
-	while ((size = psi->read(&id, &type, &count, &time, &buf, psi)) > 0) {
+	while ((size = psi->read(&id, &type, &count, &time, &buf, &compressed,
+				psi)) > 0) {
 		rc = pstore_mkfile(type, psi->name, id, count, buf,
 				  (size_t)size, time, psi);
 		kfree(buf);

commit b0aad7a99c1df90c23ff4bac76eea9cf25049e9e
Author: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
Date:   Fri Aug 16 13:53:10 2013 -0700

    pstore: Add compression support to pstore
    
    Add compression support to pstore which will help in capturing more data.
    Initially, pstore will make a call to kmsg_dump with a bigger buffer
    and will pass the size of bigger buffer to kmsg_dump and then compress
    the data to registered buffer of registered size.
    
    In case compression fails, pstore will capture the uncompressed
    data by making a call again to kmsg_dump with registered_buffer
    of registered size.
    
    Pstore will indicate the data is compressed or not with a flag
    in the write callback.
    
    Signed-off-by: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 20fa686f80fa..56218cb35267 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -26,6 +26,7 @@
 #include <linux/console.h>
 #include <linux/module.h>
 #include <linux/pstore.h>
+#include <linux/zlib.h>
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/slab.h>
@@ -65,6 +66,15 @@ struct pstore_info *psinfo;
 
 static char *backend;
 
+/* Compression parameters */
+#define COMPR_LEVEL 6
+#define WINDOW_BITS 12
+#define MEM_LEVEL 4
+static struct z_stream_s stream;
+
+static char *big_oops_buf;
+static size_t big_oops_buf_sz;
+
 /* How much of the console log to snapshot */
 static unsigned long kmsg_bytes = 10240;
 
@@ -117,6 +127,91 @@ bool pstore_cannot_block_path(enum kmsg_dump_reason reason)
 }
 EXPORT_SYMBOL_GPL(pstore_cannot_block_path);
 
+/* Derived from logfs_compress() */
+static int pstore_compress(const void *in, void *out, size_t inlen,
+							size_t outlen)
+{
+	int err, ret;
+
+	ret = -EIO;
+	err = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,
+						MEM_LEVEL, Z_DEFAULT_STRATEGY);
+	if (err != Z_OK)
+		goto error;
+
+	stream.next_in = in;
+	stream.avail_in = inlen;
+	stream.total_in = 0;
+	stream.next_out = out;
+	stream.avail_out = outlen;
+	stream.total_out = 0;
+
+	err = zlib_deflate(&stream, Z_FINISH);
+	if (err != Z_STREAM_END)
+		goto error;
+
+	err = zlib_deflateEnd(&stream);
+	if (err != Z_OK)
+		goto error;
+
+	if (stream.total_out >= stream.total_in)
+		goto error;
+
+	ret = stream.total_out;
+error:
+	return ret;
+}
+
+static void allocate_buf_for_compression(void)
+{
+	size_t size;
+
+	big_oops_buf_sz = (psinfo->bufsize * 100) / 45;
+	big_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);
+	if (big_oops_buf) {
+		size = max(zlib_deflate_workspacesize(WINDOW_BITS, MEM_LEVEL),
+			zlib_inflate_workspacesize());
+		stream.workspace = kmalloc(size, GFP_KERNEL);
+		if (!stream.workspace) {
+			pr_err("pstore: No memory for compression workspace; "
+				"skipping compression\n");
+			kfree(big_oops_buf);
+			big_oops_buf = NULL;
+		}
+	} else {
+		pr_err("No memory for uncompressed data; "
+			"skipping compression\n");
+		stream.workspace = NULL;
+	}
+
+}
+
+/*
+ * Called when compression fails, since the printk buffer
+ * would be fetched for compression calling it again when
+ * compression fails would have moved the iterator of
+ * printk buffer which results in fetching old contents.
+ * Copy the recent messages from big_oops_buf to psinfo->buf
+ */
+static size_t copy_kmsg_to_buffer(int hsize, size_t len)
+{
+	size_t total_len;
+	size_t diff;
+
+	total_len = hsize + len;
+
+	if (total_len > psinfo->bufsize) {
+		diff = total_len - psinfo->bufsize + hsize;
+		memcpy(psinfo->buf, big_oops_buf, hsize);
+		memcpy(psinfo->buf + hsize, big_oops_buf + diff,
+					psinfo->bufsize - hsize);
+		total_len = psinfo->bufsize;
+	} else
+		memcpy(psinfo->buf, big_oops_buf, total_len);
+
+	return total_len;
+}
+
 /*
  * callback from kmsg_dump. (s2,l2) has the most recently
  * written bytes, older bytes are in (s1,l1). Save as much
@@ -148,23 +243,56 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		char *dst;
 		unsigned long size;
 		int hsize;
+		int zipped_len = -1;
 		size_t len;
-		bool compressed = false;
+		bool compressed;
+		size_t total_len;
 
-		dst = psinfo->buf;
-		hsize = sprintf(dst, "%s#%d Part%d\n", why, oopscount, part);
-		size = psinfo->bufsize - hsize;
-		dst += hsize;
+		if (big_oops_buf) {
+			dst = big_oops_buf;
+			hsize = sprintf(dst, "%s#%d Part%d\n", why,
+							oopscount, part);
+			size = big_oops_buf_sz - hsize;
 
-		if (!kmsg_dump_get_buffer(dumper, true, dst, size, &len))
-			break;
+			if (!kmsg_dump_get_buffer(dumper, true, dst + hsize,
+								size, &len))
+				break;
+
+			zipped_len = pstore_compress(dst, psinfo->buf,
+						hsize + len, psinfo->bufsize);
+
+			if (zipped_len > 0) {
+				compressed = true;
+				total_len = zipped_len;
+			} else {
+				pr_err("pstore: compression failed for Part %d"
+					" returned %d\n", part, zipped_len);
+				pr_err("pstore: Capture uncompressed"
+					" oops/panic report of Part %d\n", part);
+				compressed = false;
+				total_len = copy_kmsg_to_buffer(hsize, len);
+			}
+		} else {
+			dst = psinfo->buf;
+			hsize = sprintf(dst, "%s#%d Part%d\n", why, oopscount,
+									part);
+			size = psinfo->bufsize - hsize;
+			dst += hsize;
+
+			if (!kmsg_dump_get_buffer(dumper, true, dst,
+								size, &len))
+				break;
+
+			compressed = false;
+			total_len = hsize + len;
+		}
 
 		ret = psinfo->write(PSTORE_TYPE_DMESG, reason, &id, part,
-				    oopscount, compressed, hsize + len, psinfo);
+				    oopscount, compressed, total_len, psinfo);
 		if (ret == 0 && reason == KMSG_DUMP_OOPS && pstore_is_mounted())
 			pstore_new_entry = 1;
 
-		total += hsize + len;
+		total += total_len;
 		part++;
 	}
 	if (pstore_cannot_block_path(reason)) {
@@ -262,6 +390,8 @@ int pstore_register(struct pstore_info *psi)
 		return -EINVAL;
 	}
 
+	allocate_buf_for_compression();
+
 	if (pstore_is_mounted())
 		pstore_get_records(0);
 

commit b3b515bbd689ba3937cac2dd3fc55057f8c50329
Author: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
Date:   Fri Aug 16 13:52:47 2013 -0700

    pstore: Add new argument 'compressed' in pstore write callback
    
    Addition of new argument 'compressed' in the write call back will
    help the backend to know if the data passed from pstore is compressed
    or not (In case where compression fails.). If compressed, the backend
    can add a tag indicating the data is compressed while writing to
    persistent store.
    
    Signed-off-by: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 422962ae9fc2..20fa686f80fa 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -149,6 +149,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		unsigned long size;
 		int hsize;
 		size_t len;
+		bool compressed = false;
 
 		dst = psinfo->buf;
 		hsize = sprintf(dst, "%s#%d Part%d\n", why, oopscount, part);
@@ -159,7 +160,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 			break;
 
 		ret = psinfo->write(PSTORE_TYPE_DMESG, reason, &id, part,
-				    oopscount, hsize, hsize + len, psinfo);
+				    oopscount, compressed, hsize + len, psinfo);
 		if (ret == 0 && reason == KMSG_DUMP_OOPS && pstore_is_mounted())
 			pstore_new_entry = 1;
 
@@ -221,10 +222,10 @@ static void pstore_register_console(void) {}
 static int pstore_write_compat(enum pstore_type_id type,
 			       enum kmsg_dump_reason reason,
 			       u64 *id, unsigned int part, int count,
-			       size_t hsize, size_t size,
+			       bool compressed, size_t size,
 			       struct pstore_info *psi)
 {
-	return psi->write_buf(type, reason, id, part, psinfo->buf, hsize,
+	return psi->write_buf(type, reason, id, part, psinfo->buf, compressed,
 			     size, psi);
 }
 

commit 65b97fb7303050fc826e518cf67fc283da23314f
Merge: ddcf6600b133 1d8b368ab4aa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 4 10:29:23 2013 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc
    
    Pull powerpc updates from Ben Herrenschmidt:
     "This is the powerpc changes for the 3.11 merge window.  In addition to
      the usual bug fixes and small updates, the main highlights are:
    
       - Support for transparent huge pages by Aneesh Kumar for 64-bit
         server processors.  This allows the use of 16M pages as transparent
         huge pages on kernels compiled with a 64K base page size.
    
       - Base VFIO support for KVM on power by Alexey Kardashevskiy
    
       - Wiring up of our nvram to the pstore infrastructure, including
         putting compressed oopses in there by Aruna Balakrishnaiah
    
       - Move, rework and improve our "EEH" (basically PCI error handling
         and recovery) infrastructure.  It is no longer specific to pseries
         but is now usable by the new "powernv" platform as well (no
         hypervisor) by Gavin Shan.
    
       - I fixed some bugs in our math-emu instruction decoding and made it
         usable to emulate some optional FP instructions on processors with
         hard FP that lack them (such as fsqrt on Freescale embedded
         processors).
    
       - Support for Power8 "Event Based Branch" facility by Michael
         Ellerman.  This facility allows what is basically "userspace
         interrupts" for performance monitor events.
    
       - A bunch of Transactional Memory vs.  Signals bug fixes and HW
         breakpoint/watchpoint fixes by Michael Neuling.
    
      And more ...  I appologize in advance if I've failed to highlight
      something that somebody deemed worth it."
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc: (156 commits)
      pstore: Add hsize argument in write_buf call of pstore_ftrace_call
      powerpc/fsl: add MPIC timer wakeup support
      powerpc/mpic: create mpic subsystem object
      powerpc/mpic: add global timer support
      powerpc/mpic: add irq_set_wake support
      powerpc/85xx: enable coreint for all the 64bit boards
      powerpc/8xx: Erroneous double irq_eoi() on CPM IRQ in MPC8xx
      powerpc/fsl: Enable CONFIG_E1000E in mpc85xx_smp_defconfig
      powerpc/mpic: Add get_version API both for internal and external use
      powerpc: Handle both new style and old style reserve maps
      powerpc/hw_brk: Fix off by one error when validating DAWR region end
      powerpc/pseries: Support compression of oops text via pstore
      powerpc/pseries: Re-organise the oops compression code
      pstore: Pass header size in the pstore write callback
      powerpc/powernv: Fix iommu initialization again
      powerpc/pseries: Inform the hypervisor we are using EBB regs
      powerpc/perf: Add power8 EBB support
      powerpc/perf: Core EBB support for 64-bit book3s
      powerpc/perf: Drop MMCRA from thread_struct
      powerpc/perf: Don't enable if we have zero events
      ...

commit 6bbbca735936e15b9431882eceddcf6dff76e03c
Author: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
Date:   Thu Jun 27 14:02:56 2013 +0530

    pstore: Pass header size in the pstore write callback
    
    Header size is needed to distinguish between header and the dump data.
    Incorporate the addition of new argument (hsize) in the pstore write
    callback.
    
    Signed-off-by: Aruna Balakrishnaiah <aruna@linux.vnet.ibm.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 86d1038b5a12..4637ec4169cd 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -159,7 +159,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 			break;
 
 		ret = psinfo->write(PSTORE_TYPE_DMESG, reason, &id, part,
-				    oopscount, hsize + len, psinfo);
+				    oopscount, hsize, hsize + len, psinfo);
 		if (ret == 0 && reason == KMSG_DUMP_OOPS && pstore_is_mounted())
 			pstore_new_entry = 1;
 
@@ -196,7 +196,7 @@ static void pstore_console_write(struct console *con, const char *s, unsigned c)
 			spin_lock_irqsave(&psinfo->buf_lock, flags);
 		}
 		memcpy(psinfo->buf, s, c);
-		psinfo->write(PSTORE_TYPE_CONSOLE, 0, &id, 0, 0, c, psinfo);
+		psinfo->write(PSTORE_TYPE_CONSOLE, 0, &id, 0, 0, 0, c, psinfo);
 		spin_unlock_irqrestore(&psinfo->buf_lock, flags);
 		s += c;
 		c = e - s;
@@ -221,9 +221,11 @@ static void pstore_register_console(void) {}
 static int pstore_write_compat(enum pstore_type_id type,
 			       enum kmsg_dump_reason reason,
 			       u64 *id, unsigned int part, int count,
-			       size_t size, struct pstore_info *psi)
+			       size_t hsize, size_t size,
+			       struct pstore_info *psi)
 {
-	return psi->write_buf(type, reason, id, part, psinfo->buf, size, psi);
+	return psi->write_buf(type, reason, id, part, psinfo->buf, hsize,
+			     size, psi);
 }
 
 /*

commit 8e48b1a8ed58595c40f2748c0f2da55b04da2dd6
Author: Lenny Szubowicz <lszubowi@redhat.com>
Date:   Fri Jun 28 17:11:33 2013 -0400

    pstore: Return unique error if backend registration excluded by kernel param
    
    This is patch 1/3 of a patch set that avoids what misleadingly appears
    to be a error during boot:
    
    ERST: Could not register with persistent store
    
    This message is displayed if the system has a valid ACPI ERST table and the
    pstore.backend kernel parameter has been used to disable use of ERST by
    pstore. But this same message is used for errors that preclude registration.
    
    As part of fixing this, return a unique error status from pstore_register
    if the pstore.backend kernel parameter selects a specific facility other
    than the requesting facility and check for this condition before any others.
    This allows the caller to distinquish this benign case from the other failure
    cases.
    
    Also, print an informational console message about which facility
    successfully registered as the pstore backend. Since there are various
    kernel parameters, config build options, and boot-time errors that can
    influence which facility registers with pstore, it's useful to have a
    positive indication.
    
    Signed-off-by: Lenny Szubowicz <lszubowi@redhat.com>
    Reported-by: Naotaka Hamaguchi <n.hamaguchi@jp.fujitsu.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 86d1038b5a12..b7ffe2bcd9c4 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -239,17 +239,15 @@ int pstore_register(struct pstore_info *psi)
 {
 	struct module *owner = psi->owner;
 
+	if (backend && strcmp(backend, psi->name))
+		return -EPERM;
+
 	spin_lock(&pstore_lock);
 	if (psinfo) {
 		spin_unlock(&pstore_lock);
 		return -EBUSY;
 	}
 
-	if (backend && strcmp(backend, psi->name)) {
-		spin_unlock(&pstore_lock);
-		return -EINVAL;
-	}
-
 	if (!psi->write)
 		psi->write = pstore_write_compat;
 	psinfo = psi;
@@ -274,6 +272,9 @@ int pstore_register(struct pstore_info *psi)
 		add_timer(&pstore_timer);
 	}
 
+	pr_info("pstore: Registered %s as persistent store backend\n",
+		psi->name);
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(pstore_register);

commit 9f244e9cfd70c7c0f82d3c92ce772ab2a92d9f64
Author: Seiji Aguchi <seiji.aguchi@hds.com>
Date:   Fri Jan 11 18:09:41 2013 +0000

    pstore: Avoid deadlock in panic and emergency-restart path
    
    [Issue]
    
    When pstore is in panic and emergency-restart paths, it may be blocked
    in those paths because it simply takes spin_lock.
    
    This is an example scenario which pstore may hang up in a panic path:
    
     - cpuA grabs psinfo->buf_lock
     - cpuB panics and calls smp_send_stop
     - smp_send_stop sends IRQ to cpuA
     - after 1 second, cpuB gives up on cpuA and sends an NMI instead
     - cpuA is now in an NMI handler while still holding buf_lock
     - cpuB is deadlocked
    
    This case may happen if a firmware has a bug and
    cpuA is stuck talking with it more than one second.
    
    Also, this is a similar scenario in an emergency-restart path:
    
     - cpuA grabs psinfo->buf_lock and stucks in a firmware
     - cpuB kicks emergency-restart via either sysrq-b or hangcheck timer.
       And then, cpuB is deadlocked by taking psinfo->buf_lock again.
    
    [Solution]
    
    This patch avoids the deadlocking issues in both panic and emergency_restart
    paths by introducing a function, is_non_blocking_path(), to check if a cpu
    can be blocked in current path.
    
    With this patch, pstore is not blocked even if another cpu has
    taken a spin_lock, in those paths by changing from spin_lock_irqsave
    to spin_trylock_irqsave.
    
    In addition, according to a comment of emergency_restart() in kernel/sys.c,
    spin_lock shouldn't be taken in an emergency_restart path to avoid
    deadlock. This patch fits the comment below.
    
    <snip>
    /**
     *      emergency_restart - reboot the system
     *
     *      Without shutting down any hardware or taking any locks
     *      reboot the system.  This is called when we know we are in
     *      trouble so this is our best effort to reboot.  This is
     *      safe to call in interrupt context.
     */
    void emergency_restart(void)
    <snip>
    
    Signed-off-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Acked-by: Don Zickus <dzickus@redhat.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 5ea2e77ff023..86d1038b5a12 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -96,6 +96,27 @@ static const char *get_reason_str(enum kmsg_dump_reason reason)
 	}
 }
 
+bool pstore_cannot_block_path(enum kmsg_dump_reason reason)
+{
+	/*
+	 * In case of NMI path, pstore shouldn't be blocked
+	 * regardless of reason.
+	 */
+	if (in_nmi())
+		return true;
+
+	switch (reason) {
+	/* In panic case, other cpus are stopped by smp_send_stop(). */
+	case KMSG_DUMP_PANIC:
+	/* Emergency restart shouldn't be blocked by spin lock. */
+	case KMSG_DUMP_EMERG:
+		return true;
+	default:
+		return false;
+	}
+}
+EXPORT_SYMBOL_GPL(pstore_cannot_block_path);
+
 /*
  * callback from kmsg_dump. (s2,l2) has the most recently
  * written bytes, older bytes are in (s1,l1). Save as much
@@ -114,10 +135,12 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 
 	why = get_reason_str(reason);
 
-	if (in_nmi()) {
-		is_locked = spin_trylock(&psinfo->buf_lock);
-		if (!is_locked)
-			pr_err("pstore dump routine blocked in NMI, may corrupt error record\n");
+	if (pstore_cannot_block_path(reason)) {
+		is_locked = spin_trylock_irqsave(&psinfo->buf_lock, flags);
+		if (!is_locked) {
+			pr_err("pstore dump routine blocked in %s path, may corrupt error record\n"
+				       , in_nmi() ? "NMI" : why);
+		}
 	} else
 		spin_lock_irqsave(&psinfo->buf_lock, flags);
 	oopscount++;
@@ -143,9 +166,9 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		total += hsize + len;
 		part++;
 	}
-	if (in_nmi()) {
+	if (pstore_cannot_block_path(reason)) {
 		if (is_locked)
-			spin_unlock(&psinfo->buf_lock);
+			spin_unlock_irqrestore(&psinfo->buf_lock, flags);
 	} else
 		spin_unlock_irqrestore(&psinfo->buf_lock, flags);
 }

commit 755d4fe46529018ae45bc7c86df682de45ace764
Author: Seiji Aguchi <seiji.aguchi@hds.com>
Date:   Mon Nov 26 16:07:44 2012 -0800

    efi_pstore: Add a sequence counter to a variable name
    
    [Issue]
    
    Currently, a variable name, which identifies each entry, consists of type, id and ctime.
    But if multiple events happens in a short time, a second/third event may fail to log because
    efi_pstore can't distinguish each event with current variable name.
    
    [Solution]
    
    A reasonable way to identify all events precisely is introducing a sequence counter to
    the variable name.
    
    The sequence counter has already supported in a pstore layer with "oopscount".
    So, this patch adds it to a variable name.
    Also, it is passed to read/erase callbacks of platform drivers in accordance with
    the modification of the variable name.
    
      <before applying this patch>
     a variable name of first event: dump-type0-1-12345678
     a variable name of second event: dump-type0-1-12345678
    
      type:0
      id:1
      ctime:12345678
    
     If multiple events happen in a short time, efi_pstore can't distinguish them because
     variable names are same among them.
    
      <after applying this patch>
    
     it can be distinguishable by adding a sequence counter as follows.
    
     a variable name of first event: dump-type0-1-1-12345678
     a variable name of Second event: dump-type0-1-2-12345678
    
      type:0
      id:1
      sequence counter: 1(first event), 2(second event)
      ctime:12345678
    
    In case of a write callback executed in pstore_console_write(), "0" is added to
    an argument of the write callback because it just logs all kernel messages and
    doesn't need to care about multiple events.
    
    Signed-off-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Mike Waychison <mikew@google.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 947fbe06c3b1..5ea2e77ff023 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -136,7 +136,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 			break;
 
 		ret = psinfo->write(PSTORE_TYPE_DMESG, reason, &id, part,
-				    hsize + len, psinfo);
+				    oopscount, hsize + len, psinfo);
 		if (ret == 0 && reason == KMSG_DUMP_OOPS && pstore_is_mounted())
 			pstore_new_entry = 1;
 
@@ -173,7 +173,7 @@ static void pstore_console_write(struct console *con, const char *s, unsigned c)
 			spin_lock_irqsave(&psinfo->buf_lock, flags);
 		}
 		memcpy(psinfo->buf, s, c);
-		psinfo->write(PSTORE_TYPE_CONSOLE, 0, &id, 0, c, psinfo);
+		psinfo->write(PSTORE_TYPE_CONSOLE, 0, &id, 0, 0, c, psinfo);
 		spin_unlock_irqrestore(&psinfo->buf_lock, flags);
 		s += c;
 		c = e - s;
@@ -197,7 +197,7 @@ static void pstore_register_console(void) {}
 
 static int pstore_write_compat(enum pstore_type_id type,
 			       enum kmsg_dump_reason reason,
-			       u64 *id, unsigned int part,
+			       u64 *id, unsigned int part, int count,
 			       size_t size, struct pstore_info *psi)
 {
 	return psi->write_buf(type, reason, id, part, psinfo->buf, size, psi);
@@ -267,6 +267,7 @@ void pstore_get_records(int quiet)
 	char			*buf = NULL;
 	ssize_t			size;
 	u64			id;
+	int			count;
 	enum pstore_type_id	type;
 	struct timespec		time;
 	int			failed = 0, rc;
@@ -278,9 +279,9 @@ void pstore_get_records(int quiet)
 	if (psi->open && psi->open(psi))
 		goto out;
 
-	while ((size = psi->read(&id, &type, &time, &buf, psi)) > 0) {
-		rc = pstore_mkfile(type, psi->name, id, buf, (size_t)size,
-				  time, psi);
+	while ((size = psi->read(&id, &type, &count, &time, &buf, psi)) > 0) {
+		rc = pstore_mkfile(type, psi->name, id, count, buf,
+				  (size_t)size, time, psi);
 		kfree(buf);
 		buf = NULL;
 		if (rc && (rc != -EEXIST || !quiet))

commit 70a6f46d7b0ec03653b9ab3f8063a9717a4a53ef
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Nov 14 11:49:53 2012 +0000

    pstore: Fix NULL pointer dereference in console writes
    
    Passing a NULL id causes a NULL pointer deference in writers such as
    erst_writer and efi_pstore_write because they expect to update this id.
    Pass a dummy id instead.
    
    This avoids a cascade of oopses caused when the initial
    pstore_console_write passes a null which in turn causes writes to the
    console causing further oopses in subsequent pstore_console_write calls.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index a40da07e93d6..947fbe06c3b1 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -161,6 +161,7 @@ static void pstore_console_write(struct console *con, const char *s, unsigned c)
 
 	while (s < e) {
 		unsigned long flags;
+		u64 id;
 
 		if (c > psinfo->bufsize)
 			c = psinfo->bufsize;
@@ -172,7 +173,7 @@ static void pstore_console_write(struct console *con, const char *s, unsigned c)
 			spin_lock_irqsave(&psinfo->buf_lock, flags);
 		}
 		memcpy(psinfo->buf, s, c);
-		psinfo->write(PSTORE_TYPE_CONSOLE, 0, NULL, 0, c, psinfo);
+		psinfo->write(PSTORE_TYPE_CONSOLE, 0, &id, 0, c, psinfo);
 		spin_unlock_irqrestore(&psinfo->buf_lock, flags);
 		s += c;
 		c = e - s;

commit 80c9d03c22f13a17df67b4b99a83ed5e9acf6093
Author: Chuansheng Liu <chuansheng.liu@intel.com>
Date:   Tue Sep 18 01:43:44 2012 +0800

    pstore: Avoid recursive spinlocks in the oops_in_progress case
    
    Like 8250 driver, when pstore is registered as a console,
    to avoid recursive spinlocks when panic happening, change the
    spin_lock_irqsave to spin_trylock_irqsave when oops_in_progress
    is true.
    
    Signed-off-by: liu chuansheng <chuansheng.liu@intel.com>
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 6c23eab7f76c..a40da07e93d6 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -164,7 +164,13 @@ static void pstore_console_write(struct console *con, const char *s, unsigned c)
 
 		if (c > psinfo->bufsize)
 			c = psinfo->bufsize;
-		spin_lock_irqsave(&psinfo->buf_lock, flags);
+
+		if (oops_in_progress) {
+			if (!spin_trylock_irqsave(&psinfo->buf_lock, flags))
+				break;
+		} else {
+			spin_lock_irqsave(&psinfo->buf_lock, flags);
+		}
 		memcpy(psinfo->buf, s, c);
 		psinfo->write(PSTORE_TYPE_CONSOLE, 0, NULL, 0, c, psinfo);
 		spin_unlock_irqrestore(&psinfo->buf_lock, flags);

commit 65f8c95e46a1827ae8bbc52a817ea308dd7d65ae
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Tue Jul 17 14:26:15 2012 -0700

    pstore/ftrace: Convert to its own enable/disable debugfs knob
    
    With this patch we no longer reuse function tracer infrastructure, now
    we register our own tracer back-end via a debugfs knob.
    
    It's a bit more code, but that is the only downside. On the bright side we
    have:
    
    - Ability to make persistent_ram module removable (when needed, we can
      move ftrace_ops struct into a module). Note that persistent_ram is still
      not removable for other reasons, but with this patch it's just one
      thing less to worry about;
    
    - Pstore part is more isolated from the generic function tracer. We tried
      it already by registering our own tracer in available_tracers, but that
      way we're loosing ability to see the traces while we record them to
      pstore. This solution is somewhere in the middle: we only register
      "internal ftracer" back-end, but not the "front-end";
    
    - When there is only pstore tracing enabled, the kernel will only write
      to the pstore buffer, omitting function tracer buffer (which, of course,
      still can be enabled via 'echo function > current_tracer').
    
    Suggested-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 29996e8793a7..6c23eab7f76c 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -236,6 +236,7 @@ int pstore_register(struct pstore_info *psi)
 
 	kmsg_dump_register(&pstore_dumper);
 	pstore_register_console();
+	pstore_register_ftrace();
 
 	if (pstore_update_ms >= 0) {
 		pstore_timer.expires = jiffies +

commit 060287b8c467bf49a594d8d669e1986c6d8d76b0
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Mon Jul 9 17:10:41 2012 -0700

    pstore: Add persistent function tracing
    
    With this support kernel can save function call chain log into a
    persistent ram buffer that can be decoded and dumped after reboot
    through pstore filesystem. It can be used to determine what function
    was last called before a reset or panic.
    
    We store the log in a binary format and then decode it at read time.
    
    p.s.
    Mostly the code comes from trace_persistent.c driver found in the
    Android git tree, written by Colin Cross <ccross@android.com>
    (according to sign-off history). I reworked the driver a little bit,
    and ported it to pstore.
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index ef5ca8a0255c..29996e8793a7 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -61,7 +61,7 @@ static DECLARE_WORK(pstore_work, pstore_dowork);
  * calls to pstore_register()
  */
 static DEFINE_SPINLOCK(pstore_lock);
-static struct pstore_info *psinfo;
+struct pstore_info *psinfo;
 
 static char *backend;
 

commit 897dba027445be93f40e5caf550556ca38c48c51
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Mon Jul 9 17:10:40 2012 -0700

    pstore: Introduce write_buf backend callback
    
    For function tracing we need to stop using pstore.buf directly, since
    in a tracing callback we can't use spinlocks, and thus we can't safely
    use the global buffer.
    
    With write_buf callback, backends no longer need to access pstore.buf
    directly, and thus we can pass any buffers (e.g. allocated on stack).
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 6b3ff045fe6e..ef5ca8a0255c 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -188,6 +188,14 @@ static void pstore_register_console(void)
 static void pstore_register_console(void) {}
 #endif
 
+static int pstore_write_compat(enum pstore_type_id type,
+			       enum kmsg_dump_reason reason,
+			       u64 *id, unsigned int part,
+			       size_t size, struct pstore_info *psi)
+{
+	return psi->write_buf(type, reason, id, part, psinfo->buf, size, psi);
+}
+
 /*
  * platform specific persistent storage driver registers with
  * us here. If pstore is already mounted, call the platform
@@ -212,6 +220,8 @@ int pstore_register(struct pstore_info *psi)
 		return -EINVAL;
 	}
 
+	if (!psi->write)
+		psi->write = pstore_write_compat;
 	psinfo = psi;
 	mutex_init(&psinfo->read_mutex);
 	spin_unlock(&pstore_lock);

commit bcc66c0b8881f88459f9ac21038455bcafacdc6e
Merge: 1c1b86215730 6b16351acbd4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jun 25 09:31:00 2012 -0700

    Merge 3.5-rc4 into staging-next
    
    This picks up the staging changes made in 3.5-rc4 so that everyone can sync up
    properly.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e2ae715d66bf4becfb85eb84b7150e23cf27df30
Author: Kay Sievers <kay@vrfy.org>
Date:   Fri Jun 15 14:07:51 2012 +0200

    kmsg - kmsg_dump() use iterator to receive log buffer content
    
    Provide an iterator to receive the log buffer content, and convert all
    kmsg_dump() users to it.
    
    The structured data in the kmsg buffer now contains binary data, which
    should no longer be copied verbatim to the kmsg_dump() users.
    
    The iterator should provide reliable access to the buffer data, and also
    supports proper log line-aware chunking of data while iterating.
    
    Signed-off-by: Kay Sievers <kay@vrfy.org>
    Tested-by: Tony Luck <tony.luck@intel.com>
    Reported-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Tested-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 82c585f715e3..03ce7a9b81cc 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -94,20 +94,15 @@ static const char *get_reason_str(enum kmsg_dump_reason reason)
  * as we can from the end of the buffer.
  */
 static void pstore_dump(struct kmsg_dumper *dumper,
-	    enum kmsg_dump_reason reason,
-	    const char *s1, unsigned long l1,
-	    const char *s2, unsigned long l2)
+			enum kmsg_dump_reason reason)
 {
-	unsigned long	s1_start, s2_start;
-	unsigned long	l1_cpy, l2_cpy;
-	unsigned long	size, total = 0;
-	char		*dst;
+	unsigned long	total = 0;
 	const char	*why;
 	u64		id;
-	int		hsize, ret;
 	unsigned int	part = 1;
 	unsigned long	flags = 0;
 	int		is_locked = 0;
+	int		ret;
 
 	why = get_reason_str(reason);
 
@@ -119,30 +114,25 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		spin_lock_irqsave(&psinfo->buf_lock, flags);
 	oopscount++;
 	while (total < kmsg_bytes) {
+		char *dst;
+		unsigned long size;
+		int hsize;
+		size_t len;
+
 		dst = psinfo->buf;
 		hsize = sprintf(dst, "%s#%d Part%d\n", why, oopscount, part);
 		size = psinfo->bufsize - hsize;
 		dst += hsize;
 
-		l2_cpy = min(l2, size);
-		l1_cpy = min(l1, size - l2_cpy);
-
-		if (l1_cpy + l2_cpy == 0)
+		if (!kmsg_dump_get_buffer(dumper, true, dst, size, &len))
 			break;
 
-		s2_start = l2 - l2_cpy;
-		s1_start = l1 - l1_cpy;
-
-		memcpy(dst, s1 + s1_start, l1_cpy);
-		memcpy(dst + l1_cpy, s2 + s2_start, l2_cpy);
-
 		ret = psinfo->write(PSTORE_TYPE_DMESG, reason, &id, part,
-				   hsize + l1_cpy + l2_cpy, psinfo);
+				    hsize + len, psinfo);
 		if (ret == 0 && reason == KMSG_DUMP_OOPS && pstore_is_mounted())
 			pstore_new_entry = 1;
-		l1 -= l1_cpy;
-		l2 -= l2_cpy;
-		total += l1_cpy + l2_cpy;
+
+		total += hsize + len;
 		part++;
 	}
 	if (in_nmi()) {

commit 521f7288a8126a8ec28e3ab623aacf0590684b80
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Sat May 26 06:20:29 2012 -0700

    pstore/platform: Disable automatic updates by default
    
    Having automatic updates seems pointless for production system, and
    even dangerous and thus counter-productive:
    
    1. If we can mount pstore, or read files, we can as well read
       /proc/kmsg. So, there's little point in duplicating the
       functionality and present the same information but via another
       userland ABI;
    
    2. Expecting the kernel to behave sanely after oops/panic is naive.
       It might work, but you'd rather not try it. Screwed up kernel
       can do rather bad things, like recursive faults[1]; and pstore
       rather provoking bad things to happen. It uses:
    
       1. Timers (assumes sane interrupts state);
       2. Workqueues and mutexes (assumes scheduler in a sane state);
       3. kzalloc (a working slab allocator);
    
       That's too much for a dead kernel, so the debugging facility
       itself might just make debugging harder, which is not what
       we want.
    
    Maybe for non-oops message types it would make sense to re-enable
    automatic updates, but so far I don't see any use case for this.
    Even for tracing, it has its own run-time/normal ABI, so we're
    only interested in pstore upon next boot, to retrieve what has
    gone wrong with HW or SW.
    
    So, let's disable the updates by default.
    
    [1]
    BUG: unable to handle kernel paging request at fffffffffffffff8
    IP: [<ffffffff8104801b>] kthread_data+0xb/0x20
    [...]
    Process kworker/0:1 (pid: 14, threadinfo ffff8800072c0000, task ffff88000725b100)
    [...
    Call Trace:
     [<ffffffff81043710>] wq_worker_sleeping+0x10/0xa0
     [<ffffffff813687a8>] __schedule+0x568/0x7d0
     [<ffffffff8106c24d>] ? trace_hardirqs_on+0xd/0x10
     [<ffffffff81087e22>] ? call_rcu_sched+0x12/0x20
     [<ffffffff8102b596>] ? release_task+0x156/0x2d0
     [<ffffffff8102b45e>] ? release_task+0x1e/0x2d0
     [<ffffffff8106c24d>] ? trace_hardirqs_on+0xd/0x10
     [<ffffffff81368ac4>] schedule+0x24/0x70
     [<ffffffff8102cba8>] do_exit+0x1f8/0x370
     [<ffffffff810051e7>] oops_end+0x77/0xb0
     [<ffffffff8135c301>] no_context+0x1a6/0x1b5
     [<ffffffff8135c4de>] __bad_area_nosemaphore+0x1ce/0x1ed
     [<ffffffff81053156>] ? ttwu_queue+0xc6/0xe0
     [<ffffffff8135c50b>] bad_area_nosemaphore+0xe/0x10
     [<ffffffff8101fa47>] do_page_fault+0x2c7/0x450
     [<ffffffff8106e34b>] ? __lock_release+0x6b/0xe0
     [<ffffffff8106bf21>] ? mark_held_locks+0x61/0x140
     [<ffffffff810502fe>] ? __wake_up+0x4e/0x70
     [<ffffffff81185f7d>] ? trace_hardirqs_off_thunk+0x3a/0x3c
     [<ffffffff81158970>] ? pstore_register+0x120/0x120
     [<ffffffff8136a37f>] page_fault+0x1f/0x30
     [<ffffffff81158970>] ? pstore_register+0x120/0x120
     [<ffffffff81185ab8>] ? memcpy+0x68/0x110
     [<ffffffff8115875a>] ? pstore_get_records+0x3a/0x130
     [<ffffffff811590f4>] ? persistent_ram_copy_old+0x64/0x90
     [<ffffffff81158bf4>] ramoops_pstore_read+0x84/0x130
     [<ffffffff81158799>] pstore_get_records+0x79/0x130
     [<ffffffff81042536>] ? process_one_work+0x116/0x450
     [<ffffffff81158970>] ? pstore_register+0x120/0x120
     [<ffffffff8115897e>] pstore_dowork+0xe/0x10
     [<ffffffff81042594>] process_one_work+0x174/0x450
     [<ffffffff81042536>] ? process_one_work+0x116/0x450
     [<ffffffff81042e13>] worker_thread+0x123/0x2d0
     [<ffffffff81042cf0>] ? manage_workers.isra.28+0x120/0x120
     [<ffffffff81047d8e>] kthread+0x8e/0xa0
     [<ffffffff8136ba74>] kernel_thread_helper+0x4/0x10
     [<ffffffff8136a199>] ? retint_restore_args+0xe/0xe
     [<ffffffff81047d00>] ? __init_kthread_worker+0x70/0x70
     [<ffffffff8136ba70>] ? gs_change+0xb/0xb
    Code: be e2 00 00 00 48 c7 c7 d1 2a 4e 81 e8 bf fb fd ff 48 8b 5d f0 4c 8b 65 f8 c9 c3 0f 1f 44 00 00 48 8b 87 08 02 00 00 55 48 89 e5 <48> 8b 40 f8 5d c3 66 66 66 66 66 66 2e 0f 1f 84 00 00 00 00 00
    RIP  [<ffffffff8104801b>] kthread_data+0xb/0x20
     RSP <ffff8800072c1888>
    CR2: fffffffffffffff8
    ---[ end trace 996a332dc399111d ]---
    Fixing recursive fault but reboot is needed!
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 34ca3141eb0a..be4614f24a2f 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -41,10 +41,12 @@
  * whether the system is actually still running well enough
  * to let someone see the entry
  */
-static int pstore_update_ms = 60000;
+static int pstore_update_ms = -1;
 module_param_named(update_ms, pstore_update_ms, int, 0600);
 MODULE_PARM_DESC(update_ms, "milliseconds before pstore updates its content "
-		 "(default is 60000; -1 means runtime updates are disabled)");
+		 "(default is -1, which means runtime updates are disabled; "
+		 "enabling this option is not safe, it may lead to further "
+		 "corruption on Oopses)");
 
 static int pstore_new_entry;
 

commit a3f5f075c2e2c52c9c656c54ea77ceff5b2e1e25
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Sat May 26 06:20:28 2012 -0700

    pstore/platform: Make automatic updates interval configurable
    
    There is no behavioural change, the default value is still 60 seconds.
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 61461ed9b6c8..34ca3141eb0a 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -31,6 +31,7 @@
 #include <linux/slab.h>
 #include <linux/uaccess.h>
 #include <linux/hardirq.h>
+#include <linux/jiffies.h>
 #include <linux/workqueue.h>
 
 #include "internal.h"
@@ -40,7 +41,10 @@
  * whether the system is actually still running well enough
  * to let someone see the entry
  */
-#define	PSTORE_INTERVAL	(60 * HZ)
+static int pstore_update_ms = 60000;
+module_param_named(update_ms, pstore_update_ms, int, 0600);
+MODULE_PARM_DESC(update_ms, "milliseconds before pstore updates its content "
+		 "(default is 60000; -1 means runtime updates are disabled)");
 
 static int pstore_new_entry;
 
@@ -231,8 +235,11 @@ int pstore_register(struct pstore_info *psi)
 	kmsg_dump_register(&pstore_dumper);
 	pstore_register_console();
 
-	pstore_timer.expires = jiffies + PSTORE_INTERVAL;
-	add_timer(&pstore_timer);
+	if (pstore_update_ms >= 0) {
+		pstore_timer.expires = jiffies +
+			msecs_to_jiffies(pstore_update_ms);
+		add_timer(&pstore_timer);
+	}
 
 	return 0;
 }
@@ -291,7 +298,7 @@ static void pstore_timefunc(unsigned long dummy)
 		schedule_work(&pstore_work);
 	}
 
-	mod_timer(&pstore_timer, jiffies + PSTORE_INTERVAL);
+	mod_timer(&pstore_timer, jiffies + msecs_to_jiffies(pstore_update_ms));
 }
 
 module_param(backend, charp, 0444);

commit f29e5956aebafe63f81e80f972c44c4a666e5c7f
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Sat May 26 06:20:19 2012 -0700

    pstore: Add console log messages support
    
    Pstore doesn't support logging kernel messages in run-time, it only
    dumps dmesg when kernel oopses/panics. This makes pstore useless for
    debugging hangs caused by HW issues or improper use of HW (e.g.
    weird device inserted -> driver tried to write a reserved bits ->
    SoC hanged. In that case we don't get any messages in the pstore.
    
    Therefore, let's add a runtime logging support: PSTORE_TYPE_CONSOLE.
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Colin Cross <ccross@android.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 82c585f715e3..61461ed9b6c8 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -1,6 +1,7 @@
 /*
  * Persistent Storage - platform driver interface parts.
  *
+ * Copyright (C) 2007-2008 Google, Inc.
  * Copyright (C) 2010 Intel Corporation <tony.luck@intel.com>
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -22,6 +23,7 @@
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/kmsg_dump.h>
+#include <linux/console.h>
 #include <linux/module.h>
 #include <linux/pstore.h>
 #include <linux/string.h>
@@ -156,6 +158,40 @@ static struct kmsg_dumper pstore_dumper = {
 	.dump = pstore_dump,
 };
 
+#ifdef CONFIG_PSTORE_CONSOLE
+static void pstore_console_write(struct console *con, const char *s, unsigned c)
+{
+	const char *e = s + c;
+
+	while (s < e) {
+		unsigned long flags;
+
+		if (c > psinfo->bufsize)
+			c = psinfo->bufsize;
+		spin_lock_irqsave(&psinfo->buf_lock, flags);
+		memcpy(psinfo->buf, s, c);
+		psinfo->write(PSTORE_TYPE_CONSOLE, 0, NULL, 0, c, psinfo);
+		spin_unlock_irqrestore(&psinfo->buf_lock, flags);
+		s += c;
+		c = e - s;
+	}
+}
+
+static struct console pstore_console = {
+	.name	= "pstore",
+	.write	= pstore_console_write,
+	.flags	= CON_PRINTBUFFER | CON_ENABLED | CON_ANYTIME,
+	.index	= -1,
+};
+
+static void pstore_register_console(void)
+{
+	register_console(&pstore_console);
+}
+#else
+static void pstore_register_console(void) {}
+#endif
+
 /*
  * platform specific persistent storage driver registers with
  * us here. If pstore is already mounted, call the platform
@@ -193,6 +229,7 @@ int pstore_register(struct pstore_info *psi)
 		pstore_get_records(0);
 
 	kmsg_dump_register(&pstore_dumper);
+	pstore_register_console();
 
 	pstore_timer.expires = jiffies + PSTORE_INTERVAL;
 	add_timer(&pstore_timer);

commit 381b872cf7942ab8c95de156ce403bd906f3915d
Author: Seiji Aguchi <seiji.aguchi@hds.com>
Date:   Fri Mar 16 15:36:59 2012 -0700

    pstore: Introduce get_reason_str() to pstore
    
    Recently, there has been some changes in kmsg_dump() below and they have been applied to linus-tree.
     (1) kmsg_dump(KMSG_DUMP_KEXEC) was removed.
         http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commitdiff;h=a3dd3323058d281abd584b15ad4c5b65064d7a61
    
     (2) The order of "enum kmsg_dump_reason" was modified.
         http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commitdiff;h=c22ab332902333f83766017478c1ef6607ace681
    
    Replace the fragile reason_str array with a more robust solution that
    will not be broken by future re-arrangements of the enum values.
    
    Signed-off-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Don Zickus <dzickus@redhat.com>
    Link: https://lkml.org/lkml/2012/3/16/417
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 9ec22d3b4293..82c585f715e3 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -68,9 +68,25 @@ void pstore_set_kmsg_bytes(int bytes)
 /* Tag each group of saved records with a sequence number */
 static int	oopscount;
 
-static char *reason_str[] = {
-	"Oops", "Panic", "Kexec", "Restart", "Halt", "Poweroff", "Emergency"
-};
+static const char *get_reason_str(enum kmsg_dump_reason reason)
+{
+	switch (reason) {
+	case KMSG_DUMP_PANIC:
+		return "Panic";
+	case KMSG_DUMP_OOPS:
+		return "Oops";
+	case KMSG_DUMP_EMERG:
+		return "Emergency";
+	case KMSG_DUMP_RESTART:
+		return "Restart";
+	case KMSG_DUMP_HALT:
+		return "Halt";
+	case KMSG_DUMP_POWEROFF:
+		return "Poweroff";
+	default:
+		return "Unknown";
+	}
+}
 
 /*
  * callback from kmsg_dump. (s2,l2) has the most recently
@@ -85,17 +101,15 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 	unsigned long	s1_start, s2_start;
 	unsigned long	l1_cpy, l2_cpy;
 	unsigned long	size, total = 0;
-	char		*dst, *why;
+	char		*dst;
+	const char	*why;
 	u64		id;
 	int		hsize, ret;
 	unsigned int	part = 1;
 	unsigned long	flags = 0;
 	int		is_locked = 0;
 
-	if (reason < ARRAY_SIZE(reason_str))
-		why = reason_str[reason];
-	else
-		why = "Unknown";
+	why = get_reason_str(reason);
 
 	if (in_nmi()) {
 		is_locked = spin_trylock(&psinfo->buf_lock);

commit 2174f6df7891fa331800beb72634c969f017900b
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Nov 18 13:49:00 2011 -0800

    pstore: gracefully handle NULL pstore_info functions
    
    If a pstore backend doesn't want to support various portions of the
    pstore interface, it can just leave those functions NULL instead of
    creating no-op stubs.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index f146d89179bf..9ec22d3b4293 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -207,8 +207,7 @@ void pstore_get_records(int quiet)
 		return;
 
 	mutex_lock(&psi->read_mutex);
-	rc = psi->open(psi);
-	if (rc)
+	if (psi->open && psi->open(psi))
 		goto out;
 
 	while ((size = psi->read(&id, &type, &time, &buf, psi)) > 0) {
@@ -219,7 +218,8 @@ void pstore_get_records(int quiet)
 		if (rc && (rc != -EEXIST || !quiet))
 			failed++;
 	}
-	psi->close(psi);
+	if (psi->close)
+		psi->close(psi);
 out:
 	mutex_unlock(&psi->read_mutex);
 

commit 3d6d8d20ec4fd3b256632edb373a9c504724b8a9
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Nov 17 13:13:29 2011 -0800

    pstore: pass reason to backend write callback
    
    This allows a backend to filter on the dmesg reason as well as the pstore
    reason. When ramoops is switched to pstore, this is needed since it has
    no interest in storing non-crash dmesg details.
    
    Drop pstore_write() as it has no users, and handling the "reason" here
    has no obviously correct value.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 57bbf9078ac8..f146d89179bf 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -122,7 +122,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		memcpy(dst, s1 + s1_start, l1_cpy);
 		memcpy(dst + l1_cpy, s2 + s2_start, l2_cpy);
 
-		ret = psinfo->write(PSTORE_TYPE_DMESG, &id, part,
+		ret = psinfo->write(PSTORE_TYPE_DMESG, reason, &id, part,
 				   hsize + l1_cpy + l2_cpy, psinfo);
 		if (ret == 0 && reason == KMSG_DUMP_OOPS && pstore_is_mounted())
 			pstore_new_entry = 1;
@@ -243,33 +243,5 @@ static void pstore_timefunc(unsigned long dummy)
 	mod_timer(&pstore_timer, jiffies + PSTORE_INTERVAL);
 }
 
-/*
- * Call platform driver to write a record to the
- * persistent store.
- */
-int pstore_write(enum pstore_type_id type, char *buf, size_t size)
-{
-	u64		id;
-	int		ret;
-	unsigned long	flags;
-
-	if (!psinfo)
-		return -ENODEV;
-
-	if (size > psinfo->bufsize)
-		return -EFBIG;
-
-	spin_lock_irqsave(&psinfo->buf_lock, flags);
-	memcpy(psinfo->buf, buf, size);
-	ret = psinfo->write(type, &id, 0, size, psinfo);
-	if (ret == 0 && pstore_is_mounted())
-		pstore_mkfile(PSTORE_TYPE_DMESG, psinfo->name, id, psinfo->buf,
-			      size, CURRENT_TIME, psinfo);
-	spin_unlock_irqrestore(&psinfo->buf_lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(pstore_write);
-
 module_param(backend, charp, 0444);
 MODULE_PARM_DESC(backend, "Pstore backend to use");

commit f6f8285132907757ef84ef8dae0a1244b8cde6ac
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Nov 17 12:58:07 2011 -0800

    pstore: pass allocated memory region back to caller
    
    The buf_lock cannot be held while populating the inodes, so make the backend
    pass forward an allocated and filled buffer instead. This solves the following
    backtrace. The effect is that "buf" is only ever used to notify the backends
    that something was written to it, and shouldn't be used in the read path.
    
    To replace the buf_lock during the read path, isolate the open/read/close
    loop with a separate mutex to maintain serialized access to the backend.
    
    Note that is is up to the pstore backend to cope if the (*write)() path is
    called in the middle of the read path.
    
    [   59.691019] BUG: sleeping function called from invalid context at .../mm/slub.c:847
    [   59.691019] in_atomic(): 0, irqs_disabled(): 1, pid: 1819, name: mount
    [   59.691019] Pid: 1819, comm: mount Not tainted 3.0.8 #1
    [   59.691019] Call Trace:
    [   59.691019]  [<810252d5>] __might_sleep+0xc3/0xca
    [   59.691019]  [<810a26e6>] kmem_cache_alloc+0x32/0xf3
    [   59.691019]  [<810b53ac>] ? __d_lookup_rcu+0x6f/0xf4
    [   59.691019]  [<810b68b1>] alloc_inode+0x2a/0x64
    [   59.691019]  [<810b6903>] new_inode+0x18/0x43
    [   59.691019]  [<81142447>] pstore_get_inode.isra.1+0x11/0x98
    [   59.691019]  [<81142623>] pstore_mkfile+0xae/0x26f
    [   59.691019]  [<810a2a66>] ? kmem_cache_free+0x19/0xb1
    [   59.691019]  [<8116c821>] ? ida_get_new_above+0x140/0x158
    [   59.691019]  [<811708ea>] ? __init_rwsem+0x1e/0x2c
    [   59.691019]  [<810b67e8>] ? inode_init_always+0x111/0x1b0
    [   59.691019]  [<8102127e>] ? should_resched+0xd/0x27
    [   59.691019]  [<8137977f>] ? _cond_resched+0xd/0x21
    [   59.691019]  [<81142abf>] pstore_get_records+0x52/0xa7
    [   59.691019]  [<8114254b>] pstore_fill_super+0x7d/0x91
    [   59.691019]  [<810a7ff5>] mount_single+0x46/0x82
    [   59.691019]  [<8114231a>] pstore_mount+0x15/0x17
    [   59.691019]  [<811424ce>] ? pstore_get_inode.isra.1+0x98/0x98
    [   59.691019]  [<810a8199>] mount_fs+0x5a/0x12d
    [   59.691019]  [<810b9174>] ? alloc_vfsmnt+0xa4/0x14a
    [   59.691019]  [<810b9474>] vfs_kern_mount+0x4f/0x7d
    [   59.691019]  [<810b9d7e>] do_kern_mount+0x34/0xb2
    [   59.691019]  [<810bb15f>] do_mount+0x5fc/0x64a
    [   59.691019]  [<810912fb>] ? strndup_user+0x2e/0x3f
    [   59.691019]  [<810bb3cb>] sys_mount+0x66/0x99
    [   59.691019]  [<8137b537>] sysenter_do_call+0x12/0x26
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 2bd620f0d796..57bbf9078ac8 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -167,6 +167,7 @@ int pstore_register(struct pstore_info *psi)
 	}
 
 	psinfo = psi;
+	mutex_init(&psinfo->read_mutex);
 	spin_unlock(&pstore_lock);
 
 	if (owner && !try_module_get(owner)) {
@@ -195,30 +196,32 @@ EXPORT_SYMBOL_GPL(pstore_register);
 void pstore_get_records(int quiet)
 {
 	struct pstore_info *psi = psinfo;
+	char			*buf = NULL;
 	ssize_t			size;
 	u64			id;
 	enum pstore_type_id	type;
 	struct timespec		time;
 	int			failed = 0, rc;
-	unsigned long		flags;
 
 	if (!psi)
 		return;
 
-	spin_lock_irqsave(&psinfo->buf_lock, flags);
+	mutex_lock(&psi->read_mutex);
 	rc = psi->open(psi);
 	if (rc)
 		goto out;
 
-	while ((size = psi->read(&id, &type, &time, psi)) > 0) {
-		rc = pstore_mkfile(type, psi->name, id, psi->buf, (size_t)size,
+	while ((size = psi->read(&id, &type, &time, &buf, psi)) > 0) {
+		rc = pstore_mkfile(type, psi->name, id, buf, (size_t)size,
 				  time, psi);
+		kfree(buf);
+		buf = NULL;
 		if (rc && (rc != -EEXIST || !quiet))
 			failed++;
 	}
 	psi->close(psi);
 out:
-	spin_unlock_irqrestore(&psinfo->buf_lock, flags);
+	mutex_unlock(&psi->read_mutex);
 
 	if (failed)
 		printk(KERN_WARNING "pstore: failed to load %d record(s) from '%s'\n",

commit b238b8fa93353ab50c9a2b1e2fa47a0ab01c37cd
Author: Chen Gong <gong.chen@linux.intel.com>
Date:   Wed Oct 12 09:17:24 2011 -0700

    pstore: make pstore write function return normal success/fail value
    
    Currently pstore write interface employs record id as return
    value, but it is not enough because it can't tell caller if
    the write operation is successful. Pass the record id back via
    an argument pointer and return zero for success, non-zero for
    failure.
    
    Signed-off-by: Chen Gong <gong.chen@linux.intel.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 0472924024cc..2bd620f0d796 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -87,7 +87,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 	unsigned long	size, total = 0;
 	char		*dst, *why;
 	u64		id;
-	int		hsize;
+	int		hsize, ret;
 	unsigned int	part = 1;
 	unsigned long	flags = 0;
 	int		is_locked = 0;
@@ -122,9 +122,9 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		memcpy(dst, s1 + s1_start, l1_cpy);
 		memcpy(dst + l1_cpy, s2 + s2_start, l2_cpy);
 
-		id = psinfo->write(PSTORE_TYPE_DMESG, part,
+		ret = psinfo->write(PSTORE_TYPE_DMESG, &id, part,
 				   hsize + l1_cpy + l2_cpy, psinfo);
-		if (reason == KMSG_DUMP_OOPS && pstore_is_mounted())
+		if (ret == 0 && reason == KMSG_DUMP_OOPS && pstore_is_mounted())
 			pstore_new_entry = 1;
 		l1 -= l1_cpy;
 		l2 -= l2_cpy;
@@ -247,6 +247,7 @@ static void pstore_timefunc(unsigned long dummy)
 int pstore_write(enum pstore_type_id type, char *buf, size_t size)
 {
 	u64		id;
+	int		ret;
 	unsigned long	flags;
 
 	if (!psinfo)
@@ -257,8 +258,8 @@ int pstore_write(enum pstore_type_id type, char *buf, size_t size)
 
 	spin_lock_irqsave(&psinfo->buf_lock, flags);
 	memcpy(psinfo->buf, buf, size);
-	id = psinfo->write(type, 0, size, psinfo);
-	if (pstore_is_mounted())
+	ret = psinfo->write(type, &id, 0, size, psinfo);
+	if (ret == 0 && pstore_is_mounted())
 		pstore_mkfile(PSTORE_TYPE_DMESG, psinfo->name, id, psinfo->buf,
 			      size, CURRENT_TIME, psinfo);
 	spin_unlock_irqrestore(&psinfo->buf_lock, flags);

commit abd4d5587be911f63592537284dad78766d97d62
Author: Don Zickus <dzickus@redhat.com>
Date:   Fri Aug 12 10:54:51 2011 -0700

    pstore: change mutex locking to spin_locks
    
    pstore was using mutex locking to protect read/write access to the
    backend plug-ins.  This causes problems when pstore is executed in
    an NMI context through panic() -> kmsg_dump().
    
    This patch changes the mutex to a spin_lock_irqsave then also checks to
    see if we are in an NMI context.  If we are in an NMI and can't get the
    lock, just print a message stating that and blow by the locking.
    
    All this is probably a hack around the bigger locking problem but it
    solves my current situation of trying to sleep in an NMI context.
    
    Tested by loading the lkdtm module and executing a HARDLOCKUP which
    will cause the machine to panic inside the nmi handler.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Acked-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index ca60ebcfb15f..0472924024cc 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -28,6 +28,7 @@
 #include <linux/timer.h>
 #include <linux/slab.h>
 #include <linux/uaccess.h>
+#include <linux/hardirq.h>
 #include <linux/workqueue.h>
 
 #include "internal.h"
@@ -88,13 +89,20 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 	u64		id;
 	int		hsize;
 	unsigned int	part = 1;
+	unsigned long	flags = 0;
+	int		is_locked = 0;
 
 	if (reason < ARRAY_SIZE(reason_str))
 		why = reason_str[reason];
 	else
 		why = "Unknown";
 
-	mutex_lock(&psinfo->buf_mutex);
+	if (in_nmi()) {
+		is_locked = spin_trylock(&psinfo->buf_lock);
+		if (!is_locked)
+			pr_err("pstore dump routine blocked in NMI, may corrupt error record\n");
+	} else
+		spin_lock_irqsave(&psinfo->buf_lock, flags);
 	oopscount++;
 	while (total < kmsg_bytes) {
 		dst = psinfo->buf;
@@ -123,7 +131,11 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		total += l1_cpy + l2_cpy;
 		part++;
 	}
-	mutex_unlock(&psinfo->buf_mutex);
+	if (in_nmi()) {
+		if (is_locked)
+			spin_unlock(&psinfo->buf_lock);
+	} else
+		spin_unlock_irqrestore(&psinfo->buf_lock, flags);
 }
 
 static struct kmsg_dumper pstore_dumper = {
@@ -188,11 +200,12 @@ void pstore_get_records(int quiet)
 	enum pstore_type_id	type;
 	struct timespec		time;
 	int			failed = 0, rc;
+	unsigned long		flags;
 
 	if (!psi)
 		return;
 
-	mutex_lock(&psinfo->buf_mutex);
+	spin_lock_irqsave(&psinfo->buf_lock, flags);
 	rc = psi->open(psi);
 	if (rc)
 		goto out;
@@ -205,7 +218,7 @@ void pstore_get_records(int quiet)
 	}
 	psi->close(psi);
 out:
-	mutex_unlock(&psinfo->buf_mutex);
+	spin_unlock_irqrestore(&psinfo->buf_lock, flags);
 
 	if (failed)
 		printk(KERN_WARNING "pstore: failed to load %d record(s) from '%s'\n",
@@ -233,7 +246,8 @@ static void pstore_timefunc(unsigned long dummy)
  */
 int pstore_write(enum pstore_type_id type, char *buf, size_t size)
 {
-	u64	id;
+	u64		id;
+	unsigned long	flags;
 
 	if (!psinfo)
 		return -ENODEV;
@@ -241,13 +255,13 @@ int pstore_write(enum pstore_type_id type, char *buf, size_t size)
 	if (size > psinfo->bufsize)
 		return -EFBIG;
 
-	mutex_lock(&psinfo->buf_mutex);
+	spin_lock_irqsave(&psinfo->buf_lock, flags);
 	memcpy(psinfo->buf, buf, size);
 	id = psinfo->write(type, 0, size, psinfo);
 	if (pstore_is_mounted())
 		pstore_mkfile(PSTORE_TYPE_DMESG, psinfo->name, id, psinfo->buf,
 			      size, CURRENT_TIME, psinfo);
-	mutex_unlock(&psinfo->buf_mutex);
+	spin_unlock_irqrestore(&psinfo->buf_lock, flags);
 
 	return 0;
 }

commit 6dda9266913ad57e09afc1a10d6473f10c806a63
Author: Luck, Tony <tony.luck@intel.com>
Date:   Thu Aug 11 15:14:39 2011 -0700

    pstore: defer inserting OOPS entries into pstore
    
    Life is simple for all the kernel terminating types of kmsg_dump
    call backs - pstore just saves the tail end of the console log. But
    for "oops" the situation is more complex - the kernel may carry on
    running (possibly for ever).  So we'd like to make the logged copy
    of the oops appear in the pstore filesystem - so that the user has
    a handle to clear the entry from the persistent backing store (if
    we don't, the store may fill with "oops" entries (that are also
    safely stashed in /var/log/messages) leaving no space for real
    errors.
    
    Current code calls pstore_mkfile() immediately. But this may
    not be safe. The oops could have happened with arbitrary locks
    held, or in interrupt or NMI context. So allocating memory and
    calling into generic filesystem code seems unwise.
    
    This patch defers making the entry appear. At the time
    of the oops, we merely set a flag "pstore_new_entry" noting that
    a new entry has been added. A periodic timer checks once a minute
    to see if the flag is set - if so, it schedules a work queue to
    rescan the backing store and make all new entries appear in the
    pstore filesystem.
    
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index c5300ec31696..ca60ebcfb15f 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -25,11 +25,28 @@
 #include <linux/module.h>
 #include <linux/pstore.h>
 #include <linux/string.h>
+#include <linux/timer.h>
 #include <linux/slab.h>
 #include <linux/uaccess.h>
+#include <linux/workqueue.h>
 
 #include "internal.h"
 
+/*
+ * We defer making "oops" entries appear in pstore - see
+ * whether the system is actually still running well enough
+ * to let someone see the entry
+ */
+#define	PSTORE_INTERVAL	(60 * HZ)
+
+static int pstore_new_entry;
+
+static void pstore_timefunc(unsigned long);
+static DEFINE_TIMER(pstore_timer, pstore_timefunc, 0, 0);
+
+static void pstore_dowork(struct work_struct *);
+static DECLARE_WORK(pstore_work, pstore_dowork);
+
 /*
  * pstore_lock just protects "psinfo" during
  * calls to pstore_register()
@@ -100,9 +117,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		id = psinfo->write(PSTORE_TYPE_DMESG, part,
 				   hsize + l1_cpy + l2_cpy, psinfo);
 		if (reason == KMSG_DUMP_OOPS && pstore_is_mounted())
-			pstore_mkfile(PSTORE_TYPE_DMESG, psinfo->name, id,
-				      psinfo->buf, hsize + l1_cpy + l2_cpy,
-				      CURRENT_TIME, psinfo);
+			pstore_new_entry = 1;
 		l1 -= l1_cpy;
 		l2 -= l2_cpy;
 		total += l1_cpy + l2_cpy;
@@ -148,19 +163,24 @@ int pstore_register(struct pstore_info *psi)
 	}
 
 	if (pstore_is_mounted())
-		pstore_get_records();
+		pstore_get_records(0);
 
 	kmsg_dump_register(&pstore_dumper);
 
+	pstore_timer.expires = jiffies + PSTORE_INTERVAL;
+	add_timer(&pstore_timer);
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(pstore_register);
 
 /*
- * Read all the records from the persistent store. Create and
- * file files in our filesystem.
+ * Read all the records from the persistent store. Create
+ * files in our filesystem.  Don't warn about -EEXIST errors
+ * when we are re-scanning the backing store looking to add new
+ * error records.
  */
-void pstore_get_records(void)
+void pstore_get_records(int quiet)
 {
 	struct pstore_info *psi = psinfo;
 	ssize_t			size;
@@ -178,8 +198,9 @@ void pstore_get_records(void)
 		goto out;
 
 	while ((size = psi->read(&id, &type, &time, psi)) > 0) {
-		if (pstore_mkfile(type, psi->name, id, psi->buf, (size_t)size,
-				  time, psi))
+		rc = pstore_mkfile(type, psi->name, id, psi->buf, (size_t)size,
+				  time, psi);
+		if (rc && (rc != -EEXIST || !quiet))
 			failed++;
 	}
 	psi->close(psi);
@@ -191,6 +212,21 @@ void pstore_get_records(void)
 		       failed, psi->name);
 }
 
+static void pstore_dowork(struct work_struct *work)
+{
+	pstore_get_records(1);
+}
+
+static void pstore_timefunc(unsigned long dummy)
+{
+	if (pstore_new_entry) {
+		pstore_new_entry = 0;
+		schedule_work(&pstore_work);
+	}
+
+	mod_timer(&pstore_timer, jiffies + PSTORE_INTERVAL);
+}
+
 /*
  * Call platform driver to write a record to the
  * persistent store.

commit dee28e72b619b48ec80a9e5509db458dbe66f71f
Author: Matthew Garrett <mjg@redhat.com>
Date:   Thu Jul 21 16:57:55 2011 -0400

    pstore: Allow the user to explicitly choose a backend
    
    pstore only allows one backend to be registered at present, but the
    system may provide several. Add a parameter to allow the user to choose
    which backend will be used rather than just relying on load order.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 49ff1de2178a..c5300ec31696 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -37,6 +37,8 @@
 static DEFINE_SPINLOCK(pstore_lock);
 static struct pstore_info *psinfo;
 
+static char *backend;
+
 /* How much of the console log to snapshot */
 static unsigned long kmsg_bytes = 10240;
 
@@ -131,6 +133,12 @@ int pstore_register(struct pstore_info *psi)
 		spin_unlock(&pstore_lock);
 		return -EBUSY;
 	}
+
+	if (backend && strcmp(backend, psi->name)) {
+		spin_unlock(&pstore_lock);
+		return -EINVAL;
+	}
+
 	psinfo = psi;
 	spin_unlock(&pstore_lock);
 
@@ -208,3 +216,6 @@ int pstore_write(enum pstore_type_id type, char *buf, size_t size)
 	return 0;
 }
 EXPORT_SYMBOL_GPL(pstore_write);
+
+module_param(backend, charp, 0444);
+MODULE_PARM_DESC(backend, "Pstore backend to use");

commit b94fdd077eef5e6cab56836bf62695b497946716
Author: Matthew Garrett <mjg@redhat.com>
Date:   Thu Jul 21 16:57:54 2011 -0400

    pstore: Make "part" unsigned
    
    We'll never have a negative part, so just make this an unsigned int.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 163bb40511e7..49ff1de2178a 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -67,7 +67,8 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 	unsigned long	size, total = 0;
 	char		*dst, *why;
 	u64		id;
-	int		hsize, part = 1;
+	int		hsize;
+	unsigned int	part = 1;
 
 	if (reason < ARRAY_SIZE(reason_str))
 		why = reason_str[reason];

commit 56280682ceeef74b692b3e21d1872049eea7c887
Author: Matthew Garrett <mjg@redhat.com>
Date:   Thu Jul 21 16:57:53 2011 -0400

    pstore: Add extra context for writes and erases
    
    EFI only provides small amounts of individual storage, and conventionally
    puts metadata in the storage variable name. Rather than add a metadata
    header to the (already limited) variable storage, it's easier for us to
    modify pstore to pass all the information we need to construct a unique
    variable name to the appropriate functions.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 221c04e5e333..163bb40511e7 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -78,7 +78,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 	oopscount++;
 	while (total < kmsg_bytes) {
 		dst = psinfo->buf;
-		hsize = sprintf(dst, "%s#%d Part%d\n", why, oopscount, part++);
+		hsize = sprintf(dst, "%s#%d Part%d\n", why, oopscount, part);
 		size = psinfo->bufsize - hsize;
 		dst += hsize;
 
@@ -94,8 +94,8 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		memcpy(dst, s1 + s1_start, l1_cpy);
 		memcpy(dst + l1_cpy, s2 + s2_start, l2_cpy);
 
-		id = psinfo->write(PSTORE_TYPE_DMESG, hsize + l1_cpy + l2_cpy,
-				   psinfo);
+		id = psinfo->write(PSTORE_TYPE_DMESG, part,
+				   hsize + l1_cpy + l2_cpy, psinfo);
 		if (reason == KMSG_DUMP_OOPS && pstore_is_mounted())
 			pstore_mkfile(PSTORE_TYPE_DMESG, psinfo->name, id,
 				      psinfo->buf, hsize + l1_cpy + l2_cpy,
@@ -103,6 +103,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		l1 -= l1_cpy;
 		l2 -= l2_cpy;
 		total += l1_cpy + l2_cpy;
+		part++;
 	}
 	mutex_unlock(&psinfo->buf_mutex);
 }
@@ -197,7 +198,7 @@ int pstore_write(enum pstore_type_id type, char *buf, size_t size)
 
 	mutex_lock(&psinfo->buf_mutex);
 	memcpy(psinfo->buf, buf, size);
-	id = psinfo->write(type, size, psinfo);
+	id = psinfo->write(type, 0, size, psinfo);
 	if (pstore_is_mounted())
 		pstore_mkfile(PSTORE_TYPE_DMESG, psinfo->name, id, psinfo->buf,
 			      size, CURRENT_TIME, psinfo);

commit 638c1fd3033c76778e6d9975ad8a4a9cdd5b96d9
Author: Matthew Garrett <mjg@redhat.com>
Date:   Thu Jul 21 16:57:52 2011 -0400

    pstore: Extend API for more flexibility in new backends
    
    Some pstore implementations may not have a static context, so extend the
    API to pass the pstore_info struct to all calls and allow for a context
    pointer.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index f2c3ff20ea68..221c04e5e333 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -94,11 +94,12 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		memcpy(dst, s1 + s1_start, l1_cpy);
 		memcpy(dst + l1_cpy, s2 + s2_start, l2_cpy);
 
-		id = psinfo->write(PSTORE_TYPE_DMESG, hsize + l1_cpy + l2_cpy);
+		id = psinfo->write(PSTORE_TYPE_DMESG, hsize + l1_cpy + l2_cpy,
+				   psinfo);
 		if (reason == KMSG_DUMP_OOPS && pstore_is_mounted())
 			pstore_mkfile(PSTORE_TYPE_DMESG, psinfo->name, id,
 				      psinfo->buf, hsize + l1_cpy + l2_cpy,
-				      CURRENT_TIME, psinfo->erase);
+				      CURRENT_TIME, psinfo);
 		l1 -= l1_cpy;
 		l2 -= l2_cpy;
 		total += l1_cpy + l2_cpy;
@@ -166,9 +167,9 @@ void pstore_get_records(void)
 	if (rc)
 		goto out;
 
-	while ((size = psi->read(&id, &type, &time)) > 0) {
+	while ((size = psi->read(&id, &type, &time, psi)) > 0) {
 		if (pstore_mkfile(type, psi->name, id, psi->buf, (size_t)size,
-				  time, psi->erase))
+				  time, psi))
 			failed++;
 	}
 	psi->close(psi);
@@ -196,10 +197,10 @@ int pstore_write(enum pstore_type_id type, char *buf, size_t size)
 
 	mutex_lock(&psinfo->buf_mutex);
 	memcpy(psinfo->buf, buf, size);
-	id = psinfo->write(type, size);
+	id = psinfo->write(type, size, psinfo);
 	if (pstore_is_mounted())
 		pstore_mkfile(PSTORE_TYPE_DMESG, psinfo->name, id, psinfo->buf,
-			      size, CURRENT_TIME, psinfo->erase);
+			      size, CURRENT_TIME, psinfo);
 	mutex_unlock(&psinfo->buf_mutex);
 
 	return 0;

commit 06cf91b4b4aafa50ee0a94c81d2c6922a18af242
Author: Chen Gong <gong.chen@linux.intel.com>
Date:   Mon May 16 11:00:27 2011 -0700

    pstore: fix pstore filesystem mount/remount issue
    
    Currently after mount/remount operation on pstore filesystem,
    the content on pstore will be lost. It is because current ERST
    implementation doesn't support multi-user usage, which moves
    internal pointer to the end after accessing it. Adding
    multi-user support for pstore usage.
    
    Signed-off-by: Chen Gong <gong.chen@linux.intel.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 912403c2a93d..f2c3ff20ea68 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -156,17 +156,23 @@ void pstore_get_records(void)
 	u64			id;
 	enum pstore_type_id	type;
 	struct timespec		time;
-	int			failed = 0;
+	int			failed = 0, rc;
 
 	if (!psi)
 		return;
 
 	mutex_lock(&psinfo->buf_mutex);
+	rc = psi->open(psi);
+	if (rc)
+		goto out;
+
 	while ((size = psi->read(&id, &type, &time)) > 0) {
 		if (pstore_mkfile(type, psi->name, id, psi->buf, (size_t)size,
 				  time, psi->erase))
 			failed++;
 	}
+	psi->close(psi);
+out:
 	mutex_unlock(&psinfo->buf_mutex);
 
 	if (failed)

commit 8d38d74b648513dd8ed8bd2b67d899208ef4e09e
Author: Chen Gong <gong.chen@linux.intel.com>
Date:   Mon May 16 10:58:57 2011 -0700

    pstore: fix one type of return value in pstore
    
    the return type of function _read_ in pstore is size_t,
    but in the callback function of _read_, the logic doesn't
    consider it too much, which means if negative value (assuming
    error here) is returned, it will be converted to positive because
    of type casting. ssize_t is enough for this function.
    
    Signed-off-by: Chen Gong <gong.chen@linux.intel.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index f835a25625ff..912403c2a93d 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -152,7 +152,7 @@ EXPORT_SYMBOL_GPL(pstore_register);
 void pstore_get_records(void)
 {
 	struct pstore_info *psi = psinfo;
-	size_t			size;
+	ssize_t			size;
 	u64			id;
 	enum pstore_type_id	type;
 	struct timespec		time;
@@ -163,7 +163,7 @@ void pstore_get_records(void)
 
 	mutex_lock(&psinfo->buf_mutex);
 	while ((size = psi->read(&id, &type, &time)) > 0) {
-		if (pstore_mkfile(type, psi->name, id, psi->buf, size,
+		if (pstore_mkfile(type, psi->name, id, psi->buf, (size_t)size,
 				  time, psi->erase))
 			failed++;
 	}

commit 9f6af27fb693c633cc46d36fc1d85efe6d6fbc17
Author: Tony Luck <tony.luck@intel.com>
Date:   Tue Mar 22 16:01:49 2011 -0700

    pstore: cleanups to pstore_dump()
    
    pstore_dump() can be called with many different "reason" codes. Save
    the name of the code in the persistent store record.
    
    Also - only worthwhile calling pstore_mkfile for KMSG_DUMP_OOPS - that
    is the only one where the kernel will continue running.
    
    Reviewed-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index ce9ad84d5dd9..f835a25625ff 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -48,6 +48,10 @@ void pstore_set_kmsg_bytes(int bytes)
 /* Tag each group of saved records with a sequence number */
 static int	oopscount;
 
+static char *reason_str[] = {
+	"Oops", "Panic", "Kexec", "Restart", "Halt", "Poweroff", "Emergency"
+};
+
 /*
  * callback from kmsg_dump. (s2,l2) has the most recently
  * written bytes, older bytes are in (s1,l1). Save as much
@@ -61,15 +65,20 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 	unsigned long	s1_start, s2_start;
 	unsigned long	l1_cpy, l2_cpy;
 	unsigned long	size, total = 0;
-	char		*dst;
+	char		*dst, *why;
 	u64		id;
 	int		hsize, part = 1;
 
+	if (reason < ARRAY_SIZE(reason_str))
+		why = reason_str[reason];
+	else
+		why = "Unknown";
+
 	mutex_lock(&psinfo->buf_mutex);
 	oopscount++;
 	while (total < kmsg_bytes) {
 		dst = psinfo->buf;
-		hsize = sprintf(dst, "Oops#%d Part%d\n", oopscount, part++);
+		hsize = sprintf(dst, "%s#%d Part%d\n", why, oopscount, part++);
 		size = psinfo->bufsize - hsize;
 		dst += hsize;
 
@@ -86,7 +95,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		memcpy(dst + l1_cpy, s2 + s2_start, l2_cpy);
 
 		id = psinfo->write(PSTORE_TYPE_DMESG, hsize + l1_cpy + l2_cpy);
-		if (pstore_is_mounted())
+		if (reason == KMSG_DUMP_OOPS && pstore_is_mounted())
 			pstore_mkfile(PSTORE_TYPE_DMESG, psinfo->name, id,
 				      psinfo->buf, hsize + l1_cpy + l2_cpy,
 				      CURRENT_TIME, psinfo->erase);

commit 366f7e7a79b19bd8c4e8f55fdf12b81538d1a7a4
Author: Luck, Tony <tony.luck@intel.com>
Date:   Fri Mar 18 15:33:43 2011 -0700

    pstore: use mount option instead sysfs to tweak kmsg_bytes
    
    /sys/fs is a somewhat strange way to tweak what could more
    obviously be tuned with a mount option.
    
    Suggested-by: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 705fdf8abf6e..ce9ad84d5dd9 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -37,24 +37,14 @@
 static DEFINE_SPINLOCK(pstore_lock);
 static struct pstore_info *psinfo;
 
-/* How much of the console log to snapshot. /sys/fs/pstore/kmsg_bytes */
+/* How much of the console log to snapshot */
 static unsigned long kmsg_bytes = 10240;
 
-static ssize_t b_show(struct kobject *kobj,
-		      struct kobj_attribute *attr, char *buf)
+void pstore_set_kmsg_bytes(int bytes)
 {
-	return snprintf(buf, PAGE_SIZE, "%lu\n", kmsg_bytes);
+	kmsg_bytes = bytes;
 }
 
-static ssize_t b_store(struct kobject *kobj, struct kobj_attribute *attr,
-		       const char *buf, size_t count)
-{
-	return (sscanf(buf, "%lu", &kmsg_bytes) > 0) ? count : 0;
-}
-
-struct kobj_attribute pstore_kmsg_bytes_attr =
-	__ATTR(kmsg_bytes, S_IRUGO | S_IWUSR, b_show, b_store);
-
 /* Tag each group of saved records with a sequence number */
 static int	oopscount;
 

commit ca01d6dd2d7a2652000307520777538740efc286
Author: Tony Luck <tony.luck@intel.com>
Date:   Tue Dec 28 14:25:21 2010 -0800

    pstore: new filesystem interface to platform persistent storage
    
    Some platforms have a small amount of non-volatile storage that
    can be used to store information useful to diagnose the cause of
    a system crash.  This is the generic part of a file system interface
    that presents information from the crash as a series of files in
    /dev/pstore.  Once the information has been seen, the underlying
    storage is freed by deleting the files.
    
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
new file mode 100644
index 000000000000..705fdf8abf6e
--- /dev/null
+++ b/fs/pstore/platform.c
@@ -0,0 +1,202 @@
+/*
+ * Persistent Storage - platform driver interface parts.
+ *
+ * Copyright (C) 2010 Intel Corporation <tony.luck@intel.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/atomic.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmsg_dump.h>
+#include <linux/module.h>
+#include <linux/pstore.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include "internal.h"
+
+/*
+ * pstore_lock just protects "psinfo" during
+ * calls to pstore_register()
+ */
+static DEFINE_SPINLOCK(pstore_lock);
+static struct pstore_info *psinfo;
+
+/* How much of the console log to snapshot. /sys/fs/pstore/kmsg_bytes */
+static unsigned long kmsg_bytes = 10240;
+
+static ssize_t b_show(struct kobject *kobj,
+		      struct kobj_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%lu\n", kmsg_bytes);
+}
+
+static ssize_t b_store(struct kobject *kobj, struct kobj_attribute *attr,
+		       const char *buf, size_t count)
+{
+	return (sscanf(buf, "%lu", &kmsg_bytes) > 0) ? count : 0;
+}
+
+struct kobj_attribute pstore_kmsg_bytes_attr =
+	__ATTR(kmsg_bytes, S_IRUGO | S_IWUSR, b_show, b_store);
+
+/* Tag each group of saved records with a sequence number */
+static int	oopscount;
+
+/*
+ * callback from kmsg_dump. (s2,l2) has the most recently
+ * written bytes, older bytes are in (s1,l1). Save as much
+ * as we can from the end of the buffer.
+ */
+static void pstore_dump(struct kmsg_dumper *dumper,
+	    enum kmsg_dump_reason reason,
+	    const char *s1, unsigned long l1,
+	    const char *s2, unsigned long l2)
+{
+	unsigned long	s1_start, s2_start;
+	unsigned long	l1_cpy, l2_cpy;
+	unsigned long	size, total = 0;
+	char		*dst;
+	u64		id;
+	int		hsize, part = 1;
+
+	mutex_lock(&psinfo->buf_mutex);
+	oopscount++;
+	while (total < kmsg_bytes) {
+		dst = psinfo->buf;
+		hsize = sprintf(dst, "Oops#%d Part%d\n", oopscount, part++);
+		size = psinfo->bufsize - hsize;
+		dst += hsize;
+
+		l2_cpy = min(l2, size);
+		l1_cpy = min(l1, size - l2_cpy);
+
+		if (l1_cpy + l2_cpy == 0)
+			break;
+
+		s2_start = l2 - l2_cpy;
+		s1_start = l1 - l1_cpy;
+
+		memcpy(dst, s1 + s1_start, l1_cpy);
+		memcpy(dst + l1_cpy, s2 + s2_start, l2_cpy);
+
+		id = psinfo->write(PSTORE_TYPE_DMESG, hsize + l1_cpy + l2_cpy);
+		if (pstore_is_mounted())
+			pstore_mkfile(PSTORE_TYPE_DMESG, psinfo->name, id,
+				      psinfo->buf, hsize + l1_cpy + l2_cpy,
+				      CURRENT_TIME, psinfo->erase);
+		l1 -= l1_cpy;
+		l2 -= l2_cpy;
+		total += l1_cpy + l2_cpy;
+	}
+	mutex_unlock(&psinfo->buf_mutex);
+}
+
+static struct kmsg_dumper pstore_dumper = {
+	.dump = pstore_dump,
+};
+
+/*
+ * platform specific persistent storage driver registers with
+ * us here. If pstore is already mounted, call the platform
+ * read function right away to populate the file system. If not
+ * then the pstore mount code will call us later to fill out
+ * the file system.
+ *
+ * Register with kmsg_dump to save last part of console log on panic.
+ */
+int pstore_register(struct pstore_info *psi)
+{
+	struct module *owner = psi->owner;
+
+	spin_lock(&pstore_lock);
+	if (psinfo) {
+		spin_unlock(&pstore_lock);
+		return -EBUSY;
+	}
+	psinfo = psi;
+	spin_unlock(&pstore_lock);
+
+	if (owner && !try_module_get(owner)) {
+		psinfo = NULL;
+		return -EINVAL;
+	}
+
+	if (pstore_is_mounted())
+		pstore_get_records();
+
+	kmsg_dump_register(&pstore_dumper);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pstore_register);
+
+/*
+ * Read all the records from the persistent store. Create and
+ * file files in our filesystem.
+ */
+void pstore_get_records(void)
+{
+	struct pstore_info *psi = psinfo;
+	size_t			size;
+	u64			id;
+	enum pstore_type_id	type;
+	struct timespec		time;
+	int			failed = 0;
+
+	if (!psi)
+		return;
+
+	mutex_lock(&psinfo->buf_mutex);
+	while ((size = psi->read(&id, &type, &time)) > 0) {
+		if (pstore_mkfile(type, psi->name, id, psi->buf, size,
+				  time, psi->erase))
+			failed++;
+	}
+	mutex_unlock(&psinfo->buf_mutex);
+
+	if (failed)
+		printk(KERN_WARNING "pstore: failed to load %d record(s) from '%s'\n",
+		       failed, psi->name);
+}
+
+/*
+ * Call platform driver to write a record to the
+ * persistent store.
+ */
+int pstore_write(enum pstore_type_id type, char *buf, size_t size)
+{
+	u64	id;
+
+	if (!psinfo)
+		return -ENODEV;
+
+	if (size > psinfo->bufsize)
+		return -EFBIG;
+
+	mutex_lock(&psinfo->buf_mutex);
+	memcpy(psinfo->buf, buf, size);
+	id = psinfo->write(type, size);
+	if (pstore_is_mounted())
+		pstore_mkfile(PSTORE_TYPE_DMESG, psinfo->name, id, psinfo->buf,
+			      size, CURRENT_TIME, psinfo->erase);
+	mutex_unlock(&psinfo->buf_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pstore_write);
