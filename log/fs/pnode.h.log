commit 59bd9ded4d7803d9f1f4d947064693513d18e724
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 10:10:12 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 209
    
    Based on 1 normalized pattern(s):
    
      released under gpl v2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 15 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528171438.895196075@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/pnode.h b/fs/pnode.h
index 3960a83666cf..49a058c73e4c 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -1,9 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *  linux/fs/pnode.h
  *
  * (C) Copyright IBM Corporation 2005.
- *	Released under GPL v2.
- *
  */
 #ifndef _LINUX_PNODE_H
 #define _LINUX_PNODE_H

commit 3bd045cc9c4be2049602b47505256b43908b4e2f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jan 30 13:15:45 2019 -0500

    separate copying and locking mount tree on cross-userns copies
    
    Rather than having propagate_mnt() check doing unprivileged copies,
    lock them before commit_tree().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index dc87e65becd2..3960a83666cf 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -27,8 +27,7 @@
 #define CL_MAKE_SHARED 		0x08
 #define CL_PRIVATE 		0x10
 #define CL_SHARED_TO_SLAVE	0x20
-#define CL_UNPRIVILEGED		0x40
-#define CL_COPY_MNT_NS_FILE	0x80
+#define CL_COPY_MNT_NS_FILE	0x40
 
 #define CL_COPY_ALL		(CL_COPY_UNBINDABLE | CL_COPY_MNT_NS_FILE)
 

commit 1064f874abc0d05eeed8993815f584d847b72486
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Jan 20 18:28:35 2017 +1300

    mnt: Tuck mounts under others instead of creating shadow/side mounts.
    
    Ever since mount propagation was introduced in cases where a mount in
    propagated to parent mount mountpoint pair that is already in use the
    code has placed the new mount behind the old mount in the mount hash
    table.
    
    This implementation detail is problematic as it allows creating
    arbitrary length mount hash chains.
    
    Furthermore it invalidates the constraint maintained elsewhere in the
    mount code that a parent mount and a mountpoint pair will have exactly
    one mount upon them.  Making it hard to deal with and to talk about
    this special case in the mount code.
    
    Modify mount propagation to notice when there is already a mount at
    the parent mount and mountpoint where a new mount is propagating to
    and place that preexisting mount on top of the new mount.
    
    Modify unmount propagation to notice when a mount that is being
    unmounted has another mount on top of it (and no other children), and
    to replace the unmounted mount with the mount on top of it.
    
    Move the MNT_UMUONT test from __lookup_mnt_last into
    __propagate_umount as that is the only call of __lookup_mnt_last where
    MNT_UMOUNT may be set on any mount visible in the mount hash table.
    
    These modifications allow:
     - __lookup_mnt_last to be removed.
     - attach_shadows to be renamed __attach_mnt and its shadow
       handling to be removed.
     - commit_tree to be simplified
     - copy_tree to be simplified
    
    The result is an easier to understand tree of mounts that does not
    allow creation of arbitrary length hash chains in the mount hash table.
    
    The result is also a very slight userspace visible difference in semantics.
    The following two cases now behave identically, where before order
    mattered:
    
    case 1: (explicit user action)
            B is a slave of A
            mount something on A/a , it will propagate to B/a
            and than mount something on B/a
    
    case 2: (tucked mount)
            B is a slave of A
            mount something on B/a
            and than mount something on A/a
    
    Histroically umount A/a would fail in case 1 and succeed in case 2.
    Now umount A/a succeeds in both configurations.
    
    This very small change in semantics appears if anything to be a bug
    fix to me and my survey of userspace leads me to believe that no programs
    will notice or care of this subtle semantic change.
    
    v2: Updated to mnt_change_mountpoint to not call dput or mntput
    and instead to decrement the counts directly.  It is guaranteed
    that there will be other references when mnt_change_mountpoint is
    called so this is safe.
    
    v3: Moved put_mountpoint under mount_lock in attach_recursive_mnt
        As the locking in fs/namespace.c changed between v2 and v3.
    
    v4: Reworked the logic in propagate_mount_busy and __propagate_umount
        that detects when a mount completely covers another mount.
    
    v5: Removed unnecessary tests whose result is alwasy true in
        find_topper and attach_recursive_mnt.
    
    v6: Document the user space visible semantic difference.
    
    Cc: stable@vger.kernel.org
    Fixes: b90fa9ae8f51 ("[PATCH] shared mount handling: bind and rbind")
    Tested-by: Andrei Vagin <avagin@virtuozzo.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/pnode.h b/fs/pnode.h
index 550f5a8b4fcf..dc87e65becd2 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -49,6 +49,8 @@ int get_dominating_id(struct mount *mnt, const struct path *root);
 unsigned int mnt_get_count(struct mount *mnt);
 void mnt_set_mountpoint(struct mount *, struct mountpoint *,
 			struct mount *);
+void mnt_change_mountpoint(struct mount *parent, struct mountpoint *mp,
+			   struct mount *mnt);
 struct mount *copy_tree(struct mount *, struct dentry *, int);
 bool is_path_reachable(struct mount *, struct dentry *,
 			 const struct path *root);

commit d29216842a85c7970c536108e093963f02714498
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Sep 28 00:27:17 2016 -0500

    mnt: Add a per mount namespace limit on the number of mounts
    
    CAI Qian <caiqian@redhat.com> pointed out that the semantics
    of shared subtrees make it possible to create an exponentially
    increasing number of mounts in a mount namespace.
    
        mkdir /tmp/1 /tmp/2
        mount --make-rshared /
        for i in $(seq 1 20) ; do mount --bind /tmp/1 /tmp/2 ; done
    
    Will create create 2^20 or 1048576 mounts, which is a practical problem
    as some people have managed to hit this by accident.
    
    As such CVE-2016-6213 was assigned.
    
    Ian Kent <raven@themaw.net> described the situation for autofs users
    as follows:
    
    > The number of mounts for direct mount maps is usually not very large because of
    > the way they are implemented, large direct mount maps can have performance
    > problems. There can be anywhere from a few (likely case a few hundred) to less
    > than 10000, plus mounts that have been triggered and not yet expired.
    >
    > Indirect mounts have one autofs mount at the root plus the number of mounts that
    > have been triggered and not yet expired.
    >
    > The number of autofs indirect map entries can range from a few to the common
    > case of several thousand and in rare cases up to between 30000 and 50000. I've
    > not heard of people with maps larger than 50000 entries.
    >
    > The larger the number of map entries the greater the possibility for a large
    > number of active mounts so it's not hard to expect cases of a 1000 or somewhat
    > more active mounts.
    
    So I am setting the default number of mounts allowed per mount
    namespace at 100,000.  This is more than enough for any use case I
    know of, but small enough to quickly stop an exponential increase
    in mounts.  Which should be perfect to catch misconfigurations and
    malfunctioning programs.
    
    For anyone who needs a higher limit this can be changed by writing
    to the new /proc/sys/fs/mount-max sysctl.
    
    Tested-by: CAI Qian <caiqian@redhat.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/pnode.h b/fs/pnode.h
index 0fcdbe7ca648..550f5a8b4fcf 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -52,4 +52,5 @@ void mnt_set_mountpoint(struct mount *, struct mountpoint *,
 struct mount *copy_tree(struct mount *, struct dentry *, int);
 bool is_path_reachable(struct mount *, struct dentry *,
 			 const struct path *root);
+int count_mounts(struct mnt_namespace *ns, struct mount *mnt);
 #endif /* _LINUX_PNODE_H */

commit f2d0a123bcf16d1a9cf7942ddc98e0ef77862c2b
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Jul 17 14:15:30 2015 -0500

    mnt: Clarify and correct the disconnect logic in umount_tree
    
    rmdir mntpoint will result in an infinite loop when there is
    a mount locked on the mountpoint in another mount namespace.
    
    This is because the logic to test to see if a mount should
    be disconnected in umount_tree is buggy.
    
    Move the logic to decide if a mount should remain connected to
    it's mountpoint into it's own function disconnect_mount so that
    clarity of expression instead of terseness of expression becomes
    a virtue.
    
    When the conditions where it is invalid to leave a mount connected
    are first ruled out, the logic for deciding if a mount should
    be disconnected becomes much clearer and simpler.
    
    Fixes: e0c9c0afd2fc958ffa34b697972721d81df8a56f mnt: Update detach_mounts to leave mounts connected
    Fixes: ce07d891a0891d3c0d0c2d73d577490486b809e1 mnt: Honor MNT_LOCKED when detaching mounts
    Cc: stable@vger.kernel.org
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/pnode.h b/fs/pnode.h
index 7114ce6e6b9e..0fcdbe7ca648 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -20,8 +20,6 @@
 #define SET_MNT_MARK(m) ((m)->mnt.mnt_flags |= MNT_MARKED)
 #define CLEAR_MNT_MARK(m) ((m)->mnt.mnt_flags &= ~MNT_MARKED)
 #define IS_MNT_LOCKED(m) ((m)->mnt.mnt_flags & MNT_LOCKED)
-#define IS_MNT_LOCKED_AND_LAZY(m) \
-	(((m)->mnt.mnt_flags & (MNT_LOCKED|MNT_SYNC_UMOUNT)) == MNT_LOCKED)
 
 #define CL_EXPIRE    		0x01
 #define CL_SLAVE     		0x02

commit ce07d891a0891d3c0d0c2d73d577490486b809e1
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Dec 23 21:37:03 2014 -0600

    mnt: Honor MNT_LOCKED when detaching mounts
    
    Modify umount(MNT_DETACH) to keep mounts in the hash table that are
    locked to their parent mounts, when the parent is lazily unmounted.
    
    In mntput_no_expire detach the children from the hash table, depending
    on mnt_pin_kill in cleanup_mnt to decrement the mnt_count of the children.
    
    In __detach_mounts if there are any mounts that have been unmounted
    but still are on the list of mounts of a mountpoint, remove their
    children from the mount hash table and those children to the unmounted
    list so they won't linger potentially indefinitely waiting for their
    final mntput, now that the mounts serve no purpose.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/pnode.h b/fs/pnode.h
index 0fcdbe7ca648..7114ce6e6b9e 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -20,6 +20,8 @@
 #define SET_MNT_MARK(m) ((m)->mnt.mnt_flags |= MNT_MARKED)
 #define CLEAR_MNT_MARK(m) ((m)->mnt.mnt_flags &= ~MNT_MARKED)
 #define IS_MNT_LOCKED(m) ((m)->mnt.mnt_flags & MNT_LOCKED)
+#define IS_MNT_LOCKED_AND_LAZY(m) \
+	(((m)->mnt.mnt_flags & (MNT_LOCKED|MNT_SYNC_UMOUNT)) == MNT_LOCKED)
 
 #define CL_EXPIRE    		0x01
 #define CL_SLAVE     		0x02

commit 0c56fe31420ca599c90240315f7959bf1b4eb6ce
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Jan 5 13:38:04 2015 -0600

    mnt: Don't propagate unmounts to locked mounts
    
    If the first mount in shared subtree is locked don't unmount the
    shared subtree.
    
    This is ensured by walking through the mounts parents before children
    and marking a mount as unmountable if it is not locked or it is locked
    but it's parent is marked.
    
    This allows recursive mount detach to propagate through a set of
    mounts when unmounting them would not reveal what is under any locked
    mount.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/pnode.h b/fs/pnode.h
index af47d4bd7b31..0fcdbe7ca648 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -19,6 +19,7 @@
 #define IS_MNT_MARKED(m) ((m)->mnt.mnt_flags & MNT_MARKED)
 #define SET_MNT_MARK(m) ((m)->mnt.mnt_flags |= MNT_MARKED)
 #define CLEAR_MNT_MARK(m) ((m)->mnt.mnt_flags &= ~MNT_MARKED)
+#define IS_MNT_LOCKED(m) ((m)->mnt.mnt_flags & MNT_LOCKED)
 
 #define CL_EXPIRE    		0x01
 #define CL_SLAVE     		0x02

commit 5d88457eb5b86b475422dc882f089203faaeedb5
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Jan 3 05:39:35 2015 -0600

    mnt: On an unmount propagate clearing of MNT_LOCKED
    
    A prerequisite of calling umount_tree is that the point where the tree
    is mounted at is valid to unmount.
    
    If we are propagating the effect of the unmount clear MNT_LOCKED in
    every instance where the same filesystem is mounted on the same
    mountpoint in the mount tree, as we know (by virtue of the fact
    that umount_tree was called) that it is safe to reveal what
    is at that mountpoint.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/pnode.h b/fs/pnode.h
index aa6d65df7204..af47d4bd7b31 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -42,6 +42,7 @@ int propagate_mnt(struct mount *, struct mountpoint *, struct mount *,
 		struct hlist_head *);
 int propagate_umount(struct list_head *);
 int propagate_mount_busy(struct mount *, int);
+void propagate_mount_unlock(struct mount *);
 void mnt_release_group_id(struct mount *);
 int get_dominating_id(struct mount *mnt, const struct path *root);
 unsigned int mnt_get_count(struct mount *mnt);

commit c003b26ff98ca04a180ff34c38c007a3998d62f9
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Dec 18 13:10:48 2014 -0600

    mnt: In umount_tree reuse mnt_list instead of mnt_hash
    
    umount_tree builds a list of mounts that need to be unmounted.
    Utilize mnt_list for this purpose instead of mnt_hash.  This begins to
    allow keeping a mount on the mnt_hash after it is unmounted, which is
    necessary for a properly functioning MNT_LOCKED implementation.
    
    The fact that mnt_list is an ordinary list makding available list_move
    is nice bonus.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/pnode.h b/fs/pnode.h
index 16afc3d6d2f2..aa6d65df7204 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -40,7 +40,7 @@ static inline void set_mnt_shared(struct mount *mnt)
 void change_mnt_propagation(struct mount *, int);
 int propagate_mnt(struct mount *, struct mountpoint *, struct mount *,
 		struct hlist_head *);
-int propagate_umount(struct hlist_head *);
+int propagate_umount(struct list_head *);
 int propagate_mount_busy(struct mount *, int);
 void mnt_release_group_id(struct mount *);
 int get_dominating_id(struct mount *mnt, const struct path *root);

commit e819f152104c9f7c9fe50e1aecce6f5d4bf06d65
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Dec 24 07:20:01 2014 -0600

    mnt: Improve the umount_tree flags
    
    - Remove the unneeded declaration from pnode.h
    - Mark umount_tree static as it has no callers outside of namespace.c
    - Define an enumeration of umount_tree's flags.
    - Pass umount_tree's flags in by name
    
    This removes the magic numbers 0, 1 and 2 making the code a little
    clearer and makes it possible for there to be lazy unmounts that don't
    propagate.  Which is what __detach_mounts actually wants for example.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/pnode.h b/fs/pnode.h
index 4a246358b031..16afc3d6d2f2 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -47,7 +47,6 @@ int get_dominating_id(struct mount *mnt, const struct path *root);
 unsigned int mnt_get_count(struct mount *mnt);
 void mnt_set_mountpoint(struct mount *, struct mountpoint *,
 			struct mount *);
-void umount_tree(struct mount *, int);
 struct mount *copy_tree(struct mount *, struct dentry *, int);
 bool is_path_reachable(struct mount *, struct dentry *,
 			 const struct path *root);

commit f2ebb3a921c1ca1e2ddd9242e95a1989a50c4c68
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Feb 27 09:35:45 2014 -0500

    smarter propagate_mnt()
    
    The current mainline has copies propagated to *all* nodes, then
    tears down the copies we made for nodes that do not contain
    counterparts of the desired mountpoint.  That sets the right
    propagation graph for the copies (at teardown time we move
    the slaves of removed node to a surviving peer or directly
    to master), but we end up paying a fairly steep price in
    useless allocations.  It's fairly easy to create a situation
    where N calls of mount(2) create exactly N bindings, with
    O(N^2) vfsmounts allocated and freed in process.
    
    Fortunately, it is possible to avoid those allocations/freeings.
    The trick is to create copies in the right order and find which
    one would've eventually become a master with the current algorithm.
    It turns out to be possible in O(nodes getting propagation) time
    and with no extra allocations at all.
    
    One part is that we need to make sure that eventual master will be
    created before its slaves, so we need to walk the propagation
    tree in a different order - by peer groups.  And iterate through
    the peers before dealing with the next group.
    
    Another thing is finding the (earlier) copy that will be a master
    of one we are about to create; to do that we are (temporary) marking
    the masters of mountpoints we are attaching the copies to.
    
    Either we are in a peer of the last mountpoint we'd dealt with,
    or we have the following situation: we are attaching to mountpoint M,
    the last copy S_0 had been attached to M_0 and there are sequences
    S_0...S_n, M_0...M_n such that S_{i+1} is a master of S_{i},
    S_{i} mounted on M{i} and we need to create a slave of the first S_{k}
    such that M is getting propagation from M_{k}.  It means that the master
    of M_{k} will be among the sequence of masters of M.  On the
    other hand, the nearest marked node in that sequence will either
    be the master of M_{k} or the master of M_{k-1} (the latter -
    in the case if M_{k-1} is a slave of something M gets propagation
    from, but in a wrong peer group).
    
    So we go through the sequence of masters of M until we find
    a marked one (P).  Let N be the one before it.  Then we go through
    the sequence of masters of S_0 until we find one (say, S) mounted
    on a node D that has P as master and check if D is a peer of N.
    If it is, S will be the master of new copy, if not - the master of S
    will be.
    
    That's it for the hard part; the rest is fairly simple.  Iterator
    is in next_group(), handling of one prospective mountpoint is
    propagate_one().
    
    It seems to survive all tests and gives a noticably better performance
    than the current mainline for setups that are seriously using shared
    subtrees.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index fc28a27fa892..4a246358b031 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -16,6 +16,9 @@
 #define IS_MNT_NEW(m)  (!(m)->mnt_ns)
 #define CLEAR_MNT_SHARED(m) ((m)->mnt.mnt_flags &= ~MNT_SHARED)
 #define IS_MNT_UNBINDABLE(m) ((m)->mnt.mnt_flags & MNT_UNBINDABLE)
+#define IS_MNT_MARKED(m) ((m)->mnt.mnt_flags & MNT_MARKED)
+#define SET_MNT_MARK(m) ((m)->mnt.mnt_flags |= MNT_MARKED)
+#define CLEAR_MNT_MARK(m) ((m)->mnt.mnt_flags &= ~MNT_MARKED)
 
 #define CL_EXPIRE    		0x01
 #define CL_SLAVE     		0x02

commit 38129a13e6e71f666e0468e99fdd932a687b4d7e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Mar 20 21:10:51 2014 -0400

    switch mnt_hash to hlist
    
    fixes RCU bug - walking through hlist is safe in face of element moves,
    since it's self-terminating.  Cyclic lists are not - if we end up jumping
    to another hash chain, we'll loop infinitely without ever hitting the
    original list head.
    
    [fix for dumb braino folded]
    
    Spotted by: Max Kellermann <mk@cm4all.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 59e7eda1851e..fc28a27fa892 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -36,8 +36,8 @@ static inline void set_mnt_shared(struct mount *mnt)
 
 void change_mnt_propagation(struct mount *, int);
 int propagate_mnt(struct mount *, struct mountpoint *, struct mount *,
-		struct list_head *);
-int propagate_umount(struct list_head *);
+		struct hlist_head *);
+int propagate_umount(struct hlist_head *);
 int propagate_mount_busy(struct mount *, int);
 void mnt_release_group_id(struct mount *);
 int get_dominating_id(struct mount *mnt, const struct path *root);

commit 4ce5d2b1a8fde84c0eebe70652cf28b9beda6b4e
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Mar 30 01:35:18 2013 -0700

    vfs: Don't copy mount bind mounts of /proc/<pid>/ns/mnt between namespaces
    
    Don't copy bind mounts of /proc/<pid>/ns/mnt between namespaces.
    These files hold references to a mount namespace and copying them
    between namespaces could result in a reference counting loop.
    
    The current mnt_ns_loop test prevents loops on the assumption that
    mounts don't cross between namespaces.  Unfortunately unsharing a
    mount namespace and shared substrees can both cause mounts to
    propogate between mount namespaces.
    
    Add two flags CL_COPY_UNBINDABLE and CL_COPY_MNT_NS_FILE are added to
    control this behavior, and CL_COPY_ALL is redefined as both of them.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/pnode.h b/fs/pnode.h
index b091445c1c4a..59e7eda1851e 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -19,11 +19,14 @@
 
 #define CL_EXPIRE    		0x01
 #define CL_SLAVE     		0x02
-#define CL_COPY_ALL 		0x04
+#define CL_COPY_UNBINDABLE	0x04
 #define CL_MAKE_SHARED 		0x08
 #define CL_PRIVATE 		0x10
 #define CL_SHARED_TO_SLAVE	0x20
 #define CL_UNPRIVILEGED		0x40
+#define CL_COPY_MNT_NS_FILE	0x80
+
+#define CL_COPY_ALL		(CL_COPY_UNBINDABLE | CL_COPY_MNT_NS_FILE)
 
 static inline void set_mnt_shared(struct mount *mnt)
 {

commit 20b4fb485227404329e41ad15588afad3df23050
Merge: b9394d8a657c ac3e3c5b1164
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 1 17:51:54 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull VFS updates from Al Viro,
    
    Misc cleanups all over the place, mainly wrt /proc interfaces (switch
    create_proc_entry to proc_create(), get rid of the deprecated
    create_proc_read_entry() in favor of using proc_create_data() and
    seq_file etc).
    
    7kloc removed.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (204 commits)
      don't bother with deferred freeing of fdtables
      proc: Move non-public stuff from linux/proc_fs.h to fs/proc/internal.h
      proc: Make the PROC_I() and PDE() macros internal to procfs
      proc: Supply a function to remove a proc entry by PDE
      take cgroup_open() and cpuset_open() to fs/proc/base.c
      ppc: Clean up scanlog
      ppc: Clean up rtas_flash driver somewhat
      hostap: proc: Use remove_proc_subtree()
      drm: proc: Use remove_proc_subtree()
      drm: proc: Use minor->index to label things, not PDE->name
      drm: Constify drm_proc_list[]
      zoran: Don't print proc_dir_entry data in debug
      reiserfs: Don't access the proc_dir_entry in r_open(), r_start() r_show()
      proc: Supply an accessor for getting the data from a PDE's parent
      airo: Use remove_proc_subtree()
      rtl8192u: Don't need to save device proc dir PDE
      rtl8187se: Use a dir under /proc/net/r8180/
      proc: Add proc_mkdir_data()
      proc: Move some bits from linux/proc_fs.h to linux/{of.h,signal.h,tty.h}
      proc: Move PDE_NET() to fs/proc/proc_net.c
      ...

commit 328e6d9014636afc2b3c979403b36faadb412657
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 16 14:49:45 2013 -0400

    switch unlock_mount() to namespace_unlock(), convert all umount_tree() callers
    
    which allows to kill the last argument of umount_tree() and make release_mounts()
    static.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index f4357d3a0a44..9eb00ee65bbe 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -40,8 +40,7 @@ int get_dominating_id(struct mount *mnt, const struct path *root);
 unsigned int mnt_get_count(struct mount *mnt);
 void mnt_set_mountpoint(struct mount *, struct mountpoint *,
 			struct mount *);
-void release_mounts(struct list_head *);
-void umount_tree(struct mount *, int, struct list_head *);
+void umount_tree(struct mount *, int);
 struct mount *copy_tree(struct mount *, struct dentry *, int);
 bool is_path_reachable(struct mount *, struct dentry *,
 			 const struct path *root);

commit 84d17192d2afd52aeba88c71ae4959a015f56a38
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 15 10:53:28 2013 -0400

    get rid of full-hash scan on detaching vfsmounts
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 19b853a3445c..f4357d3a0a44 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -31,14 +31,14 @@ static inline void set_mnt_shared(struct mount *mnt)
 }
 
 void change_mnt_propagation(struct mount *, int);
-int propagate_mnt(struct mount *, struct dentry *, struct mount *,
+int propagate_mnt(struct mount *, struct mountpoint *, struct mount *,
 		struct list_head *);
 int propagate_umount(struct list_head *);
 int propagate_mount_busy(struct mount *, int);
 void mnt_release_group_id(struct mount *);
 int get_dominating_id(struct mount *mnt, const struct path *root);
 unsigned int mnt_get_count(struct mount *mnt);
-void mnt_set_mountpoint(struct mount *, struct dentry *,
+void mnt_set_mountpoint(struct mount *, struct mountpoint *,
 			struct mount *);
 void release_mounts(struct list_head *);
 void umount_tree(struct mount *, int, struct list_head *);

commit 132c94e31b8bca8ea921f9f96a57d684fa4ae0a9
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Mar 22 04:08:05 2013 -0700

    vfs: Carefully propogate mounts across user namespaces
    
    As a matter of policy MNT_READONLY should not be changable if the
    original mounter had more privileges than creator of the mount
    namespace.
    
    Add the flag CL_UNPRIVILEGED to note when we are copying a mount from
    a mount namespace that requires more privileges to a mount namespace
    that requires fewer privileges.
    
    When the CL_UNPRIVILEGED flag is set cause clone_mnt to set MNT_NO_REMOUNT
    if any of the mnt flags that should never be changed are set.
    
    This protects both mount propagation and the initial creation of a less
    privileged mount namespace.
    
    Cc: stable@vger.kernel.org
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Reported-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/pnode.h b/fs/pnode.h
index 19b853a3445c..a0493d5ebfbf 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -23,6 +23,7 @@
 #define CL_MAKE_SHARED 		0x08
 #define CL_PRIVATE 		0x10
 #define CL_SHARED_TO_SLAVE	0x20
+#define CL_UNPRIVILEGED		0x40
 
 static inline void set_mnt_shared(struct mount *mnt)
 {

commit 7a472ef4be8387bc05a42e16309b02c8ca943a40
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Jul 31 13:13:04 2012 -0700

    vfs: Only support slave subtrees across different user namespaces
    
    Sharing mount subtress with mount namespaces created by unprivileged
    users allows unprivileged mounts created by unprivileged users to
    propagate to mount namespaces controlled by privileged users.
    
    Prevent nasty consequences by changing shared subtrees to slave
    subtress when an unprivileged users creates a new mount namespace.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/pnode.h b/fs/pnode.h
index 65c60979d541..19b853a3445c 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -22,6 +22,7 @@
 #define CL_COPY_ALL 		0x04
 #define CL_MAKE_SHARED 		0x08
 #define CL_PRIVATE 		0x10
+#define CL_SHARED_TO_SLAVE	0x20
 
 static inline void set_mnt_shared(struct mount *mnt)
 {

commit fc7be130c7e91cf693d4bc2d9b11f08a5a4893d0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Nov 25 01:05:37 2011 -0500

    vfs: switch pnode.h macros to struct mount *
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 54deeda0cdb8..65c60979d541 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -11,11 +11,11 @@
 #include <linux/list.h>
 #include "mount.h"
 
-#define IS_MNT_SHARED(mnt) ((mnt)->mnt_flags & MNT_SHARED)
-#define IS_MNT_SLAVE(mnt) ((mnt)->mnt_master)
-#define IS_MNT_NEW(mnt)  (!(mnt)->mnt_ns)
-#define CLEAR_MNT_SHARED(mnt) ((mnt)->mnt_flags &= ~MNT_SHARED)
-#define IS_MNT_UNBINDABLE(mnt) ((mnt)->mnt_flags & MNT_UNBINDABLE)
+#define IS_MNT_SHARED(m) ((m)->mnt.mnt_flags & MNT_SHARED)
+#define IS_MNT_SLAVE(m) ((m)->mnt_master)
+#define IS_MNT_NEW(m)  (!(m)->mnt_ns)
+#define CLEAR_MNT_SHARED(m) ((m)->mnt.mnt_flags &= ~MNT_SHARED)
+#define IS_MNT_UNBINDABLE(m) ((m)->mnt.mnt_flags & MNT_UNBINDABLE)
 
 #define CL_EXPIRE    		0x01
 #define CL_SLAVE     		0x02

commit 14cf1fa8f54353d9caf6174c1e4280c8c4dcfd7a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Nov 25 00:01:17 2011 -0500

    vfs: spread struct mount - remaining argument of mnt_set_mountpoint()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 55546a2f9b51..54deeda0cdb8 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -37,7 +37,7 @@ int propagate_mount_busy(struct mount *, int);
 void mnt_release_group_id(struct mount *);
 int get_dominating_id(struct mount *mnt, const struct path *root);
 unsigned int mnt_get_count(struct mount *mnt);
-void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
+void mnt_set_mountpoint(struct mount *, struct dentry *,
 			struct mount *);
 void release_mounts(struct list_head *);
 void umount_tree(struct mount *, int, struct list_head *);

commit a8d56d8e4fa0cb9a023834363f8d79415d277a1d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 24 23:59:29 2011 -0500

    vfs: spread struct mount - propagate_mnt()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 33f1e3cb3cd2..55546a2f9b51 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -30,7 +30,7 @@ static inline void set_mnt_shared(struct mount *mnt)
 }
 
 void change_mnt_propagation(struct mount *, int);
-int propagate_mnt(struct vfsmount *, struct dentry *, struct vfsmount *,
+int propagate_mnt(struct mount *, struct dentry *, struct mount *,
 		struct list_head *);
 int propagate_umount(struct list_head *);
 int propagate_mount_busy(struct mount *, int);

commit 6fc7871fed915914ef441efbe0f9a7c3d0f3bff1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 24 23:35:54 2011 -0500

    vfs: spread struct mount - get_dominating_id / do_make_slave
    
    next pile of horrors, similar to mnt_parent one; this time it's
    mnt_master.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 0a7a919d5efd..33f1e3cb3cd2 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -35,7 +35,7 @@ int propagate_mnt(struct vfsmount *, struct dentry *, struct vfsmount *,
 int propagate_umount(struct list_head *);
 int propagate_mount_busy(struct mount *, int);
 void mnt_release_group_id(struct mount *);
-int get_dominating_id(struct vfsmount *mnt, const struct path *root);
+int get_dominating_id(struct mount *mnt, const struct path *root);
 unsigned int mnt_get_count(struct mount *mnt);
 void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
 			struct mount *);

commit 83adc7532229f1909cf37c429780f02f06fe05ee
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 24 22:37:54 2011 -0500

    vfs: spread struct mount - work with counters
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 866b3e292887..0a7a919d5efd 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -36,7 +36,7 @@ int propagate_umount(struct list_head *);
 int propagate_mount_busy(struct mount *, int);
 void mnt_release_group_id(struct mount *);
 int get_dominating_id(struct vfsmount *mnt, const struct path *root);
-unsigned int mnt_get_count(struct vfsmount *mnt);
+unsigned int mnt_get_count(struct mount *mnt);
 void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
 			struct mount *);
 void release_mounts(struct list_head *);

commit 643822b41e5e0f133438883b0be574cdaf168a2a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 24 22:00:28 2011 -0500

    vfs: spread struct mount - is_path_reachable
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index f1d251d3771e..866b3e292887 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -42,6 +42,6 @@ void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
 void release_mounts(struct list_head *);
 void umount_tree(struct mount *, int, struct list_head *);
 struct mount *copy_tree(struct mount *, struct dentry *, int);
-bool is_path_reachable(struct vfsmount *, struct dentry *,
+bool is_path_reachable(struct mount *, struct dentry *,
 			 const struct path *root);
 #endif /* _LINUX_PNODE_H */

commit 1ab597386205f8dc757cf8750465502aeae65154
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 24 21:35:16 2011 -0500

    vfs: spread struct mount - do_umount/propagate_mount_busy
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index bfd0bbcabf6d..f1d251d3771e 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -33,7 +33,7 @@ void change_mnt_propagation(struct mount *, int);
 int propagate_mnt(struct vfsmount *, struct dentry *, struct vfsmount *,
 		struct list_head *);
 int propagate_umount(struct list_head *);
-int propagate_mount_busy(struct vfsmount *, int);
+int propagate_mount_busy(struct mount *, int);
 void mnt_release_group_id(struct mount *);
 int get_dominating_id(struct vfsmount *mnt, const struct path *root);
 unsigned int mnt_get_count(struct vfsmount *mnt);

commit 44d964d609c7c11b330a3d1caf30767fa13c7be3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 24 21:28:22 2011 -0500

    vfs: spread struct mount mnt_set_mountpoint child argument
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 609ec008d5ce..bfd0bbcabf6d 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -38,7 +38,7 @@ void mnt_release_group_id(struct mount *);
 int get_dominating_id(struct vfsmount *mnt, const struct path *root);
 unsigned int mnt_get_count(struct vfsmount *mnt);
 void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
-			struct vfsmount *);
+			struct mount *);
 void release_mounts(struct list_head *);
 void umount_tree(struct mount *, int, struct list_head *);
 struct mount *copy_tree(struct mount *, struct dentry *, int);

commit 87129cc0e3fcd89a1db3e99d62dc710e05749f77
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 24 21:24:27 2011 -0500

    vfs: spread struct mount - clone_mnt/copy_tree argument
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 3f9ab4f4e0e5..609ec008d5ce 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -41,7 +41,7 @@ void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
 			struct vfsmount *);
 void release_mounts(struct list_head *);
 void umount_tree(struct mount *, int, struct list_head *);
-struct mount *copy_tree(struct vfsmount *, struct dentry *, int);
+struct mount *copy_tree(struct mount *, struct dentry *, int);
 bool is_path_reachable(struct vfsmount *, struct dentry *,
 			 const struct path *root);
 #endif /* _LINUX_PNODE_H */

commit 761d5c38eb3d8e2aa7394726dccab245bfe2f41c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 24 21:07:43 2011 -0500

    vfs: spread struct mount - umount_tree argument
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index ed8a84d6d78f..3f9ab4f4e0e5 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -40,7 +40,7 @@ unsigned int mnt_get_count(struct vfsmount *mnt);
 void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
 			struct vfsmount *);
 void release_mounts(struct list_head *);
-void umount_tree(struct vfsmount *, int, struct list_head *);
+void umount_tree(struct mount *, int, struct list_head *);
 struct mount *copy_tree(struct vfsmount *, struct dentry *, int);
 bool is_path_reachable(struct vfsmount *, struct dentry *,
 			 const struct path *root);

commit cb338d06e9716c92d5a7855e7c67b8f111ced722
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 24 20:55:08 2011 -0500

    vfs: spread struct mount - clone_mnt/copy_tree result
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index a2ad95435c48..ed8a84d6d78f 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -41,7 +41,7 @@ void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
 			struct vfsmount *);
 void release_mounts(struct list_head *);
 void umount_tree(struct vfsmount *, int, struct list_head *);
-struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
+struct mount *copy_tree(struct vfsmount *, struct dentry *, int);
 bool is_path_reachable(struct vfsmount *, struct dentry *,
 			 const struct path *root);
 #endif /* _LINUX_PNODE_H */

commit 0f0afb1dcf01afc44581b3c0da251ac07dfb6e4a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 24 20:43:10 2011 -0500

    vfs: spread struct mount - change_mnt_propagation/set_mnt_shared
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 23dfe22139da..a2ad95435c48 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -23,13 +23,13 @@
 #define CL_MAKE_SHARED 		0x08
 #define CL_PRIVATE 		0x10
 
-static inline void set_mnt_shared(struct vfsmount *mnt)
+static inline void set_mnt_shared(struct mount *mnt)
 {
-	mnt->mnt_flags &= ~MNT_SHARED_MASK;
-	mnt->mnt_flags |= MNT_SHARED;
+	mnt->mnt.mnt_flags &= ~MNT_SHARED_MASK;
+	mnt->mnt.mnt_flags |= MNT_SHARED;
 }
 
-void change_mnt_propagation(struct vfsmount *, int);
+void change_mnt_propagation(struct mount *, int);
 int propagate_mnt(struct vfsmount *, struct dentry *, struct vfsmount *,
 		struct list_head *);
 int propagate_umount(struct list_head *);

commit 4b8b21f4fe16ee15eec5c69ea5fb41b30e428e59
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 24 19:54:23 2011 -0500

    vfs: spread struct mount - mount group id handling
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 5c234e742193..23dfe22139da 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -34,7 +34,7 @@ int propagate_mnt(struct vfsmount *, struct dentry *, struct vfsmount *,
 		struct list_head *);
 int propagate_umount(struct list_head *);
 int propagate_mount_busy(struct vfsmount *, int);
-void mnt_release_group_id(struct vfsmount *);
+void mnt_release_group_id(struct mount *);
 int get_dominating_id(struct vfsmount *mnt, const struct path *root);
 unsigned int mnt_get_count(struct vfsmount *mnt);
 void mnt_set_mountpoint(struct vfsmount *, struct dentry *,

commit aafd08dad019ecc858b31fb89064f4de623c64f7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Nov 23 12:27:01 2011 -0500

    vfs: add missing parens in pnode.h macros
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 723399e76134..5c234e742193 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -11,11 +11,11 @@
 #include <linux/list.h>
 #include "mount.h"
 
-#define IS_MNT_SHARED(mnt) (mnt->mnt_flags & MNT_SHARED)
-#define IS_MNT_SLAVE(mnt) (mnt->mnt_master)
-#define IS_MNT_NEW(mnt)  (!mnt->mnt_ns)
-#define CLEAR_MNT_SHARED(mnt) (mnt->mnt_flags &= ~MNT_SHARED)
-#define IS_MNT_UNBINDABLE(mnt) (mnt->mnt_flags & MNT_UNBINDABLE)
+#define IS_MNT_SHARED(mnt) ((mnt)->mnt_flags & MNT_SHARED)
+#define IS_MNT_SLAVE(mnt) ((mnt)->mnt_master)
+#define IS_MNT_NEW(mnt)  (!(mnt)->mnt_ns)
+#define CLEAR_MNT_SHARED(mnt) ((mnt)->mnt_flags &= ~MNT_SHARED)
+#define IS_MNT_UNBINDABLE(mnt) ((mnt)->mnt_flags & MNT_UNBINDABLE)
 
 #define CL_EXPIRE    		0x01
 #define CL_SLAVE     		0x02

commit afac7cba7ed31968a95e181dc25e204e45009ea8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Nov 23 19:34:49 2011 -0500

    vfs: more mnt_parent cleanups
    
    a) mount --move is checking that ->mnt_parent is non-NULL before
    looking if that parent happens to be shared; ->mnt_parent is never
    NULL and it's not even an misspelled !mnt_has_parent()
    
    b) pivot_root open-codes is_path_reachable(), poorly.
    
    c) so does path_is_under(), while we are at it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 7f0c13ae9484..723399e76134 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -42,4 +42,6 @@ void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
 void release_mounts(struct list_head *);
 void umount_tree(struct vfsmount *, int, struct list_head *);
 struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
+bool is_path_reachable(struct vfsmount *, struct dentry *,
+			 const struct path *root);
 #endif /* _LINUX_PNODE_H */

commit b2dba1af3c4157040303a76d25216b1713d333d0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Nov 23 19:26:23 2011 -0500

    vfs: new internal helper: mnt_has_parent(mnt)
    
    vfsmounts have ->mnt_parent pointing either to a different vfsmount
    or to itself; it's never NULL and termination condition in loops
    traversing the tree towards root is mnt == mnt->mnt_parent.  At least
    one place (see the next patch) is confused about what's going on;
    let's add an explicit helper checking it right way and use it in
    all places where we need it.  Not that there had been too many,
    but...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 391287110274..7f0c13ae9484 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -9,7 +9,7 @@
 #define _LINUX_PNODE_H
 
 #include <linux/list.h>
-#include <linux/mount.h>
+#include "mount.h"
 
 #define IS_MNT_SHARED(mnt) (mnt->mnt_flags & MNT_SHARED)
 #define IS_MNT_SLAVE(mnt) (mnt->mnt_master)

commit f47ec3f28354795f000c14bf18ed967ec81a3ec3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 21 21:15:42 2011 -0500

    trim fs/internal.h
    
    some stuff in there can actually become static; some belongs to pnode.h
    as it's a private interface between namespace.c and pnode.c...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 1ea4ae1efcd3..391287110274 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -36,4 +36,10 @@ int propagate_umount(struct list_head *);
 int propagate_mount_busy(struct vfsmount *, int);
 void mnt_release_group_id(struct vfsmount *);
 int get_dominating_id(struct vfsmount *mnt, const struct path *root);
+unsigned int mnt_get_count(struct vfsmount *mnt);
+void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
+			struct vfsmount *);
+void release_mounts(struct list_head *);
+void umount_tree(struct vfsmount *, int, struct list_head *);
+struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
 #endif /* _LINUX_PNODE_H */

commit 495d6c9c6595ec7b37910dfd42634839431d21fd
Author: Valerie Aurora <vaurora@redhat.com>
Date:   Tue Jan 26 14:20:47 2010 -0500

    VFS: Clean up shared mount flag propagation
    
    The handling of mount flags in set_mnt_shared() got a little tangled
    up during previous cleanups, with the following problems:
    
    * MNT_PNODE_MASK is defined as a literal constant when it should be a
    bitwise xor of other MNT_* flags
    * set_mnt_shared() clears and then sets MNT_SHARED (part of MNT_PNODE_MASK)
    * MNT_PNODE_MASK could use a comment in mount.h
    * MNT_PNODE_MASK is a terrible name, change to MNT_SHARED_MASK
    
    This patch fixes these problems.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 6c7ef3252a26..1ea4ae1efcd3 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -25,7 +25,7 @@
 
 static inline void set_mnt_shared(struct vfsmount *mnt)
 {
-	mnt->mnt_flags &= ~MNT_PNODE_MASK;
+	mnt->mnt_flags &= ~MNT_SHARED_MASK;
 	mnt->mnt_flags |= MNT_SHARED;
 }
 

commit 796a6b521d0eadb338adf8cf7e482351c3a8a7b4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 16 13:28:47 2010 -0500

    Kill CL_PROPAGATION, sanitize fs/pnode.c:get_source()
    
    First of all, get_source() never results in CL_PROPAGATION
    alone.  We either get CL_MAKE_SHARED (for the continuation
    of peer group) or CL_SLAVE (slave that is not shared) or both
    (beginning of peer group among slaves).  Massage the code to
    make that explicit, kill CL_PROPAGATION test in clone_mnt()
    (nothing sets CL_MAKE_SHARED without CL_PROPAGATION and in
    clone_mnt() we are checking CL_PROPAGATION after we'd found
    that there's no CL_SLAVE, so the check for CL_MAKE_SHARED
    would do just as well).
    
    Fix comments, while we are at it...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 958665d662af..6c7ef3252a26 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -21,8 +21,7 @@
 #define CL_SLAVE     		0x02
 #define CL_COPY_ALL 		0x04
 #define CL_MAKE_SHARED 		0x08
-#define CL_PROPAGATION 		0x10
-#define CL_PRIVATE 		0x20
+#define CL_PRIVATE 		0x10
 
 static inline void set_mnt_shared(struct vfsmount *mnt)
 {

commit 97e7e0f71d6d948c25f11f0a33878d9356d9579e
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Thu Mar 27 13:06:26 2008 +0100

    [patch 7/7] vfs: mountinfo: show dominating group id
    
    Show peer group ID of nearest dominating group that has intersection
    with the mount's namespace.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index 973c3f825e7d..958665d662af 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -36,4 +36,5 @@ int propagate_mnt(struct vfsmount *, struct dentry *, struct vfsmount *,
 int propagate_umount(struct list_head *);
 int propagate_mount_busy(struct vfsmount *, int);
 void mnt_release_group_id(struct vfsmount *);
+int get_dominating_id(struct vfsmount *mnt, const struct path *root);
 #endif /* _LINUX_PNODE_H */

commit 521b5d0c40386f4a9805cdec7bd979fc96a86aeb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 28 00:46:41 2008 -0400

    [PATCH] teach seq_file to discard entries
    
    Allow ->show() return SEQ_SKIP; that will discard all
    output from that element and move on.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index f249be2fee7a..973c3f825e7d 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -35,4 +35,5 @@ int propagate_mnt(struct vfsmount *, struct dentry *, struct vfsmount *,
 		struct list_head *);
 int propagate_umount(struct list_head *);
 int propagate_mount_busy(struct vfsmount *, int);
+void mnt_release_group_id(struct vfsmount *);
 #endif /* _LINUX_PNODE_H */

commit 8aec08094570562bc305df33b088926d983c3540
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 7 12:20:32 2007 -0400

    [PATCH] new helpers - collect_mounts() and release_collected_mounts()
    
    Get a snapshot of a subtree, creating private clones of vfsmounts
    for all its components and release such snapshot resp.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/pnode.h b/fs/pnode.h
index d45bd8ec36bf..f249be2fee7a 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -22,6 +22,7 @@
 #define CL_COPY_ALL 		0x04
 #define CL_MAKE_SHARED 		0x08
 #define CL_PROPAGATION 		0x10
+#define CL_PRIVATE 		0x20
 
 static inline void set_mnt_shared(struct vfsmount *mnt)
 {

commit 6b3286ed1169d74fea401367d6d4d6c6ec758a81
Author: Kirill Korotaev <dev@sw.ru>
Date:   Fri Dec 8 02:37:56 2006 -0800

    [PATCH] rename struct namespace to struct mnt_namespace
    
    Rename 'struct namespace' to 'struct mnt_namespace' to avoid confusion with
    other namespaces being developped for the containers : pid, uts, ipc, etc.
    'namespace' variables and attributes are also renamed to 'mnt_ns'
    
    Signed-off-by: Kirill Korotaev <dev@sw.ru>
    Signed-off-by: Cedric Le Goater <clg@fr.ibm.com>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Herbert Poetzl <herbert@13thfloor.at>
    Cc: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/pnode.h b/fs/pnode.h
index 020e1bb60fdb..d45bd8ec36bf 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -13,7 +13,7 @@
 
 #define IS_MNT_SHARED(mnt) (mnt->mnt_flags & MNT_SHARED)
 #define IS_MNT_SLAVE(mnt) (mnt->mnt_master)
-#define IS_MNT_NEW(mnt)  (!mnt->mnt_namespace)
+#define IS_MNT_NEW(mnt)  (!mnt->mnt_ns)
 #define CLEAR_MNT_SHARED(mnt) (mnt->mnt_flags &= ~MNT_SHARED)
 #define IS_MNT_UNBINDABLE(mnt) (mnt->mnt_flags & MNT_UNBINDABLE)
 

commit 9676f0c6389b62bd6b24d77d4b3abdbcfa32d0f2
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Mon Nov 7 17:21:20 2005 -0500

    [PATCH] unbindable mounts
    
    An unbindable mount does not forward or receive propagation.  Also
    unbindable mount disallows bind mounts.  The semantics is as follows.
    
    Bind semantics:
      It is invalid to bind mount an unbindable mount.
    
    Move semantics:
      It is invalid to move an unbindable mount under shared mount.
    
    Clone-namespace semantics:
      If a mount is unbindable in the parent namespace, the corresponding
      cloned mount in the child namespace becomes unbindable too.  Note:
      there is subtle difference, unbindable mounts cannot be bind mounted
      but can be cloned during clone-namespace.
    
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/pnode.h b/fs/pnode.h
index b59f0e9fe6b1..020e1bb60fdb 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -15,6 +15,7 @@
 #define IS_MNT_SLAVE(mnt) (mnt->mnt_master)
 #define IS_MNT_NEW(mnt)  (!mnt->mnt_namespace)
 #define CLEAR_MNT_SHARED(mnt) (mnt->mnt_flags &= ~MNT_SHARED)
+#define IS_MNT_UNBINDABLE(mnt) (mnt->mnt_flags & MNT_UNBINDABLE)
 
 #define CL_EXPIRE    		0x01
 #define CL_SLAVE     		0x02

commit a58b0eb8e64b78d9315a5491955e78b1391d42e5
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Mon Nov 7 17:20:48 2005 -0500

    [PATCH] introduce slave mounts
    
    A slave mount always has a master mount from which it receives
    mount/umount events.  Unlike shared mount the event propagation does not
    flow from the slave mount to the master.
    
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/pnode.h b/fs/pnode.h
index 9b88ba06794a..b59f0e9fe6b1 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -12,10 +12,12 @@
 #include <linux/mount.h>
 
 #define IS_MNT_SHARED(mnt) (mnt->mnt_flags & MNT_SHARED)
+#define IS_MNT_SLAVE(mnt) (mnt->mnt_master)
 #define IS_MNT_NEW(mnt)  (!mnt->mnt_namespace)
 #define CLEAR_MNT_SHARED(mnt) (mnt->mnt_flags &= ~MNT_SHARED)
 
 #define CL_EXPIRE    		0x01
+#define CL_SLAVE     		0x02
 #define CL_COPY_ALL 		0x04
 #define CL_MAKE_SHARED 		0x08
 #define CL_PROPAGATION 		0x10

commit a05964f3917c7c55368c229d7985f8e7c9977e97
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Mon Nov 7 17:20:17 2005 -0500

    [PATCH] shared mounts handling: umount
    
    An unmount of a mount creates a umount event on the parent.  If the
    parent is a shared mount, it gets propagated to all mounts in the peer
    group.
    
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/pnode.h b/fs/pnode.h
index c62c72fad212..9b88ba06794a 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -29,4 +29,6 @@ static inline void set_mnt_shared(struct vfsmount *mnt)
 void change_mnt_propagation(struct vfsmount *, int);
 int propagate_mnt(struct vfsmount *, struct dentry *, struct vfsmount *,
 		struct list_head *);
+int propagate_umount(struct list_head *);
+int propagate_mount_busy(struct vfsmount *, int);
 #endif /* _LINUX_PNODE_H */

commit b90fa9ae8f51f098ee480bbaabd6867992e9fc58
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Mon Nov 7 17:19:50 2005 -0500

    [PATCH] shared mount handling: bind and rbind
    
    Implement handling of MS_BIND in presense of shared mounts (see
    Documentation/sharedsubtree.txt in the end of patch series for detailed
    description).
    
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/pnode.h b/fs/pnode.h
index ab1bdaee4e08..c62c72fad212 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -12,7 +12,21 @@
 #include <linux/mount.h>
 
 #define IS_MNT_SHARED(mnt) (mnt->mnt_flags & MNT_SHARED)
+#define IS_MNT_NEW(mnt)  (!mnt->mnt_namespace)
 #define CLEAR_MNT_SHARED(mnt) (mnt->mnt_flags &= ~MNT_SHARED)
 
+#define CL_EXPIRE    		0x01
+#define CL_COPY_ALL 		0x04
+#define CL_MAKE_SHARED 		0x08
+#define CL_PROPAGATION 		0x10
+
+static inline void set_mnt_shared(struct vfsmount *mnt)
+{
+	mnt->mnt_flags &= ~MNT_PNODE_MASK;
+	mnt->mnt_flags |= MNT_SHARED;
+}
+
 void change_mnt_propagation(struct vfsmount *, int);
+int propagate_mnt(struct vfsmount *, struct dentry *, struct vfsmount *,
+		struct list_head *);
 #endif /* _LINUX_PNODE_H */

commit 03e06e68ff76294e53ffa898cb844d2a997b043e
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Mon Nov 7 17:19:33 2005 -0500

    [PATCH] introduce shared mounts
    
    This creates shared mounts.  A shared mount when bind-mounted to some
    mountpoint, propagates mount/umount events to each other.  All the
    shared mounts that propagate events to each other belong to the same
    peer-group.
    
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/pnode.h b/fs/pnode.h
index 33549a3a74eb..ab1bdaee4e08 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -10,5 +10,9 @@
 
 #include <linux/list.h>
 #include <linux/mount.h>
+
+#define IS_MNT_SHARED(mnt) (mnt->mnt_flags & MNT_SHARED)
+#define CLEAR_MNT_SHARED(mnt) (mnt->mnt_flags &= ~MNT_SHARED)
+
 void change_mnt_propagation(struct vfsmount *, int);
 #endif /* _LINUX_PNODE_H */

commit 07b20889e3052c7e77d6a6a54e7e83446eb1ba84
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Mon Nov 7 17:19:07 2005 -0500

    [PATCH] beginning of the shared-subtree proper
    
    A private mount does not forward or receive propagation.  This patch
    provides user the ability to convert any mount to private.
    
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/pnode.h b/fs/pnode.h
new file mode 100644
index 000000000000..33549a3a74eb
--- /dev/null
+++ b/fs/pnode.h
@@ -0,0 +1,14 @@
+/*
+ *  linux/fs/pnode.h
+ *
+ * (C) Copyright IBM Corporation 2005.
+ *	Released under GPL v2.
+ *
+ */
+#ifndef _LINUX_PNODE_H
+#define _LINUX_PNODE_H
+
+#include <linux/list.h>
+#include <linux/mount.h>
+void change_mnt_propagation(struct vfsmount *, int);
+#endif /* _LINUX_PNODE_H */
