commit 8d92890bd6b8502d6aee4b37430ae6444ade7a8c
Author: NeilBrown <neilb@suse.de>
Date:   Mon Jun 1 21:48:21 2020 -0700

    mm/writeback: discard NR_UNSTABLE_NFS, use NR_WRITEBACK instead
    
    After an NFS page has been written it is considered "unstable" until a
    COMMIT request succeeds.  If the COMMIT fails, the page will be
    re-written.
    
    These "unstable" pages are currently accounted as "reclaimable", either
    in WB_RECLAIMABLE, or in NR_UNSTABLE_NFS which is included in a
    'reclaimable' count.  This might have made sense when sending the COMMIT
    required a separate action by the VFS/MM (e.g.  releasepage() used to
    send a COMMIT).  However now that all writes generated by ->writepages()
    will automatically be followed by a COMMIT (since commit 919e3bd9a875
    ("NFS: Ensure we commit after writeback is complete")) it makes more
    sense to treat them as writeback pages.
    
    So this patch removes NR_UNSTABLE_NFS and accounts unstable pages in
    NR_WRITEBACK and WB_WRITEBACK.
    
    A particular effect of this change is that when
    wb_check_background_flush() calls wb_over_bg_threshold(), the latter
    will report 'true' a lot less often as the 'unstable' pages are no
    longer considered 'dirty' (as there is nothing that writeback can do
    about them anyway).
    
    Currently wb_check_background_flush() will trigger writeback to NFS even
    when there are relatively few dirty pages (if there are lots of unstable
    pages), this can result in small writes going to the server (10s of
    Kilobytes rather than a Megabyte) which hurts throughput.  With this
    patch, there are fewer writes which are each larger on average.
    
    Where the NR_UNSTABLE_NFS count was included in statistics
    virtual-files, the entry is retained, but the value is hard-coded as
    zero.  static trace points and warning printks which mentioned this
    counter no longer report it.
    
    [akpm@linux-foundation.org: re-layout comment]
    [akpm@linux-foundation.org: fix printk warning]
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Acked-by: Michal Hocko <mhocko@suse.com>        [mm]
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Link: http://lkml.kernel.org/r/87d06j7gqa.fsf@notabene.neil.brown.name
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 1f32a9fbfdaf..6673a77884d9 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -668,7 +668,8 @@ void nfs_super_set_maxbytes(struct super_block *sb, __u64 maxfilesize)
 }
 
 /*
- * Record the page as unstable and mark its inode as dirty.
+ * Record the page as unstable (an extra writeback period) and mark its
+ * inode as dirty.
  */
 static inline
 void nfs_mark_page_unstable(struct page *page, struct nfs_commit_info *cinfo)
@@ -676,8 +677,11 @@ void nfs_mark_page_unstable(struct page *page, struct nfs_commit_info *cinfo)
 	if (!cinfo->dreq) {
 		struct inode *inode = page_file_mapping(page)->host;
 
-		inc_node_page_state(page, NR_UNSTABLE_NFS);
-		inc_wb_stat(&inode_to_bdi(inode)->wb, WB_RECLAIMABLE);
+		/* This page is really still in write-back - just that the
+		 * writeback is happening on the server now.
+		 */
+		inc_node_page_state(page, NR_WRITEBACK);
+		inc_wb_stat(&inode_to_bdi(inode)->wb, WB_WRITEBACK);
 		__mark_inode_dirty(inode, I_DIRTY_DATASYNC);
 	}
 }

commit 377840ee48cde0700678ef14141106bbd13e00b5
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Sun Mar 29 20:03:33 2020 -0400

    NFS: Remove the redundant function nfs_pgio_has_mirroring()
    
    We need to trust that desc->pg_mirror_idx is set correctly, whether
    or not mirroring is enabled.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 78f317fac940..1f32a9fbfdaf 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -274,12 +274,6 @@ void nfs_free_request(struct nfs_page *req);
 struct nfs_pgio_mirror *
 nfs_pgio_current_mirror(struct nfs_pageio_descriptor *desc);
 
-static inline bool nfs_pgio_has_mirroring(struct nfs_pageio_descriptor *desc)
-{
-	WARN_ON_ONCE(desc->pg_mirror_count < 1);
-	return desc->pg_mirror_count > 1;
-}
-
 static inline bool nfs_match_open_context(const struct nfs_open_context *ctx1,
 		const struct nfs_open_context *ctx2)
 {

commit 0aa647b7369dd29de0789c321111b2e4668c46b2
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Sat Mar 21 09:50:05 2020 -0400

    NFS: Remove bucket array from struct pnfs_ds_commit_info
    
    Remove the unused bucket array in struct pnfs_ds_commit_info.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 683146a51599..78f317fac940 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -531,9 +531,6 @@ void nfs_clear_pnfs_ds_commit_verifiers(struct pnfs_ds_commit_info *cinfo)
 {
 	struct pnfs_commit_array *array;
 
-	pnfs_bucket_clear_pnfs_ds_commit_verifiers(cinfo->buckets,
-			cinfo->nbuckets);
-
 	rcu_read_lock();
 	list_for_each_entry_rcu(array, &cinfo->commits, cinfo_list)
 		pnfs_bucket_clear_pnfs_ds_commit_verifiers(array->buckets,

commit a9901899b649dc80ef75c14d6d78059cae14def7
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Fri Mar 20 16:04:06 2020 -0400

    pNFS: Add infrastructure for cleaning up per-layout commit structures
    
    Ensure that both the file and flexfiles layout types clean up when
    freeing the layout segments.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 4a1adad3740f..683146a51599 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -534,9 +534,11 @@ void nfs_clear_pnfs_ds_commit_verifiers(struct pnfs_ds_commit_info *cinfo)
 	pnfs_bucket_clear_pnfs_ds_commit_verifiers(cinfo->buckets,
 			cinfo->nbuckets);
 
-	list_for_each_entry(array, &cinfo->commits, cinfo_list)
+	rcu_read_lock();
+	list_for_each_entry_rcu(array, &cinfo->commits, cinfo_list)
 		pnfs_bucket_clear_pnfs_ds_commit_verifiers(array->buckets,
 				array->nbuckets);
+	rcu_read_unlock();
 }
 #else
 static inline

commit e3b9f7e60b71d3a652ab80665e724d22d61dd629
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Fri Mar 20 19:06:48 2020 -0400

    NFS/pNFS: Support commit arrays in nfs_clear_pnfs_ds_commit_verifiers()
    
    Add support for scanning the full list of per-layout segment commit
    arrays to nfs_clear_pnfs_ds_commit_verifiers().
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 6542411c020f..4a1adad3740f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -517,13 +517,26 @@ int nfs_filemap_write_and_wait_range(struct address_space *mapping,
 		loff_t lstart, loff_t lend);
 
 #ifdef CONFIG_NFS_V4_1
+static inline void
+pnfs_bucket_clear_pnfs_ds_commit_verifiers(struct pnfs_commit_bucket *buckets,
+		unsigned int nbuckets)
+{
+	unsigned int i;
+
+	for (i = 0; i < nbuckets; i++)
+		buckets[i].direct_verf.committed = NFS_INVALID_STABLE_HOW;
+}
 static inline
 void nfs_clear_pnfs_ds_commit_verifiers(struct pnfs_ds_commit_info *cinfo)
 {
-	int i;
+	struct pnfs_commit_array *array;
+
+	pnfs_bucket_clear_pnfs_ds_commit_verifiers(cinfo->buckets,
+			cinfo->nbuckets);
 
-	for (i = 0; i < cinfo->nbuckets; i++)
-		cinfo->buckets[i].direct_verf.committed = NFS_INVALID_STABLE_HOW;
+	list_for_each_entry(array, &cinfo->commits, cinfo_list)
+		pnfs_bucket_clear_pnfs_ds_commit_verifiers(array->buckets,
+				array->nbuckets);
 }
 #else
 static inline

commit 1f28476dcb98797e838a0c1dd6eae2fda213dd81
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Sat Mar 21 09:27:46 2020 -0400

    NFS: Fix O_DIRECT commit verifier handling
    
    Instead of trying to save the commit verifiers and checking them against
    previous writes, adopt the same strategy as for buffered writes, of
    just checking the verifiers at commit time.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 3b6fa9edc9b5..6542411c020f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -544,6 +544,14 @@ nfs_write_verifier_cmp(const struct nfs_write_verifier *v1,
 	return memcmp(v1->data, v2->data, sizeof(v1->data));
 }
 
+static inline bool
+nfs_write_match_verf(const struct nfs_writeverf *verf,
+		struct nfs_page *req)
+{
+	return verf->committed > NFS_UNSTABLE &&
+		!nfs_write_verifier_cmp(&req->wb_verf, &verf->verifier);
+}
+
 /* unlink.c */
 extern struct rpc_task *
 nfs_async_rename(struct inode *old_dir, struct inode *new_dir,

commit 3c9e502b59fbd243cfac7cc6c875e432d285102a
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Wed Feb 26 19:16:09 2020 -0500

    NFS: Add a helper nfs_client_for_each_server()
    
    Add a helper nfs_client_for_each_server() to iterate through all the
    filesystems that are attached to a struct nfs_client, and apply
    a function to all the active ones.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index f80c47d5ff27..3b6fa9edc9b5 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -417,7 +417,9 @@ extern int __init register_nfs_fs(void);
 extern void __exit unregister_nfs_fs(void);
 extern bool nfs_sb_active(struct super_block *sb);
 extern void nfs_sb_deactive(struct super_block *sb);
-
+extern int nfs_client_for_each_server(struct nfs_client *clp,
+				      int (*fn)(struct nfs_server *, void *),
+				      void *data);
 /* io.c */
 extern void nfs_start_io_read(struct inode *inode);
 extern void nfs_end_io_read(struct inode *inode);

commit f7b37b8b139860ed786bf8ce4358290c6053d94d
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Tue Jan 14 12:06:34 2020 -0500

    NFS: Add softreval behaviour to nfs_lookup_revalidate()
    
    If the server is unavaliable, we want to allow the revalidating
    lookup to time out, and to default to validating the cached dentry
    if the 'softreval' mount option is set.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 17f082442804..f80c47d5ff27 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -33,6 +33,15 @@ static inline int nfs_attr_use_mounted_on_fileid(struct nfs_fattr *fattr)
 	return 1;
 }
 
+static inline bool nfs_lookup_is_soft_revalidate(const struct dentry *dentry)
+{
+	if (!(NFS_SB(dentry->d_sb)->flags & NFS_MOUNT_SOFTREVAL))
+		return false;
+	if (!d_is_positive(dentry) || !NFS_FH(d_inode(dentry))->size)
+		return false;
+	return true;
+}
+
 /*
  * Note: RFC 1813 doesn't limit the number of auth flavors that
  * a server can return, so make something up.

commit ae08483cdd666045b60ceb502dcbf30038334d58
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Nov 11 21:16:23 2019 +0100

    nfs: use timespec64 in nfs_fattr
    
    Push down the use of timespec64 into NFS nfs_fattr, to avoid needless
    conversions, and get closer to having 64-bit time_t support on 32-bit
    NFSv4 and removing some old interfaces from the kernel.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index c0257411e158..17f082442804 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -697,9 +697,9 @@ unsigned int nfs_page_array_len(unsigned int base, size_t len)
 }
 
 /*
- * Convert a struct timespec into a 64-bit change attribute
+ * Convert a struct timespec64 into a 64-bit change attribute
  *
- * This does approximately the same thing as timespec_to_ns(),
+ * This does approximately the same thing as timespec64_to_ns(),
  * but for calculation efficiency, we multiply the seconds by
  * 1024*1024*1024.
  */

commit ce8866f0913ff157edc098f06bad07763ad317e7
Author: Scott Mayhew <smayhew@redhat.com>
Date:   Tue Dec 10 07:31:15 2019 -0500

    NFS: Attach supplementary error information to fs_context.
    
    Split out from commit "NFS: Add fs_context support."
    
    Add wrappers nfs_errorf(), nfs_invalf(), and nfs_warnf() which log error
    information to the fs_context.  Convert some printk's to use these new
    wrappers instead.
    
    Signed-off-by: Scott Mayhew <smayhew@redhat.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index a1fd4c3ebc4e..c0257411e158 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -133,6 +133,10 @@ struct nfs_fs_context {
 	} clone_data;
 };
 
+#define nfs_errorf(fc, fmt, ...) errorf(fc, fmt, ## __VA_ARGS__)
+#define nfs_invalf(fc, fmt, ...) invalf(fc, fmt, ## __VA_ARGS__)
+#define nfs_warnf(fc, fmt, ...) warnf(fc, fmt, ## __VA_ARGS__)
+
 static inline struct nfs_fs_context *nfs_fc2context(const struct fs_context *fc)
 {
 	return fc->fs_private;

commit 62a55d088cd87d480a6fd67b0d63b14ccae80838
Author: Scott Mayhew <smayhew@redhat.com>
Date:   Tue Dec 10 07:31:14 2019 -0500

    NFS: Additional refactoring for fs_context conversion
    
    Split out from commit "NFS: Add fs_context support."
    
    This patch adds additional refactoring for the conversion of NFS to use
    fs_context, namely:
    
     (*) Merge nfs_mount_info and nfs_clone_mount into nfs_fs_context.
         nfs_clone_mount has had several fields removed, and nfs_mount_info
         has been removed altogether.
     (*) Various functions now take an fs_context as an argument instead
         of nfs_mount_info, nfs_fs_context, etc.
    
    Signed-off-by: Scott Mayhew <smayhew@redhat.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 1cd09df9e0b5..a1fd4c3ebc4e 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -11,7 +11,7 @@
 #include <linux/nfs_page.h>
 #include <linux/wait_bit.h>
 
-#define NFS_MS_MASK (SB_RDONLY|SB_NOSUID|SB_NODEV|SB_NOEXEC|SB_SYNCHRONOUS)
+#define NFS_SB_MASK (SB_RDONLY|SB_NOSUID|SB_NODEV|SB_NOEXEC|SB_SYNCHRONOUS)
 
 extern const struct export_operations nfs_export_ops;
 
@@ -33,17 +33,6 @@ static inline int nfs_attr_use_mounted_on_fileid(struct nfs_fattr *fattr)
 	return 1;
 }
 
-struct nfs_clone_mount {
-	const struct super_block *sb;
-	struct dentry *dentry;
-	char *hostname;
-	char *mnt_path;
-	struct sockaddr *addr;
-	size_t addrlen;
-	rpc_authflavor_t authflavor;
-	struct nfs_fattr *fattr;
-};
-
 /*
  * Note: RFC 1813 doesn't limit the number of auth flavors that
  * a server can return, so make something up.
@@ -80,15 +69,6 @@ struct nfs_client_initdata {
 	const struct cred *cred;
 };
 
-struct nfs_mount_info {
-	unsigned int inherited_bsize;
-	struct nfs_fs_context *ctx;
-	struct nfs_clone_mount *cloned;
-	struct nfs_server *server;
-	struct nfs_fh *mntfh;
-	struct nfs_subversion *nfs_mod;
-};
-
 /*
  * In-kernel mount arguments
  */
@@ -140,13 +120,17 @@ struct nfs_fs_context {
 		unsigned short		export_path_len;
 	} nfs_server;
 
-	void			*lsm_opts;
-	struct net		*net;
-
-	char			buf[32];	/* Parse buffer */
-
-	struct nfs_mount_info	mount_info;
-	struct nfs_clone_mount	clone_data;
+	struct nfs_fh		*mntfh;
+	struct nfs_server	*server;
+	struct nfs_subversion	*nfs_mod;
+
+	/* Information for a cloned mount. */
+	struct nfs_clone_mount {
+		struct super_block	*sb;
+		struct dentry		*dentry;
+		struct nfs_fattr	*fattr;
+		unsigned int		inherited_bsize;
+	} clone_data;
 };
 
 static inline struct nfs_fs_context *nfs_fc2context(const struct fs_context *fc)
@@ -194,10 +178,9 @@ extern struct nfs_client *nfs4_find_client_ident(struct net *, int);
 extern struct nfs_client *
 nfs4_find_client_sessionid(struct net *, const struct sockaddr *,
 				struct nfs4_sessionid *, u32);
-extern struct nfs_server *nfs_create_server(struct nfs_mount_info *);
-extern struct nfs_server *nfs4_create_server(struct nfs_mount_info *);
-extern struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *,
-						      struct nfs_fh *);
+extern struct nfs_server *nfs_create_server(struct fs_context *);
+extern struct nfs_server *nfs4_create_server(struct fs_context *);
+extern struct nfs_server *nfs4_create_referral_server(struct fs_context *);
 extern int nfs4_update_server(struct nfs_server *server, const char *hostname,
 					struct sockaddr *sap, size_t salen,
 					struct net *net);
@@ -444,12 +427,8 @@ int nfs_submount(struct fs_context *, struct nfs_server *);
 int nfs_do_submount(struct fs_context *);
 
 /* getroot.c */
-extern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *,
-				   const char *);
+extern int nfs_get_root(struct super_block *s, struct fs_context *fc);
 #if IS_ENABLED(CONFIG_NFS_V4)
-extern struct dentry *nfs4_get_root(struct super_block *, struct nfs_fh *,
-				    const char *);
-
 extern int nfs4_get_rootfh(struct nfs_server *server, struct nfs_fh *mntfh, bool);
 #endif
 

commit f2aedb713c284429987dc66c7aaf38decfc8da2a
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 10 07:31:13 2019 -0500

    NFS: Add fs_context support.
    
    Add filesystem context support to NFS, parsing the options in advance and
    attaching the information to struct nfs_fs_context.  The highlights are:
    
     (*) Merge nfs_mount_info and nfs_clone_mount into nfs_fs_context.  This
         structure represents NFS's superblock config.
    
     (*) Make use of the VFS's parsing support to split comma-separated lists
    
     (*) Pin the NFS protocol module in the nfs_fs_context.
    
     (*) Attach supplementary error information to fs_context.  This has the
         downside that these strings must be static and can't be formatted.
    
     (*) Remove the auxiliary file_system_type structs since the information
         necessary can be conveyed in the nfs_fs_context struct instead.
    
     (*) Root mounts are made by duplicating the config for the requested mount
         so as to have the same parameters.  Submounts pick up their parameters
         from the parent superblock.
    
    [AV -- retrans is u32, not string]
    [SM -- Renamed cfg to ctx in a few functions in an earlier patch]
    [SM -- Moved fs_context mount option parsing to an earlier patch]
    [SM -- Moved fs_context error logging to a later patch]
    [SM -- Fixed printks in nfs4_try_get_tree() and nfs4_get_referral_tree()]
    [SM -- Added is_remount_fc() helper]
    [SM -- Deferred some refactoring to a later patch]
    [SM -- Fixed referral mounts, which were broken in the original patch]
    [SM -- Fixed leak of nfs_fattr when fs_context is freed]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Scott Mayhew <smayhew@redhat.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 003c2b8eb1e6..1cd09df9e0b5 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -4,7 +4,7 @@
  */
 
 #include "nfs4_fs.h"
-#include <linux/mount.h>
+#include <linux/fs_context.h>
 #include <linux/security.h>
 #include <linux/crc32.h>
 #include <linux/sunrpc/addr.h>
@@ -16,6 +16,7 @@
 extern const struct export_operations nfs_export_ops;
 
 struct nfs_string;
+struct nfs_pageio_descriptor;
 
 static inline void nfs_attr_check_mountpoint(struct super_block *parent, struct nfs_fattr *fattr)
 {
@@ -34,12 +35,13 @@ static inline int nfs_attr_use_mounted_on_fileid(struct nfs_fattr *fattr)
 
 struct nfs_clone_mount {
 	const struct super_block *sb;
-	const struct dentry *dentry;
+	struct dentry *dentry;
 	char *hostname;
 	char *mnt_path;
 	struct sockaddr *addr;
 	size_t addrlen;
 	rpc_authflavor_t authflavor;
+	struct nfs_fattr *fattr;
 };
 
 /*
@@ -78,10 +80,23 @@ struct nfs_client_initdata {
 	const struct cred *cred;
 };
 
+struct nfs_mount_info {
+	unsigned int inherited_bsize;
+	struct nfs_fs_context *ctx;
+	struct nfs_clone_mount *cloned;
+	struct nfs_server *server;
+	struct nfs_fh *mntfh;
+	struct nfs_subversion *nfs_mod;
+};
+
 /*
  * In-kernel mount arguments
  */
 struct nfs_fs_context {
+	bool			internal;
+	bool			skip_reconfig_option_check;
+	bool			need_mount;
+	bool			sloppy;
 	unsigned int		flags;		/* NFS{,4}_MOUNT_* flags */
 	unsigned int		rsize, wsize;
 	unsigned int		timeo, retrans;
@@ -98,8 +113,6 @@ struct nfs_fs_context {
 	char			*fscache_uniq;
 	unsigned short		protofamily;
 	unsigned short		mountfamily;
-	bool			need_mount;
-	bool			sloppy;
 
 	struct {
 		union {
@@ -124,14 +137,23 @@ struct nfs_fs_context {
 		int			port;
 		unsigned short		protocol;
 		unsigned short		nconnect;
+		unsigned short		export_path_len;
 	} nfs_server;
 
 	void			*lsm_opts;
 	struct net		*net;
 
 	char			buf[32];	/* Parse buffer */
+
+	struct nfs_mount_info	mount_info;
+	struct nfs_clone_mount	clone_data;
 };
 
+static inline struct nfs_fs_context *nfs_fc2context(const struct fs_context *fc)
+{
+	return fc->fs_private;
+}
+
 /* mount_clnt.c */
 struct nfs_mount_request {
 	struct sockaddr		*sap;
@@ -147,15 +169,6 @@ struct nfs_mount_request {
 	struct net		*net;
 };
 
-struct nfs_mount_info {
-	unsigned int inherited_bsize;
-	struct nfs_fs_context *ctx;
-	struct nfs_clone_mount *cloned;
-	struct nfs_server *server;
-	struct nfs_fh *mntfh;
-	struct nfs_subversion *nfs_mod;
-};
-
 extern int nfs_mount(struct nfs_mount_request *info);
 extern void nfs_umount(const struct nfs_mount_request *info);
 
@@ -235,22 +248,8 @@ static inline void nfs_fs_proc_exit(void)
 extern const struct svc_version nfs4_callback_version1;
 extern const struct svc_version nfs4_callback_version4;
 
-struct nfs_pageio_descriptor;
-
-/* mount.c */
-#define NFS_TEXT_DATA		1
-
-extern struct nfs_fs_context *nfs_alloc_parsed_mount_data(void);
-extern void nfs_free_parsed_mount_data(struct nfs_fs_context *ctx);
-extern int nfs_parse_mount_options(char *raw, struct nfs_fs_context *ctx);
-extern int nfs_validate_mount_data(struct file_system_type *fs_type,
-				   void *options,
-				   struct nfs_fs_context *ctx,
-				   struct nfs_fh *mntfh,
-				   const char *dev_name);
-extern int nfs_validate_text_mount_data(void *options,
-					struct nfs_fs_context *ctx,
-					const char *dev_name);
+/* fs_context.c */
+extern struct file_system_type nfs_fs_type;
 
 /* pagelist.c */
 extern int __init nfs_init_nfspagecache(void);
@@ -411,14 +410,9 @@ extern int nfs_wait_atomic_killable(atomic_t *p, unsigned int mode);
 
 /* super.c */
 extern const struct super_operations nfs_sops;
-extern struct file_system_type nfs_fs_type;
-extern struct file_system_type nfs_prepared_fs_type;
-#if IS_ENABLED(CONFIG_NFS_V4)
-extern struct file_system_type nfs4_referral_fs_type;
-#endif
 bool nfs_auth_info_match(const struct nfs_auth_info *, rpc_authflavor_t);
-struct dentry *nfs_try_mount(int, const char *, struct nfs_mount_info *);
-struct dentry *nfs_fs_mount(struct file_system_type *, int, const char *, void *);
+int nfs_try_get_tree(struct fs_context *);
+int nfs_get_tree_common(struct fs_context *);
 void nfs_kill_super(struct super_block *);
 
 extern struct rpc_stat nfs_rpcstat;
@@ -446,10 +440,8 @@ static inline bool nfs_file_io_is_buffered(struct nfs_inode *nfsi)
 extern char *nfs_path(char **p, struct dentry *dentry,
 		      char *buffer, ssize_t buflen, unsigned flags);
 extern struct vfsmount *nfs_d_automount(struct path *path);
-struct vfsmount *nfs_submount(struct nfs_server *, struct dentry *,
-			      struct nfs_fh *, struct nfs_fattr *);
-struct vfsmount *nfs_do_submount(struct dentry *, struct nfs_fh *,
-				 struct nfs_fattr *, rpc_authflavor_t);
+int nfs_submount(struct fs_context *, struct nfs_server *);
+int nfs_do_submount(struct fs_context *);
 
 /* getroot.c */
 extern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *,
@@ -476,7 +468,7 @@ int  nfs_show_options(struct seq_file *, struct dentry *);
 int  nfs_show_devname(struct seq_file *, struct dentry *);
 int  nfs_show_path(struct seq_file *, struct dentry *);
 int  nfs_show_stats(struct seq_file *, struct dentry *);
-int nfs_remount(struct super_block *sb, int *flags, char *raw_data);
+int  nfs_reconfigure(struct fs_context *);
 
 /* write.c */
 extern void nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,

commit e558100fda7e8c7888f523920214bcb35ed9382b
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 10 07:31:10 2019 -0500

    NFS: Do some tidying of the parsing code
    
    Do some tidying of the parsing code, including:
    
     (*) Returning 0/error rather than true/false.
    
     (*) Putting the nfs_fs_context pointer first in some arg lists.
    
     (*) Unwrap some lines that will now fit on one line.
    
     (*) Provide unioned sockaddr/sockaddr_storage fields to avoid casts.
    
     (*) nfs_parse_devname() can paste its return values directly into the
         nfs_fs_context struct as that's where the caller puts them.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5342f3e4d565..003c2b8eb1e6 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -82,11 +82,11 @@ struct nfs_client_initdata {
  * In-kernel mount arguments
  */
 struct nfs_fs_context {
-	int			flags;
+	unsigned int		flags;		/* NFS{,4}_MOUNT_* flags */
 	unsigned int		rsize, wsize;
 	unsigned int		timeo, retrans;
-	unsigned int		acregmin, acregmax,
-				acdirmin, acdirmax;
+	unsigned int		acregmin, acregmax;
+	unsigned int		acdirmin, acdirmax;
 	unsigned int		namlen;
 	unsigned int		options;
 	unsigned int		bsize;
@@ -102,7 +102,10 @@ struct nfs_fs_context {
 	bool			sloppy;
 
 	struct {
-		struct sockaddr_storage	address;
+		union {
+			struct sockaddr	address;
+			struct sockaddr_storage	_address;
+		};
 		size_t			addrlen;
 		char			*hostname;
 		u32			version;
@@ -111,7 +114,10 @@ struct nfs_fs_context {
 	} mount_server;
 
 	struct {
-		struct sockaddr_storage	address;
+		union {
+			struct sockaddr	address;
+			struct sockaddr_storage	_address;
+		};
 		size_t			addrlen;
 		char			*hostname;
 		char			*export_path;

commit 48be8a66cf98accca033c42d214698dd64ac4f79
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 10 07:31:09 2019 -0500

    NFS: Add a small buffer in nfs_fs_context to avoid string dup
    
    Add a small buffer in nfs_fs_context to avoid string duplication when
    parsing numbers.  Also make the parsing function wrapper place the parsed
    integer directly in the appropriate nfs_fs_context struct member.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index d0abc7b65cd2..5342f3e4d565 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -122,6 +122,8 @@ struct nfs_fs_context {
 
 	void			*lsm_opts;
 	struct net		*net;
+
+	char			buf[32];	/* Parse buffer */
 };
 
 /* mount_clnt.c */

commit f8ee01e3e2c8845e812497f0d4925c18cafaad87
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 10 07:31:07 2019 -0500

    NFS: Split nfs_parse_mount_options()
    
    Split nfs_parse_mount_options() to move the prologue, list-splitting and
    epilogue into one function and the per-option processing into another.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7131fa150d1b..d0abc7b65cd2 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -96,7 +96,10 @@ struct nfs_fs_context {
 	unsigned int		version;
 	unsigned int		minorversion;
 	char			*fscache_uniq;
+	unsigned short		protofamily;
+	unsigned short		mountfamily;
 	bool			need_mount;
+	bool			sloppy;
 
 	struct {
 		struct sockaddr_storage	address;

commit 5eb005caf5383dd328199f0f2114cd7dad731d3d
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 10 07:31:06 2019 -0500

    NFS: Rename struct nfs_parsed_mount_data to struct nfs_fs_context
    
    Rename struct nfs_parsed_mount_data to struct nfs_fs_context and rename
    pointers to it to "ctx".  At some point this will be pointed to by an
    fs_context struct's fs_private pointer.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 28ab31fc5aa6..7131fa150d1b 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -81,7 +81,7 @@ struct nfs_client_initdata {
 /*
  * In-kernel mount arguments
  */
-struct nfs_parsed_mount_data {
+struct nfs_fs_context {
 	int			flags;
 	unsigned int		rsize, wsize;
 	unsigned int		timeo, retrans;
@@ -138,7 +138,7 @@ struct nfs_mount_request {
 
 struct nfs_mount_info {
 	unsigned int inherited_bsize;
-	struct nfs_parsed_mount_data *parsed;
+	struct nfs_fs_context *ctx;
 	struct nfs_clone_mount *cloned;
 	struct nfs_server *server;
 	struct nfs_fh *mntfh;
@@ -229,16 +229,16 @@ struct nfs_pageio_descriptor;
 /* mount.c */
 #define NFS_TEXT_DATA		1
 
-extern struct nfs_parsed_mount_data *nfs_alloc_parsed_mount_data(void);
-extern void nfs_free_parsed_mount_data(struct nfs_parsed_mount_data *data);
-extern int nfs_parse_mount_options(char *raw, struct nfs_parsed_mount_data *mnt);
+extern struct nfs_fs_context *nfs_alloc_parsed_mount_data(void);
+extern void nfs_free_parsed_mount_data(struct nfs_fs_context *ctx);
+extern int nfs_parse_mount_options(char *raw, struct nfs_fs_context *ctx);
 extern int nfs_validate_mount_data(struct file_system_type *fs_type,
 				   void *options,
-				   struct nfs_parsed_mount_data *args,
+				   struct nfs_fs_context *ctx,
 				   struct nfs_fh *mntfh,
 				   const char *dev_name);
 extern int nfs_validate_text_mount_data(void *options,
-					struct nfs_parsed_mount_data *args,
+					struct nfs_fs_context *ctx,
 					const char *dev_name);
 
 /* pagelist.c */

commit 9954bf92c0cddd50a2a470be302e1c1ffdf21d42
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 10 07:31:04 2019 -0500

    NFS: Move mount parameterisation bits into their own file
    
    Split various bits relating to mount parameterisation out from
    fs/nfs/super.c into their own file to form the basis of filesystem context
    handling for NFS.
    
    No other changes are made to the code beyond removing 'static' qualifiers.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index a467e43fc682..28ab31fc5aa6 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -7,6 +7,7 @@
 #include <linux/mount.h>
 #include <linux/security.h>
 #include <linux/crc32.h>
+#include <linux/sunrpc/addr.h>
 #include <linux/nfs_page.h>
 #include <linux/wait_bit.h>
 
@@ -224,6 +225,22 @@ extern const struct svc_version nfs4_callback_version1;
 extern const struct svc_version nfs4_callback_version4;
 
 struct nfs_pageio_descriptor;
+
+/* mount.c */
+#define NFS_TEXT_DATA		1
+
+extern struct nfs_parsed_mount_data *nfs_alloc_parsed_mount_data(void);
+extern void nfs_free_parsed_mount_data(struct nfs_parsed_mount_data *data);
+extern int nfs_parse_mount_options(char *raw, struct nfs_parsed_mount_data *mnt);
+extern int nfs_validate_mount_data(struct file_system_type *fs_type,
+				   void *options,
+				   struct nfs_parsed_mount_data *args,
+				   struct nfs_fh *mntfh,
+				   const char *dev_name);
+extern int nfs_validate_text_mount_data(void *options,
+					struct nfs_parsed_mount_data *args,
+					const char *dev_name);
+
 /* pagelist.c */
 extern int __init nfs_init_nfspagecache(void);
 extern void nfs_destroy_nfspagecache(void);
@@ -765,3 +782,16 @@ static inline bool nfs_error_is_fatal_on_server(int err)
 	}
 	return nfs_error_is_fatal(err);
 }
+
+/*
+ * Select between a default port value and a user-specified port value.
+ * If a zero value is set, then autobind will be used.
+ */
+static inline void nfs_set_port(struct sockaddr *sap, int *port,
+				const unsigned short default_port)
+{
+	if (*port == NFS_UNSPEC_PORT)
+		*port = default_port;
+
+	rpc_set_port(sap, *port);
+}

commit adf2314fe667565258f304a04990d334defabeaf
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 10 07:31:03 2019 -0500

    nfs: get rid of ->set_security()
    
    it's always either nfs_set_sb_security() or nfs_clone_sb_security(),
    the choice being controlled by mount_info->cloned != NULL.  No need
    to add methods, especially when both instances live right next to
    the caller and are never accessed anywhere else.
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 65c8e353cb6b..a467e43fc682 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -137,7 +137,6 @@ struct nfs_mount_request {
 
 struct nfs_mount_info {
 	unsigned int inherited_bsize;
-	int (*set_security)(struct super_block *, struct dentry *, struct nfs_mount_info *);
 	struct nfs_parsed_mount_data *parsed;
 	struct nfs_clone_mount *cloned;
 	struct nfs_server *server;
@@ -391,8 +390,6 @@ extern struct file_system_type nfs4_referral_fs_type;
 #endif
 bool nfs_auth_info_match(const struct nfs_auth_info *, rpc_authflavor_t);
 struct dentry *nfs_try_mount(int, const char *, struct nfs_mount_info *);
-int nfs_set_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
-int nfs_clone_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
 struct dentry *nfs_fs_mount(struct file_system_type *, int, const char *, void *);
 void nfs_kill_super(struct super_block *);
 

commit ab88dca311a3722a66f7dee3c352e634ad1e6a25
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 10 07:31:01 2019 -0500

    nfs: get rid of mount_info ->fill_super()
    
    The only possible values are nfs_fill_super and nfs_clone_super.  The
    latter is used only when crossing into a submount and it is almost
    identical to the former; the only differences are
            * ->s_time_gran unconditionally set to 1 (even for v2 mounts).
    Regression dating back to 2012, actually.
            * ->s_blocksize/->s_blocksize_bits set to that of parent.
    
    Rather than messing with the method, stash ->s_blocksize_bits in
    mount_info in submount case and after the (now unconditional)
    call of nfs_fill_super() override ->s_blocksize/->s_blocksize_bits
    if that has been set.
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 0bb0493785fc..65c8e353cb6b 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -136,7 +136,7 @@ struct nfs_mount_request {
 };
 
 struct nfs_mount_info {
-	void (*fill_super)(struct super_block *, struct nfs_mount_info *);
+	unsigned int inherited_bsize;
 	int (*set_security)(struct super_block *, struct dentry *, struct nfs_mount_info *);
 	struct nfs_parsed_mount_data *parsed;
 	struct nfs_clone_mount *cloned;
@@ -395,8 +395,6 @@ int nfs_set_sb_security(struct super_block *, struct dentry *, struct nfs_mount_
 int nfs_clone_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
 struct dentry *nfs_fs_mount(struct file_system_type *, int, const char *, void *);
 void nfs_kill_super(struct super_block *);
-void nfs_fill_super(struct super_block *, struct nfs_mount_info *);
-void nfs_clone_super(struct super_block *, struct nfs_mount_info *);
 
 extern struct rpc_stat nfs_rpcstat;
 

commit 0c38f2131df9865aa9fb24b7ad30a9657588e0e1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 10 07:31:00 2019 -0500

    nfs: don't pass nfs_subversion to ->create_server()
    
    pick it from mount_info
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 310f81a149b2..0bb0493785fc 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -170,11 +170,8 @@ extern struct nfs_client *nfs4_find_client_ident(struct net *, int);
 extern struct nfs_client *
 nfs4_find_client_sessionid(struct net *, const struct sockaddr *,
 				struct nfs4_sessionid *, u32);
-extern struct nfs_server *nfs_create_server(struct nfs_mount_info *,
-					struct nfs_subversion *);
-extern struct nfs_server *nfs4_create_server(
-					struct nfs_mount_info *,
-					struct nfs_subversion *);
+extern struct nfs_server *nfs_create_server(struct nfs_mount_info *);
+extern struct nfs_server *nfs4_create_server(struct nfs_mount_info *);
 extern struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *,
 						      struct nfs_fh *);
 extern int nfs4_update_server(struct nfs_server *server, const char *hostname,

commit 1bc3a2cbf239fc6c5984a074cc0d7b6de182407d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 10 07:30:59 2019 -0500

    nfs: unexport nfs_fs_mount_common()
    
    Make it static, even.  And remove a stale extern of (long-gone)
    nfs_xdev_mount_common() from internal.h, while we are at it.
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index e338558b7908..310f81a149b2 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -396,10 +396,7 @@ bool nfs_auth_info_match(const struct nfs_auth_info *, rpc_authflavor_t);
 struct dentry *nfs_try_mount(int, const char *, struct nfs_mount_info *);
 int nfs_set_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
 int nfs_clone_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
-struct dentry *nfs_fs_mount_common(int, const char *, struct nfs_mount_info *);
 struct dentry *nfs_fs_mount(struct file_system_type *, int, const char *, void *);
-struct dentry * nfs_xdev_mount_common(struct file_system_type *, int,
-		const char *, struct nfs_mount_info *);
 void nfs_kill_super(struct super_block *);
 void nfs_fill_super(struct super_block *, struct nfs_mount_info *);
 void nfs_clone_super(struct super_block *, struct nfs_mount_info *);

commit 82eaed2beef5ce31ecfeb70a33616e6331a51ef2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 10 07:30:58 2019 -0500

    nfs: merge xdev and remote file_system_type
    
    they are identical now...
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 4a0ba66bc3aa..e338558b7908 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -388,7 +388,7 @@ extern int nfs_wait_atomic_killable(atomic_t *p, unsigned int mode);
 /* super.c */
 extern const struct super_operations nfs_sops;
 extern struct file_system_type nfs_fs_type;
-extern struct file_system_type nfs_xdev_fs_type;
+extern struct file_system_type nfs_prepared_fs_type;
 #if IS_ENABLED(CONFIG_NFS_V4)
 extern struct file_system_type nfs4_referral_fs_type;
 #endif

commit a55d3297be587c6baa0242ae0fbb92489e576005
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 10 07:30:57 2019 -0500

    nfs: don't bother passing nfs_subversion to ->try_mount() and nfs_fs_mount_common()
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 9888e9c7abe2..4a0ba66bc3aa 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -393,12 +393,10 @@ extern struct file_system_type nfs_xdev_fs_type;
 extern struct file_system_type nfs4_referral_fs_type;
 #endif
 bool nfs_auth_info_match(const struct nfs_auth_info *, rpc_authflavor_t);
-struct dentry *nfs_try_mount(int, const char *, struct nfs_mount_info *,
-			struct nfs_subversion *);
+struct dentry *nfs_try_mount(int, const char *, struct nfs_mount_info *);
 int nfs_set_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
 int nfs_clone_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
-struct dentry *nfs_fs_mount_common(int, const char *,
-				   struct nfs_mount_info *, struct nfs_subversion *);
+struct dentry *nfs_fs_mount_common(int, const char *, struct nfs_mount_info *);
 struct dentry *nfs_fs_mount(struct file_system_type *, int, const char *, void *);
 struct dentry * nfs_xdev_mount_common(struct file_system_type *, int,
 		const char *, struct nfs_mount_info *);

commit 6a3f7a399ebf52164e40773f4fbcb31a4c1ec02a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 10 07:30:56 2019 -0500

    nfs: stash nfs_subversion reference into nfs_mount_info
    
    That will allow to get rid of passing those references around in
    quite a few places.  Moreover, that will allow to merge xdev and
    remote file_system_type.
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index b193dd626c0a..9888e9c7abe2 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -142,6 +142,7 @@ struct nfs_mount_info {
 	struct nfs_clone_mount *cloned;
 	struct nfs_server *server;
 	struct nfs_fh *mntfh;
+	struct nfs_subversion *nfs_mod;
 };
 
 extern int nfs_mount(struct nfs_mount_request *info);

commit 250d69f6a465e36a6ab8602030267de2586e028f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 10 07:30:55 2019 -0500

    nfs: lift setting mount_info from nfs_xdev_mount()
    
    Do it in nfs_do_submount() instead.  As a side benefit, nfs_clone_data
    doesn't need ->fh and ->fattr anymore.
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 8f4900bd04f7..b193dd626c0a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -34,8 +34,6 @@ static inline int nfs_attr_use_mounted_on_fileid(struct nfs_fattr *fattr)
 struct nfs_clone_mount {
 	const struct super_block *sb;
 	const struct dentry *dentry;
-	struct nfs_fh *fh;
-	struct nfs_fattr *fattr;
 	char *hostname;
 	char *mnt_path;
 	struct sockaddr *addr;
@@ -405,6 +403,7 @@ struct dentry * nfs_xdev_mount_common(struct file_system_type *, int,
 		const char *, struct nfs_mount_info *);
 void nfs_kill_super(struct super_block *);
 void nfs_fill_super(struct super_block *, struct nfs_mount_info *);
+void nfs_clone_super(struct super_block *, struct nfs_mount_info *);
 
 extern struct rpc_stat nfs_rpcstat;
 

commit d0b779d47c92fa17a31cde312d05155941e26651
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 10 07:30:50 2019 -0500

    nfs: stash server into struct nfs_mount_info
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 24a65da58aa9..8f4900bd04f7 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -142,6 +142,7 @@ struct nfs_mount_info {
 	int (*set_security)(struct super_block *, struct dentry *, struct nfs_mount_info *);
 	struct nfs_parsed_mount_data *parsed;
 	struct nfs_clone_mount *cloned;
+	struct nfs_server *server;
 	struct nfs_fh *mntfh;
 };
 
@@ -397,7 +398,7 @@ struct dentry *nfs_try_mount(int, const char *, struct nfs_mount_info *,
 			struct nfs_subversion *);
 int nfs_set_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
 int nfs_clone_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
-struct dentry *nfs_fs_mount_common(struct nfs_server *, int, const char *,
+struct dentry *nfs_fs_mount_common(int, const char *,
 				   struct nfs_mount_info *, struct nfs_subversion *);
 struct dentry *nfs_fs_mount(struct file_system_type *, int, const char *, void *);
 struct dentry * nfs_xdev_mount_common(struct file_system_type *, int,

commit e86d5a02874c1364c50e1b532481835b54173ed2
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Fri Oct 4 16:38:56 2019 -0400

    NFS: Convert struct nfs_fattr to use struct timespec64
    
    NFSv4 supports 64-bit times, so we should switch to using struct
    timespec64 when decoding attributes.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 447a3c17fa8e..24a65da58aa9 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -713,7 +713,7 @@ unsigned int nfs_page_array_len(unsigned int base, size_t len)
  * 1024*1024*1024.
  */
 static inline
-u64 nfs_timespec_to_change_attr(const struct timespec *ts)
+u64 nfs_timespec_to_change_attr(const struct timespec64 *ts)
 {
 	return ((u64)ts->tv_sec << 30) + ts->tv_nsec;
 }

commit 972a2bf7dfe39ebf49dd47f68d27c416392e53b1
Merge: 7be3cb019db1 a8fd0feeca35
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 26 12:20:14 2019 -0700

    Merge tag 'nfs-for-5.4-1' of git://git.linux-nfs.org/projects/anna/linux-nfs
    
    Pull NFS client updates from Anna Schumaker:
     "Stable bugfixes:
       - Dequeue the request from the receive queue while we're re-encoding
         # v4.20+
       - Fix buffer handling of GSS MIC without slack # 5.1
    
      Features:
       - Increase xprtrdma maximum transport header and slot table sizes
       - Add support for nfs4_call_sync() calls using a custom
         rpc_task_struct
       - Optimize the default readahead size
       - Enable pNFS filelayout LAYOUTGET on OPEN
    
      Other bugfixes and cleanups:
       - Fix possible null-pointer dereferences and memory leaks
       - Various NFS over RDMA cleanups
       - Various NFS over RDMA comment updates
       - Don't receive TCP data into a reset request buffer
       - Don't try to parse incomplete RPC messages
       - Fix congestion window race with disconnect
       - Clean up pNFS return-on-close error handling
       - Fixes for NFS4ERR_OLD_STATEID handling"
    
    * tag 'nfs-for-5.4-1' of git://git.linux-nfs.org/projects/anna/linux-nfs: (53 commits)
      pNFS/filelayout: enable LAYOUTGET on OPEN
      NFS: Optimise the default readahead size
      NFSv4: Handle NFS4ERR_OLD_STATEID in LOCKU
      NFSv4: Handle NFS4ERR_OLD_STATEID in CLOSE/OPEN_DOWNGRADE
      NFSv4: Fix OPEN_DOWNGRADE error handling
      pNFS: Handle NFS4ERR_OLD_STATEID on layoutreturn by bumping the state seqid
      NFSv4: Add a helper to increment stateid seqids
      NFSv4: Handle RPC level errors in LAYOUTRETURN
      NFSv4: Handle NFS4ERR_DELAY correctly in return-on-close
      NFSv4: Clean up pNFS return-on-close error handling
      pNFS: Ensure we do clear the return-on-close layout stateid on fatal errors
      NFS: remove unused check for negative dentry
      NFSv3: use nfs_add_or_obtain() to create and reference inodes
      NFS: Refactor nfs_instantiate() for dentry referencing callers
      SUNRPC: Fix congestion window race with disconnect
      SUNRPC: Don't try to parse incomplete RPC messages
      SUNRPC: Rename xdr_buf_read_netobj to xdr_buf_read_mic
      SUNRPC: Fix buffer handling of GSS MIC without slack
      SUNRPC: RPC level errors should always set task->tk_rpc_status
      SUNRPC: Don't receive TCP data into a request buffer that has been reset
      ...

commit c128e575514ce93dced349417d136304a33b6f99
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Sun Sep 22 15:07:49 2019 -0400

    NFS: Optimise the default readahead size
    
    In the years since the max readahead size was fixed in NFS, a number of
    things have happened:
    - Users can now set the value directly using /sys/class/bdi
    - NFS max supported block sizes have increased by several orders of
      magnitude from 64K to 1MB.
    - Disk access latencies are orders of magnitude faster due to SSD + NVME.
    
    In particular note that if the server is advertising 1MB as the optimal
    read size, as that will set the readahead size to 15MB.
    Let's therefore adjust down, and try to default to VM_READAHEAD_PAGES.
    However let's inform the VM about our preferred block size so that it
    can choose to round up in cases where that makes sense.
    
    Reported-by: Alkis Georgopoulos <alkisg@gmail.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index a2346a2f8361..4b946e6a052f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -16,14 +16,6 @@ extern const struct export_operations nfs_export_ops;
 
 struct nfs_string;
 
-/* Maximum number of readahead requests
- * FIXME: this should really be a sysctl so that users may tune it to suit
- *        their needs. People that do NFS over a slow network, might for
- *        instance want to reduce it to something closer to 1 for improved
- *        interactive response.
- */
-#define NFS_MAX_READAHEAD	(RPC_DEF_SLOT_TABLE - 1)
-
 static inline void nfs_attr_check_mountpoint(struct super_block *parent, struct nfs_fattr *fattr)
 {
 	if (!nfs_fsid_equal(&NFS_SB(parent)->fsid, &fattr->fsid))

commit 8f54c7a4babf58bbaf849e126f7ae9664bdc9e04
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Thu Aug 15 12:26:05 2019 -0400

    NFS: Fix spurious EIO read errors
    
    If the client attempts to read a page, but the read fails due to some
    spurious error (e.g. an ACCESS error or a timeout, ...) then we need
    to allow other processes to retry.
    Also try to report errors correctly when doing a synchronous readpage.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index a2346a2f8361..e64f810223be 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -775,3 +775,13 @@ static inline bool nfs_error_is_fatal(int err)
 	}
 }
 
+static inline bool nfs_error_is_fatal_on_server(int err)
+{
+	switch (err) {
+	case 0:
+	case -ERESTARTSYS:
+	case -EINTR:
+		return false;
+	}
+	return nfs_error_is_fatal(err);
+}

commit db531db951f950b86d274cc8ed7b21b9e2240036
Author: Max Kellermann <mk@cm4all.com>
Date:   Fri Jul 12 16:18:06 2019 +0200

    Revert "NFS: readdirplus optimization by cache mechanism" (memleak)
    
    This reverts commit be4c2d4723a4a637f0d1b4f7c66447141a4b3564.
    
    That commit caused a severe memory leak in nfs_readdir_make_qstr().
    
    When listing a directory with more than 100 files (this is how many
    struct nfs_cache_array_entry elements fit in one 4kB page), all
    allocated file name strings past those 100 leak.
    
    The root of the leakage is that those string pointers are managed in
    pages which are never linked into the page cache.
    
    fs/nfs/dir.c puts pages into the page cache by calling
    read_cache_page(); the callback function nfs_readdir_filler() will
    then fill the given page struct which was passed to it, which is
    already linked in the page cache (by do_read_cache_page() calling
    add_to_page_cache_lru()).
    
    Commit be4c2d4723a4 added another (local) array of allocated pages, to
    be filled with more data, instead of discarding excess items received
    from the NFS server.  Those additional pages can be used by the next
    nfs_readdir_filler() call (from within the same nfs_readdir() call).
    
    The leak happens when some of those additional pages are never used
    (copied to the page cache using copy_highpage()).  The pages will be
    freed by nfs_readdir_free_pages(), but their contents will not.  The
    commit did not invoke nfs_readdir_clear_array() (and doing so would
    have been dangerous, because it did not track which of those pages
    were already copied to the page cache, risking double free bugs).
    
    How to reproduce the leak:
    
    - Use a kernel with CONFIG_SLUB_DEBUG_ON.
    
    - Create a directory on a NFS mount with more than 100 files with
      names long enough to use the "kmalloc-32" slab (so we can easily
      look up the allocation counts):
    
      for i in `seq 110`; do touch ${i}_0123456789abcdef; done
    
    - Drop all caches:
    
      echo 3 >/proc/sys/vm/drop_caches
    
    - Check the allocation counter:
    
      grep nfs_readdir /sys/kernel/slab/kmalloc-32/alloc_calls
      30564391 nfs_readdir_add_to_array+0x73/0xd0 age=534558/4791307/6540952 pid=370-1048386 cpus=0-47 nodes=0-1
    
    - Request a directory listing and check the allocation counters again:
    
      ls
      [...]
      grep nfs_readdir /sys/kernel/slab/kmalloc-32/alloc_calls
      30564511 nfs_readdir_add_to_array+0x73/0xd0 age=207/4792999/6542663 pid=370-1048386 cpus=0-47 nodes=0-1
    
    There are now 120 new allocations.
    
    - Drop all caches and check the counters again:
    
      echo 3 >/proc/sys/vm/drop_caches
      grep nfs_readdir /sys/kernel/slab/kmalloc-32/alloc_calls
      30564401 nfs_readdir_add_to_array+0x73/0xd0 age=735/4793524/6543176 pid=370-1048386 cpus=0-47 nodes=0-1
    
    110 allocations are gone, but 10 have leaked and will never be freed.
    
    Unhelpfully, those allocations are explicitly excluded from KMEMLEAK,
    that's why my initial attempts with KMEMLEAK were not successful:
    
            /*
             * Avoid a kmemleak false positive. The pointer to the name is stored
             * in a page cache page which kmemleak does not scan.
             */
            kmemleak_not_leak(string->name);
    
    It would be possible to solve this bug without reverting the whole
    commit:
    
    - keep track of which pages were not used, and call
      nfs_readdir_clear_array() on them, or
    - manually link those pages into the page cache
    
    But for now I have decided to just revert the commit, because the real
    fix would require complex considerations, risking more dangerous
    (crash) bugs, which may seem unsuitable for the stable branches.
    
    Signed-off-by: Max Kellermann <mk@cm4all.com>
    Cc: stable@vger.kernel.org # v5.1+
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index f359e760ed41..a2346a2f8361 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -69,8 +69,7 @@ struct nfs_clone_mount {
  * Maximum number of pages that readdir can use for creating
  * a vmapped array of pages.
  */
-#define NFS_MAX_READDIR_PAGES 64
-#define NFS_MAX_READDIR_RAPAGES 8
+#define NFS_MAX_READDIR_PAGES 8
 
 struct nfs_client_initdata {
 	unsigned long init_flags;

commit c98ebe2937404d8e6e028ac9cadcf870a6faccc2
Merge: 28ade856c0f7 b6580ab39b09
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Tue Jun 11 16:53:33 2019 -0400

    Merge branch 'multipath_tcp'

commit 6619079d05404cb32be29af329b87ac3b0ad4f96
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Apr 27 11:13:40 2017 -0400

    NFSv4: Allow multiple connections to NFSv4.x (x>0) servers
    
    If the user specifies the -onconn=<number> mount option, and the transport
    protocol is TCP, then set up <number> connections to the server. The
    connections will all go to the same IP address.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index bba09dace5d6..4a49dc1495c5 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -82,6 +82,7 @@ struct nfs_client_initdata {
 	struct nfs_subversion *nfs_mod;
 	int proto;
 	u32 minorversion;
+	unsigned int nconnect;
 	struct net *net;
 	const struct rpc_timeout *timeparms;
 	const struct cred *cred;

commit 28cc5cd8c68f1cd2146d88c7a54cc3234ed4dabe
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Wed Apr 26 23:30:48 2017 -0400

    NFS: Add a mount option to specify number of TCP connections to use
    
    Allow the user to specify that the client should use multiple connections
    to the server. For the moment, this functionality will be limited to
    TCP and to NFSv4.x (x>0).
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 498fab72f70b..bba09dace5d6 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -123,6 +123,7 @@ struct nfs_parsed_mount_data {
 		char			*export_path;
 		int			port;
 		unsigned short		protocol;
+		unsigned short		nconnect;
 	} nfs_server;
 
 	void			*lsm_opts;

commit 10b7a70cbb81a62353f763c3343ac0c48410696f
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Wed Feb 6 09:32:50 2019 -0500

    NFS: Cleanup - add nfs_clients_exit to mirror nfs_clients_init
    
    Add a helper to clean up the struct nfs_net when it is being destroyed.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 498fab72f70b..9e87265907b8 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -158,6 +158,7 @@ extern void nfs_umount(const struct nfs_mount_request *info);
 /* client.c */
 extern const struct rpc_program nfs_program;
 extern void nfs_clients_init(struct net *net);
+extern void nfs_clients_exit(struct net *net);
 extern struct nfs_client *nfs_alloc_client(const struct nfs_client_initdata *);
 int nfs_create_rpc_client(struct nfs_client *, const struct nfs_client_initdata *, rpc_authflavor_t);
 struct nfs_client *nfs_get_client(const struct nfs_client_initdata *);
@@ -170,7 +171,6 @@ int nfs_init_server_rpcclient(struct nfs_server *, const struct rpc_timeout *t,
 struct nfs_server *nfs_alloc_server(void);
 void nfs_server_copy_userdata(struct nfs_server *, struct nfs_server *);
 
-extern void nfs_cleanup_cb_ident_idr(struct net *);
 extern void nfs_put_client(struct nfs_client *);
 extern void nfs_free_client(struct nfs_client *);
 extern struct nfs_client *nfs4_find_client_ident(struct net *, int);

commit 06cbd26d312edfe4a83ff541c23f8f866265eb24
Merge: abde77eb5c66 5940d1cf9f42
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 9 14:33:15 2019 -0700

    Merge tag 'nfs-for-5.2-1' of git://git.linux-nfs.org/projects/anna/linux-nfs
    
    Pull NFS client updates from Anna Schumaker:
     "Highlights include:
    
      Stable bugfixes:
       - Fall back to MDS if no deviceid is found rather than aborting   # v4.11+
       - NFS4: Fix v4.0 client state corruption when mount
    
      Features:
       - Much improved handling of soft mounts with NFS v4.0:
           - Reduce risk of false positive timeouts
           - Faster failover of reads and writes after a timeout
           - Added a "softerr" mount option to return ETIMEDOUT instead of
             EIO to the application after a timeout
       - Increase number of xprtrdma backchannel requests
       - Add additional xprtrdma tracepoints
       - Improved send completion batching for xprtrdma
    
      Other bugfixes and cleanups:
       - Return -EINVAL when NFS v4.2 is passed an invalid dedup mode
       - Reduce usage of GFP_ATOMIC pages in SUNRPC
       - Various minor NFS over RDMA cleanups and bugfixes
       - Use the correct container namespace for upcalls
       - Don't share superblocks between user namespaces
       - Various other container fixes
       - Make nfs_match_client() killable to prevent soft lockups
       - Don't mark all open state for recovery when handling recallable
         state revoked flag"
    
    * tag 'nfs-for-5.2-1' of git://git.linux-nfs.org/projects/anna/linux-nfs: (69 commits)
      SUNRPC: Rebalance a kref in auth_gss.c
      NFS: Fix a double unlock from nfs_match,get_client
      nfs: pass the correct prototype to read_cache_page
      NFSv4: don't mark all open state for recovery when handling recallable state revoked flag
      SUNRPC: Fix an error code in gss_alloc_msg()
      SUNRPC: task should be exit if encode return EKEYEXPIRED more times
      NFS4: Fix v4.0 client state corruption when mount
      PNFS fallback to MDS if no deviceid found
      NFS: make nfs_match_client killable
      lockd: Store the lockd client credential in struct nlm_host
      NFS: When mounting, don't share filesystems between different user namespaces
      NFS: Convert NFSv2 to use the container user namespace
      NFSv4: Convert the NFS client idmapper to use the container user namespace
      NFS: Convert NFSv3 to use the container user namespace
      SUNRPC: Use namespace of listening daemon in the client AUTH_GSS upcall
      SUNRPC: Use the client user namespace when encoding creds
      NFS: Store the credential of the mount process in the nfs_server
      SUNRPC: Cache cred of process creating the rpc_client
      xprtrdma: Remove stale comment
      xprtrdma: Update comments that reference ib_drain_qp
      ...

commit ca1a199e3b8768cc6ffe2919456a8d59f691539c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Apr 15 20:19:40 2019 -0400

    nfs{,4}: switch to ->free_inode()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index c7cf23ae6597..331a0504eaf8 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -381,7 +381,7 @@ int nfs_check_flags(int);
 /* inode.c */
 extern struct workqueue_struct *nfsiod_workqueue;
 extern struct inode *nfs_alloc_inode(struct super_block *sb);
-extern void nfs_destroy_inode(struct inode *);
+extern void nfs_free_inode(struct inode *);
 extern int nfs_write_inode(struct inode *, struct writeback_control *);
 extern int nfs_drop_inode(struct inode *);
 extern void nfs_clear_inode(struct inode *);

commit 1a58e8a0e5c1f188a80eb9e505bc77d78a31a4ec
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Wed Apr 24 17:46:43 2019 -0400

    NFS: Store the credential of the mount process in the nfs_server
    
    Store the credential of the mount process so that we can determine
    information such as the user namespace.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 196534634c3a..22232e76df47 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -84,6 +84,7 @@ struct nfs_client_initdata {
 	u32 minorversion;
 	struct net *net;
 	const struct rpc_timeout *timeparms;
+	const struct cred *cred;
 };
 
 /*

commit 6fbda89b257f25694bf4892ddbbaa472f581533b
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Sun Apr 7 13:59:05 2019 -0400

    NFS: Replace custom error reporting mechanism with generic one
    
    Replace the NFS custom error reporting mechanism with the generic
    mapping_set_error().
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 3cefd0ed01be..196534634c3a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -773,9 +773,3 @@ static inline bool nfs_error_is_fatal(int err)
 	}
 }
 
-static inline void nfs_context_set_write_error(struct nfs_open_context *ctx, int error)
-{
-	ctx->error = error;
-	smp_wmb();
-	set_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);
-}

commit 11982a7c0f654ededc776bc81d8a0c51d3ee8d1c
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Sun Apr 7 13:58:59 2019 -0400

    NFS: Consider ETIMEDOUT to be a fatal error
    
    When we introduce the 'softerr' mount option, we will see the RPC
    layer returning ETIMEDOUT errors if the server is unresponsive. We
    want to consider those errors to be fatal on par with the EIO errors
    that are returned by ordinary 'soft' timeouts..
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index c7cf23ae6597..3cefd0ed01be 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -766,6 +766,7 @@ static inline bool nfs_error_is_fatal(int err)
 	case -ESTALE:
 	case -E2BIG:
 	case -ENOMEM:
+	case -ETIMEDOUT:
 		return true;
 	default:
 		return false;

commit be4c2d4723a4a637f0d1b4f7c66447141a4b3564
Author: luanshi <zhangliguang@linux.alibaba.com>
Date:   Tue Jan 29 15:34:17 2019 +0800

    NFS: readdirplus optimization by cache mechanism
    
    When listing very large directories via NFS, clients may take a long
    time to complete. There are about three factors involved:
    
    First of all, ls and practically every other method of listing a
    directory including python os.listdir and find rely on libc readdir().
    However readdir() only reads 32K of directory entries at a time, which
    means that if you have a lot of files in the same directory, it is going
    to take an insanely long time to read all the directory entries.
    
    Secondly, libc readdir() reads 32K of directory entries at a time, in
    kernel space 32K buffer split into 8 pages. One NFS readdirplus rpc will
    be called for one page, which introduces many readdirplus rpc calls.
    
    Lastly, one NFS readdirplus rpc asks for 32K data (filled by nfs_dentry)
    to fill one page (filled by dentry), we found that nearly one third of
    data was wasted.
    
    To solve above problems, pagecache mechanism was introduced. One NFS
    readdirplus rpc will ask for a large data (more than 32k), the data can
    fill more than one page, the cached pages can be used for next readdir
    call. This can reduce many readdirplus rpc calls and improve readdirplus
    performance.
    
    TESTING:
    When listing very large directories(include 300 thousand files) via NFS
    
    time ls -l /nfs_mount | wc -l
    
    without the patch:
    300001
    real    1m53.524s
    user    0m2.314s
    sys     0m2.599s
    
    with the patch:
    300001
    real    0m23.487s
    user    0m2.305s
    sys     0m2.558s
    
    Improved performance: 79.6%
    readdirplus rpc calls decrease: 85%
    
    Signed-off-by: Liguang Zhang <zhangliguang@linux.alibaba.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index b26622d9686f..c7cf23ae6597 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -69,7 +69,8 @@ struct nfs_clone_mount {
  * Maximum number of pages that readdir can use for creating
  * a vmapped array of pages.
  */
-#define NFS_MAX_READDIR_PAGES 8
+#define NFS_MAX_READDIR_PAGES 64
+#define NFS_MAX_READDIR_RAPAGES 8
 
 struct nfs_client_initdata {
 	unsigned long init_flags;

commit 2dc23afffbcac7c8935422beca1ba8636ff310ad
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Wed Feb 13 08:29:27 2019 -0500

    NFS: ENOMEM should also be a fatal error.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 1cb9670bb8b5..b26622d9686f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -764,6 +764,7 @@ static inline bool nfs_error_is_fatal(int err)
 	case -EROFS:
 	case -ESTALE:
 	case -E2BIG:
+	case -ENOMEM:
 		return true;
 	default:
 		return false;

commit 7dc58ca5d8cd3d81ff329500a502cbe64208d4a1
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Tue Jan 22 07:39:09 2019 -0500

    NFS: EINTR is also a fatal error.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index b1e577302518..1cb9670bb8b5 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -755,6 +755,7 @@ static inline bool nfs_error_is_fatal(int err)
 {
 	switch (err) {
 	case -ERESTARTSYS:
+	case -EINTR:
 	case -EACCES:
 	case -EDQUOT:
 	case -EFBIG:

commit 505b050fdf42097883b2d37b8e796e1f11dbef50
Merge: 9b286efeb5eb 718c43038f28
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 5 13:25:58 2019 -0800

    Merge branch 'mount.part1' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs mount API prep from Al Viro:
     "Mount API prereqs.
    
      Mostly that's LSM mount options cleanups. There are several minor
      fixes in there, but nothing earth-shattering (leaks on failure exits,
      mostly)"
    
    * 'mount.part1' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (27 commits)
      mount_fs: suppress MAC on MS_SUBMOUNT as well as MS_KERNMOUNT
      smack: rewrite smack_sb_eat_lsm_opts()
      smack: get rid of match_token()
      smack: take the guts of smack_parse_opts_str() into a new helper
      LSM: new method: ->sb_add_mnt_opt()
      selinux: rewrite selinux_sb_eat_lsm_opts()
      selinux: regularize Opt_... names a bit
      selinux: switch away from match_token()
      selinux: new helper - selinux_add_opt()
      LSM: bury struct security_mnt_opts
      smack: switch to private smack_mnt_opts
      selinux: switch to private struct selinux_mnt_opts
      LSM: hide struct security_mnt_opts from any generic code
      selinux: kill selinux_sb_get_mnt_opts()
      LSM: turn sb_eat_lsm_opts() into a method
      nfs_remount(): don't leak, don't ignore LSM options quietly
      btrfs: sanitize security_mnt_opts use
      selinux; don't open-code a loop in sb_finish_set_opts()
      LSM: split ->sb_set_mnt_opts() out of ->sb_kern_mount()
      new helper: security_sb_eat_lsm_opts()
      ...

commit 10e037d1e0d5d93cc057e4fad6911e481a462407
Author: Santosh kumar pradhan <santoshkumar.pradhan@wdc.com>
Date:   Wed Dec 19 12:29:57 2018 +0530

    sunrpc: Add xprt after nfs4_test_session_trunk()
    
    Multipathing: In case of NFSv3, rpc_clnt_test_and_add_xprt() adds
    the xprt to xprt switch (i.e. xps) if rpc_call_null_helper() returns
    success. But in case of NFSv4.1, it needs to do EXCHANGEID to verify
    the path along with check for session trunking.
    
    Add the xprt in nfs4_test_session_trunk() only when
    nfs4_detect_session_trunking() returns success. Also release refcount
    hold by rpc_clnt_setup_test_and_add_xprt().
    
    Signed-off-by: Santosh kumar pradhan <santoshkumar.pradhan@wdc.com>
    Tested-by: Suresh Jayaraman <suresh.jayaraman@wdc.com>
    Reported-by: Aditya Agnihotri <aditya.agnihotri@wdc.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 78d83b4bc398..7f80f036ebd9 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -568,9 +568,9 @@ extern int nfs40_walk_client_list(struct nfs_client *clp,
 extern int nfs41_walk_client_list(struct nfs_client *clp,
 				struct nfs_client **result,
 				const struct cred *cred);
-extern int nfs4_test_session_trunk(struct rpc_clnt *,
-				struct rpc_xprt *,
-				void *);
+extern void nfs4_test_session_trunk(struct rpc_clnt *clnt,
+				struct rpc_xprt *xprt,
+				void *data);
 
 static inline struct inode *nfs_igrab_and_active(struct inode *inode)
 {

commit 204cc0ccf1d49c6292aeef4c8edd1b3d10ff933c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 13 13:41:47 2018 -0500

    LSM: hide struct security_mnt_opts from any generic code
    
    Keep void * instead, allocate on demand (in parse_str_opts, at the
    moment).  Eventually both selinux and smack will be better off
    with private structures with several strings in those, rather than
    this "counter and two pointers to dynamically allocated arrays"
    ugliness.  This commit allows to do that at leisure, without
    disrupting anything outside of given module.
    
    Changes:
            * instead of struct security_mnt_opt use an opaque pointer
    initialized to NULL.
            * security_sb_eat_lsm_opts(), security_sb_parse_opts_str() and
    security_free_mnt_opts() take it as var argument (i.e. as void **);
    call sites are unchanged.
            * security_sb_set_mnt_opts() and security_sb_remount() take
    it by value (i.e. as void *).
            * new method: ->sb_free_mnt_opts().  Takes void *, does
    whatever freeing that needs to be done.
            * ->sb_set_mnt_opts() and ->sb_remount() might get NULL as
    mnt_opts argument, meaning "empty".
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 8357ff69962f..97e1dcefe561 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -123,7 +123,7 @@ struct nfs_parsed_mount_data {
 		unsigned short		protocol;
 	} nfs_server;
 
-	struct security_mnt_opts lsm_opts;
+	void			*lsm_opts;
 	struct net		*net;
 };
 

commit a52458b48af142bcc2b72fe810c0db20cfae7fdd
Author: NeilBrown <neilb@suse.com>
Date:   Mon Dec 3 11:30:31 2018 +1100

    NFS/NFSD/SUNRPC: replace generic creds with 'struct cred'.
    
    SUNRPC has two sorts of credentials, both of which appear as
    "struct rpc_cred".
    There are "generic credentials" which are supplied by clients
    such as NFS and passed in 'struct rpc_message' to indicate
    which user should be used to authorize the request, and there
    are low-level credentials such as AUTH_NULL, AUTH_UNIX, AUTH_GSS
    which describe the credential to be sent over the wires.
    
    This patch replaces all the generic credentials by 'struct cred'
    pointers - the credential structure used throughout Linux.
    
    For machine credentials, there is a special 'struct cred *' pointer
    which is statically allocated and recognized where needed as
    having a special meaning.  A look-up of a low-level cred will
    map this to a machine credential.
    
    Signed-off-by: NeilBrown <neilb@suse.com>
    Acked-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index ecb6d4317ab4..78d83b4bc398 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -254,7 +254,7 @@ struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *);
 void nfs_pgio_header_free(struct nfs_pgio_header *);
 int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
 int nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,
-		      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,
+		      const struct cred *cred, const struct nfs_rpc_ops *rpc_ops,
 		      const struct rpc_call_ops *call_ops, int how, int flags);
 void nfs_free_request(struct nfs_page *req);
 struct nfs_pgio_mirror *
@@ -269,7 +269,7 @@ static inline bool nfs_pgio_has_mirroring(struct nfs_pageio_descriptor *desc)
 static inline bool nfs_match_open_context(const struct nfs_open_context *ctx1,
 		const struct nfs_open_context *ctx2)
 {
-	return ctx1->cred == ctx2->cred && ctx1->state == ctx2->state;
+	return cred_fscmp(ctx1->cred, ctx2->cred) == 0 && ctx1->state == ctx2->state;
 }
 
 /* nfs2xdr.c */
@@ -564,10 +564,10 @@ extern struct nfs_client *nfs4_init_client(struct nfs_client *clp,
 			    const struct nfs_client_initdata *);
 extern int nfs40_walk_client_list(struct nfs_client *clp,
 				struct nfs_client **result,
-				struct rpc_cred *cred);
+				const struct cred *cred);
 extern int nfs41_walk_client_list(struct nfs_client *clp,
 				struct nfs_client **result,
-				struct rpc_cred *cred);
+				const struct cred *cred);
 extern int nfs4_test_session_trunk(struct rpc_clnt *,
 				struct rpc_xprt *,
 				void *);

commit 069d5bf5ec2650cfabc4bea9f6d779094a80b400
Author: Olga Kornievskaia <kolga@netapp.com>
Date:   Fri Oct 26 16:16:58 2018 -0400

    NFSv4: cleanup remove unused nfs4_xdev_fs_type
    
    commit e8f25e6d6d19 "NFS: Remove the NFS v4 xdev mount function"
    removed the last use of this.
    
    Signed-off-by: Olga Kornievskaia <kolga@netapp.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 8357ff69962f..ecb6d4317ab4 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -395,7 +395,6 @@ extern const struct super_operations nfs_sops;
 extern struct file_system_type nfs_fs_type;
 extern struct file_system_type nfs_xdev_fs_type;
 #if IS_ENABLED(CONFIG_NFS_V4)
-extern struct file_system_type nfs4_xdev_fs_type;
 extern struct file_system_type nfs4_referral_fs_type;
 #endif
 bool nfs_auth_info_match(const struct nfs_auth_info *, rpc_authflavor_t);

commit 1751e8a6cb935e555fcdbcb9ab4f0446e322ca3e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 27 13:05:09 2017 -0800

    Rename superblock flags (MS_xyz -> SB_xyz)
    
    This is a pure automated search-and-replace of the internal kernel
    superblock flags.
    
    The s_flags are now called SB_*, with the names and the values for the
    moment mirroring the MS_* flags that they're equivalent to.
    
    Note how the MS_xyz flags are the ones passed to the mount system call,
    while the SB_xyz flags are what we then use in sb->s_flags.
    
    The script to do this was:
    
        # places to look in; re security/*: it generally should *not* be
        # touched (that stuff parses mount(2) arguments directly), but
        # there are two places where we really deal with superblock flags.
        FILES="drivers/mtd drivers/staging/lustre fs ipc mm \
                include/linux/fs.h include/uapi/linux/bfs_fs.h \
                security/apparmor/apparmorfs.c security/apparmor/include/lib.h"
        # the list of MS_... constants
        SYMS="RDONLY NOSUID NODEV NOEXEC SYNCHRONOUS REMOUNT MANDLOCK \
              DIRSYNC NOATIME NODIRATIME BIND MOVE REC VERBOSE SILENT \
              POSIXACL UNBINDABLE PRIVATE SLAVE SHARED RELATIME KERNMOUNT \
              I_VERSION STRICTATIME LAZYTIME SUBMOUNT NOREMOTELOCK NOSEC BORN \
              ACTIVE NOUSER"
    
        SED_PROG=
        for i in $SYMS; do SED_PROG="$SED_PROG -e s/MS_$i/SB_$i/g"; done
    
        # we want files that contain at least one of MS_...,
        # with fs/namespace.c and fs/pnode.c excluded.
        L=$(for i in $SYMS; do git grep -w -l MS_$i $FILES; done| sort|uniq|grep -v '^fs/namespace.c'|grep -v '^fs/pnode.c')
    
        for f in $L; do sed -i $f $SED_PROG; done
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5ab17fd4700a..8357ff69962f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -10,7 +10,7 @@
 #include <linux/nfs_page.h>
 #include <linux/wait_bit.h>
 
-#define NFS_MS_MASK (MS_RDONLY|MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_SYNCHRONOUS)
+#define NFS_MS_MASK (SB_RDONLY|SB_NOSUID|SB_NODEV|SB_NOEXEC|SB_SYNCHRONOUS)
 
 extern const struct export_operations nfs_export_ops;
 

commit 5e4def20381678ba3ce0a4e117f97e378ecd81bc
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 2 15:27:44 2017 +0000

    Pass mode to wait_on_atomic_t() action funcs and provide default actions
    
    Make wait_on_atomic_t() pass the TASK_* mode onto its action function as an
    extra argument and make it 'unsigned int throughout.
    
    Also, consolidate a bunch of identical action functions into a default
    function that can do the appropriate thing for the mode.
    
    Also, change the argument name in the bit_wait*() function declarations to
    reflect the fact that it's the mode and not the bit number.
    
    [Peter Z gives this a grudging ACK, but thinks that the whole atomic_t wait
    should be done differently, though he's not immediately sure as to how]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    cc: Ingo Molnar <mingo@kernel.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index f9a4a5524bd5..5ab17fd4700a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -388,7 +388,7 @@ extern void nfs_evict_inode(struct inode *);
 void nfs_zap_acl_cache(struct inode *inode);
 extern bool nfs_check_cache_invalid(struct inode *, unsigned long);
 extern int nfs_wait_bit_killable(struct wait_bit_key *key, int mode);
-extern int nfs_wait_atomic_killable(atomic_t *p);
+extern int nfs_wait_atomic_killable(atomic_t *p, unsigned int mode);
 
 /* super.c */
 extern const struct super_operations nfs_sops;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5bdf952f414b..f9a4a5524bd5 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * NFS internal definitions
  */

commit bf4b49059718b2217339eb15c60f8753d5b0da99
Author: NeilBrown <neilb@suse.com>
Date:   Mon Sep 11 13:15:50 2017 +1000

    NFS: various changes relating to reporting IO errors.
    
    1/ remove 'start' and 'end' args from nfs_file_fsync_commit().
       They aren't used.
    
    2/ Make nfs_context_set_write_error() a "static inline" in internal.h
       so we can...
    
    3/ Use nfs_context_set_write_error() instead of mapping_set_error()
       if nfs_pageio_add_request() fails before sending any request.
       NFS generally keeps errors in the open_context, not the mapping,
       so this is more consistent.
    
    4/ If filemap_write_and_write_range() reports any error, still
       check ctx->error.  The value in ctx->error is likely to be
       more useful.  As part of this, NFS_CONTEXT_ERROR_WRITE is
       cleared slightly earlier, before nfs_file_fsync_commit() is called,
       rather than at the start of that function.
    
    Signed-off-by: NeilBrown <neilb@suse.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 68cc22083639..5bdf952f414b 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -768,3 +768,10 @@ static inline bool nfs_error_is_fatal(int err)
 		return false;
 	}
 }
+
+static inline void nfs_context_set_write_error(struct nfs_open_context *ctx, int error)
+{
+	ctx->error = error;
+	smp_wmb();
+	set_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);
+}

commit 196639ebbe63a037fe9a80669140bd292d8bcd80
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Fri Sep 8 21:28:11 2017 -0400

    NFS: Fix 2 use after free issues in the I/O code
    
    The writeback code wants to send a commit after processing the pages,
    which is why we want to delay releasing the struct path until after
    that's done.
    
    Also, the layout code expects that we do not free the inode before
    we've put the layout segments in pnfs_writehdr_free() and
    pnfs_readhdr_free()
    
    Fixes: 919e3bd9a875 ("NFS: Ensure we commit after writeback is complete")
    Fixes: 4714fb51fd03 ("nfs: remove pgio_header refcount, related cleanup")
    Cc: stable@vger.kernel.org
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index dc456416d2be..68cc22083639 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -251,7 +251,6 @@ int nfs_iocounter_wait(struct nfs_lock_context *l_ctx);
 extern const struct nfs_pageio_ops nfs_pgio_rw_ops;
 struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *);
 void nfs_pgio_header_free(struct nfs_pgio_header *);
-void nfs_pgio_data_destroy(struct nfs_pgio_header *);
 int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
 int nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,
 		      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,

commit b86faee6d111294fa95a2e89b5f771b2da3c9782
Merge: 48ea2cedde35 b4f937cffa66
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 13 14:35:37 2017 -0700

    Merge tag 'nfs-for-4.13-1' of git://git.linux-nfs.org/projects/anna/linux-nfs
    
    Pull NFS client updates from Anna Schumaker:
     "Stable bugfixes:
       - Fix -EACCESS on commit to DS handling
       - Fix initialization of nfs_page_array->npages
       - Only invalidate dentries that are actually invalid
    
      Features:
       - Enable NFSoRDMA transparent state migration
       - Add support for lookup-by-filehandle
       - Add support for nfs re-exporting
    
      Other bugfixes and cleanups:
       - Christoph cleaned up the way we declare NFS operations
       - Clean up various internal structures
       - Various cleanups to commits
       - Various improvements to error handling
       - Set the dt_type of . and .. entries in NFS v4
       - Make slot allocation more reliable
       - Fix fscache stat printing
       - Fix uninitialized variable warnings
       - Fix potential list overrun in nfs_atomic_open()
       - Fix a race in NFSoRDMA RPC reply handler
       - Fix return size for nfs42_proc_copy()
       - Fix against MAC forgery timing attacks"
    
    * tag 'nfs-for-4.13-1' of git://git.linux-nfs.org/projects/anna/linux-nfs: (68 commits)
      NFS: Don't run wake_up_bit() when nobody is waiting...
      nfs: add export operations
      nfs4: add NFSv4 LOOKUPP handlers
      nfs: add a nfs_ilookup helper
      nfs: replace d_add with d_splice_alias in atomic_open
      sunrpc: use constant time memory comparison for mac
      NFSv4.2 fix size storage for nfs42_proc_copy
      xprtrdma: Fix documenting comments in frwr_ops.c
      xprtrdma: Replace PAGE_MASK with offset_in_page()
      xprtrdma: FMR does not need list_del_init()
      xprtrdma: Demote "connect" log messages
      NFSv4.1: Use seqid returned by EXCHANGE_ID after state migration
      NFSv4.1: Handle EXCHGID4_FLAG_CONFIRMED_R during NFSv4.1 migration
      xprtrdma: Don't defer MR recovery if ro_map fails
      xprtrdma: Fix FRWR invalidation error recovery
      xprtrdma: Fix client lock-up after application signal fires
      xprtrdma: Rename rpcrdma_req::rl_free
      xprtrdma: Pass only the list of registered MRs to ro_unmap_sync
      xprtrdma: Pre-mark remotely invalidated MRs
      xprtrdma: On invalidation failure, remove MWs from rl_registered
      ...

commit 20fa19027286983ab2734b5910c4a687436e0c31
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Thu Jun 29 06:34:53 2017 -0700

    nfs: add export operations
    
    This support for opening files on NFS by file handle, both through the
    open_by_handle syscall, and for re-exporting NFS (for example using a
    different version).  The support is very basic for now, as each open by
    handle will have to do an NFSv4 open operation on the wire.  In the
    future this will hopefully be mitigated by an open file cache, as well
    as various optimizations in NFS for this specific case.
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    [hch: incorporated various changes, resplit the patches, new changelog]
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index c5054edb0157..2ebd57498986 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -10,6 +10,8 @@
 
 #define NFS_MS_MASK (MS_RDONLY|MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_SYNCHRONOUS)
 
+extern const struct export_operations nfs_export_ops;
+
 struct nfs_string;
 
 /* Maximum number of readahead requests

commit 62403005975c678ba7594a36670ae3bf0273d7c4
Merge: 19c6e12c07ce b20dae70bfa5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 13 13:56:24 2017 -0700

    Merge tag 'nfsd-4.13' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd updates from Bruce Fields:
     "Chuck's RDMA update overhauls the "call receive" side of the
      RPC-over-RDMA transport to use the new rdma_rw API.
    
      Christoph cleaned the way nfs operations are declared, removing a
      bunch of function-pointer casts and declaring the operation vectors as
      const.
    
      Christoph's changes touch both client and server, and both client and
      server pulls this time around should be based on the same commits from
      Christoph"
    
    * tag 'nfsd-4.13' of git://linux-nfs.org/~bfields/linux: (53 commits)
      svcrdma: fix an incorrect check on -E2BIG and -EINVAL
      nfsd4: factor ctime into change attribute
      svcrdma: Remove svc_rdma_chunk_ctxt::cc_dir field
      svcrdma: use offset_in_page() macro
      svcrdma: Clean up after converting svc_rdma_recvfrom to rdma_rw API
      svcrdma: Clean-up svc_rdma_unmap_dma
      svcrdma: Remove frmr cache
      svcrdma: Remove unused Read completion handlers
      svcrdma: Properly compute .len and .buflen for received RPC Calls
      svcrdma: Use generic RDMA R/W API in RPC Call path
      svcrdma: Add recvfrom helpers to svc_rdma_rw.c
      sunrpc: Allocate up to RPCSVC_MAXPAGES per svc_rqst
      svcrdma: Don't account for Receive queue "starvation"
      svcrdma: Improve Reply chunk sanity checking
      svcrdma: Improve Write chunk sanity checking
      svcrdma: Improve Read chunk sanity checking
      svcrdma: Remove svc_rdma_marshal.c
      svcrdma: Avoid Send Queue overflow
      svcrdma: Squelch disconnection messages
      sunrpc: Disable splice for krb5i
      ...

commit a7a3b1e971cd806b81ecea3a234d8dae9de0add0
Author: Benjamin Coddington <bcodding@redhat.com>
Date:   Tue Jun 20 08:33:44 2017 -0400

    NFS: convert flags to bool
    
    NFS uses some int, and unsigned int :1, and bool as flags in structs and
    args.  Assert the preference for uniformly replacing these with the bool
    type.
    
    Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 1c0ce9c15e94..c5054edb0157 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -272,17 +272,17 @@ static inline bool nfs_match_open_context(const struct nfs_open_context *ctx1,
 /* nfs2xdr.c */
 extern const struct rpc_procinfo nfs_procedures[];
 extern int nfs2_decode_dirent(struct xdr_stream *,
-				struct nfs_entry *, int);
+				struct nfs_entry *, bool);
 
 /* nfs3xdr.c */
 extern const struct rpc_procinfo nfs3_procedures[];
 extern int nfs3_decode_dirent(struct xdr_stream *,
-				struct nfs_entry *, int);
+				struct nfs_entry *, bool);
 
 /* nfs4xdr.c */
 #if IS_ENABLED(CONFIG_NFS_V4)
 extern int nfs4_decode_dirent(struct xdr_stream *,
-				struct nfs_entry *, int);
+				struct nfs_entry *, bool);
 #endif
 #ifdef CONFIG_NFS_V4_1
 extern const u32 nfs41_maxread_overhead;

commit aa8217d5dcb1db594d816794ef6ab434ebf3e127
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri May 12 16:21:37 2017 +0200

    sunrpc: mark all struct svc_version instances as const
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index dc2a29a7d48b..1c0ce9c15e94 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -225,8 +225,8 @@ static inline void nfs_fs_proc_exit(void)
 #endif
 
 /* callback_xdr.c */
-extern struct svc_version nfs4_callback_version1;
-extern struct svc_version nfs4_callback_version4;
+extern const struct svc_version nfs4_callback_version1;
+extern const struct svc_version nfs4_callback_version4;
 
 struct nfs_pageio_descriptor;
 /* pagelist.c */

commit 511e936bf2b3e8be2a3160ace3d86be07962a7a8
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri May 12 15:36:49 2017 +0200

    sunrpc: mark all struct rpc_procinfo instances as const
    
    struct rpc_procinfo contains function pointers, and marking it as
    constant avoids it being able to be used as an attach vector for
    code injections.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 3e24392f2caa..dc2a29a7d48b 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -270,12 +270,12 @@ static inline bool nfs_match_open_context(const struct nfs_open_context *ctx1,
 }
 
 /* nfs2xdr.c */
-extern struct rpc_procinfo nfs_procedures[];
+extern const struct rpc_procinfo nfs_procedures[];
 extern int nfs2_decode_dirent(struct xdr_stream *,
 				struct nfs_entry *, int);
 
 /* nfs3xdr.c */
-extern struct rpc_procinfo nfs3_procedures[];
+extern const struct rpc_procinfo nfs3_procedures[];
 extern int nfs3_decode_dirent(struct xdr_stream *,
 				struct nfs_entry *, int);
 
@@ -292,7 +292,7 @@ extern const u32 nfs41_maxgetdevinfo_overhead;
 
 /* nfs4proc.c */
 #if IS_ENABLED(CONFIG_NFS_V4)
-extern struct rpc_procinfo nfs4_procedures[];
+extern const struct rpc_procinfo nfs4_procedures[];
 #endif
 
 #ifdef CONFIG_NFS_V4_SECURITY_LABEL

commit 9a1d168e1bc2893120bb7c0d9932dd22f97d0b55
Merge: bb2a8b0cd116 32c1431eea48
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Wed Jun 28 13:34:15 2017 -0400

    Merge tag 'v4.12-rc5' into nfsd tree
    
    Update to get f0c3192ceee3 "virtio_net: lower limit on buffer size".
    That bug was interfering with my nfsd testing.

commit 5dd43ce2f69d42a71dcacdb13d17d8c0ac1fe8f7
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Jun 20 12:19:09 2017 +0200

    sched/wait: Split out the wait_bit*() APIs from <linux/wait.h> into <linux/wait_bit.h>
    
    The wait_bit*() types and APIs are mixed into wait.h, but they
    are a pretty orthogonal extension of wait-queues.
    
    Furthermore, only about 50 kernel files use these APIs, while
    over 1000 use the regular wait-queue functionality.
    
    So clean up the main wait.h by moving the wait-bit functionality
    out of it, into a separate .h and .c file:
    
      include/linux/wait_bit.h  for types and APIs
      kernel/sched/wait_bit.c   for the implementation
    
    Update all header dependencies.
    
    This reduces the size of wait.h rather significantly, by about 30%.
    
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 3e24392f2caa..8701d7617964 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -7,6 +7,7 @@
 #include <linux/security.h>
 #include <linux/crc32.h>
 #include <linux/nfs_page.h>
+#include <linux/wait_bit.h>
 
 #define NFS_MS_MASK (MS_RDONLY|MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_SYNCHRONOUS)
 

commit 4f253e1eb628f5adf7ca4f43aab4bbb1bfffa081
Author: Jan Kara <jack@suse.cz>
Date:   Tue May 16 12:18:11 2017 +0200

    nfs: Mark unnecessarily extern functions as static
    
    nfs_initialise_sb() and nfs_clone_super() are declared as extern even
    though they are used only in fs/nfs/super.c. Mark them as static.
    
    Also remove explicit 'inline' directive from nfs_initialise_sb() and
    leave it upto compiler to decide whether inlining is worth it.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index e9b4c3320e37..3e24392f2caa 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -398,7 +398,6 @@ extern struct file_system_type nfs4_referral_fs_type;
 bool nfs_auth_info_match(const struct nfs_auth_info *, rpc_authflavor_t);
 struct dentry *nfs_try_mount(int, const char *, struct nfs_mount_info *,
 			struct nfs_subversion *);
-void nfs_initialise_sb(struct super_block *);
 int nfs_set_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
 int nfs_clone_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
 struct dentry *nfs_fs_mount_common(struct nfs_server *, int, const char *,
@@ -458,7 +457,6 @@ extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
 
 /* super.c */
-void nfs_clone_super(struct super_block *, struct nfs_mount_info *);
 void nfs_umount_begin(struct super_block *);
 int  nfs_statfs(struct dentry *, struct kstatfs *);
 int  nfs_show_options(struct seq_file *, struct dentry *);

commit e9679189e34b25a1b9aa77fe37d331559d1544af
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri May 12 16:21:37 2017 +0200

    sunrpc: mark all struct svc_version instances as const
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index c21254924389..9976d8498cf3 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -225,8 +225,8 @@ static inline void nfs_fs_proc_exit(void)
 #endif
 
 /* callback_xdr.c */
-extern struct svc_version nfs4_callback_version1;
-extern struct svc_version nfs4_callback_version4;
+extern const struct svc_version nfs4_callback_version1;
+extern const struct svc_version nfs4_callback_version4;
 
 struct nfs_pageio_descriptor;
 /* pagelist.c */

commit 499b4988109e91b76f231fb1b4f1e53ec3260686
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri May 12 15:36:49 2017 +0200

    sunrpc: mark all struct rpc_procinfo instances as const
    
    struct rpc_procinfo contains function pointers, and marking it as
    constant avoids it being able to be used as an attach vector for
    code injections.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index e9b4c3320e37..c21254924389 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -270,12 +270,12 @@ static inline bool nfs_match_open_context(const struct nfs_open_context *ctx1,
 }
 
 /* nfs2xdr.c */
-extern struct rpc_procinfo nfs_procedures[];
+extern const struct rpc_procinfo nfs_procedures[];
 extern int nfs2_decode_dirent(struct xdr_stream *,
 				struct nfs_entry *, int);
 
 /* nfs3xdr.c */
-extern struct rpc_procinfo nfs3_procedures[];
+extern const struct rpc_procinfo nfs3_procedures[];
 extern int nfs3_decode_dirent(struct xdr_stream *,
 				struct nfs_entry *, int);
 
@@ -292,7 +292,7 @@ extern const u32 nfs41_maxgetdevinfo_overhead;
 
 /* nfs4proc.c */
 #if IS_ENABLED(CONFIG_NFS_V4)
-extern struct rpc_procinfo nfs4_procedures[];
+extern const struct rpc_procinfo nfs4_procedures[];
 #endif
 
 #ifdef CONFIG_NFS_V4_SECURITY_LABEL

commit e092693443b995c8e3a565a73b5fdb05f1260f9b
Author: Olga Kornievskaia <kolga@netapp.com>
Date:   Mon May 8 18:02:24 2017 -0400

    NFS append COMMIT after synchronous COPY
    
    Instead of messing with the commit path which has been causing issues,
    add a COMMIT op after the COPY and ask for stable copies in the first
    space.
    
    It saves a round trip, since after the COPY, the client sends a COMMIT
    anyway.
    
    Signed-off-by: Olga Kornievskaia <kolga@netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 31b26cf1b476..e9b4c3320e37 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -495,7 +495,6 @@ void nfs_mark_request_commit(struct nfs_page *req,
 			     u32 ds_commit_idx);
 int nfs_write_need_commit(struct nfs_pgio_header *);
 void nfs_writeback_update_inode(struct nfs_pgio_header *hdr);
-int nfs_commit_file(struct file *file, struct nfs_write_verifier *verf);
 int nfs_generic_commit_list(struct inode *inode, struct list_head *head,
 			    int how, struct nfs_commit_info *cinfo);
 void nfs_retry_commit(struct list_head *page_list,

commit 54551d85ad48b5b5f5735b9b76c147096828b626
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Wed Apr 26 12:21:49 2017 -0400

    NFS: Add a few more fatal I/O errors to nfs_error_is_fatal()
    
    EACCES, EDQUOT, EFBIG and ESTALE are all fatal errors as far as NFS
    I/O is concerned. They need to be reported back to the application.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7b38fedb7e03..31b26cf1b476 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -756,9 +756,13 @@ static inline bool nfs_error_is_fatal(int err)
 {
 	switch (err) {
 	case -ERESTARTSYS:
+	case -EACCES:
+	case -EDQUOT:
+	case -EFBIG:
 	case -EIO:
 	case -ENOSPC:
 	case -EROFS:
+	case -ESTALE:
 	case -E2BIG:
 		return true;
 	default:

commit a33e4b036d4612f62220f37a9fa29d273b6fd0ca
Author: Weston Andros Adamson <dros@monkey.org>
Date:   Thu Mar 9 12:56:48 2017 -0500

    pNFS: return status from nfs4_pnfs_ds_connect
    
    The nfs4_pnfs_ds_connect path can call rpc_create which can fail or it
    can wait on another context to reach the same failure.
    
    This checks that the rpc_create succeeded and returns the error to the
    caller.
    
    When an error is returned, both the files and flexfiles layouts will return
    NULL from _prepare_ds(). The flexfiles layout will also return the layout
    with the error NFS4ERR_NXIO.
    
    Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 09ca5095c04e..7b38fedb7e03 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -186,6 +186,8 @@ extern struct nfs_server *nfs_clone_server(struct nfs_server *,
 					   struct nfs_fh *,
 					   struct nfs_fattr *,
 					   rpc_authflavor_t);
+extern bool nfs_client_init_is_complete(const struct nfs_client *clp);
+extern int nfs_client_init_status(const struct nfs_client *clp);
 extern int nfs_wait_client_init_complete(const struct nfs_client *clp);
 extern void nfs_mark_client_ready(struct nfs_client *clp, int state);
 extern struct nfs_client *nfs4_set_ds_client(struct nfs_server *mds_srv,

commit 61540bf6bb40ddfa3e766de91cedca2e1afd24eb
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Dec 8 18:18:38 2016 -0500

    NFS: Clean up cache validity checking
    
    Consolidate the open-coded checking of NFS_I(inode)->cache_validity
    into a couple of helper functions.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 6b79c2ca9b9a..09ca5095c04e 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -381,6 +381,7 @@ extern int nfs_drop_inode(struct inode *);
 extern void nfs_clear_inode(struct inode *);
 extern void nfs_evict_inode(struct inode *);
 void nfs_zap_acl_cache(struct inode *inode);
+extern bool nfs_check_cache_invalid(struct inode *, unsigned long);
 extern int nfs_wait_bit_killable(struct wait_bit_key *key, int mode);
 extern int nfs_wait_atomic_killable(atomic_t *p);
 

commit 1bcf4c5c597d1b1862cf54e65198f1c9e3cad29c
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Fri Dec 2 09:15:37 2016 -0500

    NFS: Allow getattr to also report readdirplus cache hits
    
    If the use called stat() on an 'ls -l' workload, and the attribute
    cache was successfully revalidate by READDIRPLUS, then we want to
    report that back so that the readdir code continues to use
    readdirplus.
    
    Reviewed-by: Benjamin Coddington <bcodding@redhat.com>
    Tested-by: Benjamin Coddington <bcodding@redhat.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 4622d5f18e35..6b79c2ca9b9a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -344,6 +344,7 @@ extern struct nfs_client *nfs_init_client(struct nfs_client *clp,
 			   const struct nfs_client_initdata *);
 
 /* dir.c */
+extern void nfs_advise_use_readdirplus(struct inode *dir);
 extern void nfs_force_use_readdirplus(struct inode *dir);
 extern unsigned long nfs_access_cache_count(struct shrinker *shrink,
 					    struct shrink_control *sc);

commit 7d38de3ffa75f92e7b00301dcdc6a3f9c53509ab
Author: Anna Schumaker <Anna.Schumaker@Netapp.com>
Date:   Thu Nov 17 15:15:55 2016 -0500

    NFS: Remove unused authflavour parameter from nfs_get_client()
    
    This parameter hasn't been used since f8407299 (Linux 3.11-rc2), so
    let's remove it from this function and callers.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 80bcc0befb07..4622d5f18e35 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -154,8 +154,7 @@ extern const struct rpc_program nfs_program;
 extern void nfs_clients_init(struct net *net);
 extern struct nfs_client *nfs_alloc_client(const struct nfs_client_initdata *);
 int nfs_create_rpc_client(struct nfs_client *, const struct nfs_client_initdata *, rpc_authflavor_t);
-struct nfs_client *nfs_get_client(const struct nfs_client_initdata *,
-				  rpc_authflavor_t);
+struct nfs_client *nfs_get_client(const struct nfs_client_initdata *);
 int nfs_probe_fsinfo(struct nfs_server *server, struct nfs_fh *, struct nfs_fattr *);
 void nfs_server_insert_lists(struct nfs_server *);
 void nfs_server_remove_lists(struct nfs_server *);
@@ -194,14 +193,13 @@ extern struct nfs_client *nfs4_set_ds_client(struct nfs_server *mds_srv,
 					     int ds_addrlen, int ds_proto,
 					     unsigned int ds_timeo,
 					     unsigned int ds_retrans,
-					     u32 minor_version,
-					     rpc_authflavor_t au_flavor);
+					     u32 minor_version);
 extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,
 						struct inode *);
 extern struct nfs_client *nfs3_set_ds_client(struct nfs_server *mds_srv,
 			const struct sockaddr *ds_addr, int ds_addrlen,
 			int ds_proto, unsigned int ds_timeo,
-			unsigned int ds_retrans, rpc_authflavor_t au_flavor);
+			unsigned int ds_retrans);
 #ifdef CONFIG_PROC_FS
 extern int __init nfs_fs_proc_init(void);
 extern void nfs_fs_proc_exit(void);

commit c4a86165d1ec70c8e592fa7b7cc7070971533021
Merge: 2778556474b1 3f807e5ae559
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 13 21:28:20 2016 -0700

    Merge tag 'nfs-for-4.9-1' of git://git.linux-nfs.org/projects/anna/linux-nfs
    
    Pull NFS client updates from Anna Schumaker:
     "Highlights include:
    
      Stable bugfixes:
       - sunrpc: fix writ espace race causing stalls
       - NFS: Fix inode corruption in nfs_prime_dcache()
       - NFSv4: Don't report revoked delegations as valid in nfs_have_delegation()
       - NFSv4: nfs4_copy_delegation_stateid() must fail if the delegation is invalid
       - NFSv4: Open state recovery must account for file permission changes
       - NFSv4.2: Fix a reference leak in nfs42_proc_layoutstats_generic
    
      Features:
       - Add support for tracking multiple layout types with an ordered list
       - Add support for using multiple backchannel threads on the client
       - Add support for pNFS file layout session trunking
       - Delay xprtrdma use of DMA API (for device driver removal)
       - Add support for xprtrdma remote invalidation
       - Add support for larger xprtrdma inline thresholds
       - Use a scatter/gather list for sending xprtrdma RPC calls
       - Add support for the CB_NOTIFY_LOCK callback
       - Improve hashing sunrpc auth_creds by using both uid and gid
    
      Bugfixes:
       - Fix xprtrdma use of DMA API
       - Validate filenames before adding to the dcache
       - Fix corruption of xdr->nwords in xdr_copy_to_scratch
       - Fix setting buffer length in xdr_set_next_buffer()
       - Don't deadlock the state manager on the SEQUENCE status flags
       - Various delegation and stateid related fixes
       - Retry operations if an interrupted slot receives EREMOTEIO
       - Make nfs boot time y2038 safe"
    
    * tag 'nfs-for-4.9-1' of git://git.linux-nfs.org/projects/anna/linux-nfs: (100 commits)
      NFSv4.2: Fix a reference leak in nfs42_proc_layoutstats_generic
      fs: nfs: Make nfs boot time y2038 safe
      sunrpc: replace generic auth_cred hash with auth-specific function
      sunrpc: add RPCSEC_GSS hash_cred() function
      sunrpc: add auth_unix hash_cred() function
      sunrpc: add generic_auth hash_cred() function
      sunrpc: add hash_cred() function to rpc_authops struct
      Retry operation on EREMOTEIO on an interrupted slot
      pNFS: Fix atime updates on pNFS clients
      sunrpc: queue work on system_power_efficient_wq
      NFSv4.1: Even if the stateid is OK, we may need to recover the open modes
      NFSv4: If recovery failed for a specific open stateid, then don't retry
      NFSv4: Fix retry issues with nfs41_test/free_stateid
      NFSv4: Open state recovery must account for file permission changes
      NFSv4: Mark the lock and open stateids as invalid after freeing them
      NFSv4: Don't test open_stateid unless it is set
      NFSv4: nfs4_do_handle_exception() handle revoke/expiry of a single stateid
      NFS: Always call nfs_inode_find_state_and_recover() when revoking a delegation
      NFSv4: Fix a race when updating an open_stateid
      NFSv4: Fix a race in nfs_inode_reclaim_delegation()
      ...

commit 101105b1717f536ca741f940033996302d4ef191
Merge: 35ff96dfd3c9 3873691e5ab3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 20:16:43 2016 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull more vfs updates from Al Viro:
     ">rename2() work from Miklos + current_time() from Deepa"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs: Replace current_fs_time() with current_time()
      fs: Replace CURRENT_TIME_SEC with current_time() for inode timestamps
      fs: Replace CURRENT_TIME with current_time() for inode timestamps
      fs: proc: Delete inode time initializations in proc_alloc_inode()
      vfs: Add current_time() api
      vfs: add note about i_op->rename changes to porting
      fs: rename "rename2" i_op to "rename"
      vfs: remove unused i_op->rename
      fs: make remaining filesystems use .rename2
      libfs: support RENAME_NOREPLACE in simple_rename()
      fs: support RENAME_NOREPLACE for local filesystems
      ncpfs: fix unused variable warning

commit b66484cd74706fa8681d051840fe4b18a3da40ff
Merge: c913fc4146ba 05fd007e4629
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 7 21:38:00 2016 -0700

    Merge branch 'akpm' (patches from Andrew)
    
    Merge updates from Andrew Morton:
    
     - fsnotify updates
    
     - ocfs2 updates
    
     - all of MM
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (127 commits)
      console: don't prefer first registered if DT specifies stdout-path
      cred: simpler, 1D supplementary groups
      CREDITS: update Pavel's information, add GPG key, remove snail mail address
      mailmap: add Johan Hovold
      .gitattributes: set git diff driver for C source code files
      uprobes: remove function declarations from arch/{mips,s390}
      spelling.txt: "modeled" is spelt correctly
      nmi_backtrace: generate one-line reports for idle cpus
      arch/tile: adopt the new nmi_backtrace framework
      nmi_backtrace: do a local dump_stack() instead of a self-NMI
      nmi_backtrace: add more trigger_*_cpu_backtrace() methods
      min/max: remove sparse warnings when they're nested
      Documentation/filesystems/proc.txt: add more description for maps/smaps
      mm, proc: fix region lost in /proc/self/smaps
      proc: fix timerslack_ns CAP_SYS_NICE check when adjusting self
      proc: add LSM hook checks to /proc/<tid>/timerslack_ns
      proc: relax /proc/<tid>/timerslack_ns capability requirements
      meminfo: break apart a very long seq_printf with #ifdefs
      seq/proc: modify seq_put_decimal_[u]ll to take a const char *, not char
      proc: faster /proc/*/status
      ...

commit 8cd797887ae0a73313ba248e027e59c0a597d693
Author: Huang Ying <ying.huang@intel.com>
Date:   Fri Oct 7 17:00:24 2016 -0700

    mm: remove page_file_index
    
    After using the offset of the swap entry as the key of the swap cache,
    the page_index() becomes exactly same as page_file_index().  So the
    page_file_index() is removed and the callers are changed to use
    page_index() instead.
    
    Link: http://lkml.kernel.org/r/1473270649-27229-2-git-send-email-ying.huang@intel.com
    Signed-off-by: "Huang, Ying" <ying.huang@intel.com>
    Cc: Trond Myklebust <trond.myklebust@primarydata.com>
    Cc: Anna Schumaker <anna.schumaker@netapp.com>
    Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 74935a19e4bf..da9e5584bfdc 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -681,11 +681,11 @@ unsigned int nfs_page_length(struct page *page)
 	loff_t i_size = i_size_read(page_file_mapping(page)->host);
 
 	if (i_size > 0) {
-		pgoff_t page_index = page_file_index(page);
+		pgoff_t index = page_index(page);
 		pgoff_t end_index = (i_size - 1) >> PAGE_SHIFT;
-		if (page_index < end_index)
+		if (index < end_index)
 			return PAGE_SIZE;
-		if (page_index == end_index)
+		if (index == end_index)
 			return ((i_size - 1) & ~PAGE_MASK) + 1;
 	}
 	return 0;

commit 82c156f853840645604acd7c2cebcb75ed1b6652
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Sep 22 23:35:42 2016 -0400

    switch generic_file_splice_read() to use of ->read_iter()
    
    ... and kill the ->splice_read() instances that can be switched to it
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 74935a19e4bf..d7b062bdc504 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -365,8 +365,6 @@ int nfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *)
 int nfs_file_fsync(struct file *file, loff_t start, loff_t end, int datasync);
 loff_t nfs_file_llseek(struct file *, loff_t, int);
 ssize_t nfs_file_read(struct kiocb *, struct iov_iter *);
-ssize_t nfs_file_splice_read(struct file *, loff_t *, struct pipe_inode_info *,
-			     size_t, unsigned int);
 int nfs_file_mmap(struct file *, struct vm_area_struct *);
 ssize_t nfs_file_write(struct kiocb *, struct iov_iter *);
 int nfs_file_release(struct inode *, struct file *);

commit bfc505ded01e3c57d12c6f939f352200655d8635
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Sep 15 18:26:05 2016 -0400

    pNFS: Fix atime updates on pNFS clients
    
    Fix the code so that we always mark the atime as invalid in nfs4_read_done().
    Currently, the expectation appears to be that the pNFS drivers should always
    do this, with the result that most of them don't.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 4f0b2db8327f..512b776824c9 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -560,7 +560,6 @@ void nfs_init_cinfo_from_dreq(struct nfs_commit_info *cinfo,
 extern ssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq);
 
 /* nfs4proc.c */
-extern void __nfs4_read_done_cb(struct nfs_pgio_header *);
 extern struct nfs_client *nfs4_init_client(struct nfs_client *clp,
 			    const struct nfs_client_initdata *);
 extern int nfs40_walk_client_list(struct nfs_client *clp,

commit 1cd66c93ba8cdb873258f58ae6a817b28a02bcc3
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 27 11:03:58 2016 +0200

    fs: make remaining filesystems use .rename2
    
    This is trivial to do:
    
     - add flags argument to foo_rename()
     - check if flags is zero
     - assign foo_rename() to .rename2 instead of .rename
    
    This doesn't mean it's impossible to support RENAME_NOREPLACE for these
    filesystems, but it is not trivial, like for local filesystems.
    RENAME_NOREPLACE must guarantee atomicity (i.e. it shouldn't be possible
    for a file to be created on one host while it is overwritten by rename on
    another host).
    
    Filesystems converted:
    
    9p, afs, ceph, coda, ecryptfs, kernfs, lustre, ncpfs, nfs, ocfs2, orangefs.
    
    After this, we can get rid of the duplicate interfaces for rename.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: David Howells <dhowells@redhat.com> [AFS]
    Acked-by: Mike Marshall <hubcap@omnibond.com>
    Cc: Eric Van Hensbergen <ericvh@gmail.com>
    Cc: Ilya Dryomov <idryomov@gmail.com>
    Cc: Jan Harkes <jaharkes@cs.cmu.edu>
    Cc: Tyler Hicks <tyhicks@canonical.com>
    Cc: Oleg Drokin <oleg.drokin@intel.com>
    Cc: Trond Myklebust <trond.myklebust@primarydata.com>
    Cc: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 74935a19e4bf..48d1adfe25d6 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -359,7 +359,8 @@ int nfs_unlink(struct inode *, struct dentry *);
 int nfs_symlink(struct inode *, struct dentry *, const char *);
 int nfs_link(struct dentry *, struct inode *, struct dentry *);
 int nfs_mknod(struct inode *, struct dentry *, umode_t, dev_t);
-int nfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+int nfs_rename(struct inode *, struct dentry *,
+	       struct inode *, struct dentry *, unsigned int);
 
 /* file.c */
 int nfs_file_fsync(struct file *file, loff_t start, loff_t end, int datasync);

commit f844cd0d76378fa898890d2448222d407f3f8ecf
Author: Chao Yu <yuchao0@huawei.com>
Date:   Tue Sep 20 13:59:07 2016 +0800

    nfs: cover ->migratepage with CONFIG_MIGRATION
    
    It will be more clean to use CONFIG_MIGRATION to cover nfs' private
    .migratepage in nfs_file_aops like we do in other part of nfs
    operations.
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index fd82bed39ed4..4f0b2db8327f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -535,12 +535,9 @@ void nfs_clear_pnfs_ds_commit_verifiers(struct pnfs_ds_commit_info *cinfo)
 }
 #endif
 
-
 #ifdef CONFIG_MIGRATION
 extern int nfs_migrate_page(struct address_space *,
 		struct page *, struct page *, enum migrate_mode);
-#else
-#define nfs_migrate_page NULL
 #endif
 
 static inline int

commit 04fa2c6bb51b1bf34a49007e0cd824bde39eeac0
Author: Andy Adamson <andros@netapp.com>
Date:   Fri Sep 9 09:22:29 2016 -0400

    NFS pnfs data server multipath session trunking
    
    Try all multipath addresses for a data server. The first address that
    successfully connects and creates a session is the DS mount address.
    All subsequent addresses are tested for session trunking and
    added as aliases.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 74935a19e4bf..fd82bed39ed4 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -572,6 +572,9 @@ extern int nfs40_walk_client_list(struct nfs_client *clp,
 extern int nfs41_walk_client_list(struct nfs_client *clp,
 				struct nfs_client **result,
 				struct rpc_cred *cred);
+extern int nfs4_test_session_trunk(struct rpc_clnt *,
+				struct rpc_xprt *,
+				void *);
 
 static inline struct inode *nfs_igrab_and_active(struct inode *inode)
 {

commit a956beda19a6b39fbc19d0aaf21947acdc18cf74
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Aug 16 10:26:47 2016 -0400

    NFS: Allow the mount option retrans=0
    
    We should allow retrans=0 as just meaning that every timeout is a major
    timeout, and that there is no increment in the timeout value.
    
    For instance, this means that we would allow TCP users to specify a
    flat timeout value of 60s, by specifying "timeo=600,retrans=0" in their
    mount option string.
    
    Siged-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7ce5e023c3c3..74935a19e4bf 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -58,6 +58,9 @@ struct nfs_clone_mount {
  */
 #define NFS_UNSPEC_PORT		(-1)
 
+#define NFS_UNSPEC_RETRANS	(UINT_MAX)
+#define NFS_UNSPEC_TIMEO	(UINT_MAX)
+
 /*
  * Maximum number of pages that readdir can use for creating
  * a vmapped array of pages.
@@ -156,7 +159,7 @@ struct nfs_client *nfs_get_client(const struct nfs_client_initdata *,
 int nfs_probe_fsinfo(struct nfs_server *server, struct nfs_fh *, struct nfs_fattr *);
 void nfs_server_insert_lists(struct nfs_server *);
 void nfs_server_remove_lists(struct nfs_server *);
-void nfs_init_timeout_values(struct rpc_timeout *, int, unsigned int, unsigned int);
+void nfs_init_timeout_values(struct rpc_timeout *to, int proto, int timeo, int retrans);
 int nfs_init_server_rpcclient(struct nfs_server *, const struct rpc_timeout *t,
 		rpc_authflavor_t);
 struct nfs_server *nfs_alloc_server(void);

commit 7f155c702677d057d03b192ce652311de5434697
Merge: d761f3ed6e71 944171cbf499
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 30 16:33:25 2016 -0700

    Merge tag 'nfs-for-4.8-1' of git://git.linux-nfs.org/projects/trondmy/linux-nfs
    
    Pull NFS client updates from Trond Myklebust:
     "Highlights include:
    
      Stable bugfixes:
       - nfs: don't create zero-length requests
    
       - several LAYOUTGET bugfixes
    
      Features:
       - several performance related features
    
       - more aggressive caching when we can rely on close-to-open
         cache consistency
    
       - remove serialisation of O_DIRECT reads and writes
    
       - optimise several code paths to not flush to disk unnecessarily.
    
         However allow for the idiosyncracies of pNFS for those layout
         types that need to issue a LAYOUTCOMMIT before the metadata can
         be updated on the server.
    
       - SUNRPC updates to the client data receive path
    
       - pNFS/SCSI support RH/Fedora dm-mpath device nodes
    
       - pNFS files/flexfiles can now use unprivileged ports when
         the generic NFS mount options allow it.
    
      Bugfixes:
       - Don't use RDMA direct data placement together with data
         integrity or privacy security flavours
    
       - Remove the RDMA ALLPHYSICAL memory registration mode as
         it has potential security holes.
    
       - Several layout recall fixes to improve NFSv4.1 protocol
         compliance.
    
       - Fix an Oops in the pNFS files and flexfiles connection
         setup to the DS
    
       - Allow retry of operations that used a returned delegation
          stateid
    
       - Don't mark the inode as revalidated if a LAYOUTCOMMIT is
         outstanding
    
       - Fix writeback races in nfs4_copy_range() and
         nfs42_proc_deallocate()"
    
    * tag 'nfs-for-4.8-1' of git://git.linux-nfs.org/projects/trondmy/linux-nfs: (104 commits)
      pNFS: Actively set attributes as invalid if LAYOUTCOMMIT is outstanding
      NFSv4: Clean up lookup of SECINFO_NO_NAME
      NFSv4.2: Fix warning "variable ‘stateids’ set but not used"
      NFSv4: Fix warning "no previous prototype for ‘nfs4_listxattr’"
      SUNRPC: Fix a compiler warning in fs/nfs/clnt.c
      pNFS: Remove redundant smp_mb() from pnfs_init_lseg()
      pNFS: Cleanup - do layout segment initialisation in one place
      pNFS: Remove redundant stateid invalidation
      pNFS: Remove redundant pnfs_mark_layout_returned_if_empty()
      pNFS: Clear the layout metadata if the server changed the layout stateid
      pNFS: Cleanup - don't open code pnfs_mark_layout_stateid_invalid()
      NFS: pnfs_mark_matching_lsegs_return() should match the layout sequence id
      pNFS: Do not set plh_return_seq for non-callback related layoutreturns
      pNFS: Ensure layoutreturn acts as a completion for layout callbacks
      pNFS: Fix CB_LAYOUTRECALL stateid verification
      pNFS: Always update the layout barrier seqid on LAYOUTGET
      pNFS: Always update the layout stateid if NFS_LAYOUT_INVALID_STID is set
      pNFS: Clear the layout return tracking on layout reinitialisation
      pNFS: LAYOUTRETURN should only update the stateid if the layout is valid
      nfs: don't create zero-length requests
      ...

commit 11fb998986a72aa7e997d96d63d52582a01228c5
Author: Mel Gorman <mgorman@techsingularity.net>
Date:   Thu Jul 28 15:46:20 2016 -0700

    mm: move most file-based accounting to the node
    
    There are now a number of accounting oddities such as mapped file pages
    being accounted for on the node while the total number of file pages are
    accounted on the zone.  This can be coped with to some extent but it's
    confusing so this patch moves the relevant file-based accounted.  Due to
    throttling logic in the page allocator for reliable OOM detection, it is
    still necessary to track dirty and writeback pages on a per-zone basis.
    
    [mgorman@techsingularity.net: fix NR_ZONE_WRITE_PENDING accounting]
      Link: http://lkml.kernel.org/r/1468404004-5085-5-git-send-email-mgorman@techsingularity.net
    Link: http://lkml.kernel.org/r/1467970510-21195-20-git-send-email-mgorman@techsingularity.net
    Signed-off-by: Mel Gorman <mgorman@techsingularity.net>
    Acked-by: Vlastimil Babka <vbabka@suse.cz>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Hillf Danton <hillf.zj@alibaba-inc.com>
    Acked-by: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: Minchan Kim <minchan@kernel.org>
    Cc: Rik van Riel <riel@surriel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5154fa65a2f2..5ea04d87fc65 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -623,7 +623,7 @@ void nfs_mark_page_unstable(struct page *page, struct nfs_commit_info *cinfo)
 	if (!cinfo->dreq) {
 		struct inode *inode = page_file_mapping(page)->host;
 
-		inc_zone_page_state(page, NR_UNSTABLE_NFS);
+		inc_node_page_state(page, NR_UNSTABLE_NFS);
 		inc_wb_stat(&inode_to_bdi(inode)->wb, WB_RECLAIMABLE);
 		__mark_inode_dirty(inode, I_DIRTY_DATASYNC);
 	}

commit 362745268ce119c473952b30f57d947bdede7f7a
Merge: 7f94ed24958d e033fb51ebb2
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sun Jul 24 17:08:31 2016 -0400

    Merge branch 'writeback'

commit b224f7cb635f0a1a0a80c1dae93699a2a1161604
Author: Tigran Mkrtchyan <tigran.mkrtchyan@desy.de>
Date:   Mon Jun 13 20:52:00 2016 +0200

    nfs4: flexfiles: respect noresvport when establishing connections to DSes
    
    Signed-off-by: Tigran Mkrtchyan <tigran.mkrtchyan@desy.de>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index b257a2eaf92c..f7e33a5984d8 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -195,7 +195,7 @@ extern struct nfs_client *nfs4_set_ds_client(struct nfs_server *mds_srv,
 					     rpc_authflavor_t au_flavor);
 extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,
 						struct inode *);
-extern struct nfs_client *nfs3_set_ds_client(struct nfs_client *mds_clp,
+extern struct nfs_client *nfs3_set_ds_client(struct nfs_server *mds_srv,
 			const struct sockaddr *ds_addr, int ds_addrlen,
 			int ds_proto, unsigned int ds_timeo,
 			unsigned int ds_retrans, rpc_authflavor_t au_flavor);

commit 3fc75f12089eab6bf3f5350a5f760f241060bd5d
Author: Tigran Mkrtchyan <tigran.mkrtchyan@desy.de>
Date:   Mon Jun 13 19:57:35 2016 +0200

    nfs4: clnt: respect noresvport when establishing connections to DSes
    
    result:
    
    $ mount -o vers=4.1 dcache-lab007:/ /pnfs
    $ cp /etc/profile /pnfs
    tcp        0      0 131.169.185.68:1005     131.169.191.141:32049   ESTABLISHED
    tcp        0      0 131.169.185.68:751      131.169.191.144:2049    ESTABLISHED
    $
    
    $ mount -o vers=4.1,noresvport dcache-lab007:/ /pnfs
    $ cp /etc/profile /pnfs
    tcp        0      0 131.169.185.68:34894    131.169.191.141:32049   ESTABLISHED
    tcp        0      0 131.169.185.68:35722    131.169.191.144:2049    ESTABLISHED
    $
    
    Signed-off-by: Tigran Mkrtchyan <tigran.mkrtchyan@desy.de>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index d2260e67334f..b257a2eaf92c 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -186,7 +186,7 @@ extern struct nfs_server *nfs_clone_server(struct nfs_server *,
 					   rpc_authflavor_t);
 extern int nfs_wait_client_init_complete(const struct nfs_client *clp);
 extern void nfs_mark_client_ready(struct nfs_client *clp, int state);
-extern struct nfs_client *nfs4_set_ds_client(struct nfs_client* mds_clp,
+extern struct nfs_client *nfs4_set_ds_client(struct nfs_server *mds_srv,
 					     const struct sockaddr *ds_addr,
 					     int ds_addrlen, int ds_proto,
 					     unsigned int ds_timeo,

commit ce52914eb76efd62aa48d738cf845b37852bf920
Author: Scott Mayhew <smayhew@redhat.com>
Date:   Tue Jun 7 15:14:48 2016 -0400

    sunrpc: move NO_CRKEY_TIMEOUT to the auth->au_flags
    
    A generic_cred can be used to look up a unx_cred or a gss_cred, so it's
    not really safe to use the the generic_cred->acred->ac_flags to store
    the NO_CRKEY_TIMEOUT flag.  A lookup for a unx_cred triggered while the
    KEY_EXPIRE_SOON flag is already set will cause both NO_CRKEY_TIMEOUT and
    KEY_EXPIRE_SOON to be set in the ac_flags, leaving the user associated
    with the auth_cred to be in a state where they're perpetually doing 4K
    NFS_FILE_SYNC writes.
    
    This can be reproduced as follows:
    
    1. Mount two NFS filesystems, one with sec=krb5 and one with sec=sys.
    They do not need to be the same export, nor do they even need to be from
    the same NFS server.  Also, v3 is fine.
    $ sudo mount -o v3,sec=krb5 server1:/export /mnt/krb5
    $ sudo mount -o v3,sec=sys server2:/export /mnt/sys
    
    2. As the normal user, before accessing the kerberized mount, kinit with
    a short lifetime (but not so short that renewing the ticket would leave
    you within the 4-minute window again by the time the original ticket
    expires), e.g.
    $ kinit -l 10m -r 60m
    
    3. Do some I/O to the kerberized mount and verify that the writes are
    wsize, UNSTABLE:
    $ dd if=/dev/zero of=/mnt/krb5/file bs=1M count=1
    
    4. Wait until you're within 4 minutes of key expiry, then do some more
    I/O to the kerberized mount to ensure that RPC_CRED_KEY_EXPIRE_SOON gets
    set.  Verify that the writes are 4K, FILE_SYNC:
    $ dd if=/dev/zero of=/mnt/krb5/file bs=1M count=1
    
    5. Now do some I/O to the sec=sys mount.  This will cause
    RPC_CRED_NO_CRKEY_TIMEOUT to be set:
    $ dd if=/dev/zero of=/mnt/sys/file bs=1M count=1
    
    6. Writes for that user will now be permanently 4K, FILE_SYNC for that
    user, regardless of which mount is being written to, until you reboot
    the client.  Renewing the kerberos ticket (assuming it hasn't already
    expired) will have no effect.  Grabbing a new kerberos ticket at this
    point will have no effect either.
    
    Move the flag to the auth->au_flags field (which is currently unused)
    and rename it slightly to reflect that it's no longer associated with
    the auth_cred->ac_flags.  Add the rpc_auth to the arg list of
    rpcauth_cred_key_to_expire and check the au_flags there too.  Finally,
    add the inode to the arg list of nfs_ctx_key_to_expire so we can
    determine the rpc_auth to pass to rpcauth_cred_key_to_expire.
    
    Signed-off-by: Scott Mayhew <smayhew@redhat.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index fa88609f85e3..d2260e67334f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -497,7 +497,7 @@ void nfs_init_cinfo(struct nfs_commit_info *cinfo,
 		    struct inode *inode,
 		    struct nfs_direct_req *dreq);
 int nfs_key_timeout_notify(struct file *filp, struct inode *inode);
-bool nfs_ctx_key_to_expire(struct nfs_open_context *ctx);
+bool nfs_ctx_key_to_expire(struct nfs_open_context *ctx, struct inode *inode);
 void nfs_pageio_stop_mirroring(struct nfs_pageio_descriptor *pgio);
 
 #ifdef CONFIG_MIGRATION

commit 837bb1d752d92ea4d870877ffbd6ec5cf76624b3
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sat Jun 25 18:12:03 2016 -0400

    NFSv4.2: Fix writeback races in nfs4_copy_file_range
    
    We need to ensure that any writes to the destination file are serialised
    with the copy, meaning that the writeback has to occur under the inode lock.
    
    Also relax the writeback requirement on the source, and rely on the
    stateid checking to tell us if the source rebooted. Add the helper
    nfs_filemap_write_and_wait_range() to call pnfs_sync_inode() as
    is appropriate for pNFS servers that may need a layoutcommit.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 01dccf18da0a..3b01c9146e15 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -512,6 +512,9 @@ int nfs_key_timeout_notify(struct file *filp, struct inode *inode);
 bool nfs_ctx_key_to_expire(struct nfs_open_context *ctx);
 void nfs_pageio_stop_mirroring(struct nfs_pageio_descriptor *pgio);
 
+int nfs_filemap_write_and_wait_range(struct address_space *mapping,
+		loff_t lstart, loff_t lend);
+
 #ifdef CONFIG_NFS_V4_1
 static inline
 void nfs_clear_pnfs_ds_commit_verifiers(struct pnfs_ds_commit_info *cinfo)

commit 651b0e702981304f77091b82870a01480705f4fe
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sat Jun 25 17:24:46 2016 -0400

    NFS: Do not aggressively cache file attributes in the case of O_DIRECT
    
    A file that is open for O_DIRECT is by definition not obeying
    close-to-open cache consistency semantics, so let's not cache
    the attributes too aggressively either.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 159b64ede82a..01dccf18da0a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -419,6 +419,11 @@ extern void nfs_end_io_write(struct inode *inode);
 extern void nfs_start_io_direct(struct inode *inode);
 extern void nfs_end_io_direct(struct inode *inode);
 
+static inline bool nfs_file_io_is_buffered(struct nfs_inode *nfsi)
+{
+	return test_bit(NFS_INO_ODIRECT, &nfsi->flags) == 0;
+}
+
 /* namespace.c */
 #define NFS_PATH_CANONICAL 1
 extern char *nfs_path(char **p, struct dentry *dentry,

commit a5864c999de6703f7ce908f72337568520c6cad3
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Fri Jun 3 17:07:19 2016 -0400

    NFS: Do not serialise O_DIRECT reads and writes
    
    Allow dio requests to be scheduled in parallel, but ensuring that they
    do not conflict with buffered I/O.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 0eb5c924886d..159b64ede82a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -411,6 +411,14 @@ extern void __exit unregister_nfs_fs(void);
 extern bool nfs_sb_active(struct super_block *sb);
 extern void nfs_sb_deactive(struct super_block *sb);
 
+/* io.c */
+extern void nfs_start_io_read(struct inode *inode);
+extern void nfs_end_io_read(struct inode *inode);
+extern void nfs_start_io_write(struct inode *inode);
+extern void nfs_end_io_write(struct inode *inode);
+extern void nfs_start_io_direct(struct inode *inode);
+extern void nfs_end_io_direct(struct inode *inode);
+
 /* namespace.c */
 #define NFS_PATH_CANONICAL 1
 extern char *nfs_path(char **p, struct dentry *dentry,

commit a5314a74928fa6dbc4503a8c64f43bb5c1c12ac1
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Wed Jun 1 21:42:32 2016 -0400

    NFS: Ensure we reset the write verifier 'committed' value on resend.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 150a8eb0f323..0eb5c924886d 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -499,6 +499,23 @@ int nfs_key_timeout_notify(struct file *filp, struct inode *inode);
 bool nfs_ctx_key_to_expire(struct nfs_open_context *ctx);
 void nfs_pageio_stop_mirroring(struct nfs_pageio_descriptor *pgio);
 
+#ifdef CONFIG_NFS_V4_1
+static inline
+void nfs_clear_pnfs_ds_commit_verifiers(struct pnfs_ds_commit_info *cinfo)
+{
+	int i;
+
+	for (i = 0; i < cinfo->nbuckets; i++)
+		cinfo->buckets[i].direct_verf.committed = NFS_INVALID_STABLE_HOW;
+}
+#else
+static inline
+void nfs_clear_pnfs_ds_commit_verifiers(struct pnfs_ds_commit_info *cinfo)
+{
+}
+#endif
+
+
 #ifdef CONFIG_MIGRATION
 extern int nfs_migrate_page(struct address_space *,
 		struct page *, struct page *, enum migrate_mode);

commit 8fc3c3862728373e0d0f5abccc6afc56c69e0c63
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Wed Jun 1 21:32:24 2016 -0400

    NFS: Fix O_DIRECT verifier problems
    
    We should not be interested in looking at the value of the stable field,
    since that could take any value.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5154fa65a2f2..150a8eb0f323 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -506,6 +506,13 @@ extern int nfs_migrate_page(struct address_space *,
 #define nfs_migrate_page NULL
 #endif
 
+static inline int
+nfs_write_verifier_cmp(const struct nfs_write_verifier *v1,
+		const struct nfs_write_verifier *v2)
+{
+	return memcmp(v1->data, v2->data, sizeof(v1->data));
+}
+
 /* unlink.c */
 extern struct rpc_task *
 nfs_async_rename(struct inode *old_dir, struct inode *new_dir,

commit 5c6e5b60aae4347223f176966455010a5715b863
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Wed Jun 22 14:13:12 2016 -0400

    NFS: Fix an Oops in the pNFS files and flexfiles connection setup to the DS
    
    Chris Worley reports:
     RIP: 0010:[<ffffffffa0245f80>]  [<ffffffffa0245f80>] rpc_new_client+0x2a0/0x2e0 [sunrpc]
     RSP: 0018:ffff880158f6f548  EFLAGS: 00010246
     RAX: 0000000000000000 RBX: ffff880234f8bc00 RCX: 000000000000ea60
     RDX: 0000000000074cc0 RSI: 000000000000ea60 RDI: ffff880234f8bcf0
     RBP: ffff880158f6f588 R08: 000000000001ac80 R09: ffff880237003300
     R10: ffff880201171000 R11: ffffea0000d75200 R12: ffffffffa03afc60
     R13: ffff880230c18800 R14: 0000000000000000 R15: ffff880158f6f680
     FS:  00007f0e32673740(0000) GS:ffff88023fc40000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
     CR2: 0000000000000008 CR3: 0000000234886000 CR4: 00000000001406e0
     Stack:
      ffffffffa047a680 0000000000000000 ffff880158f6f598 ffff880158f6f680
      ffff880158f6f680 ffff880234d11d00 ffff88023357f800 ffff880158f6f7d0
      ffff880158f6f5b8 ffffffffa024660a ffff880158f6f5b8 ffffffffa02492ec
     Call Trace:
      [<ffffffffa024660a>] rpc_create_xprt+0x1a/0xb0 [sunrpc]
      [<ffffffffa02492ec>] ? xprt_create_transport+0x13c/0x240 [sunrpc]
      [<ffffffffa0246766>] rpc_create+0xc6/0x1a0 [sunrpc]
      [<ffffffffa038e695>] nfs_create_rpc_client+0xf5/0x140 [nfs]
      [<ffffffffa038f31a>] nfs_init_client+0x3a/0xd0 [nfs]
      [<ffffffffa038f22f>] nfs_get_client+0x25f/0x310 [nfs]
      [<ffffffffa025cef8>] ? rpc_ntop+0xe8/0x100 [sunrpc]
      [<ffffffffa047512c>] nfs3_set_ds_client+0xcc/0x100 [nfsv3]
      [<ffffffffa041fa10>] nfs4_pnfs_ds_connect+0x120/0x400 [nfsv4]
      [<ffffffffa03d41c7>] nfs4_ff_layout_prepare_ds+0xe7/0x330 [nfs_layout_flexfiles]
      [<ffffffffa03d1b1b>] ff_layout_pg_init_write+0xcb/0x280 [nfs_layout_flexfiles]
      [<ffffffffa03a14dc>] __nfs_pageio_add_request+0x12c/0x490 [nfs]
      [<ffffffffa03a1fa2>] nfs_pageio_add_request+0xc2/0x2a0 [nfs]
      [<ffffffffa03a0365>] ? nfs_pageio_init+0x75/0x120 [nfs]
      [<ffffffffa03a5b50>] nfs_do_writepage+0x120/0x270 [nfs]
      [<ffffffffa03a5d31>] nfs_writepage_locked+0x61/0xc0 [nfs]
      [<ffffffff813d4115>] ? __percpu_counter_add+0x55/0x70
      [<ffffffffa03a6a9f>] nfs_wb_single_page+0xef/0x1c0 [nfs]
      [<ffffffff811ca4a3>] ? __dec_zone_page_state+0x33/0x40
      [<ffffffffa0395b21>] nfs_launder_page+0x41/0x90 [nfs]
      [<ffffffff811baba0>] invalidate_inode_pages2_range+0x340/0x3a0
      [<ffffffff811bac17>] invalidate_inode_pages2+0x17/0x20
      [<ffffffffa039960e>] nfs_release+0x9e/0xb0 [nfs]
      [<ffffffffa0399570>] ? nfs_open+0x60/0x60 [nfs]
      [<ffffffffa0394dad>] nfs_file_release+0x3d/0x60 [nfs]
      [<ffffffff81226e6c>] __fput+0xdc/0x1e0
      [<ffffffff81226fbe>] ____fput+0xe/0x10
      [<ffffffff810bf2e4>] task_work_run+0xc4/0xe0
      [<ffffffff810a4188>] do_exit+0x2e8/0xb30
      [<ffffffff8102471c>] ? do_audit_syscall_entry+0x6c/0x70
      [<ffffffff811464e6>] ? __audit_syscall_exit+0x1e6/0x280
      [<ffffffff810a4a5f>] do_group_exit+0x3f/0xa0
      [<ffffffff810a4ad4>] SyS_exit_group+0x14/0x20
      [<ffffffff8179b76e>] system_call_fastpath+0x12/0x71
    
    Which seems to be due to a call to utsname() when in a task exit context
    in order to determine the hostname to set in rpc_new_client().
    
    In reality, what we want here is not the hostname of the current task, but
    the hostname that was used to set up the metadata server.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5154fa65a2f2..fa88609f85e3 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -66,13 +66,16 @@ struct nfs_clone_mount {
 
 struct nfs_client_initdata {
 	unsigned long init_flags;
-	const char *hostname;
-	const struct sockaddr *addr;
+	const char *hostname;			/* Hostname of the server */
+	const struct sockaddr *addr;		/* Address of the server */
+	const char *nodename;			/* Hostname of the client */
+	const char *ip_addr;			/* IP address of the client */
 	size_t addrlen;
 	struct nfs_subversion *nfs_mod;
 	int proto;
 	u32 minorversion;
 	struct net *net;
+	const struct rpc_timeout *timeparms;
 };
 
 /*
@@ -147,9 +150,8 @@ extern void nfs_umount(const struct nfs_mount_request *info);
 extern const struct rpc_program nfs_program;
 extern void nfs_clients_init(struct net *net);
 extern struct nfs_client *nfs_alloc_client(const struct nfs_client_initdata *);
-int nfs_create_rpc_client(struct nfs_client *, const struct rpc_timeout *, rpc_authflavor_t);
+int nfs_create_rpc_client(struct nfs_client *, const struct nfs_client_initdata *, rpc_authflavor_t);
 struct nfs_client *nfs_get_client(const struct nfs_client_initdata *,
-				  const struct rpc_timeout *, const char *,
 				  rpc_authflavor_t);
 int nfs_probe_fsinfo(struct nfs_server *server, struct nfs_fh *, struct nfs_fattr *);
 void nfs_server_insert_lists(struct nfs_server *);
@@ -338,8 +340,7 @@ nfs4_label_copy(struct nfs4_label *dst, struct nfs4_label *src)
 /* proc.c */
 void nfs_close_context(struct nfs_open_context *ctx, int is_sync);
 extern struct nfs_client *nfs_init_client(struct nfs_client *clp,
-			   const struct rpc_timeout *timeparms,
-			   const char *ip_addr);
+			   const struct nfs_client_initdata *);
 
 /* dir.c */
 extern void nfs_force_use_readdirplus(struct inode *dir);
@@ -521,8 +522,7 @@ extern ssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq);
 /* nfs4proc.c */
 extern void __nfs4_read_done_cb(struct nfs_pgio_header *);
 extern struct nfs_client *nfs4_init_client(struct nfs_client *clp,
-			    const struct rpc_timeout *timeparms,
-			    const char *ip_addr);
+			    const struct nfs_client_initdata *);
 extern int nfs40_walk_client_list(struct nfs_client *clp,
 				struct nfs_client **result,
 				struct rpc_cred *cred);

commit 67911c8f18b595040f5c2df0550c69a7c9397891
Author: Anna Schumaker <Anna.Schumaker@Netapp.com>
Date:   Tue Jan 19 14:37:30 2016 -0500

    NFS: Add nfs_commit_file()
    
    Copy will use this to set up a commit request for a generic range.  I
    don't want to allocate a new pagecache entry for the file, so I needed
    to change parts of the commit path to handle requests with a null
    wb_page.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index f1d1d2c472e9..5154fa65a2f2 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -477,6 +477,7 @@ void nfs_mark_request_commit(struct nfs_page *req,
 			     u32 ds_commit_idx);
 int nfs_write_need_commit(struct nfs_pgio_header *);
 void nfs_writeback_update_inode(struct nfs_pgio_header *hdr);
+int nfs_commit_file(struct file *file, struct nfs_write_verifier *verf);
 int nfs_generic_commit_list(struct inode *inode, struct list_head *head,
 			    int how, struct nfs_commit_info *cinfo);
 void nfs_retry_commit(struct list_head *page_list,

commit 09cbfeaf1a5a67bfb3201e0c83c810cecb2efa5a
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Fri Apr 1 15:29:47 2016 +0300

    mm, fs: get rid of PAGE_CACHE_* and page_cache_{get,release} macros
    
    PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} macros were introduced *long* time
    ago with promise that one day it will be possible to implement page
    cache with bigger chunks than PAGE_SIZE.
    
    This promise never materialized.  And unlikely will.
    
    We have many places where PAGE_CACHE_SIZE assumed to be equal to
    PAGE_SIZE.  And it's constant source of confusion on whether
    PAGE_CACHE_* or PAGE_* constant should be used in a particular case,
    especially on the border between fs and mm.
    
    Global switching to PAGE_CACHE_SIZE != PAGE_SIZE would cause to much
    breakage to be doable.
    
    Let's stop pretending that pages in page cache are special.  They are
    not.
    
    The changes are pretty straight-forward:
    
     - <foo> << (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - <foo> >> (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} -> PAGE_{SIZE,SHIFT,MASK,ALIGN};
    
     - page_cache_get() -> get_page();
    
     - page_cache_release() -> put_page();
    
    This patch contains automated changes generated with coccinelle using
    script below.  For some reason, coccinelle doesn't patch header files.
    I've called spatch for them manually.
    
    The only adjustment after coccinelle is revert of changes to
    PAGE_CAHCE_ALIGN definition: we are going to drop it later.
    
    There are few places in the code where coccinelle didn't reach.  I'll
    fix them manually in a separate patch.  Comments and documentation also
    will be addressed with the separate patch.
    
    virtual patch
    
    @@
    expression E;
    @@
    - E << (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    expression E;
    @@
    - E >> (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    @@
    - PAGE_CACHE_SHIFT
    + PAGE_SHIFT
    
    @@
    @@
    - PAGE_CACHE_SIZE
    + PAGE_SIZE
    
    @@
    @@
    - PAGE_CACHE_MASK
    + PAGE_MASK
    
    @@
    expression E;
    @@
    - PAGE_CACHE_ALIGN(E)
    + PAGE_ALIGN(E)
    
    @@
    expression E;
    @@
    - page_cache_get(E)
    + get_page(E)
    
    @@
    expression E;
    @@
    - page_cache_release(E)
    + put_page(E)
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 565f8135ae1f..f1d1d2c472e9 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -638,11 +638,11 @@ unsigned int nfs_page_length(struct page *page)
 
 	if (i_size > 0) {
 		pgoff_t page_index = page_file_index(page);
-		pgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;
+		pgoff_t end_index = (i_size - 1) >> PAGE_SHIFT;
 		if (page_index < end_index)
-			return PAGE_CACHE_SIZE;
+			return PAGE_SIZE;
 		if (page_index == end_index)
-			return ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;
+			return ((i_size - 1) & ~PAGE_MASK) + 1;
 	}
 	return 0;
 }

commit 95d9f6c3edd60aab1bb163f081262645f8bb8dc0
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Mar 2 17:35:55 2016 +0100

    nfs: remove nfs_inode_dio_wait
    
    Just call inode_dio_wait directly instead of through a pointless wrapper.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index c41c5f5baf03..565f8135ae1f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -515,10 +515,6 @@ extern int nfs_sillyrename(struct inode *dir, struct dentry *dentry);
 /* direct.c */
 void nfs_init_cinfo_from_dreq(struct nfs_commit_info *cinfo,
 			      struct nfs_direct_req *dreq);
-static inline void nfs_inode_dio_wait(struct inode *inode)
-{
-	inode_dio_wait(inode);
-}
 extern ssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq);
 
 /* nfs4proc.c */

commit 4ff79bc7098fab71e5957d48d31d2036c234e506
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Mar 2 17:35:54 2016 +0100

    nfs: remove nfs4_file_fsync
    
    The only difference to nfs_file_fsync is the call to pnfs_sync_inode.  But
    pnfs_sync_inode is just an inline that calls a pNFS layout driver method
    if CONFIG_PNFS is designed, and thus can be called just fine from the core
    NFS module.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 9a547aa3ec8e..c41c5f5baf03 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -358,7 +358,7 @@ int nfs_mknod(struct inode *, struct dentry *, umode_t, dev_t);
 int nfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
 
 /* file.c */
-int nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);
+int nfs_file_fsync(struct file *file, loff_t start, loff_t end, int datasync);
 loff_t nfs_file_llseek(struct file *, loff_t, int);
 ssize_t nfs_file_read(struct kiocb *, struct iov_iter *);
 ssize_t nfs_file_splice_read(struct file *, loff_t *, struct pipe_inode_info *,

commit 6272dcc6beebbc2d8cf4165b628169e878f143e0
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Fri Jan 15 16:54:15 2016 -0500

    NFS: Simplify nfs_request_add_commit_list() arguments
    
    I noticed that all the callers of this function pass cinfo->mds->list as
    an argument in addition to the cinfo structure itself.  Let's get rid of
    the extra argument, since it doesn't seem to be adding anything.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 4e8cc942336c..9a547aa3ec8e 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -484,7 +484,7 @@ void nfs_retry_commit(struct list_head *page_list,
 		      struct nfs_commit_info *cinfo,
 		      u32 ds_commit_idx);
 void nfs_commitdata_release(struct nfs_commit_data *data);
-void nfs_request_add_commit_list(struct nfs_page *req, struct list_head *dst,
+void nfs_request_add_commit_list(struct nfs_page *req,
 				 struct nfs_commit_info *cinfo);
 void nfs_request_add_commit_list_locked(struct nfs_page *req,
 		struct list_head *dst,

commit 210c7c1750fdf769647d1d526c9ea34c412c9eee
Author: Benjamin Coddington <bcodding@redhat.com>
Date:   Wed Jan 6 10:40:18 2016 -0500

    NFS: Use wait_on_atomic_t() for unlock after readahead
    
    The use of wait_on_atomic_t() for waiting on I/O to complete before
    unlocking allows us to git rid of the NFS_IO_INPROGRESS flag, and thus the
    nfs_iocounter's flags member, and finally the nfs_iocounter altogether.
    The count of I/O is moved to the lock context, and the counter
    increment/decrement functions become simple enough to open-code.
    
    Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
    [Trond: Fix up conflict with existing function nfs_wait_atomic_killable()]
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index ee81792d2886..4e8cc942336c 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -238,7 +238,7 @@ extern void nfs_pgheader_init(struct nfs_pageio_descriptor *desc,
 			      struct nfs_pgio_header *hdr,
 			      void (*release)(struct nfs_pgio_header *hdr));
 void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos);
-int nfs_iocounter_wait(struct nfs_io_counter *c);
+int nfs_iocounter_wait(struct nfs_lock_context *l_ctx);
 
 extern const struct nfs_pageio_ops nfs_pgio_rw_ops;
 struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *);
@@ -252,12 +252,6 @@ void nfs_free_request(struct nfs_page *req);
 struct nfs_pgio_mirror *
 nfs_pgio_current_mirror(struct nfs_pageio_descriptor *desc);
 
-static inline void nfs_iocounter_init(struct nfs_io_counter *c)
-{
-	c->flags = 0;
-	atomic_set(&c->io_count, 0);
-}
-
 static inline bool nfs_pgio_has_mirroring(struct nfs_pageio_descriptor *desc)
 {
 	WARN_ON_ONCE(desc->pg_mirror_count < 1);
@@ -386,6 +380,7 @@ extern void nfs_clear_inode(struct inode *);
 extern void nfs_evict_inode(struct inode *);
 void nfs_zap_acl_cache(struct inode *inode);
 extern int nfs_wait_bit_killable(struct wait_bit_key *key, int mode);
+extern int nfs_wait_atomic_killable(atomic_t *p);
 
 /* super.c */
 extern const struct super_operations nfs_sops;

commit 942e3d72a62dcfe5bf1569b179174718bbbcfbc3
Merge: 58baac0ac7cc 506c0d68269e
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Mon Jan 4 13:19:55 2016 -0500

    Merge branch 'pnfs_generic'
    
    * pnfs_generic:
      NFSv4.1/pNFS: Cleanup constify struct pnfs_layout_range arguments
      NFSv4.1/pnfs: Cleanup copying of pnfs_layout_range structures
      NFSv4.1/pNFS: Cleanup pnfs_mark_matching_lsegs_invalid()
      NFSv4.1/pNFS: Fix a race in initiate_file_draining()
      NFSv4.1/pNFS: pnfs_error_mark_layout_for_return() must always return layout
      NFSv4.1/pNFS: pnfs_mark_matching_lsegs_return() should set the iomode
      NFSv4.1/pNFS: Use nfs4_stateid_copy for copying stateids
      NFSv4.1/pNFS: Don't pass stateids by value to pnfs_send_layoutreturn()
      NFS: Relax requirements in nfs_flush_incompatible
      NFSv4.1/pNFS: Don't queue up a new commit if the layout segment is invalid
      NFS: Allow multiple commit requests in flight per file
      NFS/pNFS: Fix up pNFS write reschedule layering violations and bugs
      NFSv4: List stateid information in the callback tracepoints
      NFSv4.1/pNFS: Don't return NFS4ERR_DELAY unnecessarily in CB_LAYOUTRECALL
      NFSv4.1/pNFS: Ensure we enforce RFC5661 Section 12.5.5.2.1
      pNFS: If we have to delay the layout callback, mark the layout for return
      NFSv4.1/pNFS: Add a helper to mark the layout as returned
      pNFS: Ensure nfs4_layoutget_prepare returns the correct error

commit 138a2935dc9783b131d9647c3bddb22ae5c84d77
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Oct 1 17:17:06 2015 -0400

    NFS: Relax requirements in nfs_flush_incompatible
    
    If two processes share the same credentials and NFSv4 open stateid, then
    allow them both to dirty the same page, even if their nfs_open_context
    differs.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 99a2919047e9..870e2ba7ba49 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -264,6 +264,12 @@ static inline bool nfs_pgio_has_mirroring(struct nfs_pageio_descriptor *desc)
 	return desc->pg_mirror_count > 1;
 }
 
+static inline bool nfs_match_open_context(const struct nfs_open_context *ctx1,
+		const struct nfs_open_context *ctx2)
+{
+	return ctx1->cred == ctx2->cred && ctx1->state == ctx2->state;
+}
+
 /* nfs2xdr.c */
 extern struct rpc_procinfo nfs_procedures[];
 extern int nfs2_decode_dirent(struct xdr_stream *,

commit dc602dd706cb64036132a7903ead1c67d9a7bcb9
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Dec 31 11:44:06 2015 -0500

    NFS/pNFS: Fix up pNFS write reschedule layering violations and bugs
    
    The flexfiles layout in particular, seems to want to poke around in the
    O_DIRECT flags when retransmitting.
    This patch sets up an interface to allow it to call back into O_DIRECT
    to handle retransmission correctly. It also fixes a potential bug whereby
    we could change the behaviour of O_DIRECT if an error is already pending.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 313d55402238..99a2919047e9 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -519,7 +519,6 @@ static inline void nfs_inode_dio_wait(struct inode *inode)
 	inode_dio_wait(inode);
 }
 extern ssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq);
-extern void nfs_direct_set_resched_writes(struct nfs_direct_req *dreq);
 
 /* nfs4proc.c */
 extern void __nfs4_read_done_cb(struct nfs_pgio_header *);

commit 0bcbf039f6b2bcefe4f5dada76079080edf9ecd0
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Sat Dec 5 15:57:31 2015 +0800

    nfs: handle request add failure properly
    
    When we fail to queue a read page to IO descriptor,
    we need to clean it up otherwise it is hanging around
    preventing nfs module from being removed.
    
    When we fail to queue a write page to IO descriptor,
    we need to clean it up and also save the failure status
    to open context. Then at file close, we can try to write
    pages back again and drop the page if it fails to writeback
    in .launder_page, which will be done in the next patch.
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 313d55402238..68f773dc226e 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -711,3 +711,17 @@ static inline u32 nfs_stateid_hash(nfs4_stateid *stateid)
 	return 0;
 }
 #endif
+
+static inline bool nfs_error_is_fatal(int err)
+{
+	switch (err) {
+	case -ERESTARTSYS:
+	case -EIO:
+	case -ENOSPC:
+	case -EROFS:
+	case -E2BIG:
+		return true;
+	default:
+		return false;
+	}
+}

commit 48c9579a1afe4315be4576ec4c0b24c2715da0e0
Author: Olga Kornievskaia <kolga@netapp.com>
Date:   Tue Nov 24 13:29:41 2015 -0500

    Adding stateid information to tracepoints
    
    Operations to which stateid information is added:
    close, delegreturn, open, read, setattr, layoutget, layoutcommit, test_stateid,
    write, lock, locku, lockt
    
    Format is "stateid=<seqid>:<crc32 hash stateid.other>", also "openstateid=",
    "layoutstateid=", and "lockstateid=" for open_file, layoutget, set_lock
    tracepoints.
    
    New function is added to internal.h, nfs_stateid_hash(), to compute the hash
    
    trace_nfs4_setattr() is moved from nfs4_do_setattr() to _nfs4_do_setattr()
    to get access to stateid.
    
    trace_nfs4_setattr and trace_nfs4_delegreturn are changed from INODE_EVENT
    to new event type, INODE_STATEID_EVENT which is same as INODE_EVENT but adds
    stateid information
    
    for locking tracepoints, moved trace_nfs4_set_lock() into _nfs4_do_setlk()
    to get access to stateid information, and removed trace_nfs4_lock_reclaim(),
    trace_nfs4_lock_expired() as they call into _nfs4_do_setlk() and both were
    previously same LOCK_EVENT type.
    
    Signed-off-by: Olga Kornievskaia <kolga@netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 9dea85f7f918..313d55402238 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -696,9 +696,18 @@ static inline u32 nfs_fhandle_hash(const struct nfs_fh *fh)
 {
 	return ~crc32_le(0xFFFFFFFF, &fh->data[0], fh->size);
 }
+static inline u32 nfs_stateid_hash(const nfs4_stateid *stateid)
+{
+	return ~crc32_le(0xFFFFFFFF, &stateid->other[0],
+				NFS4_STATEID_OTHER_SIZE);
+}
 #else
 static inline u32 nfs_fhandle_hash(const struct nfs_fh *fh)
 {
 	return 0;
 }
+static inline u32 nfs_stateid_hash(nfs4_stateid *stateid)
+{
+	return 0;
+}
 #endif

commit dfd01f026058a59a513f8a365b439a0681b803af
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Sun Dec 13 22:11:16 2015 +0100

    sched/wait: Fix the signal handling fix
    
    Jan Stancek reported that I wrecked things for him by fixing things for
    Vladimir :/
    
    His report was due to an UNINTERRUPTIBLE wait getting -EINTR, which
    should not be possible, however my previous patch made this possible by
    unconditionally checking signal_pending().
    
    We cannot use current->state as was done previously, because the
    instruction after the store to that variable it can be changed.  We must
    instead pass the initial state along and use that.
    
    Fixes: 68985633bccb ("sched/wait: Fix signal handling in bit wait helpers")
    Reported-by: Jan Stancek <jstancek@redhat.com>
    Reported-by: Chris Mason <clm@fb.com>
    Tested-by: Jan Stancek <jstancek@redhat.com>
    Tested-by: Vladimir Murzin <vladimir.murzin@arm.com>
    Tested-by: Chris Mason <clm@fb.com>
    Reviewed-by: Paul Turner <pjt@google.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: tglx@linutronix.de
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: hpa@zytor.com
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 56cfde26fb9c..9dea85f7f918 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -379,7 +379,7 @@ extern int nfs_drop_inode(struct inode *);
 extern void nfs_clear_inode(struct inode *);
 extern void nfs_evict_inode(struct inode *);
 void nfs_zap_acl_cache(struct inode *inode);
-extern int nfs_wait_bit_killable(struct wait_bit_key *key);
+extern int nfs_wait_bit_killable(struct wait_bit_key *key, int mode);
 
 /* super.c */
 extern const struct super_operations nfs_sops;

commit 5445b1fbd123420bffed5e629a420aa2a16bf849
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sat Sep 5 19:06:58 2015 -0400

    NFSv4: Respect the server imposed limit on how many changes we may cache
    
    The NFSv4 delegation spec allows the server to tell a client to limit how
    much data it cache after the file is closed. In return, the server
    guarantees enough free space to avoid ENOSPC situations, etc.
    Prior to this patch, we assumed we could always cache aggressively after
    close. Unfortunately, this causes problems with servers that set the
    limit to 0 and therefore do not offer any ENOSPC guarantees.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 9ab3b1c21bb4..56cfde26fb9c 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -360,7 +360,6 @@ int nfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *)
 /* file.c */
 int nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);
 loff_t nfs_file_llseek(struct file *, loff_t, int);
-int nfs_file_flush(struct file *, fl_owner_t);
 ssize_t nfs_file_read(struct kiocb *, struct iov_iter *);
 ssize_t nfs_file_splice_read(struct file *, loff_t *, struct pipe_inode_info *,
 			     size_t, unsigned int);

commit d8efa4e62505f5113e363572b5438b7be0d08b12
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Mon Jul 13 14:01:28 2015 -0400

    NFS: Use RPC functions for matching sockaddrs
    
    They already exist and do the exact same thing.  Let's save ourselves
    several lines of code!
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 1dad18105ed0..9ab3b1c21bb4 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -219,10 +219,6 @@ static inline void nfs_fs_proc_exit(void)
 }
 #endif
 
-#ifdef CONFIG_NFS_V4_1
-int nfs_sockaddr_match_ipaddr(const struct sockaddr *, const struct sockaddr *);
-#endif
-
 /* callback_xdr.c */
 extern struct svc_version nfs4_callback_version1;
 extern struct svc_version nfs4_callback_version4;

commit 86d80f973434de24d8a807a92cd59d5ced7bd519
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Fri Jul 31 16:24:30 2015 -0400

    NFSv4.1/pnfs: Fix atomicity of commit list updates
    
    pnfs_layout_mark_request_commit() needs to ensure that it adds the
    request to the commit list atomically with all the other updates
    in order to prevent corruption to buckets[ds_commit_idx].wlseg
    due to races with pnfs_generic_clear_request_commit().
    
    Fixes: 338d00cfef07d ("pnfs: Refactor the *_layout_mark_request_commit...")
    Cc: stable@vger.kernel.org # v4.0+
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 9b372b845f6a..1dad18105ed0 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -490,6 +490,9 @@ void nfs_retry_commit(struct list_head *page_list,
 void nfs_commitdata_release(struct nfs_commit_data *data);
 void nfs_request_add_commit_list(struct nfs_page *req, struct list_head *dst,
 				 struct nfs_commit_info *cinfo);
+void nfs_request_add_commit_list_locked(struct nfs_page *req,
+		struct list_head *dst,
+		struct nfs_commit_info *cinfo);
 void nfs_request_remove_commit_list(struct nfs_page *req,
 				    struct nfs_commit_info *cinfo);
 void nfs_init_cinfo(struct nfs_commit_info *cinfo,
@@ -623,13 +626,15 @@ void nfs_super_set_maxbytes(struct super_block *sb, __u64 maxfilesize)
  * Record the page as unstable and mark its inode as dirty.
  */
 static inline
-void nfs_mark_page_unstable(struct page *page)
+void nfs_mark_page_unstable(struct page *page, struct nfs_commit_info *cinfo)
 {
-	struct inode *inode = page_file_mapping(page)->host;
+	if (!cinfo->dreq) {
+		struct inode *inode = page_file_mapping(page)->host;
 
-	inc_zone_page_state(page, NR_UNSTABLE_NFS);
-	inc_wb_stat(&inode_to_bdi(inode)->wb, WB_RECLAIMABLE);
-	 __mark_inode_dirty(inode, I_DIRTY_DATASYNC);
+		inc_zone_page_state(page, NR_UNSTABLE_NFS);
+		inc_wb_stat(&inode_to_bdi(inode)->wb, WB_RECLAIMABLE);
+		__mark_inode_dirty(inode, I_DIRTY_DATASYNC);
+	}
 }
 
 /*

commit d8132e08d25a47e2d5156aa2268cd1cd9b0d6c0d
Merge: 2ee6b0007024 a49c269111a5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 28 09:37:44 2015 -0700

    Merge tag 'nfs-for-4.2-2' of git://git.linux-nfs.org/projects/trondmy/linux-nfs
    
    Pull NFS client bugfixes from Trond Myklebust:
     "Highlights include:
    
      Stable patches:
       - Fix a situation where the client uses the wrong (zero) stateid.
       - Fix a memory leak in nfs_do_recoalesce
    
      Bugfixes:
       - Plug a memory leak when ->prepare_layoutcommit fails
       - Fix an Oops in the NFSv4 open code
       - Fix a backchannel deadlock
       - Fix a livelock in sunrpc when sendmsg fails due to low memory
         availability
       - Don't revalidate the mapping if both size and change attr are up to
         date
       - Ensure we don't miss a file extension when doing pNFS
       - Several fixes to handle NFSv4.1 sequence operation status bits
         correctly
       - Several pNFS layout return bugfixes"
    
    * tag 'nfs-for-4.2-2' of git://git.linux-nfs.org/projects/trondmy/linux-nfs: (28 commits)
      nfs: Fix an oops caused by using other thread's stack space in ASYNC mode
      nfs: plug memory leak when ->prepare_layoutcommit fails
      SUNRPC: Report TCP errors to the caller
      sunrpc: translate -EAGAIN to -ENOBUFS when socket is writable.
      NFSv4.2: handle NFS-specific llseek errors
      NFS: Don't clear desc->pg_moreio in nfs_do_recoalesce()
      NFS: Fix a memory leak in nfs_do_recoalesce
      NFS: nfs_mark_for_revalidate should always set NFS_INO_REVAL_PAGECACHE
      NFS: Remove the "NFS_CAP_CHANGE_ATTR" capability
      NFS: Set NFS_INO_REVAL_PAGECACHE if the change attribute is uninitialised
      NFS: Don't revalidate the mapping if both size and change attr are up to date
      NFSv4/pnfs: Ensure we don't miss a file extension
      NFSv4: We must set NFS_OPEN_STATE flag in nfs_resync_open_stateid_locked
      SUNRPC: xprt_complete_bc_request must also decrement the free slot count
      SUNRPC: Fix a backchannel deadlock
      pNFS: Don't throw out valid layout segments
      pNFS: pnfs_roc_drain() fix a race with open
      pNFS: Fix races between return-on-close and layoutreturn.
      pNFS: pnfs_roc_drain should return 'true' when sleeping
      pNFS: Layoutreturn must invalidate all existing layout segments.
      ...

commit a49c269111a5b3c1fd2a98f36fa27423b94549f8
Author: Kinglong Mee <kinglongmee@gmail.com>
Date:   Mon Jul 27 15:31:38 2015 +0800

    nfs: Fix an oops caused by using other thread's stack space in ASYNC mode
    
    An oops caused by using other thread's stack space in sunrpc ASYNC sending thread.
    
    [ 9839.007187] ------------[ cut here ]------------
    [ 9839.007923] kernel BUG at fs/nfs/nfs4xdr.c:910!
    [ 9839.008069] invalid opcode: 0000 [#1] SMP
    [ 9839.008069] Modules linked in: blocklayoutdriver rpcsec_gss_krb5 nfsv4 dns_resolver nfs fscache snd_hda_codec_generic snd_hda_intel snd_hda_controller snd_hda_codec snd_hwdep snd_seq snd_seq_device snd_pcm joydev iosf_mbi crct10dif_pclmul snd_timer crc32_pclmul crc32c_intel ghash_clmulni_intel snd soundcore ppdev pvpanic parport_pc i2c_piix4 serio_raw virtio_balloon parport acpi_cpufreq nfsd nfs_acl lockd grace auth_rpcgss sunrpc qxl drm_kms_helper virtio_net virtio_console virtio_blk ttm drm virtio_pci virtio_ring virtio ata_generic pata_acpi
    [ 9839.008069] CPU: 0 PID: 308 Comm: kworker/0:1H Not tainted 4.0.0-0.rc4.git1.3.fc23.x86_64 #1
    [ 9839.008069] Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
    [ 9839.008069] Workqueue: rpciod rpc_async_schedule [sunrpc]
    [ 9839.008069] task: ffff8800d8b4d8e0 ti: ffff880036678000 task.ti: ffff880036678000
    [ 9839.008069] RIP: 0010:[<ffffffffa0339cc9>]  [<ffffffffa0339cc9>] reserve_space.part.73+0x9/0x10 [nfsv4]
    [ 9839.008069] RSP: 0018:ffff88003667ba58  EFLAGS: 00010246
    [ 9839.008069] RAX: 0000000000000000 RBX: 000000001fc15e18 RCX: ffff8800c0193800
    [ 9839.008069] RDX: ffff8800e4ae3f24 RSI: 000000001fc15e2c RDI: ffff88003667bcd0
    [ 9839.008069] RBP: ffff88003667ba58 R08: ffff8800d9173008 R09: 0000000000000003
    [ 9839.008069] R10: ffff88003667bcd0 R11: 000000000000000c R12: 0000000000010000
    [ 9839.008069] R13: ffff8800d9173350 R14: 0000000000000000 R15: ffff8800c0067b98
    [ 9839.008069] FS:  0000000000000000(0000) GS:ffff88011fc00000(0000) knlGS:0000000000000000
    [ 9839.008069] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [ 9839.008069] CR2: 00007f988c9c8bb0 CR3: 00000000d99b6000 CR4: 00000000000407f0
    [ 9839.008069] Stack:
    [ 9839.008069]  ffff88003667bbc8 ffffffffa03412c5 00000000c6c55680 ffff880000000003
    [ 9839.008069]  0000000000000088 00000010c6c55680 0001000000000002 ffffffff816e87e9
    [ 9839.008069]  0000000000000000 00000000477290e2 ffff88003667bab8 ffffffff81327ba3
    [ 9839.008069] Call Trace:
    [ 9839.008069]  [<ffffffffa03412c5>] encode_attrs+0x435/0x530 [nfsv4]
    [ 9839.008069]  [<ffffffff816e87e9>] ? inet_sendmsg+0x69/0xb0
    [ 9839.008069]  [<ffffffff81327ba3>] ? selinux_socket_sendmsg+0x23/0x30
    [ 9839.008069]  [<ffffffff8164c1df>] ? do_sock_sendmsg+0x9f/0xc0
    [ 9839.008069]  [<ffffffff8164c278>] ? kernel_sendmsg+0x58/0x70
    [ 9839.008069]  [<ffffffffa011acc0>] ? xdr_reserve_space+0x20/0x170 [sunrpc]
    [ 9839.008069]  [<ffffffffa011acc0>] ? xdr_reserve_space+0x20/0x170 [sunrpc]
    [ 9839.008069]  [<ffffffffa0341b40>] ? nfs4_xdr_enc_open_noattr+0x130/0x130 [nfsv4]
    [ 9839.008069]  [<ffffffffa03419a5>] encode_open+0x2d5/0x340 [nfsv4]
    [ 9839.008069]  [<ffffffffa0341b40>] ? nfs4_xdr_enc_open_noattr+0x130/0x130 [nfsv4]
    [ 9839.008069]  [<ffffffffa011ab89>] ? xdr_encode_opaque+0x19/0x20 [sunrpc]
    [ 9839.008069]  [<ffffffffa0339cfb>] ? encode_string+0x2b/0x40 [nfsv4]
    [ 9839.008069]  [<ffffffffa0341bf3>] nfs4_xdr_enc_open+0xb3/0x140 [nfsv4]
    [ 9839.008069]  [<ffffffffa0110a4c>] rpcauth_wrap_req+0xac/0xf0 [sunrpc]
    [ 9839.008069]  [<ffffffffa01017db>] call_transmit+0x18b/0x2d0 [sunrpc]
    [ 9839.008069]  [<ffffffffa0101650>] ? call_decode+0x860/0x860 [sunrpc]
    [ 9839.008069]  [<ffffffffa0101650>] ? call_decode+0x860/0x860 [sunrpc]
    [ 9839.008069]  [<ffffffffa010caa0>] __rpc_execute+0x90/0x460 [sunrpc]
    [ 9839.008069]  [<ffffffffa010ce85>] rpc_async_schedule+0x15/0x20 [sunrpc]
    [ 9839.008069]  [<ffffffff810b452b>] process_one_work+0x1bb/0x410
    [ 9839.008069]  [<ffffffff810b47d3>] worker_thread+0x53/0x470
    [ 9839.008069]  [<ffffffff810b4780>] ? process_one_work+0x410/0x410
    [ 9839.008069]  [<ffffffff810b4780>] ? process_one_work+0x410/0x410
    [ 9839.008069]  [<ffffffff810ba7b8>] kthread+0xd8/0xf0
    [ 9839.008069]  [<ffffffff810ba6e0>] ? kthread_worker_fn+0x180/0x180
    [ 9839.008069]  [<ffffffff81786418>] ret_from_fork+0x58/0x90
    [ 9839.008069]  [<ffffffff810ba6e0>] ? kthread_worker_fn+0x180/0x180
    [ 9839.008069] Code: 00 00 48 c7 c7 21 fa 37 a0 e8 94 1c d6 e0 c6 05 d2 17 05 00 01 8b 03 eb d7 66 0f 1f 84 00 00 00 00 00 66 66 66 66 90 55 48 89 e5 <0f> 0b 0f 1f 44 00 00 66 66 66 66 90 55 48 89 e5 41 54 53 89 f3
    [ 9839.008069] RIP  [<ffffffffa0339cc9>] reserve_space.part.73+0x9/0x10 [nfsv4]
    [ 9839.008069]  RSP <ffff88003667ba58>
    [ 9839.071114] ---[ end trace cc14c03adb522e94 ]---
    
    Signed-off-by: Kinglong Mee <kinglongmee@gmail.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 9e6475bc5ba2..797013822765 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -296,6 +296,22 @@ extern struct rpc_procinfo nfs4_procedures[];
 
 #ifdef CONFIG_NFS_V4_SECURITY_LABEL
 extern struct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags);
+static inline struct nfs4_label *
+nfs4_label_copy(struct nfs4_label *dst, struct nfs4_label *src)
+{
+	if (!dst || !src)
+		return NULL;
+
+	if (src->len > NFS4_MAXLABELLEN)
+		return NULL;
+
+	dst->lfs = src->lfs;
+	dst->pi = src->pi;
+	dst->len = src->len;
+	memcpy(dst->label, src->label, src->len);
+
+	return dst;
+}
 static inline void nfs4_label_free(struct nfs4_label *label)
 {
 	if (label) {
@@ -316,6 +332,11 @@ static inline void nfs4_label_free(void *label) {}
 static inline void nfs_zap_label_cache_locked(struct nfs_inode *nfsi)
 {
 }
+static inline struct nfs4_label *
+nfs4_label_copy(struct nfs4_label *dst, struct nfs4_label *src)
+{
+	return NULL;
+}
 #endif /* CONFIG_NFS_V4_SECURITY_LABEL */
 
 /* proc.c */

commit 93f78d882865cb90020d0f80a9523c99cf46924c
Author: Tejun Heo <tj@kernel.org>
Date:   Fri May 22 17:13:27 2015 -0400

    writeback: move backing_dev_info->bdi_stat[] into bdi_writeback
    
    Currently, a bdi (backing_dev_info) embeds single wb (bdi_writeback)
    and the role of the separation is unclear.  For cgroup support for
    writeback IOs, a bdi will be updated to host multiple wb's where each
    wb serves writeback IOs of a different cgroup on the bdi.  To achieve
    that, a wb should carry all states necessary for servicing writeback
    IOs for a cgroup independently.
    
    This patch moves bdi->bdi_stat[] into wb.
    
    * enum bdi_stat_item is renamed to wb_stat_item and the prefix of all
      enums is changed from BDI_ to WB_.
    
    * BDI_STAT_BATCH() -> WB_STAT_BATCH()
    
    * [__]{add|inc|dec|sum}_wb_stat(bdi, ...) -> [__]{add|inc}_wb_stat(wb, ...)
    
    * bdi_stat[_error]() -> wb_stat[_error]()
    
    * bdi_writeout_inc() -> wb_writeout_inc()
    
    * stat init is moved to bdi_wb_init() and bdi_wb_exit() is added and
      frees stat.
    
    * As there's still only one bdi_writeback per backing_dev_info, all
      uses of bdi->stat[] are mechanically replaced with bdi->wb.stat[]
      introducing no behavior changes.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Wu Fengguang <fengguang.wu@intel.com>
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 9e6475bc5ba2..7e3c4604bea8 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -607,7 +607,7 @@ void nfs_mark_page_unstable(struct page *page)
 	struct inode *inode = page_file_mapping(page)->host;
 
 	inc_zone_page_state(page, NR_UNSTABLE_NFS);
-	inc_bdi_stat(inode_to_bdi(inode), BDI_RECLAIMABLE);
+	inc_wb_stat(&inode_to_bdi(inode)->wb, WB_RECLAIMABLE);
 	 __mark_inode_dirty(inode, I_DIRTY_DATASYNC);
 }
 

commit a08a8cd375db9769588257e7782f6b6b68561b88
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Feb 26 17:36:09 2015 -0500

    NFS: Add attribute update barriers to NFS writebacks
    
    Ensure that other operations that race with our write RPC calls
    cannot revert the file size updates that were made on the server.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Tested-by: Chuck Lever <chuck.lever@oracle.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index b802fb3a2d99..9e6475bc5ba2 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -459,6 +459,7 @@ void nfs_mark_request_commit(struct nfs_page *req,
 			     struct nfs_commit_info *cinfo,
 			     u32 ds_commit_idx);
 int nfs_write_need_commit(struct nfs_pgio_header *);
+void nfs_writeback_update_inode(struct nfs_pgio_header *hdr);
 int nfs_generic_commit_list(struct inode *inode, struct list_head *head,
 			    int how, struct nfs_commit_info *cinfo);
 void nfs_retry_commit(struct list_head *page_list,

commit d15bc38df607c893c36f4962dca0f57174c6a5c9
Author: Tom Haynes <thomas.haynes@primarydata.com>
Date:   Fri Feb 13 13:19:53 2015 -0800

    nfs: Provide and use helper functions for marking a page as unstable
    
    Signed-off-by: Tom Haynes <loghyr@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 212b8c883d22..b802fb3a2d99 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -597,6 +597,19 @@ void nfs_super_set_maxbytes(struct super_block *sb, __u64 maxfilesize)
 		sb->s_maxbytes = MAX_LFS_FILESIZE;
 }
 
+/*
+ * Record the page as unstable and mark its inode as dirty.
+ */
+static inline
+void nfs_mark_page_unstable(struct page *page)
+{
+	struct inode *inode = page_file_mapping(page)->host;
+
+	inc_zone_page_state(page, NR_UNSTABLE_NFS);
+	inc_bdi_stat(inode_to_bdi(inode), BDI_RECLAIMABLE);
+	 __mark_inode_dirty(inode, I_DIRTY_DATASYNC);
+}
+
 /*
  * Determine the number of bytes of data the page contains
  */

commit 6bec0035286119eefc32a5b1102127e6a4032cb2
Merge: 5d8e7fb69165 15d0f5ea348b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 12 13:50:21 2015 -0800

    Merge branch 'for-3.20/bdi' of git://git.kernel.dk/linux-block
    
    Pull backing device changes from Jens Axboe:
     "This contains a cleanup of how the backing device is handled, in
      preparation for a rework of the life time rules.  In this part, the
      most important change is to split the unrelated nommu mmap flags from
      it, but also removing a backing_dev_info pointer from the
      address_space (and inode), and a cleanup of other various minor bits.
    
      Christoph did all the work here, I just fixed an oops with pages that
      have a swap backing.  Arnd fixed a missing export, and Oleg killed the
      lustre backing_dev_info from staging.  Last patch was from Al,
      unexporting parts that are now no longer needed outside"
    
    * 'for-3.20/bdi' of git://git.kernel.dk/linux-block:
      Make super_blocks and sb_lock static
      mtd: export new mtd_mmap_capabilities
      fs: make inode_to_bdi() handle NULL inode
      staging/lustre/llite: get rid of backing_dev_info
      fs: remove default_backing_dev_info
      fs: don't reassign dirty inodes to default_backing_dev_info
      nfs: don't call bdi_unregister
      ceph: remove call to bdi_unregister
      fs: remove mapping->backing_dev_info
      fs: export inode_to_bdi and use it in favor of mapping->backing_dev_info
      nilfs2: set up s_bdi like the generic mount_bdev code
      block_dev: get bdev inode bdi directly from the block device
      block_dev: only write bdev inode on close
      fs: introduce f_op->mmap_capabilities for nommu mmap support
      fs: kill BDI_CAP_SWAP_BACKED
      fs: deduplicate noop_backing_dev_info

commit ea7c38fef0b774a5dc16fb0ca5935f0ae8568176
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Feb 5 15:13:24 2015 -0500

    NFSv4: Ensure we reference the inode for return-on-close in delegreturn
    
    If we have to do a return-on-close in the delegreturn code, then
    we must ensure that the inode and super block remain referenced.
    
    Cc: Peng Tao <tao.peng@primarydata.com>
    Cc: stable@vger.kernel.org # 3.17.x
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Reviewed-by: Peng Tao <tao.peng@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index a98cf2006179..21469e6e3834 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -391,7 +391,7 @@ extern struct rpc_stat nfs_rpcstat;
 
 extern int __init register_nfs_fs(void);
 extern void __exit unregister_nfs_fs(void);
-extern void nfs_sb_active(struct super_block *sb);
+extern bool nfs_sb_active(struct super_block *sb);
 extern void nfs_sb_deactive(struct super_block *sb);
 
 /* namespace.c */
@@ -514,6 +514,26 @@ extern int nfs41_walk_client_list(struct nfs_client *clp,
 				struct nfs_client **result,
 				struct rpc_cred *cred);
 
+static inline struct inode *nfs_igrab_and_active(struct inode *inode)
+{
+	inode = igrab(inode);
+	if (inode != NULL && !nfs_sb_active(inode->i_sb)) {
+		iput(inode);
+		inode = NULL;
+	}
+	return inode;
+}
+
+static inline void nfs_iput_and_deactive(struct inode *inode)
+{
+	if (inode != NULL) {
+		struct super_block *sb = inode->i_sb;
+
+		iput(inode);
+		nfs_sb_deactive(sb);
+	}
+}
+
 /*
  * Determine the device name as a string
  */

commit e2c63e091e29786a34ecf42c169e627a3d1d96d7
Merge: cc3ea893cbb3 7c13789e3e6c
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Feb 3 16:01:27 2015 -0500

    Merge branch 'flexfiles'
    
    * flexfiles: (53 commits)
      pnfs: lookup new lseg at lseg boundary
      nfs41: .init_read and .init_write can be called with valid pg_lseg
      pnfs: Update documentation on the Layout Drivers
      pnfs/flexfiles: Add the FlexFile Layout Driver
      nfs: count DIO good bytes correctly with mirroring
      nfs41: wait for LAYOUTRETURN before retrying LAYOUTGET
      nfs: add a helper to set NFS_ODIRECT_RESCHED_WRITES to direct writes
      nfs41: add NFS_LAYOUT_RETRY_LAYOUTGET to layout header flags
      nfs/flexfiles: send layoutreturn before freeing lseg
      nfs41: introduce NFS_LAYOUT_RETURN_BEFORE_CLOSE
      nfs41: allow async version layoutreturn
      nfs41: add range to layoutreturn args
      pnfs: allow LD to ask to resend read through pnfs
      nfs: add nfs_pgio_current_mirror helper
      nfs: only reset desc->pg_mirror_idx when mirroring is supported
      nfs41: add a debug warning if we destroy an unempty layout
      pnfs: fail comparison when bucket verifier not set
      nfs: mirroring support for direct io
      nfs: add mirroring support to pgio layer
      pnfs: pass ds_commit_idx through the commit path
      ...
    
    Conflicts:
            fs/nfs/pnfs.c
            fs/nfs/pnfs.h

commit 012fa16dca0da6c487dd066829ff0b0954925fe6
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Mon Dec 1 08:22:21 2014 +0800

    nfs: add a helper to set NFS_ODIRECT_RESCHED_WRITES to direct writes
    
    To allow pnfs LD to ask direct writes to be resend.
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index ffe4b7ac9e6b..44e84960a26f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -502,6 +502,7 @@ static inline void nfs_inode_dio_wait(struct inode *inode)
 	inode_dio_wait(inode);
 }
 extern ssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq);
+extern void nfs_direct_set_resched_writes(struct nfs_direct_req *dreq);
 
 /* nfs4proc.c */
 extern void __nfs4_read_done_cb(struct nfs_pgio_header *);

commit 48d635f14a544c2b3ca870d2c7349b41160496d2
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Mon Nov 10 08:35:35 2014 +0800

    nfs: add nfs_pgio_current_mirror helper
    
    Let it return current nfs_pgio_mirror in use depending on pg_mirror_count.
    For read, we always use pg_mirrors[0], so this effectively gives us freedom
    to use pg_mirror_idx to track the actual mirror to read from through out the
    IO stack.
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Tom Haynes <loghyr@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5be06bcafa2f..ffe4b7ac9e6b 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -255,6 +255,8 @@ int nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,
 		      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,
 		      const struct rpc_call_ops *call_ops, int how, int flags);
 void nfs_free_request(struct nfs_page *req);
+struct nfs_pgio_mirror *
+nfs_pgio_current_mirror(struct nfs_pageio_descriptor *desc);
 
 static inline void nfs_iocounter_init(struct nfs_io_counter *c)
 {

commit 47af81f29556a45493e5c87289c3c16ce911096c
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Mon Nov 10 08:35:34 2014 +0800

    nfs: only reset desc->pg_mirror_idx when mirroring is supported
    
    so that we don't reset desc->pg_mirror_idx for read unnecessarily.
    Remove WARN_ON_ONCE from __nfs_pageio_add_request to allow LD to
    set pg_mirror_idx for read where pg_mirror_count is always 1.
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Tom Haynes <loghyr@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index ef1c703e487b..5be06bcafa2f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -6,6 +6,7 @@
 #include <linux/mount.h>
 #include <linux/security.h>
 #include <linux/crc32.h>
+#include <linux/nfs_page.h>
 
 #define NFS_MS_MASK (MS_RDONLY|MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_SYNCHRONOUS)
 
@@ -261,6 +262,12 @@ static inline void nfs_iocounter_init(struct nfs_io_counter *c)
 	atomic_set(&c->io_count, 0);
 }
 
+static inline bool nfs_pgio_has_mirroring(struct nfs_pageio_descriptor *desc)
+{
+	WARN_ON_ONCE(desc->pg_mirror_count < 1);
+	return desc->pg_mirror_count > 1;
+}
+
 /* nfs2xdr.c */
 extern struct rpc_procinfo nfs_procedures[];
 extern int nfs2_decode_dirent(struct xdr_stream *,

commit a7d42ddb3099727f58366fa006f850a219cce6c8
Author: Weston Andros Adamson <dros@primarydata.com>
Date:   Fri Sep 19 10:55:07 2014 -0400

    nfs: add mirroring support to pgio layer
    
    This patch adds mirrored write support to the pgio layer. The default
    is to use one mirror, but pgio callers may define callbacks to change
    this to any value up to the (arbitrarily selected) limit of 16.
    
    The basic idea is to break out members of nfs_pageio_descriptor that cannot
    be shared between mirrored DSes and put them in a new structure.
    
    Signed-off-by: Weston Andros Adamson <dros@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 05f9a87cdab4..ef1c703e487b 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -469,6 +469,7 @@ void nfs_init_cinfo(struct nfs_commit_info *cinfo,
 		    struct nfs_direct_req *dreq);
 int nfs_key_timeout_notify(struct file *filp, struct inode *inode);
 bool nfs_ctx_key_to_expire(struct nfs_open_context *ctx);
+void nfs_pageio_stop_mirroring(struct nfs_pageio_descriptor *pgio);
 
 #ifdef CONFIG_MIGRATION
 extern int nfs_migrate_page(struct address_space *,

commit b57ff1303a2d4d1484c7a82bd80a3e014d6cdf5e
Author: Weston Andros Adamson <dros@primarydata.com>
Date:   Fri Sep 5 18:20:21 2014 -0400

    pnfs: pass ds_commit_idx through the commit path
    
    Pass ds_commit_idx through the nfs commit path. It's used to select
    the commit bucket when using pnfs and is ignored when not using pnfs.
    Several functions had to be changed: nfs_retry_commit,
    nfs_mark_request_commit, pnfs_mark_request_commit and the pnfs layout
    driver .mark_request_commit functions.
    
    Signed-off-by: Tom Haynes <loghyr@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index e9305e98b782..05f9a87cdab4 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -450,13 +450,15 @@ int nfs_scan_commit(struct inode *inode, struct list_head *dst,
 		    struct nfs_commit_info *cinfo);
 void nfs_mark_request_commit(struct nfs_page *req,
 			     struct pnfs_layout_segment *lseg,
-			     struct nfs_commit_info *cinfo);
+			     struct nfs_commit_info *cinfo,
+			     u32 ds_commit_idx);
 int nfs_write_need_commit(struct nfs_pgio_header *);
 int nfs_generic_commit_list(struct inode *inode, struct list_head *head,
 			    int how, struct nfs_commit_info *cinfo);
 void nfs_retry_commit(struct list_head *page_list,
 		      struct pnfs_layout_segment *lseg,
-		      struct nfs_commit_info *cinfo);
+		      struct nfs_commit_info *cinfo,
+		      u32 ds_commit_idx);
 void nfs_commitdata_release(struct nfs_commit_data *data);
 void nfs_request_add_commit_list(struct nfs_page *req, struct list_head *dst,
 				 struct nfs_commit_info *cinfo);

commit 46a5ab4754cad6aeefd96feae8ba65db8655e1af
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Fri Jun 13 23:02:25 2014 +0800

    nfs: allow to specify cred in nfs_initiate_pgio
    
    so that flexfile layout client can pass in DS credential instead of
    using user cred, which will be done in the next patch.
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Tom Haynes <Thomas.Haynes@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 98dee834e9d6..e9305e98b782 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -250,9 +250,9 @@ struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *);
 void nfs_pgio_header_free(struct nfs_pgio_header *);
 void nfs_pgio_data_destroy(struct nfs_pgio_header *);
 int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
-int nfs_initiate_pgio(struct rpc_clnt *, struct nfs_pgio_header *,
-		      const struct nfs_rpc_ops *,
-		      const struct rpc_call_ops *, int, int);
+int nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,
+		      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,
+		      const struct rpc_call_ops *call_ops, int how, int flags);
 void nfs_free_request(struct nfs_page *req);
 
 static inline void nfs_iocounter_init(struct nfs_io_counter *c)

commit c36aae9ad95afa2f9a9e9109d989c21af221fabd
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Mon Jun 9 07:10:14 2014 +0800

    nfs: allow different protocol in nfs_initiate_commit
    
    pnfs flexfile layout client may want to use NFSv3 ops rather
    than the default MDS v4 ops.
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Tom Haynes <Thomas.Haynes@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 1d15ffa94937..98dee834e9d6 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -436,6 +436,7 @@ extern void nfs_write_prepare(struct rpc_task *task, void *calldata);
 extern void nfs_commit_prepare(struct rpc_task *task, void *calldata);
 extern int nfs_initiate_commit(struct rpc_clnt *clnt,
 			       struct nfs_commit_data *data,
+			       const struct nfs_rpc_ops *nfs_ops,
 			       const struct rpc_call_ops *call_ops,
 			       int how, int flags);
 extern void nfs_init_commit(struct nfs_commit_data *data,

commit abde71f4d3c027a30f8d725e1e22001313b4481a
Author: Tom Haynes <loghyr@primarydata.com>
Date:   Mon Jun 9 13:12:20 2014 -0700

    pnfs: Add nfs_rpc_ops in calls to nfs_initiate_pgio
    
    Signed-off-by: Tom Haynes <loghyr@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5543850268d2..1d15ffa94937 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -251,6 +251,7 @@ void nfs_pgio_header_free(struct nfs_pgio_header *);
 void nfs_pgio_data_destroy(struct nfs_pgio_header *);
 int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
 int nfs_initiate_pgio(struct rpc_clnt *, struct nfs_pgio_header *,
+		      const struct nfs_rpc_ops *,
 		      const struct rpc_call_ops *, int, int);
 void nfs_free_request(struct nfs_page *req);
 

commit 30626f9c32f0ad5e2c4173f10fb4b1358bbba6ec
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Fri May 30 18:15:58 2014 +0800

    nfs41: allow LD to choose DS connection version/minor_version
    
    flexfile layout may need to set such when making DS connections.
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Tom Haynes <Thomas.Haynes@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7332ba1f693b..5543850268d2 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -190,6 +190,7 @@ extern struct nfs_client *nfs4_set_ds_client(struct nfs_client* mds_clp,
 					     int ds_addrlen, int ds_proto,
 					     unsigned int ds_timeo,
 					     unsigned int ds_retrans,
+					     u32 minor_version,
 					     rpc_authflavor_t au_flavor);
 extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,
 						struct inode *);

commit 1a04c6e1a26a43305fe124a0978a3e4be861af89
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Fri May 30 18:15:57 2014 +0800

    nfsv3: introduce nfs3_set_ds_client
    
    The flexfiles layout wants to create DS connection over NFSv3.
    Add nfs3_set_ds_client to allow that to happen.
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Tom Haynes <Thomas.Haynes@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7d7c36ff09fa..7332ba1f693b 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -193,6 +193,10 @@ extern struct nfs_client *nfs4_set_ds_client(struct nfs_client* mds_clp,
 					     rpc_authflavor_t au_flavor);
 extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,
 						struct inode *);
+extern struct nfs_client *nfs3_set_ds_client(struct nfs_client *mds_clp,
+			const struct sockaddr *ds_addr, int ds_addrlen,
+			int ds_proto, unsigned int ds_timeo,
+			unsigned int ds_retrans, rpc_authflavor_t au_flavor);
 #ifdef CONFIG_PROC_FS
 extern int __init nfs_fs_proc_init(void);
 extern void nfs_fs_proc_exit(void);

commit 064172f3459a914277aa309b2afd3bd5d1c3289a
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Thu May 29 21:07:00 2014 +0800

    nfs41: allow LD to choose DS connection auth flavor
    
    flexfile layout may use different auth flavor as specified by MDS.
    
    Reviewed-by: Jeff Layton <jlayton@primarydata.com>
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Tom Haynes <Thomas.Haynes@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index efaa31c70fbe..7d7c36ff09fa 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -189,7 +189,8 @@ extern struct nfs_client *nfs4_set_ds_client(struct nfs_client* mds_clp,
 					     const struct sockaddr *ds_addr,
 					     int ds_addrlen, int ds_proto,
 					     unsigned int ds_timeo,
-					     unsigned int ds_retrans);
+					     unsigned int ds_retrans,
+					     rpc_authflavor_t au_flavor);
 extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,
 						struct inode *);
 #ifdef CONFIG_PROC_FS

commit 2ef47eb1aee171ecf1d83311b9f7fae80f330181
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue Dec 9 16:19:16 2014 -0500

    NFS: Fix use of nfs_attr_use_mounted_on_fileid()
    
    This function call was being optimized out during nfs_fhget(), leading
    to situations where we have a valid fileid but still want to use the
    mounted_on_fileid.  For example, imagine we have our server configured
    like this:
    
    server % df
    Filesystem      Size  Used Avail Use% Mounted on
    /dev/vda1       9.1G  6.5G  1.9G  78% /
    /dev/vdb1       487M  2.3M  456M   1% /exports
    /dev/vdc1       487M  2.3M  456M   1% /exports/vol1
    /dev/vdd1       487M  2.3M  456M   1% /exports/vol2
    
    If our client mounts /exports and tries to do a "chown -R" across the
    entire mountpoint, we will get a nasty message warning us about a circular
    directory structure.  Running chown with strace tells me that each directory
    has the same device and inode number:
    
    newfstatat(AT_FDCWD, "/nfs/", {st_dev=makedev(0, 38), st_ino=2, ...}) = 0
    newfstatat(4, "vol1", {st_dev=makedev(0, 38), st_ino=2, ...}) = 0
    newfstatat(4, "vol2", {st_dev=makedev(0, 38), st_ino=2, ...}) = 0
    
    With this patch the mounted_on_fileid values are used for st_ino, so the
    directory loop warning isn't reported.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index efaa31c70fbe..b6f34bfa6fe8 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -31,8 +31,6 @@ static inline int nfs_attr_use_mounted_on_fileid(struct nfs_fattr *fattr)
 	    (((fattr->valid & NFS_ATTR_FATTR_MOUNTPOINT) == 0) &&
 	     ((fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) == 0)))
 		return 0;
-
-	fattr->fileid = fattr->mounted_on_fileid;
 	return 1;
 }
 

commit 7b14a213890a81473ec97ad7e322d5c2f19854ae
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jan 14 10:42:39 2015 +0100

    nfs: don't call bdi_unregister
    
    bdi_destroy already does all the work, and if we delay freeing the
    anon bdev we can get away with just that single call.
    
    Addintionally remove the call during mount failure, as
    deactivate_super_locked will already call ->kill_sb and clean up
    the bdi for us.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index efaa31c70fbe..f519d4187332 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -416,7 +416,6 @@ int  nfs_show_options(struct seq_file *, struct dentry *);
 int  nfs_show_devname(struct seq_file *, struct dentry *);
 int  nfs_show_path(struct seq_file *, struct dentry *);
 int  nfs_show_stats(struct seq_file *, struct dentry *);
-void nfs_put_super(struct super_block *);
 int nfs_remount(struct super_block *sb, int *flags, char *raw_data);
 
 /* write.c */

commit ef4a48c513211d842c55e84f7a1c31884b91dcf7
Merge: 90d0c376f5ee 1b2b32dcdb3d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 11 13:21:34 2014 -0400

    Merge tag 'locks-v3.18-1' of git://git.samba.org/jlayton/linux
    
    Pull file locking related changes from Jeff Layton:
     "This release is a little more busy for file locking changes than the
      last:
    
       - a set of patches from Kinglong Mee to fix the lockowner handling in
         knfsd
       - a pile of cleanups to the internal file lease API.  This should get
         us a bit closer to allowing for setlease methods that can block.
    
      There are some dependencies between mine and Bruce's trees this cycle,
      and I based my tree on top of the requisite patches in Bruce's tree"
    
    * tag 'locks-v3.18-1' of git://git.samba.org/jlayton/linux: (26 commits)
      locks: fix fcntl_setlease/getlease return when !CONFIG_FILE_LOCKING
      locks: flock_make_lock should return a struct file_lock (or PTR_ERR)
      locks: set fl_owner for leases to filp instead of current->files
      locks: give lm_break a return value
      locks: __break_lease cleanup in preparation of allowing direct removal of leases
      locks: remove i_have_this_lease check from __break_lease
      locks: move freeing of leases outside of i_lock
      locks: move i_lock acquisition into generic_*_lease handlers
      locks: define a lm_setup handler for leases
      locks: plumb a "priv" pointer into the setlease routines
      nfsd: don't keep a pointer to the lease in nfs4_file
      locks: clean up vfs_setlease kerneldoc comments
      locks: generic_delete_lease doesn't need a file_lock at all
      nfsd: fix potential lease memory leak in nfs4_setlease
      locks: close potential race in lease_get_mtime
      security: make security_file_set_fowner, f_setown and __f_setown void return
      locks: consolidate "nolease" routines
      locks: remove lock_may_read and lock_may_write
      lockd: rip out deferred lock handling from testlock codepath
      NFSD: Get reference of lockowner when coping file_lock
      ...

commit 00a36a1090350995127c2a4bfac6be7fc85b5b81
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Wed Sep 3 12:19:08 2014 -0400

    NFS: Move v3 declarations out of internal.h
    
    I am generally against the "one big header file" approach, and
    everything in the client includes this file.  Let's move all the NFS v3
    declarations into a v3-only header file.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 9056622d2230..14ae6f20a172 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -218,13 +218,6 @@ static inline void nfs_fs_proc_exit(void)
 int nfs_sockaddr_match_ipaddr(const struct sockaddr *, const struct sockaddr *);
 #endif
 
-/* nfs3client.c */
-#if IS_ENABLED(CONFIG_NFS_V3)
-struct nfs_server *nfs3_create_server(struct nfs_mount_info *, struct nfs_subversion *);
-struct nfs_server *nfs3_clone_server(struct nfs_server *, struct nfs_fh *,
-				     struct nfs_fattr *, rpc_authflavor_t);
-#endif
-
 /* callback_xdr.c */
 extern struct svc_version nfs4_callback_version1;
 extern struct svc_version nfs4_callback_version4;

commit 1c994a0909a556508c2cc26ab5d9e13c5ce33aa0
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Wed Aug 27 06:49:41 2014 -0400

    locks: consolidate "nolease" routines
    
    GFS2 and NFS have setlease routines that always just return -EINVAL.
    Turn that into a generic routine that can live in fs/libfs.c.
    
    Cc: <linux-nfs@vger.kernel.org>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: <cluster-devel@redhat.com>
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Acked-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 9056622d2230..94d922ebb5ac 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -346,7 +346,6 @@ int nfs_file_release(struct inode *, struct file *);
 int nfs_lock(struct file *, int, struct file_lock *);
 int nfs_flock(struct file *, int, struct file_lock *);
 int nfs_check_flags(int);
-int nfs_setlease(struct file *, long, struct file_lock **);
 
 /* inode.c */
 extern struct workqueue_struct *nfsiod_workqueue;

commit 06b8ab55289345ab191bf4bf0e4acc6d4bdf293d
Merge: dc1cc8513312 71a6ec8ac587
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 13 18:13:19 2014 -0600

    Merge tag 'nfs-for-3.17-1' of git://git.linux-nfs.org/projects/trondmy/linux-nfs
    
    Pull NFS client updates from Trond Myklebust:
     "Highlights include:
    
       - stable fix for a bug in nfs3_list_one_acl()
       - speed up NFS path walks by supporting LOOKUP_RCU
       - more read/write code cleanups
       - pNFS fixes for layout return on close
       - fixes for the RCU handling in the rpcsec_gss code
       - more NFS/RDMA fixes"
    
    * tag 'nfs-for-3.17-1' of git://git.linux-nfs.org/projects/trondmy/linux-nfs: (79 commits)
      nfs: reject changes to resvport and sharecache during remount
      NFS: Avoid infinite loop when RELEASE_LOCKOWNER getting expired error
      SUNRPC: remove all refcounting of groupinfo from rpcauth_lookupcred
      NFS: fix two problems in lookup_revalidate in RCU-walk
      NFS: allow lockless access to access_cache
      NFS: teach nfs_lookup_verify_inode to handle LOOKUP_RCU
      NFS: teach nfs_neg_need_reval to understand LOOKUP_RCU
      NFS: support RCU_WALK in nfs_permission()
      sunrpc/auth: allow lockless (rcu) lookup of credential cache.
      NFS: prepare for RCU-walk support but pushing tests later in code.
      NFS: nfs4_lookup_revalidate: only evaluate parent if it will be used.
      NFS: add checks for returned value of try_module_get()
      nfs: clear_request_commit while holding i_lock
      pnfs: add pnfs_put_lseg_async
      pnfs: find swapped pages on pnfs commit lists too
      nfs: fix comment and add warn_on for PG_INODE_REF
      nfs: check wait_on_bit_lock err in page_group_lock
      sunrpc: remove "ec" argument from encrypt_v2 operation
      sunrpc: clean up sparse endianness warnings in gss_krb5_wrap.c
      sunrpc: clean up sparse endianness warnings in gss_krb5_seal.c
      ...

commit 77e40aae766ccbbbb0324cb92ab22e6e998375d7
Merge: 96784de59fb3 344470cac42e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 9 17:10:41 2014 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull namespace updates from Eric Biederman:
     "This is a bunch of small changes built against 3.16-rc6.  The most
      significant change for users is the first patch which makes setns
      drmatically faster by removing unneded rcu handling.
    
      The next chunk of changes are so that "mount -o remount,.." will not
      allow the user namespace root to drop flags on a mount set by the
      system wide root.  Aks this forces read-only mounts to stay read-only,
      no-dev mounts to stay no-dev, no-suid mounts to stay no-suid, no-exec
      mounts to stay no exec and it prevents unprivileged users from messing
      with a mounts atime settings.  I have included my test case as the
      last patch in this series so people performing backports can verify
      this change works correctly.
    
      The next change fixes a bug in NFS that was discovered while auditing
      nsproxy users for the first optimization.  Today you can oops the
      kernel by reading /proc/fs/nfsfs/{servers,volumes} if you are clever
      with pid namespaces.  I rebased and fixed the build of the
      !CONFIG_NFS_FS case yesterday when a build bot caught my typo.  Given
      that no one to my knowledge bases anything on my tree fixing the typo
      in place seems more responsible that requiring a typo-fix to be
      backported as well.
    
      The last change is a small semantic cleanup introducing
      /proc/thread-self and pointing /proc/mounts and /proc/net at it.  This
      prevents several kinds of problemantic corner cases.  It is a
      user-visible change so it has a minute chance of causing regressions
      so the change to /proc/mounts and /proc/net are individual one line
      commits that can be trivially reverted.  Unfortunately I lost and
      could not find the email of the original reporter so he is not
      credited.  From at least one perspective this change to /proc/net is a
      refgression fix to allow pthread /proc/net uses that were broken by
      the introduction of the network namespace"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace:
      proc: Point /proc/mounts at /proc/thread-self/mounts instead of /proc/self/mounts
      proc: Point /proc/net at /proc/thread-self/net instead of /proc/self/net
      proc: Implement /proc/thread-self to point at the directory of the current thread
      proc: Have net show up under /proc/<tgid>/task/<tid>
      NFS: Fix /proc/fs/nfsfs/servers and /proc/fs/nfsfs/volumes
      mnt: Add tests for unprivileged remount cases that have found to be faulty
      mnt: Change the default remount atime from relatime to the existing value
      mnt: Correct permission checks in do_remount
      mnt: Move the test for MNT_LOCK_READONLY from change_mount_flags into do_remount
      mnt: Only change user settable mount flags in remount
      namespaces: Use task_lock and not rcu to protect nsproxy

commit 65b38851a17472d31fec9019fc3a55b0802dab88
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jul 31 04:35:20 2014 -0700

    NFS: Fix /proc/fs/nfsfs/servers and /proc/fs/nfsfs/volumes
    
    The usage of pid_ns->child_reaper->nsproxy->net_ns in
    nfs_server_list_open and nfs_client_list_open is not safe.
    
    /proc for a pid namespace can remain mounted after the all of the
    process in that pid namespace have exited.  There are also times
    before the initial process in a pid namespace has started or after the
    initial process in a pid namespace has exited where
    pid_ns->child_reaper can be NULL or stale.  Making the idiom
    pid_ns->child_reaper->nsproxy a double whammy of problems.
    
    Luckily all that needs to happen is to move /proc/fs/nfsfs/servers and
    /proc/fs/nfsfs/volumes under /proc/net to /proc/net/nfsfs/servers and
    /proc/net/nfsfs/volumes and add a symlink from the original location,
    and to use seq_open_net as it has been designed.
    
    Cc: stable@vger.kernel.org
    Cc: Trond Myklebust <trond.myklebust@primarydata.com>
    Cc: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index f415cbf9f6c3..2d2ebdfb0723 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -195,7 +195,16 @@ extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,
 #ifdef CONFIG_PROC_FS
 extern int __init nfs_fs_proc_init(void);
 extern void nfs_fs_proc_exit(void);
+extern int nfs_fs_proc_net_init(struct net *net);
+extern void nfs_fs_proc_net_exit(struct net *net);
 #else
+static inline int nfs_fs_proc_net_init(struct net *net)
+{
+	return 0;
+}
+static inline void nfs_fs_proc_net_exit(struct net *net)
+{
+}
 static inline int nfs_fs_proc_init(void)
 {
 	return 0;

commit ca5bc6cd5de5b53eb8fd6fea39aa3fe2a1e8c3d9
Merge: c1221321b7c2 d8d28c8f00e8
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon Jul 28 10:03:00 2014 +0200

    Merge branch 'sched/urgent' into sched/core, to merge fixes before applying new changes
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit c1221321b7c25b53204447cff9949a6d5a7ddddc
Author: NeilBrown <neilb@suse.de>
Date:   Mon Jul 7 15:16:04 2014 +1000

    sched: Allow wait_on_bit_action() functions to support a timeout
    
    It is currently not possible for various wait_on_bit functions
    to implement a timeout.
    
    While the "action" function that is called to do the waiting
    could certainly use schedule_timeout(), there is no way to carry
    forward the remaining timeout after a false wake-up.
    As false-wakeups a clearly possible at least due to possible
    hash collisions in bit_waitqueue(), this is a real problem.
    
    The 'action' function is currently passed a pointer to the word
    containing the bit being waited on.  No current action functions
    use this pointer.  So changing it to something else will be a
    little noisy but will have no immediate effect.
    
    This patch changes the 'action' function to take a pointer to
    the "struct wait_bit_key", which contains a pointer to the word
    containing the bit so nothing is really lost.
    
    It also adds a 'private' field to "struct wait_bit_key", which
    is initialized to zero.
    
    An action function can now implement a timeout with something
    like
    
    static int timed_out_waiter(struct wait_bit_key *key)
    {
            unsigned long waited;
            if (key->private == 0) {
                    key->private = jiffies;
                    if (key->private == 0)
                            key->private -= 1;
            }
            waited = jiffies - key->private;
            if (waited > 10 * HZ)
                    return -EAGAIN;
            schedule_timeout(waited - 10 * HZ);
            return 0;
    }
    
    If any other need for context in a waiter were found it would be
    easy to use ->private for some other purpose, or even extend
    "struct wait_bit_key".
    
    My particular need is to support timeouts in nfs_release_page()
    to avoid deadlocks with loopback mounted NFS.
    
    While wait_on_bit_timeout() would be a cleaner interface, it
    will not meet my need.  I need the timeout to be sensitive to
    the state of the connection with the server, which could change.
     So I need to use an 'action' interface.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Steve French <sfrench@samba.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Link: http://lkml.kernel.org/r/20140707051604.28027.41257.stgit@notabene.brown
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 82ddbf46660e..e0193d63630c 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -347,7 +347,7 @@ extern int nfs_drop_inode(struct inode *);
 extern void nfs_clear_inode(struct inode *);
 extern void nfs_evict_inode(struct inode *);
 void nfs_zap_acl_cache(struct inode *inode);
-extern int nfs_wait_bit_killable(void *word);
+extern int nfs_wait_bit_killable(struct wait_bit_key *key);
 
 /* super.c */
 extern const struct super_operations nfs_sops;

commit e655f945cd7ba2a8360ddd5462ca535a3b41e07e
Merge: 00cfaa943ec3 f563b89b1825
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sun Jul 13 15:22:02 2014 -0400

    Merge branch 'bugfixes' into linux-next
    
    * bugfixes:
      NFS: Don't reset pg_moreio in __nfs_pageio_add_request
      NFS: Remove 2 unused variables
      nfs: handle multiple reqs in nfs_wb_page_cancel
      nfs: handle multiple reqs in nfs_page_async_flush
      nfs: change find_request to find_head_request
      nfs: nfs_page should take a ref on the head req
      nfs: mark nfs_page reqs with flag for extra ref
      nfs: only show Posix ACLs in listxattr if actually present
    
    Conflicts:
            fs/nfs/write.c

commit d458138353726ea6dcbc53ae3597e489d0432c25
Author: Weston Andros Adamson <dros@primarydata.com>
Date:   Fri Jul 11 10:20:48 2014 -0400

    nfs: handle multiple reqs in nfs_page_async_flush
    
    Change nfs_find_and_lock_request so nfs_page_async_flush can handle multiple
    requests in a page. There is only one request for a page the first time
    nfs_page_async_flush is called, but if a write or commit fails, async_flush
    is called again and there may be multiple requests associated with the page.
    The solution is to merge all the requests in a page group into a single
    request before calling nfs_pageio_add_request.
    
    Rename nfs_find_and_lock_request to nfs_lock_and_join_requests and
    change it to first lock all requests for the page, then cancel and merge
    all subrequests into the head request.
    
    Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 82ddbf46660e..f415cbf9f6c3 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -244,6 +244,7 @@ void nfs_pgio_data_release(struct nfs_pgio_data *);
 int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
 int nfs_initiate_pgio(struct rpc_clnt *, struct nfs_pgio_data *,
 		      const struct rpc_call_ops *, int, int);
+void nfs_free_request(struct nfs_page *req);
 
 static inline void nfs_iocounter_init(struct nfs_io_counter *c)
 {

commit c65e6254ca4db1584c5bf5f228ee26556477a9fd
Author: Weston Andros Adamson <dros@primarydata.com>
Date:   Mon Jun 9 11:48:36 2014 -0400

    nfs: remove unused writeverf code
    
    Remove duplicate writeverf structure from merge of nfs_pgio_header and
    nfs_pgio_data and remove writeverf related flags and logic to handle
    more than one RPC per nfs_pgio_header.
    
    Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 3f3aedd2e8c9..da36257628c5 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -441,6 +441,7 @@ int nfs_scan_commit(struct inode *inode, struct list_head *dst,
 void nfs_mark_request_commit(struct nfs_page *req,
 			     struct pnfs_layout_segment *lseg,
 			     struct nfs_commit_info *cinfo);
+int nfs_write_need_commit(struct nfs_pgio_header *);
 int nfs_generic_commit_list(struct inode *inode, struct list_head *head,
 			    int how, struct nfs_commit_info *cinfo);
 void nfs_retry_commit(struct list_head *page_list,

commit d45f60c67848b9f19160692581d78e5b4757a000
Author: Weston Andros Adamson <dros@primarydata.com>
Date:   Mon Jun 9 11:48:35 2014 -0400

    nfs: merge nfs_pgio_data into _header
    
    struct nfs_pgio_data only exists as a member of nfs_pgio_header, but is
    passed around everywhere, because there used to be multiple _data structs
    per _header. Many of these functions then use the _data to find a pointer
    to the _header.  This patch cleans this up by merging the nfs_pgio_data
    structure into nfs_pgio_header and passing nfs_pgio_header around instead.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5cda049c8f9b..3f3aedd2e8c9 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -240,9 +240,9 @@ int nfs_iocounter_wait(struct nfs_io_counter *c);
 extern const struct nfs_pageio_ops nfs_pgio_rw_ops;
 struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *);
 void nfs_pgio_header_free(struct nfs_pgio_header *);
-void nfs_pgio_data_destroy(struct nfs_pgio_data *);
+void nfs_pgio_data_destroy(struct nfs_pgio_header *);
 int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
-int nfs_initiate_pgio(struct rpc_clnt *, struct nfs_pgio_data *,
+int nfs_initiate_pgio(struct rpc_clnt *, struct nfs_pgio_header *,
 		      const struct rpc_call_ops *, int, int);
 
 static inline void nfs_iocounter_init(struct nfs_io_counter *c)
@@ -481,7 +481,7 @@ static inline void nfs_inode_dio_wait(struct inode *inode)
 extern ssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq);
 
 /* nfs4proc.c */
-extern void __nfs4_read_done_cb(struct nfs_pgio_data *);
+extern void __nfs4_read_done_cb(struct nfs_pgio_header *);
 extern struct nfs_client *nfs4_init_client(struct nfs_client *clp,
 			    const struct rpc_timeout *timeparms,
 			    const char *ip_addr);

commit 1e7f3a485922211b6e4a082ebc6bf05810b0b6ea
Author: Weston Andros Adamson <dros@primarydata.com>
Date:   Mon Jun 9 11:48:33 2014 -0400

    nfs: move nfs_pgio_data and remove nfs_rw_header
    
    nfs_rw_header was used to allocate an nfs_pgio_header along with an
    nfs_pgio_data, because a _header would need at least one _data.
    
    Now there is only ever one nfs_pgio_data for each nfs_pgio_header -- move
    it to nfs_pgio_header and get rid of nfs_rw_header.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 82ddbf46660e..5cda049c8f9b 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -238,9 +238,9 @@ void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos);
 int nfs_iocounter_wait(struct nfs_io_counter *c);
 
 extern const struct nfs_pageio_ops nfs_pgio_rw_ops;
-struct nfs_rw_header *nfs_rw_header_alloc(const struct nfs_rw_ops *);
-void nfs_rw_header_free(struct nfs_pgio_header *);
-void nfs_pgio_data_release(struct nfs_pgio_data *);
+struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *);
+void nfs_pgio_header_free(struct nfs_pgio_header *);
+void nfs_pgio_data_destroy(struct nfs_pgio_data *);
 int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
 int nfs_initiate_pgio(struct rpc_clnt *, struct nfs_pgio_data *,
 		      const struct rpc_call_ops *, int, int);

commit 16b9057804c02e2d351e9c8f606e909b43cbd9e7
Merge: 5c02c392cd23 c2338f2dc7c1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 12 10:30:18 2014 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
     "This the bunch that sat in -next + lock_parent() fix.  This is the
      minimal set; there's more pending stuff.
    
      In particular, I really hope to get acct.c fixes merged this cycle -
      we need that to deal sanely with delayed-mntput stuff.  In the next
      pile, hopefully - that series is fairly short and localized
      (kernel/acct.c, fs/super.c and fs/namespace.c).  In this pile: more
      iov_iter work.  Most of prereqs for ->splice_write with sane locking
      order are there and Kent's dio rewrite would also fit nicely on top of
      this pile"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (70 commits)
      lock_parent: don't step on stale ->d_parent of all-but-freed one
      kill generic_file_splice_write()
      ceph: switch to iter_file_splice_write()
      shmem: switch to iter_file_splice_write()
      nfs: switch to iter_splice_write_file()
      fs/splice.c: remove unneeded exports
      ocfs2: switch to iter_file_splice_write()
      ->splice_write() via ->write_iter()
      bio_vec-backed iov_iter
      optimize copy_page_{to,from}_iter()
      bury generic_file_aio_{read,write}
      lustre: get rid of messing with iovecs
      ceph: switch to ->write_iter()
      ceph_sync_direct_write: stop poking into iov_iter guts
      ceph_sync_read: stop poking into iov_iter guts
      new helper: copy_page_from_iter()
      fuse: switch to ->write_iter()
      btrfs: switch to ->write_iter()
      ocfs2: switch to ->write_iter()
      xfs: switch to ->write_iter()
      ...

commit 4da54c218da96fab0d65f3263c9b0092b42f0711
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 5 04:37:17 2014 -0400

    nfs: switch to iter_splice_write_file()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index a5b36fc6b795..0e4e8049c9f5 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -328,8 +328,6 @@ ssize_t nfs_file_write(struct kiocb *, struct iov_iter *);
 int nfs_file_release(struct inode *, struct file *);
 int nfs_lock(struct file *, int, struct file_lock *);
 int nfs_flock(struct file *, int, struct file_lock *);
-ssize_t nfs_file_splice_write(struct pipe_inode_info *, struct file *, loff_t *,
-			      size_t, unsigned int);
 int nfs_check_flags(int);
 int nfs_setlease(struct file *, long, struct file_lock **);
 

commit 41d8d5b7a559a9bfbf9680d1e4777e1a7b0149d5
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:40 2014 -0400

    NFS: Create a common nfs_pageio_ops struct
    
    At this point the read and write structures look identical, so combine
    them into something shared by both.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 29e99aac3673..8b69cba1bb04 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -237,13 +237,13 @@ extern void nfs_pgheader_init(struct nfs_pageio_descriptor *desc,
 void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos);
 int nfs_iocounter_wait(struct nfs_io_counter *c);
 
+extern const struct nfs_pageio_ops nfs_pgio_rw_ops;
 struct nfs_rw_header *nfs_rw_header_alloc(const struct nfs_rw_ops *);
 void nfs_rw_header_free(struct nfs_pgio_header *);
 void nfs_pgio_data_release(struct nfs_pgio_data *);
 int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
 int nfs_initiate_pgio(struct rpc_clnt *, struct nfs_pgio_data *,
 		      const struct rpc_call_ops *, int, int);
-int nfs_generic_pg_pgios(struct nfs_pageio_descriptor *);
 
 static inline void nfs_iocounter_init(struct nfs_io_counter *c)
 {

commit cf485fcd68bc2dd91258e844ba4649404fff3235
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:39 2014 -0400

    NFS: Create a common generic_pg_pgios()
    
    What we have here is two functions that look identical.  Let's share
    some more code!
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 886273a8916b..29e99aac3673 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -243,7 +243,7 @@ void nfs_pgio_data_release(struct nfs_pgio_data *);
 int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
 int nfs_initiate_pgio(struct rpc_clnt *, struct nfs_pgio_data *,
 		      const struct rpc_call_ops *, int, int);
-int nfs_do_multiple_pgios(struct list_head *, const struct rpc_call_ops *, int);
+int nfs_generic_pg_pgios(struct nfs_pageio_descriptor *);
 
 static inline void nfs_iocounter_init(struct nfs_io_counter *c)
 {

commit c3766276f26090f4459329839cdcc8506dfbced5
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:38 2014 -0400

    NFS: Create a common multiple_pgios() function
    
    Once again, these two functions look identical in the read and write
    case.  Time to combine them together!
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index be4f2a7e9178..886273a8916b 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -243,6 +243,7 @@ void nfs_pgio_data_release(struct nfs_pgio_data *);
 int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
 int nfs_initiate_pgio(struct rpc_clnt *, struct nfs_pgio_data *,
 		      const struct rpc_call_ops *, int, int);
+int nfs_do_multiple_pgios(struct list_head *, const struct rpc_call_ops *, int);
 
 static inline void nfs_iocounter_init(struct nfs_io_counter *c)
 {

commit 1ed26f33008e954a8e91d26f97d4380dea8145db
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:37 2014 -0400

    NFS: Create a common initiate_pgio() function
    
    Most of this code is the same for both the read and write paths, so
    combine everything and use the rw_ops when necessary.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 365cdb11d0de..be4f2a7e9178 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -241,6 +241,8 @@ struct nfs_rw_header *nfs_rw_header_alloc(const struct nfs_rw_ops *);
 void nfs_rw_header_free(struct nfs_pgio_header *);
 void nfs_pgio_data_release(struct nfs_pgio_data *);
 int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
+int nfs_initiate_pgio(struct rpc_clnt *, struct nfs_pgio_data *,
+		      const struct rpc_call_ops *, int, int);
 
 static inline void nfs_iocounter_init(struct nfs_io_counter *c)
 {
@@ -402,9 +404,6 @@ struct nfs_pgio_completion_ops;
 extern void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,
 			struct inode *inode, bool force_mds,
 			const struct nfs_pgio_completion_ops *compl_ops);
-extern int nfs_initiate_read(struct rpc_clnt *clnt,
-			     struct nfs_pgio_data *data,
-			     const struct rpc_call_ops *call_ops, int flags);
 extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
 
@@ -425,10 +424,6 @@ extern void nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,
 			const struct nfs_pgio_completion_ops *compl_ops);
 extern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_commit_free(struct nfs_commit_data *p);
-extern int nfs_initiate_write(struct rpc_clnt *clnt,
-			      struct nfs_pgio_data *data,
-			      const struct rpc_call_ops *call_ops,
-			      int how, int flags);
 extern void nfs_write_prepare(struct rpc_task *task, void *calldata);
 extern void nfs_commit_prepare(struct rpc_task *task, void *calldata);
 extern int nfs_initiate_commit(struct rpc_clnt *clnt,

commit ef2c488c073f4f0b3a200745dd8d608c01d69c39
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:36 2014 -0400

    NFS: Create a generic_pgio function
    
    These functions are almost identical on both the read and write side.
    FLUSH_COND_STABLE will never be set for the read path, so leaving it in
    the generic code won't hurt anything.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index a4b9e754756b..365cdb11d0de 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -237,14 +237,10 @@ extern void nfs_pgheader_init(struct nfs_pageio_descriptor *desc,
 void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos);
 int nfs_iocounter_wait(struct nfs_io_counter *c);
 
-extern const struct rpc_call_ops nfs_pgio_common_ops;
 struct nfs_rw_header *nfs_rw_header_alloc(const struct nfs_rw_ops *);
 void nfs_rw_header_free(struct nfs_pgio_header *);
-struct nfs_pgio_data *nfs_pgio_data_alloc(struct nfs_pgio_header *, unsigned int);
 void nfs_pgio_data_release(struct nfs_pgio_data *);
-int nfs_pgio_error(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
-void nfs_pgio_rpcsetup(struct nfs_pgio_data *, unsigned int, unsigned int, int,
-		       struct nfs_commit_info *);
+int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
 
 static inline void nfs_iocounter_init(struct nfs_io_counter *c)
 {
@@ -410,8 +406,6 @@ extern int nfs_initiate_read(struct rpc_clnt *clnt,
 			     struct nfs_pgio_data *data,
 			     const struct rpc_call_ops *call_ops, int flags);
 extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
-extern int nfs_generic_pagein(struct nfs_pageio_descriptor *desc,
-			      struct nfs_pgio_header *hdr);
 extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
 
 /* super.c */
@@ -429,8 +423,6 @@ int nfs_remount(struct super_block *sb, int *flags, char *raw_data);
 extern void nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,
 			struct inode *inode, int ioflags, bool force_mds,
 			const struct nfs_pgio_completion_ops *compl_ops);
-extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
-			     struct nfs_pgio_header *hdr);
 extern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_commit_free(struct nfs_commit_data *p);
 extern int nfs_initiate_write(struct rpc_clnt *clnt,

commit 844c9e691d8723853ca8f2de0207683538645824
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:35 2014 -0400

    NFS: Create a common pgio_error function
    
    At this point, the read and write versions of this function look
    identical so both should use the same function.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 519864b3296a..a4b9e754756b 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -242,6 +242,7 @@ struct nfs_rw_header *nfs_rw_header_alloc(const struct nfs_rw_ops *);
 void nfs_rw_header_free(struct nfs_pgio_header *);
 struct nfs_pgio_data *nfs_pgio_data_alloc(struct nfs_pgio_header *, unsigned int);
 void nfs_pgio_data_release(struct nfs_pgio_data *);
+int nfs_pgio_error(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
 void nfs_pgio_rpcsetup(struct nfs_pgio_data *, unsigned int, unsigned int, int,
 		       struct nfs_commit_info *);
 

commit ce59515c1484d3a01bc2f3e7043dc488d25efe34
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:34 2014 -0400

    NFS: Create a common rpcsetup function for reads and writes
    
    Write adds a little bit of code dealing with flush flags, but since
    "how" will always be 0 when reading we can share the code.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index e34220f10165..519864b3296a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -242,6 +242,8 @@ struct nfs_rw_header *nfs_rw_header_alloc(const struct nfs_rw_ops *);
 void nfs_rw_header_free(struct nfs_pgio_header *);
 struct nfs_pgio_data *nfs_pgio_data_alloc(struct nfs_pgio_header *, unsigned int);
 void nfs_pgio_data_release(struct nfs_pgio_data *);
+void nfs_pgio_rpcsetup(struct nfs_pgio_data *, unsigned int, unsigned int, int,
+		       struct nfs_commit_info *);
 
 static inline void nfs_iocounter_init(struct nfs_io_counter *c)
 {
@@ -446,6 +448,7 @@ extern void nfs_init_commit(struct nfs_commit_data *data,
 			    struct nfs_commit_info *cinfo);
 int nfs_scan_commit_list(struct list_head *src, struct list_head *dst,
 			 struct nfs_commit_info *cinfo, int max);
+unsigned long nfs_reqs_to_commit(struct nfs_commit_info *);
 int nfs_scan_commit(struct inode *inode, struct list_head *dst,
 		    struct nfs_commit_info *cinfo);
 void nfs_mark_request_commit(struct nfs_page *req,

commit 6f92fa4581f1c26562f80dc686b3c9ea76556911
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:33 2014 -0400

    NFS: Create a common rpc_call_ops struct
    
    The read and write paths set up this struct in exactly the same way, so
    create a single shared struct.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7c0ae364bdad..e34220f10165 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -237,13 +237,11 @@ extern void nfs_pgheader_init(struct nfs_pageio_descriptor *desc,
 void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos);
 int nfs_iocounter_wait(struct nfs_io_counter *c);
 
+extern const struct rpc_call_ops nfs_pgio_common_ops;
 struct nfs_rw_header *nfs_rw_header_alloc(const struct nfs_rw_ops *);
 void nfs_rw_header_free(struct nfs_pgio_header *);
 struct nfs_pgio_data *nfs_pgio_data_alloc(struct nfs_pgio_header *, unsigned int);
 void nfs_pgio_data_release(struct nfs_pgio_data *);
-void nfs_pgio_prepare(struct rpc_task *, void *);
-void nfs_pgio_release(void *);
-void nfs_pgio_result(struct rpc_task *, void *);
 
 static inline void nfs_iocounter_init(struct nfs_io_counter *c)
 {

commit 0eecb2145c1ce18e36617008424a93836ad0a3bd
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:32 2014 -0400

    NFS: Create a common nfs_pgio_result_common function
    
    Combining these functions will let me make a single nfs_rw_common_ops
    struct (see the next patch).
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 1959260f8c57..7c0ae364bdad 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -243,6 +243,7 @@ struct nfs_pgio_data *nfs_pgio_data_alloc(struct nfs_pgio_header *, unsigned int
 void nfs_pgio_data_release(struct nfs_pgio_data *);
 void nfs_pgio_prepare(struct rpc_task *, void *);
 void nfs_pgio_release(void *);
+void nfs_pgio_result(struct rpc_task *, void *);
 
 static inline void nfs_iocounter_init(struct nfs_io_counter *c)
 {

commit a4cdda59111f92000297e0d3edb1e0e08ba3549b
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:31 2014 -0400

    NFS: Create a common pgio_rpc_prepare function
    
    The read and write paths do exactly the same thing for the rpc_prepare
    rpc_op.  This patch combines them together into a single function.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 9d6a40eae11c..1959260f8c57 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -241,6 +241,8 @@ struct nfs_rw_header *nfs_rw_header_alloc(const struct nfs_rw_ops *);
 void nfs_rw_header_free(struct nfs_pgio_header *);
 struct nfs_pgio_data *nfs_pgio_data_alloc(struct nfs_pgio_header *, unsigned int);
 void nfs_pgio_data_release(struct nfs_pgio_data *);
+void nfs_pgio_prepare(struct rpc_task *, void *);
+void nfs_pgio_release(void *);
 
 static inline void nfs_iocounter_init(struct nfs_io_counter *c)
 {

commit 4a0de55c565a36cac8422b76a948c4634a90781e
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:30 2014 -0400

    NFS: Create a common rw_header_alloc and rw_header_free function
    
    I create a new struct nfs_rw_ops to decide the differences between reads
    and writes.  This struct will be set when initializing a new
    nfs_pgio_descriptor, and then passed on to the nfs_rw_header when a new
    header is allocated.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5ddc142c5062..9d6a40eae11c 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -237,6 +237,8 @@ extern void nfs_pgheader_init(struct nfs_pageio_descriptor *desc,
 void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos);
 int nfs_iocounter_wait(struct nfs_io_counter *c);
 
+struct nfs_rw_header *nfs_rw_header_alloc(const struct nfs_rw_ops *);
+void nfs_rw_header_free(struct nfs_pgio_header *);
 struct nfs_pgio_data *nfs_pgio_data_alloc(struct nfs_pgio_header *, unsigned int);
 void nfs_pgio_data_release(struct nfs_pgio_data *);
 
@@ -397,8 +399,6 @@ extern int nfs4_get_rootfh(struct nfs_server *server, struct nfs_fh *mntfh, bool
 
 struct nfs_pgio_completion_ops;
 /* read.c */
-extern struct nfs_rw_header *nfs_readhdr_alloc(void);
-extern void nfs_readhdr_free(struct nfs_pgio_header *hdr);
 extern void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,
 			struct inode *inode, bool force_mds,
 			const struct nfs_pgio_completion_ops *compl_ops);
@@ -425,8 +425,6 @@ int nfs_remount(struct super_block *sb, int *flags, char *raw_data);
 extern void nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,
 			struct inode *inode, int ioflags, bool force_mds,
 			const struct nfs_pgio_completion_ops *compl_ops);
-extern struct nfs_rw_header *nfs_writehdr_alloc(void);
-extern void nfs_writehdr_free(struct nfs_pgio_header *hdr);
 extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
 			     struct nfs_pgio_header *hdr);
 extern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);

commit 00bfa30abe86982ce1929e9cabd703e5546106bd
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:29 2014 -0400

    NFS: Create a common pgio_alloc and pgio_release function
    
    These functions are identical for the read and write paths so they can
    be combined.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index b0e7a41d14a8..5ddc142c5062 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -231,13 +231,15 @@ extern void nfs_destroy_writepagecache(void);
 
 extern int __init nfs_init_directcache(void);
 extern void nfs_destroy_directcache(void);
-extern bool nfs_pgarray_set(struct nfs_page_array *p, unsigned int pagecount);
 extern void nfs_pgheader_init(struct nfs_pageio_descriptor *desc,
 			      struct nfs_pgio_header *hdr,
 			      void (*release)(struct nfs_pgio_header *hdr));
 void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos);
 int nfs_iocounter_wait(struct nfs_io_counter *c);
 
+struct nfs_pgio_data *nfs_pgio_data_alloc(struct nfs_pgio_header *, unsigned int);
+void nfs_pgio_data_release(struct nfs_pgio_data *);
+
 static inline void nfs_iocounter_init(struct nfs_io_counter *c)
 {
 	c->flags = 0;
@@ -407,7 +409,6 @@ extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 extern int nfs_generic_pagein(struct nfs_pageio_descriptor *desc,
 			      struct nfs_pgio_header *hdr);
 extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
-extern void nfs_readdata_release(struct nfs_pgio_data *rdata);
 
 /* super.c */
 void nfs_clone_super(struct super_block *, struct nfs_mount_info *);
@@ -429,7 +430,6 @@ extern void nfs_writehdr_free(struct nfs_pgio_header *hdr);
 extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
 			     struct nfs_pgio_header *hdr);
 extern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);
-extern void nfs_writedata_release(struct nfs_pgio_data *wdata);
 extern void nfs_commit_free(struct nfs_commit_data *p);
 extern int nfs_initiate_write(struct rpc_clnt *clnt,
 			      struct nfs_pgio_data *data,

commit c0752cdfbbb691cfe98812f7aed8ce1e766823c4
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:27 2014 -0400

    NFS: Create a common read and write header struct
    
    The only difference is the write verifier field, but we can keep that
    for a little bit longer.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index af01b80412dd..b0e7a41d14a8 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -395,7 +395,7 @@ extern int nfs4_get_rootfh(struct nfs_server *server, struct nfs_fh *mntfh, bool
 
 struct nfs_pgio_completion_ops;
 /* read.c */
-extern struct nfs_read_header *nfs_readhdr_alloc(void);
+extern struct nfs_rw_header *nfs_readhdr_alloc(void);
 extern void nfs_readhdr_free(struct nfs_pgio_header *hdr);
 extern void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,
 			struct inode *inode, bool force_mds,
@@ -424,7 +424,7 @@ int nfs_remount(struct super_block *sb, int *flags, char *raw_data);
 extern void nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,
 			struct inode *inode, int ioflags, bool force_mds,
 			const struct nfs_pgio_completion_ops *compl_ops);
-extern struct nfs_write_header *nfs_writehdr_alloc(void);
+extern struct nfs_rw_header *nfs_writehdr_alloc(void);
 extern void nfs_writehdr_free(struct nfs_pgio_header *hdr);
 extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
 			     struct nfs_pgio_header *hdr);

commit 9c7e1b3d50b56b8d8f6237ed232350b7c6476cd5
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:26 2014 -0400

    NFS: Create a common read and write data struct
    
    At this point, the only difference between nfs_read_data and
    nfs_write_data is the write verifier.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 98fe618db2aa..af01b80412dd 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -401,13 +401,13 @@ extern void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,
 			struct inode *inode, bool force_mds,
 			const struct nfs_pgio_completion_ops *compl_ops);
 extern int nfs_initiate_read(struct rpc_clnt *clnt,
-			     struct nfs_read_data *data,
+			     struct nfs_pgio_data *data,
 			     const struct rpc_call_ops *call_ops, int flags);
 extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 extern int nfs_generic_pagein(struct nfs_pageio_descriptor *desc,
 			      struct nfs_pgio_header *hdr);
 extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
-extern void nfs_readdata_release(struct nfs_read_data *rdata);
+extern void nfs_readdata_release(struct nfs_pgio_data *rdata);
 
 /* super.c */
 void nfs_clone_super(struct super_block *, struct nfs_mount_info *);
@@ -429,10 +429,10 @@ extern void nfs_writehdr_free(struct nfs_pgio_header *hdr);
 extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
 			     struct nfs_pgio_header *hdr);
 extern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);
-extern void nfs_writedata_release(struct nfs_write_data *wdata);
+extern void nfs_writedata_release(struct nfs_pgio_data *wdata);
 extern void nfs_commit_free(struct nfs_commit_data *p);
 extern int nfs_initiate_write(struct rpc_clnt *clnt,
-			      struct nfs_write_data *data,
+			      struct nfs_pgio_data *data,
 			      const struct rpc_call_ops *call_ops,
 			      int how, int flags);
 extern void nfs_write_prepare(struct rpc_task *task, void *calldata);
@@ -492,7 +492,7 @@ static inline void nfs_inode_dio_wait(struct inode *inode)
 extern ssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq);
 
 /* nfs4proc.c */
-extern void __nfs4_read_done_cb(struct nfs_read_data *);
+extern void __nfs4_read_done_cb(struct nfs_pgio_data *);
 extern struct nfs_client *nfs4_init_client(struct nfs_client *clp,
 			    const struct rpc_timeout *timeparms,
 			    const char *ip_addr);

commit fab5fc25d230edcc8ee72367e505955a2fae0cac
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Apr 16 15:07:22 2014 +0200

    nfs: remove ->read_pageio_init from rpc ops
    
    The read_pageio_init method is just a very convoluted way to grab the
    right nfs_pageio_ops vector.  The vector to chose is not a choice of
    protocol version, but just a pNFS vs MDS I/O choice that can simply be
    done inside nfs_pageio_init_read based on the presence of a layout
    driver, and a new force_mds flag to the special case of falling back
    to MDS I/O on a pNFS-capable volume.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 8431083de179..98fe618db2aa 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -398,7 +398,7 @@ struct nfs_pgio_completion_ops;
 extern struct nfs_read_header *nfs_readhdr_alloc(void);
 extern void nfs_readhdr_free(struct nfs_pgio_header *hdr);
 extern void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,
-			struct inode *inode,
+			struct inode *inode, bool force_mds,
 			const struct nfs_pgio_completion_ops *compl_ops);
 extern int nfs_initiate_read(struct rpc_clnt *clnt,
 			     struct nfs_read_data *data,

commit a20c93e3160e37ecccc738d8eef085c8507949ed
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Apr 16 15:07:21 2014 +0200

    nfs: remove ->write_pageio_init from rpc ops
    
    The write_pageio_init method is just a very convoluted way to grab the
    right nfs_pageio_ops vector.  The vector to chose is not a choice of
    protocol version, but just a pNFS vs MDS I/O choice that can simply be
    done inside nfs_pageio_init_write based on the presence of a layout
    driver, and a new force_mds flag to the special case of falling back
    to MDS I/O on a pNFS-capable volume.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index dd8bfc2e2464..8431083de179 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -422,7 +422,7 @@ int nfs_remount(struct super_block *sb, int *flags, char *raw_data);
 
 /* write.c */
 extern void nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,
-			struct inode *inode, int ioflags,
+			struct inode *inode, int ioflags, bool force_mds,
 			const struct nfs_pgio_completion_ops *compl_ops);
 extern struct nfs_write_header *nfs_writehdr_alloc(void);
 extern void nfs_writehdr_free(struct nfs_pgio_header *hdr);

commit edaf43694898c5d7deb9a394335c60e888039100
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Apr 3 14:07:25 2014 -0400

    nfs: switch to ->write_iter()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index e598e4a852ad..a5b36fc6b795 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -324,7 +324,7 @@ ssize_t nfs_file_read(struct kiocb *, struct iov_iter *);
 ssize_t nfs_file_splice_read(struct file *, loff_t *, struct pipe_inode_info *,
 			     size_t, unsigned int);
 int nfs_file_mmap(struct file *, struct vm_area_struct *);
-ssize_t nfs_file_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
+ssize_t nfs_file_write(struct kiocb *, struct iov_iter *);
 int nfs_file_release(struct inode *, struct file *);
 int nfs_lock(struct file *, int, struct file_lock *);
 int nfs_flock(struct file *, int, struct file_lock *);

commit 3aa2d199f8eb8149a88005e88736d583cbc39d31
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Apr 2 20:14:12 2014 -0400

    nfs: switch to ->read_iter()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index dd8bfc2e2464..e598e4a852ad 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -320,7 +320,7 @@ int nfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *)
 int nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);
 loff_t nfs_file_llseek(struct file *, loff_t, int);
 int nfs_file_flush(struct file *, fl_owner_t);
-ssize_t nfs_file_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);
+ssize_t nfs_file_read(struct kiocb *, struct iov_iter *);
 ssize_t nfs_file_splice_read(struct file *, loff_t *, struct pipe_inode_info *,
 			     size_t, unsigned int);
 int nfs_file_mmap(struct file *, struct vm_area_struct *);

commit bd0f725c4c0bd77b6d931f63eda2d51423a22d43
Merge: 2ca310fc4160 fdb63dcdb53a
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Mon Mar 17 15:15:21 2014 -0400

    Merge branch 'devel' into linux-next

commit 0e862a405185b28e775eeeae6b04bfa39724b1ad
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Mar 17 07:06:55 2014 -0400

    nfs: make nfs_async_rename non-static
    
    ...and move the prototype for nfs_sillyrename to internal.h.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Tested-by: Anna Schumaker <Anna.Schumaker@netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7f7c476d0c2c..2a81cdb93ec0 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -474,6 +474,13 @@ extern int nfs_migrate_page(struct address_space *,
 #define nfs_migrate_page NULL
 #endif
 
+/* unlink.c */
+extern struct rpc_task *
+nfs_async_rename(struct inode *old_dir, struct inode *new_dir,
+		 struct dentry *old_dentry, struct dentry *new_dentry,
+		 void (*complete)(struct rpc_task *, struct nfs_renamedata *));
+extern int nfs_sillyrename(struct inode *dir, struct dentry *dentry);
+
 /* direct.c */
 void nfs_init_cinfo_from_dreq(struct nfs_commit_info *cinfo,
 			      struct nfs_direct_req *dreq);

commit 292f503cade2b1d966239ef56a851e6897d1ba92
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sun Feb 16 21:42:56 2014 -0500

    NFSv4: Use the correct net namespace in nfs4_update_server
    
    We need to use the same net namespace that was used to resolve
    the hostname and sockaddr arguments.
    
    Fixes: 32e62b7c3ef09 (NFS: Add nfs4_update_server)
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index fafdddac8271..b46cf5a67329 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -176,7 +176,8 @@ extern struct nfs_server *nfs4_create_server(
 extern struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *,
 						      struct nfs_fh *);
 extern int nfs4_update_server(struct nfs_server *server, const char *hostname,
-					struct sockaddr *sap, size_t salen);
+					struct sockaddr *sap, size_t salen,
+					struct net *net);
 extern void nfs_free_server(struct nfs_server *server);
 extern struct nfs_server *nfs_clone_server(struct nfs_server *,
 					   struct nfs_fh *,

commit 311324ad1713666a6e803aecf0d4e1a136a5b34a
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Fri Feb 7 17:02:08 2014 -0500

    NFS: Be more aggressive in using readdirplus for 'ls -l' situations
    
    Try to detect 'ls -l' by having nfs_getattr() look at whether or not
    there is an opendir() file descriptor for the parent directory.
    If so, then assume that we want to force use of readdirplus in order
    to avoid the multiple GETATTR calls over the wire.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index fafdddac8271..7f7c476d0c2c 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -300,6 +300,7 @@ extern struct nfs_client *nfs_init_client(struct nfs_client *clp,
 			   const char *ip_addr);
 
 /* dir.c */
+extern void nfs_force_use_readdirplus(struct inode *dir);
 extern unsigned long nfs_access_cache_count(struct shrinker *shrink,
 					    struct shrink_control *sc);
 extern unsigned long nfs_access_cache_scan(struct shrinker *shrink,

commit fd1defc257e2b12ab69bc0b379105c00eca4e112
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Feb 6 14:38:53 2014 -0500

    NFS: Do not set NFS_INO_INVALID_LABEL unless server supports labeled NFS
    
    Commit aa9c2669626c (NFS: Client implementation of Labeled-NFS) introduces
    a performance regression. When nfs_zap_caches_locked is called, it sets
    the NFS_INO_INVALID_LABEL flag irrespectively of whether or not the
    NFS server supports security labels. Since that flag is never cleared,
    it means that all calls to nfs_revalidate_inode() will now trigger
    an on-the-wire GETATTR call.
    
    This patch ensures that we never set the NFS_INO_INVALID_LABEL unless the
    server advertises support for labeled NFS.
    It also causes nfs_setsecurity() to clear NFS_INO_INVALID_LABEL when it
    has successfully set the security label for the inode.
    Finally it gets rid of the NFS_INO_INVALID_LABEL cruft from nfs_update_inode,
    which has nothing to do with labeled NFS.
    
    Reported-by: Neil Brown <neilb@suse.de>
    Cc: stable@vger.kernel.org # 3.11+
    Tested-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 8b5cc04a8611..fafdddac8271 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -279,9 +279,18 @@ static inline void nfs4_label_free(struct nfs4_label *label)
 	}
 	return;
 }
+
+static inline void nfs_zap_label_cache_locked(struct nfs_inode *nfsi)
+{
+	if (nfs_server_capable(&nfsi->vfs_inode, NFS_CAP_SECURITY_LABEL))
+		nfsi->cache_validity |= NFS_INO_INVALID_LABEL;
+}
 #else
 static inline struct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags) { return NULL; }
 static inline void nfs4_label_free(void *label) {}
+static inline void nfs_zap_label_cache_locked(struct nfs_inode *nfsi)
+{
+}
 #endif /* CONFIG_NFS_V4_SECURITY_LABEL */
 
 /* proc.c */

commit 694e096fd7c2a7d40760fc9c9dfc826bdd495ea4
Author: Anna Schumaker <bjschuma@netapp.com>
Date:   Wed Nov 13 12:29:08 2013 -0500

    NFS: Enabling v4.2 should not recompile nfsd and lockd
    
    When CONFIG_NFS_V4_2 is toggled nfsd and lockd will be recompiled,
    instead of only the nfs client.  This patch moves a small amount of code
    into the client directory to avoid unnecessary recompiles.
    
    Signed-off-by: Anna Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index bca6a3e3c49c..8b5cc04a8611 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -269,6 +269,21 @@ extern const u32 nfs41_maxgetdevinfo_overhead;
 extern struct rpc_procinfo nfs4_procedures[];
 #endif
 
+#ifdef CONFIG_NFS_V4_SECURITY_LABEL
+extern struct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags);
+static inline void nfs4_label_free(struct nfs4_label *label)
+{
+	if (label) {
+		kfree(label->label);
+		kfree(label);
+	}
+	return;
+}
+#else
+static inline struct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags) { return NULL; }
+static inline void nfs4_label_free(void *label) {}
+#endif /* CONFIG_NFS_V4_SECURITY_LABEL */
+
 /* proc.c */
 void nfs_close_context(struct nfs_open_context *ctx, int is_sync);
 extern struct nfs_client *nfs_init_client(struct nfs_client *clp,

commit 4d4b69dd847a098cdca341c45326f6c6f61b8691
Author: Weston Andros Adamson <dros@netapp.com>
Date:   Fri Oct 18 15:15:19 2013 -0400

    NFS: add support for multiple sec= mount options
    
    This patch adds support for multiple security options which can be
    specified using a colon-delimited list of security flavors (the same
    syntax as nfsd's exports file).
    
    This is useful, for instance, when NFSv4.x mounts cross SECINFO
    boundaries. With this patch a user can use "sec=krb5i,krb5p"
    to mount a remote filesystem using krb5i, but can still cross
    into krb5p-only exports.
    
    New mounts will try all security options before failing.  NFSv4.x
    SECINFO results will be compared against the sec= flavors to
    find the first flavor in both lists or if no match is found will
    return -EPERM.
    
    Signed-off-by: Weston Andros Adamson <dros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index c8cd044f0982..bca6a3e3c49c 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -326,6 +326,7 @@ extern struct file_system_type nfs_xdev_fs_type;
 extern struct file_system_type nfs4_xdev_fs_type;
 extern struct file_system_type nfs4_referral_fs_type;
 #endif
+bool nfs_auth_info_match(const struct nfs_auth_info *, rpc_authflavor_t);
 struct dentry *nfs_try_mount(int, const char *, struct nfs_mount_info *,
 			struct nfs_subversion *);
 void nfs_initialise_sb(struct super_block *);

commit a3f73c27afff9590a4432879b7145289cb89cf0a
Author: Weston Andros Adamson <dros@netapp.com>
Date:   Fri Oct 18 15:15:16 2013 -0400

    NFS: separate passed security flavs from selected
    
    When filling parsed_mount_data, store the parsed sec= mount option in
    the new struct nfs_auth_info and the chosen flavor in selected_flavor.
    
    This patch lays the groundwork for supporting multiple sec= options.
    
    Signed-off-by: Weston Andros Adamson <dros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index e5a6bd12562a..c8cd044f0982 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -88,8 +88,8 @@ struct nfs_parsed_mount_data {
 	unsigned int		namlen;
 	unsigned int		options;
 	unsigned int		bsize;
-	unsigned int		auth_flavor_len;
-	rpc_authflavor_t	auth_flavors[1];
+	struct nfs_auth_info	auth_info;
+	rpc_authflavor_t	selected_flavor;
 	char			*client_address;
 	unsigned int		version;
 	unsigned int		minorversion;

commit 32e62b7c3ef095eccbb6a8c96fddf05dacc749df
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Oct 17 14:12:28 2013 -0400

    NFS: Add nfs4_update_server
    
    New function nfs4_update_server() moves an nfs_server to a different
    nfs_client.  This is done as part of migration recovery.
    
    Though it may be appealing to think of them as the same thing,
    migration recovery is not the same as following a referral.
    
    For a referral, the client has not descended into the file system
    yet: it has no nfs_server, no super block, no inodes or open state.
    It is enough to simply instantiate the nfs_server and super block,
    and perform a referral mount.
    
    For a migration, however, we have all of those things already, and
    they have to be moved to a different nfs_client.  No local namespace
    changes are needed here.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 38da8c2b81ac..e5a6bd12562a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -154,6 +154,7 @@ struct nfs_client *nfs_get_client(const struct nfs_client_initdata *,
 				  rpc_authflavor_t);
 int nfs_probe_fsinfo(struct nfs_server *server, struct nfs_fh *, struct nfs_fattr *);
 void nfs_server_insert_lists(struct nfs_server *);
+void nfs_server_remove_lists(struct nfs_server *);
 void nfs_init_timeout_values(struct rpc_timeout *, int, unsigned int, unsigned int);
 int nfs_init_server_rpcclient(struct nfs_server *, const struct rpc_timeout *t,
 		rpc_authflavor_t);
@@ -174,6 +175,8 @@ extern struct nfs_server *nfs4_create_server(
 					struct nfs_subversion *);
 extern struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *,
 						      struct nfs_fh *);
+extern int nfs4_update_server(struct nfs_server *server, const char *hostname,
+					struct sockaddr *sap, size_t salen);
 extern void nfs_free_server(struct nfs_server *server);
 extern struct nfs_server *nfs_clone_server(struct nfs_server *,
 					   struct nfs_fh *,

commit 1ab6c4997e04a00c50c6d786c2f046adc0d1f5de
Author: Dave Chinner <dchinner@redhat.com>
Date:   Wed Aug 28 10:18:09 2013 +1000

    fs: convert fs shrinkers to new scan/count API
    
    Convert the filesystem shrinkers to use the new API, and standardise some
    of the behaviours of the shrinkers at the same time.  For example,
    nr_to_scan means the number of objects to scan, not the number of objects
    to free.
    
    I refactored the CIFS idmap shrinker a little - it really needs to be
    broken up into a shrinker per tree and keep an item count with the tree
    root so that we don't need to walk the tree every time the shrinker needs
    to count the number of objects in the tree (i.e.  all the time under
    memory pressure).
    
    [glommer@openvz.org: fixes for ext4, ubifs, nfs, cifs and glock. Fixes are needed mainly due to new code merged in the tree]
    [assorted fixes folded in]
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Glauber Costa <glommer@openvz.org>
    Acked-by: Mel Gorman <mgorman@suse.de>
    Acked-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Acked-by: Jan Kara <jack@suse.cz>
    Acked-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Cc: Arve Hjønnevåg <arve@android.com>
    Cc: Carlos Maiolino <cmaiolino@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Gleb Natapov <gleb@redhat.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: J. Bruce Fields <bfields@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Kent Overstreet <koverstreet@google.com>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index d388302c005f..38da8c2b81ac 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -273,8 +273,10 @@ extern struct nfs_client *nfs_init_client(struct nfs_client *clp,
 			   const char *ip_addr);
 
 /* dir.c */
-extern int nfs_access_cache_shrinker(struct shrinker *shrink,
-					struct shrink_control *sc);
+extern unsigned long nfs_access_cache_count(struct shrinker *shrink,
+					    struct shrink_control *sc);
+extern unsigned long nfs_access_cache_scan(struct shrinker *shrink,
+					   struct shrink_control *sc);
 struct dentry *nfs_lookup(struct inode *, struct dentry *, unsigned int);
 int nfs_create(struct inode *, struct dentry *, umode_t, bool);
 int nfs_mkdir(struct inode *, struct dentry *, umode_t);

commit 5e6b19901b763f502e62b5fd4f583778df983ce7
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Sep 7 12:58:57 2013 -0400

    NFSv4: Fix security auto-negotiation
    
    NFSv4 security auto-negotiation has been broken since
    commit 4580a92d44e2b21c2254fa5fef0f1bfb43c82318 (NFS:
    Use server-recommended security flavor by default (NFSv3))
    because nfs4_try_mount() will automatically select AUTH_SYS
    if it sees no auth flavours.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Chuck Lever <chuck.lever@oracle.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 23ec6e8e8a4d..d388302c005f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -358,7 +358,7 @@ extern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *,
 extern struct dentry *nfs4_get_root(struct super_block *, struct nfs_fh *,
 				    const char *);
 
-extern int nfs4_get_rootfh(struct nfs_server *server, struct nfs_fh *mntfh);
+extern int nfs4_get_rootfh(struct nfs_server *server, struct nfs_fh *mntfh, bool);
 #endif
 
 struct nfs_pgio_completion_ops;

commit 0e20162ed1e9a639fc61d62c71327169fb1a1970
Author: Andy Adamson <andros@netapp.com>
Date:   Fri Sep 6 14:14:00 2013 -0400

    NFSv4.1 Use MDS auth flavor for data server connection
    
    Commit 4edaa308 "NFS: Use "krb5i" to establish NFSv4 state whenever possible"
    uses the nfs_client cl_rpcclient for all state management operations, and
    will use krb5i or auth_sys with no regard to the mount command authflavor
    choice.
    
    The MDS, as any NFSv4.1 mount point, uses the nfs_server rpc client for all
    non-state management operations with a different nfs_server for each fsid
    encountered traversing the mount point, each with a potentially different
    auth flavor.
    
    pNFS data servers are not mounted in the normal sense as there is no associated
    nfs_server structure. Data servers can also export multiple fsids, each with
    a potentially different auth flavor.
    
    Data servers need to use the same authflavor as the MDS server rpc client for
    non-state management operations. Populate a list of rpc clients with the MDS
    server rpc client auth flavor for the DS to use.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 2415198d29ad..23ec6e8e8a4d 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -186,6 +186,8 @@ extern struct nfs_client *nfs4_set_ds_client(struct nfs_client* mds_clp,
 					     int ds_addrlen, int ds_proto,
 					     unsigned int ds_timeo,
 					     unsigned int ds_retrans);
+extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,
+						struct inode *);
 #ifdef CONFIG_PROC_FS
 extern int __init nfs_fs_proc_init(void);
 extern void nfs_fs_proc_exit(void);

commit dc24826bfca8d788d05f625208f06d90be5560b3
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Aug 14 11:59:16 2013 -0400

    NFS avoid expired credential keys for buffered writes
    
    We must avoid buffering a WRITE that is using a credential key (e.g. a GSS
    context key) that is about to expire or has expired.  We currently will
    paint ourselves into a corner by returning success to the applciation
    for such a buffered WRITE, only to discover that we do not have permission when
    we attempt to flush the WRITE (and potentially associated COMMIT) to disk.
    
    Use the RPC layer credential key timeout and expire routines which use a
    a watermark, gss_key_expire_timeo. We test the key in nfs_file_write.
    
    If a WRITE is using a credential with a key that will expire within
    watermark seconds, flush the inode in nfs_write_end and send only
    NFS_FILE_SYNC WRITEs by adding nfs_ctx_key_to_expire to nfs_need_sync_write.
    Note that this results in single page NFS_FILE_SYNC WRITEs.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    [Trond: removed a pr_warn_ratelimited() for now]
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 50f7068903b9..2415198d29ad 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -431,6 +431,8 @@ void nfs_request_remove_commit_list(struct nfs_page *req,
 void nfs_init_cinfo(struct nfs_commit_info *cinfo,
 		    struct inode *inode,
 		    struct nfs_direct_req *dreq);
+int nfs_key_timeout_notify(struct file *filp, struct inode *inode);
+bool nfs_ctx_key_to_expire(struct nfs_open_context *ctx);
 
 #ifdef CONFIG_MIGRATION
 extern int nfs_migrate_page(struct address_space *,

commit 1264a2f053a32376696e51184f086d35113e75ff
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Aug 12 16:06:31 2013 -0400

    NFS: refactor code for calculating the crc32 hash of a filehandle
    
    We want to be able to display the crc32 hash of the filehandle in
    tracepoints.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 9b694f1e06c5..50f7068903b9 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -5,6 +5,7 @@
 #include "nfs4_fs.h"
 #include <linux/mount.h>
 #include <linux/security.h>
+#include <linux/crc32.h>
 
 #define NFS_MS_MASK (MS_RDONLY|MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_SYNCHRONOUS)
 
@@ -574,3 +575,22 @@ u64 nfs_timespec_to_change_attr(const struct timespec *ts)
 {
 	return ((u64)ts->tv_sec << 30) + ts->tv_nsec;
 }
+
+#ifdef CONFIG_CRC32
+/**
+ * nfs_fhandle_hash - calculate the crc32 hash for the filehandle
+ * @fh - pointer to filehandle
+ *
+ * returns a crc32 hash for the filehandle that is compatible with
+ * the one displayed by "wireshark".
+ */
+static inline u32 nfs_fhandle_hash(const struct nfs_fh *fh)
+{
+	return ~crc32_le(0xFFFFFFFF, &fh->data[0], fh->size);
+}
+#else
+static inline u32 nfs_fhandle_hash(const struct nfs_fh *fh)
+{
+	return 0;
+}
+#endif

commit f8407299f61681e9733f06c7214e81002cb459b3
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Jul 24 11:59:49 2013 -0400

    NFS Remove unused authflavour parameter from init_client
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 3c8373f90ab3..9b694f1e06c5 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -267,7 +267,7 @@ extern struct rpc_procinfo nfs4_procedures[];
 void nfs_close_context(struct nfs_open_context *ctx, int is_sync);
 extern struct nfs_client *nfs_init_client(struct nfs_client *clp,
 			   const struct rpc_timeout *timeparms,
-			   const char *ip_addr, rpc_authflavor_t authflavour);
+			   const char *ip_addr);
 
 /* dir.c */
 extern int nfs_access_cache_shrinker(struct shrinker *shrink,
@@ -451,8 +451,7 @@ extern ssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq);
 extern void __nfs4_read_done_cb(struct nfs_read_data *);
 extern struct nfs_client *nfs4_init_client(struct nfs_client *clp,
 			    const struct rpc_timeout *timeparms,
-			    const char *ip_addr,
-			    rpc_authflavor_t authflavour);
+			    const char *ip_addr);
 extern int nfs40_walk_client_list(struct nfs_client *clp,
 				struct nfs_client **result,
 				struct rpc_cred *cred);

commit 959d921f5eb8878ea16049a7f6e9bcbb6dfbcb88
Merge: f112bb48994e 7017310ad737
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Jun 28 16:29:51 2013 -0400

    Merge branch 'labeled-nfs' into linux-next
    
    * labeled-nfs:
      NFS: Apply v4.1 capabilities to v4.2
      NFS: Add in v4.2 callback operation
      NFS: Make callbacks minor version generic
      Kconfig: Add Kconfig entry for Labeled NFS V4 client
      NFS: Extend NFS xattr handlers to accept the security namespace
      NFS: Client implementation of Labeled-NFS
      NFS: Add label lifecycle management
      NFS:Add labels to client function prototypes
      NFSv4: Extend fattr bitmaps to support all 3 words
      NFSv4: Introduce new label structure
      NFSv4: Add label recommended attribute and NFSv4 flags
      NFSv4.2: Added NFS v4.2 support to the NFS client
      SELinux: Add new labeling type native labels
      LSM: Add flags field to security_sb_set_mnt_opts for in kernel mount data.
      Security: Add Hook to test if the particular xattr is part of a MAC model.
      Security: Add hook to calculate context based on a negative dentry.
      NFS: Add NFSv4.2 protocol constants
    
    Conflicts:
            fs/nfs/nfs4proc.c

commit f1c097be2b35dcfc06c1c591194d78058dd67284
Author: Andy Adamson <andros@netapp.com>
Date:   Tue Jun 25 19:02:53 2013 -0400

    NFSv4.1 Fix gdia_maxcount calculation to fit in ca_maxresponsesize
    
    The GETDEVICEINFO gdia_maxcount represents all of the data being returned
    within the GETDEVICEINFO4resok structure and includes the XDR overhead.
    
    The CREATE_SESSION ca_maxresponsesize is the maximum reply and includes the RPC
    headers (including security flavor credentials and verifiers).
    
    Split out the struct pnfs_device field maxcount which is the gdia_maxcount
    from the pglen field which is the reply (the total) buffer length.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 91e59a39fc08..4bd53f4e0fd2 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -255,6 +255,7 @@ extern int nfs4_decode_dirent(struct xdr_stream *,
 #ifdef CONFIG_NFS_V4_1
 extern const u32 nfs41_maxread_overhead;
 extern const u32 nfs41_maxwrite_overhead;
+extern const u32 nfs41_maxgetdevinfo_overhead;
 #endif
 
 /* nfs4proc.c */

commit 459de2edb9105a5d091f8215650e12c0812d59f3
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Wed Jun 5 11:15:01 2013 -0400

    NFS: Make callbacks minor version generic
    
    I found a few places that hardcode the minor version number rather than
    making it dependent on the protocol the callback came in over.  This
    patch makes it easier to add new minor versions in the future.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 91e59a39fc08..97ec2ef6a220 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -165,7 +165,7 @@ extern void nfs_free_client(struct nfs_client *);
 extern struct nfs_client *nfs4_find_client_ident(struct net *, int);
 extern struct nfs_client *
 nfs4_find_client_sessionid(struct net *, const struct sockaddr *,
-				struct nfs4_sessionid *);
+				struct nfs4_sessionid *, u32);
 extern struct nfs_server *nfs_create_server(struct nfs_mount_info *,
 					struct nfs_subversion *);
 extern struct nfs_server *nfs4_create_server(

commit 577b42327d707fbe7166aad6902c2eeee6a65015
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Apr 8 21:38:12 2013 -0400

    NFS: Add functionality to allow waiting on all outstanding reads to complete
    
    This will later allow NFS locking code to wait for readahead to complete
    before releasing byte range locks.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 541c9ebdbc5a..91e59a39fc08 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -229,6 +229,13 @@ extern void nfs_pgheader_init(struct nfs_pageio_descriptor *desc,
 			      struct nfs_pgio_header *hdr,
 			      void (*release)(struct nfs_pgio_header *hdr));
 void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos);
+int nfs_iocounter_wait(struct nfs_io_counter *c);
+
+static inline void nfs_iocounter_init(struct nfs_io_counter *c)
+{
+	c->flags = 0;
+	atomic_set(&c->io_count, 0);
+}
 
 /* nfs2xdr.c */
 extern struct rpc_procinfo nfs_procedures[];

commit 322b2b9032f4beba6f1c4158852a5a5b9ab841d7
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Jan 11 16:39:51 2013 -0500

    Revert "NFS: add nfs_sb_deactive_async to avoid deadlock"
    
    This reverts commit 324d003b0cd82151adbaecefef57b73f7959a469.
    
    The deadlock turned out to be caused by a workqueue limitation that has
    now been worked around in the RPC code (see comment in rpc_free_task).
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index f0e6c7df1a07..541c9ebdbc5a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -329,7 +329,6 @@ extern int __init register_nfs_fs(void);
 extern void __exit unregister_nfs_fs(void);
 extern void nfs_sb_active(struct super_block *sb);
 extern void nfs_sb_deactive(struct super_block *sb);
-extern void nfs_sb_deactive_async(struct super_block *sb);
 
 /* namespace.c */
 #define NFS_PATH_CANONICAL 1

commit eed9935745cc44071043ec8c4cde64c820b5c601
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Dec 14 14:36:36 2012 -0500

    NFS: Ensure that we always drop inodes that have been marked as stale
    
    There is no need to cache stale inodes.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 89c1ee4a432c..f0e6c7df1a07 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -296,6 +296,7 @@ extern struct workqueue_struct *nfsiod_workqueue;
 extern struct inode *nfs_alloc_inode(struct super_block *sb);
 extern void nfs_destroy_inode(struct inode *);
 extern int nfs_write_inode(struct inode *, struct writeback_control *);
+extern int nfs_drop_inode(struct inode *);
 extern void nfs_clear_inode(struct inode *);
 extern void nfs_evict_inode(struct inode *);
 void nfs_zap_acl_cache(struct inode *inode);

commit aaea7d2f78d008882524eddff0d78098c8fa9496
Author: Yanchuan Nian <ycnian@gmail.com>
Date:   Thu Dec 13 14:37:34 2012 +0800

    nfs: Remove duplicate function declaration in internal.h
    
    Remove duplicate function declaration in internal.h
    
    Signed-off-by: Yanchuan Nian <ycnian@gmail.com>
    [Trond: Added nfs_pageio_init_read, which suffered from the same problem]
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index fb994471bd32..89c1ee4a432c 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -363,9 +363,6 @@ extern int nfs_initiate_read(struct rpc_clnt *clnt,
 extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 extern int nfs_generic_pagein(struct nfs_pageio_descriptor *desc,
 			      struct nfs_pgio_header *hdr);
-extern void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,
-			struct inode *inode,
-			const struct nfs_pgio_completion_ops *compl_ops);
 extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_readdata_release(struct nfs_read_data *rdata);
 
@@ -388,9 +385,6 @@ extern struct nfs_write_header *nfs_writehdr_alloc(void);
 extern void nfs_writehdr_free(struct nfs_pgio_header *hdr);
 extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
 			     struct nfs_pgio_header *hdr);
-extern void nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,
-			struct inode *inode, int ioflags,
-			const struct nfs_pgio_completion_ops *compl_ops);
 extern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_writedata_release(struct nfs_write_data *wdata);
 extern void nfs_commit_free(struct nfs_commit_data *p);

commit fd0c09537a8494e9dccf3856b90058e1f97f1d62
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Nov 1 14:43:38 2012 -0400

    NFSv4: Simplify the NFSv4/v4.1 synchronous call switch
    
    We shouldn't need to pass the 'cache_reply' parameter if we
    initialise the sequence_args/sequence_res in the caller.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 9bdbfc3884a9..fb994471bd32 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -451,18 +451,6 @@ extern struct nfs_client *nfs4_init_client(struct nfs_client *clp,
 			    const struct rpc_timeout *timeparms,
 			    const char *ip_addr,
 			    rpc_authflavor_t authflavour);
-extern int _nfs4_call_sync(struct rpc_clnt *clnt,
-			   struct nfs_server *server,
-			   struct rpc_message *msg,
-			   struct nfs4_sequence_args *args,
-			   struct nfs4_sequence_res *res,
-			   int cache_reply);
-extern int _nfs4_call_sync_session(struct rpc_clnt *clnt,
-				   struct nfs_server *server,
-				   struct rpc_message *msg,
-				   struct nfs4_sequence_args *args,
-				   struct nfs4_sequence_res *res,
-				   int cache_reply);
 extern int nfs40_walk_client_list(struct nfs_client *clp,
 				struct nfs_client **result,
 				struct rpc_cred *cred);

commit 76e697ba7e8d187f50e385d21a2b2f1709a62c14
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Nov 26 14:20:49 2012 -0500

    NFSv4.1: Move slot table and session struct definitions to nfs4session.h
    
    Clean up. Gather NFSv4.1 slot definitions in fs/nfs/nfs4session.h.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 8965a998b306..9bdbfc3884a9 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -18,27 +18,6 @@ struct nfs_string;
  */
 #define NFS_MAX_READAHEAD	(RPC_DEF_SLOT_TABLE - 1)
 
-/*
- * Determine if sessions are in use.
- */
-static inline int nfs4_has_session(const struct nfs_client *clp)
-{
-#ifdef CONFIG_NFS_V4_1
-	if (clp->cl_session)
-		return 1;
-#endif /* CONFIG_NFS_V4_1 */
-	return 0;
-}
-
-static inline int nfs4_has_persistent_session(const struct nfs_client *clp)
-{
-#ifdef CONFIG_NFS_V4_1
-	if (nfs4_has_session(clp))
-		return (clp->cl_session->flags & SESSION4_PERSIST);
-#endif /* CONFIG_NFS_V4_1 */
-	return 0;
-}
-
 static inline void nfs_attr_check_mountpoint(struct super_block *parent, struct nfs_fattr *fattr)
 {
 	if (!nfs_fsid_equal(&NFS_SB(parent)->fsid, &fattr->fsid))

commit 73e39aaa8366694450cd6034050f542f965e277d
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Nov 26 12:49:34 2012 -0500

    NFSv4.1: Cleanup move session slot management to fs/nfs/nfs4session.c
    
    NFSv4.1 session management is getting complex enough to deserve
    a separate file.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 05521cadac2e..8965a998b306 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -276,8 +276,6 @@ extern const u32 nfs41_maxwrite_overhead;
 extern struct rpc_procinfo nfs4_procedures[];
 #endif
 
-extern int nfs4_init_ds_session(struct nfs_client *, unsigned long);
-
 /* proc.c */
 void nfs_close_context(struct nfs_open_context *ctx, int is_sync);
 extern struct nfs_client *nfs_init_client(struct nfs_client *clp,

commit 324d003b0cd82151adbaecefef57b73f7959a469
Author: Weston Andros Adamson <dros@netapp.com>
Date:   Tue Oct 30 17:01:39 2012 -0400

    NFS: add nfs_sb_deactive_async to avoid deadlock
    
    Use nfs_sb_deactive_async instead of nfs_sb_deactive when in a workqueue
    context.  This avoids a deadlock where rpc_shutdown_client loops forever
    in a workqueue kworker context, trying to kill all RPC tasks associated with
    the client, while one or more of these tasks have already been assigned to the
    same kworker (and will never run rpc_exit_task).
    
    This approach is needed because RPC tasks that have already been assigned
    to a kworker by queue_work cannot be canceled, as explained in the comment
    for workqueue.c:insert_wq_barrier.
    
    Signed-off-by: Weston Andros Adamson <dros@netapp.com>
    [Trond: add module_get/put.]
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index a54fe51c1dfb..05521cadac2e 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -351,6 +351,7 @@ extern int __init register_nfs_fs(void);
 extern void __exit unregister_nfs_fs(void);
 extern void nfs_sb_active(struct super_block *sb);
 extern void nfs_sb_deactive(struct super_block *sb);
+extern void nfs_sb_deactive_async(struct super_block *sb);
 
 /* namespace.c */
 #define NFS_PATH_CANONICAL 1

commit 97a54868262da1629a3e65121e65b8e8c4419d9f
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Sun Oct 21 19:23:52 2012 +0100

    nfs: Show original device name verbatim in /proc/*/mount{s,info}
    
    Since commit c7f404b ('vfs: new superblock methods to override
    /proc/*/mount{s,info}'), nfs_path() is used to generate the mounted
    device name reported back to userland.
    
    nfs_path() always generates a trailing slash when the given dentry is
    the root of an NFS mount, but userland may expect the original device
    name to be returned verbatim (as it used to be).  Make this
    canonicalisation optional and change the callers accordingly.
    
    [jrnieder@gmail.com: use flag instead of bool argument]
    Reported-and-tested-by: Chris Hiestand <chiestand@salk.edu>
    Reference: http://bugs.debian.org/669314
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Cc: <stable@vger.kernel.org> # v2.6.39+
    Signed-off-by: Jonathan Nieder <jrnieder@gmail.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 59b133c5d652..a54fe51c1dfb 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -353,8 +353,9 @@ extern void nfs_sb_active(struct super_block *sb);
 extern void nfs_sb_deactive(struct super_block *sb);
 
 /* namespace.c */
+#define NFS_PATH_CANONICAL 1
 extern char *nfs_path(char **p, struct dentry *dentry,
-		      char *buffer, ssize_t buflen);
+		      char *buffer, ssize_t buflen, unsigned flags);
 extern struct vfsmount *nfs_d_automount(struct path *path);
 struct vfsmount *nfs_submount(struct nfs_server *, struct dentry *,
 			      struct nfs_fh *, struct nfs_fattr *);
@@ -498,7 +499,7 @@ static inline char *nfs_devname(struct dentry *dentry,
 				char *buffer, ssize_t buflen)
 {
 	char *dummy;
-	return nfs_path(&dummy, dentry, buffer, buflen);
+	return nfs_path(&dummy, dentry, buffer, buflen, NFS_PATH_CANONICAL);
 }
 
 /*

commit 6296556f0b31eaff29f2a3aee2c17b7eae895b98
Author: Peng Tao <bergwolf@gmail.com>
Date:   Tue Sep 25 14:55:57 2012 +0800

    NFS41: send real write size in layoutget
    
    For buffer write, block layout client scan inode mapping to find
    next hole and use offset-to-hole as layoutget length. Object
    layout client uses offset-to-isize as layoutget length.
    
    For direct write, both block layout and object layout use dreq->bytes_left.
    
    Signed-off-by: Peng Tao <tao.peng@emc.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 89a795dc3027..59b133c5d652 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -464,6 +464,7 @@ static inline void nfs_inode_dio_wait(struct inode *inode)
 {
 	inode_dio_wait(inode);
 }
+extern ssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq);
 
 /* nfs4proc.c */
 extern void __nfs4_read_done_cb(struct nfs_read_data *);

commit 05f4c350ee02e9461c6ae3a880ea326a06835e37
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri Sep 14 17:24:32 2012 -0400

    NFS: Discover NFSv4 server trunking when mounting
    
    "Server trunking" is a fancy named for a multi-homed NFS server.
    Trunking might occur if a client sends NFS requests for a single
    workload to multiple network interfaces on the same server.  There
    are some implications for NFSv4 state management that make it useful
    for a client to know if a single NFSv4 server instance is
    multi-homed.  (Note this is only a consideration for NFSv4, not for
    legacy versions of NFS, which are stateless).
    
    If a client cares about server trunking, no NFSv4 operations can
    proceed until that client determines who it is talking to.  Thus
    server IP trunking discovery must be done when the client first
    encounters an unfamiliar server IP address.
    
    The nfs_get_client() function walks the nfs_client_list and matches
    on server IP address.  The outcome of that walk tells us immediately
    if we have an unfamiliar server IP address.  It invokes
    nfs_init_client() in this case.  Thus, nfs4_init_client() is a good
    spot to perform trunking discovery.
    
    Discovery requires a client to establish a fresh client ID, so our
    client will now send SETCLIENTID or EXCHANGE_ID as the first NFS
    operation after a successful ping, rather than waiting for an
    application to perform an operation that requires NFSv4 state.
    
    The exact process for detecting trunking is different for NFSv4.0 and
    NFSv4.1, so a minorversion-specific init_client callout method is
    introduced.
    
    CLID_INUSE recovery is important for the trunking discovery process.
    CLID_INUSE is a sign the server recognizes the client's nfs_client_id4
    id string, but the client is using the wrong principal this time for
    the SETCLIENTID operation.  The SETCLIENTID must be retried with a
    series of different principals until one works, and then the rest of
    trunking discovery can proceed.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 89560be07e4a..89a795dc3027 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -483,6 +483,12 @@ extern int _nfs4_call_sync_session(struct rpc_clnt *clnt,
 				   struct nfs4_sequence_args *args,
 				   struct nfs4_sequence_res *res,
 				   int cache_reply);
+extern int nfs40_walk_client_list(struct nfs_client *clp,
+				struct nfs_client **result,
+				struct rpc_cred *cred);
+extern int nfs41_walk_client_list(struct nfs_client *clp,
+				struct nfs_client **result,
+				struct rpc_cred *cred);
 
 /*
  * Determine the device name as a string

commit 8cb7f74eeeb5441811d93f94b6138d4a5a9d8b20
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri Sep 14 17:23:14 2012 -0400

    NFS: nfs_parsed_mount_options can use unsigned int
    
    fs/nfs/super.c: In function ‘nfs_compare_remount_data’:
    fs/nfs/super.c:2042:18: warning: comparison between signed and
        unsigned integer expressions [-Wsign-compare]
    fs/nfs/super.c:2043:18: warning: comparison between signed and
        unsigned integer expressions [-Wsign-compare]
    fs/nfs/super.c:2044:20: warning: comparison between signed and
        unsigned integer expressions [-Wsign-compare]
    fs/nfs/super.c:2046:21: warning: comparison between signed and
        unsigned integer expressions [-Wsign-compare]
    fs/nfs/super.c:2047:21: warning: comparison between signed and
        unsigned integer expressions [-Wsign-compare]
    fs/nfs/super.c:2048:21: warning: comparison between signed and
        unsigned integer expressions [-Wsign-compare]
    fs/nfs/super.c:2049:21: warning: comparison between signed and
        unsigned integer expressions [-Wsign-compare]
    fs/nfs/super.c:2050:18: warning: comparison between signed and
        unsigned integer expressions [-Wsign-compare]
    
    Seen with gcc (GCC) 4.6.3 20120306 (Red Hat 4.6.3-2).
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 31fdb03225cd..89560be07e4a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -101,11 +101,11 @@ struct nfs_client_initdata {
  */
 struct nfs_parsed_mount_data {
 	int			flags;
-	int			rsize, wsize;
-	int			timeo, retrans;
-	int			acregmin, acregmax,
+	unsigned int		rsize, wsize;
+	unsigned int		timeo, retrans;
+	unsigned int		acregmin, acregmax,
 				acdirmin, acdirmax;
-	int			namlen;
+	unsigned int		namlen;
 	unsigned int		options;
 	unsigned int		bsize;
 	unsigned int		auth_flavor_len;

commit ac694dbdbc403c00e2c14d10bc7b8412cc378259
Merge: a40a1d3d0a2f 437ea90cc3af
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 31 19:25:39 2012 -0700

    Merge branch 'akpm' (Andrew's patch-bomb)
    
    Merge Andrew's second set of patches:
     - MM
     - a few random fixes
     - a couple of RTC leftovers
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (120 commits)
      rtc/rtc-88pm80x: remove unneed devm_kfree
      rtc/rtc-88pm80x: assign ret only when rtc_register_driver fails
      mm: hugetlbfs: close race during teardown of hugetlbfs shared page tables
      tmpfs: distribute interleave better across nodes
      mm: remove redundant initialization
      mm: warn if pg_data_t isn't initialized with zero
      mips: zero out pg_data_t when it's allocated
      memcg: gix memory accounting scalability in shrink_page_list
      mm/sparse: remove index_init_lock
      mm/sparse: more checks on mem_section number
      mm/sparse: optimize sparse_index_alloc
      memcg: add mem_cgroup_from_css() helper
      memcg: further prevent OOM with too many dirty pages
      memcg: prevent OOM with too many dirty pages
      mm: mmu_notifier: fix freed page still mapped in secondary MMU
      mm: memcg: only check anon swapin page charges for swap cache
      mm: memcg: only check swap cache pages for repeated charging
      mm: memcg: split swapin charge function into private and public part
      mm: memcg: remove needless !mm fixup to init_mm when charging
      mm: memcg: remove unneeded shmem charge type
      ...

commit d56b4ddf7781ef8dd050542781cc7f55673af002
Author: Mel Gorman <mgorman@suse.de>
Date:   Tue Jul 31 16:45:06 2012 -0700

    nfs: teach the NFS client how to treat PG_swapcache pages
    
    Replace all relevant occurences of page->index and page->mapping in the
    NFS client with the new page_file_index() and page_file_mapping()
    functions.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Acked-by: Rik van Riel <riel@redhat.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Eric B Munson <emunson@mgebm.net>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Mike Christie <michaelc@cs.wisc.edu>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Xiaotian Feng <dfeng@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index cfafd13b6fe9..4be14b3e0a18 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -546,13 +546,14 @@ void nfs_super_set_maxbytes(struct super_block *sb, __u64 maxfilesize)
 static inline
 unsigned int nfs_page_length(struct page *page)
 {
-	loff_t i_size = i_size_read(page->mapping->host);
+	loff_t i_size = i_size_read(page_file_mapping(page)->host);
 
 	if (i_size > 0) {
+		pgoff_t page_index = page_file_index(page);
 		pgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;
-		if (page->index < end_index)
+		if (page_index < end_index)
 			return PAGE_CACHE_SIZE;
-		if (page->index == end_index)
+		if (page_index == end_index)
 			return ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;
 	}
 	return 0;

commit 89d77c8fa8e6d1cb7e2cce95b428be30ddcc6f23
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 30 16:05:25 2012 -0400

    NFS: Convert v4 into a module
    
    This patch exports symbols needed by the v4 module.  In addition, I also
    switch over to using IS_ENABLED() to check if CONFIG_NFS_V4 or
    CONFIG_NFS_V4_MODULE are set.
    
    The module (nfs4.ko) will be created in the same directory as nfs.ko and
    will be automatically loaded the first time you try to mount over NFS v4.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 64f0dc41a9b7..8865538b26b6 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -262,7 +262,7 @@ extern int nfs3_decode_dirent(struct xdr_stream *,
 				struct nfs_entry *, int);
 
 /* nfs4xdr.c */
-#ifdef CONFIG_NFS_V4
+#if IS_ENABLED(CONFIG_NFS_V4)
 extern int nfs4_decode_dirent(struct xdr_stream *,
 				struct nfs_entry *, int);
 #endif
@@ -272,7 +272,7 @@ extern const u32 nfs41_maxwrite_overhead;
 #endif
 
 /* nfs4proc.c */
-#ifdef CONFIG_NFS_V4
+#if IS_ENABLED(CONFIG_NFS_V4)
 extern struct rpc_procinfo nfs4_procedures[];
 #endif
 
@@ -328,7 +328,7 @@ extern int nfs_wait_bit_killable(void *word);
 extern const struct super_operations nfs_sops;
 extern struct file_system_type nfs_fs_type;
 extern struct file_system_type nfs_xdev_fs_type;
-#ifdef CONFIG_NFS_V4
+#if IS_ENABLED(CONFIG_NFS_V4)
 extern struct file_system_type nfs4_xdev_fs_type;
 extern struct file_system_type nfs4_referral_fs_type;
 #endif
@@ -364,7 +364,7 @@ struct vfsmount *nfs_do_submount(struct dentry *, struct nfs_fh *,
 /* getroot.c */
 extern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *,
 				   const char *);
-#ifdef CONFIG_NFS_V4
+#if IS_ENABLED(CONFIG_NFS_V4)
 extern struct dentry *nfs4_get_root(struct super_block *, struct nfs_fh *,
 				    const char *);
 

commit 1c606fb74c758beafd98cbad9a9133eadeec2371
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 30 16:05:24 2012 -0400

    NFS: Convert v3 into a module
    
    This patch exports symbols and moves over the final structures needed by
    the v3 module.  In addition, I also switch over to using IS_ENABLED() to
    check if CONFIG_NFS_V3 or CONFIG_NFS_V3_MODULE are set.
    
    The module (nfs3.ko) will be created in the same directory as nfs.ko and
    will be automatically loaded the first time you try to mount over NFS v3.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 4174faf73ec1..64f0dc41a9b7 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -224,7 +224,7 @@ int nfs_sockaddr_match_ipaddr(const struct sockaddr *, const struct sockaddr *);
 #endif
 
 /* nfs3client.c */
-#ifdef CONFIG_NFS_V3
+#if IS_ENABLED(CONFIG_NFS_V3)
 struct nfs_server *nfs3_create_server(struct nfs_mount_info *, struct nfs_subversion *);
 struct nfs_server *nfs3_clone_server(struct nfs_server *, struct nfs_fh *,
 				     struct nfs_fattr *, rpc_authflavor_t);

commit 19d87ca3623956494b517f3abe0caf2616d55457
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 30 16:05:21 2012 -0400

    NFS: Split out remaining NFS v4 inode functions
    
    Somehow I missed this in my previous patch series, but these functions
    are only needed by the v4 code and should be moved to a v4-only file.  I
    wasn't exactly sure where I should put these functions, so I moved them
    into nfs4super.c where I could make them static.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 17d14709e750..4174faf73ec1 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -319,10 +319,8 @@ extern struct workqueue_struct *nfsiod_workqueue;
 extern struct inode *nfs_alloc_inode(struct super_block *sb);
 extern void nfs_destroy_inode(struct inode *);
 extern int nfs_write_inode(struct inode *, struct writeback_control *);
+extern void nfs_clear_inode(struct inode *);
 extern void nfs_evict_inode(struct inode *);
-#ifdef CONFIG_NFS_V4
-extern void nfs4_evict_inode(struct inode *);
-#endif
 void nfs_zap_acl_cache(struct inode *inode);
 extern int nfs_wait_bit_killable(void *word);
 

commit 6a74490dca897471a994a542fc7c5a469b48b46b
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 30 16:05:20 2012 -0400

    NFS: Pass super operations and xattr handlers in the nfs_subversion
    
    I can set all variables in the nfs_fill_super() function, allowing me to
    remove the nfs4_fill_super() function.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 2151bafd55b4..17d14709e750 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -327,6 +327,7 @@ void nfs_zap_acl_cache(struct inode *inode);
 extern int nfs_wait_bit_killable(void *word);
 
 /* super.c */
+extern const struct super_operations nfs_sops;
 extern struct file_system_type nfs_fs_type;
 extern struct file_system_type nfs_xdev_fs_type;
 #ifdef CONFIG_NFS_V4

commit 1179acc6a3e260bc4edc74fa94f6c7908290eaec
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 30 16:05:19 2012 -0400

    NFS: Only initialize the ACL client in the v3 case
    
    v2 and v4 don't use it, so I create two new nfs_rpc_ops functions to
    initialize the ACL client only when we are using v3.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 3364eccd17ef..2151bafd55b4 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -187,13 +187,11 @@ extern struct nfs_client *nfs4_find_client_ident(struct net *, int);
 extern struct nfs_client *
 nfs4_find_client_sessionid(struct net *, const struct sockaddr *,
 				struct nfs4_sessionid *);
-extern struct nfs_server *nfs_create_server(
-					const struct nfs_parsed_mount_data *,
-					struct nfs_fh *,
+extern struct nfs_server *nfs_create_server(struct nfs_mount_info *,
 					struct nfs_subversion *);
 extern struct nfs_server *nfs4_create_server(
-					const struct nfs_parsed_mount_data *,
-					struct nfs_fh *);
+					struct nfs_mount_info *,
+					struct nfs_subversion *);
 extern struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *,
 						      struct nfs_fh *);
 extern void nfs_free_server(struct nfs_server *server);
@@ -225,6 +223,13 @@ static inline void nfs_fs_proc_exit(void)
 int nfs_sockaddr_match_ipaddr(const struct sockaddr *, const struct sockaddr *);
 #endif
 
+/* nfs3client.c */
+#ifdef CONFIG_NFS_V3
+struct nfs_server *nfs3_create_server(struct nfs_mount_info *, struct nfs_subversion *);
+struct nfs_server *nfs3_clone_server(struct nfs_server *, struct nfs_fh *,
+				     struct nfs_fattr *, rpc_authflavor_t);
+#endif
+
 /* callback_xdr.c */
 extern struct svc_version nfs4_callback_version1;
 extern struct svc_version nfs4_callback_version4;

commit ff9099f26645818563c8d396a154c2ce6ee422eb
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 30 16:05:18 2012 -0400

    NFS: Create a try_mount rpc op
    
    I'm already looking up the nfs subversion in nfs_fs_mount(), so I have
    easy access to rpc_ops that used to be difficult to reach.  This allows
    me to set up a different mount path for NFS v2/3 and NFS v4.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index ac936476b3bc..3364eccd17ef 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -328,6 +328,8 @@ extern struct file_system_type nfs_xdev_fs_type;
 extern struct file_system_type nfs4_xdev_fs_type;
 extern struct file_system_type nfs4_referral_fs_type;
 #endif
+struct dentry *nfs_try_mount(int, const char *, struct nfs_mount_info *,
+			struct nfs_subversion *);
 void nfs_initialise_sb(struct super_block *);
 int nfs_set_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
 int nfs_clone_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);

commit ab7017a3a0a64b953e091619c30413b3721d925d
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 30 16:05:16 2012 -0400

    NFS: Add version registering framework
    
    This patch adds in the code to track multiple versions of the NFS
    protocol.  I created default structures for v2, v3 and v4 so that each
    version can continue to work while I convert them into kernel modules.
    I also removed the const parameter from the rpc_version array so that I
    can change it at runtime.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index cfafd13b6fe9..ac936476b3bc 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -90,7 +90,7 @@ struct nfs_client_initdata {
 	const char *hostname;
 	const struct sockaddr *addr;
 	size_t addrlen;
-	const struct nfs_rpc_ops *rpc_ops;
+	struct nfs_subversion *nfs_mod;
 	int proto;
 	u32 minorversion;
 	struct net *net;
@@ -189,7 +189,8 @@ nfs4_find_client_sessionid(struct net *, const struct sockaddr *,
 				struct nfs4_sessionid *);
 extern struct nfs_server *nfs_create_server(
 					const struct nfs_parsed_mount_data *,
-					struct nfs_fh *);
+					struct nfs_fh *,
+					struct nfs_subversion *);
 extern struct nfs_server *nfs4_create_server(
 					const struct nfs_parsed_mount_data *,
 					struct nfs_fh *);
@@ -321,6 +322,7 @@ void nfs_zap_acl_cache(struct inode *inode);
 extern int nfs_wait_bit_killable(void *word);
 
 /* super.c */
+extern struct file_system_type nfs_fs_type;
 extern struct file_system_type nfs_xdev_fs_type;
 #ifdef CONFIG_NFS_V4
 extern struct file_system_type nfs4_xdev_fs_type;
@@ -329,8 +331,8 @@ extern struct file_system_type nfs4_referral_fs_type;
 void nfs_initialise_sb(struct super_block *);
 int nfs_set_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
 int nfs_clone_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
-struct dentry *nfs_fs_mount_common(struct file_system_type *, struct nfs_server *,
-				   int, const char *, struct nfs_mount_info *);
+struct dentry *nfs_fs_mount_common(struct nfs_server *, int, const char *,
+				   struct nfs_mount_info *, struct nfs_subversion *);
 struct dentry *nfs_fs_mount(struct file_system_type *, int, const char *, void *);
 struct dentry * nfs_xdev_mount_common(struct file_system_type *, int,
 		const char *, struct nfs_mount_info *);

commit fbdefd6442811392e857721573b63a51d1149cc8
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 16 16:39:20 2012 -0400

    NFS: Split out the NFS v4 filesystem types
    
    This allows me to move the v4 mounting and unmounting functions out of
    the generic client and into a file that is only compiled when CONFIG_NFS_V4
    is enabled.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index b4a35705246c..cfafd13b6fe9 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -153,6 +153,14 @@ struct nfs_mount_request {
 	struct net		*net;
 };
 
+struct nfs_mount_info {
+	void (*fill_super)(struct super_block *, struct nfs_mount_info *);
+	int (*set_security)(struct super_block *, struct dentry *, struct nfs_mount_info *);
+	struct nfs_parsed_mount_data *parsed;
+	struct nfs_clone_mount *cloned;
+	struct nfs_fh *mntfh;
+};
+
 extern int nfs_mount(struct nfs_mount_request *info);
 extern void nfs_umount(const struct nfs_mount_request *info);
 
@@ -318,6 +326,16 @@ extern struct file_system_type nfs_xdev_fs_type;
 extern struct file_system_type nfs4_xdev_fs_type;
 extern struct file_system_type nfs4_referral_fs_type;
 #endif
+void nfs_initialise_sb(struct super_block *);
+int nfs_set_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
+int nfs_clone_sb_security(struct super_block *, struct dentry *, struct nfs_mount_info *);
+struct dentry *nfs_fs_mount_common(struct file_system_type *, struct nfs_server *,
+				   int, const char *, struct nfs_mount_info *);
+struct dentry *nfs_fs_mount(struct file_system_type *, int, const char *, void *);
+struct dentry * nfs_xdev_mount_common(struct file_system_type *, int,
+		const char *, struct nfs_mount_info *);
+void nfs_kill_super(struct super_block *);
+void nfs_fill_super(struct super_block *, struct nfs_mount_info *);
 
 extern struct rpc_stat nfs_rpcstat;
 
@@ -364,6 +382,17 @@ extern void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,
 extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_readdata_release(struct nfs_read_data *rdata);
 
+/* super.c */
+void nfs_clone_super(struct super_block *, struct nfs_mount_info *);
+void nfs_umount_begin(struct super_block *);
+int  nfs_statfs(struct dentry *, struct kstatfs *);
+int  nfs_show_options(struct seq_file *, struct dentry *);
+int  nfs_show_devname(struct seq_file *, struct dentry *);
+int  nfs_show_path(struct seq_file *, struct dentry *);
+int  nfs_show_stats(struct seq_file *, struct dentry *);
+void nfs_put_super(struct super_block *);
+int nfs_remount(struct super_block *sb, int *flags, char *raw_data);
+
 /* write.c */
 extern void nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,
 			struct inode *inode, int ioflags,

commit fcf10398f641c4450119f8a4cc27e9e584edb010
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 16 16:39:18 2012 -0400

    NFS: Split out NFS v4 server creating code
    
    These functions are specific to NFS v4 and can be moved to nfs4client.c
    to keep them out of the generic client.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 10df28d14f83..b4a35705246c 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -85,6 +85,17 @@ struct nfs_clone_mount {
  */
 #define NFS_MAX_READDIR_PAGES 8
 
+struct nfs_client_initdata {
+	unsigned long init_flags;
+	const char *hostname;
+	const struct sockaddr *addr;
+	size_t addrlen;
+	const struct nfs_rpc_ops *rpc_ops;
+	int proto;
+	u32 minorversion;
+	struct net *net;
+};
+
 /*
  * In-kernel mount arguments
  */
@@ -150,6 +161,16 @@ extern const struct rpc_program nfs_program;
 extern void nfs_clients_init(struct net *net);
 extern struct nfs_client *nfs_alloc_client(const struct nfs_client_initdata *);
 int nfs_create_rpc_client(struct nfs_client *, const struct rpc_timeout *, rpc_authflavor_t);
+struct nfs_client *nfs_get_client(const struct nfs_client_initdata *,
+				  const struct rpc_timeout *, const char *,
+				  rpc_authflavor_t);
+int nfs_probe_fsinfo(struct nfs_server *server, struct nfs_fh *, struct nfs_fattr *);
+void nfs_server_insert_lists(struct nfs_server *);
+void nfs_init_timeout_values(struct rpc_timeout *, int, unsigned int, unsigned int);
+int nfs_init_server_rpcclient(struct nfs_server *, const struct rpc_timeout *t,
+		rpc_authflavor_t);
+struct nfs_server *nfs_alloc_server(void);
+void nfs_server_copy_userdata(struct nfs_server *, struct nfs_server *);
 
 extern void nfs_cleanup_cb_ident_idr(struct net *);
 extern void nfs_put_client(struct nfs_client *);
@@ -191,6 +212,10 @@ static inline void nfs_fs_proc_exit(void)
 }
 #endif
 
+#ifdef CONFIG_NFS_V4_1
+int nfs_sockaddr_match_ipaddr(const struct sockaddr *, const struct sockaddr *);
+#endif
+
 /* callback_xdr.c */
 extern struct svc_version nfs4_callback_version1;
 extern struct svc_version nfs4_callback_version4;

commit 428360d77c801932e4b28f15160aebbdb5f5a03e
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 16 16:39:17 2012 -0400

    NFS: Initialize the NFS v4 client from init_nfs_v4()
    
    And split these functions out of the generic client into a v4 specific
    file.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index ca7200a53caf..10df28d14f83 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -149,6 +149,7 @@ extern void nfs_umount(const struct nfs_mount_request *info);
 extern const struct rpc_program nfs_program;
 extern void nfs_clients_init(struct net *net);
 extern struct nfs_client *nfs_alloc_client(const struct nfs_client_initdata *);
+int nfs_create_rpc_client(struct nfs_client *, const struct rpc_timeout *, rpc_authflavor_t);
 
 extern void nfs_cleanup_cb_ident_idr(struct net *);
 extern void nfs_put_client(struct nfs_client *);

commit ce4ef7c0a8a0594d7b9d088d73866a4389402a7e
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 16 16:39:15 2012 -0400

    NFS: Split out NFS v4 file operations
    
    This patch moves the NFS v4 file functions into a new file that is only
    compiled when CONFIG_NFS_V4 is enabled.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 35a8ffec69f6..ca7200a53caf 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -257,6 +257,23 @@ int nfs_link(struct dentry *, struct inode *, struct dentry *);
 int nfs_mknod(struct inode *, struct dentry *, umode_t, dev_t);
 int nfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
 
+/* file.c */
+int nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);
+loff_t nfs_file_llseek(struct file *, loff_t, int);
+int nfs_file_flush(struct file *, fl_owner_t);
+ssize_t nfs_file_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);
+ssize_t nfs_file_splice_read(struct file *, loff_t *, struct pipe_inode_info *,
+			     size_t, unsigned int);
+int nfs_file_mmap(struct file *, struct vm_area_struct *);
+ssize_t nfs_file_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
+int nfs_file_release(struct inode *, struct file *);
+int nfs_lock(struct file *, int, struct file_lock *);
+int nfs_flock(struct file *, int, struct file_lock *);
+ssize_t nfs_file_splice_write(struct pipe_inode_info *, struct file *, loff_t *,
+			      size_t, unsigned int);
+int nfs_check_flags(int);
+int nfs_setlease(struct file *, long, struct file_lock **);
+
 /* inode.c */
 extern struct workqueue_struct *nfsiod_workqueue;
 extern struct inode *nfs_alloc_inode(struct super_block *sb);

commit 597d92891b8859b4b4949fd08e25e60fc80ddaaf
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 16 16:39:10 2012 -0400

    NFS: Split out NFS v2 inode operations
    
    This patch moves the NFS v2 file and directory inode functions into
    files that are only compiled whet CONFIG_NFS_V2 is enabled.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7edc172c371e..35a8ffec69f6 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -247,6 +247,15 @@ extern struct nfs_client *nfs_init_client(struct nfs_client *clp,
 /* dir.c */
 extern int nfs_access_cache_shrinker(struct shrinker *shrink,
 					struct shrink_control *sc);
+struct dentry *nfs_lookup(struct inode *, struct dentry *, unsigned int);
+int nfs_create(struct inode *, struct dentry *, umode_t, bool);
+int nfs_mkdir(struct inode *, struct dentry *, umode_t);
+int nfs_rmdir(struct inode *, struct dentry *);
+int nfs_unlink(struct inode *, struct dentry *);
+int nfs_symlink(struct inode *, struct dentry *, const char *);
+int nfs_link(struct dentry *, struct inode *, struct dentry *);
+int nfs_mknod(struct inode *, struct dentry *, umode_t, dev_t);
+int nfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
 
 /* inode.c */
 extern struct workqueue_struct *nfsiod_workqueue;

commit 57208fa7e51ca16cd68de8e8bf482f16b06d3ea1
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Wed Jun 20 15:53:48 2012 -0400

    NFS: Create an write_pageio_init() function
    
    pNFS needs to select a write function based on the layout driver
    currently in use, so I let each NFS version decide how to best handle
    initializing writes.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index b3121123b40d..7edc172c371e 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -320,7 +320,7 @@ extern struct nfs_write_header *nfs_writehdr_alloc(void);
 extern void nfs_writehdr_free(struct nfs_pgio_header *hdr);
 extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
 			     struct nfs_pgio_header *hdr);
-extern void nfs_pageio_init_write_mds(struct nfs_pageio_descriptor *pgio,
+extern void nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,
 			struct inode *inode, int ioflags,
 			const struct nfs_pgio_completion_ops *compl_ops);
 extern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);

commit 1abb50886afe8a126705c93dab2b50c1252a9c19
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Wed Jun 20 15:53:47 2012 -0400

    NFS: Create an read_pageio_init() function
    
    pNFS needs to select a read function based on the layout driver
    currently in use, so I let each NFS version decide how to best handle
    initializing reads.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 633af813984d..b3121123b40d 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -306,7 +306,7 @@ extern int nfs_initiate_read(struct rpc_clnt *clnt,
 extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 extern int nfs_generic_pagein(struct nfs_pageio_descriptor *desc,
 			      struct nfs_pgio_header *hdr);
-extern void nfs_pageio_init_read_mds(struct nfs_pageio_descriptor *pgio,
+extern void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,
 			struct inode *inode,
 			const struct nfs_pgio_completion_ops *compl_ops);
 extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);

commit 6663ee7f8187708143255c057bc132bbc84c1894
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Wed Jun 20 15:53:46 2012 -0400

    NFS: Create an alloc_client rpc_op
    
    This gives NFS v4 a way to set up callbacks and sessions without v2 or
    v3 having to do them as well.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 93b732523342..633af813984d 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -148,6 +148,7 @@ extern void nfs_umount(const struct nfs_mount_request *info);
 /* client.c */
 extern const struct rpc_program nfs_program;
 extern void nfs_clients_init(struct net *net);
+extern struct nfs_client *nfs_alloc_client(const struct nfs_client_initdata *);
 
 extern void nfs_cleanup_cb_ident_idr(struct net *);
 extern void nfs_put_client(struct nfs_client *);

commit cdb7ecedec766861e7c4cc35a203518f92023bff
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Wed Jun 20 15:53:45 2012 -0400

    NFS: Create a free_client rpc_op
    
    NFS v4 needs a way to shut down callbacks and sessions, but v2 and v3
    don't.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 18f99ef71343..93b732523342 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -151,6 +151,7 @@ extern void nfs_clients_init(struct net *net);
 
 extern void nfs_cleanup_cb_ident_idr(struct net *);
 extern void nfs_put_client(struct nfs_client *);
+extern void nfs_free_client(struct nfs_client *);
 extern struct nfs_client *nfs4_find_client_ident(struct net *, int);
 extern struct nfs_client *
 nfs4_find_client_sessionid(struct net *, const struct sockaddr *,

commit 1d59d61f606547f0712aa6971f91f71154071c99
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu May 31 12:22:33 2012 -0400

    NFS: Ensure that setattr and getattr wait for O_DIRECT write completion
    
    Use the same mechanism as the block devices are using, but move the
    helper functions from fs/direct-io.c into fs/inode.c to remove the
    dependency on CONFIG_BLOCK.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 1848a7275592..18f99ef71343 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -369,6 +369,10 @@ extern int nfs_migrate_page(struct address_space *,
 /* direct.c */
 void nfs_init_cinfo_from_dreq(struct nfs_commit_info *cinfo,
 			      struct nfs_direct_req *dreq);
+static inline void nfs_inode_dio_wait(struct inode *inode)
+{
+	inode_dio_wait(inode);
+}
 
 /* nfs4proc.c */
 extern void __nfs4_read_done_cb(struct nfs_read_data *);

commit 4697bd5e9419348ef9fa9b55cefe4355ad9d3d01
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed May 23 13:24:36 2012 -0400

    NFSv4: Fix a race in the net namespace mount notification
    
    Since the struct nfs_client gets added to the global nfs_client_list
    before it is initialised, it is possible that rpc_pipefs_event can
    end up trying to create idmapper entries on such a thing.
    
    The solution is to have the mount notification wait for the
    initialisation of each nfs_client to complete, and then to
    skip any entries for which the it failed.
    
    Reported-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Acked-by: Stanislav Kinsbursky <skinsbursky@parallels.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5ea571e8d0e9..1848a7275592 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -168,6 +168,7 @@ extern struct nfs_server *nfs_clone_server(struct nfs_server *,
 					   struct nfs_fh *,
 					   struct nfs_fattr *,
 					   rpc_authflavor_t);
+extern int nfs_wait_client_init_complete(const struct nfs_client *clp);
 extern void nfs_mark_client_ready(struct nfs_client *clp, int state);
 extern struct nfs_client *nfs4_set_ds_client(struct nfs_client* mds_clp,
 					     const struct sockaddr *ds_addr,

commit 7b38c3682c5cab4f98751d5fe57b78a59020653d
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed May 23 13:23:31 2012 -0400

    NFSv4.1: Fix session initialisation races
    
    Session initialisation is not complete until the lease manager
    has run. We need to ensure that both nfs4_init_session and
    nfs4_init_ds_session do so, and that they check for any resulting
    errors in clp->cl_cons_state.
    
    Only after this is done, can nfs4_ds_connect check the contents
    of clp->cl_exchange_flags.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Andy Adamson <andros@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 547f24f17d16..5ea571e8d0e9 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -169,7 +169,6 @@ extern struct nfs_server *nfs_clone_server(struct nfs_server *,
 					   struct nfs_fattr *,
 					   rpc_authflavor_t);
 extern void nfs_mark_client_ready(struct nfs_client *clp, int state);
-extern int nfs4_check_client_ready(struct nfs_client *clp);
 extern struct nfs_client *nfs4_set_ds_client(struct nfs_client* mds_clp,
 					     const struct sockaddr *ds_addr,
 					     int ds_addrlen, int ds_proto,
@@ -234,7 +233,7 @@ extern const u32 nfs41_maxwrite_overhead;
 extern struct rpc_procinfo nfs4_procedures[];
 #endif
 
-extern int nfs4_init_ds_session(struct nfs_client *clp);
+extern int nfs4_init_ds_session(struct nfs_client *, unsigned long);
 
 /* proc.c */
 void nfs_close_context(struct nfs_open_context *ctx, int is_sync);

commit 4bf590e08f6db3395c181618a4c14f1c39b7c4af
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon May 21 22:46:07 2012 -0400

    NFS: Add nfs_client behavior flags
    
    "noresvport" and "discrtry" can be passed to nfs_create_rpc_client()
    by setting flags in the passed-in nfs_client.  This change makes it
    easy to add new flags.
    
    Note that these settings are now "sticky" over the lifetime of a
    struct nfs_client, and may even be copied when an nfs_client is
    cloned.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 3a9e80c9524b..547f24f17d16 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -240,8 +240,7 @@ extern int nfs4_init_ds_session(struct nfs_client *clp);
 void nfs_close_context(struct nfs_open_context *ctx, int is_sync);
 extern struct nfs_client *nfs_init_client(struct nfs_client *clp,
 			   const struct rpc_timeout *timeparms,
-			   const char *ip_addr, rpc_authflavor_t authflavour,
-			   int noresvport);
+			   const char *ip_addr, rpc_authflavor_t authflavour);
 
 /* dir.c */
 extern int nfs_access_cache_shrinker(struct shrinker *shrink,
@@ -376,8 +375,7 @@ extern void __nfs4_read_done_cb(struct nfs_read_data *);
 extern struct nfs_client *nfs4_init_client(struct nfs_client *clp,
 			    const struct rpc_timeout *timeparms,
 			    const char *ip_addr,
-			    rpc_authflavor_t authflavour,
-			    int noresvport);
+			    rpc_authflavor_t authflavour);
 extern int _nfs4_call_sync(struct rpc_clnt *clnt,
 			   struct nfs_server *server,
 			   struct rpc_message *msg,

commit 8cab4c390b43fe34c07bd33799c1bc24be648122
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon May 21 22:45:59 2012 -0400

    NFS: Refactor nfs_get_client(): initialize nfs_client
    
    Clean up: Continue to rationalize the locking in nfs_get_client() by
    moving the logic that handles the case where a matching server IP
    address is not found.
    
    When we support server trunking detection, client initialization may
    return a different nfs_client struct than was passed to it.  Change
    the synopsis of the init_client methods to return an nfs_client.
    
    The client initialization logic in nfs_get_client() is not much more
    than a wrapper around ->init_client.  It's simpler to keep the little
    bits of error handling in the version-specific init_client methods.
    
    No behavior change is expected.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 989959a59f07..3a9e80c9524b 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -238,7 +238,7 @@ extern int nfs4_init_ds_session(struct nfs_client *clp);
 
 /* proc.c */
 void nfs_close_context(struct nfs_open_context *ctx, int is_sync);
-extern int nfs_init_client(struct nfs_client *clp,
+extern struct nfs_client *nfs_init_client(struct nfs_client *clp,
 			   const struct rpc_timeout *timeparms,
 			   const char *ip_addr, rpc_authflavor_t authflavour,
 			   int noresvport);
@@ -373,7 +373,7 @@ void nfs_init_cinfo_from_dreq(struct nfs_commit_info *cinfo,
 
 /* nfs4proc.c */
 extern void __nfs4_read_done_cb(struct nfs_read_data *);
-extern int nfs4_init_client(struct nfs_client *clp,
+extern struct nfs_client *nfs4_init_client(struct nfs_client *clp,
 			    const struct rpc_timeout *timeparms,
 			    const char *ip_addr,
 			    rpc_authflavor_t authflavour,

commit a033a09189c0125d56f2ac17ffb4bec5a3d3323b
Author: Andy Adamson <andros@netapp.com>
Date:   Fri Apr 27 17:53:47 2012 -0400

    NFSv4.1 remove nfs4_reset_write and nfs4_reset_read
    
    Replaced by filelayout_reset_write and filelayout_reset_read
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 1466c5d88f09..989959a59f07 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -373,13 +373,11 @@ void nfs_init_cinfo_from_dreq(struct nfs_commit_info *cinfo,
 
 /* nfs4proc.c */
 extern void __nfs4_read_done_cb(struct nfs_read_data *);
-extern void nfs4_reset_read(struct rpc_task *task, struct nfs_read_data *data);
 extern int nfs4_init_client(struct nfs_client *clp,
 			    const struct rpc_timeout *timeparms,
 			    const char *ip_addr,
 			    rpc_authflavor_t authflavour,
 			    int noresvport);
-extern void nfs4_reset_write(struct rpc_task *task, struct nfs_write_data *data);
 extern int _nfs4_call_sync(struct rpc_clnt *clnt,
 			   struct nfs_server *server,
 			   struct rpc_message *msg,

commit 98fc685ae2aa24eae98526e9196b3229d519083a
Author: Andy Adamson <andros@netapp.com>
Date:   Fri Apr 27 17:53:45 2012 -0400

    NFSv4.1 data server timeo and retrans module parameters
    
    Set the recovery parameters for data servers.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 6ed96c7ffcb2..1466c5d88f09 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -172,7 +172,9 @@ extern void nfs_mark_client_ready(struct nfs_client *clp, int state);
 extern int nfs4_check_client_ready(struct nfs_client *clp);
 extern struct nfs_client *nfs4_set_ds_client(struct nfs_client* mds_clp,
 					     const struct sockaddr *ds_addr,
-					     int ds_addrlen, int ds_proto);
+					     int ds_addrlen, int ds_proto,
+					     unsigned int ds_timeo,
+					     unsigned int ds_retrans);
 #ifdef CONFIG_PROC_FS
 extern int __init nfs_fs_proc_init(void);
 extern void nfs_fs_proc_exit(void);

commit 9f0ec176b3071e0472582c07ae1e68055b28184d
Author: Andy Adamson <andros@netapp.com>
Date:   Fri Apr 27 17:53:44 2012 -0400

    NFSv4.1 set RPC_TASK_SOFTCONN for filelayout DS RPC calls
    
    RPC_TASK_SOFTCONN returns connection errors to the caller which allows the pNFS
    file layout to quickly try the MDS or perhaps another DS.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index bf64095f850d..6ed96c7ffcb2 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -299,7 +299,7 @@ extern void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,
 			const struct nfs_pgio_completion_ops *compl_ops);
 extern int nfs_initiate_read(struct rpc_clnt *clnt,
 			     struct nfs_read_data *data,
-			     const struct rpc_call_ops *call_ops);
+			     const struct rpc_call_ops *call_ops, int flags);
 extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 extern int nfs_generic_pagein(struct nfs_pageio_descriptor *desc,
 			      struct nfs_pgio_header *hdr);
@@ -326,13 +326,13 @@ extern void nfs_commit_free(struct nfs_commit_data *p);
 extern int nfs_initiate_write(struct rpc_clnt *clnt,
 			      struct nfs_write_data *data,
 			      const struct rpc_call_ops *call_ops,
-			      int how);
+			      int how, int flags);
 extern void nfs_write_prepare(struct rpc_task *task, void *calldata);
 extern void nfs_commit_prepare(struct rpc_task *task, void *calldata);
 extern int nfs_initiate_commit(struct rpc_clnt *clnt,
 			       struct nfs_commit_data *data,
 			       const struct rpc_call_ops *call_ops,
-			       int how);
+			       int how, int flags);
 extern void nfs_init_commit(struct nfs_commit_data *data,
 			    struct list_head *head,
 			    struct pnfs_layout_segment *lseg,

commit 5e7e5a0da28216fb9d0a49e93ee27668ef4f04f7
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Thu May 10 16:47:18 2012 -0400

    NFS: Create an NFS v3 stat_to_errno()
    
    In theory, NFS v3 can have different error versions than NFS v2. v4 is
    already using its own nfs4_stat_to_errno() to map error codes, so
    rather than create something in the generic client for v2 and v3 to
    share I instead give v3 its own function.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 4e9b0ff30f66..bf64095f850d 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -208,7 +208,6 @@ extern void nfs_pgheader_init(struct nfs_pageio_descriptor *desc,
 void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos);
 
 /* nfs2xdr.c */
-extern int nfs_stat_to_errno(enum nfs_stat);
 extern struct rpc_procinfo nfs_procedures[];
 extern int nfs2_decode_dirent(struct xdr_stream *,
 				struct nfs_entry *, int);

commit b72e4f42a33137acc037546277a08f407d3c1016
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Thu May 10 15:07:40 2012 -0400

    NFS: Create a single function for text mount data
    
    The v2/3 and v4 cases were very similar, with just a few parameters
    changed.  This makes it easy to share code.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 1855e8fea423..4e9b0ff30f66 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -103,6 +103,7 @@ struct nfs_parsed_mount_data {
 	unsigned int		version;
 	unsigned int		minorversion;
 	char			*fscache_uniq;
+	bool			need_mount;
 
 	struct {
 		struct sockaddr_storage	address;

commit 3a1556e8662cc425c433b463fcdae138908ca467
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Apr 27 13:48:18 2012 -0400

    NFSv2/v3: Simulate the change attribute
    
    Use the ctime to simulate a change attribute for NFSv2 and NFSv3.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 0fd1efaf1cff..1855e8fea423 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -493,3 +493,15 @@ unsigned int nfs_page_array_len(unsigned int base, size_t len)
 		PAGE_SIZE - 1) >> PAGE_SHIFT;
 }
 
+/*
+ * Convert a struct timespec into a 64-bit change attribute
+ *
+ * This does approximately the same thing as timespec_to_ns(),
+ * but for calculation efficiency, we multiply the seconds by
+ * 1024*1024*1024.
+ */
+static inline
+u64 nfs_timespec_to_change_attr(const struct timespec *ts)
+{
+	return ((u64)ts->tv_sec << 30) + ts->tv_nsec;
+}

commit 281cad46b34db4dbb1d1e603f7b9cfe25d1ae7c9
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Fri Apr 27 13:27:45 2012 -0400

    NFS: Create a submount rpc_op
    
    This simplifies the code for v2 and v3 and gives v4 a chance to decide
    on referrals without needing to modify the generic client.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index d6994443f285..0fd1efaf1cff 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -185,17 +185,6 @@ static inline void nfs_fs_proc_exit(void)
 }
 #endif
 
-/* nfs4namespace.c */
-#ifdef CONFIG_NFS_V4
-extern struct vfsmount *nfs_do_refmount(struct rpc_clnt *client, struct dentry *dentry);
-#else
-static inline
-struct vfsmount *nfs_do_refmount(struct rpc_clnt *client, struct dentry *dentry)
-{
-	return ERR_PTR(-ENOENT);
-}
-#endif
-
 /* callback_xdr.c */
 extern struct svc_version nfs4_callback_version1;
 extern struct svc_version nfs4_callback_version4;
@@ -286,6 +275,10 @@ extern void nfs_sb_deactive(struct super_block *sb);
 extern char *nfs_path(char **p, struct dentry *dentry,
 		      char *buffer, ssize_t buflen);
 extern struct vfsmount *nfs_d_automount(struct path *path);
+struct vfsmount *nfs_submount(struct nfs_server *, struct dentry *,
+			      struct nfs_fh *, struct nfs_fattr *);
+struct vfsmount *nfs_do_submount(struct dentry *, struct nfs_fh *,
+				 struct nfs_fattr *, rpc_authflavor_t);
 
 /* getroot.c */
 extern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *,

commit 2671bfc3beb44e70636bd0208274426db57f73b5
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Fri Apr 27 13:27:44 2012 -0400

    NFS: Remove secinfo knowledge out of the generic client
    
    And also remove the unneeded rpc_op.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index d68810f61869..d6994443f285 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -286,9 +286,6 @@ extern void nfs_sb_deactive(struct super_block *sb);
 extern char *nfs_path(char **p, struct dentry *dentry,
 		      char *buffer, ssize_t buflen);
 extern struct vfsmount *nfs_d_automount(struct path *path);
-#ifdef CONFIG_NFS_V4
-rpc_authflavor_t nfs_find_best_sec(struct nfs4_secinfo_flavors *);
-#endif
 
 /* getroot.c */
 extern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *,

commit 1763da1234cba663b849476d451bdccac5147859
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:57 2012 -0400

    NFS: rewrite directio write to use async coalesce code
    
    This also has the advantage that it allows directio to use pnfs.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 137f5cd71433..d68810f61869 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -320,10 +320,11 @@ extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_readdata_release(struct nfs_read_data *rdata);
 
 /* write.c */
+extern void nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,
+			struct inode *inode, int ioflags,
+			const struct nfs_pgio_completion_ops *compl_ops);
 extern struct nfs_write_header *nfs_writehdr_alloc(void);
 extern void nfs_writehdr_free(struct nfs_pgio_header *hdr);
-extern struct nfs_write_data *nfs_writedata_alloc(struct nfs_pgio_header *hdr,
-						  unsigned int pagecount);
 extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
 			     struct nfs_pgio_header *hdr);
 extern void nfs_pageio_init_write_mds(struct nfs_pageio_descriptor *pgio,
@@ -346,6 +347,15 @@ extern void nfs_init_commit(struct nfs_commit_data *data,
 			    struct list_head *head,
 			    struct pnfs_layout_segment *lseg,
 			    struct nfs_commit_info *cinfo);
+int nfs_scan_commit_list(struct list_head *src, struct list_head *dst,
+			 struct nfs_commit_info *cinfo, int max);
+int nfs_scan_commit(struct inode *inode, struct list_head *dst,
+		    struct nfs_commit_info *cinfo);
+void nfs_mark_request_commit(struct nfs_page *req,
+			     struct pnfs_layout_segment *lseg,
+			     struct nfs_commit_info *cinfo);
+int nfs_generic_commit_list(struct inode *inode, struct list_head *head,
+			    int how, struct nfs_commit_info *cinfo);
 void nfs_retry_commit(struct list_head *page_list,
 		      struct pnfs_layout_segment *lseg,
 		      struct nfs_commit_info *cinfo);
@@ -365,6 +375,10 @@ extern int nfs_migrate_page(struct address_space *,
 #define nfs_migrate_page NULL
 #endif
 
+/* direct.c */
+void nfs_init_cinfo_from_dreq(struct nfs_commit_info *cinfo,
+			      struct nfs_direct_req *dreq);
+
 /* nfs4proc.c */
 extern void __nfs4_read_done_cb(struct nfs_read_data *);
 extern void nfs4_reset_read(struct rpc_task *task, struct nfs_read_data *data);

commit f453a54a01c7c0453ad9550906e3d2663dd486ac
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:54 2012 -0400

    NFS: create nfs_commit_completion_ops
    
    Factors out the code that needs to change when directio
    starts using these code paths.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 145e9e7dc8ce..137f5cd71433 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -344,13 +344,12 @@ extern int nfs_initiate_commit(struct rpc_clnt *clnt,
 			       int how);
 extern void nfs_init_commit(struct nfs_commit_data *data,
 			    struct list_head *head,
-			    struct pnfs_layout_segment *lseg);
+			    struct pnfs_layout_segment *lseg,
+			    struct nfs_commit_info *cinfo);
 void nfs_retry_commit(struct list_head *page_list,
 		      struct pnfs_layout_segment *lseg,
 		      struct nfs_commit_info *cinfo);
-void nfs_commit_clear_lock(struct nfs_inode *nfsi);
 void nfs_commitdata_release(struct nfs_commit_data *data);
-void nfs_commit_release_pages(struct nfs_commit_data *data);
 void nfs_request_add_commit_list(struct nfs_page *req, struct list_head *dst,
 				 struct nfs_commit_info *cinfo);
 void nfs_request_remove_commit_list(struct nfs_page *req,

commit ea2cf2282b4278461266013e9c002ee1c66700ff
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:53 2012 -0400

    NFS: create struct nfs_commit_info
    
    It is COMMIT that is handled the most differently between
    the paged and direct paths.  Create a structure that encapsulates
    everything either path needs to know about the commit state.
    
    We could use void to hide some of the layout driver stuff, but
    Trond suggests pulling it out to ensure type checking, given the
    huge changes being made, and the fact that it doesn't interfere
    with other drivers.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index cd5d4a300bc9..145e9e7dc8ce 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -346,12 +346,18 @@ extern void nfs_init_commit(struct nfs_commit_data *data,
 			    struct list_head *head,
 			    struct pnfs_layout_segment *lseg);
 void nfs_retry_commit(struct list_head *page_list,
-		      struct pnfs_layout_segment *lseg);
+		      struct pnfs_layout_segment *lseg,
+		      struct nfs_commit_info *cinfo);
 void nfs_commit_clear_lock(struct nfs_inode *nfsi);
 void nfs_commitdata_release(struct nfs_commit_data *data);
 void nfs_commit_release_pages(struct nfs_commit_data *data);
-void nfs_request_add_commit_list(struct nfs_page *req, struct list_head *head);
-void nfs_request_remove_commit_list(struct nfs_page *req);
+void nfs_request_add_commit_list(struct nfs_page *req, struct list_head *dst,
+				 struct nfs_commit_info *cinfo);
+void nfs_request_remove_commit_list(struct nfs_page *req,
+				    struct nfs_commit_info *cinfo);
+void nfs_init_cinfo(struct nfs_commit_info *cinfo,
+		    struct inode *inode,
+		    struct nfs_direct_req *dreq);
 
 #ifdef CONFIG_MIGRATION
 extern int nfs_migrate_page(struct address_space *,

commit 584aa810b6240d88c28113a90c5029449814a3b5
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:51 2012 -0400

    NFS: rewrite directio read to use async coalesce code
    
    This also has the advantage that it allows directio to use pnfs.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 3ef8fcda1a5f..cd5d4a300bc9 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -304,8 +304,9 @@ struct nfs_pgio_completion_ops;
 /* read.c */
 extern struct nfs_read_header *nfs_readhdr_alloc(void);
 extern void nfs_readhdr_free(struct nfs_pgio_header *hdr);
-extern struct nfs_read_data *nfs_readdata_alloc(struct nfs_pgio_header *hdr,
-						unsigned int pagecount);
+extern void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,
+			struct inode *inode,
+			const struct nfs_pgio_completion_ops *compl_ops);
 extern int nfs_initiate_read(struct rpc_clnt *clnt,
 			     struct nfs_read_data *data,
 			     const struct rpc_call_ops *call_ops);

commit 061ae2edb7375ab6776468b075da71008a098b55
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:48 2012 -0400

    NFS: create completion structure to pass into page_init functions
    
    Factors out the code that will need to change when directio
    starts using these code paths.  This will allow directio to use
    the generic pagein and flush routines
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 16bc9c47c83e..3ef8fcda1a5f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -300,11 +300,10 @@ extern struct dentry *nfs4_get_root(struct super_block *, struct nfs_fh *,
 extern int nfs4_get_rootfh(struct nfs_server *server, struct nfs_fh *mntfh);
 #endif
 
+struct nfs_pgio_completion_ops;
 /* read.c */
-extern void nfs_async_read_error(struct list_head *head);
 extern struct nfs_read_header *nfs_readhdr_alloc(void);
 extern void nfs_readhdr_free(struct nfs_pgio_header *hdr);
-extern void nfs_read_completion(struct nfs_pgio_header *hdr);
 extern struct nfs_read_data *nfs_readdata_alloc(struct nfs_pgio_header *hdr,
 						unsigned int pagecount);
 extern int nfs_initiate_read(struct rpc_clnt *clnt,
@@ -314,21 +313,21 @@ extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 extern int nfs_generic_pagein(struct nfs_pageio_descriptor *desc,
 			      struct nfs_pgio_header *hdr);
 extern void nfs_pageio_init_read_mds(struct nfs_pageio_descriptor *pgio,
-		struct inode *inode);
+			struct inode *inode,
+			const struct nfs_pgio_completion_ops *compl_ops);
 extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_readdata_release(struct nfs_read_data *rdata);
 
 /* write.c */
-extern void nfs_async_write_error(struct list_head *head);
 extern struct nfs_write_header *nfs_writehdr_alloc(void);
 extern void nfs_writehdr_free(struct nfs_pgio_header *hdr);
 extern struct nfs_write_data *nfs_writedata_alloc(struct nfs_pgio_header *hdr,
 						  unsigned int pagecount);
-extern void nfs_write_completion(struct nfs_pgio_header *hdr);
 extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
 			     struct nfs_pgio_header *hdr);
 extern void nfs_pageio_init_write_mds(struct nfs_pageio_descriptor *pgio,
-				  struct inode *inode, int ioflags);
+			struct inode *inode, int ioflags,
+			const struct nfs_pgio_completion_ops *compl_ops);
 extern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_writedata_release(struct nfs_write_data *wdata);
 extern void nfs_commit_free(struct nfs_commit_data *p);

commit 6c75dc0d498caa402fb17b1bf769835a9db875c8
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:47 2012 -0400

    NFS: merge _full and _partial write rpc_ops
    
    Decouple nfs_pgio_header and nfs_write_data, and have (possibly
    multiple) nfs_write_datas each take a refcount on nfs_pgio_header.
    
    For the moment keeps nfs_write_header as a way to preallocate a single
    nfs_write_data with the nfs_pgio_header.  The code doesn't need this,
    and would be prettier without, but given the amount of churn I am
    already introducing I didn't want to play with tuning new mempools.
    
    This also fixes bug in pnfs_ld_handle_write_error.  In the case of
    desc->pg_bsize < PAGE_CACHE_SIZE, the pages list was empty, causing
    replay attempt to do nothing.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 33af5e51c0bb..16bc9c47c83e 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -319,10 +319,14 @@ extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_readdata_release(struct nfs_read_data *rdata);
 
 /* write.c */
-extern struct nfs_write_header *nfs_writehdr_alloc(unsigned int npages);
+extern void nfs_async_write_error(struct list_head *head);
+extern struct nfs_write_header *nfs_writehdr_alloc(void);
 extern void nfs_writehdr_free(struct nfs_pgio_header *hdr);
+extern struct nfs_write_data *nfs_writedata_alloc(struct nfs_pgio_header *hdr,
+						  unsigned int pagecount);
+extern void nfs_write_completion(struct nfs_pgio_header *hdr);
 extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
-		struct list_head *head);
+			     struct nfs_pgio_header *hdr);
 extern void nfs_pageio_init_write_mds(struct nfs_pageio_descriptor *pgio,
 				  struct inode *inode, int ioflags);
 extern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);

commit 4db6e0b74c0f6dfc2f9c0690e8df512e3b635983
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:46 2012 -0400

    NFS: merge _full and _partial read rpc_ops
    
    Decouple nfs_pgio_header and nfs_read_data, and have (possibly
    multiple) nfs_read_datas each take a refcount on nfs_pgio_header.
    
    For the moment keeps nfs_read_header as a way to preallocate a single
    nfs_read_data with the nfs_pgio_header.  The code doesn't need this,
    and would be prettier without, but given the amount of churn I am
    already introducing I didn't want to play with tuning new mempools.
    
    This also fixes bug in pnfs_ld_handle_read_error.  In the case of
    desc->pg_bsize < PAGE_CACHE_SIZE, the pages list was empty, causing
    replay attempt to do nothing.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5c3d77fda560..33af5e51c0bb 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -200,6 +200,7 @@ struct vfsmount *nfs_do_refmount(struct rpc_clnt *client, struct dentry *dentry)
 extern struct svc_version nfs4_callback_version1;
 extern struct svc_version nfs4_callback_version4;
 
+struct nfs_pageio_descriptor;
 /* pagelist.c */
 extern int __init nfs_init_nfspagecache(void);
 extern void nfs_destroy_nfspagecache(void);
@@ -211,6 +212,10 @@ extern void nfs_destroy_writepagecache(void);
 extern int __init nfs_init_directcache(void);
 extern void nfs_destroy_directcache(void);
 extern bool nfs_pgarray_set(struct nfs_page_array *p, unsigned int pagecount);
+extern void nfs_pgheader_init(struct nfs_pageio_descriptor *desc,
+			      struct nfs_pgio_header *hdr,
+			      void (*release)(struct nfs_pgio_header *hdr));
+void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos);
 
 /* nfs2xdr.c */
 extern int nfs_stat_to_errno(enum nfs_stat);
@@ -295,17 +300,19 @@ extern struct dentry *nfs4_get_root(struct super_block *, struct nfs_fh *,
 extern int nfs4_get_rootfh(struct nfs_server *server, struct nfs_fh *mntfh);
 #endif
 
-struct nfs_pageio_descriptor;
 /* read.c */
-extern struct nfs_read_header *nfs_readhdr_alloc(unsigned int npages);
+extern void nfs_async_read_error(struct list_head *head);
+extern struct nfs_read_header *nfs_readhdr_alloc(void);
 extern void nfs_readhdr_free(struct nfs_pgio_header *hdr);
+extern void nfs_read_completion(struct nfs_pgio_header *hdr);
+extern struct nfs_read_data *nfs_readdata_alloc(struct nfs_pgio_header *hdr,
+						unsigned int pagecount);
 extern int nfs_initiate_read(struct rpc_clnt *clnt,
 			     struct nfs_read_data *data,
 			     const struct rpc_call_ops *call_ops);
 extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 extern int nfs_generic_pagein(struct nfs_pageio_descriptor *desc,
-		struct list_head *head);
-
+			      struct nfs_pgio_header *hdr);
 extern void nfs_pageio_init_read_mds(struct nfs_pageio_descriptor *pgio,
 		struct inode *inode);
 extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);

commit 30dd374f6fc1b202db3a1b57b61afff1326bad92
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:45 2012 -0400

    NFS: create struct nfs_page_array
    
    Both nfs_read_data and nfs_write_data devote several fields which
    can be combined into a single shared struct.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7dc9be1a6e1a..5c3d77fda560 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -210,6 +210,7 @@ extern void nfs_destroy_writepagecache(void);
 
 extern int __init nfs_init_directcache(void);
 extern void nfs_destroy_directcache(void);
+extern bool nfs_pgarray_set(struct nfs_page_array *p, unsigned int pagecount);
 
 /* nfs2xdr.c */
 extern int nfs_stat_to_errno(enum nfs_stat);

commit cd841605f7a721878d8a2d1362484723d8abf569
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:44 2012 -0400

    NFS: create common nfs_pgio_header for both read and write
    
    In order to avoid duplicating all the data in nfs_read_data whenever we
    split it up into multiple RPC calls (either due to a short read result
    or due to rsize < PAGE_SIZE), we split out the bits that are the same
    per RPC call into a separate "header" structure.
    
    The goal this patch moves towards is to have a single header
    refcounted by several rpc_data structures.  Thus, want to always refer
    from rpc_data to the header, and not the other way.  This patch comes
    close to that ideal, but the directio code currently needs some
    special casing, isolated in the nfs_direct_[read_write]hdr_release()
    functions.  This will be dealt with in a future patch.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 650127fd24bb..7dc9be1a6e1a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -296,6 +296,8 @@ extern int nfs4_get_rootfh(struct nfs_server *server, struct nfs_fh *mntfh);
 
 struct nfs_pageio_descriptor;
 /* read.c */
+extern struct nfs_read_header *nfs_readhdr_alloc(unsigned int npages);
+extern void nfs_readhdr_free(struct nfs_pgio_header *hdr);
 extern int nfs_initiate_read(struct rpc_clnt *clnt,
 			     struct nfs_read_data *data,
 			     const struct rpc_call_ops *call_ops);
@@ -309,6 +311,8 @@ extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_readdata_release(struct nfs_read_data *rdata);
 
 /* write.c */
+extern struct nfs_write_header *nfs_writehdr_alloc(unsigned int npages);
+extern void nfs_writehdr_free(struct nfs_pgio_header *hdr);
 extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
 		struct list_head *head);
 extern void nfs_pageio_init_write_mds(struct nfs_pageio_descriptor *pgio,

commit c5996c4efb95bbb80a25acc890357c9eae998eeb
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:41 2012 -0400

    NFS: reverse arg order in nfs_initiate_[read|write]
    
    Make it consistent with nfs_initiate_commit.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 29ab441b22b1..650127fd24bb 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -296,7 +296,8 @@ extern int nfs4_get_rootfh(struct nfs_server *server, struct nfs_fh *mntfh);
 
 struct nfs_pageio_descriptor;
 /* read.c */
-extern int nfs_initiate_read(struct nfs_read_data *data, struct rpc_clnt *clnt,
+extern int nfs_initiate_read(struct rpc_clnt *clnt,
+			     struct nfs_read_data *data,
 			     const struct rpc_call_ops *call_ops);
 extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 extern int nfs_generic_pagein(struct nfs_pageio_descriptor *desc,
@@ -315,8 +316,8 @@ extern void nfs_pageio_init_write_mds(struct nfs_pageio_descriptor *pgio,
 extern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_writedata_release(struct nfs_write_data *wdata);
 extern void nfs_commit_free(struct nfs_commit_data *p);
-extern int nfs_initiate_write(struct nfs_write_data *data,
-			      struct rpc_clnt *clnt,
+extern int nfs_initiate_write(struct rpc_clnt *clnt,
+			      struct nfs_write_data *data,
 			      const struct rpc_call_ops *call_ops,
 			      int how);
 extern void nfs_write_prepare(struct rpc_task *task, void *calldata);

commit 0b7c01533aa9f4a228d07d2768d084acb3a387bc
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:39 2012 -0400

    NFS: add a struct nfs_commit_data to replace nfs_write_data in commits
    
    Commits don't need the vectors of pages, etc. that writes do. Split out
    a separate structure for the commit operation.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index b777bdaba4c5..29ab441b22b1 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -314,24 +314,25 @@ extern void nfs_pageio_init_write_mds(struct nfs_pageio_descriptor *pgio,
 				  struct inode *inode, int ioflags);
 extern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_writedata_release(struct nfs_write_data *wdata);
-extern void nfs_commit_free(struct nfs_write_data *p);
+extern void nfs_commit_free(struct nfs_commit_data *p);
 extern int nfs_initiate_write(struct nfs_write_data *data,
 			      struct rpc_clnt *clnt,
 			      const struct rpc_call_ops *call_ops,
 			      int how);
 extern void nfs_write_prepare(struct rpc_task *task, void *calldata);
-extern int nfs_initiate_commit(struct nfs_write_data *data,
-			       struct rpc_clnt *clnt,
+extern void nfs_commit_prepare(struct rpc_task *task, void *calldata);
+extern int nfs_initiate_commit(struct rpc_clnt *clnt,
+			       struct nfs_commit_data *data,
 			       const struct rpc_call_ops *call_ops,
 			       int how);
-extern void nfs_init_commit(struct nfs_write_data *data,
+extern void nfs_init_commit(struct nfs_commit_data *data,
 			    struct list_head *head,
 			    struct pnfs_layout_segment *lseg);
 void nfs_retry_commit(struct list_head *page_list,
 		      struct pnfs_layout_segment *lseg);
 void nfs_commit_clear_lock(struct nfs_inode *nfsi);
-void nfs_commitdata_release(void *data);
-void nfs_commit_release_pages(struct nfs_write_data *data);
+void nfs_commitdata_release(struct nfs_commit_data *data);
+void nfs_commit_release_pages(struct nfs_commit_data *data);
 void nfs_request_add_commit_list(struct nfs_page *req, struct list_head *head);
 void nfs_request_remove_commit_list(struct nfs_page *req);
 

commit 7e6eb683d260d9325f0d1bd911518d5ed3cb4f0c
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Fri Apr 27 13:27:42 2012 -0400

    NFS: Honor the authflavor set in the clone mount data
    
    The authflavor is set in an nfs_clone_mount structure and passed to the
    xdev_mount() functions where it was promptly ignored.  Instead, use it
    to initialize an rpc_clnt for the cloned server.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 49c09b4a535a..b777bdaba4c5 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -165,7 +165,8 @@ extern struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *,
 extern void nfs_free_server(struct nfs_server *server);
 extern struct nfs_server *nfs_clone_server(struct nfs_server *,
 					   struct nfs_fh *,
-					   struct nfs_fattr *);
+					   struct nfs_fattr *,
+					   rpc_authflavor_t);
 extern void nfs_mark_client_ready(struct nfs_client *clp, int state);
 extern int nfs4_check_client_ready(struct nfs_client *clp);
 extern struct nfs_client *nfs4_set_ds_client(struct nfs_client* mds_clp,

commit f05d147f7e3cf0d86b3a4bd5603029a7cb109633
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Fri Apr 27 13:27:41 2012 -0400

    NFS: Fix following referral mount points with different security
    
    I create a new proc_lookup_mountpoint() to use when submounting an NFS
    v4 share.  This function returns an rpc_clnt to use for performing an
    fs_locations() call on a referral's mountpoint.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 45966d953169..49c09b4a535a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -186,10 +186,10 @@ static inline void nfs_fs_proc_exit(void)
 
 /* nfs4namespace.c */
 #ifdef CONFIG_NFS_V4
-extern struct vfsmount *nfs_do_refmount(struct dentry *dentry);
+extern struct vfsmount *nfs_do_refmount(struct rpc_clnt *client, struct dentry *dentry);
 #else
 static inline
-struct vfsmount *nfs_do_refmount(struct dentry *dentry)
+struct vfsmount *nfs_do_refmount(struct rpc_clnt *client, struct dentry *dentry)
 {
 	return ERR_PTR(-ENOENT);
 }

commit 72de53ec4bca39c26709122a8f78bfefe7b6bca4
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Fri Apr 27 13:27:40 2012 -0400

    NFS: Do secinfo as part of lookup
    
    Whenever lookup sees wrongsec do a secinfo and retry the lookup to find
    attributes of the file or directory, such as "is this a referral
    mountpoint?".  This also allows me to remove handling -NFS4ERR_WRONSEC
    as part of getattr xdr decoding.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 2476dc69365f..45966d953169 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -234,7 +234,6 @@ extern const u32 nfs41_maxwrite_overhead;
 /* nfs4proc.c */
 #ifdef CONFIG_NFS_V4
 extern struct rpc_procinfo nfs4_procedures[];
-void nfs_fixup_secinfo_attributes(struct nfs_fattr *, struct nfs_fh *);
 #endif
 
 extern int nfs4_init_ds_session(struct nfs_client *clp);

commit 8dd3775889345850ecddd689b5c200cdd91bd8c9
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Mar 15 17:16:40 2012 -0400

    NFSv4.1: Clean ups and bugfixes for the pNFS read/writeback/commit code
    
    Move more pnfs-isms out of the generic commit code.
    
    Bugfixes:
    
    - filelayout_scan_commit_lists doesn't need to get/put the lseg.
      In fact since it is run under the inode->i_lock, the lseg_put()
      can deadlock.
    
    - Ensure that we distinguish between what needs to be done for
      commit-to-data server and what needs to be done for commit-to-MDS
      using the new flag PG_COMMIT_TO_DS. Otherwise we may end up calling
      put_lseg() on a bucket for a struct nfs_page that got written
      through the MDS.
    
    - Fix a case where we were using list_del() on an nfs_page->wb_list
      instead of list_del_init().
    
    - filelayout_initiate_commit needs to call filelayout_commit_release
      on error instead of the mds_ops->rpc_release(). Otherwise it won't
      clear the commit lock.
    
    Cleanups:
    
    - Let the files layout manage the commit lists for the pNFS case.
      Don't expose stuff like pnfs_choose_commit_list, and the fact
      that the commit buckets hold references to the layout segment
      in common code.
    
    - Cast out the put_lseg() calls for the struct nfs_read/write_data->lseg
      into the pNFS layer from whence they came.
    
    - Let the pNFS layer manage the NFS_INO_PNFS_COMMIT bit.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Fred Isaman <iisaman@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 04a914704e7b..2476dc69365f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -308,8 +308,6 @@ extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_readdata_release(struct nfs_read_data *rdata);
 
 /* write.c */
-extern int nfs_scan_commit_list(struct list_head *src, struct list_head *dst,
-				int max);
 extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
 		struct list_head *head);
 extern void nfs_pageio_init_write_mds(struct nfs_pageio_descriptor *pgio,
@@ -334,6 +332,8 @@ void nfs_retry_commit(struct list_head *page_list,
 void nfs_commit_clear_lock(struct nfs_inode *nfsi);
 void nfs_commitdata_release(void *data);
 void nfs_commit_release_pages(struct nfs_write_data *data);
+void nfs_request_add_commit_list(struct nfs_page *req, struct list_head *head);
+void nfs_request_remove_commit_list(struct nfs_page *req);
 
 #ifdef CONFIG_MIGRATION
 extern int nfs_migrate_page(struct address_space *,

commit d6d6dc7cdfda7c8f49a89a7b7261846f319da6d1
Author: Fred Isaman <iisaman@netapp.com>
Date:   Thu Mar 8 17:29:35 2012 -0500

    NFS: remove nfs_inode radix tree
    
    The radix tree is only being used to compile lists of reqs needing commit.
    It is simpler to just put the reqs directly into a list.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 0c3648a947d1..04a914704e7b 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -308,6 +308,8 @@ extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_readdata_release(struct nfs_read_data *rdata);
 
 /* write.c */
+extern int nfs_scan_commit_list(struct list_head *src, struct list_head *dst,
+				int max);
 extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
 		struct list_head *head);
 extern void nfs_pageio_init_write_mds(struct nfs_pageio_descriptor *pgio,

commit c7add9a9720ff5be4715f7a0bb0d9578b2e8534e
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Thu Jan 26 15:11:49 2012 +0400

    NFS: search for client session id in proper network namespace
    
    Network namespace is taken from request transport and passed as a part of
    cb_process_state structure.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index b38b73347af5..0c3648a947d1 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -152,7 +152,8 @@ extern void nfs_cleanup_cb_ident_idr(struct net *);
 extern void nfs_put_client(struct nfs_client *);
 extern struct nfs_client *nfs4_find_client_ident(struct net *, int);
 extern struct nfs_client *
-nfs4_find_client_sessionid(const struct sockaddr *, struct nfs4_sessionid *);
+nfs4_find_client_sessionid(struct net *, const struct sockaddr *,
+				struct nfs4_sessionid *);
 extern struct nfs_server *nfs_create_server(
 					const struct nfs_parsed_mount_data *,
 					struct nfs_fh *);

commit dc03085834a4530b2514708a643cd3fe38f35b21
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Mon Jan 23 17:26:31 2012 +0000

    NFS: make nfs_client_lock per net ns
    
    This patch makes nfs_clients_lock allocated per network namespace. All items it
    protects are already network namespace aware.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 958fff2927c0..b38b73347af5 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -182,9 +182,6 @@ static inline void nfs_fs_proc_exit(void)
 {
 }
 #endif
-#ifdef CONFIG_NFS_V4
-extern spinlock_t nfs_client_lock;
-#endif
 
 /* nfs4namespace.c */
 #ifdef CONFIG_NFS_V4

commit 28cd1b3f262dba56b5e335ba668e342d530f6129
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Mon Jan 23 17:26:22 2012 +0000

    NFS: make cb_ident_idr per net ns
    
    This patch makes ID's infrastructure network namespace aware. This was done
    mainly because of nfs_client_lock, which is desired to be per network
    namespace, but protects NFS clients ID's.
    
    NOTE: NFS client's net pointer have to be set prior to ID initialization,
    proper assignment was moved.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index a9ae8069fff9..958fff2927c0 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -148,9 +148,9 @@ extern void nfs_umount(const struct nfs_mount_request *info);
 extern const struct rpc_program nfs_program;
 extern void nfs_clients_init(struct net *net);
 
-extern void nfs_cleanup_cb_ident_idr(void);
+extern void nfs_cleanup_cb_ident_idr(struct net *);
 extern void nfs_put_client(struct nfs_client *);
-extern struct nfs_client *nfs4_find_client_ident(int);
+extern struct nfs_client *nfs4_find_client_ident(struct net *, int);
 extern struct nfs_client *
 nfs4_find_client_sessionid(const struct sockaddr *, struct nfs4_sessionid *);
 extern struct nfs_server *nfs_create_server(

commit 6b13168b36b6a7f603d962c232f1f2f325705832
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Mon Jan 23 17:26:05 2012 +0000

    NFS: make nfs_client_list per net ns
    
    This patch splits global list of NFS clients into per-net-ns array of lists.
    This looks more strict and clearer.
    BTW, this patch also makes "/proc/fs/nfsfs/servers" entry content depends on
    /proc mount owner pid namespace. See below for details.
    
    NOTE: few words about how was /proc/fs/nfsfs/ entries content show per network
    namespace done. This is a little bit tricky and not the best is could be. But
    it's cheap (proper fix for /proc conteinerization is a hard nut to crack).
    The idea is simple: take proper network namespace from pid namespace
    child reaper nsproxy of /proc/ mount creator.
    This actually means, that if there are 2 containers with different net
    namespace sharing pid namespace, then read of /proc/fs/nfsfs/ entries will
    always return content, taken from net namespace of pid namespace creator task
    (and thus second namespace set wil be unvisible).
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index cdb121d3c6f4..a9ae8069fff9 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -146,6 +146,7 @@ extern void nfs_umount(const struct nfs_mount_request *info);
 
 /* client.c */
 extern const struct rpc_program nfs_program;
+extern void nfs_clients_init(struct net *net);
 
 extern void nfs_cleanup_cb_ident_idr(void);
 extern void nfs_put_client(struct nfs_client *);
@@ -183,7 +184,6 @@ static inline void nfs_fs_proc_exit(void)
 #endif
 #ifdef CONFIG_NFS_V4
 extern spinlock_t nfs_client_lock;
-extern struct list_head nfs_client_list;
 #endif
 
 /* nfs4namespace.c */

commit a613fa168afc19179a7547fbba45644c5b6912bf
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Jan 20 13:53:56 2012 -0500

    SUNRPC: constify the rpc_program
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index eda4cde40fb2..cdb121d3c6f4 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -145,7 +145,7 @@ extern int nfs_mount(struct nfs_mount_request *info);
 extern void nfs_umount(const struct nfs_mount_request *info);
 
 /* client.c */
-extern struct rpc_program nfs_program;
+extern const struct rpc_program nfs_program;
 
 extern void nfs_cleanup_cb_ident_idr(void);
 extern void nfs_put_client(struct nfs_client *);

commit babea479b75a9ea3d84ace6d880513e18397a8bb
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Fri Jan 20 17:19:56 2012 +0400

    NFS: remove unused nfs4_find_client_no_ident function
    
    Looks like this function survived after some cleanup patch without a reason.
    Now it's not called or referenced and I believe, that it can be simply removed.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 2b9836fe4434..eda4cde40fb2 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -149,7 +149,6 @@ extern struct rpc_program nfs_program;
 
 extern void nfs_cleanup_cb_ident_idr(void);
 extern void nfs_put_client(struct nfs_client *);
-extern struct nfs_client *nfs4_find_client_no_ident(const struct sockaddr *);
 extern struct nfs_client *nfs4_find_client_ident(int);
 extern struct nfs_client *
 nfs4_find_client_sessionid(const struct sockaddr *, struct nfs4_sessionid *);

commit eee17325f1dfbe004f1475743bab9e3d050d00f5
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Tue Jan 10 16:13:19 2012 +0400

    NFS: idmap PipeFS notifier introduced
    
    v2:
    1) Added "nfs_idmap_init" and "nfs_idmap_quit" definitions for kernels built
    without CONFIG_NFS_V4 option set.
    
    This patch subscribes NFS clients to RPC pipefs notifications. Idmap notifier
    is registering on NFS module load. This notifier callback is responsible for
    creation/destruction of PipeFS idmap pipe dentry for NFS4 clients.
    
    Since ipdmap pipe is created in rpc client pipefs directory, we have make sure,
    that this directory has been created already. IOW RPC client notifier callback
    has been called already. To achive this, PipeFS notifier priorities has been
    introduced (RPC clients notifier priority is greater than NFS idmap one).
    But this approach gives another problem: unlink for RPC client directory will
    be called before NFS idmap pipe unlink on UMOUNT event and will fail, because
    directory is not empty.
    The solution, introduced in this patch, is to try to remove client directory
    once again after idmap pipe was unlinked. This looks like ugly hack, so
    probably it should be replaced in some more elegant way.
    
    Note that no locking required in notifier callback because PipeFS superblock
    pointer is passed as an argument from it's creation or destruction routine and
    thus we can be sure about it's validity.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index d602188f889f..2b9836fe4434 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -182,6 +182,10 @@ static inline void nfs_fs_proc_exit(void)
 {
 }
 #endif
+#ifdef CONFIG_NFS_V4
+extern spinlock_t nfs_client_lock;
+extern struct list_head nfs_client_list;
+#endif
 
 /* nfs4namespace.c */
 #ifdef CONFIG_NFS_V4

commit 6d59b8d599d594bc314026c6856424fe49df5513
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Tue Jan 10 16:12:54 2012 +0400

    NFS: pass NFS client owner network namespace to RPC client creation routine
    
    This patch replaces static "init_net" with nfs_client->net pointer in RPC
    client creation calls.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 02fb2001a283..d602188f889f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -138,6 +138,7 @@ struct nfs_mount_request {
 	int			noresvport;
 	unsigned int		*auth_flav_len;
 	rpc_authflavor_t	*auth_flavs;
+	struct net		*net;
 };
 
 extern int nfs_mount(struct nfs_mount_request *info);

commit e50a7a1a42335243c94eeea4a8d23413cb02370d
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Tue Jan 10 16:12:46 2012 +0400

    NFS: make NFS client allocated per network namespace context
    
    This patch adds new net variable to nfs_client structure. This variable is set
    on NFS client creation and cheched during matching NFS client search.
    Initially current->nsproxy->net_ns is used as network namespace owner for new
    NFS client to create. This network namespace pointer is set during mount
    options parsing and thus can be passed from user-spave utils in future if will
    be necessary.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 8102db9b926c..02fb2001a283 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -123,6 +123,7 @@ struct nfs_parsed_mount_data {
 	} nfs_server;
 
 	struct security_mnt_opts lsm_opts;
+	struct net		*net;
 };
 
 /* mount_clnt.c */

commit a6bc32b899223a877f595ef9ddc1e89ead5072b8
Author: Mel Gorman <mgorman@suse.de>
Date:   Thu Jan 12 17:19:43 2012 -0800

    mm: compaction: introduce sync-light migration for use by compaction
    
    This patch adds a lightweight sync migrate operation MIGRATE_SYNC_LIGHT
    mode that avoids writing back pages to backing storage.  Async compaction
    maps to MIGRATE_ASYNC while sync compaction maps to MIGRATE_SYNC_LIGHT.
    For other migrate_pages users such as memory hotplug, MIGRATE_SYNC is
    used.
    
    This avoids sync compaction stalling for an excessive length of time,
    particularly when copying files to a USB stick where there might be a
    large number of dirty pages backed by a filesystem that does not support
    ->writepages.
    
    [aarcange@redhat.com: This patch is heavily based on Andrea's work]
    [akpm@linux-foundation.org: fix fs/nfs/write.c build]
    [akpm@linux-foundation.org: fix fs/btrfs/disk-io.c build]
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Minchan Kim <minchan.kim@gmail.com>
    Cc: Dave Jones <davej@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Andy Isaacson <adi@hexapodia.org>
    Cc: Nai Xia <nai.xia@gmail.com>
    Cc: Johannes Weiner <jweiner@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 114398a15830..8102db9b926c 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -332,7 +332,7 @@ void nfs_commit_release_pages(struct nfs_write_data *data);
 
 #ifdef CONFIG_MIGRATION
 extern int nfs_migrate_page(struct address_space *,
-		struct page *, struct page *, bool);
+		struct page *, struct page *, enum migrate_mode);
 #else
 #define nfs_migrate_page NULL
 #endif

commit b969c4ab9f182a6e1b2a0848be349f99714947b0
Author: Mel Gorman <mgorman@suse.de>
Date:   Thu Jan 12 17:19:34 2012 -0800

    mm: compaction: determine if dirty pages can be migrated without blocking within ->migratepage
    
    Asynchronous compaction is used when allocating transparent hugepages to
    avoid blocking for long periods of time.  Due to reports of stalling,
    there was a debate on disabling synchronous compaction but this severely
    impacted allocation success rates.  Part of the reason was that many dirty
    pages are skipped in asynchronous compaction by the following check;
    
            if (PageDirty(page) && !sync &&
                    mapping->a_ops->migratepage != migrate_page)
                            rc = -EBUSY;
    
    This skips over all mapping aops using buffer_migrate_page() even though
    it is possible to migrate some of these pages without blocking.  This
    patch updates the ->migratepage callback with a "sync" parameter.  It is
    the responsibility of the callback to fail gracefully if migration would
    block.
    
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Minchan Kim <minchan.kim@gmail.com>
    Cc: Dave Jones <davej@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Andy Isaacson <adi@hexapodia.org>
    Cc: Nai Xia <nai.xia@gmail.com>
    Cc: Johannes Weiner <jweiner@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5ee92538b063..114398a15830 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -332,7 +332,7 @@ void nfs_commit_release_pages(struct nfs_write_data *data);
 
 #ifdef CONFIG_MIGRATION
 extern int nfs_migrate_page(struct address_space *,
-		struct page *, struct page *);
+		struct page *, struct page *, bool);
 #else
 #define nfs_migrate_page NULL
 #endif

commit e2fecb215b321db0e4a5b2597349a63c07bec42f
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Jan 6 08:57:46 2012 -0500

    NFS: Remove pNFS bloat from the generic write path
    
    We have no business doing any this in the standard write release path.
    Get rid of it, and put it in the pNFS layer.
    
    Also, while we're at it, get rid of the completely bogus unlock/relock
    semantics that were present in nfs_writeback_release_full(). It is
    not only unnecessary, but actually dangerous to release the write lock
    just in order to take it again in nfs_page_async_flush(). Better just
    to open code the pgio operations in a pnfs helper.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 3f4d95751d52..5ee92538b063 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -307,6 +307,8 @@ extern void nfs_readdata_release(struct nfs_read_data *rdata);
 /* write.c */
 extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
 		struct list_head *head);
+extern void nfs_pageio_init_write_mds(struct nfs_pageio_descriptor *pgio,
+				  struct inode *inode, int ioflags);
 extern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_writedata_release(struct nfs_write_data *wdata);
 extern void nfs_commit_free(struct nfs_write_data *p);

commit 62e4a76987eab2b7fa952546614bc83e5bfc9d3e
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Nov 10 14:30:37 2011 -0500

    NFS: Revert pnfs ugliness from the generic NFS read code path
    
    pNFS-specific code belongs in the pnfs layer. It should not be
    hijacking generic NFS read or write code paths.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index c1a1bd8ddf1c..3f4d95751d52 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -299,6 +299,8 @@ extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 extern int nfs_generic_pagein(struct nfs_pageio_descriptor *desc,
 		struct list_head *head);
 
+extern void nfs_pageio_init_read_mds(struct nfs_pageio_descriptor *pgio,
+		struct inode *inode);
 extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_readdata_release(struct nfs_read_data *rdata);
 

commit d00c5d43866720963a265fa3129f3203cac35b8e
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Oct 19 12:17:29 2011 -0700

    NFS: Get rid of nfs_restart_rpc()
    
    It can trivially be replaced with rpc_restart_call_prepare.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index ab12913dd473..c1a1bd8ddf1c 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -457,13 +457,3 @@ unsigned int nfs_page_array_len(unsigned int base, size_t len)
 		PAGE_SIZE - 1) >> PAGE_SHIFT;
 }
 
-/*
- * Helper for restarting RPC calls in the possible presence of NFSv4.1
- * sessions.
- */
-static inline int nfs_restart_rpc(struct rpc_task *task, const struct nfs_client *clp)
-{
-	if (nfs4_has_session(clp))
-		return rpc_restart_call_prepare(task);
-	return rpc_restart_call(task);
-}

commit 1f9453578f059d2651aa6c6b16756627fc9f2a74
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Jul 13 15:59:57 2011 -0400

    NFS: Clean up - simplify the switch to read/write-through-MDS
    
    Use nfs_pageio_reset_read_mds and nfs_pageio_reset_write_mds instead of
    completely reinitialising the struct nfs_pageio_descriptor.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 09e20de31901..ab12913dd473 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -299,16 +299,12 @@ extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 extern int nfs_generic_pagein(struct nfs_pageio_descriptor *desc,
 		struct list_head *head);
 
-extern void nfs_pageio_init_read_mds(struct nfs_pageio_descriptor *pgio,
-		struct inode *inode);
 extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_readdata_release(struct nfs_read_data *rdata);
 
 /* write.c */
 extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
 		struct list_head *head);
-extern void nfs_pageio_init_write_mds(struct nfs_pageio_descriptor *pgio,
-				  struct inode *inode, int ioflags);
 extern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_writedata_release(struct nfs_write_data *wdata);
 extern void nfs_commit_free(struct nfs_write_data *p);

commit dce81290eed64d24493989bb7a08f9e20495e184
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Jul 13 15:59:19 2011 -0400

    NFS: Move the pnfs write code into pnfs.c
    
    ...and ensure that we recoalese to take into account differences in
    differences in block sizes when falling back to write through the MDS.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index d74d7dea9173..09e20de31901 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -305,8 +305,12 @@ extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
 extern void nfs_readdata_release(struct nfs_read_data *rdata);
 
 /* write.c */
+extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
+		struct list_head *head);
 extern void nfs_pageio_init_write_mds(struct nfs_pageio_descriptor *pgio,
 				  struct inode *inode, int ioflags);
+extern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);
+extern void nfs_writedata_release(struct nfs_write_data *wdata);
 extern void nfs_commit_free(struct nfs_write_data *p);
 extern int nfs_initiate_write(struct nfs_write_data *data,
 			      struct rpc_clnt *clnt,

commit 493292ddc78d18ee2ad2d5c24c2b7dd6a24641d2
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Jul 13 15:58:28 2011 -0400

    NFS: Move the pnfs read code into pnfs.c
    
    ...and ensure that we recoalese to take into account differences in
    block sizes when falling back to read through the MDS.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 31e8b50011af..d74d7dea9173 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -291,14 +291,18 @@ extern struct dentry *nfs4_get_root(struct super_block *, struct nfs_fh *,
 extern int nfs4_get_rootfh(struct nfs_server *server, struct nfs_fh *mntfh);
 #endif
 
+struct nfs_pageio_descriptor;
 /* read.c */
 extern int nfs_initiate_read(struct nfs_read_data *data, struct rpc_clnt *clnt,
 			     const struct rpc_call_ops *call_ops);
 extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
+extern int nfs_generic_pagein(struct nfs_pageio_descriptor *desc,
+		struct list_head *head);
 
-struct nfs_pageio_descriptor;
 extern void nfs_pageio_init_read_mds(struct nfs_pageio_descriptor *pgio,
 		struct inode *inode);
+extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
+extern void nfs_readdata_release(struct nfs_read_data *rdata);
 
 /* write.c */
 extern void nfs_pageio_init_write_mds(struct nfs_pageio_descriptor *pgio,

commit e885de1a5bc9f46ef8f934c5a7602c89d2d51e8d
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Jun 10 13:30:23 2011 -0400

    NFSv4.1: Fall back to ordinary i/o through the mds if we have no layout segment
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index fc017eadfe08..31e8b50011af 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -296,7 +296,13 @@ extern int nfs_initiate_read(struct nfs_read_data *data, struct rpc_clnt *clnt,
 			     const struct rpc_call_ops *call_ops);
 extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 
+struct nfs_pageio_descriptor;
+extern void nfs_pageio_init_read_mds(struct nfs_pageio_descriptor *pgio,
+		struct inode *inode);
+
 /* write.c */
+extern void nfs_pageio_init_write_mds(struct nfs_pageio_descriptor *pgio,
+				  struct inode *inode, int ioflags);
 extern void nfs_commit_free(struct nfs_write_data *p);
 extern int nfs_initiate_write(struct nfs_write_data *data,
 			      struct rpc_clnt *clnt,

commit fca78d6d2c77f87d7dbee89bbe4836a44da881e2
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Thu Jun 2 14:59:07 2011 -0400

    NFS: Add SECINFO_NO_NAME procedure
    
    If the client is using NFS v4.1, then we can use SECINFO_NO_NAME to find
    the secflavor for the initial mount.  If the server doesn't support
    SECINFO_NO_NAME then I fall back on the "guess and check" method used
    for v4.0 mounts.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 2a55347a2daa..fc017eadfe08 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -277,6 +277,9 @@ extern void nfs_sb_deactive(struct super_block *sb);
 extern char *nfs_path(char **p, struct dentry *dentry,
 		      char *buffer, ssize_t buflen);
 extern struct vfsmount *nfs_d_automount(struct path *path);
+#ifdef CONFIG_NFS_V4
+rpc_authflavor_t nfs_find_best_sec(struct nfs4_secinfo_flavors *);
+#endif
 
 /* getroot.c */
 extern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *,

commit 533eb4611c9eea53072eb6a61d5a6393b6a77ed7
Author: Andy Adamson <andros@netapp.com>
Date:   Mon Jun 13 18:25:56 2011 -0400

    NFSv4.1: allow nfs_fhget to succeed with mounted on fileid
    
    Commit 28331a46d88459788c8fca72dbb0415cd7f514c9 "Ensure we request the
    ordinary fileid when doing readdirplus"
    changed the meaning of NFS_ATTR_FATTR_FILEID which used to be set when
    FATTR4_WORD1_MOUNTED_ON_FILED was requested.
    
    Allow nfs_fhget to succeed with only a mounted on fileid when crossing
    a mountpoint or a referral.
    
    Ask for the fileid of the absent file system if mounted_on_fileid is not
    supported.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    cc:stable@kernel.org [2.6.39]
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index b9056cbe68d6..2a55347a2daa 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -45,6 +45,17 @@ static inline void nfs_attr_check_mountpoint(struct super_block *parent, struct
 		fattr->valid |= NFS_ATTR_FATTR_MOUNTPOINT;
 }
 
+static inline int nfs_attr_use_mounted_on_fileid(struct nfs_fattr *fattr)
+{
+	if (((fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID) == 0) ||
+	    (((fattr->valid & NFS_ATTR_FATTR_MOUNTPOINT) == 0) &&
+	     ((fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) == 0)))
+		return 0;
+
+	fattr->fileid = fattr->mounted_on_fileid;
+	return 1;
+}
+
 struct nfs_clone_mount {
 	const struct super_block *sb;
 	const struct dentry *dentry;

commit cd1acdf1723d71b28175f95b04305f1cc74ce363
Merge: fac04863cef5 9342077011d5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun May 29 14:10:13 2011 -0700

    Merge branch 'pnfs-submit' of git://git.open-osd.org/linux-open-osd
    
    * 'pnfs-submit' of git://git.open-osd.org/linux-open-osd: (32 commits)
      pnfs-obj: pg_test check for max_io_size
      NFSv4.1: define nfs_generic_pg_test
      NFSv4.1: use pnfs_generic_pg_test directly by layout driver
      NFSv4.1: change pg_test return type to bool
      NFSv4.1: unify pnfs_pageio_init functions
      pnfs-obj: objlayout_encode_layoutcommit implementation
      pnfs: encode_layoutcommit
      pnfs-obj: report errors and .encode_layoutreturn Implementation.
      pnfs: encode_layoutreturn
      pnfs: layoutret_on_setattr
      pnfs: layoutreturn
      pnfs-obj: osd raid engine read/write implementation
      pnfs: support for non-rpc layout drivers
      pnfs-obj: define per-inode private structure
      pnfs: alloc and free layout_hdr layoutdriver methods
      pnfs-obj: objio_osd device information retrieval and caching
      pnfs-obj: decode layout, alloc/free lseg
      pnfs-obj: pnfs_osd XDR client implementation
      pnfs-obj: pnfs_osd XDR definitions
      pnfs-obj: objlayoutdriver module skeleton
      ...

commit d20581aa4be11407c9eeeb75992df5ef176bba0f
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Sun May 22 19:52:03 2011 +0300

    pnfs: support for non-rpc layout drivers
    
    Non-rpc layout driver such as for objects and blocks
    implement their own I/O path and error handling logic.
    Therefore bypass NFS-based error handling for these layout drivers.
    
    [fix lseg ref-count bugs, and null de-refs]
    [Fall out from: non-rpc layout drivers]
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    [get rid of PNFS_USE_RPC_CODE]
    [get rid of __nfs4_write_done_cb]
    [revert useless change in nfs4_write_done_cb]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index ce118ce885dd..bcf0f0ff5eeb 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -310,6 +310,7 @@ extern int nfs_migrate_page(struct address_space *,
 #endif
 
 /* nfs4proc.c */
+extern void __nfs4_read_done_cb(struct nfs_read_data *);
 extern void nfs4_reset_read(struct rpc_task *task, struct nfs_read_data *data);
 extern int nfs4_init_client(struct nfs_client *clp,
 			    const struct rpc_timeout *timeparms,

commit 1495f230fa7750479c79e3656286b9183d662077
Author: Ying Han <yinghan@google.com>
Date:   Tue May 24 17:12:27 2011 -0700

    vmscan: change shrinker API by passing shrink_control struct
    
    Change each shrinker's API by consolidating the existing parameters into
    shrink_control struct.  This will simplify any further features added w/o
    touching each file of shrinker.
    
    [akpm@linux-foundation.org: fix build]
    [akpm@linux-foundation.org: fix warning]
    [kosaki.motohiro@jp.fujitsu.com: fix up new shrinker API]
    [akpm@linux-foundation.org: fix xfs warning]
    [akpm@linux-foundation.org: update gfs2]
    Signed-off-by: Ying Han <yinghan@google.com>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: Minchan Kim <minchan.kim@gmail.com>
    Acked-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Mel Gorman <mel@csn.ul.ie>
    Acked-by: Rik van Riel <riel@redhat.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Dave Hansen <dave@linux.vnet.ibm.com>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index ce118ce885dd..2df6ca7b5898 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -234,7 +234,7 @@ extern int nfs_init_client(struct nfs_client *clp,
 
 /* dir.c */
 extern int nfs_access_cache_shrinker(struct shrinker *shrink,
-					int nr_to_scan, gfp_t gfp_mask);
+					struct shrink_control *sc);
 
 /* inode.c */
 extern struct workqueue_struct *nfsiod_workqueue;

commit 0acd2201920d0968919f4f5797d63f7b6f2b19d4
Merge: 8f70e95f9f41 35124a0994fc
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Mar 24 17:03:14 2011 -0400

    Merge branch 'nfs-for-2.6.39' into nfs-for-next

commit 7ebb931598cd95cccea10d4bc4c0123a464ea565
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Thu Mar 24 17:12:30 2011 +0000

    NFS: use secinfo when crossing mountpoints
    
    A submount may use different security than the parent
    mount does.  We should figure out what sec flavor the
    submount uses at mount time.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 1ec5d0662ede..345d86b90e26 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -39,6 +39,12 @@ static inline int nfs4_has_persistent_session(const struct nfs_client *clp)
 	return 0;
 }
 
+static inline void nfs_attr_check_mountpoint(struct super_block *parent, struct nfs_fattr *fattr)
+{
+	if (!nfs_fsid_equal(&NFS_SB(parent)->fsid, &fattr->fsid))
+		fattr->valid |= NFS_ATTR_FATTR_MOUNTPOINT;
+}
+
 struct nfs_clone_mount {
 	const struct super_block *sb;
 	const struct dentry *dentry;
@@ -214,6 +220,7 @@ extern const u32 nfs41_maxwrite_overhead;
 /* nfs4proc.c */
 #ifdef CONFIG_NFS_V4
 extern struct rpc_procinfo nfs4_procedures[];
+void nfs_fixup_secinfo_attributes(struct nfs_fattr *, struct nfs_fh *);
 #endif
 
 extern int nfs4_init_ds_session(struct nfs_client *clp);

commit 7c5130588d691a3b34d02312f1bd1b6d56fe0100
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Thu Mar 24 17:12:24 2011 +0000

    NFS: lookup supports alternate client
    
    A later patch will need to perform a lookup using an
    alternate client with a different security flavor.
    This patch adds support for doing that on NFS v4.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 72e0bddf7a2f..1ec5d0662ede 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -296,12 +296,14 @@ extern int nfs4_init_client(struct nfs_client *clp,
 			    rpc_authflavor_t authflavour,
 			    int noresvport);
 extern void nfs4_reset_write(struct rpc_task *task, struct nfs_write_data *data);
-extern int _nfs4_call_sync(struct nfs_server *server,
+extern int _nfs4_call_sync(struct rpc_clnt *clnt,
+			   struct nfs_server *server,
 			   struct rpc_message *msg,
 			   struct nfs4_sequence_args *args,
 			   struct nfs4_sequence_res *res,
 			   int cache_reply);
-extern int _nfs4_call_sync_session(struct nfs_server *server,
+extern int _nfs4_call_sync_session(struct rpc_clnt *clnt,
+				   struct nfs_server *server,
 				   struct rpc_message *msg,
 				   struct nfs4_sequence_args *args,
 				   struct nfs4_sequence_res *res,

commit e0c2b3801828aadb65dec9f67f7c6b7a675ad007
Author: Fred Isaman <iisaman@netapp.com>
Date:   Wed Mar 23 13:27:53 2011 +0000

    NFSv4.1: filelayout driver specific code for COMMIT
    
    Implement all the hooks created in the previous patches.
    This requires exporting quite a few functions and adding a few
    structure fields.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index d1ddc23c404d..708705062216 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -276,11 +276,25 @@ extern int nfs_initiate_read(struct nfs_read_data *data, struct rpc_clnt *clnt,
 extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 
 /* write.c */
+extern void nfs_commit_free(struct nfs_write_data *p);
 extern int nfs_initiate_write(struct nfs_write_data *data,
 			      struct rpc_clnt *clnt,
 			      const struct rpc_call_ops *call_ops,
 			      int how);
 extern void nfs_write_prepare(struct rpc_task *task, void *calldata);
+extern int nfs_initiate_commit(struct nfs_write_data *data,
+			       struct rpc_clnt *clnt,
+			       const struct rpc_call_ops *call_ops,
+			       int how);
+extern void nfs_init_commit(struct nfs_write_data *data,
+			    struct list_head *head,
+			    struct pnfs_layout_segment *lseg);
+void nfs_retry_commit(struct list_head *page_list,
+		      struct pnfs_layout_segment *lseg);
+void nfs_commit_clear_lock(struct nfs_inode *nfsi);
+void nfs_commitdata_release(void *data);
+void nfs_commit_release_pages(struct nfs_write_data *data);
+
 #ifdef CONFIG_MIGRATION
 extern int nfs_migrate_page(struct address_space *,
 		struct page *, struct page *);

commit 179198373cf374f0ef793f1023c1cdd83b53674d
Merge: 374e55251cac 8e26de238fd7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 17 17:40:00 2011 -0700

    Merge branch 'nfs-for-2.6.39' of git://git.linux-nfs.org/projects/trondmy/nfs-2.6
    
    * 'nfs-for-2.6.39' of git://git.linux-nfs.org/projects/trondmy/nfs-2.6: (54 commits)
      RPC: killing RPC tasks races fixed
      xprt: remove redundant check
      SUNRPC: Convert struct rpc_xprt to use atomic_t counters
      SUNRPC: Ensure we always run the tk_callback before tk_action
      sunrpc: fix printk format warning
      xprt: remove redundant null check
      nfs: BKL is no longer needed, so remove the include
      NFS: Fix a warning in fs/nfs/idmap.c
      Cleanup: Factor out some cut-and-paste code.
      cleanup: save 60 lines/100 bytes by combining two mostly duplicate functions.
      NFS: account direct-io into task io accounting
      gss:krb5 only include enctype numbers in gm_upcall_enctypes
      RPCRDMA: Fix FRMR registration/invalidate handling.
      RPCRDMA: Fix to XDR page base interpretation in marshalling logic.
      NFSv4: Send unmapped uid/gids to the server when using auth_sys
      NFSv4: Propagate the error NFS4ERR_BADOWNER to nfs4_do_setattr
      NFSv4: cleanup idmapper functions to take an nfs_server argument
      NFSv4: Send unmapped uid/gids to the server if the idmapper fails
      NFSv4: If the server sends us a numeric uid/gid then accept it
      NFSv4.1: reject zero layout with zeroed stripe unit
      ...

commit f8ad9c4bae99854c961ca79ed130a0d11d9ab53c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Mar 16 06:32:07 2011 -0400

    nfs: nfs_do_{ref,sub}mount() superblock argument is redundant
    
    It's always equal to dentry->d_sb
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index f0234118d044..e94ad22da5d2 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -163,10 +163,10 @@ static inline void nfs_fs_proc_exit(void)
 
 /* nfs4namespace.c */
 #ifdef CONFIG_NFS_V4
-extern struct vfsmount *nfs_do_refmount(struct super_block *sb, struct dentry *dentry);
+extern struct vfsmount *nfs_do_refmount(struct dentry *dentry);
 #else
 static inline
-struct vfsmount *nfs_do_refmount(struct super_block *sb, struct dentry *dentry)
+struct vfsmount *nfs_do_refmount(struct dentry *dentry)
 {
 	return ERR_PTR(-ENOENT);
 }

commit b514f872f86d4b0c13fed74a1fe1f7ab500c4fd0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Mar 16 06:26:11 2011 -0400

    nfs: make nfs_path() work without vfsmount
    
    part 3: now we have everything to get nfs_path() just by dentry -
    just follow to (disconnected) root and pick the rest of the thing
    there.
    
    Start killing propagation of struct vfsmount * on the paths that
    used to bring it to nfs_path().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 9e5a003ccc53..f0234118d044 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -163,10 +163,10 @@ static inline void nfs_fs_proc_exit(void)
 
 /* nfs4namespace.c */
 #ifdef CONFIG_NFS_V4
-extern struct vfsmount *nfs_do_refmount(const struct vfsmount *mnt_parent, struct dentry *dentry);
+extern struct vfsmount *nfs_do_refmount(struct super_block *sb, struct dentry *dentry);
 #else
 static inline
-struct vfsmount *nfs_do_refmount(const struct vfsmount *mnt_parent, struct dentry *dentry)
+struct vfsmount *nfs_do_refmount(struct super_block *sb, struct dentry *dentry)
 {
 	return ERR_PTR(-ENOENT);
 }
@@ -247,9 +247,7 @@ extern void nfs_sb_active(struct super_block *sb);
 extern void nfs_sb_deactive(struct super_block *sb);
 
 /* namespace.c */
-extern char *nfs_path(const char *base,
-		      const struct dentry *droot,
-		      const struct dentry *dentry,
+extern char *nfs_path(char **p, struct dentry *dentry,
 		      char *buffer, ssize_t buflen);
 extern struct vfsmount *nfs_d_automount(struct path *path);
 
@@ -290,12 +288,11 @@ extern int _nfs4_call_sync_session(struct nfs_server *server,
 /*
  * Determine the device name as a string
  */
-static inline char *nfs_devname(const struct vfsmount *mnt_parent,
-				const struct dentry *dentry,
+static inline char *nfs_devname(struct dentry *dentry,
 				char *buffer, ssize_t buflen)
 {
-	return nfs_path(mnt_parent->mnt_devname, mnt_parent->mnt_root,
-			dentry, buffer, buflen);
+	char *dummy;
+	return nfs_path(&dummy, dentry, buffer, buflen);
 }
 
 /*

commit 0d5839ad05acd0fe2a84a39f33ac5efdf634a5a5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Mar 16 05:27:27 2011 -0400

    nfs: propagate devname to nfs{,4}_get_root()
    
    step 1 of ->mnt_devname fixes: make sure we have the value of devname
    available in ..._get_root().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index cf9fdbdabc67..9e5a003ccc53 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -254,9 +254,11 @@ extern char *nfs_path(const char *base,
 extern struct vfsmount *nfs_d_automount(struct path *path);
 
 /* getroot.c */
-extern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *);
+extern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *,
+				   const char *);
 #ifdef CONFIG_NFS_V4
-extern struct dentry *nfs4_get_root(struct super_block *, struct nfs_fh *);
+extern struct dentry *nfs4_get_root(struct super_block *, struct nfs_fh *,
+				    const char *);
 
 extern int nfs4_get_rootfh(struct nfs_server *server, struct nfs_fh *mntfh);
 #endif

commit a69aef1496726ed88386dad65abfcc8cd3195304
Author: Fred Isaman <iisaman@netapp.com>
Date:   Thu Mar 3 15:13:47 2011 +0000

    NFSv4.1: pnfs filelayout driver write
    
    Allows the pnfs filelayout driver to write to the data servers.
    
    Note that COMMIT to data servers will be implemented in a future
    patch.  To avoid improper behavior, for the moment any WRITE to a data
    server that would also require a COMMIT to the data server is sent
    NFS_FILE_SYNC.
    
    Signed-off-by: Andy Adamson <andros@citi.umich.edu>
    Signed-off-by: Dean Hildebrand <dhildeb@us.ibm.com>
    Signed-off-by: Fred Isaman <iisaman@citi.umich.edu>
    Signed-off-by: Mingyang Guo <guomingyang@nrchpc.ac.cn>
    Signed-off-by: Oleg Drokin <green@linuxhacker.ru>
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 1a3228e9ea22..d1ddc23c404d 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -276,6 +276,10 @@ extern int nfs_initiate_read(struct nfs_read_data *data, struct rpc_clnt *clnt,
 extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 
 /* write.c */
+extern int nfs_initiate_write(struct nfs_write_data *data,
+			      struct rpc_clnt *clnt,
+			      const struct rpc_call_ops *call_ops,
+			      int how);
 extern void nfs_write_prepare(struct rpc_task *task, void *calldata);
 #ifdef CONFIG_MIGRATION
 extern int nfs_migrate_page(struct address_space *,
@@ -291,6 +295,7 @@ extern int nfs4_init_client(struct nfs_client *clp,
 			    const char *ip_addr,
 			    rpc_authflavor_t authflavour,
 			    int noresvport);
+extern void nfs4_reset_write(struct rpc_task *task, struct nfs_write_data *data);
 extern int _nfs4_call_sync(struct nfs_server *server,
 			   struct rpc_message *msg,
 			   struct nfs4_sequence_args *args,

commit cbdabc7f8bf14ca1d40ab1cb86f64b3bc09716e8
Author: Andy Adamson <andros@netapp.com>
Date:   Tue Mar 1 01:34:20 2011 +0000

    NFSv4.1: filelayout async error handler
    
    Use our own async error handler.
    Mark the layout as failed and retry i/o through the MDS on specified errors.
    
    Update the mds_offset in nfs_readpage_retry so that a failed short-read retry
    to a DS gets correctly resent through the MDS.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5e9df992cd73..1a3228e9ea22 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -285,6 +285,7 @@ extern int nfs_migrate_page(struct address_space *,
 #endif
 
 /* nfs4proc.c */
+extern void nfs4_reset_read(struct rpc_task *task, struct nfs_read_data *data);
 extern int nfs4_init_client(struct nfs_client *clp,
 			    const struct rpc_timeout *timeparms,
 			    const char *ip_addr,

commit dc70d7b3189597f313df7bd2da849cfc39063b15
Author: Andy Adamson <andros@netapp.com>
Date:   Tue Mar 1 01:34:19 2011 +0000

    NFSv4.1: filelayout read
    
    Attempt a pNFS file layout read by setting up the nfs_read_data struct and
    calling nfs_initiate_read with the data server rpc client and the
    filelayout rpc call ops.
    
    Error handling is implemented in a subsequent patch.
    
    Signed-off-by: Andy Adamson <andros@citi.umich.edu>
    Signed-off-by: Dean Hildebrand <dhildeb@us.ibm.com>
    Signed-off-by: Fred Isaman <iisaman@citi.umich.edu>
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Mingyang Guo <guomingyang@nrchpc.ac.cn>
    Signed-off-by: Oleg Drokin <green@linuxhacker.ru>
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Tested-by: Guo Mingyang <guomingyang@nrchpc.ac.cn>
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5cc92014259e..5e9df992cd73 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -271,6 +271,8 @@ extern int nfs4_get_rootfh(struct nfs_server *server, struct nfs_fh *mntfh);
 #endif
 
 /* read.c */
+extern int nfs_initiate_read(struct nfs_read_data *data, struct rpc_clnt *clnt,
+			     const struct rpc_call_ops *call_ops);
 extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 
 /* write.c */

commit d83217c13531fd59730d77b5c2284e90e56c0a50
Author: Andy Adamson <andros@netapp.com>
Date:   Tue Mar 1 01:34:17 2011 +0000

    NFSv4.1: data server connection
    
    Introduce a data server set_client and init session following the
    nfs4_set_client and  nfs4_init_session convention.
    
    Once a new nfs_client is on the nfs_client_list, the nfs_client cl_cons_state
    serializes access to creating an nfs_client struct with matching properties.
    
    Use the new nfs_get_client() that initializes new clients.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 4d7b3a97e522..5cc92014259e 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -148,6 +148,9 @@ extern struct nfs_server *nfs_clone_server(struct nfs_server *,
 					   struct nfs_fattr *);
 extern void nfs_mark_client_ready(struct nfs_client *clp, int state);
 extern int nfs4_check_client_ready(struct nfs_client *clp);
+extern struct nfs_client *nfs4_set_ds_client(struct nfs_client* mds_clp,
+					     const struct sockaddr *ds_addr,
+					     int ds_addrlen, int ds_proto);
 #ifdef CONFIG_PROC_FS
 extern int __init nfs_fs_proc_init(void);
 extern void nfs_fs_proc_exit(void);
@@ -213,6 +216,8 @@ extern const u32 nfs41_maxwrite_overhead;
 extern struct rpc_procinfo nfs4_procedures[];
 #endif
 
+extern int nfs4_init_ds_session(struct nfs_client *clp);
+
 /* proc.c */
 void nfs_close_context(struct nfs_open_context *ctx, int is_sync);
 extern int nfs_init_client(struct nfs_client *clp,

commit 45a52a02072b2a7e265f024cfdb00127e08dd9f2
Author: Andy Adamson <andros@netapp.com>
Date:   Tue Mar 1 01:34:08 2011 +0000

    NFS move nfs_client initialization into nfs_get_client
    
    Now nfs_get_client returns an nfs_client ready to be used no matter if it was
    found or created.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index cf9fdbdabc67..4d7b3a97e522 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -215,6 +215,10 @@ extern struct rpc_procinfo nfs4_procedures[];
 
 /* proc.c */
 void nfs_close_context(struct nfs_open_context *ctx, int is_sync);
+extern int nfs_init_client(struct nfs_client *clp,
+			   const struct rpc_timeout *timeparms,
+			   const char *ip_addr, rpc_authflavor_t authflavour,
+			   int noresvport);
 
 /* dir.c */
 extern int nfs_access_cache_shrinker(struct shrinker *shrink,
@@ -274,6 +278,11 @@ extern int nfs_migrate_page(struct address_space *,
 #endif
 
 /* nfs4proc.c */
+extern int nfs4_init_client(struct nfs_client *clp,
+			    const struct rpc_timeout *timeparms,
+			    const char *ip_addr,
+			    rpc_authflavor_t authflavour,
+			    int noresvport);
 extern int _nfs4_call_sync(struct nfs_server *server,
 			   struct rpc_message *msg,
 			   struct nfs4_sequence_args *args,

commit 778be232a207e79088ba70d832ac25dfea6fbf1a
Author: Andy Adamson <andros@netapp.com>
Date:   Tue Jan 25 15:38:01 2011 +0000

    NFS do not find client in NFSv4 pg_authenticate
    
    The information required to find the nfs_client cooresponding to the incoming
    back channel request is contained in the NFS layer. Perform minimal checking
    in the RPC layer pg_authenticate method, and push more detailed checking into
    the NFS layer where the nfs_client can be found.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 4644f04b4b46..cf9fdbdabc67 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -133,8 +133,7 @@ extern void nfs_put_client(struct nfs_client *);
 extern struct nfs_client *nfs4_find_client_no_ident(const struct sockaddr *);
 extern struct nfs_client *nfs4_find_client_ident(int);
 extern struct nfs_client *
-nfs4_find_client_sessionid(const struct sockaddr *, struct nfs4_sessionid *,
-			   int);
+nfs4_find_client_sessionid(const struct sockaddr *, struct nfs4_sessionid *);
 extern struct nfs_server *nfs_create_server(
 					const struct nfs_parsed_mount_data *,
 					struct nfs_fh *);

commit 36d43a43761b004ad1879ac21471d8fc5f3157ec
Author: David Howells <dhowells@redhat.com>
Date:   Fri Jan 14 18:45:42 2011 +0000

    NFS: Use d_automount() rather than abusing follow_link()
    
    Make NFS use the new d_automount() dentry operation rather than abusing
    follow_link() on directories.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Acked-by: Ian Kent <raven@themaw.net>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index bfa3a34af801..4644f04b4b46 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -252,6 +252,7 @@ extern char *nfs_path(const char *base,
 		      const struct dentry *droot,
 		      const struct dentry *dentry,
 		      char *buffer, ssize_t buflen);
+extern struct vfsmount *nfs_d_automount(struct path *path);
 
 /* getroot.c */
 extern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *);

commit c36fca52f5e4594ffd0ff175b328966b0d393184
Author: Andy Adamson <andros@netapp.com>
Date:   Thu Jan 6 02:04:32 2011 +0000

    NFS refactor nfs_find_client and reference client across callback processing
    
    Fixes a bug where the nfs_client could be freed during callback processing.
    Refactor nfs_find_client to use minorversion specific means to locate the
    correct nfs_client structure.
    
    In the NFS layer, V4.0 clients are found using the callback_ident field in the
    CB_COMPOUND header.  V4.1 clients are found using the sessionID in the
    CB_SEQUENCE operation which is also compared against the sessionID associated
    with the back channel thread after a successful CREATE_SESSION.
    
    Each of these methods finds the one an only nfs_client associated
    with the incoming callback request - so nfs_find_client_next is not needed.
    
    In the RPC layer, the pg_authenticate call needs to find the nfs_client. For
    the v4.0 callback service, the callback identifier has not been decoded so a
    search by address, version, and minorversion is used.  The sessionid for the
    sessions based callback service has (usually) not been set for the
    pg_authenticate on a CB_NULL call which can be sent prior to the return
    of a CREATE_SESSION call, so the sessionid associated with the back channel
    thread is not used to find the client in pg_authenticate for CB_NULL calls.
    
    Pass the referenced nfs_client to each CB_COMPOUND operation being proceesed
    via the new cb_process_state structure. The reference is held across
    cb_compound processing.
    
    Use the new cb_process_state struct to move the NFS4ERR_RETRY_UNCACHED_REP
    processing from process_op into nfs4_callback_sequence where it belongs.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7c803c916574..bfa3a34af801 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -130,8 +130,11 @@ extern struct rpc_program nfs_program;
 
 extern void nfs_cleanup_cb_ident_idr(void);
 extern void nfs_put_client(struct nfs_client *);
-extern struct nfs_client *nfs_find_client(const struct sockaddr *, u32);
-extern struct nfs_client *nfs_find_client_next(struct nfs_client *);
+extern struct nfs_client *nfs4_find_client_no_ident(const struct sockaddr *);
+extern struct nfs_client *nfs4_find_client_ident(int);
+extern struct nfs_client *
+nfs4_find_client_sessionid(const struct sockaddr *, struct nfs4_sessionid *,
+			   int);
 extern struct nfs_server *nfs_create_server(
 					const struct nfs_parsed_mount_data *,
 					struct nfs_fh *);

commit f4eecd5da3422e82e88e36c33cbd2595eebcacb1
Author: Andy Adamson <andros@netapp.com>
Date:   Thu Jan 6 02:04:30 2011 +0000

    NFS implement v4.0 callback_ident
    
    Use the small id to pointer translator service to provide a unique callback
    identifier per SETCLIENTID call used to identify the v4.0 callback service
    associated with the clientid.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 435eae3666bd..7c803c916574 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -128,6 +128,7 @@ extern void nfs_umount(const struct nfs_mount_request *info);
 /* client.c */
 extern struct rpc_program nfs_program;
 
+extern void nfs_cleanup_cb_ident_idr(void);
 extern void nfs_put_client(struct nfs_client *);
 extern struct nfs_client *nfs_find_client(const struct sockaddr *, u32);
 extern struct nfs_client *nfs_find_client_next(struct nfs_client *);

commit 573c4e1ef53a6b891b73cc2257e1604da754a2e4
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Dec 14 14:58:11 2010 +0000

    NFS: Simplify ->decode_dirent() calling sequence
    
    Clean up.
    
    The pointer returned by ->decode_dirent() is no longer used as a
    pointer.  The only call site (xdr_decode() in fs/nfs/dir.c) simply
    extracts the errno value encoded in the pointer.  Replace the
    returned pointer with a standard integer errno return value.
    
    Also, pass the "server" argument as part of the nfs_entry instead of
    as a separate parameter.  It's faster to derive "server" in
    nfs_readdir_xdr_to_array() since we already have the directory's inode
    handy.  "server" ought to be invariant for a set of entries in the
    same directory, right?
    
    The legacy versions of decode_dirent() don't use "server" anyway, so
    it's wasted work for them to derive and pass "server" for each entry.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Tested-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 6c6a9955bae9..435eae3666bd 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -187,15 +187,18 @@ extern void nfs_destroy_directcache(void);
 /* nfs2xdr.c */
 extern int nfs_stat_to_errno(enum nfs_stat);
 extern struct rpc_procinfo nfs_procedures[];
-extern __be32 *nfs2_decode_dirent(struct xdr_stream *, struct nfs_entry *, struct nfs_server *, int);
+extern int nfs2_decode_dirent(struct xdr_stream *,
+				struct nfs_entry *, int);
 
 /* nfs3xdr.c */
 extern struct rpc_procinfo nfs3_procedures[];
-extern __be32 *nfs3_decode_dirent(struct xdr_stream *, struct nfs_entry *, struct nfs_server *, int);
+extern int nfs3_decode_dirent(struct xdr_stream *,
+				struct nfs_entry *, int);
 
 /* nfs4xdr.c */
 #ifdef CONFIG_NFS_V4
-extern __be32 *nfs4_decode_dirent(struct xdr_stream *, struct nfs_entry *, struct nfs_server *, int);
+extern int nfs4_decode_dirent(struct xdr_stream *,
+				struct nfs_entry *, int);
 #endif
 #ifdef CONFIG_NFS_V4_1
 extern const u32 nfs41_maxread_overhead;

commit f796f8b3ae292abb9cb2931e8db6fc1d69bba09d
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Dec 14 14:55:10 2010 +0000

    NFS: Introduce new-style XDR decoding functions for NFSv2
    
    We'd like to prevent local buffer overflows caused by malicious or
    broken servers.  New xdr_stream style decoders can do that.
    
    For efficiency, we also eventually want to be able to pass xdr_streams
    from call_decode() to all XDR decoding functions, rather than building
    an xdr_stream in every XDR decoding function in the kernel.
    
    nfs_decode_dirent() is renamed to follow the naming convention of the
    other two dirent decoders.
    
    Static helper functions are left without the "inline" directive.  This
    allows the compiler to choose automatically how to optimize these for
    size or speed.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Tested-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 8c2d9d83771e..6c6a9955bae9 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -187,7 +187,7 @@ extern void nfs_destroy_directcache(void);
 /* nfs2xdr.c */
 extern int nfs_stat_to_errno(enum nfs_stat);
 extern struct rpc_procinfo nfs_procedures[];
-extern __be32 *nfs_decode_dirent(struct xdr_stream *, struct nfs_entry *, struct nfs_server *, int);
+extern __be32 *nfs2_decode_dirent(struct xdr_stream *, struct nfs_entry *, struct nfs_server *, int);
 
 /* nfs3xdr.c */
 extern struct rpc_procinfo nfs3_procedures[];

commit 858284932462cec260f3d1d7426aeb03f5dbc2ad
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Dec 14 14:55:00 2010 +0000

    NFS: Use the "nfs_stat" enum for nfs_stat_to_errno()'s argument
    
    Clean up.
    
    To distinguish more clearly between the on-the-wire NFSERR_ value and
    our local errno values, use the proper type for the argument of
    nfs_stat_to_errno().
    
    Add a documenting comment appropriate for a global function shared
    outside this source file.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Tested-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index e6356b750b77..8c2d9d83771e 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -185,7 +185,7 @@ extern int __init nfs_init_directcache(void);
 extern void nfs_destroy_directcache(void);
 
 /* nfs2xdr.c */
-extern int nfs_stat_to_errno(int);
+extern int nfs_stat_to_errno(enum nfs_stat);
 extern struct rpc_procinfo nfs_procedures[];
 extern __be32 *nfs_decode_dirent(struct xdr_stream *, struct nfs_entry *, struct nfs_server *, int);
 

commit 0b26a0bf6ff398185546432420bb772bcfdf8d94
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Nov 20 14:26:44 2010 -0500

    NFS: Ensure we return the dirent->d_type when it is known
    
    Store the dirent->d_type in the struct nfs_cache_array_entry so that we
    can use it in getdents() calls.
    
    This fixes a regression with the new readdir code.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index db08ff3ff454..e6356b750b77 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -361,6 +361,15 @@ unsigned int nfs_page_length(struct page *page)
 	return 0;
 }
 
+/*
+ * Convert a umode to a dirent->d_type
+ */
+static inline
+unsigned char nfs_umode_to_dtype(umode_t mode)
+{
+	return (mode >> 12) & 15;
+}
+
 /*
  * Determine the number of pages in an array of length 'len' and
  * with a base offset of 'base'

commit 82f2e5472e2304e531c2fa85e457f4a71070044e
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Thu Oct 21 16:33:18 2010 -0400

    NFS: Readdir plus in v4
    
    By requsting more attributes during a readdir, we can mimic the readdir plus
    operation that was in NFSv3.
    
    To test, I ran the command `ls -lU --color=none` on directories with various
    numbers of files.  Without readdir plus, I see this:
    
    n files |    100    |   1,000   |  10,000   |  100,000  | 1,000,000
    --------+-----------+-----------+-----------+-----------+----------
    real    | 0m00.153s | 0m00.589s | 0m05.601s | 0m56.691s | 9m59.128s
    user    | 0m00.007s | 0m00.007s | 0m00.077s | 0m00.703s | 0m06.800s
    sys     | 0m00.010s | 0m00.070s | 0m00.633s | 0m06.423s | 1m10.005s
    access  | 3         | 1         | 1         | 4         | 31
    getattr | 2         | 1         | 1         | 1         | 1
    lookup  | 104       | 1,003     | 10,003    | 100,003   | 1,000,003
    readdir | 2         | 16        | 158       | 1,575     | 15,749
    total   | 111       | 1,021     | 10,163    | 101,583   | 1,015,784
    
    With readdir plus enabled, I see this:
    
    n files |    100    |   1,000   |  10,000   |  100,000  | 1,000,000
    --------+-----------+-----------+-----------+-----------+----------
    real    | 0m00.115s | 0m00.206s | 0m01.079s | 0m12.521s | 2m07.528s
    user    | 0m00.003s | 0m00.003s | 0m00.040s | 0m00.290s | 0m03.296s
    sys     | 0m00.007s | 0m00.020s | 0m00.120s | 0m01.357s | 0m17.556s
    access  | 3         | 1         | 1         | 1         | 7
    getattr | 2         | 1         | 1         | 1         | 1
    lookup  | 4         | 3         | 3         | 3         | 3
    readdir | 6         | 62        | 630       | 6,300     | 62,993
    total   | 15        | 67        | 635       | 6,305     | 63,004
    
    Readdir plus disabled has about a 16x increase in the number of rpc calls and
    is 4 - 5 times slower on large directories.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7b0e894d00c8..db08ff3ff454 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -187,15 +187,15 @@ extern void nfs_destroy_directcache(void);
 /* nfs2xdr.c */
 extern int nfs_stat_to_errno(int);
 extern struct rpc_procinfo nfs_procedures[];
-extern __be32 *nfs_decode_dirent(struct xdr_stream *, struct nfs_entry *, int);
+extern __be32 *nfs_decode_dirent(struct xdr_stream *, struct nfs_entry *, struct nfs_server *, int);
 
 /* nfs3xdr.c */
 extern struct rpc_procinfo nfs3_procedures[];
-extern __be32 *nfs3_decode_dirent(struct xdr_stream *, struct nfs_entry *, int);
+extern __be32 *nfs3_decode_dirent(struct xdr_stream *, struct nfs_entry *, struct nfs_server *, int);
 
 /* nfs4xdr.c */
 #ifdef CONFIG_NFS_V4
-extern __be32 *nfs4_decode_dirent(struct xdr_stream *, struct nfs_entry *entry, int plus);
+extern __be32 *nfs4_decode_dirent(struct xdr_stream *, struct nfs_entry *, struct nfs_server *, int);
 #endif
 #ifdef CONFIG_NFS_V4_1
 extern const u32 nfs41_maxread_overhead;

commit 56e4ebf877b6043c289bda32a5a7385b80c17dee
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Wed Oct 20 15:44:37 2010 -0400

    NFS: readdir with vmapped pages
    
    We can use vmapped pages to read more information from the network at once.
    This will reduce the number of calls needed to complete a readdir.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    [trondmy: Added #include for linux/vmalloc.h> in fs/nfs/dir.c]
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 74b015598a43..7b0e894d00c8 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -62,6 +62,12 @@ struct nfs_clone_mount {
  */
 #define NFS_UNSPEC_PORT		(-1)
 
+/*
+ * Maximum number of pages that readdir can use for creating
+ * a vmapped array of pages.
+ */
+#define NFS_MAX_READDIR_PAGES 8
+
 /*
  * In-kernel mount arguments
  */

commit babddc72a9468884ce1a23db3c3d54b0afa299f0
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Wed Oct 20 15:44:29 2010 -0400

    NFS: decode_dirent should use an xdr_stream
    
    Convert nfs*xdr.c to use an xdr stream in decode_dirent.  This will prevent a
    kernel oops that has been occuring when reading a vmapped page.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index c961bc92c107..74b015598a43 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -181,15 +181,15 @@ extern void nfs_destroy_directcache(void);
 /* nfs2xdr.c */
 extern int nfs_stat_to_errno(int);
 extern struct rpc_procinfo nfs_procedures[];
-extern __be32 * nfs_decode_dirent(__be32 *, struct nfs_entry *, int);
+extern __be32 *nfs_decode_dirent(struct xdr_stream *, struct nfs_entry *, int);
 
 /* nfs3xdr.c */
 extern struct rpc_procinfo nfs3_procedures[];
-extern __be32 *nfs3_decode_dirent(__be32 *, struct nfs_entry *, int);
+extern __be32 *nfs3_decode_dirent(struct xdr_stream *, struct nfs_entry *, int);
 
 /* nfs4xdr.c */
 #ifdef CONFIG_NFS_V4
-extern __be32 *nfs4_decode_dirent(__be32 *p, struct nfs_entry *entry, int plus);
+extern __be32 *nfs4_decode_dirent(struct xdr_stream *, struct nfs_entry *entry, int plus);
 #endif
 #ifdef CONFIG_NFS_V4_1
 extern const u32 nfs41_maxread_overhead;

commit 5f248c9c251c60af3403902b26e08de43964ea0b
Merge: f6cec0ae58c1 dca332528bc6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 10 11:26:52 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6: (96 commits)
      no need for list_for_each_entry_safe()/resetting with superblock list
      Fix sget() race with failing mount
      vfs: don't hold s_umount over close_bdev_exclusive() call
      sysv: do not mark superblock dirty on remount
      sysv: do not mark superblock dirty on mount
      btrfs: remove junk sb_dirt change
      BFS: clean up the superblock usage
      AFFS: wait for sb synchronization when needed
      AFFS: clean up dirty flag usage
      cifs: truncate fallout
      mbcache: fix shrinker function return value
      mbcache: Remove unused features
      add f_flags to struct statfs(64)
      pass a struct path to vfs_statfs
      update VFS documentation for method changes.
      All filesystems that need invalidate_inode_buffers() are doing that explicitly
      convert remaining ->clear_inode() to ->evict_inode()
      Make ->drop_inode() just return whether inode needs to be dropped
      fs/inode.c:clear_inode() is gone
      fs/inode.c:evict() doesn't care about delete vs. non-delete paths now
      ...
    
    Fix up trivial conflicts in fs/nilfs2/super.c

commit b57922d97fd6f79b6dbe6db0c4fd30d219fa08c1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 7 14:34:48 2010 -0400

    convert remaining ->clear_inode() to ->evict_inode()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index e70f44b9b3f4..f168ebdf7c6d 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -213,9 +213,9 @@ extern struct workqueue_struct *nfsiod_workqueue;
 extern struct inode *nfs_alloc_inode(struct super_block *sb);
 extern void nfs_destroy_inode(struct inode *);
 extern int nfs_write_inode(struct inode *, struct writeback_control *);
-extern void nfs_clear_inode(struct inode *);
+extern void nfs_evict_inode(struct inode *);
 #ifdef CONFIG_NFS_V4
-extern void nfs4_clear_inode(struct inode *);
+extern void nfs4_evict_inode(struct inode *);
 #endif
 void nfs_zap_acl_cache(struct inode *inode);
 extern int nfs_wait_bit_killable(void *word);

commit 5df6b8e65ad0f2eaee202ff002ac00d1ac605315
Merge: fe21ea18c742 3dce9a5c3a39
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 7 13:19:36 2010 -0700

    Merge branch 'nfs-for-2.6.36' of git://git.linux-nfs.org/projects/trondmy/nfs-2.6
    
    * 'nfs-for-2.6.36' of git://git.linux-nfs.org/projects/trondmy/nfs-2.6: (42 commits)
      NFS: NFSv4.1 is no longer a "developer only" feature
      NFS: NFS_V4 is no longer an EXPERIMENTAL feature
      NFS: Fix /proc/mount for legacy binary interface
      NFS: Fix the locking in nfs4_callback_getattr
      SUNRPC: Defer deleting the security context until gss_do_free_ctx()
      SUNRPC: prevent task_cleanup running on freed xprt
      SUNRPC: Reduce asynchronous RPC task stack usage
      SUNRPC: Move the bound cred to struct rpc_rqst
      SUNRPC: Clean up of rpc_bindcred()
      SUNRPC: Move remaining RPC client related task initialisation into clnt.c
      SUNRPC: Ensure that rpc_exit() always wakes up a sleeping task
      SUNRPC: Make the credential cache hashtable size configurable
      SUNRPC: Store the hashtable size in struct rpc_cred_cache
      NFS: Ensure the AUTH_UNIX credcache is allocated dynamically
      NFS: Fix the NFS users of rpc_restart_call()
      SUNRPC: The function rpc_restart_call() should return success/failure
      NFSv4: Get rid of the bogus RPC_ASSASSINATED(task) checks
      NFSv4: Clean up the process of renewing the NFSv4 lease
      NFSv4.1: Handle NFS4ERR_DELAY on SEQUENCE correctly
      NFS: nfs_rename() should not have to flush out writebacks
      ...

commit d05dd4e98f0dd30ee933e05ac9363614c47df83a
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Jul 31 14:29:07 2010 -0400

    NFS: Fix the NFS users of rpc_restart_call()
    
    Fix up those functions that depend on knowing whether or not
    rpc_restart_call is successful or not.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index d8bd619e386c..699725fee34f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -369,10 +369,9 @@ unsigned int nfs_page_array_len(unsigned int base, size_t len)
  * Helper for restarting RPC calls in the possible presence of NFSv4.1
  * sessions.
  */
-static inline void nfs_restart_rpc(struct rpc_task *task, const struct nfs_client *clp)
+static inline int nfs_restart_rpc(struct rpc_task *task, const struct nfs_client *clp)
 {
 	if (nfs4_has_session(clp))
-		rpc_restart_call_prepare(task);
-	else
-		rpc_restart_call(task);
+		return rpc_restart_call_prepare(task);
+	return rpc_restart_call(task);
 }

commit 7f8275d0d660c146de6ee3017e1e2e594c49e820
Author: Dave Chinner <dchinner@redhat.com>
Date:   Mon Jul 19 14:56:17 2010 +1000

    mm: add context argument to shrinker callback
    
    The current shrinker implementation requires the registered callback
    to have global state to work from. This makes it difficult to shrink
    caches that are not global (e.g. per-filesystem caches). Pass the shrinker
    structure to the callback so that users can embed the shrinker structure
    in the context the shrinker needs to operate on and get back to it in the
    callback via container_of().
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index d8bd619e386c..e70f44b9b3f4 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -205,7 +205,8 @@ extern struct rpc_procinfo nfs4_procedures[];
 void nfs_close_context(struct nfs_open_context *ctx, int is_sync);
 
 /* dir.c */
-extern int nfs_access_cache_shrinker(int nr_to_scan, gfp_t gfp_mask);
+extern int nfs_access_cache_shrinker(struct shrinker *shrink,
+					int nr_to_scan, gfp_t gfp_mask);
 
 /* inode.c */
 extern struct workqueue_struct *nfsiod_workqueue;

commit 815409d22df870ea0b0d86f2a3bf33c35bcef55c
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Apr 16 16:22:46 2010 -0400

    NFSv4: Eliminate nfs4_path_walk()
    
    All we really want is the ability to retrieve the root file handle. We no
    longer need the ability to walk down the path, since that is now done in
    nfs_follow_remote_path().
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 11f82f03c5de..d8bd619e386c 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -244,9 +244,7 @@ extern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *);
 #ifdef CONFIG_NFS_V4
 extern struct dentry *nfs4_get_root(struct super_block *, struct nfs_fh *);
 
-extern int nfs4_path_walk(struct nfs_server *server,
-			  struct nfs_fh *mntfh,
-			  const char *path);
+extern int nfs4_get_rootfh(struct nfs_server *server, struct nfs_fh *mntfh);
 #endif
 
 /* read.c */

commit a9185b41a4f84971b930c519f0c63bd450c4810d
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Mar 5 09:21:37 2010 +0100

    pass writeback_control to ->write_inode
    
    This gives the filesystem more information about the writeback that
    is happening.  Trond requested this for the NFS unstable write handling,
    and other filesystems might benefit from this too by beeing able to
    distinguish between the different callers in more detail.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 29e464d23b32..11f82f03c5de 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -211,7 +211,7 @@ extern int nfs_access_cache_shrinker(int nr_to_scan, gfp_t gfp_mask);
 extern struct workqueue_struct *nfsiod_workqueue;
 extern struct inode *nfs_alloc_inode(struct super_block *sb);
 extern void nfs_destroy_inode(struct inode *);
-extern int nfs_write_inode(struct inode *,int);
+extern int nfs_write_inode(struct inode *, struct writeback_control *);
 extern void nfs_clear_inode(struct inode *);
 #ifdef CONFIG_NFS_V4
 extern void nfs4_clear_inode(struct inode *);

commit 0110ee152b69f8cbde19d8bc1dd59e197e419d76
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Dec 7 09:00:24 2009 -0500

    NFS: Fix up the declaration of nfs4_restart_rpc when NFSv4 not configured
    
    Also rename it: it is used in generic code, and so should not have a 'nfs4'
    prefix.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index b1a020c11724..29e464d23b32 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -197,7 +197,6 @@ extern const u32 nfs41_maxwrite_overhead;
 #endif
 
 /* nfs4proc.c */
-extern void nfs4_restart_rpc(struct rpc_task *, const struct nfs_client *);
 #ifdef CONFIG_NFS_V4
 extern struct rpc_procinfo nfs4_procedures[];
 #endif
@@ -367,3 +366,15 @@ unsigned int nfs_page_array_len(unsigned int base, size_t len)
 	return ((unsigned long)len + (unsigned long)base +
 		PAGE_SIZE - 1) >> PAGE_SHIFT;
 }
+
+/*
+ * Helper for restarting RPC calls in the possible presence of NFSv4.1
+ * sessions.
+ */
+static inline void nfs_restart_rpc(struct rpc_task *task, const struct nfs_client *clp)
+{
+	if (nfs4_has_session(clp))
+		rpc_restart_call_prepare(task);
+	else
+		rpc_restart_call(task);
+}

commit d61e612a728fb9bf848c4383f8f6645e822d5b57
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Dec 5 19:32:19 2009 -0500

    NFSv41: Clean up slot table management
    
    We no longer need to maintain a distinction between nfs41_sequence_done and
    nfs41_sequence_free_slot.
    
    This fixes a number of slot table leakages in the NFSv4.1 code.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 83a9284b83c7..b1a020c11724 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -197,8 +197,7 @@ extern const u32 nfs41_maxwrite_overhead;
 #endif
 
 /* nfs4proc.c */
-extern void nfs4_restart_rpc(struct rpc_task *, const struct nfs_client *,
-			     struct nfs4_sequence_res *);
+extern void nfs4_restart_rpc(struct rpc_task *, const struct nfs_client *);
 #ifdef CONFIG_NFS_V4
 extern struct rpc_procinfo nfs4_procedures[];
 #endif
@@ -275,20 +274,6 @@ extern int _nfs4_call_sync_session(struct nfs_server *server,
 				   struct nfs4_sequence_res *res,
 				   int cache_reply);
 
-#ifdef CONFIG_NFS_V4_1
-extern void nfs41_sequence_free_slot(const struct nfs_client *,
-				     struct nfs4_sequence_res *res);
-#endif /* CONFIG_NFS_V4_1 */
-
-static inline void nfs4_sequence_free_slot(const struct nfs_client *clp,
-					   struct nfs4_sequence_res *res)
-{
-#ifdef CONFIG_NFS_V4_1
-	if (nfs4_has_session(clp))
-		nfs41_sequence_free_slot(clp, res);
-#endif /* CONFIG_NFS_V4_1 */
-}
-
 /*
  * Determine the device name as a string
  */

commit 2449ea2e191123729b2dc37a06fcb9d6ea7e2736
Author: Alexandros Batsakis <batsakis@netapp.com>
Date:   Sat Dec 5 13:36:55 2009 -0500

    nfs41: V2 adjust max_rqst_sz, max_resp_sz w.r.t to rsize, wsize
    
    The v4.1 client should take into account the desired rsize, wsize when
    negotiating the max size in CREATE_SESSION. Accordingly, it should use
    rsize, wsize that are smaller than the session negotiated values.
    
    Signed-off-by: Alexandros Batsakis <batsakis@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7466d24893f7..83a9284b83c7 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -191,6 +191,10 @@ extern __be32 *nfs3_decode_dirent(__be32 *, struct nfs_entry *, int);
 #ifdef CONFIG_NFS_V4
 extern __be32 *nfs4_decode_dirent(__be32 *p, struct nfs_entry *entry, int plus);
 #endif
+#ifdef CONFIG_NFS_V4_1
+extern const u32 nfs41_maxread_overhead;
+extern const u32 nfs41_maxwrite_overhead;
+#endif
 
 /* nfs4proc.c */
 extern void nfs4_restart_rpc(struct rpc_task *, const struct nfs_client *,

commit d8cb1a7ce36d44602946f06af4267da304fb4011
Author: Alexandros Batsakis <batsakis@netapp.com>
Date:   Sat Dec 5 13:29:53 2009 -0500

    nfs41: check if session exists and if it is persistent
    
    Signed-off-by: Alexandros Batsakis <batsakis@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7b890ba37fa2..7466d24893f7 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -30,6 +30,15 @@ static inline int nfs4_has_session(const struct nfs_client *clp)
 	return 0;
 }
 
+static inline int nfs4_has_persistent_session(const struct nfs_client *clp)
+{
+#ifdef CONFIG_NFS_V4_1
+	if (nfs4_has_session(clp))
+		return (clp->cl_session->flags & SESSION4_PERSIST);
+#endif /* CONFIG_NFS_V4_1 */
+	return 0;
+}
+
 struct nfs_clone_mount {
 	const struct super_block *sb;
 	const struct dentry *dentry;

commit 07bccc2dd4e8745859f0fa7d120ea39320fbcdbf
Author: Alexandros Batsakis <batsakis@netapp.com>
Date:   Sat Dec 5 13:19:01 2009 -0500

    nfs41: add support for callback with RPC version number 4
    
    The NFSv4.1 spec-29 (18.36.3) says that the server MUST use an ONC RPC
    (program) version number equal to 4 in callbacks sent to the client.
    For now we allow both versions 1 and 4.
    
    Signed-off-by: Alexandros Batsakis <batsakis@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index a6f7b6cbfd09..7b890ba37fa2 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -156,6 +156,7 @@ struct vfsmount *nfs_do_refmount(const struct vfsmount *mnt_parent, struct dentr
 
 /* callback_xdr.c */
 extern struct svc_version nfs4_callback_version1;
+extern struct svc_version nfs4_callback_version4;
 
 /* pagelist.c */
 extern int __init nfs_init_nfspagecache(void);

commit e608e79f1bf4b967afcf57777e63b5f0939b00e8
Author: Andy Adamson <andros@netapp.com>
Date:   Fri Dec 4 15:55:29 2009 -0500

    nfs41: call free slot from nfs4_restart_rpc
    
    nfs41_sequence_free_slot can be called multiple times on SEQUENCE operation
    errors.
    No reason to inline nfs4_restart_rpc
    
    Reported-by: Trond Myklebust <trond.myklebust@netapp.com>
    
    nfs_writeback_done and nfs_readpage_retry call nfs4_restart_rpc outside the
    error handler, and the slot is not freed prior to restarting in the rpc_prepare
    state during session reset.
    
    Fix this by moving the call to nfs41_sequence_free_slot from the error
    path of nfs41_sequence_done into nfs4_restart_rpc, and by removing the test
    for NFS4CLNT_SESSION_SETUP.
    Always free slot and goto the rpc prepare state on async errors.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index ebcd3795389e..a6f7b6cbfd09 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -177,26 +177,14 @@ extern __be32 * nfs_decode_dirent(__be32 *, struct nfs_entry *, int);
 extern struct rpc_procinfo nfs3_procedures[];
 extern __be32 *nfs3_decode_dirent(__be32 *, struct nfs_entry *, int);
 
-/* nfs4proc.c */
-static inline void nfs4_restart_rpc(struct rpc_task *task,
-				    const struct nfs_client *clp)
-{
-#ifdef CONFIG_NFS_V4_1
-	if (nfs4_has_session(clp) &&
-	    test_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state)) {
-		rpc_restart_call_prepare(task);
-		return;
-	}
-#endif /* CONFIG_NFS_V4_1 */
-	rpc_restart_call(task);
-}
-
 /* nfs4xdr.c */
 #ifdef CONFIG_NFS_V4
 extern __be32 *nfs4_decode_dirent(__be32 *p, struct nfs_entry *entry, int plus);
 #endif
 
 /* nfs4proc.c */
+extern void nfs4_restart_rpc(struct rpc_task *, const struct nfs_client *,
+			     struct nfs4_sequence_res *);
 #ifdef CONFIG_NFS_V4
 extern struct rpc_procinfo nfs4_procedures[];
 #endif

commit 6df08189ffd33d8357759561dba49d25c0335858
Author: Andy Adamson <andros@netapp.com>
Date:   Fri Dec 4 15:55:05 2009 -0500

    nfs41: rename cl_state session SETUP bit to RESET
    
    The bit is no longer used for session setup, only for session reset.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index e21b1bb9972f..ebcd3795389e 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -183,7 +183,7 @@ static inline void nfs4_restart_rpc(struct rpc_task *task,
 {
 #ifdef CONFIG_NFS_V4_1
 	if (nfs4_has_session(clp) &&
-	    test_bit(NFS4CLNT_SESSION_SETUP, &clp->cl_state)) {
+	    test_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state)) {
 		rpc_restart_call_prepare(task);
 		return;
 	}

commit 764302ccb88dd0df062eccd507b6c6de24f1c560
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Sep 8 19:50:03 2009 -0400

    NFS: Allow the "nfs" file system type to support NFSv4
    
    When mounting an "nfs" type file system, recognize "v4," "vers=4," or
    "nfsvers=4" mount options, and convert the file system to "nfs4" under
    the covers.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    [trondmy: fixed up binary mount code so it sets the 'version' field too]
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5e686a4d744e..e21b1bb9972f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -68,6 +68,7 @@ struct nfs_parsed_mount_data {
 	unsigned int		auth_flavor_len;
 	rpc_authflavor_t	auth_flavors[1];
 	char			*client_address;
+	unsigned int		version;
 	unsigned int		minorversion;
 	char			*fscache_uniq;
 

commit 4cfd74fc99a41fdc161f243e1c16199656d33ab1
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Sep 8 19:49:47 2009 -0400

    NFS: Mount option parser should detect missing "port="
    
    The meaning of not specifying the "port=" mount option is different
    for "-t nfs" and "-t nfs4" mounts.  The default port value for
    NFSv2/v3 mounts is 0, but the default for NFSv4 mounts is 2049.
    
    To support "-t nfs -o vers=4", the mount option parser must detect
    when "port=" is missing so that the correct default port value can be
    set depending on which NFS version is requested.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 2e485677019c..5e686a4d744e 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -48,6 +48,11 @@ struct nfs_clone_mount {
  */
 #define NFS_MAX_SECFLAVORS	(12)
 
+/*
+ * Value used if the user did not specify a port value.
+ */
+#define NFS_UNSPEC_PORT		(-1)
+
 /*
  * In-kernel mount arguments
  */
@@ -71,7 +76,7 @@ struct nfs_parsed_mount_data {
 		size_t			addrlen;
 		char			*hostname;
 		u32			version;
-		unsigned short		port;
+		int			port;
 		unsigned short		protocol;
 	} mount_server;
 
@@ -80,7 +85,7 @@ struct nfs_parsed_mount_data {
 		size_t			addrlen;
 		char			*hostname;
 		char			*export_path;
-		unsigned short		port;
+		int			port;
 		unsigned short		protocol;
 	} nfs_server;
 

commit 976a6f921cad26651d25e73826c05c7a023f5fa4
Merge: e576e05a73bc c05988cdb062
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Aug 10 17:45:50 2009 -0400

    Merge branch 'patches_cel-for-2.6.32' into nfs-for-2.6.32

commit 074cc1deec5dee63fcd5d966b36fa4f3765b50fc
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Aug 10 08:54:13 2009 -0400

    NFS: Add a ->migratepage() aop for NFS
    
    Make NFS a bit more friendly to NUMA and memory hot removal...
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7dd90a6769d0..e2ccb4a4398a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -248,6 +248,12 @@ extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 
 /* write.c */
 extern void nfs_write_prepare(struct rpc_task *task, void *calldata);
+#ifdef CONFIG_MIGRATION
+extern int nfs_migrate_page(struct address_space *,
+		struct page *, struct page *);
+#else
+#define nfs_migrate_page NULL
+#endif
 
 /* nfs4proc.c */
 extern int _nfs4_call_sync(struct nfs_server *server,

commit ec6ee61250acfccbc5578dd4014735fb2cbe53b5
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Sun Aug 9 15:09:37 2009 -0400

    NFS: Replace nfs_set_port() with rpc_set_port()
    
    Clean up.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index cf1da3e22004..c2f171a3d70e 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -368,22 +368,3 @@ unsigned int nfs_page_array_len(unsigned int base, size_t len)
 	return ((unsigned long)len + (unsigned long)base +
 		PAGE_SIZE - 1) >> PAGE_SHIFT;
 }
-
-/*
- * Set the port number in an address.  Be agnostic about the address
- * family.
- */
-static inline void nfs_set_port(struct sockaddr *sap, unsigned short port)
-{
-	struct sockaddr_in *ap = (struct sockaddr_in *)sap;
-	struct sockaddr_in6 *ap6 = (struct sockaddr_in6 *)sap;
-
-	switch (sap->sa_family) {
-	case AF_INET:
-		ap->sin_port = htons(port);
-		break;
-	case AF_INET6:
-		ap6->sin6_port = htons(port);
-		break;
-	}
-}

commit 53a0b9c4c99ab0085a06421f71592722e5b3fd5f
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Sun Aug 9 15:09:36 2009 -0400

    NFS: Replace nfs_parse_ip_address() with rpc_pton()
    
    Clean up: Use the common routine now provided in sunrpc.ko for parsing mount
    addresses.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index ff68397f9b19..cf1da3e22004 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -214,7 +214,6 @@ void nfs_zap_acl_cache(struct inode *inode);
 extern int nfs_wait_bit_killable(void *word);
 
 /* super.c */
-void nfs_parse_ip_address(char *, size_t, struct sockaddr *, size_t *);
 extern struct file_system_type nfs_xdev_fs_type;
 #ifdef CONFIG_NFS_V4
 extern struct file_system_type nfs4_xdev_fs_type;

commit a02d692611348f11ee1bc37431a883c3ff2de23e
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Sun Aug 9 15:09:34 2009 -0400

    SUNRPC: Provide functions for managing universal addresses
    
    Introduce a set of functions in the kernel's RPC implementation for
    converting between a socket address and either a standard
    presentation address string or an RPC universal address.
    
    The universal address functions will be used to encode and decode
    RPCB_FOO and NFSv4 SETCLIENTID arguments.  The other functions are
    part of a previous promise to deliver shared functions that can be
    used by upper-layer protocols to display and manipulate IP
    addresses.
    
    The kernel's current address printf formatters were designed
    specifically for kernel to user-space APIs that require a particular
    string format for socket addresses, thus are somewhat limited for the
    purposes of sunrpc.ko.  The formatter for IPv6 addresses, %pI6, does
    not support short-handing or scope IDs.  Also, these printf formatters
    are unique per address family, so a separate formatter string is
    required for printing AF_INET and AF_INET6 addresses.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 8d2b71d57d29..ff68397f9b19 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -370,8 +370,6 @@ unsigned int nfs_page_array_len(unsigned int base, size_t len)
 		PAGE_SIZE - 1) >> PAGE_SHIFT;
 }
 
-#define IPV6_SCOPE_DELIMITER	'%'
-
 /*
  * Set the port number in an address.  Be agnostic about the address
  * family.

commit 0b524123c93893391ec9e6c9b04998a45235f9c8
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Sun Aug 9 15:09:30 2009 -0400

    NFS: Add ability to send MOUNTPROC_UMNT to the kernel's mountd client
    
    After certain failure modes of an NFS mount, an NFS client should send
    a MOUNTPROC_UMNT request to remove the just-added mount entry from the
    server's mount table.  While no-one should rely on the accuracy of the
    server's mount table, sending a UMNT is simply being a good internet
    neighbor.
    
    Since NFS mount processing is handled in the kernel now, we will need
    a function in the kernel's mountd client that can post a MOUNTRPC_UMNT
    request, in order to handle these failure modes.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7dd90a6769d0..8d2b71d57d29 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -102,6 +102,7 @@ struct nfs_mount_request {
 };
 
 extern int nfs_mount(struct nfs_mount_request *info);
+extern void nfs_umount(const struct nfs_mount_request *info);
 
 /* client.c */
 extern struct rpc_program nfs_program;

commit 1f84603c0940d5bed17f7e4d2e0b2a4b8b8f1b81
Merge: 301933a0acfd 4bf259e3ae50
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Jun 17 18:13:00 2009 -0700

    Merge branch 'devel-for-2.6.31' into for-2.6.31
    
    Conflicts:
            fs/nfs/client.c
            fs/nfs/super.c

commit 8e02f6b9aae9b265064f929c6df15222b9baf256
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Wed Jun 17 18:02:13 2009 -0700

    NFS: Update MNT and MNT3 reply decoding functions
    
    Solder xdr_stream-based XDR decoding functions into the in-kernel mountd
    client that are more careful about checking data types and watching for
    buffer overflows.  The new MNT3 decoder includes support for auth-flavor
    list decoding.
    
    The "_sz" macro for MNT3 replies was missing the size of the file handle.
    I've added this back, and included the size of the auth flavor array.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 0207758de44a..10cf1110df48 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -83,6 +83,8 @@ struct nfs_mount_request {
 	unsigned short		protocol;
 	struct nfs_fh		*fh;
 	int			noresvport;
+	unsigned int		*auth_flav_len;
+	rpc_authflavor_t	*auth_flavs;
 };
 
 extern int nfs_mount(struct nfs_mount_request *info);

commit a14017db2852f9393a401a0f64053c331003babf
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Wed Jun 17 18:02:12 2009 -0700

    NFS: add XDR decoder for mountd version 3 auth-flavor lists
    
    Introduce an xdr_stream-based XDR decoder that can unpack the auth-
    flavor list returned in a MNT3 reply.
    
    The nfs_mount() function's caller allocates an array, and passes the
    size and a pointer to it.  The decoder decodes all the flavors it can
    into the array, and returns the number of decoded flavors.
    
    If the caller is not interested in the auth flavors, it can pass a
    value of zero as the size of the pre-allocated array.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index e4d6a8348adf..0207758de44a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -29,6 +29,12 @@ struct nfs_clone_mount {
 	rpc_authflavor_t authflavor;
 };
 
+/*
+ * Note: RFC 1813 doesn't limit the number of auth flavors that
+ * a server can return, so make something up.
+ */
+#define NFS_MAX_SECFLAVORS	(12)
+
 /*
  * In-kernel mount arguments
  */

commit 008f55d0e019943323c20a03493a2ba5672a4cc8
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Wed Apr 1 09:22:50 2009 -0400

    nfs41: recover lease in _nfs4_lookup_root
    
    This creates the nfsv4.1 session on mount.
    
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 78508f29c03a..acee3274d275 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -114,6 +114,7 @@ extern struct nfs_server *nfs_clone_server(struct nfs_server *,
 					   struct nfs_fh *,
 					   struct nfs_fattr *);
 extern void nfs_mark_client_ready(struct nfs_client *clp, int state);
+extern int nfs4_check_client_ready(struct nfs_client *clp);
 #ifdef CONFIG_PROC_FS
 extern int __init nfs_fs_proc_init(void);
 extern void nfs_fs_proc_exit(void);

commit eedc020e718b8ce45381383ec66030f09eb02a1e
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Apr 1 09:22:41 2009 -0400

    nfs41: use rpc prepare call state for session reset
    
    [nfs41: change nfs4_restart_rpc argument]
    [nfs41: check for session not minorversion]
    [nfs41: trigger the state manager for session reset]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [always define nfs4_restart_rpc]
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index f3b310e8ea03..78508f29c03a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -2,6 +2,7 @@
  * NFS internal definitions
  */
 
+#include "nfs4_fs.h"
 #include <linux/mount.h>
 #include <linux/security.h>
 
@@ -17,6 +18,18 @@ struct nfs_string;
  */
 #define NFS_MAX_READAHEAD	(RPC_DEF_SLOT_TABLE - 1)
 
+/*
+ * Determine if sessions are in use.
+ */
+static inline int nfs4_has_session(const struct nfs_client *clp)
+{
+#ifdef CONFIG_NFS_V4_1
+	if (clp->cl_session)
+		return 1;
+#endif /* CONFIG_NFS_V4_1 */
+	return 0;
+}
+
 struct nfs_clone_mount {
 	const struct super_block *sb;
 	const struct dentry *dentry;
@@ -148,6 +161,20 @@ extern __be32 * nfs_decode_dirent(__be32 *, struct nfs_entry *, int);
 extern struct rpc_procinfo nfs3_procedures[];
 extern __be32 *nfs3_decode_dirent(__be32 *, struct nfs_entry *, int);
 
+/* nfs4proc.c */
+static inline void nfs4_restart_rpc(struct rpc_task *task,
+				    const struct nfs_client *clp)
+{
+#ifdef CONFIG_NFS_V4_1
+	if (nfs4_has_session(clp) &&
+	    test_bit(NFS4CLNT_SESSION_SETUP, &clp->cl_state)) {
+		rpc_restart_call_prepare(task);
+		return;
+	}
+#endif /* CONFIG_NFS_V4_1 */
+	rpc_restart_call(task);
+}
+
 /* nfs4xdr.c */
 #ifdef CONFIG_NFS_V4
 extern __be32 *nfs4_decode_dirent(__be32 *p, struct nfs_entry *entry, int plus);
@@ -225,18 +252,6 @@ extern int _nfs4_call_sync_session(struct nfs_server *server,
 				   struct nfs4_sequence_res *res,
 				   int cache_reply);
 
-/*
- * Determine if sessions are in use.
- */
-static inline int nfs4_has_session(const struct nfs_client *clp)
-{
-#ifdef CONFIG_NFS_V4_1
-	if (clp->cl_session)
-		return 1;
-#endif /* CONFIG_NFS_V4_1 */
-	return 0;
-}
-
 #ifdef CONFIG_NFS_V4_1
 extern void nfs41_sequence_free_slot(const struct nfs_client *,
 				     struct nfs4_sequence_res *res);

commit 76db6d9500caeaa774a3e32a997eba30bbdc176b
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Apr 1 09:22:38 2009 -0400

    nfs41: add session setup to the state manager
    
    At mount, nfs_alloc_client sets the cl_state NFS4CLNT_LEASE_EXPIRED bit
    and nfs4_alloc_session sets the NFS4CLNT_SESSION_SETUP bit, so both bits are
    set when nfs4_lookup_root calls nfs4_recover_expired_lease which schedules
    the nfs4_state_manager and waits for it to complete.
    
    Place the session setup after the clientid establishment in nfs4_state_manager
    so that the session is setup right after the clientid has been established
    without rescheduling the state manager.
    
    Unlike nfsv4.0, the nfs_client struct is not ready to use until the session
    has been established.  Postpone marking the nfs_client struct to NFS_CS_READY
    until after a successful CREATE_SESSION call so that other threads cannot use
    the client until the session is established.
    
    If the EXCHANGE_ID call fails and the session has not been setup (the
    NFS4CLNT_SESSION_SETUP bit is set), mark the client with the error and return.
    
    If the session setup CREATE_SESSION call fails with NFS4ERR_STALE_CLIENTID
    which could occur due to server reboot or network partition inbetween the
    EXCHANGE_ID and CREATE_SESSION call, reset the NFS4CLNT_LEASE_EXPIRED and
    NFS4CLNT_SESSION_SETUP bits and try again.
    
    If the CREATE_SESSION call fails with other errors, mark the client with
    the error and return.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    
    [nfs41: NFS_CS_SESSION_SETUP cl_cons_state for back channel setup]
      On session setup, the CREATE_SESSION reply races with the server back channel
      probe which needs to succeed to setup the back channel. Set a new
      cl_cons_state NFS_CS_SESSION_SETUP just prior to the CREATE_SESSION call
      and add it as a valid state to nfs_find_client so that the client back channel
      can find the nfs_client struct and won't drop the server backchannel probe.
      Use a new cl_cons_state so that NFSv4.0 back channel behaviour which only
      sets NFS_CS_READY is unchanged.
      Adjust waiting on the nfs_client_active_wq accordingly.
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    
    [nfs41: rename NFS_CS_SESSION_SETUP to NFS_CS_SESSION_INITING]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    [nfs41: set NFS_CL_SESSION_INITING in alloc_session]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    [nfs41: move session setup into a function]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [moved nfs4_proc_create_session declaration here]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index f62bc5226155..f3b310e8ea03 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -100,6 +100,7 @@ extern void nfs_free_server(struct nfs_server *server);
 extern struct nfs_server *nfs_clone_server(struct nfs_server *,
 					   struct nfs_fh *,
 					   struct nfs_fattr *);
+extern void nfs_mark_client_ready(struct nfs_client *clp, int state);
 #ifdef CONFIG_PROC_FS
 extern int __init nfs_fs_proc_init(void);
 extern void nfs_fs_proc_exit(void);

commit def6ed7ef45ed19c3d6ca765f3bfdff1fe4c6bba
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Apr 1 09:22:26 2009 -0400

    nfs41 write sequence setup done support
    
    Separate write calls from nfs41: sequence setup/done support
    
    Implement the write rpc_call_prepare method for
    asynchronuos nfs rpcs, call nfs41_setup_sequence from
    respective rpc_call_validate_args methods.
    
    Call nfs4_sequence_done from respective rpc_call_done methods.
    
    Note that we need to pass a pointer to the nfs_server in calls data
    for passing on to nfs4_sequence_done.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [pnfs: client data server write validate and release]
    Signed-off-by: Andy Adamson <andros@umich.edu>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [move the nfs4_sequence_free_slot call in nfs_readpage_retry from]
    [nfs41: separate free slot from sequence done
    Signed-off-by: Andy Adamson <andros@umich.edu>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: Support sessions with O_DIRECT.]
    Signed-off-by: Dean Hildebrand <dhildeb@us.ibm.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: nfs4_sequence_free_slot use nfs_client for data server]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 988c8b9aa78b..f62bc5226155 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -209,6 +209,9 @@ extern int nfs4_path_walk(struct nfs_server *server,
 /* read.c */
 extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
 
+/* write.c */
+extern void nfs_write_prepare(struct rpc_task *task, void *calldata);
+
 /* nfs4proc.c */
 extern int _nfs4_call_sync(struct nfs_server *server,
 			   struct rpc_message *msg,

commit f11c88af26453aee2823a1fd9120d0cd8dae7b9a
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Apr 1 09:22:25 2009 -0400

    nfs41: read sequence setup/done support
    
    Implement the read rpc_call_prepare method for
    asynchronuos nfs rpcs, call nfs41_setup_sequence from
    respective rpc_call_validate_args methods.
    
    Call nfs4_sequence_done from respective rpc_call_done methods.
    
    Note that we need to pass a pointer to the nfs_server in calls data
    for passing on to nfs4_sequence_done.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [pnfs: client data server write validate and release]
    Signed-off-by: Andy Adamson <andros@umich.edu>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [move the nfs4_sequence_free_slot call in nfs_readpage_retry from]
    [nfs41: separate free slot from sequence done]
    [remove nfs_readargs.nfs_server, use calldata->inode instead]
    Signed-off-by: Andy Adamson <andros@umich.edu>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: Support sessions with O_DIRECT]
    Signed-off-by: Dean Hildebrand <dhildeb@us.ibm.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: nfs4_sequence_free_slot use nfs_client for data server]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 12f4c5e6fd39..988c8b9aa78b 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -206,6 +206,9 @@ extern int nfs4_path_walk(struct nfs_server *server,
 			  const char *path);
 #endif
 
+/* read.c */
+extern void nfs_read_prepare(struct rpc_task *task, void *calldata);
+
 /* nfs4proc.c */
 extern int _nfs4_call_sync(struct nfs_server *server,
 			   struct rpc_message *msg,

commit 13615871cdf8e8263626a817c350c6978a6483fe
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Apr 1 09:22:17 2009 -0400

    nfs41: nfs41_sequence_free_slot
    
    [from nfs41: separate free slot from sequence done]
    
    Don't free the slot until after all rpc_restart_calls have completed.
    Session reset will require more work.
    
    As noted by Trond, since we're using rpc_wake_up_next rather than
    rpc_wake_up() we must always wake up the next task in the queue
    either by going through nfs4_free_slot, or just calling
    rpc_wake_up_next if no slot is to be freed.
    
    [nfs41: sequence res use slotid]
    [nfs41: remove SEQ4_STATUS_USE_TK_STATUS]
    [got rid of nfs4_sequence_res.sr_session, use nfs_client.cl_session instead]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: rpc_wake_up_next if sessions slot was not consumed.]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: nfs4_sequence_free_slot use nfs_client for data server]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 8d67c2865dc3..12f4c5e6fd39 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -230,6 +230,20 @@ static inline int nfs4_has_session(const struct nfs_client *clp)
 	return 0;
 }
 
+#ifdef CONFIG_NFS_V4_1
+extern void nfs41_sequence_free_slot(const struct nfs_client *,
+				     struct nfs4_sequence_res *res);
+#endif /* CONFIG_NFS_V4_1 */
+
+static inline void nfs4_sequence_free_slot(const struct nfs_client *clp,
+					   struct nfs4_sequence_res *res)
+{
+#ifdef CONFIG_NFS_V4_1
+	if (nfs4_has_session(clp))
+		nfs41_sequence_free_slot(clp, res);
+#endif /* CONFIG_NFS_V4_1 */
+}
+
 /*
  * Determine the device name as a string
  */

commit cccef3b96a4759ae0790452280c00ea505412157
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Apr 1 09:22:03 2009 -0400

    nfs41: introduce nfs4_call_sync
    
    Use nfs4_call_sync rather than rpc_call_sync to provide
    for a nfs41 sessions-enabled interface for sessions manipulation.
    
    The nfs41 rpc logic uses the rpc_call_prepare method to
    recover and create the session, as well as selecting a free slot id
    and the rpc_call_done to free the slot and update slot table
    related metadata.
    
    In the coming patches we'll add rpc prepare and done routines
    for setting up the sequence op and processing the sequence result.
    
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: nfs4_call_sync]
    As per 11-14-08 review.
    Squash into "nfs41: introduce nfs4_call_sync" and "nfs41: nfs4_setup_sequence"
    Define two functions one for v4 and one for v41
    add a pointer to struct nfs4_client to the correct one.
    Signed-off-by: Andy Adamson <andros@netapp.com>
    [added BUG() in _nfs4_call_sync_session if !CONFIG_NFS_V4_1]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: check for session not minorversion]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [group minorversion specific stuff together]
    Signed-off-by: Alexandros Batsakis <Alexandros.Batsakis@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Andy Adamson <andros@netapp.com>
    [nfs41: fixup nfs4_clear_client_minor_version]
    [introduce nfs4_init_client_minor_version() in this patch]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [cleaned-up patch: got rid of nfs_call_sync_t, dprintks, cosmetics, extra server defs]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7cef45db9257..8d67c2865dc3 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -206,6 +206,18 @@ extern int nfs4_path_walk(struct nfs_server *server,
 			  const char *path);
 #endif
 
+/* nfs4proc.c */
+extern int _nfs4_call_sync(struct nfs_server *server,
+			   struct rpc_message *msg,
+			   struct nfs4_sequence_args *args,
+			   struct nfs4_sequence_res *res,
+			   int cache_reply);
+extern int _nfs4_call_sync_session(struct nfs_server *server,
+				   struct rpc_message *msg,
+				   struct nfs4_sequence_args *args,
+				   struct nfs4_sequence_res *res,
+				   int cache_reply);
+
 /*
  * Determine if sessions are in use.
  */

commit 557134a39c8d2ab79d8b8d53438e03e29feb5ec4
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Apr 1 09:21:53 2009 -0400

    nfs41: sessions client infrastructure
    
    NFSv4.1 Sessions basic data types, initialization, and destruction.
    
    The session is always associated with a struct nfs_client that holds
    the exchange_id results.
    
    Signed-off-by: Rahul Iyer <iyer@netapp.com>
    Signed-off-by: Andy Adamson<andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [remove extraneous rpc_clnt pointer, use the struct nfs_client cl_rpcclient.
    remove the rpc_clnt parameter from nfs4 nfs4_init_session]
    Signed-off-by: Andy Adamson<andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [Use the presence of a session to determine behaviour instead of the
    minorversion number.]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    [constified nfs4_has_session's struct nfs_client parameter]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [Rename nfs4_put_session() to nfs4_destroy_session() and call it from nfs4_free_client() not nfs4_free_server().
    Also get rid of nfs4_get_session() and the ref_count in nfs4_session struct as keeping track of nfs_client should be sufficient]
    Signed-off-by: Alexandros Batsakis <Alexandros.Batsakis@netapp.com>
    [nfs41: pass rsize and wsize into nfs4_init_session]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    [separated out removal of rpc_clnt parameter from nfs4_init_session ot a
     patch of its own]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [Pass the nfs_client pointer into nfs4_alloc_session]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: don't assign to session->clp->cl_session in nfs4_destroy_session]
    [nfs41: fixup nfs4_clear_client_minor_version]
    [introduce nfs4_clear_client_minor_version() in this patch]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [Refactor nfs4_init_session]
        Moved session allocation into nfs4_init_client_minor_version, called from
        nfs4_init_client.
        Leave rwise and wsize initialization in nfs4_init_session, called from
        nfs4_init_server.
        Reverted moving of nfs_fsid definition to nfs_fs_sb.h
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: Move NFS4_MAX_SLOT_TABLE define from under CONFIG_NFS_V4_1]
    [Fix comile error when CONFIG_NFS_V4_1 is not set.]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [moved nfs4_init_slot_table definition to "create_session operation"]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: alloc session with GFP_KERNEL]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index ffa6bd54d439..7cef45db9257 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -206,6 +206,18 @@ extern int nfs4_path_walk(struct nfs_server *server,
 			  const char *path);
 #endif
 
+/*
+ * Determine if sessions are in use.
+ */
+static inline int nfs4_has_session(const struct nfs_client *clp)
+{
+#ifdef CONFIG_NFS_V4_1
+	if (clp->cl_session)
+		return 1;
+#endif /* CONFIG_NFS_V4_1 */
+	return 0;
+}
+
 /*
  * Determine the device name as a string
  */

commit 3fd5be9e19921a89d9ed78d6a708a379a6c3c76a
Author: Mike Sager <sager@netapp.com>
Date:   Wed Apr 1 09:21:48 2009 -0400

    nfs41: add mount command option minorversion
    
    mount -t nfs4 -o minorversion=[0|1] specifies whether to use 4.0 or 4.1.
    By default, the minorversion is set to 0.
    
    Signed-off-by: Mike Sager <sager@netapp.com>
    [set default minorversion to 0 as per Trond and SteveD's request]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index e4d6a8348adf..ffa6bd54d439 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -44,6 +44,7 @@ struct nfs_parsed_mount_data {
 	unsigned int		auth_flavor_len;
 	rpc_authflavor_t	auth_flavors[1];
 	char			*client_address;
+	unsigned int		minorversion;
 	char			*fscache_uniq;
 
 	struct {

commit b797cac7487dee6bfddeb161631c1bbc54fa3cdb
Author: David Howells <dhowells@redhat.com>
Date:   Fri Apr 3 16:42:48 2009 +0100

    NFS: Add mount options to enable local caching on NFS
    
    Add NFS mount options to allow the local caching support to be enabled.
    
    The attached patch makes it possible for the NFS filesystem to be told to make
    use of the network filesystem local caching service (FS-Cache).
    
    To be able to use this, a recent nfsutils package is required.
    
    There are three variant NFS mount options that can be added to a mount command
    to control caching for a mount.  Only the last one specified takes effect:
    
     (*) Adding "fsc" will request caching.
    
     (*) Adding "fsc=<string>" will request caching and also specify a uniquifier.
    
     (*) Adding "nofsc" will disable caching.
    
    For example:
    
            mount warthog:/ /a -o fsc
    
    The cache of a particular superblock (NFS FSID) will be shared between all
    mounts of that volume, provided they have the same connection parameters and
    are not marked 'nosharecache'.
    
    Where it is otherwise impossible to distinguish superblocks because all the
    parameters are identical, but the 'nosharecache' option is supplied, a
    uniquifying string must be supplied, else only the first mount will be
    permitted to use the cache.
    
    If there's a key collision, then the second mount will disable caching and give
    a warning into the kernel log.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Steve Dickson <steved@redhat.com>
    Acked-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Tested-by: Daire Byrne <Daire.Byrne@framestore.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 013070000c38..e4d6a8348adf 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -39,6 +39,7 @@ struct nfs_parsed_mount_data {
 	int			acregmin, acregmax,
 				acdirmin, acdirmax;
 	int			namlen;
+	unsigned int		options;
 	unsigned int		bsize;
 	unsigned int		auth_flavor_len;
 	rpc_authflavor_t	auth_flavors[1];

commit 08734048b380103f0412f58b84c2f76a2c8b599f
Author: David Howells <dhowells@redhat.com>
Date:   Fri Apr 3 16:42:42 2009 +0100

    NFS: Define and create superblock-level objects
    
    Define and create superblock-level cache index objects (as managed by
    nfs_server structs).
    
    Each superblock object is created in a server level index object and is itself
    an index into which inode-level objects are inserted.
    
    Ideally there would be one superblock-level object per server, and the former
    would be folded into the latter; however, since the "nosharecache" option
    exists this isn't possible.
    
    The superblock object key is a sequence consisting of:
    
     (1) Certain superblock s_flags.
    
     (2) Various connection parameters that serve to distinguish superblocks for
         sget().
    
     (3) The volume FSID.
    
     (4) The security flavour.
    
     (5) The uniquifier length.
    
     (6) The uniquifier text.  This is normally an empty string, unless the fsc=xyz
         mount option was used to explicitly specify a uniquifier.
    
    The key blob is of variable length, depending on the length of (6).
    
    The superblock object is given no coherency data to carry in the auxiliary data
    permitted by the cache.  It is assumed that the superblock is always coherent.
    
    This patch also adds uniquification handling such that two otherwise identical
    superblocks, at least one of which is marked "nosharecache", won't end up
    trying to share the on-disk cache.  It will be possible to manually provide a
    uniquifier through a mount option with a later patch to avoid the error
    otherwise produced.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Steve Dickson <steved@redhat.com>
    Acked-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Tested-by: Daire Byrne <Daire.Byrne@framestore.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 2041f68ff1cc..013070000c38 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -5,6 +5,8 @@
 #include <linux/mount.h>
 #include <linux/security.h>
 
+#define NFS_MS_MASK (MS_RDONLY|MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_SYNCHRONOUS)
+
 struct nfs_string;
 
 /* Maximum number of readahead requests
@@ -41,6 +43,7 @@ struct nfs_parsed_mount_data {
 	unsigned int		auth_flavor_len;
 	rpc_authflavor_t	auth_flavors[1];
 	char			*client_address;
+	char			*fscache_uniq;
 
 	struct {
 		struct sockaddr_storage	address;

commit 7fe5c398fc2186ed586db11106a6692d871d0d58
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Mar 19 15:35:50 2009 -0400

    NFS: Optimise NFS close()
    
    Close-to-open cache consistency rules really only require us to flush out
    writes on calls to close(), and require us to revalidate attributes on the
    very last close of the file.
    
    Currently we appear to be doing a lot of extra attribute revalidation
    and cache flushes.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index a55e69aa52e5..2041f68ff1cc 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -152,6 +152,9 @@ extern __be32 *nfs4_decode_dirent(__be32 *p, struct nfs_entry *entry, int plus);
 extern struct rpc_procinfo nfs4_procedures[];
 #endif
 
+/* proc.c */
+void nfs_close_context(struct nfs_open_context *ctx, int is_sync);
+
 /* dir.c */
 extern int nfs_access_cache_shrinker(int nr_to_scan, gfp_t gfp_mask);
 

commit 72cb77f4a5ace37b12dcb47a0e8637a2c28ad881
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Mar 11 14:10:30 2009 -0400

    NFS: Throttle page dirtying while we're flushing to disk
    
    The following patch is a combination of a patch by myself and Peter
    Staubach.
    
    Trond: If we allow other processes to dirty pages while a process is doing
    a consistency sync to disk, we can end up never making progress.
    
    Peter: Attached is a patch which addresses a continuing problem with
    the NFS client generating out of order WRITE requests.  While
    this is compliant with all of the current protocol
    specifications, there are servers in the market which can not
    handle out of order WRITE requests very well.  Also, this may
    lead to sub-optimal block allocations in the underlying file
    system on the server.  This may cause the read throughputs to
    be reduced when reading the file from the server.
    
    Peter: There has been a lot of work recently done to address out of
    order issues on a systemic level.  However, the NFS client is
    still susceptible to the problem.  Out of order WRITE
    requests can occur when pdflush is in the middle of writing
    out pages while the process dirtying the pages calls
    generic_file_buffered_write which calls
    generic_perform_write which calls
    balance_dirty_pages_rate_limited which ends up calling
    writeback_inodes which ends up calling back into the NFS
    client to writes out dirty pages for the same file that
    pdflush happens to be working with.
    
    Signed-off-by: Peter Staubach <staubach@redhat.com>
    [modification by Trond to merge the two similar patches]
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 340ede8f608f..a55e69aa52e5 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -165,6 +165,7 @@ extern void nfs_clear_inode(struct inode *);
 extern void nfs4_clear_inode(struct inode *);
 #endif
 void nfs_zap_acl_cache(struct inode *inode);
+extern int nfs_wait_bit_killable(void *word);
 
 /* super.c */
 void nfs_parse_ip_address(char *, size_t, struct sockaddr *, size_t *);

commit 50a737f86dbf99daf3a8dcbdf778a3be36bb2a39
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Dec 23 15:21:37 2008 -0500

    NFS: "[no]resvport" mount option changes mountd client too
    
    If the admin has specified the "noresvport" option for an NFS mount
    point, the kernel's NFS client uses an unprivileged source port for
    the main NFS transport.  The kernel's mountd client should use an
    unprivileged port in this case as well.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 4e983961346e..340ede8f608f 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -72,6 +72,7 @@ struct nfs_mount_request {
 	u32			version;
 	unsigned short		protocol;
 	struct nfs_fh		*fh;
+	int			noresvport;
 };
 
 extern int nfs_mount(struct nfs_mount_request *info);

commit c5d120f8e8b464368a7dcb038dc5c077d234d10a
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Dec 23 15:21:35 2008 -0500

    NFS: introduce nfs_mount_info struct for calling nfs_mount()
    
    Clean up: convert nfs_mount() to take a single data structure argument to make
    it simpler to add more arguments.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7a38cc7b4137..4e983961346e 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -64,8 +64,17 @@ struct nfs_parsed_mount_data {
 };
 
 /* mount_clnt.c */
-extern int nfs_mount(struct sockaddr *, size_t, char *, char *,
-					int, int, struct nfs_fh *);
+struct nfs_mount_request {
+	struct sockaddr		*sap;
+	size_t			salen;
+	char			*hostname;
+	char			*dirpath;
+	u32			version;
+	unsigned short		protocol;
+	struct nfs_fh		*fh;
+};
+
+extern int nfs_mount(struct nfs_mount_request *info);
 
 /* client.c */
 extern struct rpc_program nfs_program;

commit 146ec944bbd31d241a44a00518b054fb01921d22
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Dec 23 15:21:34 2008 -0500

    NFS: Move declaration of nfs_mount() to fs/nfs/internal.h
    
    Clean up:  The nfs_mount() function is not to be used outside of the
    NFS client.  Move its public declaration to fs/nfs/internal.h.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index d212ee41caf2..7a38cc7b4137 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -63,6 +63,10 @@ struct nfs_parsed_mount_data {
 	struct security_mnt_opts lsm_opts;
 };
 
+/* mount_clnt.c */
+extern int nfs_mount(struct sockaddr *, size_t, char *, char *,
+					int, int, struct nfs_fh *);
+
 /* client.c */
 extern struct rpc_program nfs_program;
 

commit 456018d791ff4ef03d610f72486c637056bcd749
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Wed Oct 8 15:31:14 2008 -0400

    NFS: Cleanup nfs_set_port
    
    Signed-off-by: "J. Bruce Fields" <bfields@citi.umich.edu>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5d2a5d3c4241..d212ee41caf2 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -285,16 +285,15 @@ unsigned int nfs_page_array_len(unsigned int base, size_t len)
  */
 static inline void nfs_set_port(struct sockaddr *sap, unsigned short port)
 {
+	struct sockaddr_in *ap = (struct sockaddr_in *)sap;
+	struct sockaddr_in6 *ap6 = (struct sockaddr_in6 *)sap;
+
 	switch (sap->sa_family) {
-	case AF_INET: {
-	      struct sockaddr_in *ap = (struct sockaddr_in *)sap;
-	      ap->sin_port = htons(port);
-	      break;
-	}
-	case AF_INET6: {
-	       struct sockaddr_in6 *ap = (struct sockaddr_in6 *)sap;
-	       ap->sin6_port = htons(port);
-	       break;
-	}
+	case AF_INET:
+		ap->sin_port = htons(port);
+		break;
+	case AF_INET6:
+		ap6->sin6_port = htons(port);
+		break;
 	}
 }

commit ea31a4437c59219bf3ea946d58984b01a45a289c
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Wed Aug 20 16:10:23 2008 -0400

    nfs: Fix misparsing of nfsv4 fs_locations attribute
    
    The code incorrectly assumes here that the server name (or ip address)
    is null-terminated.  This can cause referrals to fail in some cases.
    
    Also support ipv6 addresses.
    
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 8d91bd88e310..5d2a5d3c4241 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -153,6 +153,7 @@ extern void nfs4_clear_inode(struct inode *);
 void nfs_zap_acl_cache(struct inode *inode);
 
 /* super.c */
+void nfs_parse_ip_address(char *, size_t, struct sockaddr *, size_t *);
 extern struct file_system_type nfs_xdev_fs_type;
 #ifdef CONFIG_NFS_V4
 extern struct file_system_type nfs4_xdev_fs_type;
@@ -276,6 +277,7 @@ unsigned int nfs_page_array_len(unsigned int base, size_t len)
 		PAGE_SIZE - 1) >> PAGE_SHIFT;
 }
 
+#define IPV6_SCOPE_DELIMITER	'%'
 
 /*
  * Set the port number in an address.  Be agnostic about the address

commit f0c929251e01a7a86b6254c775cb6b65c6457f10
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Wed Aug 20 16:10:22 2008 -0400

    nfs: prepare to share nfs_set_port
    
    We plan to use this function elsewhere.
    
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7bcf6ec2d458..8d91bd88e310 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -276,3 +276,23 @@ unsigned int nfs_page_array_len(unsigned int base, size_t len)
 		PAGE_SIZE - 1) >> PAGE_SHIFT;
 }
 
+
+/*
+ * Set the port number in an address.  Be agnostic about the address
+ * family.
+ */
+static inline void nfs_set_port(struct sockaddr *sap, unsigned short port)
+{
+	switch (sap->sa_family) {
+	case AF_INET: {
+	      struct sockaddr_in *ap = (struct sockaddr_in *)sap;
+	      ap->sin_port = htons(port);
+	      break;
+	}
+	case AF_INET6: {
+	       struct sockaddr_in6 *ap = (struct sockaddr_in6 *)sap;
+	       ap->sin6_port = htons(port);
+	       break;
+	}
+	}
+}

commit 1daef0a868370c5a96d031b9202e3354bea060e6
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sun Jul 27 18:19:01 2008 -0400

    NFS: Clean up nfs_sb_active/nfs_sb_deactive
    
    Instead of causing umount requests to block on server->active_wq while the
    asynchronous sillyrename deletes are executing, we can use the sb->s_active
    counter to obtain a reference to the super_block, and then release that
    reference in nfs_async_unlink_release().
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 24241fcbb98d..7bcf6ec2d458 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -163,8 +163,8 @@ extern struct rpc_stat nfs_rpcstat;
 
 extern int __init register_nfs_fs(void);
 extern void __exit unregister_nfs_fs(void);
-extern void nfs_sb_active(struct nfs_server *server);
-extern void nfs_sb_deactive(struct nfs_server *server);
+extern void nfs_sb_active(struct super_block *sb);
+extern void nfs_sb_deactive(struct super_block *sb);
 
 /* namespace.c */
 extern char *nfs_path(const char *base,

commit f41f741838480aeaa3a189cff6e210503cf9c42d
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Jun 11 17:39:04 2008 -0400

    NFS: Ensure we zap only the access and acl caches when setting new acls
    
    ...and ensure that we obey the NFS_INO_INVALID_ACL flag when retrieving the
    acls.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 04ae867dddba..24241fcbb98d 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -150,6 +150,7 @@ extern void nfs_clear_inode(struct inode *);
 #ifdef CONFIG_NFS_V4
 extern void nfs4_clear_inode(struct inode *);
 #endif
+void nfs_zap_acl_cache(struct inode *inode);
 
 /* super.c */
 extern struct file_system_type nfs_xdev_fs_type;

commit ecfc555a8327ff09b07066d73a98c04115007eec
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri Mar 14 14:14:56 2008 -0400

    NFS: Always enable NFS direct I/O
    
    Since O_DIRECT is a standard feature that is enabled in most distros,
    eliminate the CONFIG_NFS_DIRECTIO build option, and change the
    fs/nfs/Makefile to always build in the NFS direct I/O engine.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 999ad8ee0645..04ae867dddba 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -116,13 +116,8 @@ extern void nfs_destroy_readpagecache(void);
 extern int __init nfs_init_writepagecache(void);
 extern void nfs_destroy_writepagecache(void);
 
-#ifdef CONFIG_NFS_DIRECTIO
 extern int __init nfs_init_directcache(void);
 extern void nfs_destroy_directcache(void);
-#else
-#define nfs_init_directcache() (0)
-#define nfs_destroy_directcache() do {} while(0)
-#endif
 
 /* nfs2xdr.c */
 extern int nfs_stat_to_errno(int);

commit f22d6d79fe227245363a8849ea8c85fe6c6598c3
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri Mar 14 14:10:22 2008 -0400

    NFS: Save the value of the "port=" mount option
    
    During a remount based on the mount options displayed in /proc/mounts, we
    want to preserve the original behavior of the mount request.  Let's save
    the original setting of the "port=" mount option in the mount's nfs_server
    structure.
    
    This allows us to simplify the default behavior of port setting for NFSv4
    mounts: by default, NFSv2/3 mounts first try an RPC bind to determine the
    NFS server's port, unless the user specified the "port=" mount option;
    Users can force the client to skip the RPC bind by explicitly specifying
    "port=<value>".
    
    NFSv4, by contrast, assumes the NFS server port is 2049 and skips the RPC
    bind, unless the user specifies "port=".  Users can force an RPC bind for
    NFSv4 by explicitly specifying "port=0".
    
    I added a couple of extra comments to clarify this behavior.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index e89688a955bf..999ad8ee0645 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -56,6 +56,7 @@ struct nfs_parsed_mount_data {
 		size_t			addrlen;
 		char			*hostname;
 		char			*export_path;
+		unsigned short		port;
 		unsigned short		protocol;
 	} nfs_server;
 

commit 78fa701f341564e60461de91cd08ff5f7fb09b31
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri Mar 14 14:10:15 2008 -0400

    NFS: Fix up data types of fields in nfs_parsed_mount_options
    
    Clean up: make data types of fields in nfs_parsed_mount_options more
    consistent with other uses.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 4c1122a13844..e89688a955bf 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -46,9 +46,9 @@ struct nfs_parsed_mount_data {
 		struct sockaddr_storage	address;
 		size_t			addrlen;
 		char			*hostname;
-		unsigned int		version;
+		u32			version;
 		unsigned short		port;
-		int			protocol;
+		unsigned short		protocol;
 	} mount_server;
 
 	struct {
@@ -56,7 +56,7 @@ struct nfs_parsed_mount_data {
 		size_t			addrlen;
 		char			*hostname;
 		char			*export_path;
-		int			protocol;
+		unsigned short		protocol;
 	} nfs_server;
 
 	struct security_mnt_opts lsm_opts;

commit 9446389ef612096704fdf18fa79bab423d4110f0
Merge: cdd0972945db 84c6f6046c5a
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Mar 8 11:49:24 2008 -0500

    Merge commit 'origin' into devel

commit f9c3a3802119a2d30f3e4a69aef30a81e09d0209
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Mar 5 14:20:18 2008 -0500

    NFS: use new LSM interfaces to explicitly set mount options
    
    NFS and SELinux worked together previously because SELinux had NFS
    specific knowledge built in.  This design was approved by both groups
    back in 2004 but the recent NFS changes to use nfs_parsed_mount_data and
    the usage of nfs_clone_mount_data showed this to be a poor fragile
    solution.  This patch fixes the NFS functionality regression by making
    use of the new LSM interfaces to allow an FS to explicitly set its own
    mount options.
    
    The explicit setting of mount options is done in the nfs get_sb
    functions which are called before the generic vfs hooks try to set mount
    options for filesystems which use text mount data.
    
    This does not currently support NFSv4 as that functionality did not
    exist in previous kernels and thus there is no regression.  I will be
    adding the needed code, which I believe to be the exact same as the v3
    code, in nfs4_get_sb for 2.6.26.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 0f5619611b8d..931992763e68 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -3,6 +3,7 @@
  */
 
 #include <linux/mount.h>
+#include <linux/security.h>
 
 struct nfs_string;
 
@@ -57,6 +58,8 @@ struct nfs_parsed_mount_data {
 		char			*export_path;
 		int			protocol;
 	} nfs_server;
+
+	struct security_mnt_opts lsm_opts;
 };
 
 /* client.c */

commit 5746006f1d17d9d5a3015051ea54de4341cb31f9
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Feb 19 20:04:22 2008 -0500

    NFS: Add an nfsiod workqueue
    
    NFS post-rpciod cleanups often involve tasks that cannot be safely
    performed within the rpciod context (due to deadlock concerns). We
    therefore add a dedicated NFS workqueue that can perform tasks like
    cleaning up state after an interrupted NFSv4 open() call, or calling
    put_nfs_open_context() after an asynchronous read or write call.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 0f5619611b8d..985dc2931031 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -143,6 +143,7 @@ extern struct rpc_procinfo nfs4_procedures[];
 extern int nfs_access_cache_shrinker(int nr_to_scan, gfp_t gfp_mask);
 
 /* inode.c */
+extern struct workqueue_struct *nfsiod_workqueue;
 extern struct inode *nfs_alloc_inode(struct super_block *sb);
 extern void nfs_destroy_inode(struct inode *);
 extern int nfs_write_inode(struct inode *,int);

commit 3fbd67ad61f6d5a09ea717b56c50bc5c3d8042a8
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Jan 26 01:06:40 2008 -0500

    NFSv4: Iterate through all nfs_clients when the server recalls a delegation
    
    The same delegation may have been handed out to more than one nfs_client.
    Ensure that if a recall occurs, we return all instances.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index a80621199086..0f5619611b8d 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -64,6 +64,7 @@ extern struct rpc_program nfs_program;
 
 extern void nfs_put_client(struct nfs_client *);
 extern struct nfs_client *nfs_find_client(const struct sockaddr *, u32);
+extern struct nfs_client *nfs_find_client_next(struct nfs_client *);
 extern struct nfs_server *nfs_create_server(
 					const struct nfs_parsed_mount_data *,
 					struct nfs_fh *);

commit 4c5680177012a2b5c0f3fdf58f4375dd84a1da67
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Dec 10 14:59:28 2007 -0500

    NFS: Support non-IPv4 addresses in nfs_parsed_mount_data
    
    Replace the nfs_server and mount_server address fields in the
    nfs_parsed_mount_data structure with a "struct sockaddr_storage"
    instead of a "struct sockaddr_in".
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Cc: Aurelien Charbon <aurelien.charbon@ext.bull.net>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 75dd4e252cae..a80621199086 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -42,7 +42,8 @@ struct nfs_parsed_mount_data {
 	char			*client_address;
 
 	struct {
-		struct sockaddr_in	address;
+		struct sockaddr_storage	address;
+		size_t			addrlen;
 		char			*hostname;
 		unsigned int		version;
 		unsigned short		port;
@@ -50,7 +51,8 @@ struct nfs_parsed_mount_data {
 	} mount_server;
 
 	struct {
-		struct sockaddr_in	address;
+		struct sockaddr_storage	address;
+		size_t			addrlen;
 		char			*hostname;
 		char			*export_path;
 		int			protocol;

commit 6677d09513e35ac2f38d3a8c8a26fbd7bbcef192
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Dec 10 14:59:06 2007 -0500

    NFS: Adjust nfs_clone_mount structure to store "struct sockaddr *"
    
    Change the addr field in the nfs_clone_mount structure to store a "struct
    sockaddr *" to support non-IPv4 addresses in the NFS client.
    
    Note this is mostly a cosmetic change, and does not actually allow
    referrals using IPv6 addresses.  The existing referral code assumes that
    the server returns a string that represents an IPv4 address.  This code
    needs to support hostnames and IPv6 addresses as well as IPv4 addresses,
    thus it will need to be reorganized completely (to handle DNS resolution
    in user space).
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Cc: Aurelien Charbon <aurelien.charbon@ext.bull.net>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index c8458b168018..75dd4e252cae 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -21,7 +21,8 @@ struct nfs_clone_mount {
 	struct nfs_fattr *fattr;
 	char *hostname;
 	char *mnt_path;
-	struct sockaddr_in *addr;
+	struct sockaddr *addr;
+	size_t addrlen;
 	rpc_authflavor_t authflavor;
 };
 

commit ff052645c939b2fd8d467105adf98fa621cc244b
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Dec 10 14:58:44 2007 -0500

    NFS: Change nfs_find_client() to take "struct sockaddr *"
    
    Adjust arguments and callers of nfs_find_client() to pass a
    "struct sockaddr *" instead of "struct sockaddr_in *" to support non-IPv4
    addresses.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Cc: Aurelien Charbon <aurelien.charbon@ext.bull.net>
    
    Trond: Also fix up protocol version number argument in nfs_find_client() to
    use the correct u32 type.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 058d503a0ee1..c8458b168018 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -60,7 +60,7 @@ struct nfs_parsed_mount_data {
 extern struct rpc_program nfs_program;
 
 extern void nfs_put_client(struct nfs_client *);
-extern struct nfs_client *nfs_find_client(const struct sockaddr_in *, int);
+extern struct nfs_client *nfs_find_client(const struct sockaddr *, u32);
 extern struct nfs_server *nfs_create_server(
 					const struct nfs_parsed_mount_data *,
 					struct nfs_fh *);

commit e887cbcf911b2d16742832b38411559273ce5d77
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri Oct 26 13:32:29 2007 -0400

    NFS: Remove support for the 'mountprog' option
    
    Remove the mount option that allows users to specify an alternate mountd
    program number.  The client hasn't support setting an alternate mountd
    program number for a very long time.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index a78a09b40d1b..058d503a0ee1 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -52,7 +52,6 @@ struct nfs_parsed_mount_data {
 		struct sockaddr_in	address;
 		char			*hostname;
 		char			*export_path;
-		unsigned int		program;
 		int			protocol;
 	} nfs_server;
 };

commit ad879cef8554e20f9b5ca356c878712eb671228c
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri Oct 26 13:32:24 2007 -0400

    NFS: Remove support for the 'nfsprog' option
    
    Remove the mount option that allows users to specify an alternate NFS
    program number.  The client hasn't support setting an alternate NFS
    program number for a very long time.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 75793794aefe..a78a09b40d1b 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -43,7 +43,6 @@ struct nfs_parsed_mount_data {
 	struct {
 		struct sockaddr_in	address;
 		char			*hostname;
-		unsigned int		program;
 		unsigned int		version;
 		unsigned short		port;
 		int			protocol;

commit ef818a28fac9bd214e676986d8301db0582b92a9
Author: Steve Dickson <SteveD@redhat.com>
Date:   Thu Nov 8 04:05:04 2007 -0500

    NFS: Stop sillyname renames and unmounts from racing
    
    Added an active/deactive mechanism to the nfs_server structure
    allowing async operations to hold off umount until the
    operations are done.
    
    Signed-off-by: Steve Dickson <steved@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index f3acf48412be..75793794aefe 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -160,6 +160,8 @@ extern struct rpc_stat nfs_rpcstat;
 
 extern int __init register_nfs_fs(void);
 extern void __exit unregister_nfs_fs(void);
+extern void nfs_sb_active(struct nfs_server *server);
+extern void nfs_sb_deactive(struct nfs_server *server);
 
 /* namespace.c */
 extern char *nfs_path(const char *base,

commit 91ea40b9c6303ddab5c84f078f96b29084b45817
Author: \"Talpey, Thomas\ <Thomas.Talpey@netapp.com>
Date:   Mon Sep 10 13:44:33 2007 -0400

    NFS: use in-kernel mount argument structure for nfsv4 mounts
    
    The user-visible nfs4_mount_data does not contain sufficient data to
    describe new mount options, and also is now a legacy structure. Replace
    it with the internal nfs_parsed_mount_data for nfsv4 in-kernel use.
    
    Signed-off-by: Tom Talpey <tmt@netapp.com>
    Acked-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index d28e54e4dee4..f3acf48412be 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -5,7 +5,6 @@
 #include <linux/mount.h>
 
 struct nfs_string;
-struct nfs4_mount_data;
 
 /* Maximum number of readahead requests
  * FIXME: this should really be a sysctl so that users may tune it to suit
@@ -67,13 +66,9 @@ extern struct nfs_client *nfs_find_client(const struct sockaddr_in *, int);
 extern struct nfs_server *nfs_create_server(
 					const struct nfs_parsed_mount_data *,
 					struct nfs_fh *);
-extern struct nfs_server *nfs4_create_server(const struct nfs4_mount_data *,
-					     const char *,
-					     const struct sockaddr_in *,
-					     const char *,
-					     const char *,
-					     rpc_authflavor_t,
-					     struct nfs_fh *);
+extern struct nfs_server *nfs4_create_server(
+					const struct nfs_parsed_mount_data *,
+					struct nfs_fh *);
 extern struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *,
 						      struct nfs_fh *);
 extern void nfs_free_server(struct nfs_server *server);

commit 2283f8d6ed21ea2221df4cc329314b93f35351b0
Author: \"Talpey, Thomas\ <Thomas.Talpey@netapp.com>
Date:   Mon Sep 10 13:43:56 2007 -0400

    NFS: use in-kernel mount argument structure for nfsv[23] mounts
    
    The user-visible nfs_mount_data does not contain sufficient data to
    describe new mount options, and also is now a legacy structure. Replace
    it with the internal nfs_parsed_mount_data for nfsv[23] in-kernel use.
    
    Signed-off-by: Tom Talpey <tmt@netapp.com>
    Acked-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 9c2d0fbb9f89..d28e54e4dee4 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -5,7 +5,6 @@
 #include <linux/mount.h>
 
 struct nfs_string;
-struct nfs_mount_data;
 struct nfs4_mount_data;
 
 /* Maximum number of readahead requests
@@ -65,8 +64,9 @@ extern struct rpc_program nfs_program;
 
 extern void nfs_put_client(struct nfs_client *);
 extern struct nfs_client *nfs_find_client(const struct sockaddr_in *, int);
-extern struct nfs_server *nfs_create_server(const struct nfs_mount_data *,
-					    struct nfs_fh *);
+extern struct nfs_server *nfs_create_server(
+					const struct nfs_parsed_mount_data *,
+					struct nfs_fh *);
 extern struct nfs_server *nfs4_create_server(const struct nfs4_mount_data *,
 					     const char *,
 					     const struct sockaddr_in *,

commit 6b18eaa0821a559c5e2b7ed4b90f8aca5a8e6228
Author: \"Talpey, Thomas\ <Thomas.Talpey@netapp.com>
Date:   Mon Sep 10 13:43:29 2007 -0400

    NFS: move nfs_parsed_mount_data structure definition
    
    In preparation for rearranging the nfs mount argument passing, make the
    nfs_parsed_mount_data struct visible across nfs kernel files.
    
    Signed-off-by: Tom Talpey <tmt@netapp.com>
    Acked-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 76cf55d57101..9c2d0fbb9f89 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -27,6 +27,39 @@ struct nfs_clone_mount {
 	rpc_authflavor_t authflavor;
 };
 
+/*
+ * In-kernel mount arguments
+ */
+struct nfs_parsed_mount_data {
+	int			flags;
+	int			rsize, wsize;
+	int			timeo, retrans;
+	int			acregmin, acregmax,
+				acdirmin, acdirmax;
+	int			namlen;
+	unsigned int		bsize;
+	unsigned int		auth_flavor_len;
+	rpc_authflavor_t	auth_flavors[1];
+	char			*client_address;
+
+	struct {
+		struct sockaddr_in	address;
+		char			*hostname;
+		unsigned int		program;
+		unsigned int		version;
+		unsigned short		port;
+		int			protocol;
+	} mount_server;
+
+	struct {
+		struct sockaddr_in	address;
+		char			*hostname;
+		char			*export_path;
+		unsigned int		program;
+		int			protocol;
+	} nfs_server;
+};
+
 /* client.c */
 extern struct rpc_program nfs_program;
 

commit 9eaa67c6a5b77f248c4703d81c4a6c6434e35385
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Sun Jul 1 12:12:19 2007 -0400

    NFS: Clean-up: use correct type when converting NFS blocks to local blocks
    
    inode->i_blocks is a blkcnt_t these days, which can be a u64 or unsigned
    long, depending on the setting of CONFIG_LSF.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index ad2b40db1e65..76cf55d57101 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -183,9 +183,9 @@ unsigned long nfs_block_bits(unsigned long bsize, unsigned char *nrbitsp)
 /*
  * Calculate the number of 512byte blocks used.
  */
-static inline unsigned long nfs_calc_block_size(u64 tsize)
+static inline blkcnt_t nfs_calc_block_size(u64 tsize)
 {
-	loff_t used = (tsize + 511) >> 9;
+	blkcnt_t used = (tsize + 511) >> 9;
 	return (used > ULONG_MAX) ? ULONG_MAX : used;
 }
 

commit 8d5658c949e6d89edc579a1f112aeee3bc232a8e
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Apr 10 09:26:35 2007 -0400

    NFS: Fix a buffer overflow in the allocation of struct nfs_read/writedata
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 6610f2b02077..ad2b40db1e65 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -231,3 +231,15 @@ unsigned int nfs_page_length(struct page *page)
 	}
 	return 0;
 }
+
+/*
+ * Determine the number of pages in an array of length 'len' and
+ * with a base offset of 'base'
+ */
+static inline
+unsigned int nfs_page_array_len(unsigned int base, size_t len)
+{
+	return ((unsigned long)len + (unsigned long)base +
+		PAGE_SIZE - 1) >> PAGE_SHIFT;
+}
+

commit c228fd3aeef55637354167faead74c579d5da28b
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Jan 13 02:28:11 2007 -0500

    NFSv4: Cleanups for fs_locations code.
    
    Start long arduous project...  What the hell is
    
            struct dentry = {};
    
    all about?
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index a28f6ce2e131..6610f2b02077 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -107,10 +107,6 @@ extern __be32 *nfs4_decode_dirent(__be32 *p, struct nfs_entry *entry, int plus);
 /* nfs4proc.c */
 #ifdef CONFIG_NFS_V4
 extern struct rpc_procinfo nfs4_procedures[];
-
-extern int nfs4_proc_fs_locations(struct inode *dir, struct dentry *dentry,
-				  struct nfs4_fs_locations *fs_locations,
-				  struct page *page);
 #endif
 
 /* dir.c */

commit 49a70f278658894d2899824cd4037095fb6711fe
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Dec 5 00:35:38 2006 -0500

    NFS: Cleanup: add common helper nfs_page_length()
    
    Clean up a lot of ad-hoc page length calculations in fs/nfs/write.c
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index d205466233f6..a28f6ce2e131 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -217,3 +217,21 @@ void nfs_super_set_maxbytes(struct super_block *sb, __u64 maxfilesize)
 	if (sb->s_maxbytes > MAX_LFS_FILESIZE || sb->s_maxbytes <= 0)
 		sb->s_maxbytes = MAX_LFS_FILESIZE;
 }
+
+/*
+ * Determine the number of bytes of data the page contains
+ */
+static inline
+unsigned int nfs_page_length(struct page *page)
+{
+	loff_t i_size = i_size_read(page->mapping->host);
+
+	if (i_size > 0) {
+		pgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;
+		if (page->index < end_index)
+			return PAGE_CACHE_SIZE;
+		if (page->index == end_index)
+			return ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;
+	}
+	return 0;
+}

commit 0dbb4c6799cf8fa8c5ba1926153a30960117477d
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Oct 19 23:28:49 2006 -0700

    [PATCH] xdr annotations: NFS readdir entries
    
    on-the-wire data is big-endian
    
    [in large part pulled from Alexey's patch]
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Trond Myklebust <trond.myklebust@fys.uio.no>
    Acked-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index bea0b016bd70..d205466233f6 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -93,15 +93,15 @@ extern void nfs_destroy_directcache(void);
 /* nfs2xdr.c */
 extern int nfs_stat_to_errno(int);
 extern struct rpc_procinfo nfs_procedures[];
-extern u32 * nfs_decode_dirent(u32 *, struct nfs_entry *, int);
+extern __be32 * nfs_decode_dirent(__be32 *, struct nfs_entry *, int);
 
 /* nfs3xdr.c */
 extern struct rpc_procinfo nfs3_procedures[];
-extern u32 *nfs3_decode_dirent(u32 *, struct nfs_entry *, int);
+extern __be32 *nfs3_decode_dirent(__be32 *, struct nfs_entry *, int);
 
 /* nfs4xdr.c */
 #ifdef CONFIG_NFS_V4
-extern u32 *nfs4_decode_dirent(u32 *p, struct nfs_entry *entry, int plus);
+extern __be32 *nfs4_decode_dirent(__be32 *p, struct nfs_entry *entry, int plus);
 #endif
 
 /* nfs4proc.c */

commit 6aaca566503296a73f956908ec98173946134fe2
Author: David Howells <dhowells@redhat.com>
Date:   Tue Aug 22 20:06:13 2006 -0400

    NFS: Add server and volume lists to /proc
    
    Make two new proc files available:
    
            /proc/fs/nfsfs/servers
            /proc/fs/nfsfs/volumes
    
    The first lists the servers with which we are currently dealing (struct
    nfs_client), and the second lists the volumes we have on those servers (struct
    nfs_server).
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index e73ba4f1052a..bea0b016bd70 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -47,6 +47,18 @@ extern void nfs_free_server(struct nfs_server *server);
 extern struct nfs_server *nfs_clone_server(struct nfs_server *,
 					   struct nfs_fh *,
 					   struct nfs_fattr *);
+#ifdef CONFIG_PROC_FS
+extern int __init nfs_fs_proc_init(void);
+extern void nfs_fs_proc_exit(void);
+#else
+static inline int nfs_fs_proc_init(void)
+{
+	return 0;
+}
+static inline void nfs_fs_proc_exit(void)
+{
+}
+#endif
 
 /* nfs4namespace.c */
 #ifdef CONFIG_NFS_V4

commit 54ceac4515986030c2502960be620198dd8fe25b
Author: David Howells <dhowells@redhat.com>
Date:   Tue Aug 22 20:06:13 2006 -0400

    NFS: Share NFS superblocks per-protocol per-server per-FSID
    
    The attached patch makes NFS share superblocks between mounts from the same
    server and FSID over the same protocol.
    
    It does this by creating each superblock with a false root and returning the
    real root dentry in the vfsmount presented by get_sb(). The root dentry set
    starts off as an anonymous dentry if we don't already have the dentry for its
    inode, otherwise it simply returns the dentry we already have.
    
    We may thus end up with several trees of dentries in the superblock, and if at
    some later point one of anonymous tree roots is discovered by normal filesystem
    activity to be located in another tree within the superblock, the anonymous
    root is named and materialises attached to the second tree at the appropriate
    point.
    
    Why do it this way? Why not pass an extra argument to the mount() syscall to
    indicate the subpath and then pathwalk from the server root to the desired
    directory? You can't guarantee this will work for two reasons:
    
     (1) The root and intervening nodes may not be accessible to the client.
    
         With NFS2 and NFS3, for instance, mountd is called on the server to get
         the filehandle for the tip of a path. mountd won't give us handles for
         anything we don't have permission to access, and so we can't set up NFS
         inodes for such nodes, and so can't easily set up dentries (we'd have to
         have ghost inodes or something).
    
         With this patch we don't actually create dentries until we get handles
         from the server that we can use to set up their inodes, and we don't
         actually bind them into the tree until we know for sure where they go.
    
     (2) Inaccessible symbolic links.
    
         If we're asked to mount two exports from the server, eg:
    
            mount warthog:/warthog/aaa/xxx /mmm
            mount warthog:/warthog/bbb/yyy /nnn
    
         We may not be able to access anything nearer the root than xxx and yyy,
         but we may find out later that /mmm/www/yyy, say, is actually the same
         directory as the one mounted on /nnn. What we might then find out, for
         example, is that /warthog/bbb was actually a symbolic link to
         /warthog/aaa/xxx/www, but we can't actually determine that by talking to
         the server until /warthog is made available by NFS.
    
         This would lead to having constructed an errneous dentry tree which we
         can't easily fix. We can end up with a dentry marked as a directory when
         it should actually be a symlink, or we could end up with an apparently
         hardlinked directory.
    
         With this patch we need not make assumptions about the type of a dentry
         for which we can't retrieve information, nor need we assume we know its
         place in the grand scheme of things until we actually see that place.
    
    This patch reduces the possibility of aliasing in the inode and page caches for
    inodes that may be accessed by more than one NFS export. It also reduces the
    number of superblocks required for NFS where there are many NFS exports being
    used from a server (home directory server + autofs for example).
    
    This in turn makes it simpler to do local caching of network filesystems, as it
    can then be guaranteed that there won't be links from multiple inodes in
    separate superblocks to the same cache file.
    
    Obviously, cache aliasing between different levels of NFS protocol could still
    be a problem, but at least that gives us another key to use when indexing the
    cache.
    
    This patch makes the following changes:
    
     (1) The server record construction/destruction has been abstracted out into
         its own set of functions to make things easier to get right.  These have
         been moved into fs/nfs/client.c.
    
         All the code in fs/nfs/client.c has to do with the management of
         connections to servers, and doesn't touch superblocks in any way; the
         remaining code in fs/nfs/super.c has to do with VFS superblock management.
    
     (2) The sequence of events undertaken by NFS mount is now reordered:
    
         (a) A volume representation (struct nfs_server) is allocated.
    
         (b) A server representation (struct nfs_client) is acquired.  This may be
             allocated or shared, and is keyed on server address, port and NFS
             version.
    
         (c) If allocated, the client representation is initialised.  The state
             member variable of nfs_client is used to prevent a race during
             initialisation from two mounts.
    
         (d) For NFS4 a simple pathwalk is performed, walking from FH to FH to find
             the root filehandle for the mount (fs/nfs/getroot.c).  For NFS2/3 we
             are given the root FH in advance.
    
         (e) The volume FSID is probed for on the root FH.
    
         (f) The volume representation is initialised from the FSINFO record
             retrieved on the root FH.
    
         (g) sget() is called to acquire a superblock.  This may be allocated or
             shared, keyed on client pointer and FSID.
    
         (h) If allocated, the superblock is initialised.
    
         (i) If the superblock is shared, then the new nfs_server record is
             discarded.
    
         (j) The root dentry for this mount is looked up from the root FH.
    
         (k) The root dentry for this mount is assigned to the vfsmount.
    
     (3) nfs_readdir_lookup() creates dentries for each of the entries readdir()
         returns; this function now attaches disconnected trees from alternate
         roots that happen to be discovered attached to a directory being read (in
         the same way nfs_lookup() is made to do for lookup ops).
    
         The new d_materialise_unique() function is now used to do this, thus
         permitting the whole thing to be done under one set of locks, and thus
         avoiding any race between mount and lookup operations on the same
         directory.
    
     (4) The client management code uses a new debug facility: NFSDBG_CLIENT which
         is set by echoing 1024 to /proc/net/sunrpc/nfs_debug.
    
     (5) Clone mounts are now called xdev mounts.
    
     (6) Use the dentry passed to the statfs() op as the handle for retrieving fs
         statistics rather than the root dentry of the superblock (which is now a
         dummy).
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 2f3aa52fbefc..e73ba4f1052a 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -4,6 +4,18 @@
 
 #include <linux/mount.h>
 
+struct nfs_string;
+struct nfs_mount_data;
+struct nfs4_mount_data;
+
+/* Maximum number of readahead requests
+ * FIXME: this should really be a sysctl so that users may tune it to suit
+ *        their needs. People that do NFS over a slow network, might for
+ *        instance want to reduce it to something closer to 1 for improved
+ *        interactive response.
+ */
+#define NFS_MAX_READAHEAD	(RPC_DEF_SLOT_TABLE - 1)
+
 struct nfs_clone_mount {
 	const struct super_block *sb;
 	const struct dentry *dentry;
@@ -16,12 +28,25 @@ struct nfs_clone_mount {
 };
 
 /* client.c */
+extern struct rpc_program nfs_program;
+
 extern void nfs_put_client(struct nfs_client *);
 extern struct nfs_client *nfs_find_client(const struct sockaddr_in *, int);
-extern struct nfs_client *nfs_get_client(const char *, const struct sockaddr_in *, int);
-extern void nfs_mark_client_ready(struct nfs_client *, int);
-extern int nfs_create_rpc_client(struct nfs_client *, int, unsigned int,
-				 unsigned int, rpc_authflavor_t);
+extern struct nfs_server *nfs_create_server(const struct nfs_mount_data *,
+					    struct nfs_fh *);
+extern struct nfs_server *nfs4_create_server(const struct nfs4_mount_data *,
+					     const char *,
+					     const struct sockaddr_in *,
+					     const char *,
+					     const char *,
+					     rpc_authflavor_t,
+					     struct nfs_fh *);
+extern struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *,
+						      struct nfs_fh *);
+extern void nfs_free_server(struct nfs_server *server);
+extern struct nfs_server *nfs_clone_server(struct nfs_server *,
+					   struct nfs_fh *,
+					   struct nfs_fattr *);
 
 /* nfs4namespace.c */
 #ifdef CONFIG_NFS_V4
@@ -89,10 +114,10 @@ extern void nfs4_clear_inode(struct inode *);
 #endif
 
 /* super.c */
-extern struct file_system_type nfs_referral_nfs4_fs_type;
-extern struct file_system_type clone_nfs_fs_type;
+extern struct file_system_type nfs_xdev_fs_type;
 #ifdef CONFIG_NFS_V4
-extern struct file_system_type clone_nfs4_fs_type;
+extern struct file_system_type nfs4_xdev_fs_type;
+extern struct file_system_type nfs4_referral_fs_type;
 #endif
 
 extern struct rpc_stat nfs_rpcstat;
@@ -101,28 +126,30 @@ extern int __init register_nfs_fs(void);
 extern void __exit unregister_nfs_fs(void);
 
 /* namespace.c */
-extern char *nfs_path(const char *base, const struct dentry *dentry,
+extern char *nfs_path(const char *base,
+		      const struct dentry *droot,
+		      const struct dentry *dentry,
 		      char *buffer, ssize_t buflen);
 
-/*
- * Determine the mount path as a string
- */
+/* getroot.c */
+extern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *);
 #ifdef CONFIG_NFS_V4
-static inline char *
-nfs4_path(const struct dentry *dentry, char *buffer, ssize_t buflen)
-{
-	return nfs_path(NFS_SB(dentry->d_sb)->mnt_path, dentry, buffer, buflen);
-}
+extern struct dentry *nfs4_get_root(struct super_block *, struct nfs_fh *);
+
+extern int nfs4_path_walk(struct nfs_server *server,
+			  struct nfs_fh *mntfh,
+			  const char *path);
 #endif
 
 /*
  * Determine the device name as a string
  */
 static inline char *nfs_devname(const struct vfsmount *mnt_parent,
-			 const struct dentry *dentry,
-			 char *buffer, ssize_t buflen)
+				const struct dentry *dentry,
+				char *buffer, ssize_t buflen)
 {
-	return nfs_path(mnt_parent->mnt_devname, dentry, buffer, buflen);
+	return nfs_path(mnt_parent->mnt_devname, mnt_parent->mnt_root,
+			dentry, buffer, buflen);
 }
 
 /*
@@ -178,20 +205,3 @@ void nfs_super_set_maxbytes(struct super_block *sb, __u64 maxfilesize)
 	if (sb->s_maxbytes > MAX_LFS_FILESIZE || sb->s_maxbytes <= 0)
 		sb->s_maxbytes = MAX_LFS_FILESIZE;
 }
-
-/*
- * Check if the string represents a "valid" IPv4 address
- */
-static inline int valid_ipaddr4(const char *buf)
-{
-	int rc, count, in[4];
-
-	rc = sscanf(buf, "%d.%d.%d.%d", &in[0], &in[1], &in[2], &in[3]);
-	if (rc != 4)
-		return -EINVAL;
-	for (count = 0; count < 4; count++) {
-		if (in[count] > 255)
-			return -EINVAL;
-	}
-	return 0;
-}

commit 5006a76cca8f86c6975c16fcf67e83b8b0eee2b6
Author: David Howells <dhowells@redhat.com>
Date:   Tue Aug 22 20:06:12 2006 -0400

    NFS: Eliminate client_sys in favour of cl_rpcclient
    
    Eliminate nfs_server::client_sys in favour of nfs_client::cl_rpcclient as we
    only really need one per server that we're talking to since it doesn't have any
    security on it.
    
    The retransmission management variables are also moved to the common struct as
    they're required to set up the cl_rpcclient connection.
    
    The NFS2/3 client and client_acl connections are thenceforth derived by cloning
    the cl_rpcclient connection and post-applying the authorisation flavour.
    
    The code for setting up the initial common connection has been moved to
    client.c as nfs_create_rpc_client().  All the NFS program definition tables are
    also moved there as that's where they're now required rather than super.c.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index ac370d5d4494..2f3aa52fbefc 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -20,6 +20,8 @@ extern void nfs_put_client(struct nfs_client *);
 extern struct nfs_client *nfs_find_client(const struct sockaddr_in *, int);
 extern struct nfs_client *nfs_get_client(const char *, const struct sockaddr_in *, int);
 extern void nfs_mark_client_ready(struct nfs_client *, int);
+extern int nfs_create_rpc_client(struct nfs_client *, int, unsigned int,
+				 unsigned int, rpc_authflavor_t);
 
 /* nfs4namespace.c */
 #ifdef CONFIG_NFS_V4

commit 24c8dbbb5f777187d660393599641ab3307b4b97
Author: David Howells <dhowells@redhat.com>
Date:   Tue Aug 22 20:06:10 2006 -0400

    NFS: Generalise the nfs_client structure
    
    Generalise the nfs_client structure by:
    
     (1) Moving nfs_client to a more general place (nfs_fs_sb.h).
    
     (2) Renaming its maintenance routines to be non-NFS4 specific.
    
     (3) Move those maintenance routines to a new non-NFS4 specific file (client.c)
         and move the declarations to internal.h.
    
     (4) Make nfs_find/get_client() take a full sockaddr_in to include the port
         number (will be required for NFS2/3).
    
     (5) Make nfs_find/get_client() take the NFS protocol version (again will be
         required to differentiate NFS2, 3 & 4 client records).
    
    Also:
    
     (6) Make nfs_client construction proceed akin to inodes, marking them as under
         construction and providing a function to indicate completion.
    
     (7) Make nfs_get_client() wait interruptibly if it finds a client that it can
         share, but that client is currently being constructed.
    
     (8) Make nfs4_create_client() use (6) and (7) instead of locking cl_sem.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 4802157963f8..ac370d5d4494 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -15,6 +15,12 @@ struct nfs_clone_mount {
 	rpc_authflavor_t authflavor;
 };
 
+/* client.c */
+extern void nfs_put_client(struct nfs_client *);
+extern struct nfs_client *nfs_find_client(const struct sockaddr_in *, int);
+extern struct nfs_client *nfs_get_client(const char *, const struct sockaddr_in *, int);
+extern void nfs_mark_client_ready(struct nfs_client *, int);
+
 /* nfs4namespace.c */
 #ifdef CONFIG_NFS_V4
 extern struct vfsmount *nfs_do_refmount(const struct vfsmount *mnt_parent, struct dentry *dentry);

commit 7d4e2747a0412583526a162fbbd6edeeafcceb08
Author: David Howells <dhowells@redhat.com>
Date:   Tue Aug 22 20:06:07 2006 -0400

    NFS: Fix up split of fs/nfs/inode.c
    
    Fix ups for the splitting of the superblock stuff out of fs/nfs/inode.c,
    including:
    
     (*) Move the callback tcpport module param into callback.c.
    
     (*) Move the idmap cache timeout module param into idmap.c.
    
     (*) Changes to internal.h:
    
         (*) namespace-nfs4.c was renamed to nfs4namespace.c.
    
         (*) nfs_stat_to_errno() is in nfs2xdr.c, not nfs4xdr.c.
    
         (*) nfs4xdr.c is contingent on CONFIG_NFS_V4.
    
         (*) nfs4_path() is only uses if CONFIG_NFS_V4 is set.
    
    Plus also:
    
     (*) The sec_flavours[] table should really be const.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 660e9ff5341c..4802157963f8 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -15,7 +15,7 @@ struct nfs_clone_mount {
 	rpc_authflavor_t authflavor;
 };
 
-/* namespace-nfs4.c */
+/* nfs4namespace.c */
 #ifdef CONFIG_NFS_V4
 extern struct vfsmount *nfs_do_refmount(const struct vfsmount *mnt_parent, struct dentry *dentry);
 #else
@@ -46,6 +46,7 @@ extern void nfs_destroy_directcache(void);
 #endif
 
 /* nfs2xdr.c */
+extern int nfs_stat_to_errno(int);
 extern struct rpc_procinfo nfs_procedures[];
 extern u32 * nfs_decode_dirent(u32 *, struct nfs_entry *, int);
 
@@ -54,8 +55,9 @@ extern struct rpc_procinfo nfs3_procedures[];
 extern u32 *nfs3_decode_dirent(u32 *, struct nfs_entry *, int);
 
 /* nfs4xdr.c */
-extern int nfs_stat_to_errno(int);
+#ifdef CONFIG_NFS_V4
 extern u32 *nfs4_decode_dirent(u32 *p, struct nfs_entry *entry, int plus);
+#endif
 
 /* nfs4proc.c */
 #ifdef CONFIG_NFS_V4
@@ -97,15 +99,13 @@ extern char *nfs_path(const char *base, const struct dentry *dentry,
 /*
  * Determine the mount path as a string
  */
+#ifdef CONFIG_NFS_V4
 static inline char *
 nfs4_path(const struct dentry *dentry, char *buffer, ssize_t buflen)
 {
-#ifdef CONFIG_NFS_V4
 	return nfs_path(NFS_SB(dentry->d_sb)->mnt_path, dentry, buffer, buflen);
-#else
-	return NULL;
-#endif
 }
+#endif
 
 /*
  * Determine the device name as a string

commit 979df72e6f963b42ee484f2eca049c3344da0ba7
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Jul 25 11:28:19 2006 -0400

    NFS: Add an ACCESS cache memory shrinker
    
    A pinned inode may in theory end up filling memory with cached ACCESS
    calls. This patch ensures that the VM may shrink away the cache in these
    particular cases.
    The shrinker works by iterating through the list of inodes on the global
    nfs_access_lru_list, and removing the least recently used access
    cache entry until it is done (or until the entire cache is empty).
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index e4f4e5def0fc..660e9ff5341c 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -66,6 +66,9 @@ extern int nfs4_proc_fs_locations(struct inode *dir, struct dentry *dentry,
 				  struct page *page);
 #endif
 
+/* dir.c */
+extern int nfs_access_cache_shrinker(int nr_to_scan, gfp_t gfp_mask);
+
 /* inode.c */
 extern struct inode *nfs_alloc_inode(struct super_block *sb);
 extern void nfs_destroy_inode(struct inode *);

commit 4ebd9ab387b39c44165cd296a6637082a4f0f66a
Author: Dominik Hackl <dominik@hackl.dhs.org>
Date:   Sun Jul 2 17:29:26 2006 +0200

    [PATCH] nfs: non-procfs build fix
    
    This fixes a bug in fs/nfs which makes it impossible to build nfs
    without having procfs enabled.
    
    Signed-off-by: Dominik Hackl <dominik@hackl.dhs.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 4fe51c1292bb..e4f4e5def0fc 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -81,9 +81,9 @@ extern struct file_system_type clone_nfs_fs_type;
 #ifdef CONFIG_NFS_V4
 extern struct file_system_type clone_nfs4_fs_type;
 #endif
-#ifdef CONFIG_PROC_FS
+
 extern struct rpc_stat nfs_rpcstat;
-#endif
+
 extern int __init register_nfs_fs(void);
 extern void __exit unregister_nfs_fs(void);
 

commit 266bee88699ddbde42ab303bbc426a105cc49809
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Jun 27 12:59:15 2006 -0700

    [PATCH] fix static linking of NFS
    
    Builds on ARM report link problems with common configurations like
    statically linked NFS (for nfsroot).  The symptom is that __init
    section code references __exit section code; that won't work since
    the exit sections are discarded (since they can never be called).
    
    The best fix for these particular cases would be an "__init_or_exit"
    section annotation.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Trond Myklebust <trond.myklebust@fys.uio.no>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index bd2815e2dec1..4fe51c1292bb 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -31,15 +31,15 @@ extern struct svc_version nfs4_callback_version1;
 
 /* pagelist.c */
 extern int __init nfs_init_nfspagecache(void);
-extern void __exit nfs_destroy_nfspagecache(void);
+extern void nfs_destroy_nfspagecache(void);
 extern int __init nfs_init_readpagecache(void);
-extern void __exit nfs_destroy_readpagecache(void);
+extern void nfs_destroy_readpagecache(void);
 extern int __init nfs_init_writepagecache(void);
-extern void __exit nfs_destroy_writepagecache(void);
+extern void nfs_destroy_writepagecache(void);
 
 #ifdef CONFIG_NFS_DIRECTIO
 extern int __init nfs_init_directcache(void);
-extern void __exit nfs_destroy_directcache(void);
+extern void nfs_destroy_directcache(void);
 #else
 #define nfs_init_directcache() (0)
 #define nfs_destroy_directcache() do {} while(0)

commit d75d54147db9db5194040bd1c5022df6ba36ee48
Author: Andrew Morton <akpm@osdl.org>
Date:   Sun Jun 25 02:41:26 2006 -0700

    git-nfs-build-fixes
    
    Fix various problems with nfs4 disabled.  And various other things.
    
    In file included from fs/nfs/inode.c:50:
    fs/nfs/internal.h:24: error: static declaration of 'nfs_do_refmount' follows non-static declaration
    include/linux/nfs_fs.h:320: error: previous declaration of 'nfs_do_refmount' was here
    fs/nfs/internal.h:65: warning: 'struct nfs4_fs_locations' declared inside parameter list
    fs/nfs/internal.h:65: warning: its scope is only this definition or declaration, which is probably not what you want
    fs/nfs/internal.h: In function 'nfs4_path':
    fs/nfs/internal.h:97: error: 'struct nfs_server' has no member named 'mnt_path'
    fs/nfs/inode.c: In function 'init_once':
    fs/nfs/inode.c:1116: error: 'struct nfs_inode' has no member named 'open_states'
    fs/nfs/inode.c:1116: error: 'struct nfs_inode' has no member named 'delegation'
    fs/nfs/inode.c:1116: error: 'struct nfs_inode' has no member named 'delegation_state'
    fs/nfs/inode.c:1116: error: 'struct nfs_inode' has no member named 'rwsem'
    distcc[26452] ERROR: compile fs/nfs/inode.c on g5/64 failed
    make[1]: *** [fs/nfs/inode.o] Error 1
    make: *** [fs/nfs/inode.o] Error 2
    make: *** Waiting for unfinished jobs....
    In file included from fs/nfs/nfs3xdr.c:26:
    fs/nfs/internal.h:24: error: static declaration of 'nfs_do_refmount' follows non-static declaration
    include/linux/nfs_fs.h:320: error: previous declaration of 'nfs_do_refmount' was here
    fs/nfs/internal.h:65: warning: 'struct nfs4_fs_locations' declared inside parameter list
    fs/nfs/internal.h:65: warning: its scope is only this definition or declaration, which is probably not what you want
    fs/nfs/internal.h: In function 'nfs4_path':
    fs/nfs/internal.h:97: error: 'struct nfs_server' has no member named 'mnt_path'
    distcc[26486] ERROR: compile fs/nfs/nfs3xdr.c on g5/64 failed
    make[1]: *** [fs/nfs/nfs3xdr.o] Error 1
    make: *** [fs/nfs/nfs3xdr.o] Error 2
    In file included from fs/nfs/nfs3proc.c:24:
    fs/nfs/internal.h:24: error: static declaration of 'nfs_do_refmount' follows non-static declaration
    include/linux/nfs_fs.h:320: error: previous declaration of 'nfs_do_refmount' was here
    fs/nfs/internal.h:65: warning: 'struct nfs4_fs_locations' declared inside parameter list
    fs/nfs/internal.h:65: warning: its scope is only this definition or declaration, which is probably not what you want
    fs/nfs/internal.h: In function 'nfs4_path':
    fs/nfs/internal.h:97: error: 'struct nfs_server' has no member named 'mnt_path'
    distcc[26469] ERROR: compile fs/nfs/nfs3proc.c on bix/32 failed
    make[1]: *** [fs/nfs/nfs3proc.o] Error 1
    make: *** [fs/nfs/nfs3proc.o] Error 2
    **FAILED**
    
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Andreas Gruenbacher <agruen@suse.de>
    Cc: Andy Adamson <andros@citi.umich.edu>
    Cc: Chuck Lever <cel@netapp.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: J. Bruce Fields <bfields@fieldses.org>
    Cc: Manoj Naik <manoj@almaden.ibm.com>
    Cc: Marc Eshel <eshel@almaden.ibm.com>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5e51c4535b6f..bd2815e2dec1 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -58,11 +58,13 @@ extern int nfs_stat_to_errno(int);
 extern u32 *nfs4_decode_dirent(u32 *p, struct nfs_entry *entry, int plus);
 
 /* nfs4proc.c */
+#ifdef CONFIG_NFS_V4
 extern struct rpc_procinfo nfs4_procedures[];
 
 extern int nfs4_proc_fs_locations(struct inode *dir, struct dentry *dentry,
 				  struct nfs4_fs_locations *fs_locations,
 				  struct page *page);
+#endif
 
 /* inode.c */
 extern struct inode *nfs_alloc_inode(struct super_block *sb);
@@ -92,9 +94,14 @@ extern char *nfs_path(const char *base, const struct dentry *dentry,
 /*
  * Determine the mount path as a string
  */
-static inline char *nfs4_path(const struct dentry *dentry, char *buffer, ssize_t buflen)
+static inline char *
+nfs4_path(const struct dentry *dentry, char *buffer, ssize_t buflen)
 {
+#ifdef CONFIG_NFS_V4
 	return nfs_path(NFS_SB(dentry->d_sb)->mnt_path, dentry, buffer, buflen);
+#else
+	return NULL;
+#endif
 }
 
 /*

commit f7b422b17ee5ee4920e8ae24a6ad04bf3481ce72
Author: David Howells <dhowells@redhat.com>
Date:   Fri Jun 9 09:34:33 2006 -0400

    NFS: Split fs/nfs/inode.c
    
    As fs/nfs/inode.c is rather large, heterogenous and unwieldy, the attached
    patch splits it up into a number of files:
    
     (*) fs/nfs/inode.c
    
         Strictly inode specific functions.
    
     (*) fs/nfs/super.c
    
         Superblock management functions for NFS and NFS4, normal access, clones
         and referrals.  The NFS4 superblock functions _could_ move out into a
         separate conditionally compiled file, but it's probably not worth it as
         there're so many common bits.
    
     (*) fs/nfs/namespace.c
    
         Some namespace-specific functions have been moved here.
    
     (*) fs/nfs/nfs4namespace.c
    
         NFS4-specific namespace functions (this could be merged into the previous
         file).  This file is conditionally compiled.
    
     (*) fs/nfs/internal.h
    
         Inter-file declarations, plus a few simple utility functions moved from
         fs/nfs/inode.c.
    
         Additionally, all the in-.c-file externs have been moved here, and those
         files they were moved from now includes this file.
    
    For the most part, the functions have not been changed, only some multiplexor
    functions have changed significantly.
    
    I've also:
    
     (*) Added some extra banner comments above some functions.
    
     (*) Rearranged the function order within the files to be more logical and
         better grouped (IMO), though someone may prefer a different order.
    
     (*) Reduced the number of #ifdefs in .c files.
    
     (*) Added missing __init and __exit directives.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
new file mode 100644
index 000000000000..5e51c4535b6f
--- /dev/null
+++ b/fs/nfs/internal.h
@@ -0,0 +1,179 @@
+/*
+ * NFS internal definitions
+ */
+
+#include <linux/mount.h>
+
+struct nfs_clone_mount {
+	const struct super_block *sb;
+	const struct dentry *dentry;
+	struct nfs_fh *fh;
+	struct nfs_fattr *fattr;
+	char *hostname;
+	char *mnt_path;
+	struct sockaddr_in *addr;
+	rpc_authflavor_t authflavor;
+};
+
+/* namespace-nfs4.c */
+#ifdef CONFIG_NFS_V4
+extern struct vfsmount *nfs_do_refmount(const struct vfsmount *mnt_parent, struct dentry *dentry);
+#else
+static inline
+struct vfsmount *nfs_do_refmount(const struct vfsmount *mnt_parent, struct dentry *dentry)
+{
+	return ERR_PTR(-ENOENT);
+}
+#endif
+
+/* callback_xdr.c */
+extern struct svc_version nfs4_callback_version1;
+
+/* pagelist.c */
+extern int __init nfs_init_nfspagecache(void);
+extern void __exit nfs_destroy_nfspagecache(void);
+extern int __init nfs_init_readpagecache(void);
+extern void __exit nfs_destroy_readpagecache(void);
+extern int __init nfs_init_writepagecache(void);
+extern void __exit nfs_destroy_writepagecache(void);
+
+#ifdef CONFIG_NFS_DIRECTIO
+extern int __init nfs_init_directcache(void);
+extern void __exit nfs_destroy_directcache(void);
+#else
+#define nfs_init_directcache() (0)
+#define nfs_destroy_directcache() do {} while(0)
+#endif
+
+/* nfs2xdr.c */
+extern struct rpc_procinfo nfs_procedures[];
+extern u32 * nfs_decode_dirent(u32 *, struct nfs_entry *, int);
+
+/* nfs3xdr.c */
+extern struct rpc_procinfo nfs3_procedures[];
+extern u32 *nfs3_decode_dirent(u32 *, struct nfs_entry *, int);
+
+/* nfs4xdr.c */
+extern int nfs_stat_to_errno(int);
+extern u32 *nfs4_decode_dirent(u32 *p, struct nfs_entry *entry, int plus);
+
+/* nfs4proc.c */
+extern struct rpc_procinfo nfs4_procedures[];
+
+extern int nfs4_proc_fs_locations(struct inode *dir, struct dentry *dentry,
+				  struct nfs4_fs_locations *fs_locations,
+				  struct page *page);
+
+/* inode.c */
+extern struct inode *nfs_alloc_inode(struct super_block *sb);
+extern void nfs_destroy_inode(struct inode *);
+extern int nfs_write_inode(struct inode *,int);
+extern void nfs_clear_inode(struct inode *);
+#ifdef CONFIG_NFS_V4
+extern void nfs4_clear_inode(struct inode *);
+#endif
+
+/* super.c */
+extern struct file_system_type nfs_referral_nfs4_fs_type;
+extern struct file_system_type clone_nfs_fs_type;
+#ifdef CONFIG_NFS_V4
+extern struct file_system_type clone_nfs4_fs_type;
+#endif
+#ifdef CONFIG_PROC_FS
+extern struct rpc_stat nfs_rpcstat;
+#endif
+extern int __init register_nfs_fs(void);
+extern void __exit unregister_nfs_fs(void);
+
+/* namespace.c */
+extern char *nfs_path(const char *base, const struct dentry *dentry,
+		      char *buffer, ssize_t buflen);
+
+/*
+ * Determine the mount path as a string
+ */
+static inline char *nfs4_path(const struct dentry *dentry, char *buffer, ssize_t buflen)
+{
+	return nfs_path(NFS_SB(dentry->d_sb)->mnt_path, dentry, buffer, buflen);
+}
+
+/*
+ * Determine the device name as a string
+ */
+static inline char *nfs_devname(const struct vfsmount *mnt_parent,
+			 const struct dentry *dentry,
+			 char *buffer, ssize_t buflen)
+{
+	return nfs_path(mnt_parent->mnt_devname, dentry, buffer, buflen);
+}
+
+/*
+ * Determine the actual block size (and log2 thereof)
+ */
+static inline
+unsigned long nfs_block_bits(unsigned long bsize, unsigned char *nrbitsp)
+{
+	/* make sure blocksize is a power of two */
+	if ((bsize & (bsize - 1)) || nrbitsp) {
+		unsigned char	nrbits;
+
+		for (nrbits = 31; nrbits && !(bsize & (1 << nrbits)); nrbits--)
+			;
+		bsize = 1 << nrbits;
+		if (nrbitsp)
+			*nrbitsp = nrbits;
+	}
+
+	return bsize;
+}
+
+/*
+ * Calculate the number of 512byte blocks used.
+ */
+static inline unsigned long nfs_calc_block_size(u64 tsize)
+{
+	loff_t used = (tsize + 511) >> 9;
+	return (used > ULONG_MAX) ? ULONG_MAX : used;
+}
+
+/*
+ * Compute and set NFS server blocksize
+ */
+static inline
+unsigned long nfs_block_size(unsigned long bsize, unsigned char *nrbitsp)
+{
+	if (bsize < NFS_MIN_FILE_IO_SIZE)
+		bsize = NFS_DEF_FILE_IO_SIZE;
+	else if (bsize >= NFS_MAX_FILE_IO_SIZE)
+		bsize = NFS_MAX_FILE_IO_SIZE;
+
+	return nfs_block_bits(bsize, nrbitsp);
+}
+
+/*
+ * Determine the maximum file size for a superblock
+ */
+static inline
+void nfs_super_set_maxbytes(struct super_block *sb, __u64 maxfilesize)
+{
+	sb->s_maxbytes = (loff_t)maxfilesize;
+	if (sb->s_maxbytes > MAX_LFS_FILESIZE || sb->s_maxbytes <= 0)
+		sb->s_maxbytes = MAX_LFS_FILESIZE;
+}
+
+/*
+ * Check if the string represents a "valid" IPv4 address
+ */
+static inline int valid_ipaddr4(const char *buf)
+{
+	int rc, count, in[4];
+
+	rc = sscanf(buf, "%d.%d.%d.%d", &in[0], &in[1], &in[2], &in[3]);
+	if (rc != 4)
+		return -EINVAL;
+	for (count = 0; count < 4; count++) {
+		if (in[count] > 255)
+			return -EINVAL;
+	}
+	return 0;
+}
