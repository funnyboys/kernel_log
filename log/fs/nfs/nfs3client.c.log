commit 62a55d088cd87d480a6fd67b0d63b14ccae80838
Author: Scott Mayhew <smayhew@redhat.com>
Date:   Tue Dec 10 07:31:14 2019 -0500

    NFS: Additional refactoring for fs_context conversion
    
    Split out from commit "NFS: Add fs_context support."
    
    This patch adds additional refactoring for the conversion of NFS to use
    fs_context, namely:
    
     (*) Merge nfs_mount_info and nfs_clone_mount into nfs_fs_context.
         nfs_clone_mount has had several fields removed, and nfs_mount_info
         has been removed altogether.
     (*) Various functions now take an fs_context as an argument instead
         of nfs_mount_info, nfs_fs_context, etc.
    
    Signed-off-by: Scott Mayhew <smayhew@redhat.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/nfs3client.c b/fs/nfs/nfs3client.c
index 54727d3d3042..5601e47360c2 100644
--- a/fs/nfs/nfs3client.c
+++ b/fs/nfs/nfs3client.c
@@ -46,9 +46,10 @@ static inline void nfs_init_server_aclclient(struct nfs_server *server)
 }
 #endif
 
-struct nfs_server *nfs3_create_server(struct nfs_mount_info *mount_info)
+struct nfs_server *nfs3_create_server(struct fs_context *fc)
 {
-	struct nfs_server *server = nfs_create_server(mount_info);
+	struct nfs_server *server = nfs_create_server(fc);
+
 	/* Create a client RPC handle for the NFS v3 ACL management interface */
 	if (!IS_ERR(server))
 		nfs_init_server_aclclient(server);

commit 0c38f2131df9865aa9fb24b7ad30a9657588e0e1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 10 07:31:00 2019 -0500

    nfs: don't pass nfs_subversion to ->create_server()
    
    pick it from mount_info
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/nfs3client.c b/fs/nfs/nfs3client.c
index 223904bc40a7..54727d3d3042 100644
--- a/fs/nfs/nfs3client.c
+++ b/fs/nfs/nfs3client.c
@@ -46,10 +46,9 @@ static inline void nfs_init_server_aclclient(struct nfs_server *server)
 }
 #endif
 
-struct nfs_server *nfs3_create_server(struct nfs_mount_info *mount_info,
-				      struct nfs_subversion *nfs_mod)
+struct nfs_server *nfs3_create_server(struct nfs_mount_info *mount_info)
 {
-	struct nfs_server *server = nfs_create_server(mount_info, nfs_mod);
+	struct nfs_server *server = nfs_create_server(mount_info);
 	/* Create a client RPC handle for the NFS v3 ACL management interface */
 	if (!IS_ERR(server))
 		nfs_init_server_aclclient(server);

commit 52f98f1a2ddd2bb561f2c7e3b19a81d816a63118
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Thu Oct 17 09:49:45 2019 -0400

    NFS/pnfs: Separate NFSv3 DS and MDS traffic
    
    If a NFSv3 server is being used as both a DS and as a regular NFSv3 server,
    we may want to keep the IO traffic on a separate TCP connection, since
    it will typically have very different timeout characteristics.
    
    This patch therefore sets up a flag to separate the two modes of operation
    for the nfs_client.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/nfs3client.c b/fs/nfs/nfs3client.c
index 793fa4273edb..223904bc40a7 100644
--- a/fs/nfs/nfs3client.c
+++ b/fs/nfs/nfs3client.c
@@ -109,6 +109,7 @@ struct nfs_client *nfs3_set_ds_client(struct nfs_server *mds_srv,
 		__set_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);
 
 	__set_bit(NFS_CS_NOPING, &cl_init.init_flags);
+	__set_bit(NFS_CS_DS, &cl_init.init_flags);
 
 	/* Use the MDS nfs_client cl_ipaddr. */
 	nfs_init_timeout_values(&ds_timeout, ds_proto, ds_timeo, ds_retrans);

commit c6eb58435b98bd843d3179664a0195ff25adb2c3
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Thu Oct 3 14:12:46 2019 -0400

    pNFS: nfs3_set_ds_client should set NFS_CS_NOPING
    
    Connecting to the DS is a non-interactive, asynchronous task, so there is
    no reason to fire up an extra RPC null ping in order to ensure that the
    server is up.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/nfs3client.c b/fs/nfs/nfs3client.c
index 178dc102442f..793fa4273edb 100644
--- a/fs/nfs/nfs3client.c
+++ b/fs/nfs/nfs3client.c
@@ -108,6 +108,8 @@ struct nfs_client *nfs3_set_ds_client(struct nfs_server *mds_srv,
 	if (mds_srv->flags & NFS_MOUNT_NORESVPORT)
 		__set_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);
 
+	__set_bit(NFS_CS_NOPING, &cl_init.init_flags);
+
 	/* Use the MDS nfs_client cl_ipaddr. */
 	nfs_init_timeout_values(&ds_timeout, ds_proto, ds_timeo, ds_retrans);
 	clp = nfs_get_client(&cl_init);

commit d0372b679c319487cbb190a40993b194d4fb343c
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Thu Oct 17 09:37:44 2019 -0400

    NFS: Use non-atomic bit ops when initialising struct nfs_client_initdata
    
    We don't need atomic bit ops when initialising a local structure on the
    stack.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/nfs3client.c b/fs/nfs/nfs3client.c
index 148ceb74d27c..178dc102442f 100644
--- a/fs/nfs/nfs3client.c
+++ b/fs/nfs/nfs3client.c
@@ -106,7 +106,7 @@ struct nfs_client *nfs3_set_ds_client(struct nfs_server *mds_srv,
 		cl_init.nconnect = mds_clp->cl_nconnect;
 
 	if (mds_srv->flags & NFS_MOUNT_NORESVPORT)
-		set_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);
+		__set_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);
 
 	/* Use the MDS nfs_client cl_ipaddr. */
 	nfs_init_timeout_values(&ds_timeout, ds_proto, ds_timeo, ds_retrans);

commit bb71e4a5d7eb151aa8d4e98c628b744f78af7c57
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Apr 27 11:22:07 2017 -0400

    pNFS: Allow multiple connections to the DS
    
    If the user specifies -onconnect=<number> mount option, and the transport
    protocol is TCP, then set up <number> connections to the pNFS data server
    as well. The connections will all go to the same IP address.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/nfs3client.c b/fs/nfs/nfs3client.c
index fb0c425b5d45..148ceb74d27c 100644
--- a/fs/nfs/nfs3client.c
+++ b/fs/nfs/nfs3client.c
@@ -102,6 +102,9 @@ struct nfs_client *nfs3_set_ds_client(struct nfs_server *mds_srv,
 		return ERR_PTR(-EINVAL);
 	cl_init.hostname = buf;
 
+	if (mds_clp->cl_nconnect > 1 && ds_proto == XPRT_TRANSPORT_TCP)
+		cl_init.nconnect = mds_clp->cl_nconnect;
+
 	if (mds_srv->flags & NFS_MOUNT_NORESVPORT)
 		set_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);
 

commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/nfs/nfs3client.c b/fs/nfs/nfs3client.c
index 1afdb0f7473f..fb0c425b5d45 100644
--- a/fs/nfs/nfs3client.c
+++ b/fs/nfs/nfs3client.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 #include <linux/nfs_fs.h>
 #include <linux/nfs_mount.h>
 #include <linux/sunrpc/addr.h>

commit 1a58e8a0e5c1f188a80eb9e505bc77d78a31a4ec
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Wed Apr 24 17:46:43 2019 -0400

    NFS: Store the credential of the mount process in the nfs_server
    
    Store the credential of the mount process so that we can determine
    information such as the user namespace.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/nfs3client.c b/fs/nfs/nfs3client.c
index 7879f2a0fcfd..1afdb0f7473f 100644
--- a/fs/nfs/nfs3client.c
+++ b/fs/nfs/nfs3client.c
@@ -91,6 +91,7 @@ struct nfs_client *nfs3_set_ds_client(struct nfs_server *mds_srv,
 		.proto = ds_proto,
 		.net = mds_clp->cl_net,
 		.timeparms = &ds_timeout,
+		.cred = mds_srv->cred,
 	};
 	struct nfs_client *clp;
 	char buf[INET6_ADDRSTRLEN + 1];

commit 7d38de3ffa75f92e7b00301dcdc6a3f9c53509ab
Author: Anna Schumaker <Anna.Schumaker@Netapp.com>
Date:   Thu Nov 17 15:15:55 2016 -0500

    NFS: Remove unused authflavour parameter from nfs_get_client()
    
    This parameter hasn't been used since f8407299 (Linux 3.11-rc2), so
    let's remove it from this function and callers.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/nfs3client.c b/fs/nfs/nfs3client.c
index ee753547fb0a..7879f2a0fcfd 100644
--- a/fs/nfs/nfs3client.c
+++ b/fs/nfs/nfs3client.c
@@ -78,8 +78,7 @@ struct nfs_server *nfs3_clone_server(struct nfs_server *source,
  */
 struct nfs_client *nfs3_set_ds_client(struct nfs_server *mds_srv,
 		const struct sockaddr *ds_addr, int ds_addrlen,
-		int ds_proto, unsigned int ds_timeo, unsigned int ds_retrans,
-		rpc_authflavor_t au_flavor)
+		int ds_proto, unsigned int ds_timeo, unsigned int ds_retrans)
 {
 	struct rpc_timeout ds_timeout;
 	struct nfs_client *mds_clp = mds_srv->nfs_client;
@@ -106,7 +105,7 @@ struct nfs_client *nfs3_set_ds_client(struct nfs_server *mds_srv,
 
 	/* Use the MDS nfs_client cl_ipaddr. */
 	nfs_init_timeout_values(&ds_timeout, ds_proto, ds_timeo, ds_retrans);
-	clp = nfs_get_client(&cl_init, au_flavor);
+	clp = nfs_get_client(&cl_init);
 
 	return clp;
 }

commit b224f7cb635f0a1a0a80c1dae93699a2a1161604
Author: Tigran Mkrtchyan <tigran.mkrtchyan@desy.de>
Date:   Mon Jun 13 20:52:00 2016 +0200

    nfs4: flexfiles: respect noresvport when establishing connections to DSes
    
    Signed-off-by: Tigran Mkrtchyan <tigran.mkrtchyan@desy.de>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/nfs3client.c b/fs/nfs/nfs3client.c
index 0457b4129421..ee753547fb0a 100644
--- a/fs/nfs/nfs3client.c
+++ b/fs/nfs/nfs3client.c
@@ -76,12 +76,13 @@ struct nfs_server *nfs3_clone_server(struct nfs_server *source,
  * low timeout interval so that if a connection is lost, we retry through
  * the MDS.
  */
-struct nfs_client *nfs3_set_ds_client(struct nfs_client *mds_clp,
+struct nfs_client *nfs3_set_ds_client(struct nfs_server *mds_srv,
 		const struct sockaddr *ds_addr, int ds_addrlen,
 		int ds_proto, unsigned int ds_timeo, unsigned int ds_retrans,
 		rpc_authflavor_t au_flavor)
 {
 	struct rpc_timeout ds_timeout;
+	struct nfs_client *mds_clp = mds_srv->nfs_client;
 	struct nfs_client_initdata cl_init = {
 		.addr = ds_addr,
 		.addrlen = ds_addrlen,
@@ -100,6 +101,9 @@ struct nfs_client *nfs3_set_ds_client(struct nfs_client *mds_clp,
 		return ERR_PTR(-EINVAL);
 	cl_init.hostname = buf;
 
+	if (mds_srv->flags & NFS_MOUNT_NORESVPORT)
+		set_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);
+
 	/* Use the MDS nfs_client cl_ipaddr. */
 	nfs_init_timeout_values(&ds_timeout, ds_proto, ds_timeo, ds_retrans);
 	clp = nfs_get_client(&cl_init, au_flavor);

commit 5c6e5b60aae4347223f176966455010a5715b863
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Wed Jun 22 14:13:12 2016 -0400

    NFS: Fix an Oops in the pNFS files and flexfiles connection setup to the DS
    
    Chris Worley reports:
     RIP: 0010:[<ffffffffa0245f80>]  [<ffffffffa0245f80>] rpc_new_client+0x2a0/0x2e0 [sunrpc]
     RSP: 0018:ffff880158f6f548  EFLAGS: 00010246
     RAX: 0000000000000000 RBX: ffff880234f8bc00 RCX: 000000000000ea60
     RDX: 0000000000074cc0 RSI: 000000000000ea60 RDI: ffff880234f8bcf0
     RBP: ffff880158f6f588 R08: 000000000001ac80 R09: ffff880237003300
     R10: ffff880201171000 R11: ffffea0000d75200 R12: ffffffffa03afc60
     R13: ffff880230c18800 R14: 0000000000000000 R15: ffff880158f6f680
     FS:  00007f0e32673740(0000) GS:ffff88023fc40000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
     CR2: 0000000000000008 CR3: 0000000234886000 CR4: 00000000001406e0
     Stack:
      ffffffffa047a680 0000000000000000 ffff880158f6f598 ffff880158f6f680
      ffff880158f6f680 ffff880234d11d00 ffff88023357f800 ffff880158f6f7d0
      ffff880158f6f5b8 ffffffffa024660a ffff880158f6f5b8 ffffffffa02492ec
     Call Trace:
      [<ffffffffa024660a>] rpc_create_xprt+0x1a/0xb0 [sunrpc]
      [<ffffffffa02492ec>] ? xprt_create_transport+0x13c/0x240 [sunrpc]
      [<ffffffffa0246766>] rpc_create+0xc6/0x1a0 [sunrpc]
      [<ffffffffa038e695>] nfs_create_rpc_client+0xf5/0x140 [nfs]
      [<ffffffffa038f31a>] nfs_init_client+0x3a/0xd0 [nfs]
      [<ffffffffa038f22f>] nfs_get_client+0x25f/0x310 [nfs]
      [<ffffffffa025cef8>] ? rpc_ntop+0xe8/0x100 [sunrpc]
      [<ffffffffa047512c>] nfs3_set_ds_client+0xcc/0x100 [nfsv3]
      [<ffffffffa041fa10>] nfs4_pnfs_ds_connect+0x120/0x400 [nfsv4]
      [<ffffffffa03d41c7>] nfs4_ff_layout_prepare_ds+0xe7/0x330 [nfs_layout_flexfiles]
      [<ffffffffa03d1b1b>] ff_layout_pg_init_write+0xcb/0x280 [nfs_layout_flexfiles]
      [<ffffffffa03a14dc>] __nfs_pageio_add_request+0x12c/0x490 [nfs]
      [<ffffffffa03a1fa2>] nfs_pageio_add_request+0xc2/0x2a0 [nfs]
      [<ffffffffa03a0365>] ? nfs_pageio_init+0x75/0x120 [nfs]
      [<ffffffffa03a5b50>] nfs_do_writepage+0x120/0x270 [nfs]
      [<ffffffffa03a5d31>] nfs_writepage_locked+0x61/0xc0 [nfs]
      [<ffffffff813d4115>] ? __percpu_counter_add+0x55/0x70
      [<ffffffffa03a6a9f>] nfs_wb_single_page+0xef/0x1c0 [nfs]
      [<ffffffff811ca4a3>] ? __dec_zone_page_state+0x33/0x40
      [<ffffffffa0395b21>] nfs_launder_page+0x41/0x90 [nfs]
      [<ffffffff811baba0>] invalidate_inode_pages2_range+0x340/0x3a0
      [<ffffffff811bac17>] invalidate_inode_pages2+0x17/0x20
      [<ffffffffa039960e>] nfs_release+0x9e/0xb0 [nfs]
      [<ffffffffa0399570>] ? nfs_open+0x60/0x60 [nfs]
      [<ffffffffa0394dad>] nfs_file_release+0x3d/0x60 [nfs]
      [<ffffffff81226e6c>] __fput+0xdc/0x1e0
      [<ffffffff81226fbe>] ____fput+0xe/0x10
      [<ffffffff810bf2e4>] task_work_run+0xc4/0xe0
      [<ffffffff810a4188>] do_exit+0x2e8/0xb30
      [<ffffffff8102471c>] ? do_audit_syscall_entry+0x6c/0x70
      [<ffffffff811464e6>] ? __audit_syscall_exit+0x1e6/0x280
      [<ffffffff810a4a5f>] do_group_exit+0x3f/0xa0
      [<ffffffff810a4ad4>] SyS_exit_group+0x14/0x20
      [<ffffffff8179b76e>] system_call_fastpath+0x12/0x71
    
    Which seems to be due to a call to utsname() when in a task exit context
    in order to determine the hostname to set in rpc_new_client().
    
    In reality, what we want here is not the hostname of the current task, but
    the hostname that was used to set up the metadata server.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/nfs3client.c b/fs/nfs/nfs3client.c
index 9e9fa347a948..0457b4129421 100644
--- a/fs/nfs/nfs3client.c
+++ b/fs/nfs/nfs3client.c
@@ -81,14 +81,17 @@ struct nfs_client *nfs3_set_ds_client(struct nfs_client *mds_clp,
 		int ds_proto, unsigned int ds_timeo, unsigned int ds_retrans,
 		rpc_authflavor_t au_flavor)
 {
+	struct rpc_timeout ds_timeout;
 	struct nfs_client_initdata cl_init = {
 		.addr = ds_addr,
 		.addrlen = ds_addrlen,
+		.nodename = mds_clp->cl_rpcclient->cl_nodename,
+		.ip_addr = mds_clp->cl_ipaddr,
 		.nfs_mod = &nfs_v3,
 		.proto = ds_proto,
 		.net = mds_clp->cl_net,
+		.timeparms = &ds_timeout,
 	};
-	struct rpc_timeout ds_timeout;
 	struct nfs_client *clp;
 	char buf[INET6_ADDRSTRLEN + 1];
 
@@ -99,8 +102,7 @@ struct nfs_client *nfs3_set_ds_client(struct nfs_client *mds_clp,
 
 	/* Use the MDS nfs_client cl_ipaddr. */
 	nfs_init_timeout_values(&ds_timeout, ds_proto, ds_timeo, ds_retrans);
-	clp = nfs_get_client(&cl_init, &ds_timeout, mds_clp->cl_ipaddr,
-			     au_flavor);
+	clp = nfs_get_client(&cl_init, au_flavor);
 
 	return clp;
 }

commit 36d3e3dcc93f1d3f70916ace76d94267b8948a2a
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Tue Jul 8 06:21:10 2014 +0800

    nfs: set hostname when creating nfsv3 ds connection
    
    lockd assumes hostname exists otherwise kernel oops.
    It can be reproduced by following steps:
    1. mount flexfile MDS
    2. write some files
    3. mount DS via nfsv3
    
    BUG: unable to handle kernel NULL pointer dereference at           (null)
     IP: [<ffffffff8134f332>] strlen+0x2/0x20
     PGD 0
     Oops: 0000 [#1] SMP
     Modules linked in: nfsd(F) nfs_layout_flexfiles(F) rpcsec_gss_krb5(F) auth_rpcgss(F) nfsv4(F) dns_resolver(F) nfsv3(F) nfs_acl(F) nfs(F) lockd(F) sunrpc(F) fscache(F) ebtable_nat(F) nf_conntrack_netbios_ns(F) nf_conntrack_broadcast(F) ipt_MASQUERADE(F) ip6table_nat(F) nf_nat_ipv6(F) ip6table_mangle(F) ip6t_REJECT(F) nf_conntrack_ipv6(F) nf_defrag_ipv6(F) iptable_nat(F) nf_nat_ipv4(F) nf_nat(F) iptable_mangle(F) nf_conntrack_ipv4(F) nf_defrag_ipv4(F) xt_conntrack(F) nf_conntrack(F) ebtable_filter(F) ebtables(F) ip6table_filter(F) ip6_tables(F) bnep(F) snd_ens1371(F) snd_rawmidi(F) snd_ac97_codec(F) btusb(F) ac97_bus(F) snd_seq(F) snd_seq_device(F) snd_pcm(F) ppdev(F) bluetooth(F) 6lowpan_iphc(F) rfkill(F) vmw_balloon(F) snd_timer(F) snd(F) soundcore(F) gameport(F) i2c_piix4(F) e1000(F) vmw_vmci(F) parport_pc(F) parport(F) shpchp(F) uinput(F) xfs(F) libcrc32c(F) vmwgfx(F) ttm(F) drm(F) mptspi(F) scsi_transport_spi(F) mptscsih(F) mptbase(F) i2c_core(F)
     CPU: 0 PID: 10397 Comm: mount.nfs Tainted: GF            3.14.7-100.pd_client.001.fc16.x86_64 #1
     Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 07/31/2013
     task: ffff880008942600 ti: ffff880007990000 task.ti: ffff880007990000
     RIP: 0010:[<ffffffff8134f332>]  [<ffffffff8134f332>] strlen+0x2/0x20
     RSP: 0018:ffff880007991aa0  EFLAGS: 00010246
     RAX: 0000000000000000 RBX: ffff880038d39c20 RCX: 0000000000000004
     RDX: 0000000000000006 RSI: 0000000000000010 RDI: 0000000000000000
     RBP: ffff880007991b38 R08: 0000000000000000 R09: 0000000000000000
     R10: 0000000000014600 R11: 0000000000000400 R12: ffffffff81cc8580
     R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000004
     FS:  00007f90cd2ef880(0000) GS:ffff88003f600000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
     CR2: 0000000000000000 CR3: 0000000001710000 CR4: 00000000001407f0
     Stack:
      ffffffffa045f52c ffff880001782230 ffff880004141e28 0006880007991ac8
      ffffffff816dc14b ffff880000000000 ffff880038d39c20 0000000000000010
      0000000481cc0006 0000000000000000 ffffffffa0410be8 000000000000c014
     Call Trace:
      [<ffffffffa045f52c>] ? nlmclnt_lookup_host+0x4c/0x2c0 [lockd]
      [<ffffffff816dc14b>] ? _raw_spin_unlock_bh+0x1b/0x20
      [<ffffffffa0410be8>] ? svc_destroy+0xb8/0x140 [sunrpc]
      [<ffffffffa045c323>] nlmclnt_init+0x53/0xc0 [lockd]
      [<ffffffffa047d2dc>] ? nfs_get_client+0x1cc/0x340 [nfs]
      [<ffffffffa047c2e7>] nfs_start_lockd+0xa7/0xd0 [nfs]
      [<ffffffffa047df71>] nfs_create_server+0x181/0x5c0 [nfs]
      [<ffffffffa04460f3>] nfs3_create_server+0x13/0x30 [nfsv3]
      [<ffffffffa048a0bc>] nfs_try_mount+0x21c/0x300 [nfs]
      [<ffffffff811ca32d>] ? __kmalloc_track_caller+0x1ad/0x240
      [<ffffffffa048b677>] ? nfs_fs_mount+0xc37/0xd80 [nfs]
      [<ffffffffa048ad05>] nfs_fs_mount+0x2c5/0xd80 [nfs]
      [<ffffffffa048a830>] ? nfs_clone_super+0x140/0x140 [nfs]
      [<ffffffffa048a240>] ? nfs_clone_sb_security+0x40/0x40 [nfs]
      [<ffffffff811e7e43>] mount_fs+0x43/0x1b0
      [<ffffffff81193100>] ? __alloc_percpu+0x10/0x20
      [<ffffffff812026e6>] vfs_kern_mount+0x76/0x120
      [<ffffffff81204917>] do_mount+0x237/0xa80
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/nfs3client.c b/fs/nfs/nfs3client.c
index 52e2344bf9a1..9e9fa347a948 100644
--- a/fs/nfs/nfs3client.c
+++ b/fs/nfs/nfs3client.c
@@ -1,5 +1,6 @@
 #include <linux/nfs_fs.h>
 #include <linux/nfs_mount.h>
+#include <linux/sunrpc/addr.h>
 #include "internal.h"
 #include "nfs3_fs.h"
 
@@ -89,6 +90,12 @@ struct nfs_client *nfs3_set_ds_client(struct nfs_client *mds_clp,
 	};
 	struct rpc_timeout ds_timeout;
 	struct nfs_client *clp;
+	char buf[INET6_ADDRSTRLEN + 1];
+
+	/* fake a hostname because lockd wants it */
+	if (rpc_ntop(ds_addr, buf, sizeof(buf)) <= 0)
+		return ERR_PTR(-EINVAL);
+	cl_init.hostname = buf;
 
 	/* Use the MDS nfs_client cl_ipaddr. */
 	nfs_init_timeout_values(&ds_timeout, ds_proto, ds_timeo, ds_retrans);

commit 1a04c6e1a26a43305fe124a0978a3e4be861af89
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Fri May 30 18:15:57 2014 +0800

    nfsv3: introduce nfs3_set_ds_client
    
    The flexfiles layout wants to create DS connection over NFSv3.
    Add nfs3_set_ds_client to allow that to happen.
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Tom Haynes <Thomas.Haynes@primarydata.com>

diff --git a/fs/nfs/nfs3client.c b/fs/nfs/nfs3client.c
index 8c1b437c5403..52e2344bf9a1 100644
--- a/fs/nfs/nfs3client.c
+++ b/fs/nfs/nfs3client.c
@@ -64,3 +64,37 @@ struct nfs_server *nfs3_clone_server(struct nfs_server *source,
 		nfs_init_server_aclclient(server);
 	return server;
 }
+
+/*
+ * Set up a pNFS Data Server client over NFSv3.
+ *
+ * Return any existing nfs_client that matches server address,port,version
+ * and minorversion.
+ *
+ * For a new nfs_client, use a soft mount (default), a low retrans and a
+ * low timeout interval so that if a connection is lost, we retry through
+ * the MDS.
+ */
+struct nfs_client *nfs3_set_ds_client(struct nfs_client *mds_clp,
+		const struct sockaddr *ds_addr, int ds_addrlen,
+		int ds_proto, unsigned int ds_timeo, unsigned int ds_retrans,
+		rpc_authflavor_t au_flavor)
+{
+	struct nfs_client_initdata cl_init = {
+		.addr = ds_addr,
+		.addrlen = ds_addrlen,
+		.nfs_mod = &nfs_v3,
+		.proto = ds_proto,
+		.net = mds_clp->cl_net,
+	};
+	struct rpc_timeout ds_timeout;
+	struct nfs_client *clp;
+
+	/* Use the MDS nfs_client cl_ipaddr. */
+	nfs_init_timeout_values(&ds_timeout, ds_proto, ds_timeo, ds_retrans);
+	clp = nfs_get_client(&cl_init, &ds_timeout, mds_clp->cl_ipaddr,
+			     au_flavor);
+
+	return clp;
+}
+EXPORT_SYMBOL_GPL(nfs3_set_ds_client);

commit 3fc3edf141fd78f624194eb89d7b37ff86138422
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Sep 25 16:28:53 2014 -0400

    NFSv3: Fix missing includes of nfs3_fs.h
    
    Silence a few warnings about missing symbols that are due to missing
    includes of nfs3_fs.h.
    
    Fixes: 00a36a1090350 (NFS: Move v3 declarations out of internal.h)
    Fixes: cb8c20fa53ec2 (NFS: Move NFS v3 acl functions to nfs3_fs.h)
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/nfs3client.c b/fs/nfs/nfs3client.c
index b3fc65ef39ca..8c1b437c5403 100644
--- a/fs/nfs/nfs3client.c
+++ b/fs/nfs/nfs3client.c
@@ -1,6 +1,7 @@
 #include <linux/nfs_fs.h>
 #include <linux/nfs_mount.h>
 #include "internal.h"
+#include "nfs3_fs.h"
 
 #ifdef CONFIG_NFS_V3_ACL
 static struct rpc_stat		nfsacl_rpcstat = { &nfsacl_program };

commit 1179acc6a3e260bc4edc74fa94f6c7908290eaec
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 30 16:05:19 2012 -0400

    NFS: Only initialize the ACL client in the v3 case
    
    v2 and v4 don't use it, so I create two new nfs_rpc_ops functions to
    initialize the ACL client only when we are using v3.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/nfs3client.c b/fs/nfs/nfs3client.c
new file mode 100644
index 000000000000..b3fc65ef39ca
--- /dev/null
+++ b/fs/nfs/nfs3client.c
@@ -0,0 +1,65 @@
+#include <linux/nfs_fs.h>
+#include <linux/nfs_mount.h>
+#include "internal.h"
+
+#ifdef CONFIG_NFS_V3_ACL
+static struct rpc_stat		nfsacl_rpcstat = { &nfsacl_program };
+static const struct rpc_version *nfsacl_version[] = {
+	[3]			= &nfsacl_version3,
+};
+
+const struct rpc_program nfsacl_program = {
+	.name			= "nfsacl",
+	.number			= NFS_ACL_PROGRAM,
+	.nrvers			= ARRAY_SIZE(nfsacl_version),
+	.version		= nfsacl_version,
+	.stats			= &nfsacl_rpcstat,
+};
+
+/*
+ * Initialise an NFSv3 ACL client connection
+ */
+static void nfs_init_server_aclclient(struct nfs_server *server)
+{
+	if (server->flags & NFS_MOUNT_NOACL)
+		goto out_noacl;
+
+	server->client_acl = rpc_bind_new_program(server->client, &nfsacl_program, 3);
+	if (IS_ERR(server->client_acl))
+		goto out_noacl;
+
+	/* No errors! Assume that Sun nfsacls are supported */
+	server->caps |= NFS_CAP_ACLS;
+	return;
+
+out_noacl:
+	server->caps &= ~NFS_CAP_ACLS;
+}
+#else
+static inline void nfs_init_server_aclclient(struct nfs_server *server)
+{
+	server->flags &= ~NFS_MOUNT_NOACL;
+	server->caps &= ~NFS_CAP_ACLS;
+}
+#endif
+
+struct nfs_server *nfs3_create_server(struct nfs_mount_info *mount_info,
+				      struct nfs_subversion *nfs_mod)
+{
+	struct nfs_server *server = nfs_create_server(mount_info, nfs_mod);
+	/* Create a client RPC handle for the NFS v3 ACL management interface */
+	if (!IS_ERR(server))
+		nfs_init_server_aclclient(server);
+	return server;
+}
+
+struct nfs_server *nfs3_clone_server(struct nfs_server *source,
+				     struct nfs_fh *fh,
+				     struct nfs_fattr *fattr,
+				     rpc_authflavor_t flavor)
+{
+	struct nfs_server *server = nfs_clone_server(source, fh, fattr, flavor);
+	if (!IS_ERR(server) && !IS_ERR(source->client_acl))
+		nfs_init_server_aclclient(server);
+	return server;
+}
