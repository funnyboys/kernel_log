commit bf11fbdb20b385157b046ea7781f04d0c62554a3
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Tue Jan 29 21:40:10 2019 -0500

    NFS: Add sysfs support for per-container identifier
    
    In order to identify containers to the NFS client, we add a per-net
    sysfs attribute that udev can fill with the appropriate identifier.
    The identifier could be a unique hostname, but in most cases it
    will probably be a persisted uuid.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index fc9978c58265..c8374f74dce1 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -15,6 +15,8 @@ struct bl_dev_msg {
 	uint32_t major, minor;
 };
 
+struct nfs_netns_client;
+
 struct nfs_net {
 	struct cache_detail *nfs_dns_resolve;
 	struct rpc_pipe *bl_device_pipe;
@@ -29,6 +31,7 @@ struct nfs_net {
 	unsigned short nfs_callback_tcpport6;
 	int cb_users[NFS4_MAX_MINOR_VERSION + 1];
 #endif
+	struct nfs_netns_client *nfs_client;
 	spinlock_t nfs_client_lock;
 	ktime_t boot_time;
 #ifdef CONFIG_PROC_FS

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index 5fbd2bde91ba..fc9978c58265 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * NFS-private data for each "struct net".  Accessed with net_generic().
  */

commit c7d03a00b56fc23c3a01a8353789ad257363e281
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Thu Nov 17 04:58:21 2016 +0300

    netns: make struct pernet_operations::id unsigned int
    
    Make struct pernet_operations::id unsigned.
    
    There are 2 reasons to do so:
    
    1)
    This field is really an index into an zero based array and
    thus is unsigned entity. Using negative value is out-of-bound
    access by definition.
    
    2)
    On x86_64 unsigned 32-bit data which are mixed with pointers
    via array indexing or offsets added or subtracted to pointers
    are preffered to signed 32-bit data.
    
    "int" being used as an array index needs to be sign-extended
    to 64-bit before being used.
    
            void f(long *p, int i)
            {
                    g(p[i]);
            }
    
      roughly translates to
    
            movsx   rsi, esi
            mov     rdi, [rsi+...]
            call    g
    
    MOVSX is 3 byte instruction which isn't necessary if the variable is
    unsigned because x86_64 is zero extending by default.
    
    Now, there is net_generic() function which, you guessed it right, uses
    "int" as an array index:
    
            static inline void *net_generic(const struct net *net, int id)
            {
                    ...
                    ptr = ng->ptr[id - 1];
                    ...
            }
    
    And this function is used a lot, so those sign extensions add up.
    
    Patch snipes ~1730 bytes on allyesconfig kernel (without all junk
    messing with code generation):
    
            add/remove: 0/0 grow/shrink: 70/598 up/down: 396/-2126 (-1730)
    
    Unfortunately some functions actually grow bigger.
    This is a semmingly random artefact of code generation with register
    allocator being used differently. gcc decides that some variable
    needs to live in new r8+ registers and every access now requires REX
    prefix. Or it is shifted into r12, so [r12+0] addressing mode has to be
    used which is longer than [r8]
    
    However, overall balance is in negative direction:
    
            add/remove: 0/0 grow/shrink: 70/598 up/down: 396/-2126 (-1730)
            function                                     old     new   delta
            nfsd4_lock                                  3886    3959     +73
            tipc_link_build_proto_msg                   1096    1140     +44
            mac80211_hwsim_new_radio                    2776    2808     +32
            tipc_mon_rcv                                1032    1058     +26
            svcauth_gss_legacy_init                     1413    1429     +16
            tipc_bcbase_select_primary                   379     392     +13
            nfsd4_exchange_id                           1247    1260     +13
            nfsd4_setclientid_confirm                    782     793     +11
                    ...
            put_client_renew_locked                      494     480     -14
            ip_set_sockfn_get                            730     716     -14
            geneve_sock_add                              829     813     -16
            nfsd4_sequence_done                          721     703     -18
            nlmclnt_lookup_host                          708     686     -22
            nfsd4_lockt                                 1085    1063     -22
            nfs_get_client                              1077    1050     -27
            tcf_bpf_init                                1106    1076     -30
            nfsd4_encode_fattr                          5997    5930     -67
            Total: Before=154856051, After=154854321, chg -0.00%
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index fbce0d885d4c..5fbd2bde91ba 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -35,6 +35,6 @@ struct nfs_net {
 #endif
 };
 
-extern int nfs_net_id;
+extern unsigned int nfs_net_id;
 
 #endif

commit 2f86e0919a02d61ed2350c07f383e5542b904289
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Sat Oct 1 16:46:26 2016 -0700

    fs: nfs: Make nfs boot time y2038 safe
    
    boot_time is represented as a struct timespec.
    struct timespec and CURRENT_TIME are not y2038 safe.
    Overall, the plan is to use timespec64 and ktime_t for
    all internal kernel representation of timestamps.
    CURRENT_TIME will also be removed.
    
    boot_time is used to construct the nfs client boot verifier.
    
    Use ktime_t to represent boot_time and ktime_get_real() for
    the boot_time value.
    
    Following Trond's request https://lkml.org/lkml/2016/6/9/22 ,
    use ktime_t instead of converting to struct timespec64.
    
    Use higher and lower 32 bit parts of ktime_t for the boot
    verifier.
    
    Use the lower 32 bit part of ktime_t for the authsys_parms
    stamp field.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Trond Myklebust <trond.myklebust@primarydata.com>
    Cc: Anna Schumaker <anna.schumaker@netapp.com>
    Cc: linux-nfs@vger.kernel.org
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index f0e06e4acbef..fbce0d885d4c 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -29,7 +29,7 @@ struct nfs_net {
 	int cb_users[NFS4_MAX_MINOR_VERSION + 1];
 #endif
 	spinlock_t nfs_client_lock;
-	struct timespec boot_time;
+	ktime_t boot_time;
 #ifdef CONFIG_PROC_FS
 	struct proc_dir_entry *proc_nfsfs;
 #endif

commit e0d4ed71ca0344494722a041780f004d2bcf0f11
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Sep 26 16:02:50 2014 +0200

    pnfs/blocklayout: serialize GETDEVICEINFO calls
    
    The rpc_pipefs code isn't thread safe, leading to occasional use after
    frees when running xfstests generic/241 (dbench).
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/1411740170-18611-2-git-send-email-hch@lst.de
    Cc: stable@vger.kernel.org # 3.17.x
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index ef221fb8a183..f0e06e4acbef 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -19,6 +19,7 @@ struct nfs_net {
 	struct rpc_pipe *bl_device_pipe;
 	struct bl_dev_msg bl_mount_reply;
 	wait_queue_head_t bl_wq;
+	struct mutex bl_mutex;
 	struct list_head nfs_client_list;
 	struct list_head nfs_volume_list;
 #if IS_ENABLED(CONFIG_NFS_V4)

commit 65b38851a17472d31fec9019fc3a55b0802dab88
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jul 31 04:35:20 2014 -0700

    NFS: Fix /proc/fs/nfsfs/servers and /proc/fs/nfsfs/volumes
    
    The usage of pid_ns->child_reaper->nsproxy->net_ns in
    nfs_server_list_open and nfs_client_list_open is not safe.
    
    /proc for a pid namespace can remain mounted after the all of the
    process in that pid namespace have exited.  There are also times
    before the initial process in a pid namespace has started or after the
    initial process in a pid namespace has exited where
    pid_ns->child_reaper can be NULL or stale.  Making the idiom
    pid_ns->child_reaper->nsproxy a double whammy of problems.
    
    Luckily all that needs to happen is to move /proc/fs/nfsfs/servers and
    /proc/fs/nfsfs/volumes under /proc/net to /proc/net/nfsfs/servers and
    /proc/net/nfsfs/volumes and add a symlink from the original location,
    and to use seq_open_net as it has been designed.
    
    Cc: stable@vger.kernel.org
    Cc: Trond Myklebust <trond.myklebust@primarydata.com>
    Cc: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index 8ee1fab83268..ef221fb8a183 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -29,6 +29,9 @@ struct nfs_net {
 #endif
 	spinlock_t nfs_client_lock;
 	struct timespec boot_time;
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *proc_nfsfs;
+#endif
 };
 
 extern int nfs_net_id;

commit ca57ccc48f6a9a3ec655f87acebab82bf01088e7
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Tue Oct 2 14:18:54 2012 +0400

    nfs: include NFSv4 header in netns.h
    
    Build error:
    fs/nfs/netns.h:27:15: error: 'NFS4_MAX_MINOR_VERSION' undeclared here (not in
    a function)
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index b9c7f9b1f91b..8ee1fab83268 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -5,6 +5,7 @@
 #ifndef __NFS_NETNS_H__
 #define __NFS_NETNS_H__
 
+#include <linux/nfs4.h>
 #include <net/net_namespace.h>
 #include <net/netns/generic.h>
 

commit b3d19c51723be69fddb64723bebb5a30fb57a483
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Mon Aug 20 18:00:46 2012 +0400

    NFS: callback per-net usage counting introduced
    
    This patch also introduces refcount-aware nfs_callback_down_net() wrapper for
    svc_shutdown_net().
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index 137238b012fb..b9c7f9b1f91b 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -24,6 +24,7 @@ struct nfs_net {
 	struct idr cb_ident_idr; /* Protected by nfs_client_lock */
 	unsigned short nfs_callback_tcpport;
 	unsigned short nfs_callback_tcpport6;
+	int cb_users[NFS4_MAX_MINOR_VERSION + 1];
 #endif
 	spinlock_t nfs_client_lock;
 	struct timespec boot_time;

commit 29dcc16a8e29371e11fb58fc1292e01f30ff13c5
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Mon Aug 20 18:00:41 2012 +0400

    NFS: make nfs_callback_tcpport6 per network context
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index 1538d3a83cde..137238b012fb 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -23,6 +23,7 @@ struct nfs_net {
 #if IS_ENABLED(CONFIG_NFS_V4)
 	struct idr cb_ident_idr; /* Protected by nfs_client_lock */
 	unsigned short nfs_callback_tcpport;
+	unsigned short nfs_callback_tcpport6;
 #endif
 	spinlock_t nfs_client_lock;
 	struct timespec boot_time;

commit bbe0a3aa4e227c8aae02a484ce1c0b655cd19055
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Mon Aug 20 18:00:36 2012 +0400

    NFS: make nfs_callback_tcpport per network context
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index 0539de1b8d1f..1538d3a83cde 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -22,6 +22,7 @@ struct nfs_net {
 	struct list_head nfs_volume_list;
 #if IS_ENABLED(CONFIG_NFS_V4)
 	struct idr cb_ident_idr; /* Protected by nfs_client_lock */
+	unsigned short nfs_callback_tcpport;
 #endif
 	spinlock_t nfs_client_lock;
 	struct timespec boot_time;

commit 89d77c8fa8e6d1cb7e2cce95b428be30ddcc6f23
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 30 16:05:25 2012 -0400

    NFS: Convert v4 into a module
    
    This patch exports symbols needed by the v4 module.  In addition, I also
    switch over to using IS_ENABLED() to check if CONFIG_NFS_V4 or
    CONFIG_NFS_V4_MODULE are set.
    
    The module (nfs4.ko) will be created in the same directory as nfs.ko and
    will be automatically loaded the first time you try to mount over NFS v4.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index 8a6394edb8b0..0539de1b8d1f 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -20,7 +20,7 @@ struct nfs_net {
 	wait_queue_head_t bl_wq;
 	struct list_head nfs_client_list;
 	struct list_head nfs_volume_list;
-#ifdef CONFIG_NFS_V4
+#if IS_ENABLED(CONFIG_NFS_V4)
 	struct idr cb_ident_idr; /* Protected by nfs_client_lock */
 #endif
 	spinlock_t nfs_client_lock;

commit f092075dd33ea04000590e8ffea65c2e7d03d764
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon May 21 22:45:41 2012 -0400

    NFS: Always use the same SETCLIENTID boot verifier
    
    Currently our NFS client assigns a unique SETCLIENTID boot verifier
    for each server IP address it knows about.  It's set to CURRENT_TIME
    when the struct nfs_client for that server IP is created.
    
    During the SETCLIENTID operation, our client also presents an
    nfs_client_id4 string to servers, as an identifier on which the server
    can hang all of this client's NFSv4 state.  Our client's
    nfs_client_id4 string is unique for each server IP address.
    
    An NFSv4 server is obligated to wipe all NFSv4 state associated with
    an nfs_client_id4 string when the client presents the same
    nfs_client_id4 string along with a changed SETCLIENTID boot verifier.
    
    When our client unmounts the last of a server's shares, it destroys
    that server's struct nfs_client.  The next time the client mounts that
    NFS server, it creates a fresh struct nfs_client with a fresh boot
    verifier.  On seeing the fresh verifer, the server wipes any previous
    NFSv4 state associated with that nfs_client_id4.
    
    However, NFSv4.1 clients are supposed to present the same
    nfs_client_id4 string to all servers.  And, to support Transparent
    State Migration, the same nfs_client_id4 string should be presented
    to all NFSv4.0 servers so they recognize that migrated state for this
    client belongs with state a server may already have for this client.
    (This is known as the Uniform Client String model).
    
    If the nfs_client_id4 string is the same but the boot verifier changes
    for each server IP address, SETCLIENTID and EXCHANGE_ID operations
    from such a client could unintentionally result in a server wiping a
    client's previously obtained lease.
    
    Thus, if our NFS client is going to use a fixed nfs_client_id4 string,
    either for NFSv4.0 or NFSv4.1 mounts, our NFS client should use a
    boot verifier that does not change depending on server IP address.
    Replace our current per-nfs_client boot verifier with a per-nfs_net
    boot verifier.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index aa14ec303e94..8a6394edb8b0 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -1,3 +1,7 @@
+/*
+ * NFS-private data for each "struct net".  Accessed with net_generic().
+ */
+
 #ifndef __NFS_NETNS_H__
 #define __NFS_NETNS_H__
 
@@ -20,6 +24,7 @@ struct nfs_net {
 	struct idr cb_ident_idr; /* Protected by nfs_client_lock */
 #endif
 	spinlock_t nfs_client_lock;
+	struct timespec boot_time;
 };
 
 extern int nfs_net_id;

commit 5ffaf8554163d9f3873988ce2f9977f6c6f408d2
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Sun Mar 11 18:20:31 2012 +0400

    NFS: replace global bl_wq with per-net one
    
    This queue is used for sleeping in kernel and it have to be per-net since we
    don't want to wake any other waiters except in out network nemespace.
    BTW, move wq to per-net data is easy. But some way to handle upcall timeouts
    have to be provided. On message destroy in case of timeout, tasks, waiting for
    message to be delivered, should be awakened. Thus, some data required to
    located the right wait queue. Chosen solution replaces rpc_pipe_msg object with
    new introduced bl_pipe_msg object, containing rpc_pipe_msg and proper wq.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index 73425f555cde..aa14ec303e94 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -13,6 +13,7 @@ struct nfs_net {
 	struct cache_detail *nfs_dns_resolve;
 	struct rpc_pipe *bl_device_pipe;
 	struct bl_dev_msg bl_mount_reply;
+	wait_queue_head_t bl_wq;
 	struct list_head nfs_client_list;
 	struct list_head nfs_volume_list;
 #ifdef CONFIG_NFS_V4

commit cb9c1c4a880bc734c2848f8647be2cfa336ee346
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Sun Mar 11 18:20:23 2012 +0400

    NFS: replace global bl_mount_reply with per-net one
    
    This global variable is used for blocklayout downcall and thus can be corrupted
    if case of existence of multiple networks namespaces.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index 7baad89ae60e..73425f555cde 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -4,9 +4,15 @@
 #include <net/net_namespace.h>
 #include <net/netns/generic.h>
 
+struct bl_dev_msg {
+	int32_t status;
+	uint32_t major, minor;
+};
+
 struct nfs_net {
 	struct cache_detail *nfs_dns_resolve;
 	struct rpc_pipe *bl_device_pipe;
+	struct bl_dev_msg bl_mount_reply;
 	struct list_head nfs_client_list;
 	struct list_head nfs_volume_list;
 #ifdef CONFIG_NFS_V4

commit dc03085834a4530b2514708a643cd3fe38f35b21
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Mon Jan 23 17:26:31 2012 +0000

    NFS: make nfs_client_lock per net ns
    
    This patch makes nfs_clients_lock allocated per network namespace. All items it
    protects are already network namespace aware.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index 547cc9525ba2..7baad89ae60e 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -12,6 +12,7 @@ struct nfs_net {
 #ifdef CONFIG_NFS_V4
 	struct idr cb_ident_idr; /* Protected by nfs_client_lock */
 #endif
+	spinlock_t nfs_client_lock;
 };
 
 extern int nfs_net_id;

commit 28cd1b3f262dba56b5e335ba668e342d530f6129
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Mon Jan 23 17:26:22 2012 +0000

    NFS: make cb_ident_idr per net ns
    
    This patch makes ID's infrastructure network namespace aware. This was done
    mainly because of nfs_client_lock, which is desired to be per network
    namespace, but protects NFS clients ID's.
    
    NOTE: NFS client's net pointer have to be set prior to ID initialization,
    proper assignment was moved.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index 0fbd4e017d27..547cc9525ba2 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -9,6 +9,9 @@ struct nfs_net {
 	struct rpc_pipe *bl_device_pipe;
 	struct list_head nfs_client_list;
 	struct list_head nfs_volume_list;
+#ifdef CONFIG_NFS_V4
+	struct idr cb_ident_idr; /* Protected by nfs_client_lock */
+#endif
 };
 
 extern int nfs_net_id;

commit c25d32b26361ce0814fef2281f164866c18c8692
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Mon Jan 23 17:26:14 2012 +0000

    NFS: make nfs_volume_list per net ns
    
    This patch splits global list of NFS servers into per-net-ns array of lists.
    This looks more strict and clearer.
    BTW, this patch also makes "/proc/fs/nfsfs/volumes" content depends on /proc
    mount owner pid namespace. See below for details.
    
    NOTE: few words about how was /proc/fs/nfsfs/ entries content show per network
    namespace done. This is a little bit tricky and not the best is could be. But
    it's cheap (proper fix for /proc conteinerization is a hard nut to crack).
    The idea is simple: take proper network namespace from pid namespace
    child reaper nsproxy of /proc/ mount creator.
    This actually means, that if there are 2 containers with different net
    namespace sharing pid namespace, then read of /proc/fs/nfsfs/ entries will
    always return content, taken from net namespace of pid namespace creator task
    (and thus second namespace set wil be unvisible).
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index feb33c3f9a56..0fbd4e017d27 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -8,6 +8,7 @@ struct nfs_net {
 	struct cache_detail *nfs_dns_resolve;
 	struct rpc_pipe *bl_device_pipe;
 	struct list_head nfs_client_list;
+	struct list_head nfs_volume_list;
 };
 
 extern int nfs_net_id;

commit 6b13168b36b6a7f603d962c232f1f2f325705832
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Mon Jan 23 17:26:05 2012 +0000

    NFS: make nfs_client_list per net ns
    
    This patch splits global list of NFS clients into per-net-ns array of lists.
    This looks more strict and clearer.
    BTW, this patch also makes "/proc/fs/nfsfs/servers" entry content depends on
    /proc mount owner pid namespace. See below for details.
    
    NOTE: few words about how was /proc/fs/nfsfs/ entries content show per network
    namespace done. This is a little bit tricky and not the best is could be. But
    it's cheap (proper fix for /proc conteinerization is a hard nut to crack).
    The idea is simple: take proper network namespace from pid namespace
    child reaper nsproxy of /proc/ mount creator.
    This actually means, that if there are 2 containers with different net
    namespace sharing pid namespace, then read of /proc/fs/nfsfs/ entries will
    always return content, taken from net namespace of pid namespace creator task
    (and thus second namespace set wil be unvisible).
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index 39ae4cad5b4b..feb33c3f9a56 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -7,6 +7,7 @@
 struct nfs_net {
 	struct cache_detail *nfs_dns_resolve;
 	struct rpc_pipe *bl_device_pipe;
+	struct list_head nfs_client_list;
 };
 
 extern int nfs_net_id;

commit 9e2e74dba6ddce94da187369b50a27536147d5df
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Tue Jan 10 17:04:24 2012 +0400

    NFS: blocklayout pipe creation per network namespace context introduced
    
    This patch implements blocklayout pipe creation and registration per each
    existent network namespace.
    This was achived by registering NFS per-net operations, responsible for
    blocklayout pipe allocation/register and unregister/destruction instead of
    initialization and destruction of static "bl_device_pipe" pipe (this one was
    removed).
    Note, than pointer to network blocklayout pipe is stored in per-net "nfs_net"
    structure, because allocating of one more per-net structure for blocklayout
    module looks redundant.
    This patch also changes dev_remove() function prototype (and all it's callers,
    where it' requied) by adding network namespace pointer parameter, which is used
    to discover proper blocklayout pipe for rpc_queue_upcall() call.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
index 8c1f130d6ca2..39ae4cad5b4b 100644
--- a/fs/nfs/netns.h
+++ b/fs/nfs/netns.h
@@ -6,6 +6,7 @@
 
 struct nfs_net {
 	struct cache_detail *nfs_dns_resolve;
+	struct rpc_pipe *bl_device_pipe;
 };
 
 extern int nfs_net_id;

commit 1b340d0118da1d7c60c664f17d7c8fce2bb1cd9d
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Fri Nov 25 17:13:04 2011 +0300

    NFS: DNS resolver cache per network namespace context introduced
    
    This patch implements DNS resolver cache creation and registration for each
    alive network namespace context.
    This was done by registering NFS per-net operations, responsible for DNS cache
    allocation/register and unregister/destructioning instead of initialization and
    destruction of static "nfs_dns_resolve" cache detail (this one was removed).
    Pointer to network dns resolver cache is stored in new per-net "nfs_net"
    structure.
    This patch also changes nfs_dns_resolve_name() function prototype (and it's
    calls) by adding network pointer parameter, which is used to get proper DNS
    resolver cache pointer for do_cache_lookup_wait() call.
    
    Note: empty nfs_dns_resolver_init() and nfs_dns_resolver_destroy() functions
    will be used in next patch in the series.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/netns.h b/fs/nfs/netns.h
new file mode 100644
index 000000000000..8c1f130d6ca2
--- /dev/null
+++ b/fs/nfs/netns.h
@@ -0,0 +1,13 @@
+#ifndef __NFS_NETNS_H__
+#define __NFS_NETNS_H__
+
+#include <net/net_namespace.h>
+#include <net/netns/generic.h>
+
+struct nfs_net {
+	struct cache_detail *nfs_dns_resolve;
+};
+
+extern int nfs_net_id;
+
+#endif
