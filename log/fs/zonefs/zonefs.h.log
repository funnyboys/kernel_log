commit 8dcc1a9d90c10fa4143e5c17821082e5e60e46a1
Author: Damien Le Moal <damien.lemoal@wdc.com>
Date:   Wed Dec 25 16:07:44 2019 +0900

    fs: New zonefs file system
    
    zonefs is a very simple file system exposing each zone of a zoned block
    device as a file. Unlike a regular file system with zoned block device
    support (e.g. f2fs), zonefs does not hide the sequential write
    constraint of zoned block devices to the user. Files representing
    sequential write zones of the device must be written sequentially
    starting from the end of the file (append only writes).
    
    As such, zonefs is in essence closer to a raw block device access
    interface than to a full featured POSIX file system. The goal of zonefs
    is to simplify the implementation of zoned block device support in
    applications by replacing raw block device file accesses with a richer
    file API, avoiding relying on direct block device file ioctls which may
    be more obscure to developers. One example of this approach is the
    implementation of LSM (log-structured merge) tree structures (such as
    used in RocksDB and LevelDB) on zoned block devices by allowing SSTables
    to be stored in a zone file similarly to a regular file system rather
    than as a range of sectors of a zoned device. The introduction of the
    higher level construct "one file is one zone" can help reducing the
    amount of changes needed in the application as well as introducing
    support for different application programming languages.
    
    Zonefs on-disk metadata is reduced to an immutable super block to
    persistently store a magic number and optional feature flags and
    values. On mount, zonefs uses blkdev_report_zones() to obtain the device
    zone configuration and populates the mount point with a static file tree
    solely based on this information. E.g. file sizes come from the device
    zone type and write pointer offset managed by the device itself.
    
    The zone files created on mount have the following characteristics.
    1) Files representing zones of the same type are grouped together
       under a common sub-directory:
         * For conventional zones, the sub-directory "cnv" is used.
         * For sequential write zones, the sub-directory "seq" is used.
      These two directories are the only directories that exist in zonefs.
      Users cannot create other directories and cannot rename nor delete
      the "cnv" and "seq" sub-directories.
    2) The name of zone files is the number of the file within the zone
       type sub-directory, in order of increasing zone start sector.
    3) The size of conventional zone files is fixed to the device zone size.
       Conventional zone files cannot be truncated.
    4) The size of sequential zone files represent the file's zone write
       pointer position relative to the zone start sector. Truncating these
       files is allowed only down to 0, in which case, the zone is reset to
       rewind the zone write pointer position to the start of the zone, or
       up to the zone size, in which case the file's zone is transitioned
       to the FULL state (finish zone operation).
    5) All read and write operations to files are not allowed beyond the
       file zone size. Any access exceeding the zone size is failed with
       the -EFBIG error.
    6) Creating, deleting, renaming or modifying any attribute of files and
       sub-directories is not allowed.
    7) There are no restrictions on the type of read and write operations
       that can be issued to conventional zone files. Buffered, direct and
       mmap read & write operations are accepted. For sequential zone files,
       there are no restrictions on read operations, but all write
       operations must be direct IO append writes. mmap write of sequential
       files is not allowed.
    
    Several optional features of zonefs can be enabled at format time.
    * Conventional zone aggregation: ranges of contiguous conventional
      zones can be aggregated into a single larger file instead of the
      default one file per zone.
    * File ownership: The owner UID and GID of zone files is by default 0
      (root) but can be changed to any valid UID/GID.
    * File access permissions: the default 640 access permissions can be
      changed.
    
    The mkzonefs tool is used to format zoned block devices for use with
    zonefs. This tool is available on Github at:
    
    git@github.com:damien-lemoal/zonefs-tools.git.
    
    zonefs-tools also includes a test suite which can be run against any
    zoned block device, including null_blk block device created with zoned
    mode.
    
    Example: the following formats a 15TB host-managed SMR HDD with 256 MB
    zones with the conventional zones aggregation feature enabled.
    
    $ sudo mkzonefs -o aggr_cnv /dev/sdX
    $ sudo mount -t zonefs /dev/sdX /mnt
    $ ls -l /mnt/
    total 0
    dr-xr-xr-x 2 root root     1 Nov 25 13:23 cnv
    dr-xr-xr-x 2 root root 55356 Nov 25 13:23 seq
    
    The size of the zone files sub-directories indicate the number of files
    existing for each type of zones. In this example, there is only one
    conventional zone file (all conventional zones are aggregated under a
    single file).
    
    $ ls -l /mnt/cnv
    total 137101312
    -rw-r----- 1 root root 140391743488 Nov 25 13:23 0
    
    This aggregated conventional zone file can be used as a regular file.
    
    $ sudo mkfs.ext4 /mnt/cnv/0
    $ sudo mount -o loop /mnt/cnv/0 /data
    
    The "seq" sub-directory grouping files for sequential write zones has
    in this example 55356 zones.
    
    $ ls -lv /mnt/seq
    total 14511243264
    -rw-r----- 1 root root 0 Nov 25 13:23 0
    -rw-r----- 1 root root 0 Nov 25 13:23 1
    -rw-r----- 1 root root 0 Nov 25 13:23 2
    ...
    -rw-r----- 1 root root 0 Nov 25 13:23 55354
    -rw-r----- 1 root root 0 Nov 25 13:23 55355
    
    For sequential write zone files, the file size changes as data is
    appended at the end of the file, similarly to any regular file system.
    
    $ dd if=/dev/zero of=/mnt/seq/0 bs=4K count=1 conv=notrunc oflag=direct
    1+0 records in
    1+0 records out
    4096 bytes (4.1 kB, 4.0 KiB) copied, 0.000452219 s, 9.1 MB/s
    
    $ ls -l /mnt/seq/0
    -rw-r----- 1 root root 4096 Nov 25 13:23 /mnt/seq/0
    
    The written file can be truncated to the zone size, preventing any
    further write operation.
    
    $ truncate -s 268435456 /mnt/seq/0
    $ ls -l /mnt/seq/0
    -rw-r----- 1 root root 268435456 Nov 25 13:49 /mnt/seq/0
    
    Truncation to 0 size allows freeing the file zone storage space and
    restart append-writes to the file.
    
    $ truncate -s 0 /mnt/seq/0
    $ ls -l /mnt/seq/0
    -rw-r----- 1 root root 0 Nov 25 13:49 /mnt/seq/0
    
    Since files are statically mapped to zones on the disk, the number of
    blocks of a file as reported by stat() and fstat() indicates the size
    of the file zone.
    
    $ stat /mnt/seq/0
      File: /mnt/seq/0
      Size: 0       Blocks: 524288     IO Block: 4096   regular empty file
    Device: 870h/2160d      Inode: 50431       Links: 1
    Access: (0640/-rw-r-----)  Uid: (    0/    root)   Gid: (    0/  root)
    Access: 2019-11-25 13:23:57.048971997 +0900
    Modify: 2019-11-25 13:52:25.553805765 +0900
    Change: 2019-11-25 13:52:25.553805765 +0900
     Birth: -
    
    The number of blocks of the file ("Blocks") in units of 512B blocks
    gives the maximum file size of 524288 * 512 B = 256 MB, corresponding
    to the device zone size in this example. Of note is that the "IO block"
    field always indicates the minimum IO size for writes and corresponds
    to the device physical sector size.
    
    This code contains contributions from:
    * Johannes Thumshirn <jthumshirn@suse.de>,
    * Darrick J. Wong <darrick.wong@oracle.com>,
    * Christoph Hellwig <hch@lst.de>,
    * Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com> and
    * Ting Yao <tingyao@hust.edu.cn>.
    
    Signed-off-by: Damien Le Moal <damien.lemoal@wdc.com>
    Reviewed-by: Dave Chinner <dchinner@redhat.com>

diff --git a/fs/zonefs/zonefs.h b/fs/zonefs/zonefs.h
new file mode 100644
index 000000000000..ad17fef7ce91
--- /dev/null
+++ b/fs/zonefs/zonefs.h
@@ -0,0 +1,189 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Simple zone file system for zoned block devices.
+ *
+ * Copyright (C) 2019 Western Digital Corporation or its affiliates.
+ */
+#ifndef __ZONEFS_H__
+#define __ZONEFS_H__
+
+#include <linux/fs.h>
+#include <linux/magic.h>
+#include <linux/uuid.h>
+#include <linux/mutex.h>
+#include <linux/rwsem.h>
+
+/*
+ * Maximum length of file names: this only needs to be large enough to fit
+ * the zone group directory names and a decimal zone number for file names.
+ * 16 characters is plenty.
+ */
+#define ZONEFS_NAME_MAX		16
+
+/*
+ * Zone types: ZONEFS_ZTYPE_SEQ is used for all sequential zone types
+ * defined in linux/blkzoned.h, that is, BLK_ZONE_TYPE_SEQWRITE_REQ and
+ * BLK_ZONE_TYPE_SEQWRITE_PREF.
+ */
+enum zonefs_ztype {
+	ZONEFS_ZTYPE_CNV,
+	ZONEFS_ZTYPE_SEQ,
+	ZONEFS_ZTYPE_MAX,
+};
+
+static inline enum zonefs_ztype zonefs_zone_type(struct blk_zone *zone)
+{
+	if (zone->type == BLK_ZONE_TYPE_CONVENTIONAL)
+		return ZONEFS_ZTYPE_CNV;
+	return ZONEFS_ZTYPE_SEQ;
+}
+
+/*
+ * In-memory inode data.
+ */
+struct zonefs_inode_info {
+	struct inode		i_vnode;
+
+	/* File zone type */
+	enum zonefs_ztype	i_ztype;
+
+	/* File zone start sector (512B unit) */
+	sector_t		i_zsector;
+
+	/* File zone write pointer position (sequential zones only) */
+	loff_t			i_wpoffset;
+
+	/* File maximum size */
+	loff_t			i_max_size;
+
+	/*
+	 * To serialise fully against both syscall and mmap based IO and
+	 * sequential file truncation, two locks are used. For serializing
+	 * zonefs_seq_file_truncate() against zonefs_iomap_begin(), that is,
+	 * file truncate operations against block mapping, i_truncate_mutex is
+	 * used. i_truncate_mutex also protects against concurrent accesses
+	 * and changes to the inode private data, and in particular changes to
+	 * a sequential file size on completion of direct IO writes.
+	 * Serialization of mmap read IOs with truncate and syscall IO
+	 * operations is done with i_mmap_sem in addition to i_truncate_mutex.
+	 * Only zonefs_seq_file_truncate() takes both lock (i_mmap_sem first,
+	 * i_truncate_mutex second).
+	 */
+	struct mutex		i_truncate_mutex;
+	struct rw_semaphore	i_mmap_sem;
+};
+
+static inline struct zonefs_inode_info *ZONEFS_I(struct inode *inode)
+{
+	return container_of(inode, struct zonefs_inode_info, i_vnode);
+}
+
+/*
+ * On-disk super block (block 0).
+ */
+#define ZONEFS_LABEL_LEN	64
+#define ZONEFS_UUID_SIZE	16
+#define ZONEFS_SUPER_SIZE	4096
+
+struct zonefs_super {
+
+	/* Magic number */
+	__le32		s_magic;
+
+	/* Checksum */
+	__le32		s_crc;
+
+	/* Volume label */
+	char		s_label[ZONEFS_LABEL_LEN];
+
+	/* 128-bit uuid */
+	__u8		s_uuid[ZONEFS_UUID_SIZE];
+
+	/* Features */
+	__le64		s_features;
+
+	/* UID/GID to use for files */
+	__le32		s_uid;
+	__le32		s_gid;
+
+	/* File permissions */
+	__le32		s_perm;
+
+	/* Padding to ZONEFS_SUPER_SIZE bytes */
+	__u8		s_reserved[3988];
+
+} __packed;
+
+/*
+ * Feature flags: specified in the s_features field of the on-disk super
+ * block struct zonefs_super and in-memory in the s_feartures field of
+ * struct zonefs_sb_info.
+ */
+enum zonefs_features {
+	/*
+	 * Aggregate contiguous conventional zones into a single file.
+	 */
+	ZONEFS_F_AGGRCNV = 1ULL << 0,
+	/*
+	 * Use super block specified UID for files instead of default 0.
+	 */
+	ZONEFS_F_UID = 1ULL << 1,
+	/*
+	 * Use super block specified GID for files instead of default 0.
+	 */
+	ZONEFS_F_GID = 1ULL << 2,
+	/*
+	 * Use super block specified file permissions instead of default 640.
+	 */
+	ZONEFS_F_PERM = 1ULL << 3,
+};
+
+#define ZONEFS_F_DEFINED_FEATURES \
+	(ZONEFS_F_AGGRCNV | ZONEFS_F_UID | ZONEFS_F_GID | ZONEFS_F_PERM)
+
+/*
+ * Mount options for zone write pointer error handling.
+ */
+#define ZONEFS_MNTOPT_ERRORS_RO		(1 << 0) /* Make zone file readonly */
+#define ZONEFS_MNTOPT_ERRORS_ZRO	(1 << 1) /* Make zone file offline */
+#define ZONEFS_MNTOPT_ERRORS_ZOL	(1 << 2) /* Make zone file offline */
+#define ZONEFS_MNTOPT_ERRORS_REPAIR	(1 << 3) /* Remount read-only */
+#define ZONEFS_MNTOPT_ERRORS_MASK	\
+	(ZONEFS_MNTOPT_ERRORS_RO | ZONEFS_MNTOPT_ERRORS_ZRO | \
+	 ZONEFS_MNTOPT_ERRORS_ZOL | ZONEFS_MNTOPT_ERRORS_REPAIR)
+
+/*
+ * In-memory Super block information.
+ */
+struct zonefs_sb_info {
+
+	unsigned long		s_mount_opts;
+
+	spinlock_t		s_lock;
+
+	unsigned long long	s_features;
+	kuid_t			s_uid;
+	kgid_t			s_gid;
+	umode_t			s_perm;
+	uuid_t			s_uuid;
+	unsigned int		s_zone_sectors_shift;
+
+	unsigned int		s_nr_files[ZONEFS_ZTYPE_MAX];
+
+	loff_t			s_blocks;
+	loff_t			s_used_blocks;
+};
+
+static inline struct zonefs_sb_info *ZONEFS_SB(struct super_block *sb)
+{
+	return sb->s_fs_info;
+}
+
+#define zonefs_info(sb, format, args...)	\
+	pr_info("zonefs (%s): " format, sb->s_id, ## args)
+#define zonefs_err(sb, format, args...)		\
+	pr_err("zonefs (%s) ERROR: " format, sb->s_id, ## args)
+#define zonefs_warn(sb, format, args...)	\
+	pr_warn("zonefs (%s) WARNING: " format, sb->s_id, ## args)
+
+#endif
