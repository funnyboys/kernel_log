commit 817e9b4d9e660761e1e613aa294bf77d2e7c7310
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Jun 1 12:19:45 2018 -0400

    orangefs: specify user pointers when using dev_map_desc and bufmap
    
    Sparse lead me to the dev_map_desc one and Al Viro lead me to the bufmap
    one.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index 61ee8d64c842..d403cf29a99b 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -342,7 +342,7 @@ enum {
  * that may be 32 bit!
  */
 struct ORANGEFS_dev_map_desc {
-	void *ptr;
+	void __user *ptr;
 	__s32 total_size;
 	__s32 size;
 	__s32 count;

commit 209469d978ae91e460b37b32f2c2834d93e1ff13
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 3 16:27:14 2018 +0000

    orangefs: remove unused code
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index dc6e3e6269c3..61ee8d64c842 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -5,11 +5,6 @@
 #include <linux/slab.h>
 #include <linux/ioctl.h>
 
-/* pvfs2-config.h ***********************************************************/
-#define ORANGEFS_VERSION_MAJOR 2
-#define ORANGEFS_VERSION_MINOR 9
-#define ORANGEFS_VERSION_SUB 0
-
 /* khandle stuff  ***********************************************************/
 
 /*
@@ -70,16 +65,6 @@ static inline void ORANGEFS_khandle_from(struct orangefs_khandle *kh,
 }
 
 /* pvfs2-types.h ************************************************************/
-typedef __u32 ORANGEFS_uid;
-typedef __u32 ORANGEFS_gid;
-typedef __s32 ORANGEFS_fs_id;
-typedef __u32 ORANGEFS_permissions;
-typedef __u64 ORANGEFS_time;
-typedef __s64 ORANGEFS_size;
-typedef __u64 ORANGEFS_flags;
-typedef __u64 ORANGEFS_ds_position;
-typedef __s32 ORANGEFS_error;
-typedef __s64 ORANGEFS_offset;
 
 #define ORANGEFS_SUPER_MAGIC 0x20030528
 
@@ -145,7 +130,6 @@ typedef __s64 ORANGEFS_offset;
 #define ORANGEFS_APPEND_FL    FS_APPEND_FL
 #define ORANGEFS_NOATIME_FL   FS_NOATIME_FL
 #define ORANGEFS_MIRROR_FL    0x01000000ULL
-#define ORANGEFS_O_EXECUTE (1 << 0)
 #define ORANGEFS_FS_ID_NULL       ((__s32)0)
 #define ORANGEFS_ATTR_SYS_UID                   (1 << 0)
 #define ORANGEFS_ATTR_SYS_GID                   (1 << 1)
@@ -229,35 +213,6 @@ enum orangefs_ds_type {
 	ORANGEFS_TYPE_INTERNAL = (1 << 5)	/* for the server's private use */
 };
 
-/*
- * ORANGEFS_certificate simply stores a buffer with the buffer size.
- * The buffer can be converted to an OpenSSL X509 struct for use.
- */
-struct ORANGEFS_certificate {
-	__u32 buf_size;
-	unsigned char *buf;
-};
-
-/*
- * A credential identifies a user and is signed by the client/user
- * private key.
- */
-struct ORANGEFS_credential {
-	__u32 userid;	/* user id */
-	__u32 num_groups;	/* length of group_array */
-	__u32 *group_array;	/* groups for which the user is a member */
-	char *issuer;		/* alias of the issuing server */
-	__u64 timeout;	/* seconds after epoch to time out */
-	__u32 sig_size;	/* length of the signature in bytes */
-	unsigned char *signature;	/* digital signature */
-	struct ORANGEFS_certificate certificate;	/* user certificate buffer */
-};
-#define extra_size_ORANGEFS_credential (ORANGEFS_REQ_LIMIT_GROUPS	*	\
-				    sizeof(__u32)		+	\
-				    ORANGEFS_REQ_LIMIT_ISSUER	+	\
-				    ORANGEFS_REQ_LIMIT_SIGNATURE	+	\
-				    extra_size_ORANGEFS_certificate)
-
 /* This structure is used by the VFS-client interaction alone */
 struct ORANGEFS_keyval_pair {
 	char key[ORANGEFS_MAX_XATTR_NAMELEN];

commit 79d7cd611d9e0ee9b4c38bd33f6082979826885f
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Jan 26 14:07:12 2018 -0500

    orangefs: remove gossip_ldebug and gossip_lerr
    
    gossip_ldebug is unused.
    
    gossip_lerr is used in two places.  The messages are unique so line
    numbers are unnecessary.
    
    Also remove support for compiling gossip messages out.  It wasn't
    possible to enable it anyway.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index e0bf5e4dce0d..dc6e3e6269c3 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -395,13 +395,6 @@ struct ORANGEFS_dev_map_desc {
 
 /* gossip.h *****************************************************************/
 
-#ifdef GOSSIP_DISABLE_DEBUG
-#define gossip_debug(mask, fmt, ...)					\
-do {									\
-	if (0)								\
-		printk(KERN_DEBUG fmt, ##__VA_ARGS__);			\
-} while (0)
-#else
 extern __u64 orangefs_gossip_debug_mask;
 
 /* try to avoid function call overhead by checking masks in macro */
@@ -410,13 +403,5 @@ do {									\
 	if (orangefs_gossip_debug_mask & (mask))			\
 		printk(KERN_DEBUG fmt, ##__VA_ARGS__);			\
 } while (0)
-#endif /* GOSSIP_DISABLE_DEBUG */
-
-/* do file and line number printouts w/ the GNU preprocessor */
-#define gossip_ldebug(mask, fmt, ...)					\
-	gossip_debug(mask, "%s: " fmt, __func__, ##__VA_ARGS__)
 
 #define gossip_err pr_err
-#define gossip_lerr(fmt, ...)						\
-	gossip_err("%s line %d: " fmt,					\
-		   __FILE__, __LINE__, ##__VA_ARGS__)

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index 48bcc1bbe415..e0bf5e4dce0d 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/spinlock_types.h>

commit 7b796ae37092ef520641b3a96c211c1cc67a0346
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 25 15:38:02 2017 -0400

    orangefs: remove ORANGEFS_READDIR macros
    
    They are clones of the ORANGEFS_ITERATE macros in use elsewhere.  Delete
    ORANGEFS_ITERATE_NEXT which is a hack previously used by readdir.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index 971307ad69be..48bcc1bbe415 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -138,13 +138,8 @@ typedef __s64 ORANGEFS_offset;
 #define ORANGEFS_G_SGID    (1 << 10)
 #define ORANGEFS_U_SUID    (1 << 11)
 
-/* definition taken from stdint.h */
-#define INT32_MAX (2147483647)
-#define ORANGEFS_ITERATE_START    (INT32_MAX - 1)
-#define ORANGEFS_ITERATE_END      (INT32_MAX - 2)
-#define ORANGEFS_ITERATE_NEXT     (INT32_MAX - 3)
-#define ORANGEFS_READDIR_START ORANGEFS_ITERATE_START
-#define ORANGEFS_READDIR_END   ORANGEFS_ITERATE_END
+#define ORANGEFS_ITERATE_START    2147483646
+#define ORANGEFS_ITERATE_END      2147483645
 #define ORANGEFS_IMMUTABLE_FL FS_IMMUTABLE_FL
 #define ORANGEFS_APPEND_FL    FS_APPEND_FL
 #define ORANGEFS_NOATIME_FL   FS_NOATIME_FL

commit 44f4641073f132429e1e9a53412600206e8f7d06
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Aug 15 11:38:36 2016 -0400

    orangefs: clean up debugfs globals
    
    Mostly this is moving code into orangefs-debugfs.c so that globals turn
    into static globals.
    
    Then gossip_debug_mask is renamed orangefs_gossip_debug_mask but keeps
    global visibility, so it can be used from a macro.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index 3d7418c728f5..971307ad69be 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -4,26 +4,6 @@
 #include <linux/slab.h>
 #include <linux/ioctl.h>
 
-extern struct client_debug_mask *cdm_array;
-extern char *debug_help_string;
-extern int help_string_initialized;
-extern struct dentry *debug_dir;
-extern struct dentry *help_file_dentry;
-extern struct dentry *client_debug_dentry;
-extern const struct file_operations debug_help_fops;
-extern int client_all_index;
-extern int client_verbose_index;
-extern int cdm_element_count;
-#define DEBUG_HELP_STRING_SIZE 4096
-#define HELP_STRING_UNINITIALIZED \
-	"Client Debug Keywords are unknown until the first time\n" \
-	"the client is started after boot.\n"
-#define ORANGEFS_KMOD_DEBUG_HELP_FILE "debug-help"
-#define ORANGEFS_KMOD_DEBUG_FILE "kernel-debug"
-#define ORANGEFS_CLIENT_DEBUG_FILE "client-debug"
-#define ORANGEFS_VERBOSE "verbose"
-#define ORANGEFS_ALL "all"
-
 /* pvfs2-config.h ***********************************************************/
 #define ORANGEFS_VERSION_MAJOR 2
 #define ORANGEFS_VERSION_MINOR 9
@@ -426,13 +406,12 @@ do {									\
 		printk(KERN_DEBUG fmt, ##__VA_ARGS__);			\
 } while (0)
 #else
-extern __u64 gossip_debug_mask;
-extern struct client_debug_mask client_debug_mask;
+extern __u64 orangefs_gossip_debug_mask;
 
 /* try to avoid function call overhead by checking masks in macro */
 #define gossip_debug(mask, fmt, ...)					\
 do {									\
-	if (gossip_debug_mask & (mask))					\
+	if (orangefs_gossip_debug_mask & (mask))			\
 		printk(KERN_DEBUG fmt, ##__VA_ARGS__);			\
 } while (0)
 #endif /* GOSSIP_DISABLE_DEBUG */

commit 71680c18c8f22deafbaaf76d1c2d0eed2899a3d2
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Jun 9 16:32:38 2016 -0400

    orangefs: Cache getattr results.
    
    The userspace component attempts to do this, but this will prevent
    us from even needing to go into userspace to satisfy certain getattr
    requests.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index 1efc6f8a5224..3d7418c728f5 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -207,14 +207,6 @@ typedef __s64 ORANGEFS_offset;
 	 ORANGEFS_ATTR_SYS_DIRENT_COUNT		|	\
 	 ORANGEFS_ATTR_SYS_BLKSIZE)
 
-#define ORANGEFS_ATTR_SYS_ALL_NOHINT_NOSIZE		\
-	(ORANGEFS_ATTR_SYS_COMMON_ALL		|	\
-	 ORANGEFS_ATTR_SYS_LNK_TARGET		|	\
-	 ORANGEFS_ATTR_SYS_DFILE_COUNT		|	\
-	 ORANGEFS_ATTR_SYS_MIRROR_COPIES_COUNT	|	\
-	 ORANGEFS_ATTR_SYS_DIRENT_COUNT		|	\
-	 ORANGEFS_ATTR_SYS_BLKSIZE)
-
 #define ORANGEFS_XATTR_REPLACE 0x2
 #define ORANGEFS_XATTR_CREATE  0x1
 #define ORANGEFS_MAX_SERVER_ADDR_LEN 256

commit 1917a6932870062778e3099eb432795d45918fc3
Author: Joe Perches <joe@perches.com>
Date:   Sun Mar 27 14:34:52 2016 -0700

    orangefs: Add KERN_<LEVEL> to gossip_<level> macros
    
    Emit the logging messages at the appropriate levels.
    
    Miscellanea:
    
    o Change format to fmt
    o Use the more common ##__VA_ARGS__
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index a7f21a3b2d02..1efc6f8a5224 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -1,3 +1,4 @@
+#include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/spinlock_types.h>
 #include <linux/slab.h>
@@ -427,26 +428,28 @@ struct ORANGEFS_dev_map_desc {
 /* gossip.h *****************************************************************/
 
 #ifdef GOSSIP_DISABLE_DEBUG
-#define gossip_debug(mask, format, f...) do {} while (0)
+#define gossip_debug(mask, fmt, ...)					\
+do {									\
+	if (0)								\
+		printk(KERN_DEBUG fmt, ##__VA_ARGS__);			\
+} while (0)
 #else
 extern __u64 gossip_debug_mask;
 extern struct client_debug_mask client_debug_mask;
 
 /* try to avoid function call overhead by checking masks in macro */
-#define gossip_debug(mask, format, f...)			\
-do {								\
-	if (gossip_debug_mask & mask)				\
-		printk(format, ##f);				\
+#define gossip_debug(mask, fmt, ...)					\
+do {									\
+	if (gossip_debug_mask & (mask))					\
+		printk(KERN_DEBUG fmt, ##__VA_ARGS__);			\
 } while (0)
 #endif /* GOSSIP_DISABLE_DEBUG */
 
 /* do file and line number printouts w/ the GNU preprocessor */
-#define gossip_ldebug(mask, format, f...)				\
-		gossip_debug(mask, "%s: " format, __func__, ##f)
-
-#define gossip_err printk
-#define gossip_lerr(format, f...)					\
-		gossip_err("%s line %d: " format,			\
-			   __FILE__,					\
-			   __LINE__,					\
-			   ##f)
+#define gossip_ldebug(mask, fmt, ...)					\
+	gossip_debug(mask, "%s: " fmt, __func__, ##__VA_ARGS__)
+
+#define gossip_err pr_err
+#define gossip_lerr(fmt, ...)						\
+	gossip_err("%s line %d: " fmt,					\
+		   __FILE__, __LINE__, ##__VA_ARGS__)

commit a9bb3ba81fba1750139654360cb716ab093103b0
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Apr 6 11:19:37 2016 -0400

    Orangefs: optimize boilerplate code.
    
    Suggested by David Binderman <dcb314@hotmail.com>
    The former can potentially be a performance win over the latter.
    
    memcpy(d, s, len);
    memset(d+len, c, size-len);
    
    memset(d, c, size);
    memcpy(d, s, len);
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index 50578a28bd9e..a7f21a3b2d02 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -74,8 +74,8 @@ static inline void ORANGEFS_khandle_to(const struct orangefs_khandle *kh,
 				   void *p, int size)
 {
 
-	memset(p, 0, size);
 	memcpy(p, kh->u, 16);
+	memset(p + 16, 0, size - 16);
 
 }
 

commit 878dfd3210e0bfc047995022de3091724ea9a5f6
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Wed Mar 30 16:18:43 2016 -0400

    orangefs: minimum userspace version is 2.9.3
    
    Version 2.9.4 isn't even released yet.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index 45ce4ff4cbc7..50578a28bd9e 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -407,7 +407,7 @@ enum {
  * space. Zero signifies the upstream version of the kernel module.
  */
 #define ORANGEFS_KERNEL_PROTO_VERSION 0
-#define ORANGEFS_MINIMUM_USERSPACE_VERSION 20904
+#define ORANGEFS_MINIMUM_USERSPACE_VERSION 20903
 
 /*
  * describes memory regions to map in the ORANGEFS_DEV_MAP ioctl.

commit 6ceaf7818f266d917ed61338885ddd2b77008f06
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Sat Feb 20 14:47:13 2016 -0500

    orangefs: we never lookup with sym_follow set
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index 6ac0c60c9f5e..45ce4ff4cbc7 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -339,7 +339,6 @@ struct ORANGEFS_sys_attr_s {
 };
 
 #define ORANGEFS_LOOKUP_LINK_NO_FOLLOW 0
-#define ORANGEFS_LOOKUP_LINK_FOLLOW    1
 
 /* pint-dev.h ***************************************************************/
 

commit 933287da750edefbf0f449750fd67b4fc6c10013
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Sat Jan 30 13:46:54 2016 -0500

    orangefs: Implement inode_operations->permission().
    
    Thus d_revalidate is not obliged to check on as much, which will
    eventually lead the way to hammering the filesystem servers much less.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index 56dd65abb908..6ac0c60c9f5e 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -205,6 +205,15 @@ typedef __s64 ORANGEFS_offset;
 	 ORANGEFS_ATTR_SYS_MIRROR_COPIES_COUNT	|	\
 	 ORANGEFS_ATTR_SYS_DIRENT_COUNT		|	\
 	 ORANGEFS_ATTR_SYS_BLKSIZE)
+
+#define ORANGEFS_ATTR_SYS_ALL_NOHINT_NOSIZE		\
+	(ORANGEFS_ATTR_SYS_COMMON_ALL		|	\
+	 ORANGEFS_ATTR_SYS_LNK_TARGET		|	\
+	 ORANGEFS_ATTR_SYS_DFILE_COUNT		|	\
+	 ORANGEFS_ATTR_SYS_MIRROR_COPIES_COUNT	|	\
+	 ORANGEFS_ATTR_SYS_DIRENT_COUNT		|	\
+	 ORANGEFS_ATTR_SYS_BLKSIZE)
+
 #define ORANGEFS_XATTR_REPLACE 0x2
 #define ORANGEFS_XATTR_CREATE  0x1
 #define ORANGEFS_MAX_SERVER_ADDR_LEN 256

commit 569dbfc6b3a0e71118bc81f5f0fb56c3d1b88c54
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Jan 13 11:36:25 2016 -0500

    Orangefs: define a minimum compatible userspace version.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index 03bbe7505a35..56dd65abb908 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -399,6 +399,7 @@ enum {
  * space. Zero signifies the upstream version of the kernel module.
  */
 #define ORANGEFS_KERNEL_PROTO_VERSION 0
+#define ORANGEFS_MINIMUM_USERSPACE_VERSION 20904
 
 /*
  * describes memory regions to map in the ORANGEFS_DEV_MAP ioctl.

commit 575e946125f70c41c2042f10172842c5cab9a09a
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Dec 4 12:56:14 2015 -0500

    Orangefs: change pvfs2 filenames to orangefs
    
    Also changed references within source files that referred to
    header files whose names had changed.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index 5f10ebc83e76..03bbe7505a35 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -130,7 +130,7 @@ typedef __s64 ORANGEFS_offset;
 /* Bits 6 - 0 are reserved for the actual error code. */
 #define ORANGEFS_ERROR_NUMBER_BITS 0x7f
 
-/* Encoded errno values are decoded by PINT_errno_mapping in pvfs2-utils.c. */
+/* Encoded errno values decoded by PINT_errno_mapping in orangefs-utils.c. */
 
 /* Our own ORANGEFS protocol error codes. */
 #define ORANGEFS_ECANCEL    (1|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
@@ -352,7 +352,7 @@ struct dev_mask2_info_s {
 __s32 ORANGEFS_util_translate_mode(int mode);
 
 /* pvfs2-debug.h ************************************************************/
-#include "pvfs2-debug.h"
+#include "orangefs-debug.h"
 
 /* pvfs2-internal.h *********************************************************/
 #define llu(x) (unsigned long long)(x)
@@ -402,7 +402,7 @@ enum {
 
 /*
  * describes memory regions to map in the ORANGEFS_DEV_MAP ioctl.
- * NOTE: See devpvfs2-req.c for 32 bit compat structure.
+ * NOTE: See devorangefs-req.c for 32 bit compat structure.
  * Since this structure has a variable-sized layout that is different
  * on 32 and 64 bit platforms, we need to normalize to a 64 bit layout
  * on such systems before servicing ioctl calls from user-space binaries

commit 8bb8aefd5afb54a25a002feb4ec70011812d06a0
Author: Yi Liu <yi9@clemson.edu>
Date:   Tue Nov 24 15:12:14 2015 -0500

    OrangeFS: Change almost all instances of the string PVFS2 to OrangeFS.
    
    OrangeFS was formerly known as PVFS2 and retains the name in many places.
    
    I leave the device /dev/pvfs2-req since this affects userspace.
    
    I leave the filesystem type pvfs2 since this affects userspace. Further
    the OrangeFS sysint library reads fstab for an entry of type pvfs2
    independently of kernel mounts.
    
    I leave extended attribute keys user.pvfs2 and system.pvfs2 as the
    sysint library understands these.
    
    I leave references to userspace binaries still named pvfs2.
    
    I leave the filenames.
    
    Signed-off-by: Yi Liu <yi9@clemson.edu>
    [martin@omnibond.com: clairify above constraints and merge]
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index 85f611fe0536..5f10ebc83e76 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -20,13 +20,13 @@ extern int cdm_element_count;
 #define ORANGEFS_KMOD_DEBUG_HELP_FILE "debug-help"
 #define ORANGEFS_KMOD_DEBUG_FILE "kernel-debug"
 #define ORANGEFS_CLIENT_DEBUG_FILE "client-debug"
-#define PVFS2_VERBOSE "verbose"
-#define PVFS2_ALL "all"
+#define ORANGEFS_VERBOSE "verbose"
+#define ORANGEFS_ALL "all"
 
 /* pvfs2-config.h ***********************************************************/
-#define PVFS2_VERSION_MAJOR 2
-#define PVFS2_VERSION_MINOR 9
-#define PVFS2_VERSION_SUB 0
+#define ORANGEFS_VERSION_MAJOR 2
+#define ORANGEFS_VERSION_MINOR 9
+#define ORANGEFS_VERSION_SUB 0
 
 /* khandle stuff  ***********************************************************/
 
@@ -38,15 +38,15 @@ extern int cdm_element_count;
  * The kernel module will always use the first four bytes and
  * the last four bytes as an inum.
  */
-struct pvfs2_khandle {
+struct orangefs_khandle {
 	unsigned char u[16];
 }  __aligned(8);
 
 /*
  * kernel version of an object ref.
  */
-struct pvfs2_object_kref {
-	struct pvfs2_khandle khandle;
+struct orangefs_object_kref {
+	struct orangefs_khandle khandle;
 	__s32 fs_id;
 	__s32 __pad1;
 };
@@ -55,8 +55,8 @@ struct pvfs2_object_kref {
  * compare 2 khandles assumes little endian thus from large address to
  * small address
  */
-static inline int PVFS_khandle_cmp(const struct pvfs2_khandle *kh1,
-				   const struct pvfs2_khandle *kh2)
+static inline int ORANGEFS_khandle_cmp(const struct orangefs_khandle *kh1,
+				   const struct orangefs_khandle *kh2)
 {
 	int i;
 
@@ -70,7 +70,7 @@ static inline int PVFS_khandle_cmp(const struct pvfs2_khandle *kh1,
 	return 0;
 }
 
-static inline void PVFS_khandle_to(const struct pvfs2_khandle *kh,
+static inline void ORANGEFS_khandle_to(const struct orangefs_khandle *kh,
 				   void *p, int size)
 {
 
@@ -79,7 +79,7 @@ static inline void PVFS_khandle_to(const struct pvfs2_khandle *kh,
 
 }
 
-static inline void PVFS_khandle_from(struct pvfs2_khandle *kh,
+static inline void ORANGEFS_khandle_from(struct orangefs_khandle *kh,
 				     void *p, int size)
 {
 	memset(kh, 0, 16);
@@ -88,152 +88,152 @@ static inline void PVFS_khandle_from(struct pvfs2_khandle *kh,
 }
 
 /* pvfs2-types.h ************************************************************/
-typedef __u32 PVFS_uid;
-typedef __u32 PVFS_gid;
-typedef __s32 PVFS_fs_id;
-typedef __u32 PVFS_permissions;
-typedef __u64 PVFS_time;
-typedef __s64 PVFS_size;
-typedef __u64 PVFS_flags;
-typedef __u64 PVFS_ds_position;
-typedef __s32 PVFS_error;
-typedef __s64 PVFS_offset;
-
-#define PVFS2_SUPER_MAGIC 0x20030528
+typedef __u32 ORANGEFS_uid;
+typedef __u32 ORANGEFS_gid;
+typedef __s32 ORANGEFS_fs_id;
+typedef __u32 ORANGEFS_permissions;
+typedef __u64 ORANGEFS_time;
+typedef __s64 ORANGEFS_size;
+typedef __u64 ORANGEFS_flags;
+typedef __u64 ORANGEFS_ds_position;
+typedef __s32 ORANGEFS_error;
+typedef __s64 ORANGEFS_offset;
+
+#define ORANGEFS_SUPER_MAGIC 0x20030528
 
 /*
- * PVFS2 error codes are a signed 32-bit integer. Error codes are negative, but
+ * ORANGEFS error codes are a signed 32-bit integer. Error codes are negative, but
  * the sign is stripped before decoding.
  */
 
 /* Bit 31 is not used since it is the sign. */
 
 /*
- * Bit 30 specifies that this is a PVFS2 error. A PVFS2 error is either an
- * encoded errno value or a PVFS2 protocol error.
+ * Bit 30 specifies that this is a ORANGEFS error. A ORANGEFS error is either an
+ * encoded errno value or a ORANGEFS protocol error.
  */
-#define PVFS_ERROR_BIT (1 << 30)
+#define ORANGEFS_ERROR_BIT (1 << 30)
 
 /*
- * Bit 29 specifies that this is a PVFS2 protocol error and not an encoded
+ * Bit 29 specifies that this is a ORANGEFS protocol error and not an encoded
  * errno value.
  */
-#define PVFS_NON_ERRNO_ERROR_BIT (1 << 29)
+#define ORANGEFS_NON_ERRNO_ERROR_BIT (1 << 29)
 
 /*
  * Bits 9, 8, and 7 specify the error class, which encodes the section of
  * server code the error originated in for logging purposes. It is not used
  * in the kernel except to be masked out.
  */
-#define PVFS_ERROR_CLASS_BITS 0x380
+#define ORANGEFS_ERROR_CLASS_BITS 0x380
 
 /* Bits 6 - 0 are reserved for the actual error code. */
-#define PVFS_ERROR_NUMBER_BITS 0x7f
+#define ORANGEFS_ERROR_NUMBER_BITS 0x7f
 
 /* Encoded errno values are decoded by PINT_errno_mapping in pvfs2-utils.c. */
 
-/* Our own PVFS2 protocol error codes. */
-#define PVFS_ECANCEL    (1|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
-#define PVFS_EDEVINIT   (2|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
-#define PVFS_EDETAIL    (3|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
-#define PVFS_EHOSTNTFD  (4|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
-#define PVFS_EADDRNTFD  (5|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
-#define PVFS_ENORECVR   (6|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
-#define PVFS_ETRYAGAIN  (7|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
-#define PVFS_ENOTPVFS   (8|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
-#define PVFS_ESECURITY  (9|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
+/* Our own ORANGEFS protocol error codes. */
+#define ORANGEFS_ECANCEL    (1|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
+#define ORANGEFS_EDEVINIT   (2|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
+#define ORANGEFS_EDETAIL    (3|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
+#define ORANGEFS_EHOSTNTFD  (4|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
+#define ORANGEFS_EADDRNTFD  (5|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
+#define ORANGEFS_ENORECVR   (6|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
+#define ORANGEFS_ETRYAGAIN  (7|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
+#define ORANGEFS_ENOTPVFS   (8|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
+#define ORANGEFS_ESECURITY  (9|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
 
 /* permission bits */
-#define PVFS_O_EXECUTE (1 << 0)
-#define PVFS_O_WRITE   (1 << 1)
-#define PVFS_O_READ    (1 << 2)
-#define PVFS_G_EXECUTE (1 << 3)
-#define PVFS_G_WRITE   (1 << 4)
-#define PVFS_G_READ    (1 << 5)
-#define PVFS_U_EXECUTE (1 << 6)
-#define PVFS_U_WRITE   (1 << 7)
-#define PVFS_U_READ    (1 << 8)
-/* no PVFS_U_VTX (sticky bit) */
-#define PVFS_G_SGID    (1 << 10)
-#define PVFS_U_SUID    (1 << 11)
+#define ORANGEFS_O_EXECUTE (1 << 0)
+#define ORANGEFS_O_WRITE   (1 << 1)
+#define ORANGEFS_O_READ    (1 << 2)
+#define ORANGEFS_G_EXECUTE (1 << 3)
+#define ORANGEFS_G_WRITE   (1 << 4)
+#define ORANGEFS_G_READ    (1 << 5)
+#define ORANGEFS_U_EXECUTE (1 << 6)
+#define ORANGEFS_U_WRITE   (1 << 7)
+#define ORANGEFS_U_READ    (1 << 8)
+/* no ORANGEFS_U_VTX (sticky bit) */
+#define ORANGEFS_G_SGID    (1 << 10)
+#define ORANGEFS_U_SUID    (1 << 11)
 
 /* definition taken from stdint.h */
 #define INT32_MAX (2147483647)
-#define PVFS_ITERATE_START    (INT32_MAX - 1)
-#define PVFS_ITERATE_END      (INT32_MAX - 2)
-#define PVFS_ITERATE_NEXT     (INT32_MAX - 3)
-#define PVFS_READDIR_START PVFS_ITERATE_START
-#define PVFS_READDIR_END   PVFS_ITERATE_END
-#define PVFS_IMMUTABLE_FL FS_IMMUTABLE_FL
-#define PVFS_APPEND_FL    FS_APPEND_FL
-#define PVFS_NOATIME_FL   FS_NOATIME_FL
-#define PVFS_MIRROR_FL    0x01000000ULL
-#define PVFS_O_EXECUTE (1 << 0)
-#define PVFS_FS_ID_NULL       ((__s32)0)
-#define PVFS_ATTR_SYS_UID                   (1 << 0)
-#define PVFS_ATTR_SYS_GID                   (1 << 1)
-#define PVFS_ATTR_SYS_PERM                  (1 << 2)
-#define PVFS_ATTR_SYS_ATIME                 (1 << 3)
-#define PVFS_ATTR_SYS_CTIME                 (1 << 4)
-#define PVFS_ATTR_SYS_MTIME                 (1 << 5)
-#define PVFS_ATTR_SYS_TYPE                  (1 << 6)
-#define PVFS_ATTR_SYS_ATIME_SET             (1 << 7)
-#define PVFS_ATTR_SYS_MTIME_SET             (1 << 8)
-#define PVFS_ATTR_SYS_SIZE                  (1 << 20)
-#define PVFS_ATTR_SYS_LNK_TARGET            (1 << 24)
-#define PVFS_ATTR_SYS_DFILE_COUNT           (1 << 25)
-#define PVFS_ATTR_SYS_DIRENT_COUNT          (1 << 26)
-#define PVFS_ATTR_SYS_BLKSIZE               (1 << 28)
-#define PVFS_ATTR_SYS_MIRROR_COPIES_COUNT   (1 << 29)
-#define PVFS_ATTR_SYS_COMMON_ALL	\
-	(PVFS_ATTR_SYS_UID	|	\
-	 PVFS_ATTR_SYS_GID	|	\
-	 PVFS_ATTR_SYS_PERM	|	\
-	 PVFS_ATTR_SYS_ATIME	|	\
-	 PVFS_ATTR_SYS_CTIME	|	\
-	 PVFS_ATTR_SYS_MTIME	|	\
-	 PVFS_ATTR_SYS_TYPE)
-
-#define PVFS_ATTR_SYS_ALL_SETABLE		\
-(PVFS_ATTR_SYS_COMMON_ALL-PVFS_ATTR_SYS_TYPE)
-
-#define PVFS_ATTR_SYS_ALL_NOHINT			\
-	(PVFS_ATTR_SYS_COMMON_ALL		|	\
-	 PVFS_ATTR_SYS_SIZE			|	\
-	 PVFS_ATTR_SYS_LNK_TARGET		|	\
-	 PVFS_ATTR_SYS_DFILE_COUNT		|	\
-	 PVFS_ATTR_SYS_MIRROR_COPIES_COUNT	|	\
-	 PVFS_ATTR_SYS_DIRENT_COUNT		|	\
-	 PVFS_ATTR_SYS_BLKSIZE)
-#define PVFS_XATTR_REPLACE 0x2
-#define PVFS_XATTR_CREATE  0x1
-#define PVFS_MAX_SERVER_ADDR_LEN 256
-#define PVFS_NAME_MAX            256
+#define ORANGEFS_ITERATE_START    (INT32_MAX - 1)
+#define ORANGEFS_ITERATE_END      (INT32_MAX - 2)
+#define ORANGEFS_ITERATE_NEXT     (INT32_MAX - 3)
+#define ORANGEFS_READDIR_START ORANGEFS_ITERATE_START
+#define ORANGEFS_READDIR_END   ORANGEFS_ITERATE_END
+#define ORANGEFS_IMMUTABLE_FL FS_IMMUTABLE_FL
+#define ORANGEFS_APPEND_FL    FS_APPEND_FL
+#define ORANGEFS_NOATIME_FL   FS_NOATIME_FL
+#define ORANGEFS_MIRROR_FL    0x01000000ULL
+#define ORANGEFS_O_EXECUTE (1 << 0)
+#define ORANGEFS_FS_ID_NULL       ((__s32)0)
+#define ORANGEFS_ATTR_SYS_UID                   (1 << 0)
+#define ORANGEFS_ATTR_SYS_GID                   (1 << 1)
+#define ORANGEFS_ATTR_SYS_PERM                  (1 << 2)
+#define ORANGEFS_ATTR_SYS_ATIME                 (1 << 3)
+#define ORANGEFS_ATTR_SYS_CTIME                 (1 << 4)
+#define ORANGEFS_ATTR_SYS_MTIME                 (1 << 5)
+#define ORANGEFS_ATTR_SYS_TYPE                  (1 << 6)
+#define ORANGEFS_ATTR_SYS_ATIME_SET             (1 << 7)
+#define ORANGEFS_ATTR_SYS_MTIME_SET             (1 << 8)
+#define ORANGEFS_ATTR_SYS_SIZE                  (1 << 20)
+#define ORANGEFS_ATTR_SYS_LNK_TARGET            (1 << 24)
+#define ORANGEFS_ATTR_SYS_DFILE_COUNT           (1 << 25)
+#define ORANGEFS_ATTR_SYS_DIRENT_COUNT          (1 << 26)
+#define ORANGEFS_ATTR_SYS_BLKSIZE               (1 << 28)
+#define ORANGEFS_ATTR_SYS_MIRROR_COPIES_COUNT   (1 << 29)
+#define ORANGEFS_ATTR_SYS_COMMON_ALL	\
+	(ORANGEFS_ATTR_SYS_UID	|	\
+	 ORANGEFS_ATTR_SYS_GID	|	\
+	 ORANGEFS_ATTR_SYS_PERM	|	\
+	 ORANGEFS_ATTR_SYS_ATIME	|	\
+	 ORANGEFS_ATTR_SYS_CTIME	|	\
+	 ORANGEFS_ATTR_SYS_MTIME	|	\
+	 ORANGEFS_ATTR_SYS_TYPE)
+
+#define ORANGEFS_ATTR_SYS_ALL_SETABLE		\
+(ORANGEFS_ATTR_SYS_COMMON_ALL-ORANGEFS_ATTR_SYS_TYPE)
+
+#define ORANGEFS_ATTR_SYS_ALL_NOHINT			\
+	(ORANGEFS_ATTR_SYS_COMMON_ALL		|	\
+	 ORANGEFS_ATTR_SYS_SIZE			|	\
+	 ORANGEFS_ATTR_SYS_LNK_TARGET		|	\
+	 ORANGEFS_ATTR_SYS_DFILE_COUNT		|	\
+	 ORANGEFS_ATTR_SYS_MIRROR_COPIES_COUNT	|	\
+	 ORANGEFS_ATTR_SYS_DIRENT_COUNT		|	\
+	 ORANGEFS_ATTR_SYS_BLKSIZE)
+#define ORANGEFS_XATTR_REPLACE 0x2
+#define ORANGEFS_XATTR_CREATE  0x1
+#define ORANGEFS_MAX_SERVER_ADDR_LEN 256
+#define ORANGEFS_NAME_MAX                256
 /*
  * max extended attribute name len as imposed by the VFS and exploited for the
  * upcall request types.
  * NOTE: Please retain them as multiples of 8 even if you wish to change them
  * This is *NECESSARY* for supporting 32 bit user-space binaries on a 64-bit
  * kernel. Due to implementation within DBPF, this really needs to be
- * PVFS_NAME_MAX, which it was the same value as, but no reason to let it
+ * ORANGEFS_NAME_MAX, which it was the same value as, but no reason to let it
  * break if that changes in the future.
  */
-#define PVFS_MAX_XATTR_NAMELEN   PVFS_NAME_MAX	/* Not the same as
+#define ORANGEFS_MAX_XATTR_NAMELEN   ORANGEFS_NAME_MAX	/* Not the same as
 						 * XATTR_NAME_MAX defined
 						 * by <linux/xattr.h>
 						 */
-#define PVFS_MAX_XATTR_VALUELEN  8192	/* Not the same as XATTR_SIZE_MAX
+#define ORANGEFS_MAX_XATTR_VALUELEN  8192	/* Not the same as XATTR_SIZE_MAX
 					 * defined by <linux/xattr.h>
 					 */
-#define PVFS_MAX_XATTR_LISTLEN   16	/* Not the same as XATTR_LIST_MAX
+#define ORANGEFS_MAX_XATTR_LISTLEN   16	/* Not the same as XATTR_LIST_MAX
 					 * defined by <linux/xattr.h>
 					 */
 /*
- * PVFS I/O operation types, used in both system and server interfaces.
+ * ORANGEFS I/O operation types, used in both system and server interfaces.
  */
-enum PVFS_io_type {
-	PVFS_IO_READ = 1,
-	PVFS_IO_WRITE = 2
+enum ORANGEFS_io_type {
+	ORANGEFS_IO_READ = 1,
+	ORANGEFS_IO_WRITE = 2
 };
 
 /*
@@ -241,21 +241,21 @@ enum PVFS_io_type {
  * batch and low threshold sizes may need to be modified  to reflect this
  * change.
  */
-enum pvfs2_ds_type {
-	PVFS_TYPE_NONE = 0,
-	PVFS_TYPE_METAFILE = (1 << 0),
-	PVFS_TYPE_DATAFILE = (1 << 1),
-	PVFS_TYPE_DIRECTORY = (1 << 2),
-	PVFS_TYPE_SYMLINK = (1 << 3),
-	PVFS_TYPE_DIRDATA = (1 << 4),
-	PVFS_TYPE_INTERNAL = (1 << 5)	/* for the server's private use */
+enum orangefs_ds_type {
+	ORANGEFS_TYPE_NONE = 0,
+	ORANGEFS_TYPE_METAFILE = (1 << 0),
+	ORANGEFS_TYPE_DATAFILE = (1 << 1),
+	ORANGEFS_TYPE_DIRECTORY = (1 << 2),
+	ORANGEFS_TYPE_SYMLINK = (1 << 3),
+	ORANGEFS_TYPE_DIRDATA = (1 << 4),
+	ORANGEFS_TYPE_INTERNAL = (1 << 5)	/* for the server's private use */
 };
 
 /*
- * PVFS_certificate simply stores a buffer with the buffer size.
+ * ORANGEFS_certificate simply stores a buffer with the buffer size.
  * The buffer can be converted to an OpenSSL X509 struct for use.
  */
-struct PVFS_certificate {
+struct ORANGEFS_certificate {
 	__u32 buf_size;
 	unsigned char *buf;
 };
@@ -264,7 +264,7 @@ struct PVFS_certificate {
  * A credential identifies a user and is signed by the client/user
  * private key.
  */
-struct PVFS_credential {
+struct ORANGEFS_credential {
 	__u32 userid;	/* user id */
 	__u32 num_groups;	/* length of group_array */
 	__u32 *group_array;	/* groups for which the user is a member */
@@ -272,25 +272,25 @@ struct PVFS_credential {
 	__u64 timeout;	/* seconds after epoch to time out */
 	__u32 sig_size;	/* length of the signature in bytes */
 	unsigned char *signature;	/* digital signature */
-	struct PVFS_certificate certificate;	/* user certificate buffer */
+	struct ORANGEFS_certificate certificate;	/* user certificate buffer */
 };
-#define extra_size_PVFS_credential (PVFS_REQ_LIMIT_GROUPS	*	\
+#define extra_size_ORANGEFS_credential (ORANGEFS_REQ_LIMIT_GROUPS	*	\
 				    sizeof(__u32)		+	\
-				    PVFS_REQ_LIMIT_ISSUER	+	\
-				    PVFS_REQ_LIMIT_SIGNATURE	+	\
-				    extra_size_PVFS_certificate)
+				    ORANGEFS_REQ_LIMIT_ISSUER	+	\
+				    ORANGEFS_REQ_LIMIT_SIGNATURE	+	\
+				    extra_size_ORANGEFS_certificate)
 
 /* This structure is used by the VFS-client interaction alone */
-struct PVFS_keyval_pair {
-	char key[PVFS_MAX_XATTR_NAMELEN];
+struct ORANGEFS_keyval_pair {
+	char key[ORANGEFS_MAX_XATTR_NAMELEN];
 	__s32 key_sz;	/* __s32 for portable, fixed-size structures */
 	__s32 val_sz;
-	char val[PVFS_MAX_XATTR_VALUELEN];
+	char val[ORANGEFS_MAX_XATTR_VALUELEN];
 };
 
 /* pvfs2-sysint.h ***********************************************************/
 /* Describes attributes for a file, directory, or symlink. */
-struct PVFS_sys_attr_s {
+struct ORANGEFS_sys_attr_s {
 	__u32 owner;
 	__u32 group;
 	__u32 perms;
@@ -323,18 +323,18 @@ struct PVFS_sys_attr_s {
 	char *dist_params;
 
 	__s64 dirent_count;
-	enum pvfs2_ds_type objtype;
+	enum orangefs_ds_type objtype;
 	__u64 flags;
 	__u32 mask;
 	__s64 blksize;
 };
 
-#define PVFS2_LOOKUP_LINK_NO_FOLLOW 0
-#define PVFS2_LOOKUP_LINK_FOLLOW    1
+#define ORANGEFS_LOOKUP_LINK_NO_FOLLOW 0
+#define ORANGEFS_LOOKUP_LINK_FOLLOW    1
 
 /* pint-dev.h ***************************************************************/
 
-/* parameter structure used in PVFS_DEV_DEBUG ioctl command */
+/* parameter structure used in ORANGEFS_DEV_DEBUG ioctl command */
 struct dev_mask_info_s {
 	enum {
 		KERNEL_MASK,
@@ -349,7 +349,7 @@ struct dev_mask2_info_s {
 };
 
 /* pvfs2-util.h *************************************************************/
-__s32 PVFS_util_translate_mode(int mode);
+__s32 ORANGEFS_util_translate_mode(int mode);
 
 /* pvfs2-debug.h ************************************************************/
 #include "pvfs2-debug.h"
@@ -359,9 +359,9 @@ __s32 PVFS_util_translate_mode(int mode);
 #define lld(x) (long long)(x)
 
 /* pint-dev-shared.h ********************************************************/
-#define PVFS_DEV_MAGIC 'k'
+#define ORANGEFS_DEV_MAGIC 'k'
 
-#define PVFS2_READDIR_DEFAULT_DESC_COUNT  5
+#define ORANGEFS_READDIR_DEFAULT_DESC_COUNT  5
 
 #define DEV_GET_MAGIC           0x1
 #define DEV_GET_MAX_UPSIZE      0x2
@@ -376,39 +376,39 @@ __s32 PVFS_util_translate_mode(int mode);
 
 /* supported ioctls, codes are with respect to user-space */
 enum {
-	PVFS_DEV_GET_MAGIC = _IOW(PVFS_DEV_MAGIC, DEV_GET_MAGIC, __s32),
-	PVFS_DEV_GET_MAX_UPSIZE =
-	    _IOW(PVFS_DEV_MAGIC, DEV_GET_MAX_UPSIZE, __s32),
-	PVFS_DEV_GET_MAX_DOWNSIZE =
-	    _IOW(PVFS_DEV_MAGIC, DEV_GET_MAX_DOWNSIZE, __s32),
-	PVFS_DEV_MAP = _IO(PVFS_DEV_MAGIC, DEV_MAP),
-	PVFS_DEV_REMOUNT_ALL = _IO(PVFS_DEV_MAGIC, DEV_REMOUNT_ALL),
-	PVFS_DEV_DEBUG = _IOR(PVFS_DEV_MAGIC, DEV_DEBUG, __s32),
-	PVFS_DEV_UPSTREAM = _IOW(PVFS_DEV_MAGIC, DEV_UPSTREAM, int),
-	PVFS_DEV_CLIENT_MASK = _IOW(PVFS_DEV_MAGIC,
+	ORANGEFS_DEV_GET_MAGIC = _IOW(ORANGEFS_DEV_MAGIC, DEV_GET_MAGIC, __s32),
+	ORANGEFS_DEV_GET_MAX_UPSIZE =
+	    _IOW(ORANGEFS_DEV_MAGIC, DEV_GET_MAX_UPSIZE, __s32),
+	ORANGEFS_DEV_GET_MAX_DOWNSIZE =
+	    _IOW(ORANGEFS_DEV_MAGIC, DEV_GET_MAX_DOWNSIZE, __s32),
+	ORANGEFS_DEV_MAP = _IO(ORANGEFS_DEV_MAGIC, DEV_MAP),
+	ORANGEFS_DEV_REMOUNT_ALL = _IO(ORANGEFS_DEV_MAGIC, DEV_REMOUNT_ALL),
+	ORANGEFS_DEV_DEBUG = _IOR(ORANGEFS_DEV_MAGIC, DEV_DEBUG, __s32),
+	ORANGEFS_DEV_UPSTREAM = _IOW(ORANGEFS_DEV_MAGIC, DEV_UPSTREAM, int),
+	ORANGEFS_DEV_CLIENT_MASK = _IOW(ORANGEFS_DEV_MAGIC,
 				    DEV_CLIENT_MASK,
 				    struct dev_mask2_info_s),
-	PVFS_DEV_CLIENT_STRING = _IOW(PVFS_DEV_MAGIC,
+	ORANGEFS_DEV_CLIENT_STRING = _IOW(ORANGEFS_DEV_MAGIC,
 				      DEV_CLIENT_STRING,
 				      char *),
-	PVFS_DEV_MAXNR = DEV_MAX_NR,
+	ORANGEFS_DEV_MAXNR = DEV_MAX_NR,
 };
 
 /*
  * version number for use in communicating between kernel space and user
  * space. Zero signifies the upstream version of the kernel module.
  */
-#define PVFS_KERNEL_PROTO_VERSION 0
+#define ORANGEFS_KERNEL_PROTO_VERSION 0
 
 /*
- * describes memory regions to map in the PVFS_DEV_MAP ioctl.
+ * describes memory regions to map in the ORANGEFS_DEV_MAP ioctl.
  * NOTE: See devpvfs2-req.c for 32 bit compat structure.
  * Since this structure has a variable-sized layout that is different
  * on 32 and 64 bit platforms, we need to normalize to a 64 bit layout
  * on such systems before servicing ioctl calls from user-space binaries
  * that may be 32 bit!
  */
-struct PVFS_dev_map_desc {
+struct ORANGEFS_dev_map_desc {
 	void *ptr;
 	__s32 total_size;
 	__s32 size;

commit 548049495cb46348866aec1cb7721e9d00b4eb83
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Mon Oct 5 13:44:24 2015 -0400

    Orangefs: fix some checkpatch.pl complaints that had creeped in.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index b374c4b2009e..85f611fe0536 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -101,22 +101,30 @@ typedef __s64 PVFS_offset;
 
 #define PVFS2_SUPER_MAGIC 0x20030528
 
-/* PVFS2 error codes are a signed 32-bit integer. Error codes are negative, but
- * the sign is stripped before decoding. */
+/*
+ * PVFS2 error codes are a signed 32-bit integer. Error codes are negative, but
+ * the sign is stripped before decoding.
+ */
 
 /* Bit 31 is not used since it is the sign. */
 
-/* Bit 30 specifies that this is a PVFS2 error. A PVFS2 error is either an
- * encoded errno value or a PVFS2 protocol error. */
+/*
+ * Bit 30 specifies that this is a PVFS2 error. A PVFS2 error is either an
+ * encoded errno value or a PVFS2 protocol error.
+ */
 #define PVFS_ERROR_BIT (1 << 30)
 
-/* Bit 29 specifies that this is a PVFS2 protocol error and not an encoded
- * errno value. */
+/*
+ * Bit 29 specifies that this is a PVFS2 protocol error and not an encoded
+ * errno value.
+ */
 #define PVFS_NON_ERRNO_ERROR_BIT (1 << 29)
 
-/* Bits 9, 8, and 7 specify the error class, which encodes the section of
+/*
+ * Bits 9, 8, and 7 specify the error class, which encodes the section of
  * server code the error originated in for logging purposes. It is not used
- * in the kernel except to be masked out. */
+ * in the kernel except to be masked out.
+ */
 #define PVFS_ERROR_CLASS_BITS 0x380
 
 /* Bits 6 - 0 are reserved for the actual error code. */
@@ -388,14 +396,8 @@ enum {
 
 /*
  * version number for use in communicating between kernel space and user
- * space
+ * space. Zero signifies the upstream version of the kernel module.
  */
-/*
-#define PVFS_KERNEL_PROTO_VERSION			\
-		((PVFS2_VERSION_MAJOR * 10000)	+	\
-		 (PVFS2_VERSION_MINOR * 100)	+	\
-		 PVFS2_VERSION_SUB)
-*/
 #define PVFS_KERNEL_PROTO_VERSION 0
 
 /*

commit 894ac432b48bb64fabae31fd2f373b2b8659350f
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Oct 2 12:11:19 2015 -0400

    Orangefs: Clean up error decoding.
    
    Errors from the server need to be decoded. A bunch of code was imported from
    the server to do this but much of it is convoluted and not even needed. The
    result is better but still as convoluted as required by the protocol.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index cdbde64f8e39..b374c4b2009e 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -100,262 +100,40 @@ typedef __s32 PVFS_error;
 typedef __s64 PVFS_offset;
 
 #define PVFS2_SUPER_MAGIC 0x20030528
-#define PVFS_ERROR_BIT           (1 << 30)
-#define PVFS_NON_ERRNO_ERROR_BIT (1 << 29)
-#define IS_PVFS_ERROR(__error)   ((__error)&(PVFS_ERROR_BIT))
-#define IS_PVFS_NON_ERRNO_ERROR(__error)  \
-(((__error)&(PVFS_NON_ERRNO_ERROR_BIT)) && IS_PVFS_ERROR(__error))
-#define PVFS_ERROR_TO_ERRNO(__error) PVFS_get_errno_mapping(__error)
-
-/* 7 bits are used for the errno mapped error codes */
-#define PVFS_ERROR_CODE(__error) \
-((__error) & (__s32)(0x7f|PVFS_ERROR_BIT))
-#define PVFS_ERROR_CLASS(__error) \
-((__error) & ~((__s32)(0x7f|PVFS_ERROR_BIT|PVFS_NON_ERRNO_ERROR_BIT)))
-#define PVFS_NON_ERRNO_ERROR_CODE(__error) \
-((__error) & (__s32)(127|PVFS_ERROR_BIT|PVFS_NON_ERRNO_ERROR_BIT))
-
-/* PVFS2 error codes, compliments of asm/errno.h */
-#define PVFS_EPERM            E(1)	/* Operation not permitted */
-#define PVFS_ENOENT           E(2)	/* No such file or directory */
-#define PVFS_EINTR            E(3)	/* Interrupted system call */
-#define PVFS_EIO              E(4)	/* I/O error */
-#define PVFS_ENXIO            E(5)	/* No such device or address */
-#define PVFS_EBADF            E(6)	/* Bad file number */
-#define PVFS_EAGAIN           E(7)	/* Try again */
-#define PVFS_ENOMEM           E(8)	/* Out of memory */
-#define PVFS_EFAULT           E(9)	/* Bad address */
-#define PVFS_EBUSY           E(10)	/* Device or resource busy */
-#define PVFS_EEXIST          E(11)	/* File exists */
-#define PVFS_ENODEV          E(12)	/* No such device */
-#define PVFS_ENOTDIR         E(13)	/* Not a directory */
-#define PVFS_EISDIR          E(14)	/* Is a directory */
-#define PVFS_EINVAL          E(15)	/* Invalid argument */
-#define PVFS_EMFILE          E(16)	/* Too many open files */
-#define PVFS_EFBIG           E(17)	/* File too large */
-#define PVFS_ENOSPC          E(18)	/* No space left on device */
-#define PVFS_EROFS           E(19)	/* Read-only file system */
-#define PVFS_EMLINK          E(20)	/* Too many links */
-#define PVFS_EPIPE           E(21)	/* Broken pipe */
-#define PVFS_EDEADLK         E(22)	/* Resource deadlock would occur */
-#define PVFS_ENAMETOOLONG    E(23)	/* File name too long */
-#define PVFS_ENOLCK          E(24)	/* No record locks available */
-#define PVFS_ENOSYS          E(25)	/* Function not implemented */
-#define PVFS_ENOTEMPTY       E(26)	/* Directory not empty */
-					/*
-#define PVFS_ELOOP           E(27)	 * Too many symbolic links encountered
-					 */
-#define PVFS_EWOULDBLOCK     E(28)	/* Operation would block */
-#define PVFS_ENOMSG          E(29)	/* No message of desired type */
-#define PVFS_EUNATCH         E(30)	/* Protocol driver not attached */
-#define PVFS_EBADR           E(31)	/* Invalid request descriptor */
-#define PVFS_EDEADLOCK       E(32)
-#define PVFS_ENODATA         E(33)	/* No data available */
-#define PVFS_ETIME           E(34)	/* Timer expired */
-#define PVFS_ENONET          E(35)	/* Machine is not on the network */
-#define PVFS_EREMOTE         E(36)	/* Object is remote */
-#define PVFS_ECOMM           E(37)	/* Communication error on send */
-#define PVFS_EPROTO          E(38)	/* Protocol error */
-#define PVFS_EBADMSG         E(39)	/* Not a data message */
-					/*
-#define PVFS_EOVERFLOW       E(40)	 * Value too large for defined data
-					 * type
-					 */
-					/*
-#define PVFS_ERESTART        E(41)	 * Interrupted system call should be
-					 * restarted
-					 */
-#define PVFS_EMSGSIZE        E(42)	/* Message too long */
-#define PVFS_EPROTOTYPE      E(43)	/* Protocol wrong type for socket */
-#define PVFS_ENOPROTOOPT     E(44)	/* Protocol not available */
-#define PVFS_EPROTONOSUPPORT E(45)	/* Protocol not supported */
-					/*
-#define PVFS_EOPNOTSUPP      E(46)	 * Operation not supported on transport
-					 * endpoint
-					 */
-#define PVFS_EADDRINUSE      E(47)	/* Address already in use */
-#define PVFS_EADDRNOTAVAIL   E(48)	/* Cannot assign requested address */
-#define PVFS_ENETDOWN        E(49)	/* Network is down */
-#define PVFS_ENETUNREACH     E(50)	/* Network is unreachable */
-					/*
-#define PVFS_ENETRESET       E(51)	 * Network dropped connection because
-					 * of reset
-					 */
-#define PVFS_ENOBUFS         E(52)	/* No buffer space available */
-#define PVFS_ETIMEDOUT       E(53)	/* Connection timed out */
-#define PVFS_ECONNREFUSED    E(54)	/* Connection refused */
-#define PVFS_EHOSTDOWN       E(55)	/* Host is down */
-#define PVFS_EHOSTUNREACH    E(56)	/* No route to host */
-#define PVFS_EALREADY        E(57)	/* Operation already in progress */
-#define PVFS_EACCES          E(58)	/* Access not allowed */
-#define PVFS_ECONNRESET      E(59)	/* Connection reset by peer */
-#define PVFS_ERANGE          E(60)	/* Math out of range or buf too small */
-
-/***************** non-errno/pvfs2 specific error codes *****************/
-#define PVFS_ECANCEL    (1|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
-#define PVFS_EDEVINIT   (2|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
-#define PVFS_EDETAIL    (3|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
-#define PVFS_EHOSTNTFD  (4|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
-#define PVFS_EADDRNTFD  (5|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
-#define PVFS_ENORECVR   (6|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
-#define PVFS_ETRYAGAIN  (7|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
-#define PVFS_ENOTPVFS   (8|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
-#define PVFS_ESECURITY  (9|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
 
-/*
- * NOTE: PLEASE DO NOT ARBITRARILY ADD NEW ERRNO ERROR CODES!
- *
- * IF YOU CHOOSE TO ADD A NEW ERROR CODE (DESPITE OUR PLEA), YOU ALSO
- * NEED TO INCREMENT PVFS_ERRNO MAX (BELOW) AND ADD A MAPPING TO A
- * UNIX ERRNO VALUE IN THE MACROS BELOW (USED IN
- * src/common/misc/errno-mapping.c and the kernel module)
- */
-#define PVFS_ERRNO_MAX          61
-
-#define PVFS_ERROR_BMI    (1 << 7)	/* BMI-specific error */
-#define PVFS_ERROR_TROVE  (2 << 7)	/* Trove-specific error */
-#define PVFS_ERROR_FLOW   (3 << 7)
-#define PVFS_ERROR_SM     (4 << 7)	/* state machine specific error */
-#define PVFS_ERROR_SCHED  (5 << 7)
-#define PVFS_ERROR_CLIENT (6 << 7)
-#define PVFS_ERROR_DEV    (7 << 7)	/* device file interaction */
-
-#define PVFS_ERROR_CLASS_BITS	\
-	(PVFS_ERROR_BMI    |	\
-	 PVFS_ERROR_TROVE  |	\
-	 PVFS_ERROR_FLOW   |	\
-	 PVFS_ERROR_SM     |	\
-	 PVFS_ERROR_SCHED  |	\
-	 PVFS_ERROR_CLIENT |	\
-	 PVFS_ERROR_DEV)
-
-#define DECLARE_ERRNO_MAPPING()                       \
-__s32 PINT_errno_mapping[PVFS_ERRNO_MAX + 1] = { \
-	0,     /* leave this one empty */                 \
-	EPERM, /* 1 */                                    \
-	ENOENT,                                           \
-	EINTR,                                            \
-	EIO,                                              \
-	ENXIO,                                            \
-	EBADF,                                            \
-	EAGAIN,                                           \
-	ENOMEM,                                           \
-	EFAULT,                                           \
-	EBUSY, /* 10 */                                   \
-	EEXIST,                                           \
-	ENODEV,                                           \
-	ENOTDIR,                                          \
-	EISDIR,                                           \
-	EINVAL,                                           \
-	EMFILE,                                           \
-	EFBIG,                                            \
-	ENOSPC,                                           \
-	EROFS,                                            \
-	EMLINK, /* 20 */                                  \
-	EPIPE,                                            \
-	EDEADLK,                                          \
-	ENAMETOOLONG,                                     \
-	ENOLCK,                                           \
-	ENOSYS,                                           \
-	ENOTEMPTY,                                        \
-	ELOOP,                                            \
-	EWOULDBLOCK,                                      \
-	ENOMSG,                                           \
-	EUNATCH, /* 30 */                                 \
-	EBADR,                                            \
-	EDEADLOCK,                                        \
-	ENODATA,                                          \
-	ETIME,                                            \
-	ENONET,                                           \
-	EREMOTE,                                          \
-	ECOMM,                                            \
-	EPROTO,                                           \
-	EBADMSG,                                          \
-	EOVERFLOW, /* 40 */                               \
-	ERESTART,                                         \
-	EMSGSIZE,                                         \
-	EPROTOTYPE,                                       \
-	ENOPROTOOPT,                                      \
-	EPROTONOSUPPORT,                                  \
-	EOPNOTSUPP,                                       \
-	EADDRINUSE,                                       \
-	EADDRNOTAVAIL,                                    \
-	ENETDOWN,                                         \
-	ENETUNREACH, /* 50 */                             \
-	ENETRESET,                                        \
-	ENOBUFS,                                          \
-	ETIMEDOUT,                                        \
-	ECONNREFUSED,                                     \
-	EHOSTDOWN,                                        \
-	EHOSTUNREACH,                                     \
-	EALREADY,                                         \
-	EACCES,                                           \
-	ECONNRESET,   /* 59 */                            \
-	ERANGE,                                           \
-	0         /* PVFS_ERRNO_MAX */                    \
-};                                                    \
-const char *PINT_non_errno_strerror_mapping[] = {     \
-	"Success", /* 0 */                                \
-	"Operation cancelled (possibly due to timeout)",  \
-	"Device initialization failed",                   \
-	"Detailed per-server errors are available",       \
-	"Unknown host",                                   \
-	"No address associated with name",                \
-	"Unknown server error",                           \
-	"Host name lookup failure",                       \
-	"Path contains non-PVFS elements",                \
-	"Security error",                                 \
-};                                                    \
-__s32 PINT_non_errno_mapping[] = {               \
-	0,     /* leave this one empty */                 \
-	PVFS_ECANCEL,   /* 1 */                           \
-	PVFS_EDEVINIT,  /* 2 */                           \
-	PVFS_EDETAIL,   /* 3 */                           \
-	PVFS_EHOSTNTFD, /* 4 */                           \
-	PVFS_EADDRNTFD, /* 5 */                           \
-	PVFS_ENORECVR,  /* 6 */                           \
-	PVFS_ETRYAGAIN, /* 7 */                           \
-	PVFS_ENOTPVFS,  /* 8 */                           \
-	PVFS_ESECURITY, /* 9 */                           \
-}
+/* PVFS2 error codes are a signed 32-bit integer. Error codes are negative, but
+ * the sign is stripped before decoding. */
 
-/*
- *   NOTE: PVFS_get_errno_mapping will convert a PVFS_ERROR_CODE to an
- *   errno value.  If the error code is a pvfs2 specific error code
- *   (i.e. a PVFS_NON_ERRNO_ERROR_CODE), PVFS_get_errno_mapping will
- *   return an index into the PINT_non_errno_strerror_mapping array which
- *   can be used for getting the pvfs2 specific strerror message given
- *   the error code.  if the value is not a recognized error code, the
- *   passed in value will be returned unchanged.
- */
-#define DECLARE_ERRNO_MAPPING_AND_FN()					\
-extern __s32 PINT_errno_mapping[];					\
-extern __s32 PINT_non_errno_mapping[];				\
-extern const char *PINT_non_errno_strerror_mapping[];			\
-static __s32 PVFS_get_errno_mapping(__s32 error)			\
-{									\
-	__s32 ret = error, mask = 0;				\
-	__s32 positive = ((error > -1) ? 1 : 0);			\
-	if (IS_PVFS_NON_ERRNO_ERROR((positive ? error : -error))) {	\
-		mask = (PVFS_NON_ERRNO_ERROR_BIT |			\
-			PVFS_ERROR_BIT |				\
-			PVFS_ERROR_CLASS_BITS);				\
-		ret = PVFS_NON_ERRNO_ERROR_CODE(((positive ?		\
-						     error :		\
-						     abs(error))) &	\
-						 ~mask);		\
-	}								\
-	else if (IS_PVFS_ERROR((positive ? error : -error))) {		\
-		mask = (PVFS_ERROR_BIT |				\
-			PVFS_ERROR_CLASS_BITS);				\
-		ret = PINT_errno_mapping[PVFS_ERROR_CODE(((positive ?	\
-								error :	\
-								abs(error))) & \
-							  ~mask)];	\
-	}								\
-	return ret;							\
-}									\
-DECLARE_ERRNO_MAPPING()
+/* Bit 31 is not used since it is the sign. */
+
+/* Bit 30 specifies that this is a PVFS2 error. A PVFS2 error is either an
+ * encoded errno value or a PVFS2 protocol error. */
+#define PVFS_ERROR_BIT (1 << 30)
+
+/* Bit 29 specifies that this is a PVFS2 protocol error and not an encoded
+ * errno value. */
+#define PVFS_NON_ERRNO_ERROR_BIT (1 << 29)
+
+/* Bits 9, 8, and 7 specify the error class, which encodes the section of
+ * server code the error originated in for logging purposes. It is not used
+ * in the kernel except to be masked out. */
+#define PVFS_ERROR_CLASS_BITS 0x380
+
+/* Bits 6 - 0 are reserved for the actual error code. */
+#define PVFS_ERROR_NUMBER_BITS 0x7f
+
+/* Encoded errno values are decoded by PINT_errno_mapping in pvfs2-utils.c. */
+
+/* Our own PVFS2 protocol error codes. */
+#define PVFS_ECANCEL    (1|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
+#define PVFS_EDEVINIT   (2|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
+#define PVFS_EDETAIL    (3|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
+#define PVFS_EHOSTNTFD  (4|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
+#define PVFS_EADDRNTFD  (5|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
+#define PVFS_ENORECVR   (6|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
+#define PVFS_ETRYAGAIN  (7|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
+#define PVFS_ENOTPVFS   (8|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
+#define PVFS_ESECURITY  (9|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
 
 /* permission bits */
 #define PVFS_O_EXECUTE (1 << 0)

commit 50e01586f4b10dc7aa534bbfcd1707586e7b32e0
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Tue Sep 29 11:17:26 2015 -0400

    Orangefs: Don't opencode memcpy.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index c50c6e30f5a8..cdbde64f8e39 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -70,30 +70,21 @@ static inline int PVFS_khandle_cmp(const struct pvfs2_khandle *kh1,
 	return 0;
 }
 
-/* copy a khandle to a field of arbitrary size */
 static inline void PVFS_khandle_to(const struct pvfs2_khandle *kh,
 				   void *p, int size)
 {
-	int i;
-	unsigned char *c = p;
 
 	memset(p, 0, size);
+	memcpy(p, kh->u, 16);
 
-	for (i = 0; i < 16 && i < size; i++)
-		c[i] = kh->u[i];
 }
 
-/* copy a khandle from a field of arbitrary size */
 static inline void PVFS_khandle_from(struct pvfs2_khandle *kh,
 				     void *p, int size)
 {
-	int i;
-	unsigned char *c = p;
-
 	memset(kh, 0, 16);
+	memcpy(kh->u, p, 16);
 
-	for (i = 0; i < 16 && i < size; i++)
-		kh->u[i] = c[i];
 }
 
 /* pvfs2-types.h ************************************************************/

commit d6fe654b7b580720fee632c8d526c6a159111d50
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Thu Sep 24 12:38:38 2015 -0400

    Orangefs: put PVFS_util_min out of its misery.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index cae9cc0f9d18..c50c6e30f5a8 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -572,7 +572,6 @@ struct dev_mask2_info_s {
 };
 
 /* pvfs2-util.h *************************************************************/
-#define PVFS_util_min(x1, x2) (((x1) > (x2)) ? (x2) : (x1))
 __s32 PVFS_util_translate_mode(int mode);
 
 /* pvfs2-debug.h ************************************************************/

commit 88309aae3ddb62e6d02a8f1002a4f4fc41b423ad
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Sep 23 16:48:40 2015 -0400

    Orangefs: fix dir_emit code in pvfs2_readdir.
    
    Al Viro glanced at readdir and surmised that getdents
    would misbehave the way it was written... and sure enough.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index f571be21f66a..cae9cc0f9d18 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -384,6 +384,7 @@ DECLARE_ERRNO_MAPPING()
 #define INT32_MAX (2147483647)
 #define PVFS_ITERATE_START    (INT32_MAX - 1)
 #define PVFS_ITERATE_END      (INT32_MAX - 2)
+#define PVFS_ITERATE_NEXT     (INT32_MAX - 3)
 #define PVFS_READDIR_START PVFS_ITERATE_START
 #define PVFS_READDIR_END   PVFS_ITERATE_END
 #define PVFS_IMMUTABLE_FL FS_IMMUTABLE_FL

commit 81b784b11ea65c5c591f4d963daed2111a1b4280
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sat Aug 1 18:29:37 2015 -0700

    Orangefs: Swap order of include files
    
    spinlock_types.h requires types from linux/types.h.
    Including spinlock_types.h first may result in the following build errors,
    as seen with arm:allmodconfig.
    
    arch/arm/include/asm/spinlock_types.h:12:3: error: unknown type name 'u32'
    arch/arm/include/asm/spinlock_types.h:16:4: error: unknown type name 'u16'
    
    Fixes: deb4fb58ff73 ("Orangefs: kernel client part 2")
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Mike Marshall <hubcap@omnibond.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index ca7cef9590d3..f571be21f66a 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -1,5 +1,5 @@
-#include <linux/spinlock_types.h>
 #include <linux/types.h>
+#include <linux/spinlock_types.h>
 #include <linux/slab.h>
 #include <linux/ioctl.h>
 

commit 84d02150dea7571dc32176e35d65eecde82631a9
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Tue Jul 28 13:27:51 2015 -0400

    Orangefs: sooth most sparse complaints
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index 8e0c8a6158f7..ca7cef9590d3 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -341,7 +341,7 @@ __s32 PINT_non_errno_mapping[] = {               \
 extern __s32 PINT_errno_mapping[];					\
 extern __s32 PINT_non_errno_mapping[];				\
 extern const char *PINT_non_errno_strerror_mapping[];			\
-__s32 PVFS_get_errno_mapping(__s32 error)			\
+static __s32 PVFS_get_errno_mapping(__s32 error)			\
 {									\
 	__s32 ret = error, mask = 0;				\
 	__s32 positive = ((error > -1) ? 1 : 0);			\
@@ -364,16 +364,6 @@ __s32 PVFS_get_errno_mapping(__s32 error)			\
 	}								\
 	return ret;							\
 }									\
-__s32 PVFS_errno_to_error(int err)					\
-{									\
-	__s32 e = 0;						\
-									\
-	for (; e < PVFS_ERRNO_MAX; ++e)					\
-		if (PINT_errno_mapping[e] == err)			\
-			return e | PVFS_ERROR_BIT;			\
-									\
-	return err;							\
-}									\
 DECLARE_ERRNO_MAPPING()
 
 /* permission bits */

commit 2c590d5fb6987e6579a82285b742a318cc1fdb50
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Jul 24 10:37:15 2015 -0400

    Orangefs: kernel client update 1.
    
    Stephen Rothwell noticed that orangefs would not compile
    on powerpc...
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index 2fb3a63ae9ab..8e0c8a6158f7 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -1,6 +1,7 @@
 #include <linux/spinlock_types.h>
 #include <linux/types.h>
 #include <linux/slab.h>
+#include <linux/ioctl.h>
 
 extern struct client_debug_mask *cdm_array;
 extern char *debug_help_string;

commit f7ab093f74bf638ed98fd1115f3efa17e308bb7f
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Jul 17 10:38:11 2015 -0400

    Orangefs: kernel client part 1
    
    OrangeFS (formerly PVFS) is an lgpl licensed userspace networked parallel
    file system. OrangeFS can be accessed through included system utilities,
    user integration libraries, MPI-IO and can be used by the Hadoop
    ecosystem as an alternative to the HDFS filesystem. OrangeFS is used
    widely for parallel science, data analytics and engineering applications.
    
    While applications often don't require Orangefs to be mounted into
    the VFS, users do like to be able to access their files in the normal way.
    The Orangefs kernel client allows Orangefs filesystems to be mounted as
    a VFS. The kernel client communicates with a userspace daemon which in
    turn communicates with the Orangefs server daemons that implement the
    filesystem. The server daemons (there's almost always more than one)
    need not be running on the same host as the kernel client.
    
    Orangefs filesystems can also be mounted with FUSE, and we
    ship code and instructions to facilitate that, but most of our users
    report preferring to use our kernel module instead. Further, as an example
    of a problem we can't solve with fuse, we have in the works a
    not-yet-ready-for-prime-time version of a file_operations lock function
    that accounts for the server daemons being distributed across more
    than one running kernel.
    
    Many people and organizations, including Clemson University,
    Argonne National Laboratories and Acxiom Corporation have
    helped to create what has become Orangefs over more than twenty
    years. Some of the more recent contributors to the kernel client
    include:
    
      Mike Marshall
      Christoph Hellwig
      Randy Martin
      Becky Ligon
      Walt Ligon
      Michael Moore
      Rob Ross
      Phil Carnes
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
new file mode 100644
index 000000000000..2fb3a63ae9ab
--- /dev/null
+++ b/fs/orangefs/protocol.h
@@ -0,0 +1,681 @@
+#include <linux/spinlock_types.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+
+extern struct client_debug_mask *cdm_array;
+extern char *debug_help_string;
+extern int help_string_initialized;
+extern struct dentry *debug_dir;
+extern struct dentry *help_file_dentry;
+extern struct dentry *client_debug_dentry;
+extern const struct file_operations debug_help_fops;
+extern int client_all_index;
+extern int client_verbose_index;
+extern int cdm_element_count;
+#define DEBUG_HELP_STRING_SIZE 4096
+#define HELP_STRING_UNINITIALIZED \
+	"Client Debug Keywords are unknown until the first time\n" \
+	"the client is started after boot.\n"
+#define ORANGEFS_KMOD_DEBUG_HELP_FILE "debug-help"
+#define ORANGEFS_KMOD_DEBUG_FILE "kernel-debug"
+#define ORANGEFS_CLIENT_DEBUG_FILE "client-debug"
+#define PVFS2_VERBOSE "verbose"
+#define PVFS2_ALL "all"
+
+/* pvfs2-config.h ***********************************************************/
+#define PVFS2_VERSION_MAJOR 2
+#define PVFS2_VERSION_MINOR 9
+#define PVFS2_VERSION_SUB 0
+
+/* khandle stuff  ***********************************************************/
+
+/*
+ * The 2.9 core will put 64 bit handles in here like this:
+ *    1234 0000 0000 5678
+ * The 3.0 and beyond cores will put 128 bit handles in here like this:
+ *    1234 5678 90AB CDEF
+ * The kernel module will always use the first four bytes and
+ * the last four bytes as an inum.
+ */
+struct pvfs2_khandle {
+	unsigned char u[16];
+}  __aligned(8);
+
+/*
+ * kernel version of an object ref.
+ */
+struct pvfs2_object_kref {
+	struct pvfs2_khandle khandle;
+	__s32 fs_id;
+	__s32 __pad1;
+};
+
+/*
+ * compare 2 khandles assumes little endian thus from large address to
+ * small address
+ */
+static inline int PVFS_khandle_cmp(const struct pvfs2_khandle *kh1,
+				   const struct pvfs2_khandle *kh2)
+{
+	int i;
+
+	for (i = 15; i >= 0; i--) {
+		if (kh1->u[i] > kh2->u[i])
+			return 1;
+		if (kh1->u[i] < kh2->u[i])
+			return -1;
+	}
+
+	return 0;
+}
+
+/* copy a khandle to a field of arbitrary size */
+static inline void PVFS_khandle_to(const struct pvfs2_khandle *kh,
+				   void *p, int size)
+{
+	int i;
+	unsigned char *c = p;
+
+	memset(p, 0, size);
+
+	for (i = 0; i < 16 && i < size; i++)
+		c[i] = kh->u[i];
+}
+
+/* copy a khandle from a field of arbitrary size */
+static inline void PVFS_khandle_from(struct pvfs2_khandle *kh,
+				     void *p, int size)
+{
+	int i;
+	unsigned char *c = p;
+
+	memset(kh, 0, 16);
+
+	for (i = 0; i < 16 && i < size; i++)
+		kh->u[i] = c[i];
+}
+
+/* pvfs2-types.h ************************************************************/
+typedef __u32 PVFS_uid;
+typedef __u32 PVFS_gid;
+typedef __s32 PVFS_fs_id;
+typedef __u32 PVFS_permissions;
+typedef __u64 PVFS_time;
+typedef __s64 PVFS_size;
+typedef __u64 PVFS_flags;
+typedef __u64 PVFS_ds_position;
+typedef __s32 PVFS_error;
+typedef __s64 PVFS_offset;
+
+#define PVFS2_SUPER_MAGIC 0x20030528
+#define PVFS_ERROR_BIT           (1 << 30)
+#define PVFS_NON_ERRNO_ERROR_BIT (1 << 29)
+#define IS_PVFS_ERROR(__error)   ((__error)&(PVFS_ERROR_BIT))
+#define IS_PVFS_NON_ERRNO_ERROR(__error)  \
+(((__error)&(PVFS_NON_ERRNO_ERROR_BIT)) && IS_PVFS_ERROR(__error))
+#define PVFS_ERROR_TO_ERRNO(__error) PVFS_get_errno_mapping(__error)
+
+/* 7 bits are used for the errno mapped error codes */
+#define PVFS_ERROR_CODE(__error) \
+((__error) & (__s32)(0x7f|PVFS_ERROR_BIT))
+#define PVFS_ERROR_CLASS(__error) \
+((__error) & ~((__s32)(0x7f|PVFS_ERROR_BIT|PVFS_NON_ERRNO_ERROR_BIT)))
+#define PVFS_NON_ERRNO_ERROR_CODE(__error) \
+((__error) & (__s32)(127|PVFS_ERROR_BIT|PVFS_NON_ERRNO_ERROR_BIT))
+
+/* PVFS2 error codes, compliments of asm/errno.h */
+#define PVFS_EPERM            E(1)	/* Operation not permitted */
+#define PVFS_ENOENT           E(2)	/* No such file or directory */
+#define PVFS_EINTR            E(3)	/* Interrupted system call */
+#define PVFS_EIO              E(4)	/* I/O error */
+#define PVFS_ENXIO            E(5)	/* No such device or address */
+#define PVFS_EBADF            E(6)	/* Bad file number */
+#define PVFS_EAGAIN           E(7)	/* Try again */
+#define PVFS_ENOMEM           E(8)	/* Out of memory */
+#define PVFS_EFAULT           E(9)	/* Bad address */
+#define PVFS_EBUSY           E(10)	/* Device or resource busy */
+#define PVFS_EEXIST          E(11)	/* File exists */
+#define PVFS_ENODEV          E(12)	/* No such device */
+#define PVFS_ENOTDIR         E(13)	/* Not a directory */
+#define PVFS_EISDIR          E(14)	/* Is a directory */
+#define PVFS_EINVAL          E(15)	/* Invalid argument */
+#define PVFS_EMFILE          E(16)	/* Too many open files */
+#define PVFS_EFBIG           E(17)	/* File too large */
+#define PVFS_ENOSPC          E(18)	/* No space left on device */
+#define PVFS_EROFS           E(19)	/* Read-only file system */
+#define PVFS_EMLINK          E(20)	/* Too many links */
+#define PVFS_EPIPE           E(21)	/* Broken pipe */
+#define PVFS_EDEADLK         E(22)	/* Resource deadlock would occur */
+#define PVFS_ENAMETOOLONG    E(23)	/* File name too long */
+#define PVFS_ENOLCK          E(24)	/* No record locks available */
+#define PVFS_ENOSYS          E(25)	/* Function not implemented */
+#define PVFS_ENOTEMPTY       E(26)	/* Directory not empty */
+					/*
+#define PVFS_ELOOP           E(27)	 * Too many symbolic links encountered
+					 */
+#define PVFS_EWOULDBLOCK     E(28)	/* Operation would block */
+#define PVFS_ENOMSG          E(29)	/* No message of desired type */
+#define PVFS_EUNATCH         E(30)	/* Protocol driver not attached */
+#define PVFS_EBADR           E(31)	/* Invalid request descriptor */
+#define PVFS_EDEADLOCK       E(32)
+#define PVFS_ENODATA         E(33)	/* No data available */
+#define PVFS_ETIME           E(34)	/* Timer expired */
+#define PVFS_ENONET          E(35)	/* Machine is not on the network */
+#define PVFS_EREMOTE         E(36)	/* Object is remote */
+#define PVFS_ECOMM           E(37)	/* Communication error on send */
+#define PVFS_EPROTO          E(38)	/* Protocol error */
+#define PVFS_EBADMSG         E(39)	/* Not a data message */
+					/*
+#define PVFS_EOVERFLOW       E(40)	 * Value too large for defined data
+					 * type
+					 */
+					/*
+#define PVFS_ERESTART        E(41)	 * Interrupted system call should be
+					 * restarted
+					 */
+#define PVFS_EMSGSIZE        E(42)	/* Message too long */
+#define PVFS_EPROTOTYPE      E(43)	/* Protocol wrong type for socket */
+#define PVFS_ENOPROTOOPT     E(44)	/* Protocol not available */
+#define PVFS_EPROTONOSUPPORT E(45)	/* Protocol not supported */
+					/*
+#define PVFS_EOPNOTSUPP      E(46)	 * Operation not supported on transport
+					 * endpoint
+					 */
+#define PVFS_EADDRINUSE      E(47)	/* Address already in use */
+#define PVFS_EADDRNOTAVAIL   E(48)	/* Cannot assign requested address */
+#define PVFS_ENETDOWN        E(49)	/* Network is down */
+#define PVFS_ENETUNREACH     E(50)	/* Network is unreachable */
+					/*
+#define PVFS_ENETRESET       E(51)	 * Network dropped connection because
+					 * of reset
+					 */
+#define PVFS_ENOBUFS         E(52)	/* No buffer space available */
+#define PVFS_ETIMEDOUT       E(53)	/* Connection timed out */
+#define PVFS_ECONNREFUSED    E(54)	/* Connection refused */
+#define PVFS_EHOSTDOWN       E(55)	/* Host is down */
+#define PVFS_EHOSTUNREACH    E(56)	/* No route to host */
+#define PVFS_EALREADY        E(57)	/* Operation already in progress */
+#define PVFS_EACCES          E(58)	/* Access not allowed */
+#define PVFS_ECONNRESET      E(59)	/* Connection reset by peer */
+#define PVFS_ERANGE          E(60)	/* Math out of range or buf too small */
+
+/***************** non-errno/pvfs2 specific error codes *****************/
+#define PVFS_ECANCEL    (1|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
+#define PVFS_EDEVINIT   (2|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
+#define PVFS_EDETAIL    (3|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
+#define PVFS_EHOSTNTFD  (4|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
+#define PVFS_EADDRNTFD  (5|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
+#define PVFS_ENORECVR   (6|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
+#define PVFS_ETRYAGAIN  (7|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
+#define PVFS_ENOTPVFS   (8|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
+#define PVFS_ESECURITY  (9|(PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT))
+
+/*
+ * NOTE: PLEASE DO NOT ARBITRARILY ADD NEW ERRNO ERROR CODES!
+ *
+ * IF YOU CHOOSE TO ADD A NEW ERROR CODE (DESPITE OUR PLEA), YOU ALSO
+ * NEED TO INCREMENT PVFS_ERRNO MAX (BELOW) AND ADD A MAPPING TO A
+ * UNIX ERRNO VALUE IN THE MACROS BELOW (USED IN
+ * src/common/misc/errno-mapping.c and the kernel module)
+ */
+#define PVFS_ERRNO_MAX          61
+
+#define PVFS_ERROR_BMI    (1 << 7)	/* BMI-specific error */
+#define PVFS_ERROR_TROVE  (2 << 7)	/* Trove-specific error */
+#define PVFS_ERROR_FLOW   (3 << 7)
+#define PVFS_ERROR_SM     (4 << 7)	/* state machine specific error */
+#define PVFS_ERROR_SCHED  (5 << 7)
+#define PVFS_ERROR_CLIENT (6 << 7)
+#define PVFS_ERROR_DEV    (7 << 7)	/* device file interaction */
+
+#define PVFS_ERROR_CLASS_BITS	\
+	(PVFS_ERROR_BMI    |	\
+	 PVFS_ERROR_TROVE  |	\
+	 PVFS_ERROR_FLOW   |	\
+	 PVFS_ERROR_SM     |	\
+	 PVFS_ERROR_SCHED  |	\
+	 PVFS_ERROR_CLIENT |	\
+	 PVFS_ERROR_DEV)
+
+#define DECLARE_ERRNO_MAPPING()                       \
+__s32 PINT_errno_mapping[PVFS_ERRNO_MAX + 1] = { \
+	0,     /* leave this one empty */                 \
+	EPERM, /* 1 */                                    \
+	ENOENT,                                           \
+	EINTR,                                            \
+	EIO,                                              \
+	ENXIO,                                            \
+	EBADF,                                            \
+	EAGAIN,                                           \
+	ENOMEM,                                           \
+	EFAULT,                                           \
+	EBUSY, /* 10 */                                   \
+	EEXIST,                                           \
+	ENODEV,                                           \
+	ENOTDIR,                                          \
+	EISDIR,                                           \
+	EINVAL,                                           \
+	EMFILE,                                           \
+	EFBIG,                                            \
+	ENOSPC,                                           \
+	EROFS,                                            \
+	EMLINK, /* 20 */                                  \
+	EPIPE,                                            \
+	EDEADLK,                                          \
+	ENAMETOOLONG,                                     \
+	ENOLCK,                                           \
+	ENOSYS,                                           \
+	ENOTEMPTY,                                        \
+	ELOOP,                                            \
+	EWOULDBLOCK,                                      \
+	ENOMSG,                                           \
+	EUNATCH, /* 30 */                                 \
+	EBADR,                                            \
+	EDEADLOCK,                                        \
+	ENODATA,                                          \
+	ETIME,                                            \
+	ENONET,                                           \
+	EREMOTE,                                          \
+	ECOMM,                                            \
+	EPROTO,                                           \
+	EBADMSG,                                          \
+	EOVERFLOW, /* 40 */                               \
+	ERESTART,                                         \
+	EMSGSIZE,                                         \
+	EPROTOTYPE,                                       \
+	ENOPROTOOPT,                                      \
+	EPROTONOSUPPORT,                                  \
+	EOPNOTSUPP,                                       \
+	EADDRINUSE,                                       \
+	EADDRNOTAVAIL,                                    \
+	ENETDOWN,                                         \
+	ENETUNREACH, /* 50 */                             \
+	ENETRESET,                                        \
+	ENOBUFS,                                          \
+	ETIMEDOUT,                                        \
+	ECONNREFUSED,                                     \
+	EHOSTDOWN,                                        \
+	EHOSTUNREACH,                                     \
+	EALREADY,                                         \
+	EACCES,                                           \
+	ECONNRESET,   /* 59 */                            \
+	ERANGE,                                           \
+	0         /* PVFS_ERRNO_MAX */                    \
+};                                                    \
+const char *PINT_non_errno_strerror_mapping[] = {     \
+	"Success", /* 0 */                                \
+	"Operation cancelled (possibly due to timeout)",  \
+	"Device initialization failed",                   \
+	"Detailed per-server errors are available",       \
+	"Unknown host",                                   \
+	"No address associated with name",                \
+	"Unknown server error",                           \
+	"Host name lookup failure",                       \
+	"Path contains non-PVFS elements",                \
+	"Security error",                                 \
+};                                                    \
+__s32 PINT_non_errno_mapping[] = {               \
+	0,     /* leave this one empty */                 \
+	PVFS_ECANCEL,   /* 1 */                           \
+	PVFS_EDEVINIT,  /* 2 */                           \
+	PVFS_EDETAIL,   /* 3 */                           \
+	PVFS_EHOSTNTFD, /* 4 */                           \
+	PVFS_EADDRNTFD, /* 5 */                           \
+	PVFS_ENORECVR,  /* 6 */                           \
+	PVFS_ETRYAGAIN, /* 7 */                           \
+	PVFS_ENOTPVFS,  /* 8 */                           \
+	PVFS_ESECURITY, /* 9 */                           \
+}
+
+/*
+ *   NOTE: PVFS_get_errno_mapping will convert a PVFS_ERROR_CODE to an
+ *   errno value.  If the error code is a pvfs2 specific error code
+ *   (i.e. a PVFS_NON_ERRNO_ERROR_CODE), PVFS_get_errno_mapping will
+ *   return an index into the PINT_non_errno_strerror_mapping array which
+ *   can be used for getting the pvfs2 specific strerror message given
+ *   the error code.  if the value is not a recognized error code, the
+ *   passed in value will be returned unchanged.
+ */
+#define DECLARE_ERRNO_MAPPING_AND_FN()					\
+extern __s32 PINT_errno_mapping[];					\
+extern __s32 PINT_non_errno_mapping[];				\
+extern const char *PINT_non_errno_strerror_mapping[];			\
+__s32 PVFS_get_errno_mapping(__s32 error)			\
+{									\
+	__s32 ret = error, mask = 0;				\
+	__s32 positive = ((error > -1) ? 1 : 0);			\
+	if (IS_PVFS_NON_ERRNO_ERROR((positive ? error : -error))) {	\
+		mask = (PVFS_NON_ERRNO_ERROR_BIT |			\
+			PVFS_ERROR_BIT |				\
+			PVFS_ERROR_CLASS_BITS);				\
+		ret = PVFS_NON_ERRNO_ERROR_CODE(((positive ?		\
+						     error :		\
+						     abs(error))) &	\
+						 ~mask);		\
+	}								\
+	else if (IS_PVFS_ERROR((positive ? error : -error))) {		\
+		mask = (PVFS_ERROR_BIT |				\
+			PVFS_ERROR_CLASS_BITS);				\
+		ret = PINT_errno_mapping[PVFS_ERROR_CODE(((positive ?	\
+								error :	\
+								abs(error))) & \
+							  ~mask)];	\
+	}								\
+	return ret;							\
+}									\
+__s32 PVFS_errno_to_error(int err)					\
+{									\
+	__s32 e = 0;						\
+									\
+	for (; e < PVFS_ERRNO_MAX; ++e)					\
+		if (PINT_errno_mapping[e] == err)			\
+			return e | PVFS_ERROR_BIT;			\
+									\
+	return err;							\
+}									\
+DECLARE_ERRNO_MAPPING()
+
+/* permission bits */
+#define PVFS_O_EXECUTE (1 << 0)
+#define PVFS_O_WRITE   (1 << 1)
+#define PVFS_O_READ    (1 << 2)
+#define PVFS_G_EXECUTE (1 << 3)
+#define PVFS_G_WRITE   (1 << 4)
+#define PVFS_G_READ    (1 << 5)
+#define PVFS_U_EXECUTE (1 << 6)
+#define PVFS_U_WRITE   (1 << 7)
+#define PVFS_U_READ    (1 << 8)
+/* no PVFS_U_VTX (sticky bit) */
+#define PVFS_G_SGID    (1 << 10)
+#define PVFS_U_SUID    (1 << 11)
+
+/* definition taken from stdint.h */
+#define INT32_MAX (2147483647)
+#define PVFS_ITERATE_START    (INT32_MAX - 1)
+#define PVFS_ITERATE_END      (INT32_MAX - 2)
+#define PVFS_READDIR_START PVFS_ITERATE_START
+#define PVFS_READDIR_END   PVFS_ITERATE_END
+#define PVFS_IMMUTABLE_FL FS_IMMUTABLE_FL
+#define PVFS_APPEND_FL    FS_APPEND_FL
+#define PVFS_NOATIME_FL   FS_NOATIME_FL
+#define PVFS_MIRROR_FL    0x01000000ULL
+#define PVFS_O_EXECUTE (1 << 0)
+#define PVFS_FS_ID_NULL       ((__s32)0)
+#define PVFS_ATTR_SYS_UID                   (1 << 0)
+#define PVFS_ATTR_SYS_GID                   (1 << 1)
+#define PVFS_ATTR_SYS_PERM                  (1 << 2)
+#define PVFS_ATTR_SYS_ATIME                 (1 << 3)
+#define PVFS_ATTR_SYS_CTIME                 (1 << 4)
+#define PVFS_ATTR_SYS_MTIME                 (1 << 5)
+#define PVFS_ATTR_SYS_TYPE                  (1 << 6)
+#define PVFS_ATTR_SYS_ATIME_SET             (1 << 7)
+#define PVFS_ATTR_SYS_MTIME_SET             (1 << 8)
+#define PVFS_ATTR_SYS_SIZE                  (1 << 20)
+#define PVFS_ATTR_SYS_LNK_TARGET            (1 << 24)
+#define PVFS_ATTR_SYS_DFILE_COUNT           (1 << 25)
+#define PVFS_ATTR_SYS_DIRENT_COUNT          (1 << 26)
+#define PVFS_ATTR_SYS_BLKSIZE               (1 << 28)
+#define PVFS_ATTR_SYS_MIRROR_COPIES_COUNT   (1 << 29)
+#define PVFS_ATTR_SYS_COMMON_ALL	\
+	(PVFS_ATTR_SYS_UID	|	\
+	 PVFS_ATTR_SYS_GID	|	\
+	 PVFS_ATTR_SYS_PERM	|	\
+	 PVFS_ATTR_SYS_ATIME	|	\
+	 PVFS_ATTR_SYS_CTIME	|	\
+	 PVFS_ATTR_SYS_MTIME	|	\
+	 PVFS_ATTR_SYS_TYPE)
+
+#define PVFS_ATTR_SYS_ALL_SETABLE		\
+(PVFS_ATTR_SYS_COMMON_ALL-PVFS_ATTR_SYS_TYPE)
+
+#define PVFS_ATTR_SYS_ALL_NOHINT			\
+	(PVFS_ATTR_SYS_COMMON_ALL		|	\
+	 PVFS_ATTR_SYS_SIZE			|	\
+	 PVFS_ATTR_SYS_LNK_TARGET		|	\
+	 PVFS_ATTR_SYS_DFILE_COUNT		|	\
+	 PVFS_ATTR_SYS_MIRROR_COPIES_COUNT	|	\
+	 PVFS_ATTR_SYS_DIRENT_COUNT		|	\
+	 PVFS_ATTR_SYS_BLKSIZE)
+#define PVFS_XATTR_REPLACE 0x2
+#define PVFS_XATTR_CREATE  0x1
+#define PVFS_MAX_SERVER_ADDR_LEN 256
+#define PVFS_NAME_MAX            256
+/*
+ * max extended attribute name len as imposed by the VFS and exploited for the
+ * upcall request types.
+ * NOTE: Please retain them as multiples of 8 even if you wish to change them
+ * This is *NECESSARY* for supporting 32 bit user-space binaries on a 64-bit
+ * kernel. Due to implementation within DBPF, this really needs to be
+ * PVFS_NAME_MAX, which it was the same value as, but no reason to let it
+ * break if that changes in the future.
+ */
+#define PVFS_MAX_XATTR_NAMELEN   PVFS_NAME_MAX	/* Not the same as
+						 * XATTR_NAME_MAX defined
+						 * by <linux/xattr.h>
+						 */
+#define PVFS_MAX_XATTR_VALUELEN  8192	/* Not the same as XATTR_SIZE_MAX
+					 * defined by <linux/xattr.h>
+					 */
+#define PVFS_MAX_XATTR_LISTLEN   16	/* Not the same as XATTR_LIST_MAX
+					 * defined by <linux/xattr.h>
+					 */
+/*
+ * PVFS I/O operation types, used in both system and server interfaces.
+ */
+enum PVFS_io_type {
+	PVFS_IO_READ = 1,
+	PVFS_IO_WRITE = 2
+};
+
+/*
+ * If this enum is modified the server parameters related to the precreate pool
+ * batch and low threshold sizes may need to be modified  to reflect this
+ * change.
+ */
+enum pvfs2_ds_type {
+	PVFS_TYPE_NONE = 0,
+	PVFS_TYPE_METAFILE = (1 << 0),
+	PVFS_TYPE_DATAFILE = (1 << 1),
+	PVFS_TYPE_DIRECTORY = (1 << 2),
+	PVFS_TYPE_SYMLINK = (1 << 3),
+	PVFS_TYPE_DIRDATA = (1 << 4),
+	PVFS_TYPE_INTERNAL = (1 << 5)	/* for the server's private use */
+};
+
+/*
+ * PVFS_certificate simply stores a buffer with the buffer size.
+ * The buffer can be converted to an OpenSSL X509 struct for use.
+ */
+struct PVFS_certificate {
+	__u32 buf_size;
+	unsigned char *buf;
+};
+
+/*
+ * A credential identifies a user and is signed by the client/user
+ * private key.
+ */
+struct PVFS_credential {
+	__u32 userid;	/* user id */
+	__u32 num_groups;	/* length of group_array */
+	__u32 *group_array;	/* groups for which the user is a member */
+	char *issuer;		/* alias of the issuing server */
+	__u64 timeout;	/* seconds after epoch to time out */
+	__u32 sig_size;	/* length of the signature in bytes */
+	unsigned char *signature;	/* digital signature */
+	struct PVFS_certificate certificate;	/* user certificate buffer */
+};
+#define extra_size_PVFS_credential (PVFS_REQ_LIMIT_GROUPS	*	\
+				    sizeof(__u32)		+	\
+				    PVFS_REQ_LIMIT_ISSUER	+	\
+				    PVFS_REQ_LIMIT_SIGNATURE	+	\
+				    extra_size_PVFS_certificate)
+
+/* This structure is used by the VFS-client interaction alone */
+struct PVFS_keyval_pair {
+	char key[PVFS_MAX_XATTR_NAMELEN];
+	__s32 key_sz;	/* __s32 for portable, fixed-size structures */
+	__s32 val_sz;
+	char val[PVFS_MAX_XATTR_VALUELEN];
+};
+
+/* pvfs2-sysint.h ***********************************************************/
+/* Describes attributes for a file, directory, or symlink. */
+struct PVFS_sys_attr_s {
+	__u32 owner;
+	__u32 group;
+	__u32 perms;
+	__u64 atime;
+	__u64 mtime;
+	__u64 ctime;
+	__s64 size;
+
+	/* NOTE: caller must free if valid */
+	char *link_target;
+
+	/* Changed to __s32 so that size of structure does not change */
+	__s32 dfile_count;
+
+	/* Changed to __s32 so that size of structure does not change */
+	__s32 distr_dir_servers_initial;
+
+	/* Changed to __s32 so that size of structure does not change */
+	__s32 distr_dir_servers_max;
+
+	/* Changed to __s32 so that size of structure does not change */
+	__s32 distr_dir_split_size;
+
+	__u32 mirror_copies_count;
+
+	/* NOTE: caller must free if valid */
+	char *dist_name;
+
+	/* NOTE: caller must free if valid */
+	char *dist_params;
+
+	__s64 dirent_count;
+	enum pvfs2_ds_type objtype;
+	__u64 flags;
+	__u32 mask;
+	__s64 blksize;
+};
+
+#define PVFS2_LOOKUP_LINK_NO_FOLLOW 0
+#define PVFS2_LOOKUP_LINK_FOLLOW    1
+
+/* pint-dev.h ***************************************************************/
+
+/* parameter structure used in PVFS_DEV_DEBUG ioctl command */
+struct dev_mask_info_s {
+	enum {
+		KERNEL_MASK,
+		CLIENT_MASK,
+	} mask_type;
+	__u64 mask_value;
+};
+
+struct dev_mask2_info_s {
+	__u64 mask1_value;
+	__u64 mask2_value;
+};
+
+/* pvfs2-util.h *************************************************************/
+#define PVFS_util_min(x1, x2) (((x1) > (x2)) ? (x2) : (x1))
+__s32 PVFS_util_translate_mode(int mode);
+
+/* pvfs2-debug.h ************************************************************/
+#include "pvfs2-debug.h"
+
+/* pvfs2-internal.h *********************************************************/
+#define llu(x) (unsigned long long)(x)
+#define lld(x) (long long)(x)
+
+/* pint-dev-shared.h ********************************************************/
+#define PVFS_DEV_MAGIC 'k'
+
+#define PVFS2_READDIR_DEFAULT_DESC_COUNT  5
+
+#define DEV_GET_MAGIC           0x1
+#define DEV_GET_MAX_UPSIZE      0x2
+#define DEV_GET_MAX_DOWNSIZE    0x3
+#define DEV_MAP                 0x4
+#define DEV_REMOUNT_ALL         0x5
+#define DEV_DEBUG               0x6
+#define DEV_UPSTREAM            0x7
+#define DEV_CLIENT_MASK         0x8
+#define DEV_CLIENT_STRING       0x9
+#define DEV_MAX_NR              0xa
+
+/* supported ioctls, codes are with respect to user-space */
+enum {
+	PVFS_DEV_GET_MAGIC = _IOW(PVFS_DEV_MAGIC, DEV_GET_MAGIC, __s32),
+	PVFS_DEV_GET_MAX_UPSIZE =
+	    _IOW(PVFS_DEV_MAGIC, DEV_GET_MAX_UPSIZE, __s32),
+	PVFS_DEV_GET_MAX_DOWNSIZE =
+	    _IOW(PVFS_DEV_MAGIC, DEV_GET_MAX_DOWNSIZE, __s32),
+	PVFS_DEV_MAP = _IO(PVFS_DEV_MAGIC, DEV_MAP),
+	PVFS_DEV_REMOUNT_ALL = _IO(PVFS_DEV_MAGIC, DEV_REMOUNT_ALL),
+	PVFS_DEV_DEBUG = _IOR(PVFS_DEV_MAGIC, DEV_DEBUG, __s32),
+	PVFS_DEV_UPSTREAM = _IOW(PVFS_DEV_MAGIC, DEV_UPSTREAM, int),
+	PVFS_DEV_CLIENT_MASK = _IOW(PVFS_DEV_MAGIC,
+				    DEV_CLIENT_MASK,
+				    struct dev_mask2_info_s),
+	PVFS_DEV_CLIENT_STRING = _IOW(PVFS_DEV_MAGIC,
+				      DEV_CLIENT_STRING,
+				      char *),
+	PVFS_DEV_MAXNR = DEV_MAX_NR,
+};
+
+/*
+ * version number for use in communicating between kernel space and user
+ * space
+ */
+/*
+#define PVFS_KERNEL_PROTO_VERSION			\
+		((PVFS2_VERSION_MAJOR * 10000)	+	\
+		 (PVFS2_VERSION_MINOR * 100)	+	\
+		 PVFS2_VERSION_SUB)
+*/
+#define PVFS_KERNEL_PROTO_VERSION 0
+
+/*
+ * describes memory regions to map in the PVFS_DEV_MAP ioctl.
+ * NOTE: See devpvfs2-req.c for 32 bit compat structure.
+ * Since this structure has a variable-sized layout that is different
+ * on 32 and 64 bit platforms, we need to normalize to a 64 bit layout
+ * on such systems before servicing ioctl calls from user-space binaries
+ * that may be 32 bit!
+ */
+struct PVFS_dev_map_desc {
+	void *ptr;
+	__s32 total_size;
+	__s32 size;
+	__s32 count;
+};
+
+/* gossip.h *****************************************************************/
+
+#ifdef GOSSIP_DISABLE_DEBUG
+#define gossip_debug(mask, format, f...) do {} while (0)
+#else
+extern __u64 gossip_debug_mask;
+extern struct client_debug_mask client_debug_mask;
+
+/* try to avoid function call overhead by checking masks in macro */
+#define gossip_debug(mask, format, f...)			\
+do {								\
+	if (gossip_debug_mask & mask)				\
+		printk(format, ##f);				\
+} while (0)
+#endif /* GOSSIP_DISABLE_DEBUG */
+
+/* do file and line number printouts w/ the GNU preprocessor */
+#define gossip_ldebug(mask, format, f...)				\
+		gossip_debug(mask, "%s: " format, __func__, ##f)
+
+#define gossip_err printk
+#define gossip_lerr(format, f...)					\
+		gossip_err("%s line %d: " format,			\
+			   __FILE__,					\
+			   __LINE__,					\
+			   ##f)
