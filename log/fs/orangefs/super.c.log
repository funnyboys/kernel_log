commit 882388056194d2d4c3f589b194b6bdcc47e677e8
Merge: dce45af5c2e9 33713cd09ccd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 9 09:37:25 2019 -0700

    Merge tag 'for-linus-5.2-ofs1' of git://git.kernel.org/pub/scm/linux/kernel/git/hubcap/linux
    
    Pull orangefs updates from Mike Marshall:
     "This includes one fix and our "Orangefs through the pagecache" patch
      series which greatly improves our small IO performance and helps us
      pass more xfstests than before.
    
      Fix:
       - orangefs: truncate before updating size
    
      Pagecache series:
       - all the rest"
    
    * tag 'for-linus-5.2-ofs1' of git://git.kernel.org/pub/scm/linux/kernel/git/hubcap/linux: (23 commits)
      orangefs: truncate before updating size
      orangefs: copy Orangefs-sized blocks into the pagecache if possible.
      orangefs: pass slot index back to readpage.
      orangefs: remember count when reading.
      orangefs: add orangefs_revalidate_mapping
      orangefs: implement writepages
      orangefs: write range tracking
      orangefs: avoid fsync service operation on flush
      orangefs: skip inode writeout if nothing to write
      orangefs: move do_readv_writev to direct_IO
      orangefs: do not return successful read when the client-core disappeared
      orangefs: implement writepage
      orangefs: migrate to generic_file_read_iter
      orangefs: service ops done for writeback are not killable
      orangefs: remove orangefs_readpages
      orangefs: reorganize setattr functions to track attribute changes
      orangefs: let setattr write to cached inode
      orangefs: set up and use backing_dev_info
      orangefs: hold i_lock during inode_getattr
      orangefs: update attributes rather than relying on server
      ...

commit afd9fb2a31797b4c787034294a4062df0c19c37e
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Feb 13 20:13:46 2018 +0000

    orangefs: reorganize setattr functions to track attribute changes
    
    OrangeFS accepts a mask indicating which attributes were changed.  The
    kernel must not set any bits except those that were actually changed.
    The kernel must set the uid/gid of the request to the actual uid/gid
    responsible for the change.
    
    Code path for notify_change initiated setattrs is
    
    orangefs_setattr(dentry, iattr)
    -> __orangefs_setattr(inode, iattr)
    
    In kernel changes are initiated by calling __orangefs_setattr.
    
    Code path for writeback is
    
    orangefs_write_inode
    -> orangefs_inode_setattr
    
    attr_valid and attr_uid and attr_gid change together under i_lock.
    I_DIRTY changes separately.
    
    __orangefs_setattr
            lock
            if needs to be cleaned first, unlock and retry
            set attr_valid
            copy data in
            unlock
            mark_inode_dirty
    
    orangefs_inode_setattr
            lock
            copy attributes out
            unlock
            clear getattr_time
            # __writeback_single_inode clears dirty
    
    orangefs_inode_getattr
            # possible to get here with attr_valid set and not dirty
            lock
            if getattr_time ok or attr_valid set, unlock and return
            unlock
            do server operation
            # another thread may getattr or setattr, so check for that
            lock
            if getattr_time ok or attr_valid, unlock and return
            else, copy in
            update getattr_time
            unlock
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index f27da3bbafac..8fa30c13b7ed 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -155,17 +155,8 @@ static void orangefs_destroy_inode(struct inode *inode)
 static int orangefs_write_inode(struct inode *inode,
 				struct writeback_control *wbc)
 {
-	struct iattr iattr;
 	gossip_debug(GOSSIP_SUPER_DEBUG, "orangefs_write_inode\n");
-	iattr.ia_valid = ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_ATIME |
-	    ATTR_ATIME_SET | ATTR_MTIME | ATTR_MTIME_SET | ATTR_CTIME;
-	iattr.ia_mode = inode->i_mode;
-	iattr.ia_uid = inode->i_uid;
-	iattr.ia_gid = inode->i_gid;
-	iattr.ia_atime = inode->i_atime;
-	iattr.ia_mtime = inode->i_mtime;
-	iattr.ia_ctime = inode->i_ctime;
-	return orangefs_inode_setattr(inode, &iattr);
+	return orangefs_inode_setattr(inode);
 }
 
 /*

commit df2d7337b570c34e051a2412f716743277ccf9c8
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Feb 12 20:29:37 2018 +0000

    orangefs: let setattr write to cached inode
    
    This is a fairly big change, but ultimately it's not a lot of code.
    
    Implement write_inode and then avoid the call to orangefs_inode_setattr
    within orangefs_setattr.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index ef3388c90ff7..f27da3bbafac 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -152,6 +152,22 @@ static void orangefs_destroy_inode(struct inode *inode)
 	call_rcu(&inode->i_rcu, orangefs_i_callback);
 }
 
+static int orangefs_write_inode(struct inode *inode,
+				struct writeback_control *wbc)
+{
+	struct iattr iattr;
+	gossip_debug(GOSSIP_SUPER_DEBUG, "orangefs_write_inode\n");
+	iattr.ia_valid = ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_ATIME |
+	    ATTR_ATIME_SET | ATTR_MTIME | ATTR_MTIME_SET | ATTR_CTIME;
+	iattr.ia_mode = inode->i_mode;
+	iattr.ia_uid = inode->i_uid;
+	iattr.ia_gid = inode->i_gid;
+	iattr.ia_atime = inode->i_atime;
+	iattr.ia_mtime = inode->i_mtime;
+	iattr.ia_ctime = inode->i_ctime;
+	return orangefs_inode_setattr(inode, &iattr);
+}
+
 /*
  * NOTE: information filled in here is typically reflected in the
  * output of the system command 'df'
@@ -310,6 +326,7 @@ void fsid_key_table_finalize(void)
 static const struct super_operations orangefs_s_ops = {
 	.alloc_inode = orangefs_alloc_inode,
 	.destroy_inode = orangefs_destroy_inode,
+	.write_inode = orangefs_write_inode,
 	.drop_inode = generic_delete_inode,
 	.statfs = orangefs_statfs,
 	.remount_fs = orangefs_remount_fs,

commit f2d34c738cbf21b0d24982693b71fd9f9f52ea4b
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Feb 12 20:28:42 2018 +0000

    orangefs: set up and use backing_dev_info
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 31db6ac73de1..ef3388c90ff7 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -407,15 +407,11 @@ static int orangefs_fill_sb(struct super_block *sb,
 		struct orangefs_fs_mount_response *fs_mount,
 		void *data, int silent)
 {
-	int ret = -EINVAL;
-	struct inode *root = NULL;
-	struct dentry *root_dentry = NULL;
+	int ret;
+	struct inode *root;
+	struct dentry *root_dentry;
 	struct orangefs_object_kref root_object;
 
-	/* alloc and init our private orangefs sb info */
-	sb->s_fs_info = kzalloc(sizeof(struct orangefs_sb_info_s), GFP_KERNEL);
-	if (!ORANGEFS_SB(sb))
-		return -ENOMEM;
 	ORANGEFS_SB(sb)->sb = sb;
 
 	ORANGEFS_SB(sb)->root_khandle = fs_mount->root_khandle;
@@ -438,6 +434,10 @@ static int orangefs_fill_sb(struct super_block *sb,
 	sb->s_blocksize_bits = PAGE_SHIFT;
 	sb->s_maxbytes = MAX_LFS_FILESIZE;
 
+	ret = super_setup_bdi(sb);
+	if (ret)
+		return ret;
+
 	root_object.khandle = ORANGEFS_SB(sb)->root_khandle;
 	root_object.fs_id = ORANGEFS_SB(sb)->fs_id;
 	gossip_debug(GOSSIP_SUPER_DEBUG,
@@ -516,6 +516,13 @@ struct dentry *orangefs_mount(struct file_system_type *fst,
 		goto free_op;
 	}
 
+	/* alloc and init our private orangefs sb info */
+	sb->s_fs_info = kzalloc(sizeof(struct orangefs_sb_info_s), GFP_KERNEL);
+	if (!ORANGEFS_SB(sb)) {
+		d = ERR_PTR(-ENOMEM);
+		goto free_op;
+	}
+
 	ret = orangefs_fill_sb(sb,
 	      &new_op->downcall.resp.fs_mount, data,
 	      flags & SB_SILENT ? 1 : 0);

commit fc2e2e9c43e3b3f5dec8a02b17ee3d6343d9783a
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Dec 12 13:46:30 2017 -0500

    orangefs: implement xattr cache
    
    This uses the same timeout as the getattr cache.  This substantially
    increases performance when writing files with smaller buffer sizes.
    
    When writing, the size is (often) changed, which causes a call to
    notify_change which calls security_inode_need_killpriv which needs a
    getxattr.  Caching it reduces traffic to the server.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index dfaee90d30bd..31db6ac73de1 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -10,6 +10,7 @@
 #include "orangefs-bufmap.h"
 
 #include <linux/parser.h>
+#include <linux/hashtable.h>
 
 /* a cache for orangefs-inode objects (i.e. orangefs inode private data) */
 static struct kmem_cache *orangefs_inode_cache;
@@ -128,6 +129,15 @@ static void orangefs_i_callback(struct rcu_head *head)
 {
 	struct inode *inode = container_of(head, struct inode, i_rcu);
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_cached_xattr *cx;
+	struct hlist_node *tmp;
+	int i;
+
+	hash_for_each_safe(orangefs_inode->xattr_cache, i, tmp, cx, node) {
+		hlist_del(&cx->node);
+		kfree(cx);
+	}
+
 	kmem_cache_free(orangefs_inode_cache, orangefs_inode);
 }
 

commit f276ae0dd6d0b5bfbcb51178a63f06dc035f4cc4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Apr 16 11:43:02 2019 -0400

    orangefs: make use of ->free_inode()
    
    Acked-by: Mike Marshall <hubcap@omnibond.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index dfaee90d30bd..3784f7e8b603 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -124,11 +124,9 @@ static struct inode *orangefs_alloc_inode(struct super_block *sb)
 	return &orangefs_inode->vfs_inode;
 }
 
-static void orangefs_i_callback(struct rcu_head *head)
+static void orangefs_free_inode(struct inode *inode)
 {
-	struct inode *inode = container_of(head, struct inode, i_rcu);
-	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
-	kmem_cache_free(orangefs_inode_cache, orangefs_inode);
+	kmem_cache_free(orangefs_inode_cache, ORANGEFS_I(inode));
 }
 
 static void orangefs_destroy_inode(struct inode *inode)
@@ -138,8 +136,6 @@ static void orangefs_destroy_inode(struct inode *inode)
 	gossip_debug(GOSSIP_SUPER_DEBUG,
 			"%s: deallocated %p destroying inode %pU\n",
 			__func__, orangefs_inode, get_khandle_from_ino(inode));
-
-	call_rcu(&inode->i_rcu, orangefs_i_callback);
 }
 
 /*
@@ -299,6 +295,7 @@ void fsid_key_table_finalize(void)
 
 static const struct super_operations orangefs_s_ops = {
 	.alloc_inode = orangefs_alloc_inode,
+	.free_inode = orangefs_free_inode,
 	.destroy_inode = orangefs_destroy_inode,
 	.drop_inode = generic_delete_inode,
 	.statfs = orangefs_statfs,

commit 95f5f88f8900c09eb534c8cb42d75ff3cf7ea96c
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri May 11 17:11:48 2018 -0400

    orangefs: formatting cleanups
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index fc34146c56dc..dfaee90d30bd 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -156,9 +156,10 @@ static int orangefs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	sb = dentry->d_sb;
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "orangefs_statfs: called on sb %p (fs_id is %d)\n",
-		     sb,
-		     (int)(ORANGEFS_SB(sb)->fs_id));
+			"%s: called on sb %p (fs_id is %d)\n",
+			__func__,
+			sb,
+			(int)(ORANGEFS_SB(sb)->fs_id));
 
 	new_op = op_alloc(ORANGEFS_VFS_OP_STATFS);
 	if (!new_op)
@@ -198,7 +199,7 @@ static int orangefs_statfs(struct dentry *dentry, struct kstatfs *buf)
 
 out_op_release:
 	op_release(new_op);
-	gossip_debug(GOSSIP_SUPER_DEBUG, "orangefs_statfs: returning %d\n", ret);
+	gossip_debug(GOSSIP_SUPER_DEBUG, "%s: returning %d\n", __func__, ret);
 	return ret;
 }
 

commit 9f8fd53cd05596f6792f769c9fd5fd2b0d624507
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu May 31 16:36:59 2018 +0000

    orangefs: revamp block sizes
    
    Now the superblock block size is PAGE_SIZE.  The inode block size is
    PAGE_SIZE for directories and symlinks, but is the server-reported
    block size for regular files.
    
    The block size in the OrangeFS private inode is now deleted.  Stat
    now reports PAGE_SIZE for directories and symlinks and the
    server-reported block size for regular files.
    
    The user-space visible change is that the block size for directores
    and symlinks and the superblock is now PAGE_SIZE rather than the size of
    the client-core shared memory buffers, which was typically four
    megabytes.
    
    Reported-by: Becky Ligon <ligon@clemson.edu>
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Cc: hubcap@omnibond.com
    Cc: walt@omnibond.com
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 10796d3fe27d..fc34146c56dc 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -423,8 +423,8 @@ static int orangefs_fill_sb(struct super_block *sb,
 	sb->s_op = &orangefs_s_ops;
 	sb->s_d_op = &orangefs_dentry_operations;
 
-	sb->s_blocksize = orangefs_bufmap_size_query();
-	sb->s_blocksize_bits = orangefs_bufmap_shift_query();
+	sb->s_blocksize = PAGE_SIZE;
+	sb->s_blocksize_bits = PAGE_SHIFT;
 	sb->s_maxbytes = MAX_LFS_FILESIZE;
 
 	root_object.khandle = ORANGEFS_SB(sb)->root_khandle;

commit 659038428cb43a66e3eff71e2c845c9de3611a98
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Apr 3 00:13:17 2018 -0400

    orangefs_kill_sb(): deal with allocation failures
    
    orangefs_fill_sb() might've failed to allocate ORANGEFS_SB(s); don't
    oops in that case.
    
    Cc: stable@kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 3ae5fdba0225..10796d3fe27d 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -579,6 +579,11 @@ void orangefs_kill_sb(struct super_block *sb)
 	/* provided sb cleanup */
 	kill_anon_super(sb);
 
+	if (!ORANGEFS_SB(sb)) {
+		mutex_lock(&orangefs_request_mutex);
+		mutex_unlock(&orangefs_request_mutex);
+		return;
+	}
 	/*
 	 * issue the unmount to userspace to tell it to remove the
 	 * dynamic mount info it has for this superblock

commit a0f79386a4968b4925da6db2d1daffd0605a4402
Merge: 81153336eb76 74e938c22705
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 8 12:20:41 2018 -0800

    Merge tag 'for-linus-4.16' of git://git.kernel.org/pub/scm/linux/kernel/git/hubcap/linux
    
    Pull orangefs updates from Mike Marshall:
     "Mostly cleanups, but three bug fixes:
    
       - don't pass garbage return codes back up the call chain (Mike
         Marshall)
    
       - fix stale inode test (Martin Brandenburg)
    
       - fix off-by-one errors (Xiongfeng Wang)
    
      Also add Martin as a reviewer in the Maintainers file"
    
    * tag 'for-linus-4.16' of git://git.kernel.org/pub/scm/linux/kernel/git/hubcap/linux:
      orangefs: reverse sense of is-inode-stale test in d_revalidate
      orangefs: simplify orangefs_inode_is_stale
      Orangefs: don't propogate whacky error codes
      orangefs: use correct string length
      orangefs: make orangefs_make_bad_inode static
      orangefs: remove ORANGEFS_KERNEL_DEBUG
      orangefs: remove gossip_ldebug and gossip_lerr
      orangefs: make orangefs_client_debug_init static
      MAINTAINERS: update orangefs list and add myself as reviewer

commit 6bdfb48dae8e1b98735bf9387557298d17510be9
Author: Xiongfeng Wang <xiongfeng.wang@linaro.org>
Date:   Mon Jan 8 20:22:33 2018 +0800

    orangefs: use correct string length
    
    gcc-8 reports
    
    fs/orangefs/dcache.c: In function 'orangefs_d_revalidate':
    ./include/linux/string.h:245:9: warning: '__builtin_strncpy' specified
    bound 256 equals destination size [-Wstringop-truncation]
    
    fs/orangefs/namei.c: In function 'orangefs_rename':
    ./include/linux/string.h:245:9: warning: '__builtin_strncpy' specified
    bound 256 equals destination size [-Wstringop-truncation]
    
    fs/orangefs/super.c: In function 'orangefs_mount':
    ./include/linux/string.h:245:9: warning: '__builtin_strncpy' specified
    bound 256 equals destination size [-Wstringop-truncation]
    
    We need one less byte or call strlcpy() to make it a nul-terminated
    string.
    
    Signed-off-by: Xiongfeng Wang <xiongfeng.wang@linaro.org>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index a4f4b508eff2..b28b75c7d275 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -383,7 +383,7 @@ static int orangefs_unmount(int id, __s32 fs_id, const char *devname)
 	op->upcall.req.fs_umount.id = id;
 	op->upcall.req.fs_umount.fs_id = fs_id;
 	strncpy(op->upcall.req.fs_umount.orangefs_config_server,
-	    devname, ORANGEFS_MAX_SERVER_ADDR_LEN);
+	    devname, ORANGEFS_MAX_SERVER_ADDR_LEN - 1);
 	r = service_operation(op, "orangefs_fs_umount", 0);
 	/* Not much to do about an error here. */
 	if (r)
@@ -478,7 +478,7 @@ struct dentry *orangefs_mount(struct file_system_type *fst,
 
 	strncpy(new_op->upcall.req.fs_mount.orangefs_config_server,
 		devname,
-		ORANGEFS_MAX_SERVER_ADDR_LEN);
+		ORANGEFS_MAX_SERVER_ADDR_LEN - 1);
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
 		     "Attempting ORANGEFS Mount via host %s\n",
@@ -520,7 +520,7 @@ struct dentry *orangefs_mount(struct file_system_type *fst,
 	 */
 	strncpy(ORANGEFS_SB(sb)->devname,
 		devname,
-		ORANGEFS_MAX_SERVER_ADDR_LEN);
+		ORANGEFS_MAX_SERVER_ADDR_LEN - 1);
 
 	/* mount_pending must be cleared */
 	ORANGEFS_SB(sb)->mount_pending = 0;

commit 79d7cd611d9e0ee9b4c38bd33f6082979826885f
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Jan 26 14:07:12 2018 -0500

    orangefs: remove gossip_ldebug and gossip_lerr
    
    gossip_ldebug is unused.
    
    gossip_lerr is used in two places.  The messages are unique so line
    numbers are unnecessary.
    
    Also remove support for compiling gossip messages out.  It wasn't
    possible to enable it anyway.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 36f1390b5ed7..a4f4b508eff2 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -335,7 +335,7 @@ static int orangefs_encode_fh(struct inode *inode,
 	struct orangefs_object_kref refn;
 
 	if (*max_len < len) {
-		gossip_lerr("fh buffer is too small for encoding\n");
+		gossip_err("fh buffer is too small for encoding\n");
 		*max_len = len;
 		type = 255;
 		goto out;

commit 6b330623e56900db8db3634b782093289c8ad175
Author: David Windsor <dave@nullcore.net>
Date:   Sat Jun 10 22:50:39 2017 -0400

    orangefs: Define usercopy region in orangefs_inode_cache slab cache
    
    orangefs symlink pathnames, stored in struct orangefs_inode_s.link_target
    and therefore contained in the orangefs_inode_cache, need to be copied
    to/from userspace.
    
    cache object allocation:
        fs/orangefs/super.c:
            orangefs_alloc_inode(...):
                ...
                orangefs_inode = kmem_cache_alloc(orangefs_inode_cache, ...);
                ...
                return &orangefs_inode->vfs_inode;
    
        fs/orangefs/orangefs-utils.c:
            exofs_symlink(...):
                ...
                inode->i_link = orangefs_inode->link_target;
    
    example usage trace:
        readlink_copy+0x43/0x70
        vfs_readlink+0x62/0x110
        SyS_readlinkat+0x100/0x130
    
        fs/namei.c:
            readlink_copy(..., link):
                ...
                copy_to_user(..., link, len);
    
            (inlined in vfs_readlink)
            generic_readlink(dentry, ...):
                struct inode *inode = d_inode(dentry);
                const char *link = inode->i_link;
                ...
                readlink_copy(..., link);
    
    In support of usercopy hardening, this patch defines a region in the
    orangefs_inode_cache slab cache in which userspace copy operations are
    allowed.
    
    This region is known as the slab cache's usercopy region. Slab caches
    can now check that each dynamically sized copy operation involving
    cache-managed memory falls entirely within the slab's usercopy region.
    
    This patch is modified from Brad Spengler/PaX Team's PAX_USERCOPY
    whitelisting code in the last public patch of grsecurity/PaX based on my
    understanding of the code. Changes or omissions from the original code are
    mine and don't reflect the original grsecurity/PaX code.
    
    Signed-off-by: David Windsor <dave@nullcore.net>
    [kees: adjust commit log, provide usage trace]
    Cc: Mike Marshall <hubcap@omnibond.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 36f1390b5ed7..62d49e53061c 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -610,11 +610,16 @@ void orangefs_kill_sb(struct super_block *sb)
 
 int orangefs_inode_cache_initialize(void)
 {
-	orangefs_inode_cache = kmem_cache_create("orangefs_inode_cache",
-					      sizeof(struct orangefs_inode_s),
-					      0,
-					      ORANGEFS_CACHE_CREATE_FLAGS,
-					      orangefs_inode_cache_ctor);
+	orangefs_inode_cache = kmem_cache_create_usercopy(
+					"orangefs_inode_cache",
+					sizeof(struct orangefs_inode_s),
+					0,
+					ORANGEFS_CACHE_CREATE_FLAGS,
+					offsetof(struct orangefs_inode_s,
+						link_target),
+					sizeof_field(struct orangefs_inode_s,
+						link_target),
+					orangefs_inode_cache_ctor);
 
 	if (!orangefs_inode_cache) {
 		gossip_err("Cannot create orangefs_inode_cache\n");

commit 1751e8a6cb935e555fcdbcb9ab4f0446e322ca3e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 27 13:05:09 2017 -0800

    Rename superblock flags (MS_xyz -> SB_xyz)
    
    This is a pure automated search-and-replace of the internal kernel
    superblock flags.
    
    The s_flags are now called SB_*, with the names and the values for the
    moment mirroring the MS_* flags that they're equivalent to.
    
    Note how the MS_xyz flags are the ones passed to the mount system call,
    while the SB_xyz flags are what we then use in sb->s_flags.
    
    The script to do this was:
    
        # places to look in; re security/*: it generally should *not* be
        # touched (that stuff parses mount(2) arguments directly), but
        # there are two places where we really deal with superblock flags.
        FILES="drivers/mtd drivers/staging/lustre fs ipc mm \
                include/linux/fs.h include/uapi/linux/bfs_fs.h \
                security/apparmor/apparmorfs.c security/apparmor/include/lib.h"
        # the list of MS_... constants
        SYMS="RDONLY NOSUID NODEV NOEXEC SYNCHRONOUS REMOUNT MANDLOCK \
              DIRSYNC NOATIME NODIRATIME BIND MOVE REC VERBOSE SILENT \
              POSIXACL UNBINDABLE PRIVATE SLAVE SHARED RELATIME KERNMOUNT \
              I_VERSION STRICTATIME LAZYTIME SUBMOUNT NOREMOTELOCK NOSEC BORN \
              ACTIVE NOUSER"
    
        SED_PROG=
        for i in $SYMS; do SED_PROG="$SED_PROG -e s/MS_$i/SB_$i/g"; done
    
        # we want files that contain at least one of MS_...,
        # with fs/namespace.c and fs/pnode.c excluded.
        L=$(for i in $SYMS; do git grep -w -l MS_$i $FILES; done| sort|uniq|grep -v '^fs/namespace.c'|grep -v '^fs/pnode.c')
    
        for f in $L; do sed -i $f $SED_PROG; done
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 366750eef201..36f1390b5ed7 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -40,7 +40,7 @@ static int orangefs_show_options(struct seq_file *m, struct dentry *root)
 {
 	struct orangefs_sb_info_s *orangefs_sb = ORANGEFS_SB(root->d_sb);
 
-	if (root->d_sb->s_flags & MS_POSIXACL)
+	if (root->d_sb->s_flags & SB_POSIXACL)
 		seq_puts(m, ",acl");
 	if (orangefs_sb->flags & ORANGEFS_OPT_INTR)
 		seq_puts(m, ",intr");
@@ -60,7 +60,7 @@ static int parse_mount_options(struct super_block *sb, char *options,
 	 * Force any potential flags that might be set from the mount
 	 * to zero, ie, initialize to unset.
 	 */
-	sb->s_flags &= ~MS_POSIXACL;
+	sb->s_flags &= ~SB_POSIXACL;
 	orangefs_sb->flags &= ~ORANGEFS_OPT_INTR;
 	orangefs_sb->flags &= ~ORANGEFS_OPT_LOCAL_LOCK;
 
@@ -73,7 +73,7 @@ static int parse_mount_options(struct super_block *sb, char *options,
 		token = match_token(p, tokens, args);
 		switch (token) {
 		case Opt_acl:
-			sb->s_flags |= MS_POSIXACL;
+			sb->s_flags |= SB_POSIXACL;
 			break;
 		case Opt_intr:
 			orangefs_sb->flags |= ORANGEFS_OPT_INTR;
@@ -507,7 +507,7 @@ struct dentry *orangefs_mount(struct file_system_type *fst,
 
 	ret = orangefs_fill_sb(sb,
 	      &new_op->downcall.resp.fs_mount, data,
-	      flags & MS_SILENT ? 1 : 0);
+	      flags & SB_SILENT ? 1 : 0);
 
 	if (ret) {
 		d = ERR_PTR(ret);

commit a55f2d861585006f493e933ad32d65d71ba631fa
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Nov 7 15:01:40 2017 -0500

    orangefs: stop setting atime on inode dirty
    
    The previous code path was to mark the inode dirty, let
    orangefs_inode_dirty set a flag in our private inode, then later during
    inode release call orangefs_flush_inode which notices the flag and
    writes the atime out.
    
    The code path worked almost identically for mtime, ctime, and mode
    except that those flags are set explicitly and not as side effects of
    dirty.
    
    Now orangefs_flush_inode is removed.  Marking an inode dirty does not
    imply an atime update.  Any place where flags were set before is now
    an explicit call to orangefs_inode_setattr.  Since OrangeFS does not
    utilize inode writeback, the attribute change should be written out
    immediately.
    
    Fixes generic/120.
    
    In namei.c, there are several places where the directory mtime and ctime
    are set, but only the mtime is sent to the server.  These don't seem
    right, but I've left them as is for now.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 43df511e69f2..366750eef201 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -117,7 +117,6 @@ static struct inode *orangefs_alloc_inode(struct super_block *sb)
 	orangefs_inode->refn.fs_id = ORANGEFS_FS_ID_NULL;
 	orangefs_inode->last_failed_block_index_read = 0;
 	memset(orangefs_inode->link_target, 0, sizeof(orangefs_inode->link_target));
-	orangefs_inode->pinode_flags = 0;
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
 		     "orangefs_alloc_inode: allocated %p\n",
@@ -297,21 +296,9 @@ void fsid_key_table_finalize(void)
 {
 }
 
-/* Called whenever the VFS dirties the inode in response to atime updates */
-static void orangefs_dirty_inode(struct inode *inode, int flags)
-{
-	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
-
-	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "orangefs_dirty_inode: %pU\n",
-		     get_khandle_from_ino(inode));
-	SetAtimeFlag(orangefs_inode);
-}
-
 static const struct super_operations orangefs_s_ops = {
 	.alloc_inode = orangefs_alloc_inode,
 	.destroy_inode = orangefs_destroy_inode,
-	.dirty_inode = orangefs_dirty_inode,
 	.drop_inode = generic_delete_inode,
 	.statfs = orangefs_statfs,
 	.remount_fs = orangefs_remount_fs,

commit 933f7ac1a1df37ab6b25b50a85c13fcc5ea8cd03
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Oct 30 11:19:20 2017 -0400

    orangefs: remove initialization of i_version
    
    ...as it's completely unused.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 47ebd9bfd1a1..43df511e69f2 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -99,8 +99,6 @@ static void orangefs_inode_cache_ctor(void *req)
 
 	inode_init_once(&orangefs_inode->vfs_inode);
 	init_rwsem(&orangefs_inode->xattr_sem);
-
-	orangefs_inode->vfs_inode.i_version = 1;
 }
 
 static struct inode *orangefs_alloc_inode(struct super_block *sb)

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 47f3fb9cbec4..47ebd9bfd1a1 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * (C) 2001 Clemson University and The University of Chicago
  *

commit 07a258531c7550f8bb481dfe2ec12bb876224487
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Aug 17 21:00:07 2017 +0200

    orangefs: Delete error messages for a failed memory allocation in five functions
    
    Omit an extra message for a memory allocation failure in these functions.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 5a1bed6c8c6a..47f3fb9cbec4 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -107,10 +107,8 @@ static struct inode *orangefs_alloc_inode(struct super_block *sb)
 	struct orangefs_inode_s *orangefs_inode;
 
 	orangefs_inode = kmem_cache_alloc(orangefs_inode_cache, GFP_KERNEL);
-	if (orangefs_inode == NULL) {
-		gossip_err("Failed to allocate orangefs_inode\n");
+	if (!orangefs_inode)
 		return NULL;
-	}
 
 	/*
 	 * We want to clear everything except for rw_semaphore and the

commit 4dfdb71307675b19a54723a556371dad5e3b0083
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jul 5 16:25:45 2017 +0100

    orangefs: Implement show_options
    
    Implement the show_options superblock op for orangefs as part of a bid to
    rid of s_options and generic_show_options() to make it easier to implement
    a context-based mount where the mount options can be passed individually
    over a file descriptor.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Mike Marshall <hubcap@omnibond.com>
    cc: pvfs2-developers@beowulf-underground.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 5c7c273e17ec..5a1bed6c8c6a 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -35,6 +35,19 @@ static const match_table_t tokens = {
 
 uint64_t orangefs_features;
 
+static int orangefs_show_options(struct seq_file *m, struct dentry *root)
+{
+	struct orangefs_sb_info_s *orangefs_sb = ORANGEFS_SB(root->d_sb);
+
+	if (root->d_sb->s_flags & MS_POSIXACL)
+		seq_puts(m, ",acl");
+	if (orangefs_sb->flags & ORANGEFS_OPT_INTR)
+		seq_puts(m, ",intr");
+	if (orangefs_sb->flags & ORANGEFS_OPT_LOCAL_LOCK)
+		seq_puts(m, ",local_lock");
+	return 0;
+}
+
 static int parse_mount_options(struct super_block *sb, char *options,
 		int silent)
 {
@@ -305,7 +318,7 @@ static const struct super_operations orangefs_s_ops = {
 	.drop_inode = generic_delete_inode,
 	.statfs = orangefs_statfs,
 	.remount_fs = orangefs_remount_fs,
-	.show_options = generic_show_options,
+	.show_options = orangefs_show_options,
 };
 
 static struct dentry *orangefs_fh_to_dentry(struct super_block *sb,

commit 9d286b0d8207a70d7e0ffbd5be864ff7a62de05a
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 25 15:38:05 2017 -0400

    orangefs: ensure the userspace component is unmounted if mount fails
    
    If the mount is aborted after userspace has been asked to mount,
    userspace must be told to unmount.
    
    Ordinarily orangefs_kill_sb does the unmount.  However it cannot be
    called if the superblock has not been set up.  This is a very narrow
    window.
    
    The NULL fs_id is not unmounted.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 629d8c917fa6..5c7c273e17ec 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -376,6 +376,25 @@ static const struct export_operations orangefs_export_ops = {
 	.fh_to_dentry = orangefs_fh_to_dentry,
 };
 
+static int orangefs_unmount(int id, __s32 fs_id, const char *devname)
+{
+	struct orangefs_kernel_op_s *op;
+	int r;
+	op = op_alloc(ORANGEFS_VFS_OP_FS_UMOUNT);
+	if (!op)
+		return -ENOMEM;
+	op->upcall.req.fs_umount.id = id;
+	op->upcall.req.fs_umount.fs_id = fs_id;
+	strncpy(op->upcall.req.fs_umount.orangefs_config_server,
+	    devname, ORANGEFS_MAX_SERVER_ADDR_LEN);
+	r = service_operation(op, "orangefs_fs_umount", 0);
+	/* Not much to do about an error here. */
+	if (r)
+		gossip_err("orangefs_unmount: service_operation %d\n", r);
+	op_release(op);
+	return r;
+}
+
 static int orangefs_fill_sb(struct super_block *sb,
 		struct orangefs_fs_mount_response *fs_mount,
 		void *data, int silent)
@@ -484,6 +503,8 @@ struct dentry *orangefs_mount(struct file_system_type *fst,
 
 	if (IS_ERR(sb)) {
 		d = ERR_CAST(sb);
+		orangefs_unmount(new_op->downcall.resp.fs_mount.id,
+		    new_op->downcall.resp.fs_mount.fs_id, devname);
 		goto free_op;
 	}
 
@@ -539,6 +560,7 @@ struct dentry *orangefs_mount(struct file_system_type *fst,
 free_sb_and_op:
 	/* Will call orangefs_kill_sb with sb not in list. */
 	ORANGEFS_SB(sb)->no_list = 1;
+	/* ORANGEFS_VFS_OP_FS_UMOUNT is done by orangefs_kill_sb. */
 	deactivate_locked_super(sb);
 free_op:
 	gossip_err("orangefs_mount: mount request failed with %d\n", ret);
@@ -554,6 +576,7 @@ struct dentry *orangefs_mount(struct file_system_type *fst,
 
 void orangefs_kill_sb(struct super_block *sb)
 {
+	int r;
 	gossip_debug(GOSSIP_SUPER_DEBUG, "orangefs_kill_sb: called\n");
 
 	/* provided sb cleanup */
@@ -563,7 +586,10 @@ void orangefs_kill_sb(struct super_block *sb)
 	 * issue the unmount to userspace to tell it to remove the
 	 * dynamic mount info it has for this superblock
 	 */
-	 orangefs_unmount_sb(sb);
+	r = orangefs_unmount(ORANGEFS_SB(sb)->id, ORANGEFS_SB(sb)->fs_id,
+	    ORANGEFS_SB(sb)->devname);
+	if (!r)
+		ORANGEFS_SB(sb)->mount_pending = 1;
 
 	if (!ORANGEFS_SB(sb)->no_list) {
 		/* remove the sb from our list of orangefs specific sb's */

commit 1ec1688c5360e14dde4094d6acbf7516bf6db37e
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Apr 14 14:22:41 2017 -0400

    orangefs: free superblock when mount fails
    
    Otherwise lockdep says:
    
    [ 1337.483798] ================================================
    [ 1337.483999] [ BUG: lock held when returning to user space! ]
    [ 1337.484252] 4.11.0-rc6 #19 Not tainted
    [ 1337.484423] ------------------------------------------------
    [ 1337.484626] mount/14766 is leaving the kernel with locks still held!
    [ 1337.484841] 1 lock held by mount/14766:
    [ 1337.485017]  #0:  (&type->s_umount_key#33/1){+.+.+.}, at: [<ffffffff8124171f>] sget_userns+0x2af/0x520
    
    Caught by xfstests generic/413 which tried to mount with the unsupported
    mount option dax.  Then xfstests generic/422 ran sync which deadlocks.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Acked-by: Mike Marshall <hubcap@omnibond.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index cd261c8de53a..629d8c917fa6 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -493,7 +493,7 @@ struct dentry *orangefs_mount(struct file_system_type *fst,
 
 	if (ret) {
 		d = ERR_PTR(ret);
-		goto free_op;
+		goto free_sb_and_op;
 	}
 
 	/*
@@ -519,6 +519,9 @@ struct dentry *orangefs_mount(struct file_system_type *fst,
 	spin_unlock(&orangefs_superblocks_lock);
 	op_release(new_op);
 
+	/* Must be removed from the list now. */
+	ORANGEFS_SB(sb)->no_list = 0;
+
 	if (orangefs_userspace_version >= 20906) {
 		new_op = op_alloc(ORANGEFS_VFS_OP_FEATURES);
 		if (!new_op)
@@ -533,6 +536,10 @@ struct dentry *orangefs_mount(struct file_system_type *fst,
 
 	return dget(sb->s_root);
 
+free_sb_and_op:
+	/* Will call orangefs_kill_sb with sb not in list. */
+	ORANGEFS_SB(sb)->no_list = 1;
+	deactivate_locked_super(sb);
 free_op:
 	gossip_err("orangefs_mount: mount request failed with %d\n", ret);
 	if (ret == -EINVAL) {
@@ -558,12 +565,14 @@ void orangefs_kill_sb(struct super_block *sb)
 	 */
 	 orangefs_unmount_sb(sb);
 
-	/* remove the sb from our list of orangefs specific sb's */
-
-	spin_lock(&orangefs_superblocks_lock);
-	__list_del_entry(&ORANGEFS_SB(sb)->list);	/* not list_del_init */
-	ORANGEFS_SB(sb)->list.prev = NULL;
-	spin_unlock(&orangefs_superblocks_lock);
+	if (!ORANGEFS_SB(sb)->no_list) {
+		/* remove the sb from our list of orangefs specific sb's */
+		spin_lock(&orangefs_superblocks_lock);
+		/* not list_del_init */
+		__list_del_entry(&ORANGEFS_SB(sb)->list);
+		ORANGEFS_SB(sb)->list.prev = NULL;
+		spin_unlock(&orangefs_superblocks_lock);
+	}
 
 	/*
 	 * make sure that ORANGEFS_DEV_REMOUNT_ALL loop that might've seen us

commit cefdc26e86728812aea54248a534fd4a5da2a43d
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Apr 6 18:11:00 2017 -0400

    orangefs: move features validation to fix filesystem hang
    
    Without this fix (and another to the userspace component itself
    described later), the kernel will be unable to process any OrangeFS
    requests after the userspace component is restarted (due to a crash or
    at the administrator's behest).
    
    The bug here is that inside orangefs_remount, the orangefs_request_mutex
    is locked.  When the userspace component restarts while the filesystem
    is mounted, it sends a ORANGEFS_DEV_REMOUNT_ALL ioctl to the device,
    which causes the kernel to send it a few requests aimed at synchronizing
    the state between the two.  While this is happening the
    orangefs_request_mutex is locked to prevent any other requests going
    through.
    
    This is only half of the bugfix.  The other half is in the userspace
    component which outright ignores(!) requests made before it considers
    the filesystem remounted, which is after the ioctl returns.  Of course
    the ioctl doesn't return until after the userspace component responds to
    the request it ignores.  The userspace component has been changed to
    allow ORANGEFS_VFS_OP_FEATURES regardless of the mount status.
    
    Mike Marshall says:
     "I've tested this patch against the fixed userspace part. This patch is
      real important, I hope it can make it into 4.11...
    
      Here's what happens when the userspace daemon is restarted, without
      the patch:
    
        =============================================
        [ INFO: possible recursive locking detected ]
        [   4.10.0-00007-ge98bdb3 #1 Not tainted    ]
        ---------------------------------------------
        pvfs2-client-co/29032 is trying to acquire lock:
         (orangefs_request_mutex){+.+.+.}, at: service_operation+0x3c7/0x7b0 [orangefs]
                      but task is already holding lock:
         (orangefs_request_mutex){+.+.+.}, at: dispatch_ioctl_command+0x1bf/0x330 [orangefs]
    
        CPU: 0 PID: 29032 Comm: pvfs2-client-co Not tainted 4.10.0-00007-ge98bdb3 #1
        Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.9.3-1.fc25 04/01/2014
        Call Trace:
         __lock_acquire+0x7eb/0x1290
         lock_acquire+0xe8/0x1d0
         mutex_lock_killable_nested+0x6f/0x6e0
         service_operation+0x3c7/0x7b0 [orangefs]
         orangefs_remount+0xea/0x150 [orangefs]
         dispatch_ioctl_command+0x227/0x330 [orangefs]
         orangefs_devreq_ioctl+0x29/0x70 [orangefs]
         do_vfs_ioctl+0xa3/0x6e0
         SyS_ioctl+0x79/0x90"
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Acked-by: Mike Marshall <hubcap@omnibond.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 67c24351a67f..cd261c8de53a 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -263,8 +263,13 @@ int orangefs_remount(struct orangefs_sb_info_s *orangefs_sb)
 		if (!new_op)
 			return -ENOMEM;
 		new_op->upcall.req.features.features = 0;
-		ret = service_operation(new_op, "orangefs_features", 0);
-		orangefs_features = new_op->downcall.resp.features.features;
+		ret = service_operation(new_op, "orangefs_features",
+		    ORANGEFS_OP_PRIORITY | ORANGEFS_OP_NO_MUTEX);
+		if (!ret)
+			orangefs_features =
+			    new_op->downcall.resp.features.features;
+		else
+			orangefs_features = 0;
 		op_release(new_op);
 	} else {
 		orangefs_features = 0;

commit 0695d7dc1d9f19b82ec2cae24856bddce278cfe6
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Fri Feb 24 16:43:36 2017 +0100

    orangefs: Use RCU for destroy_inode
    
    freeing of inodes must be RCU-delayed on all filesystems
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index c48859f16e7b..67c24351a67f 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -115,6 +115,13 @@ static struct inode *orangefs_alloc_inode(struct super_block *sb)
 	return &orangefs_inode->vfs_inode;
 }
 
+static void orangefs_i_callback(struct rcu_head *head)
+{
+	struct inode *inode = container_of(head, struct inode, i_rcu);
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	kmem_cache_free(orangefs_inode_cache, orangefs_inode);
+}
+
 static void orangefs_destroy_inode(struct inode *inode)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
@@ -123,7 +130,7 @@ static void orangefs_destroy_inode(struct inode *inode)
 			"%s: deallocated %p destroying inode %pU\n",
 			__func__, orangefs_inode, get_khandle_from_ino(inode));
 
-	kmem_cache_free(orangefs_inode_cache, orangefs_inode);
+	call_rcu(&inode->i_rcu, orangefs_i_callback);
 }
 
 /*

commit f60fbdbf41c802e45c03e02ef824772c539ac965
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Mon Oct 3 15:07:36 2016 -0400

    Revert "orangefs: bump minimum userspace version"
    
    The features op did make it into OrangeFS 2.9.6 after all.
    
    This reverts commit 0c95ad76361f1d75a1ffdf82deafbcec44d19c42.

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 166f3a59d2e4..c48859f16e7b 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -251,7 +251,7 @@ int orangefs_remount(struct orangefs_sb_info_s *orangefs_sb)
 
 	op_release(new_op);
 
-	if (orangefs_userspace_version >= 20907) {
+	if (orangefs_userspace_version >= 20906) {
 		new_op = op_alloc(ORANGEFS_VFS_OP_FEATURES);
 		if (!new_op)
 			return -ENOMEM;
@@ -507,7 +507,7 @@ struct dentry *orangefs_mount(struct file_system_type *fst,
 	spin_unlock(&orangefs_superblocks_lock);
 	op_release(new_op);
 
-	if (orangefs_userspace_version >= 20907) {
+	if (orangefs_userspace_version >= 20906) {
 		new_op = op_alloc(ORANGEFS_VFS_OP_FEATURES);
 		if (!new_op)
 			return ERR_PTR(-ENOMEM);

commit b78b11985a36bfe768add17ffb70bbaf9d8d7627
Merge: f808e138c0ab 1d503617884e
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Wed Sep 28 14:50:46 2016 -0400

    Merge branch 'misc' into for-next
    
    Pull in an OrangeFS branch containing miscellaneous improvements.
    
    - clean up debugfs globals
    - remove dead code in sysfs
    - reorganize duplicated sysfs attribute structs
    - consolidate sysfs show and store functions
    - remove duplicated sysfs_ops structures
    - describe organization of sysfs
    - make devreq_mutex static
    - g_orangefs_stats -> orangefs_stats for consistency
    - rename most remaining global variables

commit 0c95ad76361f1d75a1ffdf82deafbcec44d19c42
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Wed Sep 21 12:37:23 2016 -0400

    orangefs: bump minimum userspace version
    
    OrangeFS 2.9.6 was released without support for the features op. Thus
    OrangeFS 2.9.7 will be required to use it.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 3e484a667340..b4ab1c1e8278 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -251,7 +251,7 @@ int orangefs_remount(struct orangefs_sb_info_s *orangefs_sb)
 
 	op_release(new_op);
 
-	if (orangefs_userspace_version >= 20906) {
+	if (orangefs_userspace_version >= 20907) {
 		new_op = op_alloc(ORANGEFS_VFS_OP_FEATURES);
 		if (!new_op)
 			return -ENOMEM;
@@ -507,7 +507,7 @@ struct dentry *orangefs_mount(struct file_system_type *fst,
 	spin_unlock(&orangefs_superblocks_lock);
 	op_release(new_op);
 
-	if (orangefs_userspace_version >= 20906) {
+	if (orangefs_userspace_version >= 20907) {
 		new_op = op_alloc(ORANGEFS_VFS_OP_FEATURES);
 		if (!new_op)
 			return ERR_PTR(-ENOMEM);

commit 1d503617884ed43af1c03685e73ce23f155d3fa4
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Aug 16 11:38:14 2016 -0400

    orangefs: rename most remaining global variables
    
    Only op_timeout_secs, slot_timeout_secs, and hash_table_size are left
    because they are exposed as module parameters. All other global
    variables have the orangefs_ prefix.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index b9da9a0281c9..74b84c08a140 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -530,8 +530,8 @@ void orangefs_kill_sb(struct super_block *sb)
 	 * make sure that ORANGEFS_DEV_REMOUNT_ALL loop that might've seen us
 	 * gets completed before we free the dang thing.
 	 */
-	mutex_lock(&request_mutex);
-	mutex_unlock(&request_mutex);
+	mutex_lock(&orangefs_request_mutex);
+	mutex_unlock(&orangefs_request_mutex);
 
 	/* free the orangefs superblock private data */
 	kfree(ORANGEFS_SB(sb));

commit 482664ddba81b3a5404fd083bb9697dfffc0b6a4
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Aug 12 12:02:31 2016 -0400

    orangefs: add features op
    
    This is a new userspace operation, which will be done if the client-core
    version is greater than or equal to 2.9.6. This will provide a way to
    implement optional features and to determine which features are
    supported by the client-core. If the client-core version is older than
    2.9.6, no optional features are supported and the op will not be done.
    
    The intent is to allow protocol extensions without relying on the
    client-core's current behavior of ignoring what it doesn't understand.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index b9da9a0281c9..3e484a667340 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -33,6 +33,7 @@ static const match_table_t tokens = {
 	{ Opt_err,	NULL }
 };
 
+uint64_t orangefs_features;
 
 static int parse_mount_options(struct super_block *sb, char *options,
 		int silent)
@@ -249,6 +250,19 @@ int orangefs_remount(struct orangefs_sb_info_s *orangefs_sb)
 	}
 
 	op_release(new_op);
+
+	if (orangefs_userspace_version >= 20906) {
+		new_op = op_alloc(ORANGEFS_VFS_OP_FEATURES);
+		if (!new_op)
+			return -ENOMEM;
+		new_op->upcall.req.features.features = 0;
+		ret = service_operation(new_op, "orangefs_features", 0);
+		orangefs_features = new_op->downcall.resp.features.features;
+		op_release(new_op);
+	} else {
+		orangefs_features = 0;
+	}
+
 	return ret;
 }
 
@@ -492,6 +506,19 @@ struct dentry *orangefs_mount(struct file_system_type *fst,
 	list_add_tail(&ORANGEFS_SB(sb)->list, &orangefs_superblocks);
 	spin_unlock(&orangefs_superblocks_lock);
 	op_release(new_op);
+
+	if (orangefs_userspace_version >= 20906) {
+		new_op = op_alloc(ORANGEFS_VFS_OP_FEATURES);
+		if (!new_op)
+			return ERR_PTR(-ENOMEM);
+		new_op->upcall.req.features.features = 0;
+		ret = service_operation(new_op, "orangefs_features", 0);
+		orangefs_features = new_op->downcall.resp.features.features;
+		op_release(new_op);
+	} else {
+		orangefs_features = 0;
+	}
+
 	return dget(sb->s_root);
 
 free_op:

commit 45996492e5c85aa0ac93a95d1b2d1ed56851c865
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 25 19:56:34 2016 -0400

    orangefs: fix orangefs_superblock locking
    
    * switch orangefs_remount() to taking ORANGEFS_SB(sb) instead of sb
    * remove from the list _before_ orangefs_unmount() - request_mutex
    in the latter will make sure that nothing observed in the loop in
    ORANGEFS_DEV_REMOUNT_ALL handling will get freed until the end
    of loop
    * on removal, keep the forward pointer and zero the back one.  That
    way we can drop and regain the spinlock in the loop body (again,
    ORANGEFS_DEV_REMOUNT_ALL one) and still be able to get to the
    rest of the list.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 5a89b8083966..b9da9a0281c9 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -210,7 +210,7 @@ static int orangefs_remount_fs(struct super_block *sb, int *flags, char *data)
  * the client regains all of the mount information from us.
  * NOTE: this function assumes that the request_mutex is already acquired!
  */
-int orangefs_remount(struct super_block *sb)
+int orangefs_remount(struct orangefs_sb_info_s *orangefs_sb)
 {
 	struct orangefs_kernel_op_s *new_op;
 	int ret = -EINVAL;
@@ -221,7 +221,7 @@ int orangefs_remount(struct super_block *sb)
 	if (!new_op)
 		return -ENOMEM;
 	strncpy(new_op->upcall.req.fs_mount.orangefs_config_server,
-		ORANGEFS_SB(sb)->devname,
+		orangefs_sb->devname,
 		ORANGEFS_MAX_SERVER_ADDR_LEN);
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
@@ -244,8 +244,8 @@ int orangefs_remount(struct super_block *sb)
 		 * short-lived mapping that the system interface uses
 		 * to map this superblock to a particular mount entry
 		 */
-		ORANGEFS_SB(sb)->id = new_op->downcall.resp.fs_mount.id;
-		ORANGEFS_SB(sb)->mount_pending = 0;
+		orangefs_sb->id = new_op->downcall.resp.fs_mount.id;
+		orangefs_sb->mount_pending = 0;
 	}
 
 	op_release(new_op);
@@ -485,7 +485,12 @@ struct dentry *orangefs_mount(struct file_system_type *fst,
 	 * finally, add this sb to our list of known orangefs
 	 * sb's
 	 */
-	add_orangefs_sb(sb);
+	gossip_debug(GOSSIP_SUPER_DEBUG,
+		     "Adding SB %p to orangefs superblocks\n",
+		     ORANGEFS_SB(sb));
+	spin_lock(&orangefs_superblocks_lock);
+	list_add_tail(&ORANGEFS_SB(sb)->list, &orangefs_superblocks);
+	spin_unlock(&orangefs_superblocks_lock);
 	op_release(new_op);
 	return dget(sb->s_root);
 
@@ -512,10 +517,21 @@ void orangefs_kill_sb(struct super_block *sb)
 	 * issue the unmount to userspace to tell it to remove the
 	 * dynamic mount info it has for this superblock
 	 */
-	orangefs_unmount_sb(sb);
+	 orangefs_unmount_sb(sb);
 
 	/* remove the sb from our list of orangefs specific sb's */
-	remove_orangefs_sb(sb);
+
+	spin_lock(&orangefs_superblocks_lock);
+	__list_del_entry(&ORANGEFS_SB(sb)->list);	/* not list_del_init */
+	ORANGEFS_SB(sb)->list.prev = NULL;
+	spin_unlock(&orangefs_superblocks_lock);
+
+	/*
+	 * make sure that ORANGEFS_DEV_REMOUNT_ALL loop that might've seen us
+	 * gets completed before we free the dang thing.
+	 */
+	mutex_lock(&request_mutex);
+	mutex_unlock(&request_mutex);
 
 	/* free the orangefs superblock private data */
 	kfree(ORANGEFS_SB(sb));

commit 524b1d3095159adeee0305508eefc836a197b681
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Feb 16 21:08:29 2016 -0500

    orangefs: have ->kill_sb() evict the VFS side of things first
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 1eeb0093b62c..5a89b8083966 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -505,6 +505,9 @@ void orangefs_kill_sb(struct super_block *sb)
 {
 	gossip_debug(GOSSIP_SUPER_DEBUG, "orangefs_kill_sb: called\n");
 
+	/* provided sb cleanup */
+	kill_anon_super(sb);
+
 	/*
 	 * issue the unmount to userspace to tell it to remove the
 	 * dynamic mount info it has for this superblock
@@ -514,9 +517,6 @@ void orangefs_kill_sb(struct super_block *sb)
 	/* remove the sb from our list of orangefs specific sb's */
 	remove_orangefs_sb(sb);
 
-	/* provided sb cleanup */
-	kill_anon_super(sb);
-
 	/* free the orangefs superblock private data */
 	kfree(ORANGEFS_SB(sb));
 }

commit 05d31c5cb34cbdf05f9326b276be03756abb4b70
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Mar 18 13:36:45 2016 -0400

    orangefs: remove needless wrapper around GFP_KERNEL
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index eac24eb7fe80..1eeb0093b62c 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -360,8 +360,7 @@ static int orangefs_fill_sb(struct super_block *sb,
 	struct orangefs_object_kref root_object;
 
 	/* alloc and init our private orangefs sb info */
-	sb->s_fs_info =
-		kzalloc(sizeof(struct orangefs_sb_info_s), ORANGEFS_GFP_FLAGS);
+	sb->s_fs_info = kzalloc(sizeof(struct orangefs_sb_info_s), GFP_KERNEL);
 	if (!ORANGEFS_SB(sb))
 		return -ENOMEM;
 	ORANGEFS_SB(sb)->sb = sb;

commit 47b4948fdb1055cd8d8f86aebb0b3fcb06ba36d5
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Sat Feb 20 14:22:40 2016 -0500

    orangefs: use ORANGEFS_NAME_LEN everywhere; remove ORANGEFS_NAME_MAX
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 65ddc74e96b6..eac24eb7fe80 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -170,7 +170,7 @@ static int orangefs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_type = sb->s_magic;
 	memcpy(&buf->f_fsid, &ORANGEFS_SB(sb)->fs_id, sizeof(buf->f_fsid));
 	buf->f_bsize = new_op->downcall.resp.statfs.block_size;
-	buf->f_namelen = ORANGEFS_NAME_LEN;
+	buf->f_namelen = ORANGEFS_NAME_MAX;
 
 	buf->f_blocks = (sector_t) new_op->downcall.resp.statfs.blocks_total;
 	buf->f_bfree = (sector_t) new_op->downcall.resp.statfs.blocks_avail;

commit adcf34a2893386c99e80feee36e30a782b3815e7
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Feb 24 16:54:27 2016 -0500

    Orangefs: code sanitation
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 93cc352be360..65ddc74e96b6 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -229,12 +229,12 @@ int orangefs_remount(struct super_block *sb)
 		     new_op->upcall.req.fs_mount.orangefs_config_server);
 
 	/*
-	 * we assume that the calling function has already acquire the
+	 * we assume that the calling function has already acquired the
 	 * request_mutex to prevent other operations from bypassing
 	 * this one
 	 */
 	ret = service_operation(new_op, "orangefs_remount",
-		ORANGEFS_OP_PRIORITY | ORANGEFS_OP_NO_SEMAPHORE);
+		ORANGEFS_OP_PRIORITY | ORANGEFS_OP_NO_MUTEX);
 	gossip_debug(GOSSIP_SUPER_DEBUG,
 		     "orangefs_remount: mount got return value of %d\n",
 		     ret);

commit 2d4cae0d175acae2ea2efbc17b52b71d4ffd886d
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Thu Feb 4 13:48:16 2016 -0500

    Orangefs: clean up slab allocation.
    
    A couple of caches were no longer needed:
    
     - iov_iter improvements to orangefs_devreq_write_iter eliminated
       the need for the dev_req_cache.
    
     - removal (months ago) of the old AIO code eliminated the need
       for the kiocb_cache.
    
    Also, deobfuscation of use of GFP_KERNEL when calling kmem_cache_(z)alloc
    for remaining caches.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index a32981239ea6..93cc352be360 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -92,8 +92,7 @@ static struct inode *orangefs_alloc_inode(struct super_block *sb)
 {
 	struct orangefs_inode_s *orangefs_inode;
 
-	orangefs_inode = kmem_cache_alloc(orangefs_inode_cache,
-				       ORANGEFS_CACHE_ALLOC_FLAGS);
+	orangefs_inode = kmem_cache_alloc(orangefs_inode_cache, GFP_KERNEL);
 	if (orangefs_inode == NULL) {
 		gossip_err("Failed to allocate orangefs_inode\n");
 		return NULL;

commit be57366e14d8341f5d2b589d5b59151895afe210
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Jan 13 11:38:14 2016 -0500

    Orangefs: make .statfs gossip_debug more complete.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index bee67b37d805..a32981239ea6 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -158,11 +158,15 @@ static int orangefs_statfs(struct dentry *dentry, struct kstatfs *buf)
 		goto out_op_release;
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "orangefs_statfs: got %ld blocks available | "
-		     "%ld blocks total | %ld block size\n",
+		     "%s: got %ld blocks available | "
+		     "%ld blocks total | %ld block size | "
+		     "%ld files total | %ld files avail\n",
+		     __func__,
 		     (long)new_op->downcall.resp.statfs.blocks_avail,
 		     (long)new_op->downcall.resp.statfs.blocks_total,
-		     (long)new_op->downcall.resp.statfs.block_size);
+		     (long)new_op->downcall.resp.statfs.block_size,
+		     (long)new_op->downcall.resp.statfs.files_total,
+		     (long)new_op->downcall.resp.statfs.files_avail);
 
 	buf->f_type = sb->s_magic;
 	memcpy(&buf->f_fsid, &ORANGEFS_SB(sb)->fs_id, sizeof(buf->f_fsid));

commit acaca36dd94d1bfe381a7425984991a06ba58f53
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Jan 1 10:01:52 2016 +0100

    OrangeFS: constify export_operations structures
    
    This export_operations structure is never modified, so declare it as const.
    Most other structures of this type are already const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 52bc522ea21c..bee67b37d805 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -342,7 +342,7 @@ static int orangefs_encode_fh(struct inode *inode,
 	return type;
 }
 
-static struct export_operations orangefs_export_ops = {
+static const struct export_operations orangefs_export_ops = {
 	.encode_fh = orangefs_encode_fh,
 	.fh_to_dentry = orangefs_fh_to_dentry,
 };

commit 575e946125f70c41c2042f10172842c5cab9a09a
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Dec 4 12:56:14 2015 -0500

    Orangefs: change pvfs2 filenames to orangefs
    
    Also changed references within source files that referred to
    header files whose names had changed.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index c104de1ae5de..52bc522ea21c 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -5,8 +5,8 @@
  */
 
 #include "protocol.h"
-#include "pvfs2-kernel.h"
-#include "pvfs2-bufmap.h"
+#include "orangefs-kernel.h"
+#include "orangefs-bufmap.h"
 
 #include <linux/parser.h>
 

commit 8bb8aefd5afb54a25a002feb4ec70011812d06a0
Author: Yi Liu <yi9@clemson.edu>
Date:   Tue Nov 24 15:12:14 2015 -0500

    OrangeFS: Change almost all instances of the string PVFS2 to OrangeFS.
    
    OrangeFS was formerly known as PVFS2 and retains the name in many places.
    
    I leave the device /dev/pvfs2-req since this affects userspace.
    
    I leave the filesystem type pvfs2 since this affects userspace. Further
    the OrangeFS sysint library reads fstab for an entry of type pvfs2
    independently of kernel mounts.
    
    I leave extended attribute keys user.pvfs2 and system.pvfs2 as the
    sysint library understands these.
    
    I leave references to userspace binaries still named pvfs2.
    
    I leave the filenames.
    
    Signed-off-by: Yi Liu <yi9@clemson.edu>
    [martin@omnibond.com: clairify above constraints and merge]
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 45db0772a767..c104de1ae5de 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -10,13 +10,13 @@
 
 #include <linux/parser.h>
 
-/* a cache for pvfs2-inode objects (i.e. pvfs2 inode private data) */
-static struct kmem_cache *pvfs2_inode_cache;
+/* a cache for orangefs-inode objects (i.e. orangefs inode private data) */
+static struct kmem_cache *orangefs_inode_cache;
 
-/* list for storing pvfs2 specific superblocks in use */
-LIST_HEAD(pvfs2_superblocks);
+/* list for storing orangefs specific superblocks in use */
+LIST_HEAD(orangefs_superblocks);
 
-DEFINE_SPINLOCK(pvfs2_superblocks_lock);
+DEFINE_SPINLOCK(orangefs_superblocks_lock);
 
 enum {
 	Opt_intr,
@@ -37,7 +37,7 @@ static const match_table_t tokens = {
 static int parse_mount_options(struct super_block *sb, char *options,
 		int silent)
 {
-	struct pvfs2_sb_info_s *pvfs2_sb = PVFS2_SB(sb);
+	struct orangefs_sb_info_s *orangefs_sb = ORANGEFS_SB(sb);
 	substring_t args[MAX_OPT_ARGS];
 	char *p;
 
@@ -46,8 +46,8 @@ static int parse_mount_options(struct super_block *sb, char *options,
 	 * to zero, ie, initialize to unset.
 	 */
 	sb->s_flags &= ~MS_POSIXACL;
-	pvfs2_sb->flags &= ~PVFS2_OPT_INTR;
-	pvfs2_sb->flags &= ~PVFS2_OPT_LOCAL_LOCK;
+	orangefs_sb->flags &= ~ORANGEFS_OPT_INTR;
+	orangefs_sb->flags &= ~ORANGEFS_OPT_LOCAL_LOCK;
 
 	while ((p = strsep(&options, ",")) != NULL) {
 		int token;
@@ -61,10 +61,10 @@ static int parse_mount_options(struct super_block *sb, char *options,
 			sb->s_flags |= MS_POSIXACL;
 			break;
 		case Opt_intr:
-			pvfs2_sb->flags |= PVFS2_OPT_INTR;
+			orangefs_sb->flags |= ORANGEFS_OPT_INTR;
 			break;
 		case Opt_local_lock:
-			pvfs2_sb->flags |= PVFS2_OPT_LOCAL_LOCK;
+			orangefs_sb->flags |= ORANGEFS_OPT_LOCAL_LOCK;
 			break;
 		default:
 			goto fail;
@@ -78,24 +78,24 @@ static int parse_mount_options(struct super_block *sb, char *options,
 	return -EINVAL;
 }
 
-static void pvfs2_inode_cache_ctor(void *req)
+static void orangefs_inode_cache_ctor(void *req)
 {
-	struct pvfs2_inode_s *pvfs2_inode = req;
+	struct orangefs_inode_s *orangefs_inode = req;
 
-	inode_init_once(&pvfs2_inode->vfs_inode);
-	init_rwsem(&pvfs2_inode->xattr_sem);
+	inode_init_once(&orangefs_inode->vfs_inode);
+	init_rwsem(&orangefs_inode->xattr_sem);
 
-	pvfs2_inode->vfs_inode.i_version = 1;
+	orangefs_inode->vfs_inode.i_version = 1;
 }
 
-static struct inode *pvfs2_alloc_inode(struct super_block *sb)
+static struct inode *orangefs_alloc_inode(struct super_block *sb)
 {
-	struct pvfs2_inode_s *pvfs2_inode;
+	struct orangefs_inode_s *orangefs_inode;
 
-	pvfs2_inode = kmem_cache_alloc(pvfs2_inode_cache,
-				       PVFS2_CACHE_ALLOC_FLAGS);
-	if (pvfs2_inode == NULL) {
-		gossip_err("Failed to allocate pvfs2_inode\n");
+	orangefs_inode = kmem_cache_alloc(orangefs_inode_cache,
+				       ORANGEFS_CACHE_ALLOC_FLAGS);
+	if (orangefs_inode == NULL) {
+		gossip_err("Failed to allocate orangefs_inode\n");
 		return NULL;
 	}
 
@@ -103,71 +103,71 @@ static struct inode *pvfs2_alloc_inode(struct super_block *sb)
 	 * We want to clear everything except for rw_semaphore and the
 	 * vfs_inode.
 	 */
-	memset(&pvfs2_inode->refn.khandle, 0, 16);
-	pvfs2_inode->refn.fs_id = PVFS_FS_ID_NULL;
-	pvfs2_inode->last_failed_block_index_read = 0;
-	memset(pvfs2_inode->link_target, 0, sizeof(pvfs2_inode->link_target));
-	pvfs2_inode->pinode_flags = 0;
+	memset(&orangefs_inode->refn.khandle, 0, 16);
+	orangefs_inode->refn.fs_id = ORANGEFS_FS_ID_NULL;
+	orangefs_inode->last_failed_block_index_read = 0;
+	memset(orangefs_inode->link_target, 0, sizeof(orangefs_inode->link_target));
+	orangefs_inode->pinode_flags = 0;
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "pvfs2_alloc_inode: allocated %p\n",
-		     &pvfs2_inode->vfs_inode);
-	return &pvfs2_inode->vfs_inode;
+		     "orangefs_alloc_inode: allocated %p\n",
+		     &orangefs_inode->vfs_inode);
+	return &orangefs_inode->vfs_inode;
 }
 
-static void pvfs2_destroy_inode(struct inode *inode)
+static void orangefs_destroy_inode(struct inode *inode)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
 			"%s: deallocated %p destroying inode %pU\n",
-			__func__, pvfs2_inode, get_khandle_from_ino(inode));
+			__func__, orangefs_inode, get_khandle_from_ino(inode));
 
-	kmem_cache_free(pvfs2_inode_cache, pvfs2_inode);
+	kmem_cache_free(orangefs_inode_cache, orangefs_inode);
 }
 
 /*
  * NOTE: information filled in here is typically reflected in the
  * output of the system command 'df'
 */
-static int pvfs2_statfs(struct dentry *dentry, struct kstatfs *buf)
+static int orangefs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	int ret = -ENOMEM;
-	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct orangefs_kernel_op_s *new_op = NULL;
 	int flags = 0;
 	struct super_block *sb = NULL;
 
 	sb = dentry->d_sb;
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "pvfs2_statfs: called on sb %p (fs_id is %d)\n",
+		     "orangefs_statfs: called on sb %p (fs_id is %d)\n",
 		     sb,
-		     (int)(PVFS2_SB(sb)->fs_id));
+		     (int)(ORANGEFS_SB(sb)->fs_id));
 
-	new_op = op_alloc(PVFS2_VFS_OP_STATFS);
+	new_op = op_alloc(ORANGEFS_VFS_OP_STATFS);
 	if (!new_op)
 		return ret;
-	new_op->upcall.req.statfs.fs_id = PVFS2_SB(sb)->fs_id;
+	new_op->upcall.req.statfs.fs_id = ORANGEFS_SB(sb)->fs_id;
 
-	if (PVFS2_SB(sb)->flags & PVFS2_OPT_INTR)
-		flags = PVFS2_OP_INTERRUPTIBLE;
+	if (ORANGEFS_SB(sb)->flags & ORANGEFS_OPT_INTR)
+		flags = ORANGEFS_OP_INTERRUPTIBLE;
 
-	ret = service_operation(new_op, "pvfs2_statfs", flags);
+	ret = service_operation(new_op, "orangefs_statfs", flags);
 
 	if (new_op->downcall.status < 0)
 		goto out_op_release;
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "pvfs2_statfs: got %ld blocks available | "
+		     "orangefs_statfs: got %ld blocks available | "
 		     "%ld blocks total | %ld block size\n",
 		     (long)new_op->downcall.resp.statfs.blocks_avail,
 		     (long)new_op->downcall.resp.statfs.blocks_total,
 		     (long)new_op->downcall.resp.statfs.block_size);
 
 	buf->f_type = sb->s_magic;
-	memcpy(&buf->f_fsid, &PVFS2_SB(sb)->fs_id, sizeof(buf->f_fsid));
+	memcpy(&buf->f_fsid, &ORANGEFS_SB(sb)->fs_id, sizeof(buf->f_fsid));
 	buf->f_bsize = new_op->downcall.resp.statfs.block_size;
-	buf->f_namelen = PVFS2_NAME_LEN;
+	buf->f_namelen = ORANGEFS_NAME_LEN;
 
 	buf->f_blocks = (sector_t) new_op->downcall.resp.statfs.blocks_total;
 	buf->f_bfree = (sector_t) new_op->downcall.resp.statfs.blocks_avail;
@@ -178,7 +178,7 @@ static int pvfs2_statfs(struct dentry *dentry, struct kstatfs *buf)
 
 out_op_release:
 	op_release(new_op);
-	gossip_debug(GOSSIP_SUPER_DEBUG, "pvfs2_statfs: returning %d\n", ret);
+	gossip_debug(GOSSIP_SUPER_DEBUG, "orangefs_statfs: returning %d\n", ret);
 	return ret;
 }
 
@@ -186,9 +186,9 @@ static int pvfs2_statfs(struct dentry *dentry, struct kstatfs *buf)
  * Remount as initiated by VFS layer.  We just need to reparse the mount
  * options, no need to signal pvfs2-client-core about it.
  */
-static int pvfs2_remount_fs(struct super_block *sb, int *flags, char *data)
+static int orangefs_remount_fs(struct super_block *sb, int *flags, char *data)
 {
-	gossip_debug(GOSSIP_SUPER_DEBUG, "pvfs2_remount_fs: called\n");
+	gossip_debug(GOSSIP_SUPER_DEBUG, "orangefs_remount_fs: called\n");
 	return parse_mount_options(sb, data, 1);
 }
 
@@ -207,33 +207,33 @@ static int pvfs2_remount_fs(struct super_block *sb, int *flags, char *data)
  * the client regains all of the mount information from us.
  * NOTE: this function assumes that the request_mutex is already acquired!
  */
-int pvfs2_remount(struct super_block *sb)
+int orangefs_remount(struct super_block *sb)
 {
-	struct pvfs2_kernel_op_s *new_op;
+	struct orangefs_kernel_op_s *new_op;
 	int ret = -EINVAL;
 
-	gossip_debug(GOSSIP_SUPER_DEBUG, "pvfs2_remount: called\n");
+	gossip_debug(GOSSIP_SUPER_DEBUG, "orangefs_remount: called\n");
 
-	new_op = op_alloc(PVFS2_VFS_OP_FS_MOUNT);
+	new_op = op_alloc(ORANGEFS_VFS_OP_FS_MOUNT);
 	if (!new_op)
 		return -ENOMEM;
-	strncpy(new_op->upcall.req.fs_mount.pvfs2_config_server,
-		PVFS2_SB(sb)->devname,
-		PVFS_MAX_SERVER_ADDR_LEN);
+	strncpy(new_op->upcall.req.fs_mount.orangefs_config_server,
+		ORANGEFS_SB(sb)->devname,
+		ORANGEFS_MAX_SERVER_ADDR_LEN);
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "Attempting PVFS2 Remount via host %s\n",
-		     new_op->upcall.req.fs_mount.pvfs2_config_server);
+		     "Attempting ORANGEFS Remount via host %s\n",
+		     new_op->upcall.req.fs_mount.orangefs_config_server);
 
 	/*
 	 * we assume that the calling function has already acquire the
 	 * request_mutex to prevent other operations from bypassing
 	 * this one
 	 */
-	ret = service_operation(new_op, "pvfs2_remount",
-		PVFS2_OP_PRIORITY | PVFS2_OP_NO_SEMAPHORE);
+	ret = service_operation(new_op, "orangefs_remount",
+		ORANGEFS_OP_PRIORITY | ORANGEFS_OP_NO_SEMAPHORE);
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "pvfs2_remount: mount got return value of %d\n",
+		     "orangefs_remount: mount got return value of %d\n",
 		     ret);
 	if (ret == 0) {
 		/*
@@ -241,8 +241,8 @@ int pvfs2_remount(struct super_block *sb)
 		 * short-lived mapping that the system interface uses
 		 * to map this superblock to a particular mount entry
 		 */
-		PVFS2_SB(sb)->id = new_op->downcall.resp.fs_mount.id;
-		PVFS2_SB(sb)->mount_pending = 0;
+		ORANGEFS_SB(sb)->id = new_op->downcall.resp.fs_mount.id;
+		ORANGEFS_SB(sb)->mount_pending = 0;
 	}
 
 	op_release(new_op);
@@ -259,54 +259,54 @@ void fsid_key_table_finalize(void)
 }
 
 /* Called whenever the VFS dirties the inode in response to atime updates */
-static void pvfs2_dirty_inode(struct inode *inode, int flags)
+static void orangefs_dirty_inode(struct inode *inode, int flags)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "pvfs2_dirty_inode: %pU\n",
+		     "orangefs_dirty_inode: %pU\n",
 		     get_khandle_from_ino(inode));
-	SetAtimeFlag(pvfs2_inode);
+	SetAtimeFlag(orangefs_inode);
 }
 
-static const struct super_operations pvfs2_s_ops = {
-	.alloc_inode = pvfs2_alloc_inode,
-	.destroy_inode = pvfs2_destroy_inode,
-	.dirty_inode = pvfs2_dirty_inode,
+static const struct super_operations orangefs_s_ops = {
+	.alloc_inode = orangefs_alloc_inode,
+	.destroy_inode = orangefs_destroy_inode,
+	.dirty_inode = orangefs_dirty_inode,
 	.drop_inode = generic_delete_inode,
-	.statfs = pvfs2_statfs,
-	.remount_fs = pvfs2_remount_fs,
+	.statfs = orangefs_statfs,
+	.remount_fs = orangefs_remount_fs,
 	.show_options = generic_show_options,
 };
 
-static struct dentry *pvfs2_fh_to_dentry(struct super_block *sb,
+static struct dentry *orangefs_fh_to_dentry(struct super_block *sb,
 				  struct fid *fid,
 				  int fh_len,
 				  int fh_type)
 {
-	struct pvfs2_object_kref refn;
+	struct orangefs_object_kref refn;
 
 	if (fh_len < 5 || fh_type > 2)
 		return NULL;
 
-	PVFS_khandle_from(&(refn.khandle), fid->raw, 16);
+	ORANGEFS_khandle_from(&(refn.khandle), fid->raw, 16);
 	refn.fs_id = (u32) fid->raw[4];
 	gossip_debug(GOSSIP_SUPER_DEBUG,
 		     "fh_to_dentry: handle %pU, fs_id %d\n",
 		     &refn.khandle,
 		     refn.fs_id);
 
-	return d_obtain_alias(pvfs2_iget(sb, &refn));
+	return d_obtain_alias(orangefs_iget(sb, &refn));
 }
 
-static int pvfs2_encode_fh(struct inode *inode,
+static int orangefs_encode_fh(struct inode *inode,
 		    __u32 *fh,
 		    int *max_len,
 		    struct inode *parent)
 {
 	int len = parent ? 10 : 5;
 	int type = 1;
-	struct pvfs2_object_kref refn;
+	struct orangefs_object_kref refn;
 
 	if (*max_len < len) {
 		gossip_lerr("fh buffer is too small for encoding\n");
@@ -315,8 +315,8 @@ static int pvfs2_encode_fh(struct inode *inode,
 		goto out;
 	}
 
-	refn = PVFS2_I(inode)->refn;
-	PVFS_khandle_to(&refn.khandle, fh, 16);
+	refn = ORANGEFS_I(inode)->refn;
+	ORANGEFS_khandle_to(&refn.khandle, fh, 16);
 	fh[4] = refn.fs_id;
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
@@ -326,8 +326,8 @@ static int pvfs2_encode_fh(struct inode *inode,
 
 
 	if (parent) {
-		refn = PVFS2_I(parent)->refn;
-		PVFS_khandle_to(&refn.khandle, (char *) fh + 20, 16);
+		refn = ORANGEFS_I(parent)->refn;
+		ORANGEFS_khandle_to(&refn.khandle, (char *) fh + 20, 16);
 		fh[9] = refn.fs_id;
 
 		type = 2;
@@ -342,30 +342,30 @@ static int pvfs2_encode_fh(struct inode *inode,
 	return type;
 }
 
-static struct export_operations pvfs2_export_ops = {
-	.encode_fh = pvfs2_encode_fh,
-	.fh_to_dentry = pvfs2_fh_to_dentry,
+static struct export_operations orangefs_export_ops = {
+	.encode_fh = orangefs_encode_fh,
+	.fh_to_dentry = orangefs_fh_to_dentry,
 };
 
-static int pvfs2_fill_sb(struct super_block *sb,
-		struct pvfs2_fs_mount_response *fs_mount,
+static int orangefs_fill_sb(struct super_block *sb,
+		struct orangefs_fs_mount_response *fs_mount,
 		void *data, int silent)
 {
 	int ret = -EINVAL;
 	struct inode *root = NULL;
 	struct dentry *root_dentry = NULL;
-	struct pvfs2_object_kref root_object;
+	struct orangefs_object_kref root_object;
 
-	/* alloc and init our private pvfs2 sb info */
+	/* alloc and init our private orangefs sb info */
 	sb->s_fs_info =
-		kzalloc(sizeof(struct pvfs2_sb_info_s), PVFS2_GFP_FLAGS);
-	if (!PVFS2_SB(sb))
+		kzalloc(sizeof(struct orangefs_sb_info_s), ORANGEFS_GFP_FLAGS);
+	if (!ORANGEFS_SB(sb))
 		return -ENOMEM;
-	PVFS2_SB(sb)->sb = sb;
+	ORANGEFS_SB(sb)->sb = sb;
 
-	PVFS2_SB(sb)->root_khandle = fs_mount->root_khandle;
-	PVFS2_SB(sb)->fs_id = fs_mount->fs_id;
-	PVFS2_SB(sb)->id = fs_mount->id;
+	ORANGEFS_SB(sb)->root_khandle = fs_mount->root_khandle;
+	ORANGEFS_SB(sb)->fs_id = fs_mount->fs_id;
+	ORANGEFS_SB(sb)->id = fs_mount->id;
 
 	if (data) {
 		ret = parse_mount_options(sb, data, silent);
@@ -374,23 +374,23 @@ static int pvfs2_fill_sb(struct super_block *sb,
 	}
 
 	/* Hang the xattr handlers off the superblock */
-	sb->s_xattr = pvfs2_xattr_handlers;
-	sb->s_magic = PVFS2_SUPER_MAGIC;
-	sb->s_op = &pvfs2_s_ops;
-	sb->s_d_op = &pvfs2_dentry_operations;
+	sb->s_xattr = orangefs_xattr_handlers;
+	sb->s_magic = ORANGEFS_SUPER_MAGIC;
+	sb->s_op = &orangefs_s_ops;
+	sb->s_d_op = &orangefs_dentry_operations;
 
-	sb->s_blocksize = pvfs_bufmap_size_query();
-	sb->s_blocksize_bits = pvfs_bufmap_shift_query();
+	sb->s_blocksize = orangefs_bufmap_size_query();
+	sb->s_blocksize_bits = orangefs_bufmap_shift_query();
 	sb->s_maxbytes = MAX_LFS_FILESIZE;
 
-	root_object.khandle = PVFS2_SB(sb)->root_khandle;
-	root_object.fs_id = PVFS2_SB(sb)->fs_id;
+	root_object.khandle = ORANGEFS_SB(sb)->root_khandle;
+	root_object.fs_id = ORANGEFS_SB(sb)->fs_id;
 	gossip_debug(GOSSIP_SUPER_DEBUG,
 		     "get inode %pU, fsid %d\n",
 		     &root_object.khandle,
 		     root_object.fs_id);
 
-	root = pvfs2_iget(sb, &root_object);
+	root = orangefs_iget(sb, &root_object);
 	if (IS_ERR(root))
 		return PTR_ERR(root);
 
@@ -404,23 +404,23 @@ static int pvfs2_fill_sb(struct super_block *sb,
 	if (!root_dentry)
 		return -ENOMEM;
 
-	sb->s_export_op = &pvfs2_export_ops;
+	sb->s_export_op = &orangefs_export_ops;
 	sb->s_root = root_dentry;
 	return 0;
 }
 
-struct dentry *pvfs2_mount(struct file_system_type *fst,
+struct dentry *orangefs_mount(struct file_system_type *fst,
 			   int flags,
 			   const char *devname,
 			   void *data)
 {
 	int ret = -EINVAL;
 	struct super_block *sb = ERR_PTR(-EINVAL);
-	struct pvfs2_kernel_op_s *new_op;
+	struct orangefs_kernel_op_s *new_op;
 	struct dentry *d = ERR_PTR(-EINVAL);
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "pvfs2_mount: called with devname %s\n",
+		     "orangefs_mount: called with devname %s\n",
 		     devname);
 
 	if (!devname) {
@@ -428,25 +428,25 @@ struct dentry *pvfs2_mount(struct file_system_type *fst,
 		return ERR_PTR(-EINVAL);
 	}
 
-	new_op = op_alloc(PVFS2_VFS_OP_FS_MOUNT);
+	new_op = op_alloc(ORANGEFS_VFS_OP_FS_MOUNT);
 	if (!new_op)
 		return ERR_PTR(-ENOMEM);
 
-	strncpy(new_op->upcall.req.fs_mount.pvfs2_config_server,
+	strncpy(new_op->upcall.req.fs_mount.orangefs_config_server,
 		devname,
-		PVFS_MAX_SERVER_ADDR_LEN);
+		ORANGEFS_MAX_SERVER_ADDR_LEN);
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "Attempting PVFS2 Mount via host %s\n",
-		     new_op->upcall.req.fs_mount.pvfs2_config_server);
+		     "Attempting ORANGEFS Mount via host %s\n",
+		     new_op->upcall.req.fs_mount.orangefs_config_server);
 
-	ret = service_operation(new_op, "pvfs2_mount", 0);
+	ret = service_operation(new_op, "orangefs_mount", 0);
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "pvfs2_mount: mount got return value of %d\n", ret);
+		     "orangefs_mount: mount got return value of %d\n", ret);
 	if (ret)
 		goto free_op;
 
-	if (new_op->downcall.resp.fs_mount.fs_id == PVFS_FS_ID_NULL) {
+	if (new_op->downcall.resp.fs_mount.fs_id == ORANGEFS_FS_ID_NULL) {
 		gossip_err("ERROR: Retrieved null fs_id\n");
 		ret = -EINVAL;
 		goto free_op;
@@ -459,7 +459,7 @@ struct dentry *pvfs2_mount(struct file_system_type *fst,
 		goto free_op;
 	}
 
-	ret = pvfs2_fill_sb(sb,
+	ret = orangefs_fill_sb(sb,
 	      &new_op->downcall.resp.fs_mount, data,
 	      flags & MS_SILENT ? 1 : 0);
 
@@ -472,25 +472,25 @@ struct dentry *pvfs2_mount(struct file_system_type *fst,
 	 * on successful mount, store the devname and data
 	 * used
 	 */
-	strncpy(PVFS2_SB(sb)->devname,
+	strncpy(ORANGEFS_SB(sb)->devname,
 		devname,
-		PVFS_MAX_SERVER_ADDR_LEN);
+		ORANGEFS_MAX_SERVER_ADDR_LEN);
 
 	/* mount_pending must be cleared */
-	PVFS2_SB(sb)->mount_pending = 0;
+	ORANGEFS_SB(sb)->mount_pending = 0;
 
 	/*
-	 * finally, add this sb to our list of known pvfs2
+	 * finally, add this sb to our list of known orangefs
 	 * sb's
 	 */
-	add_pvfs2_sb(sb);
+	add_orangefs_sb(sb);
 	op_release(new_op);
 	return dget(sb->s_root);
 
 free_op:
-	gossip_err("pvfs2_mount: mount request failed with %d\n", ret);
+	gossip_err("orangefs_mount: mount request failed with %d\n", ret);
 	if (ret == -EINVAL) {
-		gossip_err("Ensure that all pvfs2-servers have the same FS configuration files\n");
+		gossip_err("Ensure that all orangefs-servers have the same FS configuration files\n");
 		gossip_err("Look at pvfs2-client-core log file (typically /tmp/pvfs2-client.log) for more details\n");
 	}
 
@@ -499,43 +499,43 @@ struct dentry *pvfs2_mount(struct file_system_type *fst,
 	return d;
 }
 
-void pvfs2_kill_sb(struct super_block *sb)
+void orangefs_kill_sb(struct super_block *sb)
 {
-	gossip_debug(GOSSIP_SUPER_DEBUG, "pvfs2_kill_sb: called\n");
+	gossip_debug(GOSSIP_SUPER_DEBUG, "orangefs_kill_sb: called\n");
 
 	/*
 	 * issue the unmount to userspace to tell it to remove the
 	 * dynamic mount info it has for this superblock
 	 */
-	pvfs2_unmount_sb(sb);
+	orangefs_unmount_sb(sb);
 
-	/* remove the sb from our list of pvfs2 specific sb's */
-	remove_pvfs2_sb(sb);
+	/* remove the sb from our list of orangefs specific sb's */
+	remove_orangefs_sb(sb);
 
 	/* provided sb cleanup */
 	kill_anon_super(sb);
 
-	/* free the pvfs2 superblock private data */
-	kfree(PVFS2_SB(sb));
+	/* free the orangefs superblock private data */
+	kfree(ORANGEFS_SB(sb));
 }
 
-int pvfs2_inode_cache_initialize(void)
+int orangefs_inode_cache_initialize(void)
 {
-	pvfs2_inode_cache = kmem_cache_create("pvfs2_inode_cache",
-					      sizeof(struct pvfs2_inode_s),
+	orangefs_inode_cache = kmem_cache_create("orangefs_inode_cache",
+					      sizeof(struct orangefs_inode_s),
 					      0,
-					      PVFS2_CACHE_CREATE_FLAGS,
-					      pvfs2_inode_cache_ctor);
+					      ORANGEFS_CACHE_CREATE_FLAGS,
+					      orangefs_inode_cache_ctor);
 
-	if (!pvfs2_inode_cache) {
-		gossip_err("Cannot create pvfs2_inode_cache\n");
+	if (!orangefs_inode_cache) {
+		gossip_err("Cannot create orangefs_inode_cache\n");
 		return -ENOMEM;
 	}
 	return 0;
 }
 
-int pvfs2_inode_cache_finalize(void)
+int orangefs_inode_cache_finalize(void)
 {
-	kmem_cache_destroy(pvfs2_inode_cache);
+	kmem_cache_destroy(orangefs_inode_cache);
 	return 0;
 }

commit 75992b0fa95a667d8f436962ea6a694fe992c001
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 8 20:27:40 2015 -0400

    pvfs2_fill_sb(): use kzalloc()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index f29e7cccdfd1..45db0772a767 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -358,10 +358,9 @@ static int pvfs2_fill_sb(struct super_block *sb,
 
 	/* alloc and init our private pvfs2 sb info */
 	sb->s_fs_info =
-		kmalloc(sizeof(struct pvfs2_sb_info_s), PVFS2_GFP_FLAGS);
+		kzalloc(sizeof(struct pvfs2_sb_info_s), PVFS2_GFP_FLAGS);
 	if (!PVFS2_SB(sb))
 		return -ENOMEM;
-	memset(sb->s_fs_info, 0, sizeof(struct pvfs2_sb_info_s));
 	PVFS2_SB(sb)->sb = sb;
 
 	PVFS2_SB(sb)->root_khandle = fs_mount->root_khandle;

commit 5c0dbbc64b25fde6a4e29c545ac2296fc5194b3f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 8 20:22:43 2015 -0400

    orangefs: kill struct pvfs2_mount_sb_info_s
    
    The only reason for that thing used to be the API of mount_nodev()
    callback;  since we are calling pvfs2_fill_sb() ourselves now,
    we don't have to shove everything into a single structure.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 833af68c2227..f29e7cccdfd1 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -347,13 +347,13 @@ static struct export_operations pvfs2_export_ops = {
 	.fh_to_dentry = pvfs2_fh_to_dentry,
 };
 
-static int pvfs2_fill_sb(struct super_block *sb, void *data, int silent)
+static int pvfs2_fill_sb(struct super_block *sb,
+		struct pvfs2_fs_mount_response *fs_mount,
+		void *data, int silent)
 {
 	int ret = -EINVAL;
 	struct inode *root = NULL;
 	struct dentry *root_dentry = NULL;
-	struct pvfs2_mount_sb_info_s *mount_sb_info =
-		(struct pvfs2_mount_sb_info_s *) data;
 	struct pvfs2_object_kref root_object;
 
 	/* alloc and init our private pvfs2 sb info */
@@ -364,13 +364,12 @@ static int pvfs2_fill_sb(struct super_block *sb, void *data, int silent)
 	memset(sb->s_fs_info, 0, sizeof(struct pvfs2_sb_info_s));
 	PVFS2_SB(sb)->sb = sb;
 
-	PVFS2_SB(sb)->root_khandle = mount_sb_info->root_khandle;
-	PVFS2_SB(sb)->fs_id = mount_sb_info->fs_id;
-	PVFS2_SB(sb)->id = mount_sb_info->id;
+	PVFS2_SB(sb)->root_khandle = fs_mount->root_khandle;
+	PVFS2_SB(sb)->fs_id = fs_mount->fs_id;
+	PVFS2_SB(sb)->id = fs_mount->id;
 
-	if (mount_sb_info->data) {
-		ret = parse_mount_options(sb, mount_sb_info->data,
-					  silent);
+	if (data) {
+		ret = parse_mount_options(sb, data, silent);
 		if (ret)
 			return ret;
 	}
@@ -419,7 +418,6 @@ struct dentry *pvfs2_mount(struct file_system_type *fst,
 	int ret = -EINVAL;
 	struct super_block *sb = ERR_PTR(-EINVAL);
 	struct pvfs2_kernel_op_s *new_op;
-	struct pvfs2_mount_sb_info_s mount_sb_info;
 	struct dentry *d = ERR_PTR(-EINVAL);
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
@@ -455,13 +453,6 @@ struct dentry *pvfs2_mount(struct file_system_type *fst,
 		goto free_op;
 	}
 
-	/* fill in temporary structure passed to fill_sb method */
-	mount_sb_info.data = data;
-	mount_sb_info.root_khandle =
-		new_op->downcall.resp.fs_mount.root_khandle;
-	mount_sb_info.fs_id = new_op->downcall.resp.fs_mount.fs_id;
-	mount_sb_info.id = new_op->downcall.resp.fs_mount.id;
-
 	sb = sget(fst, NULL, set_anon_super, flags, NULL);
 
 	if (IS_ERR(sb)) {
@@ -470,7 +461,7 @@ struct dentry *pvfs2_mount(struct file_system_type *fst,
 	}
 
 	ret = pvfs2_fill_sb(sb,
-	      (void *)&mount_sb_info,
+	      &new_op->downcall.resp.fs_mount, data,
 	      flags & MS_SILENT ? 1 : 0);
 
 	if (ret) {

commit b05a7851095c24ff62d5ffeb81baeffe7acd26a2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 8 20:18:00 2015 -0400

    orangefs: double iput() in case of d_make_root() failure
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 9dee95293599..833af68c2227 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -403,10 +403,8 @@ static int pvfs2_fill_sb(struct super_block *sb, void *data, int silent)
 
 	/* allocates and places root dentry in dcache */
 	root_dentry = d_make_root(root);
-	if (!root_dentry) {
-		iput(root);
+	if (!root_dentry)
 		return -ENOMEM;
-	}
 
 	sb->s_export_op = &pvfs2_export_ops;
 	sb->s_root = root_dentry;

commit 1be21f865aa5a94b178bf22e749567001cf5ef9b
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Tue Sep 29 15:26:37 2015 -0400

    Orangefs: don't use mount_nodev, use sget directly.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 90c7a1c9f201..9dee95293599 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -422,7 +422,7 @@ struct dentry *pvfs2_mount(struct file_system_type *fst,
 	struct super_block *sb = ERR_PTR(-EINVAL);
 	struct pvfs2_kernel_op_s *new_op;
 	struct pvfs2_mount_sb_info_s mount_sb_info;
-	struct dentry *mnt_sb_d = ERR_PTR(-EINVAL);
+	struct dentry *d = ERR_PTR(-EINVAL);
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
 		     "pvfs2_mount: called with devname %s\n",
@@ -464,23 +464,21 @@ struct dentry *pvfs2_mount(struct file_system_type *fst,
 	mount_sb_info.fs_id = new_op->downcall.resp.fs_mount.fs_id;
 	mount_sb_info.id = new_op->downcall.resp.fs_mount.id;
 
-	/*
-	 * the mount_sb_info structure looks odd, but it's used because
-	 * the private sb info isn't allocated until we call
-	 * pvfs2_fill_sb, yet we have the info we need to fill it with
-	 * here.  so we store it temporarily and pass all of the info
-	 * to fill_sb where it's properly copied out
-	 */
-	mnt_sb_d = mount_nodev(fst,
-			       flags,
-			       (void *)&mount_sb_info,
-			       pvfs2_fill_sb);
-	if (IS_ERR(mnt_sb_d)) {
-		sb = ERR_CAST(mnt_sb_d);
+	sb = sget(fst, NULL, set_anon_super, flags, NULL);
+
+	if (IS_ERR(sb)) {
+		d = ERR_CAST(sb);
 		goto free_op;
 	}
 
-	sb = mnt_sb_d->d_sb;
+	ret = pvfs2_fill_sb(sb,
+	      (void *)&mount_sb_info,
+	      flags & MS_SILENT ? 1 : 0);
+
+	if (ret) {
+		d = ERR_PTR(ret);
+		goto free_op;
+	}
 
 	/*
 	 * on successful mount, store the devname and data
@@ -499,7 +497,7 @@ struct dentry *pvfs2_mount(struct file_system_type *fst,
 	 */
 	add_pvfs2_sb(sb);
 	op_release(new_op);
-	return mnt_sb_d;
+	return dget(sb->s_root);
 
 free_op:
 	gossip_err("pvfs2_mount: mount request failed with %d\n", ret);
@@ -510,10 +508,7 @@ struct dentry *pvfs2_mount(struct file_system_type *fst,
 
 	op_release(new_op);
 
-	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "pvfs2_mount: returning dentry %p\n",
-		     mnt_sb_d);
-	return mnt_sb_d;
+	return d;
 }
 
 void pvfs2_kill_sb(struct super_block *sb)

commit 84d02150dea7571dc32176e35d65eecde82631a9
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Tue Jul 28 13:27:51 2015 -0400

    Orangefs: sooth most sparse complaints
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index a854390fc0ea..90c7a1c9f201 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -269,7 +269,7 @@ static void pvfs2_dirty_inode(struct inode *inode, int flags)
 	SetAtimeFlag(pvfs2_inode);
 }
 
-struct super_operations pvfs2_s_ops = {
+static const struct super_operations pvfs2_s_ops = {
 	.alloc_inode = pvfs2_alloc_inode,
 	.destroy_inode = pvfs2_destroy_inode,
 	.dirty_inode = pvfs2_dirty_inode,
@@ -279,7 +279,7 @@ struct super_operations pvfs2_s_ops = {
 	.show_options = generic_show_options,
 };
 
-struct dentry *pvfs2_fh_to_dentry(struct super_block *sb,
+static struct dentry *pvfs2_fh_to_dentry(struct super_block *sb,
 				  struct fid *fid,
 				  int fh_len,
 				  int fh_type)
@@ -299,7 +299,7 @@ struct dentry *pvfs2_fh_to_dentry(struct super_block *sb,
 	return d_obtain_alias(pvfs2_iget(sb, &refn));
 }
 
-int pvfs2_encode_fh(struct inode *inode,
+static int pvfs2_encode_fh(struct inode *inode,
 		    __u32 *fh,
 		    int *max_len,
 		    struct inode *parent)
@@ -347,7 +347,7 @@ static struct export_operations pvfs2_export_ops = {
 	.fh_to_dentry = pvfs2_fh_to_dentry,
 };
 
-int pvfs2_fill_sb(struct super_block *sb, void *data, int silent)
+static int pvfs2_fill_sb(struct super_block *sb, void *data, int silent)
 {
 	int ret = -EINVAL;
 	struct inode *root = NULL;

commit 1182fca3bc00441d5b2dee2f0548a3b7f978f9e7
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Jul 17 10:38:15 2015 -0400

    Orangefs: kernel client part 5
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
new file mode 100644
index 000000000000..a854390fc0ea
--- /dev/null
+++ b/fs/orangefs/super.c
@@ -0,0 +1,558 @@
+/*
+ * (C) 2001 Clemson University and The University of Chicago
+ *
+ * See COPYING in top-level directory.
+ */
+
+#include "protocol.h"
+#include "pvfs2-kernel.h"
+#include "pvfs2-bufmap.h"
+
+#include <linux/parser.h>
+
+/* a cache for pvfs2-inode objects (i.e. pvfs2 inode private data) */
+static struct kmem_cache *pvfs2_inode_cache;
+
+/* list for storing pvfs2 specific superblocks in use */
+LIST_HEAD(pvfs2_superblocks);
+
+DEFINE_SPINLOCK(pvfs2_superblocks_lock);
+
+enum {
+	Opt_intr,
+	Opt_acl,
+	Opt_local_lock,
+
+	Opt_err
+};
+
+static const match_table_t tokens = {
+	{ Opt_acl,		"acl" },
+	{ Opt_intr,		"intr" },
+	{ Opt_local_lock,	"local_lock" },
+	{ Opt_err,	NULL }
+};
+
+
+static int parse_mount_options(struct super_block *sb, char *options,
+		int silent)
+{
+	struct pvfs2_sb_info_s *pvfs2_sb = PVFS2_SB(sb);
+	substring_t args[MAX_OPT_ARGS];
+	char *p;
+
+	/*
+	 * Force any potential flags that might be set from the mount
+	 * to zero, ie, initialize to unset.
+	 */
+	sb->s_flags &= ~MS_POSIXACL;
+	pvfs2_sb->flags &= ~PVFS2_OPT_INTR;
+	pvfs2_sb->flags &= ~PVFS2_OPT_LOCAL_LOCK;
+
+	while ((p = strsep(&options, ",")) != NULL) {
+		int token;
+
+		if (!*p)
+			continue;
+
+		token = match_token(p, tokens, args);
+		switch (token) {
+		case Opt_acl:
+			sb->s_flags |= MS_POSIXACL;
+			break;
+		case Opt_intr:
+			pvfs2_sb->flags |= PVFS2_OPT_INTR;
+			break;
+		case Opt_local_lock:
+			pvfs2_sb->flags |= PVFS2_OPT_LOCAL_LOCK;
+			break;
+		default:
+			goto fail;
+		}
+	}
+
+	return 0;
+fail:
+	if (!silent)
+		gossip_err("Error: mount option [%s] is not supported.\n", p);
+	return -EINVAL;
+}
+
+static void pvfs2_inode_cache_ctor(void *req)
+{
+	struct pvfs2_inode_s *pvfs2_inode = req;
+
+	inode_init_once(&pvfs2_inode->vfs_inode);
+	init_rwsem(&pvfs2_inode->xattr_sem);
+
+	pvfs2_inode->vfs_inode.i_version = 1;
+}
+
+static struct inode *pvfs2_alloc_inode(struct super_block *sb)
+{
+	struct pvfs2_inode_s *pvfs2_inode;
+
+	pvfs2_inode = kmem_cache_alloc(pvfs2_inode_cache,
+				       PVFS2_CACHE_ALLOC_FLAGS);
+	if (pvfs2_inode == NULL) {
+		gossip_err("Failed to allocate pvfs2_inode\n");
+		return NULL;
+	}
+
+	/*
+	 * We want to clear everything except for rw_semaphore and the
+	 * vfs_inode.
+	 */
+	memset(&pvfs2_inode->refn.khandle, 0, 16);
+	pvfs2_inode->refn.fs_id = PVFS_FS_ID_NULL;
+	pvfs2_inode->last_failed_block_index_read = 0;
+	memset(pvfs2_inode->link_target, 0, sizeof(pvfs2_inode->link_target));
+	pvfs2_inode->pinode_flags = 0;
+
+	gossip_debug(GOSSIP_SUPER_DEBUG,
+		     "pvfs2_alloc_inode: allocated %p\n",
+		     &pvfs2_inode->vfs_inode);
+	return &pvfs2_inode->vfs_inode;
+}
+
+static void pvfs2_destroy_inode(struct inode *inode)
+{
+	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+
+	gossip_debug(GOSSIP_SUPER_DEBUG,
+			"%s: deallocated %p destroying inode %pU\n",
+			__func__, pvfs2_inode, get_khandle_from_ino(inode));
+
+	kmem_cache_free(pvfs2_inode_cache, pvfs2_inode);
+}
+
+/*
+ * NOTE: information filled in here is typically reflected in the
+ * output of the system command 'df'
+*/
+static int pvfs2_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	int ret = -ENOMEM;
+	struct pvfs2_kernel_op_s *new_op = NULL;
+	int flags = 0;
+	struct super_block *sb = NULL;
+
+	sb = dentry->d_sb;
+
+	gossip_debug(GOSSIP_SUPER_DEBUG,
+		     "pvfs2_statfs: called on sb %p (fs_id is %d)\n",
+		     sb,
+		     (int)(PVFS2_SB(sb)->fs_id));
+
+	new_op = op_alloc(PVFS2_VFS_OP_STATFS);
+	if (!new_op)
+		return ret;
+	new_op->upcall.req.statfs.fs_id = PVFS2_SB(sb)->fs_id;
+
+	if (PVFS2_SB(sb)->flags & PVFS2_OPT_INTR)
+		flags = PVFS2_OP_INTERRUPTIBLE;
+
+	ret = service_operation(new_op, "pvfs2_statfs", flags);
+
+	if (new_op->downcall.status < 0)
+		goto out_op_release;
+
+	gossip_debug(GOSSIP_SUPER_DEBUG,
+		     "pvfs2_statfs: got %ld blocks available | "
+		     "%ld blocks total | %ld block size\n",
+		     (long)new_op->downcall.resp.statfs.blocks_avail,
+		     (long)new_op->downcall.resp.statfs.blocks_total,
+		     (long)new_op->downcall.resp.statfs.block_size);
+
+	buf->f_type = sb->s_magic;
+	memcpy(&buf->f_fsid, &PVFS2_SB(sb)->fs_id, sizeof(buf->f_fsid));
+	buf->f_bsize = new_op->downcall.resp.statfs.block_size;
+	buf->f_namelen = PVFS2_NAME_LEN;
+
+	buf->f_blocks = (sector_t) new_op->downcall.resp.statfs.blocks_total;
+	buf->f_bfree = (sector_t) new_op->downcall.resp.statfs.blocks_avail;
+	buf->f_bavail = (sector_t) new_op->downcall.resp.statfs.blocks_avail;
+	buf->f_files = (sector_t) new_op->downcall.resp.statfs.files_total;
+	buf->f_ffree = (sector_t) new_op->downcall.resp.statfs.files_avail;
+	buf->f_frsize = sb->s_blocksize;
+
+out_op_release:
+	op_release(new_op);
+	gossip_debug(GOSSIP_SUPER_DEBUG, "pvfs2_statfs: returning %d\n", ret);
+	return ret;
+}
+
+/*
+ * Remount as initiated by VFS layer.  We just need to reparse the mount
+ * options, no need to signal pvfs2-client-core about it.
+ */
+static int pvfs2_remount_fs(struct super_block *sb, int *flags, char *data)
+{
+	gossip_debug(GOSSIP_SUPER_DEBUG, "pvfs2_remount_fs: called\n");
+	return parse_mount_options(sb, data, 1);
+}
+
+/*
+ * Remount as initiated by pvfs2-client-core on restart.  This is used to
+ * repopulate mount information left from previous pvfs2-client-core.
+ *
+ * the idea here is that given a valid superblock, we're
+ * re-initializing the user space client with the initial mount
+ * information specified when the super block was first initialized.
+ * this is very different than the first initialization/creation of a
+ * superblock.  we use the special service_priority_operation to make
+ * sure that the mount gets ahead of any other pending operation that
+ * is waiting for servicing.  this means that the pvfs2-client won't
+ * fail to start several times for all other pending operations before
+ * the client regains all of the mount information from us.
+ * NOTE: this function assumes that the request_mutex is already acquired!
+ */
+int pvfs2_remount(struct super_block *sb)
+{
+	struct pvfs2_kernel_op_s *new_op;
+	int ret = -EINVAL;
+
+	gossip_debug(GOSSIP_SUPER_DEBUG, "pvfs2_remount: called\n");
+
+	new_op = op_alloc(PVFS2_VFS_OP_FS_MOUNT);
+	if (!new_op)
+		return -ENOMEM;
+	strncpy(new_op->upcall.req.fs_mount.pvfs2_config_server,
+		PVFS2_SB(sb)->devname,
+		PVFS_MAX_SERVER_ADDR_LEN);
+
+	gossip_debug(GOSSIP_SUPER_DEBUG,
+		     "Attempting PVFS2 Remount via host %s\n",
+		     new_op->upcall.req.fs_mount.pvfs2_config_server);
+
+	/*
+	 * we assume that the calling function has already acquire the
+	 * request_mutex to prevent other operations from bypassing
+	 * this one
+	 */
+	ret = service_operation(new_op, "pvfs2_remount",
+		PVFS2_OP_PRIORITY | PVFS2_OP_NO_SEMAPHORE);
+	gossip_debug(GOSSIP_SUPER_DEBUG,
+		     "pvfs2_remount: mount got return value of %d\n",
+		     ret);
+	if (ret == 0) {
+		/*
+		 * store the id assigned to this sb -- it's just a
+		 * short-lived mapping that the system interface uses
+		 * to map this superblock to a particular mount entry
+		 */
+		PVFS2_SB(sb)->id = new_op->downcall.resp.fs_mount.id;
+		PVFS2_SB(sb)->mount_pending = 0;
+	}
+
+	op_release(new_op);
+	return ret;
+}
+
+int fsid_key_table_initialize(void)
+{
+	return 0;
+}
+
+void fsid_key_table_finalize(void)
+{
+}
+
+/* Called whenever the VFS dirties the inode in response to atime updates */
+static void pvfs2_dirty_inode(struct inode *inode, int flags)
+{
+	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+
+	gossip_debug(GOSSIP_SUPER_DEBUG,
+		     "pvfs2_dirty_inode: %pU\n",
+		     get_khandle_from_ino(inode));
+	SetAtimeFlag(pvfs2_inode);
+}
+
+struct super_operations pvfs2_s_ops = {
+	.alloc_inode = pvfs2_alloc_inode,
+	.destroy_inode = pvfs2_destroy_inode,
+	.dirty_inode = pvfs2_dirty_inode,
+	.drop_inode = generic_delete_inode,
+	.statfs = pvfs2_statfs,
+	.remount_fs = pvfs2_remount_fs,
+	.show_options = generic_show_options,
+};
+
+struct dentry *pvfs2_fh_to_dentry(struct super_block *sb,
+				  struct fid *fid,
+				  int fh_len,
+				  int fh_type)
+{
+	struct pvfs2_object_kref refn;
+
+	if (fh_len < 5 || fh_type > 2)
+		return NULL;
+
+	PVFS_khandle_from(&(refn.khandle), fid->raw, 16);
+	refn.fs_id = (u32) fid->raw[4];
+	gossip_debug(GOSSIP_SUPER_DEBUG,
+		     "fh_to_dentry: handle %pU, fs_id %d\n",
+		     &refn.khandle,
+		     refn.fs_id);
+
+	return d_obtain_alias(pvfs2_iget(sb, &refn));
+}
+
+int pvfs2_encode_fh(struct inode *inode,
+		    __u32 *fh,
+		    int *max_len,
+		    struct inode *parent)
+{
+	int len = parent ? 10 : 5;
+	int type = 1;
+	struct pvfs2_object_kref refn;
+
+	if (*max_len < len) {
+		gossip_lerr("fh buffer is too small for encoding\n");
+		*max_len = len;
+		type = 255;
+		goto out;
+	}
+
+	refn = PVFS2_I(inode)->refn;
+	PVFS_khandle_to(&refn.khandle, fh, 16);
+	fh[4] = refn.fs_id;
+
+	gossip_debug(GOSSIP_SUPER_DEBUG,
+		     "Encoding fh: handle %pU, fsid %u\n",
+		     &refn.khandle,
+		     refn.fs_id);
+
+
+	if (parent) {
+		refn = PVFS2_I(parent)->refn;
+		PVFS_khandle_to(&refn.khandle, (char *) fh + 20, 16);
+		fh[9] = refn.fs_id;
+
+		type = 2;
+		gossip_debug(GOSSIP_SUPER_DEBUG,
+			     "Encoding parent: handle %pU, fsid %u\n",
+			     &refn.khandle,
+			     refn.fs_id);
+	}
+	*max_len = len;
+
+out:
+	return type;
+}
+
+static struct export_operations pvfs2_export_ops = {
+	.encode_fh = pvfs2_encode_fh,
+	.fh_to_dentry = pvfs2_fh_to_dentry,
+};
+
+int pvfs2_fill_sb(struct super_block *sb, void *data, int silent)
+{
+	int ret = -EINVAL;
+	struct inode *root = NULL;
+	struct dentry *root_dentry = NULL;
+	struct pvfs2_mount_sb_info_s *mount_sb_info =
+		(struct pvfs2_mount_sb_info_s *) data;
+	struct pvfs2_object_kref root_object;
+
+	/* alloc and init our private pvfs2 sb info */
+	sb->s_fs_info =
+		kmalloc(sizeof(struct pvfs2_sb_info_s), PVFS2_GFP_FLAGS);
+	if (!PVFS2_SB(sb))
+		return -ENOMEM;
+	memset(sb->s_fs_info, 0, sizeof(struct pvfs2_sb_info_s));
+	PVFS2_SB(sb)->sb = sb;
+
+	PVFS2_SB(sb)->root_khandle = mount_sb_info->root_khandle;
+	PVFS2_SB(sb)->fs_id = mount_sb_info->fs_id;
+	PVFS2_SB(sb)->id = mount_sb_info->id;
+
+	if (mount_sb_info->data) {
+		ret = parse_mount_options(sb, mount_sb_info->data,
+					  silent);
+		if (ret)
+			return ret;
+	}
+
+	/* Hang the xattr handlers off the superblock */
+	sb->s_xattr = pvfs2_xattr_handlers;
+	sb->s_magic = PVFS2_SUPER_MAGIC;
+	sb->s_op = &pvfs2_s_ops;
+	sb->s_d_op = &pvfs2_dentry_operations;
+
+	sb->s_blocksize = pvfs_bufmap_size_query();
+	sb->s_blocksize_bits = pvfs_bufmap_shift_query();
+	sb->s_maxbytes = MAX_LFS_FILESIZE;
+
+	root_object.khandle = PVFS2_SB(sb)->root_khandle;
+	root_object.fs_id = PVFS2_SB(sb)->fs_id;
+	gossip_debug(GOSSIP_SUPER_DEBUG,
+		     "get inode %pU, fsid %d\n",
+		     &root_object.khandle,
+		     root_object.fs_id);
+
+	root = pvfs2_iget(sb, &root_object);
+	if (IS_ERR(root))
+		return PTR_ERR(root);
+
+	gossip_debug(GOSSIP_SUPER_DEBUG,
+		     "Allocated root inode [%p] with mode %x\n",
+		     root,
+		     root->i_mode);
+
+	/* allocates and places root dentry in dcache */
+	root_dentry = d_make_root(root);
+	if (!root_dentry) {
+		iput(root);
+		return -ENOMEM;
+	}
+
+	sb->s_export_op = &pvfs2_export_ops;
+	sb->s_root = root_dentry;
+	return 0;
+}
+
+struct dentry *pvfs2_mount(struct file_system_type *fst,
+			   int flags,
+			   const char *devname,
+			   void *data)
+{
+	int ret = -EINVAL;
+	struct super_block *sb = ERR_PTR(-EINVAL);
+	struct pvfs2_kernel_op_s *new_op;
+	struct pvfs2_mount_sb_info_s mount_sb_info;
+	struct dentry *mnt_sb_d = ERR_PTR(-EINVAL);
+
+	gossip_debug(GOSSIP_SUPER_DEBUG,
+		     "pvfs2_mount: called with devname %s\n",
+		     devname);
+
+	if (!devname) {
+		gossip_err("ERROR: device name not specified.\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	new_op = op_alloc(PVFS2_VFS_OP_FS_MOUNT);
+	if (!new_op)
+		return ERR_PTR(-ENOMEM);
+
+	strncpy(new_op->upcall.req.fs_mount.pvfs2_config_server,
+		devname,
+		PVFS_MAX_SERVER_ADDR_LEN);
+
+	gossip_debug(GOSSIP_SUPER_DEBUG,
+		     "Attempting PVFS2 Mount via host %s\n",
+		     new_op->upcall.req.fs_mount.pvfs2_config_server);
+
+	ret = service_operation(new_op, "pvfs2_mount", 0);
+	gossip_debug(GOSSIP_SUPER_DEBUG,
+		     "pvfs2_mount: mount got return value of %d\n", ret);
+	if (ret)
+		goto free_op;
+
+	if (new_op->downcall.resp.fs_mount.fs_id == PVFS_FS_ID_NULL) {
+		gossip_err("ERROR: Retrieved null fs_id\n");
+		ret = -EINVAL;
+		goto free_op;
+	}
+
+	/* fill in temporary structure passed to fill_sb method */
+	mount_sb_info.data = data;
+	mount_sb_info.root_khandle =
+		new_op->downcall.resp.fs_mount.root_khandle;
+	mount_sb_info.fs_id = new_op->downcall.resp.fs_mount.fs_id;
+	mount_sb_info.id = new_op->downcall.resp.fs_mount.id;
+
+	/*
+	 * the mount_sb_info structure looks odd, but it's used because
+	 * the private sb info isn't allocated until we call
+	 * pvfs2_fill_sb, yet we have the info we need to fill it with
+	 * here.  so we store it temporarily and pass all of the info
+	 * to fill_sb where it's properly copied out
+	 */
+	mnt_sb_d = mount_nodev(fst,
+			       flags,
+			       (void *)&mount_sb_info,
+			       pvfs2_fill_sb);
+	if (IS_ERR(mnt_sb_d)) {
+		sb = ERR_CAST(mnt_sb_d);
+		goto free_op;
+	}
+
+	sb = mnt_sb_d->d_sb;
+
+	/*
+	 * on successful mount, store the devname and data
+	 * used
+	 */
+	strncpy(PVFS2_SB(sb)->devname,
+		devname,
+		PVFS_MAX_SERVER_ADDR_LEN);
+
+	/* mount_pending must be cleared */
+	PVFS2_SB(sb)->mount_pending = 0;
+
+	/*
+	 * finally, add this sb to our list of known pvfs2
+	 * sb's
+	 */
+	add_pvfs2_sb(sb);
+	op_release(new_op);
+	return mnt_sb_d;
+
+free_op:
+	gossip_err("pvfs2_mount: mount request failed with %d\n", ret);
+	if (ret == -EINVAL) {
+		gossip_err("Ensure that all pvfs2-servers have the same FS configuration files\n");
+		gossip_err("Look at pvfs2-client-core log file (typically /tmp/pvfs2-client.log) for more details\n");
+	}
+
+	op_release(new_op);
+
+	gossip_debug(GOSSIP_SUPER_DEBUG,
+		     "pvfs2_mount: returning dentry %p\n",
+		     mnt_sb_d);
+	return mnt_sb_d;
+}
+
+void pvfs2_kill_sb(struct super_block *sb)
+{
+	gossip_debug(GOSSIP_SUPER_DEBUG, "pvfs2_kill_sb: called\n");
+
+	/*
+	 * issue the unmount to userspace to tell it to remove the
+	 * dynamic mount info it has for this superblock
+	 */
+	pvfs2_unmount_sb(sb);
+
+	/* remove the sb from our list of pvfs2 specific sb's */
+	remove_pvfs2_sb(sb);
+
+	/* provided sb cleanup */
+	kill_anon_super(sb);
+
+	/* free the pvfs2 superblock private data */
+	kfree(PVFS2_SB(sb));
+}
+
+int pvfs2_inode_cache_initialize(void)
+{
+	pvfs2_inode_cache = kmem_cache_create("pvfs2_inode_cache",
+					      sizeof(struct pvfs2_inode_s),
+					      0,
+					      PVFS2_CACHE_CREATE_FLAGS,
+					      pvfs2_inode_cache_ctor);
+
+	if (!pvfs2_inode_cache) {
+		gossip_err("Cannot create pvfs2_inode_cache\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+int pvfs2_inode_cache_finalize(void)
+{
+	kmem_cache_destroy(pvfs2_inode_cache);
+	return 0;
+}
