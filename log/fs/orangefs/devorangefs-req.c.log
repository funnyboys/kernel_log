commit 29d6849d88b61edf130aef500acad78206bda3cd
Merge: a5b729ea18ae 430ff79170d8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 16 16:21:50 2018 +0900

    Merge branch 'work.compat' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull compat updates from Al Viro:
     "Some biarch patches - getting rid of assorted (mis)uses of
      compat_alloc_user_space().
    
      Not much in that area this cycle..."
    
    * 'work.compat' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      orangefs: simplify compat ioctl handling
      signalfd: lift sigmask copyin and size checks to callers of do_signalfd4()
      vmsplice(): lift importing iovec into vmsplice(2) and compat counterpart

commit 430ff79170d877c1602acb5a3701453dfa36b566
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun May 27 08:52:48 2018 -0400

    orangefs: simplify compat ioctl handling
    
    no need to mess with copy_in_user(), etc...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 66369ec90020..8581daf19634 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -716,37 +716,6 @@ struct ORANGEFS_dev_map_desc32 {
 	__s32 count;
 };
 
-static unsigned long translate_dev_map26(unsigned long args, long *error)
-{
-	struct ORANGEFS_dev_map_desc32 __user *p32 = (void __user *)args;
-	/*
-	 * Depending on the architecture, allocate some space on the
-	 * user-call-stack based on our expected layout.
-	 */
-	struct ORANGEFS_dev_map_desc __user *p =
-	    compat_alloc_user_space(sizeof(*p));
-	compat_uptr_t addr;
-
-	*error = 0;
-	/* get the ptr from the 32 bit user-space */
-	if (get_user(addr, &p32->ptr))
-		goto err;
-	/* try to put that into a 64-bit layout */
-	if (put_user(compat_ptr(addr), &p->ptr))
-		goto err;
-	/* copy the remaining fields */
-	if (copy_in_user(&p->total_size, &p32->total_size, sizeof(__s32)))
-		goto err;
-	if (copy_in_user(&p->size, &p32->size, sizeof(__s32)))
-		goto err;
-	if (copy_in_user(&p->count, &p32->count, sizeof(__s32)))
-		goto err;
-	return (unsigned long)p;
-err:
-	*error = -EFAULT;
-	return 0;
-}
-
 /*
  * 32 bit user-space apps' ioctl handlers when kernel modules
  * is compiled as a 64 bit one
@@ -755,25 +724,26 @@ static long orangefs_devreq_compat_ioctl(struct file *filp, unsigned int cmd,
 				      unsigned long args)
 {
 	long ret;
-	unsigned long arg = args;
 
 	/* Check for properly constructed commands */
 	ret = check_ioctl_command(cmd);
 	if (ret < 0)
 		return ret;
 	if (cmd == ORANGEFS_DEV_MAP) {
-		/*
-		 * convert the arguments to what we expect internally
-		 * in kernel space
-		 */
-		arg = translate_dev_map26(args, &ret);
-		if (ret < 0) {
-			gossip_err("Could not translate dev map\n");
-			return ret;
-		}
+		struct ORANGEFS_dev_map_desc desc;
+		struct ORANGEFS_dev_map_desc32 d32;
+
+		if (copy_from_user(&d32, (void __user *)args, sizeof(d32)))
+			return -EFAULT;
+
+		desc.ptr = compat_ptr(d32.ptr);
+		desc.total_size = d32.total_size;
+		desc.size = d32.size;
+		desc.count = d32.count;
+		return orangefs_bufmap_initialize(&desc);
 	}
 	/* no other ioctl requires translation */
-	return dispatch_ioctl_command(cmd, arg);
+	return dispatch_ioctl_command(cmd, args);
 }
 
 #endif /* CONFIG_COMPAT is in .config */

commit 95f5f88f8900c09eb534c8cb42d75ff3cf7ea96c
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri May 11 17:11:48 2018 -0400

    orangefs: formatting cleanups
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 66369ec90020..74b37cbbd5d4 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -281,14 +281,17 @@ static ssize_t orangefs_devreq_read(struct file *file,
 	ret = copy_to_user(buf, &proto_ver, sizeof(__s32));
 	if (ret != 0)
 		goto error;
-	ret = copy_to_user(buf+sizeof(__s32), &magic, sizeof(__s32));
+	ret = copy_to_user(buf + sizeof(__s32), &magic, sizeof(__s32));
 	if (ret != 0)
 		goto error;
-	ret = copy_to_user(buf+2 * sizeof(__s32), &cur_op->tag, sizeof(__u64));
+	ret = copy_to_user(buf + 2 * sizeof(__s32),
+		&cur_op->tag,
+		sizeof(__u64));
 	if (ret != 0)
 		goto error;
-	ret = copy_to_user(buf+2*sizeof(__s32)+sizeof(__u64), &cur_op->upcall,
-			   sizeof(struct orangefs_upcall_s));
+	ret = copy_to_user(buf + 2 * sizeof(__s32) + sizeof(__u64),
+		&cur_op->upcall,
+		sizeof(struct orangefs_upcall_s));
 	if (ret != 0)
 		goto error;
 
@@ -381,7 +384,7 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 			   (unsigned int) MAX_DEV_REQ_DOWNSIZE);
 		return -EFAULT;
 	}
-     
+
 	if (!copy_from_iter_full(&head, head_size, iter)) {
 		gossip_err("%s: failed to copy head.\n", __func__);
 		return -EFAULT;
@@ -426,7 +429,7 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		goto wakeup;
 
 	/*
-	 * We've successfully peeled off the head and the downcall. 
+	 * We've successfully peeled off the head and the downcall.
 	 * Something has gone awry if total doesn't equal the
 	 * sum of head_size, downcall_size and trailer_size.
 	 */
@@ -477,7 +480,7 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 wakeup:
 	/*
 	 * Return to vfs waitqueue, and back to service_operation
-	 * through wait_for_matching_downcall. 
+	 * through wait_for_matching_downcall.
 	 */
 	spin_lock(&op->lock);
 	if (unlikely(op_is_cancel(op))) {

commit bdd6f083586ff17eb3959cca88212fdb60ca53d1
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 3 16:27:13 2018 +0000

    orangefs: make several *_operations structs static
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 319cf9dcacdd..66369ec90020 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -778,9 +778,35 @@ static long orangefs_devreq_compat_ioctl(struct file *filp, unsigned int cmd,
 
 #endif /* CONFIG_COMPAT is in .config */
 
+static __poll_t orangefs_devreq_poll(struct file *file,
+				      struct poll_table_struct *poll_table)
+{
+	__poll_t poll_revent_mask = 0;
+
+	poll_wait(file, &orangefs_request_list_waitq, poll_table);
+
+	if (!list_empty(&orangefs_request_list))
+		poll_revent_mask |= EPOLLIN;
+	return poll_revent_mask;
+}
+
 /* the assigned character device major number */
 static int orangefs_dev_major;
 
+static const struct file_operations orangefs_devreq_file_operations = {
+	.owner = THIS_MODULE,
+	.read = orangefs_devreq_read,
+	.write_iter = orangefs_devreq_write_iter,
+	.open = orangefs_devreq_open,
+	.release = orangefs_devreq_release,
+	.unlocked_ioctl = orangefs_devreq_ioctl,
+
+#ifdef CONFIG_COMPAT		/* CONFIG_COMPAT is in .config */
+	.compat_ioctl = orangefs_devreq_compat_ioctl,
+#endif
+	.poll = orangefs_devreq_poll
+};
+
 /*
  * Initialize orangefs device specific state:
  * Must be called at module load time only
@@ -813,29 +839,3 @@ void orangefs_dev_cleanup(void)
 		     "*** /dev/%s character device unregistered ***\n",
 		     ORANGEFS_REQDEVICE_NAME);
 }
-
-static __poll_t orangefs_devreq_poll(struct file *file,
-				      struct poll_table_struct *poll_table)
-{
-	__poll_t poll_revent_mask = 0;
-
-	poll_wait(file, &orangefs_request_list_waitq, poll_table);
-
-	if (!list_empty(&orangefs_request_list))
-		poll_revent_mask |= EPOLLIN;
-	return poll_revent_mask;
-}
-
-const struct file_operations orangefs_devreq_file_operations = {
-	.owner = THIS_MODULE,
-	.read = orangefs_devreq_read,
-	.write_iter = orangefs_devreq_write_iter,
-	.open = orangefs_devreq_open,
-	.release = orangefs_devreq_release,
-	.unlocked_ioctl = orangefs_devreq_ioctl,
-
-#ifdef CONFIG_COMPAT		/* CONFIG_COMPAT is in .config */
-	.compat_ioctl = orangefs_devreq_compat_ioctl,
-#endif
-	.poll = orangefs_devreq_poll
-};

commit 81e3d0253f87d369a1d957eb3173fd596126383c
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Jan 26 19:42:47 2018 +0000

    orangefs: replace vmalloc and memset with vzalloc
    
    Use vzalloc instead of the vmalloc, memset combo
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index b03057afac2a..319cf9dcacdd 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -463,11 +463,10 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 	if (op->downcall.type != ORANGEFS_VFS_OP_READDIR)
 		goto wakeup;
 
-	op->downcall.trailer_buf = vmalloc(op->downcall.trailer_size);
+	op->downcall.trailer_buf = vzalloc(op->downcall.trailer_size);
 	if (!op->downcall.trailer_buf)
 		goto Enomem;
 
-	memset(op->downcall.trailer_buf, 0, op->downcall.trailer_size);
 	if (!copy_from_iter_full(op->downcall.trailer_buf,
 			         op->downcall.trailer_size, iter)) {
 		gossip_err("%s: failed to copy trailer.\n", __func__);

commit a9a08845e9acbd224e4ee466f5c1275ed50054e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 11 14:34:03 2018 -0800

    vfs: do bulk POLL* -> EPOLL* replacement
    
    This is the mindless scripted replacement of kernel use of POLL*
    variables as described by Al, done by this script:
    
        for V in IN OUT PRI ERR RDNORM RDBAND WRNORM WRBAND HUP RDHUP NVAL MSG; do
            L=`git grep -l -w POLL$V | grep -v '^t' | grep -v /um/ | grep -v '^sa' | grep -v '/poll.h$'|grep -v '^D'`
            for f in $L; do sed -i "-es/^\([^\"]*\)\(\<POLL$V\>\)/\\1E\\2/" $f; done
        done
    
    with de-mangling cleanups yet to come.
    
    NOTE! On almost all architectures, the EPOLL* constants have the same
    values as the POLL* constants do.  But they keyword here is "almost".
    For various bad reasons they aren't the same, and epoll() doesn't
    actually work quite correctly in some cases due to this on Sparc et al.
    
    The next patch from Al will sort out the final differences, and we
    should be all done.
    
    Scripted-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index f073cd9e6687..b03057afac2a 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -823,7 +823,7 @@ static __poll_t orangefs_devreq_poll(struct file *file,
 	poll_wait(file, &orangefs_request_list_waitq, poll_table);
 
 	if (!list_empty(&orangefs_request_list))
-		poll_revent_mask |= POLLIN;
+		poll_revent_mask |= EPOLLIN;
 	return poll_revent_mask;
 }
 

commit 168fe32a072a4b8dc81a3aebf0e5e588d38e2955
Merge: 13ddd1667e7f c71d227fc413
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 30 17:58:07 2018 -0800

    Merge branch 'misc.poll' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull poll annotations from Al Viro:
     "This introduces a __bitwise type for POLL### bitmap, and propagates
      the annotations through the tree. Most of that stuff is as simple as
      'make ->poll() instances return __poll_t and do the same to local
      variables used to hold the future return value'.
    
      Some of the obvious brainos found in process are fixed (e.g. POLLIN
      misspelled as POLL_IN). At that point the amount of sparse warnings is
      low and most of them are for genuine bugs - e.g. ->poll() instance
      deciding to return -EINVAL instead of a bitmap. I hadn't touched those
      in this series - it's large enough as it is.
    
      Another problem it has caught was eventpoll() ABI mess; select.c and
      eventpoll.c assumed that corresponding POLL### and EPOLL### were
      equal. That's true for some, but not all of them - EPOLL### are
      arch-independent, but POLL### are not.
    
      The last commit in this series separates userland POLL### values from
      the (now arch-independent) kernel-side ones, converting between them
      in the few places where they are copied to/from userland. AFAICS, this
      is the least disruptive fix preserving poll(2) ABI and making epoll()
      work on all architectures.
    
      As it is, it's simply broken on sparc - try to give it EPOLLWRNORM and
      it will trigger only on what would've triggered EPOLLWRBAND on other
      architectures. EPOLLWRBAND and EPOLLRDHUP, OTOH, are never triggered
      at all on sparc. With this patch they should work consistently on all
      architectures"
    
    * 'misc.poll' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (37 commits)
      make kernel-side POLL... arch-independent
      eventpoll: no need to mask the result of epi_item_poll() again
      eventpoll: constify struct epoll_event pointers
      debugging printk in sg_poll() uses %x to print POLL... bitmap
      annotate poll(2) guts
      9p: untangle ->poll() mess
      ->si_band gets POLL... bitmap stored into a user-visible long field
      ring_buffer_poll_wait() return value used as return value of ->poll()
      the rest of drivers/*: annotate ->poll() instances
      media: annotate ->poll() instances
      fs: annotate ->poll() instances
      ipc, kernel, mm: annotate ->poll() instances
      net: annotate ->poll() instances
      apparmor: annotate ->poll() instances
      tomoyo: annotate ->poll() instances
      sound: annotate ->poll() instances
      acpi: annotate ->poll() instances
      crypto: annotate ->poll() instances
      block: annotate ->poll() instances
      x86: annotate ->poll() instances
      ...

commit a0ec1ded22e6a6bc41981fae22406835b006a66e
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Jan 22 15:44:52 2018 -0500

    orangefs: initialize op on loop restart in orangefs_devreq_read
    
    In orangefs_devreq_read, there is a loop which picks an op off the list
    of pending ops.  If the loop fails to find an op, there is nothing to
    read, and it returns EAGAIN.  If the op has been given up on, the loop
    is restarted via a goto.  The bug is that the variable which the found
    op is written to is not reinitialized, so if there are no more eligible
    ops on the list, the code runs again on the already handled op.
    
    This is triggered by interrupting a process while the op is being copied
    to the client-core.  It's a fairly small window, but it's there.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index ded456f17de6..c584ad8d023c 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -162,7 +162,7 @@ static ssize_t orangefs_devreq_read(struct file *file,
 	struct orangefs_kernel_op_s *op, *temp;
 	__s32 proto_ver = ORANGEFS_KERNEL_PROTO_VERSION;
 	static __s32 magic = ORANGEFS_DEVREQ_MAGIC;
-	struct orangefs_kernel_op_s *cur_op = NULL;
+	struct orangefs_kernel_op_s *cur_op;
 	unsigned long ret;
 
 	/* We do not support blocking IO. */
@@ -186,6 +186,7 @@ static ssize_t orangefs_devreq_read(struct file *file,
 		return -EAGAIN;
 
 restart:
+	cur_op = NULL;
 	/* Get next op (if any) from top of list. */
 	spin_lock(&orangefs_request_list_lock);
 	list_for_each_entry_safe(op, temp, &orangefs_request_list, list) {

commit 076ccb76e1a6cf0aa5371132efdd502a11e806f1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 3 01:02:18 2017 -0400

    fs: annotate ->poll() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index a324dc584bf7..109fffd6d153 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -814,10 +814,10 @@ void orangefs_dev_cleanup(void)
 		     ORANGEFS_REQDEVICE_NAME);
 }
 
-static unsigned int orangefs_devreq_poll(struct file *file,
+static __poll_t orangefs_devreq_poll(struct file *file,
 				      struct poll_table_struct *poll_table)
 {
-	int poll_revent_mask = 0;
+	__poll_t poll_revent_mask = 0;
 
 	poll_wait(file, &orangefs_request_list_waitq, poll_table);
 

commit e410c60360e210671ad604d46b57e1f6f90f9078
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 3 01:00:54 2017 -0400

    orangefs: fix a braino in ->poll()
    
    It's POLLIN, not POLL_IN...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index ded456f17de6..a324dc584bf7 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -822,7 +822,7 @@ static unsigned int orangefs_devreq_poll(struct file *file,
 	poll_wait(file, &orangefs_request_list_waitq, poll_table);
 
 	if (!list_empty(&orangefs_request_list))
-		poll_revent_mask |= POLL_IN;
+		poll_revent_mask |= POLLIN;
 	return poll_revent_mask;
 }
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 2826859bdc2c..ded456f17de6 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * (C) 2001 Clemson University and The University of Chicago
  *

commit 07a258531c7550f8bb481dfe2ec12bb876224487
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Aug 17 21:00:07 2017 +0200

    orangefs: Delete error messages for a failed memory allocation in five functions
    
    Omit an extra message for a memory allocation failure in these functions.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index c19f0787c9c6..2826859bdc2c 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -461,13 +461,10 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 	if (op->downcall.type != ORANGEFS_VFS_OP_READDIR)
 		goto wakeup;
 
-	op->downcall.trailer_buf =
-		vmalloc(op->downcall.trailer_size);
-	if (op->downcall.trailer_buf == NULL) {
-		gossip_err("%s: failed trailer vmalloc.\n",
-			   __func__);
+	op->downcall.trailer_buf = vmalloc(op->downcall.trailer_size);
+	if (!op->downcall.trailer_buf)
 		goto Enomem;
-	}
+
 	memset(op->downcall.trailer_buf, 0, op->downcall.trailer_size);
 	if (!copy_from_iter_full(op->downcall.trailer_buf,
 			         op->downcall.trailer_size, iter)) {

commit b7a57ccab891584d00ae03dce1176b2d4cbe08e7
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 25 15:38:06 2017 -0400

    orangefs: return from orangefs_devreq_read quickly if possible
    
    It is not necessary to take the lock and search through the request list
    if the list is empty.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index e1534c9bab16..c19f0787c9c6 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -180,6 +180,10 @@ static ssize_t orangefs_devreq_read(struct file *file,
 		return -EINVAL;
 	}
 
+	/* Check for an empty list before locking. */
+	if (list_empty(&orangefs_request_list))
+		return -EAGAIN;
+
 restart:
 	/* Get next op (if any) from top of list. */
 	spin_lock(&orangefs_request_list_lock);

commit 1ec1688c5360e14dde4094d6acbf7516bf6db37e
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Apr 14 14:22:41 2017 -0400

    orangefs: free superblock when mount fails
    
    Otherwise lockdep says:
    
    [ 1337.483798] ================================================
    [ 1337.483999] [ BUG: lock held when returning to user space! ]
    [ 1337.484252] 4.11.0-rc6 #19 Not tainted
    [ 1337.484423] ------------------------------------------------
    [ 1337.484626] mount/14766 is leaving the kernel with locks still held!
    [ 1337.484841] 1 lock held by mount/14766:
    [ 1337.485017]  #0:  (&type->s_umount_key#33/1){+.+.+.}, at: [<ffffffff8124171f>] sget_userns+0x2af/0x520
    
    Caught by xfstests generic/413 which tried to mount with the unsupported
    mount option dax.  Then xfstests generic/422 ran sync which deadlocks.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Acked-by: Mike Marshall <hubcap@omnibond.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index c4ab6fdf17a0..e1534c9bab16 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -208,14 +208,19 @@ static ssize_t orangefs_devreq_read(struct file *file,
 				continue;
 			/*
 			 * Skip ops whose filesystem we don't know about unless
-			 * it is being mounted.
+			 * it is being mounted or unmounted.  It is possible for
+			 * a filesystem we don't know about to be unmounted if
+			 * it fails to mount in the kernel after userspace has
+			 * been sent the mount request.
 			 */
 			/* XXX: is there a better way to detect this? */
 			} else if (ret == -1 &&
 				   !(op->upcall.type ==
 					ORANGEFS_VFS_OP_FS_MOUNT ||
 				     op->upcall.type ==
-					ORANGEFS_VFS_OP_GETATTR)) {
+					ORANGEFS_VFS_OP_GETATTR ||
+				     op->upcall.type ==
+					ORANGEFS_VFS_OP_FS_UMOUNT)) {
 				gossip_debug(GOSSIP_DEV_DEBUG,
 				    "orangefs: skipping op tag %llu %s\n",
 				    llu(op->tag), get_opname_string(op));

commit e98bdb3059cbf2b1cd4261e126b08429f64466c3
Merge: eb68d0324dc4 c470abd4fde4
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Sat Feb 25 11:12:48 2017 -0500

    Merge tag 'v4.10' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux into for-next
    
    Linux 4.10

commit 05973c2efb40122f2a9ecde2d065f7ea5068d024
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Thu Feb 9 14:38:50 2017 -0500

    orangefs: Dan Carpenter influenced cleanups...
    
    This patch is simlar to one Dan Carpenter sent me, cleans
    up some return codes and whitespace errors. There was one
    place where he thought inserting an error message into
    the ring buffer might be too chatty, I hope I convinced him
    othewise. As a consolation <g> I changed a truly chatty
    error message in another location into a debug message,
    system-admins had already yelled at me about that one...
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 516ffb4dc9a0..f419dd999581 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -402,8 +402,9 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 	/* remove the op from the in progress hash table */
 	op = orangefs_devreq_remove_op(head.tag);
 	if (!op) {
-		gossip_err("WARNING: No one's waiting for tag %llu\n",
-			   llu(head.tag));
+		gossip_debug(GOSSIP_DEV_DEBUG,
+			     "%s: No one's waiting for tag %llu\n",
+			     __func__, llu(head.tag));
 		return ret;
 	}
 

commit cbbd26b8b1a6af9c02e2b6523e12bd50cc765059
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Nov 1 22:09:04 2016 -0400

    [iov_iter] new primitives - copy_from_iter_full() and friends
    
    copy_from_iter_full(), copy_from_iter_full_nocache() and
    csum_and_copy_from_iter_full() - counterparts of copy_from_iter()
    et.al., advancing iterator only in case of successful full copy
    and returning whether it had been successful or not.
    
    Convert some obvious users.  *NOTE* - do not blindly assume that
    something is a good candidate for those unless you are sure that
    not advancing iov_iter in failure case is the right thing in
    this case.  Anything that does short read/short write kind of
    stuff (or is in a loop, etc.) is unlikely to be a good one.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 516ffb4dc9a0..b0ced669427e 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -355,7 +355,6 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		__u64 tag;
 	} head;
 	int total = ret = iov_iter_count(iter);
-	int n;
 	int downcall_size = sizeof(struct orangefs_downcall_s);
 	int head_size = sizeof(head);
 
@@ -372,8 +371,7 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		return -EFAULT;
 	}
      
-	n = copy_from_iter(&head, head_size, iter);
-	if (n < head_size) {
+	if (!copy_from_iter_full(&head, head_size, iter)) {
 		gossip_err("%s: failed to copy head.\n", __func__);
 		return -EFAULT;
 	}
@@ -407,8 +405,7 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		return ret;
 	}
 
-	n = copy_from_iter(&op->downcall, downcall_size, iter);
-	if (n != downcall_size) {
+	if (!copy_from_iter_full(&op->downcall, downcall_size, iter)) {
 		gossip_err("%s: failed to copy downcall.\n", __func__);
 		goto Efault;
 	}
@@ -462,10 +459,8 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		goto Enomem;
 	}
 	memset(op->downcall.trailer_buf, 0, op->downcall.trailer_size);
-	n = copy_from_iter(op->downcall.trailer_buf,
-			   op->downcall.trailer_size,
-			   iter);
-	if (n != op->downcall.trailer_size) {
+	if (!copy_from_iter_full(op->downcall.trailer_buf,
+			         op->downcall.trailer_size, iter)) {
 		gossip_err("%s: failed to copy trailer.\n", __func__);
 		vfree(op->downcall.trailer_buf);
 		goto Efault;

commit b78b11985a36bfe768add17ffb70bbaf9d8d7627
Merge: f808e138c0ab 1d503617884e
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Wed Sep 28 14:50:46 2016 -0400

    Merge branch 'misc' into for-next
    
    Pull in an OrangeFS branch containing miscellaneous improvements.
    
    - clean up debugfs globals
    - remove dead code in sysfs
    - reorganize duplicated sysfs attribute structs
    - consolidate sysfs show and store functions
    - remove duplicated sysfs_ops structures
    - describe organization of sysfs
    - make devreq_mutex static
    - g_orangefs_stats -> orangefs_stats for consistency
    - rename most remaining global variables

commit 1d503617884ed43af1c03685e73ce23f155d3fa4
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Aug 16 11:38:14 2016 -0400

    orangefs: rename most remaining global variables
    
    Only op_timeout_secs, slot_timeout_secs, and hash_table_size are left
    because they are exposed as module parameters. All other global
    variables have the orangefs_ prefix.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index a5c76583dffa..641e27152d7e 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -46,7 +46,7 @@ static void orangefs_devreq_add_op(struct orangefs_kernel_op_s *op)
 {
 	int index = hash_func(op->tag, hash_table_size);
 
-	list_add_tail(&op->list, &htable_ops_in_progress[index]);
+	list_add_tail(&op->list, &orangefs_htable_ops_in_progress[index]);
 }
 
 /*
@@ -60,20 +60,20 @@ static struct orangefs_kernel_op_s *orangefs_devreq_remove_op(__u64 tag)
 
 	index = hash_func(tag, hash_table_size);
 
-	spin_lock(&htable_ops_in_progress_lock);
+	spin_lock(&orangefs_htable_ops_in_progress_lock);
 	list_for_each_entry_safe(op,
 				 next,
-				 &htable_ops_in_progress[index],
+				 &orangefs_htable_ops_in_progress[index],
 				 list) {
 		if (op->tag == tag && !op_state_purged(op) &&
 		    !op_state_given_up(op)) {
 			list_del_init(&op->list);
-			spin_unlock(&htable_ops_in_progress_lock);
+			spin_unlock(&orangefs_htable_ops_in_progress_lock);
 			return op;
 		}
 	}
 
-	spin_unlock(&htable_ops_in_progress_lock);
+	spin_unlock(&orangefs_htable_ops_in_progress_lock);
 	return NULL;
 }
 
@@ -279,11 +279,11 @@ static ssize_t orangefs_devreq_read(struct file *file,
 	if (ret != 0)
 		goto error;
 
-	spin_lock(&htable_ops_in_progress_lock);
+	spin_lock(&orangefs_htable_ops_in_progress_lock);
 	spin_lock(&cur_op->lock);
 	if (unlikely(op_state_given_up(cur_op))) {
 		spin_unlock(&cur_op->lock);
-		spin_unlock(&htable_ops_in_progress_lock);
+		spin_unlock(&orangefs_htable_ops_in_progress_lock);
 		complete(&cur_op->waitq);
 		goto restart;
 	}
@@ -301,7 +301,7 @@ static ssize_t orangefs_devreq_read(struct file *file,
 		     current->comm);
 	orangefs_devreq_add_op(cur_op);
 	spin_unlock(&cur_op->lock);
-	spin_unlock(&htable_ops_in_progress_lock);
+	spin_unlock(&orangefs_htable_ops_in_progress_lock);
 
 	/* The client only asks to read one size buffer. */
 	return MAX_DEV_REQ_UPSIZE;
@@ -620,7 +620,7 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 		 * all of the remounts are serviced (to avoid ops between
 		 * mounts to fail)
 		 */
-		ret = mutex_lock_interruptible(&request_mutex);
+		ret = mutex_lock_interruptible(&orangefs_request_mutex);
 		if (ret < 0)
 			return ret;
 		gossip_debug(GOSSIP_DEV_DEBUG,
@@ -655,7 +655,7 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 		gossip_debug(GOSSIP_DEV_DEBUG,
 			     "%s: priority remount complete\n",
 			     __func__);
-		mutex_unlock(&request_mutex);
+		mutex_unlock(&orangefs_request_mutex);
 		return ret;
 
 	case ORANGEFS_DEV_UPSTREAM:

commit a0fe051592f1d31db491bb6cdcc87f512c5b6eaa
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Aug 15 15:21:16 2016 -0400

    orangefs: make devreq_mutex static
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 6779cb7b747e..a5c76583dffa 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -20,6 +20,8 @@
 
 static int open_access_count;
 
+static DEFINE_MUTEX(devreq_mutex);
+
 #define DUMP_DEVICE_ERROR()                                                   \
 do {                                                                          \
 	gossip_err("*****************************************************\n");\

commit 44f4641073f132429e1e9a53412600206e8f7d06
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Aug 15 11:38:36 2016 -0400

    orangefs: clean up debugfs globals
    
    Mostly this is moving code into orangefs-debugfs.c so that globals turn
    into static globals.
    
    Then gossip_debug_mask is renamed orangefs_gossip_debug_mask but keeps
    global visibility, so it can be used from a macro.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index a287a66d94e3..6779cb7b747e 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -11,6 +11,7 @@
 #include "orangefs-kernel.h"
 #include "orangefs-dev-proto.h"
 #include "orangefs-bufmap.h"
+#include "orangefs-debugfs.h"
 
 #include <linux/debugfs.h>
 #include <linux/slab.h>
@@ -576,8 +577,6 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 	static __s32 max_down_size = MAX_DEV_REQ_DOWNSIZE;
 	struct ORANGEFS_dev_map_desc user_desc;
 	int ret = 0;
-	struct dev_mask_info_s mask_info = { 0 };
-	struct dev_mask2_info_s mask2_info = { 0, 0 };
 	int upstream_kmod = 1;
 	struct orangefs_sb_info_s *orangefs_sb;
 
@@ -668,134 +667,11 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 			return ret;
 
 	case ORANGEFS_DEV_CLIENT_MASK:
-		ret = copy_from_user(&mask2_info,
-				     (void __user *)arg,
-				     sizeof(struct dev_mask2_info_s));
-
-		if (ret != 0)
-			return -EIO;
-
-		client_debug_mask.mask1 = mask2_info.mask1_value;
-		client_debug_mask.mask2 = mask2_info.mask2_value;
-
-		pr_info("%s: client debug mask has been been received "
-			":%llx: :%llx:\n",
-			__func__,
-			(unsigned long long)client_debug_mask.mask1,
-			(unsigned long long)client_debug_mask.mask2);
-
-		return ret;
-
+		return orangefs_debugfs_new_client_mask((void __user *)arg);
 	case ORANGEFS_DEV_CLIENT_STRING:
-		ret = copy_from_user(&client_debug_array_string,
-				     (void __user *)arg,
-				     ORANGEFS_MAX_DEBUG_STRING_LEN);
-		/*
-		 * The real client-core makes an effort to ensure
-		 * that actual strings that aren't too long to fit in
-		 * this buffer is what we get here. We're going to use
-		 * string functions on the stuff we got, so we'll make
-		 * this extra effort to try and keep from
-		 * flowing out of this buffer when we use the string
-		 * functions, even if somehow the stuff we end up
-		 * with here is garbage.
-		 */
-		client_debug_array_string[ORANGEFS_MAX_DEBUG_STRING_LEN - 1] =
-			'\0';
-		
-		if (ret != 0) {
-			pr_info("%s: CLIENT_STRING: copy_from_user failed\n",
-				__func__);
-			return -EIO;
-		}
-
-		pr_info("%s: client debug array string has been received.\n",
-			__func__);
-
-		if (!help_string_initialized) {
-
-			/* Free the "we don't know yet" default string... */
-			kfree(debug_help_string);
-
-			/* build a proper debug help string */
-			if (orangefs_prepare_debugfs_help_string(0)) {
-				gossip_err("%s: no debug help string \n",
-					   __func__);
-				return -EIO;
-			}
-
-			/* Replace the boilerplate boot-time debug-help file. */
-			debugfs_remove(help_file_dentry);
-
-			help_file_dentry =
-				debugfs_create_file(
-					ORANGEFS_KMOD_DEBUG_HELP_FILE,
-					0444,
-					debug_dir,
-					debug_help_string,
-					&debug_help_fops);
-
-			if (!help_file_dentry) {
-				gossip_err("%s: debugfs_create_file failed for"
-					   " :%s:!\n",
-					   __func__,
-					   ORANGEFS_KMOD_DEBUG_HELP_FILE);
-				return -EIO;
-			}
-		}
-
-		debug_mask_to_string(&client_debug_mask, 1);
-
-		debugfs_remove(client_debug_dentry);
-
-		orangefs_client_debug_init();
-
-		help_string_initialized++;
-
-		return ret;
-
+		return orangefs_debugfs_new_client_string((void __user *)arg);
 	case ORANGEFS_DEV_DEBUG:
-		ret = copy_from_user(&mask_info,
-				     (void __user *)arg,
-				     sizeof(mask_info));
-
-		if (ret != 0)
-			return -EIO;
-
-		if (mask_info.mask_type == KERNEL_MASK) {
-			if ((mask_info.mask_value == 0)
-			    && (kernel_mask_set_mod_init)) {
-				/*
-				 * the kernel debug mask was set when the
-				 * kernel module was loaded; don't override
-				 * it if the client-core was started without
-				 * a value for ORANGEFS_KMODMASK.
-				 */
-				return 0;
-			}
-			debug_mask_to_string(&mask_info.mask_value,
-					     mask_info.mask_type);
-			gossip_debug_mask = mask_info.mask_value;
-			pr_info("%s: kernel debug mask has been modified to "
-				":%s: :%llx:\n",
-				__func__,
-				kernel_debug_string,
-				(unsigned long long)gossip_debug_mask);
-		} else if (mask_info.mask_type == CLIENT_MASK) {
-			debug_mask_to_string(&mask_info.mask_value,
-					     mask_info.mask_type);
-			pr_info("%s: client debug mask has been modified to"
-				":%s: :%llx:\n",
-				__func__,
-				client_debug_string,
-				llu(mask_info.mask_value));
-		} else {
-			gossip_lerr("Invalid mask type....\n");
-			return -EINVAL;
-		}
-
-		return ret;
-
+		return orangefs_debugfs_new_debug((void __user *)arg);
 	default:
 		return -ENOIOCTLCMD;
 	}

commit 482664ddba81b3a5404fd083bb9697dfffc0b6a4
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Aug 12 12:02:31 2016 -0400

    orangefs: add features op
    
    This is a new userspace operation, which will be done if the client-core
    version is greater than or equal to 2.9.6. This will provide a way to
    implement optional features and to determine which features are
    supported by the client-core. If the client-core version is older than
    2.9.6, no optional features are supported and the op will not be done.
    
    The intent is to allow protocol extensions without relying on the
    client-core's current behavior of ignoring what it doesn't understand.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 7c40e653e526..ec1a5ff1d843 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -17,7 +17,7 @@
 
 /* this file implements the /dev/pvfs2-req device node */
 
-uint32_t userspace_version;
+uint32_t orangefs_userspace_version;
 
 static int open_access_count;
 
@@ -389,9 +389,9 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		return -EPROTO;
 	}
 
-	if (!userspace_version) {
-		userspace_version = head.version;
-	} else if (userspace_version != head.version) {
+	if (!orangefs_userspace_version) {
+		orangefs_userspace_version = head.version;
+	} else if (orangefs_userspace_version != head.version) {
 		gossip_err("Error: userspace version changes\n");
 		return -EPROTO;
 	}
@@ -536,7 +536,7 @@ static int orangefs_devreq_release(struct inode *inode, struct file *file)
 	gossip_debug(GOSSIP_DEV_DEBUG,
 		     "pvfs2-client-core: device close complete\n");
 	open_access_count = 0;
-	userspace_version = 0;
+	orangefs_userspace_version = 0;
 	mutex_unlock(&devreq_mutex);
 	return 0;
 }

commit f2ee3b759593c184f1249e03d613a84b4b69db2b
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Aug 9 15:59:26 2016 -0400

    orangefs: record userspace version for feature compatbility
    
    The client reports its version to the kernel on startup. We already test
    that it is above the minimum version. Now we record it in a global
    variable so code elsewhere can consult it before making a request the
    client may not understand.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index a287a66d94e3..7c40e653e526 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -17,6 +17,8 @@
 
 /* this file implements the /dev/pvfs2-req device node */
 
+uint32_t userspace_version;
+
 static int open_access_count;
 
 #define DUMP_DEVICE_ERROR()                                                   \
@@ -387,6 +389,13 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		return -EPROTO;
 	}
 
+	if (!userspace_version) {
+		userspace_version = head.version;
+	} else if (userspace_version != head.version) {
+		gossip_err("Error: userspace version changes\n");
+		return -EPROTO;
+	}
+
 	/* remove the op from the in progress hash table */
 	op = orangefs_devreq_remove_op(head.tag);
 	if (!op) {
@@ -527,6 +536,7 @@ static int orangefs_devreq_release(struct inode *inode, struct file *file)
 	gossip_debug(GOSSIP_DEV_DEBUG,
 		     "pvfs2-client-core: device close complete\n");
 	open_access_count = 0;
+	userspace_version = 0;
 	mutex_unlock(&devreq_mutex);
 	return 0;
 }

commit 78fee0b6846f27872321338db6afe280f059ae99
Author: Jann Horn <jannh@google.com>
Date:   Sat Jun 25 01:51:52 2016 +0200

    orangefs: fix namespace handling
    
    In orangefs_inode_getxattr(), an fsuid is written to dmesg. The kuid is
    converted to a userspace uid via from_kuid(current_user_ns(), [...]), but
    since dmesg is global, init_user_ns should be used here instead.
    
    In copy_attributes_from_inode(), op_alloc() and fill_default_sys_attrs(),
    upcall structures are populated with uids/gids that have been mapped into
    the caller's namespace. However, those upcall structures are read by
    another process (the userspace filesystem driver), and that process might
    be running in another namespace. This effectively lets any user spoof its
    uid and gid as seen by the userspace filesystem driver.
    
    To fix the second issue, I just construct the opcall structures with
    init_user_ns uids/gids and require the filesystem server to run in the
    init namespace. Since orangefs is full of global state anyway (as the error
    message in DUMP_DEVICE_ERROR explains, there can only be one userspace
    orangefs filesystem driver at once), that shouldn't be a problem.
    
    [
    Why does orangefs even exist in the kernel if everything does upcalls into
    userspace? What does orangefs do that couldn't be done with the FUSE
    interface? If there is no good answer to those questions, I'd prefer to see
    orangefs kicked out of the kernel. Can that be done for something that
    shipped in a release?
    
    According to commit f7ab093f74bf ("Orangefs: kernel client part 1"), they
    even already have a FUSE daemon, and the only rational reason (apart from
    "but most of our users report preferring to use our kernel module instead")
    given for not wanting to use FUSE is one "in-the-works" feature that could
    probably be integated into FUSE instead.
    ]
    
    This patch has been compile-tested.
    
    Signed-off-by: Jann Horn <jannh@google.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index db170beba797..a287a66d94e3 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -116,6 +116,13 @@ static int orangefs_devreq_open(struct inode *inode, struct file *file)
 {
 	int ret = -EINVAL;
 
+	/* in order to ensure that the filesystem driver sees correct UIDs */
+	if (file->f_cred->user_ns != &init_user_ns) {
+		gossip_err("%s: device cannot be opened outside init_user_ns\n",
+			   __func__);
+		goto out;
+	}
+
 	if (!(file->f_flags & O_NONBLOCK)) {
 		gossip_err("%s: device cannot be opened in blocking mode\n",
 			   __func__);

commit 45996492e5c85aa0ac93a95d1b2d1ed56851c865
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 25 19:56:34 2016 -0400

    orangefs: fix orangefs_superblock locking
    
    * switch orangefs_remount() to taking ORANGEFS_SB(sb) instead of sb
    * remove from the list _before_ orangefs_unmount() - request_mutex
    in the latter will make sure that nothing observed in the loop in
    ORANGEFS_DEV_REMOUNT_ALL handling will get freed until the end
    of loop
    * on removal, keep the forward pointer and zero the back one.  That
    way we can drop and regain the spinlock in the loop body (again,
    ORANGEFS_DEV_REMOUNT_ALL one) and still be able to get to the
    rest of the list.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 35418d0b77bf..db170beba797 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -572,8 +572,7 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 	struct dev_mask_info_s mask_info = { 0 };
 	struct dev_mask2_info_s mask2_info = { 0, 0 };
 	int upstream_kmod = 1;
-	struct list_head *tmp = NULL;
-	struct orangefs_sb_info_s *orangefs_sb = NULL;
+	struct orangefs_sb_info_s *orangefs_sb;
 
 	/* mtmoore: add locking here */
 
@@ -619,26 +618,32 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 		gossip_debug(GOSSIP_DEV_DEBUG,
 			     "%s: priority remount in progress\n",
 			     __func__);
-		list_for_each(tmp, &orangefs_superblocks) {
-			orangefs_sb =
-				list_entry(tmp,
-					   struct orangefs_sb_info_s,
-					   list);
-			if (orangefs_sb && (orangefs_sb->sb)) {
+		spin_lock(&orangefs_superblocks_lock);
+		list_for_each_entry(orangefs_sb, &orangefs_superblocks, list) {
+			/*
+			 * We have to drop the spinlock, so entries can be
+			 * removed.  They can't be freed, though, so we just
+			 * keep the forward pointers and zero the back ones -
+			 * that way we can get to the rest of the list.
+			 */
+			if (!orangefs_sb->list.prev)
+				continue;
+			gossip_debug(GOSSIP_DEV_DEBUG,
+				     "%s: Remounting SB %p\n",
+				     __func__,
+				     orangefs_sb);
+
+			spin_unlock(&orangefs_superblocks_lock);
+			ret = orangefs_remount(orangefs_sb);
+			spin_lock(&orangefs_superblocks_lock);
+			if (ret) {
 				gossip_debug(GOSSIP_DEV_DEBUG,
-					     "%s: Remounting SB %p\n",
-					     __func__,
+					     "SB %p remount failed\n",
 					     orangefs_sb);
-
-				ret = orangefs_remount(orangefs_sb->sb);
-				if (ret) {
-					gossip_debug(GOSSIP_DEV_DEBUG,
-						     "SB %p remount failed\n",
-						     orangefs_sb);
-					break;
-				}
+				break;
 			}
 		}
+		spin_unlock(&orangefs_superblocks_lock);
 		gossip_debug(GOSSIP_DEV_DEBUG,
 			     "%s: priority remount complete\n",
 			     __func__);

commit 53f57fef43f5b9586c7a78acdeae27e206eae48b
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Mon Mar 14 15:28:34 2016 -0400

    Orangefs: Extra sanity insurance on buffer before using string functions on it.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 12ea8730aa5d..35418d0b77bf 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -678,6 +678,19 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 		ret = copy_from_user(&client_debug_array_string,
 				     (void __user *)arg,
 				     ORANGEFS_MAX_DEBUG_STRING_LEN);
+		/*
+		 * The real client-core makes an effort to ensure
+		 * that actual strings that aren't too long to fit in
+		 * this buffer is what we get here. We're going to use
+		 * string functions on the stuff we got, so we'll make
+		 * this extra effort to try and keep from
+		 * flowing out of this buffer when we use the string
+		 * functions, even if somehow the stuff we end up
+		 * with here is garbage.
+		 */
+		client_debug_array_string[ORANGEFS_MAX_DEBUG_STRING_LEN - 1] =
+			'\0';
+		
 		if (ret != 0) {
 			pr_info("%s: CLIENT_STRING: copy_from_user failed\n",
 				__func__);

commit acfcbaf1925f2dc5c46c61de69d756dec92a2ff8
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Sat Mar 5 13:17:39 2016 -0500

    orangefs: make fs_mount_pending static
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 0f9a12ac7458..12ea8730aa5d 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -74,6 +74,44 @@ static struct orangefs_kernel_op_s *orangefs_devreq_remove_op(__u64 tag)
 	return NULL;
 }
 
+/* Returns whether any FS are still pending remounted */
+static int mark_all_pending_mounts(void)
+{
+	int unmounted = 1;
+	struct orangefs_sb_info_s *orangefs_sb = NULL;
+
+	spin_lock(&orangefs_superblocks_lock);
+	list_for_each_entry(orangefs_sb, &orangefs_superblocks, list) {
+		/* All of these file system require a remount */
+		orangefs_sb->mount_pending = 1;
+		unmounted = 0;
+	}
+	spin_unlock(&orangefs_superblocks_lock);
+	return unmounted;
+}
+
+/*
+ * Determine if a given file system needs to be remounted or not
+ *  Returns -1 on error
+ *           0 if already mounted
+ *           1 if needs remount
+ */
+static int fs_mount_pending(__s32 fsid)
+{
+	int mount_pending = -1;
+	struct orangefs_sb_info_s *orangefs_sb = NULL;
+
+	spin_lock(&orangefs_superblocks_lock);
+	list_for_each_entry(orangefs_sb, &orangefs_superblocks, list) {
+		if (orangefs_sb->fs_id == fsid) {
+			mount_pending = orangefs_sb->mount_pending;
+			break;
+		}
+	}
+	spin_unlock(&orangefs_superblocks_lock);
+	return mount_pending;
+}
+
 static int orangefs_devreq_open(struct inode *inode, struct file *file)
 {
 	int ret = -EINVAL;
@@ -449,44 +487,6 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 	goto wakeup;
 }
 
-/* Returns whether any FS are still pending remounted */
-static int mark_all_pending_mounts(void)
-{
-	int unmounted = 1;
-	struct orangefs_sb_info_s *orangefs_sb = NULL;
-
-	spin_lock(&orangefs_superblocks_lock);
-	list_for_each_entry(orangefs_sb, &orangefs_superblocks, list) {
-		/* All of these file system require a remount */
-		orangefs_sb->mount_pending = 1;
-		unmounted = 0;
-	}
-	spin_unlock(&orangefs_superblocks_lock);
-	return unmounted;
-}
-
-/*
- * Determine if a given file system needs to be remounted or not
- *  Returns -1 on error
- *           0 if already mounted
- *           1 if needs remount
- */
-int fs_mount_pending(__s32 fsid)
-{
-	int mount_pending = -1;
-	struct orangefs_sb_info_s *orangefs_sb = NULL;
-
-	spin_lock(&orangefs_superblocks_lock);
-	list_for_each_entry(orangefs_sb, &orangefs_superblocks, list) {
-		if (orangefs_sb->fs_id == fsid) {
-			mount_pending = orangefs_sb->mount_pending;
-			break;
-		}
-	}
-	spin_unlock(&orangefs_superblocks_lock);
-	return mount_pending;
-}
-
 /*
  * NOTE: gets called when the last reference to this device is dropped.
  * Using the open_access_count variable, we enforce a reference count

commit 9d9e7ba9ee8f304c4608f3c81aa5e7fb3bddd251
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Thu Mar 3 13:46:48 2016 -0500

    Orangefs: improve gossip statements
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index d50f89ea302e..0f9a12ac7458 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -245,6 +245,12 @@ static ssize_t orangefs_devreq_read(struct file *file,
 	 * it has been sent to the client.
 	 */
 	set_op_state_inprogress(cur_op);
+	gossip_debug(GOSSIP_DEV_DEBUG,
+		     "%s: 1 op:%s: op_state:%d: process:%s:\n",
+		     __func__,
+		     get_opname_string(cur_op),
+		     cur_op->op_state,
+		     current->comm);
 	orangefs_devreq_add_op(cur_op);
 	spin_unlock(&cur_op->lock);
 	spin_unlock(&htable_ops_in_progress_lock);
@@ -262,6 +268,12 @@ static ssize_t orangefs_devreq_read(struct file *file,
 	spin_lock(&cur_op->lock);
 	if (likely(!op_state_given_up(cur_op))) {
 		set_op_state_waiting(cur_op);
+		gossip_debug(GOSSIP_DEV_DEBUG,
+			     "%s: 2 op:%s: op_state:%d: process:%s:\n",
+			     __func__,
+			     get_opname_string(cur_op),
+			     cur_op->op_state,
+			     current->comm);
 		list_add(&cur_op->list, &orangefs_request_list);
 		spin_unlock(&cur_op->lock);
 	} else {
@@ -416,6 +428,12 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		complete(&op->waitq);
 	} else {
 		set_op_state_serviced(op);
+		gossip_debug(GOSSIP_DEV_DEBUG,
+			     "%s: op:%s: op_state:%d: process:%s:\n",
+			     __func__,
+			     get_opname_string(op),
+			     op->op_state,
+			     current->comm);
 		spin_unlock(&op->lock);
 	}
 	return ret;

commit 9f08cfe94417f782393330cbfc95617c04f051c2
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Feb 26 14:39:08 2016 -0500

    Orangefs: update orangefs.txt
    
    Al Viro has cleaned up the way ops are processed and waited for,
    now orangefs.txt has an overview of how it works. Several recent
    related commits have added to the comments in the code as well.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index e3934c06b96a..d50f89ea302e 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -404,8 +404,8 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 
 wakeup:
 	/*
-	 * tell the vfs op waiting on a waitqueue
-	 * that this op is done
+	 * Return to vfs waitqueue, and back to service_operation
+	 * through wait_for_matching_downcall. 
 	 */
 	spin_lock(&op->lock);
 	if (unlikely(op_is_cancel(op))) {

commit ca9f518eadeb7edd8e438a6542d3caec9bc3bb74
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Feb 26 10:21:12 2016 -0500

    Orangefs: code sanitation.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 0db3a57f974d..e3934c06b96a 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -46,6 +46,10 @@ static void orangefs_devreq_add_op(struct orangefs_kernel_op_s *op)
 	list_add_tail(&op->list, &htable_ops_in_progress[index]);
 }
 
+/*
+ * find the op with this tag and remove it from the in progress
+ * hash table.
+ */
 static struct orangefs_kernel_op_s *orangefs_devreq_remove_op(__u64 tag)
 {
 	struct orangefs_kernel_op_s *op, *next;
@@ -190,8 +194,10 @@ static ssize_t orangefs_devreq_read(struct file *file,
 		return -EAGAIN;
 	}
 
-	gossip_debug(GOSSIP_DEV_DEBUG, "orangefs: reading op tag %llu %s\n",
-		     llu(cur_op->tag), get_opname_string(cur_op));
+	gossip_debug(GOSSIP_DEV_DEBUG, "%s: reading op tag %llu %s\n",
+		     __func__,
+		     llu(cur_op->tag),
+		     get_opname_string(cur_op));
 
 	/*
 	 * Such an op should never be on the list in the first place. If so, we
@@ -204,6 +210,7 @@ static ssize_t orangefs_devreq_read(struct file *file,
 		spin_unlock(&orangefs_request_list_lock);
 		return -EAGAIN;
 	}
+
 	list_del_init(&cur_op->list);
 	spin_unlock(&orangefs_request_list_lock);
 
@@ -323,6 +330,7 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		return -EPROTO;
 	}
 
+	/* remove the op from the in progress hash table */
 	op = orangefs_devreq_remove_op(head.tag);
 	if (!op) {
 		gossip_err("WARNING: No one's waiting for tag %llu\n",
@@ -486,15 +494,7 @@ static int orangefs_devreq_release(struct inode *inode, struct file *file)
 	gossip_debug(GOSSIP_DEV_DEBUG, "ORANGEFS Device Close: Filesystem(s) %s\n",
 		     (unmounted ? "UNMOUNTED" : "MOUNTED"));
 
-	/*
-	 * Walk through the list of ops in the request list, mark them
-	 * as purged and wake them up.
-	 */
 	purge_waiting_ops();
-	/*
-	 * Walk through the hash table of in progress operations; mark
-	 * them as purged and wake them up
-	 */
 	purge_inprogress_ops();
 
 	orangefs_bufmap_run_down();

commit adcf34a2893386c99e80feee36e30a782b3815e7
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Feb 24 16:54:27 2016 -0500

    Orangefs: code sanitation
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index f7914f5d296f..0db3a57f974d 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -590,7 +590,7 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 		 * remount all mounted orangefs volumes to regain the lost
 		 * dynamic mount tables (if any) -- NOTE: this is done
 		 * without keeping the superblock list locked due to the
-		 * upcall/downcall waiting.  also, the request semaphore is
+		 * upcall/downcall waiting.  also, the request mutex is
 		 * used to ensure that no operations will be serviced until
 		 * all of the remounts are serviced (to avoid ops between
 		 * mounts to fail)

commit 05a50a5be897004b6c1399645256bcf2e768b4ef
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Feb 18 18:59:44 2016 -0500

    orangefs: have ..._clean_interrupted_...() wait for copy to/from daemon
    
    * turn all those list_del(&op->list) into list_del_init()
    * don't pick ops that are already given up in control device
      ->read()/->write_iter().
    * have orangefs_clean_interrupted_operation() notice if op is currently
      being copied to/from daemon (by said ->read()/->write_iter()) and
      wait for that to finish.
    * when we are done copying to/from daemon and find that it had been
      given up while we were doing that, wake the waiting ..._clean_interrupted_...
    
    As the result, we are guaranteed that orangefs_clean_interrupted_operation(op)
    doesn't return until nobody else can see op.  Moreover, we don't need to play
    with op refcounts anymore.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 89c282afeb29..f7914f5d296f 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -58,9 +58,9 @@ static struct orangefs_kernel_op_s *orangefs_devreq_remove_op(__u64 tag)
 				 next,
 				 &htable_ops_in_progress[index],
 				 list) {
-		if (op->tag == tag && !op_state_purged(op)) {
+		if (op->tag == tag && !op_state_purged(op) &&
+		    !op_state_given_up(op)) {
 			list_del_init(&op->list);
-			get_op(op); /* increase ref count. */
 			spin_unlock(&htable_ops_in_progress_lock);
 			return op;
 		}
@@ -133,7 +133,7 @@ static ssize_t orangefs_devreq_read(struct file *file,
 		__s32 fsid;
 		/* This lock is held past the end of the loop when we break. */
 		spin_lock(&op->lock);
-		if (unlikely(op_state_purged(op))) {
+		if (unlikely(op_state_purged(op) || op_state_given_up(op))) {
 			spin_unlock(&op->lock);
 			continue;
 		}
@@ -199,13 +199,12 @@ static ssize_t orangefs_devreq_read(struct file *file,
 	 */
 	if (op_state_in_progress(cur_op) || op_state_serviced(cur_op)) {
 		gossip_err("orangefs: ERROR: Current op already queued.\n");
-		list_del(&cur_op->list);
+		list_del_init(&cur_op->list);
 		spin_unlock(&cur_op->lock);
 		spin_unlock(&orangefs_request_list_lock);
 		return -EAGAIN;
 	}
 	list_del_init(&cur_op->list);
-	get_op(op);
 	spin_unlock(&orangefs_request_list_lock);
 
 	spin_unlock(&cur_op->lock);
@@ -230,7 +229,7 @@ static ssize_t orangefs_devreq_read(struct file *file,
 	if (unlikely(op_state_given_up(cur_op))) {
 		spin_unlock(&cur_op->lock);
 		spin_unlock(&htable_ops_in_progress_lock);
-		op_release(cur_op);
+		complete(&cur_op->waitq);
 		goto restart;
 	}
 
@@ -242,7 +241,6 @@ static ssize_t orangefs_devreq_read(struct file *file,
 	orangefs_devreq_add_op(cur_op);
 	spin_unlock(&cur_op->lock);
 	spin_unlock(&htable_ops_in_progress_lock);
-	op_release(cur_op);
 
 	/* The client only asks to read one size buffer. */
 	return MAX_DEV_REQ_UPSIZE;
@@ -258,10 +256,12 @@ static ssize_t orangefs_devreq_read(struct file *file,
 	if (likely(!op_state_given_up(cur_op))) {
 		set_op_state_waiting(cur_op);
 		list_add(&cur_op->list, &orangefs_request_list);
+		spin_unlock(&cur_op->lock);
+	} else {
+		spin_unlock(&cur_op->lock);
+		complete(&cur_op->waitq);
 	}
-	spin_unlock(&cur_op->lock);
 	spin_unlock(&orangefs_request_list_lock);
-	op_release(cur_op);
 	return -EFAULT;
 }
 
@@ -405,11 +405,11 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		put_cancel(op);
 	} else if (unlikely(op_state_given_up(op))) {
 		spin_unlock(&op->lock);
+		complete(&op->waitq);
 	} else {
 		set_op_state_serviced(op);
 		spin_unlock(&op->lock);
 	}
-	op_release(op);
 	return ret;
 
 Efault:

commit 5964c1b83912dd5052f66ceb50634df958129981
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Feb 18 18:53:41 2016 -0500

    orangefs: set correct ->downcall.status on failing to copy reply from daemon
    
    ... and clean the end of control device ->write_iter() while we are at it
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index b27ed1cb9a36..89c282afeb29 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -333,8 +333,7 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 	n = copy_from_iter(&op->downcall, downcall_size, iter);
 	if (n != downcall_size) {
 		gossip_err("%s: failed to copy downcall.\n", __func__);
-		ret = -EFAULT;
-		goto Broken;
+		goto Efault;
 	}
 
 	if (op->downcall.status)
@@ -354,8 +353,7 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 			   downcall_size,
 			   op->downcall.trailer_size,
 			   total);
-		ret = -EFAULT;
-		goto Broken;
+		goto Efault;
 	}
 
 	/* Only READDIR operations should have trailers. */
@@ -364,8 +362,7 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		gossip_err("%s: %x operation with trailer.",
 			   __func__,
 			   op->downcall.type);
-		ret = -EFAULT;
-		goto Broken;
+		goto Efault;
 	}
 
 	/* READDIR operations should always have trailers. */
@@ -374,8 +371,7 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		gossip_err("%s: %x operation with no trailer.",
 			   __func__,
 			   op->downcall.type);
-		ret = -EFAULT;
-		goto Broken;
+		goto Efault;
 	}
 
 	if (op->downcall.type != ORANGEFS_VFS_OP_READDIR)
@@ -386,8 +382,7 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 	if (op->downcall.trailer_buf == NULL) {
 		gossip_err("%s: failed trailer vmalloc.\n",
 			   __func__);
-		ret = -ENOMEM;
-		goto Broken;
+		goto Enomem;
 	}
 	memset(op->downcall.trailer_buf, 0, op->downcall.trailer_size);
 	n = copy_from_iter(op->downcall.trailer_buf,
@@ -396,8 +391,7 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 	if (n != op->downcall.trailer_size) {
 		gossip_err("%s: failed to copy trailer.\n", __func__);
 		vfree(op->downcall.trailer_buf);
-		ret = -EFAULT;
-		goto Broken;
+		goto Efault;
 	}
 
 wakeup:
@@ -406,38 +400,27 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 	 * that this op is done
 	 */
 	spin_lock(&op->lock);
-	if (unlikely(op_state_given_up(op))) {
+	if (unlikely(op_is_cancel(op))) {
 		spin_unlock(&op->lock);
-		goto out;
-	}
-	set_op_state_serviced(op);
-	spin_unlock(&op->lock);
-
-	/*
-	 * If this operation is an I/O operation we need to wait
-	 * for all data to be copied before we can return to avoid
-	 * buffer corruption and races that can pull the buffers
-	 * out from under us.
-	 *
-	 * Essentially we're synchronizing with other parts of the
-	 * vfs implicitly by not allowing the user space
-	 * application reading/writing this device to return until
-	 * the buffers are done being used.
-	 */
-out:
-	if (unlikely(op_is_cancel(op)))
 		put_cancel(op);
+	} else if (unlikely(op_state_given_up(op))) {
+		spin_unlock(&op->lock);
+	} else {
+		set_op_state_serviced(op);
+		spin_unlock(&op->lock);
+	}
 	op_release(op);
 	return ret;
 
-Broken:
-	spin_lock(&op->lock);
-	if (!op_state_given_up(op)) {
-		op->downcall.status = ret;
-		set_op_state_serviced(op);
-	}
-	spin_unlock(&op->lock);
-	goto out;
+Efault:
+	op->downcall.status = -(ORANGEFS_ERROR_BIT | 9);
+	ret = -EFAULT;
+	goto wakeup;
+
+Enomem:
+	op->downcall.status = -(ORANGEFS_ERROR_BIT | 8);
+	ret = -ENOMEM;
+	goto wakeup;
 }
 
 /* Returns whether any FS are still pending remounted */

commit 897c5df6cf8c10d2557c098641faa62f65ef8598
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Feb 13 21:06:50 2016 -0500

    orangefs: get rid of op->done
    
    shouldn't be needed now
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 790855a72e32..b27ed1cb9a36 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -424,19 +424,6 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 	 * application reading/writing this device to return until
 	 * the buffers are done being used.
 	 */
-	if (op->downcall.type == ORANGEFS_VFS_OP_FILE_IO) {
-		long n = wait_for_completion_interruptible_timeout(&op->done,
-							op_timeout_secs * HZ);
-		if (unlikely(n < 0)) {
-			gossip_debug(GOSSIP_DEV_DEBUG,
-				"%s: signal on I/O wait, aborting\n",
-				__func__);
-		} else if (unlikely(n == 0)) {
-			gossip_debug(GOSSIP_DEV_DEBUG,
-				"%s: timed out.\n",
-				__func__);
-		}
-	}
 out:
 	if (unlikely(op_is_cancel(op)))
 		put_cancel(op);

commit ea2c9c9f6574e835cbc903c94b82b5a34a334866
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Feb 13 21:01:21 2016 -0500

    orangefs: bufmap rewrite
    
    new waiting-for-slot logics:
            * make request for slot wait for bufmap to be set up if it
    comes before it's installed *OR* while it's running down
            * make closing control device wait for all slots to be freed
            * waiting itself rewritten to (open-coded) analogues of wait_event_...
    primitives - we would need wait_event_locked() and, pardon an obscenely
    long name, wait_event_interruptible_exclusive_timeout_locked().
            * we never wait for more than slot_timeout_secs in total and,
    if during the wait the daemon goes away, we only allow
    ORANGEFS_BUFMAP_WAIT_TIMEOUT_SECS for it to come back.
            * (cosmetical) bitmap is used instead of an array of zeroes and ones
            * old (and only reached if we are about to corrupt memory) waiting
    for daemon restart in service_operation() removed.
    
    [Martin's fixes folded]
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 6a7df1204bfc..790855a72e32 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -508,8 +508,7 @@ static int orangefs_devreq_release(struct inode *inode, struct file *file)
 		     __func__);
 
 	mutex_lock(&devreq_mutex);
-	if (orangefs_get_bufmap_init())
-		orangefs_bufmap_finalize();
+	orangefs_bufmap_finalize();
 
 	open_access_count = -1;
 
@@ -527,6 +526,9 @@ static int orangefs_devreq_release(struct inode *inode, struct file *file)
 	 * them as purged and wake them up
 	 */
 	purge_inprogress_ops();
+
+	orangefs_bufmap_run_down();
+
 	gossip_debug(GOSSIP_DEV_DEBUG,
 		     "pvfs2-client-core: device close complete\n");
 	open_access_count = 0;
@@ -607,13 +609,8 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 				     (struct ORANGEFS_dev_map_desc __user *)
 				     arg,
 				     sizeof(struct ORANGEFS_dev_map_desc));
-		if (orangefs_get_bufmap_init()) {
-			return -EINVAL;
-		} else {
-			return ret ?
-			       -EIO :
-			       orangefs_bufmap_initialize(&user_desc);
-		}
+		/* WTF -EIO and not -EFAULT? */
+		return ret ? -EIO : orangefs_bufmap_initialize(&user_desc);
 	case ORANGEFS_DEV_REMOUNT_ALL:
 		gossip_debug(GOSSIP_DEV_DEBUG,
 			     "%s: got ORANGEFS_DEV_REMOUNT_ALL\n",

commit 78699e29fd784a4613d254a22627f336c55c4a76
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Feb 11 23:07:19 2016 -0500

    orangefs: delay freeing slot until cancel completes
    
    Make cancels reuse the aborted read/write op, to make sure they do not
    fail on lack of memory.
    
    Don't issue a cancel unless the daemon has seen our read/write, has not
    replied and isn't being shut down.
    
    If cancel *is* issued, don't wait for it to complete; stash the slot
    in there and just have it freed when cancel is finally replied to or
    purged (and delay dropping the reference until then, obviously).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 37278f5878b3..6a7df1204bfc 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -438,6 +438,8 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		}
 	}
 out:
+	if (unlikely(op_is_cancel(op)))
+		put_cancel(op);
 	op_release(op);
 	return ret;
 
@@ -546,6 +548,11 @@ int is_daemon_in_service(void)
 	return in_service;
 }
 
+bool __is_daemon_in_service(void)
+{
+	return open_access_count == 1;
+}
+
 static inline long check_ioctl_command(unsigned int command)
 {
 	/* Check for valid ioctl codes */

commit 5090c9670de03511834bc894cfc9737e3d61a414
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Thu Feb 4 13:29:27 2016 -0500

    Orangefs: improve gossip statement
    
    There were two just alike, making it hard maybe to tell which one
    you were looking at in syslog... so I changed it a little by adding
    some extra interesting tidbits to it...
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 812844faa7f5..37278f5878b3 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -145,8 +145,11 @@ static ssize_t orangefs_devreq_read(struct file *file,
 			ret = fs_mount_pending(fsid);
 			if (ret == 1) {
 				gossip_debug(GOSSIP_DEV_DEBUG,
-				    "orangefs: skipping op tag %llu %s\n",
-				    llu(op->tag), get_opname_string(op));
+				    "%s: mount pending, skipping op tag "
+				    "%llu %s\n",
+				    __func__,
+				    llu(op->tag),
+				    get_opname_string(op));
 				spin_unlock(&op->lock);
 				continue;
 			/*

commit 2a9e5c22605f5db6040535b10dce5fbc3a7db3bd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 23 13:45:46 2016 -0500

    orangefs: don't reinvent completion.h...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 3879f2b7cf29..812844faa7f5 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -398,6 +398,17 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 	}
 
 wakeup:
+	/*
+	 * tell the vfs op waiting on a waitqueue
+	 * that this op is done
+	 */
+	spin_lock(&op->lock);
+	if (unlikely(op_state_given_up(op))) {
+		spin_unlock(&op->lock);
+		goto out;
+	}
+	set_op_state_serviced(op);
+	spin_unlock(&op->lock);
 
 	/*
 	 * If this operation is an I/O operation we need to wait
@@ -411,61 +422,17 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 	 * the buffers are done being used.
 	 */
 	if (op->downcall.type == ORANGEFS_VFS_OP_FILE_IO) {
-		DEFINE_WAIT(wait_entry);
-
-		/*
-		 * tell the vfs op waiting on a waitqueue
-		 * that this op is done
-		 */
-		spin_lock(&op->lock);
-		if (unlikely(op_state_given_up(op))) {
-			spin_unlock(&op->lock);
-			goto out;
-		}
-		set_op_state_serviced(op);
-		spin_unlock(&op->lock);
-
-		while (1) {
-			spin_lock(&op->lock);
-			prepare_to_wait_exclusive(
-				&op->io_completion_waitq,
-				&wait_entry,
-				TASK_INTERRUPTIBLE);
-			if (op->io_completed) {
-				spin_unlock(&op->lock);
-				break;
-			}
-			spin_unlock(&op->lock);
-			if (unlikely(signal_pending(current))) {
-				gossip_debug(GOSSIP_DEV_DEBUG,
-					"%s: signal on I/O wait, aborting\n",
-					__func__);
-				break;
-			}
-
-			if (!schedule_timeout(op_timeout_secs * HZ)) {
-				gossip_debug(GOSSIP_DEV_DEBUG,
-					"%s: timed out.\n",
-					__func__);
-				break;
-			}
+		long n = wait_for_completion_interruptible_timeout(&op->done,
+							op_timeout_secs * HZ);
+		if (unlikely(n < 0)) {
+			gossip_debug(GOSSIP_DEV_DEBUG,
+				"%s: signal on I/O wait, aborting\n",
+				__func__);
+		} else if (unlikely(n == 0)) {
+			gossip_debug(GOSSIP_DEV_DEBUG,
+				"%s: timed out.\n",
+				__func__);
 		}
-
-		spin_lock(&op->lock);
-		finish_wait(&op->io_completion_waitq, &wait_entry);
-		spin_unlock(&op->lock);
-	} else {
-		/*
-		 * tell the vfs op waiting on a waitqueue that
-		 * this op is done -
-		 * for every other operation (i.e. non-I/O), we need to
-		 * wake up the callers for downcall completion
-		 * notification
-		 */
-		spin_lock(&op->lock);
-		if (!op_state_given_up(op))
-			set_op_state_serviced(op);
-		spin_unlock(&op->lock);
 	}
 out:
 	op_release(op);

commit 4f55e39732ad0bd05d70c88e174e747d55e3685c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 23 13:27:50 2016 -0500

    if ORANGEFS_VFS_OP_FILE_IO request had been given up, don't bother waiting
    
    ... we are not going to get woken up anyway, so it's just going to time out
    and whine.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index d8c436a0aa1b..3879f2b7cf29 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -418,8 +418,11 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		 * that this op is done
 		 */
 		spin_lock(&op->lock);
-		if (!op_state_given_up(op))
-			set_op_state_serviced(op);
+		if (unlikely(op_state_given_up(op))) {
+			spin_unlock(&op->lock);
+			goto out;
+		}
+		set_op_state_serviced(op);
 		spin_unlock(&op->lock);
 
 		while (1) {
@@ -433,22 +436,19 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 				break;
 			}
 			spin_unlock(&op->lock);
-
-			if (!signal_pending(current)) {
-				int timeout = op_timeout_secs * HZ;
-				if (!schedule_timeout(timeout)) {
-					gossip_debug(GOSSIP_DEV_DEBUG,
-						"%s: timed out.\n",
-						__func__);
-					break;
-				}
-				continue;
+			if (unlikely(signal_pending(current))) {
+				gossip_debug(GOSSIP_DEV_DEBUG,
+					"%s: signal on I/O wait, aborting\n",
+					__func__);
+				break;
 			}
 
-			gossip_debug(GOSSIP_DEV_DEBUG,
-				"%s: signal on I/O wait, aborting\n",
-				__func__);
-			break;
+			if (!schedule_timeout(op_timeout_secs * HZ)) {
+				gossip_debug(GOSSIP_DEV_DEBUG,
+					"%s: timed out.\n",
+					__func__);
+				break;
+			}
 		}
 
 		spin_lock(&op->lock);

commit 727cbfea623b78d46ce8e0f8c931b5189f3fe2e0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 23 13:17:55 2016 -0500

    orangefs: get rid of MSECS_TO_JIFFIES
    
    All timeouts are in _seconds_, so all calls are of form
    MSECS_TO_JIFFIES(n * 1000), which is a convoluted way to
    spell n * HZ.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index b7a6aa44ce3e..d8c436a0aa1b 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -435,9 +435,7 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 			spin_unlock(&op->lock);
 
 			if (!signal_pending(current)) {
-				int timeout =
-				    MSECS_TO_JIFFIES(1000 *
-						     op_timeout_secs);
+				int timeout = op_timeout_secs * HZ;
 				if (!schedule_timeout(timeout)) {
 					gossip_debug(GOSSIP_DEV_DEBUG,
 						"%s: timed out.\n",

commit ed42fe059389daa35a2aa10ec832e9f8d0a9e59e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jan 22 19:47:47 2016 -0500

    orangefs: hopefully saner op refcounting and locking
    
    * create with refcount 1
    * make op_release() decrement and free if zero (i.e. old put_op()
      has become that).
    * mark when submitter has given up waiting; from that point nobody
      else can move between the lists, change state, etc.
    * have daemon read/write_iter grab a reference when picking op
      and *always* give it up in the end
    * don't put into hash until we know it's been successfully passed to
      daemon
    
    * move op->lock _lower_ than htab_in_progress_lock (and make sure
      to take it in purge_inprogress_ops())
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 92573d9cc17c..b7a6aa44ce3e 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -43,9 +43,7 @@ static void orangefs_devreq_add_op(struct orangefs_kernel_op_s *op)
 {
 	int index = hash_func(op->tag, hash_table_size);
 
-	spin_lock(&htable_ops_in_progress_lock);
 	list_add_tail(&op->list, &htable_ops_in_progress[index]);
-	spin_unlock(&htable_ops_in_progress_lock);
 }
 
 static struct orangefs_kernel_op_s *orangefs_devreq_remove_op(__u64 tag)
@@ -60,8 +58,9 @@ static struct orangefs_kernel_op_s *orangefs_devreq_remove_op(__u64 tag)
 				 next,
 				 &htable_ops_in_progress[index],
 				 list) {
-		if (op->tag == tag) {
-			list_del(&op->list);
+		if (op->tag == tag && !op_state_purged(op)) {
+			list_del_init(&op->list);
+			get_op(op); /* increase ref count. */
 			spin_unlock(&htable_ops_in_progress_lock);
 			return op;
 		}
@@ -127,12 +126,17 @@ static ssize_t orangefs_devreq_read(struct file *file,
 		return -EINVAL;
 	}
 
+restart:
 	/* Get next op (if any) from top of list. */
 	spin_lock(&orangefs_request_list_lock);
 	list_for_each_entry_safe(op, temp, &orangefs_request_list, list) {
 		__s32 fsid;
 		/* This lock is held past the end of the loop when we break. */
 		spin_lock(&op->lock);
+		if (unlikely(op_state_purged(op))) {
+			spin_unlock(&op->lock);
+			continue;
+		}
 
 		fsid = fsid_of_op(op);
 		if (fsid != ORANGEFS_FS_ID_NULL) {
@@ -197,16 +201,10 @@ static ssize_t orangefs_devreq_read(struct file *file,
 		spin_unlock(&orangefs_request_list_lock);
 		return -EAGAIN;
 	}
-
-	/*
-	 * Set the operation to be in progress and move it between lists since
-	 * it has been sent to the client.
-	 */
-	set_op_state_inprogress(cur_op);
-
-	list_del(&cur_op->list);
+	list_del_init(&cur_op->list);
+	get_op(op);
 	spin_unlock(&orangefs_request_list_lock);
-	orangefs_devreq_add_op(cur_op);
+
 	spin_unlock(&cur_op->lock);
 
 	/* Push the upcall out. */
@@ -224,6 +222,25 @@ static ssize_t orangefs_devreq_read(struct file *file,
 	if (ret != 0)
 		goto error;
 
+	spin_lock(&htable_ops_in_progress_lock);
+	spin_lock(&cur_op->lock);
+	if (unlikely(op_state_given_up(cur_op))) {
+		spin_unlock(&cur_op->lock);
+		spin_unlock(&htable_ops_in_progress_lock);
+		op_release(cur_op);
+		goto restart;
+	}
+
+	/*
+	 * Set the operation to be in progress and move it between lists since
+	 * it has been sent to the client.
+	 */
+	set_op_state_inprogress(cur_op);
+	orangefs_devreq_add_op(cur_op);
+	spin_unlock(&cur_op->lock);
+	spin_unlock(&htable_ops_in_progress_lock);
+	op_release(cur_op);
+
 	/* The client only asks to read one size buffer. */
 	return MAX_DEV_REQ_UPSIZE;
 error:
@@ -235,11 +252,13 @@ static ssize_t orangefs_devreq_read(struct file *file,
 	gossip_err("orangefs: Failed to copy data to user space\n");
 	spin_lock(&orangefs_request_list_lock);
 	spin_lock(&cur_op->lock);
-	set_op_state_waiting(cur_op);
-	orangefs_devreq_remove_op(cur_op->tag);
-	list_add(&cur_op->list, &orangefs_request_list);
+	if (likely(!op_state_given_up(cur_op))) {
+		set_op_state_waiting(cur_op);
+		list_add(&cur_op->list, &orangefs_request_list);
+	}
 	spin_unlock(&cur_op->lock);
 	spin_unlock(&orangefs_request_list_lock);
+	op_release(cur_op);
 	return -EFAULT;
 }
 
@@ -278,15 +297,13 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 			   __func__,
 			   total,
 			   (unsigned int) MAX_DEV_REQ_DOWNSIZE);
-		ret = -EFAULT;
-		goto out;
+		return -EFAULT;
 	}
      
 	n = copy_from_iter(&head, head_size, iter);
 	if (n < head_size) {
 		gossip_err("%s: failed to copy head.\n", __func__);
-		ret = -EFAULT;
-		goto out;
+		return -EFAULT;
 	}
 
 	if (head.version < ORANGEFS_MINIMUM_USERSPACE_VERSION) {
@@ -295,31 +312,26 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 			   __func__,
 			   head.version,
 			   ORANGEFS_MINIMUM_USERSPACE_VERSION);
-		ret = -EPROTO;
-		goto out;
+		return -EPROTO;
 	}
 
 	if (head.magic != ORANGEFS_DEVREQ_MAGIC) {
 		gossip_err("Error: Device magic number does not match.\n");
-		ret = -EPROTO;
-		goto out;
+		return -EPROTO;
 	}
 
 	op = orangefs_devreq_remove_op(head.tag);
 	if (!op) {
 		gossip_err("WARNING: No one's waiting for tag %llu\n",
 			   llu(head.tag));
-		goto out;
+		return ret;
 	}
 
-	get_op(op); /* increase ref count. */
-
 	n = copy_from_iter(&op->downcall, downcall_size, iter);
 	if (n != downcall_size) {
 		gossip_err("%s: failed to copy downcall.\n", __func__);
-		put_op(op);
 		ret = -EFAULT;
-		goto out;
+		goto Broken;
 	}
 
 	if (op->downcall.status)
@@ -339,9 +351,8 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 			   downcall_size,
 			   op->downcall.trailer_size,
 			   total);
-		put_op(op);
 		ret = -EFAULT;
-		goto out;
+		goto Broken;
 	}
 
 	/* Only READDIR operations should have trailers. */
@@ -350,9 +361,8 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		gossip_err("%s: %x operation with trailer.",
 			   __func__,
 			   op->downcall.type);
-		put_op(op);
 		ret = -EFAULT;
-		goto out;
+		goto Broken;
 	}
 
 	/* READDIR operations should always have trailers. */
@@ -361,9 +371,8 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		gossip_err("%s: %x operation with no trailer.",
 			   __func__,
 			   op->downcall.type);
-		put_op(op);
 		ret = -EFAULT;
-		goto out;
+		goto Broken;
 	}
 
 	if (op->downcall.type != ORANGEFS_VFS_OP_READDIR)
@@ -374,9 +383,8 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 	if (op->downcall.trailer_buf == NULL) {
 		gossip_err("%s: failed trailer vmalloc.\n",
 			   __func__);
-		put_op(op);
 		ret = -ENOMEM;
-		goto out;
+		goto Broken;
 	}
 	memset(op->downcall.trailer_buf, 0, op->downcall.trailer_size);
 	n = copy_from_iter(op->downcall.trailer_buf,
@@ -385,9 +393,8 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 	if (n != op->downcall.trailer_size) {
 		gossip_err("%s: failed to copy trailer.\n", __func__);
 		vfree(op->downcall.trailer_buf);
-		put_op(op);
 		ret = -EFAULT;
-		goto out;
+		goto Broken;
 	}
 
 wakeup:
@@ -404,7 +411,6 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 	 * the buffers are done being used.
 	 */
 	if (op->downcall.type == ORANGEFS_VFS_OP_FILE_IO) {
-		int timed_out = 0;
 		DEFINE_WAIT(wait_entry);
 
 		/*
@@ -412,7 +418,8 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		 * that this op is done
 		 */
 		spin_lock(&op->lock);
-		set_op_state_serviced(op);
+		if (!op_state_given_up(op))
+			set_op_state_serviced(op);
 		spin_unlock(&op->lock);
 
 		while (1) {
@@ -435,7 +442,6 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 					gossip_debug(GOSSIP_DEV_DEBUG,
 						"%s: timed out.\n",
 						__func__);
-					timed_out = 1;
 					break;
 				}
 				continue;
@@ -450,15 +456,6 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		spin_lock(&op->lock);
 		finish_wait(&op->io_completion_waitq, &wait_entry);
 		spin_unlock(&op->lock);
-
-		/* NOTE: for I/O operations we handle releasing the op
-		 * object except in the case of timeout.  the reason we
-		 * can't free the op in timeout cases is that the op
-		 * service logic in the vfs retries operations using
-		 * the same op ptr, thus it can't be freed.
-		 */
-		if (!timed_out)
-			op_release(op);
 	} else {
 		/*
 		 * tell the vfs op waiting on a waitqueue that
@@ -468,11 +465,22 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		 * notification
 		 */
 		spin_lock(&op->lock);
-		set_op_state_serviced(op);
+		if (!op_state_given_up(op))
+			set_op_state_serviced(op);
 		spin_unlock(&op->lock);
 	}
 out:
+	op_release(op);
 	return ret;
+
+Broken:
+	spin_lock(&op->lock);
+	if (!op_state_given_up(op)) {
+		op->downcall.status = ret;
+		set_op_state_serviced(op);
+	}
+	spin_unlock(&op->lock);
+	goto out;
 }
 
 /* Returns whether any FS are still pending remounted */

commit fee25ce12504ff071254fd213055c3f1d3004622
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jan 22 19:46:08 2016 -0500

    orangefs: make sure that reopening pvfs2-req won't overlap with the end of close
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index dadeb381f9fc..92573d9cc17c 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -85,7 +85,7 @@ static int orangefs_devreq_open(struct inode *inode, struct file *file)
 	mutex_lock(&devreq_mutex);
 
 	if (open_access_count == 0) {
-		open_access_count++;
+		open_access_count = 1;
 		ret = 0;
 	} else {
 		DUMP_DEVICE_ERROR();
@@ -533,12 +533,11 @@ static int orangefs_devreq_release(struct inode *inode, struct file *file)
 	if (orangefs_get_bufmap_init())
 		orangefs_bufmap_finalize();
 
-	open_access_count--;
+	open_access_count = -1;
 
 	unmounted = mark_all_pending_mounts();
 	gossip_debug(GOSSIP_DEV_DEBUG, "ORANGEFS Device Close: Filesystem(s) %s\n",
 		     (unmounted ? "UNMOUNTED" : "MOUNTED"));
-	mutex_unlock(&devreq_mutex);
 
 	/*
 	 * Walk through the list of ops in the request list, mark them
@@ -552,6 +551,8 @@ static int orangefs_devreq_release(struct inode *inode, struct file *file)
 	purge_inprogress_ops();
 	gossip_debug(GOSSIP_DEV_DEBUG,
 		     "pvfs2-client-core: device close complete\n");
+	open_access_count = 0;
+	mutex_unlock(&devreq_mutex);
 	return 0;
 }
 

commit 831d0949799be75ed84c1c6a4541ebcd74edba6c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jan 21 23:17:37 2016 -0500

    orangefs: move wakeups into set_op_state_{serviced,purged}()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index b58fab2a9c26..dadeb381f9fc 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -415,8 +415,6 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		set_op_state_serviced(op);
 		spin_unlock(&op->lock);
 
-		wake_up_interruptible(&op->waitq);
-
 		while (1) {
 			spin_lock(&op->lock);
 			prepare_to_wait_exclusive(
@@ -464,17 +462,14 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 	} else {
 		/*
 		 * tell the vfs op waiting on a waitqueue that
-		 * this op is done
-		 */
-		spin_lock(&op->lock);
-		set_op_state_serviced(op);
-		spin_unlock(&op->lock);
-		/*
+		 * this op is done -
 		 * for every other operation (i.e. non-I/O), we need to
 		 * wake up the callers for downcall completion
 		 * notification
 		 */
-		wake_up_interruptible(&op->waitq);
+		spin_lock(&op->lock);
+		set_op_state_serviced(op);
+		spin_unlock(&op->lock);
 	}
 out:
 	return ret;

commit 90e54e36c95536a476db0fe01daa556d647aca2c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jan 19 12:07:49 2016 -0500

    orangefs: ->poll() doesn't need spinlock
    
    not just for list_empty()...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 456b5189f772..b58fab2a9c26 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -941,10 +941,8 @@ static unsigned int orangefs_devreq_poll(struct file *file,
 
 	poll_wait(file, &orangefs_request_list_waitq, poll_table);
 
-	spin_lock(&orangefs_request_list_lock);
 	if (!list_empty(&orangefs_request_list))
 		poll_revent_mask |= POLL_IN;
-	spin_unlock(&orangefs_request_list_lock);
 	return poll_revent_mask;
 }
 

commit 8016387ce78b4c5147241b798cf6d1fa400e4944
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jan 19 12:05:47 2016 -0500

    orangefs: kill ioctl32 rudiments
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 4cecc7c4f760..456b5189f772 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -898,23 +898,6 @@ static long orangefs_devreq_compat_ioctl(struct file *filp, unsigned int cmd,
 
 #endif /* CONFIG_COMPAT is in .config */
 
-/*
- * The following two ioctl32 functions had been refactored into the above
- * CONFIG_COMPAT ifdef, but that was an over simplification that was
- * not noticed until we tried to compile on power pc...
- */
-#if (defined(CONFIG_COMPAT) && !defined(HAVE_REGISTER_IOCTL32_CONVERSION)) || !defined(CONFIG_COMPAT)
-static int orangefs_ioctl32_init(void)
-{
-	return 0;
-}
-
-static void orangefs_ioctl32_cleanup(void)
-{
-	return;
-}
-#endif
-
 /* the assigned character device major number */
 static int orangefs_dev_major;
 
@@ -924,13 +907,6 @@ static int orangefs_dev_major;
  */
 int orangefs_dev_init(void)
 {
-	int ret;
-
-	/* register the ioctl32 sub-system */
-	ret = orangefs_ioctl32_init();
-	if (ret < 0)
-		return ret;
-
 	/* register orangefs-req device  */
 	orangefs_dev_major = register_chrdev(0,
 					  ORANGEFS_REQDEVICE_NAME,
@@ -939,7 +915,6 @@ int orangefs_dev_init(void)
 		gossip_debug(GOSSIP_DEV_DEBUG,
 			     "Failed to register /dev/%s (error %d)\n",
 			     ORANGEFS_REQDEVICE_NAME, orangefs_dev_major);
-		orangefs_ioctl32_cleanup();
 		return orangefs_dev_major;
 	}
 
@@ -957,8 +932,6 @@ void orangefs_dev_cleanup(void)
 	gossip_debug(GOSSIP_DEV_DEBUG,
 		     "*** /dev/%s character device unregistered ***\n",
 		     ORANGEFS_REQDEVICE_NAME);
-	/* unregister the ioctl32 sub-system */
-	orangefs_ioctl32_cleanup();
 }
 
 static unsigned int orangefs_devreq_poll(struct file *file,

commit 83595db05214eb49477b2ffb7d18ce4e7468c776
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jan 19 12:03:05 2016 -0500

    orangefs: ->poll() is only called between successful ->open() and ->release()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index fb7f092f94ba..4cecc7c4f760 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -966,14 +966,12 @@ static unsigned int orangefs_devreq_poll(struct file *file,
 {
 	int poll_revent_mask = 0;
 
-	if (open_access_count == 1) {
-		poll_wait(file, &orangefs_request_list_waitq, poll_table);
+	poll_wait(file, &orangefs_request_list_waitq, poll_table);
 
-		spin_lock(&orangefs_request_list_lock);
-		if (!list_empty(&orangefs_request_list))
-			poll_revent_mask |= POLL_IN;
-		spin_unlock(&orangefs_request_list_lock);
-	}
+	spin_lock(&orangefs_request_list_lock);
+	if (!list_empty(&orangefs_request_list))
+		poll_revent_mask |= POLL_IN;
+	spin_unlock(&orangefs_request_list_lock);
 	return poll_revent_mask;
 }
 

commit fb6d2526e92e56d3f41bfec45daf1ce09dd59e7b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jan 19 12:00:26 2016 -0500

    orangefs: generic_file_open() is pointless for character devices
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 5da5ef616b85..fb7f092f94ba 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -85,9 +85,8 @@ static int orangefs_devreq_open(struct inode *inode, struct file *file)
 	mutex_lock(&devreq_mutex);
 
 	if (open_access_count == 0) {
-		ret = generic_file_open(inode, file);
-		if (ret == 0)
-			open_access_count++;
+		open_access_count++;
+		ret = 0;
 	} else {
 		DUMP_DEVICE_ERROR();
 	}

commit cf0c27715bd640628d39421f3d232c87d7e08954
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Tue Jan 19 12:04:40 2016 -0500

    Orangefs: make gossip statement more palatable to xtensa
    
    Thanks to Intel's kbuild test robot
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 0f01d3edfc2b..5da5ef616b85 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -275,10 +275,10 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 		     ret);
 
         if (total < MAX_DEV_REQ_DOWNSIZE) {
-		gossip_err("%s: total:%d: must be at least:%lu:\n",
+		gossip_err("%s: total:%d: must be at least:%u:\n",
 			   __func__,
 			   total,
-			   MAX_DEV_REQ_DOWNSIZE);
+			   (unsigned int) MAX_DEV_REQ_DOWNSIZE);
 		ret = -EFAULT;
 		goto out;
 	}

commit b3ae4755f561cffd23192cd1fb9648649aa7405e
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Jan 13 11:18:12 2016 -0500

    Orangefs: implement .write_iter
    
    Until now, orangefs_devreq_write_iter has just been a wrapper for
    the old-fashioned orangefs_devreq_writev... linux would call
    .write_iter with "struct kiocb *iocb" and "struct iov_iter *iter"
    and .write_iter would just:
    
            return pvfs2_devreq_writev(iocb->ki_filp,
                                       iter->iov,
                                       iter->nr_segs,
                                       &iocb->ki_pos);
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index e3bb15e344ed..0f01d3edfc2b 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -245,304 +245,240 @@ static ssize_t orangefs_devreq_read(struct file *file,
 }
 
 /*
- * Function for writev() callers into the device. Readdir related
- * operations have an extra iovec containing info about objects
- * contained in directories.
+ * Function for writev() callers into the device.
+ *
+ * Userspace should have written:
+ *  - __u32 version
+ *  - __u32 magic
+ *  - __u64 tag
+ *  - struct orangefs_downcall_s
+ *  - trailer buffer (in the case of READDIR operations)
  */
-static ssize_t orangefs_devreq_writev(struct file *file,
-				   const struct iovec *iov,
-				   size_t count,
-				   loff_t *offset)
+static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
+				      struct iov_iter *iter)
 {
+	ssize_t ret;
 	struct orangefs_kernel_op_s *op = NULL;
-	void *buffer = NULL;
-	void *ptr = NULL;
-	unsigned long i = 0;
-	int num_remaining = MAX_DEV_REQ_DOWNSIZE;
-	int ret = 0;
-	/* num elements in iovec without trailer */
-	int notrailer_count = 4;
-	/*
-	 * If there's a trailer, its iov index will be equal to
-	 * notrailer_count.
-	 */
-	int trailer_index = notrailer_count;
-	int payload_size = 0;
-	int returned_downcall_size = 0;
-	__s32 magic = 0;
-	__s32 proto_ver = 0;
-	__u64 tag = 0;
-	ssize_t total_returned_size = 0;
+	struct {
+		__u32 version;
+		__u32 magic;
+		__u64 tag;
+	} head;
+	int total = ret = iov_iter_count(iter);
+	int n;
+	int downcall_size = sizeof(struct orangefs_downcall_s);
+	int head_size = sizeof(head);
+
+	gossip_debug(GOSSIP_DEV_DEBUG, "%s: total:%d: ret:%zd:\n",
+		     __func__,
+		     total,
+		     ret);
 
-	/*
-	 * There will always be at least notrailer_count iovecs, and
-	 * when there's a trailer, one more than notrailer_count. Check
-	 * count's sanity.
-	 */
-	if (count != notrailer_count && count != (notrailer_count + 1)) {
-		gossip_err("%s: count:%zu: notrailer_count :%d:\n",
-			__func__,
-			count,
-			notrailer_count);
-		return -EPROTO;
+        if (total < MAX_DEV_REQ_DOWNSIZE) {
+		gossip_err("%s: total:%d: must be at least:%lu:\n",
+			   __func__,
+			   total,
+			   MAX_DEV_REQ_DOWNSIZE);
+		ret = -EFAULT;
+		goto out;
 	}
-
-
-	/* Copy the non-trailer iovec data into a device request buffer. */
-	buffer = dev_req_alloc();
-	if (!buffer) {
-		gossip_err("%s: dev_req_alloc failed.\n", __func__);
-		return -ENOMEM;
+     
+	n = copy_from_iter(&head, head_size, iter);
+	if (n < head_size) {
+		gossip_err("%s: failed to copy head.\n", __func__);
+		ret = -EFAULT;
+		goto out;
 	}
-	ptr = buffer;
-	for (i = 0; i < notrailer_count; i++) {
-		if (iov[i].iov_len > num_remaining) {
-			gossip_err
-			    ("writev error: Freeing buffer and returning\n");
-			dev_req_release(buffer);
-			return -EMSGSIZE;
-		}
-		ret = copy_from_user(ptr, iov[i].iov_base, iov[i].iov_len);
-		if (ret) {
-			gossip_err("Failed to copy data from user space\n");
-			dev_req_release(buffer);
-			return -EIO;
-		}
-		num_remaining -= iov[i].iov_len;
-		ptr += iov[i].iov_len;
-		payload_size += iov[i].iov_len;
+
+	if (head.version < ORANGEFS_MINIMUM_USERSPACE_VERSION) {
+		gossip_err("%s: userspace claims version"
+			   "%d, minimum version required: %d.\n",
+			   __func__,
+			   head.version,
+			   ORANGEFS_MINIMUM_USERSPACE_VERSION);
+		ret = -EPROTO;
+		goto out;
 	}
-	total_returned_size = payload_size;
 
-	/* these elements are currently 8 byte aligned (8 bytes for (version +
-	 * magic) 8 bytes for tag).  If you add another element, either
-	 * make it 8 bytes big, or use get_unaligned when asigning.
-	 */
-	ptr = buffer;
-	proto_ver = *((__s32 *) ptr); /* unused */
-	ptr += sizeof(__s32);
+	if (head.magic != ORANGEFS_DEVREQ_MAGIC) {
+		gossip_err("Error: Device magic number does not match.\n");
+		ret = -EPROTO;
+		goto out;
+	}
 
-	magic = *((__s32 *) ptr);
-	ptr += sizeof(__s32);
+	op = orangefs_devreq_remove_op(head.tag);
+	if (!op) {
+		gossip_err("WARNING: No one's waiting for tag %llu\n",
+			   llu(head.tag));
+		goto out;
+	}
 
-	tag = *((__u64 *) ptr);
-	ptr += sizeof(__u64);
+	get_op(op); /* increase ref count. */
 
-	if (magic != ORANGEFS_DEVREQ_MAGIC) {
-		gossip_err("Error: Device magic number does not match.\n");
-		dev_req_release(buffer);
-		return -EPROTO;
+	n = copy_from_iter(&op->downcall, downcall_size, iter);
+	if (n != downcall_size) {
+		gossip_err("%s: failed to copy downcall.\n", __func__);
+		put_op(op);
+		ret = -EFAULT;
+		goto out;
 	}
 
-	op = orangefs_devreq_remove_op(tag);
-	if (op) {
-		/* Increase ref count! */
-		get_op(op);
-
-		/* calculate the size of the returned downcall. */
-		returned_downcall_size =
-			payload_size - (2 * sizeof(__s32) + sizeof(__u64));
-
-		/* copy the passed in downcall into the op */
-		if (returned_downcall_size ==
-			sizeof(struct orangefs_downcall_s)) {
-			memcpy(&op->downcall,
-			       ptr,
-			       sizeof(struct orangefs_downcall_s));
-		} else {
-			gossip_err("%s: returned downcall size:%d: \n",
-				   __func__,
-				   returned_downcall_size);
-			dev_req_release(buffer);
-			put_op(op);
-			return -EMSGSIZE;
-		}
+	if (op->downcall.status)
+		goto wakeup;
 
-		/* Don't tolerate an unexpected trailer iovec. */
-		if ((op->downcall.trailer_size == 0) &&
-		    (count != notrailer_count)) {
-			gossip_err("%s: unexpected trailer iovec.\n",
-				   __func__);
-			dev_req_release(buffer);
-			put_op(op);
-			return -EPROTO;
-		}
+	/*
+	 * We've successfully peeled off the head and the downcall. 
+	 * Something has gone awry if total doesn't equal the
+	 * sum of head_size, downcall_size and trailer_size.
+	 */
+	if ((head_size + downcall_size + op->downcall.trailer_size) != total) {
+		gossip_err("%s: funky write, head_size:%d"
+			   ": downcall_size:%d: trailer_size:%lld"
+			   ": total size:%d:\n",
+			   __func__,
+			   head_size,
+			   downcall_size,
+			   op->downcall.trailer_size,
+			   total);
+		put_op(op);
+		ret = -EFAULT;
+		goto out;
+	}
 
-		/* Don't consider the trailer if there's a bad status. */
-		if (op->downcall.status != 0)
-			goto no_trailer;
+	/* Only READDIR operations should have trailers. */
+	if ((op->downcall.type != ORANGEFS_VFS_OP_READDIR) &&
+	    (op->downcall.trailer_size != 0)) {
+		gossip_err("%s: %x operation with trailer.",
+			   __func__,
+			   op->downcall.type);
+		put_op(op);
+		ret = -EFAULT;
+		goto out;
+	}
 
-		/* get the trailer if there is one. */
-		if (op->downcall.trailer_size == 0)
-			goto no_trailer;
+	/* READDIR operations should always have trailers. */
+	if ((op->downcall.type == ORANGEFS_VFS_OP_READDIR) &&
+	    (op->downcall.trailer_size == 0)) {
+		gossip_err("%s: %x operation with no trailer.",
+			   __func__,
+			   op->downcall.type);
+		put_op(op);
+		ret = -EFAULT;
+		goto out;
+	}
 
-		gossip_debug(GOSSIP_DEV_DEBUG,
-			     "%s: op->downcall.trailer_size %lld\n",
-			     __func__,
-			     op->downcall.trailer_size);
+	if (op->downcall.type != ORANGEFS_VFS_OP_READDIR)
+		goto wakeup;
 
-		/*
-		 * Bail if we think think there should be a trailer, but
-		 * there's no iovec for it.
-		 */
-		if (count != (notrailer_count + 1)) {
-			gossip_err("%s: trailer_size:%lld: count:%zu:\n",
-				   __func__,
-				   op->downcall.trailer_size,
-				   count);
-			dev_req_release(buffer);
-			put_op(op);
-			return -EPROTO;
-		}
+	op->downcall.trailer_buf =
+		vmalloc(op->downcall.trailer_size);
+	if (op->downcall.trailer_buf == NULL) {
+		gossip_err("%s: failed trailer vmalloc.\n",
+			   __func__);
+		put_op(op);
+		ret = -ENOMEM;
+		goto out;
+	}
+	memset(op->downcall.trailer_buf, 0, op->downcall.trailer_size);
+	n = copy_from_iter(op->downcall.trailer_buf,
+			   op->downcall.trailer_size,
+			   iter);
+	if (n != op->downcall.trailer_size) {
+		gossip_err("%s: failed to copy trailer.\n", __func__);
+		vfree(op->downcall.trailer_buf);
+		put_op(op);
+		ret = -EFAULT;
+		goto out;
+	}
 
-		/* Verify that trailer_size is accurate. */
-		if (op->downcall.trailer_size != iov[trailer_index].iov_len) {
-			gossip_err("%s: trailer_size:%lld: != iov_len:%zd:\n",
-				   __func__,
-				   op->downcall.trailer_size,
-				   iov[trailer_index].iov_len);
-			dev_req_release(buffer);
-			put_op(op);
-			return -EMSGSIZE;
-		}
+wakeup:
 
-		total_returned_size += iov[trailer_index].iov_len;
+	/*
+	 * If this operation is an I/O operation we need to wait
+	 * for all data to be copied before we can return to avoid
+	 * buffer corruption and races that can pull the buffers
+	 * out from under us.
+	 *
+	 * Essentially we're synchronizing with other parts of the
+	 * vfs implicitly by not allowing the user space
+	 * application reading/writing this device to return until
+	 * the buffers are done being used.
+	 */
+	if (op->downcall.type == ORANGEFS_VFS_OP_FILE_IO) {
+		int timed_out = 0;
+		DEFINE_WAIT(wait_entry);
 
 		/*
-		 * Allocate a buffer, copy the trailer bytes into it and
-		 * attach it to the downcall.
+		 * tell the vfs op waiting on a waitqueue
+		 * that this op is done
 		 */
-		op->downcall.trailer_buf = vmalloc(iov[trailer_index].iov_len);
-		if (op->downcall.trailer_buf != NULL) {
-			gossip_debug(GOSSIP_DEV_DEBUG, "vmalloc: %p\n",
-				     op->downcall.trailer_buf);
-			ret = copy_from_user(op->downcall.trailer_buf,
-					     iov[trailer_index].iov_base,
-					     iov[trailer_index].iov_len);
-			if (ret) {
-				gossip_err("%s: Failed to copy trailer.\n",
-					   __func__);
-				dev_req_release(buffer);
-				gossip_debug(GOSSIP_DEV_DEBUG,
-					     "vfree: %p\n",
-					     op->downcall.trailer_buf);
-				vfree(op->downcall.trailer_buf);
-				op->downcall.trailer_buf = NULL;
-				put_op(op);
-				return -EIO;
-			}
-		} else {
-			gossip_err("writev: could not vmalloc for trailer!\n");
-			dev_req_release(buffer);
-			put_op(op);
-			return -ENOMEM;
-		}
+		spin_lock(&op->lock);
+		set_op_state_serviced(op);
+		spin_unlock(&op->lock);
 
-no_trailer:
-
-		/* if this operation is an I/O operation we need to wait
-		 * for all data to be copied before we can return to avoid
-		 * buffer corruption and races that can pull the buffers
-		 * out from under us.
-		 *
-		 * Essentially we're synchronizing with other parts of the
-		 * vfs implicitly by not allowing the user space
-		 * application reading/writing this device to return until
-		 * the buffers are done being used.
-		 */
-		if (op->upcall.type == ORANGEFS_VFS_OP_FILE_IO) {
-			int timed_out = 0;
-			DEFINE_WAIT(wait_entry);
+		wake_up_interruptible(&op->waitq);
 
-			/*
-			 * tell the vfs op waiting on a waitqueue
-			 * that this op is done
-			 */
+		while (1) {
 			spin_lock(&op->lock);
-			set_op_state_serviced(op);
-			spin_unlock(&op->lock);
-
-			wake_up_interruptible(&op->waitq);
-
-			while (1) {
-				spin_lock(&op->lock);
-				prepare_to_wait_exclusive(
-					&op->io_completion_waitq,
-					&wait_entry,
-					TASK_INTERRUPTIBLE);
-				if (op->io_completed) {
-					spin_unlock(&op->lock);
-					break;
-				}
+			prepare_to_wait_exclusive(
+				&op->io_completion_waitq,
+				&wait_entry,
+				TASK_INTERRUPTIBLE);
+			if (op->io_completed) {
 				spin_unlock(&op->lock);
-
-				if (!signal_pending(current)) {
-					int timeout =
-					    MSECS_TO_JIFFIES(1000 *
-							     op_timeout_secs);
-					if (!schedule_timeout(timeout)) {
-						gossip_debug(GOSSIP_DEV_DEBUG,
-							"%s: timed out.\n",
-							__func__);
-						timed_out = 1;
-						break;
-					}
-					continue;
-				}
-
-				gossip_debug(GOSSIP_DEV_DEBUG,
-					"%s: signal on I/O wait, aborting\n",
-					__func__);
 				break;
 			}
-
-			spin_lock(&op->lock);
-			finish_wait(&op->io_completion_waitq, &wait_entry);
 			spin_unlock(&op->lock);
 
-			/* NOTE: for I/O operations we handle releasing the op
-			 * object except in the case of timeout.  the reason we
-			 * can't free the op in timeout cases is that the op
-			 * service logic in the vfs retries operations using
-			 * the same op ptr, thus it can't be freed.
-			 */
-			if (!timed_out)
-				op_release(op);
-		} else {
+			if (!signal_pending(current)) {
+				int timeout =
+				    MSECS_TO_JIFFIES(1000 *
+						     op_timeout_secs);
+				if (!schedule_timeout(timeout)) {
+					gossip_debug(GOSSIP_DEV_DEBUG,
+						"%s: timed out.\n",
+						__func__);
+					timed_out = 1;
+					break;
+				}
+				continue;
+			}
 
-			/*
-			 * tell the vfs op waiting on a waitqueue that
-			 * this op is done
-			 */
-			spin_lock(&op->lock);
-			set_op_state_serviced(op);
-			spin_unlock(&op->lock);
-			/*
-			 * for every other operation (i.e. non-I/O), we need to
-			 * wake up the callers for downcall completion
-			 * notification
-			 */
-			wake_up_interruptible(&op->waitq);
+			gossip_debug(GOSSIP_DEV_DEBUG,
+				"%s: signal on I/O wait, aborting\n",
+				__func__);
+			break;
 		}
+
+		spin_lock(&op->lock);
+		finish_wait(&op->io_completion_waitq, &wait_entry);
+		spin_unlock(&op->lock);
+
+		/* NOTE: for I/O operations we handle releasing the op
+		 * object except in the case of timeout.  the reason we
+		 * can't free the op in timeout cases is that the op
+		 * service logic in the vfs retries operations using
+		 * the same op ptr, thus it can't be freed.
+		 */
+		if (!timed_out)
+			op_release(op);
 	} else {
-		/* ignore downcalls that we're not interested in */
-		gossip_debug(GOSSIP_DEV_DEBUG,
-			     "WARNING: No one's waiting for tag %llu\n",
-			     llu(tag));
+		/*
+		 * tell the vfs op waiting on a waitqueue that
+		 * this op is done
+		 */
+		spin_lock(&op->lock);
+		set_op_state_serviced(op);
+		spin_unlock(&op->lock);
+		/*
+		 * for every other operation (i.e. non-I/O), we need to
+		 * wake up the callers for downcall completion
+		 * notification
+		 */
+		wake_up_interruptible(&op->waitq);
 	}
-	/* put_op? */
-	dev_req_release(buffer);
-
-	return total_returned_size;
-}
-
-static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
-				      struct iov_iter *iter)
-{
-	return orangefs_devreq_writev(iocb->ki_filp,
-				   iter->iov,
-				   iter->nr_segs,
-				   &iocb->ki_pos);
+out:
+	return ret;
 }
 
 /* Returns whether any FS are still pending remounted */

commit 7d2214858f137ff5fe20d0fdc2823c12b4b54f46
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Jan 4 15:05:28 2016 -0500

    orangefs: Fix some more global namespace pollution.
    
    This only changes the names of things, so there is no functional change.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 5a9c53eb115f..e3bb15e344ed 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -600,7 +600,7 @@ static int orangefs_devreq_release(struct inode *inode, struct file *file)
 		     __func__);
 
 	mutex_lock(&devreq_mutex);
-	if (get_bufmap_init())
+	if (orangefs_get_bufmap_init())
 		orangefs_bufmap_finalize();
 
 	open_access_count--;
@@ -693,7 +693,7 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 				     (struct ORANGEFS_dev_map_desc __user *)
 				     arg,
 				     sizeof(struct ORANGEFS_dev_map_desc));
-		if (get_bufmap_init()) {
+		if (orangefs_get_bufmap_init()) {
 			return -EINVAL;
 		} else {
 			return ret ?

commit a762ae6dc5a615f18b5f0fe54a0b8551e02e19d0
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Dec 15 14:22:06 2015 -0500

    orangefs: Remove ``aligned'' upcall and downcall length macros.
    
    There was previously MAX_ALIGNED_DEV_REQ_(UP|DOWN)SIZE macros which
    evaluated to MAX_DEV_REQ_(UP|DOWN)SIZE+8. As it is unclear what this is
    for, other than creating a situation where we accept more data than we
    can parse, it is removed.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 4d7ab7cb08f7..5a9c53eb115f 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -120,10 +120,10 @@ static ssize_t orangefs_devreq_read(struct file *file,
 	}
 
 	/*
-	 * The client will do an ioctl to find MAX_ALIGNED_DEV_REQ_UPSIZE, then
+	 * The client will do an ioctl to find MAX_DEV_REQ_UPSIZE, then
 	 * always read with that size buffer.
 	 */
-	if (count != MAX_ALIGNED_DEV_REQ_UPSIZE) {
+	if (count != MAX_DEV_REQ_UPSIZE) {
 		gossip_err("orangefs: client-core tried to read wrong size\n");
 		return -EINVAL;
 	}
@@ -226,7 +226,7 @@ static ssize_t orangefs_devreq_read(struct file *file,
 		goto error;
 
 	/* The client only asks to read one size buffer. */
-	return MAX_ALIGNED_DEV_REQ_UPSIZE;
+	return MAX_DEV_REQ_UPSIZE;
 error:
 	/*
 	 * We were unable to copy the op data to the client. Put the op back in
@@ -258,7 +258,7 @@ static ssize_t orangefs_devreq_writev(struct file *file,
 	void *buffer = NULL;
 	void *ptr = NULL;
 	unsigned long i = 0;
-	int num_remaining = MAX_ALIGNED_DEV_REQ_DOWNSIZE;
+	int num_remaining = MAX_DEV_REQ_DOWNSIZE;
 	int ret = 0;
 	/* num elements in iovec without trailer */
 	int notrailer_count = 4;
@@ -661,8 +661,8 @@ static inline long check_ioctl_command(unsigned int command)
 static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 {
 	static __s32 magic = ORANGEFS_DEVREQ_MAGIC;
-	static __s32 max_up_size = MAX_ALIGNED_DEV_REQ_UPSIZE;
-	static __s32 max_down_size = MAX_ALIGNED_DEV_REQ_DOWNSIZE;
+	static __s32 max_up_size = MAX_DEV_REQ_UPSIZE;
+	static __s32 max_down_size = MAX_DEV_REQ_DOWNSIZE;
 	struct ORANGEFS_dev_map_desc user_desc;
 	int ret = 0;
 	struct dev_mask_info_s mask_info = { 0 };

commit 90d26aa80861afaee992228d8f0e57cbd06c8d87
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Dec 14 15:26:38 2015 -0500

    Orangefs: do not finalize bufmap if it was never initialized.
    
    Found by the infant Orangefs fuzzer...
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index dc2e2ce7e943..4d7ab7cb08f7 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -600,7 +600,8 @@ static int orangefs_devreq_release(struct inode *inode, struct file *file)
 		     __func__);
 
 	mutex_lock(&devreq_mutex);
-	orangefs_bufmap_finalize();
+	if (get_bufmap_init())
+		orangefs_bufmap_finalize();
 
 	open_access_count--;
 
@@ -692,7 +693,13 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 				     (struct ORANGEFS_dev_map_desc __user *)
 				     arg,
 				     sizeof(struct ORANGEFS_dev_map_desc));
-		return ret ? -EIO : orangefs_bufmap_initialize(&user_desc);
+		if (get_bufmap_init()) {
+			return -EINVAL;
+		} else {
+			return ret ?
+			       -EIO :
+			       orangefs_bufmap_initialize(&user_desc);
+		}
 	case ORANGEFS_DEV_REMOUNT_ALL:
 		gossip_debug(GOSSIP_DEV_DEBUG,
 			     "%s: got ORANGEFS_DEV_REMOUNT_ALL\n",

commit ce6c414e17be602a84b1b34915468f8301ed14a0
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Mon Dec 14 14:54:46 2015 -0500

    Orangefs: Don't wait the old-fashioned way.
    
    Get rid of add_wait_queue, set_current_state, etc, and use the
    wait_event() model.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index b182b025db86..dc2e2ce7e943 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -432,7 +432,6 @@ static ssize_t orangefs_devreq_writev(struct file *file,
 				return -EIO;
 			}
 		} else {
-			/* Change downcall status */
 			gossip_err("writev: could not vmalloc for trailer!\n");
 			dev_req_release(buffer);
 			put_op(op);
@@ -453,7 +452,7 @@ static ssize_t orangefs_devreq_writev(struct file *file,
 		 */
 		if (op->upcall.type == ORANGEFS_VFS_OP_FILE_IO) {
 			int timed_out = 0;
-			DECLARE_WAITQUEUE(wait_entry, current);
+			DEFINE_WAIT(wait_entry);
 
 			/*
 			 * tell the vfs op waiting on a waitqueue
@@ -463,14 +462,14 @@ static ssize_t orangefs_devreq_writev(struct file *file,
 			set_op_state_serviced(op);
 			spin_unlock(&op->lock);
 
-			add_wait_queue_exclusive(&op->io_completion_waitq,
-						 &wait_entry);
 			wake_up_interruptible(&op->waitq);
 
 			while (1) {
-				set_current_state(TASK_INTERRUPTIBLE);
-
 				spin_lock(&op->lock);
+				prepare_to_wait_exclusive(
+					&op->io_completion_waitq,
+					&wait_entry,
+					TASK_INTERRUPTIBLE);
 				if (op->io_completed) {
 					spin_unlock(&op->lock);
 					break;
@@ -497,9 +496,9 @@ static ssize_t orangefs_devreq_writev(struct file *file,
 				break;
 			}
 
-			set_current_state(TASK_RUNNING);
-			remove_wait_queue(&op->io_completion_waitq,
-					  &wait_entry);
+			spin_lock(&op->lock);
+			finish_wait(&op->io_completion_waitq, &wait_entry);
+			spin_unlock(&op->lock);
 
 			/* NOTE: for I/O operations we handle releasing the op
 			 * object except in the case of timeout.  the reason we

commit 97f100277cfdcd268f0cf3d83bb6e4d1a345bc80
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Dec 11 16:45:03 2015 -0500

    Orangefs: de-uglify orangefs_devreq_writev, and devorangefs-req.c in general
    
    AV dislikes many parts of orangefs_devreq_writev. Besides making
    orangefs_devreq_writev more easily readable and better commented,
    this patch makes an effort to address some of the problems:
    
     > The 5th is quietly ignored unless trailer_size is positive and
     > status is zero. If trailer_size > 0 && status == 0, you verify that
     > the length of the 5th segment is no more than trailer_size and copy
     > it to vmalloc'ed buffer. Without bothering to zero the rest of that
     > buffer out.
    
    It was just wrong to allow a 5th segment that is not exactly equal to
    trailer_size. Now that that's fixed, there's nothing to zero out in
    the vmalloced buffer - it is exactly the right size to hold the
    5th segment.
    
     > Another API bogosity: when the 5th segment is present, successful writev()
     > returns the sum of sizes of the first 4.
    
    Added size of 5th segment to writev return...
    
     > if concatenation of the first 4 segments is longer than
     > 16 + sizeof(struct pvfs2_downcall_s) by no more than sizeof(long) => whine
     > and proceed with garbage.
    
    If 4th segment isn't exactly sizeof(struct pvfs2_downcall_s), whine and fail.
    
     > if the 32bit value 4 bytes into op->downcall is zero and 64bit
     > value following it is non-zero, the latter is interpreted as the size of
     > trailer data.
    
    The latter is what userspace claimed was the length of the trailer data.
    The kernel module now compares it to the trailer iovec's iov_len as a
    sanity check.
    
     > if there's no trailer, the 5th segment (if present) is completely ignored.
    
    Whine and fail if there should be no trailer, yet a 5th segment is present.
    
     > if vmalloc fails, act as if status (32bit at offset 5 into
     > op->downcall) had been -ENOMEM and don't look at the 5th segment at all.
    
    whine and fail with -ENOMEM.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index e74938d575d6..b182b025db86 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -76,11 +76,12 @@ static int orangefs_devreq_open(struct inode *inode, struct file *file)
 	int ret = -EINVAL;
 
 	if (!(file->f_flags & O_NONBLOCK)) {
-		gossip_err("orangefs: device cannot be opened in blocking mode\n");
+		gossip_err("%s: device cannot be opened in blocking mode\n",
+			   __func__);
 		goto out;
 	}
 	ret = -EACCES;
-	gossip_debug(GOSSIP_DEV_DEBUG, "pvfs2-client-core: opening device\n");
+	gossip_debug(GOSSIP_DEV_DEBUG, "client-core: opening device\n");
 	mutex_lock(&devreq_mutex);
 
 	if (open_access_count == 0) {
@@ -100,6 +101,7 @@ static int orangefs_devreq_open(struct inode *inode, struct file *file)
 	return ret;
 }
 
+/* Function for read() callers into the device */
 static ssize_t orangefs_devreq_read(struct file *file,
 				 char __user *buf,
 				 size_t count, loff_t *offset)
@@ -112,7 +114,8 @@ static ssize_t orangefs_devreq_read(struct file *file,
 
 	/* We do not support blocking IO. */
 	if (!(file->f_flags & O_NONBLOCK)) {
-		gossip_err("orangefs: blocking reads are not supported! (pvfs2-client-core bug)\n");
+		gossip_err("%s: blocking read from client-core.\n",
+			   __func__);
 		return -EINVAL;
 	}
 
@@ -143,12 +146,16 @@ static ssize_t orangefs_devreq_read(struct file *file,
 				    llu(op->tag), get_opname_string(op));
 				spin_unlock(&op->lock);
 				continue;
-			/* Skip ops whose filesystem we don't know about unless
-			 * it is being mounted. */
+			/*
+			 * Skip ops whose filesystem we don't know about unless
+			 * it is being mounted.
+			 */
 			/* XXX: is there a better way to detect this? */
 			} else if (ret == -1 &&
-				   !(op->upcall.type == ORANGEFS_VFS_OP_FS_MOUNT ||
-				     op->upcall.type == ORANGEFS_VFS_OP_GETATTR)) {
+				   !(op->upcall.type ==
+					ORANGEFS_VFS_OP_FS_MOUNT ||
+				     op->upcall.type ==
+					ORANGEFS_VFS_OP_GETATTR)) {
 				gossip_debug(GOSSIP_DEV_DEBUG,
 				    "orangefs: skipping op tag %llu %s\n",
 				    llu(op->tag), get_opname_string(op));
@@ -237,7 +244,11 @@ static ssize_t orangefs_devreq_read(struct file *file,
 	return -EFAULT;
 }
 
-/* Function for writev() callers into the device */
+/*
+ * Function for writev() callers into the device. Readdir related
+ * operations have an extra iovec containing info about objects
+ * contained in directories.
+ */
 static ssize_t orangefs_devreq_writev(struct file *file,
 				   const struct iovec *iov,
 				   size_t count,
@@ -247,27 +258,43 @@ static ssize_t orangefs_devreq_writev(struct file *file,
 	void *buffer = NULL;
 	void *ptr = NULL;
 	unsigned long i = 0;
-	static int max_downsize = MAX_ALIGNED_DEV_REQ_DOWNSIZE;
-	int ret = 0, num_remaining = max_downsize;
-	int notrailer_count = 4; /* num elements in iovec without trailer */
+	int num_remaining = MAX_ALIGNED_DEV_REQ_DOWNSIZE;
+	int ret = 0;
+	/* num elements in iovec without trailer */
+	int notrailer_count = 4;
+	/*
+	 * If there's a trailer, its iov index will be equal to
+	 * notrailer_count.
+	 */
+	int trailer_index = notrailer_count;
 	int payload_size = 0;
+	int returned_downcall_size = 0;
 	__s32 magic = 0;
 	__s32 proto_ver = 0;
 	__u64 tag = 0;
 	ssize_t total_returned_size = 0;
 
-	/* Either there is a trailer or there isn't */
+	/*
+	 * There will always be at least notrailer_count iovecs, and
+	 * when there's a trailer, one more than notrailer_count. Check
+	 * count's sanity.
+	 */
 	if (count != notrailer_count && count != (notrailer_count + 1)) {
-		gossip_err("Error: Number of iov vectors is (%zu) and notrailer count is %d\n",
+		gossip_err("%s: count:%zu: notrailer_count :%d:\n",
+			__func__,
 			count,
 			notrailer_count);
 		return -EPROTO;
 	}
+
+
+	/* Copy the non-trailer iovec data into a device request buffer. */
 	buffer = dev_req_alloc();
-	if (!buffer)
+	if (!buffer) {
+		gossip_err("%s: dev_req_alloc failed.\n", __func__);
 		return -ENOMEM;
+	}
 	ptr = buffer;
-
 	for (i = 0; i < notrailer_count; i++) {
 		if (iov[i].iov_len > num_remaining) {
 			gossip_err
@@ -292,7 +319,7 @@ static ssize_t orangefs_devreq_writev(struct file *file,
 	 * make it 8 bytes big, or use get_unaligned when asigning.
 	 */
 	ptr = buffer;
-	proto_ver = *((__s32 *) ptr);
+	proto_ver = *((__s32 *) ptr); /* unused */
 	ptr += sizeof(__s32);
 
 	magic = *((__s32 *) ptr);
@@ -307,82 +334,114 @@ static ssize_t orangefs_devreq_writev(struct file *file,
 		return -EPROTO;
 	}
 
-	/*
-	 * proto_ver = 20902 for 2.9.2
-	 */
-
 	op = orangefs_devreq_remove_op(tag);
 	if (op) {
 		/* Increase ref count! */
 		get_op(op);
-		/* cut off magic and tag from payload size */
-		payload_size -= (2 * sizeof(__s32) + sizeof(__u64));
-		if (payload_size <= sizeof(struct orangefs_downcall_s))
-			/* copy the passed in downcall into the op */
+
+		/* calculate the size of the returned downcall. */
+		returned_downcall_size =
+			payload_size - (2 * sizeof(__s32) + sizeof(__u64));
+
+		/* copy the passed in downcall into the op */
+		if (returned_downcall_size ==
+			sizeof(struct orangefs_downcall_s)) {
 			memcpy(&op->downcall,
 			       ptr,
 			       sizeof(struct orangefs_downcall_s));
-		else
-			gossip_debug(GOSSIP_DEV_DEBUG,
-				     "writev: Ignoring %d bytes\n",
-				     payload_size);
+		} else {
+			gossip_err("%s: returned downcall size:%d: \n",
+				   __func__,
+				   returned_downcall_size);
+			dev_req_release(buffer);
+			put_op(op);
+			return -EMSGSIZE;
+		}
+
+		/* Don't tolerate an unexpected trailer iovec. */
+		if ((op->downcall.trailer_size == 0) &&
+		    (count != notrailer_count)) {
+			gossip_err("%s: unexpected trailer iovec.\n",
+				   __func__);
+			dev_req_release(buffer);
+			put_op(op);
+			return -EPROTO;
+		}
+
+		/* Don't consider the trailer if there's a bad status. */
+		if (op->downcall.status != 0)
+			goto no_trailer;
+
+		/* get the trailer if there is one. */
+		if (op->downcall.trailer_size == 0)
+			goto no_trailer;
+
+		gossip_debug(GOSSIP_DEV_DEBUG,
+			     "%s: op->downcall.trailer_size %lld\n",
+			     __func__,
+			     op->downcall.trailer_size);
 
-		/* Do not allocate needlessly if client-core forgets
-		 * to reset trailer size on op errors.
+		/*
+		 * Bail if we think think there should be a trailer, but
+		 * there's no iovec for it.
 		 */
-		if (op->downcall.status == 0 && op->downcall.trailer_size > 0) {
-			__u64 trailer_size = op->downcall.trailer_size;
-			size_t size;
-			gossip_debug(GOSSIP_DEV_DEBUG,
-				     "writev: trailer size %ld\n",
-				     (unsigned long)trailer_size);
-			if (count != (notrailer_count + 1)) {
-				gossip_err("Error: trailer size (%ld) is non-zero, no trailer elements though? (%zu)\n", (unsigned long)trailer_size, count);
-				dev_req_release(buffer);
-				put_op(op);
-				return -EPROTO;
-			}
-			size = iov[notrailer_count].iov_len;
-			if (size > trailer_size) {
-				gossip_err("writev error: trailer size (%ld) != iov_len (%zd)\n", (unsigned long)trailer_size, size);
+		if (count != (notrailer_count + 1)) {
+			gossip_err("%s: trailer_size:%lld: count:%zu:\n",
+				   __func__,
+				   op->downcall.trailer_size,
+				   count);
+			dev_req_release(buffer);
+			put_op(op);
+			return -EPROTO;
+		}
+
+		/* Verify that trailer_size is accurate. */
+		if (op->downcall.trailer_size != iov[trailer_index].iov_len) {
+			gossip_err("%s: trailer_size:%lld: != iov_len:%zd:\n",
+				   __func__,
+				   op->downcall.trailer_size,
+				   iov[trailer_index].iov_len);
+			dev_req_release(buffer);
+			put_op(op);
+			return -EMSGSIZE;
+		}
+
+		total_returned_size += iov[trailer_index].iov_len;
+
+		/*
+		 * Allocate a buffer, copy the trailer bytes into it and
+		 * attach it to the downcall.
+		 */
+		op->downcall.trailer_buf = vmalloc(iov[trailer_index].iov_len);
+		if (op->downcall.trailer_buf != NULL) {
+			gossip_debug(GOSSIP_DEV_DEBUG, "vmalloc: %p\n",
+				     op->downcall.trailer_buf);
+			ret = copy_from_user(op->downcall.trailer_buf,
+					     iov[trailer_index].iov_base,
+					     iov[trailer_index].iov_len);
+			if (ret) {
+				gossip_err("%s: Failed to copy trailer.\n",
+					   __func__);
 				dev_req_release(buffer);
-				put_op(op);
-				return -EMSGSIZE;
-			}
-			/* Allocate a buffer large enough to hold the
-			 * trailer bytes.
-			 */
-			op->downcall.trailer_buf = vmalloc(trailer_size);
-			if (op->downcall.trailer_buf != NULL) {
-				gossip_debug(GOSSIP_DEV_DEBUG, "vmalloc: %p\n",
+				gossip_debug(GOSSIP_DEV_DEBUG,
+					     "vfree: %p\n",
 					     op->downcall.trailer_buf);
-				ret = copy_from_user(op->downcall.trailer_buf,
-						     iov[notrailer_count].
-						     iov_base,
-						     size);
-				if (ret) {
-					gossip_err("Failed to copy trailer data from user space\n");
-					dev_req_release(buffer);
-					gossip_debug(GOSSIP_DEV_DEBUG,
-						     "vfree: %p\n",
-						     op->downcall.trailer_buf);
-					vfree(op->downcall.trailer_buf);
-					op->downcall.trailer_buf = NULL;
-					put_op(op);
-					return -EIO;
-				}
-				memset(op->downcall.trailer_buf + size, 0,
-				       trailer_size - size);
-			} else {
-				/* Change downcall status */
-				op->downcall.status = -ENOMEM;
-				gossip_err("writev: could not vmalloc for trailer!\n");
+				vfree(op->downcall.trailer_buf);
+				op->downcall.trailer_buf = NULL;
+				put_op(op);
+				return -EIO;
 			}
+		} else {
+			/* Change downcall status */
+			gossip_err("writev: could not vmalloc for trailer!\n");
+			dev_req_release(buffer);
+			put_op(op);
+			return -ENOMEM;
 		}
 
-		/* if this operation is an I/O operation and if it was
-		 * initiated on behalf of a *synchronous* VFS I/O operation,
-		 * only then we need to wait
+no_trailer:
+
+		/* if this operation is an I/O operation we need to wait
 		 * for all data to be copied before we can return to avoid
 		 * buffer corruption and races that can pull the buffers
 		 * out from under us.
@@ -392,12 +451,12 @@ static ssize_t orangefs_devreq_writev(struct file *file,
 		 * application reading/writing this device to return until
 		 * the buffers are done being used.
 		 */
-		if (op->upcall.type == ORANGEFS_VFS_OP_FILE_IO &&
-		    op->upcall.req.io.async_vfs_io == ORANGEFS_VFS_SYNC_IO) {
+		if (op->upcall.type == ORANGEFS_VFS_OP_FILE_IO) {
 			int timed_out = 0;
 			DECLARE_WAITQUEUE(wait_entry, current);
 
-			/* tell the vfs op waiting on a waitqueue
+			/*
+			 * tell the vfs op waiting on a waitqueue
 			 * that this op is done
 			 */
 			spin_lock(&op->lock);
@@ -423,14 +482,18 @@ static ssize_t orangefs_devreq_writev(struct file *file,
 					    MSECS_TO_JIFFIES(1000 *
 							     op_timeout_secs);
 					if (!schedule_timeout(timeout)) {
-						gossip_debug(GOSSIP_DEV_DEBUG, "*** I/O wait time is up\n");
+						gossip_debug(GOSSIP_DEV_DEBUG,
+							"%s: timed out.\n",
+							__func__);
 						timed_out = 1;
 						break;
 					}
 					continue;
 				}
 
-				gossip_debug(GOSSIP_DEV_DEBUG, "*** signal on I/O wait -- aborting\n");
+				gossip_debug(GOSSIP_DEV_DEBUG,
+					"%s: signal on I/O wait, aborting\n",
+					__func__);
 				break;
 			}
 
@@ -468,6 +531,7 @@ static ssize_t orangefs_devreq_writev(struct file *file,
 			     "WARNING: No one's waiting for tag %llu\n",
 			     llu(tag));
 	}
+	/* put_op? */
 	dev_req_release(buffer);
 
 	return total_returned_size;
@@ -632,7 +696,8 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 		return ret ? -EIO : orangefs_bufmap_initialize(&user_desc);
 	case ORANGEFS_DEV_REMOUNT_ALL:
 		gossip_debug(GOSSIP_DEV_DEBUG,
-			     "orangefs_devreq_ioctl: got ORANGEFS_DEV_REMOUNT_ALL\n");
+			     "%s: got ORANGEFS_DEV_REMOUNT_ALL\n",
+			     __func__);
 
 		/*
 		 * remount all mounted orangefs volumes to regain the lost
@@ -647,13 +712,17 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 		if (ret < 0)
 			return ret;
 		gossip_debug(GOSSIP_DEV_DEBUG,
-			     "orangefs_devreq_ioctl: priority remount in progress\n");
+			     "%s: priority remount in progress\n",
+			     __func__);
 		list_for_each(tmp, &orangefs_superblocks) {
 			orangefs_sb =
-				list_entry(tmp, struct orangefs_sb_info_s, list);
+				list_entry(tmp,
+					   struct orangefs_sb_info_s,
+					   list);
 			if (orangefs_sb && (orangefs_sb->sb)) {
 				gossip_debug(GOSSIP_DEV_DEBUG,
-					     "Remounting SB %p\n",
+					     "%s: Remounting SB %p\n",
+					     __func__,
 					     orangefs_sb);
 
 				ret = orangefs_remount(orangefs_sb->sb);
@@ -661,12 +730,13 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 					gossip_debug(GOSSIP_DEV_DEBUG,
 						     "SB %p remount failed\n",
 						     orangefs_sb);
-						break;
+					break;
 				}
 			}
 		}
 		gossip_debug(GOSSIP_DEV_DEBUG,
-			     "orangefs_devreq_ioctl: priority remount complete\n");
+			     "%s: priority remount complete\n",
+			     __func__);
 		mutex_unlock(&request_mutex);
 		return ret;
 
@@ -704,15 +774,12 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 				     (void __user *)arg,
 				     ORANGEFS_MAX_DEBUG_STRING_LEN);
 		if (ret != 0) {
-			pr_info("%s: "
-				"ORANGEFS_DEV_CLIENT_STRING: copy_from_user failed"
-				"\n",
+			pr_info("%s: CLIENT_STRING: copy_from_user failed\n",
 				__func__);
 			return -EIO;
 		}
 
-		pr_info("%s: client debug array string has been been received."
-			"\n",
+		pr_info("%s: client debug array string has been received.\n",
 			__func__);
 
 		if (!help_string_initialized) {
@@ -722,9 +789,7 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 
 			/* build a proper debug help string */
 			if (orangefs_prepare_debugfs_help_string(0)) {
-				gossip_err("%s: "
-					   "prepare_debugfs_help_string failed"
-					   "\n",
+				gossip_err("%s: no debug help string \n",
 					   __func__);
 				return -EIO;
 			}
@@ -781,15 +846,17 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 			debug_mask_to_string(&mask_info.mask_value,
 					     mask_info.mask_type);
 			gossip_debug_mask = mask_info.mask_value;
-			pr_info("ORANGEFS: kernel debug mask has been modified to "
+			pr_info("%s: kernel debug mask has been modified to "
 				":%s: :%llx:\n",
+				__func__,
 				kernel_debug_string,
 				(unsigned long long)gossip_debug_mask);
 		} else if (mask_info.mask_type == CLIENT_MASK) {
 			debug_mask_to_string(&mask_info.mask_value,
 					     mask_info.mask_type);
-			pr_info("ORANGEFS: client debug mask has been modified to"
+			pr_info("%s: client debug mask has been modified to"
 				":%s: :%llx:\n",
+				__func__,
 				client_debug_string,
 				llu(mask_info.mask_value));
 		} else {

commit 575e946125f70c41c2042f10172842c5cab9a09a
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Dec 4 12:56:14 2015 -0500

    Orangefs: change pvfs2 filenames to orangefs
    
    Also changed references within source files that referred to
    header files whose names had changed.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
new file mode 100644
index 000000000000..e74938d575d6
--- /dev/null
+++ b/fs/orangefs/devorangefs-req.c
@@ -0,0 +1,984 @@
+/*
+ * (C) 2001 Clemson University and The University of Chicago
+ *
+ * Changes by Acxiom Corporation to add protocol version to kernel
+ * communication, Copyright Acxiom Corporation, 2005.
+ *
+ * See COPYING in top-level directory.
+ */
+
+#include "protocol.h"
+#include "orangefs-kernel.h"
+#include "orangefs-dev-proto.h"
+#include "orangefs-bufmap.h"
+
+#include <linux/debugfs.h>
+#include <linux/slab.h>
+
+/* this file implements the /dev/pvfs2-req device node */
+
+static int open_access_count;
+
+#define DUMP_DEVICE_ERROR()                                                   \
+do {                                                                          \
+	gossip_err("*****************************************************\n");\
+	gossip_err("ORANGEFS Device Error:  You cannot open the device file ");  \
+	gossip_err("\n/dev/%s more than once.  Please make sure that\nthere " \
+		   "are no ", ORANGEFS_REQDEVICE_NAME);                          \
+	gossip_err("instances of a program using this device\ncurrently "     \
+		   "running. (You must verify this!)\n");                     \
+	gossip_err("For example, you can use the lsof program as follows:\n");\
+	gossip_err("'lsof | grep %s' (run this as root)\n",                   \
+		   ORANGEFS_REQDEVICE_NAME);                                     \
+	gossip_err("  open_access_count = %d\n", open_access_count);          \
+	gossip_err("*****************************************************\n");\
+} while (0)
+
+static int hash_func(__u64 tag, int table_size)
+{
+	return do_div(tag, (unsigned int)table_size);
+}
+
+static void orangefs_devreq_add_op(struct orangefs_kernel_op_s *op)
+{
+	int index = hash_func(op->tag, hash_table_size);
+
+	spin_lock(&htable_ops_in_progress_lock);
+	list_add_tail(&op->list, &htable_ops_in_progress[index]);
+	spin_unlock(&htable_ops_in_progress_lock);
+}
+
+static struct orangefs_kernel_op_s *orangefs_devreq_remove_op(__u64 tag)
+{
+	struct orangefs_kernel_op_s *op, *next;
+	int index;
+
+	index = hash_func(tag, hash_table_size);
+
+	spin_lock(&htable_ops_in_progress_lock);
+	list_for_each_entry_safe(op,
+				 next,
+				 &htable_ops_in_progress[index],
+				 list) {
+		if (op->tag == tag) {
+			list_del(&op->list);
+			spin_unlock(&htable_ops_in_progress_lock);
+			return op;
+		}
+	}
+
+	spin_unlock(&htable_ops_in_progress_lock);
+	return NULL;
+}
+
+static int orangefs_devreq_open(struct inode *inode, struct file *file)
+{
+	int ret = -EINVAL;
+
+	if (!(file->f_flags & O_NONBLOCK)) {
+		gossip_err("orangefs: device cannot be opened in blocking mode\n");
+		goto out;
+	}
+	ret = -EACCES;
+	gossip_debug(GOSSIP_DEV_DEBUG, "pvfs2-client-core: opening device\n");
+	mutex_lock(&devreq_mutex);
+
+	if (open_access_count == 0) {
+		ret = generic_file_open(inode, file);
+		if (ret == 0)
+			open_access_count++;
+	} else {
+		DUMP_DEVICE_ERROR();
+	}
+	mutex_unlock(&devreq_mutex);
+
+out:
+
+	gossip_debug(GOSSIP_DEV_DEBUG,
+		     "pvfs2-client-core: open device complete (ret = %d)\n",
+		     ret);
+	return ret;
+}
+
+static ssize_t orangefs_devreq_read(struct file *file,
+				 char __user *buf,
+				 size_t count, loff_t *offset)
+{
+	struct orangefs_kernel_op_s *op, *temp;
+	__s32 proto_ver = ORANGEFS_KERNEL_PROTO_VERSION;
+	static __s32 magic = ORANGEFS_DEVREQ_MAGIC;
+	struct orangefs_kernel_op_s *cur_op = NULL;
+	unsigned long ret;
+
+	/* We do not support blocking IO. */
+	if (!(file->f_flags & O_NONBLOCK)) {
+		gossip_err("orangefs: blocking reads are not supported! (pvfs2-client-core bug)\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * The client will do an ioctl to find MAX_ALIGNED_DEV_REQ_UPSIZE, then
+	 * always read with that size buffer.
+	 */
+	if (count != MAX_ALIGNED_DEV_REQ_UPSIZE) {
+		gossip_err("orangefs: client-core tried to read wrong size\n");
+		return -EINVAL;
+	}
+
+	/* Get next op (if any) from top of list. */
+	spin_lock(&orangefs_request_list_lock);
+	list_for_each_entry_safe(op, temp, &orangefs_request_list, list) {
+		__s32 fsid;
+		/* This lock is held past the end of the loop when we break. */
+		spin_lock(&op->lock);
+
+		fsid = fsid_of_op(op);
+		if (fsid != ORANGEFS_FS_ID_NULL) {
+			int ret;
+			/* Skip ops whose filesystem needs to be mounted. */
+			ret = fs_mount_pending(fsid);
+			if (ret == 1) {
+				gossip_debug(GOSSIP_DEV_DEBUG,
+				    "orangefs: skipping op tag %llu %s\n",
+				    llu(op->tag), get_opname_string(op));
+				spin_unlock(&op->lock);
+				continue;
+			/* Skip ops whose filesystem we don't know about unless
+			 * it is being mounted. */
+			/* XXX: is there a better way to detect this? */
+			} else if (ret == -1 &&
+				   !(op->upcall.type == ORANGEFS_VFS_OP_FS_MOUNT ||
+				     op->upcall.type == ORANGEFS_VFS_OP_GETATTR)) {
+				gossip_debug(GOSSIP_DEV_DEBUG,
+				    "orangefs: skipping op tag %llu %s\n",
+				    llu(op->tag), get_opname_string(op));
+				gossip_err(
+				    "orangefs: ERROR: fs_mount_pending %d\n",
+				    fsid);
+				spin_unlock(&op->lock);
+				continue;
+			}
+		}
+		/*
+		 * Either this op does not pertain to a filesystem, is mounting
+		 * a filesystem, or pertains to a mounted filesystem. Let it
+		 * through.
+		 */
+		cur_op = op;
+		break;
+	}
+
+	/*
+	 * At this point we either have a valid op and can continue or have not
+	 * found an op and must ask the client to try again later.
+	 */
+	if (!cur_op) {
+		spin_unlock(&orangefs_request_list_lock);
+		return -EAGAIN;
+	}
+
+	gossip_debug(GOSSIP_DEV_DEBUG, "orangefs: reading op tag %llu %s\n",
+		     llu(cur_op->tag), get_opname_string(cur_op));
+
+	/*
+	 * Such an op should never be on the list in the first place. If so, we
+	 * will abort.
+	 */
+	if (op_state_in_progress(cur_op) || op_state_serviced(cur_op)) {
+		gossip_err("orangefs: ERROR: Current op already queued.\n");
+		list_del(&cur_op->list);
+		spin_unlock(&cur_op->lock);
+		spin_unlock(&orangefs_request_list_lock);
+		return -EAGAIN;
+	}
+
+	/*
+	 * Set the operation to be in progress and move it between lists since
+	 * it has been sent to the client.
+	 */
+	set_op_state_inprogress(cur_op);
+
+	list_del(&cur_op->list);
+	spin_unlock(&orangefs_request_list_lock);
+	orangefs_devreq_add_op(cur_op);
+	spin_unlock(&cur_op->lock);
+
+	/* Push the upcall out. */
+	ret = copy_to_user(buf, &proto_ver, sizeof(__s32));
+	if (ret != 0)
+		goto error;
+	ret = copy_to_user(buf+sizeof(__s32), &magic, sizeof(__s32));
+	if (ret != 0)
+		goto error;
+	ret = copy_to_user(buf+2 * sizeof(__s32), &cur_op->tag, sizeof(__u64));
+	if (ret != 0)
+		goto error;
+	ret = copy_to_user(buf+2*sizeof(__s32)+sizeof(__u64), &cur_op->upcall,
+			   sizeof(struct orangefs_upcall_s));
+	if (ret != 0)
+		goto error;
+
+	/* The client only asks to read one size buffer. */
+	return MAX_ALIGNED_DEV_REQ_UPSIZE;
+error:
+	/*
+	 * We were unable to copy the op data to the client. Put the op back in
+	 * list. If client has crashed, the op will be purged later when the
+	 * device is released.
+	 */
+	gossip_err("orangefs: Failed to copy data to user space\n");
+	spin_lock(&orangefs_request_list_lock);
+	spin_lock(&cur_op->lock);
+	set_op_state_waiting(cur_op);
+	orangefs_devreq_remove_op(cur_op->tag);
+	list_add(&cur_op->list, &orangefs_request_list);
+	spin_unlock(&cur_op->lock);
+	spin_unlock(&orangefs_request_list_lock);
+	return -EFAULT;
+}
+
+/* Function for writev() callers into the device */
+static ssize_t orangefs_devreq_writev(struct file *file,
+				   const struct iovec *iov,
+				   size_t count,
+				   loff_t *offset)
+{
+	struct orangefs_kernel_op_s *op = NULL;
+	void *buffer = NULL;
+	void *ptr = NULL;
+	unsigned long i = 0;
+	static int max_downsize = MAX_ALIGNED_DEV_REQ_DOWNSIZE;
+	int ret = 0, num_remaining = max_downsize;
+	int notrailer_count = 4; /* num elements in iovec without trailer */
+	int payload_size = 0;
+	__s32 magic = 0;
+	__s32 proto_ver = 0;
+	__u64 tag = 0;
+	ssize_t total_returned_size = 0;
+
+	/* Either there is a trailer or there isn't */
+	if (count != notrailer_count && count != (notrailer_count + 1)) {
+		gossip_err("Error: Number of iov vectors is (%zu) and notrailer count is %d\n",
+			count,
+			notrailer_count);
+		return -EPROTO;
+	}
+	buffer = dev_req_alloc();
+	if (!buffer)
+		return -ENOMEM;
+	ptr = buffer;
+
+	for (i = 0; i < notrailer_count; i++) {
+		if (iov[i].iov_len > num_remaining) {
+			gossip_err
+			    ("writev error: Freeing buffer and returning\n");
+			dev_req_release(buffer);
+			return -EMSGSIZE;
+		}
+		ret = copy_from_user(ptr, iov[i].iov_base, iov[i].iov_len);
+		if (ret) {
+			gossip_err("Failed to copy data from user space\n");
+			dev_req_release(buffer);
+			return -EIO;
+		}
+		num_remaining -= iov[i].iov_len;
+		ptr += iov[i].iov_len;
+		payload_size += iov[i].iov_len;
+	}
+	total_returned_size = payload_size;
+
+	/* these elements are currently 8 byte aligned (8 bytes for (version +
+	 * magic) 8 bytes for tag).  If you add another element, either
+	 * make it 8 bytes big, or use get_unaligned when asigning.
+	 */
+	ptr = buffer;
+	proto_ver = *((__s32 *) ptr);
+	ptr += sizeof(__s32);
+
+	magic = *((__s32 *) ptr);
+	ptr += sizeof(__s32);
+
+	tag = *((__u64 *) ptr);
+	ptr += sizeof(__u64);
+
+	if (magic != ORANGEFS_DEVREQ_MAGIC) {
+		gossip_err("Error: Device magic number does not match.\n");
+		dev_req_release(buffer);
+		return -EPROTO;
+	}
+
+	/*
+	 * proto_ver = 20902 for 2.9.2
+	 */
+
+	op = orangefs_devreq_remove_op(tag);
+	if (op) {
+		/* Increase ref count! */
+		get_op(op);
+		/* cut off magic and tag from payload size */
+		payload_size -= (2 * sizeof(__s32) + sizeof(__u64));
+		if (payload_size <= sizeof(struct orangefs_downcall_s))
+			/* copy the passed in downcall into the op */
+			memcpy(&op->downcall,
+			       ptr,
+			       sizeof(struct orangefs_downcall_s));
+		else
+			gossip_debug(GOSSIP_DEV_DEBUG,
+				     "writev: Ignoring %d bytes\n",
+				     payload_size);
+
+		/* Do not allocate needlessly if client-core forgets
+		 * to reset trailer size on op errors.
+		 */
+		if (op->downcall.status == 0 && op->downcall.trailer_size > 0) {
+			__u64 trailer_size = op->downcall.trailer_size;
+			size_t size;
+			gossip_debug(GOSSIP_DEV_DEBUG,
+				     "writev: trailer size %ld\n",
+				     (unsigned long)trailer_size);
+			if (count != (notrailer_count + 1)) {
+				gossip_err("Error: trailer size (%ld) is non-zero, no trailer elements though? (%zu)\n", (unsigned long)trailer_size, count);
+				dev_req_release(buffer);
+				put_op(op);
+				return -EPROTO;
+			}
+			size = iov[notrailer_count].iov_len;
+			if (size > trailer_size) {
+				gossip_err("writev error: trailer size (%ld) != iov_len (%zd)\n", (unsigned long)trailer_size, size);
+				dev_req_release(buffer);
+				put_op(op);
+				return -EMSGSIZE;
+			}
+			/* Allocate a buffer large enough to hold the
+			 * trailer bytes.
+			 */
+			op->downcall.trailer_buf = vmalloc(trailer_size);
+			if (op->downcall.trailer_buf != NULL) {
+				gossip_debug(GOSSIP_DEV_DEBUG, "vmalloc: %p\n",
+					     op->downcall.trailer_buf);
+				ret = copy_from_user(op->downcall.trailer_buf,
+						     iov[notrailer_count].
+						     iov_base,
+						     size);
+				if (ret) {
+					gossip_err("Failed to copy trailer data from user space\n");
+					dev_req_release(buffer);
+					gossip_debug(GOSSIP_DEV_DEBUG,
+						     "vfree: %p\n",
+						     op->downcall.trailer_buf);
+					vfree(op->downcall.trailer_buf);
+					op->downcall.trailer_buf = NULL;
+					put_op(op);
+					return -EIO;
+				}
+				memset(op->downcall.trailer_buf + size, 0,
+				       trailer_size - size);
+			} else {
+				/* Change downcall status */
+				op->downcall.status = -ENOMEM;
+				gossip_err("writev: could not vmalloc for trailer!\n");
+			}
+		}
+
+		/* if this operation is an I/O operation and if it was
+		 * initiated on behalf of a *synchronous* VFS I/O operation,
+		 * only then we need to wait
+		 * for all data to be copied before we can return to avoid
+		 * buffer corruption and races that can pull the buffers
+		 * out from under us.
+		 *
+		 * Essentially we're synchronizing with other parts of the
+		 * vfs implicitly by not allowing the user space
+		 * application reading/writing this device to return until
+		 * the buffers are done being used.
+		 */
+		if (op->upcall.type == ORANGEFS_VFS_OP_FILE_IO &&
+		    op->upcall.req.io.async_vfs_io == ORANGEFS_VFS_SYNC_IO) {
+			int timed_out = 0;
+			DECLARE_WAITQUEUE(wait_entry, current);
+
+			/* tell the vfs op waiting on a waitqueue
+			 * that this op is done
+			 */
+			spin_lock(&op->lock);
+			set_op_state_serviced(op);
+			spin_unlock(&op->lock);
+
+			add_wait_queue_exclusive(&op->io_completion_waitq,
+						 &wait_entry);
+			wake_up_interruptible(&op->waitq);
+
+			while (1) {
+				set_current_state(TASK_INTERRUPTIBLE);
+
+				spin_lock(&op->lock);
+				if (op->io_completed) {
+					spin_unlock(&op->lock);
+					break;
+				}
+				spin_unlock(&op->lock);
+
+				if (!signal_pending(current)) {
+					int timeout =
+					    MSECS_TO_JIFFIES(1000 *
+							     op_timeout_secs);
+					if (!schedule_timeout(timeout)) {
+						gossip_debug(GOSSIP_DEV_DEBUG, "*** I/O wait time is up\n");
+						timed_out = 1;
+						break;
+					}
+					continue;
+				}
+
+				gossip_debug(GOSSIP_DEV_DEBUG, "*** signal on I/O wait -- aborting\n");
+				break;
+			}
+
+			set_current_state(TASK_RUNNING);
+			remove_wait_queue(&op->io_completion_waitq,
+					  &wait_entry);
+
+			/* NOTE: for I/O operations we handle releasing the op
+			 * object except in the case of timeout.  the reason we
+			 * can't free the op in timeout cases is that the op
+			 * service logic in the vfs retries operations using
+			 * the same op ptr, thus it can't be freed.
+			 */
+			if (!timed_out)
+				op_release(op);
+		} else {
+
+			/*
+			 * tell the vfs op waiting on a waitqueue that
+			 * this op is done
+			 */
+			spin_lock(&op->lock);
+			set_op_state_serviced(op);
+			spin_unlock(&op->lock);
+			/*
+			 * for every other operation (i.e. non-I/O), we need to
+			 * wake up the callers for downcall completion
+			 * notification
+			 */
+			wake_up_interruptible(&op->waitq);
+		}
+	} else {
+		/* ignore downcalls that we're not interested in */
+		gossip_debug(GOSSIP_DEV_DEBUG,
+			     "WARNING: No one's waiting for tag %llu\n",
+			     llu(tag));
+	}
+	dev_req_release(buffer);
+
+	return total_returned_size;
+}
+
+static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
+				      struct iov_iter *iter)
+{
+	return orangefs_devreq_writev(iocb->ki_filp,
+				   iter->iov,
+				   iter->nr_segs,
+				   &iocb->ki_pos);
+}
+
+/* Returns whether any FS are still pending remounted */
+static int mark_all_pending_mounts(void)
+{
+	int unmounted = 1;
+	struct orangefs_sb_info_s *orangefs_sb = NULL;
+
+	spin_lock(&orangefs_superblocks_lock);
+	list_for_each_entry(orangefs_sb, &orangefs_superblocks, list) {
+		/* All of these file system require a remount */
+		orangefs_sb->mount_pending = 1;
+		unmounted = 0;
+	}
+	spin_unlock(&orangefs_superblocks_lock);
+	return unmounted;
+}
+
+/*
+ * Determine if a given file system needs to be remounted or not
+ *  Returns -1 on error
+ *           0 if already mounted
+ *           1 if needs remount
+ */
+int fs_mount_pending(__s32 fsid)
+{
+	int mount_pending = -1;
+	struct orangefs_sb_info_s *orangefs_sb = NULL;
+
+	spin_lock(&orangefs_superblocks_lock);
+	list_for_each_entry(orangefs_sb, &orangefs_superblocks, list) {
+		if (orangefs_sb->fs_id == fsid) {
+			mount_pending = orangefs_sb->mount_pending;
+			break;
+		}
+	}
+	spin_unlock(&orangefs_superblocks_lock);
+	return mount_pending;
+}
+
+/*
+ * NOTE: gets called when the last reference to this device is dropped.
+ * Using the open_access_count variable, we enforce a reference count
+ * on this file so that it can be opened by only one process at a time.
+ * the devreq_mutex is used to make sure all i/o has completed
+ * before we call orangefs_bufmap_finalize, and similar such tricky
+ * situations
+ */
+static int orangefs_devreq_release(struct inode *inode, struct file *file)
+{
+	int unmounted = 0;
+
+	gossip_debug(GOSSIP_DEV_DEBUG,
+		     "%s:pvfs2-client-core: exiting, closing device\n",
+		     __func__);
+
+	mutex_lock(&devreq_mutex);
+	orangefs_bufmap_finalize();
+
+	open_access_count--;
+
+	unmounted = mark_all_pending_mounts();
+	gossip_debug(GOSSIP_DEV_DEBUG, "ORANGEFS Device Close: Filesystem(s) %s\n",
+		     (unmounted ? "UNMOUNTED" : "MOUNTED"));
+	mutex_unlock(&devreq_mutex);
+
+	/*
+	 * Walk through the list of ops in the request list, mark them
+	 * as purged and wake them up.
+	 */
+	purge_waiting_ops();
+	/*
+	 * Walk through the hash table of in progress operations; mark
+	 * them as purged and wake them up
+	 */
+	purge_inprogress_ops();
+	gossip_debug(GOSSIP_DEV_DEBUG,
+		     "pvfs2-client-core: device close complete\n");
+	return 0;
+}
+
+int is_daemon_in_service(void)
+{
+	int in_service;
+
+	/*
+	 * What this function does is checks if client-core is alive
+	 * based on the access count we maintain on the device.
+	 */
+	mutex_lock(&devreq_mutex);
+	in_service = open_access_count == 1 ? 0 : -EIO;
+	mutex_unlock(&devreq_mutex);
+	return in_service;
+}
+
+static inline long check_ioctl_command(unsigned int command)
+{
+	/* Check for valid ioctl codes */
+	if (_IOC_TYPE(command) != ORANGEFS_DEV_MAGIC) {
+		gossip_err("device ioctl magic numbers don't match! Did you rebuild pvfs2-client-core/libpvfs2? [cmd %x, magic %x != %x]\n",
+			command,
+			_IOC_TYPE(command),
+			ORANGEFS_DEV_MAGIC);
+		return -EINVAL;
+	}
+	/* and valid ioctl commands */
+	if (_IOC_NR(command) >= ORANGEFS_DEV_MAXNR || _IOC_NR(command) <= 0) {
+		gossip_err("Invalid ioctl command number [%d >= %d]\n",
+			   _IOC_NR(command), ORANGEFS_DEV_MAXNR);
+		return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
+static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
+{
+	static __s32 magic = ORANGEFS_DEVREQ_MAGIC;
+	static __s32 max_up_size = MAX_ALIGNED_DEV_REQ_UPSIZE;
+	static __s32 max_down_size = MAX_ALIGNED_DEV_REQ_DOWNSIZE;
+	struct ORANGEFS_dev_map_desc user_desc;
+	int ret = 0;
+	struct dev_mask_info_s mask_info = { 0 };
+	struct dev_mask2_info_s mask2_info = { 0, 0 };
+	int upstream_kmod = 1;
+	struct list_head *tmp = NULL;
+	struct orangefs_sb_info_s *orangefs_sb = NULL;
+
+	/* mtmoore: add locking here */
+
+	switch (command) {
+	case ORANGEFS_DEV_GET_MAGIC:
+		return ((put_user(magic, (__s32 __user *) arg) == -EFAULT) ?
+			-EIO :
+			0);
+	case ORANGEFS_DEV_GET_MAX_UPSIZE:
+		return ((put_user(max_up_size,
+				  (__s32 __user *) arg) == -EFAULT) ?
+					-EIO :
+					0);
+	case ORANGEFS_DEV_GET_MAX_DOWNSIZE:
+		return ((put_user(max_down_size,
+				  (__s32 __user *) arg) == -EFAULT) ?
+					-EIO :
+					0);
+	case ORANGEFS_DEV_MAP:
+		ret = copy_from_user(&user_desc,
+				     (struct ORANGEFS_dev_map_desc __user *)
+				     arg,
+				     sizeof(struct ORANGEFS_dev_map_desc));
+		return ret ? -EIO : orangefs_bufmap_initialize(&user_desc);
+	case ORANGEFS_DEV_REMOUNT_ALL:
+		gossip_debug(GOSSIP_DEV_DEBUG,
+			     "orangefs_devreq_ioctl: got ORANGEFS_DEV_REMOUNT_ALL\n");
+
+		/*
+		 * remount all mounted orangefs volumes to regain the lost
+		 * dynamic mount tables (if any) -- NOTE: this is done
+		 * without keeping the superblock list locked due to the
+		 * upcall/downcall waiting.  also, the request semaphore is
+		 * used to ensure that no operations will be serviced until
+		 * all of the remounts are serviced (to avoid ops between
+		 * mounts to fail)
+		 */
+		ret = mutex_lock_interruptible(&request_mutex);
+		if (ret < 0)
+			return ret;
+		gossip_debug(GOSSIP_DEV_DEBUG,
+			     "orangefs_devreq_ioctl: priority remount in progress\n");
+		list_for_each(tmp, &orangefs_superblocks) {
+			orangefs_sb =
+				list_entry(tmp, struct orangefs_sb_info_s, list);
+			if (orangefs_sb && (orangefs_sb->sb)) {
+				gossip_debug(GOSSIP_DEV_DEBUG,
+					     "Remounting SB %p\n",
+					     orangefs_sb);
+
+				ret = orangefs_remount(orangefs_sb->sb);
+				if (ret) {
+					gossip_debug(GOSSIP_DEV_DEBUG,
+						     "SB %p remount failed\n",
+						     orangefs_sb);
+						break;
+				}
+			}
+		}
+		gossip_debug(GOSSIP_DEV_DEBUG,
+			     "orangefs_devreq_ioctl: priority remount complete\n");
+		mutex_unlock(&request_mutex);
+		return ret;
+
+	case ORANGEFS_DEV_UPSTREAM:
+		ret = copy_to_user((void __user *)arg,
+				    &upstream_kmod,
+				    sizeof(upstream_kmod));
+
+		if (ret != 0)
+			return -EIO;
+		else
+			return ret;
+
+	case ORANGEFS_DEV_CLIENT_MASK:
+		ret = copy_from_user(&mask2_info,
+				     (void __user *)arg,
+				     sizeof(struct dev_mask2_info_s));
+
+		if (ret != 0)
+			return -EIO;
+
+		client_debug_mask.mask1 = mask2_info.mask1_value;
+		client_debug_mask.mask2 = mask2_info.mask2_value;
+
+		pr_info("%s: client debug mask has been been received "
+			":%llx: :%llx:\n",
+			__func__,
+			(unsigned long long)client_debug_mask.mask1,
+			(unsigned long long)client_debug_mask.mask2);
+
+		return ret;
+
+	case ORANGEFS_DEV_CLIENT_STRING:
+		ret = copy_from_user(&client_debug_array_string,
+				     (void __user *)arg,
+				     ORANGEFS_MAX_DEBUG_STRING_LEN);
+		if (ret != 0) {
+			pr_info("%s: "
+				"ORANGEFS_DEV_CLIENT_STRING: copy_from_user failed"
+				"\n",
+				__func__);
+			return -EIO;
+		}
+
+		pr_info("%s: client debug array string has been been received."
+			"\n",
+			__func__);
+
+		if (!help_string_initialized) {
+
+			/* Free the "we don't know yet" default string... */
+			kfree(debug_help_string);
+
+			/* build a proper debug help string */
+			if (orangefs_prepare_debugfs_help_string(0)) {
+				gossip_err("%s: "
+					   "prepare_debugfs_help_string failed"
+					   "\n",
+					   __func__);
+				return -EIO;
+			}
+
+			/* Replace the boilerplate boot-time debug-help file. */
+			debugfs_remove(help_file_dentry);
+
+			help_file_dentry =
+				debugfs_create_file(
+					ORANGEFS_KMOD_DEBUG_HELP_FILE,
+					0444,
+					debug_dir,
+					debug_help_string,
+					&debug_help_fops);
+
+			if (!help_file_dentry) {
+				gossip_err("%s: debugfs_create_file failed for"
+					   " :%s:!\n",
+					   __func__,
+					   ORANGEFS_KMOD_DEBUG_HELP_FILE);
+				return -EIO;
+			}
+		}
+
+		debug_mask_to_string(&client_debug_mask, 1);
+
+		debugfs_remove(client_debug_dentry);
+
+		orangefs_client_debug_init();
+
+		help_string_initialized++;
+
+		return ret;
+
+	case ORANGEFS_DEV_DEBUG:
+		ret = copy_from_user(&mask_info,
+				     (void __user *)arg,
+				     sizeof(mask_info));
+
+		if (ret != 0)
+			return -EIO;
+
+		if (mask_info.mask_type == KERNEL_MASK) {
+			if ((mask_info.mask_value == 0)
+			    && (kernel_mask_set_mod_init)) {
+				/*
+				 * the kernel debug mask was set when the
+				 * kernel module was loaded; don't override
+				 * it if the client-core was started without
+				 * a value for ORANGEFS_KMODMASK.
+				 */
+				return 0;
+			}
+			debug_mask_to_string(&mask_info.mask_value,
+					     mask_info.mask_type);
+			gossip_debug_mask = mask_info.mask_value;
+			pr_info("ORANGEFS: kernel debug mask has been modified to "
+				":%s: :%llx:\n",
+				kernel_debug_string,
+				(unsigned long long)gossip_debug_mask);
+		} else if (mask_info.mask_type == CLIENT_MASK) {
+			debug_mask_to_string(&mask_info.mask_value,
+					     mask_info.mask_type);
+			pr_info("ORANGEFS: client debug mask has been modified to"
+				":%s: :%llx:\n",
+				client_debug_string,
+				llu(mask_info.mask_value));
+		} else {
+			gossip_lerr("Invalid mask type....\n");
+			return -EINVAL;
+		}
+
+		return ret;
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+	return -ENOIOCTLCMD;
+}
+
+static long orangefs_devreq_ioctl(struct file *file,
+			       unsigned int command, unsigned long arg)
+{
+	long ret;
+
+	/* Check for properly constructed commands */
+	ret = check_ioctl_command(command);
+	if (ret < 0)
+		return (int)ret;
+
+	return (int)dispatch_ioctl_command(command, arg);
+}
+
+#ifdef CONFIG_COMPAT		/* CONFIG_COMPAT is in .config */
+
+/*  Compat structure for the ORANGEFS_DEV_MAP ioctl */
+struct ORANGEFS_dev_map_desc32 {
+	compat_uptr_t ptr;
+	__s32 total_size;
+	__s32 size;
+	__s32 count;
+};
+
+static unsigned long translate_dev_map26(unsigned long args, long *error)
+{
+	struct ORANGEFS_dev_map_desc32 __user *p32 = (void __user *)args;
+	/*
+	 * Depending on the architecture, allocate some space on the
+	 * user-call-stack based on our expected layout.
+	 */
+	struct ORANGEFS_dev_map_desc __user *p =
+	    compat_alloc_user_space(sizeof(*p));
+	compat_uptr_t addr;
+
+	*error = 0;
+	/* get the ptr from the 32 bit user-space */
+	if (get_user(addr, &p32->ptr))
+		goto err;
+	/* try to put that into a 64-bit layout */
+	if (put_user(compat_ptr(addr), &p->ptr))
+		goto err;
+	/* copy the remaining fields */
+	if (copy_in_user(&p->total_size, &p32->total_size, sizeof(__s32)))
+		goto err;
+	if (copy_in_user(&p->size, &p32->size, sizeof(__s32)))
+		goto err;
+	if (copy_in_user(&p->count, &p32->count, sizeof(__s32)))
+		goto err;
+	return (unsigned long)p;
+err:
+	*error = -EFAULT;
+	return 0;
+}
+
+/*
+ * 32 bit user-space apps' ioctl handlers when kernel modules
+ * is compiled as a 64 bit one
+ */
+static long orangefs_devreq_compat_ioctl(struct file *filp, unsigned int cmd,
+				      unsigned long args)
+{
+	long ret;
+	unsigned long arg = args;
+
+	/* Check for properly constructed commands */
+	ret = check_ioctl_command(cmd);
+	if (ret < 0)
+		return ret;
+	if (cmd == ORANGEFS_DEV_MAP) {
+		/*
+		 * convert the arguments to what we expect internally
+		 * in kernel space
+		 */
+		arg = translate_dev_map26(args, &ret);
+		if (ret < 0) {
+			gossip_err("Could not translate dev map\n");
+			return ret;
+		}
+	}
+	/* no other ioctl requires translation */
+	return dispatch_ioctl_command(cmd, arg);
+}
+
+#endif /* CONFIG_COMPAT is in .config */
+
+/*
+ * The following two ioctl32 functions had been refactored into the above
+ * CONFIG_COMPAT ifdef, but that was an over simplification that was
+ * not noticed until we tried to compile on power pc...
+ */
+#if (defined(CONFIG_COMPAT) && !defined(HAVE_REGISTER_IOCTL32_CONVERSION)) || !defined(CONFIG_COMPAT)
+static int orangefs_ioctl32_init(void)
+{
+	return 0;
+}
+
+static void orangefs_ioctl32_cleanup(void)
+{
+	return;
+}
+#endif
+
+/* the assigned character device major number */
+static int orangefs_dev_major;
+
+/*
+ * Initialize orangefs device specific state:
+ * Must be called at module load time only
+ */
+int orangefs_dev_init(void)
+{
+	int ret;
+
+	/* register the ioctl32 sub-system */
+	ret = orangefs_ioctl32_init();
+	if (ret < 0)
+		return ret;
+
+	/* register orangefs-req device  */
+	orangefs_dev_major = register_chrdev(0,
+					  ORANGEFS_REQDEVICE_NAME,
+					  &orangefs_devreq_file_operations);
+	if (orangefs_dev_major < 0) {
+		gossip_debug(GOSSIP_DEV_DEBUG,
+			     "Failed to register /dev/%s (error %d)\n",
+			     ORANGEFS_REQDEVICE_NAME, orangefs_dev_major);
+		orangefs_ioctl32_cleanup();
+		return orangefs_dev_major;
+	}
+
+	gossip_debug(GOSSIP_DEV_DEBUG,
+		     "*** /dev/%s character device registered ***\n",
+		     ORANGEFS_REQDEVICE_NAME);
+	gossip_debug(GOSSIP_DEV_DEBUG, "'mknod /dev/%s c %d 0'.\n",
+		     ORANGEFS_REQDEVICE_NAME, orangefs_dev_major);
+	return 0;
+}
+
+void orangefs_dev_cleanup(void)
+{
+	unregister_chrdev(orangefs_dev_major, ORANGEFS_REQDEVICE_NAME);
+	gossip_debug(GOSSIP_DEV_DEBUG,
+		     "*** /dev/%s character device unregistered ***\n",
+		     ORANGEFS_REQDEVICE_NAME);
+	/* unregister the ioctl32 sub-system */
+	orangefs_ioctl32_cleanup();
+}
+
+static unsigned int orangefs_devreq_poll(struct file *file,
+				      struct poll_table_struct *poll_table)
+{
+	int poll_revent_mask = 0;
+
+	if (open_access_count == 1) {
+		poll_wait(file, &orangefs_request_list_waitq, poll_table);
+
+		spin_lock(&orangefs_request_list_lock);
+		if (!list_empty(&orangefs_request_list))
+			poll_revent_mask |= POLL_IN;
+		spin_unlock(&orangefs_request_list_lock);
+	}
+	return poll_revent_mask;
+}
+
+const struct file_operations orangefs_devreq_file_operations = {
+	.owner = THIS_MODULE,
+	.read = orangefs_devreq_read,
+	.write_iter = orangefs_devreq_write_iter,
+	.open = orangefs_devreq_open,
+	.release = orangefs_devreq_release,
+	.unlocked_ioctl = orangefs_devreq_ioctl,
+
+#ifdef CONFIG_COMPAT		/* CONFIG_COMPAT is in .config */
+	.compat_ioctl = orangefs_devreq_compat_ioctl,
+#endif
+	.poll = orangefs_devreq_poll
+};
