commit a55f2d861585006f493e933ad32d65d71ba631fa
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Nov 7 15:01:40 2017 -0500

    orangefs: stop setting atime on inode dirty
    
    The previous code path was to mark the inode dirty, let
    orangefs_inode_dirty set a flag in our private inode, then later during
    inode release call orangefs_flush_inode which notices the flag and
    writes the atime out.
    
    The code path worked almost identically for mtime, ctime, and mode
    except that those flags are set explicitly and not as side effects of
    dirty.
    
    Now orangefs_flush_inode is removed.  Marking an inode dirty does not
    imply an atime update.  Any place where flags were set before is now
    an explicit call to orangefs_inode_setattr.  Since OrangeFS does not
    utilize inode writeback, the attribute change should be written out
    immediately.
    
    Fixes generic/120.
    
    In namei.c, there are several places where the directory mtime and ctime
    are set, but only the mtime is sent to the server.  These don't seem
    right, but I've left them as is for now.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index a8cc588d6224..e2c2699d8016 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -386,7 +386,6 @@ static int orangefs_dir_release(struct inode *inode, struct file *file)
 {
 	struct orangefs_dir *od = file->private_data;
 	struct orangefs_dir_part *part = od->part;
-	orangefs_flush_inode(inode);
 	while (part) {
 		struct orangefs_dir_part *next = part->next;
 		vfree(part);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index d327cbd17756..a8cc588d6224 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright 2017 Omnibond Systems, L.L.C.
  */

commit 2f713b5c7d2a90baba6c88174c81fb9a96bfde21
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu May 4 13:16:04 2017 -0400

    orangefs: count directory pieces correctly
    
    A large directory full of differently sized file names triggered this.
    Most directories, even very large directories with shorter names, would
    be lucky enough to fit in one server response.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index cac601498925..d327cbd17756 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -135,9 +135,12 @@ static int parse_readdir(struct orangefs_dir *od,
 
 	count = 1;
 	part = od->part;
-	while (part && part->next) {
-		part = part->next;
+	while (part) {
 		count++;
+		if (part->next)
+			part = part->next;
+		else
+			break;
 	}
 
 	new = (void *)op->downcall.trailer_buf;

commit 942835d68f6e16f2673c70791dc963c548681cb4
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue May 2 12:15:11 2017 -0400

    orangefs: invalidate stored directory on seek
    
    If an application seeks to a position before the point which has been
    read, it must want updates which have been made to the directory.  So
    delete the copy stored in the kernel so it will be fetched again.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index 4cfb3e5b597e..cac601498925 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -275,6 +275,28 @@ static int orangefs_dir_fill(struct orangefs_inode_s *oi,
 	return 0;
 }
 
+static loff_t orangefs_dir_llseek(struct file *file, loff_t offset,
+    int whence)
+{
+	struct orangefs_dir *od = file->private_data;
+	/*
+	 * Delete the stored data so userspace sees new directory
+	 * entries.
+	 */
+	if (!whence && offset < od->end) {
+		struct orangefs_dir_part *part = od->part;
+		while (part) {
+			struct orangefs_dir_part *next = part->next;
+			vfree(part);
+			part = next;
+		}
+		od->token = ORANGEFS_ITERATE_START;
+		od->part = NULL;
+		od->end = 1 << PART_SHIFT;
+	}
+	return default_llseek(file, offset, whence);
+}
+
 static int orangefs_dir_iterate(struct file *file,
     struct dir_context *ctx)
 {
@@ -371,7 +393,7 @@ static int orangefs_dir_release(struct inode *inode, struct file *file)
 }
 
 const struct file_operations orangefs_dir_operations = {
-	.llseek = default_llseek,
+	.llseek = orangefs_dir_llseek,
 	.read = generic_read_dir,
 	.iterate = orangefs_dir_iterate,
 	.open = orangefs_dir_open,

commit bf15ba7c1f9ad000d062968f931e80234db84a24
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue May 2 12:15:10 2017 -0400

    orangefs: skip forward to the next directory entry if seek is short
    
    If userspace seeks to a position in the stream which is not correct, it
    would have returned EIO because the data in the buffer at that offset
    would be incorrect.  This and the userspace daemon returning a corrupt
    directory are indistinguishable.
    
    Now if the data does not look right, skip forward to the next chunk and
    try again.  The motivation is that if the directory changes, an
    application may seek to a position that was valid and no longer is valid.
    
    It is not yet possible for a directory to change.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index d5ec9ba82cef..4cfb3e5b597e 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -194,11 +194,18 @@ static int fill_from_part(struct orangefs_dir_part *part,
 
 	/* The file offset from userspace is too large. */
 	if (i > part->len)
-		return -EIO;
+		return 1;
+
+	/*
+	 * If the seek pointer is positioned just before an entry it
+	 * should find the next entry.
+	 */
+	if (i % 8)
+		i = i + (8 - i%8)%8;
 
 	while (i < part->len) {
 		if (part->len < i + sizeof *len)
-			return -EIO;
+			break;
 		len = (void *)part + offset + i;
 		/*
 		 * len is the size of the string itself.  padlen is the
@@ -207,10 +214,10 @@ static int fill_from_part(struct orangefs_dir_part *part,
 		padlen = (sizeof *len + *len + 1) +
 		    (8 - (sizeof *len + *len + 1)%8)%8;
 		if (part->len < i + padlen + sizeof *khandle)
-			return -EIO;
+			goto next;
 		s = (void *)part + offset + i + sizeof *len;
 		if (s[*len] != 0)
-			return -EIO;
+			goto next;
 		khandle = (void *)part + offset + i + padlen;
 		if (!dir_emit(ctx, s, *len,
 		    orangefs_khandle_to_ino(khandle),
@@ -220,6 +227,9 @@ static int fill_from_part(struct orangefs_dir_part *part,
 		i = i + (8 - i%8)%8;
 		BUG_ON(i > part->len);
 		ctx->pos = (ctx->pos & PART_MASK) | i;
+		continue;
+next:
+		i += 8;
 	}
 	return 1;
 }

commit 7b796ae37092ef520641b3a96c211c1cc67a0346
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 25 15:38:02 2017 -0400

    orangefs: remove ORANGEFS_READDIR macros
    
    They are clones of the ORANGEFS_ITERATE macros in use elsewhere.  Delete
    ORANGEFS_ITERATE_NEXT which is a hack previously used by readdir.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index 7e9814fc6cc3..d5ec9ba82cef 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -304,13 +304,13 @@ static int orangefs_dir_iterate(struct file *file,
 	 * Must read more if the user has sought past what has been read
 	 * so far.  Stop a user who has sought past the end.
 	 */
-	while (od->token != ORANGEFS_READDIR_END &&
+	while (od->token != ORANGEFS_ITERATE_END &&
 	    ctx->pos > od->end) {
 		r = orangefs_dir_more(oi, od, dentry);
 		if (r)
 			return r;
 	}
-	if (od->token == ORANGEFS_READDIR_END && ctx->pos > od->end)
+	if (od->token == ORANGEFS_ITERATE_END && ctx->pos > od->end)
 		return -EIO;
 
 	/* Then try to fill if there's any left in the buffer. */
@@ -321,7 +321,7 @@ static int orangefs_dir_iterate(struct file *file,
 	}
 
 	/* Finally get some more and try to fill. */
-	if (od->token != ORANGEFS_READDIR_END) {
+	if (od->token != ORANGEFS_ITERATE_END) {
 		r = orangefs_dir_more(oi, od, dentry);
 		if (r)
 			return r;
@@ -339,7 +339,7 @@ static int orangefs_dir_open(struct inode *inode, struct file *file)
 	if (!file->private_data)
 		return -ENOMEM;
 	od = file->private_data;
-	od->token = ORANGEFS_READDIR_START;
+	od->token = ORANGEFS_ITERATE_START;
 	od->part = NULL;
 	od->end = 1 << PART_SHIFT;
 	od->error = 0;

commit 480e3e532e31666a18520a7964bb4095d7a16b9a
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 25 15:38:01 2017 -0400

    orangefs: support very large directories
    
    This works by maintaining a linked list of pages which the directory
    has been read into rather than one giant fixed-size buffer.
    
    This replaces code which limits the total directory size to the total
    amount that could be returned in one server request.  Since filenames
    are usually considerably shorter than the maximum, the old code could
    usually handle several server requests before running out of space.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index 9744fb3ad144..7e9814fc6cc3 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -6,6 +6,22 @@
 #include "orangefs-kernel.h"
 #include "orangefs-bufmap.h"
 
+struct orangefs_dir_part {
+	struct orangefs_dir_part *next;
+	size_t len;
+};
+
+struct orangefs_dir {
+	__u64 token;
+	struct orangefs_dir_part *part;
+	loff_t end;
+	int error;
+};
+
+#define PART_SHIFT (24)
+#define PART_SIZE (1<<24)
+#define PART_MASK (~(PART_SIZE - 1))
+
 /*
  * There can be up to 512 directory entries.  Each entry is encoded as
  * follows:
@@ -15,42 +31,39 @@
  * padding to 8 bytes
  * 16 bytes: khandle
  * padding to 8 bytes
- */
-#define MAX_DIRECTORY ((4 + 257 + 3 + 16)*512)
-
-struct orangefs_dir {
-	__u64 token;
-	void *directory;
-	size_t len;
-	int error;
-};
-
-/*
- * The userspace component sends several directory entries of the
- * following format.  The first four bytes are the string length not
- * including a trailing zero byte.  This is followed by the string and a
- * trailing zero padded to the next four byte boundry.  This is followed
- * by the sixteen byte khandle padded to the next eight byte boundry.
  *
  * The trailer_buf starts with a struct orangefs_readdir_response_s
  * which must be skipped to get to the directory data.
+ *
+ * The data which is received from the userspace daemon is termed a
+ * part and is stored in a linked list in case more than one part is
+ * needed for a large directory.
+ *
+ * The position pointer (ctx->pos) encodes the part and offset on which
+ * to begin reading at.  Bits above PART_SHIFT encode the part and bits
+ * below PART_SHIFT encode the offset.  Parts are stored in a linked
+ * list which grows as data is received from the server.  The overhead
+ * associated with managing the list is presumed to be small compared to
+ * the overhead of communicating with the server.
+ *
+ * As data is received from the server, it is placed at the end of the
+ * part list.  Data is parsed from the current position as it is needed.
+ * When data is determined to be corrupt, it is either because the
+ * userspace component has sent back corrupt data or because the file
+ * pointer has been moved to an invalid location.  Since the two cannot
+ * be differentiated, return EIO.
+ *
+ * Part zero is synthesized to contains `.' and `..'.  Part one is the
+ * first part of the part list.
  */
 
-static int orangefs_dir_more(struct orangefs_inode_s *oi,
-    struct orangefs_dir *od, struct dentry *dentry)
+static int do_readdir(struct orangefs_inode_s *oi,
+    struct orangefs_dir *od, struct dentry *dentry,
+    struct orangefs_kernel_op_s *op)
 {
-	const size_t offset =
-	    sizeof(struct orangefs_readdir_response_s);
 	struct orangefs_readdir_response_s *resp;
-	struct orangefs_kernel_op_s *op;
 	int bufi, r;
 
-	op = op_alloc(ORANGEFS_VFS_OP_READDIR);
-	if (!op) {
-		od->error = -ENOMEM;
-		return -ENOMEM;
-	}
-
 	/*
 	 * Despite the badly named field, readdir does not use shared
 	 * memory.  However, there are a limited number of readdir
@@ -66,7 +79,6 @@ static int orangefs_dir_more(struct orangefs_inode_s *oi,
 again:
 	bufi = orangefs_readdir_index_get();
 	if (bufi < 0) {
-		op_release(op);
 		od->error = bufi;
 		return bufi;
 	}
@@ -84,7 +96,6 @@ static int orangefs_dir_more(struct orangefs_inode_s *oi,
 			goto again;
 		} else if (r == -EIO) {
 			vfree(op->downcall.trailer_buf);
-			op_release(op);
 			od->error = r;
 			return r;
 		}
@@ -92,82 +103,166 @@ static int orangefs_dir_more(struct orangefs_inode_s *oi,
 
 	if (r < 0) {
 		vfree(op->downcall.trailer_buf);
-		op_release(op);
 		od->error = r;
 		return r;
 	} else if (op->downcall.status) {
 		vfree(op->downcall.trailer_buf);
-		op_release(op);
 		od->error = op->downcall.status;
 		return op->downcall.status;
 	}
 
+	/*
+	 * The maximum size is size per entry times the 512 entries plus
+	 * the header.  This is well under the limit.
+	 */
+	if (op->downcall.trailer_size > PART_SIZE) {
+		vfree(op->downcall.trailer_buf);
+		od->error = -EIO;
+		return -EIO;
+	}
+
 	resp = (struct orangefs_readdir_response_s *)
 	    op->downcall.trailer_buf;
 	od->token = resp->token;
+	return 0;
+}
 
-	if (od->len + op->downcall.trailer_size - offset <=
-	    MAX_DIRECTORY) {
-		memcpy(od->directory + od->len,
-		    op->downcall.trailer_buf + offset,
-		    op->downcall.trailer_size - offset);
-		od->len += op->downcall.trailer_size - offset;
-	} else {
-		/* This limit was chosen based on protocol limits. */
-		gossip_err("orangefs_dir_more: userspace sent too much data\n");
-		vfree(op->downcall.trailer_buf);
-		op_release(op);
-		od->error = -EIO;
-		return -EIO;
+static int parse_readdir(struct orangefs_dir *od,
+    struct orangefs_kernel_op_s *op)
+{
+	struct orangefs_dir_part *part, *new;
+	size_t count;
+
+	count = 1;
+	part = od->part;
+	while (part && part->next) {
+		part = part->next;
+		count++;
 	}
 
-	vfree(op->downcall.trailer_buf);
-	op_release(op);
+	new = (void *)op->downcall.trailer_buf;
+	new->next = NULL;
+	new->len = op->downcall.trailer_size -
+	    sizeof(struct orangefs_readdir_response_s);
+	if (!od->part)
+		od->part = new;
+	else
+		part->next = new;
+	count++;
+	od->end = count << PART_SHIFT;
+
 	return 0;
 }
 
-static int orangefs_dir_fill(struct orangefs_inode_s *oi,
-    struct orangefs_dir *od, struct dentry *dentry,
+static int orangefs_dir_more(struct orangefs_inode_s *oi,
+    struct orangefs_dir *od, struct dentry *dentry)
+{
+	struct orangefs_kernel_op_s *op;
+	int r;
+
+	op = op_alloc(ORANGEFS_VFS_OP_READDIR);
+	if (!op) {
+		od->error = -ENOMEM;
+		return -ENOMEM;
+	}
+	r = do_readdir(oi, od, dentry, op);
+	if (r) {
+		od->error = r;
+		goto out;
+	}
+	r = parse_readdir(od, op);
+	if (r) {
+		od->error = r;
+		goto out;
+	}
+
+	od->error = 0;
+out:
+	op_release(op);
+	return od->error;
+}
+
+static int fill_from_part(struct orangefs_dir_part *part,
     struct dir_context *ctx)
 {
+	const int offset = sizeof(struct orangefs_readdir_response_s);
 	struct orangefs_khandle *khandle;
 	__u32 *len, padlen;
 	loff_t i;
 	char *s;
-	i = ctx->pos - 2;
-	while (i < od->len) {
-		if (od->len < i + sizeof *len)
-			goto eio;
-		len = od->directory + i;
+	i = ctx->pos & ~PART_MASK;
+
+	/* The file offset from userspace is too large. */
+	if (i > part->len)
+		return -EIO;
+
+	while (i < part->len) {
+		if (part->len < i + sizeof *len)
+			return -EIO;
+		len = (void *)part + offset + i;
 		/*
 		 * len is the size of the string itself.  padlen is the
 		 * total size of the encoded string.
 		 */
 		padlen = (sizeof *len + *len + 1) +
-		    (4 - (sizeof *len + *len + 1)%8)%8;
-		if (od->len < i + padlen + sizeof *khandle)
-			goto eio;
-		s = od->directory + i + sizeof *len;
+		    (8 - (sizeof *len + *len + 1)%8)%8;
+		if (part->len < i + padlen + sizeof *khandle)
+			return -EIO;
+		s = (void *)part + offset + i + sizeof *len;
 		if (s[*len] != 0)
-			goto eio;
-		khandle = od->directory + i + padlen;
-
+			return -EIO;
+		khandle = (void *)part + offset + i + padlen;
 		if (!dir_emit(ctx, s, *len,
-		    orangefs_khandle_to_ino(khandle), DT_UNKNOWN))
+		    orangefs_khandle_to_ino(khandle),
+		    DT_UNKNOWN))
 			return 0;
 		i += padlen + sizeof *khandle;
 		i = i + (8 - i%8)%8;
-		ctx->pos = i + 2;
+		BUG_ON(i > part->len);
+		ctx->pos = (ctx->pos & PART_MASK) | i;
+	}
+	return 1;
+}
+
+static int orangefs_dir_fill(struct orangefs_inode_s *oi,
+    struct orangefs_dir *od, struct dentry *dentry,
+    struct dir_context *ctx)
+{
+	struct orangefs_dir_part *part;
+	size_t count;
+
+	count = ((ctx->pos & PART_MASK) >> PART_SHIFT) - 1;
+
+	part = od->part;
+	while (part->next && count) {
+		count--;
+		part = part->next;
+	}
+	/* This means the userspace file offset is invalid. */
+	if (count) {
+		od->error = -EIO;
+		return -EIO;
+	}
+
+	while (part && part->len) {
+		int r;
+		r = fill_from_part(part, ctx);
+		if (r < 0) {
+			od->error = r;
+			return r;
+		} else if (r == 0) {
+			/* Userspace buffer is full. */
+			break;
+		} else {
+			/*
+			 * The part ran out of data.  Move to the next
+			 * part. */
+			ctx->pos = (ctx->pos & PART_MASK) +
+			    (1 << PART_SHIFT);
+			part = part->next;
+		}
 	}
-	BUG_ON(i > od->len);
 	return 0;
-eio:
-	/*
-	 * Here either data from userspace is corrupt or the application
-	 * has sought to an invalid location.
-	 */
-	od->error = -EIO;
-	return -EIO;
 }
 
 static int orangefs_dir_iterate(struct file *file,
@@ -193,28 +288,33 @@ static int orangefs_dir_iterate(struct file *file,
 	if (ctx->pos == 1) {
 		if (!dir_emit_dotdot(file, ctx))
 			return 0;
-		ctx->pos++;
+		ctx->pos = 1 << PART_SHIFT;
 	}
 
+	/*
+	 * The seek position is in the first synthesized part but is not
+	 * valid.
+	 */
+	if ((ctx->pos & PART_MASK) == 0)
+		return -EIO;
+
 	r = 0;
 
 	/*
 	 * Must read more if the user has sought past what has been read
 	 * so far.  Stop a user who has sought past the end.
 	 */
-	while (od->token != ORANGEFS_READDIR_END && ctx->pos - 2 >
-	    od->len) {
+	while (od->token != ORANGEFS_READDIR_END &&
+	    ctx->pos > od->end) {
 		r = orangefs_dir_more(oi, od, dentry);
 		if (r)
 			return r;
 	}
-	if (od->token == ORANGEFS_READDIR_END && ctx->pos - 2 >
-	    od->len) {
+	if (od->token == ORANGEFS_READDIR_END && ctx->pos > od->end)
 		return -EIO;
-	}
 
 	/* Then try to fill if there's any left in the buffer. */
-	if (ctx->pos - 2 < od->len) {
+	if (ctx->pos < od->end) {
 		r = orangefs_dir_fill(oi, od, dentry, ctx);
 		if (r)
 			return r;
@@ -240,16 +340,8 @@ static int orangefs_dir_open(struct inode *inode, struct file *file)
 		return -ENOMEM;
 	od = file->private_data;
 	od->token = ORANGEFS_READDIR_START;
-	/*
-	 * XXX: It seems wasteful to allocate such a large buffer for
-	 * each request.  Most will be much smaller.
-	 */
-	od->directory = alloc_pages_exact(MAX_DIRECTORY, GFP_KERNEL);
-	if (!od->directory) {
-		kfree(file->private_data);
-		return -ENOMEM;
-	}
-	od->len = 0;
+	od->part = NULL;
+	od->end = 1 << PART_SHIFT;
 	od->error = 0;
 	return 0;
 }
@@ -257,8 +349,13 @@ static int orangefs_dir_open(struct inode *inode, struct file *file)
 static int orangefs_dir_release(struct inode *inode, struct file *file)
 {
 	struct orangefs_dir *od = file->private_data;
+	struct orangefs_dir_part *part = od->part;
 	orangefs_flush_inode(inode);
-	free_pages_exact(od->directory, MAX_DIRECTORY);
+	while (part) {
+		struct orangefs_dir_part *next = part->next;
+		vfree(part);
+		part = next;
+	}
 	kfree(od);
 	return 0;
 }

commit 72f66b8329310b810dc9b70b08af728812d2e6c1
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 25 15:38:00 2017 -0400

    orangefs: support llseek on directories
    
    This and the previous commit fix xfstests generic/257.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index cf0ebb06b84e..9744fb3ad144 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -21,7 +21,7 @@
 struct orangefs_dir {
 	__u64 token;
 	void *directory;
-	size_t i, len;
+	size_t len;
 	int error;
 };
 
@@ -132,35 +132,40 @@ static int orangefs_dir_fill(struct orangefs_inode_s *oi,
 {
 	struct orangefs_khandle *khandle;
 	__u32 *len, padlen;
+	loff_t i;
 	char *s;
-	while (od->i < od->len) {
-		if (od->len < od->i + sizeof *len)
+	i = ctx->pos - 2;
+	while (i < od->len) {
+		if (od->len < i + sizeof *len)
 			goto eio;
-		len = od->directory + od->i;
+		len = od->directory + i;
 		/*
 		 * len is the size of the string itself.  padlen is the
 		 * total size of the encoded string.
 		 */
 		padlen = (sizeof *len + *len + 1) +
 		    (4 - (sizeof *len + *len + 1)%8)%8;
-		if (od->len < od->i + padlen + sizeof *khandle)
+		if (od->len < i + padlen + sizeof *khandle)
 			goto eio;
-		s = od->directory + od->i + sizeof *len;
+		s = od->directory + i + sizeof *len;
 		if (s[*len] != 0)
 			goto eio;
-		khandle = od->directory + od->i + padlen;
+		khandle = od->directory + i + padlen;
 
 		if (!dir_emit(ctx, s, *len,
 		    orangefs_khandle_to_ino(khandle), DT_UNKNOWN))
 			return 0;
-		od->i += padlen + sizeof *khandle;
-		od->i = od->i + (8 - od->i%8)%8;
-		ctx->pos = 2 + od->i;
+		i += padlen + sizeof *khandle;
+		i = i + (8 - i%8)%8;
+		ctx->pos = i + 2;
 	}
-	BUG_ON(od->i > od->len);
+	BUG_ON(i > od->len);
 	return 0;
 eio:
-	gossip_err("orangefs_dir_fill: userspace returns corrupt data\n");
+	/*
+	 * Here either data from userspace is corrupt or the application
+	 * has sought to an invalid location.
+	 */
 	od->error = -EIO;
 	return -EIO;
 }
@@ -193,12 +198,29 @@ static int orangefs_dir_iterate(struct file *file,
 
 	r = 0;
 
-	if (od->i < od->len) {
+	/*
+	 * Must read more if the user has sought past what has been read
+	 * so far.  Stop a user who has sought past the end.
+	 */
+	while (od->token != ORANGEFS_READDIR_END && ctx->pos - 2 >
+	    od->len) {
+		r = orangefs_dir_more(oi, od, dentry);
+		if (r)
+			return r;
+	}
+	if (od->token == ORANGEFS_READDIR_END && ctx->pos - 2 >
+	    od->len) {
+		return -EIO;
+	}
+
+	/* Then try to fill if there's any left in the buffer. */
+	if (ctx->pos - 2 < od->len) {
 		r = orangefs_dir_fill(oi, od, dentry, ctx);
 		if (r)
 			return r;
 	}
 
+	/* Finally get some more and try to fill. */
 	if (od->token != ORANGEFS_READDIR_END) {
 		r = orangefs_dir_more(oi, od, dentry);
 		if (r)
@@ -227,7 +249,6 @@ static int orangefs_dir_open(struct inode *inode, struct file *file)
 		kfree(file->private_data);
 		return -ENOMEM;
 	}
-	od->i = 0;
 	od->len = 0;
 	od->error = 0;
 	return 0;
@@ -243,6 +264,7 @@ static int orangefs_dir_release(struct inode *inode, struct file *file)
 }
 
 const struct file_operations orangefs_dir_operations = {
+	.llseek = default_llseek,
 	.read = generic_read_dir,
 	.iterate = orangefs_dir_iterate,
 	.open = orangefs_dir_open,

commit 382f4581e67f57209c7aa67e39f26ba076306a2e
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 25 15:37:59 2017 -0400

    orangefs: rewrite readdir to fix several bugs
    
    In the past, readdir assumed that the user buffer will be large enough
    that all entries from the server will fit.  If this was not true,
    entries would be skipped.
    
    Since it works now, request 512 entries rather than 96 per server
    operation.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index 284373a57a08..cf0ebb06b84e 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -1,7 +1,5 @@
 /*
- * (C) 2001 Clemson University and The University of Chicago
- *
- * See COPYING in top-level directory.
+ * Copyright 2017 Omnibond Systems, L.L.C.
  */
 
 #include "protocol.h"
@@ -9,388 +7,244 @@
 #include "orangefs-bufmap.h"
 
 /*
- * decode routine used by kmod to deal with the blob sent from
- * userspace for readdirs. The blob contains zero or more of these
- * sub-blobs:
- *   __u32 - represents length of the character string that follows.
- *   string - between 1 and ORANGEFS_NAME_MAX bytes long.
- *   padding - (if needed) to cause the __u32 plus the string to be
- *             eight byte aligned.
- *   khandle - sizeof(khandle) bytes.
+ * There can be up to 512 directory entries.  Each entry is encoded as
+ * follows:
+ * 4 bytes: string size (n)
+ * n bytes: string
+ * 1 byte: trailing zero
+ * padding to 8 bytes
+ * 16 bytes: khandle
+ * padding to 8 bytes
  */
-static long decode_dirents(char *ptr, size_t size,
-                           struct orangefs_readdir_response_s *readdir)
-{
-	int i;
-	struct orangefs_readdir_response_s *rd =
-		(struct orangefs_readdir_response_s *) ptr;
-	char *buf = ptr;
-	int khandle_size = sizeof(struct orangefs_khandle);
-	size_t offset = offsetof(struct orangefs_readdir_response_s,
-				dirent_array);
-	/* 8 reflects eight byte alignment */
-	int smallest_blob = khandle_size + 8;
-	__u32 len;
-	int aligned_len;
-	int sizeof_u32 = sizeof(__u32);
-	long ret;
-
-	gossip_debug(GOSSIP_DIR_DEBUG, "%s: size:%zu:\n", __func__, size);
+#define MAX_DIRECTORY ((4 + 257 + 3 + 16)*512)
 
-	/* size is = offset on empty dirs, > offset on non-empty dirs... */
-	if (size < offset) {
-		gossip_err("%s: size:%zu: offset:%zu:\n",
-			   __func__,
-			   size,
-			   offset);
-		ret = -EINVAL;
-		goto out;
-	}
-
-        if ((size == offset) && (readdir->orangefs_dirent_outcount != 0)) {
-		gossip_err("%s: size:%zu: dirent_outcount:%d:\n",
-			   __func__,
-			   size,
-			   readdir->orangefs_dirent_outcount);
-		ret = -EINVAL;
-		goto out;
-	}
-
-	readdir->token = rd->token;
-	readdir->orangefs_dirent_outcount = rd->orangefs_dirent_outcount;
-	readdir->dirent_array = kcalloc(readdir->orangefs_dirent_outcount,
-					sizeof(*readdir->dirent_array),
-					GFP_KERNEL);
-	if (readdir->dirent_array == NULL) {
-		gossip_err("%s: kcalloc failed.\n", __func__);
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	buf += offset;
-	size -= offset;
-
-	for (i = 0; i < readdir->orangefs_dirent_outcount; i++) {
-		if (size < smallest_blob) {
-			gossip_err("%s: size:%zu: smallest_blob:%d:\n",
-				   __func__,
-				   size,
-				   smallest_blob);
-			ret = -EINVAL;
-			goto free;
-		}
-
-		len = *(__u32 *)buf;
-		if ((len < 1) || (len > ORANGEFS_NAME_MAX)) {
-			gossip_err("%s: len:%d:\n", __func__, len);
-			ret = -EINVAL;
-			goto free;
-		}
-
-		gossip_debug(GOSSIP_DIR_DEBUG,
-			     "%s: size:%zu: len:%d:\n",
-			     __func__,
-			     size,
-			     len);
-
-		readdir->dirent_array[i].d_name = buf + sizeof_u32;
-		readdir->dirent_array[i].d_length = len;
-
-		/*
-		 * Calculate "aligned" length of this string and its
-		 * associated __u32 descriptor.
-		 */
-		aligned_len = ((sizeof_u32 + len + 1) + 7) & ~7;
-		gossip_debug(GOSSIP_DIR_DEBUG,
-			     "%s: aligned_len:%d:\n",
-			     __func__,
-			     aligned_len);
-
-		/*
-		 * The end of the blob should coincide with the end
-		 * of the last sub-blob.
-		 */
-		if (size < aligned_len + khandle_size) {
-			gossip_err("%s: ran off the end of the blob.\n",
-				   __func__);
-			ret = -EINVAL;
-			goto free;
-		}
-		size -= aligned_len + khandle_size;
-
-		buf += aligned_len;
-
-		readdir->dirent_array[i].khandle =
-			*(struct orangefs_khandle *) buf;
-		buf += khandle_size;
-	}
-	ret = buf - ptr;
-	gossip_debug(GOSSIP_DIR_DEBUG, "%s: returning:%ld:\n", __func__, ret);
-	goto out;
-
-free:
-	kfree(readdir->dirent_array);
-	readdir->dirent_array = NULL;
-
-out:
-	return ret;
-}
+struct orangefs_dir {
+	__u64 token;
+	void *directory;
+	size_t i, len;
+	int error;
+};
 
 /*
- * Read directory entries from an instance of an open directory.
+ * The userspace component sends several directory entries of the
+ * following format.  The first four bytes are the string length not
+ * including a trailing zero byte.  This is followed by the string and a
+ * trailing zero padded to the next four byte boundry.  This is followed
+ * by the sixteen byte khandle padded to the next eight byte boundry.
+ *
+ * The trailer_buf starts with a struct orangefs_readdir_response_s
+ * which must be skipped to get to the directory data.
  */
-static int orangefs_readdir(struct file *file, struct dir_context *ctx)
-{
-	int ret = 0;
-	int buffer_index;
-	/*
-	 * ptoken supports Orangefs' distributed directory logic, added
-	 * in 2.9.2.
-	 */
-	__u64 *ptoken = file->private_data;
-	__u64 pos = 0;
-	ino_t ino = 0;
-	struct dentry *dentry = file->f_path.dentry;
-	struct orangefs_kernel_op_s *new_op = NULL;
-	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(dentry->d_inode);
-	struct orangefs_readdir_response_s readdir_response;
-	void *dents_buf;
-	int i = 0;
-	int len = 0;
-	ino_t current_ino = 0;
-	char *current_entry = NULL;
-	long bytes_decoded;
-
-	gossip_debug(GOSSIP_DIR_DEBUG,
-		     "%s: ctx->pos:%lld, ptoken = %llu\n",
-		     __func__,
-		     lld(ctx->pos),
-		     llu(*ptoken));
-
-	pos = (__u64) ctx->pos;
-
-	/* are we done? */
-	if (pos == ORANGEFS_READDIR_END) {
-		gossip_debug(GOSSIP_DIR_DEBUG,
-			     "Skipping to termination path\n");
-		return 0;
-	}
-
-	gossip_debug(GOSSIP_DIR_DEBUG,
-		     "orangefs_readdir called on %pd (pos=%llu)\n",
-		     dentry, llu(pos));
-
-	memset(&readdir_response, 0, sizeof(readdir_response));
 
-	new_op = op_alloc(ORANGEFS_VFS_OP_READDIR);
-	if (!new_op)
+static int orangefs_dir_more(struct orangefs_inode_s *oi,
+    struct orangefs_dir *od, struct dentry *dentry)
+{
+	const size_t offset =
+	    sizeof(struct orangefs_readdir_response_s);
+	struct orangefs_readdir_response_s *resp;
+	struct orangefs_kernel_op_s *op;
+	int bufi, r;
+
+	op = op_alloc(ORANGEFS_VFS_OP_READDIR);
+	if (!op) {
+		od->error = -ENOMEM;
 		return -ENOMEM;
+	}
 
 	/*
-	 * Only the indices are shared. No memory is actually shared, but the
-	 * mechanism is used.
+	 * Despite the badly named field, readdir does not use shared
+	 * memory.  However, there are a limited number of readdir
+	 * slots, which must be allocated here.  This flag simply tells
+	 * the op scheduler to return the op here for retry.
 	 */
-	new_op->uses_shared_memory = 1;
-	new_op->upcall.req.readdir.refn = orangefs_inode->refn;
-	new_op->upcall.req.readdir.max_dirent_count =
+	op->uses_shared_memory = 1;
+	op->upcall.req.readdir.refn = oi->refn;
+	op->upcall.req.readdir.token = od->token;
+	op->upcall.req.readdir.max_dirent_count =
 	    ORANGEFS_MAX_DIRENT_COUNT_READDIR;
 
-	gossip_debug(GOSSIP_DIR_DEBUG,
-		     "%s: upcall.req.readdir.refn.khandle: %pU\n",
-		     __func__,
-		     &new_op->upcall.req.readdir.refn.khandle);
-
-	new_op->upcall.req.readdir.token = *ptoken;
-
-get_new_buffer_index:
-	buffer_index = orangefs_readdir_index_get();
-	if (buffer_index < 0) {
-		ret = buffer_index;
-		gossip_lerr("orangefs_readdir: orangefs_readdir_index_get() failure (%d)\n",
-			    ret);
-		goto out_free_op;
+again:
+	bufi = orangefs_readdir_index_get();
+	if (bufi < 0) {
+		op_release(op);
+		od->error = bufi;
+		return bufi;
 	}
-	new_op->upcall.req.readdir.buf_index = buffer_index;
 
-	ret = service_operation(new_op,
-				"orangefs_readdir",
-				get_interruptible_flag(dentry->d_inode));
+	op->upcall.req.readdir.buf_index = bufi;
 
-	gossip_debug(GOSSIP_DIR_DEBUG,
-		     "Readdir downcall status is %d.  ret:%d\n",
-		     new_op->downcall.status,
-		     ret);
+	r = service_operation(op, "orangefs_readdir",
+	    get_interruptible_flag(dentry->d_inode));
 
-	orangefs_readdir_index_put(buffer_index);
+	orangefs_readdir_index_put(bufi);
 
-	if (ret == -EAGAIN && op_state_purged(new_op)) {
-		/* Client-core indices are invalid after it restarted. */
-		gossip_debug(GOSSIP_DIR_DEBUG,
-			"%s: Getting new buffer_index for retry of readdir..\n",
-			 __func__);
-		goto get_new_buffer_index;
-	}
-
-	if (ret == -EIO && op_state_purged(new_op)) {
-		gossip_err("%s: Client is down. Aborting readdir call.\n",
-			__func__);
-		goto out_free_op;
+	if (op_state_purged(op)) {
+		if (r == -EAGAIN) {
+			vfree(op->downcall.trailer_buf);
+			goto again;
+		} else if (r == -EIO) {
+			vfree(op->downcall.trailer_buf);
+			op_release(op);
+			od->error = r;
+			return r;
+		}
 	}
 
-	if (ret < 0 || new_op->downcall.status != 0) {
-		gossip_debug(GOSSIP_DIR_DEBUG,
-			     "Readdir request failed.  Status:%d\n",
-			     new_op->downcall.status);
-		if (ret >= 0)
-			ret = new_op->downcall.status;
-		goto out_free_op;
-	}
+	if (r < 0) {
+		vfree(op->downcall.trailer_buf);
+		op_release(op);
+		od->error = r;
+		return r;
+	} else if (op->downcall.status) {
+		vfree(op->downcall.trailer_buf);
+		op_release(op);
+		od->error = op->downcall.status;
+		return op->downcall.status;
+	}
+
+	resp = (struct orangefs_readdir_response_s *)
+	    op->downcall.trailer_buf;
+	od->token = resp->token;
+
+	if (od->len + op->downcall.trailer_size - offset <=
+	    MAX_DIRECTORY) {
+		memcpy(od->directory + od->len,
+		    op->downcall.trailer_buf + offset,
+		    op->downcall.trailer_size - offset);
+		od->len += op->downcall.trailer_size - offset;
+	} else {
+		/* This limit was chosen based on protocol limits. */
+		gossip_err("orangefs_dir_more: userspace sent too much data\n");
+		vfree(op->downcall.trailer_buf);
+		op_release(op);
+		od->error = -EIO;
+		return -EIO;
+	}
+
+	vfree(op->downcall.trailer_buf);
+	op_release(op);
+	return 0;
+}
 
-	dents_buf = new_op->downcall.trailer_buf;
-	if (dents_buf == NULL) {
-		gossip_err("Invalid NULL buffer in readdir response\n");
-		ret = -ENOMEM;
-		goto out_free_op;
-	}
+static int orangefs_dir_fill(struct orangefs_inode_s *oi,
+    struct orangefs_dir *od, struct dentry *dentry,
+    struct dir_context *ctx)
+{
+	struct orangefs_khandle *khandle;
+	__u32 *len, padlen;
+	char *s;
+	while (od->i < od->len) {
+		if (od->len < od->i + sizeof *len)
+			goto eio;
+		len = od->directory + od->i;
+		/*
+		 * len is the size of the string itself.  padlen is the
+		 * total size of the encoded string.
+		 */
+		padlen = (sizeof *len + *len + 1) +
+		    (4 - (sizeof *len + *len + 1)%8)%8;
+		if (od->len < od->i + padlen + sizeof *khandle)
+			goto eio;
+		s = od->directory + od->i + sizeof *len;
+		if (s[*len] != 0)
+			goto eio;
+		khandle = od->directory + od->i + padlen;
+
+		if (!dir_emit(ctx, s, *len,
+		    orangefs_khandle_to_ino(khandle), DT_UNKNOWN))
+			return 0;
+		od->i += padlen + sizeof *khandle;
+		od->i = od->i + (8 - od->i%8)%8;
+		ctx->pos = 2 + od->i;
+	}
+	BUG_ON(od->i > od->len);
+	return 0;
+eio:
+	gossip_err("orangefs_dir_fill: userspace returns corrupt data\n");
+	od->error = -EIO;
+	return -EIO;
+}
 
-	bytes_decoded = decode_dirents(dents_buf, new_op->downcall.trailer_size,
-					&readdir_response);
-	if (bytes_decoded < 0) {
-		ret = bytes_decoded;
-		gossip_err("Could not decode readdir from buffer %d\n", ret);
-		goto out_vfree;
-	}
+static int orangefs_dir_iterate(struct file *file,
+    struct dir_context *ctx)
+{
+	struct orangefs_inode_s *oi;
+	struct orangefs_dir *od;
+	struct dentry *dentry;
+	int r;
 
-	if (bytes_decoded != new_op->downcall.trailer_size) {
-		gossip_err("orangefs_readdir: # bytes decoded (%ld) "
-			   "!= trailer size (%ld)\n",
-			   bytes_decoded,
-			   (long)new_op->downcall.trailer_size);
-		ret = -EINVAL;
-		goto out_destroy_handle;
-	}
+	dentry = file->f_path.dentry;
+	oi = ORANGEFS_I(dentry->d_inode);
+	od = file->private_data;
 
-	/*
-	 *  orangefs doesn't actually store dot and dot-dot, but
-	 *  we need to have them represented.
-	 */
-	if (pos == 0) {
-		ino = get_ino_from_khandle(dentry->d_inode);
-		gossip_debug(GOSSIP_DIR_DEBUG,
-			     "%s: calling dir_emit of \".\" with pos = %llu\n",
-			     __func__,
-			     llu(pos));
-		ret = dir_emit(ctx, ".", 1, ino, DT_DIR);
-		pos += 1;
-	}
+	if (od->error)
+		return od->error;
 
-	if (pos == 1) {
-		ino = get_parent_ino_from_dentry(dentry);
-		gossip_debug(GOSSIP_DIR_DEBUG,
-			     "%s: calling dir_emit of \"..\" with pos = %llu\n",
-			     __func__,
-			     llu(pos));
-		ret = dir_emit(ctx, "..", 2, ino, DT_DIR);
-		pos += 1;
+	if (ctx->pos == 0) {
+		if (!dir_emit_dot(file, ctx))
+			return 0;
+		ctx->pos++;
 	}
-
-	/*
-	 * we stored ORANGEFS_ITERATE_NEXT in ctx->pos last time around
-	 * to prevent "finding" dot and dot-dot on any iteration
-	 * other than the first.
-	 */
-	if (ctx->pos == ORANGEFS_ITERATE_NEXT)
-		ctx->pos = 0;
-
-	gossip_debug(GOSSIP_DIR_DEBUG,
-		     "%s: dirent_outcount:%d:\n",
-		     __func__,
-		     readdir_response.orangefs_dirent_outcount);
-	for (i = ctx->pos;
-	     i < readdir_response.orangefs_dirent_outcount;
-	     i++) {
-		len = readdir_response.dirent_array[i].d_length;
-		current_entry = readdir_response.dirent_array[i].d_name;
-		current_ino = orangefs_khandle_to_ino(
-			&readdir_response.dirent_array[i].khandle);
-
-		gossip_debug(GOSSIP_DIR_DEBUG,
-			     "calling dir_emit for %s with len %d"
-			     ", ctx->pos %ld\n",
-			     current_entry,
-			     len,
-			     (unsigned long)ctx->pos);
-		/*
-		 * type is unknown. We don't return object type
-		 * in the dirent_array. This leaves getdents
-		 * clueless about type.
-		 */
-		ret =
-		    dir_emit(ctx, current_entry, len, current_ino, DT_UNKNOWN);
-		if (!ret)
-			break;
+	if (ctx->pos == 1) {
+		if (!dir_emit_dotdot(file, ctx))
+			return 0;
 		ctx->pos++;
-		gossip_debug(GOSSIP_DIR_DEBUG,
-			      "%s: ctx->pos:%lld\n",
-			      __func__,
-			      lld(ctx->pos));
-
 	}
 
-	/*
-	 * we ran all the way through the last batch, set up for
-	 * getting another batch...
-	 */
-	if (ret) {
-		*ptoken = readdir_response.token;
-		ctx->pos = ORANGEFS_ITERATE_NEXT;
+	r = 0;
+
+	if (od->i < od->len) {
+		r = orangefs_dir_fill(oi, od, dentry, ctx);
+		if (r)
+			return r;
 	}
 
-	/*
-	 * Did we hit the end of the directory?
-	 */
-	if (readdir_response.token == ORANGEFS_READDIR_END) {
-		gossip_debug(GOSSIP_DIR_DEBUG,
-		"End of dir detected; setting ctx->pos to ORANGEFS_READDIR_END.\n");
-		ctx->pos = ORANGEFS_READDIR_END;
+	if (od->token != ORANGEFS_READDIR_END) {
+		r = orangefs_dir_more(oi, od, dentry);
+		if (r)
+			return r;
+		r = orangefs_dir_fill(oi, od, dentry, ctx);
 	}
 
-out_destroy_handle:
-	/* kfree(NULL) is safe */
-	kfree(readdir_response.dirent_array);
-out_vfree:
-	gossip_debug(GOSSIP_DIR_DEBUG, "vfree %p\n", dents_buf);
-	vfree(dents_buf);
-out_free_op:
-	op_release(new_op);
-	gossip_debug(GOSSIP_DIR_DEBUG, "orangefs_readdir returning %d\n", ret);
-	return ret;
+	return r;
 }
 
 static int orangefs_dir_open(struct inode *inode, struct file *file)
 {
-	__u64 *ptoken;
-
-	file->private_data = kmalloc(sizeof(__u64), GFP_KERNEL);
+	struct orangefs_dir *od;
+	file->private_data = kmalloc(sizeof(struct orangefs_dir),
+	    GFP_KERNEL);
 	if (!file->private_data)
 		return -ENOMEM;
-
-	ptoken = file->private_data;
-	*ptoken = ORANGEFS_READDIR_START;
+	od = file->private_data;
+	od->token = ORANGEFS_READDIR_START;
+	/*
+	 * XXX: It seems wasteful to allocate such a large buffer for
+	 * each request.  Most will be much smaller.
+	 */
+	od->directory = alloc_pages_exact(MAX_DIRECTORY, GFP_KERNEL);
+	if (!od->directory) {
+		kfree(file->private_data);
+		return -ENOMEM;
+	}
+	od->i = 0;
+	od->len = 0;
+	od->error = 0;
 	return 0;
 }
 
 static int orangefs_dir_release(struct inode *inode, struct file *file)
 {
+	struct orangefs_dir *od = file->private_data;
 	orangefs_flush_inode(inode);
-	kfree(file->private_data);
+	free_pages_exact(od->directory, MAX_DIRECTORY);
+	kfree(od);
 	return 0;
 }
 
-/** ORANGEFS implementation of VFS directory operations */
 const struct file_operations orangefs_dir_operations = {
 	.read = generic_read_dir,
-	.iterate = orangefs_readdir,
+	.iterate = orangefs_dir_iterate,
 	.open = orangefs_dir_open,
-	.release = orangefs_dir_release,
+	.release = orangefs_dir_release
 };

commit f66debf1b3755039680289d83fe7a92a4ad3d77d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Aug 7 12:20:01 2016 -0400

    orangefs: use %pd/%pD
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index 324f0af40d7b..284373a57a08 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -177,8 +177,8 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 	}
 
 	gossip_debug(GOSSIP_DIR_DEBUG,
-		     "orangefs_readdir called on %s (pos=%llu)\n",
-		     dentry->d_name.name, llu(pos));
+		     "orangefs_readdir called on %pd (pos=%llu)\n",
+		     dentry, llu(pos));
 
 	memset(&readdir_response, 0, sizeof(readdir_response));
 

commit e56f49814250f4ca4b66ec7d3a71152846761d1b
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Apr 4 16:26:38 2016 -0400

    orangefs: remove unused variable
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index ba7dec40771e..324f0af40d7b 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -153,7 +153,6 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 	struct dentry *dentry = file->f_path.dentry;
 	struct orangefs_kernel_op_s *new_op = NULL;
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(dentry->d_inode);
-	int buffer_full = 0;
 	struct orangefs_readdir_response_s readdir_response;
 	void *dents_buf;
 	int i = 0;
@@ -350,8 +349,7 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 	/*
 	 * Did we hit the end of the directory?
 	 */
-	if (readdir_response.token == ORANGEFS_READDIR_END &&
-	    !buffer_full) {
+	if (readdir_response.token == ORANGEFS_READDIR_END) {
 		gossip_debug(GOSSIP_DIR_DEBUG,
 		"End of dir detected; setting ctx->pos to ORANGEFS_READDIR_END.\n");
 		ctx->pos = ORANGEFS_READDIR_END;

commit 641bb3246dbb64c0b4a0b6dfa6a024e82c155533
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Mar 28 17:18:27 2016 -0400

    orangefs: don't put readdir slot twice
    
    This was quite an oversight. After a readdir, the module could not be
    unloaded, the number of slots is wrong, and memory near the slot bitmap
    is possibly corrupt. Oops.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index f30b6ecacdd1..ba7dec40771e 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -235,7 +235,7 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 	if (ret == -EIO && op_state_purged(new_op)) {
 		gossip_err("%s: Client is down. Aborting readdir call.\n",
 			__func__);
-		goto out_slot;
+		goto out_free_op;
 	}
 
 	if (ret < 0 || new_op->downcall.status != 0) {
@@ -244,14 +244,14 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 			     new_op->downcall.status);
 		if (ret >= 0)
 			ret = new_op->downcall.status;
-		goto out_slot;
+		goto out_free_op;
 	}
 
 	dents_buf = new_op->downcall.trailer_buf;
 	if (dents_buf == NULL) {
 		gossip_err("Invalid NULL buffer in readdir response\n");
 		ret = -ENOMEM;
-		goto out_slot;
+		goto out_free_op;
 	}
 
 	bytes_decoded = decode_dirents(dents_buf, new_op->downcall.trailer_size,
@@ -363,8 +363,6 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 out_vfree:
 	gossip_debug(GOSSIP_DIR_DEBUG, "vfree %p\n", dents_buf);
 	vfree(dents_buf);
-out_slot:
-	orangefs_readdir_index_put(buffer_index);
 out_free_op:
 	op_release(new_op);
 	gossip_debug(GOSSIP_DIR_DEBUG, "orangefs_readdir returning %d\n", ret);

commit b8a99a8f9f0aebf2a75bb0d9280bff7e7ac9b57e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Feb 16 20:10:26 2016 -0500

    orangefs: saner calling conventions for getting a slot
    
    just have it return the slot number or -E... - the caller checks
    the sign anyway
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index 53a411732606..f30b6ecacdd1 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -141,7 +141,6 @@ static long decode_dirents(char *ptr, size_t size,
  */
 static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 {
-	struct orangefs_bufmap *bufmap = NULL;
 	int ret = 0;
 	int buffer_index;
 	/*
@@ -205,8 +204,9 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 	new_op->upcall.req.readdir.token = *ptoken;
 
 get_new_buffer_index:
-	ret = orangefs_readdir_index_get(&bufmap, &buffer_index);
-	if (ret < 0) {
+	buffer_index = orangefs_readdir_index_get();
+	if (buffer_index < 0) {
+		ret = buffer_index;
 		gossip_lerr("orangefs_readdir: orangefs_readdir_index_get() failure (%d)\n",
 			    ret);
 		goto out_free_op;

commit 9f5e2f7f1b4bf7d0b19d88edd9425510fadbb9e4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Feb 16 19:54:13 2016 -0500

    orangefs: get rid of readdir_handle_s
    
    no point, really - we couldn't keep those across the calls of
    getdents(); it would be too easy to DoS, having all slots exhausted.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index 259b667f6c8f..53a411732606 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -8,11 +8,6 @@
 #include "orangefs-kernel.h"
 #include "orangefs-bufmap.h"
 
-struct readdir_handle_s {
-	struct orangefs_readdir_response_s readdir_response;
-	void *dents_buf;
-};
-
 /*
  * decode routine used by kmod to deal with the blob sent from
  * userspace for readdirs. The blob contains zero or more of these
@@ -141,44 +136,6 @@ static long decode_dirents(char *ptr, size_t size,
 	return ret;
 }
 
-static long readdir_handle_ctor(struct readdir_handle_s *rhandle, void *buf,
-				size_t size)
-{
-	long ret;
-
-	if (buf == NULL) {
-		gossip_err
-		    ("Invalid NULL buffer specified in readdir_handle_ctor\n");
-		return -ENOMEM;
-	}
-	rhandle->dents_buf = buf;
-	ret = decode_dirents(buf, size, &rhandle->readdir_response);
-	if (ret < 0) {
-		gossip_err("Could not decode readdir from buffer %ld\n", ret);
-		gossip_debug(GOSSIP_DIR_DEBUG, "vfree %p\n", buf);
-		vfree(buf);
-		rhandle->dents_buf = NULL;
-	}
-	return ret;
-}
-
-static void readdir_handle_dtor(struct readdir_handle_s *rhandle)
-{
-	if (rhandle == NULL)
-		return;
-
-	/* kfree(NULL) is safe */
-	kfree(rhandle->readdir_response.dirent_array);
-	rhandle->readdir_response.dirent_array = NULL;
-
-	if (rhandle->dents_buf) {
-		gossip_debug(GOSSIP_DIR_DEBUG, "vfree %p\n",
-			     rhandle->dents_buf);
-		vfree(rhandle->dents_buf);
-		rhandle->dents_buf = NULL;
-	}
-}
-
 /*
  * Read directory entries from an instance of an open directory.
  */
@@ -198,7 +155,8 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 	struct orangefs_kernel_op_s *new_op = NULL;
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(dentry->d_inode);
 	int buffer_full = 0;
-	struct readdir_handle_s rhandle;
+	struct orangefs_readdir_response_s readdir_response;
+	void *dents_buf;
 	int i = 0;
 	int len = 0;
 	ino_t current_ino = 0;
@@ -224,8 +182,7 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 		     "orangefs_readdir called on %s (pos=%llu)\n",
 		     dentry->d_name.name, llu(pos));
 
-	rhandle.dents_buf = NULL;
-	memset(&rhandle.readdir_response, 0, sizeof(rhandle.readdir_response));
+	memset(&readdir_response, 0, sizeof(readdir_response));
 
 	new_op = op_alloc(ORANGEFS_VFS_OP_READDIR);
 	if (!new_op)
@@ -278,7 +235,7 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 	if (ret == -EIO && op_state_purged(new_op)) {
 		gossip_err("%s: Client is down. Aborting readdir call.\n",
 			__func__);
-		goto out_free_op;
+		goto out_slot;
 	}
 
 	if (ret < 0 || new_op->downcall.status != 0) {
@@ -287,18 +244,22 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 			     new_op->downcall.status);
 		if (ret >= 0)
 			ret = new_op->downcall.status;
-		goto out_free_op;
+		goto out_slot;
+	}
+
+	dents_buf = new_op->downcall.trailer_buf;
+	if (dents_buf == NULL) {
+		gossip_err("Invalid NULL buffer in readdir response\n");
+		ret = -ENOMEM;
+		goto out_slot;
 	}
 
-	bytes_decoded =
-		readdir_handle_ctor(&rhandle,
-				    new_op->downcall.trailer_buf,
-				    new_op->downcall.trailer_size);
+	bytes_decoded = decode_dirents(dents_buf, new_op->downcall.trailer_size,
+					&readdir_response);
 	if (bytes_decoded < 0) {
-		gossip_err("orangefs_readdir: Could not decode trailer buffer into a readdir response %d\n",
-			ret);
 		ret = bytes_decoded;
-		goto out_free_op;
+		gossip_err("Could not decode readdir from buffer %d\n", ret);
+		goto out_vfree;
 	}
 
 	if (bytes_decoded != new_op->downcall.trailer_size) {
@@ -345,14 +306,14 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 	gossip_debug(GOSSIP_DIR_DEBUG,
 		     "%s: dirent_outcount:%d:\n",
 		     __func__,
-		     rhandle.readdir_response.orangefs_dirent_outcount);
+		     readdir_response.orangefs_dirent_outcount);
 	for (i = ctx->pos;
-	     i < rhandle.readdir_response.orangefs_dirent_outcount;
+	     i < readdir_response.orangefs_dirent_outcount;
 	     i++) {
-		len = rhandle.readdir_response.dirent_array[i].d_length;
-		current_entry = rhandle.readdir_response.dirent_array[i].d_name;
+		len = readdir_response.dirent_array[i].d_length;
+		current_entry = readdir_response.dirent_array[i].d_name;
 		current_ino = orangefs_khandle_to_ino(
-			&(rhandle.readdir_response.dirent_array[i].khandle));
+			&readdir_response.dirent_array[i].khandle);
 
 		gossip_debug(GOSSIP_DIR_DEBUG,
 			     "calling dir_emit for %s with len %d"
@@ -382,14 +343,14 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 	 * getting another batch...
 	 */
 	if (ret) {
-		*ptoken = rhandle.readdir_response.token;
+		*ptoken = readdir_response.token;
 		ctx->pos = ORANGEFS_ITERATE_NEXT;
 	}
 
 	/*
 	 * Did we hit the end of the directory?
 	 */
-	if (rhandle.readdir_response.token == ORANGEFS_READDIR_END &&
+	if (readdir_response.token == ORANGEFS_READDIR_END &&
 	    !buffer_full) {
 		gossip_debug(GOSSIP_DIR_DEBUG,
 		"End of dir detected; setting ctx->pos to ORANGEFS_READDIR_END.\n");
@@ -397,7 +358,13 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 	}
 
 out_destroy_handle:
-	readdir_handle_dtor(&rhandle);
+	/* kfree(NULL) is safe */
+	kfree(readdir_response.dirent_array);
+out_vfree:
+	gossip_debug(GOSSIP_DIR_DEBUG, "vfree %p\n", dents_buf);
+	vfree(dents_buf);
+out_slot:
+	orangefs_readdir_index_put(buffer_index);
 out_free_op:
 	op_release(new_op);
 	gossip_debug(GOSSIP_DIR_DEBUG, "orangefs_readdir returning %d\n", ret);

commit cf07c0bf88b7e8765361e808b61fef287caedfe3
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Mar 9 13:11:45 2016 -0500

    Orangefs: add a new gossip statement
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index 43e3aeb529ea..259b667f6c8f 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -342,6 +342,10 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 	if (ctx->pos == ORANGEFS_ITERATE_NEXT)
 		ctx->pos = 0;
 
+	gossip_debug(GOSSIP_DIR_DEBUG,
+		     "%s: dirent_outcount:%d:\n",
+		     __func__,
+		     rhandle.readdir_response.orangefs_dirent_outcount);
 	for (i = ctx->pos;
 	     i < rhandle.readdir_response.orangefs_dirent_outcount;
 	     i++) {

commit ee3b8d377ca014b0ec4ea8988ba6fbe8463bd8d9
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Wed Feb 17 12:55:42 2016 -0500

    orangefs: free readdir buffer index before the dir_emit loop
    
    We only need it while the service operation is actually in progress
    since it is only used to co-ordinate the client-core's memory use. The
    kernel allocates its own space.
    
    Also clean up some comments which mislead the reader into thinking
    the readdir buffers are shared memory.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index c9b8d0ced833..43e3aeb529ea 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -9,7 +9,6 @@
 #include "orangefs-bufmap.h"
 
 struct readdir_handle_s {
-	int buffer_index;
 	struct orangefs_readdir_response_s readdir_response;
 	void *dents_buf;
 };
@@ -143,7 +142,7 @@ static long decode_dirents(char *ptr, size_t size,
 }
 
 static long readdir_handle_ctor(struct readdir_handle_s *rhandle, void *buf,
-				size_t size, int buffer_index)
+				size_t size)
 {
 	long ret;
 
@@ -152,17 +151,10 @@ static long readdir_handle_ctor(struct readdir_handle_s *rhandle, void *buf,
 		    ("Invalid NULL buffer specified in readdir_handle_ctor\n");
 		return -ENOMEM;
 	}
-	if (buffer_index < 0) {
-		gossip_err
-		    ("Invalid buffer index specified in readdir_handle_ctor\n");
-		return -EINVAL;
-	}
-	rhandle->buffer_index = buffer_index;
 	rhandle->dents_buf = buf;
 	ret = decode_dirents(buf, size, &rhandle->readdir_response);
 	if (ret < 0) {
 		gossip_err("Could not decode readdir from buffer %ld\n", ret);
-		rhandle->buffer_index = -1;
 		gossip_debug(GOSSIP_DIR_DEBUG, "vfree %p\n", buf);
 		vfree(buf);
 		rhandle->dents_buf = NULL;
@@ -179,10 +171,6 @@ static void readdir_handle_dtor(struct readdir_handle_s *rhandle)
 	kfree(rhandle->readdir_response.dirent_array);
 	rhandle->readdir_response.dirent_array = NULL;
 
-	if (rhandle->buffer_index >= 0) {
-		orangefs_readdir_index_put(rhandle->buffer_index);
-		rhandle->buffer_index = -1;
-	}
 	if (rhandle->dents_buf) {
 		gossip_debug(GOSSIP_DIR_DEBUG, "vfree %p\n",
 			     rhandle->dents_buf);
@@ -236,7 +224,6 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 		     "orangefs_readdir called on %s (pos=%llu)\n",
 		     dentry->d_name.name, llu(pos));
 
-	rhandle.buffer_index = -1;
 	rhandle.dents_buf = NULL;
 	memset(&rhandle.readdir_response, 0, sizeof(rhandle.readdir_response));
 
@@ -244,6 +231,10 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 	if (!new_op)
 		return -ENOMEM;
 
+	/*
+	 * Only the indices are shared. No memory is actually shared, but the
+	 * mechanism is used.
+	 */
 	new_op->uses_shared_memory = 1;
 	new_op->upcall.req.readdir.refn = orangefs_inode->refn;
 	new_op->upcall.req.readdir.max_dirent_count =
@@ -274,23 +265,19 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 		     new_op->downcall.status,
 		     ret);
 
+	orangefs_readdir_index_put(buffer_index);
+
 	if (ret == -EAGAIN && op_state_purged(new_op)) {
-		/*
-		 * readdir shared memory aread has been wiped due to
-		 * pvfs2-client-core restarting, so we must get a new
-		 * index into the shared memory.
-		 */
+		/* Client-core indices are invalid after it restarted. */
 		gossip_debug(GOSSIP_DIR_DEBUG,
 			"%s: Getting new buffer_index for retry of readdir..\n",
 			 __func__);
-		orangefs_readdir_index_put(buffer_index);
 		goto get_new_buffer_index;
 	}
 
 	if (ret == -EIO && op_state_purged(new_op)) {
 		gossip_err("%s: Client is down. Aborting readdir call.\n",
 			__func__);
-		orangefs_readdir_index_put(buffer_index);
 		goto out_free_op;
 	}
 
@@ -298,7 +285,6 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 		gossip_debug(GOSSIP_DIR_DEBUG,
 			     "Readdir request failed.  Status:%d\n",
 			     new_op->downcall.status);
-		orangefs_readdir_index_put(buffer_index);
 		if (ret >= 0)
 			ret = new_op->downcall.status;
 		goto out_free_op;
@@ -307,13 +293,11 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 	bytes_decoded =
 		readdir_handle_ctor(&rhandle,
 				    new_op->downcall.trailer_buf,
-				    new_op->downcall.trailer_size,
-				    buffer_index);
+				    new_op->downcall.trailer_size);
 	if (bytes_decoded < 0) {
 		gossip_err("orangefs_readdir: Could not decode trailer buffer into a readdir response %d\n",
 			ret);
 		ret = bytes_decoded;
-		orangefs_readdir_index_put(buffer_index);
 		goto out_free_op;
 	}
 

commit 82d37f19ff885ece97b8a072182e39c9dc4ead7d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Feb 13 21:04:51 2016 -0500

    orangefs_readdir_index_put(): get rid of bufmap argument
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index 6f5836d6a7a3..c9b8d0ced833 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -170,8 +170,7 @@ static long readdir_handle_ctor(struct readdir_handle_s *rhandle, void *buf,
 	return ret;
 }
 
-static void readdir_handle_dtor(struct orangefs_bufmap *bufmap,
-		struct readdir_handle_s *rhandle)
+static void readdir_handle_dtor(struct readdir_handle_s *rhandle)
 {
 	if (rhandle == NULL)
 		return;
@@ -181,7 +180,7 @@ static void readdir_handle_dtor(struct orangefs_bufmap *bufmap,
 	rhandle->readdir_response.dirent_array = NULL;
 
 	if (rhandle->buffer_index >= 0) {
-		orangefs_readdir_index_put(bufmap, rhandle->buffer_index);
+		orangefs_readdir_index_put(rhandle->buffer_index);
 		rhandle->buffer_index = -1;
 	}
 	if (rhandle->dents_buf) {
@@ -284,14 +283,14 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 		gossip_debug(GOSSIP_DIR_DEBUG,
 			"%s: Getting new buffer_index for retry of readdir..\n",
 			 __func__);
-		orangefs_readdir_index_put(bufmap, buffer_index);
+		orangefs_readdir_index_put(buffer_index);
 		goto get_new_buffer_index;
 	}
 
 	if (ret == -EIO && op_state_purged(new_op)) {
 		gossip_err("%s: Client is down. Aborting readdir call.\n",
 			__func__);
-		orangefs_readdir_index_put(bufmap, buffer_index);
+		orangefs_readdir_index_put(buffer_index);
 		goto out_free_op;
 	}
 
@@ -299,7 +298,7 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 		gossip_debug(GOSSIP_DIR_DEBUG,
 			     "Readdir request failed.  Status:%d\n",
 			     new_op->downcall.status);
-		orangefs_readdir_index_put(bufmap, buffer_index);
+		orangefs_readdir_index_put(buffer_index);
 		if (ret >= 0)
 			ret = new_op->downcall.status;
 		goto out_free_op;
@@ -314,7 +313,7 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 		gossip_err("orangefs_readdir: Could not decode trailer buffer into a readdir response %d\n",
 			ret);
 		ret = bytes_decoded;
-		orangefs_readdir_index_put(bufmap, buffer_index);
+		orangefs_readdir_index_put(buffer_index);
 		goto out_free_op;
 	}
 
@@ -410,7 +409,7 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 	}
 
 out_destroy_handle:
-	readdir_handle_dtor(bufmap, &rhandle);
+	readdir_handle_dtor(&rhandle);
 out_free_op:
 	op_release(new_op);
 	gossip_debug(GOSSIP_DIR_DEBUG, "orangefs_readdir returning %d\n", ret);

commit 1808f8cc6cb2842c53147eccfd5e88044d0d22a6
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Jan 15 13:10:52 2016 -0500

    Orangefs: add verification to decode_dirents
    
    Also add comments to decode_dirents and make it more readable.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index 58558e37fb8a..6f5836d6a7a3 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -15,7 +15,14 @@ struct readdir_handle_s {
 };
 
 /*
- * decode routine needed by kmod to make sense of the shared page for readdirs.
+ * decode routine used by kmod to deal with the blob sent from
+ * userspace for readdirs. The blob contains zero or more of these
+ * sub-blobs:
+ *   __u32 - represents length of the character string that follows.
+ *   string - between 1 and ORANGEFS_NAME_MAX bytes long.
+ *   padding - (if needed) to cause the __u32 plus the string to be
+ *             eight byte aligned.
+ *   khandle - sizeof(khandle) bytes.
  */
 static long decode_dirents(char *ptr, size_t size,
                            struct orangefs_readdir_response_s *readdir)
@@ -24,54 +31,115 @@ static long decode_dirents(char *ptr, size_t size,
 	struct orangefs_readdir_response_s *rd =
 		(struct orangefs_readdir_response_s *) ptr;
 	char *buf = ptr;
+	int khandle_size = sizeof(struct orangefs_khandle);
+	size_t offset = offsetof(struct orangefs_readdir_response_s,
+				dirent_array);
+	/* 8 reflects eight byte alignment */
+	int smallest_blob = khandle_size + 8;
+	__u32 len;
+	int aligned_len;
+	int sizeof_u32 = sizeof(__u32);
+	long ret;
 
-	if (size < offsetof(struct orangefs_readdir_response_s, dirent_array))
-		return -EINVAL;
+	gossip_debug(GOSSIP_DIR_DEBUG, "%s: size:%zu:\n", __func__, size);
+
+	/* size is = offset on empty dirs, > offset on non-empty dirs... */
+	if (size < offset) {
+		gossip_err("%s: size:%zu: offset:%zu:\n",
+			   __func__,
+			   size,
+			   offset);
+		ret = -EINVAL;
+		goto out;
+	}
+
+        if ((size == offset) && (readdir->orangefs_dirent_outcount != 0)) {
+		gossip_err("%s: size:%zu: dirent_outcount:%d:\n",
+			   __func__,
+			   size,
+			   readdir->orangefs_dirent_outcount);
+		ret = -EINVAL;
+		goto out;
+	}
 
 	readdir->token = rd->token;
 	readdir->orangefs_dirent_outcount = rd->orangefs_dirent_outcount;
 	readdir->dirent_array = kcalloc(readdir->orangefs_dirent_outcount,
 					sizeof(*readdir->dirent_array),
 					GFP_KERNEL);
-	if (readdir->dirent_array == NULL)
-		return -ENOMEM;
+	if (readdir->dirent_array == NULL) {
+		gossip_err("%s: kcalloc failed.\n", __func__);
+		ret = -ENOMEM;
+		goto out;
+	}
 
-	buf += offsetof(struct orangefs_readdir_response_s, dirent_array);
-	size -= offsetof(struct orangefs_readdir_response_s, dirent_array);
+	buf += offset;
+	size -= offset;
 
 	for (i = 0; i < readdir->orangefs_dirent_outcount; i++) {
-		__u32 len;
-
-		if (size < 4)
-			goto Einval;
+		if (size < smallest_blob) {
+			gossip_err("%s: size:%zu: smallest_blob:%d:\n",
+				   __func__,
+				   size,
+				   smallest_blob);
+			ret = -EINVAL;
+			goto free;
+		}
 
 		len = *(__u32 *)buf;
-		if (len >= (unsigned)-24)
-			goto Einval;
+		if ((len < 1) || (len > ORANGEFS_NAME_MAX)) {
+			gossip_err("%s: len:%d:\n", __func__, len);
+			ret = -EINVAL;
+			goto free;
+		}
 
-		readdir->dirent_array[i].d_name = buf + 4;
+		gossip_debug(GOSSIP_DIR_DEBUG,
+			     "%s: size:%zu: len:%d:\n",
+			     __func__,
+			     size,
+			     len);
+
+		readdir->dirent_array[i].d_name = buf + sizeof_u32;
 		readdir->dirent_array[i].d_length = len;
 
 		/*
-		 * Round 4 + len + 1, which is the encoded size plus the string
-		 * plus the null terminator to the nearest eight byte boundry.
+		 * Calculate "aligned" length of this string and its
+		 * associated __u32 descriptor.
 		 */
-		len = ((4 + len + 1) + 7) & ~7;
-		if (size < len + 16)
-			goto Einval;
-		size -= len + 16;
+		aligned_len = ((sizeof_u32 + len + 1) + 7) & ~7;
+		gossip_debug(GOSSIP_DIR_DEBUG,
+			     "%s: aligned_len:%d:\n",
+			     __func__,
+			     aligned_len);
 
-		buf += len;
+		/*
+		 * The end of the blob should coincide with the end
+		 * of the last sub-blob.
+		 */
+		if (size < aligned_len + khandle_size) {
+			gossip_err("%s: ran off the end of the blob.\n",
+				   __func__);
+			ret = -EINVAL;
+			goto free;
+		}
+		size -= aligned_len + khandle_size;
+
+		buf += aligned_len;
 
 		readdir->dirent_array[i].khandle =
 			*(struct orangefs_khandle *) buf;
-		buf += 16;
+		buf += khandle_size;
 	}
-	return buf - ptr;
-Einval:
+	ret = buf - ptr;
+	gossip_debug(GOSSIP_DIR_DEBUG, "%s: returning:%ld:\n", __func__, ret);
+	goto out;
+
+free:
 	kfree(readdir->dirent_array);
 	readdir->dirent_array = NULL;
-	return -EINVAL;
+
+out:
+	return ret;
 }
 
 static long readdir_handle_ctor(struct readdir_handle_s *rhandle, void *buf,

commit 7d2214858f137ff5fe20d0fdc2823c12b4b54f46
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Jan 4 15:05:28 2016 -0500

    orangefs: Fix some more global namespace pollution.
    
    This only changes the names of things, so there is no functional change.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index c043894fc2bd..58558e37fb8a 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -52,7 +52,11 @@ static long decode_dirents(char *ptr, size_t size,
 		readdir->dirent_array[i].d_name = buf + 4;
 		readdir->dirent_array[i].d_length = len;
 
-		len = roundup8(4 + len + 1);
+		/*
+		 * Round 4 + len + 1, which is the encoded size plus the string
+		 * plus the null terminator to the nearest eight byte boundry.
+		 */
+		len = ((4 + len + 1) + 7) & ~7;
 		if (size < len + 16)
 			goto Einval;
 		size -= len + 16;
@@ -109,7 +113,7 @@ static void readdir_handle_dtor(struct orangefs_bufmap *bufmap,
 	rhandle->readdir_response.dirent_array = NULL;
 
 	if (rhandle->buffer_index >= 0) {
-		readdir_index_put(bufmap, rhandle->buffer_index);
+		orangefs_readdir_index_put(bufmap, rhandle->buffer_index);
 		rhandle->buffer_index = -1;
 	}
 	if (rhandle->dents_buf) {
@@ -175,7 +179,8 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 
 	new_op->uses_shared_memory = 1;
 	new_op->upcall.req.readdir.refn = orangefs_inode->refn;
-	new_op->upcall.req.readdir.max_dirent_count = MAX_DIRENT_COUNT_READDIR;
+	new_op->upcall.req.readdir.max_dirent_count =
+	    ORANGEFS_MAX_DIRENT_COUNT_READDIR;
 
 	gossip_debug(GOSSIP_DIR_DEBUG,
 		     "%s: upcall.req.readdir.refn.khandle: %pU\n",
@@ -185,9 +190,9 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 	new_op->upcall.req.readdir.token = *ptoken;
 
 get_new_buffer_index:
-	ret = readdir_index_get(&bufmap, &buffer_index);
+	ret = orangefs_readdir_index_get(&bufmap, &buffer_index);
 	if (ret < 0) {
-		gossip_lerr("orangefs_readdir: readdir_index_get() failure (%d)\n",
+		gossip_lerr("orangefs_readdir: orangefs_readdir_index_get() failure (%d)\n",
 			    ret);
 		goto out_free_op;
 	}
@@ -211,14 +216,14 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 		gossip_debug(GOSSIP_DIR_DEBUG,
 			"%s: Getting new buffer_index for retry of readdir..\n",
 			 __func__);
-		readdir_index_put(bufmap, buffer_index);
+		orangefs_readdir_index_put(bufmap, buffer_index);
 		goto get_new_buffer_index;
 	}
 
 	if (ret == -EIO && op_state_purged(new_op)) {
 		gossip_err("%s: Client is down. Aborting readdir call.\n",
 			__func__);
-		readdir_index_put(bufmap, buffer_index);
+		orangefs_readdir_index_put(bufmap, buffer_index);
 		goto out_free_op;
 	}
 
@@ -226,7 +231,7 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 		gossip_debug(GOSSIP_DIR_DEBUG,
 			     "Readdir request failed.  Status:%d\n",
 			     new_op->downcall.status);
-		readdir_index_put(bufmap, buffer_index);
+		orangefs_readdir_index_put(bufmap, buffer_index);
 		if (ret >= 0)
 			ret = new_op->downcall.status;
 		goto out_free_op;
@@ -241,7 +246,7 @@ static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 		gossip_err("orangefs_readdir: Could not decode trailer buffer into a readdir response %d\n",
 			ret);
 		ret = bytes_decoded;
-		readdir_index_put(bufmap, buffer_index);
+		orangefs_readdir_index_put(bufmap, buffer_index);
 		goto out_free_op;
 	}
 

commit 575e946125f70c41c2042f10172842c5cab9a09a
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Dec 4 12:56:14 2015 -0500

    Orangefs: change pvfs2 filenames to orangefs
    
    Also changed references within source files that referred to
    header files whose names had changed.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index 452d589b9747..c043894fc2bd 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -5,8 +5,8 @@
  */
 
 #include "protocol.h"
-#include "pvfs2-kernel.h"
-#include "pvfs2-bufmap.h"
+#include "orangefs-kernel.h"
+#include "orangefs-bufmap.h"
 
 struct readdir_handle_s {
 	int buffer_index;

commit 8bb8aefd5afb54a25a002feb4ec70011812d06a0
Author: Yi Liu <yi9@clemson.edu>
Date:   Tue Nov 24 15:12:14 2015 -0500

    OrangeFS: Change almost all instances of the string PVFS2 to OrangeFS.
    
    OrangeFS was formerly known as PVFS2 and retains the name in many places.
    
    I leave the device /dev/pvfs2-req since this affects userspace.
    
    I leave the filesystem type pvfs2 since this affects userspace. Further
    the OrangeFS sysint library reads fstab for an entry of type pvfs2
    independently of kernel mounts.
    
    I leave extended attribute keys user.pvfs2 and system.pvfs2 as the
    sysint library understands these.
    
    I leave references to userspace binaries still named pvfs2.
    
    I leave the filenames.
    
    Signed-off-by: Yi Liu <yi9@clemson.edu>
    [martin@omnibond.com: clairify above constraints and merge]
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index 3049cd61b700..452d589b9747 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -10,7 +10,7 @@
 
 struct readdir_handle_s {
 	int buffer_index;
-	struct pvfs2_readdir_response_s readdir_response;
+	struct orangefs_readdir_response_s readdir_response;
 	void *dents_buf;
 };
 
@@ -18,28 +18,28 @@ struct readdir_handle_s {
  * decode routine needed by kmod to make sense of the shared page for readdirs.
  */
 static long decode_dirents(char *ptr, size_t size,
-			   struct pvfs2_readdir_response_s *readdir)
+                           struct orangefs_readdir_response_s *readdir)
 {
 	int i;
-	struct pvfs2_readdir_response_s *rd =
-		(struct pvfs2_readdir_response_s *) ptr;
+	struct orangefs_readdir_response_s *rd =
+		(struct orangefs_readdir_response_s *) ptr;
 	char *buf = ptr;
 
-	if (size < offsetof(struct pvfs2_readdir_response_s, dirent_array))
+	if (size < offsetof(struct orangefs_readdir_response_s, dirent_array))
 		return -EINVAL;
 
 	readdir->token = rd->token;
-	readdir->pvfs_dirent_outcount = rd->pvfs_dirent_outcount;
-	readdir->dirent_array = kcalloc(readdir->pvfs_dirent_outcount,
+	readdir->orangefs_dirent_outcount = rd->orangefs_dirent_outcount;
+	readdir->dirent_array = kcalloc(readdir->orangefs_dirent_outcount,
 					sizeof(*readdir->dirent_array),
 					GFP_KERNEL);
 	if (readdir->dirent_array == NULL)
 		return -ENOMEM;
 
-	buf += offsetof(struct pvfs2_readdir_response_s, dirent_array);
-	size -= offsetof(struct pvfs2_readdir_response_s, dirent_array);
+	buf += offsetof(struct orangefs_readdir_response_s, dirent_array);
+	size -= offsetof(struct orangefs_readdir_response_s, dirent_array);
 
-	for (i = 0; i < readdir->pvfs_dirent_outcount; i++) {
+	for (i = 0; i < readdir->orangefs_dirent_outcount; i++) {
 		__u32 len;
 
 		if (size < 4)
@@ -60,7 +60,7 @@ static long decode_dirents(char *ptr, size_t size,
 		buf += len;
 
 		readdir->dirent_array[i].khandle =
-			*(struct pvfs2_khandle *) buf;
+			*(struct orangefs_khandle *) buf;
 		buf += 16;
 	}
 	return buf - ptr;
@@ -98,7 +98,7 @@ static long readdir_handle_ctor(struct readdir_handle_s *rhandle, void *buf,
 	return ret;
 }
 
-static void readdir_handle_dtor(struct pvfs2_bufmap *bufmap,
+static void readdir_handle_dtor(struct orangefs_bufmap *bufmap,
 		struct readdir_handle_s *rhandle)
 {
 	if (rhandle == NULL)
@@ -123,9 +123,9 @@ static void readdir_handle_dtor(struct pvfs2_bufmap *bufmap,
 /*
  * Read directory entries from an instance of an open directory.
  */
-static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
+static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 {
-	struct pvfs2_bufmap *bufmap = NULL;
+	struct orangefs_bufmap *bufmap = NULL;
 	int ret = 0;
 	int buffer_index;
 	/*
@@ -136,8 +136,8 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 	__u64 pos = 0;
 	ino_t ino = 0;
 	struct dentry *dentry = file->f_path.dentry;
-	struct pvfs2_kernel_op_s *new_op = NULL;
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(dentry->d_inode);
+	struct orangefs_kernel_op_s *new_op = NULL;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(dentry->d_inode);
 	int buffer_full = 0;
 	struct readdir_handle_s rhandle;
 	int i = 0;
@@ -155,26 +155,26 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 	pos = (__u64) ctx->pos;
 
 	/* are we done? */
-	if (pos == PVFS_READDIR_END) {
+	if (pos == ORANGEFS_READDIR_END) {
 		gossip_debug(GOSSIP_DIR_DEBUG,
 			     "Skipping to termination path\n");
 		return 0;
 	}
 
 	gossip_debug(GOSSIP_DIR_DEBUG,
-		     "pvfs2_readdir called on %s (pos=%llu)\n",
+		     "orangefs_readdir called on %s (pos=%llu)\n",
 		     dentry->d_name.name, llu(pos));
 
 	rhandle.buffer_index = -1;
 	rhandle.dents_buf = NULL;
 	memset(&rhandle.readdir_response, 0, sizeof(rhandle.readdir_response));
 
-	new_op = op_alloc(PVFS2_VFS_OP_READDIR);
+	new_op = op_alloc(ORANGEFS_VFS_OP_READDIR);
 	if (!new_op)
 		return -ENOMEM;
 
 	new_op->uses_shared_memory = 1;
-	new_op->upcall.req.readdir.refn = pvfs2_inode->refn;
+	new_op->upcall.req.readdir.refn = orangefs_inode->refn;
 	new_op->upcall.req.readdir.max_dirent_count = MAX_DIRENT_COUNT_READDIR;
 
 	gossip_debug(GOSSIP_DIR_DEBUG,
@@ -187,14 +187,14 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 get_new_buffer_index:
 	ret = readdir_index_get(&bufmap, &buffer_index);
 	if (ret < 0) {
-		gossip_lerr("pvfs2_readdir: readdir_index_get() failure (%d)\n",
+		gossip_lerr("orangefs_readdir: readdir_index_get() failure (%d)\n",
 			    ret);
 		goto out_free_op;
 	}
 	new_op->upcall.req.readdir.buf_index = buffer_index;
 
 	ret = service_operation(new_op,
-				"pvfs2_readdir",
+				"orangefs_readdir",
 				get_interruptible_flag(dentry->d_inode));
 
 	gossip_debug(GOSSIP_DIR_DEBUG,
@@ -238,7 +238,7 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 				    new_op->downcall.trailer_size,
 				    buffer_index);
 	if (bytes_decoded < 0) {
-		gossip_err("pvfs2_readdir: Could not decode trailer buffer into a readdir response %d\n",
+		gossip_err("orangefs_readdir: Could not decode trailer buffer into a readdir response %d\n",
 			ret);
 		ret = bytes_decoded;
 		readdir_index_put(bufmap, buffer_index);
@@ -246,7 +246,7 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 	}
 
 	if (bytes_decoded != new_op->downcall.trailer_size) {
-		gossip_err("pvfs2_readdir: # bytes decoded (%ld) "
+		gossip_err("orangefs_readdir: # bytes decoded (%ld) "
 			   "!= trailer size (%ld)\n",
 			   bytes_decoded,
 			   (long)new_op->downcall.trailer_size);
@@ -255,7 +255,7 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 	}
 
 	/*
-	 *  pvfs2 doesn't actually store dot and dot-dot, but
+	 *  orangefs doesn't actually store dot and dot-dot, but
 	 *  we need to have them represented.
 	 */
 	if (pos == 0) {
@@ -279,19 +279,19 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 	}
 
 	/*
-	 * we stored PVFS_ITERATE_NEXT in ctx->pos last time around
+	 * we stored ORANGEFS_ITERATE_NEXT in ctx->pos last time around
 	 * to prevent "finding" dot and dot-dot on any iteration
 	 * other than the first.
 	 */
-	if (ctx->pos == PVFS_ITERATE_NEXT)
+	if (ctx->pos == ORANGEFS_ITERATE_NEXT)
 		ctx->pos = 0;
 
 	for (i = ctx->pos;
-	     i < rhandle.readdir_response.pvfs_dirent_outcount;
+	     i < rhandle.readdir_response.orangefs_dirent_outcount;
 	     i++) {
 		len = rhandle.readdir_response.dirent_array[i].d_length;
 		current_entry = rhandle.readdir_response.dirent_array[i].d_name;
-		current_ino = pvfs2_khandle_to_ino(
+		current_ino = orangefs_khandle_to_ino(
 			&(rhandle.readdir_response.dirent_array[i].khandle));
 
 		gossip_debug(GOSSIP_DIR_DEBUG,
@@ -323,28 +323,28 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 	 */
 	if (ret) {
 		*ptoken = rhandle.readdir_response.token;
-		ctx->pos = PVFS_ITERATE_NEXT;
+		ctx->pos = ORANGEFS_ITERATE_NEXT;
 	}
 
 	/*
 	 * Did we hit the end of the directory?
 	 */
-	if (rhandle.readdir_response.token == PVFS_READDIR_END &&
+	if (rhandle.readdir_response.token == ORANGEFS_READDIR_END &&
 	    !buffer_full) {
 		gossip_debug(GOSSIP_DIR_DEBUG,
-		"End of dir detected; setting ctx->pos to PVFS_READDIR_END.\n");
-		ctx->pos = PVFS_READDIR_END;
+		"End of dir detected; setting ctx->pos to ORANGEFS_READDIR_END.\n");
+		ctx->pos = ORANGEFS_READDIR_END;
 	}
 
 out_destroy_handle:
 	readdir_handle_dtor(bufmap, &rhandle);
 out_free_op:
 	op_release(new_op);
-	gossip_debug(GOSSIP_DIR_DEBUG, "pvfs2_readdir returning %d\n", ret);
+	gossip_debug(GOSSIP_DIR_DEBUG, "orangefs_readdir returning %d\n", ret);
 	return ret;
 }
 
-static int pvfs2_dir_open(struct inode *inode, struct file *file)
+static int orangefs_dir_open(struct inode *inode, struct file *file)
 {
 	__u64 *ptoken;
 
@@ -353,21 +353,21 @@ static int pvfs2_dir_open(struct inode *inode, struct file *file)
 		return -ENOMEM;
 
 	ptoken = file->private_data;
-	*ptoken = PVFS_READDIR_START;
+	*ptoken = ORANGEFS_READDIR_START;
 	return 0;
 }
 
-static int pvfs2_dir_release(struct inode *inode, struct file *file)
+static int orangefs_dir_release(struct inode *inode, struct file *file)
 {
-	pvfs2_flush_inode(inode);
+	orangefs_flush_inode(inode);
 	kfree(file->private_data);
 	return 0;
 }
 
-/** PVFS2 implementation of VFS directory operations */
-const struct file_operations pvfs2_dir_operations = {
+/** ORANGEFS implementation of VFS directory operations */
+const struct file_operations orangefs_dir_operations = {
 	.read = generic_read_dir,
-	.iterate = pvfs2_readdir,
-	.open = pvfs2_dir_open,
-	.release = pvfs2_dir_release,
+	.iterate = orangefs_readdir,
+	.open = orangefs_dir_open,
+	.release = orangefs_dir_release,
 };

commit 8092895f759ede31634d0f0fc85a74d970552c49
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 9 18:11:10 2015 -0400

    orangefs: validate the response in decode_dirents()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index eb4c3d334088..3049cd61b700 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -17,13 +17,17 @@ struct readdir_handle_s {
 /*
  * decode routine needed by kmod to make sense of the shared page for readdirs.
  */
-static long decode_dirents(char *ptr, struct pvfs2_readdir_response_s *readdir)
+static long decode_dirents(char *ptr, size_t size,
+			   struct pvfs2_readdir_response_s *readdir)
 {
 	int i;
 	struct pvfs2_readdir_response_s *rd =
 		(struct pvfs2_readdir_response_s *) ptr;
 	char *buf = ptr;
 
+	if (size < offsetof(struct pvfs2_readdir_response_s, dirent_array))
+		return -EINVAL;
+
 	readdir->token = rd->token;
 	readdir->pvfs_dirent_outcount = rd->pvfs_dirent_outcount;
 	readdir->dirent_array = kcalloc(readdir->pvfs_dirent_outcount,
@@ -31,21 +35,43 @@ static long decode_dirents(char *ptr, struct pvfs2_readdir_response_s *readdir)
 					GFP_KERNEL);
 	if (readdir->dirent_array == NULL)
 		return -ENOMEM;
+
 	buf += offsetof(struct pvfs2_readdir_response_s, dirent_array);
+	size -= offsetof(struct pvfs2_readdir_response_s, dirent_array);
+
 	for (i = 0; i < readdir->pvfs_dirent_outcount; i++) {
-		__u32 len = *(__u32 *)buf;
+		__u32 len;
+
+		if (size < 4)
+			goto Einval;
+
+		len = *(__u32 *)buf;
+		if (len >= (unsigned)-24)
+			goto Einval;
+
 		readdir->dirent_array[i].d_name = buf + 4;
-		buf += roundup8(4 + len + 1);
 		readdir->dirent_array[i].d_length = len;
+
+		len = roundup8(4 + len + 1);
+		if (size < len + 16)
+			goto Einval;
+		size -= len + 16;
+
+		buf += len;
+
 		readdir->dirent_array[i].khandle =
 			*(struct pvfs2_khandle *) buf;
 		buf += 16;
 	}
 	return buf - ptr;
+Einval:
+	kfree(readdir->dirent_array);
+	readdir->dirent_array = NULL;
+	return -EINVAL;
 }
 
 static long readdir_handle_ctor(struct readdir_handle_s *rhandle, void *buf,
-				int buffer_index)
+				size_t size, int buffer_index)
 {
 	long ret;
 
@@ -61,7 +87,7 @@ static long readdir_handle_ctor(struct readdir_handle_s *rhandle, void *buf,
 	}
 	rhandle->buffer_index = buffer_index;
 	rhandle->dents_buf = buf;
-	ret = decode_dirents(buf, &rhandle->readdir_response);
+	ret = decode_dirents(buf, size, &rhandle->readdir_response);
 	if (ret < 0) {
 		gossip_err("Could not decode readdir from buffer %ld\n", ret);
 		rhandle->buffer_index = -1;
@@ -209,6 +235,7 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 	bytes_decoded =
 		readdir_handle_ctor(&rhandle,
 				    new_op->downcall.trailer_buf,
+				    new_op->downcall.trailer_size,
 				    buffer_index);
 	if (bytes_decoded < 0) {
 		gossip_err("pvfs2_readdir: Could not decode trailer buffer into a readdir response %d\n",

commit 9be68b08719c10cc3cc9305e7b2452475a9dcacd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 9 17:43:15 2015 -0400

    orangefs: get rid of dec_string and enc_string
    
    The latter is never used, the former has one user and would be
    better off spelled out right there.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index 280755db1814..eb4c3d334088 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -23,7 +23,6 @@ static long decode_dirents(char *ptr, struct pvfs2_readdir_response_s *readdir)
 	struct pvfs2_readdir_response_s *rd =
 		(struct pvfs2_readdir_response_s *) ptr;
 	char *buf = ptr;
-	char **pptr = &buf;
 
 	readdir->token = rd->token;
 	readdir->pvfs_dirent_outcount = rd->pvfs_dirent_outcount;
@@ -32,15 +31,17 @@ static long decode_dirents(char *ptr, struct pvfs2_readdir_response_s *readdir)
 					GFP_KERNEL);
 	if (readdir->dirent_array == NULL)
 		return -ENOMEM;
-	*pptr += offsetof(struct pvfs2_readdir_response_s, dirent_array);
+	buf += offsetof(struct pvfs2_readdir_response_s, dirent_array);
 	for (i = 0; i < readdir->pvfs_dirent_outcount; i++) {
-		dec_string(pptr, &readdir->dirent_array[i].d_name,
-			   &readdir->dirent_array[i].d_length);
+		__u32 len = *(__u32 *)buf;
+		readdir->dirent_array[i].d_name = buf + 4;
+		buf += roundup8(4 + len + 1);
+		readdir->dirent_array[i].d_length = len;
 		readdir->dirent_array[i].khandle =
-			*(struct pvfs2_khandle *) *pptr;
-		*pptr += 16;
+			*(struct pvfs2_khandle *) buf;
+		buf += 16;
 	}
-	return (unsigned long)*pptr - (unsigned long)ptr;
+	return buf - ptr;
 }
 
 static long readdir_handle_ctor(struct readdir_handle_s *rhandle, void *buf,

commit ef4af94edcf8fc32ab1d4141537a4eb29ff45a40
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 9 13:23:16 2015 -0400

    orangefs: switch decode_dirents() to use of kcalloc()
    
    gets rid of multiplication overflow
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index daf497384501..280755db1814 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -27,7 +27,7 @@ static long decode_dirents(char *ptr, struct pvfs2_readdir_response_s *readdir)
 
 	readdir->token = rd->token;
 	readdir->pvfs_dirent_outcount = rd->pvfs_dirent_outcount;
-	readdir->dirent_array = kmalloc(readdir->pvfs_dirent_outcount *
+	readdir->dirent_array = kcalloc(readdir->pvfs_dirent_outcount,
 					sizeof(*readdir->dirent_array),
 					GFP_KERNEL);
 	if (readdir->dirent_array == NULL)

commit 548049495cb46348866aec1cb7721e9d00b4eb83
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Mon Oct 5 13:44:24 2015 -0400

    Orangefs: fix some checkpatch.pl complaints that had creeped in.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index 3870e78f5ecf..daf497384501 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -289,7 +289,7 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 
 	}
 
-	/* 
+	/*
 	 * we ran all the way through the last batch, set up for
 	 * getting another batch...
 	 */

commit 88309aae3ddb62e6d02a8f1002a4f4fc41b423ad
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Sep 23 16:48:40 2015 -0400

    Orangefs: fix dir_emit code in pvfs2_readdir.
    
    Al Viro glanced at readdir and surmised that getdents
    would misbehave the way it was written... and sure enough.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index c126c0fc6e0f..3870e78f5ecf 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -95,26 +95,16 @@ static void readdir_handle_dtor(struct pvfs2_bufmap *bufmap,
 
 /*
  * Read directory entries from an instance of an open directory.
- *
- * \note This routine was converted for the readdir to iterate change
- *       in "struct file_operations". "converted" mostly amounts to
- *       changing occurrences of "readdir" and "filldir" in the
- *       comments to "iterate" and "dir_emit". Also filldir calls
- *       were changed to dir_emit calls.
- *
- * \param dir_emit callback function called for each entry read.
- *
- * \retval 0  when directory has been completely traversed
- * \retval >0 if we don't call dir_emit for all entries
- *
- * \note If the dir_emit call-back returns non-zero, then iterate should
- *       assume that it has had enough, and should return as well.
  */
 static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 {
 	struct pvfs2_bufmap *bufmap = NULL;
 	int ret = 0;
 	int buffer_index;
+	/*
+	 * ptoken supports Orangefs' distributed directory logic, added
+	 * in 2.9.2.
+	 */
 	__u64 *ptoken = file->private_data;
 	__u64 pos = 0;
 	ino_t ino = 0;
@@ -129,11 +119,11 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 	char *current_entry = NULL;
 	long bytes_decoded;
 
-	gossip_ldebug(GOSSIP_DIR_DEBUG,
-		      "%s: ctx->pos:%lld, token = %llu\n",
-		      __func__,
-		      lld(ctx->pos),
-		      llu(*ptoken));
+	gossip_debug(GOSSIP_DIR_DEBUG,
+		     "%s: ctx->pos:%lld, ptoken = %llu\n",
+		     __func__,
+		     lld(ctx->pos),
+		     llu(*ptoken));
 
 	pos = (__u64) ctx->pos;
 
@@ -165,16 +155,6 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 		     __func__,
 		     &new_op->upcall.req.readdir.refn.khandle);
 
-	/*
-	 * NOTE: the position we send to the readdir upcall is out of
-	 * sync with ctx->pos since:
-	 * 1. pvfs2 doesn't include the "." and ".." entries that are
-	 *    added below.
-	 * 2. the introduction of distributed directory logic makes token no
-	 *    longer be related to f_pos and pos. Instead an independent
-	 *    variable is used inside the function and stored in the
-	 *    private_data of the file structure.
-	 */
 	new_op->upcall.req.readdir.token = *ptoken;
 
 get_new_buffer_index:
@@ -238,13 +218,18 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 	}
 
 	if (bytes_decoded != new_op->downcall.trailer_size) {
-		gossip_err("pvfs2_readdir: # bytes decoded (%ld) != trailer size (%ld)\n",
-			bytes_decoded,
-			(long)new_op->downcall.trailer_size);
+		gossip_err("pvfs2_readdir: # bytes decoded (%ld) "
+			   "!= trailer size (%ld)\n",
+			   bytes_decoded,
+			   (long)new_op->downcall.trailer_size);
 		ret = -EINVAL;
 		goto out_destroy_handle;
 	}
 
+	/*
+	 *  pvfs2 doesn't actually store dot and dot-dot, but
+	 *  we need to have them represented.
+	 */
 	if (pos == 0) {
 		ino = get_ino_from_khandle(dentry->d_inode);
 		gossip_debug(GOSSIP_DIR_DEBUG,
@@ -252,12 +237,7 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 			     __func__,
 			     llu(pos));
 		ret = dir_emit(ctx, ".", 1, ino, DT_DIR);
-		ctx->pos++;
-		gossip_ldebug(GOSSIP_DIR_DEBUG,
-			      "%s: ctx->pos:%lld\n",
-			      __func__,
-			      lld(ctx->pos));
-		pos++;
+		pos += 1;
 	}
 
 	if (pos == 1) {
@@ -267,62 +247,55 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 			     __func__,
 			     llu(pos));
 		ret = dir_emit(ctx, "..", 2, ino, DT_DIR);
-		ctx->pos++;
-		gossip_ldebug(GOSSIP_DIR_DEBUG,
-			      "%s: ctx->pos:%lld\n",
-			      __func__,
-			      lld(ctx->pos));
-		pos++;
+		pos += 1;
 	}
 
-	for (i = 0; i < rhandle.readdir_response.pvfs_dirent_outcount; i++) {
+	/*
+	 * we stored PVFS_ITERATE_NEXT in ctx->pos last time around
+	 * to prevent "finding" dot and dot-dot on any iteration
+	 * other than the first.
+	 */
+	if (ctx->pos == PVFS_ITERATE_NEXT)
+		ctx->pos = 0;
+
+	for (i = ctx->pos;
+	     i < rhandle.readdir_response.pvfs_dirent_outcount;
+	     i++) {
 		len = rhandle.readdir_response.dirent_array[i].d_length;
 		current_entry = rhandle.readdir_response.dirent_array[i].d_name;
 		current_ino = pvfs2_khandle_to_ino(
 			&(rhandle.readdir_response.dirent_array[i].khandle));
 
 		gossip_debug(GOSSIP_DIR_DEBUG,
-			     "calling dir_emit for %s with len %d, pos %ld\n",
+			     "calling dir_emit for %s with len %d"
+			     ", ctx->pos %ld\n",
 			     current_entry,
 			     len,
-			     (unsigned long)pos);
+			     (unsigned long)ctx->pos);
+		/*
+		 * type is unknown. We don't return object type
+		 * in the dirent_array. This leaves getdents
+		 * clueless about type.
+		 */
 		ret =
 		    dir_emit(ctx, current_entry, len, current_ino, DT_UNKNOWN);
+		if (!ret)
+			break;
 		ctx->pos++;
-		gossip_ldebug(GOSSIP_DIR_DEBUG,
+		gossip_debug(GOSSIP_DIR_DEBUG,
 			      "%s: ctx->pos:%lld\n",
 			      __func__,
 			      lld(ctx->pos));
 
-		pos++;
 	}
 
-	/* this means that all of the dir_emit calls succeeded */
-	if (i == rhandle.readdir_response.pvfs_dirent_outcount) {
-		/* update token */
+	/* 
+	 * we ran all the way through the last batch, set up for
+	 * getting another batch...
+	 */
+	if (ret) {
 		*ptoken = rhandle.readdir_response.token;
-	} else {
-		/* this means a dir_emit call failed */
-		if (rhandle.readdir_response.token == PVFS_READDIR_END) {
-			/*
-			 * If PVFS hit end of directory, then there
-			 * is no way to do math on the token that it
-			 * returned. Instead we go by ctx->pos but
-			 * back up to account for the artificial .
-			 * and .. entries.
-			 */
-			ctx->pos -= 3;
-		} else {
-			/*
-			 * this means a dir_emit call failed. !!! need to set
-			 * back to previous ctx->pos, no middle value allowed
-			 */
-			pos -= (i - 1);
-			ctx->pos -= (i - 1);
-		}
-		gossip_debug(GOSSIP_DIR_DEBUG,
-			"at least one dir_emit call failed. Setting ctx->pos to: %lld\n",
-			lld(ctx->pos));
+		ctx->pos = PVFS_ITERATE_NEXT;
 	}
 
 	/*
@@ -330,17 +303,11 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 	 */
 	if (rhandle.readdir_response.token == PVFS_READDIR_END &&
 	    !buffer_full) {
-		gossip_debug(GOSSIP_DIR_DEBUG, "End of dir detected; setting ctx->pos to PVFS_READDIR_END.\n");
+		gossip_debug(GOSSIP_DIR_DEBUG,
+		"End of dir detected; setting ctx->pos to PVFS_READDIR_END.\n");
 		ctx->pos = PVFS_READDIR_END;
 	}
 
-	gossip_debug(GOSSIP_DIR_DEBUG,
-		     "pos = %llu, token = %llu"
-		     ", ctx->pos should have been %lld\n",
-		     llu(pos),
-		     llu(*ptoken),
-		     lld(ctx->pos));
-
 out_destroy_handle:
 	readdir_handle_dtor(bufmap, &rhandle);
 out_free_op:

commit eeaa3d448c5d35ad0dc16a981aacd64139c53eee
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Jul 29 13:36:37 2015 -0400

    Orangefs: address problems found by static checker
    
      Don't check for negative rc from boolean.
    
      Don't pointlessly initialize variables, it short-circuits
      gcc's uninitialized variable warnings. And max_new_nr_segs
      can never be zero, so don't check for it.
    
      Preserve original kstrdup pointer for freeing later.
    
      Don't check for negative value in unsigned variable.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index 9b5f4bb17874..c126c0fc6e0f 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -104,7 +104,6 @@ static void readdir_handle_dtor(struct pvfs2_bufmap *bufmap,
  *
  * \param dir_emit callback function called for each entry read.
  *
- * \retval <0 on error
  * \retval 0  when directory has been completely traversed
  * \retval >0 if we don't call dir_emit for all entries
  *
@@ -253,8 +252,6 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 			     __func__,
 			     llu(pos));
 		ret = dir_emit(ctx, ".", 1, ino, DT_DIR);
-		if (ret < 0)
-			goto out_destroy_handle;
 		ctx->pos++;
 		gossip_ldebug(GOSSIP_DIR_DEBUG,
 			      "%s: ctx->pos:%lld\n",
@@ -270,8 +267,6 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 			     __func__,
 			     llu(pos));
 		ret = dir_emit(ctx, "..", 2, ino, DT_DIR);
-		if (ret < 0)
-			goto out_destroy_handle;
 		ctx->pos++;
 		gossip_ldebug(GOSSIP_DIR_DEBUG,
 			      "%s: ctx->pos:%lld\n",
@@ -293,17 +288,6 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 			     (unsigned long)pos);
 		ret =
 		    dir_emit(ctx, current_entry, len, current_ino, DT_UNKNOWN);
-		if (ret < 0) {
-			gossip_debug(GOSSIP_DIR_DEBUG,
-				     "dir_emit() failed. ret:%d\n",
-				     ret);
-			if (i < 2) {
-				gossip_err("dir_emit failed on one of the first two true PVFS directory entries.\n");
-				gossip_err("Duplicate entries may appear.\n");
-			}
-			buffer_full = 1;
-			break;
-		}
 		ctx->pos++;
 		gossip_ldebug(GOSSIP_DIR_DEBUG,
 			      "%s: ctx->pos:%lld\n",

commit 5db11c21a929cd9d8c0484006efb1014fc723c93
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Jul 17 10:38:12 2015 -0400

    Orangefs: kernel client part 2
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
new file mode 100644
index 000000000000..9b5f4bb17874
--- /dev/null
+++ b/fs/orangefs/dir.c
@@ -0,0 +1,394 @@
+/*
+ * (C) 2001 Clemson University and The University of Chicago
+ *
+ * See COPYING in top-level directory.
+ */
+
+#include "protocol.h"
+#include "pvfs2-kernel.h"
+#include "pvfs2-bufmap.h"
+
+struct readdir_handle_s {
+	int buffer_index;
+	struct pvfs2_readdir_response_s readdir_response;
+	void *dents_buf;
+};
+
+/*
+ * decode routine needed by kmod to make sense of the shared page for readdirs.
+ */
+static long decode_dirents(char *ptr, struct pvfs2_readdir_response_s *readdir)
+{
+	int i;
+	struct pvfs2_readdir_response_s *rd =
+		(struct pvfs2_readdir_response_s *) ptr;
+	char *buf = ptr;
+	char **pptr = &buf;
+
+	readdir->token = rd->token;
+	readdir->pvfs_dirent_outcount = rd->pvfs_dirent_outcount;
+	readdir->dirent_array = kmalloc(readdir->pvfs_dirent_outcount *
+					sizeof(*readdir->dirent_array),
+					GFP_KERNEL);
+	if (readdir->dirent_array == NULL)
+		return -ENOMEM;
+	*pptr += offsetof(struct pvfs2_readdir_response_s, dirent_array);
+	for (i = 0; i < readdir->pvfs_dirent_outcount; i++) {
+		dec_string(pptr, &readdir->dirent_array[i].d_name,
+			   &readdir->dirent_array[i].d_length);
+		readdir->dirent_array[i].khandle =
+			*(struct pvfs2_khandle *) *pptr;
+		*pptr += 16;
+	}
+	return (unsigned long)*pptr - (unsigned long)ptr;
+}
+
+static long readdir_handle_ctor(struct readdir_handle_s *rhandle, void *buf,
+				int buffer_index)
+{
+	long ret;
+
+	if (buf == NULL) {
+		gossip_err
+		    ("Invalid NULL buffer specified in readdir_handle_ctor\n");
+		return -ENOMEM;
+	}
+	if (buffer_index < 0) {
+		gossip_err
+		    ("Invalid buffer index specified in readdir_handle_ctor\n");
+		return -EINVAL;
+	}
+	rhandle->buffer_index = buffer_index;
+	rhandle->dents_buf = buf;
+	ret = decode_dirents(buf, &rhandle->readdir_response);
+	if (ret < 0) {
+		gossip_err("Could not decode readdir from buffer %ld\n", ret);
+		rhandle->buffer_index = -1;
+		gossip_debug(GOSSIP_DIR_DEBUG, "vfree %p\n", buf);
+		vfree(buf);
+		rhandle->dents_buf = NULL;
+	}
+	return ret;
+}
+
+static void readdir_handle_dtor(struct pvfs2_bufmap *bufmap,
+		struct readdir_handle_s *rhandle)
+{
+	if (rhandle == NULL)
+		return;
+
+	/* kfree(NULL) is safe */
+	kfree(rhandle->readdir_response.dirent_array);
+	rhandle->readdir_response.dirent_array = NULL;
+
+	if (rhandle->buffer_index >= 0) {
+		readdir_index_put(bufmap, rhandle->buffer_index);
+		rhandle->buffer_index = -1;
+	}
+	if (rhandle->dents_buf) {
+		gossip_debug(GOSSIP_DIR_DEBUG, "vfree %p\n",
+			     rhandle->dents_buf);
+		vfree(rhandle->dents_buf);
+		rhandle->dents_buf = NULL;
+	}
+}
+
+/*
+ * Read directory entries from an instance of an open directory.
+ *
+ * \note This routine was converted for the readdir to iterate change
+ *       in "struct file_operations". "converted" mostly amounts to
+ *       changing occurrences of "readdir" and "filldir" in the
+ *       comments to "iterate" and "dir_emit". Also filldir calls
+ *       were changed to dir_emit calls.
+ *
+ * \param dir_emit callback function called for each entry read.
+ *
+ * \retval <0 on error
+ * \retval 0  when directory has been completely traversed
+ * \retval >0 if we don't call dir_emit for all entries
+ *
+ * \note If the dir_emit call-back returns non-zero, then iterate should
+ *       assume that it has had enough, and should return as well.
+ */
+static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
+{
+	struct pvfs2_bufmap *bufmap = NULL;
+	int ret = 0;
+	int buffer_index;
+	__u64 *ptoken = file->private_data;
+	__u64 pos = 0;
+	ino_t ino = 0;
+	struct dentry *dentry = file->f_path.dentry;
+	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(dentry->d_inode);
+	int buffer_full = 0;
+	struct readdir_handle_s rhandle;
+	int i = 0;
+	int len = 0;
+	ino_t current_ino = 0;
+	char *current_entry = NULL;
+	long bytes_decoded;
+
+	gossip_ldebug(GOSSIP_DIR_DEBUG,
+		      "%s: ctx->pos:%lld, token = %llu\n",
+		      __func__,
+		      lld(ctx->pos),
+		      llu(*ptoken));
+
+	pos = (__u64) ctx->pos;
+
+	/* are we done? */
+	if (pos == PVFS_READDIR_END) {
+		gossip_debug(GOSSIP_DIR_DEBUG,
+			     "Skipping to termination path\n");
+		return 0;
+	}
+
+	gossip_debug(GOSSIP_DIR_DEBUG,
+		     "pvfs2_readdir called on %s (pos=%llu)\n",
+		     dentry->d_name.name, llu(pos));
+
+	rhandle.buffer_index = -1;
+	rhandle.dents_buf = NULL;
+	memset(&rhandle.readdir_response, 0, sizeof(rhandle.readdir_response));
+
+	new_op = op_alloc(PVFS2_VFS_OP_READDIR);
+	if (!new_op)
+		return -ENOMEM;
+
+	new_op->uses_shared_memory = 1;
+	new_op->upcall.req.readdir.refn = pvfs2_inode->refn;
+	new_op->upcall.req.readdir.max_dirent_count = MAX_DIRENT_COUNT_READDIR;
+
+	gossip_debug(GOSSIP_DIR_DEBUG,
+		     "%s: upcall.req.readdir.refn.khandle: %pU\n",
+		     __func__,
+		     &new_op->upcall.req.readdir.refn.khandle);
+
+	/*
+	 * NOTE: the position we send to the readdir upcall is out of
+	 * sync with ctx->pos since:
+	 * 1. pvfs2 doesn't include the "." and ".." entries that are
+	 *    added below.
+	 * 2. the introduction of distributed directory logic makes token no
+	 *    longer be related to f_pos and pos. Instead an independent
+	 *    variable is used inside the function and stored in the
+	 *    private_data of the file structure.
+	 */
+	new_op->upcall.req.readdir.token = *ptoken;
+
+get_new_buffer_index:
+	ret = readdir_index_get(&bufmap, &buffer_index);
+	if (ret < 0) {
+		gossip_lerr("pvfs2_readdir: readdir_index_get() failure (%d)\n",
+			    ret);
+		goto out_free_op;
+	}
+	new_op->upcall.req.readdir.buf_index = buffer_index;
+
+	ret = service_operation(new_op,
+				"pvfs2_readdir",
+				get_interruptible_flag(dentry->d_inode));
+
+	gossip_debug(GOSSIP_DIR_DEBUG,
+		     "Readdir downcall status is %d.  ret:%d\n",
+		     new_op->downcall.status,
+		     ret);
+
+	if (ret == -EAGAIN && op_state_purged(new_op)) {
+		/*
+		 * readdir shared memory aread has been wiped due to
+		 * pvfs2-client-core restarting, so we must get a new
+		 * index into the shared memory.
+		 */
+		gossip_debug(GOSSIP_DIR_DEBUG,
+			"%s: Getting new buffer_index for retry of readdir..\n",
+			 __func__);
+		readdir_index_put(bufmap, buffer_index);
+		goto get_new_buffer_index;
+	}
+
+	if (ret == -EIO && op_state_purged(new_op)) {
+		gossip_err("%s: Client is down. Aborting readdir call.\n",
+			__func__);
+		readdir_index_put(bufmap, buffer_index);
+		goto out_free_op;
+	}
+
+	if (ret < 0 || new_op->downcall.status != 0) {
+		gossip_debug(GOSSIP_DIR_DEBUG,
+			     "Readdir request failed.  Status:%d\n",
+			     new_op->downcall.status);
+		readdir_index_put(bufmap, buffer_index);
+		if (ret >= 0)
+			ret = new_op->downcall.status;
+		goto out_free_op;
+	}
+
+	bytes_decoded =
+		readdir_handle_ctor(&rhandle,
+				    new_op->downcall.trailer_buf,
+				    buffer_index);
+	if (bytes_decoded < 0) {
+		gossip_err("pvfs2_readdir: Could not decode trailer buffer into a readdir response %d\n",
+			ret);
+		ret = bytes_decoded;
+		readdir_index_put(bufmap, buffer_index);
+		goto out_free_op;
+	}
+
+	if (bytes_decoded != new_op->downcall.trailer_size) {
+		gossip_err("pvfs2_readdir: # bytes decoded (%ld) != trailer size (%ld)\n",
+			bytes_decoded,
+			(long)new_op->downcall.trailer_size);
+		ret = -EINVAL;
+		goto out_destroy_handle;
+	}
+
+	if (pos == 0) {
+		ino = get_ino_from_khandle(dentry->d_inode);
+		gossip_debug(GOSSIP_DIR_DEBUG,
+			     "%s: calling dir_emit of \".\" with pos = %llu\n",
+			     __func__,
+			     llu(pos));
+		ret = dir_emit(ctx, ".", 1, ino, DT_DIR);
+		if (ret < 0)
+			goto out_destroy_handle;
+		ctx->pos++;
+		gossip_ldebug(GOSSIP_DIR_DEBUG,
+			      "%s: ctx->pos:%lld\n",
+			      __func__,
+			      lld(ctx->pos));
+		pos++;
+	}
+
+	if (pos == 1) {
+		ino = get_parent_ino_from_dentry(dentry);
+		gossip_debug(GOSSIP_DIR_DEBUG,
+			     "%s: calling dir_emit of \"..\" with pos = %llu\n",
+			     __func__,
+			     llu(pos));
+		ret = dir_emit(ctx, "..", 2, ino, DT_DIR);
+		if (ret < 0)
+			goto out_destroy_handle;
+		ctx->pos++;
+		gossip_ldebug(GOSSIP_DIR_DEBUG,
+			      "%s: ctx->pos:%lld\n",
+			      __func__,
+			      lld(ctx->pos));
+		pos++;
+	}
+
+	for (i = 0; i < rhandle.readdir_response.pvfs_dirent_outcount; i++) {
+		len = rhandle.readdir_response.dirent_array[i].d_length;
+		current_entry = rhandle.readdir_response.dirent_array[i].d_name;
+		current_ino = pvfs2_khandle_to_ino(
+			&(rhandle.readdir_response.dirent_array[i].khandle));
+
+		gossip_debug(GOSSIP_DIR_DEBUG,
+			     "calling dir_emit for %s with len %d, pos %ld\n",
+			     current_entry,
+			     len,
+			     (unsigned long)pos);
+		ret =
+		    dir_emit(ctx, current_entry, len, current_ino, DT_UNKNOWN);
+		if (ret < 0) {
+			gossip_debug(GOSSIP_DIR_DEBUG,
+				     "dir_emit() failed. ret:%d\n",
+				     ret);
+			if (i < 2) {
+				gossip_err("dir_emit failed on one of the first two true PVFS directory entries.\n");
+				gossip_err("Duplicate entries may appear.\n");
+			}
+			buffer_full = 1;
+			break;
+		}
+		ctx->pos++;
+		gossip_ldebug(GOSSIP_DIR_DEBUG,
+			      "%s: ctx->pos:%lld\n",
+			      __func__,
+			      lld(ctx->pos));
+
+		pos++;
+	}
+
+	/* this means that all of the dir_emit calls succeeded */
+	if (i == rhandle.readdir_response.pvfs_dirent_outcount) {
+		/* update token */
+		*ptoken = rhandle.readdir_response.token;
+	} else {
+		/* this means a dir_emit call failed */
+		if (rhandle.readdir_response.token == PVFS_READDIR_END) {
+			/*
+			 * If PVFS hit end of directory, then there
+			 * is no way to do math on the token that it
+			 * returned. Instead we go by ctx->pos but
+			 * back up to account for the artificial .
+			 * and .. entries.
+			 */
+			ctx->pos -= 3;
+		} else {
+			/*
+			 * this means a dir_emit call failed. !!! need to set
+			 * back to previous ctx->pos, no middle value allowed
+			 */
+			pos -= (i - 1);
+			ctx->pos -= (i - 1);
+		}
+		gossip_debug(GOSSIP_DIR_DEBUG,
+			"at least one dir_emit call failed. Setting ctx->pos to: %lld\n",
+			lld(ctx->pos));
+	}
+
+	/*
+	 * Did we hit the end of the directory?
+	 */
+	if (rhandle.readdir_response.token == PVFS_READDIR_END &&
+	    !buffer_full) {
+		gossip_debug(GOSSIP_DIR_DEBUG, "End of dir detected; setting ctx->pos to PVFS_READDIR_END.\n");
+		ctx->pos = PVFS_READDIR_END;
+	}
+
+	gossip_debug(GOSSIP_DIR_DEBUG,
+		     "pos = %llu, token = %llu"
+		     ", ctx->pos should have been %lld\n",
+		     llu(pos),
+		     llu(*ptoken),
+		     lld(ctx->pos));
+
+out_destroy_handle:
+	readdir_handle_dtor(bufmap, &rhandle);
+out_free_op:
+	op_release(new_op);
+	gossip_debug(GOSSIP_DIR_DEBUG, "pvfs2_readdir returning %d\n", ret);
+	return ret;
+}
+
+static int pvfs2_dir_open(struct inode *inode, struct file *file)
+{
+	__u64 *ptoken;
+
+	file->private_data = kmalloc(sizeof(__u64), GFP_KERNEL);
+	if (!file->private_data)
+		return -ENOMEM;
+
+	ptoken = file->private_data;
+	*ptoken = PVFS_READDIR_START;
+	return 0;
+}
+
+static int pvfs2_dir_release(struct inode *inode, struct file *file)
+{
+	pvfs2_flush_inode(inode);
+	kfree(file->private_data);
+	return 0;
+}
+
+/** PVFS2 implementation of VFS directory operations */
+const struct file_operations pvfs2_dir_operations = {
+	.read = generic_read_dir,
+	.iterate = pvfs2_readdir,
+	.open = pvfs2_dir_open,
+	.release = pvfs2_dir_release,
+};
