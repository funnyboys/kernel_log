commit 0e393a9a8f2a450862964451715d68e9a96a9c34
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Apr 8 09:05:45 2020 -0400

    orangefs: don't mess with I_DIRTY_TIMES in orangefs_flush
    
    Christoph Hellwig noticed that we were doing some unnecessary
    work in orangefs_flush:
    
      orangefs_flush just writes out data on every close(2) call.  There is
      no need to change anything about the dirty state, especially as
      orangefs doesn't treat I_DIRTY_TIMES special in any way.  The code
      seems to come from partially open coding vfs_fsync.
    
    He sent in a patch with the above commit message and also a
    patch that was a reversion of another Orangefs patch I had
    sent upstream a while ago. I had to fix his reversion patch
    so that it would compile which caused his "don't mess with
    I_DIRTY_TIMES" patch to fail to apply. So here I have just
    remade his patch and applied it after the fixed reversion patch.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 173e6ea57a47..af375e049aae 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -645,16 +645,8 @@ static int orangefs_flush(struct file *file, fl_owner_t id)
 	 * on an explicit fsync call.  This duplicates historical OrangeFS
 	 * behavior.
 	 */
-	struct inode *inode = file->f_mapping->host;
 	int r;
 
-	if (inode->i_state & I_DIRTY_TIME) {
-		spin_lock(&inode->i_lock);
-		inode->i_state &= ~I_DIRTY_TIME;
-		spin_unlock(&inode->i_lock);
-		mark_inode_dirty_sync(inode);
-	}
-
 	r = filemap_write_and_wait_range(file->f_mapping, 0, LLONG_MAX);
 	if (r > 0)
 		return 0;

commit ec95f1dedc9c64ac5a8b0bdb7c276936c70fdedd
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Apr 8 08:52:40 2020 -0400

    orangefs: get rid of knob code...
    
    Christoph Hellwig sent in a reversion of "orangefs: remember count
    when reading." because:
    
      ->read_iter calls can race with each other and one or
      more ->flush calls. Remove the the scheme to store the read
      count in the file private data as is is completely racy and
      can cause use after free or double free conditions
    
    Christoph's reversion caused Orangefs not to work or to compile. I
    added a patch that fixed that, but intel's kbuild test robot pointed
    out that sending Christoph's patch followed by my patch upstream, it
    would break bisection because of the failure to compile. So I have
    combined the reversion plus my patch... here's the commit message
    that was in my patch:
    
      Logically, optimal Orangefs "pages" are 4 megabytes. Reading
      large Orangefs files 4096 bytes at a time is like trying to
      kick a dead whale down the beach. Before Christoph's "Revert
      orangefs: remember count when reading." I tried to give users
      a knob whereby they could, for example, use "count" in
      read(2) or bs with dd(1) to get whatever they considered an
      appropriate amount of bytes at a time from Orangefs and fill
      as many page cache pages as they could at once.
    
      Without the racy code that Christoph reverted Orangefs won't
      even compile, much less work. So this replaces the logic that
      used the private file data that Christoph reverted with
      a static number of bytes to read from Orangefs.
    
      I ran tests like the following to determine what a
      reasonable static number of bytes might be:
    
      dd if=/pvfsmnt/asdf of=/dev/null count=128 bs=4194304
      dd if=/pvfsmnt/asdf of=/dev/null count=256 bs=2097152
      dd if=/pvfsmnt/asdf of=/dev/null count=512 bs=1048576
                                .
                                .
                                .
      dd if=/pvfsmnt/asdf of=/dev/null count=4194304 bs=128
    
      Reads seem faster using the static number, so my "knob code"
      wasn't just racy, it wasn't even a good idea...
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>
    Reported-by: kbuild test robot <lkp@intel.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index c740159d9ad1..173e6ea57a47 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -346,23 +346,8 @@ static ssize_t orangefs_file_read_iter(struct kiocb *iocb,
     struct iov_iter *iter)
 {
 	int ret;
-	struct orangefs_read_options *ro;
-
 	orangefs_stats.reads++;
 
-	/*
-	 * Remember how they set "count" in read(2) or pread(2) or whatever -
-	 * users can use count as a knob to control orangefs io size and later
-	 * we can try to help them fill as many pages as possible in readpage.
-	 */
-	if (!iocb->ki_filp->private_data) {
-		iocb->ki_filp->private_data = kmalloc(sizeof *ro, GFP_KERNEL);
-		if (!iocb->ki_filp->private_data)
-			return(ENOMEM);
-		ro = iocb->ki_filp->private_data;
-		ro->blksiz = iter->count;
-	}
-
 	down_read(&file_inode(iocb->ki_filp)->i_rwsem);
 	ret = orangefs_revalidate_mapping(file_inode(iocb->ki_filp));
 	if (ret)
@@ -650,12 +635,6 @@ static int orangefs_lock(struct file *filp, int cmd, struct file_lock *fl)
 	return rc;
 }
 
-static int orangefs_file_open(struct inode * inode, struct file *file)
-{
-	file->private_data = NULL;
-	return generic_file_open(inode, file);
-}
-
 static int orangefs_flush(struct file *file, fl_owner_t id)
 {
 	/*
@@ -669,9 +648,6 @@ static int orangefs_flush(struct file *file, fl_owner_t id)
 	struct inode *inode = file->f_mapping->host;
 	int r;
 
-	kfree(file->private_data);
-	file->private_data = NULL;
-
 	if (inode->i_state & I_DIRTY_TIME) {
 		spin_lock(&inode->i_lock);
 		inode->i_state &= ~I_DIRTY_TIME;
@@ -694,7 +670,7 @@ const struct file_operations orangefs_file_operations = {
 	.lock		= orangefs_lock,
 	.unlocked_ioctl	= orangefs_ioctl,
 	.mmap		= orangefs_file_mmap,
-	.open		= orangefs_file_open,
+	.open		= generic_file_open,
 	.flush		= orangefs_flush,
 	.release	= orangefs_file_release,
 	.fsync		= orangefs_fsync,

commit f9bbb68233aa5bd5ef238bd3532fddf92fa1b53c
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Tue Nov 26 12:39:37 2019 -0500

    orangefs: posix open permission checking...
    
    Orangefs has no open, and orangefs checks file permissions
    on each file access. Posix requires that file permissions
    be checked on open and nowhere else. Orangefs-through-the-kernel
    needs to seem posix compliant.
    
    The VFS opens files, even if the filesystem provides no
    method. We can see if a file was successfully opened for
    read and or for write by looking at file->f_mode.
    
    When writes are flowing from the page cache, file is no
    longer available. We can trust the VFS to have checked
    file->f_mode before writing to the page cache.
    
    The mode of a file might change between when it is opened
    and IO commences, or it might be created with an arbitrary mode.
    
    We'll make sure we don't hit EACCES during the IO stage by
    using UID 0. Some of the time we have access without changing
    to UID 0 - how to check?
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index a5612abc0936..c740159d9ad1 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -46,8 +46,9 @@ static int flush_racache(struct inode *inode)
  * Post and wait for the I/O upcall to finish
  */
 ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
-    loff_t *offset, struct iov_iter *iter, size_t total_size,
-    loff_t readahead_size, struct orangefs_write_range *wr, int *index_return)
+	loff_t *offset, struct iov_iter *iter, size_t total_size,
+	loff_t readahead_size, struct orangefs_write_range *wr,
+	int *index_return, struct file *file)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_khandle *handle = &orangefs_inode->refn.khandle;
@@ -55,6 +56,8 @@ ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
 	int buffer_index;
 	ssize_t ret;
 	size_t copy_amount;
+	int open_for_read;
+	int open_for_write;
 
 	new_op = op_alloc(ORANGEFS_VFS_OP_FILE_IO);
 	if (!new_op)
@@ -90,6 +93,38 @@ ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
 		new_op->upcall.uid = from_kuid(&init_user_ns, wr->uid);
 		new_op->upcall.gid = from_kgid(&init_user_ns, wr->gid);
 	}
+	/*
+	 * Orangefs has no open, and orangefs checks file permissions
+	 * on each file access. Posix requires that file permissions
+	 * be checked on open and nowhere else. Orangefs-through-the-kernel
+	 * needs to seem posix compliant.
+	 *
+	 * The VFS opens files, even if the filesystem provides no
+	 * method. We can see if a file was successfully opened for
+	 * read and or for write by looking at file->f_mode.
+	 *
+	 * When writes are flowing from the page cache, file is no
+	 * longer available. We can trust the VFS to have checked
+	 * file->f_mode before writing to the page cache.
+	 *
+	 * The mode of a file might change between when it is opened
+	 * and IO commences, or it might be created with an arbitrary mode.
+	 *
+	 * We'll make sure we don't hit EACCES during the IO stage by
+	 * using UID 0. Some of the time we have access without changing
+	 * to UID 0 - how to check?
+	 */
+	if (file) {
+		open_for_write = file->f_mode & FMODE_WRITE;
+		open_for_read = file->f_mode & FMODE_READ;
+	} else {
+		open_for_write = 1;
+		open_for_read = 0; /* not relevant? */
+	}
+	if ((type == ORANGEFS_IO_WRITE) && open_for_write)
+		new_op->upcall.uid = 0;
+	if ((type == ORANGEFS_IO_READ) && open_for_read)
+		new_op->upcall.uid = 0;
 
 	gossip_debug(GOSSIP_FILE_DEBUG,
 		     "%s(%pU): offset: %llu total_size: %zd\n",

commit ec23eb54fbc7a07405d416d77e8115e575ce3adc
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Fri Jul 26 09:51:27 2019 -0300

    docs: fs: convert docs without extension to ReST
    
    There are 3 remaining files without an extension inside the fs docs
    dir.
    
    Manually convert them to ReST.
    
    In the case of the nfs/exporting.rst file, as the nfs docs
    aren't ported yet, I opted to convert and add a :orphan: there,
    with should be removed when it gets added into a nfs-specific
    part of the fs documentation.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 960f9a3c012d..a5612abc0936 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -555,7 +555,7 @@ static int orangefs_fsync(struct file *file,
  * Change the file pointer position for an instance of an open file.
  *
  * \note If .llseek is overriden, we must acquire lock as described in
- *       Documentation/filesystems/Locking.
+ *       Documentation/filesystems/locking.rst.
  *
  * Future upgrade could support SEEK_DATA and SEEK_HOLE but would
  * require much changes to the FS

commit 0a8ad0ffa4d80a544f6cbff703bf6394339afcdf
Merge: a18f8775419d e65682b55956
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 16 15:15:29 2019 -0700

    Merge tag 'for-linus-5.3-ofs1' of git://git.kernel.org/pub/scm/linux/kernel/git/hubcap/linux
    
    Pull orangefs updates from Mike Marshall:
     "Two small fixes.
    
      This is just a fix for an unused value that Colin King sent me and a
      related fix I added"
    
    * tag 'for-linus-5.3-ofs1' of git://git.kernel.org/pub/scm/linux/kernel/git/hubcap/linux:
      orangefs: eliminate needless variable assignments
      orangefs: remove redundant assignment to variable buffer_index

commit e65682b55956e9fbf8a88f303a48e7c1430ffe15
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Jul 3 21:26:44 2019 +0000

    orangefs: eliminate needless variable assignments
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 80f06ee794c5..86f63e014ffb 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -134,7 +134,6 @@ ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
 	 */
 	if (ret == -EAGAIN && op_state_purged(new_op)) {
 		orangefs_bufmap_put(buffer_index);
-		buffer_index = -1;
 		if (type == ORANGEFS_IO_WRITE)
 			iov_iter_revert(iter, total_size);
 		gossip_debug(GOSSIP_FILE_DEBUG,
@@ -262,7 +261,6 @@ ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
 				"%s(%pU): PUT buffer_index %d\n",
 				__func__, handle, buffer_index);
 		}
-		buffer_index = -1;
 	}
 	op_release(new_op);
 	return ret;

commit f10789e4f6d6e2d0592620e6e3f6b4ff35d3488d
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sat May 11 14:27:00 2019 +0100

    orangefs: remove redundant assignment to variable buffer_index
    
    The variable buffer_index is being initialized however this is never
    read and later it is being reassigned to a new value. The initialization
    is redundant and hence can be removed.
    
    Addresses-Coverity: ("Unused Value")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index a35c17017210..80f06ee794c5 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -52,7 +52,7 @@ ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_khandle *handle = &orangefs_inode->refn.khandle;
 	struct orangefs_kernel_op_s *new_op = NULL;
-	int buffer_index = -1;
+	int buffer_index;
 	ssize_t ret;
 	size_t copy_amount;
 

commit 5aca284210ce827f780ea2f4f9c6ab8d6e2d6648
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Mon Jul 1 08:25:34 2019 -0700

    vfs: create a generic checking and prep function for FS_IOC_SETFLAGS
    
    Create a generic function to check incoming FS_IOC_SETFLAGS flag values
    and later prepare the inode for updates so that we can standardize the
    implementations that follow ext4's flag values.
    
    Note that the efivarfs implementation no longer fails a no-op SETFLAGS
    without CAP_LINUX_IMMUTABLE since that's the behavior in ext*.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Acked-by: David Sterba <dsterba@suse.com>
    Reviewed-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index a35c17017210..679a3c8e4fb3 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -357,11 +357,28 @@ static ssize_t orangefs_file_write_iter(struct kiocb *iocb,
 	return ret;
 }
 
+static int orangefs_getflags(struct inode *inode, unsigned long *uval)
+{
+	__u64 val = 0;
+	int ret;
+
+	ret = orangefs_inode_getxattr(inode,
+				      "user.pvfs2.meta_hint",
+				      &val, sizeof(val));
+	if (ret < 0 && ret != -ENODATA)
+		return ret;
+	else if (ret == -ENODATA)
+		val = 0;
+	*uval = val;
+	return 0;
+}
+
 /*
  * Perform a miscellaneous operation on a file.
  */
 static long orangefs_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
+	struct inode *inode = file_inode(file);
 	int ret = -ENOTTY;
 	__u64 val = 0;
 	unsigned long uval;
@@ -375,20 +392,16 @@ static long orangefs_ioctl(struct file *file, unsigned int cmd, unsigned long ar
 	 * and append flags
 	 */
 	if (cmd == FS_IOC_GETFLAGS) {
-		val = 0;
-		ret = orangefs_inode_getxattr(file_inode(file),
-					      "user.pvfs2.meta_hint",
-					      &val, sizeof(val));
-		if (ret < 0 && ret != -ENODATA)
+		ret = orangefs_getflags(inode, &uval);
+		if (ret)
 			return ret;
-		else if (ret == -ENODATA)
-			val = 0;
-		uval = val;
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "orangefs_ioctl: FS_IOC_GETFLAGS: %llu\n",
 			     (unsigned long long)uval);
 		return put_user(uval, (int __user *)arg);
 	} else if (cmd == FS_IOC_SETFLAGS) {
+		unsigned long old_uval;
+
 		ret = 0;
 		if (get_user(uval, (int __user *)arg))
 			return -EFAULT;
@@ -404,11 +417,17 @@ static long orangefs_ioctl(struct file *file, unsigned int cmd, unsigned long ar
 			gossip_err("orangefs_ioctl: the FS_IOC_SETFLAGS only supports setting one of FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NOATIME_FL\n");
 			return -EINVAL;
 		}
+		ret = orangefs_getflags(inode, &old_uval);
+		if (ret)
+			return ret;
+		ret = vfs_ioc_setflags_prepare(inode, old_uval, uval);
+		if (ret)
+			return ret;
 		val = uval;
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "orangefs_ioctl: FS_IOC_SETFLAGS: %llu\n",
 			     (unsigned long long)val);
-		ret = orangefs_inode_setxattr(file_inode(file),
+		ret = orangefs_inode_setxattr(inode,
 					      "user.pvfs2.meta_hint",
 					      &val, sizeof(val), 0);
 	}

commit dd59a6475c4cf69afac2ade01ab732b7825a2a45
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Mon Mar 25 18:59:29 2019 -0400

    orangefs: copy Orangefs-sized blocks into the pagecache if possible.
    
    ->readpage looks in file->private_data to try and find out how the
    userspace program set "count" in read(2) or with "dd bs=" or whatever.
    
    ->readpage uses "count" and inode->i_size to calculate how much
    data Orangefs should deposit in the Orangefs shared buffer, and
    remembers which slot the data is in.
    
    After copying data from the Orangefs shared buffer slot into
    "the page", readpage tries to increment through the pagecache index
    and fill as many pages as it can from the extra data in the shared
    buffer. Hopefully these extra pages will soon be needed by the vfs,
    and they'll be in the pagecache already.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 68ba5ae7ef5d..a35c17017210 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -54,6 +54,7 @@ ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
 	struct orangefs_kernel_op_s *new_op = NULL;
 	int buffer_index = -1;
 	ssize_t ret;
+	size_t copy_amount;
 
 	new_op = op_alloc(ORANGEFS_VFS_OP_FILE_IO);
 	if (!new_op)
@@ -212,8 +213,25 @@ ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
 		 *       can futher be kernel-space or user-space addresses.
 		 *       or it can pointers to struct page's
 		 */
+
+		/*
+		 * When reading, readahead_size will only be zero when
+		 * we're doing O_DIRECT, otherwise we got here from
+		 * orangefs_readpage.
+		 *
+		 * If we got here from orangefs_readpage we want to
+		 * copy either a page or the whole file into the io
+		 * vector, whichever is smaller.
+		 */
+		if (readahead_size)
+			copy_amount =
+				min(new_op->downcall.resp.io.amt_complete,
+					(__s64)PAGE_SIZE);
+		else
+			copy_amount = new_op->downcall.resp.io.amt_complete;
+
 		ret = orangefs_bufmap_copy_to_iovec(iter, buffer_index,
-		    new_op->downcall.resp.io.amt_complete);
+			copy_amount);
 		if (ret < 0) {
 			gossip_err("%s: Failed to copy-out buffers. Please make sure that the pvfs2-client is running (%ld)\n",
 			    __func__, (long)ret);
@@ -231,10 +249,19 @@ ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
 
 out:
 	if (buffer_index >= 0) {
-		orangefs_bufmap_put(buffer_index);
-		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "%s(%pU): PUT buffer_index %d\n",
-			     __func__, handle, buffer_index);
+		if ((readahead_size) && (type == ORANGEFS_IO_READ)) {
+			/* readpage */
+			*index_return = buffer_index;
+			gossip_debug(GOSSIP_FILE_DEBUG,
+				"%s: hold on to buffer_index :%d:\n",
+				__func__, buffer_index);
+		} else {
+			/* O_DIRECT */
+			orangefs_bufmap_put(buffer_index);
+			gossip_debug(GOSSIP_FILE_DEBUG,
+				"%s(%pU): PUT buffer_index %d\n",
+				__func__, handle, buffer_index);
+		}
 		buffer_index = -1;
 	}
 	op_release(new_op);

commit 4077a0f25b001926f86d35f6236351583bada9a4
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Mon Mar 25 18:17:10 2019 -0400

    orangefs: pass slot index back to readpage.
    
    When userspace deposits more than a page of data into the shared buffer,
    we'll need to know which slot it is in when we get back to readpage
    so that we can try to use the extra data to fill some extra pages.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 74292d31d113..68ba5ae7ef5d 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -47,7 +47,7 @@ static int flush_racache(struct inode *inode)
  */
 ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
     loff_t *offset, struct iov_iter *iter, size_t total_size,
-    loff_t readahead_size, struct orangefs_write_range *wr)
+    loff_t readahead_size, struct orangefs_write_range *wr, int *index_return)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_khandle *handle = &orangefs_inode->refn.khandle;

commit c2549f8c7a28c00facaf911f700c4811cfd6f52b
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Mon Mar 25 15:52:29 2019 -0400

    orangefs: remember count when reading.
    
    Orangefs wins when it can do IO on large (up to four meg) blocks at a time,
    and looses when it has to do tiny "small io" reads and writes. Accessing
    Orangefs through the pagecache with the kernel module helps with small io,
    both reading and writing, a great deal. Readpage generally tries to fetch a
    page (four k) at a time. We'll let users use "count" (as in read(2) or
    pread(2) for example) as a knob to control how much data they get from
    Orangefs at a time and we'll try to use the data to fill extra
    pagecache pages when we get to ->readpage, hopefully resulting in
    fewer calls to readpage and Orangefs userspace.
    
    We need a way to remember how they set count so that we can still have
    it available when we get to ->readpage.
    
     - We'll use file->private_data to keep track of "count".
       We'll wrap generic_file_open with orangefs_file_open and
       initialize private_data to NULL there.
    
     - In ->read_iter we have access to both "count" and file, so
       we'll kmalloc some space onto file->private_data and store
       "count" there.
    
     - We'll kfree file->private_data each time we visit ->flush and
       reinitialize it to NULL.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index faa5b61cdfd6..74292d31d113 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -286,8 +286,23 @@ static ssize_t orangefs_file_read_iter(struct kiocb *iocb,
     struct iov_iter *iter)
 {
 	int ret;
+	struct orangefs_read_options *ro;
+
 	orangefs_stats.reads++;
 
+	/*
+	 * Remember how they set "count" in read(2) or pread(2) or whatever -
+	 * users can use count as a knob to control orangefs io size and later
+	 * we can try to help them fill as many pages as possible in readpage.
+	 */
+	if (!iocb->ki_filp->private_data) {
+		iocb->ki_filp->private_data = kmalloc(sizeof *ro, GFP_KERNEL);
+		if (!iocb->ki_filp->private_data)
+			return(ENOMEM);
+		ro = iocb->ki_filp->private_data;
+		ro->blksiz = iter->count;
+	}
+
 	down_read(&file_inode(iocb->ki_filp)->i_rwsem);
 	ret = orangefs_revalidate_mapping(file_inode(iocb->ki_filp));
 	if (ret)
@@ -556,6 +571,12 @@ static int orangefs_lock(struct file *filp, int cmd, struct file_lock *fl)
 	return rc;
 }
 
+static int orangefs_file_open(struct inode * inode, struct file *file)
+{
+	file->private_data = NULL;
+	return generic_file_open(inode, file);
+}
+
 static int orangefs_flush(struct file *file, fl_owner_t id)
 {
 	/*
@@ -569,6 +590,9 @@ static int orangefs_flush(struct file *file, fl_owner_t id)
 	struct inode *inode = file->f_mapping->host;
 	int r;
 
+	kfree(file->private_data);
+	file->private_data = NULL;
+
 	if (inode->i_state & I_DIRTY_TIME) {
 		spin_lock(&inode->i_lock);
 		inode->i_state &= ~I_DIRTY_TIME;
@@ -591,7 +615,7 @@ const struct file_operations orangefs_file_operations = {
 	.lock		= orangefs_lock,
 	.unlocked_ioctl	= orangefs_ioctl,
 	.mmap		= orangefs_file_mmap,
-	.open		= generic_file_open,
+	.open		= orangefs_file_open,
 	.flush		= orangefs_flush,
 	.release	= orangefs_file_release,
 	.fsync		= orangefs_fsync,

commit 8f04e1be784858ba0288c7c09b9de06627a800c9
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Feb 12 20:19:06 2019 +0000

    orangefs: add orangefs_revalidate_mapping
    
    This is modeled after NFS, except our method is different.  We use a
    simple timer to determine whether to invalidate the page cache.  This
    is bound to perform.
    
    This addes a sysfs parameter cache_timeout_msecs which controls the time
    between page cache invalidations.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 405449ce4b02..faa5b61cdfd6 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -241,18 +241,78 @@ ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
 	return ret;
 }
 
+int orangefs_revalidate_mapping(struct inode *inode)
+{
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct address_space *mapping = inode->i_mapping;
+	unsigned long *bitlock = &orangefs_inode->bitlock;
+	int ret;
+
+	while (1) {
+		ret = wait_on_bit(bitlock, 1, TASK_KILLABLE);
+		if (ret)
+			return ret;
+		spin_lock(&inode->i_lock);
+		if (test_bit(1, bitlock)) {
+			spin_unlock(&inode->i_lock);
+			continue;
+		}
+		if (!time_before(jiffies, orangefs_inode->mapping_time))
+			break;
+		spin_unlock(&inode->i_lock);
+		return 0;
+	}
+
+	set_bit(1, bitlock);
+	smp_wmb();
+	spin_unlock(&inode->i_lock);
+
+	unmap_mapping_range(mapping, 0, 0, 0);
+	ret = filemap_write_and_wait(mapping);
+	if (!ret)
+		ret = invalidate_inode_pages2(mapping);
+
+	orangefs_inode->mapping_time = jiffies +
+	    orangefs_cache_timeout_msecs*HZ/1000;
+
+	clear_bit(1, bitlock);
+	smp_mb__after_atomic();
+	wake_up_bit(bitlock, 1);
+
+	return ret;
+}
+
 static ssize_t orangefs_file_read_iter(struct kiocb *iocb,
     struct iov_iter *iter)
 {
+	int ret;
 	orangefs_stats.reads++;
-	return generic_file_read_iter(iocb, iter);
+
+	down_read(&file_inode(iocb->ki_filp)->i_rwsem);
+	ret = orangefs_revalidate_mapping(file_inode(iocb->ki_filp));
+	if (ret)
+		goto out;
+
+	ret = generic_file_read_iter(iocb, iter);
+out:
+	up_read(&file_inode(iocb->ki_filp)->i_rwsem);
+	return ret;
 }
 
 static ssize_t orangefs_file_write_iter(struct kiocb *iocb,
     struct iov_iter *iter)
 {
+	int ret;
 	orangefs_stats.writes++;
-	return generic_file_write_iter(iocb, iter);
+
+	if (iocb->ki_pos > i_size_read(file_inode(iocb->ki_filp))) {
+		ret = orangefs_revalidate_mapping(file_inode(iocb->ki_filp));
+		if (ret)
+			return ret;
+	}
+
+	ret = generic_file_write_iter(iocb, iter);
+	return ret;
 }
 
 /*
@@ -341,6 +401,12 @@ static const struct vm_operations_struct orangefs_file_vm_ops = {
  */
 static int orangefs_file_mmap(struct file *file, struct vm_area_struct *vma)
 {
+	int ret;
+
+	ret = orangefs_revalidate_mapping(file_inode(file));
+	if (ret)
+		return ret;
+
 	gossip_debug(GOSSIP_FILE_DEBUG,
 		     "orangefs_file_mmap: called on %s\n",
 		     (file ?

commit c472ebc25555e634d89e1ed508d37c9102bff017
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Dec 14 17:04:21 2018 -0500

    orangefs: implement writepages
    
    Go through pages and look for a consecutive writable region.  After
    finding a number of consecutive writable pages or when finding that
    the next page's dirty range is not contiguous and cannot be written
    as one request, send the write to the server.
    
    The number of pages is determined by the client-core's buffer size.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index f409ac5d3410..405449ce4b02 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -386,6 +386,7 @@ static int orangefs_file_release(struct inode *inode, struct file *file)
 			gossip_debug(GOSSIP_INODE_DEBUG,
 			    "flush_racache finished\n");
 		}
+
 	}
 	return 0;
 }

commit 52e2d0a3804c095775b178d6b0707ef6ac8e6d04
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Dec 14 15:24:43 2018 -0500

    orangefs: write range tracking
    
    Attach the actual range of bytes written to plus the responsible uid/gid
    to each dirty page.  This information must be sent to the server when
    the page is written out.
    
    Now write_begin, page_mkwrite, and invalidatepage keep up with this
    information.  There are several conditions where they must write out the
    page immediately to store the new range.  Two non-contiguous ranges
    cannot be stored on a single page.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 26d8ff410b0a..f409ac5d3410 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -46,8 +46,8 @@ static int flush_racache(struct inode *inode)
  * Post and wait for the I/O upcall to finish
  */
 ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
-		loff_t *offset, struct iov_iter *iter,
-		size_t total_size, loff_t readahead_size)
+    loff_t *offset, struct iov_iter *iter, size_t total_size,
+    loff_t readahead_size, struct orangefs_write_range *wr)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_khandle *handle = &orangefs_inode->refn.khandle;
@@ -85,6 +85,10 @@ ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
 	new_op->upcall.req.io.buf_index = buffer_index;
 	new_op->upcall.req.io.count = total_size;
 	new_op->upcall.req.io.offset = *offset;
+	if (type == ORANGEFS_IO_WRITE && wr) {
+		new_op->upcall.uid = from_kuid(&init_user_ns, wr->uid);
+		new_op->upcall.gid = from_kgid(&init_user_ns, wr->gid);
+	}
 
 	gossip_debug(GOSSIP_FILE_DEBUG,
 		     "%s(%pU): offset: %llu total_size: %zd\n",
@@ -329,7 +333,7 @@ static vm_fault_t orangefs_fault(struct vm_fault *vmf)
 static const struct vm_operations_struct orangefs_file_vm_ops = {
 	.fault = orangefs_fault,
 	.map_pages = filemap_map_pages,
-	.page_mkwrite = filemap_page_mkwrite,
+	.page_mkwrite = orangefs_page_mkwrite,
 };
 
 /*

commit 90fc07065a3505e5a874c5854fd6176beb545e08
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Mar 26 18:58:11 2018 +0000

    orangefs: avoid fsync service operation on flush
    
    Without this, an fsync call is sent to the server even if no data
    changed.  This resulted in a rather severe (50%) performance regression
    under certain metadata-heavy workloads.
    
    In the past, everything was direct IO.  Nothing happend on a close call.
    An explicit fsync call would send an fsync request to the server which
    in turn fsynced the underlying file.
    
    Now there are cached writes.  Then fsync began writing out dirty pages
    in addition to making an fsync request to the server, and close began
    calling fsync.
    
    With this commit, close only writes out dirty pages, and does not make
    the fsync request.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index f4e20d5ed207..26d8ff410b0a 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -487,7 +487,29 @@ static int orangefs_lock(struct file *filp, int cmd, struct file_lock *fl)
 
 static int orangefs_flush(struct file *file, fl_owner_t id)
 {
-	return vfs_fsync(file, 0);
+	/*
+	 * This is vfs_fsync_range(file, 0, LLONG_MAX, 0) without the
+	 * service_operation in orangefs_fsync.
+	 *
+	 * Do not send fsync to OrangeFS server on a close.  Do send fsync
+	 * on an explicit fsync call.  This duplicates historical OrangeFS
+	 * behavior.
+	 */
+	struct inode *inode = file->f_mapping->host;
+	int r;
+
+	if (inode->i_state & I_DIRTY_TIME) {
+		spin_lock(&inode->i_lock);
+		inode->i_state &= ~I_DIRTY_TIME;
+		spin_unlock(&inode->i_lock);
+		mark_inode_dirty_sync(inode);
+	}
+
+	r = filemap_write_and_wait_range(file->f_mapping, 0, LLONG_MAX);
+	if (r > 0)
+		return 0;
+	else
+		return r;
 }
 
 /** ORANGEFS implementation of VFS file operations */

commit 3e9dfc6e1e8bce62a329f1452c7eeccbac230980
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Nov 6 19:54:49 2018 +0000

    orangefs: move do_readv_writev to direct_IO
    
    direct_IO was the only caller and all direct_IO did was call it,
    so there's no use in having the code spread out into so many functions.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 0af9f0b42d80..f4e20d5ed207 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -237,114 +237,6 @@ ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
 	return ret;
 }
 
-/*
- * Common entry point for read/write/readv/writev
- * This function will dispatch it to either the direct I/O
- * or buffered I/O path depending on the mount options and/or
- * augmented/extended metadata attached to the file.
- * Note: File extended attributes override any mount options.
- */
-ssize_t do_readv_writev(enum ORANGEFS_io_type type, struct file *file,
-		loff_t *offset, struct iov_iter *iter)
-{
-	struct inode *inode = file->f_mapping->host;
-	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
-	struct orangefs_khandle *handle = &orangefs_inode->refn.khandle;
-	size_t count = iov_iter_count(iter);
-	ssize_t total_count = 0;
-	ssize_t ret = -EINVAL;
-
-	gossip_debug(GOSSIP_FILE_DEBUG,
-		"%s-BEGIN(%pU): count(%d) after estimate_max_iovecs.\n",
-		__func__,
-		handle,
-		(int)count);
-
-	if (type == ORANGEFS_IO_WRITE) {
-		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "%s(%pU): proceeding with offset : %llu, "
-			     "size %d\n",
-			     __func__,
-			     handle,
-			     llu(*offset),
-			     (int)count);
-	}
-
-	if (count == 0) {
-		ret = 0;
-		goto out;
-	}
-
-	while (iov_iter_count(iter)) {
-		size_t each_count = iov_iter_count(iter);
-		size_t amt_complete;
-
-		/* how much to transfer in this loop iteration */
-		if (each_count > orangefs_bufmap_size_query())
-			each_count = orangefs_bufmap_size_query();
-
-		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "%s(%pU): size of each_count(%d)\n",
-			     __func__,
-			     handle,
-			     (int)each_count);
-		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "%s(%pU): BEFORE wait_for_io: offset is %d\n",
-			     __func__,
-			     handle,
-			     (int)*offset);
-
-		ret = wait_for_direct_io(type, inode, offset, iter,
-				each_count, 0);
-		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "%s(%pU): return from wait_for_io:%d\n",
-			     __func__,
-			     handle,
-			     (int)ret);
-
-		if (ret < 0)
-			goto out;
-
-		*offset += ret;
-		total_count += ret;
-		amt_complete = ret;
-
-		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "%s(%pU): AFTER wait_for_io: offset is %d\n",
-			     __func__,
-			     handle,
-			     (int)*offset);
-
-		/*
-		 * if we got a short I/O operations,
-		 * fall out and return what we got so far
-		 */
-		if (amt_complete < each_count)
-			break;
-	} /*end while */
-
-out:
-	if (total_count > 0)
-		ret = total_count;
-	if (ret > 0) {
-		if (type == ORANGEFS_IO_READ) {
-			file_accessed(file);
-		} else {
-			file_update_time(file);
-			if (*offset > i_size_read(inode))
-				i_size_write(inode, *offset);
-		}
-	}
-
-	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "%s(%pU): Value(%d) returned.\n",
-		     __func__,
-		     handle,
-		     (int)ret);
-
-	return ret;
-}
-
 static ssize_t orangefs_file_read_iter(struct kiocb *iocb,
     struct iov_iter *iter)
 {

commit 43f34576042eb3256c39b502b22c6755144f7517
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Nov 6 19:51:39 2018 +0000

    orangefs: do not return successful read when the client-core disappeared
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index d8c97b87bf26..0af9f0b42d80 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -169,7 +169,10 @@ ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
 			 * trigger the write.
 			 */
 			case OP_VFS_STATE_INPROGR:
-				ret = total_size;
+				if (type == ORANGEFS_IO_READ)
+					ret = -EINTR;
+				else
+					ret = total_size;
 				break;
 			default:
 				gossip_err("%s: unexpected op state :%d:.\n",

commit 85ac799cf926a589829ebe6274bb5e5a41159743
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Feb 22 18:10:43 2018 +0000

    orangefs: implement writepage
    
    Now orangefs_inode_getattr fills from cache if an inode has dirty pages.
    
    also if attr_valid and dirty pages and !flags, we spin on inode writeback
    before returning if pages still dirty after: should it be other way
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 934f102ce9e1..d8c97b87bf26 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
  * (C) 2001 Clemson University and The University of Chicago
+ * Copyright 2018 Omnibond Systems, L.L.C.
  *
  * See COPYING in top-level directory.
  */
@@ -348,63 +349,11 @@ static ssize_t orangefs_file_read_iter(struct kiocb *iocb,
 	return generic_file_read_iter(iocb, iter);
 }
 
-static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
+static ssize_t orangefs_file_write_iter(struct kiocb *iocb,
+    struct iov_iter *iter)
 {
-	struct file *file = iocb->ki_filp;
-	loff_t pos;
-	ssize_t rc;
-
-	truncate_inode_pages(file->f_mapping, 0);
-
-	gossip_debug(GOSSIP_FILE_DEBUG, "orangefs_file_write_iter\n");
-
-	inode_lock(file->f_mapping->host);
-
-	/* Make sure generic_write_checks sees an up to date inode size. */
-	if (file->f_flags & O_APPEND) {
-		rc = orangefs_inode_getattr(file->f_mapping->host,
-		    ORANGEFS_GETATTR_SIZE);
-		if (rc == -ESTALE)
-			rc = -EIO;
-		if (rc) {
-			gossip_err("%s: orangefs_inode_getattr failed, "
-			    "rc:%zd:.\n", __func__, rc);
-			goto out;
-		}
-	}
-
-	rc = generic_write_checks(iocb, iter);
-
-	if (rc <= 0) {
-		gossip_err("%s: generic_write_checks failed, rc:%zd:.\n",
-			   __func__, rc);
-		goto out;
-	}
-
-	/*
-	 * if we are appending, generic_write_checks would have updated
-	 * pos to the end of the file, so we will wait till now to set
-	 * pos...
-	 */
-	pos = iocb->ki_pos;
-
-	rc = do_readv_writev(ORANGEFS_IO_WRITE,
-			     file,
-			     &pos,
-			     iter);
-	if (rc < 0) {
-		gossip_err("%s: do_readv_writev failed, rc:%zd:.\n",
-			   __func__, rc);
-		goto out;
-	}
-
-	iocb->ki_pos = pos;
 	orangefs_stats.writes++;
-
-out:
-
-	inode_unlock(file->f_mapping->host);
-	return rc;
+	return generic_file_write_iter(iocb, iter);
 }
 
 /*
@@ -499,9 +448,6 @@ static int orangefs_file_mmap(struct file *file, struct vm_area_struct *vma)
 			(char *)file->f_path.dentry->d_name.name :
 			(char *)"Unknown"));
 
-	if ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))
-		return -EINVAL;
-
 	/* set the sequential readahead hint */
 	vma->vm_flags |= VM_SEQ_READ;
 	vma->vm_flags &= ~VM_RAND_READ;
@@ -541,8 +487,6 @@ static int orangefs_file_release(struct inode *inode, struct file *file)
 			gossip_debug(GOSSIP_INODE_DEBUG,
 			    "flush_racache finished\n");
 		}
-		truncate_inode_pages(file_inode(file)->i_mapping,
-				     0);
 	}
 	return 0;
 }
@@ -560,6 +504,11 @@ static int orangefs_fsync(struct file *file,
 		ORANGEFS_I(file_inode(file));
 	struct orangefs_kernel_op_s *new_op = NULL;
 
+	ret = filemap_write_and_wait_range(file_inode(file)->i_mapping,
+	    start, end);
+	if (ret < 0)
+		return ret;
+
 	new_op = op_alloc(ORANGEFS_VFS_OP_FSYNC);
 	if (!new_op)
 		return -ENOMEM;
@@ -641,6 +590,11 @@ static int orangefs_lock(struct file *filp, int cmd, struct file_lock *fl)
 	return rc;
 }
 
+static int orangefs_flush(struct file *file, fl_owner_t id)
+{
+	return vfs_fsync(file, 0);
+}
+
 /** ORANGEFS implementation of VFS file operations */
 const struct file_operations orangefs_file_operations = {
 	.llseek		= orangefs_file_llseek,
@@ -650,6 +604,7 @@ const struct file_operations orangefs_file_operations = {
 	.unlocked_ioctl	= orangefs_ioctl,
 	.mmap		= orangefs_file_mmap,
 	.open		= generic_file_open,
+	.flush		= orangefs_flush,
 	.release	= orangefs_file_release,
 	.fsync		= orangefs_fsync,
 };

commit c453dcfc79815760071bd9a7805d4b809fec05cf
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Feb 16 20:51:24 2018 +0000

    orangefs: migrate to generic_file_read_iter
    
    Remove orangefs_inode_read.  It was used by readpage.  Calling
    wait_for_direct_io directly serves the purpose just as well.  There is
    now no check of the bufmap size in the readpage path.  There are already
    other places the bufmap size is assumed to be greater than PAGE_SIZE.
    
    Important to call truncate_inode_pages now in the write path so a
    subsequent read sees the new data.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index a9e69c56d2fb..934f102ce9e1 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -44,7 +44,7 @@ static int flush_racache(struct inode *inode)
 /*
  * Post and wait for the I/O upcall to finish
  */
-static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
+ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
 		loff_t *offset, struct iov_iter *iter,
 		size_t total_size, loff_t readahead_size)
 {
@@ -240,7 +240,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
  * augmented/extended metadata attached to the file.
  * Note: File extended attributes override any mount options.
  */
-static ssize_t do_readv_writev(enum ORANGEFS_io_type type, struct file *file,
+ssize_t do_readv_writev(enum ORANGEFS_io_type type, struct file *file,
 		loff_t *offset, struct iov_iter *iter)
 {
 	struct inode *inode = file->f_mapping->host;
@@ -341,65 +341,11 @@ static ssize_t do_readv_writev(enum ORANGEFS_io_type type, struct file *file,
 	return ret;
 }
 
-/*
- * Read data from a specified offset in a file (referenced by inode).
- * Data may be placed either in a user or kernel buffer.
- */
-ssize_t orangefs_inode_read(struct inode *inode,
-			    struct iov_iter *iter,
-			    loff_t *offset,
-			    loff_t readahead_size)
+static ssize_t orangefs_file_read_iter(struct kiocb *iocb,
+    struct iov_iter *iter)
 {
-	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
-	size_t count = iov_iter_count(iter);
-	size_t bufmap_size;
-	ssize_t ret = -EINVAL;
-
 	orangefs_stats.reads++;
-
-	bufmap_size = orangefs_bufmap_size_query();
-	if (count > bufmap_size) {
-		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "%s: count is too large (%zd/%zd)!\n",
-			     __func__, count, bufmap_size);
-		return -EINVAL;
-	}
-
-	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "%s(%pU) %zd@%llu\n",
-		     __func__,
-		     &orangefs_inode->refn.khandle,
-		     count,
-		     llu(*offset));
-
-	ret = wait_for_direct_io(ORANGEFS_IO_READ, inode, offset, iter,
-			count, readahead_size);
-	if (ret > 0)
-		*offset += ret;
-
-	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "%s(%pU): Value(%zd) returned.\n",
-		     __func__,
-		     &orangefs_inode->refn.khandle,
-		     ret);
-
-	return ret;
-}
-
-static ssize_t orangefs_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)
-{
-	struct file *file = iocb->ki_filp;
-	loff_t pos = iocb->ki_pos;
-	ssize_t rc = 0;
-
-	gossip_debug(GOSSIP_FILE_DEBUG, "orangefs_file_read_iter\n");
-
-	orangefs_stats.reads++;
-
-	rc = do_readv_writev(ORANGEFS_IO_READ, file, &pos, iter);
-	iocb->ki_pos = pos;
-
-	return rc;
+	return generic_file_read_iter(iocb, iter);
 }
 
 static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
@@ -408,6 +354,8 @@ static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *ite
 	loff_t pos;
 	ssize_t rc;
 
+	truncate_inode_pages(file->f_mapping, 0);
+
 	gossip_debug(GOSSIP_FILE_DEBUG, "orangefs_file_write_iter\n");
 
 	inode_lock(file->f_mapping->host);

commit 5e7f1d433804450cdb5ba478d26742963e06b1bc
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Feb 12 15:49:24 2018 +0000

    orangefs: update attributes rather than relying on server
    
    This should be a no-op now, but once inode writeback works, it'll be
    necessary to have the correct attribute in the dirty inode.
    
    Previously the attribute fetch timeout was marked invalid and the server
    provided the updated attribute.  When the inode is dirty, the server
    cannot be consulted since it does not yet know the pending setattr.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index b0688ea894a4..a9e69c56d2fb 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -327,14 +327,8 @@ static ssize_t do_readv_writev(enum ORANGEFS_io_type type, struct file *file,
 			file_accessed(file);
 		} else {
 			file_update_time(file);
-			/*
-			 * Must invalidate to ensure write loop doesn't
-			 * prevent kernel from reading updated
-			 * attribute.  Size probably changed because of
-			 * the write, and other clients could update
-			 * any other attribute.
-			 */
-			orangefs_inode->getattr_time = jiffies - 1;
+			if (*offset > i_size_read(inode))
+				i_size_write(inode, *offset);
 		}
 	}
 

commit 8b60785c1d7c63415c32bf64dabc686b9045ce7d
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Wed Feb 7 18:44:50 2018 +0000

    orangefs: simplify orangefs_inode_getattr interface
    
    No need to store the received mask.  It is either STATX_BASIC_STATS or
    STATX_BASIC_STATS & ~STATX_SIZE.  If STATX_SIZE is requested, the cache
    is bypassed anyway, so the cached mask is unnecessary to decide whether
    to do a real getattr.
    
    This is a change.  Previously a getattr would want size and use the
    cached size.  All of the in-kernel callers that wanted size did not want
    a cached size.  Now a getattr cannot use the cached size if it wants
    size at all.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index b094d3d79354..b0688ea894a4 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -420,8 +420,8 @@ static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *ite
 
 	/* Make sure generic_write_checks sees an up to date inode size. */
 	if (file->f_flags & O_APPEND) {
-		rc = orangefs_inode_getattr(file->f_mapping->host, 0, 1,
-		    STATX_SIZE);
+		rc = orangefs_inode_getattr(file->f_mapping->host,
+		    ORANGEFS_GETATTR_SIZE);
 		if (rc == -ESTALE)
 			rc = -EIO;
 		if (rc) {
@@ -528,14 +528,13 @@ static vm_fault_t orangefs_fault(struct vm_fault *vmf)
 {
 	struct file *file = vmf->vma->vm_file;
 	int ret;
-
-	ret = orangefs_inode_getattr(file->f_mapping->host, 0, 1,
-	    STATX_SIZE);
+	ret = orangefs_inode_getattr(file->f_mapping->host,
+	    ORANGEFS_GETATTR_SIZE);
 	if (ret == -ESTALE)
 		ret = -EIO;
 	if (ret) {
-		gossip_err("%s: orangefs_inode_getattr failed, ret:%d:.\n",
-				__func__, ret);
+		gossip_err("%s: orangefs_inode_getattr failed, "
+		    "ret:%d:.\n", __func__, ret);
 		return VM_FAULT_SIGBUS;
 	}
 	return filemap_fault(vmf);
@@ -656,8 +655,8 @@ static loff_t orangefs_file_llseek(struct file *file, loff_t offset, int origin)
 		 * NOTE: We are only interested in file size here,
 		 * so we set mask accordingly.
 		 */
-		ret = orangefs_inode_getattr(file->f_mapping->host, 0, 1,
-		    STATX_SIZE);
+		ret = orangefs_inode_getattr(file->f_mapping->host,
+		    ORANGEFS_GETATTR_SIZE);
 		if (ret == -ESTALE)
 			ret = -EIO;
 		if (ret) {

commit 6e356d45950e2d26b63531a2fd112c987da7a933
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Tue Feb 5 14:13:34 2019 -0500

    orangefs: remove two un-needed BUG_ONs...
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index a5a2fe76568f..b094d3d79354 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -398,8 +398,6 @@ static ssize_t orangefs_file_read_iter(struct kiocb *iocb, struct iov_iter *iter
 	loff_t pos = iocb->ki_pos;
 	ssize_t rc = 0;
 
-	BUG_ON(iocb->private);
-
 	gossip_debug(GOSSIP_FILE_DEBUG, "orangefs_file_read_iter\n");
 
 	orangefs_stats.reads++;
@@ -416,8 +414,6 @@ static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *ite
 	loff_t pos;
 	ssize_t rc;
 
-	BUG_ON(iocb->private);
-
 	gossip_debug(GOSSIP_FILE_DEBUG, "orangefs_file_write_iter\n");
 
 	inode_lock(file->f_mapping->host);

commit 8bf782f64737be055e6c1fad7a4c7cae7aae2d99
Author: Souptick Joarder <jrdr.linux@gmail.com>
Date:   Fri Jun 29 00:12:40 2018 +0530

    orangefs: Adding new return type vm_fault_t
    
    Use new return type vm_fault_t for fault handler. For now,
    this is just documenting that the function returns a VM_FAULT
    value rather than an errno. Once all instances are converted,
    vm_fault_t will become a distinct type.
    
    See the following
    commit 1c8f422059ae ("mm: change return type to vm_fault_t")
    
    Fixed checkpatch.pl warning.
    
    Signed-off-by: Souptick Joarder <jrdr.linux@gmail.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index db0b52187cbc..a5a2fe76568f 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -528,18 +528,19 @@ static long orangefs_ioctl(struct file *file, unsigned int cmd, unsigned long ar
 	return ret;
 }
 
-static int orangefs_fault(struct vm_fault *vmf)
+static vm_fault_t orangefs_fault(struct vm_fault *vmf)
 {
 	struct file *file = vmf->vma->vm_file;
-	int rc;
-	rc = orangefs_inode_getattr(file->f_mapping->host, 0, 1,
+	int ret;
+
+	ret = orangefs_inode_getattr(file->f_mapping->host, 0, 1,
 	    STATX_SIZE);
-	if (rc == -ESTALE)
-		rc = -EIO;
-	if (rc) {
-		gossip_err("%s: orangefs_inode_getattr failed, "
-		    "rc:%d:.\n", __func__, rc);
-		return rc;
+	if (ret == -ESTALE)
+		ret = -EIO;
+	if (ret) {
+		gossip_err("%s: orangefs_inode_getattr failed, ret:%d:.\n",
+				__func__, ret);
+		return VM_FAULT_SIGBUS;
 	}
 	return filemap_fault(vmf);
 }

commit 95f5f88f8900c09eb534c8cb42d75ff3cf7ea96c
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri May 11 17:11:48 2018 -0400

    orangefs: formatting cleanups
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 84f44365bfb3..db0b52187cbc 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -162,7 +162,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 				else
 					ret = 0;
 				break;
-			/* 
+			/*
 			 * If the op was in progress when the interrupt
 			 * occurred, then the client-core was able to
 			 * trigger the write.

commit ec62e95ae3f1c5bb23c7fba849fa306ad315ab10
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Apr 5 11:50:10 2018 +0100

    orangefs: make struct orangefs_file_vm_ops static
    
    The struct orangefs_file_vm_ops is local to the source and does not need
    to be in global scope, so make it static.
    
    Cleans up sparse warning:
    fs/orangefs/file.c:547:35: warning: symbol 'orangefs_file_vm_ops' was not
    declared. Should it be static?
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 26358efbf794..84f44365bfb3 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -544,7 +544,7 @@ static int orangefs_fault(struct vm_fault *vmf)
 	return filemap_fault(vmf);
 }
 
-const struct vm_operations_struct orangefs_file_vm_ops = {
+static const struct vm_operations_struct orangefs_file_vm_ops = {
 	.fault = orangefs_fault,
 	.map_pages = filemap_map_pages,
 	.page_mkwrite = filemap_page_mkwrite,

commit a5135eeab2e5ca1b94f34dcb772cb30f9f390efc
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 3 16:27:12 2018 +0000

    orangefs: implement vm_ops->fault
    
    Must retrieve size before running filemap_fault so the kernel has
    an up-to-date size.
    
    This should have been caught by xfstests generic/246, but it was masked
    by orangefs_new_inode, which set i_size to PAGE_SIZE.  When nothing
    caused a getattr prior to a pagefault, i_size was still PAGE_SIZE.
    Since xfstests only read 10 bytes, it did not catch this bug.
    
    When orangefs_new_inode was modified to perform a getattr instead,
    i_size was set to zero, as it was a newly created file.  Then
    orangefs_file_write_iter did NOT set i_size.  Instead it invalidated the
    attribute cache, which should have caused the next caller to retrieve
    i_size.  But the fault handler did not know it was supposed to retrieve
    i_size.  So during xfstests, i_size was still zero, and filemap_fault
    returned VM_FAULT_SIGBUS.
    
    Fixes xfstests generic/452.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 3a7319a1bfdb..26358efbf794 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -528,6 +528,28 @@ static long orangefs_ioctl(struct file *file, unsigned int cmd, unsigned long ar
 	return ret;
 }
 
+static int orangefs_fault(struct vm_fault *vmf)
+{
+	struct file *file = vmf->vma->vm_file;
+	int rc;
+	rc = orangefs_inode_getattr(file->f_mapping->host, 0, 1,
+	    STATX_SIZE);
+	if (rc == -ESTALE)
+		rc = -EIO;
+	if (rc) {
+		gossip_err("%s: orangefs_inode_getattr failed, "
+		    "rc:%d:.\n", __func__, rc);
+		return rc;
+	}
+	return filemap_fault(vmf);
+}
+
+const struct vm_operations_struct orangefs_file_vm_ops = {
+	.fault = orangefs_fault,
+	.map_pages = filemap_map_pages,
+	.page_mkwrite = filemap_page_mkwrite,
+};
+
 /*
  * Memory map a region of a file.
  */
@@ -539,12 +561,16 @@ static int orangefs_file_mmap(struct file *file, struct vm_area_struct *vma)
 			(char *)file->f_path.dentry->d_name.name :
 			(char *)"Unknown"));
 
+	if ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))
+		return -EINVAL;
+
 	/* set the sequential readahead hint */
 	vma->vm_flags |= VM_SEQ_READ;
 	vma->vm_flags &= ~VM_RAND_READ;
 
-	/* Use readonly mmap since we cannot support writable maps. */
-	return generic_file_readonly_mmap(file, vma);
+	file_accessed(file);
+	vma->vm_ops = &orangefs_file_vm_ops;
+	return 0;
 }
 
 #define mapping_nrpages(idata) ((idata)->nrpages)

commit dbcb5e7fc470c9daec9cb4ae463670f2047163e3
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Mar 20 17:00:12 2018 +0000

    orangefs: open code short single-use functions
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 0d228cd087e6..3a7319a1bfdb 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -41,70 +41,6 @@ static int flush_racache(struct inode *inode)
 	return ret;
 }
 
-/*
- * Copy to client-core's address space from the buffers specified
- * by the iovec upto total_size bytes.
- * NOTE: the iovector can either contain addresses which
- *       can futher be kernel-space or user-space addresses.
- *       or it can pointers to struct page's
- */
-static int precopy_buffers(int buffer_index,
-			   struct iov_iter *iter,
-			   size_t total_size)
-{
-	int ret = 0;
-	/*
-	 * copy data from application/kernel by pulling it out
-	 * of the iovec.
-	 */
-
-
-	if (total_size) {
-		ret = orangefs_bufmap_copy_from_iovec(iter,
-						      buffer_index,
-						      total_size);
-		if (ret < 0)
-		gossip_err("%s: Failed to copy-in buffers. Please make sure that the pvfs2-client is running. %ld\n",
-			   __func__,
-			   (long)ret);
-	}
-
-	if (ret < 0)
-		gossip_err("%s: Failed to copy-in buffers. Please make sure that the pvfs2-client is running. %ld\n",
-			__func__,
-			(long)ret);
-	return ret;
-}
-
-/*
- * Copy from client-core's address space to the buffers specified
- * by the iovec upto total_size bytes.
- * NOTE: the iovector can either contain addresses which
- *       can futher be kernel-space or user-space addresses.
- *       or it can pointers to struct page's
- */
-static int postcopy_buffers(int buffer_index,
-			    struct iov_iter *iter,
-			    size_t total_size)
-{
-	int ret = 0;
-	/*
-	 * copy data to application/kernel by pushing it out to
-	 * the iovec. NOTE; target buffers can be addresses or
-	 * struct page pointers.
-	 */
-	if (total_size) {
-		ret = orangefs_bufmap_copy_to_iovec(iter,
-						    buffer_index,
-						    total_size);
-		if (ret < 0)
-			gossip_err("%s: Failed to copy-out buffers. Please make sure that the pvfs2-client is running (%ld)\n",
-				__func__,
-				(long)ret);
-	}
-	return ret;
-}
-
 /*
  * Post and wait for the I/O upcall to finish
  */
@@ -157,14 +93,15 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 		     total_size);
 	/*
 	 * Stage 1: copy the buffers into client-core's address space
-	 * precopy_buffers only pertains to writes.
 	 */
-	if (type == ORANGEFS_IO_WRITE) {
-		ret = precopy_buffers(buffer_index,
-				      iter,
-				      total_size);
-		if (ret < 0)
+	if (type == ORANGEFS_IO_WRITE && total_size) {
+		ret = orangefs_bufmap_copy_from_iovec(iter, buffer_index,
+		    total_size);
+		if (ret < 0) {
+			gossip_err("%s: Failed to copy-in buffers. Please make sure that the pvfs2-client is running. %ld\n",
+			    __func__, (long)ret);
 			goto out;
+		}
 	}
 
 	gossip_debug(GOSSIP_FILE_DEBUG,
@@ -260,14 +197,20 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 
 	/*
 	 * Stage 3: Post copy buffers from client-core's address space
-	 * postcopy_buffers only pertains to reads.
 	 */
-	if (type == ORANGEFS_IO_READ) {
-		ret = postcopy_buffers(buffer_index,
-				       iter,
-				       new_op->downcall.resp.io.amt_complete);
-		if (ret < 0)
+	if (type == ORANGEFS_IO_READ && new_op->downcall.resp.io.amt_complete) {
+		/*
+		 * NOTE: the iovector can either contain addresses which
+		 *       can futher be kernel-space or user-space addresses.
+		 *       or it can pointers to struct page's
+		 */
+		ret = orangefs_bufmap_copy_to_iovec(iter, buffer_index,
+		    new_op->downcall.resp.io.amt_complete);
+		if (ret < 0) {
+			gossip_err("%s: Failed to copy-out buffers. Please make sure that the pvfs2-client is running (%ld)\n",
+			    __func__, (long)ret);
 			goto out;
+		}
 	}
 	gossip_debug(GOSSIP_FILE_DEBUG,
 	    "%s(%pU): Amount %s, returned by the sys-io call:%d\n",

commit 6793f1c450b1533a5e9c2493490de771d38b24f9
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Jan 25 19:39:44 2018 -0500

    orangefs: fix deadlock; do not write i_size in read_iter
    
    After do_readv_writev, the inode cache is invalidated anyway, so i_size
    will never be read.  It will be fetched from the server which will also
    know about updates from other machines.
    
    Fixes deadlock on 32-bit SMP.
    
    See https://marc.info/?l=linux-fsdevel&m=151268557427760&w=2
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Mike Marshall <hubcap@omnibond.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 1668fd645c45..0d228cd087e6 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -452,7 +452,7 @@ ssize_t orangefs_inode_read(struct inode *inode,
 static ssize_t orangefs_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)
 {
 	struct file *file = iocb->ki_filp;
-	loff_t pos = *(&iocb->ki_pos);
+	loff_t pos = iocb->ki_pos;
 	ssize_t rc = 0;
 
 	BUG_ON(iocb->private);
@@ -492,9 +492,6 @@ static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *ite
 		}
 	}
 
-	if (file->f_pos > i_size_read(file->f_mapping->host))
-		orangefs_i_size_write(file->f_mapping->host, file->f_pos);
-
 	rc = generic_write_checks(iocb, iter);
 
 	if (rc <= 0) {
@@ -508,7 +505,7 @@ static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *ite
 	 * pos to the end of the file, so we will wait till now to set
 	 * pos...
 	 */
-	pos = *(&iocb->ki_pos);
+	pos = iocb->ki_pos;
 
 	rc = do_readv_writev(ORANGEFS_IO_WRITE,
 			     file,

commit a55f2d861585006f493e933ad32d65d71ba631fa
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Nov 7 15:01:40 2017 -0500

    orangefs: stop setting atime on inode dirty
    
    The previous code path was to mark the inode dirty, let
    orangefs_inode_dirty set a flag in our private inode, then later during
    inode release call orangefs_flush_inode which notices the flag and
    writes the atime out.
    
    The code path worked almost identically for mtime, ctime, and mode
    except that those flags are set explicitly and not as side effects of
    dirty.
    
    Now orangefs_flush_inode is removed.  Marking an inode dirty does not
    imply an atime update.  Any place where flags were set before is now
    an explicit call to orangefs_inode_setattr.  Since OrangeFS does not
    utilize inode writeback, the attribute change should be written out
    immediately.
    
    Fixes generic/120.
    
    In namei.c, there are several places where the directory mtime and ctime
    are set, but only the mtime is sent to the server.  These don't seem
    right, but I've left them as is for now.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index e4a8e6a7eb17..1668fd645c45 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -383,9 +383,15 @@ static ssize_t do_readv_writev(enum ORANGEFS_io_type type, struct file *file,
 		if (type == ORANGEFS_IO_READ) {
 			file_accessed(file);
 		} else {
-			SetMtimeFlag(orangefs_inode);
-			inode->i_mtime = current_time(inode);
-			mark_inode_dirty_sync(inode);
+			file_update_time(file);
+			/*
+			 * Must invalidate to ensure write loop doesn't
+			 * prevent kernel from reading updated
+			 * attribute.  Size probably changed because of
+			 * the write, and other clients could update
+			 * any other attribute.
+			 */
+			orangefs_inode->getattr_time = jiffies - 1;
 		}
 	}
 
@@ -615,8 +621,6 @@ static int orangefs_file_release(struct inode *inode, struct file *file)
 		     "orangefs_file_release: called on %pD\n",
 		     file);
 
-	orangefs_flush_inode(inode);
-
 	/*
 	 * remove all associated inode pages from the page cache and
 	 * readahead cache (if any); this forces an expensive refresh of
@@ -666,8 +670,6 @@ static int orangefs_fsync(struct file *file,
 		     ret);
 
 	op_release(new_op);
-
-	orangefs_flush_inode(file_inode(file));
 	return ret;
 }
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 336ecbf8c268..e4a8e6a7eb17 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * (C) 2001 Clemson University and The University of Chicago
  *

commit 49e5571324a81ddbb0d06ff38f698534a2a47e33
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Apr 12 08:06:02 2017 -0400

    orangefs: don't call filemap_write_and_wait from fsync
    
    Orangefs doesn't do buffered writes yet, so there's no point in
    initiating and waiting for writeback.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 28f38d813ad2..336ecbf8c268 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -646,14 +646,11 @@ static int orangefs_fsync(struct file *file,
 		       loff_t end,
 		       int datasync)
 {
-	int ret = -EINVAL;
+	int ret;
 	struct orangefs_inode_s *orangefs_inode =
 		ORANGEFS_I(file_inode(file));
 	struct orangefs_kernel_op_s *new_op = NULL;
 
-	/* required call */
-	filemap_write_and_wait_range(file->f_mapping, start, end);
-
 	new_op = op_alloc(ORANGEFS_VFS_OP_FSYNC);
 	if (!new_op)
 		return -ENOMEM;

commit aeced66196460a04644538f4985192ce6be6acc0
Merge: 414975eb7644 2f713b5c7d2a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 5 13:36:10 2017 -0700

    Merge tag 'for-linus-4.12-ofs-1' of git://git.kernel.org/pub/scm/linux/kernel/git/hubcap/linux
    
    Pull orangefs updates from Mike Marshall:
     "Orangefs cleanups, fixes and statx support.
    
      Some cleanups:
    
       - remove unused get_fsid_from_ino
       - fix bounds check for listxattr
       - clean up oversize xattr validation
       - do not set getattr_time on orangefs_lookup
       - return from orangefs_devreq_read quickly if possible
       - do not wait for timeout if umounting
       - handle zero size write in debugfs
    
      Bug fixes:
    
       - do not check possibly stale size on truncate
       - ensure the userspace component is unmounted if mount fails
       - total reimplementation of dir.c
    
      New feature:
    
       - implement statx
    
      The new implementation of dir.c is kind of a big deal, all new code.
      It has been posted to fs-devel during the previous rc period, we
      didn't get much review or feedback from there, but it has been
      reviewed very heavily here, so much so that we have two entire
      versions of the reimplementation.
    
      Not only does the new implementation fix some xfstests, but it passes
      all the new tests we made here that involve seeking and rewinding and
      giant directories and long file names. The new dir code has three
      patches itself:
    
       - skip forward to the next directory entry if seek is short
       - invalidate stored directory on seek
       - count directory pieces correctly"
    
    * tag 'for-linus-4.12-ofs-1' of git://git.kernel.org/pub/scm/linux/kernel/git/hubcap/linux:
      orangefs: count directory pieces correctly
      orangefs: invalidate stored directory on seek
      orangefs: skip forward to the next directory entry if seek is short
      orangefs: handle zero size write in debugfs
      orangefs: do not wait for timeout if umounting
      orangefs: return from orangefs_devreq_read quickly if possible
      orangefs: ensure the userspace component is unmounted if mount fails
      orangefs: do not check possibly stale size on truncate
      orangefs: implement statx
      orangefs: remove ORANGEFS_READDIR macros
      orangefs: support very large directories
      orangefs: support llseek on directories
      orangefs: rewrite readdir to fix several bugs
      orangefs: do not set getattr_time on orangefs_lookup
      orangefs: clean up oversize xattr validation
      orangefs: fix bounds check for listxattr
      orangefs: remove unused get_fsid_from_ino

commit 68a24a6cc4a6025e111c282186a2506281d79b4b
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 25 15:38:03 2017 -0400

    orangefs: implement statx
    
    Fortunately OrangeFS has had a getattr request mask for a long time.
    
    The server basically has two difficulty levels for attributes.  Fetching
    any attribute except size requires communicating with the metadata
    server for that handle.  Since all the attributes are right there, it
    makes sense to return them all.  Fetching the size requires
    communicating with every I/O server (that the file is distributed
    across).  Therefore if asked for anything except size, get everything
    except size, and if asked for size, get everything.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index e6bbc8083d77..b421df11fe95 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -475,7 +475,8 @@ static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *ite
 
 	/* Make sure generic_write_checks sees an up to date inode size. */
 	if (file->f_flags & O_APPEND) {
-		rc = orangefs_inode_getattr(file->f_mapping->host, 0, 1);
+		rc = orangefs_inode_getattr(file->f_mapping->host, 0, 1,
+		    STATX_SIZE);
 		if (rc == -ESTALE)
 			rc = -EIO;
 		if (rc) {
@@ -693,7 +694,8 @@ static loff_t orangefs_file_llseek(struct file *file, loff_t offset, int origin)
 		 * NOTE: We are only interested in file size here,
 		 * so we set mask accordingly.
 		 */
-		ret = orangefs_inode_getattr(file->f_mapping->host, 0, 1);
+		ret = orangefs_inode_getattr(file->f_mapping->host, 0, 1,
+		    STATX_SIZE);
 		if (ret == -ESTALE)
 			ret = -EIO;
 		if (ret) {

commit c63ed807d1fca901d6b463deb3ceeced4969384e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Apr 13 03:12:24 2017 -0400

    orangefs: use iov_iter_revert()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index e6bbc8083d77..1cd37ebc4f25 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -114,7 +114,6 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_khandle *handle = &orangefs_inode->refn.khandle;
 	struct orangefs_kernel_op_s *new_op = NULL;
-	struct iov_iter saved = *iter;
 	int buffer_index = -1;
 	ssize_t ret;
 
@@ -193,7 +192,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 		orangefs_bufmap_put(buffer_index);
 		buffer_index = -1;
 		if (type == ORANGEFS_IO_WRITE)
-			*iter = saved;
+			iov_iter_revert(iter, total_size);
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s:going to repopulate_shared_memory.\n",
 			     __func__);

commit 450630975da9e7dffe540753e169dc4da5fe7c29
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Dec 4 18:24:56 2016 -0500

    don't open-code file_inode()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 02cc6139ec90..e6bbc8083d77 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -724,7 +724,7 @@ static int orangefs_lock(struct file *filp, int cmd, struct file_lock *fl)
 {
 	int rc = -EINVAL;
 
-	if (ORANGEFS_SB(filp->f_inode->i_sb)->flags & ORANGEFS_OPT_LOCAL_LOCK) {
+	if (ORANGEFS_SB(file_inode(filp)->i_sb)->flags & ORANGEFS_OPT_LOCAL_LOCK) {
 		if (cmd == F_GETLK) {
 			rc = 0;
 			posix_test_lock(filp, fl);

commit d62a9025aee446994a706c711e45c6a655d9d348
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Oct 21 07:33:57 2016 +0300

    orangefs: user file_inode() where it is due
    
    Replace wrong use of file->f_path.dentry->d_inode with file_inode(file).
    In case orangefs ever finds itself as an overelayfs layer, it would want
    to get its own inode and not overlayfs's inode.
    
    DISCLAIMER: I did not test this patch because I do not know how to setup
                an orangefs mount
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 66ea0cc37b18..02cc6139ec90 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -621,9 +621,9 @@ static int orangefs_file_release(struct inode *inode, struct file *file)
 	 * readahead cache (if any); this forces an expensive refresh of
 	 * data for the next caller of mmap (or 'get_block' accesses)
 	 */
-	if (file->f_path.dentry->d_inode &&
-	    file->f_path.dentry->d_inode->i_mapping &&
-	    mapping_nrpages(&file->f_path.dentry->d_inode->i_data)) {
+	if (file_inode(file) &&
+	    file_inode(file)->i_mapping &&
+	    mapping_nrpages(&file_inode(file)->i_data)) {
 		if (orangefs_features & ORANGEFS_FEATURE_READAHEAD) {
 			gossip_debug(GOSSIP_INODE_DEBUG,
 			    "calling flush_racache on %pU\n",
@@ -632,7 +632,7 @@ static int orangefs_file_release(struct inode *inode, struct file *file)
 			gossip_debug(GOSSIP_INODE_DEBUG,
 			    "flush_racache finished\n");
 		}
-		truncate_inode_pages(file->f_path.dentry->d_inode->i_mapping,
+		truncate_inode_pages(file_inode(file)->i_mapping,
 				     0);
 	}
 	return 0;
@@ -648,7 +648,7 @@ static int orangefs_fsync(struct file *file,
 {
 	int ret = -EINVAL;
 	struct orangefs_inode_s *orangefs_inode =
-		ORANGEFS_I(file->f_path.dentry->d_inode);
+		ORANGEFS_I(file_inode(file));
 	struct orangefs_kernel_op_s *new_op = NULL;
 
 	/* required call */
@@ -661,7 +661,7 @@ static int orangefs_fsync(struct file *file,
 
 	ret = service_operation(new_op,
 			"orangefs_fsync",
-			get_interruptible_flag(file->f_path.dentry->d_inode));
+			get_interruptible_flag(file_inode(file)));
 
 	gossip_debug(GOSSIP_FILE_DEBUG,
 		     "orangefs_fsync got return value of %d\n",
@@ -669,7 +669,7 @@ static int orangefs_fsync(struct file *file,
 
 	op_release(new_op);
 
-	orangefs_flush_inode(file->f_path.dentry->d_inode);
+	orangefs_flush_inode(file_inode(file));
 	return ret;
 }
 

commit 101105b1717f536ca741f940033996302d4ef191
Merge: 35ff96dfd3c9 3873691e5ab3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 20:16:43 2016 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull more vfs updates from Al Viro:
     ">rename2() work from Miklos + current_time() from Deepa"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs: Replace current_fs_time() with current_time()
      fs: Replace CURRENT_TIME_SEC with current_time() for inode timestamps
      fs: Replace CURRENT_TIME with current_time() for inode timestamps
      fs: proc: Delete inode time initializations in proc_alloc_inode()
      vfs: Add current_time() api
      vfs: add note about i_op->rename changes to porting
      fs: rename "rename2" i_op to "rename"
      vfs: remove unused i_op->rename
      fs: make remaining filesystems use .rename2
      libfs: support RENAME_NOREPLACE in simple_rename()
      fs: support RENAME_NOREPLACE for local filesystems
      ncpfs: fix unused variable warning

commit abb5a14fa20fdd400995926134b7be9eb8ce6048
Merge: 911f9dab301e e55f1d1d13e7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 13:04:49 2016 -0700

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "Assorted misc bits and pieces.
    
      There are several single-topic branches left after this (rename2
      series from Miklos, current_time series from Deepa Dinamani, xattr
      series from Andreas, uaccess stuff from from me) and I'd prefer to
      send those separately"
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (39 commits)
      proc: switch auxv to use of __mem_open()
      hpfs: support FIEMAP
      cifs: get rid of unused arguments of CIFSSMBWrite()
      posix_acl: uapi header split
      posix_acl: xattr representation cleanups
      fs/aio.c: eliminate redundant loads in put_aio_ring_file
      fs/internal.h: add const to ns_dentry_operations declaration
      compat: remove compat_printk()
      fs/buffer.c: make __getblk_slow() static
      proc: unsigned file descriptors
      fs/file: more unsigned file descriptors
      fs: compat: remove redundant check of nr_segs
      cachefiles: Fix attempt to read i_blocks after deleting file [ver #2]
      cifs: don't use memcpy() to copy struct iov_iter
      get rid of separate multipage fault-in primitives
      fs: Avoid premature clearing of capabilities
      fs: Give dentry to inode_change_ok() instead of inode
      fuse: Propagate dentry down to inode_change_ok()
      ceph: Propagate dentry down to inode_change_ok()
      xfs: Propagate dentry down to inode_change_ok()
      ...

commit b78b11985a36bfe768add17ffb70bbaf9d8d7627
Merge: f808e138c0ab 1d503617884e
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Wed Sep 28 14:50:46 2016 -0400

    Merge branch 'misc' into for-next
    
    Pull in an OrangeFS branch containing miscellaneous improvements.
    
    - clean up debugfs globals
    - remove dead code in sysfs
    - reorganize duplicated sysfs attribute structs
    - consolidate sysfs show and store functions
    - remove duplicated sysfs_ops structures
    - describe organization of sysfs
    - make devreq_mutex static
    - g_orangefs_stats -> orangefs_stats for consistency
    - rename most remaining global variables

commit 078cd8279e659989b103359bb22373cc79445bde
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Wed Sep 14 07:48:04 2016 -0700

    fs: Replace CURRENT_TIME with current_time() for inode timestamps
    
    CURRENT_TIME macro is not appropriate for filesystems as it
    doesn't use the right granularity for filesystem timestamps.
    Use current_time() instead.
    
    CURRENT_TIME is also not y2038 safe.
    
    This is also in preparation for the patch that transitions
    vfs timestamps to use 64 bit time and hence make them
    y2038 safe. As part of the effort current_time() will be
    extended to do range checks. Hence, it is necessary for all
    file system timestamps to use current_time(). Also,
    current_time() will be transitioned along with vfs to be
    y2038 safe.
    
    Note that whenever a single call to current_time() is used
    to change timestamps in different inodes, it is because they
    share the same time granularity.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Felipe Balbi <balbi@kernel.org>
    Acked-by: Steven Whitehouse <swhiteho@redhat.com>
    Acked-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Acked-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 526040e09f78..e799bb4474f6 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -358,7 +358,7 @@ static ssize_t do_readv_writev(enum ORANGEFS_io_type type, struct file *file,
 			file_accessed(file);
 		} else {
 			SetMtimeFlag(orangefs_inode);
-			inode->i_mtime = CURRENT_TIME;
+			inode->i_mtime = current_time(inode);
 			mark_inode_dirty_sync(inode);
 		}
 	}

commit 889d5f1baca698a4510174cdd6a6596997d0deb4
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Aug 15 15:33:42 2016 -0400

    orangefs: g_orangefs_stats -> orangefs_stats for consistency
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 43c08b5c7168..0578b99f5471 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -412,7 +412,7 @@ ssize_t orangefs_inode_read(struct inode *inode,
 	size_t bufmap_size;
 	ssize_t ret = -EINVAL;
 
-	g_orangefs_stats.reads++;
+	orangefs_stats.reads++;
 
 	bufmap_size = orangefs_bufmap_size_query();
 	if (count > bufmap_size) {
@@ -453,7 +453,7 @@ static ssize_t orangefs_file_read_iter(struct kiocb *iocb, struct iov_iter *iter
 
 	gossip_debug(GOSSIP_FILE_DEBUG, "orangefs_file_read_iter\n");
 
-	g_orangefs_stats.reads++;
+	orangefs_stats.reads++;
 
 	rc = do_readv_writev(ORANGEFS_IO_READ, file, &pos, iter);
 	iocb->ki_pos = pos;
@@ -514,7 +514,7 @@ static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *ite
 	}
 
 	iocb->ki_pos = pos;
-	g_orangefs_stats.writes++;
+	orangefs_stats.writes++;
 
 out:
 

commit c51e012942a7594f59db5611db14fa4a29624a10
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Aug 12 16:12:09 2016 -0400

    orangefs: do not allow client readahead cache without feature bit
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 43c08b5c7168..fe5e1eac9561 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -624,11 +624,14 @@ static int orangefs_file_release(struct inode *inode, struct file *file)
 	if (file->f_path.dentry->d_inode &&
 	    file->f_path.dentry->d_inode->i_mapping &&
 	    mapping_nrpages(&file->f_path.dentry->d_inode->i_data)) {
-		gossip_debug(GOSSIP_INODE_DEBUG,
-		    "calling flush_racache on %pU\n",
-		    get_khandle_from_ino(inode));
-		flush_racache(inode);
-		gossip_debug(GOSSIP_INODE_DEBUG, "flush_racache finished\n");
+		if (orangefs_features & ORANGEFS_FEATURE_READAHEAD) {
+			gossip_debug(GOSSIP_INODE_DEBUG,
+			    "calling flush_racache on %pU\n",
+			    get_khandle_from_ino(inode));
+			flush_racache(inode);
+			gossip_debug(GOSSIP_INODE_DEBUG,
+			    "flush_racache finished\n");
+		}
 		truncate_inode_pages(file->f_path.dentry->d_inode->i_mapping,
 				     0);
 	}

commit ed1e158777fa73ac577dcd4f67062b944b587493
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Aug 2 16:32:15 2016 -0400

    orangefs: re-add flush_racache from out-of-tree
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index c14eab567f56..43c08b5c7168 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -14,6 +14,32 @@
 #include <linux/fs.h>
 #include <linux/pagemap.h>
 
+static int flush_racache(struct inode *inode)
+{
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_kernel_op_s *new_op;
+	int ret;
+
+	gossip_debug(GOSSIP_UTILS_DEBUG,
+	    "%s: %pU: Handle is %pU | fs_id %d\n", __func__,
+	    get_khandle_from_ino(inode), &orangefs_inode->refn.khandle,
+	    orangefs_inode->refn.fs_id);
+
+	new_op = op_alloc(ORANGEFS_VFS_OP_RA_FLUSH);
+	if (!new_op)
+		return -ENOMEM;
+	new_op->upcall.req.ra_cache_flush.refn = orangefs_inode->refn;
+
+	ret = service_operation(new_op, "orangefs_flush_racache",
+	    get_interruptible_flag(inode));
+
+	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: got return value of %d\n",
+	    __func__, ret);
+
+	op_release(new_op);
+	return ret;
+}
+
 /*
  * Copy to client-core's address space from the buffers specified
  * by the iovec upto total_size bytes.
@@ -597,9 +623,15 @@ static int orangefs_file_release(struct inode *inode, struct file *file)
 	 */
 	if (file->f_path.dentry->d_inode &&
 	    file->f_path.dentry->d_inode->i_mapping &&
-	    mapping_nrpages(&file->f_path.dentry->d_inode->i_data))
+	    mapping_nrpages(&file->f_path.dentry->d_inode->i_data)) {
+		gossip_debug(GOSSIP_INODE_DEBUG,
+		    "calling flush_racache on %pU\n",
+		    get_khandle_from_ino(inode));
+		flush_racache(inode);
+		gossip_debug(GOSSIP_INODE_DEBUG, "flush_racache finished\n");
 		truncate_inode_pages(file->f_path.dentry->d_inode->i_mapping,
 				     0);
+	}
 	return 0;
 }
 

commit 6eaff8c7775abcdff5ba7c9f0305f4ccdca57ba5
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Aug 2 14:31:05 2016 -0400

    orangefs: rename remaining bits of mmap readahead cache
    
    This has been dormant code for many years. Parts of it were removed from
    the OrangeFS kernel code when it went into mainline. These bits were missed.
    Now the readahead cache has been resurrected in the OrangeFS userspace
    portions. It was renamed there, since it doesn't really have anything to do
    with mmap specifically, so it will be renamed here.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 526040e09f78..c14eab567f56 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -591,7 +591,7 @@ static int orangefs_file_release(struct inode *inode, struct file *file)
 	orangefs_flush_inode(inode);
 
 	/*
-	 * remove all associated inode pages from the page cache and mmap
+	 * remove all associated inode pages from the page cache and
 	 * readahead cache (if any); this forces an expensive refresh of
 	 * data for the next caller of mmap (or 'get_block' accesses)
 	 */

commit f66debf1b3755039680289d83fe7a92a4ad3d77d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Aug 7 12:20:01 2016 -0400

    orangefs: use %pd/%pD
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 526040e09f78..f3c5b48e0432 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -585,8 +585,8 @@ static int orangefs_file_mmap(struct file *file, struct vm_area_struct *vma)
 static int orangefs_file_release(struct inode *inode, struct file *file)
 {
 	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "orangefs_file_release: called on %s\n",
-		     file->f_path.dentry->d_name.name);
+		     "orangefs_file_release: called on %pD\n",
+		     file);
 
 	orangefs_flush_inode(inode);
 

commit d373a712c1142a4e119e359df63c192afa9bb2fb
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Sat Jun 4 11:02:33 2016 +0200

    orangefs: Remove useless xattr prefix arguments
    
    Mike,
    
    On Fri, Jun 3, 2016 at 9:44 PM, Mike Marshall <hubcap@omnibond.com> wrote:
    > We use the return value in this one line you changed, our userspace code gets
    > ill when we send it (-ENOMEM +1) as a key length...
    
    ah, my mistake.  Here's a fixed version.
    
    Thanks,
    Andreas
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 5160a3f27e71..526040e09f78 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -516,7 +516,6 @@ static long orangefs_ioctl(struct file *file, unsigned int cmd, unsigned long ar
 	if (cmd == FS_IOC_GETFLAGS) {
 		val = 0;
 		ret = orangefs_inode_getxattr(file_inode(file),
-					      "",
 					      "user.pvfs2.meta_hint",
 					      &val, sizeof(val));
 		if (ret < 0 && ret != -ENODATA)
@@ -549,7 +548,6 @@ static long orangefs_ioctl(struct file *file, unsigned int cmd, unsigned long ar
 			     "orangefs_ioctl: FS_IOC_SETFLAGS: %llu\n",
 			     (unsigned long long)val);
 		ret = orangefs_inode_setxattr(file_inode(file),
-					      "",
 					      "user.pvfs2.meta_hint",
 					      &val, sizeof(val), 0);
 	}

commit 972a7344fcb54e0aabe78cfac5abb531fc6299ab
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Mon May 30 11:25:59 2016 +0200

    orangefs: Remove useless defines
    
    The ORANGEFS_XATTR_INDEX_ defines are unused; the ORANGEFS_XATTR_NAME_
    defines only obfuscate the code.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 491e82c6f705..5160a3f27e71 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -516,7 +516,7 @@ static long orangefs_ioctl(struct file *file, unsigned int cmd, unsigned long ar
 	if (cmd == FS_IOC_GETFLAGS) {
 		val = 0;
 		ret = orangefs_inode_getxattr(file_inode(file),
-					      ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
+					      "",
 					      "user.pvfs2.meta_hint",
 					      &val, sizeof(val));
 		if (ret < 0 && ret != -ENODATA)
@@ -549,7 +549,7 @@ static long orangefs_ioctl(struct file *file, unsigned int cmd, unsigned long ar
 			     "orangefs_ioctl: FS_IOC_SETFLAGS: %llu\n",
 			     (unsigned long long)val);
 		ret = orangefs_inode_setxattr(file_inode(file),
-					      ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
+					      "",
 					      "user.pvfs2.meta_hint",
 					      &val, sizeof(val), 0);
 	}

commit 5ecfcb265f1e77d5de0140d21de3f8ab25441df7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Apr 12 00:43:20 2016 -0400

    orangefs: don't open-code inode_lock/inode_unlock
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index ae92795ed965..491e82c6f705 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -445,7 +445,7 @@ static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *ite
 
 	gossip_debug(GOSSIP_FILE_DEBUG, "orangefs_file_write_iter\n");
 
-	mutex_lock(&file->f_mapping->host->i_mutex);
+	inode_lock(file->f_mapping->host);
 
 	/* Make sure generic_write_checks sees an up to date inode size. */
 	if (file->f_flags & O_APPEND) {
@@ -492,7 +492,7 @@ static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *ite
 
 out:
 
-	mutex_unlock(&file->f_mapping->host->i_mutex);
+	inode_unlock(file->f_mapping->host);
 	return rc;
 }
 

commit 6d4c1a30b32a377083900f39c42bcacb633f99a1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Feb 16 20:15:43 2016 -0500

    orangefs: fix do_readv_writev() handling of error halfway through
    
    Error should only be returned if nothing had been read/written.
    Otherwise we need to report a short read/write instead.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index cb6a164b2718..ae92795ed965 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -350,9 +350,9 @@ static ssize_t do_readv_writev(enum ORANGEFS_io_type type, struct file *file,
 			break;
 	} /*end while */
 
+out:
 	if (total_count > 0)
 		ret = total_count;
-out:
 	if (ret > 0) {
 		if (type == ORANGEFS_IO_READ) {
 			file_accessed(file);

commit 177f8fc491e230c2e7a3ac7d5626dd6f3d94e9f2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Feb 16 20:25:19 2016 -0500

    orangefs: sanitize ->llseek()
    
    a) open files can't have NULL inodes
    b) it's SEEK_END, not ORANGEFS_SEEK_END; no need to get cute.
    c) make_bad_inode() on lseek()?
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 63e6a10ab13d..cb6a164b2718 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -652,14 +652,9 @@ static int orangefs_fsync(struct file *file,
 static loff_t orangefs_file_llseek(struct file *file, loff_t offset, int origin)
 {
 	int ret = -EINVAL;
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = file_inode(file);
 
-	if (!inode) {
-		gossip_err("orangefs_file_llseek: invalid inode (NULL)\n");
-		return ret;
-	}
-
-	if (origin == ORANGEFS_SEEK_END) {
+	if (origin == SEEK_END) {
 		/*
 		 * revalidate the inode's file size.
 		 * NOTE: We are only interested in file size here,
@@ -674,7 +669,6 @@ static loff_t orangefs_file_llseek(struct file *file, loff_t offset, int origin)
 				     __FILE__,
 				     __func__,
 				     __LINE__);
-			orangefs_make_bad_inode(inode);
 			return ret;
 		}
 	}
@@ -684,7 +678,7 @@ static loff_t orangefs_file_llseek(struct file *file, loff_t offset, int origin)
 		     " | inode size is %lu\n",
 		     (long)offset,
 		     origin,
-		     (unsigned long)file->f_path.dentry->d_inode->i_size);
+		     (unsigned long)i_size_read(inode));
 
 	return generic_file_llseek(file, offset, origin);
 }

commit b8a99a8f9f0aebf2a75bb0d9280bff7e7ac9b57e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Feb 16 20:10:26 2016 -0500

    orangefs: saner calling conventions for getting a slot
    
    just have it return the slot number or -E... - the caller checks
    the sign anyway
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index db9dd6ebcc3f..63e6a10ab13d 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -87,7 +87,6 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_khandle *handle = &orangefs_inode->refn.khandle;
-	struct orangefs_bufmap *bufmap = NULL;
 	struct orangefs_kernel_op_s *new_op = NULL;
 	struct iov_iter saved = *iter;
 	int buffer_index = -1;
@@ -104,11 +103,12 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 
 populate_shared_memory:
 	/* get a shared buffer index */
-	ret = orangefs_bufmap_get(&bufmap, &buffer_index);
-	if (ret < 0) {
+	buffer_index = orangefs_bufmap_get();
+	if (buffer_index < 0) {
+		ret = buffer_index;
 		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "%s: orangefs_bufmap_get failure (%ld)\n",
-			     __func__, (long)ret);
+			     "%s: orangefs_bufmap_get failure (%zd)\n",
+			     __func__, ret);
 		goto out;
 	}
 	gossip_debug(GOSSIP_FILE_DEBUG,

commit bf6bf606e545cb31c29499b354c13b2621acd649
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Feb 16 20:06:19 2016 -0500

    orangefs_copy_{to,from}_bufmap(): don't pass bufmap pointer
    
    it's always __orangefs_bufmap
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index d4a00ad26f6e..db9dd6ebcc3f 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -21,8 +21,7 @@
  *       can futher be kernel-space or user-space addresses.
  *       or it can pointers to struct page's
  */
-static int precopy_buffers(struct orangefs_bufmap *bufmap,
-			   int buffer_index,
+static int precopy_buffers(int buffer_index,
 			   struct iov_iter *iter,
 			   size_t total_size)
 {
@@ -34,8 +33,7 @@ static int precopy_buffers(struct orangefs_bufmap *bufmap,
 
 
 	if (total_size) {
-		ret = orangefs_bufmap_copy_from_iovec(bufmap,
-						      iter,
+		ret = orangefs_bufmap_copy_from_iovec(iter,
 						      buffer_index,
 						      total_size);
 		if (ret < 0)
@@ -58,8 +56,7 @@ static int precopy_buffers(struct orangefs_bufmap *bufmap,
  *       can futher be kernel-space or user-space addresses.
  *       or it can pointers to struct page's
  */
-static int postcopy_buffers(struct orangefs_bufmap *bufmap,
-			    int buffer_index,
+static int postcopy_buffers(int buffer_index,
 			    struct iov_iter *iter,
 			    size_t total_size)
 {
@@ -70,8 +67,7 @@ static int postcopy_buffers(struct orangefs_bufmap *bufmap,
 	 * struct page pointers.
 	 */
 	if (total_size) {
-		ret = orangefs_bufmap_copy_to_iovec(bufmap,
-						    iter,
+		ret = orangefs_bufmap_copy_to_iovec(iter,
 						    buffer_index,
 						    total_size);
 		if (ret < 0)
@@ -138,8 +134,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 	 * precopy_buffers only pertains to writes.
 	 */
 	if (type == ORANGEFS_IO_WRITE) {
-		ret = precopy_buffers(bufmap,
-				      buffer_index,
+		ret = precopy_buffers(buffer_index,
 				      iter,
 				      total_size);
 		if (ret < 0)
@@ -242,8 +237,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 	 * postcopy_buffers only pertains to reads.
 	 */
 	if (type == ORANGEFS_IO_READ) {
-		ret = postcopy_buffers(bufmap,
-				       buffer_index,
+		ret = postcopy_buffers(buffer_index,
 				       iter,
 				       new_op->downcall.resp.io.amt_complete);
 		if (ret < 0)

commit e2f7f0d798497f7e2f9296f706ff3263ede0b044
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Mar 15 12:33:20 2016 -0400

    orangefs: use new orangefs_inode_getattr to get size in write and llseek
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 3aff671534d0..d4a00ad26f6e 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -455,11 +455,12 @@ static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *ite
 
 	/* Make sure generic_write_checks sees an up to date inode size. */
 	if (file->f_flags & O_APPEND) {
-		rc = orangefs_inode_old_getattr(file->f_mapping->host,
-					 ORANGEFS_ATTR_SYS_SIZE, 0);
+		rc = orangefs_inode_getattr(file->f_mapping->host, 0, 1);
+		if (rc == -ESTALE)
+			rc = -EIO;
 		if (rc) {
-			gossip_err("%s: orangefs_inode_old_getattr failed, rc:%zd:.\n",
-				   __func__, rc);
+			gossip_err("%s: orangefs_inode_getattr failed, "
+			    "rc:%zd:.\n", __func__, rc);
 			goto out;
 		}
 	}
@@ -670,8 +671,9 @@ static loff_t orangefs_file_llseek(struct file *file, loff_t offset, int origin)
 		 * NOTE: We are only interested in file size here,
 		 * so we set mask accordingly.
 		 */
-		ret = orangefs_inode_old_getattr(inode,
-		    ORANGEFS_ATTR_SYS_SIZE, 0);
+		ret = orangefs_inode_getattr(file->f_mapping->host, 0, 1);
+		if (ret == -ESTALE)
+			ret = -EIO;
 		if (ret) {
 			gossip_debug(GOSSIP_FILE_DEBUG,
 				     "%s:%s:%d calling make bad inode\n",

commit 3c9cf98d7b4f27e4303ea6e67db7f0c343a575b6
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Mar 15 11:28:20 2016 -0400

    orangefs: rename orangefs_inode_getattr to orangefs_inode_old_getattr
    
    This is motivated by orangefs_inode_old_getattr's habit of writing over
    live inodes.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 9b561b7894b3..3aff671534d0 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -455,10 +455,10 @@ static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *ite
 
 	/* Make sure generic_write_checks sees an up to date inode size. */
 	if (file->f_flags & O_APPEND) {
-		rc = orangefs_inode_getattr(file->f_mapping->host,
+		rc = orangefs_inode_old_getattr(file->f_mapping->host,
 					 ORANGEFS_ATTR_SYS_SIZE, 0);
 		if (rc) {
-			gossip_err("%s: orangefs_inode_getattr failed, rc:%zd:.\n",
+			gossip_err("%s: orangefs_inode_old_getattr failed, rc:%zd:.\n",
 				   __func__, rc);
 			goto out;
 		}
@@ -670,7 +670,8 @@ static loff_t orangefs_file_llseek(struct file *file, loff_t offset, int origin)
 		 * NOTE: We are only interested in file size here,
 		 * so we set mask accordingly.
 		 */
-		ret = orangefs_inode_getattr(inode, ORANGEFS_ATTR_SYS_SIZE, 0);
+		ret = orangefs_inode_old_getattr(inode,
+		    ORANGEFS_ATTR_SYS_SIZE, 0);
 		if (ret) {
 			gossip_debug(GOSSIP_FILE_DEBUG,
 				     "%s:%s:%d calling make bad inode\n",

commit 162ada7764162eb2eb0a02546f820ca8b099cdea
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Mar 9 13:12:37 2016 -0500

    Orangefs: improve the POSIXness of interrupted writes...
    
    Don't return EINTR on interrupted writes if some data has already
    been written.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 6f2e0f745c5d..9b561b7894b3 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -180,21 +180,57 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 	}
 
 	if (ret < 0) {
-		/*
-		 * don't write an error to syslog on signaled operation
-		 * termination unless we've got debugging turned on, as
-		 * this can happen regularly (i.e. ctrl-c)
-		 */
-		if (ret == -EINTR)
+		if (ret == -EINTR) {
+			/*
+			 * We can't return EINTR if any data was written,
+			 * it's not POSIX. It is minimally acceptable
+			 * to give a partial write, the way NFS does.
+			 *
+			 * It would be optimal to return all or nothing,
+			 * but if a userspace write is bigger than
+			 * an IO buffer, and the interrupt occurs
+			 * between buffer writes, that would not be
+			 * possible.
+			 */
+			switch (new_op->op_state - OP_VFS_STATE_GIVEN_UP) {
+			/*
+			 * If the op was waiting when the interrupt
+			 * occurred, then the client-core did not
+			 * trigger the write.
+			 */
+			case OP_VFS_STATE_WAITING:
+				if (*offset == 0)
+					ret = -EINTR;
+				else
+					ret = 0;
+				break;
+			/* 
+			 * If the op was in progress when the interrupt
+			 * occurred, then the client-core was able to
+			 * trigger the write.
+			 */
+			case OP_VFS_STATE_INPROGR:
+				ret = total_size;
+				break;
+			default:
+				gossip_err("%s: unexpected op state :%d:.\n",
+					   __func__,
+					   new_op->op_state);
+				ret = 0;
+				break;
+			}
 			gossip_debug(GOSSIP_FILE_DEBUG,
-				     "%s: returning error %ld\n", __func__,
-				     (long)ret);
-		else
+				     "%s: got EINTR, state:%d: %p\n",
+				     __func__,
+				     new_op->op_state,
+				     new_op);
+		} else {
 			gossip_err("%s: error in %s handle %pU, returning %zd\n",
 				__func__,
 				type == ORANGEFS_IO_READ ?
 					"read from" : "write to",
 				handle, ret);
+		}
 		if (orangefs_cancel_op_in_progress(new_op))
 			return ret;
 

commit 9d9e7ba9ee8f304c4608f3c81aa5e7fb3bddd251
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Thu Mar 3 13:46:48 2016 -0500

    Orangefs: improve gossip statements
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 399d5288dc1a..6f2e0f745c5d 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -214,18 +214,14 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 			goto out;
 	}
 	gossip_debug(GOSSIP_FILE_DEBUG,
-	    "%s(%pU): Amount written as returned by the sys-io call:%d\n",
+	    "%s(%pU): Amount %s, returned by the sys-io call:%d\n",
 	    __func__,
 	    handle,
+	    type == ORANGEFS_IO_READ ?  "read" : "written",
 	    (int)new_op->downcall.resp.io.amt_complete);
 
 	ret = new_op->downcall.resp.io.amt_complete;
 
-	/*
-	 * tell the device file owner waiting on I/O that this read has
-	 * completed and it can return now.
-	 */
-
 out:
 	if (buffer_index >= 0) {
 		orangefs_bufmap_put(buffer_index);

commit 9c2bcf288ed7f600bc3f8e7541ea0522a8912bae
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Sat Feb 20 14:26:01 2016 -0500

    orangefs: remove vestigial async io code
    
    I have verified that there is nothing in the userspace daemon version we
    are implementing this protocol against that ever looks at this field.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 4eb009e8f19f..399d5288dc1a 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -102,7 +102,6 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 		return -ENOMEM;
 
 	/* synchronous I/O */
-	new_op->upcall.req.io.async_vfs_io = ORANGEFS_VFS_SYNC_IO;
 	new_op->upcall.req.io.readahead_size = readahead_size;
 	new_op->upcall.req.io.io_type = type;
 	new_op->upcall.req.io.refn = orangefs_inode->refn;

commit 897c5df6cf8c10d2557c098641faa62f65ef8598
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Feb 13 21:06:50 2016 -0500

    orangefs: get rid of op->done
    
    shouldn't be needed now
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 3b1e9e83eb91..4eb009e8f19f 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -199,7 +199,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 		if (orangefs_cancel_op_in_progress(new_op))
 			return ret;
 
-		goto done_copying;
+		goto out;
 	}
 
 	/*
@@ -212,7 +212,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 				       iter,
 				       new_op->downcall.resp.io.amt_complete);
 		if (ret < 0)
-			goto done_copying;
+			goto out;
 	}
 	gossip_debug(GOSSIP_FILE_DEBUG,
 	    "%s(%pU): Amount written as returned by the sys-io call:%d\n",
@@ -222,12 +222,10 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 
 	ret = new_op->downcall.resp.io.amt_complete;
 
-done_copying:
 	/*
 	 * tell the device file owner waiting on I/O that this read has
 	 * completed and it can return now.
 	 */
-	complete(&new_op->done);
 
 out:
 	if (buffer_index >= 0) {

commit 78699e29fd784a4613d254a22627f336c55c4a76
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Feb 11 23:07:19 2016 -0500

    orangefs: delay freeing slot until cancel completes
    
    Make cancels reuse the aborted read/write op, to make sure they do not
    fail on lack of memory.
    
    Don't issue a cancel unless the daemon has seen our read/write, has not
    replied and isn't being shut down.
    
    If cancel *is* issued, don't wait for it to complete; stash the slot
    in there and just have it freed when cancel is finally replied to or
    purged (and delay dropping the reference until then, obviously).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 193671c137c3..3b1e9e83eb91 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -181,17 +181,6 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 	}
 
 	if (ret < 0) {
-		/*
-		 * XXX: needs to be optimized - we only need to cancel if it
-		 * had been seen by daemon and not completed
-		 */
-		if (!op_state_serviced(new_op)) {
-			orangefs_cancel_op_in_progress(new_op->tag);
-		} else {
-			complete(&new_op->done);
-		}
-		orangefs_bufmap_put(buffer_index);
-		buffer_index = -1;
 		/*
 		 * don't write an error to syslog on signaled operation
 		 * termination unless we've got debugging turned on, as
@@ -207,7 +196,10 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 				type == ORANGEFS_IO_READ ?
 					"read from" : "write to",
 				handle, ret);
-		goto out;
+		if (orangefs_cancel_op_in_progress(new_op))
+			return ret;
+
+		goto done_copying;
 	}
 
 	/*

commit 1357d06d49d1f87af48ab768d34af55bff18b0c3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Feb 11 21:34:52 2016 -0500

    get rid of bufmap argument of orangefs_bufmap_put()
    
    it's always equal to __orangefs_bufmap and the latter can't change
    until we are done
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index dafa03ef0107..193671c137c3 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -170,7 +170,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 	 * a new shared memory location.
 	 */
 	if (ret == -EAGAIN && op_state_purged(new_op)) {
-		orangefs_bufmap_put(bufmap, buffer_index);
+		orangefs_bufmap_put(buffer_index);
 		buffer_index = -1;
 		if (type == ORANGEFS_IO_WRITE)
 			*iter = saved;
@@ -190,7 +190,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 		} else {
 			complete(&new_op->done);
 		}
-		orangefs_bufmap_put(bufmap, buffer_index);
+		orangefs_bufmap_put(buffer_index);
 		buffer_index = -1;
 		/*
 		 * don't write an error to syslog on signaled operation
@@ -239,7 +239,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 
 out:
 	if (buffer_index >= 0) {
-		orangefs_bufmap_put(bufmap, buffer_index);
+		orangefs_bufmap_put(buffer_index);
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s(%pU): PUT buffer_index %d\n",
 			     __func__, handle, buffer_index);

commit c0eae8cd77bc34b7e4c52037eeb53712f46fa05c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Feb 11 21:28:52 2016 -0500

    orangefs: get rid of handle_io_error()
    
    the second caller never needs to cancel, actually
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index c767ec746c76..dafa03ef0107 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -82,46 +82,6 @@ static int postcopy_buffers(struct orangefs_bufmap *bufmap,
 	return ret;
 }
 
-/*
- * handles two possible error cases, depending on context.
- *
- * by design, our vfs i/o errors need to be handled in one of two ways,
- * depending on where the error occured.
- *
- * if the error happens in the waitqueue code because we either timed
- * out or a signal was raised while waiting, we need to cancel the
- * userspace i/o operation and free the op manually.  this is done to
- * avoid having the device start writing application data to our shared
- * bufmap pages without us expecting it.
- *
- * FIXME: POSSIBLE OPTIMIZATION:
- * However, if we timed out or if we got a signal AND our upcall was never
- * picked off the queue (i.e. we were in OP_VFS_STATE_WAITING), then we don't
- * need to send a cancellation upcall. The way we can handle this is
- * set error_exit to 2 in such cases and 1 whenever cancellation has to be
- * sent and have handle_error
- * take care of this situation as well..
- *
- * if a orangefs sysint level error occured and i/o has been completed,
- * there is no need to cancel the operation, as the user has finished
- * using the bufmap page and so there is no danger in this case.  in
- * this case, we wake up the device normally so that it may free the
- * op, as normal.
- *
- * note the only reason this is a macro is because both read and write
- * cases need the exact same handling code.
- */
-#define handle_io_error()					\
-do {								\
-	if (!op_state_serviced(new_op)) {			\
-		orangefs_cancel_op_in_progress(new_op->tag);	\
-	} else {						\
-		complete(&new_op->done);			\
-	}							\
-	orangefs_bufmap_put(bufmap, buffer_index);		\
-	buffer_index = -1;					\
-} while (0)
-
 /*
  * Post and wait for the I/O upcall to finish
  */
@@ -221,7 +181,17 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 	}
 
 	if (ret < 0) {
-		handle_io_error();
+		/*
+		 * XXX: needs to be optimized - we only need to cancel if it
+		 * had been seen by daemon and not completed
+		 */
+		if (!op_state_serviced(new_op)) {
+			orangefs_cancel_op_in_progress(new_op->tag);
+		} else {
+			complete(&new_op->done);
+		}
+		orangefs_bufmap_put(bufmap, buffer_index);
+		buffer_index = -1;
 		/*
 		 * don't write an error to syslog on signaled operation
 		 * termination unless we've got debugging turned on, as
@@ -249,16 +219,8 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 				       buffer_index,
 				       iter,
 				       new_op->downcall.resp.io.amt_complete);
-		if (ret < 0) {
-			/*
-			 * put error codes in downcall so that handle_io_error()
-			 * preserves it properly
-			 */
-			WARN_ON(!op_state_serviced(new_op));
-			new_op->downcall.status = ret;
-			handle_io_error();
-			goto out;
-		}
+		if (ret < 0)
+			goto done_copying;
 	}
 	gossip_debug(GOSSIP_FILE_DEBUG,
 	    "%s(%pU): Amount written as returned by the sys-io call:%d\n",
@@ -268,6 +230,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 
 	ret = new_op->downcall.resp.io.amt_complete;
 
+done_copying:
 	/*
 	 * tell the device file owner waiting on I/O that this read has
 	 * completed and it can return now.

commit 7b9761af86b63baf4ce304fbdfdb87227d4bfbed
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Feb 7 01:25:06 2016 -0500

    orangefs: wait_for_direct_io(): restore the position in iter when restarting
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 40b38057b826..c767ec746c76 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -133,6 +133,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 	struct orangefs_khandle *handle = &orangefs_inode->refn.khandle;
 	struct orangefs_bufmap *bufmap = NULL;
 	struct orangefs_kernel_op_s *new_op = NULL;
+	struct iov_iter saved = *iter;
 	int buffer_index = -1;
 	ssize_t ret;
 
@@ -211,6 +212,8 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 	if (ret == -EAGAIN && op_state_purged(new_op)) {
 		orangefs_bufmap_put(bufmap, buffer_index);
 		buffer_index = -1;
+		if (type == ORANGEFS_IO_WRITE)
+			*iter = saved;
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s:going to repopulate_shared_memory.\n",
 			     __func__);

commit e17be9fd4d51302c41b17e22f9ec96751f47951b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Feb 6 14:59:38 2016 -0500

    orangefs: avoid freeing a slot twice in wait_for_direct_io()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index d865b58fb1fc..40b38057b826 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -210,6 +210,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 	 */
 	if (ret == -EAGAIN && op_state_purged(new_op)) {
 		orangefs_bufmap_put(bufmap, buffer_index);
+		buffer_index = -1;
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s:going to repopulate_shared_memory.\n",
 			     __func__);

commit 6ebcc3fcdac1f70078a02ab11f2aa5a88a4fdaee
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Thu Feb 4 16:28:31 2016 -0500

    Orangefs: added a couple of WARN_ONs, perhaps just temporarily.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 7e6fe8d8ab2b..d865b58fb1fc 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -250,6 +250,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 			 * put error codes in downcall so that handle_io_error()
 			 * preserves it properly
 			 */
+			WARN_ON(!op_state_serviced(new_op));
 			new_op->downcall.status = ret;
 			handle_io_error();
 			goto out;

commit 99109822f5cbe6d530eb55193b25aa5348f6134d
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Jan 28 10:19:40 2016 -0500

    orangefs: Fix revalidate.
    
    Previously, it would update a live inode. This was fixed, but it did not
    ever check that the inode attributes in the dcache are correct. This
    checks all inode attributes and rejects any that are not correct, which
    causes a lookup and thus a new getattr.
    
    Perhaps inode_operations->permission should replace or augment some of
    this.
    
    There is no actual caching, and this does a rather excessive amount of
    network operations back to the filesystem server.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index c585063d1100..7e6fe8d8ab2b 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -467,7 +467,7 @@ static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *ite
 	/* Make sure generic_write_checks sees an up to date inode size. */
 	if (file->f_flags & O_APPEND) {
 		rc = orangefs_inode_getattr(file->f_mapping->host,
-					 ORANGEFS_ATTR_SYS_SIZE);
+					 ORANGEFS_ATTR_SYS_SIZE, 0);
 		if (rc) {
 			gossip_err("%s: orangefs_inode_getattr failed, rc:%zd:.\n",
 				   __func__, rc);
@@ -681,7 +681,7 @@ static loff_t orangefs_file_llseek(struct file *file, loff_t offset, int origin)
 		 * NOTE: We are only interested in file size here,
 		 * so we set mask accordingly.
 		 */
-		ret = orangefs_inode_getattr(inode, ORANGEFS_ATTR_SYS_SIZE);
+		ret = orangefs_inode_getattr(inode, ORANGEFS_ATTR_SYS_SIZE, 0);
 		if (ret) {
 			gossip_debug(GOSSIP_FILE_DEBUG,
 				     "%s:%s:%d calling make bad inode\n",

commit b0bc3a7b621cb8d7bcce507f323249a7340f4141
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 23 13:50:37 2016 -0500

    orangefs: move handle_io_error() to file.c
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 7af0adba29aa..c585063d1100 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -14,11 +14,6 @@
 #include <linux/fs.h>
 #include <linux/pagemap.h>
 
-#define wake_up_daemon_for_return(op)			\
-do {							\
-	complete(&op->done);				\
-} while (0)
-
 /*
  * Copy to client-core's address space from the buffers specified
  * by the iovec upto total_size bytes.
@@ -87,6 +82,46 @@ static int postcopy_buffers(struct orangefs_bufmap *bufmap,
 	return ret;
 }
 
+/*
+ * handles two possible error cases, depending on context.
+ *
+ * by design, our vfs i/o errors need to be handled in one of two ways,
+ * depending on where the error occured.
+ *
+ * if the error happens in the waitqueue code because we either timed
+ * out or a signal was raised while waiting, we need to cancel the
+ * userspace i/o operation and free the op manually.  this is done to
+ * avoid having the device start writing application data to our shared
+ * bufmap pages without us expecting it.
+ *
+ * FIXME: POSSIBLE OPTIMIZATION:
+ * However, if we timed out or if we got a signal AND our upcall was never
+ * picked off the queue (i.e. we were in OP_VFS_STATE_WAITING), then we don't
+ * need to send a cancellation upcall. The way we can handle this is
+ * set error_exit to 2 in such cases and 1 whenever cancellation has to be
+ * sent and have handle_error
+ * take care of this situation as well..
+ *
+ * if a orangefs sysint level error occured and i/o has been completed,
+ * there is no need to cancel the operation, as the user has finished
+ * using the bufmap page and so there is no danger in this case.  in
+ * this case, we wake up the device normally so that it may free the
+ * op, as normal.
+ *
+ * note the only reason this is a macro is because both read and write
+ * cases need the exact same handling code.
+ */
+#define handle_io_error()					\
+do {								\
+	if (!op_state_serviced(new_op)) {			\
+		orangefs_cancel_op_in_progress(new_op->tag);	\
+	} else {						\
+		complete(&new_op->done);			\
+	}							\
+	orangefs_bufmap_put(bufmap, buffer_index);		\
+	buffer_index = -1;					\
+} while (0)
+
 /*
  * Post and wait for the I/O upcall to finish
  */
@@ -232,7 +267,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 	 * tell the device file owner waiting on I/O that this read has
 	 * completed and it can return now.
 	 */
-	wake_up_daemon_for_return(new_op);
+	complete(&new_op->done);
 
 out:
 	if (buffer_index >= 0) {

commit 2a9e5c22605f5db6040535b10dce5fbc3a7db3bd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 23 13:45:46 2016 -0500

    orangefs: don't reinvent completion.h...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index df3404ba60af..7af0adba29aa 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -16,10 +16,7 @@
 
 #define wake_up_daemon_for_return(op)			\
 do {							\
-	spin_lock(&op->lock);                           \
-	op->io_completed = 1;                           \
-	spin_unlock(&op->lock);                         \
-	wake_up_interruptible(&op->io_completion_waitq);\
+	complete(&op->done);				\
 } while (0)
 
 /*

commit ed42fe059389daa35a2aa10ec832e9f8d0a9e59e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jan 22 19:47:47 2016 -0500

    orangefs: hopefully saner op refcounting and locking
    
    * create with refcount 1
    * make op_release() decrement and free if zero (i.e. old put_op()
      has become that).
    * mark when submitter has given up waiting; from that point nobody
      else can move between the lists, change state, etc.
    * have daemon read/write_iter grab a reference when picking op
      and *always* give it up in the end
    * don't put into hash until we know it's been successfully passed to
      daemon
    
    * move op->lock _lower_ than htab_in_progress_lock (and make sure
      to take it in purge_inprogress_ops())
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 171013ae0036..df3404ba60af 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -105,10 +105,9 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 	ssize_t ret;
 
 	new_op = op_alloc(ORANGEFS_VFS_OP_FILE_IO);
-	if (!new_op) {
-		ret = -ENOMEM;
-		goto out;
-	}
+	if (!new_op)
+		return -ENOMEM;
+
 	/* synchronous I/O */
 	new_op->upcall.req.io.async_vfs_io = ORANGEFS_VFS_SYNC_IO;
 	new_op->upcall.req.io.readahead_size = readahead_size;
@@ -234,12 +233,9 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 
 	/*
 	 * tell the device file owner waiting on I/O that this read has
-	 * completed and it can return now.  in this exact case, on
-	 * wakeup the daemon will free the op, so we *cannot* touch it
-	 * after this.
+	 * completed and it can return now.
 	 */
 	wake_up_daemon_for_return(new_op);
-	new_op = NULL;
 
 out:
 	if (buffer_index >= 0) {
@@ -249,10 +245,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 			     __func__, handle, buffer_index);
 		buffer_index = -1;
 	}
-	if (new_op) {
-		op_release(new_op);
-		new_op = NULL;
-	}
+	op_release(new_op);
 	return ret;
 }
 

commit 575e946125f70c41c2042f10172842c5cab9a09a
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Dec 4 12:56:14 2015 -0500

    Orangefs: change pvfs2 filenames to orangefs
    
    Also changed references within source files that referred to
    header files whose names had changed.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index ae5d8ed67ed5..171013ae0036 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -9,8 +9,8 @@
  */
 
 #include "protocol.h"
-#include "pvfs2-kernel.h"
-#include "pvfs2-bufmap.h"
+#include "orangefs-kernel.h"
+#include "orangefs-bufmap.h"
 #include <linux/fs.h>
 #include <linux/pagemap.h>
 
@@ -186,7 +186,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod
 	}
 
 	if (ret < 0) {
-		handle_io_error(); /* defined in pvfs2-kernel.h */
+		handle_io_error();
 		/*
 		 * don't write an error to syslog on signaled operation
 		 * termination unless we've got debugging turned on, as

commit 8bb8aefd5afb54a25a002feb4ec70011812d06a0
Author: Yi Liu <yi9@clemson.edu>
Date:   Tue Nov 24 15:12:14 2015 -0500

    OrangeFS: Change almost all instances of the string PVFS2 to OrangeFS.
    
    OrangeFS was formerly known as PVFS2 and retains the name in many places.
    
    I leave the device /dev/pvfs2-req since this affects userspace.
    
    I leave the filesystem type pvfs2 since this affects userspace. Further
    the OrangeFS sysint library reads fstab for an entry of type pvfs2
    independently of kernel mounts.
    
    I leave extended attribute keys user.pvfs2 and system.pvfs2 as the
    sysint library understands these.
    
    I leave references to userspace binaries still named pvfs2.
    
    I leave the filenames.
    
    Signed-off-by: Yi Liu <yi9@clemson.edu>
    [martin@omnibond.com: clairify above constraints and merge]
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 3a8140f289f6..ae5d8ed67ed5 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -29,7 +29,7 @@ do {							\
  *       can futher be kernel-space or user-space addresses.
  *       or it can pointers to struct page's
  */
-static int precopy_buffers(struct pvfs2_bufmap *bufmap,
+static int precopy_buffers(struct orangefs_bufmap *bufmap,
 			   int buffer_index,
 			   struct iov_iter *iter,
 			   size_t total_size)
@@ -42,10 +42,10 @@ static int precopy_buffers(struct pvfs2_bufmap *bufmap,
 
 
 	if (total_size) {
-		ret = pvfs_bufmap_copy_from_iovec(bufmap,
-						iter,
-						buffer_index,
-						total_size);
+		ret = orangefs_bufmap_copy_from_iovec(bufmap,
+						      iter,
+						      buffer_index,
+						      total_size);
 		if (ret < 0)
 		gossip_err("%s: Failed to copy-in buffers. Please make sure that the pvfs2-client is running. %ld\n",
 			   __func__,
@@ -66,7 +66,7 @@ static int precopy_buffers(struct pvfs2_bufmap *bufmap,
  *       can futher be kernel-space or user-space addresses.
  *       or it can pointers to struct page's
  */
-static int postcopy_buffers(struct pvfs2_bufmap *bufmap,
+static int postcopy_buffers(struct orangefs_bufmap *bufmap,
 			    int buffer_index,
 			    struct iov_iter *iter,
 			    size_t total_size)
@@ -78,10 +78,10 @@ static int postcopy_buffers(struct pvfs2_bufmap *bufmap,
 	 * struct page pointers.
 	 */
 	if (total_size) {
-		ret = pvfs_bufmap_copy_to_iovec(bufmap,
-						iter,
-						buffer_index,
-						total_size);
+		ret = orangefs_bufmap_copy_to_iovec(bufmap,
+						    iter,
+						    buffer_index,
+						    total_size);
 		if (ret < 0)
 			gossip_err("%s: Failed to copy-out buffers. Please make sure that the pvfs2-client is running (%ld)\n",
 				__func__,
@@ -93,34 +93,34 @@ static int postcopy_buffers(struct pvfs2_bufmap *bufmap,
 /*
  * Post and wait for the I/O upcall to finish
  */
-static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
+static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
 		loff_t *offset, struct iov_iter *iter,
 		size_t total_size, loff_t readahead_size)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
-	struct pvfs2_khandle *handle = &pvfs2_inode->refn.khandle;
-	struct pvfs2_bufmap *bufmap = NULL;
-	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_khandle *handle = &orangefs_inode->refn.khandle;
+	struct orangefs_bufmap *bufmap = NULL;
+	struct orangefs_kernel_op_s *new_op = NULL;
 	int buffer_index = -1;
 	ssize_t ret;
 
-	new_op = op_alloc(PVFS2_VFS_OP_FILE_IO);
+	new_op = op_alloc(ORANGEFS_VFS_OP_FILE_IO);
 	if (!new_op) {
 		ret = -ENOMEM;
 		goto out;
 	}
 	/* synchronous I/O */
-	new_op->upcall.req.io.async_vfs_io = PVFS_VFS_SYNC_IO;
+	new_op->upcall.req.io.async_vfs_io = ORANGEFS_VFS_SYNC_IO;
 	new_op->upcall.req.io.readahead_size = readahead_size;
 	new_op->upcall.req.io.io_type = type;
-	new_op->upcall.req.io.refn = pvfs2_inode->refn;
+	new_op->upcall.req.io.refn = orangefs_inode->refn;
 
 populate_shared_memory:
 	/* get a shared buffer index */
-	ret = pvfs_bufmap_get(&bufmap, &buffer_index);
+	ret = orangefs_bufmap_get(&bufmap, &buffer_index);
 	if (ret < 0) {
 		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "%s: pvfs_bufmap_get failure (%ld)\n",
+			     "%s: orangefs_bufmap_get failure (%ld)\n",
 			     __func__, (long)ret);
 		goto out;
 	}
@@ -146,7 +146,7 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 	 * Stage 1: copy the buffers into client-core's address space
 	 * precopy_buffers only pertains to writes.
 	 */
-	if (type == PVFS_IO_WRITE) {
+	if (type == ORANGEFS_IO_WRITE) {
 		ret = precopy_buffers(bufmap,
 				      buffer_index,
 				      iter,
@@ -163,14 +163,14 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 
 	/* Stage 2: Service the I/O operation */
 	ret = service_operation(new_op,
-				type == PVFS_IO_WRITE ?
+				type == ORANGEFS_IO_WRITE ?
 					"file_write" :
 					"file_read",
 				get_interruptible_flag(inode));
 
 	/*
 	 * If service_operation() returns -EAGAIN #and# the operation was
-	 * purged from pvfs2_request_list or htable_ops_in_progress, then
+	 * purged from orangefs_request_list or htable_ops_in_progress, then
 	 * we know that the client was restarted, causing the shared memory
 	 * area to be wiped clean.  To restart a  write operation in this
 	 * case, we must re-copy the data from the user's iovec to a NEW
@@ -178,7 +178,7 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 	 * a new shared memory location.
 	 */
 	if (ret == -EAGAIN && op_state_purged(new_op)) {
-		pvfs_bufmap_put(bufmap, buffer_index);
+		orangefs_bufmap_put(bufmap, buffer_index);
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s:going to repopulate_shared_memory.\n",
 			     __func__);
@@ -199,7 +199,7 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 		else
 			gossip_err("%s: error in %s handle %pU, returning %zd\n",
 				__func__,
-				type == PVFS_IO_READ ?
+				type == ORANGEFS_IO_READ ?
 					"read from" : "write to",
 				handle, ret);
 		goto out;
@@ -209,7 +209,7 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 	 * Stage 3: Post copy buffers from client-core's address space
 	 * postcopy_buffers only pertains to reads.
 	 */
-	if (type == PVFS_IO_READ) {
+	if (type == ORANGEFS_IO_READ) {
 		ret = postcopy_buffers(bufmap,
 				       buffer_index,
 				       iter,
@@ -243,7 +243,7 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 
 out:
 	if (buffer_index >= 0) {
-		pvfs_bufmap_put(bufmap, buffer_index);
+		orangefs_bufmap_put(bufmap, buffer_index);
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s(%pU): PUT buffer_index %d\n",
 			     __func__, handle, buffer_index);
@@ -263,12 +263,12 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
  * augmented/extended metadata attached to the file.
  * Note: File extended attributes override any mount options.
  */
-static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
+static ssize_t do_readv_writev(enum ORANGEFS_io_type type, struct file *file,
 		loff_t *offset, struct iov_iter *iter)
 {
 	struct inode *inode = file->f_mapping->host;
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
-	struct pvfs2_khandle *handle = &pvfs2_inode->refn.khandle;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_khandle *handle = &orangefs_inode->refn.khandle;
 	size_t count = iov_iter_count(iter);
 	ssize_t total_count = 0;
 	ssize_t ret = -EINVAL;
@@ -279,7 +279,7 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 		handle,
 		(int)count);
 
-	if (type == PVFS_IO_WRITE) {
+	if (type == ORANGEFS_IO_WRITE) {
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s(%pU): proceeding with offset : %llu, "
 			     "size %d\n",
@@ -299,8 +299,8 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 		size_t amt_complete;
 
 		/* how much to transfer in this loop iteration */
-		if (each_count > pvfs_bufmap_size_query())
-			each_count = pvfs_bufmap_size_query();
+		if (each_count > orangefs_bufmap_size_query())
+			each_count = orangefs_bufmap_size_query();
 
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s(%pU): size of each_count(%d)\n",
@@ -346,10 +346,10 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 		ret = total_count;
 out:
 	if (ret > 0) {
-		if (type == PVFS_IO_READ) {
+		if (type == ORANGEFS_IO_READ) {
 			file_accessed(file);
 		} else {
-			SetMtimeFlag(pvfs2_inode);
+			SetMtimeFlag(orangefs_inode);
 			inode->i_mtime = CURRENT_TIME;
 			mark_inode_dirty_sync(inode);
 		}
@@ -368,19 +368,19 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
  * Read data from a specified offset in a file (referenced by inode).
  * Data may be placed either in a user or kernel buffer.
  */
-ssize_t pvfs2_inode_read(struct inode *inode,
-			 struct iov_iter *iter,
-			 loff_t *offset,
-			 loff_t readahead_size)
+ssize_t orangefs_inode_read(struct inode *inode,
+			    struct iov_iter *iter,
+			    loff_t *offset,
+			    loff_t readahead_size)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	size_t count = iov_iter_count(iter);
 	size_t bufmap_size;
 	ssize_t ret = -EINVAL;
 
-	g_pvfs2_stats.reads++;
+	g_orangefs_stats.reads++;
 
-	bufmap_size = pvfs_bufmap_size_query();
+	bufmap_size = orangefs_bufmap_size_query();
 	if (count > bufmap_size) {
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s: count is too large (%zd/%zd)!\n",
@@ -391,11 +391,11 @@ ssize_t pvfs2_inode_read(struct inode *inode,
 	gossip_debug(GOSSIP_FILE_DEBUG,
 		     "%s(%pU) %zd@%llu\n",
 		     __func__,
-		     &pvfs2_inode->refn.khandle,
+		     &orangefs_inode->refn.khandle,
 		     count,
 		     llu(*offset));
 
-	ret = wait_for_direct_io(PVFS_IO_READ, inode, offset, iter,
+	ret = wait_for_direct_io(ORANGEFS_IO_READ, inode, offset, iter,
 			count, readahead_size);
 	if (ret > 0)
 		*offset += ret;
@@ -403,13 +403,13 @@ ssize_t pvfs2_inode_read(struct inode *inode,
 	gossip_debug(GOSSIP_FILE_DEBUG,
 		     "%s(%pU): Value(%zd) returned.\n",
 		     __func__,
-		     &pvfs2_inode->refn.khandle,
+		     &orangefs_inode->refn.khandle,
 		     ret);
 
 	return ret;
 }
 
-static ssize_t pvfs2_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)
+static ssize_t orangefs_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)
 {
 	struct file *file = iocb->ki_filp;
 	loff_t pos = *(&iocb->ki_pos);
@@ -417,17 +417,17 @@ static ssize_t pvfs2_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)
 
 	BUG_ON(iocb->private);
 
-	gossip_debug(GOSSIP_FILE_DEBUG, "pvfs2_file_read_iter\n");
+	gossip_debug(GOSSIP_FILE_DEBUG, "orangefs_file_read_iter\n");
 
-	g_pvfs2_stats.reads++;
+	g_orangefs_stats.reads++;
 
-	rc = do_readv_writev(PVFS_IO_READ, file, &pos, iter);
+	rc = do_readv_writev(ORANGEFS_IO_READ, file, &pos, iter);
 	iocb->ki_pos = pos;
 
 	return rc;
 }
 
-static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
+static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
 {
 	struct file *file = iocb->ki_filp;
 	loff_t pos;
@@ -435,23 +435,23 @@ static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
 
 	BUG_ON(iocb->private);
 
-	gossip_debug(GOSSIP_FILE_DEBUG, "pvfs2_file_write_iter\n");
+	gossip_debug(GOSSIP_FILE_DEBUG, "orangefs_file_write_iter\n");
 
 	mutex_lock(&file->f_mapping->host->i_mutex);
 
 	/* Make sure generic_write_checks sees an up to date inode size. */
 	if (file->f_flags & O_APPEND) {
-		rc = pvfs2_inode_getattr(file->f_mapping->host,
-					 PVFS_ATTR_SYS_SIZE);
+		rc = orangefs_inode_getattr(file->f_mapping->host,
+					 ORANGEFS_ATTR_SYS_SIZE);
 		if (rc) {
-			gossip_err("%s: pvfs2_inode_getattr failed, rc:%zd:.\n",
+			gossip_err("%s: orangefs_inode_getattr failed, rc:%zd:.\n",
 				   __func__, rc);
 			goto out;
 		}
 	}
 
 	if (file->f_pos > i_size_read(file->f_mapping->host))
-		pvfs2_i_size_write(file->f_mapping->host, file->f_pos);
+		orangefs_i_size_write(file->f_mapping->host, file->f_pos);
 
 	rc = generic_write_checks(iocb, iter);
 
@@ -468,7 +468,7 @@ static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
 	 */
 	pos = *(&iocb->ki_pos);
 
-	rc = do_readv_writev(PVFS_IO_WRITE,
+	rc = do_readv_writev(ORANGEFS_IO_WRITE,
 			     file,
 			     &pos,
 			     iter);
@@ -479,7 +479,7 @@ static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
 	}
 
 	iocb->ki_pos = pos;
-	g_pvfs2_stats.writes++;
+	g_orangefs_stats.writes++;
 
 out:
 
@@ -490,14 +490,14 @@ static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
 /*
  * Perform a miscellaneous operation on a file.
  */
-static long pvfs2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+static long orangefs_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	int ret = -ENOTTY;
 	__u64 val = 0;
 	unsigned long uval;
 
 	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "pvfs2_ioctl: called with cmd %d\n",
+		     "orangefs_ioctl: called with cmd %d\n",
 		     cmd);
 
 	/*
@@ -506,17 +506,17 @@ static long pvfs2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	 */
 	if (cmd == FS_IOC_GETFLAGS) {
 		val = 0;
-		ret = pvfs2_inode_getxattr(file_inode(file),
-					   PVFS2_XATTR_NAME_DEFAULT_PREFIX,
-					   "user.pvfs2.meta_hint",
-					   &val, sizeof(val));
+		ret = orangefs_inode_getxattr(file_inode(file),
+					      ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
+					      "user.pvfs2.meta_hint",
+					      &val, sizeof(val));
 		if (ret < 0 && ret != -ENODATA)
 			return ret;
 		else if (ret == -ENODATA)
 			val = 0;
 		uval = val;
 		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "pvfs2_ioctl: FS_IOC_GETFLAGS: %llu\n",
+			     "orangefs_ioctl: FS_IOC_GETFLAGS: %llu\n",
 			     (unsigned long long)uval);
 		return put_user(uval, (int __user *)arg);
 	} else if (cmd == FS_IOC_SETFLAGS) {
@@ -524,25 +524,25 @@ static long pvfs2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		if (get_user(uval, (int __user *)arg))
 			return -EFAULT;
 		/*
-		 * PVFS_MIRROR_FL is set internally when the mirroring mode
+		 * ORANGEFS_MIRROR_FL is set internally when the mirroring mode
 		 * is turned on for a file. The user is not allowed to turn
 		 * on this bit, but the bit is present if the user first gets
 		 * the flags and then updates the flags with some new
 		 * settings. So, we ignore it in the following edit. bligon.
 		 */
-		if ((uval & ~PVFS_MIRROR_FL) &
+		if ((uval & ~ORANGEFS_MIRROR_FL) &
 		    (~(FS_IMMUTABLE_FL | FS_APPEND_FL | FS_NOATIME_FL))) {
-			gossip_err("pvfs2_ioctl: the FS_IOC_SETFLAGS only supports setting one of FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NOATIME_FL\n");
+			gossip_err("orangefs_ioctl: the FS_IOC_SETFLAGS only supports setting one of FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NOATIME_FL\n");
 			return -EINVAL;
 		}
 		val = uval;
 		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "pvfs2_ioctl: FS_IOC_SETFLAGS: %llu\n",
+			     "orangefs_ioctl: FS_IOC_SETFLAGS: %llu\n",
 			     (unsigned long long)val);
-		ret = pvfs2_inode_setxattr(file_inode(file),
-					   PVFS2_XATTR_NAME_DEFAULT_PREFIX,
-					   "user.pvfs2.meta_hint",
-					   &val, sizeof(val), 0);
+		ret = orangefs_inode_setxattr(file_inode(file),
+					      ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
+					      "user.pvfs2.meta_hint",
+					      &val, sizeof(val), 0);
 	}
 
 	return ret;
@@ -551,10 +551,10 @@ static long pvfs2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 /*
  * Memory map a region of a file.
  */
-static int pvfs2_file_mmap(struct file *file, struct vm_area_struct *vma)
+static int orangefs_file_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "pvfs2_file_mmap: called on %s\n",
+		     "orangefs_file_mmap: called on %s\n",
 		     (file ?
 			(char *)file->f_path.dentry->d_name.name :
 			(char *)"Unknown"));
@@ -575,13 +575,13 @@ static int pvfs2_file_mmap(struct file *file, struct vm_area_struct *vma)
  *
  * \note Not called when each file is closed.
  */
-static int pvfs2_file_release(struct inode *inode, struct file *file)
+static int orangefs_file_release(struct inode *inode, struct file *file)
 {
 	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "pvfs2_file_release: called on %s\n",
+		     "orangefs_file_release: called on %s\n",
 		     file->f_path.dentry->d_name.name);
 
-	pvfs2_flush_inode(inode);
+	orangefs_flush_inode(inode);
 
 	/*
 	 * remove all associated inode pages from the page cache and mmap
@@ -599,35 +599,35 @@ static int pvfs2_file_release(struct inode *inode, struct file *file)
 /*
  * Push all data for a specific file onto permanent storage.
  */
-static int pvfs2_fsync(struct file *file,
+static int orangefs_fsync(struct file *file,
 		       loff_t start,
 		       loff_t end,
 		       int datasync)
 {
 	int ret = -EINVAL;
-	struct pvfs2_inode_s *pvfs2_inode =
-		PVFS2_I(file->f_path.dentry->d_inode);
-	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct orangefs_inode_s *orangefs_inode =
+		ORANGEFS_I(file->f_path.dentry->d_inode);
+	struct orangefs_kernel_op_s *new_op = NULL;
 
 	/* required call */
 	filemap_write_and_wait_range(file->f_mapping, start, end);
 
-	new_op = op_alloc(PVFS2_VFS_OP_FSYNC);
+	new_op = op_alloc(ORANGEFS_VFS_OP_FSYNC);
 	if (!new_op)
 		return -ENOMEM;
-	new_op->upcall.req.fsync.refn = pvfs2_inode->refn;
+	new_op->upcall.req.fsync.refn = orangefs_inode->refn;
 
 	ret = service_operation(new_op,
-			"pvfs2_fsync",
+			"orangefs_fsync",
 			get_interruptible_flag(file->f_path.dentry->d_inode));
 
 	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "pvfs2_fsync got return value of %d\n",
+		     "orangefs_fsync got return value of %d\n",
 		     ret);
 
 	op_release(new_op);
 
-	pvfs2_flush_inode(file->f_path.dentry->d_inode);
+	orangefs_flush_inode(file->f_path.dentry->d_inode);
 	return ret;
 }
 
@@ -640,36 +640,36 @@ static int pvfs2_fsync(struct file *file,
  * Future upgrade could support SEEK_DATA and SEEK_HOLE but would
  * require much changes to the FS
  */
-static loff_t pvfs2_file_llseek(struct file *file, loff_t offset, int origin)
+static loff_t orangefs_file_llseek(struct file *file, loff_t offset, int origin)
 {
 	int ret = -EINVAL;
 	struct inode *inode = file->f_path.dentry->d_inode;
 
 	if (!inode) {
-		gossip_err("pvfs2_file_llseek: invalid inode (NULL)\n");
+		gossip_err("orangefs_file_llseek: invalid inode (NULL)\n");
 		return ret;
 	}
 
-	if (origin == PVFS2_SEEK_END) {
+	if (origin == ORANGEFS_SEEK_END) {
 		/*
 		 * revalidate the inode's file size.
 		 * NOTE: We are only interested in file size here,
 		 * so we set mask accordingly.
 		 */
-		ret = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_SIZE);
+		ret = orangefs_inode_getattr(inode, ORANGEFS_ATTR_SYS_SIZE);
 		if (ret) {
 			gossip_debug(GOSSIP_FILE_DEBUG,
 				     "%s:%s:%d calling make bad inode\n",
 				     __FILE__,
 				     __func__,
 				     __LINE__);
-			pvfs2_make_bad_inode(inode);
+			orangefs_make_bad_inode(inode);
 			return ret;
 		}
 	}
 
 	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "pvfs2_file_llseek: offset is %ld | origin is %d"
+		     "orangefs_file_llseek: offset is %ld | origin is %d"
 		     " | inode size is %lu\n",
 		     (long)offset,
 		     origin,
@@ -682,11 +682,11 @@ static loff_t pvfs2_file_llseek(struct file *file, loff_t offset, int origin)
  * Support local locks (locks that only this kernel knows about)
  * if Orangefs was mounted -o local_lock.
  */
-static int pvfs2_lock(struct file *filp, int cmd, struct file_lock *fl)
+static int orangefs_lock(struct file *filp, int cmd, struct file_lock *fl)
 {
 	int rc = -EINVAL;
 
-	if (PVFS2_SB(filp->f_inode->i_sb)->flags & PVFS2_OPT_LOCAL_LOCK) {
+	if (ORANGEFS_SB(filp->f_inode->i_sb)->flags & ORANGEFS_OPT_LOCAL_LOCK) {
 		if (cmd == F_GETLK) {
 			rc = 0;
 			posix_test_lock(filp, fl);
@@ -698,15 +698,15 @@ static int pvfs2_lock(struct file *filp, int cmd, struct file_lock *fl)
 	return rc;
 }
 
-/** PVFS2 implementation of VFS file operations */
-const struct file_operations pvfs2_file_operations = {
-	.llseek		= pvfs2_file_llseek,
-	.read_iter	= pvfs2_file_read_iter,
-	.write_iter	= pvfs2_file_write_iter,
-	.lock		= pvfs2_lock,
-	.unlocked_ioctl	= pvfs2_ioctl,
-	.mmap		= pvfs2_file_mmap,
+/** ORANGEFS implementation of VFS file operations */
+const struct file_operations orangefs_file_operations = {
+	.llseek		= orangefs_file_llseek,
+	.read_iter	= orangefs_file_read_iter,
+	.write_iter	= orangefs_file_write_iter,
+	.lock		= orangefs_lock,
+	.unlocked_ioctl	= orangefs_ioctl,
+	.mmap		= orangefs_file_mmap,
 	.open		= generic_file_open,
-	.release	= pvfs2_file_release,
-	.fsync		= pvfs2_fsync,
+	.release	= orangefs_file_release,
+	.fsync		= orangefs_fsync,
 };

commit 555fa0fa618b846c5b38406347b7d53ace320ac6
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Wed Nov 11 16:33:39 2015 +0000

    fs: out of bounds on stack in iov_iter_advance
    
    On Wed, Nov 11, 2015 at 10:19:48AM +0000, Al Viro wrote:
    
    > I'll cook the minimal fixup for API change after I get some sleep and
    > send it your way, unless somebody gets there first...
    
    This should do it - switches ->ioctl() to pvfs2_inode_[gs]etxattr() and
    converts xattr_handler ->[gs]et() to new API.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 78a46968a994..3a8140f289f6 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -506,11 +506,10 @@ static long pvfs2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	 */
 	if (cmd == FS_IOC_GETFLAGS) {
 		val = 0;
-		ret = pvfs2_xattr_get_default(file->f_path.dentry,
-					      "user.pvfs2.meta_hint",
-					      &val,
-					      sizeof(val),
-					      0);
+		ret = pvfs2_inode_getxattr(file_inode(file),
+					   PVFS2_XATTR_NAME_DEFAULT_PREFIX,
+					   "user.pvfs2.meta_hint",
+					   &val, sizeof(val));
 		if (ret < 0 && ret != -ENODATA)
 			return ret;
 		else if (ret == -ENODATA)
@@ -540,12 +539,10 @@ static long pvfs2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "pvfs2_ioctl: FS_IOC_SETFLAGS: %llu\n",
 			     (unsigned long long)val);
-		ret = pvfs2_xattr_set_default(file->f_path.dentry,
-					      "user.pvfs2.meta_hint",
-					      &val,
-					      sizeof(val),
-					      0,
-					      0);
+		ret = pvfs2_inode_setxattr(file_inode(file),
+					   PVFS2_XATTR_NAME_DEFAULT_PREFIX,
+					   "user.pvfs2.meta_hint",
+					   &val, sizeof(val), 0);
 	}
 
 	return ret;

commit 3f1b6947dcfa76de0b690022dcf3ed8814744aa7
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Nov 13 13:05:11 2015 -0500

    Orangefs: set pos after generic_write_checks
    
    if we are appending, generic_write_checks would have updated
    pos to the end of the file...
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 78d296bb870e..78a46968a994 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -430,7 +430,7 @@ static ssize_t pvfs2_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)
 static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
 {
 	struct file *file = iocb->ki_filp;
-	loff_t pos = *(&iocb->ki_pos);
+	loff_t pos;
 	ssize_t rc;
 
 	BUG_ON(iocb->private);
@@ -461,6 +461,13 @@ static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
 		goto out;
 	}
 
+	/*
+	 * if we are appending, generic_write_checks would have updated
+	 * pos to the end of the file, so we will wait till now to set
+	 * pos...
+	 */
+	pos = *(&iocb->ki_pos);
+
 	rc = do_readv_writev(PVFS_IO_WRITE,
 			     file,
 			     &pos,

commit 74f68fce2a395a188d454a488ea167affa4d7cf5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 8 18:31:05 2015 -0400

    orangefs: make pvfs2_inode_read() take iov_iter
    
    ... and make the only caller use page-backed iov_iter,
    getting rid of kmap/kunmap *and* of the bug with
    attempted use of iovec-backed copy_page_to_iter()
    on a kernel pointer.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 8dae04dc9df4..78d296bb870e 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -369,22 +369,17 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
  * Data may be placed either in a user or kernel buffer.
  */
 ssize_t pvfs2_inode_read(struct inode *inode,
-			 char __user *buf,
-			 size_t count,
+			 struct iov_iter *iter,
 			 loff_t *offset,
 			 loff_t readahead_size)
 {
 	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	size_t count = iov_iter_count(iter);
 	size_t bufmap_size;
-	struct iovec vec;
-	struct iov_iter iter;
 	ssize_t ret = -EINVAL;
 
 	g_pvfs2_stats.reads++;
 
-	vec.iov_base = buf;
-	vec.iov_len = count;
-
 	bufmap_size = pvfs_bufmap_size_query();
 	if (count > bufmap_size) {
 		gossip_debug(GOSSIP_FILE_DEBUG,
@@ -400,8 +395,7 @@ ssize_t pvfs2_inode_read(struct inode *inode,
 		     count,
 		     llu(*offset));
 
-	iov_iter_init(&iter, READ, &vec, 1, count);
-	ret = wait_for_direct_io(PVFS_IO_READ, inode, offset, &iter,
+	ret = wait_for_direct_io(PVFS_IO_READ, inode, offset, iter,
 			count, readahead_size);
 	if (ret > 0)
 		*offset += ret;

commit 0071ed1ec663fa87a3a8ae18f6d0812db010a343
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 8 18:22:08 2015 -0400

    orangefs: make do_readv_writev() take iov_iter
    
    no need to build a copy of what the caller already has;
    what's more, we want the one given to caller properly
    advanced *and* we shouldn't depend upon it being an
    iovec-backed one.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index ff7fe37f5a22..8dae04dc9df4 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -264,13 +264,12 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
  * Note: File extended attributes override any mount options.
  */
 static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
-		loff_t *offset, const struct iovec *iov, unsigned long nr_segs)
+		loff_t *offset, struct iov_iter *iter)
 {
 	struct inode *inode = file->f_mapping->host;
 	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
 	struct pvfs2_khandle *handle = &pvfs2_inode->refn.khandle;
-	struct iov_iter iter;
-	size_t count = iov_length(iov, nr_segs);
+	size_t count = iov_iter_count(iter);
 	ssize_t total_count = 0;
 	ssize_t ret = -EINVAL;
 
@@ -295,18 +294,13 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 		goto out;
 	}
 
-	iov_iter_init(&iter, type == PVFS_IO_READ ? READ : WRITE,
-			      iov, nr_segs, count);
-
-	while (total_count < count) {
-		size_t each_count;
+	while (iov_iter_count(iter)) {
+		size_t each_count = iov_iter_count(iter);
 		size_t amt_complete;
 
 		/* how much to transfer in this loop iteration */
-		each_count =
-		   (((count - total_count) > pvfs_bufmap_size_query()) ?
-			pvfs_bufmap_size_query() :
-			(count - total_count));
+		if (each_count > pvfs_bufmap_size_query())
+			each_count = pvfs_bufmap_size_query();
 
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s(%pU): size of each_count(%d)\n",
@@ -319,7 +313,7 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 			     handle,
 			     (int)*offset);
 
-		ret = wait_for_direct_io(type, inode, offset, &iter,
+		ret = wait_for_direct_io(type, inode, offset, iter,
 				each_count, 0);
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s(%pU): return from wait_for_io:%d\n",
@@ -426,7 +420,6 @@ static ssize_t pvfs2_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)
 	struct file *file = iocb->ki_filp;
 	loff_t pos = *(&iocb->ki_pos);
 	ssize_t rc = 0;
-	unsigned long nr_segs = iter->nr_segs;
 
 	BUG_ON(iocb->private);
 
@@ -434,11 +427,7 @@ static ssize_t pvfs2_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)
 
 	g_pvfs2_stats.reads++;
 
-	rc = do_readv_writev(PVFS_IO_READ,
-			     file,
-			     &pos,
-			     iter->iov,
-			     nr_segs);
+	rc = do_readv_writev(PVFS_IO_READ, file, &pos, iter);
 	iocb->ki_pos = pos;
 
 	return rc;
@@ -448,7 +437,6 @@ static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
 {
 	struct file *file = iocb->ki_filp;
 	loff_t pos = *(&iocb->ki_pos);
-	unsigned long nr_segs = iter->nr_segs;
 	ssize_t rc;
 
 	BUG_ON(iocb->private);
@@ -482,8 +470,7 @@ static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
 	rc = do_readv_writev(PVFS_IO_WRITE,
 			     file,
 			     &pos,
-			     iter->iov,
-			     nr_segs);
+			     iter);
 	if (rc < 0) {
 		gossip_err("%s: do_readv_writev failed, rc:%zd:.\n",
 			   __func__, rc);

commit dc4067f671231eea971298cb44f687a30e04d0fd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 8 18:17:26 2015 -0400

    orangefs: don't bother with splitting iovecs
    
    copy_page_{to,from}_iter() advances it just fine *and* it has no
    problem with partially consumed segments.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 9a439b2e8bde..ff7fe37f5a22 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -256,168 +256,6 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 	return ret;
 }
 
-/*
- * The reason we need to do this is to be able to support readv and writev
- * that are larger than (pvfs_bufmap_size_query()) Default is
- * PVFS2_BUFMAP_DEFAULT_DESC_SIZE MB. What that means is that we will
- * create a new io vec descriptor for those memory addresses that
- * go beyond the limit. Return value for this routine is negative in case
- * of errors and 0 in case of success.
- *
- * Further, the new_nr_segs pointer is updated to hold the new value
- * of number of iovecs, the new_vec pointer is updated to hold the pointer
- * to the new split iovec, and the size array is an array of integers holding
- * the number of iovecs that straddle pvfs_bufmap_size_query().
- * The max_new_nr_segs value is computed by the caller and returned.
- * (It will be (count of all iov_len/ block_size) + 1).
- */
-static int split_iovecs(unsigned long max_new_nr_segs,		/* IN */
-			unsigned long nr_segs,			/* IN */
-			const struct iovec *original_iovec,	/* IN */
-			unsigned long *new_nr_segs,		/* OUT */
-			struct iovec **new_vec,			/* OUT */
-			unsigned long *seg_count,		/* OUT */
-			unsigned long **seg_array)		/* OUT */
-{
-	unsigned long seg;
-	unsigned long count = 0;
-	unsigned long begin_seg;
-	unsigned long tmpnew_nr_segs = 0;
-	struct iovec *new_iovec = NULL;
-	struct iovec *orig_iovec;
-	unsigned long *sizes = NULL;
-	unsigned long sizes_count = 0;
-
-	if (nr_segs <= 0 ||
-	    original_iovec == NULL ||
-	    new_nr_segs == NULL ||
-	    new_vec == NULL ||
-	    seg_count == NULL ||
-	    seg_array == NULL ||
-	    max_new_nr_segs <= 0) {
-		gossip_err("Invalid parameters to split_iovecs\n");
-		return -EINVAL;
-	}
-	*new_nr_segs = 0;
-	*new_vec = NULL;
-	*seg_count = 0;
-	*seg_array = NULL;
-	/* copy the passed in iovec descriptor to a temp structure */
-	orig_iovec = kmalloc_array(nr_segs,
-				   sizeof(*orig_iovec),
-				   PVFS2_BUFMAP_GFP_FLAGS);
-	if (orig_iovec == NULL) {
-		gossip_err(
-		    "split_iovecs: Could not allocate memory for %lu bytes!\n",
-		    (unsigned long)(nr_segs * sizeof(*orig_iovec)));
-		return -ENOMEM;
-	}
-	new_iovec = kcalloc(max_new_nr_segs,
-			    sizeof(*new_iovec),
-			    PVFS2_BUFMAP_GFP_FLAGS);
-	if (new_iovec == NULL) {
-		kfree(orig_iovec);
-		gossip_err(
-		    "split_iovecs: Could not allocate memory for %lu bytes!\n",
-		    (unsigned long)(max_new_nr_segs * sizeof(*new_iovec)));
-		return -ENOMEM;
-	}
-	sizes = kcalloc(max_new_nr_segs,
-			sizeof(*sizes),
-			PVFS2_BUFMAP_GFP_FLAGS);
-	if (sizes == NULL) {
-		kfree(new_iovec);
-		kfree(orig_iovec);
-		gossip_err(
-		    "split_iovecs: Could not allocate memory for %lu bytes!\n",
-		    (unsigned long)(max_new_nr_segs * sizeof(*sizes)));
-		return -ENOMEM;
-	}
-	/* copy the passed in iovec to a temp structure */
-	memcpy(orig_iovec, original_iovec, nr_segs * sizeof(*orig_iovec));
-	begin_seg = 0;
-repeat:
-	for (seg = begin_seg; seg < nr_segs; seg++) {
-		if (tmpnew_nr_segs >= max_new_nr_segs ||
-		    sizes_count >= max_new_nr_segs) {
-			kfree(sizes);
-			kfree(orig_iovec);
-			kfree(new_iovec);
-			gossip_err
-			    ("split_iovecs: exceeded the index limit (%lu)\n",
-			    tmpnew_nr_segs);
-			return -EINVAL;
-		}
-		if (count + orig_iovec[seg].iov_len <
-		    pvfs_bufmap_size_query()) {
-			count += orig_iovec[seg].iov_len;
-			memcpy(&new_iovec[tmpnew_nr_segs],
-			       &orig_iovec[seg],
-			       sizeof(*new_iovec));
-			tmpnew_nr_segs++;
-			sizes[sizes_count]++;
-		} else {
-			new_iovec[tmpnew_nr_segs].iov_base =
-			    orig_iovec[seg].iov_base;
-			new_iovec[tmpnew_nr_segs].iov_len =
-			    (pvfs_bufmap_size_query() - count);
-			tmpnew_nr_segs++;
-			sizes[sizes_count]++;
-			sizes_count++;
-			begin_seg = seg;
-			orig_iovec[seg].iov_base +=
-			    (pvfs_bufmap_size_query() - count);
-			orig_iovec[seg].iov_len -=
-			    (pvfs_bufmap_size_query() - count);
-			count = 0;
-			break;
-		}
-	}
-	if (seg != nr_segs)
-		goto repeat;
-	else
-		sizes_count++;
-
-	*new_nr_segs = tmpnew_nr_segs;
-	/* new_iovec is freed by the caller */
-	*new_vec = new_iovec;
-	*seg_count = sizes_count;
-	/* seg_array is also freed by the caller */
-	*seg_array = sizes;
-	kfree(orig_iovec);
-	return 0;
-}
-
-static long bound_max_iovecs(const struct iovec *curr, unsigned long nr_segs,
-			     ssize_t *total_count)
-{
-	unsigned long i;
-	long max_nr_iovecs;
-	ssize_t total;
-	ssize_t count;
-
-	total = 0;
-	count = 0;
-	max_nr_iovecs = 0;
-	for (i = 0; i < nr_segs; i++) {
-		const struct iovec *iv = &curr[i];
-
-		count += iv->iov_len;
-		if (unlikely((ssize_t) (count | iv->iov_len) < 0))
-			return -EINVAL;
-		if (total + iv->iov_len < pvfs_bufmap_size_query()) {
-			total += iv->iov_len;
-			max_nr_iovecs++;
-		} else {
-			total =
-			    (total + iv->iov_len - pvfs_bufmap_size_query());
-			max_nr_iovecs += (total / pvfs_bufmap_size_query() + 2);
-		}
-	}
-	*total_count = count;
-	return max_nr_iovecs;
-}
-
 /*
  * Common entry point for read/write/readv/writev
  * This function will dispatch it to either the direct I/O
@@ -431,25 +269,10 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 	struct inode *inode = file->f_mapping->host;
 	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
 	struct pvfs2_khandle *handle = &pvfs2_inode->refn.khandle;
-	ssize_t ret;
-	ssize_t total_count;
-	unsigned int to_free;
-	size_t count;
-	unsigned long seg;
-	unsigned long new_nr_segs;
-	unsigned long max_new_nr_segs;
-	unsigned long seg_count;
-	unsigned long *seg_array;
-	struct iovec *iovecptr;
-	struct iovec *ptr;
-
-	total_count = 0;
-	ret = -EINVAL;
-	count = 0;
-	to_free = 0;
-
-	/* Compute total and max number of segments after split */
-	max_new_nr_segs = bound_max_iovecs(iov, nr_segs, &count);
+	struct iov_iter iter;
+	size_t count = iov_length(iov, nr_segs);
+	ssize_t total_count = 0;
+	ssize_t ret = -EINVAL;
 
 	gossip_debug(GOSSIP_FILE_DEBUG,
 		"%s-BEGIN(%pU): count(%d) after estimate_max_iovecs.\n",
@@ -472,93 +295,10 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 		goto out;
 	}
 
-	/*
-	 * if the total size of data transfer requested is greater than
-	 * the kernel-set blocksize of PVFS2, then we split the iovecs
-	 * such that no iovec description straddles a block size limit
-	 */
-
-	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "%s: pvfs_bufmap_size:%d\n",
-		     __func__,
-		     pvfs_bufmap_size_query());
-
-	if (count > pvfs_bufmap_size_query()) {
-		/*
-		 * Split up the given iovec description such that
-		 * no iovec descriptor straddles over the block-size limitation.
-		 * This makes us our job easier to stage the I/O.
-		 * In addition, this function will also compute an array
-		 * with seg_count entries that will store the number of
-		 * segments that straddle the block-size boundaries.
-		 */
-		ret = split_iovecs(max_new_nr_segs,	/* IN */
-				   nr_segs,		/* IN */
-				   iov,			/* IN */
-				   &new_nr_segs,	/* OUT */
-				   &iovecptr,		/* OUT */
-				   &seg_count,		/* OUT */
-				   &seg_array);		/* OUT */
-		if (ret < 0) {
-			gossip_err("%s: Failed to split iovecs to satisfy larger than blocksize readv/writev request %zd\n",
-				__func__,
-				ret);
-			goto out;
-		}
-		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "%s: Splitting iovecs from %lu to %lu"
-			     " [max_new %lu]\n",
-			     __func__,
-			     nr_segs,
-			     new_nr_segs,
-			     max_new_nr_segs);
-		/* We must free seg_array and iovecptr */
-		to_free = 1;
-	} else {
-		new_nr_segs = nr_segs;
-		/* use the given iovec description */
-		iovecptr = (struct iovec *)iov;
-		/* There is only 1 element in the seg_array */
-		seg_count = 1;
-		/* and its value is the number of segments passed in */
-		seg_array = &nr_segs;
-		/* We dont have to free up anything */
-		to_free = 0;
-	}
-	ptr = iovecptr;
+	iov_iter_init(&iter, type == PVFS_IO_READ ? READ : WRITE,
+			      iov, nr_segs, count);
 
-	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "%s(%pU) %zd@%llu\n",
-		     __func__,
-		     handle,
-		     count,
-		     llu(*offset));
-	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "%s(%pU): new_nr_segs: %lu, seg_count: %lu\n",
-		     __func__,
-		     handle,
-		     new_nr_segs, seg_count);
-
-/* PVFS2_KERNEL_DEBUG is a CFLAGS define. */
-#ifdef PVFS2_KERNEL_DEBUG
-	for (seg = 0; seg < new_nr_segs; seg++)
-		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "%s: %d) %p to %p [%d bytes]\n",
-			     __func__,
-			     (int)seg + 1,
-			     iovecptr[seg].iov_base,
-			     iovecptr[seg].iov_base + iovecptr[seg].iov_len,
-			     (int)iovecptr[seg].iov_len);
-	for (seg = 0; seg < seg_count; seg++)
-		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "%s: %zd) %lu\n",
-			     __func__,
-			     seg + 1,
-			     seg_array[seg]);
-#endif
-	seg = 0;
 	while (total_count < count) {
-		struct iov_iter iter;
 		size_t each_count;
 		size_t amt_complete;
 
@@ -579,9 +319,6 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 			     handle,
 			     (int)*offset);
 
-		iov_iter_init(&iter, type == PVFS_IO_READ ? READ : WRITE,
-			      ptr, seg_array[seg], each_count);
-
 		ret = wait_for_direct_io(type, inode, offset, &iter,
 				each_count, 0);
 		gossip_debug(GOSSIP_FILE_DEBUG,
@@ -593,9 +330,6 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 		if (ret < 0)
 			goto out;
 
-		/* advance the iovec pointer */
-		ptr += seg_array[seg];
-		seg++;
 		*offset += ret;
 		total_count += ret;
 		amt_complete = ret;
@@ -617,10 +351,6 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 	if (total_count > 0)
 		ret = total_count;
 out:
-	if (to_free) {
-		kfree(iovecptr);
-		kfree(seg_array);
-	}
 	if (ret > 0) {
 		if (type == PVFS_IO_READ) {
 			file_accessed(file);

commit 3c2fcfcb6858585e9df6c7832464ab28bfb5bb6b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 8 18:00:26 2015 -0400

    orangefs: make wait_for_direct_io() take iov_iter
    
    incidentally, insane or compromised server returning *more* than
    requested on read should not oops the kernel - initialize the
    iov_iter for read according to the iovec we've got.  That's why
    pvfs_bufmap_copy_to_iovec() needed a separate size argument - we
    shouldn't abuse iov_iter_count(iter) for passing that.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index bd8e6f866047..9a439b2e8bde 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -94,7 +94,7 @@ static int postcopy_buffers(struct pvfs2_bufmap *bufmap,
  * Post and wait for the I/O upcall to finish
  */
 static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
-		loff_t *offset, struct iovec *vec, unsigned long nr_segs,
+		loff_t *offset, struct iov_iter *iter,
 		size_t total_size, loff_t readahead_size)
 {
 	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
@@ -137,10 +137,9 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 	new_op->upcall.req.io.offset = *offset;
 
 	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "%s(%pU): nr_segs %lu, offset: %llu total_size: %zd\n",
+		     "%s(%pU): offset: %llu total_size: %zd\n",
 		     __func__,
 		     handle,
-		     nr_segs,
 		     llu(*offset),
 		     total_size);
 	/*
@@ -148,11 +147,9 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 	 * precopy_buffers only pertains to writes.
 	 */
 	if (type == PVFS_IO_WRITE) {
-		struct iov_iter iter;
-		iov_iter_init(&iter, WRITE, vec, nr_segs, total_size);
 		ret = precopy_buffers(bufmap,
 				      buffer_index,
-				      &iter,
+				      iter,
 				      total_size);
 		if (ret < 0)
 			goto out;
@@ -213,11 +210,9 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 	 * postcopy_buffers only pertains to reads.
 	 */
 	if (type == PVFS_IO_READ) {
-		struct iov_iter iter;
-		iov_iter_init(&iter, READ, vec, nr_segs, new_op->downcall.resp.io.amt_complete);
 		ret = postcopy_buffers(bufmap,
 				       buffer_index,
-				       &iter,
+				       iter,
 				       new_op->downcall.resp.io.amt_complete);
 		if (ret < 0) {
 			/*
@@ -563,6 +558,7 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 #endif
 	seg = 0;
 	while (total_count < count) {
+		struct iov_iter iter;
 		size_t each_count;
 		size_t amt_complete;
 
@@ -583,8 +579,11 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 			     handle,
 			     (int)*offset);
 
-		ret = wait_for_direct_io(type, inode, offset, ptr,
-				seg_array[seg], each_count, 0);
+		iov_iter_init(&iter, type == PVFS_IO_READ ? READ : WRITE,
+			      ptr, seg_array[seg], each_count);
+
+		ret = wait_for_direct_io(type, inode, offset, &iter,
+				each_count, 0);
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s(%pU): return from wait_for_io:%d\n",
 			     __func__,
@@ -654,6 +653,7 @@ ssize_t pvfs2_inode_read(struct inode *inode,
 	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
 	size_t bufmap_size;
 	struct iovec vec;
+	struct iov_iter iter;
 	ssize_t ret = -EINVAL;
 
 	g_pvfs2_stats.reads++;
@@ -676,7 +676,8 @@ ssize_t pvfs2_inode_read(struct inode *inode,
 		     count,
 		     llu(*offset));
 
-	ret = wait_for_direct_io(PVFS_IO_READ, inode, offset, &vec, 1,
+	iov_iter_init(&iter, READ, &vec, 1, count);
+	ret = wait_for_direct_io(PVFS_IO_READ, inode, offset, &iter,
 			count, readahead_size);
 	if (ret > 0)
 		*offset += ret;

commit a5c126a52269ce304b6da95e980e595668bf467d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 8 17:54:31 2015 -0400

    orangefs: make precopy_buffers() take iov_iter
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index c169bdda66a3..bd8e6f866047 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -31,13 +31,10 @@ do {							\
  */
 static int precopy_buffers(struct pvfs2_bufmap *bufmap,
 			   int buffer_index,
-			   const struct iovec *vec,
-			   unsigned long nr_segs,
+			   struct iov_iter *iter,
 			   size_t total_size)
 {
 	int ret = 0;
-	struct iov_iter iter;
-
 	/*
 	 * copy data from application/kernel by pulling it out
 	 * of the iovec.
@@ -45,9 +42,8 @@ static int precopy_buffers(struct pvfs2_bufmap *bufmap,
 
 
 	if (total_size) {
-		iov_iter_init(&iter, WRITE, vec, nr_segs, total_size);
 		ret = pvfs_bufmap_copy_from_iovec(bufmap,
-						&iter,
+						iter,
 						buffer_index,
 						total_size);
 		if (ret < 0)
@@ -152,10 +148,11 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 	 * precopy_buffers only pertains to writes.
 	 */
 	if (type == PVFS_IO_WRITE) {
+		struct iov_iter iter;
+		iov_iter_init(&iter, WRITE, vec, nr_segs, total_size);
 		ret = precopy_buffers(bufmap,
 				      buffer_index,
-				      vec,
-				      nr_segs,
+				      &iter,
 				      total_size);
 		if (ret < 0)
 			goto out;

commit 5f0e3c953fd962d82e1f38aeb24f7aec9bd1ba54
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 8 17:52:44 2015 -0400

    orangefs: make postcopy_buffers() take iov_iter
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 92a0974f0743..c169bdda66a3 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -72,23 +72,18 @@ static int precopy_buffers(struct pvfs2_bufmap *bufmap,
  */
 static int postcopy_buffers(struct pvfs2_bufmap *bufmap,
 			    int buffer_index,
-			    const struct iovec *vec,
-			    int nr_segs,
+			    struct iov_iter *iter,
 			    size_t total_size)
 {
 	int ret = 0;
-
-	struct iov_iter iter;
-
 	/*
 	 * copy data to application/kernel by pushing it out to
 	 * the iovec. NOTE; target buffers can be addresses or
 	 * struct page pointers.
 	 */
 	if (total_size) {
-		iov_iter_init(&iter, READ, vec, nr_segs, total_size);
 		ret = pvfs_bufmap_copy_to_iovec(bufmap,
-						&iter,
+						iter,
 						buffer_index,
 						total_size);
 		if (ret < 0)
@@ -221,10 +216,11 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 	 * postcopy_buffers only pertains to reads.
 	 */
 	if (type == PVFS_IO_READ) {
+		struct iov_iter iter;
+		iov_iter_init(&iter, READ, vec, nr_segs, new_op->downcall.resp.io.amt_complete);
 		ret = postcopy_buffers(bufmap,
 				       buffer_index,
-				       vec,
-				       nr_segs,
+				       &iter,
 				       new_op->downcall.resp.io.amt_complete);
 		if (ret < 0) {
 			/*

commit 5c278228bbfe3abb7d468ef39dffac23de15c078
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 8 17:43:58 2015 -0400

    orangefs: explicitly pass the size to pvfs_bufmap_copy_to_iovec()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index feb1764c2f80..92a0974f0743 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -89,7 +89,8 @@ static int postcopy_buffers(struct pvfs2_bufmap *bufmap,
 		iov_iter_init(&iter, READ, vec, nr_segs, total_size);
 		ret = pvfs_bufmap_copy_to_iovec(bufmap,
 						&iter,
-						buffer_index);
+						buffer_index,
+						total_size);
 		if (ret < 0)
 			gossip_err("%s: Failed to copy-out buffers. Please make sure that the pvfs2-client is running (%ld)\n",
 				__func__,

commit 548049495cb46348866aec1cb7721e9d00b4eb83
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Mon Oct 5 13:44:24 2015 -0400

    Orangefs: fix some checkpatch.pl complaints that had creeped in.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 87f718163d1b..feb1764c2f80 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -54,7 +54,6 @@ static int precopy_buffers(struct pvfs2_bufmap *bufmap,
 		gossip_err("%s: Failed to copy-in buffers. Please make sure that the pvfs2-client is running. %ld\n",
 			   __func__,
 			   (long)ret);
-		
 	}
 
 	if (ret < 0)
@@ -199,9 +198,9 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 	if (ret < 0) {
 		handle_io_error(); /* defined in pvfs2-kernel.h */
 		/*
-		   don't write an error to syslog on signaled operation
-		   termination unless we've got debugging turned on, as
-		   this can happen regularly (i.e. ctrl-c)
+		 * don't write an error to syslog on signaled operation
+		 * termination unless we've got debugging turned on, as
+		 * this can happen regularly (i.e. ctrl-c)
 		 */
 		if (ret == -EINTR)
 			gossip_debug(GOSSIP_FILE_DEBUG,
@@ -245,10 +244,10 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 	ret = new_op->downcall.resp.io.amt_complete;
 
 	/*
-	   tell the device file owner waiting on I/O that this read has
-	   completed and it can return now.  in this exact case, on
-	   wakeup the daemon will free the op, so we *cannot* touch it
-	   after this.
+	 * tell the device file owner waiting on I/O that this read has
+	 * completed and it can return now.  in this exact case, on
+	 * wakeup the daemon will free the op, so we *cannot* touch it
+	 * after this.
 	 */
 	wake_up_daemon_for_return(new_op);
 	new_op = NULL;
@@ -875,9 +874,9 @@ static int pvfs2_file_release(struct inode *inode, struct file *file)
 	pvfs2_flush_inode(inode);
 
 	/*
-	   remove all associated inode pages from the page cache and mmap
-	   readahead cache (if any); this forces an expensive refresh of
-	   data for the next caller of mmap (or 'get_block' accesses)
+	 * remove all associated inode pages from the page cache and mmap
+	 * readahead cache (if any); this forces an expensive refresh of
+	 * data for the next caller of mmap (or 'get_block' accesses)
 	 */
 	if (file->f_path.dentry->d_inode &&
 	    file->f_path.dentry->d_inode->i_mapping &&
@@ -960,8 +959,8 @@ static loff_t pvfs2_file_llseek(struct file *file, loff_t offset, int origin)
 	}
 
 	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "pvfs2_file_llseek: offset is %ld | origin is %d | "
-		     "inode size is %lu\n",
+		     "pvfs2_file_llseek: offset is %ld | origin is %d"
+		     " | inode size is %lu\n",
 		     (long)offset,
 		     origin,
 		     (unsigned long)file->f_path.dentry->d_inode->i_size);

commit 353908035f699bc6b769c4cd351c3125553d63c1
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Wed Sep 30 13:11:54 2015 -0400

    Orangefs: Use readonly mmap since writepage is not implemented.
    
    Previously the code silently failed to update the disk. Now it will not
    allow writable and shared mmaps.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 53e58c3f2121..87f718163d1b 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -853,7 +853,9 @@ static int pvfs2_file_mmap(struct file *file, struct vm_area_struct *vma)
 	/* set the sequential readahead hint */
 	vma->vm_flags |= VM_SEQ_READ;
 	vma->vm_flags &= ~VM_RAND_READ;
-	return generic_file_mmap(file, vma);
+
+	/* Use readonly mmap since we cannot support writable maps. */
+	return generic_file_readonly_mmap(file, vma);
 }
 
 #define mapping_nrpages(idata) ((idata)->nrpages)

commit f957ae2dec09b63b44df9ec06765cbdc52666eec
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Thu Sep 24 12:53:05 2015 -0400

    Orangefs: choose return codes from among the expected ones.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 3e5fc1a2c82f..53e58c3f2121 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -973,7 +973,7 @@ static loff_t pvfs2_file_llseek(struct file *file, loff_t offset, int origin)
  */
 static int pvfs2_lock(struct file *filp, int cmd, struct file_lock *fl)
 {
-	int rc = -ENOLCK;
+	int rc = -EINVAL;
 
 	if (PVFS2_SB(filp->f_inode->i_sb)->flags & PVFS2_OPT_LOCAL_LOCK) {
 		if (cmd == F_GETLK) {

commit 4d1c44043b26e99dd70f379cdbe80c64f43fd123
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Sep 4 10:31:16 2015 -0400

    Orangefs: use iov_iter interface
    
    replace opencoded pvfs_bufmap_copy_to_kernel_iovec,
    pvfs_bufmap_copy_to_user_iovec, pvfs_bufmap_copy_iovec_from_kernel,
    and pvfs_bufmap_copy_iovec_from_user with pvfs_bufmap_copy_to_iovec
    and pvfs_bufmap_copy_from_iovec, which both use the iov_iter
    interface.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 013a07c8bdfd..3e5fc1a2c82f 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -33,31 +33,30 @@ static int precopy_buffers(struct pvfs2_bufmap *bufmap,
 			   int buffer_index,
 			   const struct iovec *vec,
 			   unsigned long nr_segs,
-			   size_t total_size,
-			   int from_user)
+			   size_t total_size)
 {
 	int ret = 0;
+	struct iov_iter iter;
 
 	/*
 	 * copy data from application/kernel by pulling it out
 	 * of the iovec.
 	 */
-	/* Are we copying from User Virtual Addresses? */
-	if (from_user)
-		ret = pvfs_bufmap_copy_iovec_from_user(
-			bufmap,
-			buffer_index,
-			vec,
-			nr_segs,
-			total_size);
-	/* Are we copying from Kernel Virtual Addresses? */
-	else
-		ret = pvfs_bufmap_copy_iovec_from_kernel(
-			bufmap,
-			buffer_index,
-			vec,
-			nr_segs,
-			total_size);
+
+
+	if (total_size) {
+		iov_iter_init(&iter, WRITE, vec, nr_segs, total_size);
+		ret = pvfs_bufmap_copy_from_iovec(bufmap,
+						&iter,
+						buffer_index,
+						total_size);
+		if (ret < 0)
+		gossip_err("%s: Failed to copy-in buffers. Please make sure that the pvfs2-client is running. %ld\n",
+			   __func__,
+			   (long)ret);
+		
+	}
+
 	if (ret < 0)
 		gossip_err("%s: Failed to copy-in buffers. Please make sure that the pvfs2-client is running. %ld\n",
 			__func__,
@@ -76,35 +75,24 @@ static int postcopy_buffers(struct pvfs2_bufmap *bufmap,
 			    int buffer_index,
 			    const struct iovec *vec,
 			    int nr_segs,
-			    size_t total_size,
-			    int to_user)
+			    size_t total_size)
 {
 	int ret = 0;
 
+	struct iov_iter iter;
+
 	/*
 	 * copy data to application/kernel by pushing it out to
 	 * the iovec. NOTE; target buffers can be addresses or
 	 * struct page pointers.
 	 */
 	if (total_size) {
-		/* Are we copying to User Virtual Addresses? */
-		if (to_user)
-			ret = pvfs_bufmap_copy_to_user_iovec(
-				bufmap,
-				buffer_index,
-				vec,
-				nr_segs,
-				total_size);
-		/* Are we copying to Kern Virtual Addresses? */
-		else
-			ret = pvfs_bufmap_copy_to_kernel_iovec(
-				bufmap,
-				buffer_index,
-				vec,
-				nr_segs,
-				total_size);
+		iov_iter_init(&iter, READ, vec, nr_segs, total_size);
+		ret = pvfs_bufmap_copy_to_iovec(bufmap,
+						&iter,
+						buffer_index);
 		if (ret < 0)
-			gossip_err("%s: Failed to copy-out buffers.  Please make sure that the pvfs2-client is running (%ld)\n",
+			gossip_err("%s: Failed to copy-out buffers. Please make sure that the pvfs2-client is running (%ld)\n",
 				__func__,
 				(long)ret);
 	}
@@ -116,7 +104,7 @@ static int postcopy_buffers(struct pvfs2_bufmap *bufmap,
  */
 static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 		loff_t *offset, struct iovec *vec, unsigned long nr_segs,
-		size_t total_size, loff_t readahead_size, int to_user)
+		size_t total_size, loff_t readahead_size)
 {
 	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
 	struct pvfs2_khandle *handle = &pvfs2_inode->refn.khandle;
@@ -158,10 +146,9 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 	new_op->upcall.req.io.offset = *offset;
 
 	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "%s(%pU): copy_to_user %d nr_segs %lu, offset: %llu total_size: %zd\n",
+		     "%s(%pU): nr_segs %lu, offset: %llu total_size: %zd\n",
 		     __func__,
 		     handle,
-		     to_user,
 		     nr_segs,
 		     llu(*offset),
 		     total_size);
@@ -174,8 +161,7 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 				      buffer_index,
 				      vec,
 				      nr_segs,
-				      total_size,
-				      to_user);
+				      total_size);
 		if (ret < 0)
 			goto out;
 	}
@@ -239,8 +225,7 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 				       buffer_index,
 				       vec,
 				       nr_segs,
-				       new_op->downcall.resp.io.amt_complete,
-				       to_user);
+				       new_op->downcall.resp.io.amt_complete);
 		if (ret < 0) {
 			/*
 			 * put error codes in downcall so that handle_io_error()
@@ -606,7 +591,7 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 			     (int)*offset);
 
 		ret = wait_for_direct_io(type, inode, offset, ptr,
-				seg_array[seg], each_count, 0, 1);
+				seg_array[seg], each_count, 0);
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s(%pU): return from wait_for_io:%d\n",
 			     __func__,
@@ -699,7 +684,7 @@ ssize_t pvfs2_inode_read(struct inode *inode,
 		     llu(*offset));
 
 	ret = wait_for_direct_io(PVFS_IO_READ, inode, offset, &vec, 1,
-			count, readahead_size, 0);
+			count, readahead_size);
 	if (ret > 0)
 		*offset += ret;
 

commit eeaa3d448c5d35ad0dc16a981aacd64139c53eee
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Jul 29 13:36:37 2015 -0400

    Orangefs: address problems found by static checker
    
      Don't check for negative rc from boolean.
    
      Don't pointlessly initialize variables, it short-circuits
      gcc's uninitialized variable warnings. And max_new_nr_segs
      can never be zero, so don't check for it.
    
      Preserve original kstrdup pointer for freeing later.
    
      Don't check for negative value in unsigned variable.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 4ba1b6c48aa7..013a07c8bdfd 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -463,12 +463,12 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 	unsigned int to_free;
 	size_t count;
 	unsigned long seg;
-	unsigned long new_nr_segs = 0;
-	unsigned long max_new_nr_segs = 0;
-	unsigned long seg_count = 0;
-	unsigned long *seg_array = NULL;
-	struct iovec *iovecptr = NULL;
-	struct iovec *ptr = NULL;
+	unsigned long new_nr_segs;
+	unsigned long max_new_nr_segs;
+	unsigned long seg_count;
+	unsigned long *seg_array;
+	struct iovec *iovecptr;
+	struct iovec *ptr;
 
 	total_count = 0;
 	ret = -EINVAL;
@@ -477,12 +477,6 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 
 	/* Compute total and max number of segments after split */
 	max_new_nr_segs = bound_max_iovecs(iov, nr_segs, &count);
-	if (max_new_nr_segs < 0) {
-		gossip_lerr("%s: could not bound iovec %lu\n",
-			    __func__,
-			    max_new_nr_segs);
-		goto out;
-	}
 
 	gossip_debug(GOSSIP_FILE_DEBUG,
 		"%s-BEGIN(%pU): count(%d) after estimate_max_iovecs.\n",

commit 84d02150dea7571dc32176e35d65eecde82631a9
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Tue Jul 28 13:27:51 2015 -0400

    Orangefs: sooth most sparse complaints
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 8e26f9fac289..4ba1b6c48aa7 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -799,7 +799,7 @@ static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
 /*
  * Perform a miscellaneous operation on a file.
  */
-long pvfs2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+static long pvfs2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	int ret = -ENOTTY;
 	__u64 val = 0;
@@ -885,7 +885,7 @@ static int pvfs2_file_mmap(struct file *file, struct vm_area_struct *vma)
  *
  * \note Not called when each file is closed.
  */
-int pvfs2_file_release(struct inode *inode, struct file *file)
+static int pvfs2_file_release(struct inode *inode, struct file *file)
 {
 	gossip_debug(GOSSIP_FILE_DEBUG,
 		     "pvfs2_file_release: called on %s\n",
@@ -909,7 +909,10 @@ int pvfs2_file_release(struct inode *inode, struct file *file)
 /*
  * Push all data for a specific file onto permanent storage.
  */
-int pvfs2_fsync(struct file *file, loff_t start, loff_t end, int datasync)
+static int pvfs2_fsync(struct file *file,
+		       loff_t start,
+		       loff_t end,
+		       int datasync)
 {
 	int ret = -EINVAL;
 	struct pvfs2_inode_s *pvfs2_inode =
@@ -947,7 +950,7 @@ int pvfs2_fsync(struct file *file, loff_t start, loff_t end, int datasync)
  * Future upgrade could support SEEK_DATA and SEEK_HOLE but would
  * require much changes to the FS
  */
-loff_t pvfs2_file_llseek(struct file *file, loff_t offset, int origin)
+static loff_t pvfs2_file_llseek(struct file *file, loff_t offset, int origin)
 {
 	int ret = -EINVAL;
 	struct inode *inode = file->f_path.dentry->d_inode;
@@ -989,7 +992,7 @@ loff_t pvfs2_file_llseek(struct file *file, loff_t offset, int origin)
  * Support local locks (locks that only this kernel knows about)
  * if Orangefs was mounted -o local_lock.
  */
-int pvfs2_lock(struct file *filp, int cmd, struct file_lock *fl)
+static int pvfs2_lock(struct file *filp, int cmd, struct file_lock *fl)
 {
 	int rc = -ENOLCK;
 

commit 5db11c21a929cd9d8c0484006efb1014fc723c93
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Jul 17 10:38:12 2015 -0400

    Orangefs: kernel client part 2
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
new file mode 100644
index 000000000000..8e26f9fac289
--- /dev/null
+++ b/fs/orangefs/file.c
@@ -0,0 +1,1019 @@
+/*
+ * (C) 2001 Clemson University and The University of Chicago
+ *
+ * See COPYING in top-level directory.
+ */
+
+/*
+ *  Linux VFS file operations.
+ */
+
+#include "protocol.h"
+#include "pvfs2-kernel.h"
+#include "pvfs2-bufmap.h"
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+
+#define wake_up_daemon_for_return(op)			\
+do {							\
+	spin_lock(&op->lock);                           \
+	op->io_completed = 1;                           \
+	spin_unlock(&op->lock);                         \
+	wake_up_interruptible(&op->io_completion_waitq);\
+} while (0)
+
+/*
+ * Copy to client-core's address space from the buffers specified
+ * by the iovec upto total_size bytes.
+ * NOTE: the iovector can either contain addresses which
+ *       can futher be kernel-space or user-space addresses.
+ *       or it can pointers to struct page's
+ */
+static int precopy_buffers(struct pvfs2_bufmap *bufmap,
+			   int buffer_index,
+			   const struct iovec *vec,
+			   unsigned long nr_segs,
+			   size_t total_size,
+			   int from_user)
+{
+	int ret = 0;
+
+	/*
+	 * copy data from application/kernel by pulling it out
+	 * of the iovec.
+	 */
+	/* Are we copying from User Virtual Addresses? */
+	if (from_user)
+		ret = pvfs_bufmap_copy_iovec_from_user(
+			bufmap,
+			buffer_index,
+			vec,
+			nr_segs,
+			total_size);
+	/* Are we copying from Kernel Virtual Addresses? */
+	else
+		ret = pvfs_bufmap_copy_iovec_from_kernel(
+			bufmap,
+			buffer_index,
+			vec,
+			nr_segs,
+			total_size);
+	if (ret < 0)
+		gossip_err("%s: Failed to copy-in buffers. Please make sure that the pvfs2-client is running. %ld\n",
+			__func__,
+			(long)ret);
+	return ret;
+}
+
+/*
+ * Copy from client-core's address space to the buffers specified
+ * by the iovec upto total_size bytes.
+ * NOTE: the iovector can either contain addresses which
+ *       can futher be kernel-space or user-space addresses.
+ *       or it can pointers to struct page's
+ */
+static int postcopy_buffers(struct pvfs2_bufmap *bufmap,
+			    int buffer_index,
+			    const struct iovec *vec,
+			    int nr_segs,
+			    size_t total_size,
+			    int to_user)
+{
+	int ret = 0;
+
+	/*
+	 * copy data to application/kernel by pushing it out to
+	 * the iovec. NOTE; target buffers can be addresses or
+	 * struct page pointers.
+	 */
+	if (total_size) {
+		/* Are we copying to User Virtual Addresses? */
+		if (to_user)
+			ret = pvfs_bufmap_copy_to_user_iovec(
+				bufmap,
+				buffer_index,
+				vec,
+				nr_segs,
+				total_size);
+		/* Are we copying to Kern Virtual Addresses? */
+		else
+			ret = pvfs_bufmap_copy_to_kernel_iovec(
+				bufmap,
+				buffer_index,
+				vec,
+				nr_segs,
+				total_size);
+		if (ret < 0)
+			gossip_err("%s: Failed to copy-out buffers.  Please make sure that the pvfs2-client is running (%ld)\n",
+				__func__,
+				(long)ret);
+	}
+	return ret;
+}
+
+/*
+ * Post and wait for the I/O upcall to finish
+ */
+static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
+		loff_t *offset, struct iovec *vec, unsigned long nr_segs,
+		size_t total_size, loff_t readahead_size, int to_user)
+{
+	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	struct pvfs2_khandle *handle = &pvfs2_inode->refn.khandle;
+	struct pvfs2_bufmap *bufmap = NULL;
+	struct pvfs2_kernel_op_s *new_op = NULL;
+	int buffer_index = -1;
+	ssize_t ret;
+
+	new_op = op_alloc(PVFS2_VFS_OP_FILE_IO);
+	if (!new_op) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	/* synchronous I/O */
+	new_op->upcall.req.io.async_vfs_io = PVFS_VFS_SYNC_IO;
+	new_op->upcall.req.io.readahead_size = readahead_size;
+	new_op->upcall.req.io.io_type = type;
+	new_op->upcall.req.io.refn = pvfs2_inode->refn;
+
+populate_shared_memory:
+	/* get a shared buffer index */
+	ret = pvfs_bufmap_get(&bufmap, &buffer_index);
+	if (ret < 0) {
+		gossip_debug(GOSSIP_FILE_DEBUG,
+			     "%s: pvfs_bufmap_get failure (%ld)\n",
+			     __func__, (long)ret);
+		goto out;
+	}
+	gossip_debug(GOSSIP_FILE_DEBUG,
+		     "%s(%pU): GET op %p -> buffer_index %d\n",
+		     __func__,
+		     handle,
+		     new_op,
+		     buffer_index);
+
+	new_op->uses_shared_memory = 1;
+	new_op->upcall.req.io.buf_index = buffer_index;
+	new_op->upcall.req.io.count = total_size;
+	new_op->upcall.req.io.offset = *offset;
+
+	gossip_debug(GOSSIP_FILE_DEBUG,
+		     "%s(%pU): copy_to_user %d nr_segs %lu, offset: %llu total_size: %zd\n",
+		     __func__,
+		     handle,
+		     to_user,
+		     nr_segs,
+		     llu(*offset),
+		     total_size);
+	/*
+	 * Stage 1: copy the buffers into client-core's address space
+	 * precopy_buffers only pertains to writes.
+	 */
+	if (type == PVFS_IO_WRITE) {
+		ret = precopy_buffers(bufmap,
+				      buffer_index,
+				      vec,
+				      nr_segs,
+				      total_size,
+				      to_user);
+		if (ret < 0)
+			goto out;
+	}
+
+	gossip_debug(GOSSIP_FILE_DEBUG,
+		     "%s(%pU): Calling post_io_request with tag (%llu)\n",
+		     __func__,
+		     handle,
+		     llu(new_op->tag));
+
+	/* Stage 2: Service the I/O operation */
+	ret = service_operation(new_op,
+				type == PVFS_IO_WRITE ?
+					"file_write" :
+					"file_read",
+				get_interruptible_flag(inode));
+
+	/*
+	 * If service_operation() returns -EAGAIN #and# the operation was
+	 * purged from pvfs2_request_list or htable_ops_in_progress, then
+	 * we know that the client was restarted, causing the shared memory
+	 * area to be wiped clean.  To restart a  write operation in this
+	 * case, we must re-copy the data from the user's iovec to a NEW
+	 * shared memory location. To restart a read operation, we must get
+	 * a new shared memory location.
+	 */
+	if (ret == -EAGAIN && op_state_purged(new_op)) {
+		pvfs_bufmap_put(bufmap, buffer_index);
+		gossip_debug(GOSSIP_FILE_DEBUG,
+			     "%s:going to repopulate_shared_memory.\n",
+			     __func__);
+		goto populate_shared_memory;
+	}
+
+	if (ret < 0) {
+		handle_io_error(); /* defined in pvfs2-kernel.h */
+		/*
+		   don't write an error to syslog on signaled operation
+		   termination unless we've got debugging turned on, as
+		   this can happen regularly (i.e. ctrl-c)
+		 */
+		if (ret == -EINTR)
+			gossip_debug(GOSSIP_FILE_DEBUG,
+				     "%s: returning error %ld\n", __func__,
+				     (long)ret);
+		else
+			gossip_err("%s: error in %s handle %pU, returning %zd\n",
+				__func__,
+				type == PVFS_IO_READ ?
+					"read from" : "write to",
+				handle, ret);
+		goto out;
+	}
+
+	/*
+	 * Stage 3: Post copy buffers from client-core's address space
+	 * postcopy_buffers only pertains to reads.
+	 */
+	if (type == PVFS_IO_READ) {
+		ret = postcopy_buffers(bufmap,
+				       buffer_index,
+				       vec,
+				       nr_segs,
+				       new_op->downcall.resp.io.amt_complete,
+				       to_user);
+		if (ret < 0) {
+			/*
+			 * put error codes in downcall so that handle_io_error()
+			 * preserves it properly
+			 */
+			new_op->downcall.status = ret;
+			handle_io_error();
+			goto out;
+		}
+	}
+	gossip_debug(GOSSIP_FILE_DEBUG,
+	    "%s(%pU): Amount written as returned by the sys-io call:%d\n",
+	    __func__,
+	    handle,
+	    (int)new_op->downcall.resp.io.amt_complete);
+
+	ret = new_op->downcall.resp.io.amt_complete;
+
+	/*
+	   tell the device file owner waiting on I/O that this read has
+	   completed and it can return now.  in this exact case, on
+	   wakeup the daemon will free the op, so we *cannot* touch it
+	   after this.
+	 */
+	wake_up_daemon_for_return(new_op);
+	new_op = NULL;
+
+out:
+	if (buffer_index >= 0) {
+		pvfs_bufmap_put(bufmap, buffer_index);
+		gossip_debug(GOSSIP_FILE_DEBUG,
+			     "%s(%pU): PUT buffer_index %d\n",
+			     __func__, handle, buffer_index);
+		buffer_index = -1;
+	}
+	if (new_op) {
+		op_release(new_op);
+		new_op = NULL;
+	}
+	return ret;
+}
+
+/*
+ * The reason we need to do this is to be able to support readv and writev
+ * that are larger than (pvfs_bufmap_size_query()) Default is
+ * PVFS2_BUFMAP_DEFAULT_DESC_SIZE MB. What that means is that we will
+ * create a new io vec descriptor for those memory addresses that
+ * go beyond the limit. Return value for this routine is negative in case
+ * of errors and 0 in case of success.
+ *
+ * Further, the new_nr_segs pointer is updated to hold the new value
+ * of number of iovecs, the new_vec pointer is updated to hold the pointer
+ * to the new split iovec, and the size array is an array of integers holding
+ * the number of iovecs that straddle pvfs_bufmap_size_query().
+ * The max_new_nr_segs value is computed by the caller and returned.
+ * (It will be (count of all iov_len/ block_size) + 1).
+ */
+static int split_iovecs(unsigned long max_new_nr_segs,		/* IN */
+			unsigned long nr_segs,			/* IN */
+			const struct iovec *original_iovec,	/* IN */
+			unsigned long *new_nr_segs,		/* OUT */
+			struct iovec **new_vec,			/* OUT */
+			unsigned long *seg_count,		/* OUT */
+			unsigned long **seg_array)		/* OUT */
+{
+	unsigned long seg;
+	unsigned long count = 0;
+	unsigned long begin_seg;
+	unsigned long tmpnew_nr_segs = 0;
+	struct iovec *new_iovec = NULL;
+	struct iovec *orig_iovec;
+	unsigned long *sizes = NULL;
+	unsigned long sizes_count = 0;
+
+	if (nr_segs <= 0 ||
+	    original_iovec == NULL ||
+	    new_nr_segs == NULL ||
+	    new_vec == NULL ||
+	    seg_count == NULL ||
+	    seg_array == NULL ||
+	    max_new_nr_segs <= 0) {
+		gossip_err("Invalid parameters to split_iovecs\n");
+		return -EINVAL;
+	}
+	*new_nr_segs = 0;
+	*new_vec = NULL;
+	*seg_count = 0;
+	*seg_array = NULL;
+	/* copy the passed in iovec descriptor to a temp structure */
+	orig_iovec = kmalloc_array(nr_segs,
+				   sizeof(*orig_iovec),
+				   PVFS2_BUFMAP_GFP_FLAGS);
+	if (orig_iovec == NULL) {
+		gossip_err(
+		    "split_iovecs: Could not allocate memory for %lu bytes!\n",
+		    (unsigned long)(nr_segs * sizeof(*orig_iovec)));
+		return -ENOMEM;
+	}
+	new_iovec = kcalloc(max_new_nr_segs,
+			    sizeof(*new_iovec),
+			    PVFS2_BUFMAP_GFP_FLAGS);
+	if (new_iovec == NULL) {
+		kfree(orig_iovec);
+		gossip_err(
+		    "split_iovecs: Could not allocate memory for %lu bytes!\n",
+		    (unsigned long)(max_new_nr_segs * sizeof(*new_iovec)));
+		return -ENOMEM;
+	}
+	sizes = kcalloc(max_new_nr_segs,
+			sizeof(*sizes),
+			PVFS2_BUFMAP_GFP_FLAGS);
+	if (sizes == NULL) {
+		kfree(new_iovec);
+		kfree(orig_iovec);
+		gossip_err(
+		    "split_iovecs: Could not allocate memory for %lu bytes!\n",
+		    (unsigned long)(max_new_nr_segs * sizeof(*sizes)));
+		return -ENOMEM;
+	}
+	/* copy the passed in iovec to a temp structure */
+	memcpy(orig_iovec, original_iovec, nr_segs * sizeof(*orig_iovec));
+	begin_seg = 0;
+repeat:
+	for (seg = begin_seg; seg < nr_segs; seg++) {
+		if (tmpnew_nr_segs >= max_new_nr_segs ||
+		    sizes_count >= max_new_nr_segs) {
+			kfree(sizes);
+			kfree(orig_iovec);
+			kfree(new_iovec);
+			gossip_err
+			    ("split_iovecs: exceeded the index limit (%lu)\n",
+			    tmpnew_nr_segs);
+			return -EINVAL;
+		}
+		if (count + orig_iovec[seg].iov_len <
+		    pvfs_bufmap_size_query()) {
+			count += orig_iovec[seg].iov_len;
+			memcpy(&new_iovec[tmpnew_nr_segs],
+			       &orig_iovec[seg],
+			       sizeof(*new_iovec));
+			tmpnew_nr_segs++;
+			sizes[sizes_count]++;
+		} else {
+			new_iovec[tmpnew_nr_segs].iov_base =
+			    orig_iovec[seg].iov_base;
+			new_iovec[tmpnew_nr_segs].iov_len =
+			    (pvfs_bufmap_size_query() - count);
+			tmpnew_nr_segs++;
+			sizes[sizes_count]++;
+			sizes_count++;
+			begin_seg = seg;
+			orig_iovec[seg].iov_base +=
+			    (pvfs_bufmap_size_query() - count);
+			orig_iovec[seg].iov_len -=
+			    (pvfs_bufmap_size_query() - count);
+			count = 0;
+			break;
+		}
+	}
+	if (seg != nr_segs)
+		goto repeat;
+	else
+		sizes_count++;
+
+	*new_nr_segs = tmpnew_nr_segs;
+	/* new_iovec is freed by the caller */
+	*new_vec = new_iovec;
+	*seg_count = sizes_count;
+	/* seg_array is also freed by the caller */
+	*seg_array = sizes;
+	kfree(orig_iovec);
+	return 0;
+}
+
+static long bound_max_iovecs(const struct iovec *curr, unsigned long nr_segs,
+			     ssize_t *total_count)
+{
+	unsigned long i;
+	long max_nr_iovecs;
+	ssize_t total;
+	ssize_t count;
+
+	total = 0;
+	count = 0;
+	max_nr_iovecs = 0;
+	for (i = 0; i < nr_segs; i++) {
+		const struct iovec *iv = &curr[i];
+
+		count += iv->iov_len;
+		if (unlikely((ssize_t) (count | iv->iov_len) < 0))
+			return -EINVAL;
+		if (total + iv->iov_len < pvfs_bufmap_size_query()) {
+			total += iv->iov_len;
+			max_nr_iovecs++;
+		} else {
+			total =
+			    (total + iv->iov_len - pvfs_bufmap_size_query());
+			max_nr_iovecs += (total / pvfs_bufmap_size_query() + 2);
+		}
+	}
+	*total_count = count;
+	return max_nr_iovecs;
+}
+
+/*
+ * Common entry point for read/write/readv/writev
+ * This function will dispatch it to either the direct I/O
+ * or buffered I/O path depending on the mount options and/or
+ * augmented/extended metadata attached to the file.
+ * Note: File extended attributes override any mount options.
+ */
+static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
+		loff_t *offset, const struct iovec *iov, unsigned long nr_segs)
+{
+	struct inode *inode = file->f_mapping->host;
+	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	struct pvfs2_khandle *handle = &pvfs2_inode->refn.khandle;
+	ssize_t ret;
+	ssize_t total_count;
+	unsigned int to_free;
+	size_t count;
+	unsigned long seg;
+	unsigned long new_nr_segs = 0;
+	unsigned long max_new_nr_segs = 0;
+	unsigned long seg_count = 0;
+	unsigned long *seg_array = NULL;
+	struct iovec *iovecptr = NULL;
+	struct iovec *ptr = NULL;
+
+	total_count = 0;
+	ret = -EINVAL;
+	count = 0;
+	to_free = 0;
+
+	/* Compute total and max number of segments after split */
+	max_new_nr_segs = bound_max_iovecs(iov, nr_segs, &count);
+	if (max_new_nr_segs < 0) {
+		gossip_lerr("%s: could not bound iovec %lu\n",
+			    __func__,
+			    max_new_nr_segs);
+		goto out;
+	}
+
+	gossip_debug(GOSSIP_FILE_DEBUG,
+		"%s-BEGIN(%pU): count(%d) after estimate_max_iovecs.\n",
+		__func__,
+		handle,
+		(int)count);
+
+	if (type == PVFS_IO_WRITE) {
+		gossip_debug(GOSSIP_FILE_DEBUG,
+			     "%s(%pU): proceeding with offset : %llu, "
+			     "size %d\n",
+			     __func__,
+			     handle,
+			     llu(*offset),
+			     (int)count);
+	}
+
+	if (count == 0) {
+		ret = 0;
+		goto out;
+	}
+
+	/*
+	 * if the total size of data transfer requested is greater than
+	 * the kernel-set blocksize of PVFS2, then we split the iovecs
+	 * such that no iovec description straddles a block size limit
+	 */
+
+	gossip_debug(GOSSIP_FILE_DEBUG,
+		     "%s: pvfs_bufmap_size:%d\n",
+		     __func__,
+		     pvfs_bufmap_size_query());
+
+	if (count > pvfs_bufmap_size_query()) {
+		/*
+		 * Split up the given iovec description such that
+		 * no iovec descriptor straddles over the block-size limitation.
+		 * This makes us our job easier to stage the I/O.
+		 * In addition, this function will also compute an array
+		 * with seg_count entries that will store the number of
+		 * segments that straddle the block-size boundaries.
+		 */
+		ret = split_iovecs(max_new_nr_segs,	/* IN */
+				   nr_segs,		/* IN */
+				   iov,			/* IN */
+				   &new_nr_segs,	/* OUT */
+				   &iovecptr,		/* OUT */
+				   &seg_count,		/* OUT */
+				   &seg_array);		/* OUT */
+		if (ret < 0) {
+			gossip_err("%s: Failed to split iovecs to satisfy larger than blocksize readv/writev request %zd\n",
+				__func__,
+				ret);
+			goto out;
+		}
+		gossip_debug(GOSSIP_FILE_DEBUG,
+			     "%s: Splitting iovecs from %lu to %lu"
+			     " [max_new %lu]\n",
+			     __func__,
+			     nr_segs,
+			     new_nr_segs,
+			     max_new_nr_segs);
+		/* We must free seg_array and iovecptr */
+		to_free = 1;
+	} else {
+		new_nr_segs = nr_segs;
+		/* use the given iovec description */
+		iovecptr = (struct iovec *)iov;
+		/* There is only 1 element in the seg_array */
+		seg_count = 1;
+		/* and its value is the number of segments passed in */
+		seg_array = &nr_segs;
+		/* We dont have to free up anything */
+		to_free = 0;
+	}
+	ptr = iovecptr;
+
+	gossip_debug(GOSSIP_FILE_DEBUG,
+		     "%s(%pU) %zd@%llu\n",
+		     __func__,
+		     handle,
+		     count,
+		     llu(*offset));
+	gossip_debug(GOSSIP_FILE_DEBUG,
+		     "%s(%pU): new_nr_segs: %lu, seg_count: %lu\n",
+		     __func__,
+		     handle,
+		     new_nr_segs, seg_count);
+
+/* PVFS2_KERNEL_DEBUG is a CFLAGS define. */
+#ifdef PVFS2_KERNEL_DEBUG
+	for (seg = 0; seg < new_nr_segs; seg++)
+		gossip_debug(GOSSIP_FILE_DEBUG,
+			     "%s: %d) %p to %p [%d bytes]\n",
+			     __func__,
+			     (int)seg + 1,
+			     iovecptr[seg].iov_base,
+			     iovecptr[seg].iov_base + iovecptr[seg].iov_len,
+			     (int)iovecptr[seg].iov_len);
+	for (seg = 0; seg < seg_count; seg++)
+		gossip_debug(GOSSIP_FILE_DEBUG,
+			     "%s: %zd) %lu\n",
+			     __func__,
+			     seg + 1,
+			     seg_array[seg]);
+#endif
+	seg = 0;
+	while (total_count < count) {
+		size_t each_count;
+		size_t amt_complete;
+
+		/* how much to transfer in this loop iteration */
+		each_count =
+		   (((count - total_count) > pvfs_bufmap_size_query()) ?
+			pvfs_bufmap_size_query() :
+			(count - total_count));
+
+		gossip_debug(GOSSIP_FILE_DEBUG,
+			     "%s(%pU): size of each_count(%d)\n",
+			     __func__,
+			     handle,
+			     (int)each_count);
+		gossip_debug(GOSSIP_FILE_DEBUG,
+			     "%s(%pU): BEFORE wait_for_io: offset is %d\n",
+			     __func__,
+			     handle,
+			     (int)*offset);
+
+		ret = wait_for_direct_io(type, inode, offset, ptr,
+				seg_array[seg], each_count, 0, 1);
+		gossip_debug(GOSSIP_FILE_DEBUG,
+			     "%s(%pU): return from wait_for_io:%d\n",
+			     __func__,
+			     handle,
+			     (int)ret);
+
+		if (ret < 0)
+			goto out;
+
+		/* advance the iovec pointer */
+		ptr += seg_array[seg];
+		seg++;
+		*offset += ret;
+		total_count += ret;
+		amt_complete = ret;
+
+		gossip_debug(GOSSIP_FILE_DEBUG,
+			     "%s(%pU): AFTER wait_for_io: offset is %d\n",
+			     __func__,
+			     handle,
+			     (int)*offset);
+
+		/*
+		 * if we got a short I/O operations,
+		 * fall out and return what we got so far
+		 */
+		if (amt_complete < each_count)
+			break;
+	} /*end while */
+
+	if (total_count > 0)
+		ret = total_count;
+out:
+	if (to_free) {
+		kfree(iovecptr);
+		kfree(seg_array);
+	}
+	if (ret > 0) {
+		if (type == PVFS_IO_READ) {
+			file_accessed(file);
+		} else {
+			SetMtimeFlag(pvfs2_inode);
+			inode->i_mtime = CURRENT_TIME;
+			mark_inode_dirty_sync(inode);
+		}
+	}
+
+	gossip_debug(GOSSIP_FILE_DEBUG,
+		     "%s(%pU): Value(%d) returned.\n",
+		     __func__,
+		     handle,
+		     (int)ret);
+
+	return ret;
+}
+
+/*
+ * Read data from a specified offset in a file (referenced by inode).
+ * Data may be placed either in a user or kernel buffer.
+ */
+ssize_t pvfs2_inode_read(struct inode *inode,
+			 char __user *buf,
+			 size_t count,
+			 loff_t *offset,
+			 loff_t readahead_size)
+{
+	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	size_t bufmap_size;
+	struct iovec vec;
+	ssize_t ret = -EINVAL;
+
+	g_pvfs2_stats.reads++;
+
+	vec.iov_base = buf;
+	vec.iov_len = count;
+
+	bufmap_size = pvfs_bufmap_size_query();
+	if (count > bufmap_size) {
+		gossip_debug(GOSSIP_FILE_DEBUG,
+			     "%s: count is too large (%zd/%zd)!\n",
+			     __func__, count, bufmap_size);
+		return -EINVAL;
+	}
+
+	gossip_debug(GOSSIP_FILE_DEBUG,
+		     "%s(%pU) %zd@%llu\n",
+		     __func__,
+		     &pvfs2_inode->refn.khandle,
+		     count,
+		     llu(*offset));
+
+	ret = wait_for_direct_io(PVFS_IO_READ, inode, offset, &vec, 1,
+			count, readahead_size, 0);
+	if (ret > 0)
+		*offset += ret;
+
+	gossip_debug(GOSSIP_FILE_DEBUG,
+		     "%s(%pU): Value(%zd) returned.\n",
+		     __func__,
+		     &pvfs2_inode->refn.khandle,
+		     ret);
+
+	return ret;
+}
+
+static ssize_t pvfs2_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)
+{
+	struct file *file = iocb->ki_filp;
+	loff_t pos = *(&iocb->ki_pos);
+	ssize_t rc = 0;
+	unsigned long nr_segs = iter->nr_segs;
+
+	BUG_ON(iocb->private);
+
+	gossip_debug(GOSSIP_FILE_DEBUG, "pvfs2_file_read_iter\n");
+
+	g_pvfs2_stats.reads++;
+
+	rc = do_readv_writev(PVFS_IO_READ,
+			     file,
+			     &pos,
+			     iter->iov,
+			     nr_segs);
+	iocb->ki_pos = pos;
+
+	return rc;
+}
+
+static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
+{
+	struct file *file = iocb->ki_filp;
+	loff_t pos = *(&iocb->ki_pos);
+	unsigned long nr_segs = iter->nr_segs;
+	ssize_t rc;
+
+	BUG_ON(iocb->private);
+
+	gossip_debug(GOSSIP_FILE_DEBUG, "pvfs2_file_write_iter\n");
+
+	mutex_lock(&file->f_mapping->host->i_mutex);
+
+	/* Make sure generic_write_checks sees an up to date inode size. */
+	if (file->f_flags & O_APPEND) {
+		rc = pvfs2_inode_getattr(file->f_mapping->host,
+					 PVFS_ATTR_SYS_SIZE);
+		if (rc) {
+			gossip_err("%s: pvfs2_inode_getattr failed, rc:%zd:.\n",
+				   __func__, rc);
+			goto out;
+		}
+	}
+
+	if (file->f_pos > i_size_read(file->f_mapping->host))
+		pvfs2_i_size_write(file->f_mapping->host, file->f_pos);
+
+	rc = generic_write_checks(iocb, iter);
+
+	if (rc <= 0) {
+		gossip_err("%s: generic_write_checks failed, rc:%zd:.\n",
+			   __func__, rc);
+		goto out;
+	}
+
+	rc = do_readv_writev(PVFS_IO_WRITE,
+			     file,
+			     &pos,
+			     iter->iov,
+			     nr_segs);
+	if (rc < 0) {
+		gossip_err("%s: do_readv_writev failed, rc:%zd:.\n",
+			   __func__, rc);
+		goto out;
+	}
+
+	iocb->ki_pos = pos;
+	g_pvfs2_stats.writes++;
+
+out:
+
+	mutex_unlock(&file->f_mapping->host->i_mutex);
+	return rc;
+}
+
+/*
+ * Perform a miscellaneous operation on a file.
+ */
+long pvfs2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret = -ENOTTY;
+	__u64 val = 0;
+	unsigned long uval;
+
+	gossip_debug(GOSSIP_FILE_DEBUG,
+		     "pvfs2_ioctl: called with cmd %d\n",
+		     cmd);
+
+	/*
+	 * we understand some general ioctls on files, such as the immutable
+	 * and append flags
+	 */
+	if (cmd == FS_IOC_GETFLAGS) {
+		val = 0;
+		ret = pvfs2_xattr_get_default(file->f_path.dentry,
+					      "user.pvfs2.meta_hint",
+					      &val,
+					      sizeof(val),
+					      0);
+		if (ret < 0 && ret != -ENODATA)
+			return ret;
+		else if (ret == -ENODATA)
+			val = 0;
+		uval = val;
+		gossip_debug(GOSSIP_FILE_DEBUG,
+			     "pvfs2_ioctl: FS_IOC_GETFLAGS: %llu\n",
+			     (unsigned long long)uval);
+		return put_user(uval, (int __user *)arg);
+	} else if (cmd == FS_IOC_SETFLAGS) {
+		ret = 0;
+		if (get_user(uval, (int __user *)arg))
+			return -EFAULT;
+		/*
+		 * PVFS_MIRROR_FL is set internally when the mirroring mode
+		 * is turned on for a file. The user is not allowed to turn
+		 * on this bit, but the bit is present if the user first gets
+		 * the flags and then updates the flags with some new
+		 * settings. So, we ignore it in the following edit. bligon.
+		 */
+		if ((uval & ~PVFS_MIRROR_FL) &
+		    (~(FS_IMMUTABLE_FL | FS_APPEND_FL | FS_NOATIME_FL))) {
+			gossip_err("pvfs2_ioctl: the FS_IOC_SETFLAGS only supports setting one of FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NOATIME_FL\n");
+			return -EINVAL;
+		}
+		val = uval;
+		gossip_debug(GOSSIP_FILE_DEBUG,
+			     "pvfs2_ioctl: FS_IOC_SETFLAGS: %llu\n",
+			     (unsigned long long)val);
+		ret = pvfs2_xattr_set_default(file->f_path.dentry,
+					      "user.pvfs2.meta_hint",
+					      &val,
+					      sizeof(val),
+					      0,
+					      0);
+	}
+
+	return ret;
+}
+
+/*
+ * Memory map a region of a file.
+ */
+static int pvfs2_file_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	gossip_debug(GOSSIP_FILE_DEBUG,
+		     "pvfs2_file_mmap: called on %s\n",
+		     (file ?
+			(char *)file->f_path.dentry->d_name.name :
+			(char *)"Unknown"));
+
+	/* set the sequential readahead hint */
+	vma->vm_flags |= VM_SEQ_READ;
+	vma->vm_flags &= ~VM_RAND_READ;
+	return generic_file_mmap(file, vma);
+}
+
+#define mapping_nrpages(idata) ((idata)->nrpages)
+
+/*
+ * Called to notify the module that there are no more references to
+ * this file (i.e. no processes have it open).
+ *
+ * \note Not called when each file is closed.
+ */
+int pvfs2_file_release(struct inode *inode, struct file *file)
+{
+	gossip_debug(GOSSIP_FILE_DEBUG,
+		     "pvfs2_file_release: called on %s\n",
+		     file->f_path.dentry->d_name.name);
+
+	pvfs2_flush_inode(inode);
+
+	/*
+	   remove all associated inode pages from the page cache and mmap
+	   readahead cache (if any); this forces an expensive refresh of
+	   data for the next caller of mmap (or 'get_block' accesses)
+	 */
+	if (file->f_path.dentry->d_inode &&
+	    file->f_path.dentry->d_inode->i_mapping &&
+	    mapping_nrpages(&file->f_path.dentry->d_inode->i_data))
+		truncate_inode_pages(file->f_path.dentry->d_inode->i_mapping,
+				     0);
+	return 0;
+}
+
+/*
+ * Push all data for a specific file onto permanent storage.
+ */
+int pvfs2_fsync(struct file *file, loff_t start, loff_t end, int datasync)
+{
+	int ret = -EINVAL;
+	struct pvfs2_inode_s *pvfs2_inode =
+		PVFS2_I(file->f_path.dentry->d_inode);
+	struct pvfs2_kernel_op_s *new_op = NULL;
+
+	/* required call */
+	filemap_write_and_wait_range(file->f_mapping, start, end);
+
+	new_op = op_alloc(PVFS2_VFS_OP_FSYNC);
+	if (!new_op)
+		return -ENOMEM;
+	new_op->upcall.req.fsync.refn = pvfs2_inode->refn;
+
+	ret = service_operation(new_op,
+			"pvfs2_fsync",
+			get_interruptible_flag(file->f_path.dentry->d_inode));
+
+	gossip_debug(GOSSIP_FILE_DEBUG,
+		     "pvfs2_fsync got return value of %d\n",
+		     ret);
+
+	op_release(new_op);
+
+	pvfs2_flush_inode(file->f_path.dentry->d_inode);
+	return ret;
+}
+
+/*
+ * Change the file pointer position for an instance of an open file.
+ *
+ * \note If .llseek is overriden, we must acquire lock as described in
+ *       Documentation/filesystems/Locking.
+ *
+ * Future upgrade could support SEEK_DATA and SEEK_HOLE but would
+ * require much changes to the FS
+ */
+loff_t pvfs2_file_llseek(struct file *file, loff_t offset, int origin)
+{
+	int ret = -EINVAL;
+	struct inode *inode = file->f_path.dentry->d_inode;
+
+	if (!inode) {
+		gossip_err("pvfs2_file_llseek: invalid inode (NULL)\n");
+		return ret;
+	}
+
+	if (origin == PVFS2_SEEK_END) {
+		/*
+		 * revalidate the inode's file size.
+		 * NOTE: We are only interested in file size here,
+		 * so we set mask accordingly.
+		 */
+		ret = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_SIZE);
+		if (ret) {
+			gossip_debug(GOSSIP_FILE_DEBUG,
+				     "%s:%s:%d calling make bad inode\n",
+				     __FILE__,
+				     __func__,
+				     __LINE__);
+			pvfs2_make_bad_inode(inode);
+			return ret;
+		}
+	}
+
+	gossip_debug(GOSSIP_FILE_DEBUG,
+		     "pvfs2_file_llseek: offset is %ld | origin is %d | "
+		     "inode size is %lu\n",
+		     (long)offset,
+		     origin,
+		     (unsigned long)file->f_path.dentry->d_inode->i_size);
+
+	return generic_file_llseek(file, offset, origin);
+}
+
+/*
+ * Support local locks (locks that only this kernel knows about)
+ * if Orangefs was mounted -o local_lock.
+ */
+int pvfs2_lock(struct file *filp, int cmd, struct file_lock *fl)
+{
+	int rc = -ENOLCK;
+
+	if (PVFS2_SB(filp->f_inode->i_sb)->flags & PVFS2_OPT_LOCAL_LOCK) {
+		if (cmd == F_GETLK) {
+			rc = 0;
+			posix_test_lock(filp, fl);
+		} else {
+			rc = posix_lock_file(filp, fl, NULL);
+		}
+	}
+
+	return rc;
+}
+
+/** PVFS2 implementation of VFS file operations */
+const struct file_operations pvfs2_file_operations = {
+	.llseek		= pvfs2_file_llseek,
+	.read_iter	= pvfs2_file_read_iter,
+	.write_iter	= pvfs2_file_write_iter,
+	.lock		= pvfs2_lock,
+	.unlocked_ioctl	= pvfs2_ioctl,
+	.mmap		= pvfs2_file_mmap,
+	.open		= generic_file_open,
+	.release	= pvfs2_file_release,
+	.fsync		= pvfs2_fsync,
+};
