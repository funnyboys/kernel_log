commit fc2e2e9c43e3b3f5dec8a02b17ee3d6343d9783a
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Dec 12 13:46:30 2017 -0500

    orangefs: implement xattr cache
    
    This uses the same timeout as the getattr cache.  This substantially
    increases performance when writing files with smaller buffer sizes.
    
    When writing, the size is (often) changed, which causes a call to
    notify_change which calls security_inode_need_killpriv which needs a
    getxattr.  Caching it reduces traffic to the server.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index 03bcb871544d..bdc285aea360 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
  * (C) 2001 Clemson University and The University of Chicago
+ * Copyright 2018 Omnibond Systems, L.L.C.
  *
  * See COPYING in top-level directory.
  */
@@ -14,7 +15,7 @@
 #include "orangefs-bufmap.h"
 #include <linux/posix_acl_xattr.h>
 #include <linux/xattr.h>
-
+#include <linux/hashtable.h>
 
 #define SYSTEM_ORANGEFS_KEY "system.pvfs2."
 #define SYSTEM_ORANGEFS_KEY_LEN 13
@@ -50,6 +51,35 @@ static inline int convert_to_internal_xattr_flags(int setxattr_flags)
 	return internal_flag;
 }
 
+static unsigned int xattr_key(const char *key)
+{
+	unsigned int i = 0;
+	while (key)
+		i += *key++;
+	return i % 16;
+}
+
+static struct orangefs_cached_xattr *find_cached_xattr(struct inode *inode,
+    const char *key)
+{
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_cached_xattr *cx;
+	struct hlist_head *h;
+	struct hlist_node *tmp;
+	h = &orangefs_inode->xattr_cache[xattr_key(key)];
+	if (hlist_empty(h))
+		return NULL;
+	hlist_for_each_entry_safe(cx, tmp, h, node) {
+/*		if (!time_before(jiffies, cx->timeout)) {
+			hlist_del(&cx->node);
+			kfree(cx);
+			continue;
+		}*/
+		if (!strcmp(cx->key, key))
+			return cx;
+	}
+	return NULL;
+}
 
 /*
  * Tries to get a specified key's attributes of a given
@@ -65,6 +95,7 @@ ssize_t orangefs_inode_getxattr(struct inode *inode, const char *name,
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_kernel_op_s *new_op = NULL;
+	struct orangefs_cached_xattr *cx;
 	ssize_t ret = -ENOMEM;
 	ssize_t length = 0;
 	int fsuid;
@@ -93,6 +124,27 @@ ssize_t orangefs_inode_getxattr(struct inode *inode, const char *name,
 
 	down_read(&orangefs_inode->xattr_sem);
 
+	cx = find_cached_xattr(inode, name);
+	if (cx && time_before(jiffies, cx->timeout)) {
+		if (cx->length == -1) {
+			ret = -ENODATA;
+			goto out_unlock;
+		} else {
+			if (size == 0) {
+				ret = cx->length;
+				goto out_unlock;
+			}
+			if (cx->length > size) {
+				ret = -ERANGE;
+				goto out_unlock;
+			}
+			memcpy(buffer, cx->val, cx->length);
+			memset(buffer + cx->length, 0, size - cx->length);
+			ret = cx->length;
+			goto out_unlock;
+		}
+	}
+
 	new_op = op_alloc(ORANGEFS_VFS_OP_GETXATTR);
 	if (!new_op)
 		goto out_unlock;
@@ -117,6 +169,15 @@ ssize_t orangefs_inode_getxattr(struct inode *inode, const char *name,
 				     " does not exist!\n",
 				     get_khandle_from_ino(inode),
 				     (char *)new_op->upcall.req.getxattr.key);
+			cx = kmalloc(sizeof *cx, GFP_KERNEL);
+			if (cx) {
+				strcpy(cx->key, name);
+				cx->length = -1;
+				cx->timeout = jiffies +
+				    orangefs_getattr_timeout_msecs*HZ/1000;
+				hash_add(orangefs_inode->xattr_cache, &cx->node,
+				    xattr_key(cx->key));
+			}
 		}
 		goto out_release_op;
 	}
@@ -156,6 +217,23 @@ ssize_t orangefs_inode_getxattr(struct inode *inode, const char *name,
 
 	ret = length;
 
+	if (cx) {
+		strcpy(cx->key, name);
+		memcpy(cx->val, buffer, length);
+		cx->length = length;
+		cx->timeout = jiffies + HZ;
+	} else {
+		cx = kmalloc(sizeof *cx, GFP_KERNEL);
+		if (cx) {
+			strcpy(cx->key, name);
+			memcpy(cx->val, buffer, length);
+			cx->length = length;
+			cx->timeout = jiffies + HZ;
+			hash_add(orangefs_inode->xattr_cache, &cx->node,
+			    xattr_key(cx->key));
+		}
+	}
+
 out_release_op:
 	op_release(new_op);
 out_unlock:
@@ -168,6 +246,9 @@ static int orangefs_inode_removexattr(struct inode *inode, const char *name,
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_kernel_op_s *new_op = NULL;
+	struct orangefs_cached_xattr *cx;
+	struct hlist_head *h;
+	struct hlist_node *tmp;
 	int ret = -ENOMEM;
 
 	if (strlen(name) >= ORANGEFS_MAX_XATTR_NAMELEN)
@@ -209,6 +290,16 @@ static int orangefs_inode_removexattr(struct inode *inode, const char *name,
 		     "orangefs_inode_removexattr: returning %d\n", ret);
 
 	op_release(new_op);
+
+	h = &orangefs_inode->xattr_cache[xattr_key(name)];
+	hlist_for_each_entry_safe(cx, tmp, h, node) {
+		if (!strcmp(cx->key, name)) {
+			hlist_del(&cx->node);
+			kfree(cx);
+			break;
+		}
+	}
+
 out_unlock:
 	up_write(&orangefs_inode->xattr_sem);
 	return ret;
@@ -226,6 +317,9 @@ int orangefs_inode_setxattr(struct inode *inode, const char *name,
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_kernel_op_s *new_op;
 	int internal_flag = 0;
+	struct orangefs_cached_xattr *cx;
+	struct hlist_head *h;
+	struct hlist_node *tmp;
 	int ret = -ENOMEM;
 
 	gossip_debug(GOSSIP_XATTR_DEBUG,
@@ -287,6 +381,16 @@ int orangefs_inode_setxattr(struct inode *inode, const char *name,
 
 	/* when request is serviced properly, free req op struct */
 	op_release(new_op);
+
+	h = &orangefs_inode->xattr_cache[xattr_key(name)];
+	hlist_for_each_entry_safe(cx, tmp, h, node) {
+		if (!strcmp(cx->key, name)) {
+			hlist_del(&cx->node);
+			kfree(cx);
+			break;
+		}
+	}
+
 out_unlock:
 	up_write(&orangefs_inode->xattr_sem);
 	return ret;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index 81ac88bb91ff..03bcb871544d 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * (C) 2001 Clemson University and The University of Chicago
  *

commit 0b08273c8ab7e688832120c4817b1adfdc56e231
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Aug 17 21:35:16 2017 +0200

    orangefs: Adjust three checks for null pointers
    
    MIME-Version: 1.0
    Content-Type: text/plain; charset=UTF-8
    Content-Transfer-Encoding: 8bit
    
    The script “checkpatch.pl” pointed information out like the following.
    
    Comparison to NULL could be written !…
    
    Thus fix affected source code places.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index fed0e9aae23b..81ac88bb91ff 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -239,7 +239,7 @@ int orangefs_inode_setxattr(struct inode *inode, const char *name,
 	internal_flag = convert_to_internal_xattr_flags(flags);
 
 	/* This is equivalent to a removexattr */
-	if (size == 0 && value == NULL) {
+	if (size == 0 && !value) {
 		gossip_debug(GOSSIP_XATTR_DEBUG,
 			     "removing xattr (%s)\n",
 			     name);
@@ -311,7 +311,7 @@ ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 	int i = 0;
 	int returned_count = 0;
 
-	if (size > 0 && buffer == NULL) {
+	if (size > 0 && !buffer) {
 		gossip_err("%s: bogus NULL pointers\n", __func__);
 		return -EINVAL;
 	}

commit 121744440582004a1751c688a2622e5dfeaae09d
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Wed Aug 2 10:35:14 2017 +0200

    orangefs: constify xattr_handler structure
    
    The xattr_handler structure is only stored in an array of const
    structures.  Thus the xattr_handler structure itself can be
    const.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index a34b25be39c5..fed0e9aae23b 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -442,7 +442,7 @@ static int orangefs_xattr_get_default(const struct xattr_handler *handler,
 
 }
 
-static struct xattr_handler orangefs_xattr_default_handler = {
+static const struct xattr_handler orangefs_xattr_default_handler = {
 	.prefix = "",  /* match any name => handlers called with full name */
 	.get = orangefs_xattr_get_default,
 	.set = orangefs_xattr_set_default,

commit 5f13e58767a53ebb54265e03c0c4a67650286263
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon May 22 15:08:31 2017 +0300

    orangefs: off by ones in xattr size checks
    
    A previous patch which claimed to remove off by ones actually introduced
    them.
    
    strlen() returns the length of the string not including the NUL
    character.  We are using strcpy() to copy "name" into a buffer which is
    ORANGEFS_MAX_XATTR_NAMELEN characters long.  We should make sure to
    leave space for the NUL, otherwise we're writing one character beyond
    the end of the buffer.
    
    Fixes: e675c5ec51fe ("orangefs: clean up oversize xattr validation")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index 237c9c04dc3b..a34b25be39c5 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -76,7 +76,7 @@ ssize_t orangefs_inode_getxattr(struct inode *inode, const char *name,
 	if (S_ISLNK(inode->i_mode))
 		return -EOPNOTSUPP;
 
-	if (strlen(name) > ORANGEFS_MAX_XATTR_NAMELEN)
+	if (strlen(name) >= ORANGEFS_MAX_XATTR_NAMELEN)
 		return -EINVAL;
 
 	fsuid = from_kuid(&init_user_ns, current_fsuid());
@@ -169,7 +169,7 @@ static int orangefs_inode_removexattr(struct inode *inode, const char *name,
 	struct orangefs_kernel_op_s *new_op = NULL;
 	int ret = -ENOMEM;
 
-	if (strlen(name) > ORANGEFS_MAX_XATTR_NAMELEN)
+	if (strlen(name) >= ORANGEFS_MAX_XATTR_NAMELEN)
 		return -EINVAL;
 
 	down_write(&orangefs_inode->xattr_sem);
@@ -233,7 +233,7 @@ int orangefs_inode_setxattr(struct inode *inode, const char *name,
 
 	if (size > ORANGEFS_MAX_XATTR_VALUELEN)
 		return -EINVAL;
-	if (strlen(name) > ORANGEFS_MAX_XATTR_NAMELEN)
+	if (strlen(name) >= ORANGEFS_MAX_XATTR_NAMELEN)
 		return -EINVAL;
 
 	internal_flag = convert_to_internal_xattr_flags(flags);

commit e675c5ec51fe2554719a7b6bcdbef0a770f2c19b
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 25 15:37:57 2017 -0400

    orangefs: clean up oversize xattr validation
    
    Also don't check flags as this has been validated by the VFS already.
    
    Fix an off-by-one error in the max size checking.
    
    Stop logging just because userspace wants to write attributes which do
    not fit.
    
    This and the previous commit fix xfstests generic/020.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index fba4db7d0512..237c9c04dc3b 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -76,11 +76,8 @@ ssize_t orangefs_inode_getxattr(struct inode *inode, const char *name,
 	if (S_ISLNK(inode->i_mode))
 		return -EOPNOTSUPP;
 
-	if (strlen(name) >= ORANGEFS_MAX_XATTR_NAMELEN) {
-		gossip_err("Invalid key length (%d)\n",
-			   (int)strlen(name));
+	if (strlen(name) > ORANGEFS_MAX_XATTR_NAMELEN)
 		return -EINVAL;
-	}
 
 	fsuid = from_kuid(&init_user_ns, current_fsuid());
 	fsgid = from_kgid(&init_user_ns, current_fsgid());
@@ -172,6 +169,9 @@ static int orangefs_inode_removexattr(struct inode *inode, const char *name,
 	struct orangefs_kernel_op_s *new_op = NULL;
 	int ret = -ENOMEM;
 
+	if (strlen(name) > ORANGEFS_MAX_XATTR_NAMELEN)
+		return -EINVAL;
+
 	down_write(&orangefs_inode->xattr_sem);
 	new_op = op_alloc(ORANGEFS_VFS_OP_REMOVEXATTR);
 	if (!new_op)
@@ -231,23 +231,13 @@ int orangefs_inode_setxattr(struct inode *inode, const char *name,
 		     "%s: name %s, buffer_size %zd\n",
 		     __func__, name, size);
 
-	if (size >= ORANGEFS_MAX_XATTR_VALUELEN ||
-	    flags < 0) {
-		gossip_err("orangefs_inode_setxattr: bogus values of size(%d), flags(%d)\n",
-			   (int)size,
-			   flags);
+	if (size > ORANGEFS_MAX_XATTR_VALUELEN)
+		return -EINVAL;
+	if (strlen(name) > ORANGEFS_MAX_XATTR_NAMELEN)
 		return -EINVAL;
-	}
 
 	internal_flag = convert_to_internal_xattr_flags(flags);
 
-	if (strlen(name) >= ORANGEFS_MAX_XATTR_NAMELEN) {
-		gossip_err
-		    ("orangefs_inode_setxattr: bogus key size (%d)\n",
-		     (int)(strlen(name)));
-		return -EINVAL;
-	}
-
 	/* This is equivalent to a removexattr */
 	if (size == 0 && value == NULL) {
 		gossip_debug(GOSSIP_XATTR_DEBUG,

commit a956af337b9ff25822d9ce1a59c6ed0c09fc14b9
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 25 15:37:56 2017 -0400

    orangefs: fix bounds check for listxattr
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index 74a81b1daaac..fba4db7d0512 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -358,7 +358,7 @@ ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 
 	returned_count = new_op->downcall.resp.listxattr.returned_count;
 	if (returned_count < 0 ||
-	    returned_count >= ORANGEFS_MAX_XATTR_LISTLEN) {
+	    returned_count > ORANGEFS_MAX_XATTR_LISTLEN) {
 		gossip_err("%s: impossible value for returned_count:%d:\n",
 		__func__,
 		returned_count);

commit 6c6ef9f26e598fb977f60935e109cd5b266c941a
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Sep 29 17:48:44 2016 +0200

    xattr: Stop calling {get,set,remove}xattr inode operations
    
    All filesystems that support xattrs by now do so via xattr handlers.
    They all define sb->s_xattr, and their getxattr, setxattr, and
    removexattr inode operations use the generic inode operations.  On
    filesystems that don't support xattrs, the xattr inode operations are
    all NULL, and sb->s_xattr is also NULL.
    
    This means that we can remove the getxattr, setxattr, and removexattr
    inode operations and directly call the generic handlers, or better,
    inline expand those handlers into fs/xattr.c.
    
    Filesystems that do not support xattrs on some inodes should clear the
    IOP_XATTR i_opflags flag in those inodes.  (Right now, some filesystems
    have checks to disable xattrs on some inodes in the ->list, ->get, and
    ->set xattr handler operations instead.)  The IOP_XATTR flag is
    automatically cleared in inodes of filesystems that don't have xattr
    support.
    
    In orangefs, symlinks do have a setxattr iop but no getxattr iop.  Add a
    check for symlinks to orangefs_inode_getxattr to preserve the current,
    weird behavior; that check may not be necessary though.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index 2a9f07f06d10..74a81b1daaac 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -73,6 +73,9 @@ ssize_t orangefs_inode_getxattr(struct inode *inode, const char *name,
 		     "%s: name %s, buffer_size %zd\n",
 		     __func__, name, size);
 
+	if (S_ISLNK(inode->i_mode))
+		return -EOPNOTSUPP;
+
 	if (strlen(name) >= ORANGEFS_MAX_XATTR_NAMELEN) {
 		gossip_err("Invalid key length (%d)\n",
 			   (int)strlen(name));

commit 78fee0b6846f27872321338db6afe280f059ae99
Author: Jann Horn <jannh@google.com>
Date:   Sat Jun 25 01:51:52 2016 +0200

    orangefs: fix namespace handling
    
    In orangefs_inode_getxattr(), an fsuid is written to dmesg. The kuid is
    converted to a userspace uid via from_kuid(current_user_ns(), [...]), but
    since dmesg is global, init_user_ns should be used here instead.
    
    In copy_attributes_from_inode(), op_alloc() and fill_default_sys_attrs(),
    upcall structures are populated with uids/gids that have been mapped into
    the caller's namespace. However, those upcall structures are read by
    another process (the userspace filesystem driver), and that process might
    be running in another namespace. This effectively lets any user spoof its
    uid and gid as seen by the userspace filesystem driver.
    
    To fix the second issue, I just construct the opcall structures with
    init_user_ns uids/gids and require the filesystem server to run in the
    init namespace. Since orangefs is full of global state anyway (as the error
    message in DUMP_DEVICE_ERROR explains, there can only be one userspace
    orangefs filesystem driver at once), that shouldn't be a problem.
    
    [
    Why does orangefs even exist in the kernel if everything does upcalls into
    userspace? What does orangefs do that couldn't be done with the FUSE
    interface? If there is no good answer to those questions, I'd prefer to see
    orangefs kicked out of the kernel. Can that be done for something that
    shipped in a release?
    
    According to commit f7ab093f74bf ("Orangefs: kernel client part 1"), they
    even already have a FUSE daemon, and the only rational reason (apart from
    "but most of our users report preferring to use our kernel module instead")
    given for not wanting to use FUSE is one "in-the-works" feature that could
    probably be integated into FUSE instead.
    ]
    
    This patch has been compile-tested.
    
    Signed-off-by: Jann Horn <jannh@google.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index 73a0c3411d4b..2a9f07f06d10 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -79,8 +79,8 @@ ssize_t orangefs_inode_getxattr(struct inode *inode, const char *name,
 		return -EINVAL;
 	}
 
-	fsuid = from_kuid(current_user_ns(), current_fsuid());
-	fsgid = from_kgid(current_user_ns(), current_fsgid());
+	fsuid = from_kuid(&init_user_ns, current_fsuid());
+	fsgid = from_kgid(&init_user_ns, current_fsgid());
 
 	gossip_debug(GOSSIP_XATTR_DEBUG,
 		     "getxattr on inode %pU, name %s "

commit d373a712c1142a4e119e359df63c192afa9bb2fb
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Sat Jun 4 11:02:33 2016 +0200

    orangefs: Remove useless xattr prefix arguments
    
    Mike,
    
    On Fri, Jun 3, 2016 at 9:44 PM, Mike Marshall <hubcap@omnibond.com> wrote:
    > We use the return value in this one line you changed, our userspace code gets
    > ill when we send it (-ENOMEM +1) as a key length...
    
    ah, my mistake.  Here's a fixed version.
    
    Thanks,
    Andreas
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index 640a98f9144d..73a0c3411d4b 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -59,8 +59,8 @@ static inline int convert_to_internal_xattr_flags(int setxattr_flags)
  * unless the key does not exist for the file and/or if
  * there were errors in fetching the attribute value.
  */
-ssize_t orangefs_inode_getxattr(struct inode *inode, const char *prefix,
-		const char *name, void *buffer, size_t size)
+ssize_t orangefs_inode_getxattr(struct inode *inode, const char *name,
+				void *buffer, size_t size)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_kernel_op_s *new_op = NULL;
@@ -70,12 +70,12 @@ ssize_t orangefs_inode_getxattr(struct inode *inode, const char *prefix,
 	int fsgid;
 
 	gossip_debug(GOSSIP_XATTR_DEBUG,
-		     "%s: prefix %s name %s, buffer_size %zd\n",
-		     __func__, prefix, name, size);
+		     "%s: name %s, buffer_size %zd\n",
+		     __func__, name, size);
 
-	if ((strlen(name) + strlen(prefix)) >= ORANGEFS_MAX_XATTR_NAMELEN) {
+	if (strlen(name) >= ORANGEFS_MAX_XATTR_NAMELEN) {
 		gossip_err("Invalid key length (%d)\n",
-			   (int)(strlen(name) + strlen(prefix)));
+			   (int)strlen(name));
 		return -EINVAL;
 	}
 
@@ -97,15 +97,14 @@ ssize_t orangefs_inode_getxattr(struct inode *inode, const char *prefix,
 		goto out_unlock;
 
 	new_op->upcall.req.getxattr.refn = orangefs_inode->refn;
-	ret = snprintf((char *)new_op->upcall.req.getxattr.key,
-		       ORANGEFS_MAX_XATTR_NAMELEN, "%s%s", prefix, name);
+	strcpy(new_op->upcall.req.getxattr.key, name);
 
 	/*
 	 * NOTE: Although keys are meant to be NULL terminated textual
 	 * strings, I am going to explicitly pass the length just in case
 	 * we change this later on...
 	 */
-	new_op->upcall.req.getxattr.key_sz = ret + 1;
+	new_op->upcall.req.getxattr.key_sz = strlen(name) + 1;
 
 	ret = service_operation(new_op, "orangefs_inode_getxattr",
 				get_interruptible_flag(inode));
@@ -163,10 +162,8 @@ ssize_t orangefs_inode_getxattr(struct inode *inode, const char *prefix,
 	return ret;
 }
 
-static int orangefs_inode_removexattr(struct inode *inode,
-			    const char *prefix,
-			    const char *name,
-			    int flags)
+static int orangefs_inode_removexattr(struct inode *inode, const char *name,
+				      int flags)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_kernel_op_s *new_op = NULL;
@@ -183,12 +180,8 @@ static int orangefs_inode_removexattr(struct inode *inode,
 	 * textual strings, I am going to explicitly pass the
 	 * length just in case we change this later on...
 	 */
-	ret = snprintf((char *)new_op->upcall.req.removexattr.key,
-		       ORANGEFS_MAX_XATTR_NAMELEN,
-		       "%s%s",
-		       (prefix ? prefix : ""),
-		       name);
-	new_op->upcall.req.removexattr.key_sz = ret + 1;
+	strcpy(new_op->upcall.req.removexattr.key, name);
+	new_op->upcall.req.removexattr.key_sz = strlen(name) + 1;
 
 	gossip_debug(GOSSIP_XATTR_DEBUG,
 		     "orangefs_inode_removexattr: key %s, key_sz %d\n",
@@ -223,8 +216,8 @@ static int orangefs_inode_removexattr(struct inode *inode,
  * Returns a -ve number on error and 0 on success.  Key is text, but value
  * can be binary!
  */
-int orangefs_inode_setxattr(struct inode *inode, const char *prefix,
-		const char *name, const void *value, size_t size, int flags)
+int orangefs_inode_setxattr(struct inode *inode, const char *name,
+			    const void *value, size_t size, int flags)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_kernel_op_s *new_op;
@@ -232,8 +225,8 @@ int orangefs_inode_setxattr(struct inode *inode, const char *prefix,
 	int ret = -ENOMEM;
 
 	gossip_debug(GOSSIP_XATTR_DEBUG,
-		     "%s: prefix %s, name %s, buffer_size %zd\n",
-		     __func__, prefix, name, size);
+		     "%s: name %s, buffer_size %zd\n",
+		     __func__, name, size);
 
 	if (size >= ORANGEFS_MAX_XATTR_VALUELEN ||
 	    flags < 0) {
@@ -245,29 +238,19 @@ int orangefs_inode_setxattr(struct inode *inode, const char *prefix,
 
 	internal_flag = convert_to_internal_xattr_flags(flags);
 
-	if (prefix) {
-		if (strlen(name) + strlen(prefix) >= ORANGEFS_MAX_XATTR_NAMELEN) {
-			gossip_err
-			    ("orangefs_inode_setxattr: bogus key size (%d)\n",
-			     (int)(strlen(name) + strlen(prefix)));
-			return -EINVAL;
-		}
-	} else {
-		if (strlen(name) >= ORANGEFS_MAX_XATTR_NAMELEN) {
-			gossip_err
-			    ("orangefs_inode_setxattr: bogus key size (%d)\n",
-			     (int)(strlen(name)));
-			return -EINVAL;
-		}
+	if (strlen(name) >= ORANGEFS_MAX_XATTR_NAMELEN) {
+		gossip_err
+		    ("orangefs_inode_setxattr: bogus key size (%d)\n",
+		     (int)(strlen(name)));
+		return -EINVAL;
 	}
 
 	/* This is equivalent to a removexattr */
 	if (size == 0 && value == NULL) {
 		gossip_debug(GOSSIP_XATTR_DEBUG,
-			     "removing xattr (%s%s)\n",
-			     prefix,
+			     "removing xattr (%s)\n",
 			     name);
-		return orangefs_inode_removexattr(inode, prefix, name, flags);
+		return orangefs_inode_removexattr(inode, name, flags);
 	}
 
 	gossip_debug(GOSSIP_XATTR_DEBUG,
@@ -288,11 +271,8 @@ int orangefs_inode_setxattr(struct inode *inode, const char *prefix,
 	 * strings, I am going to explicitly pass the length just in
 	 * case we change this later on...
 	 */
-	ret = snprintf((char *)new_op->upcall.req.setxattr.keyval.key,
-		       ORANGEFS_MAX_XATTR_NAMELEN,
-		       "%s%s",
-		       prefix, name);
-	new_op->upcall.req.setxattr.keyval.key_sz = ret + 1;
+	strcpy(new_op->upcall.req.setxattr.keyval.key, name);
+	new_op->upcall.req.setxattr.keyval.key_sz = strlen(name) + 1;
 	memcpy(new_op->upcall.req.setxattr.keyval.val, value, size);
 	new_op->upcall.req.setxattr.keyval.val_sz = size;
 
@@ -455,12 +435,7 @@ static int orangefs_xattr_set_default(const struct xattr_handler *handler,
 				      size_t size,
 				      int flags)
 {
-	return orangefs_inode_setxattr(inode,
-				    "",
-				    name,
-				    buffer,
-				    size,
-				    flags);
+	return orangefs_inode_setxattr(inode, name, buffer, size, flags);
 }
 
 static int orangefs_xattr_get_default(const struct xattr_handler *handler,
@@ -470,11 +445,7 @@ static int orangefs_xattr_get_default(const struct xattr_handler *handler,
 				      void *buffer,
 				      size_t size)
 {
-	return orangefs_inode_getxattr(inode,
-				    "",
-				    name,
-				    buffer,
-				    size);
+	return orangefs_inode_getxattr(inode, name, buffer, size);
 
 }
 

commit 2ce8272a1014d9d0d2f859ffba9a815f9ce12f99
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Mon May 30 11:26:00 2016 +0200

    orangefs: Remove redundant "trusted." xattr handler
    
    Orangefs has a catch-all xattr handler that effectively does what the
    trusted handler does already.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index f387e8ad477b..640a98f9144d 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -478,42 +478,6 @@ static int orangefs_xattr_get_default(const struct xattr_handler *handler,
 
 }
 
-static int orangefs_xattr_set_trusted(const struct xattr_handler *handler,
-				     struct dentry *unused,
-				     struct inode *inode,
-				     const char *name,
-				     const void *buffer,
-				     size_t size,
-				     int flags)
-{
-	return orangefs_inode_setxattr(inode,
-				    XATTR_TRUSTED_PREFIX,
-				    name,
-				    buffer,
-				    size,
-				    flags);
-}
-
-static int orangefs_xattr_get_trusted(const struct xattr_handler *handler,
-				      struct dentry *unused,
-				      struct inode *inode,
-				      const char *name,
-				      void *buffer,
-				      size_t size)
-{
-	return orangefs_inode_getxattr(inode,
-				    XATTR_TRUSTED_PREFIX,
-				    name,
-				    buffer,
-				    size);
-}
-
-static struct xattr_handler orangefs_xattr_trusted_handler = {
-	.prefix = XATTR_TRUSTED_PREFIX,
-	.get = orangefs_xattr_get_trusted,
-	.set = orangefs_xattr_set_trusted,
-};
-
 static struct xattr_handler orangefs_xattr_default_handler = {
 	.prefix = "",  /* match any name => handlers called with full name */
 	.get = orangefs_xattr_get_default,
@@ -523,7 +487,6 @@ static struct xattr_handler orangefs_xattr_default_handler = {
 const struct xattr_handler *orangefs_xattr_handlers[] = {
 	&posix_acl_access_xattr_handler,
 	&posix_acl_default_xattr_handler,
-	&orangefs_xattr_trusted_handler,
 	&orangefs_xattr_default_handler,
 	NULL
 };

commit 972a7344fcb54e0aabe78cfac5abb531fc6299ab
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Mon May 30 11:25:59 2016 +0200

    orangefs: Remove useless defines
    
    The ORANGEFS_XATTR_INDEX_ defines are unused; the ORANGEFS_XATTR_NAME_
    defines only obfuscate the code.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index 5893ddde0e4b..f387e8ad477b 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -456,7 +456,7 @@ static int orangefs_xattr_set_default(const struct xattr_handler *handler,
 				      int flags)
 {
 	return orangefs_inode_setxattr(inode,
-				    ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
+				    "",
 				    name,
 				    buffer,
 				    size,
@@ -471,7 +471,7 @@ static int orangefs_xattr_get_default(const struct xattr_handler *handler,
 				      size_t size)
 {
 	return orangefs_inode_getxattr(inode,
-				    ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
+				    "",
 				    name,
 				    buffer,
 				    size);
@@ -487,7 +487,7 @@ static int orangefs_xattr_set_trusted(const struct xattr_handler *handler,
 				     int flags)
 {
 	return orangefs_inode_setxattr(inode,
-				    ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,
+				    XATTR_TRUSTED_PREFIX,
 				    name,
 				    buffer,
 				    size,
@@ -502,25 +502,20 @@ static int orangefs_xattr_get_trusted(const struct xattr_handler *handler,
 				      size_t size)
 {
 	return orangefs_inode_getxattr(inode,
-				    ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,
+				    XATTR_TRUSTED_PREFIX,
 				    name,
 				    buffer,
 				    size);
 }
 
 static struct xattr_handler orangefs_xattr_trusted_handler = {
-	.prefix = ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,
+	.prefix = XATTR_TRUSTED_PREFIX,
 	.get = orangefs_xattr_get_trusted,
 	.set = orangefs_xattr_set_trusted,
 };
 
 static struct xattr_handler orangefs_xattr_default_handler = {
-	/*
-	 * NOTE: this is set to be the empty string.
-	 * so that all un-prefixed xattrs keys get caught
-	 * here!
-	 */
-	.prefix = ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
+	.prefix = "",  /* match any name => handlers called with full name */
 	.get = orangefs_xattr_get_default,
 	.set = orangefs_xattr_set_default,
 };

commit 5930122683dff58f0846b0f0405b4bd598a3ba6a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri May 27 10:19:30 2016 -0400

    switch xattr_handler->set() to passing dentry and inode separately
    
    preparation for similar switch in ->setxattr() (see the next commit for
    rationale).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index 99c19545752c..5893ddde0e4b 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -448,13 +448,14 @@ ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 }
 
 static int orangefs_xattr_set_default(const struct xattr_handler *handler,
-				      struct dentry *dentry,
+				      struct dentry *unused,
+				      struct inode *inode,
 				      const char *name,
 				      const void *buffer,
 				      size_t size,
 				      int flags)
 {
-	return orangefs_inode_setxattr(dentry->d_inode,
+	return orangefs_inode_setxattr(inode,
 				    ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
 				    name,
 				    buffer,
@@ -478,13 +479,14 @@ static int orangefs_xattr_get_default(const struct xattr_handler *handler,
 }
 
 static int orangefs_xattr_set_trusted(const struct xattr_handler *handler,
-				     struct dentry *dentry,
+				     struct dentry *unused,
+				     struct inode *inode,
 				     const char *name,
 				     const void *buffer,
 				     size_t size,
 				     int flags)
 {
-	return orangefs_inode_setxattr(dentry->d_inode,
+	return orangefs_inode_setxattr(inode,
 				    ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,
 				    name,
 				    buffer,

commit 84695ffee7987ee1e581be4c4696e47e1a29403b
Merge: bf1620068911 ce23e6401334
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon May 2 19:45:47 2016 -0400

    Merge getxattr prototype change into work.lookups
    
    The rest of work.xattr stuff isn't needed for this branch

commit b296821a7c42fa58baa17513b2b7b30ae66f3336
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Apr 10 20:48:24 2016 -0400

    xattr_handler: pass dentry and inode as separate arguments of ->get()
    
    ... and do not assume they are already attached to each other
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index ef5da7538cd5..6a4c0f7ce5c1 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -478,12 +478,13 @@ static int orangefs_xattr_set_default(const struct xattr_handler *handler,
 }
 
 static int orangefs_xattr_get_default(const struct xattr_handler *handler,
-				      struct dentry *dentry,
+				      struct dentry *unused,
+				      struct inode *inode,
 				      const char *name,
 				      void *buffer,
 				      size_t size)
 {
-	return orangefs_inode_getxattr(dentry->d_inode,
+	return orangefs_inode_getxattr(inode,
 				    ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
 				    name,
 				    buffer,
@@ -507,12 +508,13 @@ static int orangefs_xattr_set_trusted(const struct xattr_handler *handler,
 }
 
 static int orangefs_xattr_get_trusted(const struct xattr_handler *handler,
-				      struct dentry *dentry,
+				      struct dentry *unused,
+				      struct inode *inode,
 				      const char *name,
 				      void *buffer,
 				      size_t size)
 {
-	return orangefs_inode_getxattr(dentry->d_inode,
+	return orangefs_inode_getxattr(inode,
 				    ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,
 				    name,
 				    buffer,

commit a9bb3ba81fba1750139654360cb716ab093103b0
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Apr 6 11:19:37 2016 -0400

    Orangefs: optimize boilerplate code.
    
    Suggested by David Binderman <dcb314@hotmail.com>
    The former can potentially be a performance win over the latter.
    
    memcpy(d, s, len);
    memset(d+len, c, size-len);
    
    memset(d, c, size);
    memcpy(d, s, len);
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index 90a8ae77d641..63a6280d8c3a 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -142,8 +142,8 @@ ssize_t orangefs_inode_getxattr(struct inode *inode, const char *prefix,
 		goto out_release_op;
 	}
 
-	memset(buffer, 0, size);
 	memcpy(buffer, new_op->downcall.resp.getxattr.val, length);
+	memset(buffer + length, 0, size - length);
 	gossip_debug(GOSSIP_XATTR_DEBUG,
 	     "orangefs_inode_getxattr: inode %pU "
 	     "key %s key_sz %d, val_len %d\n",

commit 2d09a2ca6a6c66d765458df2653f888c4a481c81
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Apr 6 10:52:38 2016 -0400

    Orangefs: xattr.c cleanup
    
    1. It is nonsense to test for negative size_t, suggested by
       David Binderman <dcb314@hotmail.com>
    
    2. By the time Orangefs gets called, the vfs has ensured that
       name != NULL, and that buffer and size are sane.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index ef5da7538cd5..90a8ae77d641 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -73,10 +73,6 @@ ssize_t orangefs_inode_getxattr(struct inode *inode, const char *prefix,
 		     "%s: prefix %s name %s, buffer_size %zd\n",
 		     __func__, prefix, name, size);
 
-	if (name == NULL || (size > 0 && buffer == NULL)) {
-		gossip_err("orangefs_inode_getxattr: bogus NULL pointers\n");
-		return -EINVAL;
-	}
 	if ((strlen(name) + strlen(prefix)) >= ORANGEFS_MAX_XATTR_NAMELEN) {
 		gossip_err("Invalid key length (%d)\n",
 			   (int)(strlen(name) + strlen(prefix)));
@@ -239,8 +235,7 @@ int orangefs_inode_setxattr(struct inode *inode, const char *prefix,
 		     "%s: prefix %s, name %s, buffer_size %zd\n",
 		     __func__, prefix, name, size);
 
-	if (size < 0 ||
-	    size >= ORANGEFS_MAX_XATTR_VALUELEN ||
+	if (size >= ORANGEFS_MAX_XATTR_VALUELEN ||
 	    flags < 0) {
 		gossip_err("orangefs_inode_setxattr: bogus values of size(%d), flags(%d)\n",
 			   (int)size,
@@ -248,12 +243,6 @@ int orangefs_inode_setxattr(struct inode *inode, const char *prefix,
 		return -EINVAL;
 	}
 
-	if (name == NULL ||
-	    (size > 0 && value == NULL)) {
-		gossip_err("orangefs_inode_setxattr: bogus NULL pointers!\n");
-		return -EINVAL;
-	}
-
 	internal_flag = convert_to_internal_xattr_flags(flags);
 
 	if (prefix) {
@@ -353,10 +342,6 @@ ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 		gossip_err("%s: bogus NULL pointers\n", __func__);
 		return -EINVAL;
 	}
-	if (size < 0) {
-		gossip_err("Invalid size (%d)\n", (int)size);
-		return -EINVAL;
-	}
 
 	down_read(&orangefs_inode->xattr_sem);
 	new_op = op_alloc(ORANGEFS_VFS_OP_LISTXATTR);

commit 02a5cc537dfa222583b6b6c17451a67816fce9f5
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Wed Mar 16 14:01:43 2016 -0400

    orangefs: sanitize listxattr and return EIO on impossible values
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index 75a7dde8cc5f..ef5da7538cd5 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -394,6 +394,7 @@ ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 		gossip_err("%s: impossible value for returned_count:%d:\n",
 		__func__,
 		returned_count);
+		ret = -EIO;
 		goto done;
 	}
 
@@ -401,6 +402,15 @@ ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 	 * Check to see how much can be fit in the buffer. Fit only whole keys.
 	 */
 	for (i = 0; i < returned_count; i++) {
+		if (new_op->downcall.resp.listxattr.lengths[i] < 0 ||
+		    new_op->downcall.resp.listxattr.lengths[i] >
+		    ORANGEFS_MAX_XATTR_NAMELEN) {
+			gossip_err("%s: impossible value for lengths[%d]\n",
+			    __func__,
+			    new_op->downcall.resp.listxattr.lengths[i]);
+			ret = -EIO;
+			goto done;
+		}
 		if (total + new_op->downcall.resp.listxattr.lengths[i] > size)
 			goto done;
 

commit 5e06664f29c92c8e6b007cdec1f3abf197bc1961
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Wed Mar 16 13:54:48 2016 -0400

    orangefs: remove unused reference to xattr key length
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index 8e9ccf971486..75a7dde8cc5f 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -344,7 +344,6 @@ ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 	__u64 token = ORANGEFS_ITERATE_START;
 	ssize_t ret = -ENOMEM;
 	ssize_t total = 0;
-	ssize_t length = 0;
 	int count_keys = 0;
 	int key_size;
 	int i = 0;
@@ -389,10 +388,6 @@ ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 		goto done;
 	}
 
-	length = new_op->downcall.resp.listxattr.keylen;
-	if (length == 0)
-		goto done;
-
 	returned_count = new_op->downcall.resp.listxattr.returned_count;
 	if (returned_count < 0 ||
 	    returned_count >= ORANGEFS_MAX_XATTR_LISTLEN) {

commit 62441fa53bccc69fe344e6b20be0680cca0fbc15
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Thu Dec 17 16:11:40 2015 -0500

    Orangefs: validate resp.listxattr.returned_count
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index 0e4e01602738..8e9ccf971486 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -348,6 +348,7 @@ ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 	int count_keys = 0;
 	int key_size;
 	int i = 0;
+	int returned_count = 0;
 
 	if (size > 0 && buffer == NULL) {
 		gossip_err("%s: bogus NULL pointers\n", __func__);
@@ -392,10 +393,19 @@ ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 	if (length == 0)
 		goto done;
 
+	returned_count = new_op->downcall.resp.listxattr.returned_count;
+	if (returned_count < 0 ||
+	    returned_count >= ORANGEFS_MAX_XATTR_LISTLEN) {
+		gossip_err("%s: impossible value for returned_count:%d:\n",
+		__func__,
+		returned_count);
+		goto done;
+	}
+
 	/*
 	 * Check to see how much can be fit in the buffer. Fit only whole keys.
 	 */
-	for (i = 0; i < new_op->downcall.resp.listxattr.returned_count; i++) {
+	for (i = 0; i < returned_count; i++) {
 		if (total + new_op->downcall.resp.listxattr.lengths[i] > size)
 			goto done;
 

commit 575e946125f70c41c2042f10172842c5cab9a09a
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Dec 4 12:56:14 2015 -0500

    Orangefs: change pvfs2 filenames to orangefs
    
    Also changed references within source files that referred to
    header files whose names had changed.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index aeb3c3083591..0e4e01602738 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -9,8 +9,8 @@
  */
 
 #include "protocol.h"
-#include "pvfs2-kernel.h"
-#include "pvfs2-bufmap.h"
+#include "orangefs-kernel.h"
+#include "orangefs-bufmap.h"
 #include <linux/posix_acl_xattr.h>
 #include <linux/xattr.h>
 

commit 8bb8aefd5afb54a25a002feb4ec70011812d06a0
Author: Yi Liu <yi9@clemson.edu>
Date:   Tue Nov 24 15:12:14 2015 -0500

    OrangeFS: Change almost all instances of the string PVFS2 to OrangeFS.
    
    OrangeFS was formerly known as PVFS2 and retains the name in many places.
    
    I leave the device /dev/pvfs2-req since this affects userspace.
    
    I leave the filesystem type pvfs2 since this affects userspace. Further
    the OrangeFS sysint library reads fstab for an entry of type pvfs2
    independently of kernel mounts.
    
    I leave extended attribute keys user.pvfs2 and system.pvfs2 as the
    sysint library understands these.
    
    I leave references to userspace binaries still named pvfs2.
    
    I leave the filenames.
    
    Signed-off-by: Yi Liu <yi9@clemson.edu>
    [martin@omnibond.com: clairify above constraints and merge]
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index b683daab7425..aeb3c3083591 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -15,8 +15,8 @@
 #include <linux/xattr.h>
 
 
-#define SYSTEM_PVFS2_KEY "system.pvfs2."
-#define SYSTEM_PVFS2_KEY_LEN 13
+#define SYSTEM_ORANGEFS_KEY "system.pvfs2."
+#define SYSTEM_ORANGEFS_KEY_LEN 13
 
 /*
  * this function returns
@@ -24,15 +24,15 @@
  *     of a listxattr.
  *   1 if the key corresponding to name is meant to be returned as part of
  *     a listxattr.
- * The ones that start SYSTEM_PVFS2_KEY are the ones to avoid printing.
+ * The ones that start SYSTEM_ORANGEFS_KEY are the ones to avoid printing.
  */
 static int is_reserved_key(const char *key, size_t size)
 {
 
-	if (size < SYSTEM_PVFS2_KEY_LEN)
+	if (size < SYSTEM_ORANGEFS_KEY_LEN)
 		return 1;
 
-	return strncmp(key, SYSTEM_PVFS2_KEY, SYSTEM_PVFS2_KEY_LEN) ?  1 : 0;
+	return strncmp(key, SYSTEM_ORANGEFS_KEY, SYSTEM_ORANGEFS_KEY_LEN) ?  1 : 0;
 }
 
 static inline int convert_to_internal_xattr_flags(int setxattr_flags)
@@ -41,10 +41,10 @@ static inline int convert_to_internal_xattr_flags(int setxattr_flags)
 
 	if (setxattr_flags & XATTR_REPLACE) {
 		/* Attribute must exist! */
-		internal_flag = PVFS_XATTR_REPLACE;
+		internal_flag = ORANGEFS_XATTR_REPLACE;
 	} else if (setxattr_flags & XATTR_CREATE) {
 		/* Attribute must not exist */
-		internal_flag = PVFS_XATTR_CREATE;
+		internal_flag = ORANGEFS_XATTR_CREATE;
 	}
 	return internal_flag;
 }
@@ -59,11 +59,11 @@ static inline int convert_to_internal_xattr_flags(int setxattr_flags)
  * unless the key does not exist for the file and/or if
  * there were errors in fetching the attribute value.
  */
-ssize_t pvfs2_inode_getxattr(struct inode *inode, const char *prefix,
+ssize_t orangefs_inode_getxattr(struct inode *inode, const char *prefix,
 		const char *name, void *buffer, size_t size)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
-	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_kernel_op_s *new_op = NULL;
 	ssize_t ret = -ENOMEM;
 	ssize_t length = 0;
 	int fsuid;
@@ -74,10 +74,10 @@ ssize_t pvfs2_inode_getxattr(struct inode *inode, const char *prefix,
 		     __func__, prefix, name, size);
 
 	if (name == NULL || (size > 0 && buffer == NULL)) {
-		gossip_err("pvfs2_inode_getxattr: bogus NULL pointers\n");
+		gossip_err("orangefs_inode_getxattr: bogus NULL pointers\n");
 		return -EINVAL;
 	}
-	if ((strlen(name) + strlen(prefix)) >= PVFS_MAX_XATTR_NAMELEN) {
+	if ((strlen(name) + strlen(prefix)) >= ORANGEFS_MAX_XATTR_NAMELEN) {
 		gossip_err("Invalid key length (%d)\n",
 			   (int)(strlen(name) + strlen(prefix)));
 		return -EINVAL;
@@ -94,15 +94,15 @@ ssize_t pvfs2_inode_getxattr(struct inode *inode, const char *prefix,
 		     fsuid,
 		     fsgid);
 
-	down_read(&pvfs2_inode->xattr_sem);
+	down_read(&orangefs_inode->xattr_sem);
 
-	new_op = op_alloc(PVFS2_VFS_OP_GETXATTR);
+	new_op = op_alloc(ORANGEFS_VFS_OP_GETXATTR);
 	if (!new_op)
 		goto out_unlock;
 
-	new_op->upcall.req.getxattr.refn = pvfs2_inode->refn;
+	new_op->upcall.req.getxattr.refn = orangefs_inode->refn;
 	ret = snprintf((char *)new_op->upcall.req.getxattr.key,
-		       PVFS_MAX_XATTR_NAMELEN, "%s%s", prefix, name);
+		       ORANGEFS_MAX_XATTR_NAMELEN, "%s%s", prefix, name);
 
 	/*
 	 * NOTE: Although keys are meant to be NULL terminated textual
@@ -111,13 +111,13 @@ ssize_t pvfs2_inode_getxattr(struct inode *inode, const char *prefix,
 	 */
 	new_op->upcall.req.getxattr.key_sz = ret + 1;
 
-	ret = service_operation(new_op, "pvfs2_inode_getxattr",
+	ret = service_operation(new_op, "orangefs_inode_getxattr",
 				get_interruptible_flag(inode));
 	if (ret != 0) {
 		if (ret == -ENOENT) {
 			ret = -ENODATA;
 			gossip_debug(GOSSIP_XATTR_DEBUG,
-				     "pvfs2_inode_getxattr: inode %pU key %s"
+				     "orangefs_inode_getxattr: inode %pU key %s"
 				     " does not exist!\n",
 				     get_khandle_from_ino(inode),
 				     (char *)new_op->upcall.req.getxattr.key);
@@ -149,7 +149,7 @@ ssize_t pvfs2_inode_getxattr(struct inode *inode, const char *prefix,
 	memset(buffer, 0, size);
 	memcpy(buffer, new_op->downcall.resp.getxattr.val, length);
 	gossip_debug(GOSSIP_XATTR_DEBUG,
-	     "pvfs2_inode_getxattr: inode %pU "
+	     "orangefs_inode_getxattr: inode %pU "
 	     "key %s key_sz %d, val_len %d\n",
 	     get_khandle_from_ino(inode),
 	     (char *)new_op->
@@ -163,44 +163,44 @@ ssize_t pvfs2_inode_getxattr(struct inode *inode, const char *prefix,
 out_release_op:
 	op_release(new_op);
 out_unlock:
-	up_read(&pvfs2_inode->xattr_sem);
+	up_read(&orangefs_inode->xattr_sem);
 	return ret;
 }
 
-static int pvfs2_inode_removexattr(struct inode *inode,
+static int orangefs_inode_removexattr(struct inode *inode,
 			    const char *prefix,
 			    const char *name,
 			    int flags)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
-	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_kernel_op_s *new_op = NULL;
 	int ret = -ENOMEM;
 
-	down_write(&pvfs2_inode->xattr_sem);
-	new_op = op_alloc(PVFS2_VFS_OP_REMOVEXATTR);
+	down_write(&orangefs_inode->xattr_sem);
+	new_op = op_alloc(ORANGEFS_VFS_OP_REMOVEXATTR);
 	if (!new_op)
 		goto out_unlock;
 
-	new_op->upcall.req.removexattr.refn = pvfs2_inode->refn;
+	new_op->upcall.req.removexattr.refn = orangefs_inode->refn;
 	/*
 	 * NOTE: Although keys are meant to be NULL terminated
 	 * textual strings, I am going to explicitly pass the
 	 * length just in case we change this later on...
 	 */
 	ret = snprintf((char *)new_op->upcall.req.removexattr.key,
-		       PVFS_MAX_XATTR_NAMELEN,
+		       ORANGEFS_MAX_XATTR_NAMELEN,
 		       "%s%s",
 		       (prefix ? prefix : ""),
 		       name);
 	new_op->upcall.req.removexattr.key_sz = ret + 1;
 
 	gossip_debug(GOSSIP_XATTR_DEBUG,
-		     "pvfs2_inode_removexattr: key %s, key_sz %d\n",
+		     "orangefs_inode_removexattr: key %s, key_sz %d\n",
 		     (char *)new_op->upcall.req.removexattr.key,
 		     (int)new_op->upcall.req.removexattr.key_sz);
 
 	ret = service_operation(new_op,
-				"pvfs2_inode_removexattr",
+				"orangefs_inode_removexattr",
 				get_interruptible_flag(inode));
 	if (ret == -ENOENT) {
 		/*
@@ -213,11 +213,11 @@ static int pvfs2_inode_removexattr(struct inode *inode,
 	}
 
 	gossip_debug(GOSSIP_XATTR_DEBUG,
-		     "pvfs2_inode_removexattr: returning %d\n", ret);
+		     "orangefs_inode_removexattr: returning %d\n", ret);
 
 	op_release(new_op);
 out_unlock:
-	up_write(&pvfs2_inode->xattr_sem);
+	up_write(&orangefs_inode->xattr_sem);
 	return ret;
 }
 
@@ -227,11 +227,11 @@ static int pvfs2_inode_removexattr(struct inode *inode,
  * Returns a -ve number on error and 0 on success.  Key is text, but value
  * can be binary!
  */
-int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
+int orangefs_inode_setxattr(struct inode *inode, const char *prefix,
 		const char *name, const void *value, size_t size, int flags)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
-	struct pvfs2_kernel_op_s *new_op;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_kernel_op_s *new_op;
 	int internal_flag = 0;
 	int ret = -ENOMEM;
 
@@ -240,9 +240,9 @@ int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
 		     __func__, prefix, name, size);
 
 	if (size < 0 ||
-	    size >= PVFS_MAX_XATTR_VALUELEN ||
+	    size >= ORANGEFS_MAX_XATTR_VALUELEN ||
 	    flags < 0) {
-		gossip_err("pvfs2_inode_setxattr: bogus values of size(%d), flags(%d)\n",
+		gossip_err("orangefs_inode_setxattr: bogus values of size(%d), flags(%d)\n",
 			   (int)size,
 			   flags);
 		return -EINVAL;
@@ -250,23 +250,23 @@ int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
 
 	if (name == NULL ||
 	    (size > 0 && value == NULL)) {
-		gossip_err("pvfs2_inode_setxattr: bogus NULL pointers!\n");
+		gossip_err("orangefs_inode_setxattr: bogus NULL pointers!\n");
 		return -EINVAL;
 	}
 
 	internal_flag = convert_to_internal_xattr_flags(flags);
 
 	if (prefix) {
-		if (strlen(name) + strlen(prefix) >= PVFS_MAX_XATTR_NAMELEN) {
+		if (strlen(name) + strlen(prefix) >= ORANGEFS_MAX_XATTR_NAMELEN) {
 			gossip_err
-			    ("pvfs2_inode_setxattr: bogus key size (%d)\n",
+			    ("orangefs_inode_setxattr: bogus key size (%d)\n",
 			     (int)(strlen(name) + strlen(prefix)));
 			return -EINVAL;
 		}
 	} else {
-		if (strlen(name) >= PVFS_MAX_XATTR_NAMELEN) {
+		if (strlen(name) >= ORANGEFS_MAX_XATTR_NAMELEN) {
 			gossip_err
-			    ("pvfs2_inode_setxattr: bogus key size (%d)\n",
+			    ("orangefs_inode_setxattr: bogus key size (%d)\n",
 			     (int)(strlen(name)));
 			return -EINVAL;
 		}
@@ -278,7 +278,7 @@ int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
 			     "removing xattr (%s%s)\n",
 			     prefix,
 			     name);
-		return pvfs2_inode_removexattr(inode, prefix, name, flags);
+		return orangefs_inode_removexattr(inode, prefix, name, flags);
 	}
 
 	gossip_debug(GOSSIP_XATTR_DEBUG,
@@ -286,13 +286,13 @@ int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
 		     get_khandle_from_ino(inode),
 		     name);
 
-	down_write(&pvfs2_inode->xattr_sem);
-	new_op = op_alloc(PVFS2_VFS_OP_SETXATTR);
+	down_write(&orangefs_inode->xattr_sem);
+	new_op = op_alloc(ORANGEFS_VFS_OP_SETXATTR);
 	if (!new_op)
 		goto out_unlock;
 
 
-	new_op->upcall.req.setxattr.refn = pvfs2_inode->refn;
+	new_op->upcall.req.setxattr.refn = orangefs_inode->refn;
 	new_op->upcall.req.setxattr.flags = internal_flag;
 	/*
 	 * NOTE: Although keys are meant to be NULL terminated textual
@@ -300,7 +300,7 @@ int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
 	 * case we change this later on...
 	 */
 	ret = snprintf((char *)new_op->upcall.req.setxattr.keyval.key,
-		       PVFS_MAX_XATTR_NAMELEN,
+		       ORANGEFS_MAX_XATTR_NAMELEN,
 		       "%s%s",
 		       prefix, name);
 	new_op->upcall.req.setxattr.keyval.key_sz = ret + 1;
@@ -308,24 +308,24 @@ int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
 	new_op->upcall.req.setxattr.keyval.val_sz = size;
 
 	gossip_debug(GOSSIP_XATTR_DEBUG,
-		     "pvfs2_inode_setxattr: key %s, key_sz %d "
+		     "orangefs_inode_setxattr: key %s, key_sz %d "
 		     " value size %zd\n",
 		     (char *)new_op->upcall.req.setxattr.keyval.key,
 		     (int)new_op->upcall.req.setxattr.keyval.key_sz,
 		     size);
 
 	ret = service_operation(new_op,
-				"pvfs2_inode_setxattr",
+				"orangefs_inode_setxattr",
 				get_interruptible_flag(inode));
 
 	gossip_debug(GOSSIP_XATTR_DEBUG,
-		     "pvfs2_inode_setxattr: returning %d\n",
+		     "orangefs_inode_setxattr: returning %d\n",
 		     ret);
 
 	/* when request is serviced properly, free req op struct */
 	op_release(new_op);
 out_unlock:
-	up_write(&pvfs2_inode->xattr_sem);
+	up_write(&orangefs_inode->xattr_sem);
 	return ret;
 }
 
@@ -336,12 +336,12 @@ int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
  * subsequent memory allocations. Thus our return value is always the size of
  * all the keys unless there were errors in fetching the keys!
  */
-ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
+ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 {
 	struct inode *inode = dentry->d_inode;
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
-	struct pvfs2_kernel_op_s *new_op;
-	__u64 token = PVFS_ITERATE_START;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_kernel_op_s *new_op;
+	__u64 token = ORANGEFS_ITERATE_START;
 	ssize_t ret = -ENOMEM;
 	ssize_t total = 0;
 	ssize_t length = 0;
@@ -358,8 +358,8 @@ ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
 		return -EINVAL;
 	}
 
-	down_read(&pvfs2_inode->xattr_sem);
-	new_op = op_alloc(PVFS2_VFS_OP_LISTXATTR);
+	down_read(&orangefs_inode->xattr_sem);
+	new_op = op_alloc(ORANGEFS_VFS_OP_LISTXATTR);
 	if (!new_op)
 		goto out_unlock;
 
@@ -368,10 +368,10 @@ ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
 
 try_again:
 	key_size = 0;
-	new_op->upcall.req.listxattr.refn = pvfs2_inode->refn;
+	new_op->upcall.req.listxattr.refn = orangefs_inode->refn;
 	new_op->upcall.req.listxattr.token = token;
 	new_op->upcall.req.listxattr.requested_count =
-	    (size == 0) ? 0 : PVFS_MAX_XATTR_LISTLEN;
+	    (size == 0) ? 0 : ORANGEFS_MAX_XATTR_LISTLEN;
 	ret = service_operation(new_op, __func__,
 				get_interruptible_flag(inode));
 	if (ret != 0)
@@ -384,7 +384,7 @@ ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
 		 * up allocating memory rather than us...
 		 */
 		total = new_op->downcall.resp.listxattr.returned_count *
-			PVFS_MAX_XATTR_NAMELEN;
+			ORANGEFS_MAX_XATTR_NAMELEN;
 		goto done;
 	}
 
@@ -429,7 +429,7 @@ ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
 	 * fetching more keys!
 	 */
 	token = new_op->downcall.resp.listxattr.token;
-	if (token != PVFS_ITERATE_END)
+	if (token != ORANGEFS_ITERATE_END)
 		goto try_again;
 
 done:
@@ -443,88 +443,88 @@ ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
 	if (ret == 0)
 		ret = total;
 out_unlock:
-	up_read(&pvfs2_inode->xattr_sem);
+	up_read(&orangefs_inode->xattr_sem);
 	return ret;
 }
 
-static int pvfs2_xattr_set_default(const struct xattr_handler *handler,
-				   struct dentry *dentry,
-				   const char *name,
-				   const void *buffer,
-				   size_t size,
-				   int flags)
+static int orangefs_xattr_set_default(const struct xattr_handler *handler,
+				      struct dentry *dentry,
+				      const char *name,
+				      const void *buffer,
+				      size_t size,
+				      int flags)
 {
-	return pvfs2_inode_setxattr(dentry->d_inode,
-				    PVFS2_XATTR_NAME_DEFAULT_PREFIX,
+	return orangefs_inode_setxattr(dentry->d_inode,
+				    ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
 				    name,
 				    buffer,
 				    size,
 				    flags);
 }
 
-static int pvfs2_xattr_get_default(const struct xattr_handler *handler,
-				   struct dentry *dentry,
-				   const char *name,
-				   void *buffer,
-				   size_t size)
+static int orangefs_xattr_get_default(const struct xattr_handler *handler,
+				      struct dentry *dentry,
+				      const char *name,
+				      void *buffer,
+				      size_t size)
 {
-	return pvfs2_inode_getxattr(dentry->d_inode,
-				    PVFS2_XATTR_NAME_DEFAULT_PREFIX,
+	return orangefs_inode_getxattr(dentry->d_inode,
+				    ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
 				    name,
 				    buffer,
 				    size);
 
 }
 
-static int pvfs2_xattr_set_trusted(const struct xattr_handler *handler,
-				   struct dentry *dentry,
-				   const char *name,
-				   const void *buffer,
-				   size_t size,
-				   int flags)
+static int orangefs_xattr_set_trusted(const struct xattr_handler *handler,
+				     struct dentry *dentry,
+				     const char *name,
+				     const void *buffer,
+				     size_t size,
+				     int flags)
 {
-	return pvfs2_inode_setxattr(dentry->d_inode,
-				    PVFS2_XATTR_NAME_TRUSTED_PREFIX,
+	return orangefs_inode_setxattr(dentry->d_inode,
+				    ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,
 				    name,
 				    buffer,
 				    size,
 				    flags);
 }
 
-static int pvfs2_xattr_get_trusted(const struct xattr_handler *handler,
-				   struct dentry *dentry,
-				   const char *name,
-				   void *buffer,
-				   size_t size)
+static int orangefs_xattr_get_trusted(const struct xattr_handler *handler,
+				      struct dentry *dentry,
+				      const char *name,
+				      void *buffer,
+				      size_t size)
 {
-	return pvfs2_inode_getxattr(dentry->d_inode,
-				    PVFS2_XATTR_NAME_TRUSTED_PREFIX,
+	return orangefs_inode_getxattr(dentry->d_inode,
+				    ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,
 				    name,
 				    buffer,
 				    size);
 }
 
-static struct xattr_handler pvfs2_xattr_trusted_handler = {
-	.prefix = PVFS2_XATTR_NAME_TRUSTED_PREFIX,
-	.get = pvfs2_xattr_get_trusted,
-	.set = pvfs2_xattr_set_trusted,
+static struct xattr_handler orangefs_xattr_trusted_handler = {
+	.prefix = ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,
+	.get = orangefs_xattr_get_trusted,
+	.set = orangefs_xattr_set_trusted,
 };
 
-static struct xattr_handler pvfs2_xattr_default_handler = {
+static struct xattr_handler orangefs_xattr_default_handler = {
 	/*
 	 * NOTE: this is set to be the empty string.
 	 * so that all un-prefixed xattrs keys get caught
 	 * here!
 	 */
-	.prefix = PVFS2_XATTR_NAME_DEFAULT_PREFIX,
-	.get = pvfs2_xattr_get_default,
-	.set = pvfs2_xattr_set_default,
+	.prefix = ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
+	.get = orangefs_xattr_get_default,
+	.set = orangefs_xattr_set_default,
 };
 
-const struct xattr_handler *pvfs2_xattr_handlers[] = {
+const struct xattr_handler *orangefs_xattr_handlers[] = {
 	&posix_acl_access_xattr_handler,
 	&posix_acl_default_xattr_handler,
-	&pvfs2_xattr_trusted_handler,
-	&pvfs2_xattr_default_handler,
+	&orangefs_xattr_trusted_handler,
+	&orangefs_xattr_default_handler,
 	NULL
 };

commit 555fa0fa618b846c5b38406347b7d53ace320ac6
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Wed Nov 11 16:33:39 2015 +0000

    fs: out of bounds on stack in iov_iter_advance
    
    On Wed, Nov 11, 2015 at 10:19:48AM +0000, Al Viro wrote:
    
    > I'll cook the minimal fixup for API change after I get some sleep and
    > send it your way, unless somebody gets there first...
    
    This should do it - switches ->ioctl() to pvfs2_inode_[gs]etxattr() and
    converts xattr_handler ->[gs]et() to new API.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index 227eaa47b1e1..b683daab7425 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -447,12 +447,12 @@ ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
 	return ret;
 }
 
-int pvfs2_xattr_set_default(struct dentry *dentry,
-			    const char *name,
-			    const void *buffer,
-			    size_t size,
-			    int flags,
-			    int handler_flags)
+static int pvfs2_xattr_set_default(const struct xattr_handler *handler,
+				   struct dentry *dentry,
+				   const char *name,
+				   const void *buffer,
+				   size_t size,
+				   int flags)
 {
 	return pvfs2_inode_setxattr(dentry->d_inode,
 				    PVFS2_XATTR_NAME_DEFAULT_PREFIX,
@@ -462,11 +462,11 @@ int pvfs2_xattr_set_default(struct dentry *dentry,
 				    flags);
 }
 
-int pvfs2_xattr_get_default(struct dentry *dentry,
-			    const char *name,
-			    void *buffer,
-			    size_t size,
-			    int handler_flags)
+static int pvfs2_xattr_get_default(const struct xattr_handler *handler,
+				   struct dentry *dentry,
+				   const char *name,
+				   void *buffer,
+				   size_t size)
 {
 	return pvfs2_inode_getxattr(dentry->d_inode,
 				    PVFS2_XATTR_NAME_DEFAULT_PREFIX,
@@ -476,12 +476,12 @@ int pvfs2_xattr_get_default(struct dentry *dentry,
 
 }
 
-static int pvfs2_xattr_set_trusted(struct dentry *dentry,
-			    const char *name,
-			    const void *buffer,
-			    size_t size,
-			    int flags,
-			    int handler_flags)
+static int pvfs2_xattr_set_trusted(const struct xattr_handler *handler,
+				   struct dentry *dentry,
+				   const char *name,
+				   const void *buffer,
+				   size_t size,
+				   int flags)
 {
 	return pvfs2_inode_setxattr(dentry->d_inode,
 				    PVFS2_XATTR_NAME_TRUSTED_PREFIX,
@@ -491,11 +491,11 @@ static int pvfs2_xattr_set_trusted(struct dentry *dentry,
 				    flags);
 }
 
-static int pvfs2_xattr_get_trusted(struct dentry *dentry,
-			    const char *name,
-			    void *buffer,
-			    size_t size,
-			    int handler_flags)
+static int pvfs2_xattr_get_trusted(const struct xattr_handler *handler,
+				   struct dentry *dentry,
+				   const char *name,
+				   void *buffer,
+				   size_t size)
 {
 	return pvfs2_inode_getxattr(dentry->d_inode,
 				    PVFS2_XATTR_NAME_TRUSTED_PREFIX,

commit eeaa3d448c5d35ad0dc16a981aacd64139c53eee
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Jul 29 13:36:37 2015 -0400

    Orangefs: address problems found by static checker
    
      Don't check for negative rc from boolean.
    
      Don't pointlessly initialize variables, it short-circuits
      gcc's uninitialized variable warnings. And max_new_nr_segs
      can never be zero, so don't check for it.
    
      Preserve original kstrdup pointer for freeing later.
    
      Don't check for negative value in unsigned variable.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index 2766090f5ca4..227eaa47b1e1 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -77,10 +77,8 @@ ssize_t pvfs2_inode_getxattr(struct inode *inode, const char *prefix,
 		gossip_err("pvfs2_inode_getxattr: bogus NULL pointers\n");
 		return -EINVAL;
 	}
-	if (size < 0 ||
-	    (strlen(name) + strlen(prefix)) >= PVFS_MAX_XATTR_NAMELEN) {
-		gossip_err("Invalid size (%d) or key length (%d)\n",
-			   (int)size,
+	if ((strlen(name) + strlen(prefix)) >= PVFS_MAX_XATTR_NAMELEN) {
+		gossip_err("Invalid key length (%d)\n",
 			   (int)(strlen(name) + strlen(prefix)));
 		return -EINVAL;
 	}

commit 1182fca3bc00441d5b2dee2f0548a3b7f978f9e7
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Jul 17 10:38:15 2015 -0400

    Orangefs: kernel client part 5
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
new file mode 100644
index 000000000000..2766090f5ca4
--- /dev/null
+++ b/fs/orangefs/xattr.c
@@ -0,0 +1,532 @@
+/*
+ * (C) 2001 Clemson University and The University of Chicago
+ *
+ * See COPYING in top-level directory.
+ */
+
+/*
+ *  Linux VFS extended attribute operations.
+ */
+
+#include "protocol.h"
+#include "pvfs2-kernel.h"
+#include "pvfs2-bufmap.h"
+#include <linux/posix_acl_xattr.h>
+#include <linux/xattr.h>
+
+
+#define SYSTEM_PVFS2_KEY "system.pvfs2."
+#define SYSTEM_PVFS2_KEY_LEN 13
+
+/*
+ * this function returns
+ *   0 if the key corresponding to name is not meant to be printed as part
+ *     of a listxattr.
+ *   1 if the key corresponding to name is meant to be returned as part of
+ *     a listxattr.
+ * The ones that start SYSTEM_PVFS2_KEY are the ones to avoid printing.
+ */
+static int is_reserved_key(const char *key, size_t size)
+{
+
+	if (size < SYSTEM_PVFS2_KEY_LEN)
+		return 1;
+
+	return strncmp(key, SYSTEM_PVFS2_KEY, SYSTEM_PVFS2_KEY_LEN) ?  1 : 0;
+}
+
+static inline int convert_to_internal_xattr_flags(int setxattr_flags)
+{
+	int internal_flag = 0;
+
+	if (setxattr_flags & XATTR_REPLACE) {
+		/* Attribute must exist! */
+		internal_flag = PVFS_XATTR_REPLACE;
+	} else if (setxattr_flags & XATTR_CREATE) {
+		/* Attribute must not exist */
+		internal_flag = PVFS_XATTR_CREATE;
+	}
+	return internal_flag;
+}
+
+
+/*
+ * Tries to get a specified key's attributes of a given
+ * file into a user-specified buffer. Note that the getxattr
+ * interface allows for the users to probe the size of an
+ * extended attribute by passing in a value of 0 to size.
+ * Thus our return value is always the size of the attribute
+ * unless the key does not exist for the file and/or if
+ * there were errors in fetching the attribute value.
+ */
+ssize_t pvfs2_inode_getxattr(struct inode *inode, const char *prefix,
+		const char *name, void *buffer, size_t size)
+{
+	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	struct pvfs2_kernel_op_s *new_op = NULL;
+	ssize_t ret = -ENOMEM;
+	ssize_t length = 0;
+	int fsuid;
+	int fsgid;
+
+	gossip_debug(GOSSIP_XATTR_DEBUG,
+		     "%s: prefix %s name %s, buffer_size %zd\n",
+		     __func__, prefix, name, size);
+
+	if (name == NULL || (size > 0 && buffer == NULL)) {
+		gossip_err("pvfs2_inode_getxattr: bogus NULL pointers\n");
+		return -EINVAL;
+	}
+	if (size < 0 ||
+	    (strlen(name) + strlen(prefix)) >= PVFS_MAX_XATTR_NAMELEN) {
+		gossip_err("Invalid size (%d) or key length (%d)\n",
+			   (int)size,
+			   (int)(strlen(name) + strlen(prefix)));
+		return -EINVAL;
+	}
+
+	fsuid = from_kuid(current_user_ns(), current_fsuid());
+	fsgid = from_kgid(current_user_ns(), current_fsgid());
+
+	gossip_debug(GOSSIP_XATTR_DEBUG,
+		     "getxattr on inode %pU, name %s "
+		     "(uid %o, gid %o)\n",
+		     get_khandle_from_ino(inode),
+		     name,
+		     fsuid,
+		     fsgid);
+
+	down_read(&pvfs2_inode->xattr_sem);
+
+	new_op = op_alloc(PVFS2_VFS_OP_GETXATTR);
+	if (!new_op)
+		goto out_unlock;
+
+	new_op->upcall.req.getxattr.refn = pvfs2_inode->refn;
+	ret = snprintf((char *)new_op->upcall.req.getxattr.key,
+		       PVFS_MAX_XATTR_NAMELEN, "%s%s", prefix, name);
+
+	/*
+	 * NOTE: Although keys are meant to be NULL terminated textual
+	 * strings, I am going to explicitly pass the length just in case
+	 * we change this later on...
+	 */
+	new_op->upcall.req.getxattr.key_sz = ret + 1;
+
+	ret = service_operation(new_op, "pvfs2_inode_getxattr",
+				get_interruptible_flag(inode));
+	if (ret != 0) {
+		if (ret == -ENOENT) {
+			ret = -ENODATA;
+			gossip_debug(GOSSIP_XATTR_DEBUG,
+				     "pvfs2_inode_getxattr: inode %pU key %s"
+				     " does not exist!\n",
+				     get_khandle_from_ino(inode),
+				     (char *)new_op->upcall.req.getxattr.key);
+		}
+		goto out_release_op;
+	}
+
+	/*
+	 * Length returned includes null terminator.
+	 */
+	length = new_op->downcall.resp.getxattr.val_sz;
+
+	/*
+	 * Just return the length of the queried attribute.
+	 */
+	if (size == 0) {
+		ret = length;
+		goto out_release_op;
+	}
+
+	/*
+	 * Check to see if key length is > provided buffer size.
+	 */
+	if (length > size) {
+		ret = -ERANGE;
+		goto out_release_op;
+	}
+
+	memset(buffer, 0, size);
+	memcpy(buffer, new_op->downcall.resp.getxattr.val, length);
+	gossip_debug(GOSSIP_XATTR_DEBUG,
+	     "pvfs2_inode_getxattr: inode %pU "
+	     "key %s key_sz %d, val_len %d\n",
+	     get_khandle_from_ino(inode),
+	     (char *)new_op->
+		upcall.req.getxattr.key,
+		     (int)new_op->
+		upcall.req.getxattr.key_sz,
+	     (int)ret);
+
+	ret = length;
+
+out_release_op:
+	op_release(new_op);
+out_unlock:
+	up_read(&pvfs2_inode->xattr_sem);
+	return ret;
+}
+
+static int pvfs2_inode_removexattr(struct inode *inode,
+			    const char *prefix,
+			    const char *name,
+			    int flags)
+{
+	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	struct pvfs2_kernel_op_s *new_op = NULL;
+	int ret = -ENOMEM;
+
+	down_write(&pvfs2_inode->xattr_sem);
+	new_op = op_alloc(PVFS2_VFS_OP_REMOVEXATTR);
+	if (!new_op)
+		goto out_unlock;
+
+	new_op->upcall.req.removexattr.refn = pvfs2_inode->refn;
+	/*
+	 * NOTE: Although keys are meant to be NULL terminated
+	 * textual strings, I am going to explicitly pass the
+	 * length just in case we change this later on...
+	 */
+	ret = snprintf((char *)new_op->upcall.req.removexattr.key,
+		       PVFS_MAX_XATTR_NAMELEN,
+		       "%s%s",
+		       (prefix ? prefix : ""),
+		       name);
+	new_op->upcall.req.removexattr.key_sz = ret + 1;
+
+	gossip_debug(GOSSIP_XATTR_DEBUG,
+		     "pvfs2_inode_removexattr: key %s, key_sz %d\n",
+		     (char *)new_op->upcall.req.removexattr.key,
+		     (int)new_op->upcall.req.removexattr.key_sz);
+
+	ret = service_operation(new_op,
+				"pvfs2_inode_removexattr",
+				get_interruptible_flag(inode));
+	if (ret == -ENOENT) {
+		/*
+		 * Request to replace a non-existent attribute is an error.
+		 */
+		if (flags & XATTR_REPLACE)
+			ret = -ENODATA;
+		else
+			ret = 0;
+	}
+
+	gossip_debug(GOSSIP_XATTR_DEBUG,
+		     "pvfs2_inode_removexattr: returning %d\n", ret);
+
+	op_release(new_op);
+out_unlock:
+	up_write(&pvfs2_inode->xattr_sem);
+	return ret;
+}
+
+/*
+ * Tries to set an attribute for a given key on a file.
+ *
+ * Returns a -ve number on error and 0 on success.  Key is text, but value
+ * can be binary!
+ */
+int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
+		const char *name, const void *value, size_t size, int flags)
+{
+	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	struct pvfs2_kernel_op_s *new_op;
+	int internal_flag = 0;
+	int ret = -ENOMEM;
+
+	gossip_debug(GOSSIP_XATTR_DEBUG,
+		     "%s: prefix %s, name %s, buffer_size %zd\n",
+		     __func__, prefix, name, size);
+
+	if (size < 0 ||
+	    size >= PVFS_MAX_XATTR_VALUELEN ||
+	    flags < 0) {
+		gossip_err("pvfs2_inode_setxattr: bogus values of size(%d), flags(%d)\n",
+			   (int)size,
+			   flags);
+		return -EINVAL;
+	}
+
+	if (name == NULL ||
+	    (size > 0 && value == NULL)) {
+		gossip_err("pvfs2_inode_setxattr: bogus NULL pointers!\n");
+		return -EINVAL;
+	}
+
+	internal_flag = convert_to_internal_xattr_flags(flags);
+
+	if (prefix) {
+		if (strlen(name) + strlen(prefix) >= PVFS_MAX_XATTR_NAMELEN) {
+			gossip_err
+			    ("pvfs2_inode_setxattr: bogus key size (%d)\n",
+			     (int)(strlen(name) + strlen(prefix)));
+			return -EINVAL;
+		}
+	} else {
+		if (strlen(name) >= PVFS_MAX_XATTR_NAMELEN) {
+			gossip_err
+			    ("pvfs2_inode_setxattr: bogus key size (%d)\n",
+			     (int)(strlen(name)));
+			return -EINVAL;
+		}
+	}
+
+	/* This is equivalent to a removexattr */
+	if (size == 0 && value == NULL) {
+		gossip_debug(GOSSIP_XATTR_DEBUG,
+			     "removing xattr (%s%s)\n",
+			     prefix,
+			     name);
+		return pvfs2_inode_removexattr(inode, prefix, name, flags);
+	}
+
+	gossip_debug(GOSSIP_XATTR_DEBUG,
+		     "setxattr on inode %pU, name %s\n",
+		     get_khandle_from_ino(inode),
+		     name);
+
+	down_write(&pvfs2_inode->xattr_sem);
+	new_op = op_alloc(PVFS2_VFS_OP_SETXATTR);
+	if (!new_op)
+		goto out_unlock;
+
+
+	new_op->upcall.req.setxattr.refn = pvfs2_inode->refn;
+	new_op->upcall.req.setxattr.flags = internal_flag;
+	/*
+	 * NOTE: Although keys are meant to be NULL terminated textual
+	 * strings, I am going to explicitly pass the length just in
+	 * case we change this later on...
+	 */
+	ret = snprintf((char *)new_op->upcall.req.setxattr.keyval.key,
+		       PVFS_MAX_XATTR_NAMELEN,
+		       "%s%s",
+		       prefix, name);
+	new_op->upcall.req.setxattr.keyval.key_sz = ret + 1;
+	memcpy(new_op->upcall.req.setxattr.keyval.val, value, size);
+	new_op->upcall.req.setxattr.keyval.val_sz = size;
+
+	gossip_debug(GOSSIP_XATTR_DEBUG,
+		     "pvfs2_inode_setxattr: key %s, key_sz %d "
+		     " value size %zd\n",
+		     (char *)new_op->upcall.req.setxattr.keyval.key,
+		     (int)new_op->upcall.req.setxattr.keyval.key_sz,
+		     size);
+
+	ret = service_operation(new_op,
+				"pvfs2_inode_setxattr",
+				get_interruptible_flag(inode));
+
+	gossip_debug(GOSSIP_XATTR_DEBUG,
+		     "pvfs2_inode_setxattr: returning %d\n",
+		     ret);
+
+	/* when request is serviced properly, free req op struct */
+	op_release(new_op);
+out_unlock:
+	up_write(&pvfs2_inode->xattr_sem);
+	return ret;
+}
+
+/*
+ * Tries to get a specified object's keys into a user-specified buffer of a
+ * given size.  Note that like the previous instances of xattr routines, this
+ * also allows you to pass in a NULL pointer and 0 size to probe the size for
+ * subsequent memory allocations. Thus our return value is always the size of
+ * all the keys unless there were errors in fetching the keys!
+ */
+ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	struct pvfs2_kernel_op_s *new_op;
+	__u64 token = PVFS_ITERATE_START;
+	ssize_t ret = -ENOMEM;
+	ssize_t total = 0;
+	ssize_t length = 0;
+	int count_keys = 0;
+	int key_size;
+	int i = 0;
+
+	if (size > 0 && buffer == NULL) {
+		gossip_err("%s: bogus NULL pointers\n", __func__);
+		return -EINVAL;
+	}
+	if (size < 0) {
+		gossip_err("Invalid size (%d)\n", (int)size);
+		return -EINVAL;
+	}
+
+	down_read(&pvfs2_inode->xattr_sem);
+	new_op = op_alloc(PVFS2_VFS_OP_LISTXATTR);
+	if (!new_op)
+		goto out_unlock;
+
+	if (buffer && size > 0)
+		memset(buffer, 0, size);
+
+try_again:
+	key_size = 0;
+	new_op->upcall.req.listxattr.refn = pvfs2_inode->refn;
+	new_op->upcall.req.listxattr.token = token;
+	new_op->upcall.req.listxattr.requested_count =
+	    (size == 0) ? 0 : PVFS_MAX_XATTR_LISTLEN;
+	ret = service_operation(new_op, __func__,
+				get_interruptible_flag(inode));
+	if (ret != 0)
+		goto done;
+
+	if (size == 0) {
+		/*
+		 * This is a bit of a big upper limit, but I did not want to
+		 * spend too much time getting this correct, since users end
+		 * up allocating memory rather than us...
+		 */
+		total = new_op->downcall.resp.listxattr.returned_count *
+			PVFS_MAX_XATTR_NAMELEN;
+		goto done;
+	}
+
+	length = new_op->downcall.resp.listxattr.keylen;
+	if (length == 0)
+		goto done;
+
+	/*
+	 * Check to see how much can be fit in the buffer. Fit only whole keys.
+	 */
+	for (i = 0; i < new_op->downcall.resp.listxattr.returned_count; i++) {
+		if (total + new_op->downcall.resp.listxattr.lengths[i] > size)
+			goto done;
+
+		/*
+		 * Since many dumb programs try to setxattr() on our reserved
+		 * xattrs this is a feeble attempt at defeating those by not
+		 * listing them in the output of listxattr.. sigh
+		 */
+		if (is_reserved_key(new_op->downcall.resp.listxattr.key +
+				    key_size,
+				    new_op->downcall.resp.
+					listxattr.lengths[i])) {
+			gossip_debug(GOSSIP_XATTR_DEBUG, "Copying key %d -> %s\n",
+					i, new_op->downcall.resp.listxattr.key +
+						key_size);
+			memcpy(buffer + total,
+				new_op->downcall.resp.listxattr.key + key_size,
+				new_op->downcall.resp.listxattr.lengths[i]);
+			total += new_op->downcall.resp.listxattr.lengths[i];
+			count_keys++;
+		} else {
+			gossip_debug(GOSSIP_XATTR_DEBUG, "[RESERVED] key %d -> %s\n",
+					i, new_op->downcall.resp.listxattr.key +
+						key_size);
+		}
+		key_size += new_op->downcall.resp.listxattr.lengths[i];
+	}
+
+	/*
+	 * Since the buffer was large enough, we might have to continue
+	 * fetching more keys!
+	 */
+	token = new_op->downcall.resp.listxattr.token;
+	if (token != PVFS_ITERATE_END)
+		goto try_again;
+
+done:
+	gossip_debug(GOSSIP_XATTR_DEBUG, "%s: returning %d"
+		     " [size of buffer %ld] (filled in %d keys)\n",
+		     __func__,
+		     ret ? (int)ret : (int)total,
+		     (long)size,
+		     count_keys);
+	op_release(new_op);
+	if (ret == 0)
+		ret = total;
+out_unlock:
+	up_read(&pvfs2_inode->xattr_sem);
+	return ret;
+}
+
+int pvfs2_xattr_set_default(struct dentry *dentry,
+			    const char *name,
+			    const void *buffer,
+			    size_t size,
+			    int flags,
+			    int handler_flags)
+{
+	return pvfs2_inode_setxattr(dentry->d_inode,
+				    PVFS2_XATTR_NAME_DEFAULT_PREFIX,
+				    name,
+				    buffer,
+				    size,
+				    flags);
+}
+
+int pvfs2_xattr_get_default(struct dentry *dentry,
+			    const char *name,
+			    void *buffer,
+			    size_t size,
+			    int handler_flags)
+{
+	return pvfs2_inode_getxattr(dentry->d_inode,
+				    PVFS2_XATTR_NAME_DEFAULT_PREFIX,
+				    name,
+				    buffer,
+				    size);
+
+}
+
+static int pvfs2_xattr_set_trusted(struct dentry *dentry,
+			    const char *name,
+			    const void *buffer,
+			    size_t size,
+			    int flags,
+			    int handler_flags)
+{
+	return pvfs2_inode_setxattr(dentry->d_inode,
+				    PVFS2_XATTR_NAME_TRUSTED_PREFIX,
+				    name,
+				    buffer,
+				    size,
+				    flags);
+}
+
+static int pvfs2_xattr_get_trusted(struct dentry *dentry,
+			    const char *name,
+			    void *buffer,
+			    size_t size,
+			    int handler_flags)
+{
+	return pvfs2_inode_getxattr(dentry->d_inode,
+				    PVFS2_XATTR_NAME_TRUSTED_PREFIX,
+				    name,
+				    buffer,
+				    size);
+}
+
+static struct xattr_handler pvfs2_xattr_trusted_handler = {
+	.prefix = PVFS2_XATTR_NAME_TRUSTED_PREFIX,
+	.get = pvfs2_xattr_get_trusted,
+	.set = pvfs2_xattr_set_trusted,
+};
+
+static struct xattr_handler pvfs2_xattr_default_handler = {
+	/*
+	 * NOTE: this is set to be the empty string.
+	 * so that all un-prefixed xattrs keys get caught
+	 * here!
+	 */
+	.prefix = PVFS2_XATTR_NAME_DEFAULT_PREFIX,
+	.get = pvfs2_xattr_get_default,
+	.set = pvfs2_xattr_set_default,
+};
+
+const struct xattr_handler *pvfs2_xattr_handlers[] = {
+	&posix_acl_access_xattr_handler,
+	&posix_acl_default_xattr_handler,
+	&pvfs2_xattr_trusted_handler,
+	&pvfs2_xattr_default_handler,
+	NULL
+};
