commit ec95f1dedc9c64ac5a8b0bdb7c276936c70fdedd
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Apr 8 08:52:40 2020 -0400

    orangefs: get rid of knob code...
    
    Christoph Hellwig sent in a reversion of "orangefs: remember count
    when reading." because:
    
      ->read_iter calls can race with each other and one or
      more ->flush calls. Remove the the scheme to store the read
      count in the file private data as is is completely racy and
      can cause use after free or double free conditions
    
    Christoph's reversion caused Orangefs not to work or to compile. I
    added a patch that fixed that, but intel's kbuild test robot pointed
    out that sending Christoph's patch followed by my patch upstream, it
    would break bisection because of the failure to compile. So I have
    combined the reversion plus my patch... here's the commit message
    that was in my patch:
    
      Logically, optimal Orangefs "pages" are 4 megabytes. Reading
      large Orangefs files 4096 bytes at a time is like trying to
      kick a dead whale down the beach. Before Christoph's "Revert
      orangefs: remember count when reading." I tried to give users
      a knob whereby they could, for example, use "count" in
      read(2) or bs with dd(1) to get whatever they considered an
      appropriate amount of bytes at a time from Orangefs and fill
      as many page cache pages as they could at once.
    
      Without the racy code that Christoph reverted Orangefs won't
      even compile, much less work. So this replaces the logic that
      used the private file data that Christoph reverted with
      a static number of bytes to read from Orangefs.
    
      I ran tests like the following to determine what a
      reasonable static number of bytes might be:
    
      dd if=/pvfsmnt/asdf of=/dev/null count=128 bs=4194304
      dd if=/pvfsmnt/asdf of=/dev/null count=256 bs=2097152
      dd if=/pvfsmnt/asdf of=/dev/null count=512 bs=1048576
                                .
                                .
                                .
      dd if=/pvfsmnt/asdf of=/dev/null count=4194304 bs=128
    
      Reads seem faster using the static number, so my "knob code"
      wasn't just racy, it wasn't even a good idea...
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>
    Reported-by: kbuild test robot <lkp@intel.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index ed67f39fa7ce..e12aeb9623d6 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -239,10 +239,6 @@ struct orangefs_write_range {
 	kgid_t gid;
 };
 
-struct orangefs_read_options {
-	ssize_t blksiz;
-};
-
 extern struct orangefs_stats orangefs_stats;
 
 /*

commit f9bbb68233aa5bd5ef238bd3532fddf92fa1b53c
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Tue Nov 26 12:39:37 2019 -0500

    orangefs: posix open permission checking...
    
    Orangefs has no open, and orangefs checks file permissions
    on each file access. Posix requires that file permissions
    be checked on open and nowhere else. Orangefs-through-the-kernel
    needs to seem posix compliant.
    
    The VFS opens files, even if the filesystem provides no
    method. We can see if a file was successfully opened for
    read and or for write by looking at file->f_mode.
    
    When writes are flowing from the page cache, file is no
    longer available. We can trust the VFS to have checked
    file->f_mode before writing to the page cache.
    
    The mode of a file might change between when it is opened
    and IO commences, or it might be created with an arbitrary mode.
    
    We'll make sure we don't hit EACCES during the IO stage by
    using UID 0. Some of the time we have access without changing
    to UID 0 - how to check?
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 34a6c99fa29b..ed67f39fa7ce 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -398,7 +398,8 @@ bool __is_daemon_in_service(void);
  */
 int orangefs_revalidate_mapping(struct inode *);
 ssize_t wait_for_direct_io(enum ORANGEFS_io_type, struct inode *, loff_t *,
-    struct iov_iter *, size_t, loff_t, struct orangefs_write_range *, int *);
+    struct iov_iter *, size_t, loff_t, struct orangefs_write_range *, int *,
+    struct file *);
 ssize_t do_readv_writev(enum ORANGEFS_io_type, struct file *, loff_t *,
     struct iov_iter *);
 

commit 25b532cec59ee119bf1c4081fe06fac43722f61f
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Fri Jul 26 09:51:28 2019 -0300

    docs: fs: convert porting to ReST
    
    This file has its own proper style, except that, after a while,
    the coding style gets violated and whitespaces are placed on
    different ways.
    
    As Sphinx and ReST are very sentitive to whitespace differences,
    I had to opt if each entry after required/mandatory/... fields
    should start with zero spaces or with a tab. I opted to start them
    all from the zero position, in order to avoid needing to break lines
    with more than 80 columns, with would make harder for review.
    
    Most of the other changes at porting.rst were made to use an unified
    notation with works nice as a text file while also produce a good html
    output after being parsed.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 572dd29fbd54..34a6c99fa29b 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -246,7 +246,7 @@ struct orangefs_read_options {
 extern struct orangefs_stats orangefs_stats;
 
 /*
- * NOTE: See Documentation/filesystems/porting for information
+ * NOTE: See Documentation/filesystems/porting.rst for information
  * on implementing FOO_I and properly accessing fs private data
  */
 static inline struct orangefs_inode_s *ORANGEFS_I(struct inode *inode)

commit 4077a0f25b001926f86d35f6236351583bada9a4
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Mon Mar 25 18:17:10 2019 -0400

    orangefs: pass slot index back to readpage.
    
    When userspace deposits more than a page of data into the shared buffer,
    we'll need to know which slot it is in when we get back to readpage
    so that we can try to use the extra data to fill some extra pages.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 3ae2f129b9c7..572dd29fbd54 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -398,7 +398,7 @@ bool __is_daemon_in_service(void);
  */
 int orangefs_revalidate_mapping(struct inode *);
 ssize_t wait_for_direct_io(enum ORANGEFS_io_type, struct inode *, loff_t *,
-    struct iov_iter *, size_t, loff_t, struct orangefs_write_range *);
+    struct iov_iter *, size_t, loff_t, struct orangefs_write_range *, int *);
 ssize_t do_readv_writev(enum ORANGEFS_io_type, struct file *, loff_t *,
     struct iov_iter *);
 

commit c2549f8c7a28c00facaf911f700c4811cfd6f52b
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Mon Mar 25 15:52:29 2019 -0400

    orangefs: remember count when reading.
    
    Orangefs wins when it can do IO on large (up to four meg) blocks at a time,
    and looses when it has to do tiny "small io" reads and writes. Accessing
    Orangefs through the pagecache with the kernel module helps with small io,
    both reading and writing, a great deal. Readpage generally tries to fetch a
    page (four k) at a time. We'll let users use "count" (as in read(2) or
    pread(2) for example) as a knob to control how much data they get from
    Orangefs at a time and we'll try to use the data to fill extra
    pagecache pages when we get to ->readpage, hopefully resulting in
    fewer calls to readpage and Orangefs userspace.
    
    We need a way to remember how they set count so that we can still have
    it available when we get to ->readpage.
    
     - We'll use file->private_data to keep track of "count".
       We'll wrap generic_file_open with orangefs_file_open and
       initialize private_data to NULL there.
    
     - In ->read_iter we have access to both "count" and file, so
       we'll kmalloc some space onto file->private_data and store
       "count" there.
    
     - We'll kfree file->private_data each time we visit ->flush and
       reinitialize it to NULL.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 87beab10326a..3ae2f129b9c7 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -239,6 +239,10 @@ struct orangefs_write_range {
 	kgid_t gid;
 };
 
+struct orangefs_read_options {
+	ssize_t blksiz;
+};
+
 extern struct orangefs_stats orangefs_stats;
 
 /*

commit 8f04e1be784858ba0288c7c09b9de06627a800c9
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Feb 12 20:19:06 2019 +0000

    orangefs: add orangefs_revalidate_mapping
    
    This is modeled after NFS, except our method is different.  We use a
    simple timer to determine whether to invalidate the page cache.  This
    is bound to perform.
    
    This addes a sysfs parameter cache_timeout_msecs which controls the time
    between page cache invalidations.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 336a3ec0b83e..87beab10326a 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -193,9 +193,11 @@ struct orangefs_inode_s {
 	sector_t last_failed_block_index_read;
 
 	unsigned long getattr_time;
+	unsigned long mapping_time;
 	int attr_valid;
 	kuid_t attr_uid;
 	kgid_t attr_gid;
+	unsigned long bitlock;
 
 	DECLARE_HASHTABLE(xattr_cache, 4);
 };
@@ -390,6 +392,7 @@ bool __is_daemon_in_service(void);
 /*
  * defined in file.c
  */
+int orangefs_revalidate_mapping(struct inode *);
 ssize_t wait_for_direct_io(enum ORANGEFS_io_type, struct inode *, loff_t *,
     struct iov_iter *, size_t, loff_t, struct orangefs_write_range *);
 ssize_t do_readv_writev(enum ORANGEFS_io_type, struct file *, loff_t *,
@@ -427,6 +430,7 @@ int orangefs_normalize_to_errno(__s32 error_code);
 extern struct mutex orangefs_request_mutex;
 extern int op_timeout_secs;
 extern int slot_timeout_secs;
+extern int orangefs_cache_timeout_msecs;
 extern int orangefs_dcache_timeout_msecs;
 extern int orangefs_getattr_timeout_msecs;
 extern struct list_head orangefs_superblocks;

commit 52e2d0a3804c095775b178d6b0707ef6ac8e6d04
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Dec 14 15:24:43 2018 -0500

    orangefs: write range tracking
    
    Attach the actual range of bytes written to plus the responsible uid/gid
    to each dirty page.  This information must be sent to the server when
    the page is written out.
    
    Now write_begin, page_mkwrite, and invalidatepage keep up with this
    information.  There are several conditions where they must write out the
    page immediately to store the new range.  Two non-contiguous ranges
    cannot be stored on a single page.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 307bbb61819a..336a3ec0b83e 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -230,6 +230,13 @@ struct orangefs_cached_xattr {
 	unsigned long timeout;
 };
 
+struct orangefs_write_range {
+	loff_t pos;
+	size_t len;
+	kuid_t uid;
+	kgid_t gid;
+};
+
 extern struct orangefs_stats orangefs_stats;
 
 /*
@@ -342,6 +349,7 @@ void fsid_key_table_finalize(void);
 /*
  * defined in inode.c
  */
+vm_fault_t orangefs_page_mkwrite(struct vm_fault *);
 struct inode *orangefs_new_inode(struct super_block *sb,
 			      struct inode *dir,
 			      int mode,
@@ -383,7 +391,7 @@ bool __is_daemon_in_service(void);
  * defined in file.c
  */
 ssize_t wait_for_direct_io(enum ORANGEFS_io_type, struct inode *, loff_t *,
-    struct iov_iter *, size_t, loff_t);
+    struct iov_iter *, size_t, loff_t, struct orangefs_write_range *);
 ssize_t do_readv_writev(enum ORANGEFS_io_type, struct file *, loff_t *,
     struct iov_iter *);
 

commit c453dcfc79815760071bd9a7805d4b809fec05cf
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Feb 16 20:51:24 2018 +0000

    orangefs: migrate to generic_file_read_iter
    
    Remove orangefs_inode_read.  It was used by readpage.  Calling
    wait_for_direct_io directly serves the purpose just as well.  There is
    now no check of the bufmap size in the readpage path.  There are already
    other places the bufmap size is assumed to be greater than PAGE_SIZE.
    
    Important to call truncate_inode_pages now in the write path so a
    subsequent read sees the new data.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 46b9ad1d2a9b..307bbb61819a 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -369,11 +369,6 @@ ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size);
 struct inode *orangefs_iget(struct super_block *sb,
 			 struct orangefs_object_kref *ref);
 
-ssize_t orangefs_inode_read(struct inode *inode,
-			    struct iov_iter *iter,
-			    loff_t *offset,
-			    loff_t readahead_size);
-
 /*
  * defined in devorangefs-req.c
  */
@@ -384,6 +379,14 @@ void orangefs_dev_cleanup(void);
 int is_daemon_in_service(void);
 bool __is_daemon_in_service(void);
 
+/*
+ * defined in file.c
+ */
+ssize_t wait_for_direct_io(enum ORANGEFS_io_type, struct inode *, loff_t *,
+    struct iov_iter *, size_t, loff_t);
+ssize_t do_readv_writev(enum ORANGEFS_io_type, struct file *, loff_t *,
+    struct iov_iter *);
+
 /*
  * defined in orangefs-utils.c
  */

commit 0dcac0f7812b2c09ed018a5eba91448a37f1b71b
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Feb 15 19:38:01 2018 +0000

    orangefs: service ops done for writeback are not killable
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index a74d9e8c5f9e..46b9ad1d2a9b 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -442,6 +442,7 @@ extern const struct dentry_operations orangefs_dentry_operations;
 #define ORANGEFS_OP_CANCELLATION  4   /* this is a cancellation */
 #define ORANGEFS_OP_NO_MUTEX      8   /* don't acquire request_mutex */
 #define ORANGEFS_OP_ASYNC         16  /* Queue it, but don't wait */
+#define ORANGEFS_OP_WRITEBACK     32
 
 int service_operation(struct orangefs_kernel_op_s *op,
 		      const char *op_name,

commit afd9fb2a31797b4c787034294a4062df0c19c37e
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Feb 13 20:13:46 2018 +0000

    orangefs: reorganize setattr functions to track attribute changes
    
    OrangeFS accepts a mask indicating which attributes were changed.  The
    kernel must not set any bits except those that were actually changed.
    The kernel must set the uid/gid of the request to the actual uid/gid
    responsible for the change.
    
    Code path for notify_change initiated setattrs is
    
    orangefs_setattr(dentry, iattr)
    -> __orangefs_setattr(inode, iattr)
    
    In kernel changes are initiated by calling __orangefs_setattr.
    
    Code path for writeback is
    
    orangefs_write_inode
    -> orangefs_inode_setattr
    
    attr_valid and attr_uid and attr_gid change together under i_lock.
    I_DIRTY changes separately.
    
    __orangefs_setattr
            lock
            if needs to be cleaned first, unlock and retry
            set attr_valid
            copy data in
            unlock
            mark_inode_dirty
    
    orangefs_inode_setattr
            lock
            copy attributes out
            unlock
            clear getattr_time
            # __writeback_single_inode clears dirty
    
    orangefs_inode_getattr
            # possible to get here with attr_valid set and not dirty
            lock
            if getattr_time ok or attr_valid set, unlock and return
            unlock
            do server operation
            # another thread may getattr or setattr, so check for that
            lock
            if getattr_time ok or attr_valid, unlock and return
            else, copy in
            update getattr_time
            unlock
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 4f0cf14c18f6..a74d9e8c5f9e 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -193,6 +193,9 @@ struct orangefs_inode_s {
 	sector_t last_failed_block_index_read;
 
 	unsigned long getattr_time;
+	int attr_valid;
+	kuid_t attr_uid;
+	kgid_t attr_gid;
 
 	DECLARE_HASHTABLE(xattr_cache, 4);
 };
@@ -345,7 +348,8 @@ struct inode *orangefs_new_inode(struct super_block *sb,
 			      dev_t dev,
 			      struct orangefs_object_kref *ref);
 
-int orangefs_setattr(struct dentry *dentry, struct iattr *iattr);
+int __orangefs_setattr(struct inode *, struct iattr *);
+int orangefs_setattr(struct dentry *, struct iattr *);
 
 int orangefs_getattr(const struct path *path, struct kstat *stat,
 		     u32 request_mask, unsigned int flags);
@@ -403,7 +407,7 @@ int orangefs_inode_getattr(struct inode *, int);
 
 int orangefs_inode_check_changed(struct inode *inode);
 
-int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr);
+int orangefs_inode_setattr(struct inode *inode);
 
 bool orangefs_cancel_op_in_progress(struct orangefs_kernel_op_s *op);
 

commit 8b60785c1d7c63415c32bf64dabc686b9045ce7d
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Wed Feb 7 18:44:50 2018 +0000

    orangefs: simplify orangefs_inode_getattr interface
    
    No need to store the received mask.  It is either STATX_BASIC_STATS or
    STATX_BASIC_STATS & ~STATX_SIZE.  If STATX_SIZE is requested, the cache
    is bypassed anyway, so the cached mask is unnecessary to decide whether
    to do a real getattr.
    
    This is a change.  Previously a getattr would want size and use the
    cached size.  All of the in-kernel callers that wanted size did not want
    a cached size.  Now a getattr cannot use the cached size if it wants
    size at all.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index eba9136207f9..4f0cf14c18f6 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -193,7 +193,6 @@ struct orangefs_inode_s {
 	sector_t last_failed_block_index_read;
 
 	unsigned long getattr_time;
-	u32 getattr_mask;
 
 	DECLARE_HASHTABLE(xattr_cache, 4);
 };
@@ -397,8 +396,10 @@ int orangefs_inode_setxattr(struct inode *inode,
 			 size_t size,
 			 int flags);
 
-int orangefs_inode_getattr(struct inode *inode, int new, int bypass,
-    u32 request_mask);
+#define ORANGEFS_GETATTR_NEW 1
+#define ORANGEFS_GETATTR_SIZE 2
+
+int orangefs_inode_getattr(struct inode *, int);
 
 int orangefs_inode_check_changed(struct inode *inode);
 

commit fc2e2e9c43e3b3f5dec8a02b17ee3d6343d9783a
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Dec 12 13:46:30 2017 -0500

    orangefs: implement xattr cache
    
    This uses the same timeout as the getattr cache.  This substantially
    increases performance when writing files with smaller buffer sizes.
    
    When writing, the size is (often) changed, which causes a call to
    notify_change which calls security_inode_need_killpriv which needs a
    getxattr.  Caching it reduces traffic to the server.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 17b24ad6b264..eba9136207f9 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -51,6 +51,7 @@
 #include <linux/rwsem.h>
 #include <linux/xattr.h>
 #include <linux/exportfs.h>
+#include <linux/hashtable.h>
 
 #include <asm/unaligned.h>
 
@@ -193,6 +194,8 @@ struct orangefs_inode_s {
 
 	unsigned long getattr_time;
 	u32 getattr_mask;
+
+	DECLARE_HASHTABLE(xattr_cache, 4);
 };
 
 /* per superblock private orangefs info */
@@ -217,6 +220,14 @@ struct orangefs_stats {
 	unsigned long writes;
 };
 
+struct orangefs_cached_xattr {
+	struct hlist_node node;
+	char key[ORANGEFS_MAX_XATTR_NAMELEN];
+	char val[ORANGEFS_MAX_XATTR_VALUELEN];
+	ssize_t length;
+	unsigned long timeout;
+};
+
 extern struct orangefs_stats orangefs_stats;
 
 /*

commit 7a932516f55cdf430c7cce78df2010ff7db6b874
Merge: dc594c39f7a9 e264abeaf9da
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 15 07:31:07 2018 +0900

    Merge tag 'vfs-timespec64' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/playground
    
    Pull inode timestamps conversion to timespec64 from Arnd Bergmann:
     "This is a late set of changes from Deepa Dinamani doing an automated
      treewide conversion of the inode and iattr structures from 'timespec'
      to 'timespec64', to push the conversion from the VFS layer into the
      individual file systems.
    
      As Deepa writes:
    
       'The series aims to switch vfs timestamps to use struct timespec64.
        Currently vfs uses struct timespec, which is not y2038 safe.
    
        The series involves the following:
        1. Add vfs helper functions for supporting struct timepec64
           timestamps.
        2. Cast prints of vfs timestamps to avoid warnings after the switch.
        3. Simplify code using vfs timestamps so that the actual replacement
           becomes easy.
        4. Convert vfs timestamps to use struct timespec64 using a script.
           This is a flag day patch.
    
        Next steps:
        1. Convert APIs that can handle timespec64, instead of converting
           timestamps at the boundaries.
        2. Update internal data structures to avoid timestamp conversions'
    
      Thomas Gleixner adds:
    
       'I think there is no point to drag that out for the next merge
        window. The whole thing needs to be done in one go for the core
        changes which means that you're going to play that catchup game
        forever. Let's get over with it towards the end of the merge window'"
    
    * tag 'vfs-timespec64' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/playground:
      pstore: Remove bogus format string definition
      vfs: change inode times to use struct timespec64
      pstore: Convert internal records to timespec64
      udf: Simplify calls to udf_disk_stamp_to_time
      fs: nfs: get rid of memcpys for inode times
      ceph: make inode time prints to be long long
      lustre: Use long long type to print inode time
      fs: add timespec64_truncate()

commit 95582b00838837fc07e042979320caf917ce3fe6
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Tue May 8 19:36:02 2018 -0700

    vfs: change inode times to use struct timespec64
    
    struct timespec is not y2038 safe. Transition vfs to use
    y2038 safe struct timespec64 instead.
    
    The change was made with the help of the following cocinelle
    script. This catches about 80% of the changes.
    All the header file and logic changes are included in the
    first 5 rules. The rest are trivial substitutions.
    I avoid changing any of the function signatures or any other
    filesystem specific data structures to keep the patch simple
    for review.
    
    The script can be a little shorter by combining different cases.
    But, this version was sufficient for my usecase.
    
    virtual patch
    
    @ depends on patch @
    identifier now;
    @@
    - struct timespec
    + struct timespec64
      current_time ( ... )
      {
    - struct timespec now = current_kernel_time();
    + struct timespec64 now = current_kernel_time64();
      ...
    - return timespec_trunc(
    + return timespec64_trunc(
      ... );
      }
    
    @ depends on patch @
    identifier xtime;
    @@
     struct \( iattr \| inode \| kstat \) {
     ...
    -       struct timespec xtime;
    +       struct timespec64 xtime;
     ...
     }
    
    @ depends on patch @
    identifier t;
    @@
     struct inode_operations {
     ...
    int (*update_time) (...,
    -       struct timespec t,
    +       struct timespec64 t,
    ...);
     ...
     }
    
    @ depends on patch @
    identifier t;
    identifier fn_update_time =~ "update_time$";
    @@
     fn_update_time (...,
    - struct timespec *t,
    + struct timespec64 *t,
     ...) { ... }
    
    @ depends on patch @
    identifier t;
    @@
    lease_get_mtime( ... ,
    - struct timespec *t
    + struct timespec64 *t
      ) { ... }
    
    @te depends on patch forall@
    identifier ts;
    local idexpression struct inode *inode_node;
    identifier i_xtime =~ "^i_[acm]time$";
    identifier ia_xtime =~ "^ia_[acm]time$";
    identifier fn_update_time =~ "update_time$";
    identifier fn;
    expression e, E3;
    local idexpression struct inode *node1;
    local idexpression struct inode *node2;
    local idexpression struct iattr *attr1;
    local idexpression struct iattr *attr2;
    local idexpression struct iattr attr;
    identifier i_xtime1 =~ "^i_[acm]time$";
    identifier i_xtime2 =~ "^i_[acm]time$";
    identifier ia_xtime1 =~ "^ia_[acm]time$";
    identifier ia_xtime2 =~ "^ia_[acm]time$";
    @@
    (
    (
    - struct timespec ts;
    + struct timespec64 ts;
    |
    - struct timespec ts = current_time(inode_node);
    + struct timespec64 ts = current_time(inode_node);
    )
    
    <+... when != ts
    (
    - timespec_equal(&inode_node->i_xtime, &ts)
    + timespec64_equal(&inode_node->i_xtime, &ts)
    |
    - timespec_equal(&ts, &inode_node->i_xtime)
    + timespec64_equal(&ts, &inode_node->i_xtime)
    |
    - timespec_compare(&inode_node->i_xtime, &ts)
    + timespec64_compare(&inode_node->i_xtime, &ts)
    |
    - timespec_compare(&ts, &inode_node->i_xtime)
    + timespec64_compare(&ts, &inode_node->i_xtime)
    |
    ts = current_time(e)
    |
    fn_update_time(..., &ts,...)
    |
    inode_node->i_xtime = ts
    |
    node1->i_xtime = ts
    |
    ts = inode_node->i_xtime
    |
    <+... attr1->ia_xtime ...+> = ts
    |
    ts = attr1->ia_xtime
    |
    ts.tv_sec
    |
    ts.tv_nsec
    |
    btrfs_set_stack_timespec_sec(..., ts.tv_sec)
    |
    btrfs_set_stack_timespec_nsec(..., ts.tv_nsec)
    |
    - ts = timespec64_to_timespec(
    + ts =
    ...
    -)
    |
    - ts = ktime_to_timespec(
    + ts = ktime_to_timespec64(
    ...)
    |
    - ts = E3
    + ts = timespec_to_timespec64(E3)
    |
    - ktime_get_real_ts(&ts)
    + ktime_get_real_ts64(&ts)
    |
    fn(...,
    - ts
    + timespec64_to_timespec(ts)
    ,...)
    )
    ...+>
    (
    <... when != ts
    - return ts;
    + return timespec64_to_timespec(ts);
    ...>
    )
    |
    - timespec_equal(&node1->i_xtime1, &node2->i_xtime2)
    + timespec64_equal(&node1->i_xtime2, &node2->i_xtime2)
    |
    - timespec_equal(&node1->i_xtime1, &attr2->ia_xtime2)
    + timespec64_equal(&node1->i_xtime2, &attr2->ia_xtime2)
    |
    - timespec_compare(&node1->i_xtime1, &node2->i_xtime2)
    + timespec64_compare(&node1->i_xtime1, &node2->i_xtime2)
    |
    node1->i_xtime1 =
    - timespec_trunc(attr1->ia_xtime1,
    + timespec64_trunc(attr1->ia_xtime1,
    ...)
    |
    - attr1->ia_xtime1 = timespec_trunc(attr2->ia_xtime2,
    + attr1->ia_xtime1 =  timespec64_trunc(attr2->ia_xtime2,
    ...)
    |
    - ktime_get_real_ts(&attr1->ia_xtime1)
    + ktime_get_real_ts64(&attr1->ia_xtime1)
    |
    - ktime_get_real_ts(&attr.ia_xtime1)
    + ktime_get_real_ts64(&attr.ia_xtime1)
    )
    
    @ depends on patch @
    struct inode *node;
    struct iattr *attr;
    identifier fn;
    identifier i_xtime =~ "^i_[acm]time$";
    identifier ia_xtime =~ "^ia_[acm]time$";
    expression e;
    @@
    (
    - fn(node->i_xtime);
    + fn(timespec64_to_timespec(node->i_xtime));
    |
     fn(...,
    - node->i_xtime);
    + timespec64_to_timespec(node->i_xtime));
    |
    - e = fn(attr->ia_xtime);
    + e = fn(timespec64_to_timespec(attr->ia_xtime));
    )
    
    @ depends on patch forall @
    struct inode *node;
    struct iattr *attr;
    identifier i_xtime =~ "^i_[acm]time$";
    identifier ia_xtime =~ "^ia_[acm]time$";
    identifier fn;
    @@
    {
    + struct timespec ts;
    <+...
    (
    + ts = timespec64_to_timespec(node->i_xtime);
    fn (...,
    - &node->i_xtime,
    + &ts,
    ...);
    |
    + ts = timespec64_to_timespec(attr->ia_xtime);
    fn (...,
    - &attr->ia_xtime,
    + &ts,
    ...);
    )
    ...+>
    }
    
    @ depends on patch forall @
    struct inode *node;
    struct iattr *attr;
    struct kstat *stat;
    identifier ia_xtime =~ "^ia_[acm]time$";
    identifier i_xtime =~ "^i_[acm]time$";
    identifier xtime =~ "^[acm]time$";
    identifier fn, ret;
    @@
    {
    + struct timespec ts;
    <+...
    (
    + ts = timespec64_to_timespec(node->i_xtime);
    ret = fn (...,
    - &node->i_xtime,
    + &ts,
    ...);
    |
    + ts = timespec64_to_timespec(node->i_xtime);
    ret = fn (...,
    - &node->i_xtime);
    + &ts);
    |
    + ts = timespec64_to_timespec(attr->ia_xtime);
    ret = fn (...,
    - &attr->ia_xtime,
    + &ts,
    ...);
    |
    + ts = timespec64_to_timespec(attr->ia_xtime);
    ret = fn (...,
    - &attr->ia_xtime);
    + &ts);
    |
    + ts = timespec64_to_timespec(stat->xtime);
    ret = fn (...,
    - &stat->xtime);
    + &ts);
    )
    ...+>
    }
    
    @ depends on patch @
    struct inode *node;
    struct inode *node2;
    identifier i_xtime1 =~ "^i_[acm]time$";
    identifier i_xtime2 =~ "^i_[acm]time$";
    identifier i_xtime3 =~ "^i_[acm]time$";
    struct iattr *attrp;
    struct iattr *attrp2;
    struct iattr attr ;
    identifier ia_xtime1 =~ "^ia_[acm]time$";
    identifier ia_xtime2 =~ "^ia_[acm]time$";
    struct kstat *stat;
    struct kstat stat1;
    struct timespec64 ts;
    identifier xtime =~ "^[acmb]time$";
    expression e;
    @@
    (
    ( node->i_xtime2 \| attrp->ia_xtime2 \| attr.ia_xtime2 \) = node->i_xtime1  ;
    |
     node->i_xtime2 = \( node2->i_xtime1 \| timespec64_trunc(...) \);
    |
     node->i_xtime2 = node->i_xtime1 = node->i_xtime3 = \(ts \| current_time(...) \);
    |
     node->i_xtime1 = node->i_xtime3 = \(ts \| current_time(...) \);
    |
     stat->xtime = node2->i_xtime1;
    |
     stat1.xtime = node2->i_xtime1;
    |
    ( node->i_xtime2 \| attrp->ia_xtime2 \) = attrp->ia_xtime1  ;
    |
    ( attrp->ia_xtime1 \| attr.ia_xtime1 \) = attrp2->ia_xtime2;
    |
    - e = node->i_xtime1;
    + e = timespec64_to_timespec( node->i_xtime1 );
    |
    - e = attrp->ia_xtime1;
    + e = timespec64_to_timespec( attrp->ia_xtime1 );
    |
    node->i_xtime1 = current_time(...);
    |
     node->i_xtime2 = node->i_xtime1 = node->i_xtime3 =
    - e;
    + timespec_to_timespec64(e);
    |
     node->i_xtime1 = node->i_xtime3 =
    - e;
    + timespec_to_timespec64(e);
    |
    - node->i_xtime1 = e;
    + node->i_xtime1 = timespec_to_timespec64(e);
    )
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Cc: <anton@tuxera.com>
    Cc: <balbi@kernel.org>
    Cc: <bfields@fieldses.org>
    Cc: <darrick.wong@oracle.com>
    Cc: <dhowells@redhat.com>
    Cc: <dsterba@suse.com>
    Cc: <dwmw2@infradead.org>
    Cc: <hch@lst.de>
    Cc: <hirofumi@mail.parknet.co.jp>
    Cc: <hubcap@omnibond.com>
    Cc: <jack@suse.com>
    Cc: <jaegeuk@kernel.org>
    Cc: <jaharkes@cs.cmu.edu>
    Cc: <jslaby@suse.com>
    Cc: <keescook@chromium.org>
    Cc: <mark@fasheh.com>
    Cc: <miklos@szeredi.hu>
    Cc: <nico@linaro.org>
    Cc: <reiserfs-devel@vger.kernel.org>
    Cc: <richard@nod.at>
    Cc: <sage@redhat.com>
    Cc: <sfrench@samba.org>
    Cc: <swhiteho@redhat.com>
    Cc: <tj@kernel.org>
    Cc: <trond.myklebust@primarydata.com>
    Cc: <tytso@mit.edu>
    Cc: <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index c29bb0ebc6bb..7ed50ee3db8a 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -343,7 +343,7 @@ int orangefs_getattr(const struct path *path, struct kstat *stat,
 
 int orangefs_permission(struct inode *inode, int mask);
 
-int orangefs_update_time(struct inode *, struct timespec *, int);
+int orangefs_update_time(struct inode *, struct timespec64 *, int);
 
 /*
  * defined in xattr.c

commit 9f8fd53cd05596f6792f769c9fd5fd2b0d624507
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu May 31 16:36:59 2018 +0000

    orangefs: revamp block sizes
    
    Now the superblock block size is PAGE_SIZE.  The inode block size is
    PAGE_SIZE for directories and symlinks, but is the server-reported
    block size for regular files.
    
    The block size in the OrangeFS private inode is now deleted.  Stat
    now reports PAGE_SIZE for directories and symlinks and the
    server-reported block size for regular files.
    
    The user-space visible change is that the block size for directores
    and symlinks and the superblock is now PAGE_SIZE rather than the size of
    the client-core shared memory buffers, which was typically four
    megabytes.
    
    Reported-by: Becky Ligon <ligon@clemson.edu>
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Cc: hubcap@omnibond.com
    Cc: walt@omnibond.com
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index c29bb0ebc6bb..004511617b6d 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -182,7 +182,6 @@ static inline void set_op_state_purged(struct orangefs_kernel_op_s *op)
 struct orangefs_inode_s {
 	struct orangefs_object_kref refn;
 	char link_target[ORANGEFS_NAME_MAX];
-	__s64 blksize;
 	/*
 	 * Reading/Writing Extended attributes need to acquire the appropriate
 	 * reader/writer semaphore on the orangefs_inode_s structure.

commit 209469d978ae91e460b37b32f2c2834d93e1ff13
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 3 16:27:14 2018 +0000

    orangefs: remove unused code
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index f49d53de8901..c29bb0ebc6bb 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -65,11 +65,7 @@
 #define ORANGEFS_REQDEVICE_NAME          "pvfs2-req"
 
 #define ORANGEFS_DEVREQ_MAGIC             0x20030529
-#define ORANGEFS_LINK_MAX                 0x000000FF
 #define ORANGEFS_PURGE_RETRY_COUNT     0x00000005
-#define ORANGEFS_MAX_NUM_OPTIONS          0x00000004
-#define ORANGEFS_MAX_MOUNT_OPT_LEN        0x00000080
-#define ORANGEFS_MAX_FSKEY_LEN            64
 
 #define MAX_DEV_REQ_UPSIZE (2 * sizeof(__s32) +   \
 sizeof(__u64) + sizeof(struct orangefs_upcall_s))
@@ -112,15 +108,6 @@ extern const struct xattr_handler *orangefs_xattr_handlers[];
 extern struct posix_acl *orangefs_get_acl(struct inode *inode, int type);
 extern int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type);
 
-/*
- * Redefine xtvec structure so that we could move helper functions out of
- * the define
- */
-struct xtvec {
-	__kernel_off_t xtv_off;		/* must be off_t */
-	__kernel_size_t xtv_len;	/* must be size_t */
-};
-
 /*
  * orangefs data structures
  */
@@ -224,39 +211,6 @@ struct orangefs_sb_info_s {
 	struct list_head list;
 };
 
-/*
- * structure that holds the state of any async I/O operation issued
- * through the VFS. Needed especially to handle cancellation requests
- * or even completion notification so that the VFS client-side daemon
- * can free up its vfs_request slots.
- */
-struct orangefs_kiocb_s {
-	/* the pointer to the task that initiated the AIO */
-	struct task_struct *tsk;
-
-	/* pointer to the kiocb that kicked this operation */
-	struct kiocb *kiocb;
-
-	/* buffer index that was used for the I/O */
-	struct orangefs_bufmap *bufmap;
-	int buffer_index;
-
-	/* orangefs kernel operation type */
-	struct orangefs_kernel_op_s *op;
-
-	/* set to indicate the type of the operation */
-	int rw;
-
-	/* file offset */
-	loff_t offset;
-
-	/* and the count in bytes */
-	size_t bytes_to_be_copied;
-
-	ssize_t bytes_copied;
-	int needs_cleanup;
-};
-
 struct orangefs_stats {
 	unsigned long cache_hits;
 	unsigned long cache_misses;
@@ -305,21 +259,6 @@ static inline struct orangefs_khandle *get_khandle_from_ino(struct inode *inode)
 	return &(ORANGEFS_I(inode)->refn.khandle);
 }
 
-static inline ino_t get_ino_from_khandle(struct inode *inode)
-{
-	struct orangefs_khandle *khandle;
-	ino_t ino;
-
-	khandle = get_khandle_from_ino(inode);
-	ino = orangefs_khandle_to_ino(khandle);
-	return ino;
-}
-
-static inline ino_t get_parent_ino_from_dentry(struct dentry *dentry)
-{
-	return get_ino_from_khandle(dentry->d_parent->d_inode);
-}
-
 static inline int is_root_handle(struct inode *inode)
 {
 	gossip_debug(GOSSIP_DCACHE_DEBUG,
@@ -391,7 +330,6 @@ void fsid_key_table_finalize(void);
 /*
  * defined in inode.c
  */
-__u32 convert_to_orangefs_mask(unsigned long lite_mask);
 struct inode *orangefs_new_inode(struct super_block *sb,
 			      struct inode *dir,
 			      int mode,
@@ -410,17 +348,6 @@ int orangefs_update_time(struct inode *, struct timespec *, int);
 /*
  * defined in xattr.c
  */
-int orangefs_setxattr(struct dentry *dentry,
-		   const char *name,
-		   const void *value,
-		   size_t size,
-		   int flags);
-
-ssize_t orangefs_getxattr(struct dentry *dentry,
-		       const char *name,
-		       void *buffer,
-		       size_t size);
-
 ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size);
 
 /*
@@ -467,8 +394,6 @@ int orangefs_inode_check_changed(struct inode *inode);
 
 int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr);
 
-int orangefs_unmount_sb(struct super_block *sb);
-
 bool orangefs_cancel_op_in_progress(struct orangefs_kernel_op_s *op);
 
 int orangefs_normalize_to_errno(__s32 error_code);
@@ -493,8 +418,6 @@ extern const struct inode_operations orangefs_dir_inode_operations;
 extern const struct file_operations orangefs_dir_operations;
 extern const struct dentry_operations orangefs_dentry_operations;
 
-extern wait_queue_head_t orangefs_bufmap_init_waitq;
-
 /*
  * misc convenience macros
  */

commit bdd6f083586ff17eb3959cca88212fdb60ca53d1
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 3 16:27:13 2018 +0000

    orangefs: make several *_operations structs static
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index eebbaece85ef..f49d53de8901 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -487,14 +487,11 @@ extern struct list_head *orangefs_htable_ops_in_progress;
 extern spinlock_t orangefs_htable_ops_in_progress_lock;
 extern int hash_table_size;
 
-extern const struct address_space_operations orangefs_address_operations;
-extern const struct inode_operations orangefs_file_inode_operations;
 extern const struct file_operations orangefs_file_operations;
 extern const struct inode_operations orangefs_symlink_inode_operations;
 extern const struct inode_operations orangefs_dir_inode_operations;
 extern const struct file_operations orangefs_dir_operations;
 extern const struct dentry_operations orangefs_dentry_operations;
-extern const struct file_operations orangefs_devreq_file_operations;
 
 extern wait_queue_head_t orangefs_bufmap_init_waitq;
 

commit 4d0cac7e752cccb9eb30cd0f22438b9506ed51bc
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Jan 26 14:07:14 2018 -0500

    orangefs: make orangefs_make_bad_inode static
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 25bacc334d91..eebbaece85ef 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -467,8 +467,6 @@ int orangefs_inode_check_changed(struct inode *inode);
 
 int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr);
 
-void orangefs_make_bad_inode(struct inode *inode);
-
 int orangefs_unmount_sb(struct super_block *sb);
 
 bool orangefs_cancel_op_in_progress(struct orangefs_kernel_op_s *op);

commit 538e30482155dbaaa53495ed37b889e9c2577cb9
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Jan 26 14:07:13 2018 -0500

    orangefs: remove ORANGEFS_KERNEL_DEBUG
    
    It wasn't possible to enable it, and it would've had very little effect.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 2595453fe737..25bacc334d91 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -56,11 +56,7 @@
 
 #include "orangefs-dev-proto.h"
 
-#ifdef ORANGEFS_KERNEL_DEBUG
-#define ORANGEFS_DEFAULT_OP_TIMEOUT_SECS       10
-#else
 #define ORANGEFS_DEFAULT_OP_TIMEOUT_SECS       20
-#endif
 
 #define ORANGEFS_BUFMAP_WAIT_TIMEOUT_SECS   30
 
@@ -104,11 +100,11 @@ enum orangefs_vfs_op_states {
  * orangefs kernel memory related flags
  */
 
-#if ((defined ORANGEFS_KERNEL_DEBUG) && (defined CONFIG_DEBUG_SLAB))
+#if (defined CONFIG_DEBUG_SLAB)
 #define ORANGEFS_CACHE_CREATE_FLAGS SLAB_RED_ZONE
 #else
 #define ORANGEFS_CACHE_CREATE_FLAGS 0
-#endif /* ((defined ORANGEFS_KERNEL_DEBUG) && (defined CONFIG_DEBUG_SLAB)) */
+#endif
 
 extern int orangefs_init_acl(struct inode *inode, struct inode *dir);
 extern const struct xattr_handler *orangefs_xattr_handlers[];

commit 6793f1c450b1533a5e9c2493490de771d38b24f9
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Jan 25 19:39:44 2018 -0500

    orangefs: fix deadlock; do not write i_size in read_iter
    
    After do_readv_writev, the inode cache is invalidated anyway, so i_size
    will never be read.  It will be fetched from the server which will also
    know about updates from other machines.
    
    Fixes deadlock on 32-bit SMP.
    
    See https://marc.info/?l=linux-fsdevel&m=151268557427760&w=2
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Mike Marshall <hubcap@omnibond.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 97adf7d100b5..2595453fe737 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -533,17 +533,6 @@ do {									\
 	sys_attr.mask = ORANGEFS_ATTR_SYS_ALL_SETABLE;			\
 } while (0)
 
-static inline void orangefs_i_size_write(struct inode *inode, loff_t i_size)
-{
-#if BITS_PER_LONG == 32 && defined(CONFIG_SMP)
-	inode_lock(inode);
-#endif
-	i_size_write(inode, i_size);
-#if BITS_PER_LONG == 32 && defined(CONFIG_SMP)
-	inode_unlock(inode);
-#endif
-}
-
 static inline void orangefs_set_timeout(struct dentry *dentry)
 {
 	unsigned long time = jiffies + orangefs_dcache_timeout_msecs*HZ/1000;

commit b620fd2df20d2073b4f432113e0de9a6b5d33be5
Merge: adb072d3cd03 db0267e7afc7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 21 05:40:48 2017 -1000

    Merge tag 'for-linus-4.15-ofs1' of git://git.kernel.org/pub/scm/linux/kernel/git/hubcap/linux
    
    Pull orangefs updates from Mike Marshall:
     "Fix:
    
       - stop setting atime on inode dirty (Martin Brandenburg)
    
      Cleanups:
    
       - remove initialization of i_version (Jeff Layton)
    
       - use ARRAY_SIZE (Jérémy Lefaure)
    
       - call op_release sooner when creating inodes (Mike MarshallMartin
         Brandenburg)"
    
    * tag 'for-linus-4.15-ofs1' of git://git.kernel.org/pub/scm/linux/kernel/git/hubcap/linux:
      orangefs: call op_release sooner when creating inodes
      orangefs: stop setting atime on inode dirty
      orangefs: use ARRAY_SIZE
      orangefs: remove initialization of i_version

commit 16382e17c0ff583df2d5eed56ca7c771d637e9d1
Merge: 93f30c73ecd0 cfe057f7db1f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 17 12:08:18 2017 -0800

    Merge branch 'work.iov_iter' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull iov_iter updates from Al Viro:
    
     - bio_{map,copy}_user_iov() series; those are cleanups - fixes from the
       same pile went into mainline (and stable) in late September.
    
     - fs/iomap.c iov_iter-related fixes
    
     - new primitive - iov_iter_for_each_range(), which applies a function
       to kernel-mapped segments of an iov_iter.
    
       Usable for kvec and bvec ones, the latter does kmap()/kunmap() around
       the callback. _Not_ usable for iovec- or pipe-backed iov_iter; the
       latter is not hard to fix if the need ever appears, the former is by
       design.
    
       Another related primitive will have to wait for the next cycle - it
       passes page + offset + size instead of pointer + size, and that one
       will be usable for everything _except_ kvec. Unfortunately, that one
       didn't get exposure in -next yet, so...
    
     - a bit more lustre iov_iter work, including a use case for
       iov_iter_for_each_range() (checksum calculation)
    
     - vhost/scsi leak fix in failure exit
    
     - misc cleanups and detritectomy...
    
    * 'work.iov_iter' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (21 commits)
      iomap_dio_actor(): fix iov_iter bugs
      switch ksocknal_lib_recv_...() to use of iov_iter_for_each_range()
      lustre: switch struct ksock_conn to iov_iter
      vhost/scsi: switch to iov_iter_get_pages()
      fix a page leak in vhost_scsi_iov_to_sgl() error recovery
      new primitive: iov_iter_for_each_range()
      lnet_return_rx_credits_locked: don't abuse list_entry
      xen: don't open-code iov_iter_kvec()
      orangefs: remove detritus from struct orangefs_kiocb_s
      kill iov_shorten()
      bio_alloc_map_data(): do bmd->iter setup right there
      bio_copy_user_iov(): saner bio size calculation
      bio_map_user_iov(): get rid of copying iov_iter
      bio_copy_from_iter(): get rid of copying iov_iter
      move more stuff down into bio_copy_user_iov()
      blk_rq_map_user_iov(): move iov_iter_advance() down
      bio_map_user_iov(): get rid of the iov_for_each()
      bio_map_user_iov(): move alignment check into the main loop
      don't rely upon subsequent bio_add_pc_page() calls failing
      ... and with iov_iter_get_pages_alloc() it becomes even simpler
      ...

commit a55f2d861585006f493e933ad32d65d71ba631fa
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Nov 7 15:01:40 2017 -0500

    orangefs: stop setting atime on inode dirty
    
    The previous code path was to mark the inode dirty, let
    orangefs_inode_dirty set a flag in our private inode, then later during
    inode release call orangefs_flush_inode which notices the flag and
    writes the atime out.
    
    The code path worked almost identically for mtime, ctime, and mode
    except that those flags are set explicitly and not as side effects of
    dirty.
    
    Now orangefs_flush_inode is removed.  Marking an inode dirty does not
    imply an atime update.  Any place where flags were set before is now
    an explicit call to orangefs_inode_setattr.  Since OrangeFS does not
    utilize inode writeback, the attribute change should be written out
    immediately.
    
    Fixes generic/120.
    
    In namei.c, there are several places where the directory mtime and ctime
    are set, but only the mtime is sent to the server.  These don't seem
    right, but I've left them as is for now.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 004af348fb80..6d2bacac85f4 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -209,37 +209,10 @@ struct orangefs_inode_s {
 	struct inode vfs_inode;
 	sector_t last_failed_block_index_read;
 
-	/*
-	 * State of in-memory attributes not yet flushed to disk associated
-	 * with this object
-	 */
-	unsigned long pinode_flags;
-
 	unsigned long getattr_time;
 	u32 getattr_mask;
 };
 
-#define P_ATIME_FLAG 0
-#define P_MTIME_FLAG 1
-#define P_CTIME_FLAG 2
-#define P_MODE_FLAG  3
-
-#define ClearAtimeFlag(pinode) clear_bit(P_ATIME_FLAG, &(pinode)->pinode_flags)
-#define SetAtimeFlag(pinode)   set_bit(P_ATIME_FLAG, &(pinode)->pinode_flags)
-#define AtimeFlag(pinode)      test_bit(P_ATIME_FLAG, &(pinode)->pinode_flags)
-
-#define ClearMtimeFlag(pinode) clear_bit(P_MTIME_FLAG, &(pinode)->pinode_flags)
-#define SetMtimeFlag(pinode)   set_bit(P_MTIME_FLAG, &(pinode)->pinode_flags)
-#define MtimeFlag(pinode)      test_bit(P_MTIME_FLAG, &(pinode)->pinode_flags)
-
-#define ClearCtimeFlag(pinode) clear_bit(P_CTIME_FLAG, &(pinode)->pinode_flags)
-#define SetCtimeFlag(pinode)   set_bit(P_CTIME_FLAG, &(pinode)->pinode_flags)
-#define CtimeFlag(pinode)      test_bit(P_CTIME_FLAG, &(pinode)->pinode_flags)
-
-#define ClearModeFlag(pinode) clear_bit(P_MODE_FLAG, &(pinode)->pinode_flags)
-#define SetModeFlag(pinode)   set_bit(P_MODE_FLAG, &(pinode)->pinode_flags)
-#define ModeFlag(pinode)      test_bit(P_MODE_FLAG, &(pinode)->pinode_flags)
-
 /* per superblock private orangefs info */
 struct orangefs_sb_info_s {
 	struct orangefs_khandle root_khandle;
@@ -442,6 +415,8 @@ int orangefs_getattr(const struct path *path, struct kstat *stat,
 
 int orangefs_permission(struct inode *inode, int mask);
 
+int orangefs_update_time(struct inode *, struct timespec *, int);
+
 /*
  * defined in xattr.c
  */
@@ -484,8 +459,6 @@ bool __is_daemon_in_service(void);
  */
 __s32 fsid_of_op(struct orangefs_kernel_op_s *op);
 
-int orangefs_flush_inode(struct inode *inode);
-
 ssize_t orangefs_inode_getxattr(struct inode *inode,
 			     const char *name,
 			     void *buffer,

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index ea0ce507a6ab..004af348fb80 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * (C) 2001 Clemson University and The University of Chicago
  *

commit 6570f0dd6004b5b925b19666e9c60da432d197fd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Sep 24 17:43:00 2017 -0400

    orangefs: remove detritus from struct orangefs_kiocb_s
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index ea0ce507a6ab..937a5dd2cb14 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -274,12 +274,6 @@ struct orangefs_kiocb_s {
 	/* orangefs kernel operation type */
 	struct orangefs_kernel_op_s *op;
 
-	/* The user space buffers from/to which I/O is being staged */
-	struct iovec *iov;
-
-	/* number of elements in the iovector */
-	unsigned long nr_segs;
-
 	/* set to indicate the type of the operation */
 	int rw;
 

commit 68a24a6cc4a6025e111c282186a2506281d79b4b
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 25 15:38:03 2017 -0400

    orangefs: implement statx
    
    Fortunately OrangeFS has had a getattr request mask for a long time.
    
    The server basically has two difficulty levels for attributes.  Fetching
    any attribute except size requires communicating with the metadata
    server for that handle.  Since all the attributes are right there, it
    makes sense to return them all.  Fetching the size requires
    communicating with every I/O server (that the file is distributed
    across).  Therefore if asked for anything except size, get everything
    except size, and if asked for size, get everything.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index d9b050bc8882..ea0ce507a6ab 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -215,6 +215,7 @@ struct orangefs_inode_s {
 	unsigned long pinode_flags;
 
 	unsigned long getattr_time;
+	u32 getattr_mask;
 };
 
 #define P_ATIME_FLAG 0
@@ -495,7 +496,8 @@ int orangefs_inode_setxattr(struct inode *inode,
 			 size_t size,
 			 int flags);
 
-int orangefs_inode_getattr(struct inode *inode, int new, int bypass);
+int orangefs_inode_getattr(struct inode *inode, int new, int bypass,
+    u32 request_mask);
 
 int orangefs_inode_check_changed(struct inode *inode);
 

commit 418ce3eb66885e409eb3fef5c19bd037435241c5
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 25 15:37:55 2017 -0400

    orangefs: remove unused get_fsid_from_ino
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 8afac46fcc87..d9b050bc8882 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -340,11 +340,6 @@ static inline struct orangefs_khandle *get_khandle_from_ino(struct inode *inode)
 	return &(ORANGEFS_I(inode)->refn.khandle);
 }
 
-static inline __s32 get_fsid_from_ino(struct inode *inode)
-{
-	return ORANGEFS_I(inode)->refn.fs_id;
-}
-
 static inline ino_t get_ino_from_khandle(struct inode *inode)
 {
 	struct orangefs_khandle *khandle;

commit 1ec1688c5360e14dde4094d6acbf7516bf6db37e
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Apr 14 14:22:41 2017 -0400

    orangefs: free superblock when mount fails
    
    Otherwise lockdep says:
    
    [ 1337.483798] ================================================
    [ 1337.483999] [ BUG: lock held when returning to user space! ]
    [ 1337.484252] 4.11.0-rc6 #19 Not tainted
    [ 1337.484423] ------------------------------------------------
    [ 1337.484626] mount/14766 is leaving the kernel with locks still held!
    [ 1337.484841] 1 lock held by mount/14766:
    [ 1337.485017]  #0:  (&type->s_umount_key#33/1){+.+.+.}, at: [<ffffffff8124171f>] sget_userns+0x2af/0x520
    
    Caught by xfstests generic/413 which tried to mount with the unsupported
    mount option dax.  Then xfstests generic/422 ran sync which deadlocks.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Acked-by: Mike Marshall <hubcap@omnibond.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 5e48a0be9761..8afac46fcc87 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -249,6 +249,7 @@ struct orangefs_sb_info_s {
 	char devname[ORANGEFS_MAX_SERVER_ADDR_LEN];
 	struct super_block *sb;
 	int mount_pending;
+	int no_list;
 	struct list_head list;
 };
 

commit 590dce2d4934fb909b112cd80c80486362337744
Merge: e0d072250a54 a528d35e8bfc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 3 11:38:56 2017 -0800

    Merge branch 'rebased-statx' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs 'statx()' update from Al Viro.
    
    This adds the new extended stat() interface that internally subsumes our
    previous stat interfaces, and allows user mode to specify in more detail
    what kind of information it wants.
    
    It also allows for some explicit synchronization information to be
    passed to the filesystem, which can be relevant for network filesystems:
    is the cached value ok, or do you need open/close consistency, or what?
    
    From David Howells.
    
    Andreas Dilger points out that the first version of the extended statx
    interface was posted June 29, 2010:
    
        https://www.spinics.net/lists/linux-fsdevel/msg33831.html
    
    * 'rebased-statx' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      statx: Add a system call to make enhanced file info available

commit a528d35e8bfcc521d7cb70aaf03e1bd296c8493f
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jan 31 16:46:22 2017 +0000

    statx: Add a system call to make enhanced file info available
    
    Add a system call to make extended file information available, including
    file creation and some attribute flags where available through the
    underlying filesystem.
    
    The getattr inode operation is altered to take two additional arguments: a
    u32 request_mask and an unsigned int flags that indicate the
    synchronisation mode.  This change is propagated to the vfs_getattr*()
    function.
    
    Functions like vfs_stat() are now inline wrappers around new functions
    vfs_statx() and vfs_statx_fd() to reduce stack usage.
    
    ========
    OVERVIEW
    ========
    
    The idea was initially proposed as a set of xattrs that could be retrieved
    with getxattr(), but the general preference proved to be for a new syscall
    with an extended stat structure.
    
    A number of requests were gathered for features to be included.  The
    following have been included:
    
     (1) Make the fields a consistent size on all arches and make them large.
    
     (2) Spare space, request flags and information flags are provided for
         future expansion.
    
     (3) Better support for the y2038 problem [Arnd Bergmann] (tv_sec is an
         __s64).
    
     (4) Creation time: The SMB protocol carries the creation time, which could
         be exported by Samba, which will in turn help CIFS make use of
         FS-Cache as that can be used for coherency data (stx_btime).
    
         This is also specified in NFSv4 as a recommended attribute and could
         be exported by NFSD [Steve French].
    
     (5) Lightweight stat: Ask for just those details of interest, and allow a
         netfs (such as NFS) to approximate anything not of interest, possibly
         without going to the server [Trond Myklebust, Ulrich Drepper, Andreas
         Dilger] (AT_STATX_DONT_SYNC).
    
     (6) Heavyweight stat: Force a netfs to go to the server, even if it thinks
         its cached attributes are up to date [Trond Myklebust]
         (AT_STATX_FORCE_SYNC).
    
    And the following have been left out for future extension:
    
     (7) Data version number: Could be used by userspace NFS servers [Aneesh
         Kumar].
    
         Can also be used to modify fill_post_wcc() in NFSD which retrieves
         i_version directly, but has just called vfs_getattr().  It could get
         it from the kstat struct if it used vfs_xgetattr() instead.
    
         (There's disagreement on the exact semantics of a single field, since
         not all filesystems do this the same way).
    
     (8) BSD stat compatibility: Including more fields from the BSD stat such
         as creation time (st_btime) and inode generation number (st_gen)
         [Jeremy Allison, Bernd Schubert].
    
     (9) Inode generation number: Useful for FUSE and userspace NFS servers
         [Bernd Schubert].
    
         (This was asked for but later deemed unnecessary with the
         open-by-handle capability available and caused disagreement as to
         whether it's a security hole or not).
    
    (10) Extra coherency data may be useful in making backups [Andreas Dilger].
    
         (No particular data were offered, but things like last backup
         timestamp, the data version number and the DOS archive bit would come
         into this category).
    
    (11) Allow the filesystem to indicate what it can/cannot provide: A
         filesystem can now say it doesn't support a standard stat feature if
         that isn't available, so if, for instance, inode numbers or UIDs don't
         exist or are fabricated locally...
    
         (This requires a separate system call - I have an fsinfo() call idea
         for this).
    
    (12) Store a 16-byte volume ID in the superblock that can be returned in
         struct xstat [Steve French].
    
         (Deferred to fsinfo).
    
    (13) Include granularity fields in the time data to indicate the
         granularity of each of the times (NFSv4 time_delta) [Steve French].
    
         (Deferred to fsinfo).
    
    (14) FS_IOC_GETFLAGS value.  These could be translated to BSD's st_flags.
         Note that the Linux IOC flags are a mess and filesystems such as Ext4
         define flags that aren't in linux/fs.h, so translation in the kernel
         may be a necessity (or, possibly, we provide the filesystem type too).
    
         (Some attributes are made available in stx_attributes, but the general
         feeling was that the IOC flags were to ext[234]-specific and shouldn't
         be exposed through statx this way).
    
    (15) Mask of features available on file (eg: ACLs, seclabel) [Brad Boyer,
         Michael Kerrisk].
    
         (Deferred, probably to fsinfo.  Finding out if there's an ACL or
         seclabal might require extra filesystem operations).
    
    (16) Femtosecond-resolution timestamps [Dave Chinner].
    
         (A __reserved field has been left in the statx_timestamp struct for
         this - if there proves to be a need).
    
    (17) A set multiple attributes syscall to go with this.
    
    ===============
    NEW SYSTEM CALL
    ===============
    
    The new system call is:
    
            int ret = statx(int dfd,
                            const char *filename,
                            unsigned int flags,
                            unsigned int mask,
                            struct statx *buffer);
    
    The dfd, filename and flags parameters indicate the file to query, in a
    similar way to fstatat().  There is no equivalent of lstat() as that can be
    emulated with statx() by passing AT_SYMLINK_NOFOLLOW in flags.  There is
    also no equivalent of fstat() as that can be emulated by passing a NULL
    filename to statx() with the fd of interest in dfd.
    
    Whether or not statx() synchronises the attributes with the backing store
    can be controlled by OR'ing a value into the flags argument (this typically
    only affects network filesystems):
    
     (1) AT_STATX_SYNC_AS_STAT tells statx() to behave as stat() does in this
         respect.
    
     (2) AT_STATX_FORCE_SYNC will require a network filesystem to synchronise
         its attributes with the server - which might require data writeback to
         occur to get the timestamps correct.
    
     (3) AT_STATX_DONT_SYNC will suppress synchronisation with the server in a
         network filesystem.  The resulting values should be considered
         approximate.
    
    mask is a bitmask indicating the fields in struct statx that are of
    interest to the caller.  The user should set this to STATX_BASIC_STATS to
    get the basic set returned by stat().  It should be noted that asking for
    more information may entail extra I/O operations.
    
    buffer points to the destination for the data.  This must be 256 bytes in
    size.
    
    ======================
    MAIN ATTRIBUTES RECORD
    ======================
    
    The following structures are defined in which to return the main attribute
    set:
    
            struct statx_timestamp {
                    __s64   tv_sec;
                    __s32   tv_nsec;
                    __s32   __reserved;
            };
    
            struct statx {
                    __u32   stx_mask;
                    __u32   stx_blksize;
                    __u64   stx_attributes;
                    __u32   stx_nlink;
                    __u32   stx_uid;
                    __u32   stx_gid;
                    __u16   stx_mode;
                    __u16   __spare0[1];
                    __u64   stx_ino;
                    __u64   stx_size;
                    __u64   stx_blocks;
                    __u64   __spare1[1];
                    struct statx_timestamp  stx_atime;
                    struct statx_timestamp  stx_btime;
                    struct statx_timestamp  stx_ctime;
                    struct statx_timestamp  stx_mtime;
                    __u32   stx_rdev_major;
                    __u32   stx_rdev_minor;
                    __u32   stx_dev_major;
                    __u32   stx_dev_minor;
                    __u64   __spare2[14];
            };
    
    The defined bits in request_mask and stx_mask are:
    
            STATX_TYPE              Want/got stx_mode & S_IFMT
            STATX_MODE              Want/got stx_mode & ~S_IFMT
            STATX_NLINK             Want/got stx_nlink
            STATX_UID               Want/got stx_uid
            STATX_GID               Want/got stx_gid
            STATX_ATIME             Want/got stx_atime{,_ns}
            STATX_MTIME             Want/got stx_mtime{,_ns}
            STATX_CTIME             Want/got stx_ctime{,_ns}
            STATX_INO               Want/got stx_ino
            STATX_SIZE              Want/got stx_size
            STATX_BLOCKS            Want/got stx_blocks
            STATX_BASIC_STATS       [The stuff in the normal stat struct]
            STATX_BTIME             Want/got stx_btime{,_ns}
            STATX_ALL               [All currently available stuff]
    
    stx_btime is the file creation time, stx_mask is a bitmask indicating the
    data provided and __spares*[] are where as-yet undefined fields can be
    placed.
    
    Time fields are structures with separate seconds and nanoseconds fields
    plus a reserved field in case we want to add even finer resolution.  Note
    that times will be negative if before 1970; in such a case, the nanosecond
    fields will also be negative if not zero.
    
    The bits defined in the stx_attributes field convey information about a
    file, how it is accessed, where it is and what it does.  The following
    attributes map to FS_*_FL flags and are the same numerical value:
    
            STATX_ATTR_COMPRESSED           File is compressed by the fs
            STATX_ATTR_IMMUTABLE            File is marked immutable
            STATX_ATTR_APPEND               File is append-only
            STATX_ATTR_NODUMP               File is not to be dumped
            STATX_ATTR_ENCRYPTED            File requires key to decrypt in fs
    
    Within the kernel, the supported flags are listed by:
    
            KSTAT_ATTR_FS_IOC_FLAGS
    
    [Are any other IOC flags of sufficient general interest to be exposed
    through this interface?]
    
    New flags include:
    
            STATX_ATTR_AUTOMOUNT            Object is an automount trigger
    
    These are for the use of GUI tools that might want to mark files specially,
    depending on what they are.
    
    Fields in struct statx come in a number of classes:
    
     (0) stx_dev_*, stx_blksize.
    
         These are local system information and are always available.
    
     (1) stx_mode, stx_nlinks, stx_uid, stx_gid, stx_[amc]time, stx_ino,
         stx_size, stx_blocks.
    
         These will be returned whether the caller asks for them or not.  The
         corresponding bits in stx_mask will be set to indicate whether they
         actually have valid values.
    
         If the caller didn't ask for them, then they may be approximated.  For
         example, NFS won't waste any time updating them from the server,
         unless as a byproduct of updating something requested.
    
         If the values don't actually exist for the underlying object (such as
         UID or GID on a DOS file), then the bit won't be set in the stx_mask,
         even if the caller asked for the value.  In such a case, the returned
         value will be a fabrication.
    
         Note that there are instances where the type might not be valid, for
         instance Windows reparse points.
    
     (2) stx_rdev_*.
    
         This will be set only if stx_mode indicates we're looking at a
         blockdev or a chardev, otherwise will be 0.
    
     (3) stx_btime.
    
         Similar to (1), except this will be set to 0 if it doesn't exist.
    
    =======
    TESTING
    =======
    
    The following test program can be used to test the statx system call:
    
            samples/statx/test-statx.c
    
    Just compile and run, passing it paths to the files you want to examine.
    The file is built automatically if CONFIG_SAMPLES is enabled.
    
    Here's some example output.  Firstly, an NFS directory that crosses to
    another FSID.  Note that the AUTOMOUNT attribute is set because transiting
    this directory will cause d_automount to be invoked by the VFS.
    
            [root@andromeda ~]# /tmp/test-statx -A /warthog/data
            statx(/warthog/data) = 0
            results=7ff
              Size: 4096            Blocks: 8          IO Block: 1048576  directory
            Device: 00:26           Inode: 1703937     Links: 125
            Access: (3777/drwxrwxrwx)  Uid:     0   Gid:  4041
            Access: 2016-11-24 09:02:12.219699527+0000
            Modify: 2016-11-17 10:44:36.225653653+0000
            Change: 2016-11-17 10:44:36.225653653+0000
            Attributes: 0000000000001000 (-------- -------- -------- -------- -------- -------- ---m---- --------)
    
    Secondly, the result of automounting on that directory.
    
            [root@andromeda ~]# /tmp/test-statx /warthog/data
            statx(/warthog/data) = 0
            results=7ff
              Size: 4096            Blocks: 8          IO Block: 1048576  directory
            Device: 00:27           Inode: 2           Links: 125
            Access: (3777/drwxrwxrwx)  Uid:     0   Gid:  4041
            Access: 2016-11-24 09:02:12.219699527+0000
            Modify: 2016-11-17 10:44:36.225653653+0000
            Change: 2016-11-17 10:44:36.225653653+0000
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 70355a9a2596..0c4f03c22ce0 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -439,9 +439,8 @@ struct inode *orangefs_new_inode(struct super_block *sb,
 
 int orangefs_setattr(struct dentry *dentry, struct iattr *iattr);
 
-int orangefs_getattr(struct vfsmount *mnt,
-		  struct dentry *dentry,
-		  struct kstat *kstat);
+int orangefs_getattr(const struct path *path, struct kstat *stat,
+		     u32 request_mask, unsigned int flags);
 
 int orangefs_permission(struct inode *inode, int mask);
 

commit 174cd4b1e5fbd0d74c68cf3a74f5bd4923485512
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 19:15:33 2017 +0100

    sched/headers: Prepare to move signal wakeup & sigpending methods from <linux/sched.h> into <linux/sched/signal.h>
    
    Fix up affected files that include this signal functionality via sched.h.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 70355a9a2596..8948683b367f 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -41,7 +41,7 @@
 #include <linux/uaccess.h>
 #include <linux/atomic.h>
 #include <linux/uio.h>
-#include <linux/sched.h>
+#include <linux/sched/signal.h>
 #include <linux/mm.h>
 #include <linux/wait.h>
 #include <linux/dcache.h>

commit 70823b9bf3290855a7df895d89bd8209182b52e3
Author: Jan Kara <jack@suse.cz>
Date:   Thu Feb 2 18:34:11 2017 +0100

    orangefs: Remove orangefs_backing_dev_info
    
    It is not used anywhere.
    
    CC: Mike Marshall <hubcap@omnibond.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 3bf803d732c5..70355a9a2596 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -529,7 +529,6 @@ extern spinlock_t orangefs_htable_ops_in_progress_lock;
 extern int hash_table_size;
 
 extern const struct address_space_operations orangefs_address_operations;
-extern struct backing_dev_info orangefs_backing_dev_info;
 extern const struct inode_operations orangefs_file_inode_operations;
 extern const struct file_operations orangefs_file_operations;
 extern const struct inode_operations orangefs_symlink_inode_operations;

commit 804b1737d71253f01621d2a37a0dce6279a2d440
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Oct 17 10:14:23 2016 +0200

    orangefs: don't use d_time
    
    Instead use d_fsdata which is the same size.  Hoping to get rid of d_time,
    which is used by very few filesystems by this time.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 0a82048f3aaf..3bf803d732c5 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -580,4 +580,11 @@ static inline void orangefs_i_size_write(struct inode *inode, loff_t i_size)
 #endif
 }
 
+static inline void orangefs_set_timeout(struct dentry *dentry)
+{
+	unsigned long time = jiffies + orangefs_dcache_timeout_msecs*HZ/1000;
+
+	dentry->d_fsdata = (void *) time;
+}
+
 #endif /* __ORANGEFSKERNEL_H */

commit b78b11985a36bfe768add17ffb70bbaf9d8d7627
Merge: f808e138c0ab 1d503617884e
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Wed Sep 28 14:50:46 2016 -0400

    Merge branch 'misc' into for-next
    
    Pull in an OrangeFS branch containing miscellaneous improvements.
    
    - clean up debugfs globals
    - remove dead code in sysfs
    - reorganize duplicated sysfs attribute structs
    - consolidate sysfs show and store functions
    - remove duplicated sysfs_ops structures
    - describe organization of sysfs
    - make devreq_mutex static
    - g_orangefs_stats -> orangefs_stats for consistency
    - rename most remaining global variables

commit 1d503617884ed43af1c03685e73ce23f155d3fa4
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Aug 16 11:38:14 2016 -0400

    orangefs: rename most remaining global variables
    
    Only op_timeout_secs, slot_timeout_secs, and hash_table_size are left
    because they are exposed as module parameters. All other global
    variables have the orangefs_ prefix.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 761a1d852979..5584dfadb81c 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -510,18 +510,18 @@ bool orangefs_cancel_op_in_progress(struct orangefs_kernel_op_s *op);
 
 int orangefs_normalize_to_errno(__s32 error_code);
 
-extern struct mutex request_mutex;
+extern struct mutex orangefs_request_mutex;
 extern int op_timeout_secs;
 extern int slot_timeout_secs;
-extern int dcache_timeout_msecs;
-extern int getattr_timeout_msecs;
+extern int orangefs_dcache_timeout_msecs;
+extern int orangefs_getattr_timeout_msecs;
 extern struct list_head orangefs_superblocks;
 extern spinlock_t orangefs_superblocks_lock;
 extern struct list_head orangefs_request_list;
 extern spinlock_t orangefs_request_list_lock;
 extern wait_queue_head_t orangefs_request_list_waitq;
-extern struct list_head *htable_ops_in_progress;
-extern spinlock_t htable_ops_in_progress_lock;
+extern struct list_head *orangefs_htable_ops_in_progress;
+extern spinlock_t orangefs_htable_ops_in_progress_lock;
 extern int hash_table_size;
 
 extern const struct address_space_operations orangefs_address_operations;

commit 889d5f1baca698a4510174cdd6a6596997d0deb4
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Aug 15 15:33:42 2016 -0400

    orangefs: g_orangefs_stats -> orangefs_stats for consistency
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index e1b50a11bc5f..761a1d852979 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -298,7 +298,7 @@ struct orangefs_stats {
 	unsigned long writes;
 };
 
-extern struct orangefs_stats g_orangefs_stats;
+extern struct orangefs_stats orangefs_stats;
 
 /*
  * NOTE: See Documentation/filesystems/porting for information
@@ -511,7 +511,6 @@ bool orangefs_cancel_op_in_progress(struct orangefs_kernel_op_s *op);
 int orangefs_normalize_to_errno(__s32 error_code);
 
 extern struct mutex request_mutex;
-extern int debug;
 extern int op_timeout_secs;
 extern int slot_timeout_secs;
 extern int dcache_timeout_msecs;

commit a0fe051592f1d31db491bb6cdcc87f512c5b6eaa
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Aug 15 15:21:16 2016 -0400

    orangefs: make devreq_mutex static
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 67d391c85465..e1b50a11bc5f 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -510,7 +510,6 @@ bool orangefs_cancel_op_in_progress(struct orangefs_kernel_op_s *op);
 
 int orangefs_normalize_to_errno(__s32 error_code);
 
-extern struct mutex devreq_mutex;
 extern struct mutex request_mutex;
 extern int debug;
 extern int op_timeout_secs;

commit 44f4641073f132429e1e9a53412600206e8f7d06
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Aug 15 11:38:36 2016 -0400

    orangefs: clean up debugfs globals
    
    Mostly this is moving code into orangefs-debugfs.c so that globals turn
    into static globals.
    
    Then gossip_debug_mask is renamed orangefs_gossip_debug_mask but keeps
    global visibility, so it can be used from a macro.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 633c07a6e3d8..67d391c85465 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -99,16 +99,6 @@ enum orangefs_vfs_op_states {
 	OP_VFS_STATE_GIVEN_UP = 16,
 };
 
-/*
- * An array of client_debug_mask will be built to hold debug keyword/mask
- * values fetched from userspace.
- */
-struct client_debug_mask {
-	char *keyword;
-	__u64 mask1;
-	__u64 mask2;
-};
-
 /*
  * orangefs kernel memory related flags
  */
@@ -119,29 +109,6 @@ struct client_debug_mask {
 #define ORANGEFS_CACHE_CREATE_FLAGS 0
 #endif /* ((defined ORANGEFS_KERNEL_DEBUG) && (defined CONFIG_DEBUG_SLAB)) */
 
-/* these functions are defined in orangefs-utils.c */
-int orangefs_prepare_cdm_array(char *debug_array_string);
-int orangefs_prepare_debugfs_help_string(int);
-
-/* defined in orangefs-debugfs.c */
-int orangefs_client_debug_init(void);
-
-void debug_string_to_mask(char *, void *, int);
-void do_c_mask(int, char *, struct client_debug_mask **);
-void do_k_mask(int, char *, __u64 **);
-
-void debug_mask_to_string(void *, int);
-void do_k_string(void *, int);
-void do_c_string(void *, int);
-int check_amalgam_keyword(void *, int);
-int keyword_is_amalgam(char *);
-
-/*these variables are defined in orangefs-mod.c */
-extern char kernel_debug_string[ORANGEFS_MAX_DEBUG_STRING_LEN];
-extern char client_debug_string[ORANGEFS_MAX_DEBUG_STRING_LEN];
-extern char client_debug_array_string[ORANGEFS_MAX_DEBUG_STRING_LEN];
-extern unsigned int kernel_mask_set_mod_init;
-
 extern int orangefs_init_acl(struct inode *inode, struct inode *dir);
 extern const struct xattr_handler *orangefs_xattr_handlers[];
 

commit 482664ddba81b3a5404fd083bb9697dfffc0b6a4
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Aug 12 12:02:31 2016 -0400

    orangefs: add features op
    
    This is a new userspace operation, which will be done if the client-core
    version is greater than or equal to 2.9.6. This will provide a way to
    implement optional features and to determine which features are
    supported by the client-core. If the client-core version is older than
    2.9.6, no optional features are supported and the op will not be done.
    
    The intent is to allow protocol extensions without relying on the
    client-core's current behavior of ignoring what it doesn't understand.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index ff3566a8388f..6cf3f467fd89 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -447,6 +447,8 @@ void purge_waiting_ops(void);
 /*
  * defined in super.c
  */
+extern uint64_t orangefs_features;
+
 struct dentry *orangefs_mount(struct file_system_type *fst,
 			   int flags,
 			   const char *devname,
@@ -506,7 +508,7 @@ ssize_t orangefs_inode_read(struct inode *inode,
 /*
  * defined in devorangefs-req.c
  */
-extern uint32_t userspace_version;
+extern uint32_t orangefs_userspace_version;
 
 int orangefs_dev_init(void);
 void orangefs_dev_cleanup(void);

commit f2ee3b759593c184f1249e03d613a84b4b69db2b
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Aug 9 15:59:26 2016 -0400

    orangefs: record userspace version for feature compatbility
    
    The client reports its version to the kernel on startup. We already test
    that it is above the minimum version. Now we record it in a global
    variable so code elsewhere can consult it before making a request the
    client may not understand.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 633c07a6e3d8..ff3566a8388f 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -506,6 +506,8 @@ ssize_t orangefs_inode_read(struct inode *inode,
 /*
  * defined in devorangefs-req.c
  */
+extern uint32_t userspace_version;
+
 int orangefs_dev_init(void);
 void orangefs_dev_cleanup(void);
 int is_daemon_in_service(void);

commit 4cd8f319441a323280eaa0acf390ffb18c64d86b
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Jul 25 13:58:24 2016 -0400

    orangefs: Allow dcache and getattr cache time to be configured.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 9338fe64820d..633c07a6e3d8 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -548,6 +548,8 @@ extern struct mutex request_mutex;
 extern int debug;
 extern int op_timeout_secs;
 extern int slot_timeout_secs;
+extern int dcache_timeout_msecs;
+extern int getattr_timeout_msecs;
 extern struct list_head orangefs_superblocks;
 extern spinlock_t orangefs_superblocks_lock;
 extern struct list_head orangefs_request_list;

commit 71680c18c8f22deafbaaf76d1c2d0eed2899a3d2
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Jun 9 16:32:38 2016 -0400

    orangefs: Cache getattr results.
    
    The userspace component attempts to do this, but this will prevent
    us from even needing to go into userspace to satisfy certain getattr
    requests.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 4b6e132d5a0f..9338fe64820d 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -246,6 +246,8 @@ struct orangefs_inode_s {
 	 * with this object
 	 */
 	unsigned long pinode_flags;
+
+	unsigned long getattr_time;
 };
 
 #define P_ATIME_FLAG 0
@@ -527,7 +529,7 @@ int orangefs_inode_setxattr(struct inode *inode,
 			 size_t size,
 			 int flags);
 
-int orangefs_inode_getattr(struct inode *inode, int new, int size);
+int orangefs_inode_getattr(struct inode *inode, int new, int bypass);
 
 int orangefs_inode_check_changed(struct inode *inode);
 

commit 6784725ab0b9473ce44bfad91a256bd72b5cddc1
Merge: 554828ee0db4 47be61845c77
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 28 12:59:05 2016 -0700

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
     "Assorted cleanups and fixes.
    
      Probably the most interesting part long-term is ->d_init() - that will
      have a bunch of followups in (at least) ceph and lustre, but we'll
      need to sort the barrier-related rules before it can get used for
      really non-trivial stuff.
    
      Another fun thing is the merge of ->d_iput() callers (dentry_iput()
      and dentry_unlink_inode()) and a bunch of ->d_compare() ones (all
      except the one in __d_lookup_lru())"
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (26 commits)
      fs/dcache.c: avoid soft-lockup in dput()
      vfs: new d_init method
      vfs: Update lookup_dcache() comment
      bdev: get rid of ->bd_inodes
      Remove last traces of ->sync_page
      new helper: d_same_name()
      dentry_cmp(): use lockless_dereference() instead of smp_read_barrier_depends()
      vfs: clean up documentation
      vfs: document ->d_real()
      vfs: merge .d_select_inode() into .d_real()
      unify dentry_iput() and dentry_unlink_inode()
      binfmt_misc: ->s_root is not going anywhere
      drop redundant ->owner initializations
      ufs: get rid of redundant checks
      orangefs: constify inode_operations
      missed comment updates from ->direct_IO() prototype change
      file_inode(f)->i_mapping is f->f_mapping
      trim fsnotify hooks a bit
      9p: new helper - v9fs_parent_fid()
      debugfs: ->d_parent is never NULL or negative
      ...

commit 78fee0b6846f27872321338db6afe280f059ae99
Author: Jann Horn <jannh@google.com>
Date:   Sat Jun 25 01:51:52 2016 +0200

    orangefs: fix namespace handling
    
    In orangefs_inode_getxattr(), an fsuid is written to dmesg. The kuid is
    converted to a userspace uid via from_kuid(current_user_ns(), [...]), but
    since dmesg is global, init_user_ns should be used here instead.
    
    In copy_attributes_from_inode(), op_alloc() and fill_default_sys_attrs(),
    upcall structures are populated with uids/gids that have been mapped into
    the caller's namespace. However, those upcall structures are read by
    another process (the userspace filesystem driver), and that process might
    be running in another namespace. This effectively lets any user spoof its
    uid and gid as seen by the userspace filesystem driver.
    
    To fix the second issue, I just construct the opcall structures with
    init_user_ns uids/gids and require the filesystem server to run in the
    init namespace. Since orangefs is full of global state anyway (as the error
    message in DUMP_DEVICE_ERROR explains, there can only be one userspace
    orangefs filesystem driver at once), that shouldn't be a problem.
    
    [
    Why does orangefs even exist in the kernel if everything does upcalls into
    userspace? What does orangefs do that couldn't be done with the FUSE
    interface? If there is no good answer to those questions, I'd prefer to see
    orangefs kicked out of the kernel. Can that be done for something that
    shipped in a release?
    
    According to commit f7ab093f74bf ("Orangefs: kernel client part 1"), they
    even already have a FUSE daemon, and the only rational reason (apart from
    "but most of our users report preferring to use our kernel module instead")
    given for not wanting to use FUSE is one "in-the-works" feature that could
    probably be integated into FUSE instead.
    ]
    
    This patch has been compile-tested.
    
    Signed-off-by: Jann Horn <jannh@google.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 7b542f168d44..c1181e5529af 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -587,8 +587,8 @@ int service_operation(struct orangefs_kernel_op_s *op,
 
 #define fill_default_sys_attrs(sys_attr, type, mode)			\
 do {									\
-	sys_attr.owner = from_kuid(current_user_ns(), current_fsuid()); \
-	sys_attr.group = from_kgid(current_user_ns(), current_fsgid()); \
+	sys_attr.owner = from_kuid(&init_user_ns, current_fsuid()); \
+	sys_attr.group = from_kgid(&init_user_ns, current_fsgid()); \
 	sys_attr.perms = ORANGEFS_util_translate_mode(mode);		\
 	sys_attr.mtime = 0;						\
 	sys_attr.atime = 0;						\

commit d373a712c1142a4e119e359df63c192afa9bb2fb
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Sat Jun 4 11:02:33 2016 +0200

    orangefs: Remove useless xattr prefix arguments
    
    Mike,
    
    On Fri, Jun 3, 2016 at 9:44 PM, Mike Marshall <hubcap@omnibond.com> wrote:
    > We use the return value in this one line you changed, our userspace code gets
    > ill when we send it (-ENOMEM +1) as a key length...
    
    ah, my mistake.  Here's a fixed version.
    
    Thanks,
    Andreas
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 6503e376047e..7b542f168d44 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -517,13 +517,11 @@ __s32 fsid_of_op(struct orangefs_kernel_op_s *op);
 int orangefs_flush_inode(struct inode *inode);
 
 ssize_t orangefs_inode_getxattr(struct inode *inode,
-			     const char *prefix,
 			     const char *name,
 			     void *buffer,
 			     size_t size);
 
 int orangefs_inode_setxattr(struct inode *inode,
-			 const char *prefix,
 			 const char *name,
 			 const void *value,
 			 size_t size,

commit 972a7344fcb54e0aabe78cfac5abb531fc6299ab
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Mon May 30 11:25:59 2016 +0200

    orangefs: Remove useless defines
    
    The ORANGEFS_XATTR_INDEX_ defines are unused; the ORANGEFS_XATTR_NAME_
    defines only obfuscate the code.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 2281882f718e..6503e376047e 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -119,17 +119,6 @@ struct client_debug_mask {
 #define ORANGEFS_CACHE_CREATE_FLAGS 0
 #endif /* ((defined ORANGEFS_KERNEL_DEBUG) && (defined CONFIG_DEBUG_SLAB)) */
 
-/* orangefs xattr and acl related defines */
-#define ORANGEFS_XATTR_INDEX_POSIX_ACL_ACCESS  1
-#define ORANGEFS_XATTR_INDEX_POSIX_ACL_DEFAULT 2
-#define ORANGEFS_XATTR_INDEX_TRUSTED           3
-#define ORANGEFS_XATTR_INDEX_DEFAULT           4
-
-#define ORANGEFS_XATTR_NAME_ACL_ACCESS XATTR_NAME_POSIX_ACL_ACCESS
-#define ORANGEFS_XATTR_NAME_ACL_DEFAULT XATTR_NAME_POSIX_ACL_DEFAULT
-#define ORANGEFS_XATTR_NAME_TRUSTED_PREFIX "trusted."
-#define ORANGEFS_XATTR_NAME_DEFAULT_PREFIX ""
-
 /* these functions are defined in orangefs-utils.c */
 int orangefs_prepare_cdm_array(char *debug_array_string);
 int orangefs_prepare_debugfs_help_string(int);

commit 6f3fc1070be028170b0f4c0c326480c9fcd1da3e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat May 14 18:46:32 2016 -0400

    orangefs: constify inode_operations
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 2281882f718e..db78ddde0236 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -570,10 +570,10 @@ extern int hash_table_size;
 
 extern const struct address_space_operations orangefs_address_operations;
 extern struct backing_dev_info orangefs_backing_dev_info;
-extern struct inode_operations orangefs_file_inode_operations;
+extern const struct inode_operations orangefs_file_inode_operations;
 extern const struct file_operations orangefs_file_operations;
-extern struct inode_operations orangefs_symlink_inode_operations;
-extern struct inode_operations orangefs_dir_inode_operations;
+extern const struct inode_operations orangefs_symlink_inode_operations;
+extern const struct inode_operations orangefs_dir_inode_operations;
 extern const struct file_operations orangefs_dir_operations;
 extern const struct dentry_operations orangefs_dentry_operations;
 extern const struct file_operations orangefs_devreq_file_operations;

commit 5ecfcb265f1e77d5de0140d21de3f8ab25441df7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Apr 12 00:43:20 2016 -0400

    orangefs: don't open-code inode_lock/inode_unlock
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index a9925e296ceb..2281882f718e 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -612,11 +612,11 @@ do {									\
 static inline void orangefs_i_size_write(struct inode *inode, loff_t i_size)
 {
 #if BITS_PER_LONG == 32 && defined(CONFIG_SMP)
-	mutex_lock(&inode->i_mutex);
+	inode_lock(inode);
 #endif
 	i_size_write(inode, i_size);
 #if BITS_PER_LONG == 32 && defined(CONFIG_SMP)
-	mutex_unlock(&inode->i_mutex);
+	inode_unlock(inode);
 #endif
 }
 

commit 45996492e5c85aa0ac93a95d1b2d1ed56851c865
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 25 19:56:34 2016 -0400

    orangefs: fix orangefs_superblock locking
    
    * switch orangefs_remount() to taking ORANGEFS_SB(sb) instead of sb
    * remove from the list _before_ orangefs_unmount() - request_mutex
    in the latter will make sure that nothing observed in the loop in
    ORANGEFS_DEV_REMOUNT_ALL handling will get freed until the end
    of loop
    * on removal, keep the forward pointer and zero the back one.  That
    way we can drop and regain the spinlock in the loop body (again,
    ORANGEFS_DEV_REMOUNT_ALL one) and still be able to get to the
    rest of the list.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index db258d2ccc6a..a9925e296ceb 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -462,7 +462,7 @@ struct dentry *orangefs_mount(struct file_system_type *fst,
 			   void *data);
 
 void orangefs_kill_sb(struct super_block *sb);
-int orangefs_remount(struct super_block *sb);
+int orangefs_remount(struct orangefs_sb_info_s *);
 
 int fsid_key_table_initialize(void);
 void fsid_key_table_finalize(void);
@@ -598,38 +598,6 @@ int service_operation(struct orangefs_kernel_op_s *op,
 	((ORANGEFS_SB(inode->i_sb)->flags & ORANGEFS_OPT_INTR) ? \
 		ORANGEFS_OP_INTERRUPTIBLE : 0)
 
-#define add_orangefs_sb(sb)						\
-do {									\
-	gossip_debug(GOSSIP_SUPER_DEBUG,				\
-		     "Adding SB %p to orangefs superblocks\n",		\
-		     ORANGEFS_SB(sb));					\
-	spin_lock(&orangefs_superblocks_lock);				\
-	list_add_tail(&ORANGEFS_SB(sb)->list, &orangefs_superblocks);		\
-	spin_unlock(&orangefs_superblocks_lock); \
-} while (0)
-
-#define remove_orangefs_sb(sb)						\
-do {									\
-	struct list_head *tmp = NULL;					\
-	struct list_head *tmp_safe = NULL;				\
-	struct orangefs_sb_info_s *orangefs_sb = NULL;			\
-									\
-	spin_lock(&orangefs_superblocks_lock);				\
-	list_for_each_safe(tmp, tmp_safe, &orangefs_superblocks) {		\
-		orangefs_sb = list_entry(tmp,				\
-				      struct orangefs_sb_info_s,		\
-				      list);				\
-		if (orangefs_sb && (orangefs_sb->sb == sb)) {			\
-			gossip_debug(GOSSIP_SUPER_DEBUG,		\
-			    "Removing SB %p from orangefs superblocks\n",	\
-			orangefs_sb);					\
-			list_del(&orangefs_sb->list);			\
-			break;						\
-		}							\
-	}								\
-	spin_unlock(&orangefs_superblocks_lock);				\
-} while (0)
-
 #define fill_default_sys_attrs(sys_attr, type, mode)			\
 do {									\
 	sys_attr.owner = from_kuid(current_user_ns(), current_fsuid()); \

commit 177f8fc491e230c2e7a3ac7d5626dd6f3d94e9f2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Feb 16 20:25:19 2016 -0500

    orangefs: sanitize ->llseek()
    
    a) open files can't have NULL inodes
    b) it's SEEK_END, not ORANGEFS_SEEK_END; no need to get cute.
    c) make_bad_inode() on lseek()?
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 5832168106de..db258d2ccc6a 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -70,7 +70,6 @@
 #define ORANGEFS_DEVREQ_MAGIC             0x20030529
 #define ORANGEFS_LINK_MAX                 0x000000FF
 #define ORANGEFS_PURGE_RETRY_COUNT     0x00000005
-#define ORANGEFS_SEEK_END              0x00000002
 #define ORANGEFS_MAX_NUM_OPTIONS          0x00000004
 #define ORANGEFS_MAX_MOUNT_OPT_LEN        0x00000080
 #define ORANGEFS_MAX_FSKEY_LEN            64

commit 05d31c5cb34cbdf05f9326b276be03756abb4b70
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Mar 18 13:36:45 2016 -0400

    orangefs: remove needless wrapper around GFP_KERNEL
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index d85776b15176..5832168106de 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -120,9 +120,6 @@ struct client_debug_mask {
 #define ORANGEFS_CACHE_CREATE_FLAGS 0
 #endif /* ((defined ORANGEFS_KERNEL_DEBUG) && (defined CONFIG_DEBUG_SLAB)) */
 
-#define ORANGEFS_GFP_FLAGS (GFP_KERNEL)
-#define ORANGEFS_BUFMAP_GFP_FLAGS (GFP_KERNEL)
-
 /* orangefs xattr and acl related defines */
 #define ORANGEFS_XATTR_INDEX_POSIX_ACL_ACCESS  1
 #define ORANGEFS_XATTR_INDEX_POSIX_ACL_DEFAULT 2

commit 93d53a488571fb8f8ceaba09352dcf4dfa1fc4e0
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Mar 17 16:33:08 2016 -0400

    orangefs: remove wrapper around mutex_lock(&inode->i_mutex)
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 5e85b199dee2..d85776b15176 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -645,18 +645,14 @@ do {									\
 	sys_attr.mask = ORANGEFS_ATTR_SYS_ALL_SETABLE;			\
 } while (0)
 
-#define orangefs_inode_lock(__i)  mutex_lock(&(__i)->i_mutex)
-
-#define orangefs_inode_unlock(__i) mutex_unlock(&(__i)->i_mutex)
-
 static inline void orangefs_i_size_write(struct inode *inode, loff_t i_size)
 {
 #if BITS_PER_LONG == 32 && defined(CONFIG_SMP)
-	orangefs_inode_lock(inode);
+	mutex_lock(&inode->i_mutex);
 #endif
 	i_size_write(inode, i_size);
 #if BITS_PER_LONG == 32 && defined(CONFIG_SMP)
-	orangefs_inode_unlock(inode);
+	mutex_unlock(&inode->i_mutex);
 #endif
 }
 

commit 5859d77e56e470ba16960befcd948c97a6f62102
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Mar 17 15:15:16 2016 -0400

    orangefs: use new getattr for revalidate and remove old getattr
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 276685cdf38d..5e85b199dee2 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -544,10 +544,10 @@ int orangefs_inode_setxattr(struct inode *inode,
 			 size_t size,
 			 int flags);
 
-int orangefs_inode_old_getattr(struct inode *inode, __u32 mask, int check);
-
 int orangefs_inode_getattr(struct inode *inode, int new, int size);
 
+int orangefs_inode_check_changed(struct inode *inode);
+
 int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr);
 
 void orangefs_make_bad_inode(struct inode *inode);

commit 3c9cf98d7b4f27e4303ea6e67db7f0c343a575b6
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Mar 15 11:28:20 2016 -0400

    orangefs: rename orangefs_inode_getattr to orangefs_inode_old_getattr
    
    This is motivated by orangefs_inode_old_getattr's habit of writing over
    live inodes.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 784629870717..276685cdf38d 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -544,7 +544,9 @@ int orangefs_inode_setxattr(struct inode *inode,
 			 size_t size,
 			 int flags);
 
-int orangefs_inode_getattr(struct inode *inode, __u32 mask, int check);
+int orangefs_inode_old_getattr(struct inode *inode, __u32 mask, int check);
+
+int orangefs_inode_getattr(struct inode *inode, int new, int size);
 
 int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr);
 

commit d57521a653e7ac2e8edaabfff202caf87c61f08a
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Mar 14 16:59:38 2016 -0400

    orangefs: remove inode->i_lock wrapper
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 045e493ab033..784629870717 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -632,9 +632,6 @@ do {									\
 	spin_unlock(&orangefs_superblocks_lock);				\
 } while (0)
 
-#define orangefs_lock_inode(inode) spin_lock(&inode->i_lock)
-#define orangefs_unlock_inode(inode) spin_unlock(&inode->i_lock)
-
 #define fill_default_sys_attrs(sys_attr, type, mode)			\
 do {									\
 	sys_attr.owner = from_kuid(current_user_ns(), current_fsuid()); \

commit acfcbaf1925f2dc5c46c61de69d756dec92a2ff8
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Sat Mar 5 13:17:39 2016 -0500

    orangefs: make fs_mount_pending static
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index c045c0b89507..045e493ab033 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -523,7 +523,6 @@ int orangefs_dev_init(void);
 void orangefs_dev_cleanup(void);
 int is_daemon_in_service(void);
 bool __is_daemon_in_service(void);
-int fs_mount_pending(__s32 fsid);
 
 /*
  * defined in orangefs-utils.c

commit 401898eed7e05b8a898a44b49d5e9a510aebee83
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Feb 26 13:54:09 2016 +0100

    orangefs: remove unused 'diff' function
    
    orangefs contains a helper function to calculate the difference
    between two timeval structures. We are trying to remove all
    instances of timespec from the kernel, and this one is not
    used at all, so let's remove it now.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index b6f52e3fee7f..c045c0b89507 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -662,15 +662,4 @@ static inline void orangefs_i_size_write(struct inode *inode, loff_t i_size)
 #endif
 }
 
-static inline unsigned int diff(struct timeval *end, struct timeval *begin)
-{
-	if (end->tv_usec < begin->tv_usec) {
-		end->tv_usec += 1000000;
-		end->tv_sec--;
-	}
-	end->tv_sec -= begin->tv_sec;
-	end->tv_usec -= begin->tv_usec;
-	return (end->tv_sec * 1000000) + end->tv_usec;
-}
-
 #endif /* __ORANGEFSKERNEL_H */

commit be81ce48b262e2164d64a1354c618571b0c9cd09
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Feb 26 13:54:10 2016 +0100

    orangefs: avoid time conversion function
    
    The new orangefs code uses a helper function to read a time field to
    its private structures from struct iattr. This will conflict with the
    move to 64-bit timestamps in the kernel and is generally not necessary.
    
    This replaces the conversion with a simple cast to time64_t that shows
    what is going on. As the orangefs-internal representation already uses
    64-bit timestamps, there should be no ambiguity to negative values,
    and the cast ensures that we treat them as times before 1970 on both
    32-bit and 64-bit architectures, rather than times after 2038. This
    patch keeps that behavior.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 785c9a4ef834..b6f52e3fee7f 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -555,11 +555,6 @@ int orangefs_unmount_sb(struct super_block *sb);
 
 bool orangefs_cancel_op_in_progress(struct orangefs_kernel_op_s *op);
 
-static inline __u64 orangefs_convert_time_field(const struct timespec *ts)
-{
-	return (__u64)ts->tv_sec;
-}
-
 int orangefs_normalize_to_errno(__s32 error_code);
 
 extern struct mutex devreq_mutex;

commit 69a23de2f3de046f1017489eb9e6de4e8165e4f0
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Sat Feb 20 15:28:58 2016 -0500

    orangefs: clean up fill_default_sys_attrs
    
    Size and type are read-only and not in the mask. The times were left
    unset despite being in the mask.
    
    We zero-fill the times since the server will fill them in and we will
    get the correct time when we fill the inode with getattr.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 91cbd53f782c..785c9a4ef834 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -645,9 +645,10 @@ do {									\
 do {									\
 	sys_attr.owner = from_kuid(current_user_ns(), current_fsuid()); \
 	sys_attr.group = from_kgid(current_user_ns(), current_fsgid()); \
-	sys_attr.size = 0;						\
 	sys_attr.perms = ORANGEFS_util_translate_mode(mode);		\
-	sys_attr.objtype = type;					\
+	sys_attr.mtime = 0;						\
+	sys_attr.atime = 0;						\
+	sys_attr.ctime = 0;						\
 	sys_attr.mask = ORANGEFS_ATTR_SYS_ALL_SETABLE;			\
 } while (0)
 

commit 9c2bcf288ed7f600bc3f8e7541ea0522a8912bae
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Sat Feb 20 14:26:01 2016 -0500

    orangefs: remove vestigial async io code
    
    I have verified that there is nothing in the userspace daemon version we
    are implementing this protocol against that ever looks at this field.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index c3b3b22115eb..91cbd53f782c 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -100,14 +100,6 @@ enum orangefs_vfs_op_states {
 	OP_VFS_STATE_GIVEN_UP = 16,
 };
 
-/*
- * Defines for controlling whether I/O upcalls are for async or sync operations
- */
-enum ORANGEFS_async_io_type {
-	ORANGEFS_VFS_SYNC_IO = 0,
-	ORANGEFS_VFS_ASYNC_IO = 1,
-};
-
 /*
  * An array of client_debug_mask will be built to hold debug keyword/mask
  * values fetched from userspace.

commit adcf34a2893386c99e80feee36e30a782b3815e7
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Feb 24 16:54:27 2016 -0500

    Orangefs: code sanitation
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 4ed64e555ca0..c3b3b22115eb 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -603,7 +603,7 @@ extern wait_queue_head_t orangefs_bufmap_init_waitq;
 #define ORANGEFS_OP_INTERRUPTIBLE 1   /* service_operation() is interruptible */
 #define ORANGEFS_OP_PRIORITY      2   /* service_operation() is high priority */
 #define ORANGEFS_OP_CANCELLATION  4   /* this is a cancellation */
-#define ORANGEFS_OP_NO_SEMAPHORE  8   /* don't acquire semaphore */
+#define ORANGEFS_OP_NO_MUTEX      8   /* don't acquire request_mutex */
 #define ORANGEFS_OP_ASYNC         16  /* Queue it, but don't wait */
 
 int service_operation(struct orangefs_kernel_op_s *op,

commit d37c0f307adb1d15712cb8d3cec23d81389c1937
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Feb 24 13:24:14 2016 -0500

    Orangefs: clean up orangefs_kernel_op_s comments.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 6290c24d8270..4ed64e555ca0 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -188,11 +188,12 @@ struct orangefs_kernel_op_s {
 	__u64 tag;
 
 	/*
-	 * Set uses_shared_memory to 1 if this operation uses shared memory.
-	 * If true, then a retry on the op must also get a new shared memory
-	 * buffer and re-populate it.  Cancels don't care - it only matters
-	 * for service_operation() retry logics and cancels don't go through
-	 * it anymore.
+	 * Set uses_shared_memory to non zero if this operation uses
+	 * shared memory. If true, then a retry on the op must also
+	 * get a new shared memory buffer and re-populate it.
+	 * Cancels don't care - it only matters for service_operation()
+	 * retry logics and cancels don't go through it anymore. It
+	 * safely stays non-zero when we use it as slot_to_free.
 	 */
 	union {
 		int uses_shared_memory;
@@ -205,8 +206,6 @@ struct orangefs_kernel_op_s {
 	struct completion waitq;
 	spinlock_t lock;
 
-	/* VFS aio fields */
-
 	int attempts;
 
 	struct list_head list;

commit c1223ca48baa867e9abc77fbb7f97500dc2a0cf8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Feb 18 19:17:51 2016 -0500

    orangefs: get rid of op refcounts
    
    not needed anymore
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 7d0c8b3afc7e..6290c24d8270 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -205,8 +205,6 @@ struct orangefs_kernel_op_s {
 	struct completion waitq;
 	spinlock_t lock;
 
-	atomic_t ref_count;
-
 	/* VFS aio fields */
 
 	int attempts;
@@ -230,23 +228,7 @@ static inline void set_op_state_serviced(struct orangefs_kernel_op_s *op)
 #define op_state_given_up(op)    ((op)->op_state & OP_VFS_STATE_GIVEN_UP)
 #define op_is_cancel(op)         ((op)->upcall.type == ORANGEFS_VFS_OP_CANCEL)
 
-static inline void get_op(struct orangefs_kernel_op_s *op)
-{
-	atomic_inc(&op->ref_count);
-	gossip_debug(GOSSIP_DEV_DEBUG,
-			"(get) Alloced OP (%p:%llu)\n",	op, llu(op->tag));
-}
-
-void __op_release(struct orangefs_kernel_op_s *op);
-
-static inline void op_release(struct orangefs_kernel_op_s *op)
-{
-	if (atomic_dec_and_test(&op->ref_count)) {
-		gossip_debug(GOSSIP_DEV_DEBUG,
-			"(put) Releasing OP (%p:%llu)\n", op, llu((op)->tag));
-		__op_release(op);
-	}
-}
+void op_release(struct orangefs_kernel_op_s *op);
 
 extern void orangefs_bufmap_put(int);
 static inline void put_cancel(struct orangefs_kernel_op_s *op)

commit 05a50a5be897004b6c1399645256bcf2e768b4ef
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Feb 18 18:59:44 2016 -0500

    orangefs: have ..._clean_interrupted_...() wait for copy to/from daemon
    
    * turn all those list_del(&op->list) into list_del_init()
    * don't pick ops that are already given up in control device
      ->read()/->write_iter().
    * have orangefs_clean_interrupted_operation() notice if op is currently
      being copied to/from daemon (by said ->read()/->write_iter()) and
      wait for that to finish.
    * when we are done copying to/from daemon and find that it had been
      given up while we were doing that, wake the waiting ..._clean_interrupted_...
    
    As the result, we are guaranteed that orangefs_clean_interrupted_operation(op)
    doesn't return until nobody else can see op.  Moreover, we don't need to play
    with op refcounts anymore.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 1d20eadaefd8..7d0c8b3afc7e 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -259,7 +259,7 @@ static inline void set_op_state_purged(struct orangefs_kernel_op_s *op)
 {
 	spin_lock(&op->lock);
 	if (unlikely(op_is_cancel(op))) {
-		list_del(&op->list);
+		list_del_init(&op->list);
 		spin_unlock(&op->lock);
 		put_cancel(op);
 	} else {

commit 897c5df6cf8c10d2557c098641faa62f65ef8598
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Feb 13 21:06:50 2016 -0500

    orangefs: get rid of op->done
    
    shouldn't be needed now
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 8613d4166d0f..1d20eadaefd8 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -205,8 +205,6 @@ struct orangefs_kernel_op_s {
 	struct completion waitq;
 	spinlock_t lock;
 
-	struct completion done;
-
 	atomic_t ref_count;
 
 	/* VFS aio fields */

commit c72f15b7d9b3cc744f066776dd0e61e6ab25e7d2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Feb 13 10:49:24 2016 -0500

    service_operation(): don't block signals, just use ..._killable
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index de898bda7859..8613d4166d0f 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -580,10 +580,6 @@ int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr);
 
 void orangefs_make_bad_inode(struct inode *inode);
 
-void orangefs_block_signals(sigset_t *);
-
-void orangefs_set_signals(sigset_t *);
-
 int orangefs_unmount_sb(struct super_block *sb);
 
 bool orangefs_cancel_op_in_progress(struct orangefs_kernel_op_s *op);

commit d2d87a3b6df3088a991e277d42cd6a549ff2bc66
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Feb 13 10:15:22 2016 -0500

    orangefs: get rid of loop in wait_for_matching_downcall()
    
    turn op->waitq into struct completion...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 3ceeeaed4143..de898bda7859 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -202,7 +202,7 @@ struct orangefs_kernel_op_s {
 	struct orangefs_upcall_s upcall;
 	struct orangefs_downcall_s downcall;
 
-	wait_queue_head_t waitq;
+	struct completion waitq;
 	spinlock_t lock;
 
 	struct completion done;
@@ -222,7 +222,7 @@ struct orangefs_kernel_op_s {
 static inline void set_op_state_serviced(struct orangefs_kernel_op_s *op)
 {
 	op->op_state = OP_VFS_STATE_SERVICED;
-	wake_up_interruptible(&op->waitq);
+	complete(&op->waitq);
 }
 
 #define op_state_waiting(op)     ((op)->op_state & OP_VFS_STATE_WAITING)
@@ -266,7 +266,7 @@ static inline void set_op_state_purged(struct orangefs_kernel_op_s *op)
 		put_cancel(op);
 	} else {
 		op->op_state |= OP_VFS_STATE_PURGED;
-		wake_up_interruptible(&op->waitq);
+		complete(&op->waitq);
 		spin_unlock(&op->lock);
 	}
 }

commit 78699e29fd784a4613d254a22627f336c55c4a76
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Feb 11 23:07:19 2016 -0500

    orangefs: delay freeing slot until cancel completes
    
    Make cancels reuse the aborted read/write op, to make sure they do not
    fail on lack of memory.
    
    Don't issue a cancel unless the daemon has seen our read/write, has not
    replied and isn't being shut down.
    
    If cancel *is* issued, don't wait for it to complete; stash the slot
    in there and just have it freed when cancel is finally replied to or
    purged (and delay dropping the reference until then, obviously).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index a8cde9019efe..3ceeeaed4143 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -190,9 +190,14 @@ struct orangefs_kernel_op_s {
 	/*
 	 * Set uses_shared_memory to 1 if this operation uses shared memory.
 	 * If true, then a retry on the op must also get a new shared memory
-	 * buffer and re-populate it.
+	 * buffer and re-populate it.  Cancels don't care - it only matters
+	 * for service_operation() retry logics and cancels don't go through
+	 * it anymore.
 	 */
-	int uses_shared_memory;
+	union {
+		int uses_shared_memory;
+		int slot_to_free;
+	};
 
 	struct orangefs_upcall_s upcall;
 	struct orangefs_downcall_s downcall;
@@ -219,17 +224,13 @@ static inline void set_op_state_serviced(struct orangefs_kernel_op_s *op)
 	op->op_state = OP_VFS_STATE_SERVICED;
 	wake_up_interruptible(&op->waitq);
 }
-static inline void set_op_state_purged(struct orangefs_kernel_op_s *op)
-{
-	op->op_state |= OP_VFS_STATE_PURGED;
-	wake_up_interruptible(&op->waitq);
-}
 
 #define op_state_waiting(op)     ((op)->op_state & OP_VFS_STATE_WAITING)
 #define op_state_in_progress(op) ((op)->op_state & OP_VFS_STATE_INPROGR)
 #define op_state_serviced(op)    ((op)->op_state & OP_VFS_STATE_SERVICED)
 #define op_state_purged(op)      ((op)->op_state & OP_VFS_STATE_PURGED)
 #define op_state_given_up(op)    ((op)->op_state & OP_VFS_STATE_GIVEN_UP)
+#define op_is_cancel(op)         ((op)->upcall.type == ORANGEFS_VFS_OP_CANCEL)
 
 static inline void get_op(struct orangefs_kernel_op_s *op)
 {
@@ -249,6 +250,27 @@ static inline void op_release(struct orangefs_kernel_op_s *op)
 	}
 }
 
+extern void orangefs_bufmap_put(int);
+static inline void put_cancel(struct orangefs_kernel_op_s *op)
+{
+	orangefs_bufmap_put(op->slot_to_free);
+	op_release(op);
+}
+
+static inline void set_op_state_purged(struct orangefs_kernel_op_s *op)
+{
+	spin_lock(&op->lock);
+	if (unlikely(op_is_cancel(op))) {
+		list_del(&op->list);
+		spin_unlock(&op->lock);
+		put_cancel(op);
+	} else {
+		op->op_state |= OP_VFS_STATE_PURGED;
+		wake_up_interruptible(&op->waitq);
+		spin_unlock(&op->lock);
+	}
+}
+
 /* per inode private orangefs info */
 struct orangefs_inode_s {
 	struct orangefs_object_kref refn;
@@ -448,6 +470,7 @@ static inline int match_handle(struct orangefs_khandle resp_handle,
 int op_cache_initialize(void);
 int op_cache_finalize(void);
 struct orangefs_kernel_op_s *op_alloc(__s32 type);
+void orangefs_new_tag(struct orangefs_kernel_op_s *op);
 char *get_opname_string(struct orangefs_kernel_op_s *new_op);
 
 int orangefs_inode_cache_initialize(void);
@@ -528,6 +551,7 @@ ssize_t orangefs_inode_read(struct inode *inode,
 int orangefs_dev_init(void);
 void orangefs_dev_cleanup(void);
 int is_daemon_in_service(void);
+bool __is_daemon_in_service(void);
 int fs_mount_pending(__s32 fsid);
 
 /*
@@ -562,7 +586,7 @@ void orangefs_set_signals(sigset_t *);
 
 int orangefs_unmount_sb(struct super_block *sb);
 
-int orangefs_cancel_op_in_progress(__u64 tag);
+bool orangefs_cancel_op_in_progress(struct orangefs_kernel_op_s *op);
 
 static inline __u64 orangefs_convert_time_field(const struct timespec *ts)
 {

commit 933287da750edefbf0f449750fd67b4fc6c10013
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Sat Jan 30 13:46:54 2016 -0500

    orangefs: Implement inode_operations->permission().
    
    Thus d_revalidate is not obliged to check on as much, which will
    eventually lead the way to hammering the filesystem servers much less.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index d4db96223dac..a8cde9019efe 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -493,6 +493,8 @@ int orangefs_getattr(struct vfsmount *mnt,
 		  struct dentry *dentry,
 		  struct kstat *kstat);
 
+int orangefs_permission(struct inode *inode, int mask);
+
 /*
  * defined in xattr.c
  */

commit 2d4cae0d175acae2ea2efbc17b52b71d4ffd886d
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Thu Feb 4 13:48:16 2016 -0500

    Orangefs: clean up slab allocation.
    
    A couple of caches were no longer needed:
    
     - iov_iter improvements to orangefs_devreq_write_iter eliminated
       the need for the dev_req_cache.
    
     - removal (months ago) of the old AIO code eliminated the need
       for the kiocb_cache.
    
    Also, deobfuscation of use of GFP_KERNEL when calling kmem_cache_(z)alloc
    for remaining caches.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 3e258554688d..d4db96223dac 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -128,7 +128,6 @@ struct client_debug_mask {
 #define ORANGEFS_CACHE_CREATE_FLAGS 0
 #endif /* ((defined ORANGEFS_KERNEL_DEBUG) && (defined CONFIG_DEBUG_SLAB)) */
 
-#define ORANGEFS_CACHE_ALLOC_FLAGS (GFP_KERNEL)
 #define ORANGEFS_GFP_FLAGS (GFP_KERNEL)
 #define ORANGEFS_BUFMAP_GFP_FLAGS (GFP_KERNEL)
 
@@ -207,9 +206,6 @@ struct orangefs_kernel_op_s {
 
 	/* VFS aio fields */
 
-	/* used by the async I/O code to stash the orangefs_kiocb_s structure */
-	void *priv;
-
 	int attempts;
 
 	struct list_head list;
@@ -217,6 +213,7 @@ struct orangefs_kernel_op_s {
 
 #define set_op_state_waiting(op)     ((op)->op_state = OP_VFS_STATE_WAITING)
 #define set_op_state_inprogress(op)  ((op)->op_state = OP_VFS_STATE_INPROGR)
+#define set_op_state_given_up(op)  ((op)->op_state = OP_VFS_STATE_GIVEN_UP)
 static inline void set_op_state_serviced(struct orangefs_kernel_op_s *op)
 {
 	op->op_state = OP_VFS_STATE_SERVICED;
@@ -453,19 +450,9 @@ int op_cache_finalize(void);
 struct orangefs_kernel_op_s *op_alloc(__s32 type);
 char *get_opname_string(struct orangefs_kernel_op_s *new_op);
 
-int dev_req_cache_initialize(void);
-int dev_req_cache_finalize(void);
-void *dev_req_alloc(void);
-void dev_req_release(void *);
-
 int orangefs_inode_cache_initialize(void);
 int orangefs_inode_cache_finalize(void);
 
-int kiocb_cache_initialize(void);
-int kiocb_cache_finalize(void);
-struct orangefs_kiocb_s *kiocb_alloc(void);
-void kiocb_release(struct orangefs_kiocb_s *ptr);
-
 /*
  * defined in orangefs-mod.c
  */

commit 99109822f5cbe6d530eb55193b25aa5348f6134d
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Jan 28 10:19:40 2016 -0500

    orangefs: Fix revalidate.
    
    Previously, it would update a live inode. This was fixed, but it did not
    ever check that the inode attributes in the dcache are correct. This
    checks all inode attributes and rejects any that are not correct, which
    causes a lookup and thus a new getattr.
    
    Perhaps inode_operations->permission should replace or augment some of
    this.
    
    There is no actual caching, and this does a rather excessive amount of
    network operations back to the filesystem server.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 9c876762f825..3e258554688d 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -561,7 +561,7 @@ int orangefs_inode_setxattr(struct inode *inode,
 			 size_t size,
 			 int flags);
 
-int orangefs_inode_getattr(struct inode *inode, __u32 mask);
+int orangefs_inode_getattr(struct inode *inode, __u32 mask, int check);
 
 int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr);
 

commit 115b93a8595c878759c7c1fdbd95fbbeacbe9168
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 23 14:04:31 2016 -0500

    orangefs: clean up op_alloc()
    
    fold orangefs_op_initialize() in there, don't bother locking something
    nobody else could've seen yet, use kmem_cache_zalloc() instead of
    explicit memset()...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index e11fc67d7773..9c876762f825 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -565,8 +565,6 @@ int orangefs_inode_getattr(struct inode *inode, __u32 mask);
 
 int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr);
 
-void orangefs_op_initialize(struct orangefs_kernel_op_s *op);
-
 void orangefs_make_bad_inode(struct inode *inode);
 
 void orangefs_block_signals(sigset_t *);

commit b0bc3a7b621cb8d7bcce507f323249a7340f4141
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 23 13:50:37 2016 -0500

    orangefs: move handle_io_error() to file.c
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 58e523c23637..e11fc67d7773 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -624,46 +624,6 @@ int service_operation(struct orangefs_kernel_op_s *op,
 		      const char *op_name,
 		      int flags);
 
-/*
- * handles two possible error cases, depending on context.
- *
- * by design, our vfs i/o errors need to be handled in one of two ways,
- * depending on where the error occured.
- *
- * if the error happens in the waitqueue code because we either timed
- * out or a signal was raised while waiting, we need to cancel the
- * userspace i/o operation and free the op manually.  this is done to
- * avoid having the device start writing application data to our shared
- * bufmap pages without us expecting it.
- *
- * FIXME: POSSIBLE OPTIMIZATION:
- * However, if we timed out or if we got a signal AND our upcall was never
- * picked off the queue (i.e. we were in OP_VFS_STATE_WAITING), then we don't
- * need to send a cancellation upcall. The way we can handle this is
- * set error_exit to 2 in such cases and 1 whenever cancellation has to be
- * sent and have handle_error
- * take care of this situation as well..
- *
- * if a orangefs sysint level error occured and i/o has been completed,
- * there is no need to cancel the operation, as the user has finished
- * using the bufmap page and so there is no danger in this case.  in
- * this case, we wake up the device normally so that it may free the
- * op, as normal.
- *
- * note the only reason this is a macro is because both read and write
- * cases need the exact same handling code.
- */
-#define handle_io_error()					\
-do {								\
-	if (!op_state_serviced(new_op)) {			\
-		orangefs_cancel_op_in_progress(new_op->tag);	\
-	} else {						\
-		wake_up_daemon_for_return(new_op);		\
-	}							\
-	orangefs_bufmap_put(bufmap, buffer_index);				\
-	buffer_index = -1;					\
-} while (0)
-
 #define get_interruptible_flag(inode) \
 	((ORANGEFS_SB(inode->i_sb)->flags & ORANGEFS_OPT_INTR) ? \
 		ORANGEFS_OP_INTERRUPTIBLE : 0)

commit 2a9e5c22605f5db6040535b10dce5fbc3a7db3bd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 23 13:45:46 2016 -0500

    orangefs: don't reinvent completion.h...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 2b72806d0f68..58e523c23637 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -201,8 +201,7 @@ struct orangefs_kernel_op_s {
 	wait_queue_head_t waitq;
 	spinlock_t lock;
 
-	int io_completed;
-	wait_queue_head_t io_completion_waitq;
+	struct completion done;
 
 	atomic_t ref_count;
 

commit 727cbfea623b78d46ce8e0f8c931b5189f3fe2e0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 23 13:17:55 2016 -0500

    orangefs: get rid of MSECS_TO_JIFFIES
    
    All timeouts are in _seconds_, so all calls are of form
    MSECS_TO_JIFFIES(n * 1000), which is a convoluted way to
    spell n * HZ.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index f96ec3da6b00..2b72806d0f68 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -80,11 +80,6 @@ sizeof(__u64) + sizeof(struct orangefs_upcall_s))
 #define MAX_DEV_REQ_DOWNSIZE (2 * sizeof(__s32) + \
 sizeof(__u64) + sizeof(struct orangefs_downcall_s))
 
-/* borrowed from irda.h */
-#ifndef MSECS_TO_JIFFIES
-#define MSECS_TO_JIFFIES(ms) (((ms)*HZ+999)/1000)
-#endif
-
 /*
  * valid orangefs kernel operation states
  *

commit ed42fe059389daa35a2aa10ec832e9f8d0a9e59e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jan 22 19:47:47 2016 -0500

    orangefs: hopefully saner op refcounting and locking
    
    * create with refcount 1
    * make op_release() decrement and free if zero (i.e. old put_op()
      has become that).
    * mark when submitter has given up waiting; from that point nobody
      else can move between the lists, change state, etc.
    * have daemon read/write_iter grab a reference when picking op
      and *always* give it up in the end
    * don't put into hash until we know it's been successfully passed to
      daemon
    
    * move op->lock _lower_ than htab_in_progress_lock (and make sure
      to take it in purge_inprogress_ops())
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 4219b2f9a5ae..f96ec3da6b00 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -94,6 +94,7 @@ sizeof(__u64) + sizeof(struct orangefs_downcall_s))
  * serviced - op has matching downcall; ok
  * purged   - op has to start a timer since client-core
  *            exited uncleanly before servicing op
+ * given up - submitter has given up waiting for it
  */
 enum orangefs_vfs_op_states {
 	OP_VFS_STATE_UNKNOWN = 0,
@@ -101,30 +102,9 @@ enum orangefs_vfs_op_states {
 	OP_VFS_STATE_INPROGR = 2,
 	OP_VFS_STATE_SERVICED = 4,
 	OP_VFS_STATE_PURGED = 8,
+	OP_VFS_STATE_GIVEN_UP = 16,
 };
 
-#define get_op(op)					\
-	do {						\
-		atomic_inc(&(op)->ref_count);	\
-		gossip_debug(GOSSIP_DEV_DEBUG,	\
-			"(get) Alloced OP (%p:%llu)\n",	\
-			op,				\
-			llu((op)->tag));		\
-	} while (0)
-
-#define put_op(op)							\
-	do {								\
-		if (atomic_sub_and_test(1, &(op)->ref_count) == 1) {  \
-			gossip_debug(GOSSIP_DEV_DEBUG,		\
-				"(put) Releasing OP (%p:%llu)\n",	\
-				op,					\
-				llu((op)->tag));			\
-			op_release(op);					\
-			}						\
-	} while (0)
-
-#define op_wait(op) (atomic_read(&(op)->ref_count) <= 2 ? 0 : 1)
-
 /*
  * Defines for controlling whether I/O upcalls are for async or sync operations
  */
@@ -258,6 +238,25 @@ static inline void set_op_state_purged(struct orangefs_kernel_op_s *op)
 #define op_state_in_progress(op) ((op)->op_state & OP_VFS_STATE_INPROGR)
 #define op_state_serviced(op)    ((op)->op_state & OP_VFS_STATE_SERVICED)
 #define op_state_purged(op)      ((op)->op_state & OP_VFS_STATE_PURGED)
+#define op_state_given_up(op)    ((op)->op_state & OP_VFS_STATE_GIVEN_UP)
+
+static inline void get_op(struct orangefs_kernel_op_s *op)
+{
+	atomic_inc(&op->ref_count);
+	gossip_debug(GOSSIP_DEV_DEBUG,
+			"(get) Alloced OP (%p:%llu)\n",	op, llu(op->tag));
+}
+
+void __op_release(struct orangefs_kernel_op_s *op);
+
+static inline void op_release(struct orangefs_kernel_op_s *op)
+{
+	if (atomic_dec_and_test(&op->ref_count)) {
+		gossip_debug(GOSSIP_DEV_DEBUG,
+			"(put) Releasing OP (%p:%llu)\n", op, llu((op)->tag));
+		__op_release(op);
+	}
+}
 
 /* per inode private orangefs info */
 struct orangefs_inode_s {
@@ -459,7 +458,6 @@ int op_cache_initialize(void);
 int op_cache_finalize(void);
 struct orangefs_kernel_op_s *op_alloc(__s32 type);
 char *get_opname_string(struct orangefs_kernel_op_s *new_op);
-void op_release(struct orangefs_kernel_op_s *op);
 
 int dev_req_cache_initialize(void);
 int dev_req_cache_finalize(void);
@@ -665,11 +663,9 @@ int service_operation(struct orangefs_kernel_op_s *op,
 do {								\
 	if (!op_state_serviced(new_op)) {			\
 		orangefs_cancel_op_in_progress(new_op->tag);	\
-		op_release(new_op);				\
 	} else {						\
 		wake_up_daemon_for_return(new_op);		\
 	}							\
-	new_op = NULL;						\
 	orangefs_bufmap_put(bufmap, buffer_index);				\
 	buffer_index = -1;					\
 } while (0)

commit 60831949cca782d54bd1f370fbadf17b772d6741
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jan 21 23:17:37 2016 -0500

    orangefs: move wakeups into set_op_state_{serviced,purged}()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 160c4c6a4d17..4219b2f9a5ae 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -103,24 +103,6 @@ enum orangefs_vfs_op_states {
 	OP_VFS_STATE_PURGED = 8,
 };
 
-#define set_op_state_waiting(op)     ((op)->op_state = OP_VFS_STATE_WAITING)
-#define set_op_state_inprogress(op)  ((op)->op_state = OP_VFS_STATE_INPROGR)
-static inline void set_op_state_serviced(struct orangefs_kernel_op_s *op)
-{
-	op->op_state = OP_VFS_STATE_SERVICED;
-	wake_up_interruptible(&op->waitq);
-}
-static inline void set_op_state_purged(struct orangefs_kernel_op_s *op)
-{
-	op->op_state |= OP_VFS_STATE_PURGED;
-	wake_up_interruptible(&op->waitq);
-}
-
-#define op_state_waiting(op)     ((op)->op_state & OP_VFS_STATE_WAITING)
-#define op_state_in_progress(op) ((op)->op_state & OP_VFS_STATE_INPROGR)
-#define op_state_serviced(op)    ((op)->op_state & OP_VFS_STATE_SERVICED)
-#define op_state_purged(op)      ((op)->op_state & OP_VFS_STATE_PURGED)
-
 #define get_op(op)					\
 	do {						\
 		atomic_inc(&(op)->ref_count);	\
@@ -259,6 +241,24 @@ struct orangefs_kernel_op_s {
 	struct list_head list;
 };
 
+#define set_op_state_waiting(op)     ((op)->op_state = OP_VFS_STATE_WAITING)
+#define set_op_state_inprogress(op)  ((op)->op_state = OP_VFS_STATE_INPROGR)
+static inline void set_op_state_serviced(struct orangefs_kernel_op_s *op)
+{
+	op->op_state = OP_VFS_STATE_SERVICED;
+	wake_up_interruptible(&op->waitq);
+}
+static inline void set_op_state_purged(struct orangefs_kernel_op_s *op)
+{
+	op->op_state |= OP_VFS_STATE_PURGED;
+	wake_up_interruptible(&op->waitq);
+}
+
+#define op_state_waiting(op)     ((op)->op_state & OP_VFS_STATE_WAITING)
+#define op_state_in_progress(op) ((op)->op_state & OP_VFS_STATE_INPROGR)
+#define op_state_serviced(op)    ((op)->op_state & OP_VFS_STATE_SERVICED)
+#define op_state_purged(op)      ((op)->op_state & OP_VFS_STATE_PURGED)
+
 /* per inode private orangefs info */
 struct orangefs_inode_s {
 	struct orangefs_object_kref refn;

commit 831d0949799be75ed84c1c6a4541ebcd74edba6c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jan 21 23:17:37 2016 -0500

    orangefs: move wakeups into set_op_state_{serviced,purged}()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 825545a7d167..160c4c6a4d17 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -105,8 +105,16 @@ enum orangefs_vfs_op_states {
 
 #define set_op_state_waiting(op)     ((op)->op_state = OP_VFS_STATE_WAITING)
 #define set_op_state_inprogress(op)  ((op)->op_state = OP_VFS_STATE_INPROGR)
-#define set_op_state_serviced(op)    ((op)->op_state = OP_VFS_STATE_SERVICED)
-#define set_op_state_purged(op)      ((op)->op_state |= OP_VFS_STATE_PURGED)
+static inline void set_op_state_serviced(struct orangefs_kernel_op_s *op)
+{
+	op->op_state = OP_VFS_STATE_SERVICED;
+	wake_up_interruptible(&op->waitq);
+}
+static inline void set_op_state_purged(struct orangefs_kernel_op_s *op)
+{
+	op->op_state |= OP_VFS_STATE_PURGED;
+	wake_up_interruptible(&op->waitq);
+}
 
 #define op_state_waiting(op)     ((op)->op_state & OP_VFS_STATE_WAITING)
 #define op_state_in_progress(op) ((op)->op_state & OP_VFS_STATE_INPROGR)

commit b7ae37b09e069a5d8d604caabd6675456a0d89fc
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jan 21 22:58:58 2016 -0500

    orangefs: make wait_for_...downcall() static
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index d78f3852bc4d..825545a7d167 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -474,8 +474,6 @@ void purge_inprogress_ops(void);
 /*
  * defined in waitqueue.c
  */
-int wait_for_matching_downcall(struct orangefs_kernel_op_s *op);
-int wait_for_cancellation_downcall(struct orangefs_kernel_op_s *op);
 void purge_waiting_ops(void);
 
 /*

commit e07db0a2c2e910d6619bfff962d73bd9c886c604
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jan 21 22:21:41 2016 -0500

    make orangefs_clean_up_interrupted_operation() static
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index ab2b9b061996..d78f3852bc4d 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -476,7 +476,6 @@ void purge_inprogress_ops(void);
  */
 int wait_for_matching_downcall(struct orangefs_kernel_op_s *op);
 int wait_for_cancellation_downcall(struct orangefs_kernel_op_s *op);
-void orangefs_clean_up_interrupted_operation(struct orangefs_kernel_op_s *op);
 void purge_waiting_ops(void);
 
 /*

commit 1264ddfdb7afda6f2c994ac30cad925fec346bae
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jan 21 21:55:47 2016 -0500

    orangefs: kill orangefs_inode_s ->list
    
    no users...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index d9b5b512bd83..ab2b9b061996 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -270,9 +270,6 @@ struct orangefs_inode_s {
 	 * with this object
 	 */
 	unsigned long pinode_flags;
-
-	/* All allocated orangefs_inode_s objects are chained to a list */
-	struct list_head list;
 };
 
 #define P_ATIME_FLAG 0

commit fc916da52dde736605137c7d528e2cdec7f81bca
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jan 19 12:26:13 2016 -0500

    orangefs: get rid of <censored> macros
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 6dcc38a5f117..d9b5b512bd83 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -619,47 +619,6 @@ extern wait_queue_head_t orangefs_bufmap_init_waitq;
 /*
  * misc convenience macros
  */
-#define add_op_to_request_list(op)				\
-do {								\
-	spin_lock(&orangefs_request_list_lock);			\
-	spin_lock(&op->lock);					\
-	set_op_state_waiting(op);				\
-	list_add_tail(&op->list, &orangefs_request_list);		\
-	spin_unlock(&orangefs_request_list_lock);			\
-	spin_unlock(&op->lock);					\
-	wake_up_interruptible(&orangefs_request_list_waitq);	\
-} while (0)
-
-#define add_priority_op_to_request_list(op)				\
-	do {								\
-		spin_lock(&orangefs_request_list_lock);			\
-		spin_lock(&op->lock);					\
-		set_op_state_waiting(op);				\
-									\
-		list_add(&op->list, &orangefs_request_list);		\
-		spin_unlock(&orangefs_request_list_lock);			\
-		spin_unlock(&op->lock);					\
-		wake_up_interruptible(&orangefs_request_list_waitq);	\
-} while (0)
-
-#define remove_op_from_request_list(op)					\
-	do {								\
-		struct list_head *tmp = NULL;				\
-		struct list_head *tmp_safe = NULL;			\
-		struct orangefs_kernel_op_s *tmp_op = NULL;		\
-									\
-		spin_lock(&orangefs_request_list_lock);			\
-		list_for_each_safe(tmp, tmp_safe, &orangefs_request_list) { \
-			tmp_op = list_entry(tmp,			\
-					    struct orangefs_kernel_op_s,	\
-					    list);			\
-			if (tmp_op && (tmp_op == op)) {			\
-				list_del(&tmp_op->list);		\
-				break;					\
-			}						\
-		}							\
-		spin_unlock(&orangefs_request_list_lock);			\
-	} while (0)
 
 #define ORANGEFS_OP_INTERRUPTIBLE 1   /* service_operation() is interruptible */
 #define ORANGEFS_OP_PRIORITY      2   /* service_operation() is high priority */

commit cf0c27715bd640628d39421f3d232c87d7e08954
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Tue Jan 19 12:04:40 2016 -0500

    Orangefs: make gossip statement more palatable to xtensa
    
    Thanks to Intel's kbuild test robot
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 1c87e0bbdfe8..6dcc38a5f117 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -75,9 +75,9 @@
 #define ORANGEFS_MAX_MOUNT_OPT_LEN        0x00000080
 #define ORANGEFS_MAX_FSKEY_LEN            64
 
-#define MAX_DEV_REQ_UPSIZE (2*sizeof(__s32) +   \
+#define MAX_DEV_REQ_UPSIZE (2 * sizeof(__s32) +   \
 sizeof(__u64) + sizeof(struct orangefs_upcall_s))
-#define MAX_DEV_REQ_DOWNSIZE (2*sizeof(__s32) + \
+#define MAX_DEV_REQ_DOWNSIZE (2 * sizeof(__s32) + \
 sizeof(__u64) + sizeof(struct orangefs_downcall_s))
 
 /* borrowed from irda.h */

commit c817e266e408538290af06b95f07f6ee2b7d507a
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Wed Jan 13 11:29:05 2016 -0500

    Orangefs: rename orangefs_kernel_op_s.aio_ref_count to just ref_count.
    
    The op structure's ref_count member hasn't got anything to do with
    asynchronous I/O.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 0c7a9cf9b8ef..1c87e0bbdfe8 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -115,7 +115,7 @@ enum orangefs_vfs_op_states {
 
 #define get_op(op)					\
 	do {						\
-		atomic_inc(&(op)->aio_ref_count);	\
+		atomic_inc(&(op)->ref_count);	\
 		gossip_debug(GOSSIP_DEV_DEBUG,	\
 			"(get) Alloced OP (%p:%llu)\n",	\
 			op,				\
@@ -124,7 +124,7 @@ enum orangefs_vfs_op_states {
 
 #define put_op(op)							\
 	do {								\
-		if (atomic_sub_and_test(1, &(op)->aio_ref_count) == 1) {  \
+		if (atomic_sub_and_test(1, &(op)->ref_count) == 1) {  \
 			gossip_debug(GOSSIP_DEV_DEBUG,		\
 				"(put) Releasing OP (%p:%llu)\n",	\
 				op,					\
@@ -133,7 +133,7 @@ enum orangefs_vfs_op_states {
 			}						\
 	} while (0)
 
-#define op_wait(op) (atomic_read(&(op)->aio_ref_count) <= 2 ? 0 : 1)
+#define op_wait(op) (atomic_read(&(op)->ref_count) <= 2 ? 0 : 1)
 
 /*
  * Defines for controlling whether I/O upcalls are for async or sync operations
@@ -239,14 +239,13 @@ struct orangefs_kernel_op_s {
 	int io_completed;
 	wait_queue_head_t io_completion_waitq;
 
+	atomic_t ref_count;
+
 	/* VFS aio fields */
 
 	/* used by the async I/O code to stash the orangefs_kiocb_s structure */
 	void *priv;
 
-	/* used again for the async I/O code for deallocation */
-	atomic_t aio_ref_count;
-
 	int attempts;
 
 	struct list_head list;

commit c146c0b87f7cef247744a649f8c1d794d18bfcb7
Author: Richard Weinberger <richard@nod.at>
Date:   Sat Jan 2 23:04:47 2016 +0100

    orangefs: Don't pollute global namespace
    
    Prefix public functions with "orangefs_" do don't
    pollute the global namespace.
    
    This fixes a build issue on UML which also has block_signals().
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index fe8284045a40..0c7a9cf9b8ef 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -576,9 +576,9 @@ void orangefs_op_initialize(struct orangefs_kernel_op_s *op);
 
 void orangefs_make_bad_inode(struct inode *inode);
 
-void block_signals(sigset_t *);
+void orangefs_block_signals(sigset_t *);
 
-void set_signals(sigset_t *);
+void orangefs_set_signals(sigset_t *);
 
 int orangefs_unmount_sb(struct super_block *sb);
 

commit eb57bcc2718a9fb5eaea80e0d76e53afac6ae2ec
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Dec 21 14:49:29 2015 +0100

    orangefs: fix typo in ornagefs_inode_lock
    
    Orangefs fails to build on 32-bit SMP configurations due to a simple
    misspelling, this does the obvious fix.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: 575e946125f7 ("Orangefs: change pvfs2 filenames to orangefs")
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 0b7ba0496aa3..fe8284045a40 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -770,7 +770,7 @@ do {									\
 static inline void orangefs_i_size_write(struct inode *inode, loff_t i_size)
 {
 #if BITS_PER_LONG == 32 && defined(CONFIG_SMP)
-	ornagefs_inode_lock(inode);
+	orangefs_inode_lock(inode);
 #endif
 	i_size_write(inode, i_size);
 #if BITS_PER_LONG == 32 && defined(CONFIG_SMP)

commit fef8b67ce6cab8e031285642b841acf5355d6788
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Thu Dec 17 14:31:24 2015 -0500

    Orangefs: don't use deprecated xattr defines.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index c337a52eb639..0b7ba0496aa3 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -173,17 +173,8 @@ struct client_debug_mask {
 #define ORANGEFS_XATTR_INDEX_TRUSTED           3
 #define ORANGEFS_XATTR_INDEX_DEFAULT           4
 
-#if 0
-#ifndef POSIX_ACL_XATTR_ACCESS
-#define POSIX_ACL_XATTR_ACCESS	"system.posix_acl_access"
-#endif
-#ifndef POSIX_ACL_XATTR_DEFAULT
-#define POSIX_ACL_XATTR_DEFAULT	"system.posix_acl_default"
-#endif
-#endif
-
-#define ORANGEFS_XATTR_NAME_ACL_ACCESS  POSIX_ACL_XATTR_ACCESS
-#define ORANGEFS_XATTR_NAME_ACL_DEFAULT POSIX_ACL_XATTR_DEFAULT
+#define ORANGEFS_XATTR_NAME_ACL_ACCESS XATTR_NAME_POSIX_ACL_ACCESS
+#define ORANGEFS_XATTR_NAME_ACL_DEFAULT XATTR_NAME_POSIX_ACL_DEFAULT
 #define ORANGEFS_XATTR_NAME_TRUSTED_PREFIX "trusted."
 #define ORANGEFS_XATTR_NAME_DEFAULT_PREFIX ""
 

commit a762ae6dc5a615f18b5f0fe54a0b8551e02e19d0
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Dec 15 14:22:06 2015 -0500

    orangefs: Remove ``aligned'' upcall and downcall length macros.
    
    There was previously MAX_ALIGNED_DEV_REQ_(UP|DOWN)SIZE macros which
    evaluated to MAX_DEV_REQ_(UP|DOWN)SIZE+8. As it is unclear what this is
    for, other than creating a situation where we accept more data than we
    can parse, it is removed.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
index 840872389fc5..c337a52eb639 100644
--- a/fs/orangefs/orangefs-kernel.h
+++ b/fs/orangefs/orangefs-kernel.h
@@ -80,29 +80,11 @@ sizeof(__u64) + sizeof(struct orangefs_upcall_s))
 #define MAX_DEV_REQ_DOWNSIZE (2*sizeof(__s32) + \
 sizeof(__u64) + sizeof(struct orangefs_downcall_s))
 
-#define BITS_PER_LONG_DIV_8 (BITS_PER_LONG >> 3)
-
 /* borrowed from irda.h */
 #ifndef MSECS_TO_JIFFIES
 #define MSECS_TO_JIFFIES(ms) (((ms)*HZ+999)/1000)
 #endif
 
-#define MAX_ALIGNED_DEV_REQ_UPSIZE				\
-		(MAX_DEV_REQ_UPSIZE +				\
-			((((MAX_DEV_REQ_UPSIZE /		\
-				(BITS_PER_LONG_DIV_8)) *	\
-				(BITS_PER_LONG_DIV_8)) +	\
-			    (BITS_PER_LONG_DIV_8)) -		\
-			MAX_DEV_REQ_UPSIZE))
-
-#define MAX_ALIGNED_DEV_REQ_DOWNSIZE				\
-		(MAX_DEV_REQ_DOWNSIZE +				\
-			((((MAX_DEV_REQ_DOWNSIZE /		\
-				(BITS_PER_LONG_DIV_8)) *	\
-				(BITS_PER_LONG_DIV_8)) +	\
-			    (BITS_PER_LONG_DIV_8)) -		\
-			MAX_DEV_REQ_DOWNSIZE))
-
 /*
  * valid orangefs kernel operation states
  *

commit 575e946125f70c41c2042f10172842c5cab9a09a
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Dec 4 12:56:14 2015 -0500

    Orangefs: change pvfs2 filenames to orangefs
    
    Also changed references within source files that referred to
    header files whose names had changed.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h
new file mode 100644
index 000000000000..840872389fc5
--- /dev/null
+++ b/fs/orangefs/orangefs-kernel.h
@@ -0,0 +1,819 @@
+/*
+ * (C) 2001 Clemson University and The University of Chicago
+ *
+ * See COPYING in top-level directory.
+ */
+
+/*
+ *  The ORANGEFS Linux kernel support allows ORANGEFS volumes to be mounted and
+ *  accessed through the Linux VFS (i.e. using standard I/O system calls).
+ *  This support is only needed on clients that wish to mount the file system.
+ *
+ */
+
+/*
+ *  Declarations and macros for the ORANGEFS Linux kernel support.
+ */
+
+#ifndef __ORANGEFSKERNEL_H
+#define __ORANGEFSKERNEL_H
+
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/statfs.h>
+#include <linux/backing-dev.h>
+#include <linux/device.h>
+#include <linux/mpage.h>
+#include <linux/namei.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+
+#include <linux/aio.h>
+#include <linux/posix_acl.h>
+#include <linux/posix_acl_xattr.h>
+#include <linux/compat.h>
+#include <linux/mount.h>
+#include <linux/uaccess.h>
+#include <linux/atomic.h>
+#include <linux/uio.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/wait.h>
+#include <linux/dcache.h>
+#include <linux/pagemap.h>
+#include <linux/poll.h>
+#include <linux/rwsem.h>
+#include <linux/xattr.h>
+#include <linux/exportfs.h>
+
+#include <asm/unaligned.h>
+
+#include "orangefs-dev-proto.h"
+
+#ifdef ORANGEFS_KERNEL_DEBUG
+#define ORANGEFS_DEFAULT_OP_TIMEOUT_SECS       10
+#else
+#define ORANGEFS_DEFAULT_OP_TIMEOUT_SECS       20
+#endif
+
+#define ORANGEFS_BUFMAP_WAIT_TIMEOUT_SECS   30
+
+#define ORANGEFS_DEFAULT_SLOT_TIMEOUT_SECS     900	/* 15 minutes */
+
+#define ORANGEFS_REQDEVICE_NAME          "pvfs2-req"
+
+#define ORANGEFS_DEVREQ_MAGIC             0x20030529
+#define ORANGEFS_LINK_MAX                 0x000000FF
+#define ORANGEFS_PURGE_RETRY_COUNT     0x00000005
+#define ORANGEFS_SEEK_END              0x00000002
+#define ORANGEFS_MAX_NUM_OPTIONS          0x00000004
+#define ORANGEFS_MAX_MOUNT_OPT_LEN        0x00000080
+#define ORANGEFS_MAX_FSKEY_LEN            64
+
+#define MAX_DEV_REQ_UPSIZE (2*sizeof(__s32) +   \
+sizeof(__u64) + sizeof(struct orangefs_upcall_s))
+#define MAX_DEV_REQ_DOWNSIZE (2*sizeof(__s32) + \
+sizeof(__u64) + sizeof(struct orangefs_downcall_s))
+
+#define BITS_PER_LONG_DIV_8 (BITS_PER_LONG >> 3)
+
+/* borrowed from irda.h */
+#ifndef MSECS_TO_JIFFIES
+#define MSECS_TO_JIFFIES(ms) (((ms)*HZ+999)/1000)
+#endif
+
+#define MAX_ALIGNED_DEV_REQ_UPSIZE				\
+		(MAX_DEV_REQ_UPSIZE +				\
+			((((MAX_DEV_REQ_UPSIZE /		\
+				(BITS_PER_LONG_DIV_8)) *	\
+				(BITS_PER_LONG_DIV_8)) +	\
+			    (BITS_PER_LONG_DIV_8)) -		\
+			MAX_DEV_REQ_UPSIZE))
+
+#define MAX_ALIGNED_DEV_REQ_DOWNSIZE				\
+		(MAX_DEV_REQ_DOWNSIZE +				\
+			((((MAX_DEV_REQ_DOWNSIZE /		\
+				(BITS_PER_LONG_DIV_8)) *	\
+				(BITS_PER_LONG_DIV_8)) +	\
+			    (BITS_PER_LONG_DIV_8)) -		\
+			MAX_DEV_REQ_DOWNSIZE))
+
+/*
+ * valid orangefs kernel operation states
+ *
+ * unknown  - op was just initialized
+ * waiting  - op is on request_list (upward bound)
+ * inprogr  - op is in progress (waiting for downcall)
+ * serviced - op has matching downcall; ok
+ * purged   - op has to start a timer since client-core
+ *            exited uncleanly before servicing op
+ */
+enum orangefs_vfs_op_states {
+	OP_VFS_STATE_UNKNOWN = 0,
+	OP_VFS_STATE_WAITING = 1,
+	OP_VFS_STATE_INPROGR = 2,
+	OP_VFS_STATE_SERVICED = 4,
+	OP_VFS_STATE_PURGED = 8,
+};
+
+#define set_op_state_waiting(op)     ((op)->op_state = OP_VFS_STATE_WAITING)
+#define set_op_state_inprogress(op)  ((op)->op_state = OP_VFS_STATE_INPROGR)
+#define set_op_state_serviced(op)    ((op)->op_state = OP_VFS_STATE_SERVICED)
+#define set_op_state_purged(op)      ((op)->op_state |= OP_VFS_STATE_PURGED)
+
+#define op_state_waiting(op)     ((op)->op_state & OP_VFS_STATE_WAITING)
+#define op_state_in_progress(op) ((op)->op_state & OP_VFS_STATE_INPROGR)
+#define op_state_serviced(op)    ((op)->op_state & OP_VFS_STATE_SERVICED)
+#define op_state_purged(op)      ((op)->op_state & OP_VFS_STATE_PURGED)
+
+#define get_op(op)					\
+	do {						\
+		atomic_inc(&(op)->aio_ref_count);	\
+		gossip_debug(GOSSIP_DEV_DEBUG,	\
+			"(get) Alloced OP (%p:%llu)\n",	\
+			op,				\
+			llu((op)->tag));		\
+	} while (0)
+
+#define put_op(op)							\
+	do {								\
+		if (atomic_sub_and_test(1, &(op)->aio_ref_count) == 1) {  \
+			gossip_debug(GOSSIP_DEV_DEBUG,		\
+				"(put) Releasing OP (%p:%llu)\n",	\
+				op,					\
+				llu((op)->tag));			\
+			op_release(op);					\
+			}						\
+	} while (0)
+
+#define op_wait(op) (atomic_read(&(op)->aio_ref_count) <= 2 ? 0 : 1)
+
+/*
+ * Defines for controlling whether I/O upcalls are for async or sync operations
+ */
+enum ORANGEFS_async_io_type {
+	ORANGEFS_VFS_SYNC_IO = 0,
+	ORANGEFS_VFS_ASYNC_IO = 1,
+};
+
+/*
+ * An array of client_debug_mask will be built to hold debug keyword/mask
+ * values fetched from userspace.
+ */
+struct client_debug_mask {
+	char *keyword;
+	__u64 mask1;
+	__u64 mask2;
+};
+
+/*
+ * orangefs kernel memory related flags
+ */
+
+#if ((defined ORANGEFS_KERNEL_DEBUG) && (defined CONFIG_DEBUG_SLAB))
+#define ORANGEFS_CACHE_CREATE_FLAGS SLAB_RED_ZONE
+#else
+#define ORANGEFS_CACHE_CREATE_FLAGS 0
+#endif /* ((defined ORANGEFS_KERNEL_DEBUG) && (defined CONFIG_DEBUG_SLAB)) */
+
+#define ORANGEFS_CACHE_ALLOC_FLAGS (GFP_KERNEL)
+#define ORANGEFS_GFP_FLAGS (GFP_KERNEL)
+#define ORANGEFS_BUFMAP_GFP_FLAGS (GFP_KERNEL)
+
+/* orangefs xattr and acl related defines */
+#define ORANGEFS_XATTR_INDEX_POSIX_ACL_ACCESS  1
+#define ORANGEFS_XATTR_INDEX_POSIX_ACL_DEFAULT 2
+#define ORANGEFS_XATTR_INDEX_TRUSTED           3
+#define ORANGEFS_XATTR_INDEX_DEFAULT           4
+
+#if 0
+#ifndef POSIX_ACL_XATTR_ACCESS
+#define POSIX_ACL_XATTR_ACCESS	"system.posix_acl_access"
+#endif
+#ifndef POSIX_ACL_XATTR_DEFAULT
+#define POSIX_ACL_XATTR_DEFAULT	"system.posix_acl_default"
+#endif
+#endif
+
+#define ORANGEFS_XATTR_NAME_ACL_ACCESS  POSIX_ACL_XATTR_ACCESS
+#define ORANGEFS_XATTR_NAME_ACL_DEFAULT POSIX_ACL_XATTR_DEFAULT
+#define ORANGEFS_XATTR_NAME_TRUSTED_PREFIX "trusted."
+#define ORANGEFS_XATTR_NAME_DEFAULT_PREFIX ""
+
+/* these functions are defined in orangefs-utils.c */
+int orangefs_prepare_cdm_array(char *debug_array_string);
+int orangefs_prepare_debugfs_help_string(int);
+
+/* defined in orangefs-debugfs.c */
+int orangefs_client_debug_init(void);
+
+void debug_string_to_mask(char *, void *, int);
+void do_c_mask(int, char *, struct client_debug_mask **);
+void do_k_mask(int, char *, __u64 **);
+
+void debug_mask_to_string(void *, int);
+void do_k_string(void *, int);
+void do_c_string(void *, int);
+int check_amalgam_keyword(void *, int);
+int keyword_is_amalgam(char *);
+
+/*these variables are defined in orangefs-mod.c */
+extern char kernel_debug_string[ORANGEFS_MAX_DEBUG_STRING_LEN];
+extern char client_debug_string[ORANGEFS_MAX_DEBUG_STRING_LEN];
+extern char client_debug_array_string[ORANGEFS_MAX_DEBUG_STRING_LEN];
+extern unsigned int kernel_mask_set_mod_init;
+
+extern int orangefs_init_acl(struct inode *inode, struct inode *dir);
+extern const struct xattr_handler *orangefs_xattr_handlers[];
+
+extern struct posix_acl *orangefs_get_acl(struct inode *inode, int type);
+extern int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type);
+
+/*
+ * Redefine xtvec structure so that we could move helper functions out of
+ * the define
+ */
+struct xtvec {
+	__kernel_off_t xtv_off;		/* must be off_t */
+	__kernel_size_t xtv_len;	/* must be size_t */
+};
+
+/*
+ * orangefs data structures
+ */
+struct orangefs_kernel_op_s {
+	enum orangefs_vfs_op_states op_state;
+	__u64 tag;
+
+	/*
+	 * Set uses_shared_memory to 1 if this operation uses shared memory.
+	 * If true, then a retry on the op must also get a new shared memory
+	 * buffer and re-populate it.
+	 */
+	int uses_shared_memory;
+
+	struct orangefs_upcall_s upcall;
+	struct orangefs_downcall_s downcall;
+
+	wait_queue_head_t waitq;
+	spinlock_t lock;
+
+	int io_completed;
+	wait_queue_head_t io_completion_waitq;
+
+	/* VFS aio fields */
+
+	/* used by the async I/O code to stash the orangefs_kiocb_s structure */
+	void *priv;
+
+	/* used again for the async I/O code for deallocation */
+	atomic_t aio_ref_count;
+
+	int attempts;
+
+	struct list_head list;
+};
+
+/* per inode private orangefs info */
+struct orangefs_inode_s {
+	struct orangefs_object_kref refn;
+	char link_target[ORANGEFS_NAME_MAX];
+	__s64 blksize;
+	/*
+	 * Reading/Writing Extended attributes need to acquire the appropriate
+	 * reader/writer semaphore on the orangefs_inode_s structure.
+	 */
+	struct rw_semaphore xattr_sem;
+
+	struct inode vfs_inode;
+	sector_t last_failed_block_index_read;
+
+	/*
+	 * State of in-memory attributes not yet flushed to disk associated
+	 * with this object
+	 */
+	unsigned long pinode_flags;
+
+	/* All allocated orangefs_inode_s objects are chained to a list */
+	struct list_head list;
+};
+
+#define P_ATIME_FLAG 0
+#define P_MTIME_FLAG 1
+#define P_CTIME_FLAG 2
+#define P_MODE_FLAG  3
+
+#define ClearAtimeFlag(pinode) clear_bit(P_ATIME_FLAG, &(pinode)->pinode_flags)
+#define SetAtimeFlag(pinode)   set_bit(P_ATIME_FLAG, &(pinode)->pinode_flags)
+#define AtimeFlag(pinode)      test_bit(P_ATIME_FLAG, &(pinode)->pinode_flags)
+
+#define ClearMtimeFlag(pinode) clear_bit(P_MTIME_FLAG, &(pinode)->pinode_flags)
+#define SetMtimeFlag(pinode)   set_bit(P_MTIME_FLAG, &(pinode)->pinode_flags)
+#define MtimeFlag(pinode)      test_bit(P_MTIME_FLAG, &(pinode)->pinode_flags)
+
+#define ClearCtimeFlag(pinode) clear_bit(P_CTIME_FLAG, &(pinode)->pinode_flags)
+#define SetCtimeFlag(pinode)   set_bit(P_CTIME_FLAG, &(pinode)->pinode_flags)
+#define CtimeFlag(pinode)      test_bit(P_CTIME_FLAG, &(pinode)->pinode_flags)
+
+#define ClearModeFlag(pinode) clear_bit(P_MODE_FLAG, &(pinode)->pinode_flags)
+#define SetModeFlag(pinode)   set_bit(P_MODE_FLAG, &(pinode)->pinode_flags)
+#define ModeFlag(pinode)      test_bit(P_MODE_FLAG, &(pinode)->pinode_flags)
+
+/* per superblock private orangefs info */
+struct orangefs_sb_info_s {
+	struct orangefs_khandle root_khandle;
+	__s32 fs_id;
+	int id;
+	int flags;
+#define ORANGEFS_OPT_INTR	0x01
+#define ORANGEFS_OPT_LOCAL_LOCK	0x02
+	char devname[ORANGEFS_MAX_SERVER_ADDR_LEN];
+	struct super_block *sb;
+	int mount_pending;
+	struct list_head list;
+};
+
+/*
+ * structure that holds the state of any async I/O operation issued
+ * through the VFS. Needed especially to handle cancellation requests
+ * or even completion notification so that the VFS client-side daemon
+ * can free up its vfs_request slots.
+ */
+struct orangefs_kiocb_s {
+	/* the pointer to the task that initiated the AIO */
+	struct task_struct *tsk;
+
+	/* pointer to the kiocb that kicked this operation */
+	struct kiocb *kiocb;
+
+	/* buffer index that was used for the I/O */
+	struct orangefs_bufmap *bufmap;
+	int buffer_index;
+
+	/* orangefs kernel operation type */
+	struct orangefs_kernel_op_s *op;
+
+	/* The user space buffers from/to which I/O is being staged */
+	struct iovec *iov;
+
+	/* number of elements in the iovector */
+	unsigned long nr_segs;
+
+	/* set to indicate the type of the operation */
+	int rw;
+
+	/* file offset */
+	loff_t offset;
+
+	/* and the count in bytes */
+	size_t bytes_to_be_copied;
+
+	ssize_t bytes_copied;
+	int needs_cleanup;
+};
+
+struct orangefs_stats {
+	unsigned long cache_hits;
+	unsigned long cache_misses;
+	unsigned long reads;
+	unsigned long writes;
+};
+
+extern struct orangefs_stats g_orangefs_stats;
+
+/*
+ * NOTE: See Documentation/filesystems/porting for information
+ * on implementing FOO_I and properly accessing fs private data
+ */
+static inline struct orangefs_inode_s *ORANGEFS_I(struct inode *inode)
+{
+	return container_of(inode, struct orangefs_inode_s, vfs_inode);
+}
+
+static inline struct orangefs_sb_info_s *ORANGEFS_SB(struct super_block *sb)
+{
+	return (struct orangefs_sb_info_s *) sb->s_fs_info;
+}
+
+/* ino_t descends from "unsigned long", 8 bytes, 64 bits. */
+static inline ino_t orangefs_khandle_to_ino(struct orangefs_khandle *khandle)
+{
+	union {
+		unsigned char u[8];
+		__u64 ino;
+	} ihandle;
+
+	ihandle.u[0] = khandle->u[0] ^ khandle->u[4];
+	ihandle.u[1] = khandle->u[1] ^ khandle->u[5];
+	ihandle.u[2] = khandle->u[2] ^ khandle->u[6];
+	ihandle.u[3] = khandle->u[3] ^ khandle->u[7];
+	ihandle.u[4] = khandle->u[12] ^ khandle->u[8];
+	ihandle.u[5] = khandle->u[13] ^ khandle->u[9];
+	ihandle.u[6] = khandle->u[14] ^ khandle->u[10];
+	ihandle.u[7] = khandle->u[15] ^ khandle->u[11];
+
+	return ihandle.ino;
+}
+
+static inline struct orangefs_khandle *get_khandle_from_ino(struct inode *inode)
+{
+	return &(ORANGEFS_I(inode)->refn.khandle);
+}
+
+static inline __s32 get_fsid_from_ino(struct inode *inode)
+{
+	return ORANGEFS_I(inode)->refn.fs_id;
+}
+
+static inline ino_t get_ino_from_khandle(struct inode *inode)
+{
+	struct orangefs_khandle *khandle;
+	ino_t ino;
+
+	khandle = get_khandle_from_ino(inode);
+	ino = orangefs_khandle_to_ino(khandle);
+	return ino;
+}
+
+static inline ino_t get_parent_ino_from_dentry(struct dentry *dentry)
+{
+	return get_ino_from_khandle(dentry->d_parent->d_inode);
+}
+
+static inline int is_root_handle(struct inode *inode)
+{
+	gossip_debug(GOSSIP_DCACHE_DEBUG,
+		     "%s: root handle: %pU, this handle: %pU:\n",
+		     __func__,
+		     &ORANGEFS_SB(inode->i_sb)->root_khandle,
+		     get_khandle_from_ino(inode));
+
+	if (ORANGEFS_khandle_cmp(&(ORANGEFS_SB(inode->i_sb)->root_khandle),
+			     get_khandle_from_ino(inode)))
+		return 0;
+	else
+		return 1;
+}
+
+static inline int match_handle(struct orangefs_khandle resp_handle,
+			       struct inode *inode)
+{
+	gossip_debug(GOSSIP_DCACHE_DEBUG,
+		     "%s: one handle: %pU, another handle:%pU:\n",
+		     __func__,
+		     &resp_handle,
+		     get_khandle_from_ino(inode));
+
+	if (ORANGEFS_khandle_cmp(&resp_handle, get_khandle_from_ino(inode)))
+		return 0;
+	else
+		return 1;
+}
+
+/*
+ * defined in orangefs-cache.c
+ */
+int op_cache_initialize(void);
+int op_cache_finalize(void);
+struct orangefs_kernel_op_s *op_alloc(__s32 type);
+char *get_opname_string(struct orangefs_kernel_op_s *new_op);
+void op_release(struct orangefs_kernel_op_s *op);
+
+int dev_req_cache_initialize(void);
+int dev_req_cache_finalize(void);
+void *dev_req_alloc(void);
+void dev_req_release(void *);
+
+int orangefs_inode_cache_initialize(void);
+int orangefs_inode_cache_finalize(void);
+
+int kiocb_cache_initialize(void);
+int kiocb_cache_finalize(void);
+struct orangefs_kiocb_s *kiocb_alloc(void);
+void kiocb_release(struct orangefs_kiocb_s *ptr);
+
+/*
+ * defined in orangefs-mod.c
+ */
+void purge_inprogress_ops(void);
+
+/*
+ * defined in waitqueue.c
+ */
+int wait_for_matching_downcall(struct orangefs_kernel_op_s *op);
+int wait_for_cancellation_downcall(struct orangefs_kernel_op_s *op);
+void orangefs_clean_up_interrupted_operation(struct orangefs_kernel_op_s *op);
+void purge_waiting_ops(void);
+
+/*
+ * defined in super.c
+ */
+struct dentry *orangefs_mount(struct file_system_type *fst,
+			   int flags,
+			   const char *devname,
+			   void *data);
+
+void orangefs_kill_sb(struct super_block *sb);
+int orangefs_remount(struct super_block *sb);
+
+int fsid_key_table_initialize(void);
+void fsid_key_table_finalize(void);
+
+/*
+ * defined in inode.c
+ */
+__u32 convert_to_orangefs_mask(unsigned long lite_mask);
+struct inode *orangefs_new_inode(struct super_block *sb,
+			      struct inode *dir,
+			      int mode,
+			      dev_t dev,
+			      struct orangefs_object_kref *ref);
+
+int orangefs_setattr(struct dentry *dentry, struct iattr *iattr);
+
+int orangefs_getattr(struct vfsmount *mnt,
+		  struct dentry *dentry,
+		  struct kstat *kstat);
+
+/*
+ * defined in xattr.c
+ */
+int orangefs_setxattr(struct dentry *dentry,
+		   const char *name,
+		   const void *value,
+		   size_t size,
+		   int flags);
+
+ssize_t orangefs_getxattr(struct dentry *dentry,
+		       const char *name,
+		       void *buffer,
+		       size_t size);
+
+ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size);
+
+/*
+ * defined in namei.c
+ */
+struct inode *orangefs_iget(struct super_block *sb,
+			 struct orangefs_object_kref *ref);
+
+ssize_t orangefs_inode_read(struct inode *inode,
+			    struct iov_iter *iter,
+			    loff_t *offset,
+			    loff_t readahead_size);
+
+/*
+ * defined in devorangefs-req.c
+ */
+int orangefs_dev_init(void);
+void orangefs_dev_cleanup(void);
+int is_daemon_in_service(void);
+int fs_mount_pending(__s32 fsid);
+
+/*
+ * defined in orangefs-utils.c
+ */
+__s32 fsid_of_op(struct orangefs_kernel_op_s *op);
+
+int orangefs_flush_inode(struct inode *inode);
+
+ssize_t orangefs_inode_getxattr(struct inode *inode,
+			     const char *prefix,
+			     const char *name,
+			     void *buffer,
+			     size_t size);
+
+int orangefs_inode_setxattr(struct inode *inode,
+			 const char *prefix,
+			 const char *name,
+			 const void *value,
+			 size_t size,
+			 int flags);
+
+int orangefs_inode_getattr(struct inode *inode, __u32 mask);
+
+int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr);
+
+void orangefs_op_initialize(struct orangefs_kernel_op_s *op);
+
+void orangefs_make_bad_inode(struct inode *inode);
+
+void block_signals(sigset_t *);
+
+void set_signals(sigset_t *);
+
+int orangefs_unmount_sb(struct super_block *sb);
+
+int orangefs_cancel_op_in_progress(__u64 tag);
+
+static inline __u64 orangefs_convert_time_field(const struct timespec *ts)
+{
+	return (__u64)ts->tv_sec;
+}
+
+int orangefs_normalize_to_errno(__s32 error_code);
+
+extern struct mutex devreq_mutex;
+extern struct mutex request_mutex;
+extern int debug;
+extern int op_timeout_secs;
+extern int slot_timeout_secs;
+extern struct list_head orangefs_superblocks;
+extern spinlock_t orangefs_superblocks_lock;
+extern struct list_head orangefs_request_list;
+extern spinlock_t orangefs_request_list_lock;
+extern wait_queue_head_t orangefs_request_list_waitq;
+extern struct list_head *htable_ops_in_progress;
+extern spinlock_t htable_ops_in_progress_lock;
+extern int hash_table_size;
+
+extern const struct address_space_operations orangefs_address_operations;
+extern struct backing_dev_info orangefs_backing_dev_info;
+extern struct inode_operations orangefs_file_inode_operations;
+extern const struct file_operations orangefs_file_operations;
+extern struct inode_operations orangefs_symlink_inode_operations;
+extern struct inode_operations orangefs_dir_inode_operations;
+extern const struct file_operations orangefs_dir_operations;
+extern const struct dentry_operations orangefs_dentry_operations;
+extern const struct file_operations orangefs_devreq_file_operations;
+
+extern wait_queue_head_t orangefs_bufmap_init_waitq;
+
+/*
+ * misc convenience macros
+ */
+#define add_op_to_request_list(op)				\
+do {								\
+	spin_lock(&orangefs_request_list_lock);			\
+	spin_lock(&op->lock);					\
+	set_op_state_waiting(op);				\
+	list_add_tail(&op->list, &orangefs_request_list);		\
+	spin_unlock(&orangefs_request_list_lock);			\
+	spin_unlock(&op->lock);					\
+	wake_up_interruptible(&orangefs_request_list_waitq);	\
+} while (0)
+
+#define add_priority_op_to_request_list(op)				\
+	do {								\
+		spin_lock(&orangefs_request_list_lock);			\
+		spin_lock(&op->lock);					\
+		set_op_state_waiting(op);				\
+									\
+		list_add(&op->list, &orangefs_request_list);		\
+		spin_unlock(&orangefs_request_list_lock);			\
+		spin_unlock(&op->lock);					\
+		wake_up_interruptible(&orangefs_request_list_waitq);	\
+} while (0)
+
+#define remove_op_from_request_list(op)					\
+	do {								\
+		struct list_head *tmp = NULL;				\
+		struct list_head *tmp_safe = NULL;			\
+		struct orangefs_kernel_op_s *tmp_op = NULL;		\
+									\
+		spin_lock(&orangefs_request_list_lock);			\
+		list_for_each_safe(tmp, tmp_safe, &orangefs_request_list) { \
+			tmp_op = list_entry(tmp,			\
+					    struct orangefs_kernel_op_s,	\
+					    list);			\
+			if (tmp_op && (tmp_op == op)) {			\
+				list_del(&tmp_op->list);		\
+				break;					\
+			}						\
+		}							\
+		spin_unlock(&orangefs_request_list_lock);			\
+	} while (0)
+
+#define ORANGEFS_OP_INTERRUPTIBLE 1   /* service_operation() is interruptible */
+#define ORANGEFS_OP_PRIORITY      2   /* service_operation() is high priority */
+#define ORANGEFS_OP_CANCELLATION  4   /* this is a cancellation */
+#define ORANGEFS_OP_NO_SEMAPHORE  8   /* don't acquire semaphore */
+#define ORANGEFS_OP_ASYNC         16  /* Queue it, but don't wait */
+
+int service_operation(struct orangefs_kernel_op_s *op,
+		      const char *op_name,
+		      int flags);
+
+/*
+ * handles two possible error cases, depending on context.
+ *
+ * by design, our vfs i/o errors need to be handled in one of two ways,
+ * depending on where the error occured.
+ *
+ * if the error happens in the waitqueue code because we either timed
+ * out or a signal was raised while waiting, we need to cancel the
+ * userspace i/o operation and free the op manually.  this is done to
+ * avoid having the device start writing application data to our shared
+ * bufmap pages without us expecting it.
+ *
+ * FIXME: POSSIBLE OPTIMIZATION:
+ * However, if we timed out or if we got a signal AND our upcall was never
+ * picked off the queue (i.e. we were in OP_VFS_STATE_WAITING), then we don't
+ * need to send a cancellation upcall. The way we can handle this is
+ * set error_exit to 2 in such cases and 1 whenever cancellation has to be
+ * sent and have handle_error
+ * take care of this situation as well..
+ *
+ * if a orangefs sysint level error occured and i/o has been completed,
+ * there is no need to cancel the operation, as the user has finished
+ * using the bufmap page and so there is no danger in this case.  in
+ * this case, we wake up the device normally so that it may free the
+ * op, as normal.
+ *
+ * note the only reason this is a macro is because both read and write
+ * cases need the exact same handling code.
+ */
+#define handle_io_error()					\
+do {								\
+	if (!op_state_serviced(new_op)) {			\
+		orangefs_cancel_op_in_progress(new_op->tag);	\
+		op_release(new_op);				\
+	} else {						\
+		wake_up_daemon_for_return(new_op);		\
+	}							\
+	new_op = NULL;						\
+	orangefs_bufmap_put(bufmap, buffer_index);				\
+	buffer_index = -1;					\
+} while (0)
+
+#define get_interruptible_flag(inode) \
+	((ORANGEFS_SB(inode->i_sb)->flags & ORANGEFS_OPT_INTR) ? \
+		ORANGEFS_OP_INTERRUPTIBLE : 0)
+
+#define add_orangefs_sb(sb)						\
+do {									\
+	gossip_debug(GOSSIP_SUPER_DEBUG,				\
+		     "Adding SB %p to orangefs superblocks\n",		\
+		     ORANGEFS_SB(sb));					\
+	spin_lock(&orangefs_superblocks_lock);				\
+	list_add_tail(&ORANGEFS_SB(sb)->list, &orangefs_superblocks);		\
+	spin_unlock(&orangefs_superblocks_lock); \
+} while (0)
+
+#define remove_orangefs_sb(sb)						\
+do {									\
+	struct list_head *tmp = NULL;					\
+	struct list_head *tmp_safe = NULL;				\
+	struct orangefs_sb_info_s *orangefs_sb = NULL;			\
+									\
+	spin_lock(&orangefs_superblocks_lock);				\
+	list_for_each_safe(tmp, tmp_safe, &orangefs_superblocks) {		\
+		orangefs_sb = list_entry(tmp,				\
+				      struct orangefs_sb_info_s,		\
+				      list);				\
+		if (orangefs_sb && (orangefs_sb->sb == sb)) {			\
+			gossip_debug(GOSSIP_SUPER_DEBUG,		\
+			    "Removing SB %p from orangefs superblocks\n",	\
+			orangefs_sb);					\
+			list_del(&orangefs_sb->list);			\
+			break;						\
+		}							\
+	}								\
+	spin_unlock(&orangefs_superblocks_lock);				\
+} while (0)
+
+#define orangefs_lock_inode(inode) spin_lock(&inode->i_lock)
+#define orangefs_unlock_inode(inode) spin_unlock(&inode->i_lock)
+
+#define fill_default_sys_attrs(sys_attr, type, mode)			\
+do {									\
+	sys_attr.owner = from_kuid(current_user_ns(), current_fsuid()); \
+	sys_attr.group = from_kgid(current_user_ns(), current_fsgid()); \
+	sys_attr.size = 0;						\
+	sys_attr.perms = ORANGEFS_util_translate_mode(mode);		\
+	sys_attr.objtype = type;					\
+	sys_attr.mask = ORANGEFS_ATTR_SYS_ALL_SETABLE;			\
+} while (0)
+
+#define orangefs_inode_lock(__i)  mutex_lock(&(__i)->i_mutex)
+
+#define orangefs_inode_unlock(__i) mutex_unlock(&(__i)->i_mutex)
+
+static inline void orangefs_i_size_write(struct inode *inode, loff_t i_size)
+{
+#if BITS_PER_LONG == 32 && defined(CONFIG_SMP)
+	ornagefs_inode_lock(inode);
+#endif
+	i_size_write(inode, i_size);
+#if BITS_PER_LONG == 32 && defined(CONFIG_SMP)
+	orangefs_inode_unlock(inode);
+#endif
+}
+
+static inline unsigned int diff(struct timeval *end, struct timeval *begin)
+{
+	if (end->tv_usec < begin->tv_usec) {
+		end->tv_usec += 1000000;
+		end->tv_sec--;
+	}
+	end->tv_sec -= begin->tv_sec;
+	end->tv_usec -= begin->tv_usec;
+	return (end->tv_sec * 1000000) + end->tv_usec;
+}
+
+#endif /* __ORANGEFSKERNEL_H */
