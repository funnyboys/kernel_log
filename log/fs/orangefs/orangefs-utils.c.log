commit 8a88bbce6f83430a737a97bb72d0912a6a103945
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Feb 22 18:15:56 2018 +0000

    orangefs: skip inode writeout if nothing to write
    
    Would happen if an inode is dirty but whatever happened is not something
    that can be written out to OrangeFS.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index d6093a468db9..d4b7ae763186 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -431,6 +431,11 @@ int orangefs_inode_setattr(struct inode *inode)
 	copy_attributes_from_inode(inode,
 	    &new_op->upcall.req.setattr.attributes);
 	orangefs_inode->attr_valid = 0;
+	if (!new_op->upcall.req.setattr.attributes.mask) {
+		spin_unlock(&inode->i_lock);
+		op_release(new_op);
+		return 0;
+	}
 	spin_unlock(&inode->i_lock);
 
 	ret = service_operation(new_op, __func__,

commit 85ac799cf926a589829ebe6274bb5e5a41159743
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Feb 22 18:10:43 2018 +0000

    orangefs: implement writepage
    
    Now orangefs_inode_getattr fills from cache if an inode has dirty pages.
    
    also if attr_valid and dirty pages and !flags, we spin on inode writeback
    before returning if pages still dirty after: should it be other way
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 9221c4a3398e..d6093a468db9 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -247,7 +247,7 @@ int orangefs_inode_getattr(struct inode *inode, int flags)
 	spin_lock(&inode->i_lock);
 	/* Must have all the attributes in the mask and be within cache time. */
 	if ((!flags && time_before(jiffies, orangefs_inode->getattr_time)) ||
-	    orangefs_inode->attr_valid) {
+	    orangefs_inode->attr_valid || inode->i_state & I_DIRTY_PAGES) {
 		if (orangefs_inode->attr_valid) {
 			spin_unlock(&inode->i_lock);
 			write_inode_now(inode, 1);
@@ -281,12 +281,16 @@ int orangefs_inode_getattr(struct inode *inode, int flags)
 	spin_lock(&inode->i_lock);
 	/* Must have all the attributes in the mask and be within cache time. */
 	if ((!flags && time_before(jiffies, orangefs_inode->getattr_time)) ||
-	    orangefs_inode->attr_valid) {
+	    orangefs_inode->attr_valid || inode->i_state & I_DIRTY_PAGES) {
 		if (orangefs_inode->attr_valid) {
 			spin_unlock(&inode->i_lock);
 			write_inode_now(inode, 1);
 			goto again2;
 		}
+		if (inode->i_state & I_DIRTY_PAGES) {
+			ret = 0;
+			goto out_unlock;
+		}
 		gossip_debug(GOSSIP_UTILS_DEBUG, "%s: in cache or dirty\n",
 		    __func__);
 		ret = 0;

commit 0dcac0f7812b2c09ed018a5eba91448a37f1b71b
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Feb 15 19:38:01 2018 +0000

    orangefs: service ops done for writeback are not killable
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index a4fac527f85d..9221c4a3398e 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -430,7 +430,7 @@ int orangefs_inode_setattr(struct inode *inode)
 	spin_unlock(&inode->i_lock);
 
 	ret = service_operation(new_op, __func__,
-	    get_interruptible_flag(inode));
+	    get_interruptible_flag(inode) | ORANGEFS_OP_WRITEBACK);
 	gossip_debug(GOSSIP_UTILS_DEBUG,
 	    "orangefs_inode_setattr: returning %d\n", ret);
 	if (ret)

commit afd9fb2a31797b4c787034294a4062df0c19c37e
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Feb 13 20:13:46 2018 +0000

    orangefs: reorganize setattr functions to track attribute changes
    
    OrangeFS accepts a mask indicating which attributes were changed.  The
    kernel must not set any bits except those that were actually changed.
    The kernel must set the uid/gid of the request to the actual uid/gid
    responsible for the change.
    
    Code path for notify_change initiated setattrs is
    
    orangefs_setattr(dentry, iattr)
    -> __orangefs_setattr(inode, iattr)
    
    In kernel changes are initiated by calling __orangefs_setattr.
    
    Code path for writeback is
    
    orangefs_write_inode
    -> orangefs_inode_setattr
    
    attr_valid and attr_uid and attr_gid change together under i_lock.
    I_DIRTY changes separately.
    
    __orangefs_setattr
            lock
            if needs to be cleaned first, unlock and retry
            set attr_valid
            copy data in
            unlock
            mark_inode_dirty
    
    orangefs_inode_setattr
            lock
            copy attributes out
            unlock
            clear getattr_time
            # __writeback_single_inode clears dirty
    
    orangefs_inode_getattr
            # possible to get here with attr_valid set and not dirty
            lock
            if getattr_time ok or attr_valid set, unlock and return
            unlock
            do server operation
            # another thread may getattr or setattr, so check for that
            lock
            if getattr_time ok or attr_valid, unlock and return
            else, copy in
            update getattr_time
            unlock
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index d44cbe96719a..a4fac527f85d 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -136,51 +136,37 @@ static int orangefs_inode_perms(struct ORANGEFS_sys_attr_s *attrs)
  * NOTE: in kernel land, we never use the sys_attr->link_target for
  * anything, so don't bother copying it into the sys_attr object here.
  */
-static inline int copy_attributes_from_inode(struct inode *inode,
-					     struct ORANGEFS_sys_attr_s *attrs,
-					     struct iattr *iattr)
+static inline void copy_attributes_from_inode(struct inode *inode,
+    struct ORANGEFS_sys_attr_s *attrs)
 {
-	umode_t tmp_mode;
-
-	if (!iattr || !inode || !attrs) {
-		gossip_err("NULL iattr (%p), inode (%p), attrs (%p) "
-			   "in copy_attributes_from_inode!\n",
-			   iattr,
-			   inode,
-			   attrs);
-		return -EINVAL;
-	}
-	/*
-	 * We need to be careful to only copy the attributes out of the
-	 * iattr object that we know are valid.
-	 */
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	attrs->mask = 0;
-	if (iattr->ia_valid & ATTR_UID) {
-		attrs->owner = from_kuid(&init_user_ns, iattr->ia_uid);
+	if (orangefs_inode->attr_valid & ATTR_UID) {
+		attrs->owner = from_kuid(&init_user_ns, inode->i_uid);
 		attrs->mask |= ORANGEFS_ATTR_SYS_UID;
 		gossip_debug(GOSSIP_UTILS_DEBUG, "(UID) %d\n", attrs->owner);
 	}
-	if (iattr->ia_valid & ATTR_GID) {
-		attrs->group = from_kgid(&init_user_ns, iattr->ia_gid);
+	if (orangefs_inode->attr_valid & ATTR_GID) {
+		attrs->group = from_kgid(&init_user_ns, inode->i_gid);
 		attrs->mask |= ORANGEFS_ATTR_SYS_GID;
 		gossip_debug(GOSSIP_UTILS_DEBUG, "(GID) %d\n", attrs->group);
 	}
 
-	if (iattr->ia_valid & ATTR_ATIME) {
+	if (orangefs_inode->attr_valid & ATTR_ATIME) {
 		attrs->mask |= ORANGEFS_ATTR_SYS_ATIME;
-		if (iattr->ia_valid & ATTR_ATIME_SET) {
-			attrs->atime = (time64_t)iattr->ia_atime.tv_sec;
+		if (orangefs_inode->attr_valid & ATTR_ATIME_SET) {
+			attrs->atime = (time64_t)inode->i_atime.tv_sec;
 			attrs->mask |= ORANGEFS_ATTR_SYS_ATIME_SET;
 		}
 	}
-	if (iattr->ia_valid & ATTR_MTIME) {
+	if (orangefs_inode->attr_valid & ATTR_MTIME) {
 		attrs->mask |= ORANGEFS_ATTR_SYS_MTIME;
-		if (iattr->ia_valid & ATTR_MTIME_SET) {
-			attrs->mtime = (time64_t)iattr->ia_mtime.tv_sec;
+		if (orangefs_inode->attr_valid & ATTR_MTIME_SET) {
+			attrs->mtime = (time64_t)inode->i_mtime.tv_sec;
 			attrs->mask |= ORANGEFS_ATTR_SYS_MTIME_SET;
 		}
 	}
-	if (iattr->ia_valid & ATTR_CTIME)
+	if (orangefs_inode->attr_valid & ATTR_CTIME)
 		attrs->mask |= ORANGEFS_ATTR_SYS_CTIME;
 
 	/*
@@ -189,36 +175,10 @@ static inline int copy_attributes_from_inode(struct inode *inode,
 	 * worry about ATTR_SIZE
 	 */
 
-	if (iattr->ia_valid & ATTR_MODE) {
-		tmp_mode = iattr->ia_mode;
-		if (tmp_mode & (S_ISVTX)) {
-			if (is_root_handle(inode)) {
-				/*
-				 * allow sticky bit to be set on root (since
-				 * it shows up that way by default anyhow),
-				 * but don't show it to the server
-				 */
-				tmp_mode -= S_ISVTX;
-			} else {
-				gossip_debug(GOSSIP_UTILS_DEBUG,
-					"%s: setting sticky bit not supported.\n",
-					__func__);
-				return -EINVAL;
-			}
-		}
-
-		if (tmp_mode & (S_ISUID)) {
-			gossip_debug(GOSSIP_UTILS_DEBUG,
-				"%s: setting setuid bit not supported.\n",
-				__func__);
-			return -EINVAL;
-		}
-
-		attrs->perms = ORANGEFS_util_translate_mode(tmp_mode);
+	if (orangefs_inode->attr_valid & ATTR_MODE) {
+		attrs->perms = ORANGEFS_util_translate_mode(inode->i_mode);
 		attrs->mask |= ORANGEFS_ATTR_SYS_PERM;
 	}
-
-	return 0;
 }
 
 static int orangefs_inode_type(enum orangefs_ds_type objtype)
@@ -283,10 +243,16 @@ int orangefs_inode_getattr(struct inode *inode, int flags)
 	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: called on inode %pU flags %d\n",
 	    __func__, get_khandle_from_ino(inode), flags);
 
+again:
 	spin_lock(&inode->i_lock);
 	/* Must have all the attributes in the mask and be within cache time. */
 	if ((!flags && time_before(jiffies, orangefs_inode->getattr_time)) ||
-	    inode->i_state & I_DIRTY) {
+	    orangefs_inode->attr_valid) {
+		if (orangefs_inode->attr_valid) {
+			spin_unlock(&inode->i_lock);
+			write_inode_now(inode, 1);
+			goto again;
+		}
 		spin_unlock(&inode->i_lock);
 		return 0;
 	}
@@ -311,10 +277,16 @@ int orangefs_inode_getattr(struct inode *inode, int flags)
 	if (ret != 0)
 		goto out;
 
+again2:
 	spin_lock(&inode->i_lock);
 	/* Must have all the attributes in the mask and be within cache time. */
 	if ((!flags && time_before(jiffies, orangefs_inode->getattr_time)) ||
-	    inode->i_state & I_DIRTY) {
+	    orangefs_inode->attr_valid) {
+		if (orangefs_inode->attr_valid) {
+			spin_unlock(&inode->i_lock);
+			write_inode_now(inode, 1);
+			goto again2;
+		}
 		gossip_debug(GOSSIP_UTILS_DEBUG, "%s: in cache or dirty\n",
 		    __func__);
 		ret = 0;
@@ -438,7 +410,7 @@ int orangefs_inode_check_changed(struct inode *inode)
  * issues a orangefs setattr request to make sure the new attribute values
  * take effect if successful.  returns 0 on success; -errno otherwise
  */
-int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr)
+int orangefs_inode_setattr(struct inode *inode)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_kernel_op_s *new_op;
@@ -448,24 +420,26 @@ int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr)
 	if (!new_op)
 		return -ENOMEM;
 
+	spin_lock(&inode->i_lock);
+	new_op->upcall.uid = from_kuid(&init_user_ns, orangefs_inode->attr_uid);
+	new_op->upcall.gid = from_kgid(&init_user_ns, orangefs_inode->attr_gid);
 	new_op->upcall.req.setattr.refn = orangefs_inode->refn;
-	ret = copy_attributes_from_inode(inode,
-		       &new_op->upcall.req.setattr.attributes,
-		       iattr);
-	if (ret >= 0) {
-		ret = service_operation(new_op, __func__,
-				get_interruptible_flag(inode));
+	copy_attributes_from_inode(inode,
+	    &new_op->upcall.req.setattr.attributes);
+	orangefs_inode->attr_valid = 0;
+	spin_unlock(&inode->i_lock);
 
-		gossip_debug(GOSSIP_UTILS_DEBUG,
-			     "orangefs_inode_setattr: returning %d\n",
-			     ret);
-	}
+	ret = service_operation(new_op, __func__,
+	    get_interruptible_flag(inode));
+	gossip_debug(GOSSIP_UTILS_DEBUG,
+	    "orangefs_inode_setattr: returning %d\n", ret);
+	if (ret)
+		orangefs_make_bad_inode(inode);
 
 	op_release(new_op);
 
 	if (ret == 0)
 		orangefs_inode->getattr_time = jiffies - 1;
-
 	return ret;
 }
 

commit 5e4f606e26d6a1df6784f5833ea258047ac93254
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Feb 12 17:04:57 2018 +0000

    orangefs: hold i_lock during inode_getattr
    
    This should be a no-op now.  When inode writeback works, this will
    prevent a getattr from overwriting inode data while an inode is
    transitioning to dirty.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 76f18a3494c7..d44cbe96719a 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -280,12 +280,17 @@ int orangefs_inode_getattr(struct inode *inode, int flags)
 	loff_t inode_size;
 	int ret, type;
 
-	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: called on inode %pU\n", __func__,
-	    get_khandle_from_ino(inode));
+	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: called on inode %pU flags %d\n",
+	    __func__, get_khandle_from_ino(inode), flags);
 
+	spin_lock(&inode->i_lock);
 	/* Must have all the attributes in the mask and be within cache time. */
-	if (!flags && time_before(jiffies, orangefs_inode->getattr_time))
+	if ((!flags && time_before(jiffies, orangefs_inode->getattr_time)) ||
+	    inode->i_state & I_DIRTY) {
+		spin_unlock(&inode->i_lock);
 		return 0;
+	}
+	spin_unlock(&inode->i_lock);
 
 	new_op = op_alloc(ORANGEFS_VFS_OP_GETATTR);
 	if (!new_op)
@@ -306,13 +311,23 @@ int orangefs_inode_getattr(struct inode *inode, int flags)
 	if (ret != 0)
 		goto out;
 
+	spin_lock(&inode->i_lock);
+	/* Must have all the attributes in the mask and be within cache time. */
+	if ((!flags && time_before(jiffies, orangefs_inode->getattr_time)) ||
+	    inode->i_state & I_DIRTY) {
+		gossip_debug(GOSSIP_UTILS_DEBUG, "%s: in cache or dirty\n",
+		    __func__);
+		ret = 0;
+		goto out_unlock;
+	}
+
 	if (!(flags & ORANGEFS_GETATTR_NEW)) {
 		ret = orangefs_inode_is_stale(inode,
 		    &new_op->downcall.resp.getattr.attributes,
 		    new_op->downcall.resp.getattr.link_target);
 		if (ret) {
 			ret = -ESTALE;
-			goto out;
+			goto out_unlock;
 		}
 	}
 
@@ -328,19 +343,15 @@ int orangefs_inode_getattr(struct inode *inode, int flags)
 			inode->i_size = inode_size;
 			inode->i_blkbits = ffs(new_op->downcall.resp.getattr.
 			    attributes.blksize);
-			spin_lock(&inode->i_lock);
 			inode->i_bytes = inode_size;
 			inode->i_blocks =
 			    (inode_size + 512 - inode_size % 512)/512;
-			spin_unlock(&inode->i_lock);
 		}
 		break;
 	case S_IFDIR:
 		if (flags) {
 			inode->i_size = PAGE_SIZE;
-			spin_lock(&inode->i_lock);
 			inode_set_bytes(inode, inode->i_size);
-			spin_unlock(&inode->i_lock);
 		}
 		set_nlink(inode, 1);
 		break;
@@ -353,7 +364,7 @@ int orangefs_inode_getattr(struct inode *inode, int flags)
 			    ORANGEFS_NAME_MAX);
 			if (ret == -E2BIG) {
 				ret = -EIO;
-				goto out;
+				goto out_unlock;
 			}
 			inode->i_link = orangefs_inode->link_target;
 		}
@@ -363,7 +374,7 @@ int orangefs_inode_getattr(struct inode *inode, int flags)
 		/* XXX: ESTALE?  This is what is done if it is not new. */
 		orangefs_make_bad_inode(inode);
 		ret = -ESTALE;
-		goto out;
+		goto out_unlock;
 	}
 
 	inode->i_uid = make_kuid(&init_user_ns, new_op->
@@ -387,6 +398,8 @@ int orangefs_inode_getattr(struct inode *inode, int flags)
 	orangefs_inode->getattr_time = jiffies +
 	    orangefs_getattr_timeout_msecs*HZ/1000;
 	ret = 0;
+out_unlock:
+	spin_unlock(&inode->i_lock);
 out:
 	op_release(new_op);
 	return ret;

commit 8b60785c1d7c63415c32bf64dabc686b9045ce7d
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Wed Feb 7 18:44:50 2018 +0000

    orangefs: simplify orangefs_inode_getattr interface
    
    No need to store the received mask.  It is either STATX_BASIC_STATS or
    STATX_BASIC_STATS & ~STATX_SIZE.  If STATX_SIZE is requested, the cache
    is bypassed anyway, so the cached mask is unnecessary to decide whether
    to do a real getattr.
    
    This is a change.  Previously a getattr would want size and use the
    cached size.  All of the in-kernel callers that wanted size did not want
    a cached size.  Now a getattr cannot use the cached size if it wants
    size at all.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 804c8a261e4b..76f18a3494c7 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
  * (C) 2001 Clemson University and The University of Chicago
+ * Copyright 2018 Omnibond Systems, L.L.C.
  *
  * See COPYING in top-level directory.
  */
@@ -272,8 +273,7 @@ static int orangefs_inode_is_stale(struct inode *inode,
 	return 0;
 }
 
-int orangefs_inode_getattr(struct inode *inode, int new, int bypass,
-    u32 request_mask)
+int orangefs_inode_getattr(struct inode *inode, int flags)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_kernel_op_s *new_op;
@@ -283,16 +283,9 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass,
 	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: called on inode %pU\n", __func__,
 	    get_khandle_from_ino(inode));
 
-	if (!new && !bypass) {
-		/*
-		 * Must have all the attributes in the mask and be within cache
-		 * time.
-		 */
-		if ((request_mask & orangefs_inode->getattr_mask) ==
-		    request_mask &&
-		    time_before(jiffies, orangefs_inode->getattr_time))
-			return 0;
-	}
+	/* Must have all the attributes in the mask and be within cache time. */
+	if (!flags && time_before(jiffies, orangefs_inode->getattr_time))
+		return 0;
 
 	new_op = op_alloc(ORANGEFS_VFS_OP_GETATTR);
 	if (!new_op)
@@ -302,7 +295,7 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass,
 	 * Size is the hardest attribute to get.  The incremental cost of any
 	 * other attribute is essentially zero.
 	 */
-	if (request_mask & STATX_SIZE || new)
+	if (flags)
 		new_op->upcall.req.getattr.mask = ORANGEFS_ATTR_SYS_ALL_NOHINT;
 	else
 		new_op->upcall.req.getattr.mask =
@@ -313,7 +306,7 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass,
 	if (ret != 0)
 		goto out;
 
-	if (!new) {
+	if (!(flags & ORANGEFS_GETATTR_NEW)) {
 		ret = orangefs_inode_is_stale(inode,
 		    &new_op->downcall.resp.getattr.attributes,
 		    new_op->downcall.resp.getattr.link_target);
@@ -329,7 +322,7 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass,
 	case S_IFREG:
 		inode->i_flags = orangefs_inode_flags(&new_op->
 		    downcall.resp.getattr.attributes);
-		if (request_mask & STATX_SIZE || new) {
+		if (flags) {
 			inode_size = (loff_t)new_op->
 			    downcall.resp.getattr.attributes.size;
 			inode->i_size = inode_size;
@@ -343,7 +336,7 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass,
 		}
 		break;
 	case S_IFDIR:
-		if (request_mask & STATX_SIZE || new) {
+		if (flags) {
 			inode->i_size = PAGE_SIZE;
 			spin_lock(&inode->i_lock);
 			inode_set_bytes(inode, inode->i_size);
@@ -352,7 +345,7 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass,
 		set_nlink(inode, 1);
 		break;
 	case S_IFLNK:
-		if (new) {
+		if (flags & ORANGEFS_GETATTR_NEW) {
 			inode->i_size = (loff_t)strlen(new_op->
 			    downcall.resp.getattr.link_target);
 			ret = strscpy(orangefs_inode->link_target,
@@ -393,10 +386,6 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass,
 
 	orangefs_inode->getattr_time = jiffies +
 	    orangefs_getattr_timeout_msecs*HZ/1000;
-	if (request_mask & STATX_SIZE || new)
-		orangefs_inode->getattr_mask = STATX_BASIC_STATS;
-	else
-		orangefs_inode->getattr_mask = STATX_BASIC_STATS & ~STATX_SIZE;
 	ret = 0;
 out:
 	op_release(new_op);

commit 95f5f88f8900c09eb534c8cb42d75ff3cf7ea96c
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri May 11 17:11:48 2018 -0400

    orangefs: formatting cleanups
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 89729040c5b4..804c8a261e4b 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -183,9 +183,9 @@ static inline int copy_attributes_from_inode(struct inode *inode,
 		attrs->mask |= ORANGEFS_ATTR_SYS_CTIME;
 
 	/*
-	 * ORANGEFS cannot set size with a setattr operation.  Probably not likely
-	 * to be requested through the VFS, but just in case, don't worry about
-	 * ATTR_SIZE
+	 * ORANGEFS cannot set size with a setattr operation. Probably not
+	 * likely to be requested through the VFS, but just in case, don't
+	 * worry about ATTR_SIZE
 	 */
 
 	if (iattr->ia_valid & ATTR_MODE) {
@@ -200,14 +200,16 @@ static inline int copy_attributes_from_inode(struct inode *inode,
 				tmp_mode -= S_ISVTX;
 			} else {
 				gossip_debug(GOSSIP_UTILS_DEBUG,
-					     "User attempted to set sticky bit on non-root directory; returning EINVAL.\n");
+					"%s: setting sticky bit not supported.\n",
+					__func__);
 				return -EINVAL;
 			}
 		}
 
 		if (tmp_mode & (S_ISUID)) {
 			gossip_debug(GOSSIP_UTILS_DEBUG,
-				     "Attempting to set setuid bit (not supported); returning EINVAL.\n");
+				"%s: setting setuid bit not supported.\n",
+				__func__);
 			return -EINVAL;
 		}
 
@@ -521,7 +523,9 @@ int orangefs_normalize_to_errno(__s32 error_code)
 			error_code = -ETIMEDOUT;
 		} else {
 			/* assume a default error code */
-			gossip_err("orangefs: warning: got error code without errno equivalent: %d.\n", error_code);
+			gossip_err("%s: bad error code :%d:.\n",
+				__func__,
+				error_code);
 			error_code = -EINVAL;
 		}
 
@@ -538,7 +542,7 @@ int orangefs_normalize_to_errno(__s32 error_code)
 	 * there is a bug somewhere.
 	 */
 	} else {
-		gossip_err("orangefs: orangefs_normalize_to_errno: got error code which is not from ORANGEFS.\n");
+		gossip_err("%s: unknown error code.\n", __func__);
 		error_code = -EINVAL;
 	}
 	return error_code;

commit 9f8fd53cd05596f6792f769c9fd5fd2b0d624507
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu May 31 16:36:59 2018 +0000

    orangefs: revamp block sizes
    
    Now the superblock block size is PAGE_SIZE.  The inode block size is
    PAGE_SIZE for directories and symlinks, but is the server-reported
    block size for regular files.
    
    The block size in the OrangeFS private inode is now deleted.  Stat
    now reports PAGE_SIZE for directories and symlinks and the
    server-reported block size for regular files.
    
    The user-space visible change is that the block size for directores
    and symlinks and the superblock is now PAGE_SIZE rather than the size of
    the client-core shared memory buffers, which was typically four
    megabytes.
    
    Reported-by: Becky Ligon <ligon@clemson.edu>
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Cc: hubcap@omnibond.com
    Cc: walt@omnibond.com
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 00fadaf0da8f..89729040c5b4 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -275,7 +275,7 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass,
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_kernel_op_s *new_op;
-	loff_t inode_size, rounded_up_size;
+	loff_t inode_size;
 	int ret, type;
 
 	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: called on inode %pU\n", __func__,
@@ -330,22 +330,19 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass,
 		if (request_mask & STATX_SIZE || new) {
 			inode_size = (loff_t)new_op->
 			    downcall.resp.getattr.attributes.size;
-			rounded_up_size =
-			    (inode_size + (4096 - (inode_size % 4096)));
 			inode->i_size = inode_size;
-			orangefs_inode->blksize =
-			    new_op->downcall.resp.getattr.attributes.blksize;
+			inode->i_blkbits = ffs(new_op->downcall.resp.getattr.
+			    attributes.blksize);
 			spin_lock(&inode->i_lock);
 			inode->i_bytes = inode_size;
 			inode->i_blocks =
-			    (unsigned long)(rounded_up_size / 512);
+			    (inode_size + 512 - inode_size % 512)/512;
 			spin_unlock(&inode->i_lock);
 		}
 		break;
 	case S_IFDIR:
 		if (request_mask & STATX_SIZE || new) {
 			inode->i_size = PAGE_SIZE;
-			orangefs_inode->blksize = i_blocksize(inode);
 			spin_lock(&inode->i_lock);
 			inode_set_bytes(inode, inode->i_size);
 			spin_unlock(&inode->i_lock);
@@ -356,7 +353,6 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass,
 		if (new) {
 			inode->i_size = (loff_t)strlen(new_op->
 			    downcall.resp.getattr.link_target);
-			orangefs_inode->blksize = i_blocksize(inode);
 			ret = strscpy(orangefs_inode->link_target,
 			    new_op->downcall.resp.getattr.link_target,
 			    ORANGEFS_NAME_MAX);

commit bc8282a730215f1ffab5959556b20e99c7ff6cef
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Tue Jan 16 00:18:36 2018 +0900

    treewide: Fix typos in printk
    
    This patch fixes spelling typos found in printk.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index ea6256d136d1..00fadaf0da8f 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -500,7 +500,7 @@ int orangefs_normalize_to_errno(__s32 error_code)
 	 * server.
 	 */
 	} else if (error_code > 0) {
-		gossip_err("orangefs: error status receieved.\n");
+		gossip_err("orangefs: error status received.\n");
 		gossip_err("orangefs: assuming error code is inverted.\n");
 		error_code = -error_code;
 	}

commit 480e5ae9b860c8a1c74ab9414f9bd78a43ad356f
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Feb 6 14:01:25 2018 +0000

    orangefs: simplify orangefs_inode_is_stale
    
    Check whether this is a new inode at location of call.
    
    Raises the question of what to do with an unknown inode type.  Old code
    would've marked the inode bad and returned ESTALE.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index ccddfcab7fc0..ea6256d136d1 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -249,25 +249,23 @@ static void orangefs_make_bad_inode(struct inode *inode)
 	}
 }
 
-static int orangefs_inode_is_stale(struct inode *inode, int new,
+static int orangefs_inode_is_stale(struct inode *inode,
     struct ORANGEFS_sys_attr_s *attrs, char *link_target)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	int type = orangefs_inode_type(attrs->objtype);
-	if (!new) {
-		/*
-		 * If the inode type or symlink target have changed then this
-		 * inode is stale.
-		 */
-		if (type == -1 || !(inode->i_mode & type)) {
-			orangefs_make_bad_inode(inode);
-			return 1;
-		}
-		if (type == S_IFLNK && strncmp(orangefs_inode->link_target,
-		    link_target, ORANGEFS_NAME_MAX)) {
-			orangefs_make_bad_inode(inode);
-			return 1;
-		}
+	/*
+	 * If the inode type or symlink target have changed then this
+	 * inode is stale.
+	 */
+	if (type == -1 || !(inode->i_mode & type)) {
+		orangefs_make_bad_inode(inode);
+		return 1;
+	}
+	if (type == S_IFLNK && strncmp(orangefs_inode->link_target,
+	    link_target, ORANGEFS_NAME_MAX)) {
+		orangefs_make_bad_inode(inode);
+		return 1;
 	}
 	return 0;
 }
@@ -313,16 +311,18 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass,
 	if (ret != 0)
 		goto out;
 
-	type = orangefs_inode_type(new_op->
-	    downcall.resp.getattr.attributes.objtype);
-	ret = orangefs_inode_is_stale(inode, new,
-	    &new_op->downcall.resp.getattr.attributes,
-	    new_op->downcall.resp.getattr.link_target);
-	if (ret) {
-		ret = -ESTALE;
-		goto out;
+	if (!new) {
+		ret = orangefs_inode_is_stale(inode,
+		    &new_op->downcall.resp.getattr.attributes,
+		    new_op->downcall.resp.getattr.link_target);
+		if (ret) {
+			ret = -ESTALE;
+			goto out;
+		}
 	}
 
+	type = orangefs_inode_type(new_op->
+	    downcall.resp.getattr.attributes.objtype);
 	switch (type) {
 	case S_IFREG:
 		inode->i_flags = orangefs_inode_flags(&new_op->
@@ -367,6 +367,12 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass,
 			inode->i_link = orangefs_inode->link_target;
 		}
 		break;
+	/* i.e. -1 */
+	default:
+		/* XXX: ESTALE?  This is what is done if it is not new. */
+		orangefs_make_bad_inode(inode);
+		ret = -ESTALE;
+		goto out;
 	}
 
 	inode->i_uid = make_kuid(&init_user_ns, new_op->
@@ -420,7 +426,7 @@ int orangefs_inode_check_changed(struct inode *inode)
 	if (ret != 0)
 		goto out;
 
-	ret = orangefs_inode_is_stale(inode, 0,
+	ret = orangefs_inode_is_stale(inode,
 	    &new_op->downcall.resp.getattr.attributes,
 	    new_op->downcall.resp.getattr.link_target);
 out:

commit cf546ab6b189ab8b3acb26bbc2f0af4df21f16c7
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Thu Jan 25 14:43:28 2018 -0500

    Orangefs: don't propogate whacky error codes
    
    When we get an error return code from userspace (the client-core)
    we check to make sure it is a valid code.
    
    This patch maps the whacky return code to -EINVAL instead of
    propagating garbage back up the call chain potentially resulting
    in a hard-to-find train-wreck.
    
    The client-core doesn't have any business returning whacky return
    codes, but if it does, we don't want the kernel to crash as a result.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 3098c2ee7b5f..ccddfcab7fc0 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -537,6 +537,7 @@ int orangefs_normalize_to_errno(__s32 error_code)
 	 */
 	} else {
 		gossip_err("orangefs: orangefs_normalize_to_errno: got error code which is not from ORANGEFS.\n");
+		error_code = -EINVAL;
 	}
 	return error_code;
 }

commit 4d0cac7e752cccb9eb30cd0f22438b9506ed51bc
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Jan 26 14:07:14 2018 -0500

    orangefs: make orangefs_make_bad_inode static
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 97fe93129f38..3098c2ee7b5f 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -230,6 +230,25 @@ static int orangefs_inode_type(enum orangefs_ds_type objtype)
 		return -1;
 }
 
+static void orangefs_make_bad_inode(struct inode *inode)
+{
+	if (is_root_handle(inode)) {
+		/*
+		 * if this occurs, the pvfs2-client-core was killed but we
+		 * can't afford to lose the inode operations and such
+		 * associated with the root handle in any case.
+		 */
+		gossip_debug(GOSSIP_UTILS_DEBUG,
+			     "*** NOT making bad root inode %pU\n",
+			     get_khandle_from_ino(inode));
+	} else {
+		gossip_debug(GOSSIP_UTILS_DEBUG,
+			     "*** making bad inode %pU\n",
+			     get_khandle_from_ino(inode));
+		make_bad_inode(inode);
+	}
+}
+
 static int orangefs_inode_is_stale(struct inode *inode, int new,
     struct ORANGEFS_sys_attr_s *attrs, char *link_target)
 {
@@ -444,25 +463,6 @@ int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr)
 	return ret;
 }
 
-void orangefs_make_bad_inode(struct inode *inode)
-{
-	if (is_root_handle(inode)) {
-		/*
-		 * if this occurs, the pvfs2-client-core was killed but we
-		 * can't afford to lose the inode operations and such
-		 * associated with the root handle in any case.
-		 */
-		gossip_debug(GOSSIP_UTILS_DEBUG,
-			     "*** NOT making bad root inode %pU\n",
-			     get_khandle_from_ino(inode));
-	} else {
-		gossip_debug(GOSSIP_UTILS_DEBUG,
-			     "*** making bad inode %pU\n",
-			     get_khandle_from_ino(inode));
-		make_bad_inode(inode);
-	}
-}
-
 /*
  * The following is a very dirty hack that is now a permanent part of the
  * ORANGEFS protocol. See protocol.h for more error definitions.

commit a55f2d861585006f493e933ad32d65d71ba631fa
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Nov 7 15:01:40 2017 -0500

    orangefs: stop setting atime on inode dirty
    
    The previous code path was to mark the inode dirty, let
    orangefs_inode_dirty set a flag in our private inode, then later during
    inode release call orangefs_flush_inode which notices the flag and
    writes the atime out.
    
    The code path worked almost identically for mtime, ctime, and mode
    except that those flags are set explicitly and not as side effects of
    dirty.
    
    Now orangefs_flush_inode is removed.  Marking an inode dirty does not
    imply an atime update.  Any place where flags were set before is now
    an explicit call to orangefs_inode_setattr.  Since OrangeFS does not
    utilize inode writeback, the attribute change should be written out
    immediately.
    
    Fixes generic/120.
    
    In namei.c, there are several places where the directory mtime and ctime
    are set, but only the mtime is sent to the server.  These don't seem
    right, but I've left them as is for now.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 994a0604145a..97fe93129f38 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -438,89 +438,8 @@ int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr)
 
 	op_release(new_op);
 
-	/*
-	 * successful setattr should clear the atime, mtime and
-	 * ctime flags.
-	 */
-	if (ret == 0) {
-		ClearAtimeFlag(orangefs_inode);
-		ClearMtimeFlag(orangefs_inode);
-		ClearCtimeFlag(orangefs_inode);
-		ClearModeFlag(orangefs_inode);
+	if (ret == 0)
 		orangefs_inode->getattr_time = jiffies - 1;
-	}
-
-	return ret;
-}
-
-int orangefs_flush_inode(struct inode *inode)
-{
-	/*
-	 * If it is a dirty inode, this function gets called.
-	 * Gather all the information that needs to be setattr'ed
-	 * Right now, this will only be used for mode, atime, mtime
-	 * and/or ctime.
-	 */
-	struct iattr wbattr;
-	int ret;
-	int mtime_flag;
-	int ctime_flag;
-	int atime_flag;
-	int mode_flag;
-	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
-
-	memset(&wbattr, 0, sizeof(wbattr));
-
-	/*
-	 * check inode flags up front, and clear them if they are set.  This
-	 * will prevent multiple processes from all trying to flush the same
-	 * inode if they call close() simultaneously
-	 */
-	mtime_flag = MtimeFlag(orangefs_inode);
-	ClearMtimeFlag(orangefs_inode);
-	ctime_flag = CtimeFlag(orangefs_inode);
-	ClearCtimeFlag(orangefs_inode);
-	atime_flag = AtimeFlag(orangefs_inode);
-	ClearAtimeFlag(orangefs_inode);
-	mode_flag = ModeFlag(orangefs_inode);
-	ClearModeFlag(orangefs_inode);
-
-	/*  -- Lazy atime,mtime and ctime update --
-	 * Note: all times are dictated by server in the new scheme
-	 * and not by the clients
-	 *
-	 * Also mode updates are being handled now..
-	 */
-
-	if (mtime_flag)
-		wbattr.ia_valid |= ATTR_MTIME;
-	if (ctime_flag)
-		wbattr.ia_valid |= ATTR_CTIME;
-	if (atime_flag)
-		wbattr.ia_valid |= ATTR_ATIME;
-
-	if (mode_flag) {
-		wbattr.ia_mode = inode->i_mode;
-		wbattr.ia_valid |= ATTR_MODE;
-	}
-
-	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "*********** orangefs_flush_inode: %pU "
-		     "(ia_valid %d)\n",
-		     get_khandle_from_ino(inode),
-		     wbattr.ia_valid);
-	if (wbattr.ia_valid == 0) {
-		gossip_debug(GOSSIP_UTILS_DEBUG,
-			     "orangefs_flush_inode skipping setattr()\n");
-		return 0;
-	}
-
-	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "orangefs_flush_inode (%pU) writing mode %o\n",
-		     get_khandle_from_ino(inode),
-		     inode->i_mode);
-
-	ret = orangefs_inode_setattr(inode, &wbattr);
 
 	return ret;
 }

commit 296200d3bb649f9646f60abe6e8ebb9fd8d20f4b
Author: Jérémy Lefaure <jeremy.lefaure@lse.epita.fr>
Date:   Sun Oct 1 15:30:48 2017 -0400

    orangefs: use ARRAY_SIZE
    
    Using the ARRAY_SIZE macro improves the readability of the code.
    
    Found with Coccinelle with the following semantic patch:
    @r depends on (org || report)@
    type T;
    T[] E;
    position p;
    @@
    (
     (sizeof(E)@p /sizeof(*E))
    |
     (sizeof(E)@p /sizeof(E[...]))
    |
     (sizeof(E)@p /sizeof(T))
    )
    
    Signed-off-by: Jérémy Lefaure <jeremy.lefaure@lse.epita.fr>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index f82336496311..994a0604145a 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -4,6 +4,7 @@
  *
  * See COPYING in top-level directory.
  */
+#include <linux/kernel.h>
 #include "protocol.h"
 #include "orangefs-kernel.h"
 #include "orangefs-dev-proto.h"
@@ -606,7 +607,7 @@ int orangefs_normalize_to_errno(__s32 error_code)
 	/* Convert ORANGEFS encoded errno values into regular errno values. */
 	} else if ((-error_code) & ORANGEFS_ERROR_BIT) {
 		i = (-error_code) & ~(ORANGEFS_ERROR_BIT|ORANGEFS_ERROR_CLASS_BITS);
-		if (i < sizeof(PINT_errno_mapping)/sizeof(*PINT_errno_mapping))
+		if (i < ARRAY_SIZE(PINT_errno_mapping))
 			error_code = -PINT_errno_mapping[i];
 		else
 			error_code = -EINVAL;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index aab6f1842963..f82336496311 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * (C) 2001 Clemson University and The University of Chicago
  *

commit 9d286b0d8207a70d7e0ffbd5be864ff7a62de05a
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 25 15:38:05 2017 -0400

    orangefs: ensure the userspace component is unmounted if mount fails
    
    If the mount is aborted after userspace has been asked to mount,
    userspace must be told to unmount.
    
    Ordinarily orangefs_kill_sb does the unmount.  However it cannot be
    called if the superblock has not been set up.  This is a very narrow
    window.
    
    The NULL fs_id is not unmounted.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index fcbf4e56fd06..aab6f1842963 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -523,41 +523,6 @@ int orangefs_flush_inode(struct inode *inode)
 	return ret;
 }
 
-int orangefs_unmount_sb(struct super_block *sb)
-{
-	int ret = -EINVAL;
-	struct orangefs_kernel_op_s *new_op = NULL;
-
-	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "orangefs_unmount_sb called on sb %p\n",
-		     sb);
-
-	new_op = op_alloc(ORANGEFS_VFS_OP_FS_UMOUNT);
-	if (!new_op)
-		return -ENOMEM;
-	new_op->upcall.req.fs_umount.id = ORANGEFS_SB(sb)->id;
-	new_op->upcall.req.fs_umount.fs_id = ORANGEFS_SB(sb)->fs_id;
-	strncpy(new_op->upcall.req.fs_umount.orangefs_config_server,
-		ORANGEFS_SB(sb)->devname,
-		ORANGEFS_MAX_SERVER_ADDR_LEN);
-
-	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "Attempting ORANGEFS Unmount via host %s\n",
-		     new_op->upcall.req.fs_umount.orangefs_config_server);
-
-	ret = service_operation(new_op, "orangefs_fs_umount", 0);
-
-	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "orangefs_unmount: got return value of %d\n", ret);
-	if (ret)
-		sb = ERR_PTR(ret);
-	else
-		ORANGEFS_SB(sb)->mount_pending = 1;
-
-	op_release(new_op);
-	return ret;
-}
-
 void orangefs_make_bad_inode(struct inode *inode)
 {
 	if (is_root_handle(inode)) {

commit 68a24a6cc4a6025e111c282186a2506281d79b4b
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Apr 25 15:38:03 2017 -0400

    orangefs: implement statx
    
    Fortunately OrangeFS has had a getattr request mask for a long time.
    
    The server basically has two difficulty levels for attributes.  Fetching
    any attribute except size requires communicating with the metadata
    server for that handle.  Since all the attributes are right there, it
    makes sense to return them all.  Fetching the size requires
    communicating with every I/O server (that the file is distributed
    across).  Therefore if asked for anything except size, get everything
    except size, and if asked for size, get everything.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 9b96b99539d6..fcbf4e56fd06 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -251,7 +251,8 @@ static int orangefs_inode_is_stale(struct inode *inode, int new,
 	return 0;
 }
 
-int orangefs_inode_getattr(struct inode *inode, int new, int bypass)
+int orangefs_inode_getattr(struct inode *inode, int new, int bypass,
+    u32 request_mask)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_kernel_op_s *new_op;
@@ -262,7 +263,13 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass)
 	    get_khandle_from_ino(inode));
 
 	if (!new && !bypass) {
-		if (time_before(jiffies, orangefs_inode->getattr_time))
+		/*
+		 * Must have all the attributes in the mask and be within cache
+		 * time.
+		 */
+		if ((request_mask & orangefs_inode->getattr_mask) ==
+		    request_mask &&
+		    time_before(jiffies, orangefs_inode->getattr_time))
 			return 0;
 	}
 
@@ -270,7 +277,15 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass)
 	if (!new_op)
 		return -ENOMEM;
 	new_op->upcall.req.getattr.refn = orangefs_inode->refn;
-	new_op->upcall.req.getattr.mask = ORANGEFS_ATTR_SYS_ALL_NOHINT;
+	/*
+	 * Size is the hardest attribute to get.  The incremental cost of any
+	 * other attribute is essentially zero.
+	 */
+	if (request_mask & STATX_SIZE || new)
+		new_op->upcall.req.getattr.mask = ORANGEFS_ATTR_SYS_ALL_NOHINT;
+	else
+		new_op->upcall.req.getattr.mask =
+		    ORANGEFS_ATTR_SYS_ALL_NOHINT & ~ORANGEFS_ATTR_SYS_SIZE;
 
 	ret = service_operation(new_op, __func__,
 	    get_interruptible_flag(inode));
@@ -291,25 +306,29 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass)
 	case S_IFREG:
 		inode->i_flags = orangefs_inode_flags(&new_op->
 		    downcall.resp.getattr.attributes);
-		inode_size = (loff_t)new_op->
-		    downcall.resp.getattr.attributes.size;
-		rounded_up_size =
-		    (inode_size + (4096 - (inode_size % 4096)));
-		inode->i_size = inode_size;
-		orangefs_inode->blksize =
-		    new_op->downcall.resp.getattr.attributes.blksize;
-		spin_lock(&inode->i_lock);
-		inode->i_bytes = inode_size;
-		inode->i_blocks =
-		    (unsigned long)(rounded_up_size / 512);
-		spin_unlock(&inode->i_lock);
+		if (request_mask & STATX_SIZE || new) {
+			inode_size = (loff_t)new_op->
+			    downcall.resp.getattr.attributes.size;
+			rounded_up_size =
+			    (inode_size + (4096 - (inode_size % 4096)));
+			inode->i_size = inode_size;
+			orangefs_inode->blksize =
+			    new_op->downcall.resp.getattr.attributes.blksize;
+			spin_lock(&inode->i_lock);
+			inode->i_bytes = inode_size;
+			inode->i_blocks =
+			    (unsigned long)(rounded_up_size / 512);
+			spin_unlock(&inode->i_lock);
+		}
 		break;
 	case S_IFDIR:
-		inode->i_size = PAGE_SIZE;
-		orangefs_inode->blksize = i_blocksize(inode);
-		spin_lock(&inode->i_lock);
-		inode_set_bytes(inode, inode->i_size);
-		spin_unlock(&inode->i_lock);
+		if (request_mask & STATX_SIZE || new) {
+			inode->i_size = PAGE_SIZE;
+			orangefs_inode->blksize = i_blocksize(inode);
+			spin_lock(&inode->i_lock);
+			inode_set_bytes(inode, inode->i_size);
+			spin_unlock(&inode->i_lock);
+		}
 		set_nlink(inode, 1);
 		break;
 	case S_IFLNK:
@@ -349,6 +368,10 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass)
 
 	orangefs_inode->getattr_time = jiffies +
 	    orangefs_getattr_timeout_msecs*HZ/1000;
+	if (request_mask & STATX_SIZE || new)
+		orangefs_inode->getattr_mask = STATX_BASIC_STATS;
+	else
+		orangefs_inode->getattr_mask = STATX_BASIC_STATS & ~STATX_SIZE;
 	ret = 0;
 out:
 	op_release(new_op);

commit 93407472a21b82f39c955ea7787e5bc7da100642
Author: Fabian Frederick <fabf@skynet.be>
Date:   Mon Feb 27 14:28:32 2017 -0800

    fs: add i_blocksize()
    
    Replace all 1 << inode->i_blkbits and (1 << inode->i_blkbits) in fs
    branch.
    
    This patch also fixes multiple checkpatch warnings: WARNING: Prefer
    'unsigned int' to bare use of 'unsigned'
    
    Thanks to Andrew Morton for suggesting more appropriate function instead
    of macro.
    
    [geliangtang@gmail.com: truncate: use i_blocksize()]
      Link: http://lkml.kernel.org/r/9c8b2cd83c8f5653805d43debde9fa8817e02fc4.1484895804.git.geliangtang@gmail.com
    Link: http://lkml.kernel.org/r/1481319905-10126-1-git-send-email-fabf@skynet.be
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Geliang Tang <geliangtang@gmail.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 06af81f71e10..9b96b99539d6 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -306,7 +306,7 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass)
 		break;
 	case S_IFDIR:
 		inode->i_size = PAGE_SIZE;
-		orangefs_inode->blksize = (1 << inode->i_blkbits);
+		orangefs_inode->blksize = i_blocksize(inode);
 		spin_lock(&inode->i_lock);
 		inode_set_bytes(inode, inode->i_size);
 		spin_unlock(&inode->i_lock);
@@ -316,7 +316,7 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass)
 		if (new) {
 			inode->i_size = (loff_t)strlen(new_op->
 			    downcall.resp.getattr.link_target);
-			orangefs_inode->blksize = (1 << inode->i_blkbits);
+			orangefs_inode->blksize = i_blocksize(inode);
 			ret = strscpy(orangefs_inode->link_target,
 			    new_op->downcall.resp.getattr.link_target,
 			    ORANGEFS_NAME_MAX);

commit 1d503617884ed43af1c03685e73ce23f155d3fa4
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Aug 16 11:38:14 2016 -0400

    orangefs: rename most remaining global variables
    
    Only op_timeout_secs, slot_timeout_secs, and hash_table_size are left
    because they are exposed as module parameters. All other global
    variables have the orangefs_ prefix.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index f7328f26cb00..06af81f71e10 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -347,7 +347,8 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass)
 	inode->i_mode = type | (is_root_handle(inode) ? S_ISVTX : 0) |
 	    orangefs_inode_perms(&new_op->downcall.resp.getattr.attributes);
 
-	orangefs_inode->getattr_time = jiffies + getattr_timeout_msecs*HZ/1000;
+	orangefs_inode->getattr_time = jiffies +
+	    orangefs_getattr_timeout_msecs*HZ/1000;
 	ret = 0;
 out:
 	op_release(new_op);

commit 44f4641073f132429e1e9a53412600206e8f7d06
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Aug 15 11:38:36 2016 -0400

    orangefs: clean up debugfs globals
    
    Mostly this is moving code into orangefs-debugfs.c so that globals turn
    into static globals.
    
    Then gossip_debug_mask is renamed orangefs_gossip_debug_mask but keeps
    global visibility, so it can be used from a macro.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 9a99285fe310..f7328f26cb00 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -656,401 +656,3 @@ __s32 ORANGEFS_util_translate_mode(int mode)
 	return ret;
 }
 #undef NUM_MODES
-
-/*
- * After obtaining a string representation of the client's debug
- * keywords and their associated masks, this function is called to build an
- * array of these values.
- */
-int orangefs_prepare_cdm_array(char *debug_array_string)
-{
-	int i;
-	int rc = -EINVAL;
-	char *cds_head = NULL;
-	char *cds_delimiter = NULL;
-	int keyword_len = 0;
-
-	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: start\n", __func__);
-
-	/*
-	 * figure out how many elements the cdm_array needs.
-	 */
-	for (i = 0; i < strlen(debug_array_string); i++)
-		if (debug_array_string[i] == '\n')
-			cdm_element_count++;
-
-	if (!cdm_element_count) {
-		pr_info("No elements in client debug array string!\n");
-		goto out;
-	}
-
-	cdm_array =
-		kzalloc(cdm_element_count * sizeof(struct client_debug_mask),
-			GFP_KERNEL);
-	if (!cdm_array) {
-		pr_info("malloc failed for cdm_array!\n");
-		rc = -ENOMEM;
-		goto out;
-	}
-
-	cds_head = debug_array_string;
-
-	for (i = 0; i < cdm_element_count; i++) {
-		cds_delimiter = strchr(cds_head, '\n');
-		*cds_delimiter = '\0';
-
-		keyword_len = strcspn(cds_head, " ");
-
-		cdm_array[i].keyword = kzalloc(keyword_len + 1, GFP_KERNEL);
-		if (!cdm_array[i].keyword) {
-			rc = -ENOMEM;
-			goto out;
-		}
-
-		sscanf(cds_head,
-		       "%s %llx %llx",
-		       cdm_array[i].keyword,
-		       (unsigned long long *)&(cdm_array[i].mask1),
-		       (unsigned long long *)&(cdm_array[i].mask2));
-
-		if (!strcmp(cdm_array[i].keyword, ORANGEFS_VERBOSE))
-			client_verbose_index = i;
-
-		if (!strcmp(cdm_array[i].keyword, ORANGEFS_ALL))
-			client_all_index = i;
-
-		cds_head = cds_delimiter + 1;
-	}
-
-	rc = cdm_element_count;
-
-	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: rc:%d:\n", __func__, rc);
-
-out:
-
-	return rc;
-
-}
-
-/*
- * /sys/kernel/debug/orangefs/debug-help can be catted to
- * see all the available kernel and client debug keywords.
- *
- * When the kernel boots, we have no idea what keywords the
- * client supports, nor their associated masks.
- *
- * We pass through this function once at boot and stamp a
- * boilerplate "we don't know" message for the client in the
- * debug-help file. We pass through here again when the client
- * starts and then we can fill out the debug-help file fully.
- *
- * The client might be restarted any number of times between
- * reboots, we only build the debug-help file the first time.
- */
-int orangefs_prepare_debugfs_help_string(int at_boot)
-{
-	int rc = -EINVAL;
-	int i;
-	int byte_count = 0;
-	char *client_title = "Client Debug Keywords:\n";
-	char *kernel_title = "Kernel Debug Keywords:\n";
-
-	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: start\n", __func__);
-
-	if (at_boot) {
-		byte_count += strlen(HELP_STRING_UNINITIALIZED);
-		client_title = HELP_STRING_UNINITIALIZED;
-	} else {
-		/*
-		 * fill the client keyword/mask array and remember
-		 * how many elements there were.
-		 */
-		cdm_element_count =
-			orangefs_prepare_cdm_array(client_debug_array_string);
-		if (cdm_element_count <= 0)
-			goto out;
-
-		/* Count the bytes destined for debug_help_string. */
-		byte_count += strlen(client_title);
-
-		for (i = 0; i < cdm_element_count; i++) {
-			byte_count += strlen(cdm_array[i].keyword + 2);
-			if (byte_count >= DEBUG_HELP_STRING_SIZE) {
-				pr_info("%s: overflow 1!\n", __func__);
-				goto out;
-			}
-		}
-
-		gossip_debug(GOSSIP_UTILS_DEBUG,
-			     "%s: cdm_element_count:%d:\n",
-			     __func__,
-			     cdm_element_count);
-	}
-
-	byte_count += strlen(kernel_title);
-	for (i = 0; i < num_kmod_keyword_mask_map; i++) {
-		byte_count +=
-			strlen(s_kmod_keyword_mask_map[i].keyword + 2);
-		if (byte_count >= DEBUG_HELP_STRING_SIZE) {
-			pr_info("%s: overflow 2!\n", __func__);
-			goto out;
-		}
-	}
-
-	/* build debug_help_string. */
-	debug_help_string = kzalloc(DEBUG_HELP_STRING_SIZE, GFP_KERNEL);
-	if (!debug_help_string) {
-		rc = -ENOMEM;
-		goto out;
-	}
-
-	strcat(debug_help_string, client_title);
-
-	if (!at_boot) {
-		for (i = 0; i < cdm_element_count; i++) {
-			strcat(debug_help_string, "\t");
-			strcat(debug_help_string, cdm_array[i].keyword);
-			strcat(debug_help_string, "\n");
-		}
-	}
-
-	strcat(debug_help_string, "\n");
-	strcat(debug_help_string, kernel_title);
-
-	for (i = 0; i < num_kmod_keyword_mask_map; i++) {
-		strcat(debug_help_string, "\t");
-		strcat(debug_help_string, s_kmod_keyword_mask_map[i].keyword);
-		strcat(debug_help_string, "\n");
-	}
-
-	rc = 0;
-
-out:
-
-	return rc;
-
-}
-
-/*
- * kernel = type 0
- * client = type 1
- */
-void debug_mask_to_string(void *mask, int type)
-{
-	int i;
-	int len = 0;
-	char *debug_string;
-	int element_count = 0;
-
-	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: start\n", __func__);
-
-	if (type) {
-		debug_string = client_debug_string;
-		element_count = cdm_element_count;
-	} else {
-		debug_string = kernel_debug_string;
-		element_count = num_kmod_keyword_mask_map;
-	}
-
-	memset(debug_string, 0, ORANGEFS_MAX_DEBUG_STRING_LEN);
-
-	/*
-	 * Some keywords, like "all" or "verbose", are amalgams of
-	 * numerous other keywords. Make a special check for those
-	 * before grinding through the whole mask only to find out
-	 * later...
-	 */
-	if (check_amalgam_keyword(mask, type))
-		goto out;
-
-	/* Build the debug string. */
-	for (i = 0; i < element_count; i++)
-		if (type)
-			do_c_string(mask, i);
-		else
-			do_k_string(mask, i);
-
-	len = strlen(debug_string);
-
-	if ((len) && (type))
-		client_debug_string[len - 1] = '\0';
-	else if (len)
-		kernel_debug_string[len - 1] = '\0';
-	else if (type)
-		strcpy(client_debug_string, "none");
-	else
-		strcpy(kernel_debug_string, "none");
-
-out:
-gossip_debug(GOSSIP_UTILS_DEBUG, "%s: string:%s:\n", __func__, debug_string);
-
-	return;
-
-}
-
-void do_k_string(void *k_mask, int index)
-{
-	__u64 *mask = (__u64 *) k_mask;
-
-	if (keyword_is_amalgam((char *) s_kmod_keyword_mask_map[index].keyword))
-		goto out;
-
-	if (*mask & s_kmod_keyword_mask_map[index].mask_val) {
-		if ((strlen(kernel_debug_string) +
-		     strlen(s_kmod_keyword_mask_map[index].keyword))
-			< ORANGEFS_MAX_DEBUG_STRING_LEN - 1) {
-				strcat(kernel_debug_string,
-				       s_kmod_keyword_mask_map[index].keyword);
-				strcat(kernel_debug_string, ",");
-			} else {
-				gossip_err("%s: overflow!\n", __func__);
-				strcpy(kernel_debug_string, ORANGEFS_ALL);
-				goto out;
-			}
-	}
-
-out:
-
-	return;
-}
-
-void do_c_string(void *c_mask, int index)
-{
-	struct client_debug_mask *mask = (struct client_debug_mask *) c_mask;
-
-	if (keyword_is_amalgam(cdm_array[index].keyword))
-		goto out;
-
-	if ((mask->mask1 & cdm_array[index].mask1) ||
-	    (mask->mask2 & cdm_array[index].mask2)) {
-		if ((strlen(client_debug_string) +
-		     strlen(cdm_array[index].keyword) + 1)
-			< ORANGEFS_MAX_DEBUG_STRING_LEN - 2) {
-				strcat(client_debug_string,
-				       cdm_array[index].keyword);
-				strcat(client_debug_string, ",");
-			} else {
-				gossip_err("%s: overflow!\n", __func__);
-				strcpy(client_debug_string, ORANGEFS_ALL);
-				goto out;
-			}
-	}
-out:
-	return;
-}
-
-int keyword_is_amalgam(char *keyword)
-{
-	int rc = 0;
-
-	if ((!strcmp(keyword, ORANGEFS_ALL)) || (!strcmp(keyword, ORANGEFS_VERBOSE)))
-		rc = 1;
-
-	return rc;
-}
-
-/*
- * kernel = type 0
- * client = type 1
- *
- * return 1 if we found an amalgam.
- */
-int check_amalgam_keyword(void *mask, int type)
-{
-	__u64 *k_mask;
-	struct client_debug_mask *c_mask;
-	int k_all_index = num_kmod_keyword_mask_map - 1;
-	int rc = 0;
-
-	if (type) {
-		c_mask = (struct client_debug_mask *) mask;
-
-		if ((c_mask->mask1 == cdm_array[client_all_index].mask1) &&
-		    (c_mask->mask2 == cdm_array[client_all_index].mask2)) {
-			strcpy(client_debug_string, ORANGEFS_ALL);
-			rc = 1;
-			goto out;
-		}
-
-		if ((c_mask->mask1 == cdm_array[client_verbose_index].mask1) &&
-		    (c_mask->mask2 == cdm_array[client_verbose_index].mask2)) {
-			strcpy(client_debug_string, ORANGEFS_VERBOSE);
-			rc = 1;
-			goto out;
-		}
-
-	} else {
-		k_mask = (__u64 *) mask;
-
-		if (*k_mask >= s_kmod_keyword_mask_map[k_all_index].mask_val) {
-			strcpy(kernel_debug_string, ORANGEFS_ALL);
-			rc = 1;
-			goto out;
-		}
-	}
-
-out:
-
-	return rc;
-}
-
-/*
- * kernel = type 0
- * client = type 1
- */
-void debug_string_to_mask(char *debug_string, void *mask, int type)
-{
-	char *unchecked_keyword;
-	int i;
-	char *strsep_fodder = kstrdup(debug_string, GFP_KERNEL);
-	char *original_pointer;
-	int element_count = 0;
-	struct client_debug_mask *c_mask;
-	__u64 *k_mask;
-
-	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: start\n", __func__);
-
-	if (type) {
-		c_mask = (struct client_debug_mask *)mask;
-		element_count = cdm_element_count;
-	} else {
-		k_mask = (__u64 *)mask;
-		*k_mask = 0;
-		element_count = num_kmod_keyword_mask_map;
-	}
-
-	original_pointer = strsep_fodder;
-	while ((unchecked_keyword = strsep(&strsep_fodder, ",")))
-		if (strlen(unchecked_keyword)) {
-			for (i = 0; i < element_count; i++)
-				if (type)
-					do_c_mask(i,
-						  unchecked_keyword,
-						  &c_mask);
-				else
-					do_k_mask(i,
-						  unchecked_keyword,
-						  &k_mask);
-		}
-
-	kfree(original_pointer);
-}
-
-void do_c_mask(int i,
-	       char *unchecked_keyword,
-	       struct client_debug_mask **sane_mask)
-{
-
-	if (!strcmp(cdm_array[i].keyword, unchecked_keyword)) {
-		(**sane_mask).mask1 = (**sane_mask).mask1 | cdm_array[i].mask1;
-		(**sane_mask).mask2 = (**sane_mask).mask2 | cdm_array[i].mask2;
-	}
-}
-
-void do_k_mask(int i, char *unchecked_keyword, __u64 **sane_mask)
-{
-
-	if (!strcmp(s_kmod_keyword_mask_map[i].keyword, unchecked_keyword))
-		**sane_mask = (**sane_mask) |
-				s_kmod_keyword_mask_map[i].mask_val;
-}

commit 6eaff8c7775abcdff5ba7c9f0305f4ccdca57ba5
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Aug 2 14:31:05 2016 -0400

    orangefs: rename remaining bits of mmap readahead cache
    
    This has been dormant code for many years. Parts of it were removed from
    the OrangeFS kernel code when it went into mainline. These bits were missed.
    Now the readahead cache has been resurrected in the OrangeFS userspace
    portions. It was renamed there, since it doesn't really have anything to do
    with mmap specifically, so it will be renamed here.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index d13c7291fd05..9a99285fe310 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -50,7 +50,7 @@ __s32 fsid_of_op(struct orangefs_kernel_op_s *op)
 		case ORANGEFS_VFS_OP_TRUNCATE:
 			fsid = op->upcall.req.truncate.refn.fs_id;
 			break;
-		case ORANGEFS_VFS_OP_MMAP_RA_FLUSH:
+		case ORANGEFS_VFS_OP_RA_FLUSH:
 			fsid = op->upcall.req.ra_cache_flush.refn.fs_id;
 			break;
 		case ORANGEFS_VFS_OP_FS_UMOUNT:

commit 8bbb20a863ca72dfb9025a4653f21b5abf926d20
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Jul 28 14:46:36 2016 -0400

    orangefs: Account for jiffies wraparound.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index cd512a3a9c52..d13c7291fd05 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -262,7 +262,7 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass)
 	    get_khandle_from_ino(inode));
 
 	if (!new && !bypass) {
-		if (orangefs_inode->getattr_time > jiffies)
+		if (time_before(jiffies, orangefs_inode->getattr_time))
 			return 0;
 	}
 
@@ -421,7 +421,7 @@ int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr)
 		ClearMtimeFlag(orangefs_inode);
 		ClearCtimeFlag(orangefs_inode);
 		ClearModeFlag(orangefs_inode);
-		orangefs_inode->getattr_time = 0;
+		orangefs_inode->getattr_time = jiffies - 1;
 	}
 
 	return ret;

commit 4cd8f319441a323280eaa0acf390ffb18c64d86b
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Jul 25 13:58:24 2016 -0400

    orangefs: Allow dcache and getattr cache time to be configured.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 69b4d8af8d81..cd512a3a9c52 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -347,7 +347,7 @@ int orangefs_inode_getattr(struct inode *inode, int new, int bypass)
 	inode->i_mode = type | (is_root_handle(inode) ? S_ISVTX : 0) |
 	    orangefs_inode_perms(&new_op->downcall.resp.getattr.attributes);
 
-	orangefs_inode->getattr_time = jiffies + HZ;
+	orangefs_inode->getattr_time = jiffies + getattr_timeout_msecs*HZ/1000;
 	ret = 0;
 out:
 	op_release(new_op);

commit 71680c18c8f22deafbaaf76d1c2d0eed2899a3d2
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Jun 9 16:32:38 2016 -0400

    orangefs: Cache getattr results.
    
    The userspace component attempts to do this, but this will prevent
    us from even needing to go into userspace to satisfy certain getattr
    requests.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index c5fbc62357c6..69b4d8af8d81 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -251,7 +251,7 @@ static int orangefs_inode_is_stale(struct inode *inode, int new,
 	return 0;
 }
 
-int orangefs_inode_getattr(struct inode *inode, int new, int size)
+int orangefs_inode_getattr(struct inode *inode, int new, int bypass)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_kernel_op_s *new_op;
@@ -261,12 +261,16 @@ int orangefs_inode_getattr(struct inode *inode, int new, int size)
 	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: called on inode %pU\n", __func__,
 	    get_khandle_from_ino(inode));
 
+	if (!new && !bypass) {
+		if (orangefs_inode->getattr_time > jiffies)
+			return 0;
+	}
+
 	new_op = op_alloc(ORANGEFS_VFS_OP_GETATTR);
 	if (!new_op)
 		return -ENOMEM;
 	new_op->upcall.req.getattr.refn = orangefs_inode->refn;
-	new_op->upcall.req.getattr.mask = size ?
-	    ORANGEFS_ATTR_SYS_ALL_NOHINT : ORANGEFS_ATTR_SYS_ALL_NOHINT_NOSIZE;
+	new_op->upcall.req.getattr.mask = ORANGEFS_ATTR_SYS_ALL_NOHINT;
 
 	ret = service_operation(new_op, __func__,
 	    get_interruptible_flag(inode));
@@ -287,20 +291,18 @@ int orangefs_inode_getattr(struct inode *inode, int new, int size)
 	case S_IFREG:
 		inode->i_flags = orangefs_inode_flags(&new_op->
 		    downcall.resp.getattr.attributes);
-		if (size) {
-			inode_size = (loff_t)new_op->
-			    downcall.resp.getattr.attributes.size;
-			rounded_up_size =
-			    (inode_size + (4096 - (inode_size % 4096)));
-			inode->i_size = inode_size;
-			orangefs_inode->blksize =
-			    new_op->downcall.resp.getattr.attributes.blksize;
-			spin_lock(&inode->i_lock);
-			inode->i_bytes = inode_size;
-			inode->i_blocks =
-			    (unsigned long)(rounded_up_size / 512);
-			spin_unlock(&inode->i_lock);
-		}
+		inode_size = (loff_t)new_op->
+		    downcall.resp.getattr.attributes.size;
+		rounded_up_size =
+		    (inode_size + (4096 - (inode_size % 4096)));
+		inode->i_size = inode_size;
+		orangefs_inode->blksize =
+		    new_op->downcall.resp.getattr.attributes.blksize;
+		spin_lock(&inode->i_lock);
+		inode->i_bytes = inode_size;
+		inode->i_blocks =
+		    (unsigned long)(rounded_up_size / 512);
+		spin_unlock(&inode->i_lock);
 		break;
 	case S_IFDIR:
 		inode->i_size = PAGE_SIZE;
@@ -345,6 +347,7 @@ int orangefs_inode_getattr(struct inode *inode, int new, int size)
 	inode->i_mode = type | (is_root_handle(inode) ? S_ISVTX : 0) |
 	    orangefs_inode_perms(&new_op->downcall.resp.getattr.attributes);
 
+	orangefs_inode->getattr_time = jiffies + HZ;
 	ret = 0;
 out:
 	op_release(new_op);
@@ -418,6 +421,7 @@ int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr)
 		ClearMtimeFlag(orangefs_inode);
 		ClearCtimeFlag(orangefs_inode);
 		ClearModeFlag(orangefs_inode);
+		orangefs_inode->getattr_time = 0;
 	}
 
 	return ret;

commit 78fee0b6846f27872321338db6afe280f059ae99
Author: Jann Horn <jannh@google.com>
Date:   Sat Jun 25 01:51:52 2016 +0200

    orangefs: fix namespace handling
    
    In orangefs_inode_getxattr(), an fsuid is written to dmesg. The kuid is
    converted to a userspace uid via from_kuid(current_user_ns(), [...]), but
    since dmesg is global, init_user_ns should be used here instead.
    
    In copy_attributes_from_inode(), op_alloc() and fill_default_sys_attrs(),
    upcall structures are populated with uids/gids that have been mapped into
    the caller's namespace. However, those upcall structures are read by
    another process (the userspace filesystem driver), and that process might
    be running in another namespace. This effectively lets any user spoof its
    uid and gid as seen by the userspace filesystem driver.
    
    To fix the second issue, I just construct the opcall structures with
    init_user_ns uids/gids and require the filesystem server to run in the
    init namespace. Since orangefs is full of global state anyway (as the error
    message in DUMP_DEVICE_ERROR explains, there can only be one userspace
    orangefs filesystem driver at once), that shouldn't be a problem.
    
    [
    Why does orangefs even exist in the kernel if everything does upcalls into
    userspace? What does orangefs do that couldn't be done with the FUSE
    interface? If there is no good answer to those questions, I'd prefer to see
    orangefs kicked out of the kernel. Can that be done for something that
    shipped in a release?
    
    According to commit f7ab093f74bf ("Orangefs: kernel client part 1"), they
    even already have a FUSE daemon, and the only rational reason (apart from
    "but most of our users report preferring to use our kernel module instead")
    given for not wanting to use FUSE is one "in-the-works" feature that could
    probably be integated into FUSE instead.
    ]
    
    This patch has been compile-tested.
    
    Signed-off-by: Jann Horn <jannh@google.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 2d129b5886ee..c5fbc62357c6 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -153,12 +153,12 @@ static inline int copy_attributes_from_inode(struct inode *inode,
 	 */
 	attrs->mask = 0;
 	if (iattr->ia_valid & ATTR_UID) {
-		attrs->owner = from_kuid(current_user_ns(), iattr->ia_uid);
+		attrs->owner = from_kuid(&init_user_ns, iattr->ia_uid);
 		attrs->mask |= ORANGEFS_ATTR_SYS_UID;
 		gossip_debug(GOSSIP_UTILS_DEBUG, "(UID) %d\n", attrs->owner);
 	}
 	if (iattr->ia_valid & ATTR_GID) {
-		attrs->group = from_kgid(current_user_ns(), iattr->ia_gid);
+		attrs->group = from_kgid(&init_user_ns, iattr->ia_gid);
 		attrs->mask |= ORANGEFS_ATTR_SYS_GID;
 		gossip_debug(GOSSIP_UTILS_DEBUG, "(GID) %d\n", attrs->group);
 	}

commit 6759212640fda202d0da5ce2f75dd261f1b879cc
Merge: 1a59c53920ee e56f49814250
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 9 10:33:58 2016 -0700

    Merge tag 'for-linus-4.6-ofs1' of git://git.kernel.org/pub/scm/linux/kernel/git/hubcap/linux
    
    Pull orangefs fixes from Mike Marshall:
     "Orangefs cleanups and a strncpy vulnerability fix.
    
      Cleanups:
       - remove an unused variable from orangefs_readdir.
       - clean up printk wrapper used for ofs "gossip" debugging.
       - clean up truncate ctime and mtime setting in inode.c
       - remove a useless null check found by coccinelle.
       - optimize some memcpy/memset boilerplate code.
       - remove some useless sanity checks from xattr.c
    
      Fix:
       - fix a potential strncpy vulnerability"
    
    * tag 'for-linus-4.6-ofs1' of git://git.kernel.org/pub/scm/linux/kernel/git/hubcap/linux:
      orangefs: remove unused variable
      orangefs: Add KERN_<LEVEL> to gossip_<level> macros
      orangefs: strncpy -> strscpy
      orangefs: clean up truncate ctime and mtime setting
      Orangefs: fix ifnullfree.cocci warnings
      Orangefs: optimize boilerplate code.
      Orangefs: xattr.c cleanup

commit 2eacea74cc465edc23ce5a4dd5c2213008ac3a05
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Apr 8 13:33:21 2016 -0400

    orangefs: strncpy -> strscpy
    
    It would have been possible for a rogue client-core to send in a symlink
    target which is not NUL terminated. This returns EIO if the client-core
    gives us corrupt data.
    
    Leave debugfs and superblock code as is for now.
    
    Other dcache.c and namei.c strncpy instances are safe because
    ORANGEFS_NAME_MAX = NAME_MAX + 1; there is always enough space for a
    name plus a NUL byte.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 40f5163b56aa..f392a6a362b4 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -315,9 +315,13 @@ int orangefs_inode_getattr(struct inode *inode, int new, int size)
 			inode->i_size = (loff_t)strlen(new_op->
 			    downcall.resp.getattr.link_target);
 			orangefs_inode->blksize = (1 << inode->i_blkbits);
-			strlcpy(orangefs_inode->link_target,
+			ret = strscpy(orangefs_inode->link_target,
 			    new_op->downcall.resp.getattr.link_target,
 			    ORANGEFS_NAME_MAX);
+			if (ret == -E2BIG) {
+				ret = -EIO;
+				goto out;
+			}
 			inode->i_link = orangefs_inode->link_target;
 		}
 		break;

commit 09cbfeaf1a5a67bfb3201e0c83c810cecb2efa5a
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Fri Apr 1 15:29:47 2016 +0300

    mm, fs: get rid of PAGE_CACHE_* and page_cache_{get,release} macros
    
    PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} macros were introduced *long* time
    ago with promise that one day it will be possible to implement page
    cache with bigger chunks than PAGE_SIZE.
    
    This promise never materialized.  And unlikely will.
    
    We have many places where PAGE_CACHE_SIZE assumed to be equal to
    PAGE_SIZE.  And it's constant source of confusion on whether
    PAGE_CACHE_* or PAGE_* constant should be used in a particular case,
    especially on the border between fs and mm.
    
    Global switching to PAGE_CACHE_SIZE != PAGE_SIZE would cause to much
    breakage to be doable.
    
    Let's stop pretending that pages in page cache are special.  They are
    not.
    
    The changes are pretty straight-forward:
    
     - <foo> << (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - <foo> >> (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} -> PAGE_{SIZE,SHIFT,MASK,ALIGN};
    
     - page_cache_get() -> get_page();
    
     - page_cache_release() -> put_page();
    
    This patch contains automated changes generated with coccinelle using
    script below.  For some reason, coccinelle doesn't patch header files.
    I've called spatch for them manually.
    
    The only adjustment after coccinelle is revert of changes to
    PAGE_CAHCE_ALIGN definition: we are going to drop it later.
    
    There are few places in the code where coccinelle didn't reach.  I'll
    fix them manually in a separate patch.  Comments and documentation also
    will be addressed with the separate patch.
    
    virtual patch
    
    @@
    expression E;
    @@
    - E << (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    expression E;
    @@
    - E >> (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    @@
    - PAGE_CACHE_SHIFT
    + PAGE_SHIFT
    
    @@
    @@
    - PAGE_CACHE_SIZE
    + PAGE_SIZE
    
    @@
    @@
    - PAGE_CACHE_MASK
    + PAGE_MASK
    
    @@
    expression E;
    @@
    - PAGE_CACHE_ALIGN(E)
    + PAGE_ALIGN(E)
    
    @@
    expression E;
    @@
    - page_cache_get(E)
    + get_page(E)
    
    @@
    expression E;
    @@
    - page_cache_release(E)
    + put_page(E)
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 40f5163b56aa..8277aba65e87 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -303,7 +303,7 @@ int orangefs_inode_getattr(struct inode *inode, int new, int size)
 		}
 		break;
 	case S_IFDIR:
-		inode->i_size = PAGE_CACHE_SIZE;
+		inode->i_size = PAGE_SIZE;
 		orangefs_inode->blksize = (1 << inode->i_blkbits);
 		spin_lock(&inode->i_lock);
 		inode_set_bytes(inode, inode->i_size);

commit e8da254c415475d3df67966a198523bfe3ac0576
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Mar 18 14:20:15 2016 -0400

    orangefs: move code which sets i_link to orangefs_inode_getattr
    
    Everything else setting inode->i_ values is in there.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 36ee30d1f0ad..40f5163b56aa 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -318,6 +318,7 @@ int orangefs_inode_getattr(struct inode *inode, int new, int size)
 			strlcpy(orangefs_inode->link_target,
 			    new_op->downcall.resp.getattr.link_target,
 			    ORANGEFS_NAME_MAX);
+			inode->i_link = orangefs_inode->link_target;
 		}
 		break;
 	}

commit 266626339b688e650f4197fb8e54532581e18cae
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Mar 17 16:01:52 2016 -0400

    orangefs: refactor inode type or link_target change detection
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 6643a6a87fa1..36ee30d1f0ad 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -228,12 +228,35 @@ static int orangefs_inode_type(enum orangefs_ds_type objtype)
 		return -1;
 }
 
+static int orangefs_inode_is_stale(struct inode *inode, int new,
+    struct ORANGEFS_sys_attr_s *attrs, char *link_target)
+{
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	int type = orangefs_inode_type(attrs->objtype);
+	if (!new) {
+		/*
+		 * If the inode type or symlink target have changed then this
+		 * inode is stale.
+		 */
+		if (type == -1 || !(inode->i_mode & type)) {
+			orangefs_make_bad_inode(inode);
+			return 1;
+		}
+		if (type == S_IFLNK && strncmp(orangefs_inode->link_target,
+		    link_target, ORANGEFS_NAME_MAX)) {
+			orangefs_make_bad_inode(inode);
+			return 1;
+		}
+	}
+	return 0;
+}
+
 int orangefs_inode_getattr(struct inode *inode, int new, int size)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_kernel_op_s *new_op;
 	loff_t inode_size, rounded_up_size;
-	int ret;
+	int ret, type;
 
 	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: called on inode %pU\n", __func__,
 	    get_khandle_from_ino(inode));
@@ -250,28 +273,17 @@ int orangefs_inode_getattr(struct inode *inode, int new, int size)
 	if (ret != 0)
 		goto out;
 
-	ret = orangefs_inode_type(new_op->
+	type = orangefs_inode_type(new_op->
 	    downcall.resp.getattr.attributes.objtype);
-	if (!new) {
-		/*
-		 * If the inode type or symlink target have changed then this
-		 * inode is stale.
-		 */
-		if (ret == -1 || !(inode->i_mode & ret)) {
-			orangefs_make_bad_inode(inode);
-			ret = -ESTALE;
-			goto out;
-		}
-		if (ret == S_IFLNK && strncmp(orangefs_inode->link_target,
-		    new_op->downcall.resp.getattr.link_target,
-		    ORANGEFS_NAME_MAX)) {
-			orangefs_make_bad_inode(inode);
-			ret = -ESTALE;
-			goto out;
-		}
+	ret = orangefs_inode_is_stale(inode, new,
+	    &new_op->downcall.resp.getattr.attributes,
+	    new_op->downcall.resp.getattr.link_target);
+	if (ret) {
+		ret = -ESTALE;
+		goto out;
 	}
 
-	switch (ret) {
+	switch (type) {
 	case S_IFREG:
 		inode->i_flags = orangefs_inode_flags(&new_op->
 		    downcall.resp.getattr.attributes);
@@ -325,7 +337,7 @@ int orangefs_inode_getattr(struct inode *inode, int new, int size)
 	inode->i_ctime.tv_nsec = 0;
 
 	/* special case: mark the root inode as sticky */
-	inode->i_mode = ret | (is_root_handle(inode) ? S_ISVTX : 0) |
+	inode->i_mode = type | (is_root_handle(inode) ? S_ISVTX : 0) |
 	    orangefs_inode_perms(&new_op->downcall.resp.getattr.attributes);
 
 	ret = 0;
@@ -355,26 +367,9 @@ int orangefs_inode_check_changed(struct inode *inode)
 	if (ret != 0)
 		goto out;
 
-	ret = orangefs_inode_type(new_op->
-	    downcall.resp.getattr.attributes.objtype);
-	/*
-	 * If the inode type or symlink target have changed then this
-	 * inode is stale.
-	 */
-	if (ret == -1 || !(inode->i_mode & ret)) {
-		orangefs_make_bad_inode(inode);
-		ret = 1;
-		goto out;
-	}
-	if (ret == S_IFLNK && strncmp(orangefs_inode->link_target,
-	    new_op->downcall.resp.getattr.link_target,
-	    ORANGEFS_NAME_MAX)) {
-		orangefs_make_bad_inode(inode);
-		ret = 1;
-		goto out;
-	}
-
-	ret = 0;
+	ret = orangefs_inode_is_stale(inode, 0,
+	    &new_op->downcall.resp.getattr.attributes,
+	    new_op->downcall.resp.getattr.link_target);
 out:
 	op_release(new_op);
 	return ret;

commit 5859d77e56e470ba16960befcd948c97a6f62102
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Mar 17 15:15:16 2016 -0400

    orangefs: use new getattr for revalidate and remove old getattr
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 59c51e2c5a71..6643a6a87fa1 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -129,141 +129,6 @@ static int orangefs_inode_perms(struct ORANGEFS_sys_attr_s *attrs)
 	return perm_mode;
 }
 
-/* NOTE: symname is ignored unless the inode is a sym link */
-static int copy_attributes_to_inode(struct inode *inode,
-				    struct ORANGEFS_sys_attr_s *attrs,
-				    char *symname)
-{
-	int ret = -1;
-	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
-	loff_t inode_size = 0;
-	loff_t rounded_up_size = 0;
-
-
-	/*
-	 * arbitrarily set the inode block size; FIXME: we need to
-	 * resolve the difference between the reported inode blocksize
-	 * and the PAGE_CACHE_SIZE, since our block count will always
-	 * be wrong.
-	 *
-	 * For now, we're setting the block count to be the proper
-	 * number assuming the block size is 512 bytes, and the size is
-	 * rounded up to the nearest 4K.  This is apparently required
-	 * to get proper size reports from the 'du' shell utility.
-	 *
-	 * changing the inode->i_blkbits to something other than
-	 * PAGE_CACHE_SHIFT breaks mmap/execution as we depend on that.
-	 */
-	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "attrs->mask = %x (objtype = %s)\n",
-		     attrs->mask,
-		     attrs->objtype == ORANGEFS_TYPE_METAFILE ? "file" :
-		     attrs->objtype == ORANGEFS_TYPE_DIRECTORY ? "directory" :
-		     attrs->objtype == ORANGEFS_TYPE_SYMLINK ? "symlink" :
-			"invalid/unknown");
-
-	switch (attrs->objtype) {
-	case ORANGEFS_TYPE_METAFILE:
-		inode->i_flags = orangefs_inode_flags(attrs);
-		if (attrs->mask & ORANGEFS_ATTR_SYS_SIZE) {
-			inode_size = (loff_t) attrs->size;
-			rounded_up_size =
-			    (inode_size + (4096 - (inode_size % 4096)));
-
-			spin_lock(&inode->i_lock);
-			inode->i_bytes = inode_size;
-			inode->i_blocks =
-			    (unsigned long)(rounded_up_size / 512);
-			spin_unlock(&inode->i_lock);
-
-			/*
-			 * NOTE: make sure all the places we're called
-			 * from have the inode->i_sem lock. We're fine
-			 * in 99% of the cases since we're mostly
-			 * called from a lookup.
-			 */
-			inode->i_size = inode_size;
-		}
-		break;
-	case ORANGEFS_TYPE_SYMLINK:
-		if (symname != NULL) {
-			inode->i_size = (loff_t) strlen(symname);
-			break;
-		}
-		/*FALLTHRU*/
-	default:
-		inode->i_size = PAGE_CACHE_SIZE;
-
-		spin_lock(&inode->i_lock);
-		inode_set_bytes(inode, inode->i_size);
-		spin_unlock(&inode->i_lock);
-		break;
-	}
-
-	inode->i_uid = make_kuid(&init_user_ns, attrs->owner);
-	inode->i_gid = make_kgid(&init_user_ns, attrs->group);
-	inode->i_atime.tv_sec = (time64_t) attrs->atime;
-	inode->i_mtime.tv_sec = (time64_t) attrs->mtime;
-	inode->i_ctime.tv_sec = (time64_t) attrs->ctime;
-	inode->i_atime.tv_nsec = 0;
-	inode->i_mtime.tv_nsec = 0;
-	inode->i_ctime.tv_nsec = 0;
-
-	inode->i_mode = orangefs_inode_perms(attrs);
-
-	if (is_root_handle(inode)) {
-		/* special case: mark the root inode as sticky */
-		inode->i_mode |= S_ISVTX;
-		gossip_debug(GOSSIP_UTILS_DEBUG,
-			     "Marking inode %pU as sticky\n",
-			     get_khandle_from_ino(inode));
-	}
-
-	switch (attrs->objtype) {
-	case ORANGEFS_TYPE_METAFILE:
-		inode->i_mode |= S_IFREG;
-		ret = 0;
-		break;
-	case ORANGEFS_TYPE_DIRECTORY:
-		inode->i_mode |= S_IFDIR;
-		/* NOTE: we have no good way to keep nlink consistent
-		 * for directories across clients; keep constant at 1.
-		 * Why 1?  If we go with 2, then find(1) gets confused
-		 * and won't work properly withouth the -noleaf option
-		 */
-		set_nlink(inode, 1);
-		ret = 0;
-		break;
-	case ORANGEFS_TYPE_SYMLINK:
-		inode->i_mode |= S_IFLNK;
-
-		/* copy link target to inode private data */
-		if (orangefs_inode && symname) {
-			strncpy(orangefs_inode->link_target,
-				symname,
-				ORANGEFS_NAME_MAX);
-			gossip_debug(GOSSIP_UTILS_DEBUG,
-				     "Copied attr link target %s\n",
-				     orangefs_inode->link_target);
-		}
-		gossip_debug(GOSSIP_UTILS_DEBUG,
-			     "symlink mode %o\n",
-			     inode->i_mode);
-		ret = 0;
-		break;
-	default:
-		gossip_err("orangefs: copy_attributes_to_inode: got invalid attribute type %x\n",
-			attrs->objtype);
-	}
-
-	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "orangefs: copy_attributes_to_inode: setting i_mode to %o, i_size to %lu\n",
-		     inode->i_mode,
-		     (unsigned long)i_size_read(inode));
-
-	return ret;
-}
-
 /*
  * NOTE: in kernel land, we never use the sys_attr->link_target for
  * anything, so don't bother copying it into the sys_attr object here.
@@ -351,192 +216,6 @@ static inline int copy_attributes_from_inode(struct inode *inode,
 	return 0;
 }
 
-static int compare_attributes_to_inode(struct inode *inode,
-				       struct ORANGEFS_sys_attr_s *attrs,
-				       char *symname,
-				       int mask)
-{
-	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
-	loff_t inode_size, rounded_up_size;
-
-	/* Much of what happens below relies on the type being around. */
-	if (!(mask & ORANGEFS_ATTR_SYS_TYPE))
-		return 0;
-
-	if (attrs->objtype == ORANGEFS_TYPE_METAFILE &&
-	    inode->i_flags != orangefs_inode_flags(attrs))
-		return 0;
-
-	/* Compare file size. */
-
-	switch (attrs->objtype) {
-	case ORANGEFS_TYPE_METAFILE:
-		if (mask & ORANGEFS_ATTR_SYS_SIZE) {
-			inode_size = attrs->size;
-			rounded_up_size = inode_size +
-			    (4096 - (inode_size % 4096));
-			if (inode->i_bytes != inode_size ||
-			    inode->i_blocks != rounded_up_size/512)
-				return 0;
-		}
-		break;
-	case ORANGEFS_TYPE_SYMLINK:
-		if (mask & ORANGEFS_ATTR_SYS_SIZE)
-			if (symname && strlen(symname) != inode->i_size)
-				return 0;
-		break;
-	default:
-		if (inode->i_size != PAGE_CACHE_SIZE &&
-		    inode_get_bytes(inode) != PAGE_CACHE_SIZE)
-			return 0;
-	}
-
-	/* Compare general attributes. */
-
-	if (mask & ORANGEFS_ATTR_SYS_UID &&
-	    !uid_eq(inode->i_uid, make_kuid(&init_user_ns, attrs->owner)))
-		return 0;
-	if (mask & ORANGEFS_ATTR_SYS_GID &&
-	    !gid_eq(inode->i_gid, make_kgid(&init_user_ns, attrs->group)))
-		return 0;
-	if (mask & ORANGEFS_ATTR_SYS_ATIME &&
-	    inode->i_atime.tv_sec != attrs->atime)
-		return 0;
-	if (mask & ORANGEFS_ATTR_SYS_MTIME &&
-	    inode->i_atime.tv_sec != attrs->mtime)
-		return 0;
-	if (mask & ORANGEFS_ATTR_SYS_CTIME &&
-	    inode->i_atime.tv_sec != attrs->ctime)
-		return 0;
-	if (inode->i_atime.tv_nsec != 0 ||
-	    inode->i_mtime.tv_nsec != 0 ||
-	    inode->i_ctime.tv_nsec != 0)
-		return 0;
-
-	if (mask & ORANGEFS_ATTR_SYS_PERM &&
-	    (inode->i_mode & ~(S_ISVTX|S_IFREG|S_IFDIR|S_IFLNK)) !=
-	    orangefs_inode_perms(attrs))
-		return 0;
-
-	if (is_root_handle(inode))
-		if (!(inode->i_mode & S_ISVTX))
-			return 0;
-
-	/* Compare file type. */
-
-	switch (attrs->objtype) {
-	case ORANGEFS_TYPE_METAFILE:
-		if (!S_ISREG(inode->i_mode))
-			return 0;
-		break;
-	case ORANGEFS_TYPE_DIRECTORY:
-		if (!S_ISDIR(inode->i_mode))
-			return 0;
-		if (inode->i_nlink != 1)
-			return 0;
-		break;
-	case ORANGEFS_TYPE_SYMLINK:
-		if (!S_ISLNK(inode->i_mode))
-			return 0;
-		if (orangefs_inode && symname &&
-		    mask & ORANGEFS_ATTR_SYS_LNK_TARGET)
-			if (strcmp(orangefs_inode->link_target, symname))
-				return 0;
-		break;
-	default:
-		gossip_err("orangefs: compare_attributes_to_inode: got invalid attribute type %x\n",
-		    attrs->objtype);
-
-	}
-
-	return 1;
-}
-
-/*
- * Issues a orangefs getattr request and fills in the appropriate inode
- * attributes if successful. When check is 0, returns 0 on success and -errno
- * otherwise. When check is 1, returns 1 on success where the inode is valid
- * and 0 on success where the inode is stale and -errno otherwise.
- */
-int orangefs_inode_old_getattr(struct inode *inode, __u32 getattr_mask,
-    int check)
-{
-	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
-	struct orangefs_kernel_op_s *new_op;
-	int ret = -EINVAL;
-
-	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "%s: called on inode %pU\n",
-		     __func__,
-		     get_khandle_from_ino(inode));
-
-	new_op = op_alloc(ORANGEFS_VFS_OP_GETATTR);
-	if (!new_op)
-		return -ENOMEM;
-	new_op->upcall.req.getattr.refn = orangefs_inode->refn;
-	new_op->upcall.req.getattr.mask = getattr_mask;
-
-	ret = service_operation(new_op, __func__,
-				get_interruptible_flag(inode));
-	if (ret != 0)
-		goto out;
-
-	if (check) {
-		ret = compare_attributes_to_inode(inode,
-		    &new_op->downcall.resp.getattr.attributes,
-		    new_op->downcall.resp.getattr.link_target,
-		    getattr_mask);
-
-		if (new_op->downcall.resp.getattr.attributes.objtype ==
-		    ORANGEFS_TYPE_METAFILE) {
-			if (orangefs_inode->blksize !=
-			    new_op->downcall.resp.getattr.attributes.blksize)
-				ret = 0;
-		} else {
-			if (orangefs_inode->blksize != 1 << inode->i_blkbits)
-				ret = 0;
-		}
-	} else {
-		if (copy_attributes_to_inode(inode,
-				&new_op->downcall.resp.getattr.attributes,
-				new_op->downcall.resp.getattr.link_target)) {
-			gossip_err("%s: failed to copy attributes\n", __func__);
-			ret = -ENOENT;
-			goto out;
-		}
-
-		/*
-		 * Store blksize in orangefs specific part of inode structure;
-		 * we are only going to use this to report to stat to make sure
-		 * it doesn't perturb any inode related code paths.
-		 */
-		if (new_op->downcall.resp.getattr.attributes.objtype ==
-				ORANGEFS_TYPE_METAFILE) {
-			orangefs_inode->blksize = new_op->downcall.resp.
-			    getattr.attributes.blksize;
-		} else {
-			/*
-			 * mimic behavior of generic_fillattr() for other file
-			 * types.
-			 */
-			orangefs_inode->blksize = (1 << inode->i_blkbits);
-
-		}
-	}
-
-out:
-	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "Getattr on handle %pU, "
-		     "fsid %d\n  (inode ct = %d) returned %d\n",
-		     &orangefs_inode->refn.khandle,
-		     orangefs_inode->refn.fs_id,
-		     (int)atomic_read(&inode->i_count),
-		     ret);
-
-	op_release(new_op);
-	return ret;
-}
-
 static int orangefs_inode_type(enum orangefs_ds_type objtype)
 {
 	if (objtype == ORANGEFS_TYPE_METAFILE)
@@ -655,6 +334,52 @@ int orangefs_inode_getattr(struct inode *inode, int new, int size)
 	return ret;
 }
 
+int orangefs_inode_check_changed(struct inode *inode)
+{
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_kernel_op_s *new_op;
+	int ret;
+
+	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: called on inode %pU\n", __func__,
+	    get_khandle_from_ino(inode));
+
+	new_op = op_alloc(ORANGEFS_VFS_OP_GETATTR);
+	if (!new_op)
+		return -ENOMEM;
+	new_op->upcall.req.getattr.refn = orangefs_inode->refn;
+	new_op->upcall.req.getattr.mask = ORANGEFS_ATTR_SYS_TYPE |
+	    ORANGEFS_ATTR_SYS_LNK_TARGET;
+
+	ret = service_operation(new_op, __func__,
+	    get_interruptible_flag(inode));
+	if (ret != 0)
+		goto out;
+
+	ret = orangefs_inode_type(new_op->
+	    downcall.resp.getattr.attributes.objtype);
+	/*
+	 * If the inode type or symlink target have changed then this
+	 * inode is stale.
+	 */
+	if (ret == -1 || !(inode->i_mode & ret)) {
+		orangefs_make_bad_inode(inode);
+		ret = 1;
+		goto out;
+	}
+	if (ret == S_IFLNK && strncmp(orangefs_inode->link_target,
+	    new_op->downcall.resp.getattr.link_target,
+	    ORANGEFS_NAME_MAX)) {
+		orangefs_make_bad_inode(inode);
+		ret = 1;
+		goto out;
+	}
+
+	ret = 0;
+out:
+	op_release(new_op);
+	return ret;
+}
+
 /*
  * issues a orangefs setattr request to make sure the new attribute values
  * take effect if successful.  returns 0 on success; -errno otherwise

commit 3c9cf98d7b4f27e4303ea6e67db7f0c343a575b6
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Tue Mar 15 11:28:20 2016 -0400

    orangefs: rename orangefs_inode_getattr to orangefs_inode_old_getattr
    
    This is motivated by orangefs_inode_old_getattr's habit of writing over
    live inodes.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index df4ad04407e2..59c51e2c5a71 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -458,7 +458,8 @@ static int compare_attributes_to_inode(struct inode *inode,
  * otherwise. When check is 1, returns 1 on success where the inode is valid
  * and 0 on success where the inode is stale and -errno otherwise.
  */
-int orangefs_inode_getattr(struct inode *inode, __u32 getattr_mask, int check)
+int orangefs_inode_old_getattr(struct inode *inode, __u32 getattr_mask,
+    int check)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_kernel_op_s *new_op;
@@ -536,6 +537,124 @@ int orangefs_inode_getattr(struct inode *inode, __u32 getattr_mask, int check)
 	return ret;
 }
 
+static int orangefs_inode_type(enum orangefs_ds_type objtype)
+{
+	if (objtype == ORANGEFS_TYPE_METAFILE)
+		return S_IFREG;
+	else if (objtype == ORANGEFS_TYPE_DIRECTORY)
+		return S_IFDIR;
+	else if (objtype == ORANGEFS_TYPE_SYMLINK)
+		return S_IFLNK;
+	else
+		return -1;
+}
+
+int orangefs_inode_getattr(struct inode *inode, int new, int size)
+{
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_kernel_op_s *new_op;
+	loff_t inode_size, rounded_up_size;
+	int ret;
+
+	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: called on inode %pU\n", __func__,
+	    get_khandle_from_ino(inode));
+
+	new_op = op_alloc(ORANGEFS_VFS_OP_GETATTR);
+	if (!new_op)
+		return -ENOMEM;
+	new_op->upcall.req.getattr.refn = orangefs_inode->refn;
+	new_op->upcall.req.getattr.mask = size ?
+	    ORANGEFS_ATTR_SYS_ALL_NOHINT : ORANGEFS_ATTR_SYS_ALL_NOHINT_NOSIZE;
+
+	ret = service_operation(new_op, __func__,
+	    get_interruptible_flag(inode));
+	if (ret != 0)
+		goto out;
+
+	ret = orangefs_inode_type(new_op->
+	    downcall.resp.getattr.attributes.objtype);
+	if (!new) {
+		/*
+		 * If the inode type or symlink target have changed then this
+		 * inode is stale.
+		 */
+		if (ret == -1 || !(inode->i_mode & ret)) {
+			orangefs_make_bad_inode(inode);
+			ret = -ESTALE;
+			goto out;
+		}
+		if (ret == S_IFLNK && strncmp(orangefs_inode->link_target,
+		    new_op->downcall.resp.getattr.link_target,
+		    ORANGEFS_NAME_MAX)) {
+			orangefs_make_bad_inode(inode);
+			ret = -ESTALE;
+			goto out;
+		}
+	}
+
+	switch (ret) {
+	case S_IFREG:
+		inode->i_flags = orangefs_inode_flags(&new_op->
+		    downcall.resp.getattr.attributes);
+		if (size) {
+			inode_size = (loff_t)new_op->
+			    downcall.resp.getattr.attributes.size;
+			rounded_up_size =
+			    (inode_size + (4096 - (inode_size % 4096)));
+			inode->i_size = inode_size;
+			orangefs_inode->blksize =
+			    new_op->downcall.resp.getattr.attributes.blksize;
+			spin_lock(&inode->i_lock);
+			inode->i_bytes = inode_size;
+			inode->i_blocks =
+			    (unsigned long)(rounded_up_size / 512);
+			spin_unlock(&inode->i_lock);
+		}
+		break;
+	case S_IFDIR:
+		inode->i_size = PAGE_CACHE_SIZE;
+		orangefs_inode->blksize = (1 << inode->i_blkbits);
+		spin_lock(&inode->i_lock);
+		inode_set_bytes(inode, inode->i_size);
+		spin_unlock(&inode->i_lock);
+		set_nlink(inode, 1);
+		break;
+	case S_IFLNK:
+		if (new) {
+			inode->i_size = (loff_t)strlen(new_op->
+			    downcall.resp.getattr.link_target);
+			orangefs_inode->blksize = (1 << inode->i_blkbits);
+			strlcpy(orangefs_inode->link_target,
+			    new_op->downcall.resp.getattr.link_target,
+			    ORANGEFS_NAME_MAX);
+		}
+		break;
+	}
+
+	inode->i_uid = make_kuid(&init_user_ns, new_op->
+	    downcall.resp.getattr.attributes.owner);
+	inode->i_gid = make_kgid(&init_user_ns, new_op->
+	    downcall.resp.getattr.attributes.group);
+	inode->i_atime.tv_sec = (time64_t)new_op->
+	    downcall.resp.getattr.attributes.atime;
+	inode->i_mtime.tv_sec = (time64_t)new_op->
+	    downcall.resp.getattr.attributes.mtime;
+	inode->i_ctime.tv_sec = (time64_t)new_op->
+	    downcall.resp.getattr.attributes.ctime;
+	inode->i_atime.tv_nsec = 0;
+	inode->i_mtime.tv_nsec = 0;
+	inode->i_ctime.tv_nsec = 0;
+
+	/* special case: mark the root inode as sticky */
+	inode->i_mode = ret | (is_root_handle(inode) ? S_ISVTX : 0) |
+	    orangefs_inode_perms(&new_op->downcall.resp.getattr.attributes);
+
+	ret = 0;
+out:
+	op_release(new_op);
+	return ret;
+}
+
 /*
  * issues a orangefs setattr request to make sure the new attribute values
  * take effect if successful.  returns 0 on success; -errno otherwise

commit d57521a653e7ac2e8edaabfff202caf87c61f08a
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Mar 14 16:59:38 2016 -0400

    orangefs: remove inode->i_lock wrapper
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 8ef9e9646748..df4ad04407e2 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -170,11 +170,11 @@ static int copy_attributes_to_inode(struct inode *inode,
 			rounded_up_size =
 			    (inode_size + (4096 - (inode_size % 4096)));
 
-			orangefs_lock_inode(inode);
+			spin_lock(&inode->i_lock);
 			inode->i_bytes = inode_size;
 			inode->i_blocks =
 			    (unsigned long)(rounded_up_size / 512);
-			orangefs_unlock_inode(inode);
+			spin_unlock(&inode->i_lock);
 
 			/*
 			 * NOTE: make sure all the places we're called
@@ -194,9 +194,9 @@ static int copy_attributes_to_inode(struct inode *inode,
 	default:
 		inode->i_size = PAGE_CACHE_SIZE;
 
-		orangefs_lock_inode(inode);
+		spin_lock(&inode->i_lock);
 		inode_set_bytes(inode, inode->i_size);
-		orangefs_unlock_inode(inode);
+		spin_unlock(&inode->i_lock);
 		break;
 	}
 

commit be81ce48b262e2164d64a1354c618571b0c9cd09
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Feb 26 13:54:10 2016 +0100

    orangefs: avoid time conversion function
    
    The new orangefs code uses a helper function to read a time field to
    its private structures from struct iattr. This will conflict with the
    move to 64-bit timestamps in the kernel and is generally not necessary.
    
    This replaces the conversion with a simple cast to time64_t that shows
    what is going on. As the orangefs-internal representation already uses
    64-bit timestamps, there should be no ambiguity to negative values,
    and the cast ensures that we treat them as times before 1970 on both
    32-bit and 64-bit architectures, rather than times after 2038. This
    patch keeps that behavior.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 488f3501b09c..8ef9e9646748 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -202,9 +202,9 @@ static int copy_attributes_to_inode(struct inode *inode,
 
 	inode->i_uid = make_kuid(&init_user_ns, attrs->owner);
 	inode->i_gid = make_kgid(&init_user_ns, attrs->group);
-	inode->i_atime.tv_sec = (time_t) attrs->atime;
-	inode->i_mtime.tv_sec = (time_t) attrs->mtime;
-	inode->i_ctime.tv_sec = (time_t) attrs->ctime;
+	inode->i_atime.tv_sec = (time64_t) attrs->atime;
+	inode->i_mtime.tv_sec = (time64_t) attrs->mtime;
+	inode->i_ctime.tv_sec = (time64_t) attrs->ctime;
 	inode->i_atime.tv_nsec = 0;
 	inode->i_mtime.tv_nsec = 0;
 	inode->i_ctime.tv_nsec = 0;
@@ -301,16 +301,14 @@ static inline int copy_attributes_from_inode(struct inode *inode,
 	if (iattr->ia_valid & ATTR_ATIME) {
 		attrs->mask |= ORANGEFS_ATTR_SYS_ATIME;
 		if (iattr->ia_valid & ATTR_ATIME_SET) {
-			attrs->atime =
-			    orangefs_convert_time_field(&iattr->ia_atime);
+			attrs->atime = (time64_t)iattr->ia_atime.tv_sec;
 			attrs->mask |= ORANGEFS_ATTR_SYS_ATIME_SET;
 		}
 	}
 	if (iattr->ia_valid & ATTR_MTIME) {
 		attrs->mask |= ORANGEFS_ATTR_SYS_MTIME;
 		if (iattr->ia_valid & ATTR_MTIME_SET) {
-			attrs->mtime =
-			    orangefs_convert_time_field(&iattr->ia_mtime);
+			attrs->mtime = (time64_t)iattr->ia_mtime.tv_sec;
 			attrs->mask |= ORANGEFS_ATTR_SYS_MTIME_SET;
 		}
 	}

commit c72f15b7d9b3cc744f066776dd0e61e6ab25e7d2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Feb 13 10:49:24 2016 -0500

    service_operation(): don't block signals, just use ..._killable
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 63e8c9bc912e..488f3501b09c 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -707,27 +707,6 @@ void orangefs_make_bad_inode(struct inode *inode)
 	}
 }
 
-/* Block all blockable signals... */
-void orangefs_block_signals(sigset_t *orig_sigset)
-{
-	sigset_t mask;
-
-	/*
-	 * Initialize all entries in the signal set to the
-	 * inverse of the given mask.
-	 */
-	siginitsetinv(&mask, sigmask(SIGKILL));
-
-	/* Block 'em Danno... */
-	sigprocmask(SIG_BLOCK, &mask, orig_sigset);
-}
-
-/* set the signal mask to the given template... */
-void orangefs_set_signals(sigset_t *sigset)
-{
-	sigprocmask(SIG_SETMASK, sigset, NULL);
-}
-
 /*
  * The following is a very dirty hack that is now a permanent part of the
  * ORANGEFS protocol. See protocol.h for more error definitions.

commit cf22644a0e5f1a66c61e90da15784effe3ba7ced
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Fri Feb 5 16:37:00 2016 -0500

    orangefs: use S_ISREG(mode) and friends instead of mode & S_IFREG.
    
    Suggestion from Dan Carpenter.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 08f9c2dab0fe..63e8c9bc912e 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -428,17 +428,17 @@ static int compare_attributes_to_inode(struct inode *inode,
 
 	switch (attrs->objtype) {
 	case ORANGEFS_TYPE_METAFILE:
-		if (!(inode->i_mode & S_IFREG))
+		if (!S_ISREG(inode->i_mode))
 			return 0;
 		break;
 	case ORANGEFS_TYPE_DIRECTORY:
-		if (!(inode->i_mode & S_IFDIR))
+		if (!S_ISDIR(inode->i_mode))
 			return 0;
 		if (inode->i_nlink != 1)
 			return 0;
 		break;
 	case ORANGEFS_TYPE_SYMLINK:
-		if (!(inode->i_mode & S_IFLNK))
+		if (!S_ISLNK(inode->i_mode))
 			return 0;
 		if (orangefs_inode && symname &&
 		    mask & ORANGEFS_ATTR_SYS_LNK_TARGET)

commit 78699e29fd784a4613d254a22627f336c55c4a76
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Feb 11 23:07:19 2016 -0500

    orangefs: delay freeing slot until cancel completes
    
    Make cancels reuse the aborted read/write op, to make sure they do not
    fail on lack of memory.
    
    Don't issue a cancel unless the daemon has seen our read/write, has not
    replied and isn't being shut down.
    
    If cancel *is* issued, don't wait for it to complete; stash the slot
    in there and just have it freed when cancel is finally replied to or
    purged (and delay dropping the reference until then, obviously).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index fa3ed8ad35be..08f9c2dab0fe 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -688,38 +688,6 @@ int orangefs_unmount_sb(struct super_block *sb)
 	return ret;
 }
 
-/*
- * NOTE: on successful cancellation, be sure to return -EINTR, as
- * that's the return value the caller expects
- */
-int orangefs_cancel_op_in_progress(__u64 tag)
-{
-	int ret = -EINVAL;
-	struct orangefs_kernel_op_s *new_op = NULL;
-
-	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "orangefs_cancel_op_in_progress called on tag %llu\n",
-		     llu(tag));
-
-	new_op = op_alloc(ORANGEFS_VFS_OP_CANCEL);
-	if (!new_op)
-		return -ENOMEM;
-	new_op->upcall.req.cancel.op_tag = tag;
-
-	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "Attempting ORANGEFS operation cancellation of tag %llu\n",
-		     llu(new_op->upcall.req.cancel.op_tag));
-
-	ret = service_operation(new_op, "orangefs_cancel", ORANGEFS_OP_CANCELLATION);
-
-	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "orangefs_cancel_op_in_progress: got return value of %d\n",
-		     ret);
-
-	op_release(new_op);
-	return ret;
-}
-
 void orangefs_make_bad_inode(struct inode *inode)
 {
 	if (is_root_handle(inode)) {

commit fe88adc3661ff9eb2a9777277f9c3abf5909449f
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Sat Jan 30 13:46:11 2016 -0500

    orangefs: Only compare attributes specified in orangefs_inode_getattr.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 6cf29a439211..fa3ed8ad35be 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -355,26 +355,37 @@ static inline int copy_attributes_from_inode(struct inode *inode,
 
 static int compare_attributes_to_inode(struct inode *inode,
 				       struct ORANGEFS_sys_attr_s *attrs,
-				       char *symname)
+				       char *symname,
+				       int mask)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	loff_t inode_size, rounded_up_size;
 
+	/* Much of what happens below relies on the type being around. */
+	if (!(mask & ORANGEFS_ATTR_SYS_TYPE))
+		return 0;
+
+	if (attrs->objtype == ORANGEFS_TYPE_METAFILE &&
+	    inode->i_flags != orangefs_inode_flags(attrs))
+		return 0;
+
 	/* Compare file size. */
 
 	switch (attrs->objtype) {
 	case ORANGEFS_TYPE_METAFILE:
-		if(inode->i_flags != orangefs_inode_flags(attrs))
-			return 0;
-		inode_size = attrs->size;
-		rounded_up_size = inode_size + (4096 - (inode_size % 4096));
-		if (inode->i_bytes != inode_size ||
-		    inode->i_blocks != rounded_up_size/512)
-			return 0;
+		if (mask & ORANGEFS_ATTR_SYS_SIZE) {
+			inode_size = attrs->size;
+			rounded_up_size = inode_size +
+			    (4096 - (inode_size % 4096));
+			if (inode->i_bytes != inode_size ||
+			    inode->i_blocks != rounded_up_size/512)
+				return 0;
+		}
 		break;
 	case ORANGEFS_TYPE_SYMLINK:
-		if (symname && strlen(symname) != inode->i_size)
-			return 0;
+		if (mask & ORANGEFS_ATTR_SYS_SIZE)
+			if (symname && strlen(symname) != inode->i_size)
+				return 0;
 		break;
 	default:
 		if (inode->i_size != PAGE_CACHE_SIZE &&
@@ -384,17 +395,28 @@ static int compare_attributes_to_inode(struct inode *inode,
 
 	/* Compare general attributes. */
 
-	if (!uid_eq(inode->i_uid, make_kuid(&init_user_ns, attrs->owner)) ||
-	    !gid_eq(inode->i_gid, make_kgid(&init_user_ns, attrs->group)) ||
-	    inode->i_atime.tv_sec != attrs->atime ||
-	    inode->i_mtime.tv_sec != attrs->mtime ||
-	    inode->i_ctime.tv_sec != attrs->ctime ||
-	    inode->i_atime.tv_nsec != 0 ||
+	if (mask & ORANGEFS_ATTR_SYS_UID &&
+	    !uid_eq(inode->i_uid, make_kuid(&init_user_ns, attrs->owner)))
+		return 0;
+	if (mask & ORANGEFS_ATTR_SYS_GID &&
+	    !gid_eq(inode->i_gid, make_kgid(&init_user_ns, attrs->group)))
+		return 0;
+	if (mask & ORANGEFS_ATTR_SYS_ATIME &&
+	    inode->i_atime.tv_sec != attrs->atime)
+		return 0;
+	if (mask & ORANGEFS_ATTR_SYS_MTIME &&
+	    inode->i_atime.tv_sec != attrs->mtime)
+		return 0;
+	if (mask & ORANGEFS_ATTR_SYS_CTIME &&
+	    inode->i_atime.tv_sec != attrs->ctime)
+		return 0;
+	if (inode->i_atime.tv_nsec != 0 ||
 	    inode->i_mtime.tv_nsec != 0 ||
 	    inode->i_ctime.tv_nsec != 0)
 		return 0;
 
-	if ((inode->i_mode & ~(S_ISVTX|S_IFREG|S_IFDIR|S_IFLNK)) !=
+	if (mask & ORANGEFS_ATTR_SYS_PERM &&
+	    (inode->i_mode & ~(S_ISVTX|S_IFREG|S_IFDIR|S_IFLNK)) !=
 	    orangefs_inode_perms(attrs))
 		return 0;
 
@@ -418,7 +440,8 @@ static int compare_attributes_to_inode(struct inode *inode,
 	case ORANGEFS_TYPE_SYMLINK:
 		if (!(inode->i_mode & S_IFLNK))
 			return 0;
-		if (orangefs_inode && symname)
+		if (orangefs_inode && symname &&
+		    mask & ORANGEFS_ATTR_SYS_LNK_TARGET)
 			if (strcmp(orangefs_inode->link_target, symname))
 				return 0;
 		break;
@@ -462,7 +485,8 @@ int orangefs_inode_getattr(struct inode *inode, __u32 getattr_mask, int check)
 	if (check) {
 		ret = compare_attributes_to_inode(inode,
 		    &new_op->downcall.resp.getattr.attributes,
-		    new_op->downcall.resp.getattr.link_target);
+		    new_op->downcall.resp.getattr.link_target,
+		    getattr_mask);
 
 		if (new_op->downcall.resp.getattr.attributes.objtype ==
 		    ORANGEFS_TYPE_METAFILE) {

commit 99109822f5cbe6d530eb55193b25aa5348f6134d
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Thu Jan 28 10:19:40 2016 -0500

    orangefs: Fix revalidate.
    
    Previously, it would update a live inode. This was fixed, but it did not
    ever check that the inode attributes in the dcache are correct. This
    checks all inode attributes and rejects any that are not correct, which
    causes a lookup and thus a new getattr.
    
    Perhaps inode_operations->permission should replace or augment some of
    this.
    
    There is no actual caching, and this does a rather excessive amount of
    network operations back to the filesystem server.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 035f050ae0e8..6cf29a439211 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -353,11 +353,91 @@ static inline int copy_attributes_from_inode(struct inode *inode,
 	return 0;
 }
 
+static int compare_attributes_to_inode(struct inode *inode,
+				       struct ORANGEFS_sys_attr_s *attrs,
+				       char *symname)
+{
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	loff_t inode_size, rounded_up_size;
+
+	/* Compare file size. */
+
+	switch (attrs->objtype) {
+	case ORANGEFS_TYPE_METAFILE:
+		if(inode->i_flags != orangefs_inode_flags(attrs))
+			return 0;
+		inode_size = attrs->size;
+		rounded_up_size = inode_size + (4096 - (inode_size % 4096));
+		if (inode->i_bytes != inode_size ||
+		    inode->i_blocks != rounded_up_size/512)
+			return 0;
+		break;
+	case ORANGEFS_TYPE_SYMLINK:
+		if (symname && strlen(symname) != inode->i_size)
+			return 0;
+		break;
+	default:
+		if (inode->i_size != PAGE_CACHE_SIZE &&
+		    inode_get_bytes(inode) != PAGE_CACHE_SIZE)
+			return 0;
+	}
+
+	/* Compare general attributes. */
+
+	if (!uid_eq(inode->i_uid, make_kuid(&init_user_ns, attrs->owner)) ||
+	    !gid_eq(inode->i_gid, make_kgid(&init_user_ns, attrs->group)) ||
+	    inode->i_atime.tv_sec != attrs->atime ||
+	    inode->i_mtime.tv_sec != attrs->mtime ||
+	    inode->i_ctime.tv_sec != attrs->ctime ||
+	    inode->i_atime.tv_nsec != 0 ||
+	    inode->i_mtime.tv_nsec != 0 ||
+	    inode->i_ctime.tv_nsec != 0)
+		return 0;
+
+	if ((inode->i_mode & ~(S_ISVTX|S_IFREG|S_IFDIR|S_IFLNK)) !=
+	    orangefs_inode_perms(attrs))
+		return 0;
+
+	if (is_root_handle(inode))
+		if (!(inode->i_mode & S_ISVTX))
+			return 0;
+
+	/* Compare file type. */
+
+	switch (attrs->objtype) {
+	case ORANGEFS_TYPE_METAFILE:
+		if (!(inode->i_mode & S_IFREG))
+			return 0;
+		break;
+	case ORANGEFS_TYPE_DIRECTORY:
+		if (!(inode->i_mode & S_IFDIR))
+			return 0;
+		if (inode->i_nlink != 1)
+			return 0;
+		break;
+	case ORANGEFS_TYPE_SYMLINK:
+		if (!(inode->i_mode & S_IFLNK))
+			return 0;
+		if (orangefs_inode && symname)
+			if (strcmp(orangefs_inode->link_target, symname))
+				return 0;
+		break;
+	default:
+		gossip_err("orangefs: compare_attributes_to_inode: got invalid attribute type %x\n",
+		    attrs->objtype);
+
+	}
+
+	return 1;
+}
+
 /*
- * issues a orangefs getattr request and fills in the appropriate inode
- * attributes if successful.  returns 0 on success; -errno otherwise
+ * Issues a orangefs getattr request and fills in the appropriate inode
+ * attributes if successful. When check is 0, returns 0 on success and -errno
+ * otherwise. When check is 1, returns 1 on success where the inode is valid
+ * and 0 on success where the inode is stale and -errno otherwise.
  */
-int orangefs_inode_getattr(struct inode *inode, __u32 getattr_mask)
+int orangefs_inode_getattr(struct inode *inode, __u32 getattr_mask, int check)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct orangefs_kernel_op_s *new_op;
@@ -379,27 +459,46 @@ int orangefs_inode_getattr(struct inode *inode, __u32 getattr_mask)
 	if (ret != 0)
 		goto out;
 
-	if (copy_attributes_to_inode(inode,
-			&new_op->downcall.resp.getattr.attributes,
-			new_op->downcall.resp.getattr.link_target)) {
-		gossip_err("%s: failed to copy attributes\n", __func__);
-		ret = -ENOENT;
-		goto out;
-	}
+	if (check) {
+		ret = compare_attributes_to_inode(inode,
+		    &new_op->downcall.resp.getattr.attributes,
+		    new_op->downcall.resp.getattr.link_target);
 
-	/*
-	 * Store blksize in orangefs specific part of inode structure; we are
-	 * only going to use this to report to stat to make sure it doesn't
-	 * perturb any inode related code paths.
-	 */
-	if (new_op->downcall.resp.getattr.attributes.objtype ==
-			ORANGEFS_TYPE_METAFILE) {
-		orangefs_inode->blksize =
-			new_op->downcall.resp.getattr.attributes.blksize;
+		if (new_op->downcall.resp.getattr.attributes.objtype ==
+		    ORANGEFS_TYPE_METAFILE) {
+			if (orangefs_inode->blksize !=
+			    new_op->downcall.resp.getattr.attributes.blksize)
+				ret = 0;
+		} else {
+			if (orangefs_inode->blksize != 1 << inode->i_blkbits)
+				ret = 0;
+		}
 	} else {
-		/* mimic behavior of generic_fillattr() for other types. */
-		orangefs_inode->blksize = (1 << inode->i_blkbits);
+		if (copy_attributes_to_inode(inode,
+				&new_op->downcall.resp.getattr.attributes,
+				new_op->downcall.resp.getattr.link_target)) {
+			gossip_err("%s: failed to copy attributes\n", __func__);
+			ret = -ENOENT;
+			goto out;
+		}
 
+		/*
+		 * Store blksize in orangefs specific part of inode structure;
+		 * we are only going to use this to report to stat to make sure
+		 * it doesn't perturb any inode related code paths.
+		 */
+		if (new_op->downcall.resp.getattr.attributes.objtype ==
+				ORANGEFS_TYPE_METAFILE) {
+			orangefs_inode->blksize = new_op->downcall.resp.
+			    getattr.attributes.blksize;
+		} else {
+			/*
+			 * mimic behavior of generic_fillattr() for other file
+			 * types.
+			 */
+			orangefs_inode->blksize = (1 << inode->i_blkbits);
+
+		}
 	}
 
 out:

commit 394f647e3ad073dab19ba081501e4a0ca05302c4
Author: Martin Brandenburg <martin@omnibond.com>
Date:   Mon Jan 25 15:33:39 2016 -0500

    orangefs: Util functions shouldn't operate on inode where it can be avoided.
    
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index 92a38b0091f2..035f050ae0e8 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -78,24 +78,55 @@ __s32 fsid_of_op(struct orangefs_kernel_op_s *op)
 	return fsid;
 }
 
-static void orangefs_set_inode_flags(struct inode *inode,
-				     struct ORANGEFS_sys_attr_s *attrs)
+static int orangefs_inode_flags(struct ORANGEFS_sys_attr_s *attrs)
 {
+	int flags = 0;
 	if (attrs->flags & ORANGEFS_IMMUTABLE_FL)
-		inode->i_flags |= S_IMMUTABLE;
+		flags |= S_IMMUTABLE;
 	else
-		inode->i_flags &= ~S_IMMUTABLE;
-
+		flags &= ~S_IMMUTABLE;
 	if (attrs->flags & ORANGEFS_APPEND_FL)
-		inode->i_flags |= S_APPEND;
+		flags |= S_APPEND;
 	else
-		inode->i_flags &= ~S_APPEND;
-
+		flags &= ~S_APPEND;
 	if (attrs->flags & ORANGEFS_NOATIME_FL)
-		inode->i_flags |= S_NOATIME;
+		flags |= S_NOATIME;
 	else
-		inode->i_flags &= ~S_NOATIME;
+		flags &= ~S_NOATIME;
+	return flags;
+}
+
+static int orangefs_inode_perms(struct ORANGEFS_sys_attr_s *attrs)
+{
+	int perm_mode = 0;
+
+	if (attrs->perms & ORANGEFS_O_EXECUTE)
+		perm_mode |= S_IXOTH;
+	if (attrs->perms & ORANGEFS_O_WRITE)
+		perm_mode |= S_IWOTH;
+	if (attrs->perms & ORANGEFS_O_READ)
+		perm_mode |= S_IROTH;
+
+	if (attrs->perms & ORANGEFS_G_EXECUTE)
+		perm_mode |= S_IXGRP;
+	if (attrs->perms & ORANGEFS_G_WRITE)
+		perm_mode |= S_IWGRP;
+	if (attrs->perms & ORANGEFS_G_READ)
+		perm_mode |= S_IRGRP;
 
+	if (attrs->perms & ORANGEFS_U_EXECUTE)
+		perm_mode |= S_IXUSR;
+	if (attrs->perms & ORANGEFS_U_WRITE)
+		perm_mode |= S_IWUSR;
+	if (attrs->perms & ORANGEFS_U_READ)
+		perm_mode |= S_IRUSR;
+
+	if (attrs->perms & ORANGEFS_G_SGID)
+		perm_mode |= S_ISGID;
+	if (attrs->perms & ORANGEFS_U_SUID)
+		perm_mode |= S_ISUID;
+
+	return perm_mode;
 }
 
 /* NOTE: symname is ignored unless the inode is a sym link */
@@ -104,7 +135,6 @@ static int copy_attributes_to_inode(struct inode *inode,
 				    char *symname)
 {
 	int ret = -1;
-	int perm_mode = 0;
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	loff_t inode_size = 0;
 	loff_t rounded_up_size = 0;
@@ -134,7 +164,7 @@ static int copy_attributes_to_inode(struct inode *inode,
 
 	switch (attrs->objtype) {
 	case ORANGEFS_TYPE_METAFILE:
-		orangefs_set_inode_flags(inode, attrs);
+		inode->i_flags = orangefs_inode_flags(attrs);
 		if (attrs->mask & ORANGEFS_ATTR_SYS_SIZE) {
 			inode_size = (loff_t) attrs->size;
 			rounded_up_size =
@@ -179,33 +209,7 @@ static int copy_attributes_to_inode(struct inode *inode,
 	inode->i_mtime.tv_nsec = 0;
 	inode->i_ctime.tv_nsec = 0;
 
-	if (attrs->perms & ORANGEFS_O_EXECUTE)
-		perm_mode |= S_IXOTH;
-	if (attrs->perms & ORANGEFS_O_WRITE)
-		perm_mode |= S_IWOTH;
-	if (attrs->perms & ORANGEFS_O_READ)
-		perm_mode |= S_IROTH;
-
-	if (attrs->perms & ORANGEFS_G_EXECUTE)
-		perm_mode |= S_IXGRP;
-	if (attrs->perms & ORANGEFS_G_WRITE)
-		perm_mode |= S_IWGRP;
-	if (attrs->perms & ORANGEFS_G_READ)
-		perm_mode |= S_IRGRP;
-
-	if (attrs->perms & ORANGEFS_U_EXECUTE)
-		perm_mode |= S_IXUSR;
-	if (attrs->perms & ORANGEFS_U_WRITE)
-		perm_mode |= S_IWUSR;
-	if (attrs->perms & ORANGEFS_U_READ)
-		perm_mode |= S_IRUSR;
-
-	if (attrs->perms & ORANGEFS_G_SGID)
-		perm_mode |= S_ISGID;
-	if (attrs->perms & ORANGEFS_U_SUID)
-		perm_mode |= S_ISUID;
-
-	inode->i_mode = perm_mode;
+	inode->i_mode = orangefs_inode_perms(attrs);
 
 	if (is_root_handle(inode)) {
 		/* special case: mark the root inode as sticky */

commit 115b93a8595c878759c7c1fdbd95fbbeacbe9168
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 23 14:04:31 2016 -0500

    orangefs: clean up op_alloc()
    
    fold orangefs_op_initialize() in there, don't bother locking something
    nobody else could've seen yet, use kmem_cache_zalloc() instead of
    explicit memset()...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index ca7edcfae873..92a38b0091f2 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -593,22 +593,6 @@ int orangefs_cancel_op_in_progress(__u64 tag)
 	return ret;
 }
 
-void orangefs_op_initialize(struct orangefs_kernel_op_s *op)
-{
-	if (op) {
-		spin_lock(&op->lock);
-		init_completion(&op->done);
-
-		op->upcall.type = ORANGEFS_VFS_OP_INVALID;
-		op->downcall.type = ORANGEFS_VFS_OP_INVALID;
-		op->downcall.status = -1;
-
-		op->op_state = OP_VFS_STATE_UNKNOWN;
-		op->tag = 0;
-		spin_unlock(&op->lock);
-	}
-}
-
 void orangefs_make_bad_inode(struct inode *inode)
 {
 	if (is_root_handle(inode)) {

commit 2a9e5c22605f5db6040535b10dce5fbc3a7db3bd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 23 13:45:46 2016 -0500

    orangefs: don't reinvent completion.h...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index a6117787ee8d..ca7edcfae873 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -597,7 +597,7 @@ void orangefs_op_initialize(struct orangefs_kernel_op_s *op)
 {
 	if (op) {
 		spin_lock(&op->lock);
-		op->io_completed = 0;
+		init_completion(&op->done);
 
 		op->upcall.type = ORANGEFS_VFS_OP_INVALID;
 		op->downcall.type = ORANGEFS_VFS_OP_INVALID;

commit ed42fe059389daa35a2aa10ec832e9f8d0a9e59e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jan 22 19:47:47 2016 -0500

    orangefs: hopefully saner op refcounting and locking
    
    * create with refcount 1
    * make op_release() decrement and free if zero (i.e. old put_op()
      has become that).
    * mark when submitter has given up waiting; from that point nobody
      else can move between the lists, change state, etc.
    * have daemon read/write_iter grab a reference when picking op
      and *always* give it up in the end
    * don't put into hash until we know it's been successfully passed to
      daemon
    
    * move op->lock _lower_ than htab_in_progress_lock (and make sure
      to take it in purge_inprogress_ops())
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index f21233201ce3..a6117787ee8d 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -429,19 +429,15 @@ int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr)
 	ret = copy_attributes_from_inode(inode,
 		       &new_op->upcall.req.setattr.attributes,
 		       iattr);
-	if (ret < 0) {
-		op_release(new_op);
-		return ret;
-	}
-
-	ret = service_operation(new_op, __func__,
+	if (ret >= 0) {
+		ret = service_operation(new_op, __func__,
 				get_interruptible_flag(inode));
 
-	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "orangefs_inode_setattr: returning %d\n",
-		     ret);
+		gossip_debug(GOSSIP_UTILS_DEBUG,
+			     "orangefs_inode_setattr: returning %d\n",
+			     ret);
+	}
 
-	/* when request is serviced properly, free req op struct */
 	op_release(new_op);
 
 	/*

commit c146c0b87f7cef247744a649f8c1d794d18bfcb7
Author: Richard Weinberger <richard@nod.at>
Date:   Sat Jan 2 23:04:47 2016 +0100

    orangefs: Don't pollute global namespace
    
    Prefix public functions with "orangefs_" do don't
    pollute the global namespace.
    
    This fixes a build issue on UML which also has block_signals().
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Martin Brandenburg <martin@omnibond.com>
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
index fa2a46521b7a..f21233201ce3 100644
--- a/fs/orangefs/orangefs-utils.c
+++ b/fs/orangefs/orangefs-utils.c
@@ -633,7 +633,7 @@ void orangefs_make_bad_inode(struct inode *inode)
 }
 
 /* Block all blockable signals... */
-void block_signals(sigset_t *orig_sigset)
+void orangefs_block_signals(sigset_t *orig_sigset)
 {
 	sigset_t mask;
 
@@ -648,7 +648,7 @@ void block_signals(sigset_t *orig_sigset)
 }
 
 /* set the signal mask to the given template... */
-void set_signals(sigset_t *sigset)
+void orangefs_set_signals(sigset_t *sigset)
 {
 	sigprocmask(SIG_SETMASK, sigset, NULL);
 }

commit 575e946125f70c41c2042f10172842c5cab9a09a
Author: Mike Marshall <hubcap@omnibond.com>
Date:   Fri Dec 4 12:56:14 2015 -0500

    Orangefs: change pvfs2 filenames to orangefs
    
    Also changed references within source files that referred to
    header files whose names had changed.
    
    Signed-off-by: Mike Marshall <hubcap@omnibond.com>

diff --git a/fs/orangefs/orangefs-utils.c b/fs/orangefs/orangefs-utils.c
new file mode 100644
index 000000000000..fa2a46521b7a
--- /dev/null
+++ b/fs/orangefs/orangefs-utils.c
@@ -0,0 +1,1156 @@
+/*
+ * (C) 2001 Clemson University and The University of Chicago
+ *
+ * See COPYING in top-level directory.
+ */
+#include "protocol.h"
+#include "orangefs-kernel.h"
+#include "orangefs-dev-proto.h"
+#include "orangefs-bufmap.h"
+
+__s32 fsid_of_op(struct orangefs_kernel_op_s *op)
+{
+	__s32 fsid = ORANGEFS_FS_ID_NULL;
+
+	if (op) {
+		switch (op->upcall.type) {
+		case ORANGEFS_VFS_OP_FILE_IO:
+			fsid = op->upcall.req.io.refn.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_LOOKUP:
+			fsid = op->upcall.req.lookup.parent_refn.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_CREATE:
+			fsid = op->upcall.req.create.parent_refn.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_GETATTR:
+			fsid = op->upcall.req.getattr.refn.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_REMOVE:
+			fsid = op->upcall.req.remove.parent_refn.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_MKDIR:
+			fsid = op->upcall.req.mkdir.parent_refn.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_READDIR:
+			fsid = op->upcall.req.readdir.refn.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_SETATTR:
+			fsid = op->upcall.req.setattr.refn.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_SYMLINK:
+			fsid = op->upcall.req.sym.parent_refn.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_RENAME:
+			fsid = op->upcall.req.rename.old_parent_refn.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_STATFS:
+			fsid = op->upcall.req.statfs.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_TRUNCATE:
+			fsid = op->upcall.req.truncate.refn.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_MMAP_RA_FLUSH:
+			fsid = op->upcall.req.ra_cache_flush.refn.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_FS_UMOUNT:
+			fsid = op->upcall.req.fs_umount.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_GETXATTR:
+			fsid = op->upcall.req.getxattr.refn.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_SETXATTR:
+			fsid = op->upcall.req.setxattr.refn.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_LISTXATTR:
+			fsid = op->upcall.req.listxattr.refn.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_REMOVEXATTR:
+			fsid = op->upcall.req.removexattr.refn.fs_id;
+			break;
+		case ORANGEFS_VFS_OP_FSYNC:
+			fsid = op->upcall.req.fsync.refn.fs_id;
+			break;
+		default:
+			break;
+		}
+	}
+	return fsid;
+}
+
+static void orangefs_set_inode_flags(struct inode *inode,
+				     struct ORANGEFS_sys_attr_s *attrs)
+{
+	if (attrs->flags & ORANGEFS_IMMUTABLE_FL)
+		inode->i_flags |= S_IMMUTABLE;
+	else
+		inode->i_flags &= ~S_IMMUTABLE;
+
+	if (attrs->flags & ORANGEFS_APPEND_FL)
+		inode->i_flags |= S_APPEND;
+	else
+		inode->i_flags &= ~S_APPEND;
+
+	if (attrs->flags & ORANGEFS_NOATIME_FL)
+		inode->i_flags |= S_NOATIME;
+	else
+		inode->i_flags &= ~S_NOATIME;
+
+}
+
+/* NOTE: symname is ignored unless the inode is a sym link */
+static int copy_attributes_to_inode(struct inode *inode,
+				    struct ORANGEFS_sys_attr_s *attrs,
+				    char *symname)
+{
+	int ret = -1;
+	int perm_mode = 0;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	loff_t inode_size = 0;
+	loff_t rounded_up_size = 0;
+
+
+	/*
+	 * arbitrarily set the inode block size; FIXME: we need to
+	 * resolve the difference between the reported inode blocksize
+	 * and the PAGE_CACHE_SIZE, since our block count will always
+	 * be wrong.
+	 *
+	 * For now, we're setting the block count to be the proper
+	 * number assuming the block size is 512 bytes, and the size is
+	 * rounded up to the nearest 4K.  This is apparently required
+	 * to get proper size reports from the 'du' shell utility.
+	 *
+	 * changing the inode->i_blkbits to something other than
+	 * PAGE_CACHE_SHIFT breaks mmap/execution as we depend on that.
+	 */
+	gossip_debug(GOSSIP_UTILS_DEBUG,
+		     "attrs->mask = %x (objtype = %s)\n",
+		     attrs->mask,
+		     attrs->objtype == ORANGEFS_TYPE_METAFILE ? "file" :
+		     attrs->objtype == ORANGEFS_TYPE_DIRECTORY ? "directory" :
+		     attrs->objtype == ORANGEFS_TYPE_SYMLINK ? "symlink" :
+			"invalid/unknown");
+
+	switch (attrs->objtype) {
+	case ORANGEFS_TYPE_METAFILE:
+		orangefs_set_inode_flags(inode, attrs);
+		if (attrs->mask & ORANGEFS_ATTR_SYS_SIZE) {
+			inode_size = (loff_t) attrs->size;
+			rounded_up_size =
+			    (inode_size + (4096 - (inode_size % 4096)));
+
+			orangefs_lock_inode(inode);
+			inode->i_bytes = inode_size;
+			inode->i_blocks =
+			    (unsigned long)(rounded_up_size / 512);
+			orangefs_unlock_inode(inode);
+
+			/*
+			 * NOTE: make sure all the places we're called
+			 * from have the inode->i_sem lock. We're fine
+			 * in 99% of the cases since we're mostly
+			 * called from a lookup.
+			 */
+			inode->i_size = inode_size;
+		}
+		break;
+	case ORANGEFS_TYPE_SYMLINK:
+		if (symname != NULL) {
+			inode->i_size = (loff_t) strlen(symname);
+			break;
+		}
+		/*FALLTHRU*/
+	default:
+		inode->i_size = PAGE_CACHE_SIZE;
+
+		orangefs_lock_inode(inode);
+		inode_set_bytes(inode, inode->i_size);
+		orangefs_unlock_inode(inode);
+		break;
+	}
+
+	inode->i_uid = make_kuid(&init_user_ns, attrs->owner);
+	inode->i_gid = make_kgid(&init_user_ns, attrs->group);
+	inode->i_atime.tv_sec = (time_t) attrs->atime;
+	inode->i_mtime.tv_sec = (time_t) attrs->mtime;
+	inode->i_ctime.tv_sec = (time_t) attrs->ctime;
+	inode->i_atime.tv_nsec = 0;
+	inode->i_mtime.tv_nsec = 0;
+	inode->i_ctime.tv_nsec = 0;
+
+	if (attrs->perms & ORANGEFS_O_EXECUTE)
+		perm_mode |= S_IXOTH;
+	if (attrs->perms & ORANGEFS_O_WRITE)
+		perm_mode |= S_IWOTH;
+	if (attrs->perms & ORANGEFS_O_READ)
+		perm_mode |= S_IROTH;
+
+	if (attrs->perms & ORANGEFS_G_EXECUTE)
+		perm_mode |= S_IXGRP;
+	if (attrs->perms & ORANGEFS_G_WRITE)
+		perm_mode |= S_IWGRP;
+	if (attrs->perms & ORANGEFS_G_READ)
+		perm_mode |= S_IRGRP;
+
+	if (attrs->perms & ORANGEFS_U_EXECUTE)
+		perm_mode |= S_IXUSR;
+	if (attrs->perms & ORANGEFS_U_WRITE)
+		perm_mode |= S_IWUSR;
+	if (attrs->perms & ORANGEFS_U_READ)
+		perm_mode |= S_IRUSR;
+
+	if (attrs->perms & ORANGEFS_G_SGID)
+		perm_mode |= S_ISGID;
+	if (attrs->perms & ORANGEFS_U_SUID)
+		perm_mode |= S_ISUID;
+
+	inode->i_mode = perm_mode;
+
+	if (is_root_handle(inode)) {
+		/* special case: mark the root inode as sticky */
+		inode->i_mode |= S_ISVTX;
+		gossip_debug(GOSSIP_UTILS_DEBUG,
+			     "Marking inode %pU as sticky\n",
+			     get_khandle_from_ino(inode));
+	}
+
+	switch (attrs->objtype) {
+	case ORANGEFS_TYPE_METAFILE:
+		inode->i_mode |= S_IFREG;
+		ret = 0;
+		break;
+	case ORANGEFS_TYPE_DIRECTORY:
+		inode->i_mode |= S_IFDIR;
+		/* NOTE: we have no good way to keep nlink consistent
+		 * for directories across clients; keep constant at 1.
+		 * Why 1?  If we go with 2, then find(1) gets confused
+		 * and won't work properly withouth the -noleaf option
+		 */
+		set_nlink(inode, 1);
+		ret = 0;
+		break;
+	case ORANGEFS_TYPE_SYMLINK:
+		inode->i_mode |= S_IFLNK;
+
+		/* copy link target to inode private data */
+		if (orangefs_inode && symname) {
+			strncpy(orangefs_inode->link_target,
+				symname,
+				ORANGEFS_NAME_MAX);
+			gossip_debug(GOSSIP_UTILS_DEBUG,
+				     "Copied attr link target %s\n",
+				     orangefs_inode->link_target);
+		}
+		gossip_debug(GOSSIP_UTILS_DEBUG,
+			     "symlink mode %o\n",
+			     inode->i_mode);
+		ret = 0;
+		break;
+	default:
+		gossip_err("orangefs: copy_attributes_to_inode: got invalid attribute type %x\n",
+			attrs->objtype);
+	}
+
+	gossip_debug(GOSSIP_UTILS_DEBUG,
+		     "orangefs: copy_attributes_to_inode: setting i_mode to %o, i_size to %lu\n",
+		     inode->i_mode,
+		     (unsigned long)i_size_read(inode));
+
+	return ret;
+}
+
+/*
+ * NOTE: in kernel land, we never use the sys_attr->link_target for
+ * anything, so don't bother copying it into the sys_attr object here.
+ */
+static inline int copy_attributes_from_inode(struct inode *inode,
+					     struct ORANGEFS_sys_attr_s *attrs,
+					     struct iattr *iattr)
+{
+	umode_t tmp_mode;
+
+	if (!iattr || !inode || !attrs) {
+		gossip_err("NULL iattr (%p), inode (%p), attrs (%p) "
+			   "in copy_attributes_from_inode!\n",
+			   iattr,
+			   inode,
+			   attrs);
+		return -EINVAL;
+	}
+	/*
+	 * We need to be careful to only copy the attributes out of the
+	 * iattr object that we know are valid.
+	 */
+	attrs->mask = 0;
+	if (iattr->ia_valid & ATTR_UID) {
+		attrs->owner = from_kuid(current_user_ns(), iattr->ia_uid);
+		attrs->mask |= ORANGEFS_ATTR_SYS_UID;
+		gossip_debug(GOSSIP_UTILS_DEBUG, "(UID) %d\n", attrs->owner);
+	}
+	if (iattr->ia_valid & ATTR_GID) {
+		attrs->group = from_kgid(current_user_ns(), iattr->ia_gid);
+		attrs->mask |= ORANGEFS_ATTR_SYS_GID;
+		gossip_debug(GOSSIP_UTILS_DEBUG, "(GID) %d\n", attrs->group);
+	}
+
+	if (iattr->ia_valid & ATTR_ATIME) {
+		attrs->mask |= ORANGEFS_ATTR_SYS_ATIME;
+		if (iattr->ia_valid & ATTR_ATIME_SET) {
+			attrs->atime =
+			    orangefs_convert_time_field(&iattr->ia_atime);
+			attrs->mask |= ORANGEFS_ATTR_SYS_ATIME_SET;
+		}
+	}
+	if (iattr->ia_valid & ATTR_MTIME) {
+		attrs->mask |= ORANGEFS_ATTR_SYS_MTIME;
+		if (iattr->ia_valid & ATTR_MTIME_SET) {
+			attrs->mtime =
+			    orangefs_convert_time_field(&iattr->ia_mtime);
+			attrs->mask |= ORANGEFS_ATTR_SYS_MTIME_SET;
+		}
+	}
+	if (iattr->ia_valid & ATTR_CTIME)
+		attrs->mask |= ORANGEFS_ATTR_SYS_CTIME;
+
+	/*
+	 * ORANGEFS cannot set size with a setattr operation.  Probably not likely
+	 * to be requested through the VFS, but just in case, don't worry about
+	 * ATTR_SIZE
+	 */
+
+	if (iattr->ia_valid & ATTR_MODE) {
+		tmp_mode = iattr->ia_mode;
+		if (tmp_mode & (S_ISVTX)) {
+			if (is_root_handle(inode)) {
+				/*
+				 * allow sticky bit to be set on root (since
+				 * it shows up that way by default anyhow),
+				 * but don't show it to the server
+				 */
+				tmp_mode -= S_ISVTX;
+			} else {
+				gossip_debug(GOSSIP_UTILS_DEBUG,
+					     "User attempted to set sticky bit on non-root directory; returning EINVAL.\n");
+				return -EINVAL;
+			}
+		}
+
+		if (tmp_mode & (S_ISUID)) {
+			gossip_debug(GOSSIP_UTILS_DEBUG,
+				     "Attempting to set setuid bit (not supported); returning EINVAL.\n");
+			return -EINVAL;
+		}
+
+		attrs->perms = ORANGEFS_util_translate_mode(tmp_mode);
+		attrs->mask |= ORANGEFS_ATTR_SYS_PERM;
+	}
+
+	return 0;
+}
+
+/*
+ * issues a orangefs getattr request and fills in the appropriate inode
+ * attributes if successful.  returns 0 on success; -errno otherwise
+ */
+int orangefs_inode_getattr(struct inode *inode, __u32 getattr_mask)
+{
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_kernel_op_s *new_op;
+	int ret = -EINVAL;
+
+	gossip_debug(GOSSIP_UTILS_DEBUG,
+		     "%s: called on inode %pU\n",
+		     __func__,
+		     get_khandle_from_ino(inode));
+
+	new_op = op_alloc(ORANGEFS_VFS_OP_GETATTR);
+	if (!new_op)
+		return -ENOMEM;
+	new_op->upcall.req.getattr.refn = orangefs_inode->refn;
+	new_op->upcall.req.getattr.mask = getattr_mask;
+
+	ret = service_operation(new_op, __func__,
+				get_interruptible_flag(inode));
+	if (ret != 0)
+		goto out;
+
+	if (copy_attributes_to_inode(inode,
+			&new_op->downcall.resp.getattr.attributes,
+			new_op->downcall.resp.getattr.link_target)) {
+		gossip_err("%s: failed to copy attributes\n", __func__);
+		ret = -ENOENT;
+		goto out;
+	}
+
+	/*
+	 * Store blksize in orangefs specific part of inode structure; we are
+	 * only going to use this to report to stat to make sure it doesn't
+	 * perturb any inode related code paths.
+	 */
+	if (new_op->downcall.resp.getattr.attributes.objtype ==
+			ORANGEFS_TYPE_METAFILE) {
+		orangefs_inode->blksize =
+			new_op->downcall.resp.getattr.attributes.blksize;
+	} else {
+		/* mimic behavior of generic_fillattr() for other types. */
+		orangefs_inode->blksize = (1 << inode->i_blkbits);
+
+	}
+
+out:
+	gossip_debug(GOSSIP_UTILS_DEBUG,
+		     "Getattr on handle %pU, "
+		     "fsid %d\n  (inode ct = %d) returned %d\n",
+		     &orangefs_inode->refn.khandle,
+		     orangefs_inode->refn.fs_id,
+		     (int)atomic_read(&inode->i_count),
+		     ret);
+
+	op_release(new_op);
+	return ret;
+}
+
+/*
+ * issues a orangefs setattr request to make sure the new attribute values
+ * take effect if successful.  returns 0 on success; -errno otherwise
+ */
+int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr)
+{
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_kernel_op_s *new_op;
+	int ret;
+
+	new_op = op_alloc(ORANGEFS_VFS_OP_SETATTR);
+	if (!new_op)
+		return -ENOMEM;
+
+	new_op->upcall.req.setattr.refn = orangefs_inode->refn;
+	ret = copy_attributes_from_inode(inode,
+		       &new_op->upcall.req.setattr.attributes,
+		       iattr);
+	if (ret < 0) {
+		op_release(new_op);
+		return ret;
+	}
+
+	ret = service_operation(new_op, __func__,
+				get_interruptible_flag(inode));
+
+	gossip_debug(GOSSIP_UTILS_DEBUG,
+		     "orangefs_inode_setattr: returning %d\n",
+		     ret);
+
+	/* when request is serviced properly, free req op struct */
+	op_release(new_op);
+
+	/*
+	 * successful setattr should clear the atime, mtime and
+	 * ctime flags.
+	 */
+	if (ret == 0) {
+		ClearAtimeFlag(orangefs_inode);
+		ClearMtimeFlag(orangefs_inode);
+		ClearCtimeFlag(orangefs_inode);
+		ClearModeFlag(orangefs_inode);
+	}
+
+	return ret;
+}
+
+int orangefs_flush_inode(struct inode *inode)
+{
+	/*
+	 * If it is a dirty inode, this function gets called.
+	 * Gather all the information that needs to be setattr'ed
+	 * Right now, this will only be used for mode, atime, mtime
+	 * and/or ctime.
+	 */
+	struct iattr wbattr;
+	int ret;
+	int mtime_flag;
+	int ctime_flag;
+	int atime_flag;
+	int mode_flag;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+
+	memset(&wbattr, 0, sizeof(wbattr));
+
+	/*
+	 * check inode flags up front, and clear them if they are set.  This
+	 * will prevent multiple processes from all trying to flush the same
+	 * inode if they call close() simultaneously
+	 */
+	mtime_flag = MtimeFlag(orangefs_inode);
+	ClearMtimeFlag(orangefs_inode);
+	ctime_flag = CtimeFlag(orangefs_inode);
+	ClearCtimeFlag(orangefs_inode);
+	atime_flag = AtimeFlag(orangefs_inode);
+	ClearAtimeFlag(orangefs_inode);
+	mode_flag = ModeFlag(orangefs_inode);
+	ClearModeFlag(orangefs_inode);
+
+	/*  -- Lazy atime,mtime and ctime update --
+	 * Note: all times are dictated by server in the new scheme
+	 * and not by the clients
+	 *
+	 * Also mode updates are being handled now..
+	 */
+
+	if (mtime_flag)
+		wbattr.ia_valid |= ATTR_MTIME;
+	if (ctime_flag)
+		wbattr.ia_valid |= ATTR_CTIME;
+	if (atime_flag)
+		wbattr.ia_valid |= ATTR_ATIME;
+
+	if (mode_flag) {
+		wbattr.ia_mode = inode->i_mode;
+		wbattr.ia_valid |= ATTR_MODE;
+	}
+
+	gossip_debug(GOSSIP_UTILS_DEBUG,
+		     "*********** orangefs_flush_inode: %pU "
+		     "(ia_valid %d)\n",
+		     get_khandle_from_ino(inode),
+		     wbattr.ia_valid);
+	if (wbattr.ia_valid == 0) {
+		gossip_debug(GOSSIP_UTILS_DEBUG,
+			     "orangefs_flush_inode skipping setattr()\n");
+		return 0;
+	}
+
+	gossip_debug(GOSSIP_UTILS_DEBUG,
+		     "orangefs_flush_inode (%pU) writing mode %o\n",
+		     get_khandle_from_ino(inode),
+		     inode->i_mode);
+
+	ret = orangefs_inode_setattr(inode, &wbattr);
+
+	return ret;
+}
+
+int orangefs_unmount_sb(struct super_block *sb)
+{
+	int ret = -EINVAL;
+	struct orangefs_kernel_op_s *new_op = NULL;
+
+	gossip_debug(GOSSIP_UTILS_DEBUG,
+		     "orangefs_unmount_sb called on sb %p\n",
+		     sb);
+
+	new_op = op_alloc(ORANGEFS_VFS_OP_FS_UMOUNT);
+	if (!new_op)
+		return -ENOMEM;
+	new_op->upcall.req.fs_umount.id = ORANGEFS_SB(sb)->id;
+	new_op->upcall.req.fs_umount.fs_id = ORANGEFS_SB(sb)->fs_id;
+	strncpy(new_op->upcall.req.fs_umount.orangefs_config_server,
+		ORANGEFS_SB(sb)->devname,
+		ORANGEFS_MAX_SERVER_ADDR_LEN);
+
+	gossip_debug(GOSSIP_UTILS_DEBUG,
+		     "Attempting ORANGEFS Unmount via host %s\n",
+		     new_op->upcall.req.fs_umount.orangefs_config_server);
+
+	ret = service_operation(new_op, "orangefs_fs_umount", 0);
+
+	gossip_debug(GOSSIP_UTILS_DEBUG,
+		     "orangefs_unmount: got return value of %d\n", ret);
+	if (ret)
+		sb = ERR_PTR(ret);
+	else
+		ORANGEFS_SB(sb)->mount_pending = 1;
+
+	op_release(new_op);
+	return ret;
+}
+
+/*
+ * NOTE: on successful cancellation, be sure to return -EINTR, as
+ * that's the return value the caller expects
+ */
+int orangefs_cancel_op_in_progress(__u64 tag)
+{
+	int ret = -EINVAL;
+	struct orangefs_kernel_op_s *new_op = NULL;
+
+	gossip_debug(GOSSIP_UTILS_DEBUG,
+		     "orangefs_cancel_op_in_progress called on tag %llu\n",
+		     llu(tag));
+
+	new_op = op_alloc(ORANGEFS_VFS_OP_CANCEL);
+	if (!new_op)
+		return -ENOMEM;
+	new_op->upcall.req.cancel.op_tag = tag;
+
+	gossip_debug(GOSSIP_UTILS_DEBUG,
+		     "Attempting ORANGEFS operation cancellation of tag %llu\n",
+		     llu(new_op->upcall.req.cancel.op_tag));
+
+	ret = service_operation(new_op, "orangefs_cancel", ORANGEFS_OP_CANCELLATION);
+
+	gossip_debug(GOSSIP_UTILS_DEBUG,
+		     "orangefs_cancel_op_in_progress: got return value of %d\n",
+		     ret);
+
+	op_release(new_op);
+	return ret;
+}
+
+void orangefs_op_initialize(struct orangefs_kernel_op_s *op)
+{
+	if (op) {
+		spin_lock(&op->lock);
+		op->io_completed = 0;
+
+		op->upcall.type = ORANGEFS_VFS_OP_INVALID;
+		op->downcall.type = ORANGEFS_VFS_OP_INVALID;
+		op->downcall.status = -1;
+
+		op->op_state = OP_VFS_STATE_UNKNOWN;
+		op->tag = 0;
+		spin_unlock(&op->lock);
+	}
+}
+
+void orangefs_make_bad_inode(struct inode *inode)
+{
+	if (is_root_handle(inode)) {
+		/*
+		 * if this occurs, the pvfs2-client-core was killed but we
+		 * can't afford to lose the inode operations and such
+		 * associated with the root handle in any case.
+		 */
+		gossip_debug(GOSSIP_UTILS_DEBUG,
+			     "*** NOT making bad root inode %pU\n",
+			     get_khandle_from_ino(inode));
+	} else {
+		gossip_debug(GOSSIP_UTILS_DEBUG,
+			     "*** making bad inode %pU\n",
+			     get_khandle_from_ino(inode));
+		make_bad_inode(inode);
+	}
+}
+
+/* Block all blockable signals... */
+void block_signals(sigset_t *orig_sigset)
+{
+	sigset_t mask;
+
+	/*
+	 * Initialize all entries in the signal set to the
+	 * inverse of the given mask.
+	 */
+	siginitsetinv(&mask, sigmask(SIGKILL));
+
+	/* Block 'em Danno... */
+	sigprocmask(SIG_BLOCK, &mask, orig_sigset);
+}
+
+/* set the signal mask to the given template... */
+void set_signals(sigset_t *sigset)
+{
+	sigprocmask(SIG_SETMASK, sigset, NULL);
+}
+
+/*
+ * The following is a very dirty hack that is now a permanent part of the
+ * ORANGEFS protocol. See protocol.h for more error definitions.
+ */
+
+/* The order matches include/orangefs-types.h in the OrangeFS source. */
+static int PINT_errno_mapping[] = {
+	0, EPERM, ENOENT, EINTR, EIO, ENXIO, EBADF, EAGAIN, ENOMEM,
+	EFAULT, EBUSY, EEXIST, ENODEV, ENOTDIR, EISDIR, EINVAL, EMFILE,
+	EFBIG, ENOSPC, EROFS, EMLINK, EPIPE, EDEADLK, ENAMETOOLONG,
+	ENOLCK, ENOSYS, ENOTEMPTY, ELOOP, EWOULDBLOCK, ENOMSG, EUNATCH,
+	EBADR, EDEADLOCK, ENODATA, ETIME, ENONET, EREMOTE, ECOMM,
+	EPROTO, EBADMSG, EOVERFLOW, ERESTART, EMSGSIZE, EPROTOTYPE,
+	ENOPROTOOPT, EPROTONOSUPPORT, EOPNOTSUPP, EADDRINUSE,
+	EADDRNOTAVAIL, ENETDOWN, ENETUNREACH, ENETRESET, ENOBUFS,
+	ETIMEDOUT, ECONNREFUSED, EHOSTDOWN, EHOSTUNREACH, EALREADY,
+	EACCES, ECONNRESET, ERANGE
+};
+
+int orangefs_normalize_to_errno(__s32 error_code)
+{
+	__u32 i;
+
+	/* Success */
+	if (error_code == 0) {
+		return 0;
+	/*
+	 * This shouldn't ever happen. If it does it should be fixed on the
+	 * server.
+	 */
+	} else if (error_code > 0) {
+		gossip_err("orangefs: error status receieved.\n");
+		gossip_err("orangefs: assuming error code is inverted.\n");
+		error_code = -error_code;
+	}
+
+	/*
+	 * XXX: This is very bad since error codes from ORANGEFS may not be
+	 * suitable for return into userspace.
+	 */
+
+	/*
+	 * Convert ORANGEFS error values into errno values suitable for return
+	 * from the kernel.
+	 */
+	if ((-error_code) & ORANGEFS_NON_ERRNO_ERROR_BIT) {
+		if (((-error_code) &
+		    (ORANGEFS_ERROR_NUMBER_BITS|ORANGEFS_NON_ERRNO_ERROR_BIT|
+		    ORANGEFS_ERROR_BIT)) == ORANGEFS_ECANCEL) {
+			/*
+			 * cancellation error codes generally correspond to
+			 * a timeout from the client's perspective
+			 */
+			error_code = -ETIMEDOUT;
+		} else {
+			/* assume a default error code */
+			gossip_err("orangefs: warning: got error code without errno equivalent: %d.\n", error_code);
+			error_code = -EINVAL;
+		}
+
+	/* Convert ORANGEFS encoded errno values into regular errno values. */
+	} else if ((-error_code) & ORANGEFS_ERROR_BIT) {
+		i = (-error_code) & ~(ORANGEFS_ERROR_BIT|ORANGEFS_ERROR_CLASS_BITS);
+		if (i < sizeof(PINT_errno_mapping)/sizeof(*PINT_errno_mapping))
+			error_code = -PINT_errno_mapping[i];
+		else
+			error_code = -EINVAL;
+
+	/*
+	 * Only ORANGEFS protocol error codes should ever come here. Otherwise
+	 * there is a bug somewhere.
+	 */
+	} else {
+		gossip_err("orangefs: orangefs_normalize_to_errno: got error code which is not from ORANGEFS.\n");
+	}
+	return error_code;
+}
+
+#define NUM_MODES 11
+__s32 ORANGEFS_util_translate_mode(int mode)
+{
+	int ret = 0;
+	int i = 0;
+	static int modes[NUM_MODES] = {
+		S_IXOTH, S_IWOTH, S_IROTH,
+		S_IXGRP, S_IWGRP, S_IRGRP,
+		S_IXUSR, S_IWUSR, S_IRUSR,
+		S_ISGID, S_ISUID
+	};
+	static int orangefs_modes[NUM_MODES] = {
+		ORANGEFS_O_EXECUTE, ORANGEFS_O_WRITE, ORANGEFS_O_READ,
+		ORANGEFS_G_EXECUTE, ORANGEFS_G_WRITE, ORANGEFS_G_READ,
+		ORANGEFS_U_EXECUTE, ORANGEFS_U_WRITE, ORANGEFS_U_READ,
+		ORANGEFS_G_SGID, ORANGEFS_U_SUID
+	};
+
+	for (i = 0; i < NUM_MODES; i++)
+		if (mode & modes[i])
+			ret |= orangefs_modes[i];
+
+	return ret;
+}
+#undef NUM_MODES
+
+/*
+ * After obtaining a string representation of the client's debug
+ * keywords and their associated masks, this function is called to build an
+ * array of these values.
+ */
+int orangefs_prepare_cdm_array(char *debug_array_string)
+{
+	int i;
+	int rc = -EINVAL;
+	char *cds_head = NULL;
+	char *cds_delimiter = NULL;
+	int keyword_len = 0;
+
+	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: start\n", __func__);
+
+	/*
+	 * figure out how many elements the cdm_array needs.
+	 */
+	for (i = 0; i < strlen(debug_array_string); i++)
+		if (debug_array_string[i] == '\n')
+			cdm_element_count++;
+
+	if (!cdm_element_count) {
+		pr_info("No elements in client debug array string!\n");
+		goto out;
+	}
+
+	cdm_array =
+		kzalloc(cdm_element_count * sizeof(struct client_debug_mask),
+			GFP_KERNEL);
+	if (!cdm_array) {
+		pr_info("malloc failed for cdm_array!\n");
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	cds_head = debug_array_string;
+
+	for (i = 0; i < cdm_element_count; i++) {
+		cds_delimiter = strchr(cds_head, '\n');
+		*cds_delimiter = '\0';
+
+		keyword_len = strcspn(cds_head, " ");
+
+		cdm_array[i].keyword = kzalloc(keyword_len + 1, GFP_KERNEL);
+		if (!cdm_array[i].keyword) {
+			rc = -ENOMEM;
+			goto out;
+		}
+
+		sscanf(cds_head,
+		       "%s %llx %llx",
+		       cdm_array[i].keyword,
+		       (unsigned long long *)&(cdm_array[i].mask1),
+		       (unsigned long long *)&(cdm_array[i].mask2));
+
+		if (!strcmp(cdm_array[i].keyword, ORANGEFS_VERBOSE))
+			client_verbose_index = i;
+
+		if (!strcmp(cdm_array[i].keyword, ORANGEFS_ALL))
+			client_all_index = i;
+
+		cds_head = cds_delimiter + 1;
+	}
+
+	rc = cdm_element_count;
+
+	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: rc:%d:\n", __func__, rc);
+
+out:
+
+	return rc;
+
+}
+
+/*
+ * /sys/kernel/debug/orangefs/debug-help can be catted to
+ * see all the available kernel and client debug keywords.
+ *
+ * When the kernel boots, we have no idea what keywords the
+ * client supports, nor their associated masks.
+ *
+ * We pass through this function once at boot and stamp a
+ * boilerplate "we don't know" message for the client in the
+ * debug-help file. We pass through here again when the client
+ * starts and then we can fill out the debug-help file fully.
+ *
+ * The client might be restarted any number of times between
+ * reboots, we only build the debug-help file the first time.
+ */
+int orangefs_prepare_debugfs_help_string(int at_boot)
+{
+	int rc = -EINVAL;
+	int i;
+	int byte_count = 0;
+	char *client_title = "Client Debug Keywords:\n";
+	char *kernel_title = "Kernel Debug Keywords:\n";
+
+	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: start\n", __func__);
+
+	if (at_boot) {
+		byte_count += strlen(HELP_STRING_UNINITIALIZED);
+		client_title = HELP_STRING_UNINITIALIZED;
+	} else {
+		/*
+		 * fill the client keyword/mask array and remember
+		 * how many elements there were.
+		 */
+		cdm_element_count =
+			orangefs_prepare_cdm_array(client_debug_array_string);
+		if (cdm_element_count <= 0)
+			goto out;
+
+		/* Count the bytes destined for debug_help_string. */
+		byte_count += strlen(client_title);
+
+		for (i = 0; i < cdm_element_count; i++) {
+			byte_count += strlen(cdm_array[i].keyword + 2);
+			if (byte_count >= DEBUG_HELP_STRING_SIZE) {
+				pr_info("%s: overflow 1!\n", __func__);
+				goto out;
+			}
+		}
+
+		gossip_debug(GOSSIP_UTILS_DEBUG,
+			     "%s: cdm_element_count:%d:\n",
+			     __func__,
+			     cdm_element_count);
+	}
+
+	byte_count += strlen(kernel_title);
+	for (i = 0; i < num_kmod_keyword_mask_map; i++) {
+		byte_count +=
+			strlen(s_kmod_keyword_mask_map[i].keyword + 2);
+		if (byte_count >= DEBUG_HELP_STRING_SIZE) {
+			pr_info("%s: overflow 2!\n", __func__);
+			goto out;
+		}
+	}
+
+	/* build debug_help_string. */
+	debug_help_string = kzalloc(DEBUG_HELP_STRING_SIZE, GFP_KERNEL);
+	if (!debug_help_string) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	strcat(debug_help_string, client_title);
+
+	if (!at_boot) {
+		for (i = 0; i < cdm_element_count; i++) {
+			strcat(debug_help_string, "\t");
+			strcat(debug_help_string, cdm_array[i].keyword);
+			strcat(debug_help_string, "\n");
+		}
+	}
+
+	strcat(debug_help_string, "\n");
+	strcat(debug_help_string, kernel_title);
+
+	for (i = 0; i < num_kmod_keyword_mask_map; i++) {
+		strcat(debug_help_string, "\t");
+		strcat(debug_help_string, s_kmod_keyword_mask_map[i].keyword);
+		strcat(debug_help_string, "\n");
+	}
+
+	rc = 0;
+
+out:
+
+	return rc;
+
+}
+
+/*
+ * kernel = type 0
+ * client = type 1
+ */
+void debug_mask_to_string(void *mask, int type)
+{
+	int i;
+	int len = 0;
+	char *debug_string;
+	int element_count = 0;
+
+	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: start\n", __func__);
+
+	if (type) {
+		debug_string = client_debug_string;
+		element_count = cdm_element_count;
+	} else {
+		debug_string = kernel_debug_string;
+		element_count = num_kmod_keyword_mask_map;
+	}
+
+	memset(debug_string, 0, ORANGEFS_MAX_DEBUG_STRING_LEN);
+
+	/*
+	 * Some keywords, like "all" or "verbose", are amalgams of
+	 * numerous other keywords. Make a special check for those
+	 * before grinding through the whole mask only to find out
+	 * later...
+	 */
+	if (check_amalgam_keyword(mask, type))
+		goto out;
+
+	/* Build the debug string. */
+	for (i = 0; i < element_count; i++)
+		if (type)
+			do_c_string(mask, i);
+		else
+			do_k_string(mask, i);
+
+	len = strlen(debug_string);
+
+	if ((len) && (type))
+		client_debug_string[len - 1] = '\0';
+	else if (len)
+		kernel_debug_string[len - 1] = '\0';
+	else if (type)
+		strcpy(client_debug_string, "none");
+	else
+		strcpy(kernel_debug_string, "none");
+
+out:
+gossip_debug(GOSSIP_UTILS_DEBUG, "%s: string:%s:\n", __func__, debug_string);
+
+	return;
+
+}
+
+void do_k_string(void *k_mask, int index)
+{
+	__u64 *mask = (__u64 *) k_mask;
+
+	if (keyword_is_amalgam((char *) s_kmod_keyword_mask_map[index].keyword))
+		goto out;
+
+	if (*mask & s_kmod_keyword_mask_map[index].mask_val) {
+		if ((strlen(kernel_debug_string) +
+		     strlen(s_kmod_keyword_mask_map[index].keyword))
+			< ORANGEFS_MAX_DEBUG_STRING_LEN - 1) {
+				strcat(kernel_debug_string,
+				       s_kmod_keyword_mask_map[index].keyword);
+				strcat(kernel_debug_string, ",");
+			} else {
+				gossip_err("%s: overflow!\n", __func__);
+				strcpy(kernel_debug_string, ORANGEFS_ALL);
+				goto out;
+			}
+	}
+
+out:
+
+	return;
+}
+
+void do_c_string(void *c_mask, int index)
+{
+	struct client_debug_mask *mask = (struct client_debug_mask *) c_mask;
+
+	if (keyword_is_amalgam(cdm_array[index].keyword))
+		goto out;
+
+	if ((mask->mask1 & cdm_array[index].mask1) ||
+	    (mask->mask2 & cdm_array[index].mask2)) {
+		if ((strlen(client_debug_string) +
+		     strlen(cdm_array[index].keyword) + 1)
+			< ORANGEFS_MAX_DEBUG_STRING_LEN - 2) {
+				strcat(client_debug_string,
+				       cdm_array[index].keyword);
+				strcat(client_debug_string, ",");
+			} else {
+				gossip_err("%s: overflow!\n", __func__);
+				strcpy(client_debug_string, ORANGEFS_ALL);
+				goto out;
+			}
+	}
+out:
+	return;
+}
+
+int keyword_is_amalgam(char *keyword)
+{
+	int rc = 0;
+
+	if ((!strcmp(keyword, ORANGEFS_ALL)) || (!strcmp(keyword, ORANGEFS_VERBOSE)))
+		rc = 1;
+
+	return rc;
+}
+
+/*
+ * kernel = type 0
+ * client = type 1
+ *
+ * return 1 if we found an amalgam.
+ */
+int check_amalgam_keyword(void *mask, int type)
+{
+	__u64 *k_mask;
+	struct client_debug_mask *c_mask;
+	int k_all_index = num_kmod_keyword_mask_map - 1;
+	int rc = 0;
+
+	if (type) {
+		c_mask = (struct client_debug_mask *) mask;
+
+		if ((c_mask->mask1 == cdm_array[client_all_index].mask1) &&
+		    (c_mask->mask2 == cdm_array[client_all_index].mask2)) {
+			strcpy(client_debug_string, ORANGEFS_ALL);
+			rc = 1;
+			goto out;
+		}
+
+		if ((c_mask->mask1 == cdm_array[client_verbose_index].mask1) &&
+		    (c_mask->mask2 == cdm_array[client_verbose_index].mask2)) {
+			strcpy(client_debug_string, ORANGEFS_VERBOSE);
+			rc = 1;
+			goto out;
+		}
+
+	} else {
+		k_mask = (__u64 *) mask;
+
+		if (*k_mask >= s_kmod_keyword_mask_map[k_all_index].mask_val) {
+			strcpy(kernel_debug_string, ORANGEFS_ALL);
+			rc = 1;
+			goto out;
+		}
+	}
+
+out:
+
+	return rc;
+}
+
+/*
+ * kernel = type 0
+ * client = type 1
+ */
+void debug_string_to_mask(char *debug_string, void *mask, int type)
+{
+	char *unchecked_keyword;
+	int i;
+	char *strsep_fodder = kstrdup(debug_string, GFP_KERNEL);
+	char *original_pointer;
+	int element_count = 0;
+	struct client_debug_mask *c_mask;
+	__u64 *k_mask;
+
+	gossip_debug(GOSSIP_UTILS_DEBUG, "%s: start\n", __func__);
+
+	if (type) {
+		c_mask = (struct client_debug_mask *)mask;
+		element_count = cdm_element_count;
+	} else {
+		k_mask = (__u64 *)mask;
+		*k_mask = 0;
+		element_count = num_kmod_keyword_mask_map;
+	}
+
+	original_pointer = strsep_fodder;
+	while ((unchecked_keyword = strsep(&strsep_fodder, ",")))
+		if (strlen(unchecked_keyword)) {
+			for (i = 0; i < element_count; i++)
+				if (type)
+					do_c_mask(i,
+						  unchecked_keyword,
+						  &c_mask);
+				else
+					do_k_mask(i,
+						  unchecked_keyword,
+						  &k_mask);
+		}
+
+	kfree(original_pointer);
+}
+
+void do_c_mask(int i,
+	       char *unchecked_keyword,
+	       struct client_debug_mask **sane_mask)
+{
+
+	if (!strcmp(cdm_array[i].keyword, unchecked_keyword)) {
+		(**sane_mask).mask1 = (**sane_mask).mask1 | cdm_array[i].mask1;
+		(**sane_mask).mask2 = (**sane_mask).mask2 | cdm_array[i].mask2;
+	}
+}
+
+void do_k_mask(int i, char *unchecked_keyword, __u64 **sane_mask)
+{
+
+	if (!strcmp(s_kmod_keyword_mask_map[i].keyword, unchecked_keyword))
+		**sane_mask = (**sane_mask) |
+				s_kmod_keyword_mask_map[i].mask_val;
+}
