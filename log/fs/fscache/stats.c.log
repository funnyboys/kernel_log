commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index 00564a1dfd76..a5aa93ece8c5 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /* FS-Cache statistics
  *
  * Copyright (C) 2007 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
  */
 
 #define FSCACHE_DEBUG_LEVEL THREAD

commit 3f3942aca6da351a12543aa776467791b63b3a78
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 15 15:57:23 2018 +0200

    proc: introduce proc_create_single{,_data}
    
    Variants of proc_create{,_data} that directly take a seq_file show
    callback and drastically reduces the boilerplate code in the callers.
    
    All trivial callers converted over.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index fcc8c2f2690e..00564a1dfd76 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -138,7 +138,7 @@ atomic_t fscache_n_cache_culled_objects;
 /*
  * display the general statistics
  */
-static int fscache_stats_show(struct seq_file *m, void *v)
+int fscache_stats_show(struct seq_file *m, void *v)
 {
 	seq_puts(m, "FS-Cache statistics\n");
 
@@ -284,18 +284,3 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_cache_culled_objects));
 	return 0;
 }
-
-/*
- * open "/proc/fs/fscache/stats" allowing provision of a statistical summary
- */
-static int fscache_stats_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, fscache_stats_show, NULL);
-}
-
-const struct file_operations fscache_stats_fops = {
-	.open		= fscache_stats_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release        = single_release,
-};

commit bfa3837ec3ccda3138ce9b798107aadcc6d2e78c
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 4 13:41:26 2018 +0100

    fscache, cachefiles: Fix checker warnings
    
    Fix a couple of checker warnings in fscache and cachefiles:
    
     (1) fscache_n_op_requeue is never used, so get rid of it.
    
     (2) cachefiles_uncache_page() is passed in a lock that it releases, so
         this needs annotating.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index 7ac6e839b065..fcc8c2f2690e 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -21,7 +21,6 @@
 atomic_t fscache_n_op_pend;
 atomic_t fscache_n_op_run;
 atomic_t fscache_n_op_enqueue;
-atomic_t fscache_n_op_requeue;
 atomic_t fscache_n_op_deferred_release;
 atomic_t fscache_n_op_initialised;
 atomic_t fscache_n_op_release;

commit 84c60b1388249a0167d5fe8160f84e66a1221ba8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri May 27 22:40:31 2016 -0400

    drop redundant ->owner initializations
    
    it's not needed for file_operations of inodes located on fs defined
    in the hosting module and for file_operations that go into procfs.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index 7cfa0aacdf6d..7ac6e839b065 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -295,7 +295,6 @@ static int fscache_stats_open(struct inode *inode, struct file *file)
 }
 
 const struct file_operations fscache_stats_fops = {
-	.owner		= THIS_MODULE,
 	.open		= fscache_stats_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,

commit 03cdd0e4b9a98ae995b81cd8f58e992ec3f44ae2
Author: David Howells <dhowells@redhat.com>
Date:   Wed Feb 25 13:21:15 2015 +0000

    FS-Cache: Count the number of initialised operations
    
    Count and display through /proc/fs/fscache/stats the number of initialised
    operations.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Steve Dickson <steved@redhat.com>
    Acked-by: Jeff Layton <jeff.layton@primarydata.com>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index 3a722e8f2307..7cfa0aacdf6d 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -23,6 +23,7 @@ atomic_t fscache_n_op_run;
 atomic_t fscache_n_op_enqueue;
 atomic_t fscache_n_op_requeue;
 atomic_t fscache_n_op_deferred_release;
+atomic_t fscache_n_op_initialised;
 atomic_t fscache_n_op_release;
 atomic_t fscache_n_op_gc;
 atomic_t fscache_n_op_cancelled;
@@ -251,7 +252,8 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_op_enqueue),
 		   atomic_read(&fscache_n_op_cancelled),
 		   atomic_read(&fscache_n_op_rejected));
-	seq_printf(m, "Ops    : dfr=%u rel=%u gc=%u\n",
+	seq_printf(m, "Ops    : ini=%u dfr=%u rel=%u gc=%u\n",
+		   atomic_read(&fscache_n_op_initialised),
 		   atomic_read(&fscache_n_op_deferred_release),
 		   atomic_read(&fscache_n_op_release),
 		   atomic_read(&fscache_n_op_gc));

commit 182d919b84902eece162c63ed3d476c8016b4197
Author: David Howells <dhowells@redhat.com>
Date:   Thu Feb 19 23:47:31 2015 +0000

    FS-Cache: Count culled objects and objects rejected due to lack of space
    
    Count the number of objects that get culled by the cache backend and the
    number of objects that the cache backend declines to instantiate due to lack
    of space in the cache.
    
    These numbers are made available through /proc/fs/fscache/stats
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Steve Dickson <steved@redhat.com>
    Acked-by: Jeff Layton <jeff.layton@primarydata.com>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index 40d13c70ef51..3a722e8f2307 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -130,6 +130,11 @@ atomic_t fscache_n_cop_write_page;
 atomic_t fscache_n_cop_uncache_page;
 atomic_t fscache_n_cop_dissociate_pages;
 
+atomic_t fscache_n_cache_no_space_reject;
+atomic_t fscache_n_cache_stale_objects;
+atomic_t fscache_n_cache_retired_objects;
+atomic_t fscache_n_cache_culled_objects;
+
 /*
  * display the general statistics
  */
@@ -271,6 +276,11 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_cop_write_page),
 		   atomic_read(&fscache_n_cop_uncache_page),
 		   atomic_read(&fscache_n_cop_dissociate_pages));
+	seq_printf(m, "CacheEv: nsp=%d stl=%d rtr=%d cul=%d\n",
+		   atomic_read(&fscache_n_cache_no_space_reject),
+		   atomic_read(&fscache_n_cache_stale_objects),
+		   atomic_read(&fscache_n_cache_retired_objects),
+		   atomic_read(&fscache_n_cache_culled_objects));
 	return 0;
 }
 

commit ec686c9239b4d472052a271c505d04dae84214cc
Author: Anurup m <anurup.m@huawei.com>
Date:   Mon Apr 29 15:05:52 2013 -0700

    fs/fscache/stats.c: fix memory leak
    
    There is a kernel memory leak observed when the proc file
    /proc/fs/fscache/stats is read.
    
    The reason is that in fscache_stats_open, single_open is called and the
    respective release function is not called during release.  Hence fix
    with correct release function - single_release().
    
    Addresses https://bugzilla.kernel.org/show_bug.cgi?id=57101
    
    Signed-off-by: Anurup m <anurup.m@huawei.com>
    Cc: shyju pv <shyju.pv@huawei.com>
    Cc: Sanil kumar <sanil.kumar@huawei.com>
    Cc: Nataraj m <nataraj.m@huawei.com>
    Cc: Li Zefan <lizefan@huawei.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index 8179e8bc4a3d..40d13c70ef51 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -287,5 +287,5 @@ const struct file_operations fscache_stats_fops = {
 	.open		= fscache_stats_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
-	.release	= seq_release,
+	.release        = single_release,
 };

commit 8c209ce721444a61b61d9e772746c721e4d8d1e8
Author: David Howells <dhowells@redhat.com>
Date:   Wed Dec 5 13:34:49 2012 +0000

    NFS: nfs_migrate_page() does not wait for FS-Cache to finish with a page
    
    nfs_migrate_page() does not wait for FS-Cache to finish with a page, probably
    leading to the following bad-page-state:
    
     BUG: Bad page state in process python-bin  pfn:17d39b
     page:ffffea00053649e8 flags:004000000000100c count:0 mapcount:0 mapping:(null)
    index:38686 (Tainted: G    B      ---------------- )
     Pid: 31053, comm: python-bin Tainted: G    B      ----------------
    2.6.32-71.24.1.el6.x86_64 #1
     Call Trace:
     [<ffffffff8111bfe7>] bad_page+0x107/0x160
     [<ffffffff8111ee69>] free_hot_cold_page+0x1c9/0x220
     [<ffffffff8111ef19>] __pagevec_free+0x59/0xb0
     [<ffffffff8104b988>] ? flush_tlb_others_ipi+0x128/0x130
     [<ffffffff8112230c>] release_pages+0x21c/0x250
     [<ffffffff8115b92a>] ? remove_migration_pte+0x28a/0x2b0
     [<ffffffff8115f3f8>] ? mem_cgroup_get_reclaim_stat_from_page+0x18/0x70
     [<ffffffff81122687>] ____pagevec_lru_add+0x167/0x180
     [<ffffffff811226f8>] __lru_cache_add+0x58/0x70
     [<ffffffff81122731>] lru_cache_add_lru+0x21/0x40
     [<ffffffff81123f49>] putback_lru_page+0x69/0x100
     [<ffffffff8115c0bd>] migrate_pages+0x13d/0x5d0
     [<ffffffff81122687>] ? ____pagevec_lru_add+0x167/0x180
     [<ffffffff81152ab0>] ? compaction_alloc+0x0/0x370
     [<ffffffff8115255c>] compact_zone+0x4cc/0x600
     [<ffffffff8111cfac>] ? get_page_from_freelist+0x15c/0x820
     [<ffffffff810672f4>] ? check_preempt_wakeup+0x1c4/0x3c0
     [<ffffffff8115290e>] compact_zone_order+0x7e/0xb0
     [<ffffffff81152a49>] try_to_compact_pages+0x109/0x170
     [<ffffffff8111e94d>] __alloc_pages_nodemask+0x5ed/0x850
     [<ffffffff814c9136>] ? thread_return+0x4e/0x778
     [<ffffffff81150d43>] alloc_pages_vma+0x93/0x150
     [<ffffffff81167ea5>] do_huge_pmd_anonymous_page+0x135/0x340
     [<ffffffff814cb6f6>] ? rwsem_down_read_failed+0x26/0x30
     [<ffffffff81136755>] handle_mm_fault+0x245/0x2b0
     [<ffffffff814ce383>] do_page_fault+0x123/0x3a0
     [<ffffffff814cbdf5>] page_fault+0x25/0x30
    
    nfs_migrate_page() calls nfs_fscache_release_page() which doesn't actually wait
    - even if __GFP_WAIT is set.  The reason that doesn't wait is that
    fscache_maybe_release_page() might deadlock the allocator as the work threads
    writing to the cache may all end up sleeping on memory allocation.
    
    However, I wonder if that is actually a problem.  There are a number of things
    I can do to deal with this:
    
     (1) Make nfs_migrate_page() wait.
    
     (2) Make fscache_maybe_release_page() honour the __GFP_WAIT flag.
    
     (3) Set a timeout around the wait.
    
     (4) Make nfs_migrate_page() return an error if the page is still busy.
    
    For the moment, I'll select (2) and (4).
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index 51cdaee14109..8179e8bc4a3d 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -69,6 +69,7 @@ atomic_t fscache_n_store_vmscan_not_storing;
 atomic_t fscache_n_store_vmscan_gone;
 atomic_t fscache_n_store_vmscan_busy;
 atomic_t fscache_n_store_vmscan_cancelled;
+atomic_t fscache_n_store_vmscan_wait;
 
 atomic_t fscache_n_marks;
 atomic_t fscache_n_uncaches;
@@ -232,11 +233,12 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_store_radix_deletes),
 		   atomic_read(&fscache_n_store_pages_over_limit));
 
-	seq_printf(m, "VmScan : nos=%u gon=%u bsy=%u can=%u\n",
+	seq_printf(m, "VmScan : nos=%u gon=%u bsy=%u can=%u wt=%u\n",
 		   atomic_read(&fscache_n_store_vmscan_not_storing),
 		   atomic_read(&fscache_n_store_vmscan_gone),
 		   atomic_read(&fscache_n_store_vmscan_busy),
-		   atomic_read(&fscache_n_store_vmscan_cancelled));
+		   atomic_read(&fscache_n_store_vmscan_cancelled),
+		   atomic_read(&fscache_n_store_vmscan_wait));
 
 	seq_printf(m, "Ops    : pend=%u run=%u enq=%u can=%u rej=%u\n",
 		   atomic_read(&fscache_n_op_pend),

commit ef778e7ae67cd426c30cad43378b908f5eb0bad5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Dec 20 21:52:36 2012 +0000

    FS-Cache: Provide proper invalidation
    
    Provide a proper invalidation method rather than relying on the netfs retiring
    the cookie it has and getting a new one.  The problem with this is that isn't
    easy for the netfs to make sure that it has completed/cancelled all its
    outstanding storage and retrieval operations on the cookie it is retiring.
    
    Instead, have the cache provide an invalidation method that will cancel or wait
    for all currently outstanding operations before invalidating the cache, and
    will cause new operations to queue up behind that.  Whilst invalidation is in
    progress, some requests will be rejected until the cache can stack a barrier on
    the operation queue to cause new operations to be deferred behind it.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index 4765190d537f..51cdaee14109 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -80,6 +80,9 @@ atomic_t fscache_n_acquires_ok;
 atomic_t fscache_n_acquires_nobufs;
 atomic_t fscache_n_acquires_oom;
 
+atomic_t fscache_n_invalidates;
+atomic_t fscache_n_invalidates_run;
+
 atomic_t fscache_n_updates;
 atomic_t fscache_n_updates_null;
 atomic_t fscache_n_updates_run;
@@ -112,6 +115,7 @@ atomic_t fscache_n_cop_alloc_object;
 atomic_t fscache_n_cop_lookup_object;
 atomic_t fscache_n_cop_lookup_complete;
 atomic_t fscache_n_cop_grab_object;
+atomic_t fscache_n_cop_invalidate_object;
 atomic_t fscache_n_cop_update_object;
 atomic_t fscache_n_cop_drop_object;
 atomic_t fscache_n_cop_put_object;
@@ -168,6 +172,10 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_object_created),
 		   atomic_read(&fscache_n_object_lookups_timed_out));
 
+	seq_printf(m, "Invals : n=%u run=%u\n",
+		   atomic_read(&fscache_n_invalidates),
+		   atomic_read(&fscache_n_invalidates_run));
+
 	seq_printf(m, "Updates: n=%u nul=%u run=%u\n",
 		   atomic_read(&fscache_n_updates),
 		   atomic_read(&fscache_n_updates_null),
@@ -246,7 +254,8 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_cop_lookup_object),
 		   atomic_read(&fscache_n_cop_lookup_complete),
 		   atomic_read(&fscache_n_cop_grab_object));
-	seq_printf(m, "CacheOp: upo=%d dro=%d pto=%d atc=%d syn=%d\n",
+	seq_printf(m, "CacheOp: inv=%d upo=%d dro=%d pto=%d atc=%d syn=%d\n",
+		   atomic_read(&fscache_n_cop_invalidate_object),
 		   atomic_read(&fscache_n_cop_update_object),
 		   atomic_read(&fscache_n_cop_drop_object),
 		   atomic_read(&fscache_n_cop_put_object),

commit cc4fc29e59c386919a7674e203be7822dc968dc0
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 6 14:35:09 2010 -0700

    fs-cache: order the debugfs stats correctly
    
    Order the debugfs statistics correctly.  The values displayed through a
    seq_printf() statement should be in the same order as the names in the
    format string.
    
    In the 'Lookups' line, objects created ('crt=') and lookups timed out
    ('tmo=') have their values transposed.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index 46435f3aae68..4765190d537f 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -165,8 +165,8 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_object_lookups),
 		   atomic_read(&fscache_n_object_lookups_negative),
 		   atomic_read(&fscache_n_object_lookups_positive),
-		   atomic_read(&fscache_n_object_lookups_timed_out),
-		   atomic_read(&fscache_n_object_created));
+		   atomic_read(&fscache_n_object_created),
+		   atomic_read(&fscache_n_object_lookups_timed_out));
 
 	seq_printf(m, "Updates: n=%u nul=%u run=%u\n",
 		   atomic_read(&fscache_n_updates),

commit fee096deb4f33897937b974cb2c5168bab7935be
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 19 18:12:05 2009 +0000

    CacheFiles: Catch an overly long wait for an old active object
    
    Catch an overly long wait for an old, dying active object when we want to
    replace it with a new one.  The probability is that all the slow-work threads
    are hogged, and the delete can't get a look in.
    
    What we do instead is:
    
     (1) if there's nothing in the slow work queue, we sleep until either the dying
         object has finished dying or there is something in the slow work queue
         behind which we can queue our object.
    
     (2) if there is something in the slow work queue, we return ETIMEDOUT to
         fscache_lookup_object(), which then puts us back on the slow work queue,
         presumably behind the deletion that we're blocked by.  We are then
         deferred for a while until we work our way back through the queue -
         without blocking a slow-work thread unnecessarily.
    
    A backtrace similar to the following may appear in the log without this patch:
    
            INFO: task kslowd004:5711 blocked for more than 120 seconds.
            "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
            kslowd004     D 0000000000000000     0  5711      2 0x00000080
             ffff88000340bb80 0000000000000046 ffff88002550d000 0000000000000000
             ffff88002550d000 0000000000000007 ffff88000340bfd8 ffff88002550d2a8
             000000000000ddf0 00000000000118c0 00000000000118c0 ffff88002550d2a8
            Call Trace:
             [<ffffffff81058e21>] ? trace_hardirqs_on+0xd/0xf
             [<ffffffffa011c4d8>] ? cachefiles_wait_bit+0x0/0xd [cachefiles]
             [<ffffffffa011c4e1>] cachefiles_wait_bit+0x9/0xd [cachefiles]
             [<ffffffff81353153>] __wait_on_bit+0x43/0x76
             [<ffffffff8111ae39>] ? ext3_xattr_get+0x1ec/0x270
             [<ffffffff813531ef>] out_of_line_wait_on_bit+0x69/0x74
             [<ffffffffa011c4d8>] ? cachefiles_wait_bit+0x0/0xd [cachefiles]
             [<ffffffff8104c125>] ? wake_bit_function+0x0/0x2e
             [<ffffffffa011bc79>] cachefiles_mark_object_active+0x203/0x23b [cachefiles]
             [<ffffffffa011c209>] cachefiles_walk_to_object+0x558/0x827 [cachefiles]
             [<ffffffffa011a429>] cachefiles_lookup_object+0xac/0x12a [cachefiles]
             [<ffffffffa00aa1e9>] fscache_lookup_object+0x1c7/0x214 [fscache]
             [<ffffffffa00aafc5>] fscache_object_state_machine+0xa5/0x52d [fscache]
             [<ffffffffa00ab4ac>] fscache_object_slow_work_execute+0x5f/0xa0 [fscache]
             [<ffffffff81082093>] slow_work_execute+0x18f/0x2d1
             [<ffffffff8108239a>] slow_work_thread+0x1c5/0x308
             [<ffffffff8104c0f1>] ? autoremove_wake_function+0x0/0x34
             [<ffffffff810821d5>] ? slow_work_thread+0x0/0x308
             [<ffffffff8104be91>] kthread+0x7a/0x82
             [<ffffffff8100beda>] child_rip+0xa/0x20
             [<ffffffff8100b87c>] ? restore_args+0x0/0x30
             [<ffffffff8104be17>] ? kthread+0x0/0x82
             [<ffffffff8100bed0>] ? child_rip+0x0/0x20
            1 lock held by kslowd004/5711:
             #0:  (&sb->s_type->i_mutex_key#7/1){+.+.+.}, at: [<ffffffffa011be64>] cachefiles_walk_to_object+0x1b3/0x827 [cachefiles]
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index 05f77caf4a2d..46435f3aae68 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -98,6 +98,7 @@ atomic_t fscache_n_object_no_alloc;
 atomic_t fscache_n_object_lookups;
 atomic_t fscache_n_object_lookups_negative;
 atomic_t fscache_n_object_lookups_positive;
+atomic_t fscache_n_object_lookups_timed_out;
 atomic_t fscache_n_object_created;
 atomic_t fscache_n_object_avail;
 atomic_t fscache_n_object_dead;
@@ -160,10 +161,11 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_acquires_nobufs),
 		   atomic_read(&fscache_n_acquires_oom));
 
-	seq_printf(m, "Lookups: n=%u neg=%u pos=%u crt=%u\n",
+	seq_printf(m, "Lookups: n=%u neg=%u pos=%u crt=%u tmo=%u\n",
 		   atomic_read(&fscache_n_object_lookups),
 		   atomic_read(&fscache_n_object_lookups_negative),
 		   atomic_read(&fscache_n_object_lookups_positive),
+		   atomic_read(&fscache_n_object_lookups_timed_out),
 		   atomic_read(&fscache_n_object_created));
 
 	seq_printf(m, "Updates: n=%u nul=%u run=%u\n",

commit 60d543ca724be155c2b6166e36a00c80b21bd810
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 19 18:11:45 2009 +0000

    FS-Cache: Start processing an object's operations on that object's death
    
    Start processing an object's operations when that object moves into the DYING
    state as the object cannot be destroyed until all its outstanding operations
    have completed.
    
    Furthermore, make sure that read and allocation operations handle being woken
    up on a dead object.  Such events are recorded in the Allocs.abt and
    Retrvls.abt statistics as viewable through /proc/fs/fscache/stats.
    
    The code for waiting for object activation for the read and allocation
    operations is also extracted into its own function as it is much the same in
    all cases, differing only in the stats incremented.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index 9e15289eb5c1..05f77caf4a2d 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -39,6 +39,7 @@ atomic_t fscache_n_allocs_ok;
 atomic_t fscache_n_allocs_wait;
 atomic_t fscache_n_allocs_nobufs;
 atomic_t fscache_n_allocs_intr;
+atomic_t fscache_n_allocs_object_dead;
 atomic_t fscache_n_alloc_ops;
 atomic_t fscache_n_alloc_op_waits;
 
@@ -49,6 +50,7 @@ atomic_t fscache_n_retrievals_nodata;
 atomic_t fscache_n_retrievals_nobufs;
 atomic_t fscache_n_retrievals_intr;
 atomic_t fscache_n_retrievals_nomem;
+atomic_t fscache_n_retrievals_object_dead;
 atomic_t fscache_n_retrieval_ops;
 atomic_t fscache_n_retrieval_op_waits;
 
@@ -188,9 +190,10 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_allocs_wait),
 		   atomic_read(&fscache_n_allocs_nobufs),
 		   atomic_read(&fscache_n_allocs_intr));
-	seq_printf(m, "Allocs : ops=%u owt=%u\n",
+	seq_printf(m, "Allocs : ops=%u owt=%u abt=%u\n",
 		   atomic_read(&fscache_n_alloc_ops),
-		   atomic_read(&fscache_n_alloc_op_waits));
+		   atomic_read(&fscache_n_alloc_op_waits),
+		   atomic_read(&fscache_n_allocs_object_dead));
 
 	seq_printf(m, "Retrvls: n=%u ok=%u wt=%u nod=%u nbf=%u"
 		   " int=%u oom=%u\n",
@@ -201,9 +204,10 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_retrievals_nobufs),
 		   atomic_read(&fscache_n_retrievals_intr),
 		   atomic_read(&fscache_n_retrievals_nomem));
-	seq_printf(m, "Retrvls: ops=%u owt=%u\n",
+	seq_printf(m, "Retrvls: ops=%u owt=%u abt=%u\n",
 		   atomic_read(&fscache_n_retrieval_ops),
-		   atomic_read(&fscache_n_retrieval_op_waits));
+		   atomic_read(&fscache_n_retrieval_op_waits),
+		   atomic_read(&fscache_n_retrievals_object_dead));
 
 	seq_printf(m, "Stores : n=%u ok=%u agn=%u nbf=%u oom=%u\n",
 		   atomic_read(&fscache_n_stores),

commit 2175bb06dc6cf2af9c098a1770561f9e63edae4e
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 19 18:11:38 2009 +0000

    FS-Cache: Add a retirement stat counter
    
    Add a stat counter to count retirement events rather than ordinary release
    events (the retire argument to fscache_relinquish_cookie()).
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index cda69994e06d..9e15289eb5c1 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -85,6 +85,7 @@ atomic_t fscache_n_updates_run;
 atomic_t fscache_n_relinquishes;
 atomic_t fscache_n_relinquishes_null;
 atomic_t fscache_n_relinquishes_waitcrt;
+atomic_t fscache_n_relinquishes_retire;
 
 atomic_t fscache_n_cookie_index;
 atomic_t fscache_n_cookie_data;
@@ -168,10 +169,11 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_updates_null),
 		   atomic_read(&fscache_n_updates_run));
 
-	seq_printf(m, "Relinqs: n=%u nul=%u wcr=%u\n",
+	seq_printf(m, "Relinqs: n=%u nul=%u wcr=%u rtr=%u\n",
 		   atomic_read(&fscache_n_relinquishes),
 		   atomic_read(&fscache_n_relinquishes_null),
-		   atomic_read(&fscache_n_relinquishes_waitcrt));
+		   atomic_read(&fscache_n_relinquishes_waitcrt),
+		   atomic_read(&fscache_n_relinquishes_retire));
 
 	seq_printf(m, "AttrChg: n=%u ok=%u nbf=%u oom=%u run=%u\n",
 		   atomic_read(&fscache_n_attr_changed),

commit 201a15428bd54f83eccec8b7c64a04b8f9431204
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 19 18:11:35 2009 +0000

    FS-Cache: Handle pages pending storage that get evicted under OOM conditions
    
    Handle netfs pages that the vmscan algorithm wants to evict from the pagecache
    under OOM conditions, but that are waiting for write to the cache.  Under these
    conditions, vmscan calls the releasepage() function of the netfs, asking if a
    page can be discarded.
    
    The problem is typified by the following trace of a stuck process:
    
            kslowd005     D 0000000000000000     0  4253      2 0x00000080
             ffff88001b14f370 0000000000000046 ffff880020d0d000 0000000000000007
             0000000000000006 0000000000000001 ffff88001b14ffd8 ffff880020d0d2a8
             000000000000ddf0 00000000000118c0 00000000000118c0 ffff880020d0d2a8
            Call Trace:
             [<ffffffffa00782d8>] __fscache_wait_on_page_write+0x8b/0xa7 [fscache]
             [<ffffffff8104c0f1>] ? autoremove_wake_function+0x0/0x34
             [<ffffffffa0078240>] ? __fscache_check_page_write+0x63/0x70 [fscache]
             [<ffffffffa00b671d>] nfs_fscache_release_page+0x4e/0xc4 [nfs]
             [<ffffffffa00927f0>] nfs_release_page+0x3c/0x41 [nfs]
             [<ffffffff810885d3>] try_to_release_page+0x32/0x3b
             [<ffffffff81093203>] shrink_page_list+0x316/0x4ac
             [<ffffffff8109372b>] shrink_inactive_list+0x392/0x67c
             [<ffffffff813532fa>] ? __mutex_unlock_slowpath+0x100/0x10b
             [<ffffffff81058df0>] ? trace_hardirqs_on_caller+0x10c/0x130
             [<ffffffff8135330e>] ? mutex_unlock+0x9/0xb
             [<ffffffff81093aa2>] shrink_list+0x8d/0x8f
             [<ffffffff81093d1c>] shrink_zone+0x278/0x33c
             [<ffffffff81052d6c>] ? ktime_get_ts+0xad/0xba
             [<ffffffff81094b13>] try_to_free_pages+0x22e/0x392
             [<ffffffff81091e24>] ? isolate_pages_global+0x0/0x212
             [<ffffffff8108e743>] __alloc_pages_nodemask+0x3dc/0x5cf
             [<ffffffff81089529>] grab_cache_page_write_begin+0x65/0xaa
             [<ffffffff8110f8c0>] ext3_write_begin+0x78/0x1eb
             [<ffffffff81089ec5>] generic_file_buffered_write+0x109/0x28c
             [<ffffffff8103cb69>] ? current_fs_time+0x22/0x29
             [<ffffffff8108a509>] __generic_file_aio_write+0x350/0x385
             [<ffffffff8108a588>] ? generic_file_aio_write+0x4a/0xae
             [<ffffffff8108a59e>] generic_file_aio_write+0x60/0xae
             [<ffffffff810b2e82>] do_sync_write+0xe3/0x120
             [<ffffffff8104c0f1>] ? autoremove_wake_function+0x0/0x34
             [<ffffffff810b18e1>] ? __dentry_open+0x1a5/0x2b8
             [<ffffffff810b1a76>] ? dentry_open+0x82/0x89
             [<ffffffffa00e693c>] cachefiles_write_page+0x298/0x335 [cachefiles]
             [<ffffffffa0077147>] fscache_write_op+0x178/0x2c2 [fscache]
             [<ffffffffa0075656>] fscache_op_execute+0x7a/0xd1 [fscache]
             [<ffffffff81082093>] slow_work_execute+0x18f/0x2d1
             [<ffffffff8108239a>] slow_work_thread+0x1c5/0x308
             [<ffffffff8104c0f1>] ? autoremove_wake_function+0x0/0x34
             [<ffffffff810821d5>] ? slow_work_thread+0x0/0x308
             [<ffffffff8104be91>] kthread+0x7a/0x82
             [<ffffffff8100beda>] child_rip+0xa/0x20
             [<ffffffff8100b87c>] ? restore_args+0x0/0x30
             [<ffffffff8102ef83>] ? tg_shares_up+0x171/0x227
             [<ffffffff8104be17>] ? kthread+0x0/0x82
             [<ffffffff8100bed0>] ? child_rip+0x0/0x20
    
    In the above backtrace, the following is happening:
    
     (1) A page storage operation is being executed by a slow-work thread
         (fscache_write_op()).
    
     (2) FS-Cache farms the operation out to the cache to perform
         (cachefiles_write_page()).
    
     (3) CacheFiles is then calling Ext3 to perform the actual write, using Ext3's
         standard write (do_sync_write()) under KERNEL_DS directly from the netfs
         page.
    
     (4) However, for Ext3 to perform the write, it must allocate some memory, in
         particular, it must allocate at least one page cache page into which it
         can copy the data from the netfs page.
    
     (5) Under OOM conditions, the memory allocator can't immediately come up with
         a page, so it uses vmscan to find something to discard
         (try_to_free_pages()).
    
     (6) vmscan finds a clean netfs page it might be able to discard (possibly the
         one it's trying to write out).
    
     (7) The netfs is called to throw the page away (nfs_release_page()) - but it's
         called with __GFP_WAIT, so the netfs decides to wait for the store to
         complete (__fscache_wait_on_page_write()).
    
     (8) This blocks a slow-work processing thread - possibly against itself.
    
    The system ends up stuck because it can't write out any netfs pages to the
    cache without allocating more memory.
    
    To avoid this, we make FS-Cache cancel some writes that aren't in the middle of
    actually being performed.  This means that some data won't make it into the
    cache this time.  To support this, a new FS-Cache function is added
    fscache_maybe_release_page() that replaces what the netfs releasepage()
    functions used to do with respect to the cache.
    
    The decisions fscache_maybe_release_page() makes are counted and displayed
    through /proc/fs/fscache/stats on a line labelled "VmScan".  There are four
    counters provided: "nos=N" - pages that weren't pending storage; "gon=N" -
    pages that were pending storage when we first looked, but weren't by the time
    we got the object lock; "bsy=N" - pages that we ignored as they were actively
    being written when we looked; and "can=N" - pages that we cancelled the storage
    of.
    
    What I'd really like to do is alter the behaviour of the cancellation
    heuristics, depending on how necessary it is to expel pages.  If there are
    plenty of other pages that aren't waiting to be written to the cache that
    could be ejected first, then it would be nice to hold up on immediate
    cancellation of cache writes - but I don't see a way of doing that.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index 045ba396dbf2..cda69994e06d 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -63,6 +63,11 @@ atomic_t fscache_n_store_pages;
 atomic_t fscache_n_store_radix_deletes;
 atomic_t fscache_n_store_pages_over_limit;
 
+atomic_t fscache_n_store_vmscan_not_storing;
+atomic_t fscache_n_store_vmscan_gone;
+atomic_t fscache_n_store_vmscan_busy;
+atomic_t fscache_n_store_vmscan_cancelled;
+
 atomic_t fscache_n_marks;
 atomic_t fscache_n_uncaches;
 
@@ -211,6 +216,12 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_store_radix_deletes),
 		   atomic_read(&fscache_n_store_pages_over_limit));
 
+	seq_printf(m, "VmScan : nos=%u gon=%u bsy=%u can=%u\n",
+		   atomic_read(&fscache_n_store_vmscan_not_storing),
+		   atomic_read(&fscache_n_store_vmscan_gone),
+		   atomic_read(&fscache_n_store_vmscan_busy),
+		   atomic_read(&fscache_n_store_vmscan_cancelled));
+
 	seq_printf(m, "Ops    : pend=%u run=%u enq=%u can=%u rej=%u\n",
 		   atomic_read(&fscache_n_op_pend),
 		   atomic_read(&fscache_n_op_run),

commit e3d4d28b1c8cc7c26536a50b43d86ccd39878550
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 19 18:11:32 2009 +0000

    FS-Cache: Handle read request vs lookup, creation or other cache failure
    
    FS-Cache doesn't correctly handle the netfs requesting a read from the cache
    on an object that failed or was withdrawn by the cache.  A trace similar to
    the following might be seen:
    
            CacheFiles: Lookup failed error -105
            [exe   ] unexpected submission OP165afe [OBJ6cac OBJECT_LC_DYING]
            [exe   ] objstate=OBJECT_LC_DYING [OBJECT_LC_DYING]
            [exe   ] objflags=0
            [exe   ] objevent=9 [fffffffffffffffb]
            [exe   ] ops=0 inp=0 exc=0
            Pid: 6970, comm: exe Not tainted 2.6.32-rc6-cachefs #50
            Call Trace:
             [<ffffffffa0076477>] fscache_submit_op+0x3ff/0x45a [fscache]
             [<ffffffffa0077997>] __fscache_read_or_alloc_pages+0x187/0x3c4 [fscache]
             [<ffffffffa00b6480>] ? nfs_readpage_from_fscache_complete+0x0/0x66 [nfs]
             [<ffffffffa00b6388>] __nfs_readpages_from_fscache+0x7e/0x176 [nfs]
             [<ffffffff8108e483>] ? __alloc_pages_nodemask+0x11c/0x5cf
             [<ffffffffa009d796>] nfs_readpages+0x114/0x1d7 [nfs]
             [<ffffffff81090314>] __do_page_cache_readahead+0x15f/0x1ec
             [<ffffffff81090228>] ? __do_page_cache_readahead+0x73/0x1ec
             [<ffffffff810903bd>] ra_submit+0x1c/0x20
             [<ffffffff810906bb>] ondemand_readahead+0x227/0x23a
             [<ffffffff81090762>] page_cache_sync_readahead+0x17/0x19
             [<ffffffff8108a99e>] generic_file_aio_read+0x236/0x5a0
             [<ffffffffa00937bd>] nfs_file_read+0xe4/0xf3 [nfs]
             [<ffffffff810b2fa2>] do_sync_read+0xe3/0x120
             [<ffffffff81354cc3>] ? _spin_unlock_irq+0x2b/0x31
             [<ffffffff8104c0f1>] ? autoremove_wake_function+0x0/0x34
             [<ffffffff811848e5>] ? selinux_file_permission+0x5d/0x10f
             [<ffffffff81352bdb>] ? thread_return+0x3e/0x101
             [<ffffffff8117d7b0>] ? security_file_permission+0x11/0x13
             [<ffffffff810b3b06>] vfs_read+0xaa/0x16f
             [<ffffffff81058df0>] ? trace_hardirqs_on_caller+0x10c/0x130
             [<ffffffff810b3c84>] sys_read+0x45/0x6c
             [<ffffffff8100ae2b>] system_call_fastpath+0x16/0x1b
    
    The object state might also be OBJECT_DYING or OBJECT_WITHDRAWING.
    
    This should be handled by simply rejecting the new operation with ENOBUFS.
    There's no need to log an error for it.  Events of this type now appear in the
    stats file under Ops:rej.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index 1d53ea68409e..045ba396dbf2 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -26,6 +26,7 @@ atomic_t fscache_n_op_deferred_release;
 atomic_t fscache_n_op_release;
 atomic_t fscache_n_op_gc;
 atomic_t fscache_n_op_cancelled;
+atomic_t fscache_n_op_rejected;
 
 atomic_t fscache_n_attr_changed;
 atomic_t fscache_n_attr_changed_ok;
@@ -210,11 +211,12 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_store_radix_deletes),
 		   atomic_read(&fscache_n_store_pages_over_limit));
 
-	seq_printf(m, "Ops    : pend=%u run=%u enq=%u can=%u\n",
+	seq_printf(m, "Ops    : pend=%u run=%u enq=%u can=%u rej=%u\n",
 		   atomic_read(&fscache_n_op_pend),
 		   atomic_read(&fscache_n_op_run),
 		   atomic_read(&fscache_n_op_enqueue),
-		   atomic_read(&fscache_n_op_cancelled));
+		   atomic_read(&fscache_n_op_cancelled),
+		   atomic_read(&fscache_n_op_rejected));
 	seq_printf(m, "Ops    : dfr=%u rel=%u gc=%u\n",
 		   atomic_read(&fscache_n_op_deferred_release),
 		   atomic_read(&fscache_n_op_release),

commit 1bccf513ac49d44604ba1cddcc29f5886e70f1b6
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 19 18:11:25 2009 +0000

    FS-Cache: Fix lock misorder in fscache_write_op()
    
    FS-Cache has two structs internally for keeping track of the internal state of
    a cached file: the fscache_cookie struct, which represents the netfs's state,
    and fscache_object struct, which represents the cache's state.  Each has a
    pointer that points to the other (when both are in existence), and each has a
    spinlock for pointer maintenance.
    
    Since netfs operations approach these structures from the cookie side, they get
    the cookie lock first, then the object lock.  Cache operations, on the other
    hand, approach from the object side, and get the object lock first.  It is not
    then permitted for a cache operation to get the cookie lock whilst it is
    holding the object lock lest deadlock occur; instead, it must do one of two
    things:
    
     (1) increment the cookie usage counter, drop the object lock and then get both
         locks in order, or
    
     (2) simply hold the object lock as certain parts of the cookie may not be
         altered whilst the object lock is held.
    
    It is also not permitted to follow either pointer without holding the lock at
    the end you start with.  To break the pointers between the cookie and the
    object, both locks must be held.
    
    fscache_write_op(), however, violates the locking rules: It attempts to get the
    cookie lock without (a) checking that the cookie pointer is a valid pointer,
    and (b) holding the object lock to protect the cookie pointer whilst it follows
    it.  This is so that it can access the pending page store tree without
    interference from __fscache_write_page().
    
    This is fixed by splitting the cookie lock, such that the page store tracking
    tree is protected by its own lock, and checking that the cookie pointer is
    non-NULL before we attempt to follow it whilst holding the object lock.
    
    The new lock is subordinate to both the cookie lock and the object lock, and so
    should be taken after those.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index 4c07439d1307..1d53ea68409e 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -58,6 +58,9 @@ atomic_t fscache_n_stores_nobufs;
 atomic_t fscache_n_stores_oom;
 atomic_t fscache_n_store_ops;
 atomic_t fscache_n_store_calls;
+atomic_t fscache_n_store_pages;
+atomic_t fscache_n_store_radix_deletes;
+atomic_t fscache_n_store_pages_over_limit;
 
 atomic_t fscache_n_marks;
 atomic_t fscache_n_uncaches;
@@ -200,9 +203,12 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_stores_again),
 		   atomic_read(&fscache_n_stores_nobufs),
 		   atomic_read(&fscache_n_stores_oom));
-	seq_printf(m, "Stores : ops=%u run=%u\n",
+	seq_printf(m, "Stores : ops=%u run=%u pgs=%u rxd=%u olm=%u\n",
 		   atomic_read(&fscache_n_store_ops),
-		   atomic_read(&fscache_n_store_calls));
+		   atomic_read(&fscache_n_store_calls),
+		   atomic_read(&fscache_n_store_pages),
+		   atomic_read(&fscache_n_store_radix_deletes),
+		   atomic_read(&fscache_n_store_pages_over_limit));
 
 	seq_printf(m, "Ops    : pend=%u run=%u enq=%u can=%u\n",
 		   atomic_read(&fscache_n_op_pend),

commit 5753c441889253e4323eee85f791a1d64cf08196
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 19 18:11:19 2009 +0000

    FS-Cache: Permit cache retrieval ops to be interrupted in the initial wait phase
    
    Permit the operations to retrieve data from the cache or to allocate space in
    the cache for future writes to be interrupted whilst they're waiting for
    permission for the operation to proceed.  Typically this wait occurs whilst the
    cache object is being looked up on disk in the background.
    
    If an interruption occurs, and the operation has not yet been given the
    go-ahead to run, the operation is dequeued and cancelled, and control returns
    to the read operation of the netfs routine with none of the requested pages
    having been read or in any way marked as known by the cache.
    
    This means that the initial wait is done interruptibly rather than
    uninterruptibly.
    
    In addition, extra stats values are made available to show the number of ops
    cancelled and the number of cache space allocations interrupted.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index 20233fb44bfd..4c07439d1307 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -25,6 +25,7 @@ atomic_t fscache_n_op_requeue;
 atomic_t fscache_n_op_deferred_release;
 atomic_t fscache_n_op_release;
 atomic_t fscache_n_op_gc;
+atomic_t fscache_n_op_cancelled;
 
 atomic_t fscache_n_attr_changed;
 atomic_t fscache_n_attr_changed_ok;
@@ -36,6 +37,7 @@ atomic_t fscache_n_allocs;
 atomic_t fscache_n_allocs_ok;
 atomic_t fscache_n_allocs_wait;
 atomic_t fscache_n_allocs_nobufs;
+atomic_t fscache_n_allocs_intr;
 atomic_t fscache_n_alloc_ops;
 atomic_t fscache_n_alloc_op_waits;
 
@@ -169,11 +171,12 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_attr_changed_nomem),
 		   atomic_read(&fscache_n_attr_changed_calls));
 
-	seq_printf(m, "Allocs : n=%u ok=%u wt=%u nbf=%u\n",
+	seq_printf(m, "Allocs : n=%u ok=%u wt=%u nbf=%u int=%u\n",
 		   atomic_read(&fscache_n_allocs),
 		   atomic_read(&fscache_n_allocs_ok),
 		   atomic_read(&fscache_n_allocs_wait),
-		   atomic_read(&fscache_n_allocs_nobufs));
+		   atomic_read(&fscache_n_allocs_nobufs),
+		   atomic_read(&fscache_n_allocs_intr));
 	seq_printf(m, "Allocs : ops=%u owt=%u\n",
 		   atomic_read(&fscache_n_alloc_ops),
 		   atomic_read(&fscache_n_alloc_op_waits));
@@ -201,10 +204,11 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_store_ops),
 		   atomic_read(&fscache_n_store_calls));
 
-	seq_printf(m, "Ops    : pend=%u run=%u enq=%u\n",
+	seq_printf(m, "Ops    : pend=%u run=%u enq=%u can=%u\n",
 		   atomic_read(&fscache_n_op_pend),
 		   atomic_read(&fscache_n_op_run),
-		   atomic_read(&fscache_n_op_enqueue));
+		   atomic_read(&fscache_n_op_enqueue),
+		   atomic_read(&fscache_n_op_cancelled));
 	seq_printf(m, "Ops    : dfr=%u rel=%u gc=%u\n",
 		   atomic_read(&fscache_n_op_deferred_release),
 		   atomic_read(&fscache_n_op_release),

commit 52bd75fdb135d6133d878ae60c6e7e3f4ebc1cfc
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 19 18:11:08 2009 +0000

    FS-Cache: Add counters for entry/exit to/from cache operation functions
    
    Count entries to and exits from cache operation table functions.  Maintain
    these as a single counter that's added to or removed from as appropriate.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
index 65deb99e756b..20233fb44bfd 100644
--- a/fs/fscache/stats.c
+++ b/fs/fscache/stats.c
@@ -93,6 +93,23 @@ atomic_t fscache_n_checkaux_okay;
 atomic_t fscache_n_checkaux_update;
 atomic_t fscache_n_checkaux_obsolete;
 
+atomic_t fscache_n_cop_alloc_object;
+atomic_t fscache_n_cop_lookup_object;
+atomic_t fscache_n_cop_lookup_complete;
+atomic_t fscache_n_cop_grab_object;
+atomic_t fscache_n_cop_update_object;
+atomic_t fscache_n_cop_drop_object;
+atomic_t fscache_n_cop_put_object;
+atomic_t fscache_n_cop_sync_cache;
+atomic_t fscache_n_cop_attr_changed;
+atomic_t fscache_n_cop_read_or_alloc_page;
+atomic_t fscache_n_cop_read_or_alloc_pages;
+atomic_t fscache_n_cop_allocate_page;
+atomic_t fscache_n_cop_allocate_pages;
+atomic_t fscache_n_cop_write_page;
+atomic_t fscache_n_cop_uncache_page;
+atomic_t fscache_n_cop_dissociate_pages;
+
 /*
  * display the general statistics
  */
@@ -192,6 +209,26 @@ static int fscache_stats_show(struct seq_file *m, void *v)
 		   atomic_read(&fscache_n_op_deferred_release),
 		   atomic_read(&fscache_n_op_release),
 		   atomic_read(&fscache_n_op_gc));
+
+	seq_printf(m, "CacheOp: alo=%d luo=%d luc=%d gro=%d\n",
+		   atomic_read(&fscache_n_cop_alloc_object),
+		   atomic_read(&fscache_n_cop_lookup_object),
+		   atomic_read(&fscache_n_cop_lookup_complete),
+		   atomic_read(&fscache_n_cop_grab_object));
+	seq_printf(m, "CacheOp: upo=%d dro=%d pto=%d atc=%d syn=%d\n",
+		   atomic_read(&fscache_n_cop_update_object),
+		   atomic_read(&fscache_n_cop_drop_object),
+		   atomic_read(&fscache_n_cop_put_object),
+		   atomic_read(&fscache_n_cop_attr_changed),
+		   atomic_read(&fscache_n_cop_sync_cache));
+	seq_printf(m, "CacheOp: rap=%d ras=%d alp=%d als=%d wrp=%d ucp=%d dsp=%d\n",
+		   atomic_read(&fscache_n_cop_read_or_alloc_page),
+		   atomic_read(&fscache_n_cop_read_or_alloc_pages),
+		   atomic_read(&fscache_n_cop_allocate_page),
+		   atomic_read(&fscache_n_cop_allocate_pages),
+		   atomic_read(&fscache_n_cop_write_page),
+		   atomic_read(&fscache_n_cop_uncache_page),
+		   atomic_read(&fscache_n_cop_dissociate_pages));
 	return 0;
 }
 

commit 7394daa8c61dfda4baa687f133748fa0b599b017
Author: David Howells <dhowells@redhat.com>
Date:   Fri Apr 3 16:42:37 2009 +0100

    FS-Cache: Add use of /proc and presentation of statistics
    
    Make FS-Cache create its /proc interface and present various statistical
    information through it.  Also provide the functions for updating this
    information.
    
    These features are enabled by:
    
            CONFIG_FSCACHE_PROC
            CONFIG_FSCACHE_STATS
            CONFIG_FSCACHE_HISTOGRAM
    
    The /proc directory for FS-Cache is also exported so that caching modules can
    add their own statistics there too.
    
    The FS-Cache module is loadable at this point, and the statistics files can be
    examined by userspace:
    
            cat /proc/fs/fscache/stats
            cat /proc/fs/fscache/histogram
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Steve Dickson <steved@redhat.com>
    Acked-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Tested-by: Daire Byrne <Daire.Byrne@framestore.com>

diff --git a/fs/fscache/stats.c b/fs/fscache/stats.c
new file mode 100644
index 000000000000..65deb99e756b
--- /dev/null
+++ b/fs/fscache/stats.c
@@ -0,0 +1,212 @@
+/* FS-Cache statistics
+ *
+ * Copyright (C) 2007 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#define FSCACHE_DEBUG_LEVEL THREAD
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include "internal.h"
+
+/*
+ * operation counters
+ */
+atomic_t fscache_n_op_pend;
+atomic_t fscache_n_op_run;
+atomic_t fscache_n_op_enqueue;
+atomic_t fscache_n_op_requeue;
+atomic_t fscache_n_op_deferred_release;
+atomic_t fscache_n_op_release;
+atomic_t fscache_n_op_gc;
+
+atomic_t fscache_n_attr_changed;
+atomic_t fscache_n_attr_changed_ok;
+atomic_t fscache_n_attr_changed_nobufs;
+atomic_t fscache_n_attr_changed_nomem;
+atomic_t fscache_n_attr_changed_calls;
+
+atomic_t fscache_n_allocs;
+atomic_t fscache_n_allocs_ok;
+atomic_t fscache_n_allocs_wait;
+atomic_t fscache_n_allocs_nobufs;
+atomic_t fscache_n_alloc_ops;
+atomic_t fscache_n_alloc_op_waits;
+
+atomic_t fscache_n_retrievals;
+atomic_t fscache_n_retrievals_ok;
+atomic_t fscache_n_retrievals_wait;
+atomic_t fscache_n_retrievals_nodata;
+atomic_t fscache_n_retrievals_nobufs;
+atomic_t fscache_n_retrievals_intr;
+atomic_t fscache_n_retrievals_nomem;
+atomic_t fscache_n_retrieval_ops;
+atomic_t fscache_n_retrieval_op_waits;
+
+atomic_t fscache_n_stores;
+atomic_t fscache_n_stores_ok;
+atomic_t fscache_n_stores_again;
+atomic_t fscache_n_stores_nobufs;
+atomic_t fscache_n_stores_oom;
+atomic_t fscache_n_store_ops;
+atomic_t fscache_n_store_calls;
+
+atomic_t fscache_n_marks;
+atomic_t fscache_n_uncaches;
+
+atomic_t fscache_n_acquires;
+atomic_t fscache_n_acquires_null;
+atomic_t fscache_n_acquires_no_cache;
+atomic_t fscache_n_acquires_ok;
+atomic_t fscache_n_acquires_nobufs;
+atomic_t fscache_n_acquires_oom;
+
+atomic_t fscache_n_updates;
+atomic_t fscache_n_updates_null;
+atomic_t fscache_n_updates_run;
+
+atomic_t fscache_n_relinquishes;
+atomic_t fscache_n_relinquishes_null;
+atomic_t fscache_n_relinquishes_waitcrt;
+
+atomic_t fscache_n_cookie_index;
+atomic_t fscache_n_cookie_data;
+atomic_t fscache_n_cookie_special;
+
+atomic_t fscache_n_object_alloc;
+atomic_t fscache_n_object_no_alloc;
+atomic_t fscache_n_object_lookups;
+atomic_t fscache_n_object_lookups_negative;
+atomic_t fscache_n_object_lookups_positive;
+atomic_t fscache_n_object_created;
+atomic_t fscache_n_object_avail;
+atomic_t fscache_n_object_dead;
+
+atomic_t fscache_n_checkaux_none;
+atomic_t fscache_n_checkaux_okay;
+atomic_t fscache_n_checkaux_update;
+atomic_t fscache_n_checkaux_obsolete;
+
+/*
+ * display the general statistics
+ */
+static int fscache_stats_show(struct seq_file *m, void *v)
+{
+	seq_puts(m, "FS-Cache statistics\n");
+
+	seq_printf(m, "Cookies: idx=%u dat=%u spc=%u\n",
+		   atomic_read(&fscache_n_cookie_index),
+		   atomic_read(&fscache_n_cookie_data),
+		   atomic_read(&fscache_n_cookie_special));
+
+	seq_printf(m, "Objects: alc=%u nal=%u avl=%u ded=%u\n",
+		   atomic_read(&fscache_n_object_alloc),
+		   atomic_read(&fscache_n_object_no_alloc),
+		   atomic_read(&fscache_n_object_avail),
+		   atomic_read(&fscache_n_object_dead));
+	seq_printf(m, "ChkAux : non=%u ok=%u upd=%u obs=%u\n",
+		   atomic_read(&fscache_n_checkaux_none),
+		   atomic_read(&fscache_n_checkaux_okay),
+		   atomic_read(&fscache_n_checkaux_update),
+		   atomic_read(&fscache_n_checkaux_obsolete));
+
+	seq_printf(m, "Pages  : mrk=%u unc=%u\n",
+		   atomic_read(&fscache_n_marks),
+		   atomic_read(&fscache_n_uncaches));
+
+	seq_printf(m, "Acquire: n=%u nul=%u noc=%u ok=%u nbf=%u"
+		   " oom=%u\n",
+		   atomic_read(&fscache_n_acquires),
+		   atomic_read(&fscache_n_acquires_null),
+		   atomic_read(&fscache_n_acquires_no_cache),
+		   atomic_read(&fscache_n_acquires_ok),
+		   atomic_read(&fscache_n_acquires_nobufs),
+		   atomic_read(&fscache_n_acquires_oom));
+
+	seq_printf(m, "Lookups: n=%u neg=%u pos=%u crt=%u\n",
+		   atomic_read(&fscache_n_object_lookups),
+		   atomic_read(&fscache_n_object_lookups_negative),
+		   atomic_read(&fscache_n_object_lookups_positive),
+		   atomic_read(&fscache_n_object_created));
+
+	seq_printf(m, "Updates: n=%u nul=%u run=%u\n",
+		   atomic_read(&fscache_n_updates),
+		   atomic_read(&fscache_n_updates_null),
+		   atomic_read(&fscache_n_updates_run));
+
+	seq_printf(m, "Relinqs: n=%u nul=%u wcr=%u\n",
+		   atomic_read(&fscache_n_relinquishes),
+		   atomic_read(&fscache_n_relinquishes_null),
+		   atomic_read(&fscache_n_relinquishes_waitcrt));
+
+	seq_printf(m, "AttrChg: n=%u ok=%u nbf=%u oom=%u run=%u\n",
+		   atomic_read(&fscache_n_attr_changed),
+		   atomic_read(&fscache_n_attr_changed_ok),
+		   atomic_read(&fscache_n_attr_changed_nobufs),
+		   atomic_read(&fscache_n_attr_changed_nomem),
+		   atomic_read(&fscache_n_attr_changed_calls));
+
+	seq_printf(m, "Allocs : n=%u ok=%u wt=%u nbf=%u\n",
+		   atomic_read(&fscache_n_allocs),
+		   atomic_read(&fscache_n_allocs_ok),
+		   atomic_read(&fscache_n_allocs_wait),
+		   atomic_read(&fscache_n_allocs_nobufs));
+	seq_printf(m, "Allocs : ops=%u owt=%u\n",
+		   atomic_read(&fscache_n_alloc_ops),
+		   atomic_read(&fscache_n_alloc_op_waits));
+
+	seq_printf(m, "Retrvls: n=%u ok=%u wt=%u nod=%u nbf=%u"
+		   " int=%u oom=%u\n",
+		   atomic_read(&fscache_n_retrievals),
+		   atomic_read(&fscache_n_retrievals_ok),
+		   atomic_read(&fscache_n_retrievals_wait),
+		   atomic_read(&fscache_n_retrievals_nodata),
+		   atomic_read(&fscache_n_retrievals_nobufs),
+		   atomic_read(&fscache_n_retrievals_intr),
+		   atomic_read(&fscache_n_retrievals_nomem));
+	seq_printf(m, "Retrvls: ops=%u owt=%u\n",
+		   atomic_read(&fscache_n_retrieval_ops),
+		   atomic_read(&fscache_n_retrieval_op_waits));
+
+	seq_printf(m, "Stores : n=%u ok=%u agn=%u nbf=%u oom=%u\n",
+		   atomic_read(&fscache_n_stores),
+		   atomic_read(&fscache_n_stores_ok),
+		   atomic_read(&fscache_n_stores_again),
+		   atomic_read(&fscache_n_stores_nobufs),
+		   atomic_read(&fscache_n_stores_oom));
+	seq_printf(m, "Stores : ops=%u run=%u\n",
+		   atomic_read(&fscache_n_store_ops),
+		   atomic_read(&fscache_n_store_calls));
+
+	seq_printf(m, "Ops    : pend=%u run=%u enq=%u\n",
+		   atomic_read(&fscache_n_op_pend),
+		   atomic_read(&fscache_n_op_run),
+		   atomic_read(&fscache_n_op_enqueue));
+	seq_printf(m, "Ops    : dfr=%u rel=%u gc=%u\n",
+		   atomic_read(&fscache_n_op_deferred_release),
+		   atomic_read(&fscache_n_op_release),
+		   atomic_read(&fscache_n_op_gc));
+	return 0;
+}
+
+/*
+ * open "/proc/fs/fscache/stats" allowing provision of a statistical summary
+ */
+static int fscache_stats_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, fscache_stats_show, NULL);
+}
+
+const struct file_operations fscache_stats_fops = {
+	.owner		= THIS_MODULE,
+	.open		= fscache_stats_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
