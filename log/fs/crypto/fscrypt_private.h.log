commit e3b1078bedd323df343894a27eb3b3c34944dfd1
Author: Eric Biggers <ebiggers@google.com>
Date:   Fri May 15 13:41:41 2020 -0700

    fscrypt: add support for IV_INO_LBLK_32 policies
    
    The eMMC inline crypto standard will only specify 32 DUN bits (a.k.a. IV
    bits), unlike UFS's 64.  IV_INO_LBLK_64 is therefore not applicable, but
    an encryption format which uses one key per policy and permits the
    moving of encrypted file contents (as f2fs's garbage collector requires)
    is still desirable.
    
    To support such hardware, add a new encryption format IV_INO_LBLK_32
    that makes the best use of the 32 bits: the IV is set to
    'SipHash-2-4(inode_number) + file_logical_block_number mod 2^32', where
    the SipHash key is derived from the fscrypt master key.  We hash only
    the inode number and not also the block number, because we need to
    maintain contiguity of DUNs to merge bios.
    
    Unlike with IV_INO_LBLK_64, with this format IV reuse is possible; this
    is unavoidable given the size of the DUN.  This means this format should
    only be used where the requirements of the first paragraph apply.
    However, the hash spreads out the IVs in the whole usable range, and the
    use of a keyed hash makes it difficult for an attacker to determine
    which files use which IVs.
    
    Besides the above differences, this flag works like IV_INO_LBLK_64 in
    that on ext4 it is only allowed if the stable_inodes feature has been
    enabled to prevent inode numbers and the filesystem UUID from changing.
    
    Link: https://lore.kernel.org/r/20200515204141.251098-1-ebiggers@kernel.org
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Reviewed-by: Paul Crowley <paulcrowley@google.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 855ea935f5a6..eb7fcd2b7fb8 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -222,6 +222,9 @@ struct fscrypt_info {
 
 	/* This inode's nonce, copied from the fscrypt_context */
 	u8 ci_nonce[FS_KEY_DERIVATION_NONCE_SIZE];
+
+	/* Hashed inode number.  Only set for IV_INO_LBLK_32 */
+	u32 ci_hashed_ino;
 };
 
 typedef enum {
@@ -290,6 +293,8 @@ int fscrypt_init_hkdf(struct fscrypt_hkdf *hkdf, const u8 *master_key,
 #define HKDF_CONTEXT_DIRECT_KEY		3
 #define HKDF_CONTEXT_IV_INO_LBLK_64_KEY	4
 #define HKDF_CONTEXT_DIRHASH_KEY	5
+#define HKDF_CONTEXT_IV_INO_LBLK_32_KEY	6
+#define HKDF_CONTEXT_INODE_HASH_KEY	7
 
 int fscrypt_hkdf_expand(const struct fscrypt_hkdf *hkdf, u8 context,
 			const u8 *info, unsigned int infolen,
@@ -386,14 +391,17 @@ struct fscrypt_master_key {
 	struct list_head	mk_decrypted_inodes;
 	spinlock_t		mk_decrypted_inodes_lock;
 
-	/* Crypto API transforms for DIRECT_KEY policies, allocated on-demand */
-	struct crypto_skcipher	*mk_direct_tfms[__FSCRYPT_MODE_MAX + 1];
-
 	/*
-	 * Crypto API transforms for filesystem-layer implementation of
-	 * IV_INO_LBLK_64 policies, allocated on-demand.
+	 * Per-mode encryption keys for the various types of encryption policies
+	 * that use them.  Allocated and derived on-demand.
 	 */
-	struct crypto_skcipher	*mk_iv_ino_lblk_64_tfms[__FSCRYPT_MODE_MAX + 1];
+	struct crypto_skcipher *mk_direct_keys[__FSCRYPT_MODE_MAX + 1];
+	struct crypto_skcipher *mk_iv_ino_lblk_64_keys[__FSCRYPT_MODE_MAX + 1];
+	struct crypto_skcipher *mk_iv_ino_lblk_32_keys[__FSCRYPT_MODE_MAX + 1];
+
+	/* Hash key for inode numbers.  Initialized only when needed. */
+	siphash_key_t		mk_ino_hash_key;
+	bool			mk_ino_hash_key_initialized;
 
 } __randomize_layout;
 

commit cdeb21da1783afe26a827eb62d61084f93720be9
Author: Eric Biggers <ebiggers@google.com>
Date:   Tue May 12 16:32:49 2020 -0700

    fscrypt: add fscrypt_add_test_dummy_key()
    
    Currently, the test_dummy_encryption mount option (which is used for
    encryption I/O testing with xfstests) uses v1 encryption policies, and
    it relies on userspace inserting a test key into the session keyring.
    
    We need test_dummy_encryption to support v2 encryption policies too.
    Requiring userspace to add the test key doesn't work well with v2
    policies, since v2 policies only support the filesystem keyring (not the
    session keyring), and keys in the filesystem keyring are lost when the
    filesystem is unmounted.  Hooking all test code that unmounts and
    re-mounts the filesystem would be difficult.
    
    Instead, let's make the filesystem automatically add the test key to its
    keyring when test_dummy_encryption is enabled.
    
    That puts the responsibility for choosing the test key on the kernel.
    We could just hard-code a key.  But out of paranoia, let's first try
    using a per-boot random key, to prevent this code from being misused.
    A per-boot key will work as long as no one expects dummy-encrypted files
    to remain accessible after a reboot.  (gce-xfstests doesn't.)
    
    Therefore, this patch adds a function fscrypt_add_test_dummy_key() which
    implements the above.  The next patch will use it.
    
    Link: https://lore.kernel.org/r/20200512233251.118314-3-ebiggers@kernel.org
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Reviewed-by: Jaegeuk Kim <jaegeuk@kernel.org>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 20cbd9a4b28b..855ea935f5a6 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -437,6 +437,9 @@ struct key *
 fscrypt_find_master_key(struct super_block *sb,
 			const struct fscrypt_key_specifier *mk_spec);
 
+int fscrypt_add_test_dummy_key(struct super_block *sb,
+			       struct fscrypt_key_specifier *key_spec);
+
 int fscrypt_verify_key_added(struct super_block *sb,
 			     const u8 identifier[FSCRYPT_KEY_IDENTIFIER_SIZE]);
 

commit 607009020a5e7fd9353fb2dd4cdcc73e26f3350f
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon May 11 12:13:58 2020 -0700

    fscrypt: remove unnecessary extern keywords
    
    Remove the unnecessary 'extern' keywords from function declarations.
    This makes it so that we don't have a mix of both styles, so it won't be
    ambiguous what to use in new fscrypt patches.  This also makes the code
    shorter and matches the 'checkpatch --strict' expectation.
    
    Link: https://lore.kernel.org/r/20200511191358.53096-4-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index f547094100be..20cbd9a4b28b 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -231,15 +231,14 @@ typedef enum {
 
 /* crypto.c */
 extern struct kmem_cache *fscrypt_info_cachep;
-extern int fscrypt_initialize(unsigned int cop_flags);
-extern int fscrypt_crypt_block(const struct inode *inode,
-			       fscrypt_direction_t rw, u64 lblk_num,
-			       struct page *src_page, struct page *dest_page,
-			       unsigned int len, unsigned int offs,
-			       gfp_t gfp_flags);
-extern struct page *fscrypt_alloc_bounce_page(gfp_t gfp_flags);
-
-extern void __printf(3, 4) __cold
+int fscrypt_initialize(unsigned int cop_flags);
+int fscrypt_crypt_block(const struct inode *inode, fscrypt_direction_t rw,
+			u64 lblk_num, struct page *src_page,
+			struct page *dest_page, unsigned int len,
+			unsigned int offs, gfp_t gfp_flags);
+struct page *fscrypt_alloc_bounce_page(gfp_t gfp_flags);
+
+void __printf(3, 4) __cold
 fscrypt_msg(const struct inode *inode, const char *level, const char *fmt, ...);
 
 #define fscrypt_warn(inode, fmt, ...)		\
@@ -264,12 +263,10 @@ void fscrypt_generate_iv(union fscrypt_iv *iv, u64 lblk_num,
 			 const struct fscrypt_info *ci);
 
 /* fname.c */
-extern int fscrypt_fname_encrypt(const struct inode *inode,
-				 const struct qstr *iname,
-				 u8 *out, unsigned int olen);
-extern bool fscrypt_fname_encrypted_size(const struct inode *inode,
-					 u32 orig_len, u32 max_len,
-					 u32 *encrypted_len_ret);
+int fscrypt_fname_encrypt(const struct inode *inode, const struct qstr *iname,
+			  u8 *out, unsigned int olen);
+bool fscrypt_fname_encrypted_size(const struct inode *inode, u32 orig_len,
+				  u32 max_len, u32 *encrypted_len_ret);
 extern const struct dentry_operations fscrypt_d_ops;
 
 /* hkdf.c */
@@ -278,8 +275,8 @@ struct fscrypt_hkdf {
 	struct crypto_shash *hmac_tfm;
 };
 
-extern int fscrypt_init_hkdf(struct fscrypt_hkdf *hkdf, const u8 *master_key,
-			     unsigned int master_key_size);
+int fscrypt_init_hkdf(struct fscrypt_hkdf *hkdf, const u8 *master_key,
+		      unsigned int master_key_size);
 
 /*
  * The list of contexts in which fscrypt uses HKDF.  These values are used as
@@ -294,11 +291,11 @@ extern int fscrypt_init_hkdf(struct fscrypt_hkdf *hkdf, const u8 *master_key,
 #define HKDF_CONTEXT_IV_INO_LBLK_64_KEY	4
 #define HKDF_CONTEXT_DIRHASH_KEY	5
 
-extern int fscrypt_hkdf_expand(const struct fscrypt_hkdf *hkdf, u8 context,
-			       const u8 *info, unsigned int infolen,
-			       u8 *okm, unsigned int okmlen);
+int fscrypt_hkdf_expand(const struct fscrypt_hkdf *hkdf, u8 context,
+			const u8 *info, unsigned int infolen,
+			u8 *okm, unsigned int okmlen);
 
-extern void fscrypt_destroy_hkdf(struct fscrypt_hkdf *hkdf);
+void fscrypt_destroy_hkdf(struct fscrypt_hkdf *hkdf);
 
 /* keyring.c */
 
@@ -436,14 +433,14 @@ static inline int master_key_spec_len(const struct fscrypt_key_specifier *spec)
 	return 0;
 }
 
-extern struct key *
+struct key *
 fscrypt_find_master_key(struct super_block *sb,
 			const struct fscrypt_key_specifier *mk_spec);
 
-extern int fscrypt_verify_key_added(struct super_block *sb,
-				    const u8 identifier[FSCRYPT_KEY_IDENTIFIER_SIZE]);
+int fscrypt_verify_key_added(struct super_block *sb,
+			     const u8 identifier[FSCRYPT_KEY_IDENTIFIER_SIZE]);
 
-extern int __init fscrypt_init_keyring(void);
+int __init fscrypt_init_keyring(void);
 
 /* keysetup.c */
 
@@ -457,33 +454,32 @@ struct fscrypt_mode {
 
 extern struct fscrypt_mode fscrypt_modes[];
 
-extern struct crypto_skcipher *
-fscrypt_allocate_skcipher(struct fscrypt_mode *mode, const u8 *raw_key,
-			  const struct inode *inode);
+struct crypto_skcipher *fscrypt_allocate_skcipher(struct fscrypt_mode *mode,
+						  const u8 *raw_key,
+						  const struct inode *inode);
 
-extern int fscrypt_set_per_file_enc_key(struct fscrypt_info *ci,
-					const u8 *raw_key);
+int fscrypt_set_per_file_enc_key(struct fscrypt_info *ci, const u8 *raw_key);
 
-extern int fscrypt_derive_dirhash_key(struct fscrypt_info *ci,
-				      const struct fscrypt_master_key *mk);
+int fscrypt_derive_dirhash_key(struct fscrypt_info *ci,
+			       const struct fscrypt_master_key *mk);
 
 /* keysetup_v1.c */
 
-extern void fscrypt_put_direct_key(struct fscrypt_direct_key *dk);
+void fscrypt_put_direct_key(struct fscrypt_direct_key *dk);
 
-extern int fscrypt_setup_v1_file_key(struct fscrypt_info *ci,
-				     const u8 *raw_master_key);
+int fscrypt_setup_v1_file_key(struct fscrypt_info *ci,
+			      const u8 *raw_master_key);
+
+int fscrypt_setup_v1_file_key_via_subscribed_keyrings(struct fscrypt_info *ci);
 
-extern int fscrypt_setup_v1_file_key_via_subscribed_keyrings(
-					struct fscrypt_info *ci);
 /* policy.c */
 
-extern bool fscrypt_policies_equal(const union fscrypt_policy *policy1,
-				   const union fscrypt_policy *policy2);
-extern bool fscrypt_supported_policy(const union fscrypt_policy *policy_u,
-				     const struct inode *inode);
-extern int fscrypt_policy_from_context(union fscrypt_policy *policy_u,
-				       const union fscrypt_context *ctx_u,
-				       int ctx_size);
+bool fscrypt_policies_equal(const union fscrypt_policy *policy1,
+			    const union fscrypt_policy *policy2);
+bool fscrypt_supported_policy(const union fscrypt_policy *policy_u,
+			      const struct inode *inode);
+int fscrypt_policy_from_context(union fscrypt_policy *policy_u,
+				const union fscrypt_context *ctx_u,
+				int ctx_size);
 
 #endif /* _FSCRYPT_PRIVATE_H */

commit d2fe97545a1e2d01c0ca0105bdc59002a0d0b130
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon May 11 12:13:56 2020 -0700

    fscrypt: fix all kerneldoc warnings
    
    Fix all kerneldoc warnings in fs/crypto/ and include/linux/fscrypt.h.
    Most of these were due to missing documentation for function parameters.
    
    Detected with:
    
        scripts/kernel-doc -v -none fs/crypto/*.{c,h} include/linux/fscrypt.h
    
    This cleanup makes it possible to check new patches for kerneldoc
    warnings without having to filter out all the existing ones.
    
    For consistency, also adjust some function "brief descriptions" to
    include the parentheses and to wrap at 80 characters.  (The latter
    matches the checkpatch expectation.)
    
    Link: https://lore.kernel.org/r/20200511191358.53096-2-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index dbced2937ec8..f547094100be 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -43,7 +43,7 @@ struct fscrypt_context_v2 {
 	u8 nonce[FS_KEY_DERIVATION_NONCE_SIZE];
 };
 
-/**
+/*
  * fscrypt_context - the encryption context of an inode
  *
  * This is the on-disk equivalent of an fscrypt_policy, stored alongside each
@@ -157,7 +157,7 @@ fscrypt_policy_flags(const union fscrypt_policy *policy)
 	BUG();
 }
 
-/**
+/*
  * For encrypted symlinks, the ciphertext length is stored at the beginning
  * of the string in little-endian format.
  */

commit e98ad464750c0894bc560d10503dae8ff90ccdac
Author: Eric Biggers <ebiggers@google.com>
Date:   Sat Mar 14 13:50:49 2020 -0700

    fscrypt: add FS_IOC_GET_ENCRYPTION_NONCE ioctl
    
    Add an ioctl FS_IOC_GET_ENCRYPTION_NONCE which retrieves the nonce from
    an encrypted file or directory.  The nonce is the 16-byte random value
    stored in the inode's encryption xattr.  It is normally used together
    with the master key to derive the inode's actual encryption key.
    
    The nonces are needed by automated tests that verify the correctness of
    the ciphertext on-disk.  Except for the IV_INO_LBLK_64 case, there's no
    way to replicate a file's ciphertext without knowing that file's nonce.
    
    The nonces aren't secret, and the existing ciphertext verification tests
    in xfstests retrieve them from disk using debugfs or dump.f2fs.  But in
    environments that lack these debugging tools, getting the nonces by
    manually parsing the filesystem structure would be very hard.
    
    To make this important type of testing much easier, let's just add an
    ioctl that retrieves the nonce.
    
    Link: https://lore.kernel.org/r/20200314205052.93294-2-ebiggers@kernel.org
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 9aae851409e5..dbced2937ec8 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -76,6 +76,26 @@ static inline int fscrypt_context_size(const union fscrypt_context *ctx)
 	return 0;
 }
 
+/* Check whether an fscrypt_context has a recognized version number and size */
+static inline bool fscrypt_context_is_valid(const union fscrypt_context *ctx,
+					    int ctx_size)
+{
+	return ctx_size >= 1 && ctx_size == fscrypt_context_size(ctx);
+}
+
+/* Retrieve the context's nonce, assuming the context was already validated */
+static inline const u8 *fscrypt_context_nonce(const union fscrypt_context *ctx)
+{
+	switch (ctx->version) {
+	case FSCRYPT_CONTEXT_V1:
+		return ctx->v1.nonce;
+	case FSCRYPT_CONTEXT_V2:
+		return ctx->v2.nonce;
+	}
+	WARN_ON(1);
+	return NULL;
+}
+
 #undef fscrypt_policy
 union fscrypt_policy {
 	u8 version;

commit f592efe735a29c764e0d473307dab0f59665f02b
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Jan 20 14:31:58 2020 -0800

    fscrypt: clarify what is meant by a per-file key
    
    Now that there's sometimes a second type of per-file key (the dirhash
    key), clarify some function names, macros, and documentation that
    specifically deal with per-file *encryption* keys.
    
    Link: https://lore.kernel.org/r/20200120223201.241390-4-ebiggers@kernel.org
    Reviewed-by: Daniel Rosenberg <drosen@google.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 81dbb2befe81..9aae851409e5 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -269,7 +269,7 @@ extern int fscrypt_init_hkdf(struct fscrypt_hkdf *hkdf, const u8 *master_key,
  * output doesn't reveal another.
  */
 #define HKDF_CONTEXT_KEY_IDENTIFIER	1
-#define HKDF_CONTEXT_PER_FILE_KEY	2
+#define HKDF_CONTEXT_PER_FILE_ENC_KEY	2
 #define HKDF_CONTEXT_DIRECT_KEY		3
 #define HKDF_CONTEXT_IV_INO_LBLK_64_KEY	4
 #define HKDF_CONTEXT_DIRHASH_KEY	5
@@ -441,8 +441,8 @@ extern struct crypto_skcipher *
 fscrypt_allocate_skcipher(struct fscrypt_mode *mode, const u8 *raw_key,
 			  const struct inode *inode);
 
-extern int fscrypt_set_derived_key(struct fscrypt_info *ci,
-				   const u8 *derived_key);
+extern int fscrypt_set_per_file_enc_key(struct fscrypt_info *ci,
+					const u8 *raw_key);
 
 extern int fscrypt_derive_dirhash_key(struct fscrypt_info *ci,
 				      const struct fscrypt_master_key *mk);

commit aa408f835d025a839033988d3f5a2866314414ef
Author: Daniel Rosenberg <drosen@google.com>
Date:   Mon Jan 20 14:31:57 2020 -0800

    fscrypt: derive dirhash key for casefolded directories
    
    When we allow indexed directories to use both encryption and
    casefolding, for the dirhash we can't just hash the ciphertext filenames
    that are stored on-disk (as is done currently) because the dirhash must
    be case insensitive, but the stored names are case-preserving.  Nor can
    we hash the plaintext names with an unkeyed hash (or a hash keyed with a
    value stored on-disk like ext4's s_hash_seed), since that would leak
    information about the names that encryption is meant to protect.
    
    Instead, if we can accept a dirhash that's only computable when the
    fscrypt key is available, we can hash the plaintext names with a keyed
    hash using a secret key derived from the directory's fscrypt master key.
    We'll use SipHash-2-4 for this purpose.
    
    Prepare for this by deriving a SipHash key for each casefolded encrypted
    directory.  Make sure to handle deriving the key not only when setting
    up the directory's fscrypt_info, but also in the case where the casefold
    flag is enabled after the fscrypt_info was already set up.  (We could
    just always derive the key regardless of casefolding, but that would
    introduce unnecessary overhead for people not using casefolding.)
    
    Signed-off-by: Daniel Rosenberg <drosen@google.com>
    [EB: improved commit message, updated fscrypt.rst, squashed with change
     that avoids unnecessarily deriving the key, and many other cleanups]
    Link: https://lore.kernel.org/r/20200120223201.241390-3-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index fea7f5547428..81dbb2befe81 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -12,6 +12,7 @@
 #define _FSCRYPT_PRIVATE_H
 
 #include <linux/fscrypt.h>
+#include <linux/siphash.h>
 #include <crypto/hash.h>
 
 #define CONST_STRLEN(str)	(sizeof(str) - 1)
@@ -188,6 +189,14 @@ struct fscrypt_info {
 	 */
 	struct fscrypt_direct_key *ci_direct_key;
 
+	/*
+	 * This inode's hash key for filenames.  This is a 128-bit SipHash-2-4
+	 * key.  This is only set for directories that use a keyed dirhash over
+	 * the plaintext filenames -- currently just casefolded directories.
+	 */
+	siphash_key_t ci_dirhash_key;
+	bool ci_dirhash_key_initialized;
+
 	/* The encryption policy used by this inode */
 	union fscrypt_policy ci_policy;
 
@@ -263,6 +272,7 @@ extern int fscrypt_init_hkdf(struct fscrypt_hkdf *hkdf, const u8 *master_key,
 #define HKDF_CONTEXT_PER_FILE_KEY	2
 #define HKDF_CONTEXT_DIRECT_KEY		3
 #define HKDF_CONTEXT_IV_INO_LBLK_64_KEY	4
+#define HKDF_CONTEXT_DIRHASH_KEY	5
 
 extern int fscrypt_hkdf_expand(const struct fscrypt_hkdf *hkdf, u8 context,
 			       const u8 *info, unsigned int infolen,
@@ -434,6 +444,9 @@ fscrypt_allocate_skcipher(struct fscrypt_mode *mode, const u8 *raw_key,
 extern int fscrypt_set_derived_key(struct fscrypt_info *ci,
 				   const u8 *derived_key);
 
+extern int fscrypt_derive_dirhash_key(struct fscrypt_info *ci,
+				      const struct fscrypt_master_key *mk);
+
 /* keysetup_v1.c */
 
 extern void fscrypt_put_direct_key(struct fscrypt_direct_key *dk);

commit 1b3b827ee5230a73c8ed1b2cd8d53b4bd001268b
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Jan 19 23:17:36 2020 -0800

    fscrypt: add "fscrypt_" prefix to fname_encrypt()
    
    fname_encrypt() is a global function, due to being used in both fname.c
    and hooks.c.  So it should be prefixed with "fscrypt_", like all the
    other global functions in fs/crypto/.
    
    Link: https://lore.kernel.org/r/20200120071736.45915-1-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index b22e8decebed..fea7f5547428 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -235,8 +235,9 @@ void fscrypt_generate_iv(union fscrypt_iv *iv, u64 lblk_num,
 			 const struct fscrypt_info *ci);
 
 /* fname.c */
-extern int fname_encrypt(const struct inode *inode, const struct qstr *iname,
-			 u8 *out, unsigned int olen);
+extern int fscrypt_fname_encrypt(const struct inode *inode,
+				 const struct qstr *iname,
+				 u8 *out, unsigned int olen);
 extern bool fscrypt_fname_encrypted_size(const struct inode *inode,
 					 u32 orig_len, u32 max_len,
 					 u32 *encrypted_len_ret);

commit b7e8d3d27edde7a05e195e0015bc6873f6263a30
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Dec 9 13:18:29 2019 -0800

    fscrypt: remove fscrypt_is_direct_key_policy()
    
    fscrypt_is_direct_key_policy() is no longer used, so remove it.
    
    Link: https://lore.kernel.org/r/20191209211829.239800-5-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 71f496fe7173..b22e8decebed 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -136,12 +136,6 @@ fscrypt_policy_flags(const union fscrypt_policy *policy)
 	BUG();
 }
 
-static inline bool
-fscrypt_is_direct_key_policy(const union fscrypt_policy *policy)
-{
-	return fscrypt_policy_flags(policy) & FSCRYPT_POLICY_FLAG_DIRECT_KEY;
-}
-
 /**
  * For encrypted symlinks, the ciphertext length is stored at the beginning
  * of the string in little-endian format.

commit ef5b18b00bada6091fb531fb0c29cf0f7e1a3b85
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Dec 9 13:18:28 2019 -0800

    fscrypt: move fscrypt_valid_enc_modes() to policy.c
    
    fscrypt_valid_enc_modes() is only used by policy.c, so move it to there.
    
    Also adjust the order of the checks to be more natural, matching the
    numerical order of the constants and also keeping AES-256 (the
    recommended default) first in the list.
    
    No change in behavior.
    
    Link: https://lore.kernel.org/r/20191209211829.239800-4-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 41b061cdf06e..71f496fe7173 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -206,24 +206,6 @@ typedef enum {
 	FS_ENCRYPT,
 } fscrypt_direction_t;
 
-static inline bool fscrypt_valid_enc_modes(u32 contents_mode,
-					   u32 filenames_mode)
-{
-	if (contents_mode == FSCRYPT_MODE_AES_128_CBC &&
-	    filenames_mode == FSCRYPT_MODE_AES_128_CTS)
-		return true;
-
-	if (contents_mode == FSCRYPT_MODE_AES_256_XTS &&
-	    filenames_mode == FSCRYPT_MODE_AES_256_CTS)
-		return true;
-
-	if (contents_mode == FSCRYPT_MODE_ADIANTUM &&
-	    filenames_mode == FSCRYPT_MODE_ADIANTUM)
-		return true;
-
-	return false;
-}
-
 /* crypto.c */
 extern struct kmem_cache *fscrypt_info_cachep;
 extern int fscrypt_initialize(unsigned int cop_flags);

commit 85af90e57ce9697d36d479124e0bfffb145e39a4
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Dec 9 13:18:27 2019 -0800

    fscrypt: check for appropriate use of DIRECT_KEY flag earlier
    
    FSCRYPT_POLICY_FLAG_DIRECT_KEY is currently only allowed with Adiantum
    encryption.  But FS_IOC_SET_ENCRYPTION_POLICY allowed it in combination
    with other encryption modes, and an error wasn't reported until later
    when the encrypted directory was actually used.
    
    Fix it to report the error earlier by validating the correct use of the
    DIRECT_KEY flag in fscrypt_supported_policy(), similar to how we
    validate the IV_INO_LBLK_64 flag.
    
    Link: https://lore.kernel.org/r/20191209211829.239800-3-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 37c418d23962..41b061cdf06e 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -448,11 +448,7 @@ struct fscrypt_mode {
 	int logged_impl_name;
 };
 
-static inline bool
-fscrypt_mode_supports_direct_key(const struct fscrypt_mode *mode)
-{
-	return mode->ivsize >= offsetofend(union fscrypt_iv, nonce);
-}
+extern struct fscrypt_mode fscrypt_modes[];
 
 extern struct crypto_skcipher *
 fscrypt_allocate_skcipher(struct fscrypt_mode *mode, const u8 *raw_key,

commit 2ebdef6d8c766ab7da532002091ad486f9db88ed
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Dec 9 12:43:59 2019 -0800

    fscrypt: move fscrypt_d_revalidate() to fname.c
    
    fscrypt_d_revalidate() and fscrypt_d_ops really belong in fname.c, since
    they're specific to filenames encryption.  crypto.c is for contents
    encryption and general fs/crypto/ initialization and utilities.
    
    Link: https://lore.kernel.org/r/20191209204359.228544-1-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 5792ecbd4d24..37c418d23962 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -233,7 +233,6 @@ extern int fscrypt_crypt_block(const struct inode *inode,
 			       unsigned int len, unsigned int offs,
 			       gfp_t gfp_flags);
 extern struct page *fscrypt_alloc_bounce_page(gfp_t gfp_flags);
-extern const struct dentry_operations fscrypt_d_ops;
 
 extern void __printf(3, 4) __cold
 fscrypt_msg(const struct inode *inode, const char *level, const char *fmt, ...);
@@ -265,6 +264,7 @@ extern int fname_encrypt(const struct inode *inode, const struct qstr *iname,
 extern bool fscrypt_fname_encrypted_size(const struct inode *inode,
 					 u32 orig_len, u32 max_len,
 					 u32 *encrypted_len_ret);
+extern const struct dentry_operations fscrypt_d_ops;
 
 /* hkdf.c */
 

commit 8a4ab0b866d8aba85b9899edebf14b87b25f817f
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Dec 15 13:39:47 2019 -0800

    fscrypt: constify inode parameter to filename encryption functions
    
    Constify the struct inode parameter to fscrypt_fname_disk_to_usr() and
    the other filename encryption functions so that users don't have to pass
    in a non-const inode when they are dealing with a const one, as in [1].
    
    [1] https://lkml.kernel.org/linux-ext4/20191203051049.44573-6-drosen@google.com/
    
    Cc: Daniel Rosenberg <drosen@google.com>
    Link: https://lore.kernel.org/r/20191215213947.9521-1-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 23cef4d3793a..5792ecbd4d24 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -260,7 +260,7 @@ void fscrypt_generate_iv(union fscrypt_iv *iv, u64 lblk_num,
 			 const struct fscrypt_info *ci);
 
 /* fname.c */
-extern int fname_encrypt(struct inode *inode, const struct qstr *iname,
+extern int fname_encrypt(const struct inode *inode, const struct qstr *iname,
 			 u8 *out, unsigned int olen);
 extern bool fscrypt_fname_encrypted_size(const struct inode *inode,
 					 u32 orig_len, u32 max_len,

commit 2a5831b1d29754c216ad3b06a018c29e74d4ad10
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Dec 9 12:40:54 2019 -0800

    fscrypt: constify struct fscrypt_hkdf parameter to fscrypt_hkdf_expand()
    
    Constify the struct fscrypt_hkdf parameter to fscrypt_hkdf_expand().
    This makes it clearer that struct fscrypt_hkdf contains the key only,
    not any per-request state.
    
    Link: https://lore.kernel.org/r/20191209204054.227736-1-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 130b50e5a011..23cef4d3793a 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -287,7 +287,7 @@ extern int fscrypt_init_hkdf(struct fscrypt_hkdf *hkdf, const u8 *master_key,
 #define HKDF_CONTEXT_DIRECT_KEY		3
 #define HKDF_CONTEXT_IV_INO_LBLK_64_KEY	4
 
-extern int fscrypt_hkdf_expand(struct fscrypt_hkdf *hkdf, u8 context,
+extern int fscrypt_hkdf_expand(const struct fscrypt_hkdf *hkdf, u8 context,
 			       const u8 *info, unsigned int infolen,
 			       u8 *okm, unsigned int okmlen);
 

commit b103fb7653fff09e7a6fb6ba9398a41584e7ae36
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Oct 24 14:54:36 2019 -0700

    fscrypt: add support for IV_INO_LBLK_64 policies
    
    Inline encryption hardware compliant with the UFS v2.1 standard or with
    the upcoming version of the eMMC standard has the following properties:
    
    (1) Per I/O request, the encryption key is specified by a previously
        loaded keyslot.  There might be only a small number of keyslots.
    
    (2) Per I/O request, the starting IV is specified by a 64-bit "data unit
        number" (DUN).  IV bits 64-127 are assumed to be 0.  The hardware
        automatically increments the DUN for each "data unit" of
        configurable size in the request, e.g. for each filesystem block.
    
    Property (1) makes it inefficient to use the traditional fscrypt
    per-file keys.  Property (2) precludes the use of the existing
    DIRECT_KEY fscrypt policy flag, which needs at least 192 IV bits.
    
    Therefore, add a new fscrypt policy flag IV_INO_LBLK_64 which causes the
    encryption to modified as follows:
    
    - The encryption keys are derived from the master key, encryption mode
      number, and filesystem UUID.
    
    - The IVs are chosen as (inode_number << 32) | file_logical_block_num.
      For filenames encryption, file_logical_block_num is 0.
    
    Since the file nonces aren't used in the key derivation, many files may
    share the same encryption key.  This is much more efficient on the
    target hardware.  Including the inode number in the IVs and mixing the
    filesystem UUID into the keys ensures that data in different files is
    nevertheless still encrypted differently.
    
    Additionally, limiting the inode and block numbers to 32 bits and
    placing the block number in the low bits maintains compatibility with
    the 64-bit DUN convention (property (2) above).
    
    Since this scheme assumes that inode numbers are stable (which may
    preclude filesystem shrinking) and that inode and file logical block
    numbers are at most 32-bit, IV_INO_LBLK_64 will only be allowed on
    filesystems that meet these constraints.  These are acceptable
    limitations for the cases where this format would actually be used.
    
    Note that IV_INO_LBLK_64 is an on-disk format, not an implementation.
    This patch just adds support for it using the existing filesystem layer
    encryption.  A later patch will add support for inline encryption.
    
    Reviewed-by: Paul Crowley <paulcrowley@google.com>
    Co-developed-by: Satya Tangirala <satyat@google.com>
    Signed-off-by: Satya Tangirala <satyat@google.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index d9a3e8614049..130b50e5a011 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -163,6 +163,9 @@ struct fscrypt_info {
 	/* The actual crypto transform used for encryption and decryption */
 	struct crypto_skcipher *ci_ctfm;
 
+	/* True if the key should be freed when this fscrypt_info is freed */
+	bool ci_owns_key;
+
 	/*
 	 * Encryption mode used for this inode.  It corresponds to either the
 	 * contents or filenames encryption mode, depending on the inode type.
@@ -281,7 +284,8 @@ extern int fscrypt_init_hkdf(struct fscrypt_hkdf *hkdf, const u8 *master_key,
  */
 #define HKDF_CONTEXT_KEY_IDENTIFIER	1
 #define HKDF_CONTEXT_PER_FILE_KEY	2
-#define HKDF_CONTEXT_PER_MODE_KEY	3
+#define HKDF_CONTEXT_DIRECT_KEY		3
+#define HKDF_CONTEXT_IV_INO_LBLK_64_KEY	4
 
 extern int fscrypt_hkdf_expand(struct fscrypt_hkdf *hkdf, u8 context,
 			       const u8 *info, unsigned int infolen,
@@ -378,8 +382,14 @@ struct fscrypt_master_key {
 	struct list_head	mk_decrypted_inodes;
 	spinlock_t		mk_decrypted_inodes_lock;
 
-	/* Per-mode tfms for DIRECT_KEY policies, allocated on-demand */
-	struct crypto_skcipher	*mk_mode_keys[__FSCRYPT_MODE_MAX + 1];
+	/* Crypto API transforms for DIRECT_KEY policies, allocated on-demand */
+	struct crypto_skcipher	*mk_direct_tfms[__FSCRYPT_MODE_MAX + 1];
+
+	/*
+	 * Crypto API transforms for filesystem-layer implementation of
+	 * IV_INO_LBLK_64 policies, allocated on-demand.
+	 */
+	struct crypto_skcipher	*mk_iv_ino_lblk_64_tfms[__FSCRYPT_MODE_MAX + 1];
 
 } __randomize_layout;
 

commit ff73c2c016f8569b728eb1e9ebfab383545e4d65
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Oct 21 13:49:03 2019 -0700

    fscrypt: avoid data race on fscrypt_mode::logged_impl_name
    
    The access to logged_impl_name is technically a data race, which tools
    like KCSAN could complain about in the future.  See:
    https://github.com/google/ktsan/wiki/READ_ONCE-and-WRITE_ONCE
    
    Fix by using xchg(), which also ensures that only one thread does the
    logging.
    
    This also required switching from bool to int, to avoid a build error on
    the RISC-V architecture which doesn't implement xchg on bytes.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index dacf8fcbac3b..d9a3e8614049 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -435,7 +435,7 @@ struct fscrypt_mode {
 	const char *cipher_str;
 	int keysize;
 	int ivsize;
-	bool logged_impl_name;
+	int logged_impl_name;
 };
 
 static inline bool

commit 1565bdad59e97f31cfc7b065bc0fc77e9549e62d
Author: Eric Biggers <ebiggers@google.com>
Date:   Wed Oct 9 16:34:17 2019 -0700

    fscrypt: remove struct fscrypt_ctx
    
    Now that ext4 and f2fs implement their own post-read workflow that
    supports both fscrypt and fsverity, the fscrypt-only workflow based
    around struct fscrypt_ctx is no longer used.  So remove the unused code.
    
    This is based on a patch from Chandan Rajendra's "Consolidate FS read
    I/O callbacks code" patchset, but rebased onto the latest kernel, folded
    __fscrypt_decrypt_bio() into fscrypt_decrypt_bio(), cleaned up
    fscrypt_initialize(), and updated the commit message.
    
    Originally-from: Chandan Rajendra <chandan@linux.ibm.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 76c64297ce18..dacf8fcbac3b 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -203,8 +203,6 @@ typedef enum {
 	FS_ENCRYPT,
 } fscrypt_direction_t;
 
-#define FS_CTX_REQUIRES_FREE_ENCRYPT_FL		0x00000001
-
 static inline bool fscrypt_valid_enc_modes(u32 contents_mode,
 					   u32 filenames_mode)
 {

commit 4006d799d93b159fd834c50999265b5c534a71d5
Author: Eric Biggers <ebiggers@google.com>
Date:   Wed Oct 9 16:34:16 2019 -0700

    fscrypt: invoke crypto API for ESSIV handling
    
    Instead of open-coding the calculations for ESSIV handling, use an ESSIV
    skcipher which does all of this under the hood.  ESSIV was added to the
    crypto API in v5.4.
    
    This is based on a patch from Ard Biesheuvel, but reworked to apply
    after all the fscrypt changes that went into v5.4.
    
    Tested with 'kvm-xfstests -c ext4,f2fs -g encrypt', including the
    ciphertext verification tests for v1 and v2 encryption policies.
    
    Originally-from: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index e84efc01512e..76c64297ce18 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -163,12 +163,6 @@ struct fscrypt_info {
 	/* The actual crypto transform used for encryption and decryption */
 	struct crypto_skcipher *ci_ctfm;
 
-	/*
-	 * Cipher for ESSIV IV generation.  Only set for CBC contents
-	 * encryption, otherwise is NULL.
-	 */
-	struct crypto_cipher *ci_essiv_tfm;
-
 	/*
 	 * Encryption mode used for this inode.  It corresponds to either the
 	 * contents or filenames encryption mode, depending on the inode type.
@@ -444,7 +438,6 @@ struct fscrypt_mode {
 	int keysize;
 	int ivsize;
 	bool logged_impl_name;
-	bool needs_essiv;
 };
 
 static inline bool

commit 5ab7189a31bad40e4b44020cae6e56c8074721a1
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:48 2019 -0700

    fscrypt: require that key be added when setting a v2 encryption policy
    
    By looking up the master keys in a filesystem-level keyring rather than
    in the calling processes' key hierarchy, it becomes possible for a user
    to set an encryption policy which refers to some key they don't actually
    know, then encrypt their files using that key.  Cryptographically this
    isn't much of a problem, but the semantics of this would be a bit weird.
    Thus, enforce that a v2 encryption policy can only be set if the user
    has previously added the key, or has capable(CAP_FOWNER).
    
    We tolerate that this problem will continue to exist for v1 encryption
    policies, however; there is no way around that.
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index d0e238234234..e84efc01512e 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -431,6 +431,9 @@ extern struct key *
 fscrypt_find_master_key(struct super_block *sb,
 			const struct fscrypt_key_specifier *mk_spec);
 
+extern int fscrypt_verify_key_added(struct super_block *sb,
+				    const u8 identifier[FSCRYPT_KEY_IDENTIFIER_SIZE]);
+
 extern int __init fscrypt_init_keyring(void);
 
 /* keysetup.c */

commit 23c688b54016eed15d39f4387ca9da241e165922
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:47 2019 -0700

    fscrypt: allow unprivileged users to add/remove keys for v2 policies
    
    Allow the FS_IOC_ADD_ENCRYPTION_KEY and FS_IOC_REMOVE_ENCRYPTION_KEY
    ioctls to be used by non-root users to add and remove encryption keys
    from the filesystem-level crypto keyrings, subject to limitations.
    
    Motivation: while privileged fscrypt key management is sufficient for
    some users (e.g. Android and Chromium OS, where a privileged process
    manages all keys), the old API by design also allows non-root users to
    set up and use encrypted directories, and we don't want to regress on
    that.  Especially, we don't want to force users to continue using the
    old API, running into the visibility mismatch between files and keyrings
    and being unable to "lock" encrypted directories.
    
    Intuitively, the ioctls have to be privileged since they manipulate
    filesystem-level state.  However, it's actually safe to make them
    unprivileged if we very carefully enforce some specific limitations.
    
    First, each key must be identified by a cryptographic hash so that a
    user can't add the wrong key for another user's files.  For v2
    encryption policies, we use the key_identifier for this.  v1 policies
    don't have this, so managing keys for them remains privileged.
    
    Second, each key a user adds is charged to their quota for the keyrings
    service.  Thus, a user can't exhaust memory by adding a huge number of
    keys.  By default each non-root user is allowed up to 200 keys; this can
    be changed using the existing sysctl 'kernel.keys.maxkeys'.
    
    Third, if multiple users add the same key, we keep track of those users
    of the key (of which there remains a single copy), and won't really
    remove the key, i.e. "lock" the encrypted files, until all those users
    have removed it.  This prevents denial of service attacks that would be
    possible under simpler schemes, such allowing the first user who added a
    key to remove it -- since that could be a malicious user who has
    compromised the key.  Of course, encryption keys should be kept secret,
    but the idea is that using encryption should never be *less* secure than
    not using encryption, even if your key was compromised.
    
    We tolerate that a user will be unable to really remove a key, i.e.
    unable to "lock" their encrypted files, if another user has added the
    same key.  But in a sense, this is actually a good thing because it will
    avoid providing a false notion of security where a key appears to have
    been removed when actually it's still in memory, available to any
    attacker who compromises the operating system kernel.
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index c89e37d38e42..d0e238234234 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -335,9 +335,16 @@ struct fscrypt_master_key {
 	 * FS_IOC_REMOVE_ENCRYPTION_KEY can be retried, or
 	 * FS_IOC_ADD_ENCRYPTION_KEY can add the secret again.
 	 *
-	 * Locking: protected by key->sem.
+	 * Locking: protected by key->sem (outer) and mk_secret_sem (inner).
+	 * The reason for two locks is that key->sem also protects modifying
+	 * mk_users, which ranks it above the semaphore for the keyring key
+	 * type, which is in turn above page faults (via keyring_read).  But
+	 * sometimes filesystems call fscrypt_get_encryption_info() from within
+	 * a transaction, which ranks it below page faults.  So we need a
+	 * separate lock which protects mk_secret but not also mk_users.
 	 */
 	struct fscrypt_master_key_secret	mk_secret;
+	struct rw_semaphore			mk_secret_sem;
 
 	/*
 	 * For v1 policy keys: an arbitrary key descriptor which was assigned by
@@ -347,6 +354,22 @@ struct fscrypt_master_key {
 	 */
 	struct fscrypt_key_specifier		mk_spec;
 
+	/*
+	 * Keyring which contains a key of type 'key_type_fscrypt_user' for each
+	 * user who has added this key.  Normally each key will be added by just
+	 * one user, but it's possible that multiple users share a key, and in
+	 * that case we need to keep track of those users so that one user can't
+	 * remove the key before the others want it removed too.
+	 *
+	 * This is NULL for v1 policy keys; those can only be added by root.
+	 *
+	 * Locking: in addition to this keyrings own semaphore, this is
+	 * protected by the master key's key->sem, so we can do atomic
+	 * search+insert.  It can also be searched without taking any locks, but
+	 * in that case the returned key may have already been removed.
+	 */
+	struct key		*mk_users;
+
 	/*
 	 * Length of ->mk_decrypted_inodes, plus one if mk_secret is present.
 	 * Once this goes to 0, the master key is removed from ->s_master_keys.
@@ -374,9 +397,9 @@ is_master_key_secret_present(const struct fscrypt_master_key_secret *secret)
 	/*
 	 * The READ_ONCE() is only necessary for fscrypt_drop_inode() and
 	 * fscrypt_key_describe().  These run in atomic context, so they can't
-	 * take key->sem and thus 'secret' can change concurrently which would
-	 * be a data race.  But they only need to know whether the secret *was*
-	 * present at the time of check, so READ_ONCE() suffices.
+	 * take ->mk_secret_sem and thus 'secret' can change concurrently which
+	 * would be a data race.  But they only need to know whether the secret
+	 * *was* present at the time of check, so READ_ONCE() suffices.
 	 */
 	return READ_ONCE(secret->size) != 0;
 }

commit 5dae460c2292dbbdac3a7a982cd566f470d957a2
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:47 2019 -0700

    fscrypt: v2 encryption policy support
    
    Add a new fscrypt policy version, "v2".  It has the following changes
    from the original policy version, which we call "v1" (*):
    
    - Master keys (the user-provided encryption keys) are only ever used as
      input to HKDF-SHA512.  This is more flexible and less error-prone, and
      it avoids the quirks and limitations of the AES-128-ECB based KDF.
      Three classes of cryptographically isolated subkeys are defined:
    
        - Per-file keys, like used in v1 policies except for the new KDF.
    
        - Per-mode keys.  These implement the semantics of the DIRECT_KEY
          flag, which for v1 policies made the master key be used directly.
          These are also planned to be used for inline encryption when
          support for it is added.
    
        - Key identifiers (see below).
    
    - Each master key is identified by a 16-byte master_key_identifier,
      which is derived from the key itself using HKDF-SHA512.  This prevents
      users from associating the wrong key with an encrypted file or
      directory.  This was easily possible with v1 policies, which
      identified the key by an arbitrary 8-byte master_key_descriptor.
    
    - The key must be provided in the filesystem-level keyring, not in a
      process-subscribed keyring.
    
    The following UAPI additions are made:
    
    - The existing ioctl FS_IOC_SET_ENCRYPTION_POLICY can now be passed a
      fscrypt_policy_v2 to set a v2 encryption policy.  It's disambiguated
      from fscrypt_policy/fscrypt_policy_v1 by the version code prefix.
    
    - A new ioctl FS_IOC_GET_ENCRYPTION_POLICY_EX is added.  It allows
      getting the v1 or v2 encryption policy of an encrypted file or
      directory.  The existing FS_IOC_GET_ENCRYPTION_POLICY ioctl could not
      be used because it did not have a way for userspace to indicate which
      policy structure is expected.  The new ioctl includes a size field, so
      it is extensible to future fscrypt policy versions.
    
    - The ioctls FS_IOC_ADD_ENCRYPTION_KEY, FS_IOC_REMOVE_ENCRYPTION_KEY,
      and FS_IOC_GET_ENCRYPTION_KEY_STATUS now support managing keys for v2
      encryption policies.  Such keys are kept logically separate from keys
      for v1 encryption policies, and are identified by 'identifier' rather
      than by 'descriptor'.  The 'identifier' need not be provided when
      adding a key, since the kernel will calculate it anyway.
    
    This patch temporarily keeps adding/removing v2 policy keys behind the
    same permission check done for adding/removing v1 policy keys:
    capable(CAP_SYS_ADMIN).  However, the next patch will carefully take
    advantage of the cryptographically secure master_key_identifier to allow
    non-root users to add/remove v2 policy keys, thus providing a full
    replacement for v1 policies.
    
    (*) Actually, in the API fscrypt_policy::version is 0 while on-disk
        fscrypt_context::format is 1.  But I believe it makes the most sense
        to advance both to '2' to have them be in sync, and to consider the
        numbering to start at 1 except for the API quirk.
    
    Reviewed-by: Paul Crowley <paulcrowley@google.com>
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 9556e9499dc5..c89e37d38e42 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -20,27 +20,127 @@
 
 #define FSCRYPT_MIN_KEY_SIZE		16
 
-/**
- * Encryption context for inode
- *
- * Protector format:
- *  1 byte: Protector format (1 = this version)
- *  1 byte: File contents encryption mode
- *  1 byte: File names encryption mode
- *  1 byte: Flags
- *  8 bytes: Master Key descriptor
- *  16 bytes: Encryption Key derivation nonce
- */
-struct fscrypt_context {
-	u8 format;
+#define FSCRYPT_CONTEXT_V1	1
+#define FSCRYPT_CONTEXT_V2	2
+
+struct fscrypt_context_v1 {
+	u8 version; /* FSCRYPT_CONTEXT_V1 */
 	u8 contents_encryption_mode;
 	u8 filenames_encryption_mode;
 	u8 flags;
 	u8 master_key_descriptor[FSCRYPT_KEY_DESCRIPTOR_SIZE];
 	u8 nonce[FS_KEY_DERIVATION_NONCE_SIZE];
-} __packed;
+};
 
-#define FS_ENCRYPTION_CONTEXT_FORMAT_V1		1
+struct fscrypt_context_v2 {
+	u8 version; /* FSCRYPT_CONTEXT_V2 */
+	u8 contents_encryption_mode;
+	u8 filenames_encryption_mode;
+	u8 flags;
+	u8 __reserved[4];
+	u8 master_key_identifier[FSCRYPT_KEY_IDENTIFIER_SIZE];
+	u8 nonce[FS_KEY_DERIVATION_NONCE_SIZE];
+};
+
+/**
+ * fscrypt_context - the encryption context of an inode
+ *
+ * This is the on-disk equivalent of an fscrypt_policy, stored alongside each
+ * encrypted file usually in a hidden extended attribute.  It contains the
+ * fields from the fscrypt_policy, in order to identify the encryption algorithm
+ * and key with which the file is encrypted.  It also contains a nonce that was
+ * randomly generated by fscrypt itself; this is used as KDF input or as a tweak
+ * to cause different files to be encrypted differently.
+ */
+union fscrypt_context {
+	u8 version;
+	struct fscrypt_context_v1 v1;
+	struct fscrypt_context_v2 v2;
+};
+
+/*
+ * Return the size expected for the given fscrypt_context based on its version
+ * number, or 0 if the context version is unrecognized.
+ */
+static inline int fscrypt_context_size(const union fscrypt_context *ctx)
+{
+	switch (ctx->version) {
+	case FSCRYPT_CONTEXT_V1:
+		BUILD_BUG_ON(sizeof(ctx->v1) != 28);
+		return sizeof(ctx->v1);
+	case FSCRYPT_CONTEXT_V2:
+		BUILD_BUG_ON(sizeof(ctx->v2) != 40);
+		return sizeof(ctx->v2);
+	}
+	return 0;
+}
+
+#undef fscrypt_policy
+union fscrypt_policy {
+	u8 version;
+	struct fscrypt_policy_v1 v1;
+	struct fscrypt_policy_v2 v2;
+};
+
+/*
+ * Return the size expected for the given fscrypt_policy based on its version
+ * number, or 0 if the policy version is unrecognized.
+ */
+static inline int fscrypt_policy_size(const union fscrypt_policy *policy)
+{
+	switch (policy->version) {
+	case FSCRYPT_POLICY_V1:
+		return sizeof(policy->v1);
+	case FSCRYPT_POLICY_V2:
+		return sizeof(policy->v2);
+	}
+	return 0;
+}
+
+/* Return the contents encryption mode of a valid encryption policy */
+static inline u8
+fscrypt_policy_contents_mode(const union fscrypt_policy *policy)
+{
+	switch (policy->version) {
+	case FSCRYPT_POLICY_V1:
+		return policy->v1.contents_encryption_mode;
+	case FSCRYPT_POLICY_V2:
+		return policy->v2.contents_encryption_mode;
+	}
+	BUG();
+}
+
+/* Return the filenames encryption mode of a valid encryption policy */
+static inline u8
+fscrypt_policy_fnames_mode(const union fscrypt_policy *policy)
+{
+	switch (policy->version) {
+	case FSCRYPT_POLICY_V1:
+		return policy->v1.filenames_encryption_mode;
+	case FSCRYPT_POLICY_V2:
+		return policy->v2.filenames_encryption_mode;
+	}
+	BUG();
+}
+
+/* Return the flags (FSCRYPT_POLICY_FLAG*) of a valid encryption policy */
+static inline u8
+fscrypt_policy_flags(const union fscrypt_policy *policy)
+{
+	switch (policy->version) {
+	case FSCRYPT_POLICY_V1:
+		return policy->v1.flags;
+	case FSCRYPT_POLICY_V2:
+		return policy->v2.flags;
+	}
+	BUG();
+}
+
+static inline bool
+fscrypt_is_direct_key_policy(const union fscrypt_policy *policy)
+{
+	return fscrypt_policy_flags(policy) & FSCRYPT_POLICY_FLAG_DIRECT_KEY;
+}
 
 /**
  * For encrypted symlinks, the ciphertext length is stored at the beginning
@@ -70,8 +170,8 @@ struct fscrypt_info {
 	struct crypto_cipher *ci_essiv_tfm;
 
 	/*
-	 * Encryption mode used for this inode.  It corresponds to either
-	 * ci_data_mode or ci_filename_mode, depending on the inode type.
+	 * Encryption mode used for this inode.  It corresponds to either the
+	 * contents or filenames encryption mode, depending on the inode type.
 	 */
 	struct fscrypt_mode *ci_mode;
 
@@ -97,11 +197,10 @@ struct fscrypt_info {
 	 */
 	struct fscrypt_direct_key *ci_direct_key;
 
-	/* fields from the fscrypt_context */
-	u8 ci_data_mode;
-	u8 ci_filename_mode;
-	u8 ci_flags;
-	u8 ci_master_key_descriptor[FSCRYPT_KEY_DESCRIPTOR_SIZE];
+	/* The encryption policy used by this inode */
+	union fscrypt_policy ci_policy;
+
+	/* This inode's nonce, copied from the fscrypt_context */
 	u8 ci_nonce[FS_KEY_DERIVATION_NONCE_SIZE];
 };
 
@@ -181,6 +280,17 @@ struct fscrypt_hkdf {
 extern int fscrypt_init_hkdf(struct fscrypt_hkdf *hkdf, const u8 *master_key,
 			     unsigned int master_key_size);
 
+/*
+ * The list of contexts in which fscrypt uses HKDF.  These values are used as
+ * the first byte of the HKDF application-specific info string to guarantee that
+ * info strings are never repeated between contexts.  This ensures that all HKDF
+ * outputs are unique and cryptographically isolated, i.e. knowledge of one
+ * output doesn't reveal another.
+ */
+#define HKDF_CONTEXT_KEY_IDENTIFIER	1
+#define HKDF_CONTEXT_PER_FILE_KEY	2
+#define HKDF_CONTEXT_PER_MODE_KEY	3
+
 extern int fscrypt_hkdf_expand(struct fscrypt_hkdf *hkdf, u8 context,
 			       const u8 *info, unsigned int infolen,
 			       u8 *okm, unsigned int okmlen);
@@ -194,10 +304,16 @@ extern void fscrypt_destroy_hkdf(struct fscrypt_hkdf *hkdf);
  */
 struct fscrypt_master_key_secret {
 
-	/* Size of the raw key in bytes */
+	/*
+	 * For v2 policy keys: HKDF context keyed by this master key.
+	 * For v1 policy keys: not set (hkdf.hmac_tfm == NULL).
+	 */
+	struct fscrypt_hkdf	hkdf;
+
+	/* Size of the raw key in bytes.  Set even if ->raw isn't set. */
 	u32			size;
 
-	/* The raw key */
+	/* For v1 policy keys: the raw key.  Wiped for v2 policy keys. */
 	u8			raw[FSCRYPT_MAX_KEY_SIZE];
 
 } __randomize_layout;
@@ -223,7 +339,12 @@ struct fscrypt_master_key {
 	 */
 	struct fscrypt_master_key_secret	mk_secret;
 
-	/* Arbitrary key descriptor which was assigned by userspace */
+	/*
+	 * For v1 policy keys: an arbitrary key descriptor which was assigned by
+	 * userspace (->descriptor).
+	 *
+	 * For v2 policy keys: a cryptographic hash of this key (->identifier).
+	 */
 	struct fscrypt_key_specifier		mk_spec;
 
 	/*
@@ -242,6 +363,9 @@ struct fscrypt_master_key {
 	struct list_head	mk_decrypted_inodes;
 	spinlock_t		mk_decrypted_inodes_lock;
 
+	/* Per-mode tfms for DIRECT_KEY policies, allocated on-demand */
+	struct crypto_skcipher	*mk_mode_keys[__FSCRYPT_MODE_MAX + 1];
+
 } __randomize_layout;
 
 static inline bool
@@ -263,6 +387,8 @@ static inline const char *master_key_spec_type(
 	switch (spec->type) {
 	case FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR:
 		return "descriptor";
+	case FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER:
+		return "identifier";
 	}
 	return "[unknown]";
 }
@@ -272,6 +398,8 @@ static inline int master_key_spec_len(const struct fscrypt_key_specifier *spec)
 	switch (spec->type) {
 	case FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR:
 		return FSCRYPT_KEY_DESCRIPTOR_SIZE;
+	case FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER:
+		return FSCRYPT_KEY_IDENTIFIER_SIZE;
 	}
 	return 0;
 }
@@ -315,5 +443,14 @@ extern int fscrypt_setup_v1_file_key(struct fscrypt_info *ci,
 
 extern int fscrypt_setup_v1_file_key_via_subscribed_keyrings(
 					struct fscrypt_info *ci);
+/* policy.c */
+
+extern bool fscrypt_policies_equal(const union fscrypt_policy *policy1,
+				   const union fscrypt_policy *policy2);
+extern bool fscrypt_supported_policy(const union fscrypt_policy *policy_u,
+				     const struct inode *inode);
+extern int fscrypt_policy_from_context(union fscrypt_policy *policy_u,
+				       const union fscrypt_context *ctx_u,
+				       int ctx_size);
 
 #endif /* _FSCRYPT_PRIVATE_H */

commit c1144c9b8ad94d8c11809d75c1f322a853cdfc4a
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:47 2019 -0700

    fscrypt: add an HKDF-SHA512 implementation
    
    Add an implementation of HKDF (RFC 5869) to fscrypt, for the purpose of
    deriving additional key material from the fscrypt master keys for v2
    encryption policies.  HKDF is a key derivation function built on top of
    HMAC.  We choose SHA-512 for the underlying unkeyed hash, and use an
    "hmac(sha512)" transform allocated from the crypto API.
    
    We'll be using this to replace the AES-ECB based KDF currently used to
    derive the per-file encryption keys.  While the AES-ECB based KDF is
    believed to meet the original security requirements, it is nonstandard
    and has problems that don't exist in modern KDFs such as HKDF:
    
    1. It's reversible.  Given a derived key and nonce, an attacker can
       easily compute the master key.  This is okay if the master key and
       derived keys are equally hard to compromise, but now we'd like to be
       more robust against threats such as a derived key being compromised
       through a timing attack, or a derived key for an in-use file being
       compromised after the master key has already been removed.
    
    2. It doesn't evenly distribute the entropy from the master key; each 16
       input bytes only affects the corresponding 16 output bytes.
    
    3. It isn't easily extensible to deriving other values or keys, such as
       a public hash for securely identifying the key, or per-mode keys.
       Per-mode keys will be immediately useful for Adiantum encryption, for
       which fscrypt currently uses the master key directly, introducing
       unnecessary usage constraints.  Per-mode keys will also be useful for
       hardware inline encryption, which is currently being worked on.
    
    HKDF solves all the above problems.
    
    Reviewed-by: Paul Crowley <paulcrowley@google.com>
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index fc804f4a03fc..9556e9499dc5 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -172,6 +172,21 @@ extern bool fscrypt_fname_encrypted_size(const struct inode *inode,
 					 u32 orig_len, u32 max_len,
 					 u32 *encrypted_len_ret);
 
+/* hkdf.c */
+
+struct fscrypt_hkdf {
+	struct crypto_shash *hmac_tfm;
+};
+
+extern int fscrypt_init_hkdf(struct fscrypt_hkdf *hkdf, const u8 *master_key,
+			     unsigned int master_key_size);
+
+extern int fscrypt_hkdf_expand(struct fscrypt_hkdf *hkdf, u8 context,
+			       const u8 *info, unsigned int infolen,
+			       u8 *okm, unsigned int okmlen);
+
+extern void fscrypt_destroy_hkdf(struct fscrypt_hkdf *hkdf);
+
 /* keyring.c */
 
 /*

commit b1c0ec3599f42ad372063b0235a3c33f65eb1e30
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:46 2019 -0700

    fscrypt: add FS_IOC_REMOVE_ENCRYPTION_KEY ioctl
    
    Add a new fscrypt ioctl, FS_IOC_REMOVE_ENCRYPTION_KEY.  This ioctl
    removes an encryption key that was added by FS_IOC_ADD_ENCRYPTION_KEY.
    It wipes the secret key itself, then "locks" the encrypted files and
    directories that had been unlocked using that key -- implemented by
    evicting the relevant dentries and inodes from the VFS caches.
    
    The problem this solves is that many fscrypt users want the ability to
    remove encryption keys, causing the corresponding encrypted directories
    to appear "locked" (presented in ciphertext form) again.  Moreover,
    users want removing an encryption key to *really* remove it, in the
    sense that the removed keys cannot be recovered even if kernel memory is
    compromised, e.g. by the exploit of a kernel security vulnerability or
    by a physical attack.  This is desirable after a user logs out of the
    system, for example.  In many cases users even already assume this to be
    the case and are surprised to hear when it's not.
    
    It is not sufficient to simply unlink the master key from the keyring
    (or to revoke or invalidate it), since the actual encryption transform
    objects are still pinned in memory by their inodes.  Therefore, to
    really remove a key we must also evict the relevant inodes.
    
    Currently one workaround is to run 'sync && echo 2 >
    /proc/sys/vm/drop_caches'.  But, that evicts all unused inodes in the
    system rather than just the inodes associated with the key being
    removed, causing severe performance problems.  Moreover, it requires
    root privileges, so regular users can't "lock" their encrypted files.
    
    Another workaround, used in Chromium OS kernels, is to add a new
    VFS-level ioctl FS_IOC_DROP_CACHE which is a more restricted version of
    drop_caches that operates on a single super_block.  It does:
    
            shrink_dcache_sb(sb);
            invalidate_inodes(sb, false);
    
    But it's still a hack.  Yet, the major users of filesystem encryption
    want this feature badly enough that they are actually using these hacks.
    
    To properly solve the problem, start maintaining a list of the inodes
    which have been "unlocked" using each master key.  Originally this
    wasn't possible because the kernel didn't keep track of in-use master
    keys at all.  But, with the ->s_master_keys keyring it is now possible.
    
    Then, add an ioctl FS_IOC_REMOVE_ENCRYPTION_KEY.  It finds the specified
    master key in ->s_master_keys, then wipes the secret key itself, which
    prevents any additional inodes from being unlocked with the key.  Then,
    it syncs the filesystem and evicts the inodes in the key's list.  The
    normal inode eviction code will free and wipe the per-file keys (in
    ->i_crypt_info).  Note that freeing ->i_crypt_info without evicting the
    inodes was also considered, but would have been racy.
    
    Some inodes may still be in use when a master key is removed, and we
    can't simply revoke random file descriptors, mmap's, etc.  Thus, the
    ioctl simply skips in-use inodes, and returns -EBUSY to indicate that
    some inodes weren't evicted.  The master key *secret* is still removed,
    but the fscrypt_master_key struct remains to keep track of the remaining
    inodes.  Userspace can then retry the ioctl to evict the remaining
    inodes.  Alternatively, if userspace adds the key again, the refreshed
    secret will be associated with the existing list of inodes so they
    remain correctly tracked for future key removals.
    
    The ioctl doesn't wipe pagecache pages.  Thus, we tolerate that after a
    kernel compromise some portions of plaintext file contents may still be
    recoverable from memory.  This can be solved by enabling page poisoning
    system-wide, which security conscious users may choose to do.  But it's
    very difficult to solve otherwise, e.g. note that plaintext file
    contents may have been read in other places than pagecache pages.
    
    Like FS_IOC_ADD_ENCRYPTION_KEY, FS_IOC_REMOVE_ENCRYPTION_KEY is
    initially restricted to privileged users only.  This is sufficient for
    some use cases, but not all.  A later patch will relax this restriction,
    but it will require introducing key hashes, among other changes.
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 0d9ebfd3bf3a..fc804f4a03fc 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -78,6 +78,19 @@ struct fscrypt_info {
 	/* Back-pointer to the inode */
 	struct inode *ci_inode;
 
+	/*
+	 * The master key with which this inode was unlocked (decrypted).  This
+	 * will be NULL if the master key was found in a process-subscribed
+	 * keyring rather than in the filesystem-level keyring.
+	 */
+	struct key *ci_master_key;
+
+	/*
+	 * Link in list of inodes that were unlocked with the master key.
+	 * Only used when ->ci_master_key is set.
+	 */
+	struct list_head ci_master_key_link;
+
 	/*
 	 * If non-NULL, then encryption is done using the master key directly
 	 * and ci_ctfm will equal ci_direct_key->dk_ctfm.
@@ -183,14 +196,52 @@ struct fscrypt_master_key_secret {
  */
 struct fscrypt_master_key {
 
-	/* The secret key material */
+	/*
+	 * The secret key material.  After FS_IOC_REMOVE_ENCRYPTION_KEY is
+	 * executed, this is wiped and no new inodes can be unlocked with this
+	 * key; however, there may still be inodes in ->mk_decrypted_inodes
+	 * which could not be evicted.  As long as some inodes still remain,
+	 * FS_IOC_REMOVE_ENCRYPTION_KEY can be retried, or
+	 * FS_IOC_ADD_ENCRYPTION_KEY can add the secret again.
+	 *
+	 * Locking: protected by key->sem.
+	 */
 	struct fscrypt_master_key_secret	mk_secret;
 
 	/* Arbitrary key descriptor which was assigned by userspace */
 	struct fscrypt_key_specifier		mk_spec;
 
+	/*
+	 * Length of ->mk_decrypted_inodes, plus one if mk_secret is present.
+	 * Once this goes to 0, the master key is removed from ->s_master_keys.
+	 * The 'struct fscrypt_master_key' will continue to live as long as the
+	 * 'struct key' whose payload it is, but we won't let this reference
+	 * count rise again.
+	 */
+	refcount_t		mk_refcount;
+
+	/*
+	 * List of inodes that were unlocked using this key.  This allows the
+	 * inodes to be evicted efficiently if the key is removed.
+	 */
+	struct list_head	mk_decrypted_inodes;
+	spinlock_t		mk_decrypted_inodes_lock;
+
 } __randomize_layout;
 
+static inline bool
+is_master_key_secret_present(const struct fscrypt_master_key_secret *secret)
+{
+	/*
+	 * The READ_ONCE() is only necessary for fscrypt_drop_inode() and
+	 * fscrypt_key_describe().  These run in atomic context, so they can't
+	 * take key->sem and thus 'secret' can change concurrently which would
+	 * be a data race.  But they only need to know whether the secret *was*
+	 * present at the time of check, so READ_ONCE() suffices.
+	 */
+	return READ_ONCE(secret->size) != 0;
+}
+
 static inline const char *master_key_spec_type(
 				const struct fscrypt_key_specifier *spec)
 {

commit 22d94f493bfb408fdd764f7b1d0363af2122fba5
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:46 2019 -0700

    fscrypt: add FS_IOC_ADD_ENCRYPTION_KEY ioctl
    
    Add a new fscrypt ioctl, FS_IOC_ADD_ENCRYPTION_KEY.  This ioctl adds an
    encryption key to the filesystem's fscrypt keyring ->s_master_keys,
    making any files encrypted with that key appear "unlocked".
    
    Why we need this
    ~~~~~~~~~~~~~~~~
    
    The main problem is that the "locked/unlocked" (ciphertext/plaintext)
    status of encrypted files is global, but the fscrypt keys are not.
    fscrypt only looks for keys in the keyring(s) the process accessing the
    filesystem is subscribed to: the thread keyring, process keyring, and
    session keyring, where the session keyring may contain the user keyring.
    
    Therefore, userspace has to put fscrypt keys in the keyrings for
    individual users or sessions.  But this means that when a process with a
    different keyring tries to access encrypted files, whether they appear
    "unlocked" or not is nondeterministic.  This is because it depends on
    whether the files are currently present in the inode cache.
    
    Fixing this by consistently providing each process its own view of the
    filesystem depending on whether it has the key or not isn't feasible due
    to how the VFS caches work.  Furthermore, while sometimes users expect
    this behavior, it is misguided for two reasons.  First, it would be an
    OS-level access control mechanism largely redundant with existing access
    control mechanisms such as UNIX file permissions, ACLs, LSMs, etc.
    Encryption is actually for protecting the data at rest.
    
    Second, almost all users of fscrypt actually do need the keys to be
    global.  The largest users of fscrypt, Android and Chromium OS, achieve
    this by having PID 1 create a "session keyring" that is inherited by
    every process.  This works, but it isn't scalable because it prevents
    session keyrings from being used for any other purpose.
    
    On general-purpose Linux distros, the 'fscrypt' userspace tool [1] can't
    similarly abuse the session keyring, so to make 'sudo' work on all
    systems it has to link all the user keyrings into root's user keyring
    [2].  This is ugly and raises security concerns.  Moreover it can't make
    the keys available to system services, such as sshd trying to access the
    user's '~/.ssh' directory (see [3], [4]) or NetworkManager trying to
    read certificates from the user's home directory (see [5]); or to Docker
    containers (see [6], [7]).
    
    By having an API to add a key to the *filesystem* we'll be able to fix
    the above bugs, remove userspace workarounds, and clearly express the
    intended semantics: the locked/unlocked status of an encrypted directory
    is global, and encryption is orthogonal to OS-level access control.
    
    Why not use the add_key() syscall
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    We use an ioctl for this API rather than the existing add_key() system
    call because the ioctl gives us the flexibility needed to implement
    fscrypt-specific semantics that will be introduced in later patches:
    
    - Supporting key removal with the semantics such that the secret is
      removed immediately and any unused inodes using the key are evicted;
      also, the eviction of any in-use inodes can be retried.
    
    - Calculating a key-dependent cryptographic identifier and returning it
      to userspace.
    
    - Allowing keys to be added and removed by non-root users, but only keys
      for v2 encryption policies; and to prevent denial-of-service attacks,
      users can only remove keys they themselves have added, and a key is
      only really removed after all users who added it have removed it.
    
    Trying to shoehorn these semantics into the keyrings syscalls would be
    very difficult, whereas the ioctls make things much easier.
    
    However, to reuse code the implementation still uses the keyrings
    service internally.  Thus we get lockless RCU-mode key lookups without
    having to re-implement it, and the keys automatically show up in
    /proc/keys for debugging purposes.
    
    References:
    
        [1] https://github.com/google/fscrypt
        [2] https://goo.gl/55cCrI#heading=h.vf09isp98isb
        [3] https://github.com/google/fscrypt/issues/111#issuecomment-444347939
        [4] https://github.com/google/fscrypt/issues/116
        [5] https://bugs.launchpad.net/ubuntu/+source/fscrypt/+bug/1770715
        [6] https://github.com/google/fscrypt/issues/128
        [7] https://askubuntu.com/questions/1130306/cannot-run-docker-on-an-encrypted-filesystem
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 794dcba25ca8..0d9ebfd3bf3a 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -14,9 +14,12 @@
 #include <linux/fscrypt.h>
 #include <crypto/hash.h>
 
-/* Encryption parameters */
+#define CONST_STRLEN(str)	(sizeof(str) - 1)
+
 #define FS_KEY_DERIVATION_NONCE_SIZE	16
 
+#define FSCRYPT_MIN_KEY_SIZE		16
+
 /**
  * Encryption context for inode
  *
@@ -156,6 +159,63 @@ extern bool fscrypt_fname_encrypted_size(const struct inode *inode,
 					 u32 orig_len, u32 max_len,
 					 u32 *encrypted_len_ret);
 
+/* keyring.c */
+
+/*
+ * fscrypt_master_key_secret - secret key material of an in-use master key
+ */
+struct fscrypt_master_key_secret {
+
+	/* Size of the raw key in bytes */
+	u32			size;
+
+	/* The raw key */
+	u8			raw[FSCRYPT_MAX_KEY_SIZE];
+
+} __randomize_layout;
+
+/*
+ * fscrypt_master_key - an in-use master key
+ *
+ * This represents a master encryption key which has been added to the
+ * filesystem and can be used to "unlock" the encrypted files which were
+ * encrypted with it.
+ */
+struct fscrypt_master_key {
+
+	/* The secret key material */
+	struct fscrypt_master_key_secret	mk_secret;
+
+	/* Arbitrary key descriptor which was assigned by userspace */
+	struct fscrypt_key_specifier		mk_spec;
+
+} __randomize_layout;
+
+static inline const char *master_key_spec_type(
+				const struct fscrypt_key_specifier *spec)
+{
+	switch (spec->type) {
+	case FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR:
+		return "descriptor";
+	}
+	return "[unknown]";
+}
+
+static inline int master_key_spec_len(const struct fscrypt_key_specifier *spec)
+{
+	switch (spec->type) {
+	case FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR:
+		return FSCRYPT_KEY_DESCRIPTOR_SIZE;
+	}
+	return 0;
+}
+
+extern struct key *
+fscrypt_find_master_key(struct super_block *sb,
+			const struct fscrypt_key_specifier *mk_spec);
+
+extern int __init fscrypt_init_keyring(void);
+
 /* keysetup.c */
 
 struct fscrypt_mode {

commit feed825861919ac3fac4b2ab83673dd5225f7f0d
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:45 2019 -0700

    fscrypt: rename keyinfo.c to keysetup.c
    
    Rename keyinfo.c to keysetup.c since this better describes what the file
    does (sets up the key), and it matches the new file keysetup_v1.c.
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 387b44b255f6..794dcba25ca8 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -156,7 +156,7 @@ extern bool fscrypt_fname_encrypted_size(const struct inode *inode,
 					 u32 orig_len, u32 max_len,
 					 u32 *encrypted_len_ret);
 
-/* keyinfo.c */
+/* keysetup.c */
 
 struct fscrypt_mode {
 	const char *friendly_name;

commit 0109ce76dd6e9e69559e56ea9f10d1e12ca4a50b
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:45 2019 -0700

    fscrypt: move v1 policy key setup to keysetup_v1.c
    
    In preparation for introducing v2 encryption policies which will find
    and derive encryption keys differently from the current v1 encryption
    policies, move the v1 policy-specific key setup code from keyinfo.c into
    keysetup_v1.c.
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 56bac5c7ef40..387b44b255f6 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -173,4 +173,21 @@ fscrypt_mode_supports_direct_key(const struct fscrypt_mode *mode)
 	return mode->ivsize >= offsetofend(union fscrypt_iv, nonce);
 }
 
+extern struct crypto_skcipher *
+fscrypt_allocate_skcipher(struct fscrypt_mode *mode, const u8 *raw_key,
+			  const struct inode *inode);
+
+extern int fscrypt_set_derived_key(struct fscrypt_info *ci,
+				   const u8 *derived_key);
+
+/* keysetup_v1.c */
+
+extern void fscrypt_put_direct_key(struct fscrypt_direct_key *dk);
+
+extern int fscrypt_setup_v1_file_key(struct fscrypt_info *ci,
+				     const u8 *raw_master_key);
+
+extern int fscrypt_setup_v1_file_key_via_subscribed_keyrings(
+					struct fscrypt_info *ci);
+
 #endif /* _FSCRYPT_PRIVATE_H */

commit 3ec4f2a62927c72607db633f55b0489e3d5b8e48
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:45 2019 -0700

    fscrypt: refactor key setup code in preparation for v2 policies
    
    Do some more refactoring of the key setup code, in preparation for
    introducing a filesystem-level keyring and v2 encryption policies:
    
    - Now that ci_inode exists, don't pass around the inode unnecessarily.
    
    - Define a function setup_file_encryption_key() which handles the crypto
      key setup given an under-construction fscrypt_info.  Don't pass the
      fscrypt_context, since everything is in the fscrypt_info.
      [This will be extended for v2 policies and the fs-level keyring.]
    
    - Define a function fscrypt_set_derived_key() which sets the per-file
      key, without depending on anything specific to v1 policies.
      [This will also be used for v2 policies.]
    
    - Define a function fscrypt_setup_v1_file_key() which takes the raw
      master key, thus separating finding the key from using it.
      [This will also be used if the key is found in the fs-level keyring.]
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 80d15a1bf606..56bac5c7ef40 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -4,9 +4,8 @@
  *
  * Copyright (C) 2015, Google, Inc.
  *
- * This contains encryption key functions.
- *
- * Written by Michael Halcrow, Ildar Muslukhov, and Uday Savagaonkar, 2015.
+ * Originally written by Michael Halcrow, Ildar Muslukhov, and Uday Savagaonkar.
+ * Heavily modified since then.
  */
 
 #ifndef _FSCRYPT_PRIVATE_H
@@ -168,4 +167,10 @@ struct fscrypt_mode {
 	bool needs_essiv;
 };
 
+static inline bool
+fscrypt_mode_supports_direct_key(const struct fscrypt_mode *mode)
+{
+	return mode->ivsize >= offsetofend(union fscrypt_iv, nonce);
+}
+
 #endif /* _FSCRYPT_PRIVATE_H */

commit a828daabb2ae917c12f4dc617c04db1185e6221f
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:45 2019 -0700

    fscrypt: rename fscrypt_master_key to fscrypt_direct_key
    
    In preparation for introducing a filesystem-level keyring which will
    contain fscrypt master keys, rename the existing 'struct
    fscrypt_master_key' to 'struct fscrypt_direct_key'.  This is the
    structure in the existing table of master keys that's maintained to
    deduplicate the crypto transforms for v1 DIRECT_KEY policies.
    
    I've chosen to keep this table as-is rather than make it automagically
    add/remove the keys to/from the filesystem-level keyring, since that
    would add a lot of extra complexity to the filesystem-level keyring.
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index d345a7d28df8..80d15a1bf606 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -77,11 +77,10 @@ struct fscrypt_info {
 	struct inode *ci_inode;
 
 	/*
-	 * If non-NULL, then this inode uses a master key directly rather than a
-	 * derived key, and ci_ctfm will equal ci_master_key->mk_ctfm.
-	 * Otherwise, this inode uses a derived key.
+	 * If non-NULL, then encryption is done using the master key directly
+	 * and ci_ctfm will equal ci_direct_key->dk_ctfm.
 	 */
-	struct fscrypt_master_key *ci_master_key;
+	struct fscrypt_direct_key *ci_direct_key;
 
 	/* fields from the fscrypt_context */
 	u8 ci_data_mode;

commit 59dc6a8e1f534cde6f7986f2fd278062e25336c0
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:44 2019 -0700

    fscrypt: add ->ci_inode to fscrypt_info
    
    Add an inode back-pointer to 'struct fscrypt_info', such that
    inode->i_crypt_info->ci_inode == inode.
    
    This will be useful for:
    
    1. Evicting the inodes when a fscrypt key is removed, since we'll track
       the inodes using a given key by linking their fscrypt_infos together,
       rather than the inodes directly.  This avoids bloating 'struct inode'
       with a new list_head.
    
    2. Simplifying the per-file key setup, since the inode pointer won't
       have to be passed around everywhere just in case something goes wrong
       and it's needed for fscrypt_warn().
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index fae411b2f78d..d345a7d28df8 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -73,6 +73,9 @@ struct fscrypt_info {
 	 */
 	struct fscrypt_mode *ci_mode;
 
+	/* Back-pointer to the inode */
+	struct inode *ci_inode;
+
 	/*
 	 * If non-NULL, then this inode uses a master key directly rather than a
 	 * derived key, and ci_ctfm will equal ci_master_key->mk_ctfm.

commit 3b6df59bc4d242ac5847592de55d1ff327cd4549
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:44 2019 -0700

    fscrypt: use FSCRYPT_* definitions, not FS_*
    
    Update fs/crypto/ to use the new names for the UAPI constants rather
    than the old names, then make the old definitions conditional on
    !__KERNEL__.
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 4d715708c6e1..fae411b2f78d 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -34,7 +34,7 @@ struct fscrypt_context {
 	u8 contents_encryption_mode;
 	u8 filenames_encryption_mode;
 	u8 flags;
-	u8 master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];
+	u8 master_key_descriptor[FSCRYPT_KEY_DESCRIPTOR_SIZE];
 	u8 nonce[FS_KEY_DERIVATION_NONCE_SIZE];
 } __packed;
 
@@ -84,7 +84,7 @@ struct fscrypt_info {
 	u8 ci_data_mode;
 	u8 ci_filename_mode;
 	u8 ci_flags;
-	u8 ci_master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];
+	u8 ci_master_key_descriptor[FSCRYPT_KEY_DESCRIPTOR_SIZE];
 	u8 ci_nonce[FS_KEY_DERIVATION_NONCE_SIZE];
 };
 
@@ -98,16 +98,16 @@ typedef enum {
 static inline bool fscrypt_valid_enc_modes(u32 contents_mode,
 					   u32 filenames_mode)
 {
-	if (contents_mode == FS_ENCRYPTION_MODE_AES_128_CBC &&
-	    filenames_mode == FS_ENCRYPTION_MODE_AES_128_CTS)
+	if (contents_mode == FSCRYPT_MODE_AES_128_CBC &&
+	    filenames_mode == FSCRYPT_MODE_AES_128_CTS)
 		return true;
 
-	if (contents_mode == FS_ENCRYPTION_MODE_AES_256_XTS &&
-	    filenames_mode == FS_ENCRYPTION_MODE_AES_256_CTS)
+	if (contents_mode == FSCRYPT_MODE_AES_256_XTS &&
+	    filenames_mode == FSCRYPT_MODE_AES_256_CTS)
 		return true;
 
-	if (contents_mode == FS_ENCRYPTION_MODE_ADIANTUM &&
-	    filenames_mode == FS_ENCRYPTION_MODE_ADIANTUM)
+	if (contents_mode == FSCRYPT_MODE_ADIANTUM &&
+	    filenames_mode == FSCRYPT_MODE_ADIANTUM)
 		return true;
 
 	return false;

commit 886da8b39cf27995836062bb7fe5fd5cb764540a
Author: Eric Biggers <ebiggers@google.com>
Date:   Wed Jul 24 11:07:58 2019 -0700

    fscrypt: make fscrypt_msg() take inode instead of super_block
    
    Most of the warning and error messages in fs/crypto/ are for situations
    related to a specific inode, not merely to a super_block.  So to make
    things easier, make fscrypt_msg() take an inode rather than a
    super_block, and make it print the inode number.
    
    Note: This is the same approach I'm taking for fsverity_msg().
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 224178294371..4d715708c6e1 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -125,12 +125,12 @@ extern struct page *fscrypt_alloc_bounce_page(gfp_t gfp_flags);
 extern const struct dentry_operations fscrypt_d_ops;
 
 extern void __printf(3, 4) __cold
-fscrypt_msg(struct super_block *sb, const char *level, const char *fmt, ...);
+fscrypt_msg(const struct inode *inode, const char *level, const char *fmt, ...);
 
-#define fscrypt_warn(sb, fmt, ...)		\
-	fscrypt_msg(sb, KERN_WARNING, fmt, ##__VA_ARGS__)
-#define fscrypt_err(sb, fmt, ...)		\
-	fscrypt_msg(sb, KERN_ERR, fmt, ##__VA_ARGS__)
+#define fscrypt_warn(inode, fmt, ...)		\
+	fscrypt_msg((inode), KERN_WARNING, fmt, ##__VA_ARGS__)
+#define fscrypt_err(inode, fmt, ...)		\
+	fscrypt_msg((inode), KERN_ERR, fmt, ##__VA_ARGS__)
 
 #define FSCRYPT_MAX_IV_SIZE	32
 

commit 75798f85f2badb04074cc909dbbb93072f4041ff
Author: Eric Biggers <ebiggers@google.com>
Date:   Wed Jul 24 11:07:57 2019 -0700

    fscrypt: remove loadable module related code
    
    Since commit 643fa9612bf1 ("fscrypt: remove filesystem specific build
    config option"), fs/crypto/ can no longer be built as a loadable module.
    Thus it no longer needs a module_exit function, nor a MODULE_LICENSE.
    So remove them, and change module_init to late_initcall.
    
    Reviewed-by: Chandan Rajendra <chandan@linux.ibm.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 8978eec9d766..224178294371 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -166,6 +166,4 @@ struct fscrypt_mode {
 	bool needs_essiv;
 };
 
-extern void __exit fscrypt_essiv_cleanup(void);
-
 #endif /* _FSCRYPT_PRIVATE_H */

commit f47fcbb2b578bdb213d9ac5875aab56a2034d466
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon May 20 09:29:41 2019 -0700

    fscrypt: rename fscrypt_do_page_crypto() to fscrypt_crypt_block()
    
    fscrypt_do_page_crypto() only does a single encryption or decryption
    operation, with a single logical block number (single IV).  So it
    actually operates on a filesystem block, not a "page" per se.  To
    reflect this, rename it to fscrypt_crypt_block().
    
    Reviewed-by: Chandan Rajendra <chandan@linux.ibm.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 4122ee1a0b7b..8978eec9d766 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -116,12 +116,11 @@ static inline bool fscrypt_valid_enc_modes(u32 contents_mode,
 /* crypto.c */
 extern struct kmem_cache *fscrypt_info_cachep;
 extern int fscrypt_initialize(unsigned int cop_flags);
-extern int fscrypt_do_page_crypto(const struct inode *inode,
-				  fscrypt_direction_t rw, u64 lblk_num,
-				  struct page *src_page,
-				  struct page *dest_page,
-				  unsigned int len, unsigned int offs,
-				  gfp_t gfp_flags);
+extern int fscrypt_crypt_block(const struct inode *inode,
+			       fscrypt_direction_t rw, u64 lblk_num,
+			       struct page *src_page, struct page *dest_page,
+			       unsigned int len, unsigned int offs,
+			       gfp_t gfp_flags);
 extern struct page *fscrypt_alloc_bounce_page(gfp_t gfp_flags);
 extern const struct dentry_operations fscrypt_d_ops;
 

commit d2d0727b1654e11563f181f4d3d48b9275514480
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon May 20 09:29:39 2019 -0700

    fscrypt: simplify bounce page handling
    
    Currently, bounce page handling for writes to encrypted files is
    unnecessarily complicated.  A fscrypt_ctx is allocated along with each
    bounce page, page_private(bounce_page) points to this fscrypt_ctx, and
    fscrypt_ctx::w::control_page points to the original pagecache page.
    
    However, because writes don't use the fscrypt_ctx for anything else,
    there's no reason why page_private(bounce_page) can't just point to the
    original pagecache page directly.
    
    Therefore, this patch makes this change.  In the process, it also cleans
    up the API exposed to filesystems that allows testing whether a page is
    a bounce page, getting the pagecache page from a bounce page, and
    freeing a bounce page.
    
    Reviewed-by: Chandan Rajendra <chandan@linux.ibm.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 7da276159593..4122ee1a0b7b 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -94,7 +94,6 @@ typedef enum {
 } fscrypt_direction_t;
 
 #define FS_CTX_REQUIRES_FREE_ENCRYPT_FL		0x00000001
-#define FS_CTX_HAS_BOUNCE_BUFFER_FL		0x00000002
 
 static inline bool fscrypt_valid_enc_modes(u32 contents_mode,
 					   u32 filenames_mode)
@@ -123,8 +122,7 @@ extern int fscrypt_do_page_crypto(const struct inode *inode,
 				  struct page *dest_page,
 				  unsigned int len, unsigned int offs,
 				  gfp_t gfp_flags);
-extern struct page *fscrypt_alloc_bounce_page(struct fscrypt_ctx *ctx,
-					      gfp_t gfp_flags);
+extern struct page *fscrypt_alloc_bounce_page(gfp_t gfp_flags);
 extern const struct dentry_operations fscrypt_d_ops;
 
 extern void __printf(3, 4) __cold

commit 643fa9612bf1a29153eee46fd398117632f93cbe
Author: Chandan Rajendra <chandan@linux.vnet.ibm.com>
Date:   Wed Dec 12 15:20:12 2018 +0530

    fscrypt: remove filesystem specific build config option
    
    In order to have a common code base for fscrypt "post read" processing
    for all filesystems which support encryption, this commit removes
    filesystem specific build config option (e.g. CONFIG_EXT4_FS_ENCRYPTION)
    and replaces it with a build option (i.e. CONFIG_FS_ENCRYPTION) whose
    value affects all the filesystems making use of fscrypt.
    
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Chandan Rajendra <chandan@linux.vnet.ibm.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 7424f851eb5c..7da276159593 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -12,7 +12,6 @@
 #ifndef _FSCRYPT_PRIVATE_H
 #define _FSCRYPT_PRIVATE_H
 
-#define __FS_HAS_ENCRYPTION 1
 #include <linux/fscrypt.h>
 #include <crypto/hash.h>
 

commit 8094c3ceb21ad93896fd4d238e8ba41911932eaf
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Jan 6 08:36:21 2019 -0500

    fscrypt: add Adiantum support
    
    Add support for the Adiantum encryption mode to fscrypt.  Adiantum is a
    tweakable, length-preserving encryption mode with security provably
    reducible to that of XChaCha12 and AES-256, subject to a security bound.
    It's also a true wide-block mode, unlike XTS.  See the paper
    "Adiantum: length-preserving encryption for entry-level processors"
    (https://eprint.iacr.org/2018/720.pdf) for more details.  Also see
    commit 059c2a4d8e16 ("crypto: adiantum - add Adiantum support").
    
    On sufficiently long messages, Adiantum's bottlenecks are XChaCha12 and
    the NH hash function.  These algorithms are fast even on processors
    without dedicated crypto instructions.  Adiantum makes it feasible to
    enable storage encryption on low-end mobile devices that lack AES
    instructions; currently such devices are unencrypted.  On ARM Cortex-A7,
    on 4096-byte messages Adiantum encryption is about 4 times faster than
    AES-256-XTS encryption; decryption is about 5 times faster.
    
    In fscrypt, Adiantum is suitable for encrypting both file contents and
    names.  With filenames, it fixes a known weakness: when two filenames in
    a directory share a common prefix of >= 16 bytes, with CTS-CBC their
    encrypted filenames share a common prefix too, leaking information.
    Adiantum does not have this problem.
    
    Since Adiantum also accepts long tweaks (IVs), it's also safe to use the
    master key directly for Adiantum encryption rather than deriving
    per-file keys, provided that the per-file nonce is included in the IVs
    and the master key isn't used for any other encryption mode.  This
    configuration saves memory and improves performance.  A new fscrypt
    policy flag is added to allow users to opt-in to this configuration.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 79debfc9cef9..7424f851eb5c 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -17,7 +17,6 @@
 #include <crypto/hash.h>
 
 /* Encryption parameters */
-#define FS_IV_SIZE			16
 #define FS_KEY_DERIVATION_NONCE_SIZE	16
 
 /**
@@ -52,16 +51,42 @@ struct fscrypt_symlink_data {
 } __packed;
 
 /*
- * A pointer to this structure is stored in the file system's in-core
- * representation of an inode.
+ * fscrypt_info - the "encryption key" for an inode
+ *
+ * When an encrypted file's key is made available, an instance of this struct is
+ * allocated and stored in ->i_crypt_info.  Once created, it remains until the
+ * inode is evicted.
  */
 struct fscrypt_info {
+
+	/* The actual crypto transform used for encryption and decryption */
+	struct crypto_skcipher *ci_ctfm;
+
+	/*
+	 * Cipher for ESSIV IV generation.  Only set for CBC contents
+	 * encryption, otherwise is NULL.
+	 */
+	struct crypto_cipher *ci_essiv_tfm;
+
+	/*
+	 * Encryption mode used for this inode.  It corresponds to either
+	 * ci_data_mode or ci_filename_mode, depending on the inode type.
+	 */
+	struct fscrypt_mode *ci_mode;
+
+	/*
+	 * If non-NULL, then this inode uses a master key directly rather than a
+	 * derived key, and ci_ctfm will equal ci_master_key->mk_ctfm.
+	 * Otherwise, this inode uses a derived key.
+	 */
+	struct fscrypt_master_key *ci_master_key;
+
+	/* fields from the fscrypt_context */
 	u8 ci_data_mode;
 	u8 ci_filename_mode;
 	u8 ci_flags;
-	struct crypto_skcipher *ci_ctfm;
-	struct crypto_cipher *ci_essiv_tfm;
-	u8 ci_master_key[FS_KEY_DESCRIPTOR_SIZE];
+	u8 ci_master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];
+	u8 ci_nonce[FS_KEY_DERIVATION_NONCE_SIZE];
 };
 
 typedef enum {
@@ -83,6 +108,10 @@ static inline bool fscrypt_valid_enc_modes(u32 contents_mode,
 	    filenames_mode == FS_ENCRYPTION_MODE_AES_256_CTS)
 		return true;
 
+	if (contents_mode == FS_ENCRYPTION_MODE_ADIANTUM &&
+	    filenames_mode == FS_ENCRYPTION_MODE_ADIANTUM)
+		return true;
+
 	return false;
 }
 
@@ -107,6 +136,22 @@ fscrypt_msg(struct super_block *sb, const char *level, const char *fmt, ...);
 #define fscrypt_err(sb, fmt, ...)		\
 	fscrypt_msg(sb, KERN_ERR, fmt, ##__VA_ARGS__)
 
+#define FSCRYPT_MAX_IV_SIZE	32
+
+union fscrypt_iv {
+	struct {
+		/* logical block number within the file */
+		__le64 lblk_num;
+
+		/* per-file nonce; only set in DIRECT_KEY mode */
+		u8 nonce[FS_KEY_DERIVATION_NONCE_SIZE];
+	};
+	u8 raw[FSCRYPT_MAX_IV_SIZE];
+};
+
+void fscrypt_generate_iv(union fscrypt_iv *iv, u64 lblk_num,
+			 const struct fscrypt_info *ci);
+
 /* fname.c */
 extern int fname_encrypt(struct inode *inode, const struct qstr *iname,
 			 u8 *out, unsigned int olen);
@@ -115,6 +160,16 @@ extern bool fscrypt_fname_encrypted_size(const struct inode *inode,
 					 u32 *encrypted_len_ret);
 
 /* keyinfo.c */
+
+struct fscrypt_mode {
+	const char *friendly_name;
+	const char *cipher_str;
+	int keysize;
+	int ivsize;
+	bool logged_impl_name;
+	bool needs_essiv;
+};
+
 extern void __exit fscrypt_essiv_cleanup(void);
 
 #endif /* _FSCRYPT_PRIVATE_H */

commit 578bdaabd015b9b164842c3e8ace9802f38e7ecc
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Aug 7 08:22:25 2018 +0200

    crypto: speck - remove Speck
    
    These are unused, undesired, and have never actually been used by
    anybody. The original authors of this code have changed their mind about
    its inclusion. While originally proposed for disk encryption on low-end
    devices, the idea was discarded [1] in favor of something else before
    that could really get going. Therefore, this patch removes Speck.
    
    [1] https://marc.info/?l=linux-crypto-vger&m=153359499015659
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Acked-by: Eric Biggers <ebiggers@google.com>
    Cc: stable@vger.kernel.org
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 39c20ef26db4..79debfc9cef9 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -83,10 +83,6 @@ static inline bool fscrypt_valid_enc_modes(u32 contents_mode,
 	    filenames_mode == FS_ENCRYPTION_MODE_AES_256_CTS)
 		return true;
 
-	if (contents_mode == FS_ENCRYPTION_MODE_SPECK128_256_XTS &&
-	    filenames_mode == FS_ENCRYPTION_MODE_SPECK128_256_CTS)
-		return true;
-
 	return false;
 }
 

commit d54d35c501bcbd57b9722a6b371c0608b5d34199
Merge: a2225d931f75 dfa742803fbb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 11 10:16:13 2018 -0700

    Merge tag 'f2fs-for-4.18' of git://git.kernel.org/pub/scm/linux/kernel/git/jaegeuk/f2fs
    
    Pull f2fs updates from Jaegeuk Kim:
     "In this round, we've mainly focused on discard, aka unmap, control
      along with fstrim for Android-specific usage model. In addition, we've
      fixed writepage flow which returned EAGAIN previously resulting in EIO
      of fsync(2) due to mapping's error state. In order to avoid old MM bug
      [1], we decided not to use __GFP_ZERO for the mapping for node and
      meta page caches. As always, we've cleaned up many places for future
      fsverity and symbol conflicts.
    
      Enhancements:
       - do discard/fstrim in lower priority considering fs utilization
       - split large discard commands into smaller ones for better responsiveness
       - add more sanity checks to address syzbot reports
       - add a mount option, fsync_mode=nobarrier, which can reduce # of cache flushes
       - clean up symbol namespace with modified function names
       - be strict on block allocation and IO control in corner cases
    
      Bug fixes:
       - don't use __GFP_ZERO for mappings
       - fix error reports in writepage to avoid fsync() failure
       - avoid selinux denial on CAP_RESOURCE on resgid/resuid
       - fix some subtle race conditions in GC/atomic writes/shutdown
       - fix overflow bugs in sanity_check_raw_super
       - fix missing bits on get_flags
    
      Clean-ups:
       - prepare the generic flow for future fsverity integration
       - fix some broken coding standard"
    
    [1] https://lkml.org/lkml/2018/4/8/661
    
    * tag 'f2fs-for-4.18' of git://git.kernel.org/pub/scm/linux/kernel/git/jaegeuk/f2fs: (79 commits)
      f2fs: fix to clear FI_VOLATILE_FILE correctly
      f2fs: let sync node IO interrupt async one
      f2fs: don't change wbc->sync_mode
      f2fs: fix to update mtime correctly
      fs: f2fs: insert space around that ':' and ', '
      fs: f2fs: add missing blank lines after declarations
      fs: f2fs: changed variable type of offset "unsigned" to "loff_t"
      f2fs: clean up symbol namespace
      f2fs: make set_de_type() static
      f2fs: make __f2fs_write_data_pages() static
      f2fs: fix to avoid accessing cross the boundary
      f2fs: fix to let caller retry allocating block address
      disable loading f2fs module on PAGE_SIZE > 4KB
      f2fs: fix error path of move_data_page
      f2fs: don't drop dentry pages after fs shutdown
      f2fs: fix to avoid race during access gc_thread pointer
      f2fs: clean up with clear_radix_tree_dirty_tag
      f2fs: fix to don't trigger writeback during recovery
      f2fs: clear discard_wake earlier
      f2fs: let discard thread wait a little longer if dev is busy
      ...

commit 12d28f79558f2e987c5f3817f89e1ccc0f11a7b5
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon May 7 17:22:08 2018 -0700

    fscrypt: add Speck128/256 support
    
    fscrypt currently only supports AES encryption.  However, many low-end
    mobile devices have older CPUs that don't have AES instructions, e.g.
    the ARMv8 Cryptography Extensions.  Currently, user data on such devices
    is not encrypted at rest because AES is too slow, even when the NEON
    bit-sliced implementation of AES is used.  Unfortunately, it is
    infeasible to encrypt these devices at all when AES is the only option.
    
    Therefore, this patch updates fscrypt to support the Speck block cipher,
    which was recently added to the crypto API.  The C implementation of
    Speck is not especially fast, but Speck can be implemented very
    efficiently with general-purpose vector instructions, e.g. ARM NEON.
    For example, on an ARMv7 processor, we measured the NEON-accelerated
    Speck128/256-XTS at 69 MB/s for both encryption and decryption, while
    AES-256-XTS with the NEON bit-sliced implementation was only 22 MB/s
    encryption and 19 MB/s decryption.
    
    There are multiple variants of Speck.  This patch only adds support for
    Speck128/256, which is the variant with a 128-bit block size and 256-bit
    key size -- the same as AES-256.  This is believed to be the most secure
    variant of Speck, and it's only about 6% slower than Speck128/128.
    Speck64/128 would be at least 20% faster because it has 20% rounds, and
    it can be even faster on CPUs that can't efficiently do the 64-bit
    operations needed for Speck128.  However, Speck64's 64-bit block size is
    not preferred security-wise.  ARM NEON also supports the needed 64-bit
    operations even on 32-bit CPUs, resulting in Speck128 being fast enough
    for our targeted use cases so far.
    
    The chosen modes of operation are XTS for contents and CTS-CBC for
    filenames.  These are the same modes of operation that fscrypt defaults
    to for AES.  Note that as with the other fscrypt modes, Speck will not
    be used unless userspace chooses to use it.  Nor are any of the existing
    modes (which are all AES-based) being removed, of course.
    
    We intentionally don't make CONFIG_FS_ENCRYPTION select
    CONFIG_CRYPTO_SPECK, so people will have to enable Speck support
    themselves if they need it.  This is because we shouldn't bloat the
    FS_ENCRYPTION dependencies with every new cipher, especially ones that
    aren't recommended for most users.  Moreover, CRYPTO_SPECK is just the
    generic implementation, which won't be fast enough for many users; in
    practice, they'll need to enable CRYPTO_SPECK_NEON to get acceptable
    performance.
    
    More details about our choice of Speck can be found in our patches that
    added Speck to the crypto API, and the follow-on discussion threads.
    We're planning a publication that explains the choice in more detail.
    But briefly, we can't use ChaCha20 as we previously proposed, since it
    would be insecure to use a stream cipher in this context, with potential
    IV reuse during writes on f2fs and/or on wear-leveling flash storage.
    
    We also evaluated many other lightweight and/or ARX-based block ciphers
    such as Chaskey-LTS, RC5, LEA, CHAM, Threefish, RC6, NOEKEON, SPARX, and
    XTEA.  However, all had disadvantages vs. Speck, such as insufficient
    performance with NEON, much less published cryptanalysis, or an
    insufficient security level.  Various design choices in Speck make it
    perform better with NEON than competing ciphers while still having a
    security margin similar to AES, and in the case of Speck128 also the
    same available security levels.  Unfortunately, Speck does have some
    political baggage attached -- it's an NSA designed cipher, and was
    rejected from an ISO standard (though for context, as far as I know none
    of the above-mentioned alternatives are ISO standards either).
    Nevertheless, we believe it is a good solution to the problem from a
    technical perspective.
    
    Certain algorithms constructed from ChaCha or the ChaCha permutation,
    such as MEM (Masked Even-Mansour) or HPolyC, may also meet our
    performance requirements.  However, these are new constructions that
    need more time to receive the cryptographic review and acceptance needed
    to be confident in their security.  HPolyC hasn't been published yet,
    and we are concerned that MEM makes stronger assumptions about the
    underlying permutation than the ChaCha stream cipher does.  In contrast,
    the XTS mode of operation is relatively well accepted, and Speck has
    over 70 cryptanalysis papers.  Of course, these ChaCha-based algorithms
    can still be added later if they become ready.
    
    The best known attack on Speck128/256 is a differential cryptanalysis
    attack on 25 of 34 rounds with 2^253 time complexity and 2^125 chosen
    plaintexts, i.e. only marginally faster than brute force.  There is no
    known attack on the full 34 rounds.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 09d6c72635b6..37562394c5de 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -83,6 +83,10 @@ static inline bool fscrypt_valid_enc_modes(u32 contents_mode,
 	    filenames_mode == FS_ENCRYPTION_MODE_AES_256_CTS)
 		return true;
 
+	if (contents_mode == FS_ENCRYPTION_MODE_SPECK128_256_XTS &&
+	    filenames_mode == FS_ENCRYPTION_MODE_SPECK128_256_CTS)
+		return true;
+
 	return false;
 }
 

commit 544d08fde258b4da72b6cfbe2d7172c86ce9860d
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Apr 30 15:51:47 2018 -0700

    fscrypt: use a common logging function
    
    Use a common function for fscrypt warning and error messages so that all
    the messages are consistently ratelimited, include the "fscrypt:"
    prefix, and include the filesystem name if applicable.
    
    Also fix up a few of the log messages to be more descriptive.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 8358610d6558..09d6c72635b6 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -100,6 +100,14 @@ extern struct page *fscrypt_alloc_bounce_page(struct fscrypt_ctx *ctx,
 					      gfp_t gfp_flags);
 extern const struct dentry_operations fscrypt_d_ops;
 
+extern void __printf(3, 4) __cold
+fscrypt_msg(struct super_block *sb, const char *level, const char *fmt, ...);
+
+#define fscrypt_warn(sb, fmt, ...)		\
+	fscrypt_msg(sb, KERN_WARNING, fmt, ##__VA_ARGS__)
+#define fscrypt_err(sb, fmt, ...)		\
+	fscrypt_msg(sb, KERN_ERR, fmt, ##__VA_ARGS__)
+
 /* fname.c */
 extern int fname_encrypt(struct inode *inode, const struct qstr *iname,
 			 u8 *out, unsigned int olen);

commit 11b8818ec09d577567f59fc1b32cfa56c756fe89
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Apr 30 15:51:46 2018 -0700

    fscrypt: remove internal key size constants
    
    With one exception, the internal key size constants such as
    FS_AES_256_XTS_KEY_SIZE are only used for the 'available_modes' array,
    where they really only serve to obfuscate what the values are.  Also
    some of the constants are unused, and the key sizes tend to be in the
    names of the algorithms anyway.  In the past these values were also
    misused, e.g. we used to have FS_AES_256_XTS_KEY_SIZE in places that
    technically should have been FS_MAX_KEY_SIZE.
    
    The exception is that FS_AES_128_ECB_KEY_SIZE is used for key
    derivation.  But it's more appropriate to use
    FS_KEY_DERIVATION_NONCE_SIZE for that instead.
    
    Thus, just put the sizes directly in the 'available_modes' array.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index fb96e493167b..8358610d6558 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -18,15 +18,7 @@
 
 /* Encryption parameters */
 #define FS_IV_SIZE			16
-#define FS_AES_128_ECB_KEY_SIZE		16
-#define FS_AES_128_CBC_KEY_SIZE		16
-#define FS_AES_128_CTS_KEY_SIZE		16
-#define FS_AES_256_GCM_KEY_SIZE		32
-#define FS_AES_256_CBC_KEY_SIZE		32
-#define FS_AES_256_CTS_KEY_SIZE		32
-#define FS_AES_256_XTS_KEY_SIZE		64
-
-#define FS_KEY_DERIVATION_NONCE_SIZE		16
+#define FS_KEY_DERIVATION_NONCE_SIZE	16
 
 /**
  * Encryption context for inode

commit 54222025f2fe8055fa88c39b5d9f68cbd76b1be0
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Apr 30 15:51:36 2018 -0700

    fscrypt: clean up after fscrypt_prepare_lookup() conversions
    
    Now that all filesystems have been converted to use
    fscrypt_prepare_lookup(), we can remove the fscrypt_set_d_op() and
    fscrypt_set_encrypted_dentry() functions as well as un-export
    fscrypt_d_ops.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index ad6722bae8b7..fb96e493167b 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -106,6 +106,7 @@ extern int fscrypt_do_page_crypto(const struct inode *inode,
 				  gfp_t gfp_flags);
 extern struct page *fscrypt_alloc_bounce_page(struct fscrypt_ctx *ctx,
 					      gfp_t gfp_flags);
+extern const struct dentry_operations fscrypt_d_ops;
 
 /* fname.c */
 extern int fname_encrypt(struct inode *inode, const struct qstr *iname,

commit 0cb8dae4a0df2a977847c2dc6766a7783ce50f9d
Author: Eric Biggers <ebiggers@google.com>
Date:   Wed Apr 18 11:09:47 2018 -0700

    fscrypt: allow synchronous bio decryption
    
    Currently, fscrypt provides fscrypt_decrypt_bio_pages() which decrypts a
    bio's pages asynchronously, then unlocks them afterwards.  But, this
    assumes that decryption is the last "postprocessing step" for the bio,
    so it's incompatible with additional postprocessing steps such as
    authenticity verification after decryption.
    
    Therefore, rename the existing fscrypt_decrypt_bio_pages() to
    fscrypt_enqueue_decrypt_bio().  Then, add fscrypt_decrypt_bio() which
    decrypts the pages in the bio synchronously without unlocking the pages,
    nor setting them Uptodate; and add fscrypt_enqueue_decrypt_work(), which
    enqueues work on the fscrypt_read_workqueue.  The new functions will be
    used by filesystems that support both fscrypt and fs-verity.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index ad6722bae8b7..4012558f6115 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -97,7 +97,6 @@ static inline bool fscrypt_valid_enc_modes(u32 contents_mode,
 /* crypto.c */
 extern struct kmem_cache *fscrypt_info_cachep;
 extern int fscrypt_initialize(unsigned int cop_flags);
-extern struct workqueue_struct *fscrypt_read_workqueue;
 extern int fscrypt_do_page_crypto(const struct inode *inode,
 				  fscrypt_direction_t rw, u64 lblk_num,
 				  struct page *src_page,

commit b9db0b4a68d373897119d1e0a3beebe1c1a23936
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Jan 11 23:30:08 2018 -0500

    fscrypt: fix up fscrypt_fname_encrypted_size() for internal use
    
    Filesystems don't need fscrypt_fname_encrypted_size() anymore, so
    unexport it and move it to fscrypt_private.h.
    
    We also never calculate the encrypted size of a filename without having
    the fscrypt_info present since it is needed to know the amount of
    NUL-padding which is determined by the encryption policy, and also we
    will always truncate the NUL-padding to the maximum filename length.
    Therefore, also make fscrypt_fname_encrypted_size() assume that the
    fscrypt_info is present, and make it truncate the returned length to the
    specified max_len.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 053917587200..ad6722bae8b7 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -110,6 +110,9 @@ extern struct page *fscrypt_alloc_bounce_page(struct fscrypt_ctx *ctx,
 /* fname.c */
 extern int fname_encrypt(struct inode *inode, const struct qstr *iname,
 			 u8 *out, unsigned int olen);
+extern bool fscrypt_fname_encrypted_size(const struct inode *inode,
+					 u32 orig_len, u32 max_len,
+					 u32 *encrypted_len_ret);
 
 /* keyinfo.c */
 extern void __exit fscrypt_essiv_cleanup(void);

commit 50c961de59ec841c1185c18457e6dab227f3bbf3
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Jan 11 23:30:08 2018 -0500

    fscrypt: calculate NUL-padding length in one place only
    
    Currently, when encrypting a filename (either a real filename or a
    symlink target) we calculate the amount of NUL-padding twice: once
    before encryption and once during encryption in fname_encrypt().  It is
    needed before encryption to allocate the needed buffer size as well as
    calculate the size the symlink target will take up on-disk before
    creating the symlink inode.  Calculating the size during encryption as
    well is redundant.
    
    Remove this redundancy by always calculating the exact size beforehand,
    and making fname_encrypt() just add as much NUL padding as is needed to
    fill the output buffer.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index cec9ce309f41..053917587200 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -108,8 +108,8 @@ extern struct page *fscrypt_alloc_bounce_page(struct fscrypt_ctx *ctx,
 					      gfp_t gfp_flags);
 
 /* fname.c */
-extern int fname_encrypt(struct inode *inode,
-			 const struct qstr *iname, struct fscrypt_str *oname);
+extern int fname_encrypt(struct inode *inode, const struct qstr *iname,
+			 u8 *out, unsigned int olen);
 
 /* keyinfo.c */
 extern void __exit fscrypt_essiv_cleanup(void);

commit 0eaab5b10621e84868df911dad43d330fa1b9bc8
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Jan 11 23:30:08 2018 -0500

    fscrypt: move fscrypt_symlink_data to fscrypt_private.h
    
    Now that all filesystems have been converted to use the symlink helper
    functions, they no longer need the declaration of 'struct
    fscrypt_symlink_data'.  Move it from fscrypt.h to fscrypt_private.h.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 6995bca5006b..cec9ce309f41 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -50,6 +50,15 @@ struct fscrypt_context {
 
 #define FS_ENCRYPTION_CONTEXT_FORMAT_V1		1
 
+/**
+ * For encrypted symlinks, the ciphertext length is stored at the beginning
+ * of the string in little-endian format.
+ */
+struct fscrypt_symlink_data {
+	__le16 len;
+	char encrypted_path[1];
+} __packed;
+
 /*
  * A pointer to this structure is stored in the file system's in-core
  * representation of an inode.

commit 76e81d6d50481144824237e6843122824b0a55c0
Author: Eric Biggers <ebiggers@google.com>
Date:   Fri Jan 5 10:45:01 2018 -0800

    fscrypt: new helper functions for ->symlink()
    
    Currently, filesystems supporting fscrypt need to implement some tricky
    logic when creating encrypted symlinks, including handling a peculiar
    on-disk format (struct fscrypt_symlink_data) and correctly calculating
    the size of the encrypted symlink.  Introduce helper functions to make
    things a bit easier:
    
    - fscrypt_prepare_symlink() computes and validates the size the symlink
      target will require on-disk.
    - fscrypt_encrypt_symlink() creates the encrypted target if needed.
    
    The new helpers actually fix some subtle bugs.  First, when checking
    whether the symlink target was too long, filesystems didn't account for
    the fact that the NUL padding is meant to be truncated if it would cause
    the maximum length to be exceeded, as is done for filenames in
    directories.  Consequently users would receive ENAMETOOLONG when
    creating symlinks close to what is supposed to be the maximum length.
    For example, with EXT4 with a 4K block size, the maximum symlink target
    length in an encrypted directory is supposed to be 4093 bytes (in
    comparison to 4095 in an unencrypted directory), but in
    FS_POLICY_FLAGS_PAD_32-mode only up to 4064 bytes were accepted.
    
    Second, symlink targets of "." and ".." were not being encrypted, even
    though they should be, as these names are special in *directory entries*
    but not in symlink targets.  Fortunately, we can fix this simply by
    starting to encrypt them, as old kernels already accept them in
    encrypted form.
    
    Third, the output string length the filesystems were providing when
    doing the actual encryption was incorrect, as it was forgotten to
    exclude 'sizeof(struct fscrypt_symlink_data)'.  Fortunately though, this
    bug didn't make a difference.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 2b848e7c92f0..6995bca5006b 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -98,6 +98,10 @@ extern int fscrypt_do_page_crypto(const struct inode *inode,
 extern struct page *fscrypt_alloc_bounce_page(struct fscrypt_ctx *ctx,
 					      gfp_t gfp_flags);
 
+/* fname.c */
+extern int fname_encrypt(struct inode *inode,
+			 const struct qstr *iname, struct fscrypt_str *oname);
+
 /* keyinfo.c */
 extern void __exit fscrypt_essiv_cleanup(void);
 

commit bb8179e5a8509876415c0eac6f6ba8a130b3cb47
Author: Eric Biggers <ebiggers@google.com>
Date:   Fri Jan 5 10:44:58 2018 -0800

    fscrypt: move fscrypt_valid_enc_modes() to fscrypt_private.h
    
    The encryption modes are validated by fs/crypto/, not by individual
    filesystems.  Therefore, move fscrypt_valid_enc_modes() from fscrypt.h
    to fscrypt_private.h.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 823c43a00bf7..2b848e7c92f0 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -71,6 +71,20 @@ typedef enum {
 #define FS_CTX_REQUIRES_FREE_ENCRYPT_FL		0x00000001
 #define FS_CTX_HAS_BOUNCE_BUFFER_FL		0x00000002
 
+static inline bool fscrypt_valid_enc_modes(u32 contents_mode,
+					   u32 filenames_mode)
+{
+	if (contents_mode == FS_ENCRYPTION_MODE_AES_128_CBC &&
+	    filenames_mode == FS_ENCRYPTION_MODE_AES_128_CTS)
+		return true;
+
+	if (contents_mode == FS_ENCRYPTION_MODE_AES_256_XTS &&
+	    filenames_mode == FS_ENCRYPTION_MODE_AES_256_CTS)
+		return true;
+
+	return false;
+}
+
 /* crypto.c */
 extern struct kmem_cache *fscrypt_info_cachep;
 extern int fscrypt_initialize(unsigned int cop_flags);

commit e4de782a0960b9620c084881f12fb5e73ebff82b
Author: Eric Biggers <ebiggers@google.com>
Date:   Fri Jan 5 10:44:54 2018 -0800

    fscrypt: move fscrypt_info_cachep declaration to fscrypt_private.h
    
    The fscrypt_info kmem_cache is internal to fscrypt; filesystems don't
    need to access it.  So move its declaration into fscrypt_private.h.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index c0b4f5597e1a..823c43a00bf7 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -72,6 +72,7 @@ typedef enum {
 #define FS_CTX_HAS_BOUNCE_BUFFER_FL		0x00000002
 
 /* crypto.c */
+extern struct kmem_cache *fscrypt_info_cachep;
 extern int fscrypt_initialize(unsigned int cop_flags);
 extern struct workqueue_struct *fscrypt_read_workqueue;
 extern int fscrypt_do_page_crypto(const struct inode *inode,

commit 32190f0afbf4f1c0a9142e5a886a078ee0b794fd
Merge: 37dc79565c4b a0b3bc855374
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 14 11:35:15 2017 -0800

    Merge tag 'fscrypt-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/fscrypt
    
    Pull fscrypt updates from Ted Ts'o:
     "Lots of cleanups, mostly courtesy by Eric Biggers"
    
    * tag 'fscrypt-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/fscrypt:
      fscrypt: lock mutex before checking for bounce page pool
      fscrypt: add a documentation file for filesystem-level encryption
      ext4: switch to fscrypt_prepare_setattr()
      ext4: switch to fscrypt_prepare_lookup()
      ext4: switch to fscrypt_prepare_rename()
      ext4: switch to fscrypt_prepare_link()
      ext4: switch to fscrypt_file_open()
      fscrypt: new helper function - fscrypt_prepare_setattr()
      fscrypt: new helper function - fscrypt_prepare_lookup()
      fscrypt: new helper function - fscrypt_prepare_rename()
      fscrypt: new helper function - fscrypt_prepare_link()
      fscrypt: new helper function - fscrypt_file_open()
      fscrypt: new helper function - fscrypt_require_key()
      fscrypt: remove unneeded empty fscrypt_operations structs
      fscrypt: remove ->is_encrypted()
      fscrypt: switch from ->is_encrypted() to IS_ENCRYPTED()
      fs, fscrypt: add an S_ENCRYPTED inode flag
      fscrypt: clean up include file mess

commit 37dc79565c4b7e735f190eaa6ed5bb6eb3d3968a
Merge: 894025f24bd0 1d9ddde12e3c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 14 10:52:09 2017 -0800

    Merge branch 'linus' of git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6
    
    Pull crypto updates from Herbert Xu:
     "Here is the crypto update for 4.15:
    
      API:
    
       - Disambiguate EBUSY when queueing crypto request by adding ENOSPC.
         This change touches code outside the crypto API.
       - Reset settings when empty string is written to rng_current.
    
      Algorithms:
    
       - Add OSCCA SM3 secure hash.
    
      Drivers:
    
       - Remove old mv_cesa driver (replaced by marvell/cesa).
       - Enable rfc3686/ecb/cfb/ofb AES in crypto4xx.
       - Add ccm/gcm AES in crypto4xx.
       - Add support for BCM7278 in iproc-rng200.
       - Add hash support on Exynos in s5p-sss.
       - Fix fallback-induced error in vmx.
       - Fix output IV in atmel-aes.
       - Fix empty GCM hash in mediatek.
    
      Others:
    
       - Fix DoS potential in lib/mpi.
       - Fix potential out-of-order issues with padata"
    
    * 'linus' of git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6: (162 commits)
      lib/mpi: call cond_resched() from mpi_powm() loop
      crypto: stm32/hash - Fix return issue on update
      crypto: dh - Remove pointless checks for NULL 'p' and 'g'
      crypto: qat - Clean up error handling in qat_dh_set_secret()
      crypto: dh - Don't permit 'key' or 'g' size longer than 'p'
      crypto: dh - Don't permit 'p' to be 0
      crypto: dh - Fix double free of ctx->p
      hwrng: iproc-rng200 - Add support for BCM7278
      dt-bindings: rng: Document BCM7278 RNG200 compatible
      crypto: chcr - Replace _manual_ swap with swap macro
      crypto: marvell - Add a NULL entry at the end of mv_cesa_plat_id_table[]
      hwrng: virtio - Virtio RNG devices need to be re-registered after suspend/resume
      crypto: atmel - remove empty functions
      crypto: ecdh - remove empty exit()
      MAINTAINERS: update maintainer for qat
      crypto: caam - remove unused param of ctx_map_to_sec4_sg()
      crypto: caam - remove unneeded edesc zeroization
      crypto: atmel-aes - Reset the controller before each use
      crypto: atmel-aes - properly set IV after {en,de}crypt
      hwrng: core - Reset user selected rng by writing "" to rng_current
      ...

commit d0082e1a7c8dfee55b06e442f137097230a1102a
Author: Gilad Ben-Yossef <gilad@benyossef.com>
Date:   Wed Oct 18 08:00:44 2017 +0100

    fscrypt: move to generic async completion
    
    fscrypt starts several async. crypto ops and waiting for them to
    complete. Move it over to generic code doing the same.
    
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index a1d5021c31ef..c0f1881f7c3d 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -69,16 +69,6 @@ typedef enum {
 #define FS_CTX_REQUIRES_FREE_ENCRYPT_FL		0x00000001
 #define FS_CTX_HAS_BOUNCE_BUFFER_FL		0x00000002
 
-struct fscrypt_completion_result {
-	struct completion completion;
-	int res;
-};
-
-#define DECLARE_FS_COMPLETION_RESULT(ecr) \
-	struct fscrypt_completion_result ecr = { \
-		COMPLETION_INITIALIZER_ONSTACK((ecr).completion), 0 }
-
-
 /* crypto.c */
 extern int fscrypt_initialize(unsigned int cop_flags);
 extern struct workqueue_struct *fscrypt_read_workqueue;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index a1d5021c31ef..092e9dad1414 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * fscrypt_private.h
  *

commit 734f0d241d2b4e47383bd0d16e21e06f6cb8d2c3
Author: Dave Chinner <dchinner@redhat.com>
Date:   Mon Oct 9 12:15:34 2017 -0700

    fscrypt: clean up include file mess
    
    Filesystems have to include different header files based on whether they
    are compiled with encryption support or not. That's nasty and messy.
    
    Instead, rationalise the headers so we have a single include fscrypt.h
    and let it decide what internal implementation to include based on the
    __FS_HAS_ENCRYPTION define.  Filesystems set __FS_HAS_ENCRYPTION to 1
    before including linux/fscrypt.h if they are built with encryption
    support.  Otherwise, they must set __FS_HAS_ENCRYPTION to 0.
    
    Add guards to prevent fscrypt_supp.h and fscrypt_notsupp.h from being
    directly included by filesystems.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    [EB: use 1 and 0 rather than defined/undefined]
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index a1d5021c31ef..a180981ee6d7 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -11,7 +11,8 @@
 #ifndef _FSCRYPT_PRIVATE_H
 #define _FSCRYPT_PRIVATE_H
 
-#include <linux/fscrypt_supp.h>
+#define __FS_HAS_ENCRYPTION 1
+#include <linux/fscrypt.h>
 #include <crypto/hash.h>
 
 /* Encryption parameters */

commit b7e7cf7a66a27e62c5f873a0068cee34094bf5d7
Author: Daniel Walter <dwalter@sigma-star.at>
Date:   Mon Jun 19 09:27:58 2017 +0200

    fscrypt: add support for AES-128-CBC
    
    fscrypt provides facilities to use different encryption algorithms which
    are selectable by userspace when setting the encryption policy. Currently,
    only AES-256-XTS for file contents and AES-256-CBC-CTS for file names are
    implemented. This is a clear case of kernel offers the mechanism and
    userspace selects a policy. Similar to what dm-crypt and ecryptfs have.
    
    This patch adds support for using AES-128-CBC for file contents and
    AES-128-CBC-CTS for file name encryption. To mitigate watermarking
    attacks, IVs are generated using the ESSIV algorithm. While AES-CBC is
    actually slightly less secure than AES-XTS from a security point of view,
    there is more widespread hardware support. Using AES-CBC gives us the
    acceptable performance while still providing a moderate level of security
    for persistent storage.
    
    Especially low-powered embedded devices with crypto accelerators such as
    CAAM or CESA often only support AES-CBC. Since using AES-CBC over AES-XTS
    is basically thought of a last resort, we use AES-128-CBC over AES-256-CBC
    since it has less encryption rounds and yields noticeable better
    performance starting from a file size of just a few kB.
    
    Signed-off-by: Daniel Walter <dwalter@sigma-star.at>
    [david@sigma-star.at: addressed review comments]
    Signed-off-by: David Gstir <david@sigma-star.at>
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 1e1f8a361b75..a1d5021c31ef 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -12,10 +12,13 @@
 #define _FSCRYPT_PRIVATE_H
 
 #include <linux/fscrypt_supp.h>
+#include <crypto/hash.h>
 
 /* Encryption parameters */
-#define FS_XTS_TWEAK_SIZE		16
+#define FS_IV_SIZE			16
 #define FS_AES_128_ECB_KEY_SIZE		16
+#define FS_AES_128_CBC_KEY_SIZE		16
+#define FS_AES_128_CTS_KEY_SIZE		16
 #define FS_AES_256_GCM_KEY_SIZE		32
 #define FS_AES_256_CBC_KEY_SIZE		32
 #define FS_AES_256_CTS_KEY_SIZE		32
@@ -54,6 +57,7 @@ struct fscrypt_info {
 	u8 ci_filename_mode;
 	u8 ci_flags;
 	struct crypto_skcipher *ci_ctfm;
+	struct crypto_cipher *ci_essiv_tfm;
 	u8 ci_master_key[FS_KEY_DESCRIPTOR_SIZE];
 };
 
@@ -87,4 +91,7 @@ extern int fscrypt_do_page_crypto(const struct inode *inode,
 extern struct page *fscrypt_alloc_bounce_page(struct fscrypt_ctx *ctx,
 					      gfp_t gfp_flags);
 
+/* keyinfo.c */
+extern void __exit fscrypt_essiv_cleanup(void);
+
 #endif /* _FSCRYPT_PRIVATE_H */

commit 17159420a6c18bb3515ff85598b5ccf1a572763d
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Apr 24 10:00:10 2017 -0700

    fscrypt: introduce helper function for filename matching
    
    Introduce a helper function fscrypt_match_name() which tests whether a
    fscrypt_name matches a directory entry.  Also clean up the magic numbers
    and document things properly.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index e08ca6d1ca0f..1e1f8a361b75 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -13,8 +13,6 @@
 
 #include <linux/fscrypt_supp.h>
 
-#define FS_FNAME_CRYPTO_DIGEST_SIZE	32
-
 /* Encryption parameters */
 #define FS_XTS_TWEAK_SIZE		16
 #define FS_AES_128_ECB_KEY_SIZE		16

commit 9c8268def6127a9d9888b822a74becb80dfeab6f
Author: Joe Richey <joerichey@google.com>
Date:   Thu Apr 6 16:14:05 2017 -0700

    fscrypt: Move key structure and constants to uapi
    
    This commit exposes the necessary constants and structures for a
    userspace program to pass filesystem encryption keys into the keyring.
    The fscrypt_key structure was already part of the kernel ABI, this
    change just makes it so programs no longer have to redeclare these
    structures (like e4crypt in e2fsprogs currently does).
    
    Note that we do not expose the other FS_*_KEY_SIZE constants as they are
    not necessary. Only XTS is supported for contents_encryption_mode, so
    currently FS_MAX_KEY_SIZE bytes of key material must always be passed to
    the kernel.
    
    This commit also removes __packed from fscrypt_key as it does not
    contain any implicit padding and does not refer to an on-disk structure.
    
    Signed-off-by: Joe Richey <joerichey@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index e39696e64494..e08ca6d1ca0f 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -22,10 +22,6 @@
 #define FS_AES_256_CBC_KEY_SIZE		32
 #define FS_AES_256_CTS_KEY_SIZE		32
 #define FS_AES_256_XTS_KEY_SIZE		64
-#define FS_MAX_KEY_SIZE			64
-
-#define FS_KEY_DESC_PREFIX		"fscrypt:"
-#define FS_KEY_DESC_PREFIX_SIZE		8
 
 #define FS_KEY_DERIVATION_NONCE_SIZE		16
 
@@ -51,13 +47,6 @@ struct fscrypt_context {
 
 #define FS_ENCRYPTION_CONTEXT_FORMAT_V1		1
 
-/* This is passed in from userspace into the kernel keyring */
-struct fscrypt_key {
-	u32 mode;
-	u8 raw[FS_MAX_KEY_SIZE];
-	u32 size;
-} __packed;
-
 /*
  * A pointer to this structure is stored in the file system's in-core
  * representation of an inode.

commit 1b53cf9815bb4744958d41f3795d5d5a1d365e2d
Author: Eric Biggers <ebiggers@google.com>
Date:   Tue Feb 21 15:07:11 2017 -0800

    fscrypt: remove broken support for detecting keyring key revocation
    
    Filesystem encryption ostensibly supported revoking a keyring key that
    had been used to "unlock" encrypted files, causing those files to become
    "locked" again.  This was, however, buggy for several reasons, the most
    severe of which was that when key revocation happened to be detected for
    an inode, its fscrypt_info was immediately freed, even while other
    threads could be using it for encryption or decryption concurrently.
    This could be exploited to crash the kernel or worse.
    
    This patch fixes the use-after-free by removing the code which detects
    the keyring key having been revoked, invalidated, or expired.  Instead,
    an encrypted inode that is "unlocked" now simply remains unlocked until
    it is evicted from memory.  Note that this is no worse than the case for
    block device-level encryption, e.g. dm-crypt, and it still remains
    possible for a privileged user to evict unused pages, inodes, and
    dentries by running 'sync; echo 3 > /proc/sys/vm/drop_caches', or by
    simply unmounting the filesystem.  In fact, one of those actions was
    already needed anyway for key revocation to work even somewhat sanely.
    This change is not expected to break any applications.
    
    In the future I'd like to implement a real API for fscrypt key
    revocation that interacts sanely with ongoing filesystem operations ---
    waiting for existing operations to complete and blocking new operations,
    and invalidating and sanitizing key material and plaintext from the VFS
    caches.  But this is a hard problem, and for now this bug must be fixed.
    
    This bug affected almost all versions of ext4, f2fs, and ubifs
    encryption, and it was potentially reachable in any kernel configured
    with encryption support (CONFIG_EXT4_ENCRYPTION=y,
    CONFIG_EXT4_FS_ENCRYPTION=y, CONFIG_F2FS_FS_ENCRYPTION=y, or
    CONFIG_UBIFS_FS_ENCRYPTION=y).  Note that older kernels did not use the
    shared fs/crypto/ code, but due to the potential security implications
    of this bug, it may still be worthwhile to backport this fix to them.
    
    Fixes: b7236e21d55f ("ext4 crypto: reorganize how we store keys in the inode")
    Cc: stable@vger.kernel.org # v4.2+
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Acked-by: Michael Halcrow <mhalcrow@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index fdbb8af32eaf..e39696e64494 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -67,7 +67,6 @@ struct fscrypt_info {
 	u8 ci_filename_mode;
 	u8 ci_flags;
 	struct crypto_skcipher *ci_ctfm;
-	struct key *ci_keyring_key;
 	u8 ci_master_key[FS_KEY_DESCRIPTOR_SIZE];
 };
 
@@ -101,7 +100,4 @@ extern int fscrypt_do_page_crypto(const struct inode *inode,
 extern struct page *fscrypt_alloc_bounce_page(struct fscrypt_ctx *ctx,
 					      gfp_t gfp_flags);
 
-/* keyinfo.c */
-extern int fscrypt_get_crypt_info(struct inode *);
-
 #endif /* _FSCRYPT_PRIVATE_H */

commit b14c8e6afd873cae97060272efaac376efec77a4
Author: Richard Weinberger <richard@nod.at>
Date:   Wed Feb 1 21:32:09 2017 +0100

    fscrypt: properly declare on-stack completion
    
    When a completion is declared on-stack we have to use
    COMPLETION_INITIALIZER_ONSTACK().
    
    Fixes: 0b81d07790726 ("fs crypto: move per-file encryption from f2fs
    tree to fs/crypto")
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index e8a229e1d45d..fdbb8af32eaf 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -86,7 +86,7 @@ struct fscrypt_completion_result {
 
 #define DECLARE_FS_COMPLETION_RESULT(ecr) \
 	struct fscrypt_completion_result ecr = { \
-		COMPLETION_INITIALIZER((ecr).completion), 0 }
+		COMPLETION_INITIALIZER_ONSTACK((ecr).completion), 0 }
 
 
 /* crypto.c */

commit 46f47e48008b63f5fd3a3bad8b79ba1a89fb625f
Author: Eric Biggers <ebiggers@google.com>
Date:   Tue Jan 24 10:58:06 2017 -0800

    fscrypt: split supp and notsupp declarations into their own headers
    
    Previously, each filesystem configured without encryption support would
    define all the public fscrypt functions to their notsupp_* stubs.  This
    list of #defines had to be updated in every filesystem whenever a change
    was made to the public fscrypt functions.  To make things more
    maintainable now that we have three filesystems using fscrypt, split the
    old header fscrypto.h into several new headers.  fscrypt_supp.h contains
    the real declarations and is included by filesystems when configured
    with encryption support, whereas fscrypt_notsupp.h contains the inline
    stubs and is included by filesystems when configured without encryption
    support.  fscrypt_common.h contains common declarations needed by both.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 7bff7b4c7498..e8a229e1d45d 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -11,7 +11,7 @@
 #ifndef _FSCRYPT_PRIVATE_H
 #define _FSCRYPT_PRIVATE_H
 
-#include <linux/fscrypto.h>
+#include <linux/fscrypt_supp.h>
 
 #define FS_FNAME_CRYPTO_DIGEST_SIZE	32
 

commit 58ae74683ae2c07cd717a91799edb50231061938
Author: Richard Weinberger <richard@nod.at>
Date:   Mon Dec 19 12:25:32 2016 +0100

    fscrypt: factor out bio specific functions
    
    That way we can get rid of the direct dependency on CONFIG_BLOCK.
    
    Fixes: d475a507457b ("ubifs: Add skeleton for fscrypto")
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Reported-by: Randy Dunlap <rdunlap@infradead.org>
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: David Gstir <david@sigma-star.at>
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index aeab032d7d35..7bff7b4c7498 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -71,6 +71,11 @@ struct fscrypt_info {
 	u8 ci_master_key[FS_KEY_DESCRIPTOR_SIZE];
 };
 
+typedef enum {
+	FS_DECRYPT = 0,
+	FS_ENCRYPT,
+} fscrypt_direction_t;
+
 #define FS_CTX_REQUIRES_FREE_ENCRYPT_FL		0x00000001
 #define FS_CTX_HAS_BOUNCE_BUFFER_FL		0x00000002
 
@@ -85,7 +90,16 @@ struct fscrypt_completion_result {
 
 
 /* crypto.c */
-int fscrypt_initialize(unsigned int cop_flags);
+extern int fscrypt_initialize(unsigned int cop_flags);
+extern struct workqueue_struct *fscrypt_read_workqueue;
+extern int fscrypt_do_page_crypto(const struct inode *inode,
+				  fscrypt_direction_t rw, u64 lblk_num,
+				  struct page *src_page,
+				  struct page *dest_page,
+				  unsigned int len, unsigned int offs,
+				  gfp_t gfp_flags);
+extern struct page *fscrypt_alloc_bounce_page(struct fscrypt_ctx *ctx,
+					      gfp_t gfp_flags);
 
 /* keyinfo.c */
 extern int fscrypt_get_crypt_info(struct inode *);

commit 6a34e4d2be07255cc59e6ccaf820669cfd7f815c
Author: David Gstir <david@sigma-star.at>
Date:   Tue Dec 6 23:53:58 2016 +0100

    fscrypt: Rename FS_WRITE_PATH_FL to FS_CTX_HAS_BOUNCE_BUFFER_FL
    
    ... to better explain its purpose after introducing in-place encryption
    without bounce buffer.
    
    Signed-off-by: David Gstir <david@sigma-star.at>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 7ba10cd45a2e..aeab032d7d35 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -72,7 +72,7 @@ struct fscrypt_info {
 };
 
 #define FS_CTX_REQUIRES_FREE_ENCRYPT_FL		0x00000001
-#define FS_WRITE_PATH_FL			0x00000002
+#define FS_CTX_HAS_BOUNCE_BUFFER_FL		0x00000002
 
 struct fscrypt_completion_result {
 	struct completion completion;

commit f32d7ac20a5864483c1f96e4970daa083e18bfd1
Author: David Gstir <david@sigma-star.at>
Date:   Tue Dec 6 23:53:57 2016 +0100

    fscrypt: Delay bounce page pool allocation until needed
    
    Since fscrypt users can now indicated if fscrypt_encrypt_page() should
    use a bounce page, we can delay the bounce page pool initialization util
    it is really needed. That is until fscrypt_operations has no
    FS_CFLG_OWN_PAGES flag set.
    
    Signed-off-by: David Gstir <david@sigma-star.at>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index c98b2a7fb6d3..7ba10cd45a2e 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -85,7 +85,7 @@ struct fscrypt_completion_result {
 
 
 /* crypto.c */
-int fscrypt_initialize(void);
+int fscrypt_initialize(unsigned int cop_flags);
 
 /* keyinfo.c */
 extern int fscrypt_get_crypt_info(struct inode *);

commit cc4e0df038ddb73510c01712abf302b3f0130147
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Sat Nov 26 22:05:18 2016 -0500

    fscrypt: move non-public structures and constants to fscrypt_private.h
    
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Reviewed-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index bb92f0c0961b..c98b2a7fb6d3 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -13,6 +13,77 @@
 
 #include <linux/fscrypto.h>
 
+#define FS_FNAME_CRYPTO_DIGEST_SIZE	32
+
+/* Encryption parameters */
+#define FS_XTS_TWEAK_SIZE		16
+#define FS_AES_128_ECB_KEY_SIZE		16
+#define FS_AES_256_GCM_KEY_SIZE		32
+#define FS_AES_256_CBC_KEY_SIZE		32
+#define FS_AES_256_CTS_KEY_SIZE		32
+#define FS_AES_256_XTS_KEY_SIZE		64
+#define FS_MAX_KEY_SIZE			64
+
+#define FS_KEY_DESC_PREFIX		"fscrypt:"
+#define FS_KEY_DESC_PREFIX_SIZE		8
+
+#define FS_KEY_DERIVATION_NONCE_SIZE		16
+
+/**
+ * Encryption context for inode
+ *
+ * Protector format:
+ *  1 byte: Protector format (1 = this version)
+ *  1 byte: File contents encryption mode
+ *  1 byte: File names encryption mode
+ *  1 byte: Flags
+ *  8 bytes: Master Key descriptor
+ *  16 bytes: Encryption Key derivation nonce
+ */
+struct fscrypt_context {
+	u8 format;
+	u8 contents_encryption_mode;
+	u8 filenames_encryption_mode;
+	u8 flags;
+	u8 master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];
+	u8 nonce[FS_KEY_DERIVATION_NONCE_SIZE];
+} __packed;
+
+#define FS_ENCRYPTION_CONTEXT_FORMAT_V1		1
+
+/* This is passed in from userspace into the kernel keyring */
+struct fscrypt_key {
+	u32 mode;
+	u8 raw[FS_MAX_KEY_SIZE];
+	u32 size;
+} __packed;
+
+/*
+ * A pointer to this structure is stored in the file system's in-core
+ * representation of an inode.
+ */
+struct fscrypt_info {
+	u8 ci_data_mode;
+	u8 ci_filename_mode;
+	u8 ci_flags;
+	struct crypto_skcipher *ci_ctfm;
+	struct key *ci_keyring_key;
+	u8 ci_master_key[FS_KEY_DESCRIPTOR_SIZE];
+};
+
+#define FS_CTX_REQUIRES_FREE_ENCRYPT_FL		0x00000001
+#define FS_WRITE_PATH_FL			0x00000002
+
+struct fscrypt_completion_result {
+	struct completion completion;
+	int res;
+};
+
+#define DECLARE_FS_COMPLETION_RESULT(ecr) \
+	struct fscrypt_completion_result ecr = { \
+		COMPLETION_INITIALIZER((ecr).completion), 0 }
+
+
 /* crypto.c */
 int fscrypt_initialize(void);
 

commit b98701df349b7003efd52d9330acbb7be5a255c6
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Sat Nov 26 20:43:09 2016 -0500

    fscrypt: unexport fscrypt_initialize()
    
    The fscrypt_initalize() function isn't used outside fs/crypto, so
    there's no point making it be an exported symbol.
    
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Reviewed-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
index 7c31108728e4..bb92f0c0961b 100644
--- a/fs/crypto/fscrypt_private.h
+++ b/fs/crypto/fscrypt_private.h
@@ -13,6 +13,9 @@
 
 #include <linux/fscrypto.h>
 
+/* crypto.c */
+int fscrypt_initialize(void);
+
 /* keyinfo.c */
 extern int fscrypt_get_crypt_info(struct inode *);
 

commit 3325bea5b26ac67e2521383f10e5ea0156c9a4b6
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Sat Nov 26 20:32:46 2016 -0500

    fscrypt: rename get_crypt_info() to fscrypt_get_crypt_info()
    
    To avoid namespace collisions, rename get_crypt_info() to
    fscrypt_get_crypt_info().  The function is only used inside the
    fs/crypto directory, so declare it in the new header file,
    fscrypt_private.h.
    
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Reviewed-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h
new file mode 100644
index 000000000000..7c31108728e4
--- /dev/null
+++ b/fs/crypto/fscrypt_private.h
@@ -0,0 +1,19 @@
+/*
+ * fscrypt_private.h
+ *
+ * Copyright (C) 2015, Google, Inc.
+ *
+ * This contains encryption key functions.
+ *
+ * Written by Michael Halcrow, Ildar Muslukhov, and Uday Savagaonkar, 2015.
+ */
+
+#ifndef _FSCRYPT_PRIVATE_H
+#define _FSCRYPT_PRIVATE_H
+
+#include <linux/fscrypto.h>
+
+/* keyinfo.c */
+extern int fscrypt_get_crypt_info(struct inode *);
+
+#endif /* _FSCRYPT_PRIVATE_H */
