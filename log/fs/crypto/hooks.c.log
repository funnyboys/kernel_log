commit d2fe97545a1e2d01c0ca0105bdc59002a0d0b130
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon May 11 12:13:56 2020 -0700

    fscrypt: fix all kerneldoc warnings
    
    Fix all kerneldoc warnings in fs/crypto/ and include/linux/fscrypt.h.
    Most of these were due to missing documentation for function parameters.
    
    Detected with:
    
        scripts/kernel-doc -v -none fs/crypto/*.{c,h} include/linux/fscrypt.h
    
    This cleanup makes it possible to check new patches for kerneldoc
    warnings without having to filter out all the existing ones.
    
    For consistency, also adjust some function "brief descriptions" to
    include the parentheses and to wrap at 80 characters.  (The latter
    matches the checkpatch expectation.)
    
    Link: https://lore.kernel.org/r/20200511191358.53096-2-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index 5ef861742921..09fb8aa0f2e9 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -10,7 +10,7 @@
 #include "fscrypt_private.h"
 
 /**
- * fscrypt_file_open - prepare to open a possibly-encrypted regular file
+ * fscrypt_file_open() - prepare to open a possibly-encrypted regular file
  * @inode: the inode being opened
  * @filp: the struct file being set up
  *
@@ -262,7 +262,7 @@ int __fscrypt_encrypt_symlink(struct inode *inode, const char *target,
 EXPORT_SYMBOL_GPL(__fscrypt_encrypt_symlink);
 
 /**
- * fscrypt_get_symlink - get the target of an encrypted symlink
+ * fscrypt_get_symlink() - get the target of an encrypted symlink
  * @inode: the symlink inode
  * @caddr: the on-disk contents of the symlink
  * @max_size: size of @caddr buffer

commit aa408f835d025a839033988d3f5a2866314414ef
Author: Daniel Rosenberg <drosen@google.com>
Date:   Mon Jan 20 14:31:57 2020 -0800

    fscrypt: derive dirhash key for casefolded directories
    
    When we allow indexed directories to use both encryption and
    casefolding, for the dirhash we can't just hash the ciphertext filenames
    that are stored on-disk (as is done currently) because the dirhash must
    be case insensitive, but the stored names are case-preserving.  Nor can
    we hash the plaintext names with an unkeyed hash (or a hash keyed with a
    value stored on-disk like ext4's s_hash_seed), since that would leak
    information about the names that encryption is meant to protect.
    
    Instead, if we can accept a dirhash that's only computable when the
    fscrypt key is available, we can hash the plaintext names with a keyed
    hash using a secret key derived from the directory's fscrypt master key.
    We'll use SipHash-2-4 for this purpose.
    
    Prepare for this by deriving a SipHash key for each casefolded encrypted
    directory.  Make sure to handle deriving the key not only when setting
    up the directory's fscrypt_info, but also in the case where the casefold
    flag is enabled after the fscrypt_info was already set up.  (We could
    just always derive the key regardless of casefolding, but that would
    introduce unnecessary overhead for people not using casefolding.)
    
    Signed-off-by: Daniel Rosenberg <drosen@google.com>
    [EB: improved commit message, updated fscrypt.rst, squashed with change
     that avoids unnecessarily deriving the key, and many other cleanups]
    Link: https://lore.kernel.org/r/20200120223201.241390-3-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index fd4e5ae21077..5ef861742921 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -5,6 +5,8 @@
  * Encryption hooks for higher-level filesystem operations.
  */
 
+#include <linux/key.h>
+
 #include "fscrypt_private.h"
 
 /**
@@ -137,8 +139,14 @@ int fscrypt_prepare_setflags(struct inode *inode,
 			     unsigned int oldflags, unsigned int flags)
 {
 	struct fscrypt_info *ci;
+	struct fscrypt_master_key *mk;
 	int err;
 
+	/*
+	 * When the CASEFOLD flag is set on an encrypted directory, we must
+	 * derive the secret key needed for the dirhash.  This is only possible
+	 * if the directory uses a v2 encryption policy.
+	 */
 	if (IS_ENCRYPTED(inode) && (flags & ~oldflags & FS_CASEFOLD_FL)) {
 		err = fscrypt_require_key(inode);
 		if (err)
@@ -146,6 +154,14 @@ int fscrypt_prepare_setflags(struct inode *inode,
 		ci = inode->i_crypt_info;
 		if (ci->ci_policy.version != FSCRYPT_POLICY_V2)
 			return -EINVAL;
+		mk = ci->ci_master_key->payload.data[0];
+		down_read(&mk->mk_secret_sem);
+		if (is_master_key_secret_present(&mk->mk_secret))
+			err = fscrypt_derive_dirhash_key(ci, mk);
+		else
+			err = -ENOKEY;
+		up_read(&mk->mk_secret_sem);
+		return err;
 	}
 	return 0;
 }

commit 6e1918cfb263acacd3fc9239127732b69de64695
Author: Daniel Rosenberg <drosen@google.com>
Date:   Mon Jan 20 14:31:56 2020 -0800

    fscrypt: don't allow v1 policies with casefolding
    
    Casefolded encrypted directories will use a new dirhash method that
    requires a secret key.  If the directory uses a v2 encryption policy,
    it's easy to derive this key from the master key using HKDF.  However,
    v1 encryption policies don't provide a way to derive additional keys.
    
    Therefore, don't allow casefolding on directories that use a v1 policy.
    Specifically, make it so that trying to enable casefolding on a
    directory that has a v1 policy fails, trying to set a v1 policy on a
    casefolded directory fails, and trying to open a casefolded directory
    that has a v1 policy (if one somehow exists on-disk) fails.
    
    Signed-off-by: Daniel Rosenberg <drosen@google.com>
    [EB: improved commit message, updated fscrypt.rst, and other cleanups]
    Link: https://lore.kernel.org/r/20200120223201.241390-2-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index 4081aae4bc35..fd4e5ae21077 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -122,6 +122,34 @@ int __fscrypt_prepare_lookup(struct inode *dir, struct dentry *dentry,
 }
 EXPORT_SYMBOL_GPL(__fscrypt_prepare_lookup);
 
+/**
+ * fscrypt_prepare_setflags() - prepare to change flags with FS_IOC_SETFLAGS
+ * @inode: the inode on which flags are being changed
+ * @oldflags: the old flags
+ * @flags: the new flags
+ *
+ * The caller should be holding i_rwsem for write.
+ *
+ * Return: 0 on success; -errno if the flags change isn't allowed or if
+ *	   another error occurs.
+ */
+int fscrypt_prepare_setflags(struct inode *inode,
+			     unsigned int oldflags, unsigned int flags)
+{
+	struct fscrypt_info *ci;
+	int err;
+
+	if (IS_ENCRYPTED(inode) && (flags & ~oldflags & FS_CASEFOLD_FL)) {
+		err = fscrypt_require_key(inode);
+		if (err)
+			return err;
+		ci = inode->i_crypt_info;
+		if (ci->ci_policy.version != FSCRYPT_POLICY_V2)
+			return -EINVAL;
+	}
+	return 0;
+}
+
 int __fscrypt_prepare_symlink(struct inode *dir, unsigned int len,
 			      unsigned int max_len,
 			      struct fscrypt_str *disk_link)

commit 1b3b827ee5230a73c8ed1b2cd8d53b4bd001268b
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Jan 19 23:17:36 2020 -0800

    fscrypt: add "fscrypt_" prefix to fname_encrypt()
    
    fname_encrypt() is a global function, due to being used in both fname.c
    and hooks.c.  So it should be prefixed with "fscrypt_", like all the
    other global functions in fs/crypto/.
    
    Link: https://lore.kernel.org/r/20200120071736.45915-1-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index bb3b7fcfdd48..4081aae4bc35 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -188,7 +188,8 @@ int __fscrypt_encrypt_symlink(struct inode *inode, const char *target,
 	ciphertext_len = disk_link->len - sizeof(*sd);
 	sd->len = cpu_to_le16(ciphertext_len);
 
-	err = fname_encrypt(inode, &iname, sd->encrypted_path, ciphertext_len);
+	err = fscrypt_fname_encrypt(inode, &iname, sd->encrypted_path,
+				    ciphertext_len);
 	if (err)
 		goto err_free_sd;
 

commit 886da8b39cf27995836062bb7fe5fd5cb764540a
Author: Eric Biggers <ebiggers@google.com>
Date:   Wed Jul 24 11:07:58 2019 -0700

    fscrypt: make fscrypt_msg() take inode instead of super_block
    
    Most of the warning and error messages in fs/crypto/ are for situations
    related to a specific inode, not merely to a super_block.  So to make
    things easier, make fscrypt_msg() take an inode rather than a
    super_block, and make it print the inode number.
    
    Note: This is the same approach I'm taking for fsverity_msg().
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index c1d6715d88e9..bb3b7fcfdd48 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -39,9 +39,9 @@ int fscrypt_file_open(struct inode *inode, struct file *filp)
 	dir = dget_parent(file_dentry(filp));
 	if (IS_ENCRYPTED(d_inode(dir)) &&
 	    !fscrypt_has_permitted_context(d_inode(dir), inode)) {
-		fscrypt_warn(inode->i_sb,
-			     "inconsistent encryption contexts: %lu/%lu",
-			     d_inode(dir)->i_ino, inode->i_ino);
+		fscrypt_warn(inode,
+			     "Inconsistent encryption context (parent directory: %lu)",
+			     d_inode(dir)->i_ino);
 		err = -EPERM;
 	}
 	dput(dir);

commit 0bb06cac060dd033153277a0d9dab9fd8aa455a2
Author: Eric Biggers <ebiggers@google.com>
Date:   Tue May 28 12:59:08 2019 -0700

    fscrypt: remove unnecessary includes of ratelimit.h
    
    These should have been removed during commit 544d08fde258 ("fscrypt: use
    a common logging function"), but I missed them.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index bd525f7573a4..c1d6715d88e9 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -5,7 +5,6 @@
  * Encryption hooks for higher-level filesystem operations.
  */
 
-#include <linux/ratelimit.h>
 #include "fscrypt_private.h"
 
 /**

commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index 2dc22549d724..bd525f7573a4 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * fs/crypto/hooks.c
  *

commit 2c58d548f5706d085c4b009f6abb945220460632
Author: Eric Biggers <ebiggers@google.com>
Date:   Wed Apr 10 13:21:15 2019 -0700

    fscrypt: cache decrypted symlink target in ->i_link
    
    Path lookups that traverse encrypted symlink(s) are very slow because
    each encrypted symlink needs to be decrypted each time it's followed.
    This also involves dropping out of rcu-walk mode.
    
    Make encrypted symlinks faster by caching the decrypted symlink target
    in ->i_link.  The first call to fscrypt_get_symlink() sets it.  Then,
    the existing VFS path lookup code uses the non-NULL ->i_link to take the
    fast path where ->get_link() isn't called, and lookups in rcu-walk mode
    remain in rcu-walk mode.
    
    Also set ->i_link immediately when a new encrypted symlink is created.
    
    To safely free the symlink target after an RCU grace period has elapsed,
    introduce a new function fscrypt_free_inode(), and make the relevant
    filesystems call it just before actually freeing the inode.
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index 042d5b44f4ed..2dc22549d724 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -189,11 +189,9 @@ int __fscrypt_encrypt_symlink(struct inode *inode, const char *target,
 	sd->len = cpu_to_le16(ciphertext_len);
 
 	err = fname_encrypt(inode, &iname, sd->encrypted_path, ciphertext_len);
-	if (err) {
-		if (!disk_link->name)
-			kfree(sd);
-		return err;
-	}
+	if (err)
+		goto err_free_sd;
+
 	/*
 	 * Null-terminating the ciphertext doesn't make sense, but we still
 	 * count the null terminator in the length, so we might as well
@@ -201,9 +199,20 @@ int __fscrypt_encrypt_symlink(struct inode *inode, const char *target,
 	 */
 	sd->encrypted_path[ciphertext_len] = '\0';
 
+	/* Cache the plaintext symlink target for later use by get_link() */
+	err = -ENOMEM;
+	inode->i_link = kmemdup(target, len + 1, GFP_NOFS);
+	if (!inode->i_link)
+		goto err_free_sd;
+
 	if (!disk_link->name)
 		disk_link->name = (unsigned char *)sd;
 	return 0;
+
+err_free_sd:
+	if (!disk_link->name)
+		kfree(sd);
+	return err;
 }
 EXPORT_SYMBOL_GPL(__fscrypt_encrypt_symlink);
 
@@ -212,7 +221,7 @@ EXPORT_SYMBOL_GPL(__fscrypt_encrypt_symlink);
  * @inode: the symlink inode
  * @caddr: the on-disk contents of the symlink
  * @max_size: size of @caddr buffer
- * @done: if successful, will be set up to free the returned target
+ * @done: if successful, will be set up to free the returned target if needed
  *
  * If the symlink's encryption key is available, we decrypt its target.
  * Otherwise, we encode its target for presentation.
@@ -227,12 +236,18 @@ const char *fscrypt_get_symlink(struct inode *inode, const void *caddr,
 {
 	const struct fscrypt_symlink_data *sd;
 	struct fscrypt_str cstr, pstr;
+	bool has_key;
 	int err;
 
 	/* This is for encrypted symlinks only */
 	if (WARN_ON(!IS_ENCRYPTED(inode)))
 		return ERR_PTR(-EINVAL);
 
+	/* If the decrypted target is already cached, just return it. */
+	pstr.name = READ_ONCE(inode->i_link);
+	if (pstr.name)
+		return pstr.name;
+
 	/*
 	 * Try to set up the symlink's encryption key, but we can continue
 	 * regardless of whether the key is available or not.
@@ -240,6 +255,7 @@ const char *fscrypt_get_symlink(struct inode *inode, const void *caddr,
 	err = fscrypt_get_encryption_info(inode);
 	if (err)
 		return ERR_PTR(err);
+	has_key = fscrypt_has_encryption_key(inode);
 
 	/*
 	 * For historical reasons, encrypted symlink targets are prefixed with
@@ -271,7 +287,17 @@ const char *fscrypt_get_symlink(struct inode *inode, const void *caddr,
 		goto err_kfree;
 
 	pstr.name[pstr.len] = '\0';
-	set_delayed_call(done, kfree_link, pstr.name);
+
+	/*
+	 * Cache decrypted symlink targets in i_link for later use.  Don't cache
+	 * symlink targets encoded without the key, since those become outdated
+	 * once the key is added.  This pairs with the READ_ONCE() above and in
+	 * the VFS path lookup code.
+	 */
+	if (!has_key ||
+	    cmpxchg_release(&inode->i_link, NULL, pstr.name) != NULL)
+		set_delayed_call(done, kfree_link, pstr.name);
+
 	return pstr.name;
 
 err_kfree:

commit b01531db6cec2aa330dbc91bfbfaaef4a0d387a4
Author: Eric Biggers <ebiggers@google.com>
Date:   Wed Mar 20 11:39:13 2019 -0700

    fscrypt: fix race where ->lookup() marks plaintext dentry as ciphertext
    
    ->lookup() in an encrypted directory begins as follows:
    
    1. fscrypt_prepare_lookup():
        a. Try to load the directory's encryption key.
        b. If the key is unavailable, mark the dentry as a ciphertext name
           via d_flags.
    2. fscrypt_setup_filename():
        a. Try to load the directory's encryption key.
        b. If the key is available, encrypt the name (treated as a plaintext
           name) to get the on-disk name.  Otherwise decode the name
           (treated as a ciphertext name) to get the on-disk name.
    
    But if the key is concurrently added, it may be found at (2a) but not at
    (1a).  In this case, the dentry will be wrongly marked as a ciphertext
    name even though it was actually treated as plaintext.
    
    This will cause the dentry to be wrongly invalidated on the next lookup,
    potentially causing problems.  For example, if the racy ->lookup() was
    part of sys_mount(), then the new mount will be detached when anything
    tries to access it.  This is despite the mountpoint having a plaintext
    path, which should remain valid now that the key was added.
    
    Of course, this is only possible if there's a userspace race.  Still,
    the additional kernel-side race is confusing and unexpected.
    
    Close the kernel-side race by changing fscrypt_prepare_lookup() to also
    set the on-disk filename (step 2b), consistent with the d_flags update.
    
    Fixes: 28b4c263961c ("ext4 crypto: revalidate dentry after adding or removing the key")
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index 9d8910e86ee5..042d5b44f4ed 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -104,20 +104,21 @@ int __fscrypt_prepare_rename(struct inode *old_dir, struct dentry *old_dentry,
 }
 EXPORT_SYMBOL_GPL(__fscrypt_prepare_rename);
 
-int __fscrypt_prepare_lookup(struct inode *dir, struct dentry *dentry)
+int __fscrypt_prepare_lookup(struct inode *dir, struct dentry *dentry,
+			     struct fscrypt_name *fname)
 {
-	int err = fscrypt_get_encryption_info(dir);
+	int err = fscrypt_setup_filename(dir, &dentry->d_name, 1, fname);
 
-	if (err)
+	if (err && err != -ENOENT)
 		return err;
 
-	if (!fscrypt_has_encryption_key(dir)) {
+	if (fname->is_ciphertext_name) {
 		spin_lock(&dentry->d_lock);
 		dentry->d_flags |= DCACHE_ENCRYPTED_NAME;
 		spin_unlock(&dentry->d_lock);
 		d_set_d_op(dentry, &fscrypt_d_ops);
 	}
-	return 0;
+	return err;
 }
 EXPORT_SYMBOL_GPL(__fscrypt_prepare_lookup);
 

commit d456a33f041af4b54f3ce495a86d00c246165032
Author: Eric Biggers <ebiggers@google.com>
Date:   Wed Mar 20 11:39:12 2019 -0700

    fscrypt: only set dentry_operations on ciphertext dentries
    
    Plaintext dentries are always valid, so only set fscrypt_d_ops on
    ciphertext dentries.
    
    Besides marginally improved performance, this allows overlayfs to use an
    fscrypt-encrypted upperdir, provided that all the following are true:
    
        (1) The fscrypt encryption key is placed in the keyring before
            mounting overlayfs, and remains while the overlayfs is mounted.
    
        (2) The overlayfs workdir uses the same encryption policy.
    
        (3) No dentries for the ciphertext names of subdirectories have been
            created in the upperdir or workdir yet.  (Since otherwise
            d_splice_alias() will reuse the old dentry with ->d_op set.)
    
    One potential use case is using an ephemeral encryption key to encrypt
    all files created or changed by a container, so that they can be
    securely erased ("crypto-shredded") after the container stops.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index 2e7498a821a4..9d8910e86ee5 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -115,9 +115,8 @@ int __fscrypt_prepare_lookup(struct inode *dir, struct dentry *dentry)
 		spin_lock(&dentry->d_lock);
 		dentry->d_flags |= DCACHE_ENCRYPTED_NAME;
 		spin_unlock(&dentry->d_lock);
+		d_set_d_op(dentry, &fscrypt_d_ops);
 	}
-
-	d_set_d_op(dentry, &fscrypt_d_ops);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(__fscrypt_prepare_lookup);

commit 968dd6d0c6d6b6a989c6ddb9e2584a031b83e7b5
Author: Eric Biggers <ebiggers@google.com>
Date:   Wed Mar 20 11:39:10 2019 -0700

    fscrypt: fix race allowing rename() and link() of ciphertext dentries
    
    Close some race conditions where fscrypt allowed rename() and link() on
    ciphertext dentries that had been looked up just prior to the key being
    concurrently added.  It's better to return -ENOKEY in this case.
    
    This avoids doing the nonsensical thing of encrypting the names a second
    time when searching for the actual on-disk dir entries.  It also
    guarantees that DCACHE_ENCRYPTED_NAME dentries are never rename()d, so
    the dcache won't have support all possible combinations of moving
    DCACHE_ENCRYPTED_NAME around during __d_move().
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index a9492f75bbe1..2e7498a821a4 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -49,7 +49,8 @@ int fscrypt_file_open(struct inode *inode, struct file *filp)
 }
 EXPORT_SYMBOL_GPL(fscrypt_file_open);
 
-int __fscrypt_prepare_link(struct inode *inode, struct inode *dir)
+int __fscrypt_prepare_link(struct inode *inode, struct inode *dir,
+			   struct dentry *dentry)
 {
 	int err;
 
@@ -57,6 +58,10 @@ int __fscrypt_prepare_link(struct inode *inode, struct inode *dir)
 	if (err)
 		return err;
 
+	/* ... in case we looked up ciphertext name before key was added */
+	if (dentry->d_flags & DCACHE_ENCRYPTED_NAME)
+		return -ENOKEY;
+
 	if (!fscrypt_has_permitted_context(dir, inode))
 		return -EXDEV;
 
@@ -78,6 +83,11 @@ int __fscrypt_prepare_rename(struct inode *old_dir, struct dentry *old_dentry,
 	if (err)
 		return err;
 
+	/* ... in case we looked up ciphertext name(s) before key was added */
+	if ((old_dentry->d_flags | new_dentry->d_flags) &
+	    DCACHE_ENCRYPTED_NAME)
+		return -ENOKEY;
+
 	if (old_dir != new_dir) {
 		if (IS_ENCRYPTED(new_dir) &&
 		    !fscrypt_has_permitted_context(new_dir,

commit 6cc248684d3d23bbd073ae2fa73d3416c0558909
Author: Eric Biggers <ebiggers@google.com>
Date:   Wed Mar 20 11:39:09 2019 -0700

    fscrypt: clean up and improve dentry revalidation
    
    Make various improvements to fscrypt dentry revalidation:
    
    - Don't try to handle the case where the per-directory key is removed,
      as this can't happen without the inode (and dentries) being evicted.
    
    - Flag ciphertext dentries rather than plaintext dentries, since it's
      ciphertext dentries that need the special handling.
    
    - Avoid doing unnecessary work for non-ciphertext dentries.
    
    - When revalidating ciphertext dentries, try to set up the directory's
      i_crypt_info to make sure the key is really still absent, rather than
      invalidating all negative dentries as the previous code did.  An old
      comment suggested we can't do this for locking reasons, but AFAICT
      this comment was outdated and it actually works fine.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index 56debb1fcf5e..a9492f75bbe1 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -101,9 +101,9 @@ int __fscrypt_prepare_lookup(struct inode *dir, struct dentry *dentry)
 	if (err)
 		return err;
 
-	if (fscrypt_has_encryption_key(dir)) {
+	if (!fscrypt_has_encryption_key(dir)) {
 		spin_lock(&dentry->d_lock);
-		dentry->d_flags |= DCACHE_ENCRYPTED_WITH_KEY;
+		dentry->d_flags |= DCACHE_ENCRYPTED_NAME;
 		spin_unlock(&dentry->d_lock);
 	}
 

commit f5e55e777cc93eae1416f0fa4908e8846b6d7825
Author: Eric Biggers <ebiggers@google.com>
Date:   Tue Jan 22 16:20:21 2019 -0800

    fscrypt: return -EXDEV for incompatible rename or link into encrypted dir
    
    Currently, trying to rename or link a regular file, directory, or
    symlink into an encrypted directory fails with EPERM when the source
    file is unencrypted or is encrypted with a different encryption policy,
    and is on the same mountpoint.  It is correct for the operation to fail,
    but the choice of EPERM breaks tools like 'mv' that know to copy rather
    than rename if they see EXDEV, but don't know what to do with EPERM.
    
    Our original motivation for EPERM was to encourage users to securely
    handle their data.  Encrypting files by "moving" them into an encrypted
    directory can be insecure because the unencrypted data may remain in
    free space on disk, where it can later be recovered by an attacker.
    It's much better to encrypt the data from the start, or at least try to
    securely delete the source data e.g. using the 'shred' program.
    
    However, the current behavior hasn't been effective at achieving its
    goal because users tend to be confused, hack around it, and complain;
    see e.g. https://github.com/google/fscrypt/issues/76.  And in some cases
    it's actually inconsistent or unnecessary.  For example, 'mv'-ing files
    between differently encrypted directories doesn't work even in cases
    where it can be secure, such as when in userspace the same passphrase
    protects both directories.  Yet, you *can* already 'mv' unencrypted
    files into an encrypted directory if the source files are on a different
    mountpoint, even though doing so is often insecure.
    
    There are probably better ways to teach users to securely handle their
    files.  For example, the 'fscrypt' userspace tool could provide a
    command that migrates unencrypted files into an encrypted directory,
    acting like 'shred' on the source files and providing appropriate
    warnings depending on the type of the source filesystem and disk.
    
    Receiving errors on unimportant files might also force some users to
    disable encryption, thus making the behavior counterproductive.  It's
    desirable to make encryption as unobtrusive as possible.
    
    Therefore, change the error code from EPERM to EXDEV so that tools
    looking for EXDEV will fall back to a copy.
    
    This, of course, doesn't prevent users from still doing the right things
    to securely manage their files.  Note that this also matches the
    behavior when a file is renamed between two project quota hierarchies;
    so there's precedent for using EXDEV for things other than mountpoints.
    
    xfstests generic/398 will require an update with this change.
    
    [Rewritten from an earlier patch series by Michael Halcrow.]
    
    Cc: Michael Halcrow <mhalcrow@google.com>
    Cc: Joe Richey <joerichey@google.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index 926e5df20ec3..56debb1fcf5e 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -58,7 +58,7 @@ int __fscrypt_prepare_link(struct inode *inode, struct inode *dir)
 		return err;
 
 	if (!fscrypt_has_permitted_context(dir, inode))
-		return -EPERM;
+		return -EXDEV;
 
 	return 0;
 }
@@ -82,13 +82,13 @@ int __fscrypt_prepare_rename(struct inode *old_dir, struct dentry *old_dentry,
 		if (IS_ENCRYPTED(new_dir) &&
 		    !fscrypt_has_permitted_context(new_dir,
 						   d_inode(old_dentry)))
-			return -EPERM;
+			return -EXDEV;
 
 		if ((flags & RENAME_EXCHANGE) &&
 		    IS_ENCRYPTED(old_dir) &&
 		    !fscrypt_has_permitted_context(old_dir,
 						   d_inode(new_dentry)))
-			return -EPERM;
+			return -EXDEV;
 	}
 	return 0;
 }

commit 544d08fde258b4da72b6cfbe2d7172c86ce9860d
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Apr 30 15:51:47 2018 -0700

    fscrypt: use a common logging function
    
    Use a common function for fscrypt warning and error messages so that all
    the messages are consistently ratelimited, include the "fscrypt:"
    prefix, and include the filesystem name if applicable.
    
    Also fix up a few of the log messages to be more descriptive.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index bec06490fb13..926e5df20ec3 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -39,8 +39,9 @@ int fscrypt_file_open(struct inode *inode, struct file *filp)
 	dir = dget_parent(file_dentry(filp));
 	if (IS_ENCRYPTED(d_inode(dir)) &&
 	    !fscrypt_has_permitted_context(d_inode(dir), inode)) {
-		pr_warn_ratelimited("fscrypt: inconsistent encryption contexts: %lu/%lu",
-				    d_inode(dir)->i_ino, inode->i_ino);
+		fscrypt_warn(inode->i_sb,
+			     "inconsistent encryption contexts: %lu/%lu",
+			     d_inode(dir)->i_ino, inode->i_ino);
 		err = -EPERM;
 	}
 	dput(dir);

commit 0b1dfa4cc6c60052b2c30ead316fa84c46d3c43c
Author: Eric Biggers <ebiggers@google.com>
Date:   Fri Jan 19 13:45:24 2018 -0800

    fscrypt: fix build with pre-4.6 gcc versions
    
    gcc versions prior to 4.6 require an extra level of braces when using a
    designated initializer for a member in an anonymous struct or union.
    This caused a compile error with the 'struct qstr' initialization in
    __fscrypt_encrypt_symlink().
    
    Fix it by using QSTR_INIT().
    
    Reported-by: Andrew Morton <akpm@linux-foundation.org>
    Fixes: 76e81d6d5048 ("fscrypt: new helper functions for ->symlink()")
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index 28f9f059571d..bec06490fb13 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -158,7 +158,7 @@ int __fscrypt_encrypt_symlink(struct inode *inode, const char *target,
 			      unsigned int len, struct fscrypt_str *disk_link)
 {
 	int err;
-	struct qstr iname = { .name = target, .len = len };
+	struct qstr iname = QSTR_INIT(target, len);
 	struct fscrypt_symlink_data *sd;
 	unsigned int ciphertext_len;
 

commit b9db0b4a68d373897119d1e0a3beebe1c1a23936
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Jan 11 23:30:08 2018 -0500

    fscrypt: fix up fscrypt_fname_encrypted_size() for internal use
    
    Filesystems don't need fscrypt_fname_encrypted_size() anymore, so
    unexport it and move it to fscrypt_private.h.
    
    We also never calculate the encrypted size of a filename without having
    the fscrypt_info present since it is needed to know the amount of
    NUL-padding which is determined by the encryption policy, and also we
    will always truncate the NUL-padding to the maximum filename length.
    Therefore, also make fscrypt_fname_encrypted_size() assume that the
    fscrypt_info is present, and make it truncate the returned length to the
    specified max_len.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index 5bf38d94c5d2..28f9f059571d 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -143,12 +143,12 @@ int __fscrypt_prepare_symlink(struct inode *dir, unsigned int len,
 	 * counting it (even though it is meaningless for ciphertext) is simpler
 	 * for now since filesystems will assume it is there and subtract it.
 	 */
-	if (sizeof(struct fscrypt_symlink_data) + len > max_len)
+	if (!fscrypt_fname_encrypted_size(dir, len,
+					  max_len - sizeof(struct fscrypt_symlink_data),
+					  &disk_link->len))
 		return -ENAMETOOLONG;
-	disk_link->len = min_t(unsigned int,
-			       sizeof(struct fscrypt_symlink_data) +
-					fscrypt_fname_encrypted_size(dir, len),
-			       max_len);
+	disk_link->len += sizeof(struct fscrypt_symlink_data);
+
 	disk_link->name = NULL;
 	return 0;
 }

commit 50c961de59ec841c1185c18457e6dab227f3bbf3
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Jan 11 23:30:08 2018 -0500

    fscrypt: calculate NUL-padding length in one place only
    
    Currently, when encrypting a filename (either a real filename or a
    symlink target) we calculate the amount of NUL-padding twice: once
    before encryption and once during encryption in fname_encrypt().  It is
    needed before encryption to allocate the needed buffer size as well as
    calculate the size the symlink target will take up on-disk before
    creating the symlink inode.  Calculating the size during encryption as
    well is redundant.
    
    Remove this redundancy by always calculating the exact size beforehand,
    and making fname_encrypt() just add as much NUL padding as is needed to
    fill the output buffer.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index 8900e348ba6e..5bf38d94c5d2 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -161,7 +161,6 @@ int __fscrypt_encrypt_symlink(struct inode *inode, const char *target,
 	struct qstr iname = { .name = target, .len = len };
 	struct fscrypt_symlink_data *sd;
 	unsigned int ciphertext_len;
-	struct fscrypt_str oname;
 
 	err = fscrypt_require_key(inode);
 	if (err)
@@ -178,16 +177,12 @@ int __fscrypt_encrypt_symlink(struct inode *inode, const char *target,
 	ciphertext_len = disk_link->len - sizeof(*sd);
 	sd->len = cpu_to_le16(ciphertext_len);
 
-	oname.name = sd->encrypted_path;
-	oname.len = ciphertext_len;
-	err = fname_encrypt(inode, &iname, &oname);
+	err = fname_encrypt(inode, &iname, sd->encrypted_path, ciphertext_len);
 	if (err) {
 		if (!disk_link->name)
 			kfree(sd);
 		return err;
 	}
-	BUG_ON(oname.len != ciphertext_len);
-
 	/*
 	 * Null-terminating the ciphertext doesn't make sense, but we still
 	 * count the null terminator in the length, so we might as well

commit 3b0d8837a79ba7b7cc324d1f2b206c074e9c6182
Author: Eric Biggers <ebiggers@google.com>
Date:   Fri Jan 5 10:45:02 2018 -0800

    fscrypt: new helper function - fscrypt_get_symlink()
    
    Filesystems also have duplicate code to support ->get_link() on
    encrypted symlinks.  Factor it out into a new function
    fscrypt_get_symlink().  It takes in the contents of the encrypted
    symlink on-disk and provides the target (decrypted or encoded) that
    should be returned from ->get_link().
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index 4b83e4af2e41..8900e348ba6e 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -200,3 +200,76 @@ int __fscrypt_encrypt_symlink(struct inode *inode, const char *target,
 	return 0;
 }
 EXPORT_SYMBOL_GPL(__fscrypt_encrypt_symlink);
+
+/**
+ * fscrypt_get_symlink - get the target of an encrypted symlink
+ * @inode: the symlink inode
+ * @caddr: the on-disk contents of the symlink
+ * @max_size: size of @caddr buffer
+ * @done: if successful, will be set up to free the returned target
+ *
+ * If the symlink's encryption key is available, we decrypt its target.
+ * Otherwise, we encode its target for presentation.
+ *
+ * This may sleep, so the filesystem must have dropped out of RCU mode already.
+ *
+ * Return: the presentable symlink target or an ERR_PTR()
+ */
+const char *fscrypt_get_symlink(struct inode *inode, const void *caddr,
+				unsigned int max_size,
+				struct delayed_call *done)
+{
+	const struct fscrypt_symlink_data *sd;
+	struct fscrypt_str cstr, pstr;
+	int err;
+
+	/* This is for encrypted symlinks only */
+	if (WARN_ON(!IS_ENCRYPTED(inode)))
+		return ERR_PTR(-EINVAL);
+
+	/*
+	 * Try to set up the symlink's encryption key, but we can continue
+	 * regardless of whether the key is available or not.
+	 */
+	err = fscrypt_get_encryption_info(inode);
+	if (err)
+		return ERR_PTR(err);
+
+	/*
+	 * For historical reasons, encrypted symlink targets are prefixed with
+	 * the ciphertext length, even though this is redundant with i_size.
+	 */
+
+	if (max_size < sizeof(*sd))
+		return ERR_PTR(-EUCLEAN);
+	sd = caddr;
+	cstr.name = (unsigned char *)sd->encrypted_path;
+	cstr.len = le16_to_cpu(sd->len);
+
+	if (cstr.len == 0)
+		return ERR_PTR(-EUCLEAN);
+
+	if (cstr.len + sizeof(*sd) - 1 > max_size)
+		return ERR_PTR(-EUCLEAN);
+
+	err = fscrypt_fname_alloc_buffer(inode, cstr.len, &pstr);
+	if (err)
+		return ERR_PTR(err);
+
+	err = fscrypt_fname_disk_to_usr(inode, 0, 0, &cstr, &pstr);
+	if (err)
+		goto err_kfree;
+
+	err = -EUCLEAN;
+	if (pstr.name[0] == '\0')
+		goto err_kfree;
+
+	pstr.name[pstr.len] = '\0';
+	set_delayed_call(done, kfree_link, pstr.name);
+	return pstr.name;
+
+err_kfree:
+	kfree(pstr.name);
+	return ERR_PTR(err);
+}
+EXPORT_SYMBOL_GPL(fscrypt_get_symlink);

commit 76e81d6d50481144824237e6843122824b0a55c0
Author: Eric Biggers <ebiggers@google.com>
Date:   Fri Jan 5 10:45:01 2018 -0800

    fscrypt: new helper functions for ->symlink()
    
    Currently, filesystems supporting fscrypt need to implement some tricky
    logic when creating encrypted symlinks, including handling a peculiar
    on-disk format (struct fscrypt_symlink_data) and correctly calculating
    the size of the encrypted symlink.  Introduce helper functions to make
    things a bit easier:
    
    - fscrypt_prepare_symlink() computes and validates the size the symlink
      target will require on-disk.
    - fscrypt_encrypt_symlink() creates the encrypted target if needed.
    
    The new helpers actually fix some subtle bugs.  First, when checking
    whether the symlink target was too long, filesystems didn't account for
    the fact that the NUL padding is meant to be truncated if it would cause
    the maximum length to be exceeded, as is done for filenames in
    directories.  Consequently users would receive ENAMETOOLONG when
    creating symlinks close to what is supposed to be the maximum length.
    For example, with EXT4 with a 4K block size, the maximum symlink target
    length in an encrypted directory is supposed to be 4093 bytes (in
    comparison to 4095 in an unencrypted directory), but in
    FS_POLICY_FLAGS_PAD_32-mode only up to 4064 bytes were accepted.
    
    Second, symlink targets of "." and ".." were not being encrypted, even
    though they should be, as these names are special in *directory entries*
    but not in symlink targets.  Fortunately, we can fix this simply by
    starting to encrypt them, as old kernels already accept them in
    encrypted form.
    
    Third, the output string length the filesystems were providing when
    doing the actual encryption was incorrect, as it was forgotten to
    exclude 'sizeof(struct fscrypt_symlink_data)'.  Fortunately though, this
    bug didn't make a difference.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index 9f5fb2eb9cf7..4b83e4af2e41 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -110,3 +110,93 @@ int __fscrypt_prepare_lookup(struct inode *dir, struct dentry *dentry)
 	return 0;
 }
 EXPORT_SYMBOL_GPL(__fscrypt_prepare_lookup);
+
+int __fscrypt_prepare_symlink(struct inode *dir, unsigned int len,
+			      unsigned int max_len,
+			      struct fscrypt_str *disk_link)
+{
+	int err;
+
+	/*
+	 * To calculate the size of the encrypted symlink target we need to know
+	 * the amount of NUL padding, which is determined by the flags set in
+	 * the encryption policy which will be inherited from the directory.
+	 * The easiest way to get access to this is to just load the directory's
+	 * fscrypt_info, since we'll need it to create the dir_entry anyway.
+	 *
+	 * Note: in test_dummy_encryption mode, @dir may be unencrypted.
+	 */
+	err = fscrypt_get_encryption_info(dir);
+	if (err)
+		return err;
+	if (!fscrypt_has_encryption_key(dir))
+		return -ENOKEY;
+
+	/*
+	 * Calculate the size of the encrypted symlink and verify it won't
+	 * exceed max_len.  Note that for historical reasons, encrypted symlink
+	 * targets are prefixed with the ciphertext length, despite this
+	 * actually being redundant with i_size.  This decreases by 2 bytes the
+	 * longest symlink target we can accept.
+	 *
+	 * We could recover 1 byte by not counting a null terminator, but
+	 * counting it (even though it is meaningless for ciphertext) is simpler
+	 * for now since filesystems will assume it is there and subtract it.
+	 */
+	if (sizeof(struct fscrypt_symlink_data) + len > max_len)
+		return -ENAMETOOLONG;
+	disk_link->len = min_t(unsigned int,
+			       sizeof(struct fscrypt_symlink_data) +
+					fscrypt_fname_encrypted_size(dir, len),
+			       max_len);
+	disk_link->name = NULL;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(__fscrypt_prepare_symlink);
+
+int __fscrypt_encrypt_symlink(struct inode *inode, const char *target,
+			      unsigned int len, struct fscrypt_str *disk_link)
+{
+	int err;
+	struct qstr iname = { .name = target, .len = len };
+	struct fscrypt_symlink_data *sd;
+	unsigned int ciphertext_len;
+	struct fscrypt_str oname;
+
+	err = fscrypt_require_key(inode);
+	if (err)
+		return err;
+
+	if (disk_link->name) {
+		/* filesystem-provided buffer */
+		sd = (struct fscrypt_symlink_data *)disk_link->name;
+	} else {
+		sd = kmalloc(disk_link->len, GFP_NOFS);
+		if (!sd)
+			return -ENOMEM;
+	}
+	ciphertext_len = disk_link->len - sizeof(*sd);
+	sd->len = cpu_to_le16(ciphertext_len);
+
+	oname.name = sd->encrypted_path;
+	oname.len = ciphertext_len;
+	err = fname_encrypt(inode, &iname, &oname);
+	if (err) {
+		if (!disk_link->name)
+			kfree(sd);
+		return err;
+	}
+	BUG_ON(oname.len != ciphertext_len);
+
+	/*
+	 * Null-terminating the ciphertext doesn't make sense, but we still
+	 * count the null terminator in the length, so we might as well
+	 * initialize it just in case the filesystem writes it out.
+	 */
+	sd->encrypted_path[ciphertext_len] = '\0';
+
+	if (!disk_link->name)
+		disk_link->name = (unsigned char *)sd;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(__fscrypt_encrypt_symlink);

commit 32c3cf028e747d1e9cf0679b16dcbe3794fe4853
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Oct 9 12:15:43 2017 -0700

    fscrypt: new helper function - fscrypt_prepare_lookup()
    
    Introduce a helper function which prepares to look up the given dentry
    in the given directory.  If the directory is encrypted, it handles
    loading the directory's encryption key, setting the dentry's ->d_op to
    fscrypt_d_ops, and setting DCACHE_ENCRYPTED_WITH_KEY if the directory's
    encryption key is available.
    
    Note: once all filesystems switch over to this, we'll be able to move
    fscrypt_d_ops and fscrypt_set_encrypted_dentry() to fscrypt_private.h.
    
    Acked-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index 822cb78f9b45..9f5fb2eb9cf7 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -92,3 +92,21 @@ int __fscrypt_prepare_rename(struct inode *old_dir, struct dentry *old_dentry,
 	return 0;
 }
 EXPORT_SYMBOL_GPL(__fscrypt_prepare_rename);
+
+int __fscrypt_prepare_lookup(struct inode *dir, struct dentry *dentry)
+{
+	int err = fscrypt_get_encryption_info(dir);
+
+	if (err)
+		return err;
+
+	if (fscrypt_has_encryption_key(dir)) {
+		spin_lock(&dentry->d_lock);
+		dentry->d_flags |= DCACHE_ENCRYPTED_WITH_KEY;
+		spin_unlock(&dentry->d_lock);
+	}
+
+	d_set_d_op(dentry, &fscrypt_d_ops);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(__fscrypt_prepare_lookup);

commit 94b26f3672a0e41025104c7e46943917544e1c87
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Oct 9 12:15:42 2017 -0700

    fscrypt: new helper function - fscrypt_prepare_rename()
    
    Introduce a helper function which prepares to rename a file into a
    possibly encrypted directory.  It handles loading the encryption keys
    for the source and target directories if needed, and it handles
    enforcing that if the target directory (and the source directory for a
    cross-rename) is encrypted, then the file being moved into the directory
    has the same encryption policy as its containing directory.
    
    Acked-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index 8b90217320dd..822cb78f9b45 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -62,3 +62,33 @@ int __fscrypt_prepare_link(struct inode *inode, struct inode *dir)
 	return 0;
 }
 EXPORT_SYMBOL_GPL(__fscrypt_prepare_link);
+
+int __fscrypt_prepare_rename(struct inode *old_dir, struct dentry *old_dentry,
+			     struct inode *new_dir, struct dentry *new_dentry,
+			     unsigned int flags)
+{
+	int err;
+
+	err = fscrypt_require_key(old_dir);
+	if (err)
+		return err;
+
+	err = fscrypt_require_key(new_dir);
+	if (err)
+		return err;
+
+	if (old_dir != new_dir) {
+		if (IS_ENCRYPTED(new_dir) &&
+		    !fscrypt_has_permitted_context(new_dir,
+						   d_inode(old_dentry)))
+			return -EPERM;
+
+		if ((flags & RENAME_EXCHANGE) &&
+		    IS_ENCRYPTED(old_dir) &&
+		    !fscrypt_has_permitted_context(old_dir,
+						   d_inode(new_dentry)))
+			return -EPERM;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(__fscrypt_prepare_rename);

commit 0ea87a9644ebb5c9a3b100585d10533366de3269
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Oct 9 12:15:41 2017 -0700

    fscrypt: new helper function - fscrypt_prepare_link()
    
    Introduce a helper function which prepares to link an inode into a
    possibly-encrypted directory.  It handles setting up the target
    directory's encryption key, then verifying that the link won't violate
    the constraint that all files in an encrypted directory tree use the
    same encryption policy.
    
    Acked-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
index 069088e91ea9..8b90217320dd 100644
--- a/fs/crypto/hooks.c
+++ b/fs/crypto/hooks.c
@@ -47,3 +47,18 @@ int fscrypt_file_open(struct inode *inode, struct file *filp)
 	return err;
 }
 EXPORT_SYMBOL_GPL(fscrypt_file_open);
+
+int __fscrypt_prepare_link(struct inode *inode, struct inode *dir)
+{
+	int err;
+
+	err = fscrypt_require_key(dir);
+	if (err)
+		return err;
+
+	if (!fscrypt_has_permitted_context(dir, inode))
+		return -EPERM;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(__fscrypt_prepare_link);

commit efcc7ae2c9172d9a7ae94afdaf066a7abf0b9a90
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Oct 9 12:15:40 2017 -0700

    fscrypt: new helper function - fscrypt_file_open()
    
    Add a helper function which prepares to open a regular file which may be
    encrypted.  It handles setting up the file's encryption key, then
    checking that the file's encryption policy matches that of its parent
    directory (if the parent directory is encrypted).  It may be set as the
    ->open() method or it can be called from another ->open() method.
    
    Acked-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/crypto/hooks.c b/fs/crypto/hooks.c
new file mode 100644
index 000000000000..069088e91ea9
--- /dev/null
+++ b/fs/crypto/hooks.c
@@ -0,0 +1,49 @@
+/*
+ * fs/crypto/hooks.c
+ *
+ * Encryption hooks for higher-level filesystem operations.
+ */
+
+#include <linux/ratelimit.h>
+#include "fscrypt_private.h"
+
+/**
+ * fscrypt_file_open - prepare to open a possibly-encrypted regular file
+ * @inode: the inode being opened
+ * @filp: the struct file being set up
+ *
+ * Currently, an encrypted regular file can only be opened if its encryption key
+ * is available; access to the raw encrypted contents is not supported.
+ * Therefore, we first set up the inode's encryption key (if not already done)
+ * and return an error if it's unavailable.
+ *
+ * We also verify that if the parent directory (from the path via which the file
+ * is being opened) is encrypted, then the inode being opened uses the same
+ * encryption policy.  This is needed as part of the enforcement that all files
+ * in an encrypted directory tree use the same encryption policy, as a
+ * protection against certain types of offline attacks.  Note that this check is
+ * needed even when opening an *unencrypted* file, since it's forbidden to have
+ * an unencrypted file in an encrypted directory.
+ *
+ * Return: 0 on success, -ENOKEY if the key is missing, or another -errno code
+ */
+int fscrypt_file_open(struct inode *inode, struct file *filp)
+{
+	int err;
+	struct dentry *dir;
+
+	err = fscrypt_require_key(inode);
+	if (err)
+		return err;
+
+	dir = dget_parent(file_dentry(filp));
+	if (IS_ENCRYPTED(d_inode(dir)) &&
+	    !fscrypt_has_permitted_context(d_inode(dir), inode)) {
+		pr_warn_ratelimited("fscrypt: inconsistent encryption contexts: %lu/%lu",
+				    d_inode(dir)->i_ino, inode->i_ino);
+		err = -EPERM;
+	}
+	dput(dir);
+	return err;
+}
+EXPORT_SYMBOL_GPL(fscrypt_file_open);
