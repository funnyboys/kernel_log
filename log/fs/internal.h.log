commit 0b166a57e6222666292a481b742af92b50c3ba50
Merge: b25c6644bfd3 6b8ed62008a4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 5 16:19:28 2020 -0700

    Merge tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4
    
    Pull ext4 updates from Ted Ts'o:
     "A lot of bug fixes and cleanups for ext4, including:
    
       - Fix performance problems found in dioread_nolock now that it is the
         default, caused by transaction leaks.
    
       - Clean up fiemap handling in ext4
    
       - Clean up and refactor multiple block allocator (mballoc) code
    
       - Fix a problem with mballoc with a smaller file systems running out
         of blocks because they couldn't properly use blocks that had been
         reserved by inode preallocation.
    
       - Fixed a race in ext4_sync_parent() versus rename()
    
       - Simplify the error handling in the extent manipulation code
    
       - Make sure all metadata I/O errors are felected to
         ext4_ext_dirty()'s and ext4_make_inode_dirty()'s callers.
    
       - Avoid passing an error pointer to brelse in ext4_xattr_set()
    
       - Fix race which could result to freeing an inode on the dirty last
         in data=journal mode.
    
       - Fix refcount handling if ext4_iget() fails
    
       - Fix a crash in generic/019 caused by a corrupted extent node"
    
    * tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4: (58 commits)
      ext4: avoid unnecessary transaction starts during writeback
      ext4: don't block for O_DIRECT if IOCB_NOWAIT is set
      ext4: remove the access_ok() check in ext4_ioctl_get_es_cache
      fs: remove the access_ok() check in ioctl_fiemap
      fs: handle FIEMAP_FLAG_SYNC in fiemap_prep
      fs: move fiemap range validation into the file systems instances
      iomap: fix the iomap_fiemap prototype
      fs: move the fiemap definitions out of fs.h
      fs: mark __generic_block_fiemap static
      ext4: remove the call to fiemap_check_flags in ext4_fiemap
      ext4: split _ext4_fiemap
      ext4: fix fiemap size checks for bitmap files
      ext4: fix EXT4_MAX_LOGICAL_BLOCK macro
      add comment for ext4_dir_entry_2 file_type member
      jbd2: avoid leaking transaction credits when unreserving handle
      ext4: drop ext4_journal_free_reserved()
      ext4: mballoc: use lock for checking free blocks while retrying
      ext4: mballoc: refactor ext4_mb_good_group()
      ext4: mballoc: introduce pcpu seqcnt for freeing PA to improve ENOSPC handling
      ext4: mballoc: refactor ext4_mb_discard_preallocations()
      ...

commit 4301efa4c7cca11556dd89899eee066d49b47bf7
Author: Jan Kara <jack@suse.cz>
Date:   Tue Apr 21 10:54:44 2020 +0200

    writeback: Export inode_io_list_del()
    
    Ext4 needs to remove inode from writeback lists after it is out of
    visibility of its journalling machinery (which can still dirty the
    inode). Export inode_io_list_del() for it.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Link: https://lore.kernel.org/r/20200421085445.5731-3-jack@suse.cz
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/internal.h b/fs/internal.h
index aa5d45524e87..8819d0d58b03 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -143,8 +143,6 @@ extern int dentry_needs_remove_privs(struct dentry *dentry);
 /*
  * fs-writeback.c
  */
-extern void inode_io_list_del(struct inode *inode);
-
 extern long get_nr_dirty_inodes(void);
 extern int invalidate_inodes(struct super_block *, bool);
 

commit 1ee08de1e234d95b5b4f866878b72fceb5372904
Merge: bce159d73409 7b53d59859bc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 2 15:42:50 2020 -0700

    Merge tag 'for-5.8/io_uring-2020-06-01' of git://git.kernel.dk/linux-block
    
    Pull io_uring updates from Jens Axboe:
     "A relatively quiet round, mostly just fixes and code improvements. In
    particular:
    
       - Make statx just use the generic statx handler, instead of open
         coding it. We don't need that anymore, as we always call it async
         safe (Bijan)
    
       - Enable closing of the ring itself. Also fixes O_PATH closure (me)
    
       - Properly name completion members (me)
    
       - Batch reap of dead file registrations (me)
    
       - Allow IORING_OP_POLL with double waitqueues (me)
    
       - Add tee(2) support (Pavel)
    
       - Remove double off read (Pavel)
    
       - Fix overflow cancellations (Pavel)
    
       - Improve CQ timeouts (Pavel)
    
       - Async defer drain fixes (Pavel)
    
       - Add support for enabling/disabling notifications on a registered
         eventfd (Stefano)
    
       - Remove dead state parameter (Xiaoguang)
    
       - Disable SQPOLL submit on dying ctx (Xiaoguang)
    
       - Various code cleanups"
    
    * tag 'for-5.8/io_uring-2020-06-01' of git://git.kernel.dk/linux-block: (29 commits)
      io_uring: fix overflowed reqs cancellation
      io_uring: off timeouts based only on completions
      io_uring: move timeouts flushing to a helper
      statx: hide interfaces no longer used by io_uring
      io_uring: call statx directly
      statx: allow system call to be invoked from io_uring
      io_uring: add io_statx structure
      io_uring: get rid of manual punting in io_close
      io_uring: separate DRAIN flushing into a cold path
      io_uring: don't re-read sqe->off in timeout_prep()
      io_uring: simplify io_timeout locking
      io_uring: fix flush req->refs underflow
      io_uring: don't submit sqes when ctx->refs is dying
      io_uring: async task poll trigger cleanup
      io_uring: add tee(2) support
      splice: export do_tee()
      io_uring: don't repeat valid flag list
      io_uring: rename io_file_put()
      io_uring: remove req->needs_fixed_files
      io_uring: cleanup io_poll_remove_one() logic
      ...

commit 6f88cc176a3358c54bb6c38c8afee3f3a42faf54
Author: Bijan Mottahedeh <bijan.mottahedeh@oracle.com>
Date:   Fri May 22 21:31:19 2020 -0700

    statx: hide interfaces no longer used by io_uring
    
    The io_uring interfaces have been replaced by do_statx() and are no
    longer needed.
    
    Signed-off-by: Bijan Mottahedeh <bijan.mottahedeh@oracle.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/internal.h b/fs/internal.h
index 88a9793f96a1..cf2043c8ac3d 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -186,7 +186,5 @@ int sb_init_dio_done_wq(struct super_block *sb);
 /*
  * fs/stat.c:
  */
-unsigned vfs_stat_set_lookup_flags(unsigned *lookup_flags, int flags);
-int cp_statx(const struct kstat *stat, struct statx __user *buffer);
 int do_statx(int dfd, const char __user *filename, unsigned flags,
 	     unsigned int mask, struct statx __user *buffer);

commit 0018784fc84f636d473a0d2a65a34f9d01893c0a
Author: Bijan Mottahedeh <bijan.mottahedeh@oracle.com>
Date:   Fri May 22 21:31:17 2020 -0700

    statx: allow system call to be invoked from io_uring
    
    This is a prepatory patch to allow io_uring to invoke statx directly.
    
    Signed-off-by: Bijan Mottahedeh <bijan.mottahedeh@oracle.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/internal.h b/fs/internal.h
index aa5d45524e87..88a9793f96a1 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -188,3 +188,5 @@ int sb_init_dio_done_wq(struct super_block *sb);
  */
 unsigned vfs_stat_set_lookup_flags(unsigned *lookup_flags, int flags);
 int cp_statx(const struct kstat *stat, struct statx __user *buffer);
+int do_statx(int dfd, const char __user *filename, unsigned flags,
+	     unsigned int mask, struct statx __user *buffer);

commit c8ffd8bcdd28296a198f237cc595148a8d4adfbe
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu May 14 16:44:25 2020 +0200

    vfs: add faccessat2 syscall
    
    POSIX defines faccessat() as having a fourth "flags" argument, while the
    linux syscall doesn't have it.  Glibc tries to emulate AT_EACCESS and
    AT_SYMLINK_NOFOLLOW, but AT_EACCESS emulation is broken.
    
    Add a new faccessat(2) syscall with the added flags argument and implement
    both flags.
    
    The value of AT_EACCESS is defined in glibc headers to be the same as
    AT_REMOVEDIR.  Use this value for the kernel interface as well, together
    with the explanatory comment.
    
    Also add AT_EMPTY_PATH support, which is not documented by POSIX, but can
    be useful and is trivial to implement.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/internal.h b/fs/internal.h
index aa5d45524e87..0d467e32dd7e 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -126,7 +126,6 @@ extern struct open_how build_open_how(int flags, umode_t mode);
 extern int build_open_flags(const struct open_how *how, struct open_flags *op);
 
 long do_sys_ftruncate(unsigned int fd, loff_t length, int small);
-long do_faccessat(int dfd, const char __user *filename, int mode);
 int do_fchmodat(int dfd, const char __user *filename, umode_t mode);
 int do_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group,
 		int flag);

commit 9c577491b985e1b27995abe69b32b041893798cf
Merge: d987ca1c6b7e 99a4a90c8e93
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 2 12:30:08 2020 -0700

    Merge branch 'work.dotdot1' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs pathwalk sanitizing from Al Viro:
     "Massive pathwalk rewrite and cleanups.
    
      Several iterations have been posted; hopefully this thing is getting
      readable and understandable now. Pretty much all parts of pathname
      resolutions are affected...
    
      The branch is identical to what has sat in -next, except for commit
      message in "lift all calls of step_into() out of follow_dotdot/
      follow_dotdot_rcu", crediting Qian Cai for reporting the bug; only
      commit message changed there."
    
    * 'work.dotdot1' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (69 commits)
      lookup_open(): don't bother with fallbacks to lookup+create
      atomic_open(): no need to pass struct open_flags anymore
      open_last_lookups(): move complete_walk() into do_open()
      open_last_lookups(): lift O_EXCL|O_CREAT handling into do_open()
      open_last_lookups(): don't abuse complete_walk() when all we want is unlazy
      open_last_lookups(): consolidate fsnotify_create() calls
      take post-lookup part of do_last() out of loop
      link_path_walk(): sample parent's i_uid and i_mode for the last component
      __nd_alloc_stack(): make it return bool
      reserve_stack(): switch to __nd_alloc_stack()
      pick_link(): take reserving space on stack into a new helper
      pick_link(): more straightforward handling of allocation failures
      fold path_to_nameidata() into its only remaining caller
      pick_link(): pass it struct path already with normal refcounting rules
      fs/namei.c: kill follow_mount()
      non-RCU analogue of the previous commit
      helper for mount rootwards traversal
      follow_dotdot(): be lazy about changing nd->path
      follow_dotdot_rcu(): be lazy about changing nd->path
      follow_dotdot{,_rcu}(): massage loops
      ...

commit 29125ed624eeb3ac2eb7bca313a8de29c1c84dcd
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Mar 25 16:48:40 2020 +0100

    block: move guard_bio_eod to bio.c
    
    This is bio layer functionality and not related to buffer heads.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/internal.h b/fs/internal.h
index f3f280b952a3..4d37912a5587 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -38,7 +38,6 @@ static inline int __sync_blockdev(struct block_device *bdev, int wait)
 /*
  * buffer.c
  */
-extern void guard_bio_eod(struct bio *bio);
 extern int __block_write_begin_int(struct page *page, loff_t pos, unsigned len,
 		get_block_t *get_block, struct iomap *iomap);
 

commit 161aff1d93abf0e5b5e9dbca88928998c155f677
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 11 22:52:26 2020 -0500

    LOOKUP_MOUNTPOINT: fold path_mountpointat() into path_lookupat()
    
    New LOOKUP flag, telling path_lookupat() to act as path_mountpointat().
    IOW, traverse mounts at the final point and skip revalidation of the
    location where it ends up.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index f3f280b952a3..b108a8eb75ca 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -61,7 +61,6 @@ extern int finish_clean_context(struct fs_context *fc);
  */
 extern int filename_lookup(int dfd, struct filename *name, unsigned flags,
 			   struct path *path, struct path *root);
-extern int user_path_mountpoint_at(int, const char __user *, unsigned int, struct path *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct path *);
 long do_mknodat(int dfd, const char __user *filename, umode_t mode,

commit 896f8d23d0cb5889021d66eab6107e97109c5459
Merge: 33c84e89abe4 3e4827b05d2a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 29 18:53:37 2020 -0800

    Merge tag 'for-5.6/io_uring-vfs-2020-01-29' of git://git.kernel.dk/linux-block
    
    Pull io_uring updates from Jens Axboe:
    
     - Support for various new opcodes (fallocate, openat, close, statx,
       fadvise, madvise, openat2, non-vectored read/write, send/recv, and
       epoll_ctl)
    
     - Faster ring quiesce for fileset updates
    
     - Optimizations for overflow condition checking
    
     - Support for max-sized clamping
    
     - Support for probing what opcodes are supported
    
     - Support for io-wq backend sharing between "sibling" rings
    
     - Support for registering personalities
    
     - Lots of little fixes and improvements
    
    * tag 'for-5.6/io_uring-vfs-2020-01-29' of git://git.kernel.dk/linux-block: (64 commits)
      io_uring: add support for epoll_ctl(2)
      eventpoll: support non-blocking do_epoll_ctl() calls
      eventpoll: abstract out epoll_ctl() handler
      io_uring: fix linked command file table usage
      io_uring: support using a registered personality for commands
      io_uring: allow registering credentials
      io_uring: add io-wq workqueue sharing
      io-wq: allow grabbing existing io-wq
      io_uring/io-wq: don't use static creds/mm assignments
      io-wq: make the io_wq ref counted
      io_uring: fix refcounting with batched allocations at OOM
      io_uring: add comment for drain_next
      io_uring: don't attempt to copy iovec for READ/WRITE
      io_uring: honor IOSQE_ASYNC for linked reqs
      io_uring: prep req when do IOSQE_ASYNC
      io_uring: use labeled array init in io_op_defs
      io_uring: optimise sqe-to-req flags translation
      io_uring: remove REQ_F_IO_DRAINED
      io_uring: file switch work needs to get flushed on exit
      io_uring: hide uring_fd in ctx
      ...

commit 33c84e89abe4a92ab699c33029bd54269d574782
Merge: e9f8ca0ae7b7 11e673206f21
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 29 18:16:16 2020 -0800

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This series is slightly unusual because it includes Arnd's compat
      ioctl tree here:
    
        1c46a2cf2dbd Merge tag 'block-ioctl-cleanup-5.6' into 5.6/scsi-queue
    
      Excluding Arnd's changes, this is mostly an update of the usual
      drivers: megaraid_sas, mpt3sas, qla2xxx, ufs, lpfc, hisi_sas.
    
      There are a couple of core and base updates around error propagation
      and atomicity in the attribute container base we use for the SCSI
      transport classes.
    
      The rest is minor changes and updates"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (149 commits)
      scsi: hisi_sas: Rename hisi_sas_cq.pci_irq_mask
      scsi: hisi_sas: Add prints for v3 hw interrupt converge and automatic affinity
      scsi: hisi_sas: Modify the file permissions of trigger_dump to write only
      scsi: hisi_sas: Replace magic number when handle channel interrupt
      scsi: hisi_sas: replace spin_lock_irqsave/spin_unlock_restore with spin_lock/spin_unlock
      scsi: hisi_sas: use threaded irq to process CQ interrupts
      scsi: ufs: Use UFS device indicated maximum LU number
      scsi: ufs: Add max_lu_supported in struct ufs_dev_info
      scsi: ufs: Delete is_init_prefetch from struct ufs_hba
      scsi: ufs: Inline two functions into their callers
      scsi: ufs: Move ufshcd_get_max_pwr_mode() to ufshcd_device_params_init()
      scsi: ufs: Split ufshcd_probe_hba() based on its called flow
      scsi: ufs: Delete struct ufs_dev_desc
      scsi: ufs: Fix ufshcd_probe_hba() reture value in case ufshcd_scsi_add_wlus() fails
      scsi: ufs-mediatek: enable low-power mode for hibern8 state
      scsi: ufs: export some functions for vendor usage
      scsi: ufs-mediatek: add dbg_register_dump implementation
      scsi: qla2xxx: Fix a NULL pointer dereference in an error path
      scsi: qla1280: Make checking for 64bit support consistent
      scsi: megaraid_sas: Update driver version to 07.713.01.00-rc1
      ...

commit 3934e36f6099e6277db33f433fe135c6644e8ac2
Author: Jens Axboe <axboe@kernel.dk>
Date:   Sat Dec 14 13:26:33 2019 -0700

    fs: make two stat prep helpers available
    
    To implement an async stat, we need to provide the flags mapping and
    the statx user copy. Make them available internally, through
    fs/internal.h.
    
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/internal.h b/fs/internal.h
index c4baf42f8d8a..54e2835c0eba 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -190,3 +190,9 @@ extern int do_vfs_ioctl(struct file *file, unsigned int fd, unsigned int cmd,
 
 /* direct-io.c: */
 int sb_init_dio_done_wq(struct super_block *sb);
+
+/*
+ * fs/stat.c:
+ */
+unsigned vfs_stat_set_lookup_flags(unsigned *lookup_flags, int flags);
+int cp_statx(const struct kstat *stat, struct statx __user *buffer);

commit 35cb6d54c1d5daf1d1ed585ef5ce4557e7ab284c
Author: Jens Axboe <axboe@kernel.dk>
Date:   Fri Dec 13 11:10:11 2019 -0700

    fs: make build_open_flags() available internally
    
    This is a prep patch for supporting non-blocking open from io_uring.
    
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/internal.h b/fs/internal.h
index e3fa69544b66..c4baf42f8d8a 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -124,6 +124,8 @@ extern struct file *do_filp_open(int dfd, struct filename *pathname,
 		const struct open_flags *op);
 extern struct file *do_file_open_root(struct dentry *, struct vfsmount *,
 		const char *, const struct open_flags *);
+extern struct open_how build_open_how(int flags, umode_t mode);
+extern int build_open_flags(const struct open_how *how, struct open_flags *op);
 
 long do_sys_ftruncate(unsigned int fd, loff_t length, int small);
 long do_faccessat(int dfd, const char __user *filename, int mode);

commit 83c9c547168e8b914ea6398430473a4de68c52cc
Author: Ming Lei <ming.lei@redhat.com>
Date:   Sun Jan 5 09:41:14 2020 +0800

    fs: move guard_bio_eod() after bio_set_op_attrs
    
    Commit 85a8ce62c2ea ("block: add bio_truncate to fix guard_bio_eod")
    adds bio_truncate() for handling bio EOD. However, bio_truncate()
    doesn't use the passed 'op' parameter from guard_bio_eod's callers.
    
    So bio_trunacate() may retrieve wrong 'op', and zering pages may
    not be done for READ bio.
    
    Fixes this issue by moving guard_bio_eod() after bio_set_op_attrs()
    in submit_bh_wbc() so that bio_truncate() can always retrieve correct
    op info.
    
    Meantime remove the 'op' parameter from guard_bio_eod() because it isn't
    used any more.
    
    Cc: Carlos Maiolino <cmaiolino@redhat.com>
    Cc: linux-fsdevel@vger.kernel.org
    Fixes: 85a8ce62c2ea ("block: add bio_truncate to fix guard_bio_eod")
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    
    Fold in kerneldoc and bio_op() change.
    
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/internal.h b/fs/internal.h
index 4a7da1df573d..e3fa69544b66 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -38,7 +38,7 @@ static inline int __sync_blockdev(struct block_device *bdev, int wait)
 /*
  * buffer.c
  */
-extern void guard_bio_eod(int rw, struct bio *bio);
+extern void guard_bio_eod(struct bio *bio);
 extern int __block_write_begin_int(struct page *page, loff_t pos, unsigned len,
 		get_block_t *get_block, struct iomap *iomap);
 

commit 77b9040195dea3fcddf19e136c9e99a501351778
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Nov 27 21:25:36 2019 +0100

    compat_ioctl: simplify the implementation
    
    Now that both native and compat ioctl syscalls are
    in the same file, a couple of simplifications can
    be made, bringing the implementation closer together:
    
    - do_vfs_ioctl(), ioctl_preallocate(), and compat_ioctl_preallocate()
      can become static, allowing the compiler to optimize better
    
    - slightly update the coding style for consistency between
      the functions.
    
    - rather than listing each command in two switch statements
      for the compat case, just call a single function that has
      all the common commands.
    
    As a side-effect, FS_IOC_RESVSP/FS_IOC_RESVSP64 are now available
    to x86 compat tasks, along with FS_IOC_RESVSP_32/FS_IOC_RESVSP64_32.
    This is harmless for i386 emulation, and can be considered a bugfix
    for x32 emulation, which never supported these in the past.
    
    Reviewed-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/fs/internal.h b/fs/internal.h
index 4a7da1df573d..d46247850ad7 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -180,11 +180,5 @@ extern void mnt_pin_kill(struct mount *m);
  */
 extern const struct dentry_operations ns_dentry_operations;
 
-/*
- * fs/ioctl.c
- */
-extern int do_vfs_ioctl(struct file *file, unsigned int fd, unsigned int cmd,
-		    unsigned long arg);
-
 /* direct-io.c: */
 int sb_init_dio_done_wq(struct super_block *sb);

commit 5c8b0dfc6f4a5e6c707827d0172fc1572e689094
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 25 14:08:24 2019 -0400

    make __d_alloc() static
    
    no users outside of fs/dcache.c
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 315fcd8d237c..4a7da1df573d 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -151,7 +151,6 @@ extern int invalidate_inodes(struct super_block *, bool);
 /*
  * dcache.c
  */
-extern struct dentry *__d_alloc(struct super_block *, const struct qstr *);
 extern int d_set_mounted(struct dentry *dentry);
 extern long prune_dcache_sb(struct super_block *sb, struct shrink_control *sc);
 extern struct dentry *d_alloc_cursor(struct dentry *);

commit 18253e034d2aeee140f82fc9fe89c4bce5c81799
Merge: abdfd52a295f 56cbb429d911
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 20 09:15:51 2019 -0700

    Merge branch 'work.dcache2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull dcache and mountpoint updates from Al Viro:
     "Saner handling of refcounts to mountpoints.
    
      Transfer the counting reference from struct mount ->mnt_mountpoint
      over to struct mountpoint ->m_dentry. That allows us to get rid of the
      convoluted games with ordering of mount shutdowns.
    
      The cost is in teaching shrink_dcache_{parent,for_umount} to cope with
      mixed-filesystem shrink lists, which we'll also need for the Slab
      Movable Objects patchset"
    
    * 'work.dcache2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      switch the remnants of releasing the mountpoint away from fs_pin
      get rid of detach_mnt()
      make struct mountpoint bear the dentry reference to mountpoint, not struct mount
      Teach shrink_dcache_parent() to cope with mixed-filesystem shrink lists
      fs/namespace.c: shift put_mountpoint() to callers of unhash_mnt()
      __detach_mounts(): lookup_mountpoint() can't return ERR_PTR() anymore
      nfs: dget_parent() never returns NULL
      ceph: don't open-code the check for dead lockref

commit 26473f83703e6bc56114ce4b045000de6efcfff7
Merge: 4f5ed1318c01 5d907307adc1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 19 11:38:12 2019 -0700

    Merge tag 'iomap-5.3-merge-4' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux
    
    Pull iomap split/cleanup from Darrick Wong:
     "As promised, here's the second part of the iomap merge for 5.3, in
      which we break up iomap.c into smaller files grouped by functional
      area so that it'll be easier in the long run to maintain cohesiveness
      of code units and to review incoming patches. There are no functional
      changes and fs/iomap.c split cleanly.
    
      Summary:
    
       - Regroup the fs/iomap.c code by major functional area so that we can
         start development for 5.4 from a more stable base"
    
    * tag 'iomap-5.3-merge-4' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux:
      iomap: move internal declarations into fs/iomap/
      iomap: move the main iteration code into a separate file
      iomap: move the buffered IO code into a separate file
      iomap: move the direct IO code into a separate file
      iomap: move the SEEK_HOLE code into a separate file
      iomap: move the file mapping reporting code into a separate file
      iomap: move the swapfile code into a separate file
      iomap: start moving code to fs/iomap/

commit 933a90bf4f3505f8ec83bda21a3c7d70d7c2b426
Merge: 5f4fc6d440d7 037f11b4752f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 19 10:42:02 2019 -0700

    Merge branch 'work.mount0' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs mount updates from Al Viro:
     "The first part of mount updates.
    
      Convert filesystems to use the new mount API"
    
    * 'work.mount0' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (63 commits)
      mnt_init(): call shmem_init() unconditionally
      constify ksys_mount() string arguments
      don't bother with registering rootfs
      init_rootfs(): don't bother with init_ramfs_fs()
      vfs: Convert smackfs to use the new mount API
      vfs: Convert selinuxfs to use the new mount API
      vfs: Convert securityfs to use the new mount API
      vfs: Convert apparmorfs to use the new mount API
      vfs: Convert openpromfs to use the new mount API
      vfs: Convert xenfs to use the new mount API
      vfs: Convert gadgetfs to use the new mount API
      vfs: Convert oprofilefs to use the new mount API
      vfs: Convert ibmasmfs to use the new mount API
      vfs: Convert qib_fs/ipathfs to use the new mount API
      vfs: Convert efivarfs to use the new mount API
      vfs: Convert configfs to use the new mount API
      vfs: Convert binfmt_misc to use the new mount API
      convenience helper: get_tree_single()
      convenience helper get_tree_nodev()
      vfs: Kill sget_userns()
      ...

commit 5d907307adc14cd5148b07629c2b4535acd06062
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Mon Jul 15 08:51:01 2019 -0700

    iomap: move internal declarations into fs/iomap/
    
    Move internal function declarations out of fs/internal.h into
    include/linux/iomap.h so that our transition is complete.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/internal.h b/fs/internal.h
index 2f3c3de51fad..2b0bebd67904 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -182,15 +182,5 @@ extern const struct dentry_operations ns_dentry_operations;
 extern int do_vfs_ioctl(struct file *file, unsigned int fd, unsigned int cmd,
 		    unsigned long arg);
 
-/*
- * iomap support:
- */
-typedef loff_t (*iomap_actor_t)(struct inode *inode, loff_t pos, loff_t len,
-		void *data, struct iomap *iomap);
-
-loff_t iomap_apply(struct inode *inode, loff_t pos, loff_t length,
-		unsigned flags, const struct iomap_ops *ops, void *data,
-		iomap_actor_t actor);
-
 /* direct-io.c: */
 int sb_init_dio_done_wq(struct super_block *sb);

commit 9bdebc2bd1c4abfbf44dc154cc152ec333e004de
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jun 29 18:31:24 2019 -0400

    Teach shrink_dcache_parent() to cope with mixed-filesystem shrink lists
    
    Currently, running into a shrink list that contains dentries from different
    filesystems can cause several unpleasant things for shrink_dcache_parent()
    and for umount(2).
    
    The first problem is that there's a window during shrink_dentry_list() between
    __dentry_kill() takes a victim out and dropping reference to its parent.  During
    that window the parent looks like a genuine busy dentry.  shrink_dcache_parent()
    (or, worse yet, shrink_dcache_for_umount()) coming at that time will see no
    eviction candidates and no indication that it needs to wait for some
    shrink_dentry_list() to proceed further.
    
    That applies for any shrink list that might intersect with the subtree we are
    trying to shrink; the only reason it does not blow on umount(2) in the mainline
    is that we unregister the memory shrinker before hitting shrink_dcache_for_umount().
    
    Another problem happens if something in a mixed-filesystem shrink list gets
    be stuck in e.g. iput(), getting umount of unrelated fs to spin waiting for
    the stuck shrinker to get around to our dentries.
    
    Solution:
            1) have shrink_dentry_list() decrement the parent's refcount and
    make sure it's on a shrink list (ours unless it already had been on some
    other) before calling __dentry_kill().  That eliminates the window when
    shrink_dcache_parent() would've blown past the entire subtree without
    noticing anything with zero refcount not on shrink lists.
            2) when shrink_dcache_parent() has found no eviction candidates,
    but some dentries are still sitting on shrink lists, rather than
    repeating the scan in hope that shrinkers have progressed, scan looking
    for something on shrink lists with zero refcount.  If such a thing is
    found, grab rcu_read_lock() and stop the scan, with caller locking
    it for eviction, dropping out of RCU and doing __dentry_kill(), with
    the same treatment for parent as shrink_dentry_list() would do.
    
    Note that right now mixed-filesystem shrink lists do not occur, so this
    is not a mainline bug.  Howevere, there's a bunch of uses for such
    beasts (e.g. the "try and evict everything we can out of given page"
    patches; there are potential uses in mount-related code, considerably
    simplifying the life in fs/namespace.c, etc.)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index a48ef81be37d..dc317abe31b5 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -156,6 +156,8 @@ extern int d_set_mounted(struct dentry *dentry);
 extern long prune_dcache_sb(struct super_block *sb, struct shrink_control *sc);
 extern struct dentry *d_alloc_cursor(struct dentry *);
 extern struct dentry * d_alloc_pseudo(struct super_block *, const struct qstr *);
+extern void dput_to_list(struct dentry *, struct list_head *);
+extern void shrink_dentry_list(struct list_head *);
 
 /*
  * read_write.c

commit 8af54f291e5cfdb215e0b3045cc365954c55855d
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Jun 27 17:28:40 2019 -0700

    fs: fold __generic_write_end back into generic_write_end
    
    This effectively reverts a6d639da63ae ("fs: factor out a
    __generic_write_end helper") as we now open code what is left of that
    helper in iomap.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/fs/internal.h b/fs/internal.h
index a48ef81be37d..2f3c3de51fad 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -40,8 +40,6 @@ static inline int __sync_blockdev(struct block_device *bdev, int wait)
 extern void guard_bio_eod(int rw, struct bio *bio);
 extern int __block_write_begin_int(struct page *page, loff_t pos, unsigned len,
 		get_block_t *get_block, struct iomap *iomap);
-void __generic_write_end(struct inode *inode, loff_t pos, unsigned copied,
-		struct page *page);
 
 /*
  * char_dev.c

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/internal.h b/fs/internal.h
index 0010889f2e85..a48ef81be37d 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -1,12 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* fs/ internal definitions
  *
  * Copyright (C) 2006 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
  */
 
 struct super_block;

commit 20284ab7427ffac514faf44fd9eb50e5745f4474
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun May 12 17:31:45 2019 -0400

    switch mount_capable() to fs_context
    
            now both callers of mount_capable() have access to fs_context;
    the only difference is that for sget_fc() we have the possibility
    of fc->global being true, while for legacy_get_tree() it's guaranteed
    to be impossible.  Unify to more generic variant...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 65db901420af..b089a489da1f 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -114,7 +114,7 @@ extern struct file *alloc_empty_file_noaccount(int, const struct cred *);
 extern int reconfigure_super(struct fs_context *);
 extern bool trylock_super(struct super_block *sb);
 extern struct super_block *user_get_super(dev_t);
-extern bool mount_capable(struct file_system_type *, struct user_namespace *);
+extern bool mount_capable(struct fs_context *);
 
 /*
  * open.c

commit 2527b284defaeadf74829b0b0bd3207ca7f165eb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun May 12 17:09:01 2019 -0400

    move the capability checks from sget_userns() to legacy_get_tree()
    
    1) all call chains leading to sget_userns() pass through ->mount()
    instances.
    2) none of ->mount() instances is ever called directly - the only
    call site is legacy_get_tree()
    3) all remaining ->mount() instances end up calling sget_userns()
    
    IOW, we might as well do the capability checks just before calling
    ->mount().  As for the arguments passed to mount_capable(),
    in case of call chains to sget_userns() going through sget(),
    we either don't call mount_capable() at all, or pass current_user_ns()
    to it.  The call chains going through mount_pseudo_xattr() don't
    call mount_capable() at all (SB_KERNMOUNT in flags on those).
    
    That could've been split into smaller steps (lifting the checks
    into sget(), then callers of sget(), then all the way to the
    entries of every ->mount() out there, then to the sole caller),
    but that would be too much churn for little benefit...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 1ac2b8f6c621..65db901420af 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -18,6 +18,7 @@ struct path;
 struct mount;
 struct shrink_control;
 struct fs_context;
+struct user_namespace;
 
 /*
  * block_dev.c
@@ -113,6 +114,7 @@ extern struct file *alloc_empty_file_noaccount(int, const struct cred *);
 extern int reconfigure_super(struct fs_context *);
 extern bool trylock_super(struct super_block *sb);
 extern struct super_block *user_get_super(dev_t);
+extern bool mount_capable(struct file_system_type *, struct user_namespace *);
 
 /*
  * open.c

commit 7e5f7bb08b8cefd3a7e8961861f47fe1f0e830d4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon May 20 13:44:57 2019 +0100

    unexport simple_dname()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 0010889f2e85..1ac2b8f6c621 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -160,6 +160,7 @@ extern int d_set_mounted(struct dentry *dentry);
 extern long prune_dcache_sb(struct super_block *sb, struct shrink_control *sc);
 extern struct dentry *d_alloc_cursor(struct dentry *);
 extern struct dentry * d_alloc_pseudo(struct super_block *, const struct qstr *);
+extern char *simple_dname(struct dentry *, char *, int);
 
 /*
  * read_write.c

commit 400913252d09f9cfb8cce33daee43167921fc343
Merge: d27fb65bc238 f1b5618e013a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 20:17:51 2019 -0700

    Merge branch 'work.mount-syscalls' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull mount ABI updates from Al Viro:
     "The syscalls themselves, finally.
    
      That's not all there is to that stuff, but switching individual
      filesystems to new methods is fortunately independent from everything
      else, so e.g. NFS series can go through NFS tree, etc.
    
      As those conversions get done, we'll be finally able to get rid of a
      bunch of duplication in fs/super.c introduced in the beginning of the
      entire thing. I expect that to be finished in the next window..."
    
    * 'work.mount-syscalls' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      vfs: Add a sample program for the new mount API
      vfs: syscall: Add fspick() to select a superblock for reconfiguration
      vfs: syscall: Add fsmount() to create a mount for a superblock
      vfs: syscall: Add fsconfig() for configuring and managing a context
      vfs: Implement logging through fs_context
      vfs: syscall: Add fsopen() to prepare for superblock creation
      Make anon_inodes unconditional
      teach move_mount(2) to work with OPEN_TREE_CLONE
      vfs: syscall: Add move_mount(2) to move mounts around
      vfs: syscall: Add open_tree(2) to reference or clone a mount

commit d27fb65bc2389621040e5107baedb94b4cccf641
Merge: d3511f53bb24 795d673af1af
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 20:03:32 2019 -0700

    Merge branch 'work.dcache' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc dcache updates from Al Viro:
     "Most of this pile is putting name length into struct name_snapshot and
      making use of it.
    
      The beginning of this series ("ovl_lookup_real_one(): don't bother
      with strlen()") ought to have been split in two (separate switch of
      name_snapshot to struct qstr from overlayfs reaping the trivial
      benefits of that), but I wanted to avoid a rebase - by the time I'd
      spotted that it was (a) in -next and (b) close to 5.1-final ;-/"
    
    * 'work.dcache' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      audit_compare_dname_path(): switch to const struct qstr *
      audit_update_watch(): switch to const struct qstr *
      inotify_handle_event(): don't bother with strlen()
      fsnotify: switch send_to_group() and ->handle_event to const struct qstr *
      fsnotify(): switch to passing const struct qstr * for file_name
      switch fsnotify_move() to passing const struct qstr * for old_name
      ovl_lookup_real_one(): don't bother with strlen()
      sysv: bury the broken "quietly truncate the long filenames" logics
      nsfs: unobfuscate
      unexport d_alloc_pseudo()

commit d8456eaf319a27d33186f1091bc1ff5c59cf0f0d
Merge: b8cac3cd24c1 cbbf4c0be8a7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 11:43:32 2019 -0700

    Merge tag 'iomap-5.2-merge-2' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux
    
    Pull iomap updates from Darrick Wong:
     "Nothing particularly exciting here, just adding some callouts for gfs2
      and cleaning a few things.
    
      Summary:
    
       - Add some extra hooks to the iomap buffered write path to enable
         gfs2 journalled writes
    
       - SPDX conversion
    
       - Various refactoring"
    
    * tag 'iomap-5.2-merge-2' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux:
      iomap: move iomap_read_inline_data around
      iomap: Add a page_prepare callback
      iomap: Fix use-after-free error in page_done callback
      fs: Turn __generic_write_end into a void function
      iomap: Clean up __generic_write_end calling
      iomap: convert to SPDX identifier

commit 26ddb1f4fd884258eeb8a8d7f2d40b163f00fedd
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Tue Apr 30 08:45:33 2019 -0700

    fs: Turn __generic_write_end into a void function
    
    The VFS-internal __generic_write_end helper always returns the value of
    its @copied argument.  This can be confusing, and it isn't very useful
    anyway, so turn __generic_write_end into a function returning void
    instead.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/fs/internal.h b/fs/internal.h
index 6a8b71643af4..530587fdf5d8 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -44,7 +44,7 @@ static inline int __sync_blockdev(struct block_device *bdev, int wait)
 extern void guard_bio_eod(int rw, struct bio *bio);
 extern int __block_write_begin_int(struct page *page, loff_t pos, unsigned len,
 		get_block_t *get_block, struct iomap *iomap);
-int __generic_write_end(struct inode *inode, loff_t pos, unsigned copied,
+void __generic_write_end(struct inode *inode, loff_t pos, unsigned copied,
 		struct page *page);
 
 /*

commit ab1152dd5650d35da6f0f6d3c0cc18f86fdc0725
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 15 22:58:11 2019 -0400

    unexport d_alloc_pseudo()
    
    No modular uses since introducion of alloc_file_pseudo(),
    and the only non-modular user not in alloc_file_pseudo()
    had actually been wrong - should've been d_alloc_anon().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 2e7362837a6e..8102032432cf 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -155,6 +155,7 @@ extern struct dentry *__d_alloc(struct super_block *, const struct qstr *);
 extern int d_set_mounted(struct dentry *dentry);
 extern long prune_dcache_sb(struct super_block *sb, struct shrink_control *sc);
 extern struct dentry *d_alloc_cursor(struct dentry *);
+extern struct dentry * d_alloc_pseudo(struct super_block *, const struct qstr *);
 
 /*
  * read_write.c

commit 9419a3191dcb27f24478d288abaab697228d28e6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Apr 4 21:04:13 2019 -0400

    acct_on(): don't mess with freeze protection
    
    What happens there is that we are replacing file->path.mnt of
    a file we'd just opened with a clone and we need the write
    count contribution to be transferred from original mount to
    new one.  That's it.  We do *NOT* want any kind of freeze
    protection for the duration of switchover.
    
    IOW, we should just use __mnt_{want,drop}_write() for that
    switchover; no need to bother with mnt_{want,drop}_write()
    there.
    
    Tested-by: Amir Goldstein <amir73il@gmail.com>
    Reported-by: syzbot+2a73a6ea9507b7112141@syzkaller.appspotmail.com
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 6a8b71643af4..2e7362837a6e 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -89,9 +89,7 @@ extern int sb_prepare_remount_readonly(struct super_block *);
 
 extern void __init mnt_init(void);
 
-extern int __mnt_want_write(struct vfsmount *);
 extern int __mnt_want_write_file(struct file *);
-extern void __mnt_drop_write(struct vfsmount *);
 extern void __mnt_drop_write_file(struct file *);
 
 /*

commit ecdab150fddb42fe6a739335257949220033b782
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:36:09 2018 +0000

    vfs: syscall: Add fsconfig() for configuring and managing a context
    
    Add a syscall for configuring a filesystem creation context and triggering
    actions upon it, to be used in conjunction with fsopen, fspick and fsmount.
    
        long fsconfig(int fs_fd, unsigned int cmd, const char *key,
                      const void *value, int aux);
    
    Where fs_fd indicates the context, cmd indicates the action to take, key
    indicates the parameter name for parameter-setting actions and, if needed,
    value points to a buffer containing the value and aux can give more
    information for the value.
    
    The following command IDs are proposed:
    
     (*) FSCONFIG_SET_FLAG: No value is specified.  The parameter must be
         boolean in nature.  The key may be prefixed with "no" to invert the
         setting. value must be NULL and aux must be 0.
    
     (*) FSCONFIG_SET_STRING: A string value is specified.  The parameter can
         be expecting boolean, integer, string or take a path.  A conversion to
         an appropriate type will be attempted (which may include looking up as
         a path).  value points to a NUL-terminated string and aux must be 0.
    
     (*) FSCONFIG_SET_BINARY: A binary blob is specified.  value points to
         the blob and aux indicates its size.  The parameter must be expecting
         a blob.
    
     (*) FSCONFIG_SET_PATH: A non-empty path is specified.  The parameter must
         be expecting a path object.  value points to a NUL-terminated string
         that is the path and aux is a file descriptor at which to start a
         relative lookup or AT_FDCWD.
    
     (*) FSCONFIG_SET_PATH_EMPTY: As fsconfig_set_path, but with AT_EMPTY_PATH
         implied.
    
     (*) FSCONFIG_SET_FD: An open file descriptor is specified.  value must
         be NULL and aux indicates the file descriptor.
    
     (*) FSCONFIG_CMD_CREATE: Trigger superblock creation.
    
     (*) FSCONFIG_CMD_RECONFIGURE: Trigger superblock reconfiguration.
    
    For the "set" command IDs, the idea is that the file_system_type will point
    to a list of parameters and the types of value that those parameters expect
    to take.  The core code can then do the parse and argument conversion and
    then give the LSM and FS a cooked option or array of options to use.
    
    Source specification is also done the same way same way, using special keys
    "source", "source1", "source2", etc..
    
    [!] Note that, for the moment, the key and value are just glued back
    together and handed to the filesystem.  Every filesystem that uses options
    uses match_token() and co. to do this, and this will need to be changed -
    but not all at once.
    
    Example usage:
    
        fd = fsopen("ext4", FSOPEN_CLOEXEC);
        fsconfig(fd, fsconfig_set_path, "source", "/dev/sda1", AT_FDCWD);
        fsconfig(fd, fsconfig_set_path_empty, "journal_path", "", journal_fd);
        fsconfig(fd, fsconfig_set_fd, "journal_fd", "", journal_fd);
        fsconfig(fd, fsconfig_set_flag, "user_xattr", NULL, 0);
        fsconfig(fd, fsconfig_set_flag, "noacl", NULL, 0);
        fsconfig(fd, fsconfig_set_string, "sb", "1", 0);
        fsconfig(fd, fsconfig_set_string, "errors", "continue", 0);
        fsconfig(fd, fsconfig_set_string, "data", "journal", 0);
        fsconfig(fd, fsconfig_set_string, "context", "unconfined_u:...", 0);
        fsconfig(fd, fsconfig_cmd_create, NULL, NULL, 0);
        mfd = fsmount(fd, FSMOUNT_CLOEXEC, MS_NOEXEC);
    
    or:
    
        fd = fsopen("ext4", FSOPEN_CLOEXEC);
        fsconfig(fd, fsconfig_set_string, "source", "/dev/sda1", 0);
        fsconfig(fd, fsconfig_cmd_create, NULL, NULL, 0);
        mfd = fsmount(fd, FSMOUNT_CLOEXEC, MS_NOEXEC);
    
    or:
    
        fd = fsopen("afs", FSOPEN_CLOEXEC);
        fsconfig(fd, fsconfig_set_string, "source", "#grand.central.org:root.cell", 0);
        fsconfig(fd, fsconfig_cmd_create, NULL, NULL, 0);
        mfd = fsmount(fd, FSMOUNT_CLOEXEC, MS_NOEXEC);
    
    or:
    
        fd = fsopen("jffs2", FSOPEN_CLOEXEC);
        fsconfig(fd, fsconfig_set_string, "source", "mtd0", 0);
        fsconfig(fd, fsconfig_cmd_create, NULL, NULL, 0);
        mfd = fsmount(fd, FSMOUNT_CLOEXEC, MS_NOEXEC);
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-api@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index f3a027c44758..95cf7b0af21f 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -55,8 +55,11 @@ extern void __init chrdev_init(void);
 /*
  * fs_context.c
  */
+extern const struct fs_context_operations legacy_fs_context_ops;
 extern int parse_monolithic_mount_data(struct fs_context *, void *);
 extern void fc_drop_locked(struct fs_context *);
+extern void vfs_clean_context(struct fs_context *fc);
+extern int finish_clean_context(struct fs_context *fc);
 
 /*
  * namei.c

commit a07b20004793d8926f78d63eb5980559f7813404
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 5 17:40:30 2018 +0000

    vfs: syscall: Add open_tree(2) to reference or clone a mount
    
    open_tree(dfd, pathname, flags)
    
    Returns an O_PATH-opened file descriptor or an error.
    dfd and pathname specify the location to open, in usual
    fashion (see e.g. fstatat(2)).  flags should be an OR of
    some of the following:
            * AT_PATH_EMPTY, AT_NO_AUTOMOUNT, AT_SYMLINK_NOFOLLOW -
    same meanings as usual
            * OPEN_TREE_CLOEXEC - make the resulting descriptor
    close-on-exec
            * OPEN_TREE_CLONE or OPEN_TREE_CLONE | AT_RECURSIVE -
    instead of opening the location in question, create a detached
    mount tree matching the subtree rooted at location specified by
    dfd/pathname.  With AT_RECURSIVE the entire subtree is cloned,
    without it - only the part within in the mount containing the
    location in question.  In other words, the same as mount --rbind
    or mount --bind would've taken.  The detached tree will be
    dissolved on the final close of obtained file.  Creation of such
    detached trees requires the same capabilities as doing mount --bind.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-api@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 6a8b71643af4..f3a027c44758 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -94,6 +94,7 @@ extern int __mnt_want_write_file(struct file *);
 extern void __mnt_drop_write(struct vfsmount *);
 extern void __mnt_drop_write_file(struct file *);
 
+extern void dissolve_on_fput(struct vfsmount *);
 /*
  * fs_struct.c
  */

commit 31d921c7fb9691722ba9503b64153cdc322a7fa8
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:07:24 2018 +0000

    vfs: Add configuration parser helpers
    
    Because the new API passes in key,value parameters, match_token() cannot be
    used with it.  Instead, provide three new helpers to aid with parsing:
    
     (1) fs_parse().  This takes a parameter and a simple static description of
         all the parameters and maps the key name to an ID.  It returns 1 on a
         match, 0 on no match if unknowns should be ignored and some other
         negative error code on a parse error.
    
         The parameter description includes a list of key names to IDs, desired
         parameter types and a list of enumeration name -> ID mappings.
    
         [!] Note that for the moment I've required that the key->ID mapping
         array is expected to be sorted and unterminated.  The size of the
         array is noted in the fsconfig_parser struct.  This allows me to use
         bsearch(), but I'm not sure any performance gain is worth the hassle
         of requiring people to keep the array sorted.
    
         The parameter type array is sized according to the number of parameter
         IDs and is indexed directly.  The optional enum mapping array is an
         unterminated, unsorted list and the size goes into the fsconfig_parser
         struct.
    
         The function can do some additional things:
    
            (a) If it's not ambiguous and no value is given, the prefix "no" on
                a key name is permitted to indicate that the parameter should
                be considered negatory.
    
            (b) If the desired type is a single simple integer, it will perform
                an appropriate conversion and store the result in a union in
                the parse result.
    
            (c) If the desired type is an enumeration, {key ID, name} will be
                looked up in the enumeration list and the matching value will
                be stored in the parse result union.
    
            (d) Optionally generate an error if the key is unrecognised.
    
         This is called something like:
    
            enum rdt_param {
                    Opt_cdp,
                    Opt_cdpl2,
                    Opt_mba_mpbs,
                    nr__rdt_params
            };
    
            const struct fs_parameter_spec rdt_param_specs[nr__rdt_params] = {
                    [Opt_cdp]       = { fs_param_is_bool },
                    [Opt_cdpl2]     = { fs_param_is_bool },
                    [Opt_mba_mpbs]  = { fs_param_is_bool },
            };
    
            const const char *const rdt_param_keys[nr__rdt_params] = {
                    [Opt_cdp]       = "cdp",
                    [Opt_cdpl2]     = "cdpl2",
                    [Opt_mba_mpbs]  = "mba_mbps",
            };
    
            const struct fs_parameter_description rdt_parser = {
                    .name           = "rdt",
                    .nr_params      = nr__rdt_params,
                    .keys           = rdt_param_keys,
                    .specs          = rdt_param_specs,
                    .no_source      = true,
            };
    
            int rdt_parse_param(struct fs_context *fc,
                                struct fs_parameter *param)
            {
                    struct fs_parse_result parse;
                    struct rdt_fs_context *ctx = rdt_fc2context(fc);
                    int ret;
    
                    ret = fs_parse(fc, &rdt_parser, param, &parse);
                    if (ret < 0)
                            return ret;
    
                    switch (parse.key) {
                    case Opt_cdp:
                            ctx->enable_cdpl3 = true;
                            return 0;
                    case Opt_cdpl2:
                            ctx->enable_cdpl2 = true;
                            return 0;
                    case Opt_mba_mpbs:
                            ctx->enable_mba_mbps = true;
                            return 0;
                    }
    
                    return -EINVAL;
            }
    
     (2) fs_lookup_param().  This takes a { dirfd, path, LOOKUP_EMPTY? } or
         string value and performs an appropriate path lookup to convert it
         into a path object, which it will then return.
    
         If the desired type was a blockdev, the type of the looked up inode
         will be checked to make sure it is one.
    
         This can be used like:
    
            enum foo_param {
                    Opt_source,
                    nr__foo_params
            };
    
            const struct fs_parameter_spec foo_param_specs[nr__foo_params] = {
                    [Opt_source]    = { fs_param_is_blockdev },
            };
    
            const char *char foo_param_keys[nr__foo_params] = {
                    [Opt_source]    = "source",
            };
    
            const struct constant_table foo_param_alt_keys[] = {
                    { "device",     Opt_source },
            };
    
            const struct fs_parameter_description foo_parser = {
                    .name           = "foo",
                    .nr_params      = nr__foo_params,
                    .nr_alt_keys    = ARRAY_SIZE(foo_param_alt_keys),
                    .keys           = foo_param_keys,
                    .alt_keys       = foo_param_alt_keys,
                    .specs          = foo_param_specs,
            };
    
            int foo_parse_param(struct fs_context *fc,
                                struct fs_parameter *param)
            {
                    struct fs_parse_result parse;
                    struct foo_fs_context *ctx = foo_fc2context(fc);
                    int ret;
    
                    ret = fs_parse(fc, &foo_parser, param, &parse);
                    if (ret < 0)
                            return ret;
    
                    switch (parse.key) {
                    case Opt_source:
                            return fs_lookup_param(fc, &foo_parser, param,
                                                   &parse, &ctx->source);
                    default:
                            return -EINVAL;
                    }
            }
    
     (3) lookup_constant().  This takes a table of named constants and looks up
         the given name within it.  The table is expected to be sorted such
         that bsearch() be used upon it.
    
         Possibly I should require the table be terminated and just use a
         for-loop to scan it instead of using bsearch() to reduce hassle.
    
         Tables look something like:
    
            static const struct constant_table bool_names[] = {
                    { "0",          false },
                    { "1",          true },
                    { "false",      false },
                    { "no",         false },
                    { "true",       true },
                    { "yes",        true },
            };
    
         and a lookup is done with something like:
    
            b = lookup_constant(bool_names, param->string, -1);
    
    Additionally, optional validation routines for the parameter description
    are provided that can be enabled at compile time.  A later patch will
    invoke these when a filesystem is registered.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 8f8d07cc433f..6a8b71643af4 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -61,6 +61,8 @@ extern void fc_drop_locked(struct fs_context *);
 /*
  * namei.c
  */
+extern int filename_lookup(int dfd, struct filename *name, unsigned flags,
+			   struct path *path, struct path *root);
 extern int user_path_mountpoint_at(int, const char __user *, unsigned int, struct path *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct path *);

commit f3a09c92018a91ad0981146a4ac59414f814d801
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Dec 23 18:55:56 2018 -0500

    introduce fs_context methods
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 016a5b8dd305..8f8d07cc433f 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -55,8 +55,6 @@ extern void __init chrdev_init(void);
 /*
  * fs_context.c
  */
-extern int legacy_get_tree(struct fs_context *fc);
-extern int legacy_reconfigure(struct fs_context *fc);
 extern int parse_monolithic_mount_data(struct fs_context *, void *);
 extern void fc_drop_locked(struct fs_context *);
 

commit 8d0347f6c3a9d4953ddd636a31c6584da082e084
Author: David Howells <dhowells@redhat.com>
Date:   Sun Nov 4 09:28:36 2018 -0500

    convert do_remount_sb() to fs_context
    
    Replace do_remount_sb() with a function, reconfigure_super(), that's
    fs_context aware.  The fs_context is expected to be parameterised already
    and have ->root pointing to the superblock to be reconfigured.
    
    A legacy wrapper is provided that is intended to be called from the
    fs_context ops when those appear, but for now is called directly from
    reconfigure_super().  This wrapper invokes the ->remount_fs() superblock op
    for the moment.  It is intended that the remount_fs() op will be phased
    out.
    
    The fs_context->purpose is set to FS_CONTEXT_FOR_RECONFIGURE to indicate
    that the context is being used for reconfiguration.
    
    do_umount_root() is provided to consolidate remount-to-R/O for umount and
    emergency remount by creating a context and invoking reconfiguration.
    
    do_remount(), do_umount() and do_emergency_remount_callback() are switched
    to use the new process.
    
    [AV -- fold UMOUNT and EMERGENCY_REMOUNT in; fixes the
    umount / bug, gets rid of pointless complexity]
    [AV -- set ->net_ns in all cases; nfs remount will need that]
    [AV -- shift security_sb_remount() call into reconfigure_super(); the callers
    that didn't do security_sb_remount() have NULL fc->security anyway, so it's
    a no-op for them]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Co-developed-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 6af26d897034..016a5b8dd305 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -56,6 +56,7 @@ extern void __init chrdev_init(void);
  * fs_context.c
  */
 extern int legacy_get_tree(struct fs_context *fc);
+extern int legacy_reconfigure(struct fs_context *fc);
 extern int parse_monolithic_mount_data(struct fs_context *, void *);
 extern void fc_drop_locked(struct fs_context *);
 
@@ -107,7 +108,7 @@ extern struct file *alloc_empty_file_noaccount(int, const struct cred *);
 /*
  * super.c
  */
-extern int do_remount_sb(struct super_block *, int, void *, int);
+extern int reconfigure_super(struct fs_context *);
 extern bool trylock_super(struct super_block *sb);
 extern struct super_block *user_get_super(dev_t);
 

commit c9ce29ed795fae86e594844857fad1b0d3be85f4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 20 15:04:50 2018 -0500

    vfs_get_tree(): evict the call of security_sb_kern_mount()
    
    Right now vfs_get_tree() calls security_sb_kern_mount() (i.e.
    mount MAC) unless it gets MS_KERNMOUNT or MS_SUBMOUNT in flags.
    Doing it that way is both clumsy and imprecise.
    
    Consider the callers' tree of vfs_get_tree():
    vfs_get_tree()
            <- do_new_mount()
            <- vfs_kern_mount()
                    <- simple_pin_fs()
                    <- vfs_submount()
                    <- kern_mount_data()
                    <- init_mount_tree()
                    <- btrfs_mount()
                            <- vfs_get_tree()
                    <- nfs_do_root_mount()
                            <- nfs4_try_mount()
                                    <- nfs_fs_mount()
                                            <- vfs_get_tree()
                            <- nfs4_referral_mount()
    
    do_new_mount() always does need MAC (we are guaranteed that neither
    MS_KERNMOUNT nor MS_SUBMOUNT will be passed there).
    
    simple_pin_fs(), vfs_submount() and kern_mount_data() pass explicit
    flags inhibiting that check.  So does nfs4_referral_mount() (the
    flags there are ulimately coming from vfs_submount()).
    
    init_mount_tree() is called too early for anything LSM-related; it
    doesn't matter whether we attempt those checks, they'll do nothing.
    
    Finally, in case of btrfs_mount() and nfs_fs_mount(), doing MAC
    is pointless - either the caller will do it, or the flags are
    such that we wouldn't have done it either.
    
    In other words, the one and only case when we want that check
    done is when we are called from do_new_mount(), and there we
    want it unconditionally.
    
    So let's simply move it there.  The superblock is still locked,
    so nobody is going to get access to it (via ustat(2), etc.)
    until we get a chance to apply the checks - we are free to
    move them to any point up to where we drop ->s_umount (in
    do_new_mount_fc()).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index f85c3212d25d..6af26d897034 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -57,6 +57,7 @@ extern void __init chrdev_init(void);
  */
 extern int legacy_get_tree(struct fs_context *fc);
 extern int parse_monolithic_mount_data(struct fs_context *, void *);
+extern void fc_drop_locked(struct fs_context *);
 
 /*
  * namei.c

commit 9bc61ab18b1d41f26dc06b9e6d3c203e65f83fe6
Author: David Howells <dhowells@redhat.com>
Date:   Sun Nov 4 03:19:03 2018 -0500

    vfs: Introduce fs_context, switch vfs_kern_mount() to it.
    
    Introduce a filesystem context concept to be used during superblock
    creation for mount and superblock reconfiguration for remount.  This is
    allocated at the beginning of the mount procedure and into it is placed:
    
     (1) Filesystem type.
    
     (2) Namespaces.
    
     (3) Source/Device names (there may be multiple).
    
     (4) Superblock flags (SB_*).
    
     (5) Security details.
    
     (6) Filesystem-specific data, as set by the mount options.
    
    Accessor functions are then provided to set up a context, parameterise it
    from monolithic mount data (the data page passed to mount(2)) and tear it
    down again.
    
    A legacy wrapper is provided that implements what will be the basic
    operations, wrapping access to filesystems that aren't yet aware of the
    fs_context.
    
    Finally, vfs_kern_mount() is changed to make use of the fs_context and
    mount_fs() is replaced by vfs_get_tree(), called from vfs_kern_mount().
    [AV -- add missing kstrdup()]
    [AV -- put_cred() can be unconditional - fc->cred can't be NULL]
    [AV -- take legacy_validate() contents into legacy_parse_monolithic()]
    [AV -- merge KERNEL_MOUNT and USER_MOUNT]
    [AV -- don't unlock superblock on success return from vfs_get_tree()]
    [AV -- kill 'reference' argument of init_fs_context()]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Co-developed-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index d410186bc369..f85c3212d25d 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -17,6 +17,7 @@ struct linux_binprm;
 struct path;
 struct mount;
 struct shrink_control;
+struct fs_context;
 
 /*
  * block_dev.c
@@ -51,6 +52,12 @@ int __generic_write_end(struct inode *inode, loff_t pos, unsigned copied,
  */
 extern void __init chrdev_init(void);
 
+/*
+ * fs_context.c
+ */
+extern int legacy_get_tree(struct fs_context *fc);
+extern int parse_monolithic_mount_data(struct fs_context *, void *);
+
 /*
  * namei.c
  */
@@ -101,8 +108,6 @@ extern struct file *alloc_empty_file_noaccount(int, const struct cred *);
  */
 extern int do_remount_sb(struct super_block *, int, void *, int);
 extern bool trylock_super(struct super_block *sb);
-extern struct dentry *mount_fs(struct file_system_type *,
-			       int, const char *, void *);
 extern struct super_block *user_get_super(dev_t);
 
 /*

commit d9a185f8b49678775ef56ecbdbc7b76970302897
Merge: c22fc16d172f 989974c80457
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 21 18:19:09 2018 -0700

    Merge tag 'ovl-update-4.19' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs
    
    Pull overlayfs updates from Miklos Szeredi:
     "This contains two new features:
    
       - Stack file operations: this allows removal of several hacks from
         the VFS, proper interaction of read-only open files with copy-up,
         possibility to implement fs modifying ioctls properly, and others.
    
       - Metadata only copy-up: when file is on lower layer and only
         metadata is modified (except size) then only copy up the metadata
         and continue to use the data from the lower file"
    
    * tag 'ovl-update-4.19' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs: (66 commits)
      ovl: Enable metadata only feature
      ovl: Do not do metacopy only for ioctl modifying file attr
      ovl: Do not do metadata only copy-up for truncate operation
      ovl: add helper to force data copy-up
      ovl: Check redirect on index as well
      ovl: Set redirect on upper inode when it is linked
      ovl: Set redirect on metacopy files upon rename
      ovl: Do not set dentry type ORIGIN for broken hardlinks
      ovl: Add an inode flag OVL_CONST_INO
      ovl: Treat metacopy dentries as type OVL_PATH_MERGE
      ovl: Check redirects for metacopy files
      ovl: Move some dir related ovl_lookup_single() code in else block
      ovl: Do not expose metacopy only dentry from d_real()
      ovl: Open file with data except for the case of fsync
      ovl: Add helper ovl_inode_realdata()
      ovl: Store lower data inode in ovl_inode
      ovl: Fix ovl_getattr() to get number of blocks from lower
      ovl: Add helper ovl_dentry_lowerdata() to get lower data dentry
      ovl: Copy up meta inode data from lowest data inode
      ovl: Modify ovl_lookup() and friends to lookup metacopy dentry
      ...

commit 161fa27ff2e2fd4ea7ccb660184670eab2b6ea98
Merge: a1a4f841ec45 806a1477b10a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 13 22:29:03 2018 -0700

    Merge branch 'iomap-4.19-merge' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux
    
    Pull fs iomap refactoring from Darrick Wong:
     "This is the first part of the XFS changes for 4.19.
    
      Christoph and Andreas coordinated some refactoring work on the iomap
      code in preparation for removing buffer heads from XFS and porting
      gfs2 to iomap. I'm sending this small pull request ahead of the main
      XFS merge to avoid holding up gfs2 unnecessarily"
    
    * 'iomap-4.19-merge' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux:
      iomap: add inline data support to iomap_readpage_actor
      iomap: support direct I/O to inline data
      iomap: refactor iomap_dio_actor
      iomap: add initial support for writes without buffer heads
      iomap: add an iomap-based readpage and readpages implementation
      iomap: add private pointer to struct iomap
      iomap: add a page_done callback
      iomap: generic inline data handling
      iomap: complete partial direct I/O writes synchronously
      iomap: mark newly allocated buffer heads as new
      fs: factor out a __generic_write_end helper

commit c6718543463dbb78486ad259f884cb800df802b5
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 18 15:44:43 2018 +0200

    Revert "vfs: update ovl inode before relatime check"
    
    This reverts commit 598e3c8f72f5b77c84d2cb26cfd936ffb3cfdbaa.
    
    Overlayfs no longer relies on the vfs correct atime handling.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/internal.h b/fs/internal.h
index abb41f346b18..e54ad4361d0d 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -133,13 +133,6 @@ extern long prune_icache_sb(struct super_block *sb, struct shrink_control *sc);
 extern void inode_add_lru(struct inode *inode);
 extern int dentry_needs_remove_privs(struct dentry *dentry);
 
-extern bool __atime_needs_update(const struct path *, struct inode *, bool);
-static inline bool atime_needs_update_rcu(const struct path *path,
-					  struct inode *inode)
-{
-	return __atime_needs_update(path, inode, true);
-}
-
 /*
  * fs-writeback.c
  */

commit 6742cee04353231015ddbe7e8b404ac9c1eb4473
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 18 15:44:43 2018 +0200

    Revert "ovl: don't allow writing ioctl on lower layer"
    
    This reverts commit 7c6893e3c9abf6a9676e060a1e35e5caca673d57.
    
    Overlayfs no longer relies on the vfs for checking writability of files.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/internal.h b/fs/internal.h
index 9c3b4c40e582..abb41f346b18 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -80,10 +80,8 @@ extern void __init mnt_init(void);
 
 extern int __mnt_want_write(struct vfsmount *);
 extern int __mnt_want_write_file(struct file *);
-extern int mnt_want_write_file_path(struct file *);
 extern void __mnt_drop_write(struct vfsmount *);
 extern void __mnt_drop_write_file(struct file *);
-extern void mnt_drop_write_file_path(struct file *);
 
 /*
  * fs_struct.c

commit 9df6702ad0e85901450fe48a7b5f0f8975353eeb
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 18 15:44:40 2018 +0200

    vfs: export vfs_ioctl() to modules
    
    This is needed by the stacked ioctl implementation in overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/internal.h b/fs/internal.h
index 442098fa0a84..9c3b4c40e582 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -184,7 +184,6 @@ extern const struct dentry_operations ns_dentry_operations;
  */
 extern int do_vfs_ioctl(struct file *file, unsigned int fd, unsigned int cmd,
 		    unsigned long arg);
-extern long vfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
 
 /*
  * iomap support:

commit d3b1084dfd629ef89bc1c4bab95e5cb87e7d08c2
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 18 15:44:40 2018 +0200

    vfs: make open_with_fake_path() not contribute to nr_files
    
    Stacking file operations in overlay will store an extra open file for each
    overlay file opened.
    
    The overhead is just that of "struct file" which is about 256bytes, because
    overlay already pins an extra dentry and inode when the file is open, which
    add up to a much larger overhead.
    
    For fear of breaking working setups, don't start accounting the extra file.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/internal.h b/fs/internal.h
index 52a346903748..442098fa0a84 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -94,6 +94,7 @@ extern void chroot_fs_refs(const struct path *, const struct path *);
  * file_table.c
  */
 extern struct file *alloc_empty_file(int, const struct cred *);
+extern struct file *alloc_empty_file_noaccount(int, const struct cred *);
 
 /*
  * super.c

commit 69527c554f82d4bca4b154ccc06ad1554806bdc0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 8 13:01:49 2018 -0400

    now we can fold open_check_o_direct() into do_dentry_open()
    
    These checks are better off in do_dentry_open(); the reason we couldn't
    put them there used to be that callers couldn't tell what kind of cleanup
    would do_dentry_open() failure call for.  Now that we have FMODE_OPENED,
    cleanup is the same in all cases - it's simply fput().  So let's fold
    that into do_dentry_open(), as Christoph's patch tried to.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index baeab53aeaff..52a346903748 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -125,7 +125,6 @@ int do_fchmodat(int dfd, const char __user *filename, umode_t mode);
 int do_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group,
 		int flag);
 
-extern int open_check_o_direct(struct file *f);
 extern int vfs_open(const struct path *, struct file *);
 
 /*

commit ae2bb293a3e8adbc54d08cede5afc22929030c03
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 10 13:22:28 2018 -0400

    get rid of cred argument of vfs_open() and do_dentry_open()
    
    always equal to ->f_cred
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 661c314aba30..baeab53aeaff 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -126,7 +126,7 @@ int do_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group,
 		int flag);
 
 extern int open_check_o_direct(struct file *f);
-extern int vfs_open(const struct path *, struct file *, const struct cred *);
+extern int vfs_open(const struct path *, struct file *);
 
 /*
  * inode.c

commit ea73ea7279884ba80896d4ea0f0443bf48b9e311
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jul 11 15:00:04 2018 -0400

    pass ->f_flags value to alloc_empty_file()
    
    ... and have it set the f_flags-derived part of ->f_mode.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 66473bf388e4..661c314aba30 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -93,7 +93,7 @@ extern void chroot_fs_refs(const struct path *, const struct path *);
 /*
  * file_table.c
  */
-extern struct file *alloc_empty_file(const struct cred *);
+extern struct file *alloc_empty_file(int, const struct cred *);
 
 /*
  * super.c

commit 6de37b6dc085e7c5e092b69289af66876526da44
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 10 13:12:05 2018 -0400

    pass creds to get_empty_filp(), make sure dentry_open() passes the right creds
    
    ... and rename get_empty_filp() to alloc_empty_file().
    
    dentry_open() gets creds as argument, but the only thing that sees those is
    security_file_open() - file->f_cred still ends up with current_cred().  For
    almost all callers it's the same thing, but there are several broken cases.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 5645b4ebf494..66473bf388e4 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -93,7 +93,7 @@ extern void chroot_fs_refs(const struct path *, const struct path *);
 /*
  * file_table.c
  */
-extern struct file *get_empty_filp(void);
+extern struct file *alloc_empty_file(const struct cred *);
 
 /*
  * super.c

commit b4e7a7a88b5d060650094b8d3454bc521d669f6a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 8 11:17:54 2018 -0400

    drm_mode_create_lease_ioctl(): fix open-coded filp_clone_open()
    
    Failure of ->open() should *not* be followed by fput().  Fixed by
    using filp_clone_open(), which gets the cleanups right.
    
    Cc: stable@vger.kernel.org
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 980d005b21b4..5645b4ebf494 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -127,7 +127,6 @@ int do_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group,
 
 extern int open_check_o_direct(struct file *f);
 extern int vfs_open(const struct path *, struct file *, const struct cred *);
-extern struct file *filp_clone_open(struct file *);
 
 /*
  * inode.c

commit a6d639da63aeb838d5c0b7dc50598f2eac4014a0
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jun 19 15:10:55 2018 -0700

    fs: factor out a __generic_write_end helper
    
    Bits of the buffer.c based write_end implementations that don't know
    about buffer_heads and can be reused by other implementations.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Brian Foster <bfoster@redhat.com>
    Reviewed-by: Andreas Gruenbacher <agruenba@redhat.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/fs/internal.h b/fs/internal.h
index 980d005b21b4..4a18bdbd2214 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -43,6 +43,8 @@ static inline int __sync_blockdev(struct block_device *bdev, int wait)
 extern void guard_bio_eod(int rw, struct bio *bio);
 extern int __block_write_begin_int(struct page *page, loff_t pos, unsigned len,
 		get_block_t *get_block, struct iomap *iomap);
+int __generic_write_end(struct inode *inode, loff_t pos, unsigned copied,
+		struct page *page);
 
 /*
  * char_dev.c

commit af04fadcaa932d2d804699409d9d96dd5d85ce7f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jun 2 01:31:02 2018 -0400

    Revert "fs: fold open_check_o_direct into do_dentry_open"
    
    This reverts commit cab64df194667dc5d9d786f0a895f647f5501c0d.
    
    Having vfs_open() in some cases drop the reference to
    struct file combined with
    
            error = vfs_open(path, f, cred);
            if (error) {
                    put_filp(f);
                    return ERR_PTR(error);
            }
            return f;
    
    is flat-out wrong.  It used to be
    
                    error = vfs_open(path, f, cred);
                    if (!error) {
                            /* from now on we need fput() to dispose of f */
                            error = open_check_o_direct(f);
                            if (error) {
                                    fput(f);
                                    f = ERR_PTR(error);
                            }
                    } else {
                            put_filp(f);
                            f = ERR_PTR(error);
                    }
    
    and sure, having that open_check_o_direct() boilerplate gotten rid of is
    nice, but not that way...
    
    Worse, another call chain (via finish_open()) is FUBAR now wrt
    FILE_OPENED handling - in that case we get error returned, with file
    already hit by fput() *AND* FILE_OPENED not set.  Guess what happens in
    path_openat(), when it hits
    
            if (!(opened & FILE_OPENED)) {
                    BUG_ON(!error);
                    put_filp(file);
            }
    
    The root cause of all that crap is that the callers of do_dentry_open()
    have no way to tell which way did it fail; while that could be fixed up
    (by passing something like int *opened to do_dentry_open() and have it
    marked if we'd called ->open()), it's probably much too late in the
    cycle to do so right now.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/internal.h b/fs/internal.h
index e08972db0303..980d005b21b4 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -125,6 +125,7 @@ int do_fchmodat(int dfd, const char __user *filename, umode_t mode);
 int do_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group,
 		int flag);
 
+extern int open_check_o_direct(struct file *f);
 extern int vfs_open(const struct path *, struct file *, const struct cred *);
 extern struct file *filp_clone_open(struct file *);
 

commit 9022ca6b1129da44e3d5c4fa779b8bb9ceabe2ce
Merge: 38c23685b273 0e11f6443f52
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 6 11:07:08 2018 -0700

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "Assorted stuff, including Christoph's I_DIRTY patches"
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs: move I_DIRTY_INODE to fs.h
      ubifs: fix bogus __mark_inode_dirty(I_DIRTY_SYNC | I_DIRTY_DATASYNC) call
      ntfs: fix bogus __mark_inode_dirty(I_DIRTY_SYNC | I_DIRTY_DATASYNC) call
      gfs2: fix bogus __mark_inode_dirty(I_DIRTY_SYNC | I_DIRTY_DATASYNC) calls
      fs: fold open_check_o_direct into do_dentry_open
      vfs: Replace stray non-ASCII homoglyph characters with their ASCII equivalents
      vfs: make sure struct filename->iname is word-aligned
      get rid of pointless includes of fs_struct.h
      [poll] annotate SAA6588_CMD_POLL users

commit 411d9475cf901b5a6d2996b46cb5726184a4fa50
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:54 2018 +0100

    fs: add ksys_ftruncate() wrapper; remove in-kernel calls to sys_ftruncate()
    
    Using the ksys_ftruncate() wrapper allows us to get rid of in-kernel
    calls to the sys_ftruncate() syscall. The ksys_ prefix denotes that this
    function is meant as a drop-in replacement for the syscall. In
    particular, it uses the same calling convention as sys_ftruncate().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/fs/internal.h b/fs/internal.h
index c797480cbd6f..980d005b21b4 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -119,6 +119,7 @@ extern struct file *do_filp_open(int dfd, struct filename *pathname,
 extern struct file *do_file_open_root(struct dentry *, struct vfsmount *,
 		const char *, const struct open_flags *);
 
+long do_sys_ftruncate(unsigned int fd, loff_t length, int small);
 long do_faccessat(int dfd, const char __user *filename, int mode);
 int do_fchmodat(int dfd, const char __user *filename, umode_t mode);
 int do_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group,

commit 55731b3cda3a85ee888dac3bf1f36489f275c187
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:55 2018 +0100

    fs: add do_fchownat(), ksys_fchown() helpers and ksys_{,l}chown() wrappers
    
    Using the fs-interal do_fchownat() wrapper allows us to get rid of
    fs-internal calls to the sys_fchownat() syscall.
    
    Introducing the ksys_fchown() helper and the ksys_{,}chown() wrappers
    allows us to avoid the in-kernel calls to the sys_{,l,f}chown() syscalls.
    The ksys_ prefix denotes that these functions are meant as a drop-in
    replacement for the syscalls. In particular, they use the same calling
    convention as sys_{,l,f}chown().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/fs/internal.h b/fs/internal.h
index 26f4f05b52ef..c797480cbd6f 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -121,6 +121,8 @@ extern struct file *do_file_open_root(struct dentry *, struct vfsmount *,
 
 long do_faccessat(int dfd, const char __user *filename, int mode);
 int do_fchmodat(int dfd, const char __user *filename, umode_t mode);
+int do_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group,
+		int flag);
 
 extern int open_check_o_direct(struct file *f);
 extern int vfs_open(const struct path *, struct file *, const struct cred *);

commit cbfe20f565228966f0249f016752437df95df679
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:54 2018 +0100

    fs: add do_faccessat() helper and ksys_access() wrapper; remove in-kernel calls to syscall
    
    Using the fs-internal do_faccessat() helper allows us to get rid of
    fs-internal calls to the sys_faccessat() syscall.
    
    Introducing the ksys_access() wrapper allows us to avoid the in-kernel
    calls to the sys_access() syscall. The ksys_ prefix denotes that this
    function is meant as a drop-in replacement for the syscall. In
    particular, it uses the same calling convention as sys_access().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/fs/internal.h b/fs/internal.h
index 2474bf460f96..26f4f05b52ef 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -119,6 +119,7 @@ extern struct file *do_filp_open(int dfd, struct filename *pathname,
 extern struct file *do_file_open_root(struct dentry *, struct vfsmount *,
 		const char *, const struct open_flags *);
 
+long do_faccessat(int dfd, const char __user *filename, int mode);
 int do_fchmodat(int dfd, const char __user *filename, umode_t mode);
 
 extern int open_check_o_direct(struct file *f);

commit 03450e271a160bc07a2c48e5769e0ba338582d77
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:53 2018 +0100

    fs: add ksys_fchmod() and do_fchmodat() helpers and ksys_chmod() wrapper; remove in-kernel calls to syscall
    
    Using the fs-internal do_fchmodat() helper allows us to get rid of
    fs-internal calls to the sys_fchmodat() syscall.
    
    Introducing the ksys_fchmod() helper and the ksys_chmod() wrapper allows
    us to avoid the in-kernel calls to the sys_fchmod() and sys_chmod()
    syscalls. The ksys_ prefix denotes that these functions are meant as a
    drop-in replacement for the syscalls. In particular, they use the same
    calling convention as sys_fchmod() and sys_chmod().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/fs/internal.h b/fs/internal.h
index 91e6fc93fcb5..2474bf460f96 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -119,6 +119,8 @@ extern struct file *do_filp_open(int dfd, struct filename *pathname,
 extern struct file *do_file_open_root(struct dentry *, struct vfsmount *,
 		const char *, const struct open_flags *);
 
+int do_fchmodat(int dfd, const char __user *filename, umode_t mode);
+
 extern int open_check_o_direct(struct file *f);
 extern int vfs_open(const struct path *, struct file *, const struct cred *);
 extern struct file *filp_clone_open(struct file *);

commit 46ea89eb652a365e10257016d09dcf1aaf23cf63
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:53 2018 +0100

    fs: add do_linkat() helper and ksys_link() wrapper; remove in-kernel calls to syscall
    
    Using the fs-internal do_linkat() helper allows us to get rid of
    fs-internal calls to the sys_linkat() syscall.
    
    Introducing the ksys_link() wrapper allows us to avoid the in-kernel
    calls to sys_link() syscall. The ksys_ prefix denotes that this function
    is meant as a drop-in replacement for the syscall. In particular, it uses
    the same calling convention as sys_link().
    
    In the near future, the only fs-external user of ksys_link() should be
    converted to use vfs_link() instead.
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/fs/internal.h b/fs/internal.h
index 4f0b67054c54..91e6fc93fcb5 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -62,6 +62,8 @@ long do_rmdir(int dfd, const char __user *pathname);
 long do_unlinkat(int dfd, struct filename *name);
 long do_symlinkat(const char __user *oldname, int newdfd,
 		  const char __user *newname);
+int do_linkat(int olddfd, const char __user *oldname, int newdfd,
+	      const char __user *newname, int flags);
 
 /*
  * namespace.c

commit 87c4e19262d81862886207be3c8795f6576d5a52
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:50 2018 +0100

    fs: add do_mknodat() helper and ksys_mknod() wrapper; remove in-kernel calls to syscall
    
    Using the fs-internal do_mknodat() helper allows us to get rid of
    fs-internal calls to the sys_mknodat() syscall.
    
    Introducing the ksys_mknod() wrapper allows us to avoid the in-kernel
    calls to sys_mknod() syscall. The ksys_ prefix denotes that this function
    is meant as a drop-in replacement for the syscall. In particular, it uses
    the same calling convention as sys_mknod().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/fs/internal.h b/fs/internal.h
index a3f04ca2a08b..4f0b67054c54 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -55,6 +55,8 @@ extern void __init chrdev_init(void);
 extern int user_path_mountpoint_at(int, const char __user *, unsigned int, struct path *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct path *);
+long do_mknodat(int dfd, const char __user *filename, umode_t mode,
+		unsigned int dev);
 long do_mkdirat(int dfd, const char __user *pathname, umode_t mode);
 long do_rmdir(int dfd, const char __user *pathname);
 long do_unlinkat(int dfd, struct filename *name);

commit b724e846b491ef8db943be8086226c9d8da31877
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:49 2018 +0100

    fs: add do_symlinkat() helper and ksys_symlink() wrapper; remove in-kernel calls to syscall
    
    Using the fs-internal do_symlinkat() helper allows us to get rid of
    fs-internal calls to the sys_symlinkat() syscall.
    
    Introducing the ksys_symlink() wrapper allows us to avoid the in-kernel
    calls to the sys_symlink() syscall. The ksys_ prefix denotes that this
    function is meant as a drop-in replacement for the syscall. In particular,
    it uses the same calling convention as sys_symlink().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/fs/internal.h b/fs/internal.h
index 53846bd4d9d7..a3f04ca2a08b 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -58,6 +58,8 @@ extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 long do_mkdirat(int dfd, const char __user *pathname, umode_t mode);
 long do_rmdir(int dfd, const char __user *pathname);
 long do_unlinkat(int dfd, struct filename *name);
+long do_symlinkat(const char __user *oldname, int newdfd,
+		  const char __user *newname);
 
 /*
  * namespace.c

commit 0101db7a301981a008296d522d8c1f456b0fe837
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:49 2018 +0100

    fs: add do_mkdirat() helper and ksys_mkdir() wrapper; remove in-kernel calls to syscall
    
    Using the fs-internal do_mkdirat() helper allows us to get rid of
    fs-internal calls to the sys_mkdirat() syscall.
    
    Introducing the ksys_mkdir() wrapper allows us to avoid the in-kernel calls
    to the sys_mkdir() syscall. The ksys_ prefix denotes that this function is
    meant as a drop-in replacement for the syscall. In particular, it uses the
    same calling convention as sys_mkdir().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/fs/internal.h b/fs/internal.h
index 0eda35fa1743..53846bd4d9d7 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -55,6 +55,7 @@ extern void __init chrdev_init(void);
 extern int user_path_mountpoint_at(int, const char __user *, unsigned int, struct path *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct path *);
+long do_mkdirat(int dfd, const char __user *pathname, umode_t mode);
 long do_rmdir(int dfd, const char __user *pathname);
 long do_unlinkat(int dfd, struct filename *name);
 

commit f459dffae1c6026928bbe8e972daecb635b7b5e9
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 11 11:34:48 2018 +0100

    fs: add ksys_rmdir() wrapper; remove in-kernel calls to sys_rmdir()
    
    Using this wrapper allows us to avoid the in-kernel calls to the
    sys_rmdir() syscall. The ksys_ prefix denotes that this function is meant
    as a drop-in replacement for the syscall. In particular, it uses the same
    calling convention as sys_rmdir().
    
    This patch is part of a series which removes in-kernel calls to syscalls.
    On this basis, the syscall entry path can be streamlined. For details, see
    http://lkml.kernel.org/r/20180325162527.GA17492@light.dominikbrodowski.net
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/fs/internal.h b/fs/internal.h
index df262f41a0ef..0eda35fa1743 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -55,6 +55,7 @@ extern void __init chrdev_init(void);
 extern int user_path_mountpoint_at(int, const char __user *, unsigned int, struct path *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct path *);
+long do_rmdir(int dfd, const char __user *pathname);
 long do_unlinkat(int dfd, struct filename *name);
 
 /*

commit cab64df194667dc5d9d786f0a895f647f5501c0d
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Mar 20 11:30:14 2018 +0100

    fs: fold open_check_o_direct into do_dentry_open
    
    do_dentry_open is where we do the actual open of the file, so this is
    where we should do our O_DIRECT sanity check to cover all potential
    callers.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index df262f41a0ef..5e797281d941 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -111,7 +111,6 @@ extern struct file *do_filp_open(int dfd, struct filename *pathname,
 extern struct file *do_file_open_root(struct dentry *, struct vfsmount *,
 		const char *, const struct open_flags *);
 
-extern int open_check_o_direct(struct file *f);
 extern int vfs_open(const struct path *, struct file *, const struct cred *);
 extern struct file *filp_clone_open(struct file *);
 

commit da2f1362c8bdf187c171a59a2c84b8ed3566d5fe
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Nov 4 13:44:45 2017 +0300

    fs: expose do_unlinkat for built-in callers
    
    And make it take a struct filename instead of a user pointer.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 48cee21b4f14..df262f41a0ef 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -55,6 +55,7 @@ extern void __init chrdev_init(void);
 extern int user_path_mountpoint_at(int, const char __user *, unsigned int, struct path *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct path *);
+long do_unlinkat(int dfd, struct filename *name);
 
 /*
  * namespace.c

commit c353f88f3de485a059e5c003721e2dc276d02fad
Merge: 6d8ef53e8b2f 939ae4efd51c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 13 09:11:44 2017 -0700

    Merge branch 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs
    
    Pull overlayfs updates from Miklos Szeredi:
     "This fixes d_ino correctness in readdir, which brings overlayfs on par
      with normal filesystems regarding inode number semantics, as long as
      all layers are on the same filesystem.
    
      There are also some bug fixes, one in particular (random ioctl's
      shouldn't be able to modify lower layers) that touches some vfs code,
      but of course no-op for non-overlay fs"
    
    * 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs:
      ovl: fix false positive ESTALE on lookup
      ovl: don't allow writing ioctl on lower layer
      ovl: fix relatime for directories
      vfs: add flags to d_real()
      ovl: cleanup d_real for negative
      ovl: constant d_ino for non-merge dirs
      ovl: constant d_ino across copy up
      ovl: fix readdir error value
      ovl: check snprintf return

commit 7c6893e3c9abf6a9676e060a1e35e5caca673d57
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 5 12:53:12 2017 +0200

    ovl: don't allow writing ioctl on lower layer
    
    Problem with ioctl() is that it's a file operation, yet often used as an
    inode operation (i.e. modify the inode despite the file being opened for
    read-only).
    
    mnt_want_write_file() is used by filesystems in such cases to get write
    access on an arbitrary open file.
    
    Since overlayfs lets filesystems do all file operations, including ioctl,
    this can lead to mnt_want_write_file() returning OK for a lower file and
    modification of that lower file.
    
    This patch prevents modification by checking if the file is from an
    overlayfs lower layer and returning EPERM in that case.
    
    Need to introduce a mnt_want_write_file_path() variant that still does the
    old thing for inode operations that can do the copy up + modification
    correctly in such cases (fchown, fsetxattr, fremovexattr).
    
    This does not address the correctness of such ioctls on overlayfs (the
    correct way would be to copy up and attempt to perform ioctl on upper
    file).
    
    In theory this could be a regression.  We very much hope that nobody is
    relying on such a hack in any sane setup.
    
    While this patch meddles in VFS code, it has no effect on non-overlayfs
    filesystems.
    
    Reported-by: "zhangyi (F)" <yi.zhang@huawei.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/internal.h b/fs/internal.h
index 9676fe11c093..60cdbcd2887b 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -71,8 +71,10 @@ extern void __init mnt_init(void);
 
 extern int __mnt_want_write(struct vfsmount *);
 extern int __mnt_want_write_file(struct file *);
+extern int mnt_want_write_file_path(struct file *);
 extern void __mnt_drop_write(struct vfsmount *);
 extern void __mnt_drop_write_file(struct file *);
+extern void mnt_drop_write_file_path(struct file *);
 
 /*
  * fs_struct.c

commit 799ea9e9c59949008770aab4e1da87f10e99dbe4
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Fri Aug 18 18:08:25 2017 -0700

    xfs: evict all inodes involved with log redo item
    
    When we introduced the bmap redo log items, we set MS_ACTIVE on the
    mountpoint and XFS_IRECOVERY on the inode to prevent unlinked inodes
    from being truncated prematurely during log recovery.  This also had the
    effect of putting linked inodes on the lru instead of evicting them.
    
    Unfortunately, we neglected to find all those unreferenced lru inodes
    and evict them after finishing log recovery, which means that we leak
    them if anything goes wrong in the rest of xfs_mountfs, because the lru
    is only cleaned out on unmount.
    
    Therefore, evict unreferenced inodes in the lru list immediately
    after clearing MS_ACTIVE.
    
    Fixes: 17c12bcd30 ("xfs: when replaying bmap operations, don't let unlinked inodes get reaped")
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Cc: viro@ZenIV.linux.org.uk
    Reviewed-by: Brian Foster <bfoster@redhat.com>

diff --git a/fs/internal.h b/fs/internal.h
index 9676fe11c093..fedfe94d84ba 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -132,7 +132,6 @@ static inline bool atime_needs_update_rcu(const struct path *path,
 extern void inode_io_list_del(struct inode *inode);
 
 extern long get_nr_dirty_inodes(void);
-extern void evict_inodes(struct super_block *);
 extern int invalidate_inodes(struct super_block *, bool);
 
 /*

commit 11fbf53d66ec302fe50b06bd7cb4863dbb98775a
Merge: 339fbf6796f8 6b4657667ba0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 9 09:12:53 2017 -0700

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "Assorted bits and pieces from various people. No common topic in this
      pile, sorry"
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs/affs: add rename exchange
      fs/affs: add rename2 to prepare multiple methods
      Make stat/lstat/fstatat pass AT_NO_AUTOMOUNT to vfs_statx()
      fs: don't set *REFERENCED on single use objects
      fs: compat: Remove warning from COMPATIBLE_IOCTL
      remove pointless extern of atime_need_update_rcu()
      fs: completely ignore unknown open flags
      fs: add a VALID_OPEN_FLAGS
      fs: remove _submit_bh()
      fs: constify tree_descr arrays passed to simple_fill_super()
      fs: drop duplicate header percpu-rwsem.h
      fs/affs: bugfix: Write files greater than page size on OFS
      fs/affs: bugfix: enable writes on OFS disks
      fs/affs: remove node generation check
      fs/affs: import amigaffs.h
      fs/affs: bugfix: make symbolic links work again

commit 0b33540f9d751b565c270d23a077ee6d9fc9e1d5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 29 17:42:25 2017 -0400

    remove pointless extern of atime_need_update_rcu()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 11c6d89dce9c..7e1847dd4e3b 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -128,8 +128,6 @@ static inline bool atime_needs_update_rcu(const struct path *path,
 	return __atime_needs_update(path, inode, true);
 }
 
-extern bool atime_needs_update_rcu(const struct path *, struct inode *);
-
 /*
  * fs-writeback.c
  */

commit 2b8910264a7fec4599b620e5206eb877a207f40a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 8 18:16:56 2017 -0400

    fhandle: move compat syscalls from compat.c
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 11c6d89dce9c..076751d90ba2 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -108,8 +108,6 @@ extern struct file *do_filp_open(int dfd, struct filename *pathname,
 extern struct file *do_file_open_root(struct dentry *, struct vfsmount *,
 		const char *, const struct open_flags *);
 
-extern long do_handle_open(int mountdirfd,
-			   struct file_handle __user *ufh, int open_flag);
 extern int open_check_o_direct(struct file *f);
 extern int vfs_open(const struct path *, struct file *, const struct cred *);
 extern struct file *filp_clone_open(struct file *);

commit 8ff6daa17b6a64e59bbabaa116b9bd854fa4da1f
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jan 27 23:20:26 2017 -0800

    iomap: constify struct iomap_ops
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/fs/internal.h b/fs/internal.h
index b63cf3af2dc2..11c6d89dce9c 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -182,7 +182,7 @@ typedef loff_t (*iomap_actor_t)(struct inode *inode, loff_t pos, loff_t len,
 		void *data, struct iomap *iomap);
 
 loff_t iomap_apply(struct inode *inode, loff_t pos, loff_t length,
-		unsigned flags, struct iomap_ops *ops, void *data,
+		unsigned flags, const struct iomap_ops *ops, void *data,
 		iomap_actor_t actor);
 
 /* direct-io.c: */

commit 0110c350c86d511be2130cb2a30dcbb76c4af750
Merge: d9cb5bfcc333 9763f7a4a5f7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 17 18:44:00 2016 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull more vfs updates from Al Viro:
     "In this pile:
    
       - autofs-namespace series
       - dedupe stuff
       - more struct path constification"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (40 commits)
      ocfs2: implement the VFS clone_range, copy_range, and dedupe_range features
      ocfs2: charge quota for reflinked blocks
      ocfs2: fix bad pointer cast
      ocfs2: always unlock when completing dio writes
      ocfs2: don't eat io errors during _dio_end_io_write
      ocfs2: budget for extent tree splits when adding refcount flag
      ocfs2: prohibit refcounted swapfiles
      ocfs2: add newlines to some error messages
      ocfs2: convert inode refcount test to a helper
      simple_write_end(): don't zero in short copy into uptodate
      exofs: don't mess with simple_write_{begin,end}
      9p: saner ->write_end() on failing copy into non-uptodate page
      fix gfs2_stuffed_write_end() on short copies
      fix ceph_write_end()
      nfs_write_end(): fix handling of short copies
      vfs: refactor clone/dedupe_file_range common functions
      fs: try to clone files first in vfs_copy_file_range
      vfs: misc struct path constification
      namespace.c: constify struct path passed to a bunch of primitives
      quota: constify struct path in quota_on
      ...

commit ca71cf71eeda04dc9ad18271504e499013af5415
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Nov 20 19:45:28 2016 -0500

    namespace.c: constify struct path passed to a bunch of primitives
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index f4da3341b4a3..3e460159d835 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -62,7 +62,7 @@ extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 extern void *copy_mount_options(const void __user *);
 extern char *copy_mount_string(const void __user *);
 
-extern struct vfsmount *lookup_mnt(struct path *);
+extern struct vfsmount *lookup_mnt(const struct path *);
 extern int finish_automount(struct vfsmount *, struct path *);
 
 extern int sb_prepare_remount_readonly(struct super_block *);

commit ec1b826097f30858f9ed201cb78f1a762c50d0aa
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Nov 30 14:33:53 2016 +1100

    fs: make sb_init_dio_done_wq available outside of direct-io.c
    
    We want to use the per-sb completion workqueue from the new iomap
    direct I/O code.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Jens Axboe <axboe@fb.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/fs/internal.h b/fs/internal.h
index f4da3341b4a3..4fcf51766d4a 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -184,3 +184,6 @@ typedef loff_t (*iomap_actor_t)(struct inode *inode, loff_t pos, loff_t len,
 loff_t iomap_apply(struct inode *inode, loff_t pos, loff_t length,
 		unsigned flags, struct iomap_ops *ops, void *data,
 		iomap_actor_t actor);
+
+/* direct-io.c: */
+int sb_init_dio_done_wq(struct super_block *sb);

commit abb5a14fa20fdd400995926134b7be9eb8ce6048
Merge: 911f9dab301e e55f1d1d13e7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 13:04:49 2016 -0700

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "Assorted misc bits and pieces.
    
      There are several single-topic branches left after this (rename2
      series from Miklos, current_time series from Deepa Dinamani, xattr
      series from Andreas, uaccess stuff from from me) and I'd prefer to
      send those separately"
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (39 commits)
      proc: switch auxv to use of __mem_open()
      hpfs: support FIEMAP
      cifs: get rid of unused arguments of CIFSSMBWrite()
      posix_acl: uapi header split
      posix_acl: xattr representation cleanups
      fs/aio.c: eliminate redundant loads in put_aio_ring_file
      fs/internal.h: add const to ns_dentry_operations declaration
      compat: remove compat_printk()
      fs/buffer.c: make __getblk_slow() static
      proc: unsigned file descriptors
      fs/file: more unsigned file descriptors
      fs: compat: remove redundant check of nr_segs
      cachefiles: Fix attempt to read i_blocks after deleting file [ver #2]
      cifs: don't use memcpy() to copy struct iov_iter
      get rid of separate multipage fault-in primitives
      fs: Avoid premature clearing of capabilities
      fs: Give dentry to inode_change_ok() instead of inode
      fuse: Propagate dentry down to inode_change_ok()
      ceph: Propagate dentry down to inode_change_ok()
      xfs: Propagate dentry down to inode_change_ok()
      ...

commit f334bcd94b7d3c0fbc34d518a86548f451ab5faf
Merge: 73e8fb2d596d 814184fd4025
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Oct 8 11:00:01 2016 -0400

    Merge remote-tracking branch 'ovl/misc' into work.misc

commit be218aa2e3f7aa698cdce5a4efb1e178677db8fd
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Thu Sep 15 00:15:34 2016 +0200

    fs/internal.h: add const to ns_dentry_operations declaration
    
    The actual definition in fs/nsfs.c is already const.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index ba0737649d4a..395887882315 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -156,7 +156,7 @@ extern void mnt_pin_kill(struct mount *m);
 /*
  * fs/nsfs.c
  */
-extern struct dentry_operations ns_dentry_operations;
+extern const struct dentry_operations ns_dentry_operations;
 
 /*
  * fs/ioctl.c

commit befb503ca6e648cc5ed3e3a472d5b5887a60e0f2
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Sep 19 11:24:49 2016 +1000

    iomap: expose iomap_apply outside iomap.c
    
    This allows the DAX code to use it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/fs/internal.h b/fs/internal.h
index ba0737649d4a..859178692ce4 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -12,6 +12,7 @@
 struct super_block;
 struct file_system_type;
 struct iomap;
+struct iomap_ops;
 struct linux_binprm;
 struct path;
 struct mount;
@@ -164,3 +165,13 @@ extern struct dentry_operations ns_dentry_operations;
 extern int do_vfs_ioctl(struct file *file, unsigned int fd, unsigned int cmd,
 		    unsigned long arg);
 extern long vfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+
+/*
+ * iomap support:
+ */
+typedef loff_t (*iomap_actor_t)(struct inode *inode, loff_t pos, loff_t len,
+		void *data, struct iomap *iomap);
+
+loff_t iomap_apply(struct inode *inode, loff_t pos, loff_t length,
+		unsigned flags, struct iomap_ops *ops, void *data,
+		iomap_actor_t actor);

commit 598e3c8f72f5b77c84d2cb26cfd936ffb3cfdbaa
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Sep 16 12:44:20 2016 +0200

    vfs: update ovl inode before relatime check
    
    On overlayfs relatime_need_update() needs inode times to be correct on
    overlay inode.  But i_mtime and i_ctime are updated by filesystem code on
    underlying inode only, so they will be out-of-date on the overlay inode.
    
    This patch copies the times from the underlying inode if needed.  This
    can't be done if called from RCU lookup (link following) but link m/ctime
    are not updated by fs, so this is all right.
    
    This patch doesn't change functionality for anything but overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/internal.h b/fs/internal.h
index ba0737649d4a..a63da5e96148 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -120,6 +120,15 @@ extern long prune_icache_sb(struct super_block *sb, struct shrink_control *sc);
 extern void inode_add_lru(struct inode *inode);
 extern int dentry_needs_remove_privs(struct dentry *dentry);
 
+extern bool __atime_needs_update(const struct path *, struct inode *, bool);
+static inline bool atime_needs_update_rcu(const struct path *path,
+					  struct inode *inode)
+{
+	return __atime_needs_update(path, inode, true);
+}
+
+extern bool atime_needs_update_rcu(const struct path *, struct inode *);
+
 /*
  * fs-writeback.c
  */

commit e9d488c3114acb6a0a93e99c02f9cd1d656f46c7
Merge: 337684a1746f 4af75df6a410
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Aug 7 10:13:14 2016 -0400

    Merge tag 'binfmt-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/binfmt_misc
    
    Pull binfmt_misc update from James Bottomley:
     "This update is to allow architecture emulation containers to function
      such that the emulation binary can be housed outside the container
      itself.  The container and fs parts both have acks from relevant
      experts.
    
      To use the new feature you have to add an F option to your binfmt_misc
      configuration"
    
    From the docs:
     "The usual behaviour of binfmt_misc is to spawn the binary lazily when
      the misc format file is invoked.  However, this doesn't work very well
      in the face of mount namespaces and changeroots, so the F mode opens
      the binary as soon as the emulation is installed and uses the opened
      image to spawn the emulator, meaning it is always available once
      installed, regardless of how the environment changes"
    
    * tag 'binfmt-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/binfmt_misc:
      binfmt_misc: add F option description to documentation
      binfmt_misc: add persistent opened binary handler for containers
      fs: add filp_clone_open API

commit 8ecfb75216a71ba0e00e419ddafa52d12d965445
Merge: 7d50a29fe438 f0fce87c36ae
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Aug 3 13:31:51 2016 -0400

    Merge branch 'for-viro' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs into for-linus

commit f0fce87c36aec5c4a895c78b76396f5727047b93
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Aug 3 13:44:27 2016 +0200

    vfs: make dentry_needs_remove_privs() internal
    
    Only used by the vfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/internal.h b/fs/internal.h
index f57ced528cde..30b568f02613 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -114,6 +114,7 @@ extern int vfs_open(const struct path *, struct file *, const struct cred *);
  */
 extern long prune_icache_sb(struct super_block *sb, struct shrink_control *sc);
 extern void inode_add_lru(struct inode *inode);
+extern int dentry_needs_remove_privs(struct dentry *dentry);
 
 /*
  * fs-writeback.c

commit 0e6acf0204da5b8705722a5f6806a4f55ed379d6
Merge: 0e06f5c0deee f2bdfda9a1c6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 27 09:53:35 2016 -0700

    Merge tag 'xfs-for-linus-4.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/dgc/linux-xfs
    
    Pull xfs updates from Dave Chinner:
     "The major addition is the new iomap based block mapping
      infrastructure.  We've been kicking this about locally for years, but
      there are other filesystems want to use it too (e.g. gfs2).  Now it
      is fully working, reviewed and ready for merge and be used by other
      filesystems.
    
      There are a lot of other fixes and cleanups in the tree, but those are
      XFS internal things and none are of the scale or visibility of the
      iomap changes.  See below for details.
    
      I am likely to send another pull request next week - we're just about
      ready to merge some new functionality (on disk block->owner reverse
      mapping infrastructure), but that's a huge chunk of code (74 files
      changed, 7283 insertions(+), 1114 deletions(-)) so I'm keeping that
      separate to all the "normal" pull request changes so they don't get
      lost in the noise.
    
      Summary of changes in this update:
       - generic iomap based IO path infrastructure
       - generic iomap based fiemap implementation
       - xfs iomap based Io path implementation
       - buffer error handling fixes
       - tracking of in flight buffer IO for unmount serialisation
       - direct IO and DAX io path separation and simplification
       - shortform directory format definition changes for wider platform
         compatibility
       - various buffer cache fixes
       - cleanups in preparation for rmap merge
       - error injection cleanups and fixes
       - log item format buffer memory allocation restructuring to prevent
         rare OOM reclaim deadlocks
       - sparse inode chunks are now fully supported"
    
    * tag 'xfs-for-linus-4.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/dgc/linux-xfs: (53 commits)
      xfs: remove EXPERIMENTAL tag from sparse inode feature
      xfs: bufferhead chains are invalid after end_page_writeback
      xfs: allocate log vector buffers outside CIL context lock
      libxfs: directory node splitting does not have an extra block
      xfs: remove dax code from object file when disabled
      xfs: skip dirty pages in ->releasepage()
      xfs: remove __arch_pack
      xfs: kill xfs_dir2_inou_t
      xfs: kill xfs_dir2_sf_off_t
      xfs: split direct I/O and DAX path
      xfs: direct calls in the direct I/O path
      xfs: stop using generic_file_read_iter for direct I/O
      xfs: split xfs_file_read_iter into buffered and direct I/O helpers
      xfs: remove s_maxbytes enforcement in xfs_file_read_iter
      xfs: kill ioflags
      xfs: don't pass ioflags around in the ioctl path
      xfs: track and serialize in-flight async buffers against unmount
      xfs: exclude never-released buffers from buftarg I/O accounting
      xfs: don't reset b_retries to 0 on every failure
      xfs: remove extraneous buffer flag changes
      ...

commit ae259a9c8593f98aa60d045df978a5482a67c53f
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jun 21 09:23:11 2016 +1000

    fs: introduce iomap infrastructure
    
    Add infrastructure for multipage buffered writes.  This is implemented
    using an main iterator that applies an actor function to a range that
    can be written.
    
    This infrastucture is used to implement a buffered write helper, one
    to zero file ranges and one to implement the ->page_mkwrite VM
    operations.  All of them borrow a fair amount of code from fs/buffers.
    for now by using an internal version of __block_write_begin that
    gets passed an iomap and builds the corresponding buffer head.
    
    The file system is gets a set of paired ->iomap_begin and ->iomap_end
    calls which allow it to map/reserve a range and get a notification
    once the write code is finished with it.
    
    Based on earlier code from Dave Chinner.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/fs/internal.h b/fs/internal.h
index b71deeecea17..c0c6f493ab8a 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -11,6 +11,7 @@
 
 struct super_block;
 struct file_system_type;
+struct iomap;
 struct linux_binprm;
 struct path;
 struct mount;
@@ -39,6 +40,8 @@ static inline int __sync_blockdev(struct block_device *bdev, int wait)
  * buffer.c
  */
 extern void guard_bio_eod(int rw, struct bio *bio);
+extern int __block_write_begin_int(struct page *page, loff_t pos, unsigned len,
+		get_block_t *get_block, struct iomap *iomap);
 
 /*
  * char_dev.c

commit ba65dc5ef16f82fba77869cecf7a7d515f61446b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 10 11:32:47 2016 -0400

    much milder d_walk() race
    
    d_walk() relies upon the tree not getting rearranged under it without
    rename_lock being touched.  And we do grab rename_lock around the
    places that change the tree topology.  Unfortunately, branch reordering
    is just as bad from d_walk() POV and we have two places that do it
    without touching rename_lock - one in handling of cursors (for ramfs-style
    directories) and another in autofs.  autofs one is a separate story; this
    commit deals with the cursors.
            * mark cursor dentries explicitly at allocation time
            * make __dentry_kill() leave ->d_child.next pointing to the next
    non-cursor sibling, making sure that it won't be moved around unnoticed
    before the parent is relocked on ascend-to-parent path in d_walk().
            * make d_walk() skip cursors explicitly; strictly speaking it's
    not necessary (all callbacks we pass to d_walk() are no-ops on cursors),
    but it makes analysis easier.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index b71deeecea17..f57ced528cde 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -130,6 +130,7 @@ extern int invalidate_inodes(struct super_block *, bool);
 extern struct dentry *__d_alloc(struct super_block *, const struct qstr *);
 extern int d_set_mounted(struct dentry *dentry);
 extern long prune_dcache_sb(struct super_block *sb, struct shrink_control *sc);
+extern struct dentry *d_alloc_cursor(struct dentry *);
 
 /*
  * read_write.c

commit 9a08c352d05305ca7651540c3b107da1e4e1f40b
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Wed Feb 17 16:49:38 2016 -0800

    fs: add filp_clone_open API
    
    I need an API that allows me to obtain a clone of the current file
    pointer to pass in to an exec handler.  I've labelled this as an
    internal API because I can't see how it would be useful outside of the
    fs subsystem.  The use case will be a persistent binfmt_misc handler.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Acked-by: Jan Kara <jack@suse.cz>

diff --git a/fs/internal.h b/fs/internal.h
index b71deeecea17..c8ca0c957743 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -108,6 +108,7 @@ extern long do_handle_open(int mountdirfd,
 			   struct file_handle __user *ufh, int open_flag);
 extern int open_check_o_direct(struct file *f);
 extern int vfs_open(const struct path *, struct file *, const struct cred *);
+extern struct file *filp_clone_open(struct file *);
 
 /*
  * inode.c

commit 6108209c4ae964836f6bac5210f1c64153800b62
Merge: a1c6f05733c2 a7f61e89af73
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jan 8 21:20:11 2016 -0500

    Merge branch 'for-linus' into work.misc

commit 66cf191f3eae4582a83cb4251b75b43bee95a999
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jan 7 09:53:30 2016 -0500

    compat_ioctl: don't pass fd around when not needed
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 71859c4d0b41..e38c08ca437d 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -151,3 +151,10 @@ extern void mnt_pin_kill(struct mount *m);
  * fs/nsfs.c
  */
 extern struct dentry_operations ns_dentry_operations;
+
+/*
+ * fs/ioctl.c
+ */
+extern int do_vfs_ioctl(struct file *file, unsigned int fd, unsigned int cmd,
+		    unsigned long arg);
+extern long vfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg);

commit b40ef8696fbbb1107fbe5f4afc21c357f16e5ffc
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Dec 14 18:44:44 2015 -0500

    saner calling conventions for copy_mount_options()
    
    let it just return NULL, pointer to kernel copy or ERR_PTR().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 71859c4d0b41..aa81316aaf47 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -55,7 +55,7 @@ extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 /*
  * namespace.c
  */
-extern int copy_mount_options(const void __user *, unsigned long *);
+extern void *copy_mount_options(const void __user *);
 extern char *copy_mount_string(const void __user *);
 
 extern struct vfsmount *lookup_mnt(struct path *);

commit c7f5408493aeb01532927b2276316797a03ed6ee
Author: Dave Chinner <dchinner@redhat.com>
Date:   Wed Mar 4 14:07:22 2015 -0500

    inode: rename i_wb_list to i_io_list
    
    There's a small consistency problem between the inode and writeback
    naming. Writeback calls the "for IO" inode queues b_io and
    b_more_io, but the inode calls these the "writeback list" or
    i_wb_list. This makes it hard to an new "under writeback" list to
    the inode, or call it an "under IO" list on the bdi because either
    way we'll have writeback on IO and IO on writeback and it'll just be
    confusing. I'm getting confused just writing this!
    
    So, rename the inode "for IO" list variable to i_io_list so we can
    add a new "writeback list" in a subsequent patch.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Dave Chinner <dchinner@redhat.com>

diff --git a/fs/internal.h b/fs/internal.h
index ee1209c54eb1..71859c4d0b41 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -118,7 +118,7 @@ extern void inode_add_lru(struct inode *inode);
 /*
  * fs-writeback.c
  */
-extern void inode_wb_list_del(struct inode *inode);
+extern void inode_io_list_del(struct inode *inode);
 
 extern long get_nr_dirty_inodes(void);
 extern void evict_inodes(struct super_block *);

commit 74278da9f70d84d715601fe794567a6d2bfdf078
Author: Dave Chinner <dchinner@redhat.com>
Date:   Wed Mar 4 12:37:22 2015 -0500

    inode: convert inode_sb_list_lock to per-sb
    
    The process of reducing contention on per-superblock inode lists
    starts with moving the locking to match the per-superblock inode
    list. This takes the global lock out of the picture and reduces the
    contention problems to within a single filesystem. This doesn't get
    rid of contention as the locks still have global CPU scope, but it
    does isolate operations on different superblocks form each other.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Dave Chinner <dchinner@redhat.com>

diff --git a/fs/internal.h b/fs/internal.h
index 4d5af583ab03..ee1209c54eb1 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -112,7 +112,6 @@ extern int vfs_open(const struct path *, struct file *, const struct cred *);
 /*
  * inode.c
  */
-extern spinlock_t inode_sb_list_lock;
 extern long prune_icache_sb(struct super_block *sb, struct shrink_control *sc);
 extern void inode_add_lru(struct inode *inode);
 

commit 4bacc9c9234c7c8eec44f5ed4e960d9f96fa0f01
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 18 14:32:31 2015 +0100

    overlayfs: Make f_path always point to the overlay and f_inode to the underlay
    
    Make file->f_path always point to the overlay dentry so that the path in
    /proc/pid/fd is correct and to ensure that label-based LSMs have access to the
    overlay as well as the underlay (path-based LSMs probably don't need it).
    
    Using my union testsuite to set things up, before the patch I see:
    
            [root@andromeda union-testsuite]# bash 5</mnt/a/foo107
            [root@andromeda union-testsuite]# ls -l /proc/$$/fd/
            ...
            lr-x------. 1 root root 64 Jun  5 14:38 5 -> /a/foo107
            [root@andromeda union-testsuite]# stat /mnt/a/foo107
            ...
            Device: 23h/35d Inode: 13381       Links: 1
            ...
            [root@andromeda union-testsuite]# stat -L /proc/$$/fd/5
            ...
            Device: 23h/35d Inode: 13381       Links: 1
            ...
    
    After the patch:
    
            [root@andromeda union-testsuite]# bash 5</mnt/a/foo107
            [root@andromeda union-testsuite]# ls -l /proc/$$/fd/
            ...
            lr-x------. 1 root root 64 Jun  5 14:22 5 -> /mnt/a/foo107
            [root@andromeda union-testsuite]# stat /mnt/a/foo107
            ...
            Device: 23h/35d Inode: 40346       Links: 1
            ...
            [root@andromeda union-testsuite]# stat -L /proc/$$/fd/5
            ...
            Device: 23h/35d Inode: 40346       Links: 1
            ...
    
    Note the change in where /proc/$$/fd/5 points to in the ls command.  It was
    pointing to /a/foo107 (which doesn't exist) and now points to /mnt/a/foo107
    (which is correct).
    
    The inode accessed, however, is the lower layer.  The union layer is on device
    25h/37d and the upper layer on 24h/36d.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 01dce1d1476b..4d5af583ab03 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -107,6 +107,7 @@ extern struct file *do_file_open_root(struct dentry *, struct vfsmount *,
 extern long do_handle_open(int mountdirfd,
 			   struct file_handle __user *ufh, int open_flag);
 extern int open_check_o_direct(struct file *f);
+extern int vfs_open(const struct path *, struct file *, const struct cred *);
 
 /*
  * inode.c

commit eb6ef3df4faa5424cf2a24b4e4f3eeceb1482a8e
Author: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
Date:   Thu Feb 19 20:19:35 2015 +0300

    trylock_super(): replacement for grab_super_passive()
    
    I've noticed significant locking contention in memory reclaimer around
    sb_lock inside grab_super_passive(). Grab_super_passive() is called from
    two places: in icache/dcache shrinkers (function super_cache_scan) and
    from writeback (function __writeback_inodes_wb). Both are required for
    progress in memory allocator.
    
    Grab_super_passive() acquires sb_lock to increment sb->s_count and check
    sb->s_instances. It seems sb->s_umount locked for read is enough here:
    super-block deactivation always runs under sb->s_umount locked for write.
    Protecting super-block itself isn't a problem: in super_cache_scan() sb
    is protected by shrinker_rwsem: it cannot be freed if its slab shrinkers
    are still active. Inside writeback super-block comes from inode from bdi
    writeback list under wb->list_lock.
    
    This patch removes locking sb_lock and checks s_instances under s_umount:
    generic_shutdown_super() unlinks it under sb->s_umount locked for write.
    New variant is called trylock_super() and since it only locks semaphore,
    callers must call up_read(&sb->s_umount) instead of drop_super(sb) when
    they're done.
    
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 30459dab409d..01dce1d1476b 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -84,7 +84,7 @@ extern struct file *get_empty_filp(void);
  * super.c
  */
 extern int do_remount_sb(struct super_block *, int, void *, int);
-extern bool grab_super_passive(struct super_block *sb);
+extern bool trylock_super(struct super_block *sb);
 extern struct dentry *mount_fs(struct file_system_type *,
 			       int, const char *, void *);
 extern struct super_block *user_get_super(dev_t);

commit 50652963eae6afe13678dc84d789a174306a4df7
Merge: e2b74f232e84 87b95ce0964c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 17 14:56:45 2015 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc VFS updates from Al Viro:
     "This cycle a lot of stuff sits on topical branches, so I'll be sending
      more or less one pull request per branch.
    
      This is the first pile; more to follow in a few.  In this one are
      several misc commits from early in the cycle (before I went for
      separate branches), plus the rework of mntput/dput ordering on umount,
      switching to use of fs_pin instead of convoluted games in
      namespace_unlock()"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      switch the IO-triggering parts of umount to fs_pin
      new fs_pin killing logics
      allow attaching fs_pin to a group not associated with some superblock
      get rid of the second argument of acct_kill()
      take count and rcu_head out of fs_pin
      dcache: let the dentry count go down to zero without taking d_lock
      pull bumping refcount into ->kill()
      kill pin_put()
      mode_t whack-a-mole: chelsio
      file->f_path.dentry is pinned down for as long as the file is open...
      get rid of lustre_dump_dentry()
      gut proc_register() a bit
      kill d_validate()
      ncpfs: get rid of d_validate() nonsense
      selinuxfs: don't open-code d_genocide()

commit 503c358cf1925853195ee39ec437e51138bbb7df
Author: Vladimir Davydov <vdavydov@parallels.com>
Date:   Thu Feb 12 14:58:47 2015 -0800

    list_lru: introduce list_lru_shrink_{count,walk}
    
    Kmem accounting of memcg is unusable now, because it lacks slab shrinker
    support.  That means when we hit the limit we will get ENOMEM w/o any
    chance to recover.  What we should do then is to call shrink_slab, which
    would reclaim old inode/dentry caches from this cgroup.  This is what
    this patch set is intended to do.
    
    Basically, it does two things.  First, it introduces the notion of
    per-memcg slab shrinker.  A shrinker that wants to reclaim objects per
    cgroup should mark itself as SHRINKER_MEMCG_AWARE.  Then it will be
    passed the memory cgroup to scan from in shrink_control->memcg.  For
    such shrinkers shrink_slab iterates over the whole cgroup subtree under
    the target cgroup and calls the shrinker for each kmem-active memory
    cgroup.
    
    Secondly, this patch set makes the list_lru structure per-memcg.  It's
    done transparently to list_lru users - everything they have to do is to
    tell list_lru_init that they want memcg-aware list_lru.  Then the
    list_lru will automatically distribute objects among per-memcg lists
    basing on which cgroup the object is accounted to.  This way to make FS
    shrinkers (icache, dcache) memcg-aware we only need to make them use
    memcg-aware list_lru, and this is what this patch set does.
    
    As before, this patch set only enables per-memcg kmem reclaim when the
    pressure goes from memory.limit, not from memory.kmem.limit.  Handling
    memory.kmem.limit is going to be tricky due to GFP_NOFS allocations, and
    it is still unclear whether we will have this knob in the unified
    hierarchy.
    
    This patch (of 9):
    
    NUMA aware slab shrinkers use the list_lru structure to distribute
    objects coming from different NUMA nodes to different lists.  Whenever
    such a shrinker needs to count or scan objects from a particular node,
    it issues commands like this:
    
            count = list_lru_count_node(lru, sc->nid);
            freed = list_lru_walk_node(lru, sc->nid, isolate_func,
                                       isolate_arg, &sc->nr_to_scan);
    
    where sc is an instance of the shrink_control structure passed to it
    from vmscan.
    
    To simplify this, let's add special list_lru functions to be used by
    shrinkers, list_lru_shrink_count() and list_lru_shrink_walk(), which
    consolidate the nid and nr_to_scan arguments in the shrink_control
    structure.
    
    This will also allow us to avoid patching shrinkers that use list_lru
    when we make shrink_slab() per-memcg - all we will have to do is extend
    the shrink_control structure to include the target memcg and make
    list_lru_shrink_{count,walk} handle this appropriately.
    
    Signed-off-by: Vladimir Davydov <vdavydov@parallels.com>
    Suggested-by: Dave Chinner <david@fromorbit.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: Glauber Costa <glommer@gmail.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/internal.h b/fs/internal.h
index e9a61fe67575..d92c346a793d 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -14,6 +14,7 @@ struct file_system_type;
 struct linux_binprm;
 struct path;
 struct mount;
+struct shrink_control;
 
 /*
  * block_dev.c
@@ -111,8 +112,7 @@ extern int open_check_o_direct(struct file *f);
  * inode.c
  */
 extern spinlock_t inode_sb_list_lock;
-extern long prune_icache_sb(struct super_block *sb, unsigned long nr_to_scan,
-			    int nid);
+extern long prune_icache_sb(struct super_block *sb, struct shrink_control *sc);
 extern void inode_add_lru(struct inode *inode);
 
 /*
@@ -129,8 +129,7 @@ extern int invalidate_inodes(struct super_block *, bool);
  */
 extern struct dentry *__d_alloc(struct super_block *, const struct qstr *);
 extern int d_set_mounted(struct dentry *dentry);
-extern long prune_dcache_sb(struct super_block *sb, unsigned long nr_to_scan,
-			    int nid);
+extern long prune_dcache_sb(struct super_block *sb, struct shrink_control *sc);
 
 /*
  * read_write.c

commit fdab684d7202774bfd8762d4a656a553b787c8ec
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jan 11 10:57:27 2015 -0500

    allow attaching fs_pin to a group not associated with some superblock
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index e9a61fe67575..a6efd2f09ba3 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -145,7 +145,7 @@ extern const struct file_operations pipefifo_fops;
 /*
  * fs_pin.c
  */
-extern void sb_pin_kill(struct super_block *sb);
+extern void group_pin_kill(struct hlist_head *p);
 extern void mnt_pin_kill(struct mount *m);
 
 /*

commit e149ed2b805fefdccf7ccdfc19eca22fdd4514ac
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Nov 1 10:57:28 2014 -0400

    take the targets of /proc/*/ns/* symlinks to separate fs
    
    New pseudo-filesystem: nsfs.  Targets of /proc/*/ns/* live there now.
    It's not mountable (not even registered, so it's not in /proc/filesystems,
    etc.).  Files on it *are* bindable - we explicitly permit that in do_loopback().
    
    This stuff lives in fs/nsfs.c now; proc_ns_fget() moved there as well.
    get_proc_ns() is a macro now (it's simply returning ->i_private; would
    have been an inline, if not for header ordering headache).
    proc_ns_inode() is an ex-parrot.  The interface used in procfs is
    ns_get_path(path, task, ops) and ns_get_name(buf, size, task, ops).
    
    Dentries and inodes are never hashed; a non-counting reference to dentry
    is stashed in ns_common (removed by ->d_prune()) and reused by ns_get_path()
    if present.  See ns_get_path()/ns_prune_dentry/nsfs_evict() for details
    of that mechanism.
    
    As the result, proc_ns_follow_link() has stopped poking in nd->path.mnt;
    it does nd_jump_link() on a consistent <vfsmount,dentry> pair it gets
    from ns_get_path().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 757ba2abf21e..e9a61fe67575 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -147,3 +147,8 @@ extern const struct file_operations pipefifo_fops;
  */
 extern void sb_pin_kill(struct super_block *sb);
 extern void mnt_pin_kill(struct mount *m);
+
+/*
+ * fs/nsfs.c
+ */
+extern struct dentry_operations ns_dentry_operations;

commit bd5d08569cc379f8366663a61558a9ce17c2e460
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Oct 24 00:14:35 2014 +0200

    vfs: export __inode_permission() to modules
    
    We need to be able to check inode permissions (but not filesystem implied
    permissions) for stackable filesystems.  Expose this interface for overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/internal.h b/fs/internal.h
index 0f0626a6997c..757ba2abf21e 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -47,7 +47,6 @@ extern void __init chrdev_init(void);
 /*
  * namei.c
  */
-extern int __inode_permission(struct inode *, int);
 extern int user_path_mountpoint_at(int, const char __user *, unsigned int, struct path *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct path *);

commit 1c118596a7682912106c80007102ce0184c77780
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Oct 24 00:14:35 2014 +0200

    vfs: export do_splice_direct() to modules
    
    Export do_splice_direct() to modules.  Needed by overlay filesystem.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/internal.h b/fs/internal.h
index 9477f8f6aefc..0f0626a6997c 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -138,12 +138,6 @@ extern long prune_dcache_sb(struct super_block *sb, unsigned long nr_to_scan,
  */
 extern int rw_verify_area(int, struct file *, const loff_t *, size_t);
 
-/*
- * splice.c
- */
-extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
-		loff_t *opos, size_t len, unsigned int flags);
-
 /*
  * pipe.c
  */

commit 77c688ac87183537ed0fb84ec2cb8fa8ec97c458
Merge: 5e40d331bd72 a457606a6f81
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 13 11:28:42 2014 +0200

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
     "The big thing in this pile is Eric's unmount-on-rmdir series; we
      finally have everything we need for that.  The final piece of prereqs
      is delayed mntput() - now filesystem shutdown always happens on
      shallow stack.
    
      Other than that, we have several new primitives for iov_iter (Matt
      Wilcox, culled from his XIP-related series) pushing the conversion to
      ->read_iter()/ ->write_iter() a bit more, a bunch of fs/dcache.c
      cleanups and fixes (including the external name refcounting, which
      gives consistent behaviour of d_move() wrt procfs symlinks for long
      and short names alike) and assorted cleanups and fixes all over the
      place.
    
      This is just the first pile; there's a lot of stuff from various
      people that ought to go in this window.  Starting with
      unionmount/overlayfs mess...  ;-/"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (60 commits)
      fs/file_table.c: Update alloc_file() comment
      vfs: Deduplicate code shared by xattr system calls operating on paths
      reiserfs: remove pointless forward declaration of struct nameidata
      don't need that forward declaration of struct nameidata in dcache.h anymore
      take dname_external() into fs/dcache.c
      let path_init() failures treated the same way as subsequent link_path_walk()
      fix misuses of f_count() in ppp and netlink
      ncpfs: use list_for_each_entry() for d_subdirs walk
      vfs: move getname() from callers to do_mount()
      gfs2_atomic_open(): skip lookups on hashed dentry
      [infiniband] remove pointless assignments
      gadgetfs: saner API for gadgetfs_create_file()
      f_fs: saner API for ffs_sb_create_file()
      jfs: don't hash direct inode
      [s390] remove pointless assignment of ->f_op in vmlogrdr ->open()
      ecryptfs: ->f_op is never NULL
      android: ->f_op is never NULL
      nouveau: __iomem misannotations
      missing annotation in fs/file.c
      fs: namespace: suppress 'may be used uninitialized' warnings
      ...

commit 4db96b71e3caea5bb39053d57683129e0682c66f
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Thu Oct 9 15:26:55 2014 -0700

    vfs: guard end of device for mpage interface
    
    Add guard_bio_eod() check for mpage code in order to allow us to do IO
    even on the odd last sectors of a device, even if the block size is some
    multiple of the physical sector size.
    
    Using mpage_readpages() for block device requires this guard check.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/internal.h b/fs/internal.h
index e325b4f9c799..b2623200107b 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -34,6 +34,11 @@ static inline int __sync_blockdev(struct block_device *bdev, int wait)
 }
 #endif
 
+/*
+ * buffer.c
+ */
+extern void guard_bio_eod(int rw, struct bio *bio);
+
 /*
  * char_dev.c
  */

commit b8850d1fa8e2f6653e57daf6d08e58c5f5eb2c85
Author: Tim Gardner <tim.gardner@canonical.com>
Date:   Thu Aug 28 11:26:03 2014 -0600

    fs: namespace: suppress 'may be used uninitialized' warnings
    
    The gcc version 4.9.1 compiler complains Even though it isn't possible for
    these variables to not get initialized before they are used.
    
    fs/namespace.c: In function SyS_mount:
    fs/namespace.c:2720:8: warning: kernel_dev may be used uninitialized in this function [-Wmaybe-uninitialized]
      ret = do_mount(kernel_dev, kernel_dir->name, kernel_type, flags,
            ^
    fs/namespace.c:2699:8: note: kernel_dev was declared here
      char *kernel_dev;
            ^
    fs/namespace.c:2720:8: warning: kernel_type may be used uninitialized in this function [-Wmaybe-uninitialized]
      ret = do_mount(kernel_dev, kernel_dir->name, kernel_type, flags,
            ^
    fs/namespace.c:2697:8: note: kernel_type was declared here
      char *kernel_type;
            ^
    
    Fix the warnings by simplifying copy_mount_string() as suggested by Al Viro.
    
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index e325b4f9c799..bd4ac19f4d8f 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -51,7 +51,7 @@ extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
  * namespace.c
  */
 extern int copy_mount_options(const void __user *, unsigned long *);
-extern int copy_mount_string(const void __user *, char **);
+extern char *copy_mount_string(const void __user *);
 
 extern struct vfsmount *lookup_mnt(struct path *);
 extern int finish_automount(struct vfsmount *, struct path *);

commit 8fa1f1c2bd86007beb4a4845e6087ac4a704dc80
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 21 18:22:52 2014 -0400

    make fs/{namespace,super}.c forget about acct.h
    
    These externs belong in fs/internal.h.  Rename (they are not acct-specific
    anymore) and move them over there.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 9a2edba87c2b..e325b4f9c799 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -143,3 +143,9 @@ extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
  * pipe.c
  */
 extern const struct file_operations pipefifo_fops;
+
+/*
+ * fs_pin.c
+ */
+extern void sb_pin_kill(struct super_block *sb);
+extern void mnt_pin_kill(struct mount *m);

commit ed44724b79d8e03a40665436019cf22baba80d30
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 19 14:37:20 2014 -0400

    acct: switch to __kernel_write()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 465742407466..9a2edba87c2b 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -131,7 +131,6 @@ extern long prune_dcache_sb(struct super_block *sb, unsigned long nr_to_scan,
 /*
  * read_write.c
  */
-extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
 extern int rw_verify_area(int, struct file *, const loff_t *, size_t);
 
 /*

commit eee5cc2702929fd41cce28058dc6d6717f723f87
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 4 11:06:42 2013 -0400

    get rid of s_files and files_lock
    
    The only thing we need it for is alt-sysrq-r (emergency remount r/o)
    and these days we can do just as well without going through the
    list of files.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 4a11e75ce14d..465742407466 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -73,9 +73,6 @@ extern void chroot_fs_refs(const struct path *, const struct path *);
 /*
  * file_table.c
  */
-extern void file_sb_list_add(struct file *f, struct super_block *sb);
-extern void file_sb_list_del(struct file *f);
-extern void mark_files_ro(struct super_block *);
 extern struct file *get_empty_filp(void);
 
 /*

commit 719ea2fbb553ab3f61a174a4b5861289dcc46cb1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Sep 29 11:24:49 2013 -0400

    new helpers: lock_mount_hash/unlock_mount_hash
    
    aka br_write_{lock,unlock} of vfsmount_lock.  Inlines in fs/mount.h,
    vfsmount_lock extern moved over there as well.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 513e0d859a6c..4a11e75ce14d 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -9,8 +9,6 @@
  * 2 of the License, or (at your option) any later version.
  */
 
-#include <linux/lglock.h>
-
 struct super_block;
 struct file_system_type;
 struct linux_binprm;
@@ -62,8 +60,6 @@ extern int sb_prepare_remount_readonly(struct super_block *);
 
 extern void __init mnt_init(void);
 
-extern struct lglock vfsmount_lock;
-
 extern int __mnt_want_write(struct vfsmount *);
 extern int __mnt_want_write_file(struct file *);
 extern void __mnt_drop_write(struct vfsmount *);

commit 9b17c62382dd2e7507984b9890bf44e070cdd8bb
Author: Dave Chinner <dchinner@redhat.com>
Date:   Wed Aug 28 10:18:05 2013 +1000

    fs: convert inode and dentry shrinking to be node aware
    
    Now that the shrinker is passing a node in the scan control structure, we
    can pass this to the the generic LRU list code to isolate reclaim to the
    lists on matching nodes.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Glauber Costa <glommer@parallels.com>
    Acked-by: Mel Gorman <mgorman@suse.de>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Cc: Arve Hjnnevg <arve@android.com>
    Cc: Carlos Maiolino <cmaiolino@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Gleb Natapov <gleb@redhat.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: J. Bruce Fields <bfields@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Kent Overstreet <koverstreet@google.com>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index cb83a3417a68..513e0d859a6c 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -114,7 +114,8 @@ extern int open_check_o_direct(struct file *f);
  * inode.c
  */
 extern spinlock_t inode_sb_list_lock;
-extern long prune_icache_sb(struct super_block *sb, unsigned long nr_to_scan);
+extern long prune_icache_sb(struct super_block *sb, unsigned long nr_to_scan,
+			    int nid);
 extern void inode_add_lru(struct inode *inode);
 
 /*
@@ -131,7 +132,8 @@ extern int invalidate_inodes(struct super_block *, bool);
  */
 extern struct dentry *__d_alloc(struct super_block *, const struct qstr *);
 extern int d_set_mounted(struct dentry *dentry);
-extern long prune_dcache_sb(struct super_block *sb, unsigned long nr_to_scan);
+extern long prune_dcache_sb(struct super_block *sb, unsigned long nr_to_scan,
+			    int nid);
 
 /*
  * read_write.c

commit 0a234c6dcb79a270803f5c9773ed650b78730962
Author: Dave Chinner <dchinner@redhat.com>
Date:   Wed Aug 28 10:17:57 2013 +1000

    shrinker: convert superblock shrinkers to new API
    
    Convert superblock shrinker to use the new count/scan API, and propagate
    the API changes through to the filesystem callouts.  The filesystem
    callouts already use a count/scan API, so it's just changing counters to
    longs to match the VM API.
    
    This requires the dentry and inode shrinker callouts to be converted to
    the count/scan API.  This is mainly a mechanical change.
    
    [glommer@openvz.org: use mult_frac for fractional proportions, build fixes]
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Glauber Costa <glommer@openvz.org>
    Acked-by: Mel Gorman <mgorman@suse.de>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Cc: Arve Hjnnevg <arve@android.com>
    Cc: Carlos Maiolino <cmaiolino@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Gleb Natapov <gleb@redhat.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: J. Bruce Fields <bfields@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Kent Overstreet <koverstreet@google.com>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index b6495659d6e8..cb83a3417a68 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -114,6 +114,7 @@ extern int open_check_o_direct(struct file *f);
  * inode.c
  */
 extern spinlock_t inode_sb_list_lock;
+extern long prune_icache_sb(struct super_block *sb, unsigned long nr_to_scan);
 extern void inode_add_lru(struct inode *inode);
 
 /*
@@ -130,6 +131,7 @@ extern int invalidate_inodes(struct super_block *, bool);
  */
 extern struct dentry *__d_alloc(struct super_block *, const struct qstr *);
 extern int d_set_mounted(struct dentry *dentry);
+extern long prune_dcache_sb(struct super_block *sb, unsigned long nr_to_scan);
 
 /*
  * read_write.c

commit 3942c07ccf98e66b8893f396dca98f5b076f905f
Author: Glauber Costa <glommer@openvz.org>
Date:   Wed Aug 28 10:17:53 2013 +1000

    fs: bump inode and dentry counters to long
    
    This series reworks our current object cache shrinking infrastructure in
    two main ways:
    
     * Noticing that a lot of users copy and paste their own version of LRU
       lists for objects, we put some effort in providing a generic version.
       It is modeled after the filesystem users: dentries, inodes, and xfs
       (for various tasks), but we expect that other users could benefit in
       the near future with little or no modification.  Let us know if you
       have any issues.
    
     * The underlying list_lru being proposed automatically and
       transparently keeps the elements in per-node lists, and is able to
       manipulate the node lists individually.  Given this infrastructure, we
       are able to modify the up-to-now hammer called shrink_slab to proceed
       with node-reclaim instead of always searching memory from all over like
       it has been doing.
    
    Per-node lru lists are also expected to lead to less contention in the lru
    locks on multi-node scans, since we are now no longer fighting for a
    global lock.  The locks usually disappear from the profilers with this
    change.
    
    Although we have no official benchmarks for this version - be our guest to
    independently evaluate this - earlier versions of this series were
    performance tested (details at
    http://permalink.gmane.org/gmane.linux.kernel.mm/100537) yielding no
    visible performance regressions while yielding a better qualitative
    behavior in NUMA machines.
    
    With this infrastructure in place, we can use the list_lru entry point to
    provide memcg isolation and per-memcg targeted reclaim.  Historically,
    those two pieces of work have been posted together.  This version presents
    only the infrastructure work, deferring the memcg work for a later time,
    so we can focus on getting this part tested.  You can see more about the
    history of such work at http://lwn.net/Articles/552769/
    
    Dave Chinner (18):
      dcache: convert dentry_stat.nr_unused to per-cpu counters
      dentry: move to per-sb LRU locks
      dcache: remove dentries from LRU before putting on dispose list
      mm: new shrinker API
      shrinker: convert superblock shrinkers to new API
      list: add a new LRU list type
      inode: convert inode lru list to generic lru list code.
      dcache: convert to use new lru list infrastructure
      list_lru: per-node list infrastructure
      shrinker: add node awareness
      fs: convert inode and dentry shrinking to be node aware
      xfs: convert buftarg LRU to generic code
      xfs: rework buffer dispose list tracking
      xfs: convert dquot cache lru to list_lru
      fs: convert fs shrinkers to new scan/count API
      drivers: convert shrinkers to new count/scan API
      shrinker: convert remaining shrinkers to count/scan API
      shrinker: Kill old ->shrink API.
    
    Glauber Costa (7):
      fs: bump inode and dentry counters to long
      super: fix calculation of shrinkable objects for small numbers
      list_lru: per-node API
      vmscan: per-node deferred work
      i915: bail out earlier when shrinker cannot acquire mutex
      hugepage: convert huge zero page shrinker to new shrinker API
      list_lru: dynamically adjust node arrays
    
    This patch:
    
    There are situations in very large machines in which we can have a large
    quantity of dirty inodes, unused dentries, etc.  This is particularly true
    when umounting a filesystem, where eventually since every live object will
    eventually be discarded.
    
    Dave Chinner reported a problem with this while experimenting with the
    shrinker revamp patchset.  So we believe it is time for a change.  This
    patch just moves int to longs.  Machines where it matters should have a
    big long anyway.
    
    Signed-off-by: Glauber Costa <glommer@openvz.org>
    Cc: Dave Chinner <dchinner@redhat.com>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Cc: Arve Hjnnevg <arve@android.com>
    Cc: Carlos Maiolino <cmaiolino@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Dave Chinner <dchinner@redhat.com>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Gleb Natapov <gleb@redhat.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: J. Bruce Fields <bfields@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Kent Overstreet <koverstreet@google.com>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 2be46ea5dd0b..b6495659d6e8 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -121,7 +121,7 @@ extern void inode_add_lru(struct inode *inode);
  */
 extern void inode_wb_list_del(struct inode *inode);
 
-extern int get_nr_dirty_inodes(void);
+extern long get_nr_dirty_inodes(void);
 extern void evict_inodes(struct super_block *);
 extern int invalidate_inodes(struct super_block *, bool);
 

commit 197df04c749a07616621b762e699b1fff4102fac
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Sep 8 14:03:27 2013 -0400

    rename user_path_umountat() to user_path_mountpoint_at()
    
    ... and move the extern from linux/namei.h to fs/internal.h,
    along with that of vfs_path_lookup().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index d20893795526..2be46ea5dd0b 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -45,6 +45,9 @@ extern void __init chrdev_init(void);
  * namei.c
  */
 extern int __inode_permission(struct inode *, int);
+extern int user_path_mountpoint_at(int, const char __user *, unsigned int, struct path *);
+extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
+			   const char *, unsigned int, struct path *);
 
 /*
  * namespace.c

commit eed810076685c77dc9a8c5c3593e641c93caed1c
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Thu Sep 5 14:39:11 2013 +0200

    vfs: check unlinked ancestors before mount
    
    We check submounts before doing d_drop() on a non-empty directory dentry in
    NFS (have_submounts()), but we do not exclude a racing mount.  Nor do we
    prevent mounts to be added to the disconnected subtree using relative paths
    after the d_drop().
    
    This patch fixes these issues by checking for unlinked (unhashed, non-root)
    ancestors before proceeding with the mount.  This is done with rename
    seqlock taken for write and with ->d_lock grabbed on each ancestor in turn,
    including our dentry itself.  This ensures that the only one of
    check_submounts_and_drop() or has_unlinked_ancestor() can succeed.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 7c5f01cf619d..d20893795526 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -126,6 +126,7 @@ extern int invalidate_inodes(struct super_block *, bool);
  * dcache.c
  */
 extern struct dentry *__d_alloc(struct super_block *, const struct qstr *);
+extern int d_set_mounted(struct dentry *dentry);
 
 /*
  * read_write.c

commit 68d70d03f8f5bd10a0e7337210b13f536fd4aeb9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jun 19 15:26:04 2013 +0400

    constify rw_verify_area()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index f6ad34362823..7c5f01cf619d 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -131,6 +131,7 @@ extern struct dentry *__d_alloc(struct super_block *, const struct qstr *);
  * read_write.c
  */
 extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
+extern int rw_verify_area(int, struct file *, const loff_t *, size_t);
 
 /*
  * splice.c

commit f9652e10c12b43d9bb957269745cf2fa5682fa92
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jun 11 08:23:01 2013 +0400

    allow build_open_flags() to return an error
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 68121584ae37..f6ad34362823 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -96,11 +96,12 @@ struct open_flags {
 	umode_t mode;
 	int acc_mode;
 	int intent;
+	int lookup_flags;
 };
 extern struct file *do_filp_open(int dfd, struct filename *pathname,
-		const struct open_flags *op, int flags);
+		const struct open_flags *op);
 extern struct file *do_file_open_root(struct dentry *, struct vfsmount *,
-		const char *, const struct open_flags *, int lookup_flags);
+		const char *, const struct open_flags *);
 
 extern long do_handle_open(int mountdirfd,
 			   struct file_handle __user *ufh, int open_flag);

commit 7995bd287134f6c8f80d94bebe7396f05a9bc42b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 20 18:58:36 2013 +0400

    splice: don't pass the address of ->f_pos to methods
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index eaa75f75b625..68121584ae37 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -131,6 +131,12 @@ extern struct dentry *__d_alloc(struct super_block *, const struct qstr *);
  */
 extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
 
+/*
+ * splice.c
+ */
+extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
+		loff_t *opos, size_t len, unsigned int flags);
+
 /*
  * pipe.c
  */

commit 599a0ac14e065b7c08471ef2e75a504b7dec9267
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Mar 12 09:58:10 2013 -0400

    pipe: fold file_operations instances in one
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 4be78237d896..eaa75f75b625 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -130,3 +130,8 @@ extern struct dentry *__d_alloc(struct super_block *, const struct qstr *);
  * read_write.c
  */
 extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
+
+/*
+ * pipe.c
+ */
+extern const struct file_operations pipefifo_fops;

commit 06ae43f34bcc07a0b6be8bf78a1c895bcd12c839
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Mar 20 13:19:30 2013 -0400

    Don't bother with redoing rw_verify_area() from default_file_splice_from()
    
    default_file_splice_from() ends up calling vfs_write() (via very convoluted
    callchain).  It's an overkill, since we already have done rw_verify_area()
    in the caller by the time we call vfs_write() we are under set_fs(KERNEL_DS),
    so access_ok() is also pointless.  Add a new helper (__kernel_write()),
    use it instead of kernel_write() in there.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 507141fceb99..4be78237d896 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -125,3 +125,8 @@ extern int invalidate_inodes(struct super_block *, bool);
  * dcache.c
  */
 extern struct dentry *__d_alloc(struct super_block *, const struct qstr *);
+
+/*
+ * read_write.c
+ */
+extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);

commit dcf787f39162ce32ca325b3e784aba2d2444619a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 1 23:51:07 2013 -0500

    constify path_get/path_put and fs_struct.c stuff
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 2f6af7f645eb..507141fceb99 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -69,7 +69,7 @@ extern void __mnt_drop_write_file(struct file *);
 /*
  * fs_struct.c
  */
-extern void chroot_fs_refs(struct path *, struct path *);
+extern void chroot_fs_refs(const struct path *, const struct path *);
 
 /*
  * file_table.c

commit 4eff96dd5283a102e0c1cac95247090be74a38ed
Author: Jan Kara <jack@suse.cz>
Date:   Mon Nov 26 16:29:51 2012 -0800

    writeback: put unused inodes to LRU after writeback completion
    
    Commit 169ebd90131b ("writeback: Avoid iput() from flusher thread")
    removed iget-iput pair from inode writeback.  As a side effect, inodes
    that are dirty during iput_final() call won't be ever added to inode LRU
    (iput_final() doesn't add dirty inodes to LRU and later when the inode
    is cleaned there's noone to add the inode there).  Thus inodes are
    effectively unreclaimable until someone looks them up again.
    
    The practical effect of this bug is limited by the fact that inodes are
    pinned by a dentry for long enough that the inode gets cleaned.  But
    still the bug can have nasty consequences leading up to OOM conditions
    under certain circumstances.  Following can easily reproduce the
    problem:
    
      for (( i = 0; i < 1000; i++ )); do
        mkdir $i
        for (( j = 0; j < 1000; j++ )); do
          touch $i/$j
          echo 2 > /proc/sys/vm/drop_caches
        done
      done
    
    then one needs to run 'sync; ls -lR' to make inodes reclaimable again.
    
    We fix the issue by inserting unused clean inodes into the LRU after
    writeback finishes in inode_sync_complete().
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Reported-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Cc: Wu Fengguang <fengguang.wu@intel.com>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: <stable@vger.kernel.org>            [3.5+]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/internal.h b/fs/internal.h
index 916b7cbf3e3e..2f6af7f645eb 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -110,6 +110,7 @@ extern int open_check_o_direct(struct file *f);
  * inode.c
  */
 extern spinlock_t inode_sb_list_lock;
+extern void inode_add_lru(struct inode *inode);
 
 /*
  * fs-writeback.c

commit 669abf4e5539c8aa48bf28c965be05c0a7b58a27
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 10 16:43:10 2012 -0400

    vfs: make path_openat take a struct filename pointer
    
    ...and fix up the callers. For do_file_open_root, just declare a
    struct filename on the stack and fill out the .name field. For
    do_filp_open, make it also take a struct filename pointer, and fix up its
    callers to call it appropriately.
    
    For filp_open, add a variant that takes a struct filename pointer and turn
    filp_open into a wrapper around it.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 371bcc4b1697..916b7cbf3e3e 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -97,8 +97,8 @@ struct open_flags {
 	int acc_mode;
 	int intent;
 };
-extern struct file *do_filp_open(int dfd, const char *pathname,
-		const struct open_flags *op, int lookup_flags);
+extern struct file *do_filp_open(int dfd, struct filename *pathname,
+		const struct open_flags *op, int flags);
 extern struct file *do_file_open_root(struct dentry *, struct vfsmount *,
 		const char *, const struct open_flags *, int lookup_flags);
 

commit eb04c28288bb0098d0e75d81ba2a575239de71d8
Author: Jan Kara <jack@suse.cz>
Date:   Tue Jun 12 16:20:35 2012 +0200

    fs: Add freezing handling to mnt_want_write() / mnt_drop_write()
    
    Most of places where we want freeze protection coincides with the places where
    we also have remount-ro protection. So make mnt_want_write() and
    mnt_drop_write() (and their _file alternative) prevent freezing as well.
    For the few cases that are really interested only in remount-ro protection
    provide new function variants.
    
    BugLink: https://bugs.launchpad.net/bugs/897421
    Tested-by: Kamal Mostafa <kamal@canonical.com>
    Tested-by: Peter M. Petrakis <peter.petrakis@canonical.com>
    Tested-by: Dann Frazier <dann.frazier@canonical.com>
    Tested-by: Massimo Morana <massimo.morana@canonical.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index a6fd56c68b11..371bcc4b1697 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -61,6 +61,10 @@ extern void __init mnt_init(void);
 
 extern struct lglock vfsmount_lock;
 
+extern int __mnt_want_write(struct vfsmount *);
+extern int __mnt_want_write_file(struct file *);
+extern void __mnt_drop_write(struct vfsmount *);
+extern void __mnt_drop_write_file(struct file *);
 
 /*
  * fs_struct.c

commit 0bdaea9017b9d2b9996e153a71ee03555969b80e
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jun 25 12:55:46 2012 +0100

    VFS: Split inode_permission()
    
    Split inode_permission() into inode- and superblock-dependent parts.
    
    This is aimed at unionmounts where the superblock from the upper layer has to
    be checked rather than the superblock from the lower layer as the upper layer
    may be writable, thus allowing an unwritable file from the lower layer to be
    copied up and modified.
    
    Original-author: Valerie Aurora <vaurora@redhat.com>
    Signed-off-by: David Howells <dhowells@redhat.com> (Further development)
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 8a9f5fa840f1..a6fd56c68b11 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -41,6 +41,11 @@ static inline int __sync_blockdev(struct block_device *bdev, int wait)
  */
 extern void __init chrdev_init(void);
 
+/*
+ * namei.c
+ */
+extern int __inode_permission(struct inode *, int);
+
 /*
  * namespace.c
  */

commit 30d904947459cca2beb69e0110716f5248b31f2a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 22 12:40:19 2012 +0400

    kill struct opendata
    
    Just pass struct file *.  Methods are happier that way...
    There's no need to return struct file * from finish_open() now,
    so let it return int.  Next: saner prototypes for parts in
    namei.c
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 09003a02292d..8a9f5fa840f1 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -82,9 +82,6 @@ extern struct super_block *user_get_super(dev_t);
 /*
  * open.c
  */
-struct opendata {
-	struct file *filp;
-};
 struct open_flags {
 	int open_flag;
 	umode_t mode;

commit a4a3bdd778715999ddfeefdc52ab76254580fa76
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jun 10 05:55:37 2012 -0400

    kill opendata->{mnt,dentry}
    
    ->filp->f_path is there for purpose...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index ae69a3b150d7..09003a02292d 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -83,8 +83,6 @@ extern struct super_block *user_get_super(dev_t);
  * open.c
  */
 struct opendata {
-	struct dentry *dentry;
-	struct vfsmount *mnt;
 	struct file *filp;
 };
 struct open_flags {

commit 015c3bbcd88df2305aae5b017a9c91c08b380aa1
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Jun 5 15:10:27 2012 +0200

    vfs: remove open intents from nameidata
    
    All users of open intents have been converted to use ->atomic_{open,create}.
    
    This patch gets rid of nd->intent.open and related infrastructure.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 70067775df2e..ae69a3b150d7 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -82,13 +82,10 @@ extern struct super_block *user_get_super(dev_t);
 /*
  * open.c
  */
-struct nameidata;
-extern struct file *nameidata_to_filp(struct nameidata *);
-extern void release_open_intent(struct nameidata *);
 struct opendata {
 	struct dentry *dentry;
 	struct vfsmount *mnt;
-	struct file **filp;
+	struct file *filp;
 };
 struct open_flags {
 	int open_flag;

commit d18e9008c377dc6a6d2166a6840bf3a23a5867fd
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Jun 5 15:10:17 2012 +0200

    vfs: add i_op->atomic_open()
    
    Add a new inode operation which is called on the last component of an open.
    Using this the filesystem can look up, possibly create and open the file in one
    atomic operation.  If it cannot perform this (e.g. the file type turned out to
    be wrong) it may signal this by returning NULL instead of an open struct file
    pointer.
    
    i_op->atomic_open() is only called if the last component is negative or needs
    lookup.  Handling cached positive dentries here doesn't add much value: these
    can be opened using f_op->open().  If the cached file turns out to be invalid,
    the open can be retried, this time using ->atomic_open() with a fresh dentry.
    
    For now leave the old way of using open intents in lookup and revalidate in
    place.  This will be removed once all the users are converted.
    
    David Howells noticed that if ->atomic_open() opens the file but does not create
    it, handle_truncate() will be called on it even if it is not a regular file.
    Fix this by checking the file type in this case too.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index d2a23ff61b40..70067775df2e 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -85,6 +85,11 @@ extern struct super_block *user_get_super(dev_t);
 struct nameidata;
 extern struct file *nameidata_to_filp(struct nameidata *);
 extern void release_open_intent(struct nameidata *);
+struct opendata {
+	struct dentry *dentry;
+	struct vfsmount *mnt;
+	struct file **filp;
+};
 struct open_flags {
 	int open_flag;
 	umode_t mode;

commit f7a99c5b7c8bd3d3f533c8b38274e33f3da9096e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jun 9 00:59:08 2012 -0400

    get rid of ->mnt_longterm
    
    it's enough to set ->mnt_ns of internal vfsmounts to something
    distinct from all struct mnt_namespace out there; then we can
    just use the check for ->mnt_ns != NULL in the fast path of
    mntput_no_expire()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 18bc216ea09d..d2a23ff61b40 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -50,8 +50,6 @@ extern int copy_mount_string(const void __user *, char **);
 extern struct vfsmount *lookup_mnt(struct path *);
 extern int finish_automount(struct vfsmount *, struct path *);
 
-extern void mnt_make_longterm(struct vfsmount *);
-extern void mnt_make_shortterm(struct vfsmount *);
 extern int sb_prepare_remount_readonly(struct super_block *);
 
 extern void __init mnt_init(void);

commit 90ad1a8ecb9bfd5ff4503ac42cd049a97643ee51
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Mon May 21 17:30:15 2012 +0200

    vfs: split __dentry_open()
    
    Split __dentry_open() into two functions:
    
      do_dentry_open() - does most of the actual work, doesn't put file on failure
      open_check_o_direct() - after a successful open, checks direct_IO method
    
    This will allow i_op->atomic_open to do just the file initialization and leave
    the direct_IO checking to the VFS.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 8040af489c78..18bc216ea09d 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -100,6 +100,7 @@ extern struct file *do_file_open_root(struct dentry *, struct vfsmount *,
 
 extern long do_handle_open(int mountdirfd,
 			   struct file_handle __user *ufh, int open_flag);
+extern int open_check_o_direct(struct file *f);
 
 /*
  * inode.c

commit eea62f831b8030b0eeea8314eed73b6132d1de26
Author: Andi Kleen <ak@linux.intel.com>
Date:   Tue May 8 13:32:24 2012 +0930

    brlocks/lglocks: turn into functions
    
    lglocks and brlocks are currently generated with some complicated macros
    in lglock.h.  But there's no reason to not just use common utility
    functions and put all the data into a common data structure.
    
    Since there are at least two users it makes sense to share this code in a
    library.  This is also easier maintainable than a macro forest.
    
    This will also make it later possible to dynamically allocate lglocks and
    also use them in modules (this would both still need some additional, but
    now straightforward, code)
    
    [akpm@linux-foundation.org: checkpatch fixes]
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 9962c59ba280..8040af489c78 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -56,7 +56,7 @@ extern int sb_prepare_remount_readonly(struct super_block *);
 
 extern void __init mnt_init(void);
 
-DECLARE_BRLOCK(vfsmount_lock);
+extern struct lglock vfsmount_lock;
 
 
 /*

commit 4ed5e82fe77f4147cf386327c9a63a2dd7eff518
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Mon Nov 21 12:11:31 2011 +0100

    vfs: protect remounting superblock read-only
    
    Currently remouting superblock read-only is racy in a major way.
    
    With the per mount read-only infrastructure it is now possible to
    prevent most races, which this patch attempts.
    
    Before starting the remount read-only, iterate through all mounts
    belonging to the superblock and if none of them have any pending
    writes, set sb->s_readonly_remount.  This indicates that remount is in
    progress and no further write requests are allowed.  If the remount
    succeeds set MS_RDONLY and reset s_readonly_remount.
    
    If the remounting is unsuccessful just reset s_readonly_remount.
    This can result in transient EROFS errors, despite the fact the
    remount failed.  Unfortunately hodling off writes is difficult as
    remount itself may touch the filesystem (e.g. through load_nls())
    which would deadlock.
    
    A later patch deals with delayed writes due to nlink going to zero.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Tested-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 2523a4029452..9962c59ba280 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -52,6 +52,7 @@ extern int finish_automount(struct vfsmount *, struct path *);
 
 extern void mnt_make_longterm(struct vfsmount *);
 extern void mnt_make_shortterm(struct vfsmount *);
+extern int sb_prepare_remount_readonly(struct super_block *);
 
 extern void __init mnt_init(void);
 

commit ece2ccb668046610189d88d6aaf05aeb09c988a1
Merge: d10577a8d86a a218d0fdc5f9 ff01bb483265
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jan 6 23:15:54 2012 -0500

    Merge branches 'vfsmount-guts', 'umode_t' and 'partitions' into Z

commit c71053659e3bb27d44b79da0bb4abf5838c2060a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 24 18:22:03 2011 -0500

    vfs: spread struct mount - __lookup_mnt() result
    
    switch __lookup_mnt() to returning struct mount *; callers adjusted.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 7b1cb1528ac2..6aab61a4f36f 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -15,6 +15,7 @@ struct super_block;
 struct file_system_type;
 struct linux_binprm;
 struct path;
+struct mount;
 
 /*
  * block_dev.c
@@ -46,7 +47,6 @@ extern void __init chrdev_init(void);
 extern int copy_mount_options(const void __user *, unsigned long *);
 extern int copy_mount_string(const void __user *, char **);
 
-extern struct vfsmount *__lookup_mnt(struct vfsmount *, struct dentry *, int);
 extern struct vfsmount *lookup_mnt(struct path *);
 extern int finish_automount(struct vfsmount *, struct path *);
 

commit a218d0fdc5f9004164ff151d274487f6799907d0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 21 14:59:34 2011 -0500

    switch open and mkdir syscalls to umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 7b1cb1528ac2..23599f88d1a5 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -88,7 +88,7 @@ extern struct file *nameidata_to_filp(struct nameidata *);
 extern void release_open_intent(struct nameidata *);
 struct open_flags {
 	int open_flag;
-	int mode;
+	umode_t mode;
 	int acc_mode;
 	int intent;
 };

commit cf31e70d6cf93f19fe9bf1144966ef40991ac723
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jan 2 22:28:36 2012 -0500

    vfs: new helper - vfs_ustat()
    
    ... and bury user_get_super()/statfs_by_dentry() - they are
    purely internal now.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 839d3f9e9173..7b1cb1528ac2 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -78,6 +78,7 @@ extern int do_remount_sb(struct super_block *, int, void *, int);
 extern bool grab_super_passive(struct super_block *sb);
 extern struct dentry *mount_fs(struct file_system_type *,
 			       int, const char *, void *);
+extern struct super_block *user_get_super(dev_t);
 
 /*
  * open.c

commit f47ec3f28354795f000c14bf18ed967ec81a3ec3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 21 21:15:42 2011 -0500

    trim fs/internal.h
    
    some stuff in there can actually become static; some belongs to pnode.h
    as it's a private interface between namespace.c and pnode.c...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index fe327c20af83..839d3f9e9173 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -20,14 +20,8 @@ struct path;
  * block_dev.c
  */
 #ifdef CONFIG_BLOCK
-extern struct super_block *blockdev_superblock;
 extern void __init bdev_cache_init(void);
 
-static inline int sb_is_blkdev_sb(struct super_block *sb)
-{
-	return sb == blockdev_superblock;
-}
-
 extern int __sync_blockdev(struct block_device *bdev, int wait);
 
 #else
@@ -35,11 +29,6 @@ static inline void bdev_cache_init(void)
 {
 }
 
-static inline int sb_is_blkdev_sb(struct super_block *sb)
-{
-	return 0;
-}
-
 static inline int __sync_blockdev(struct block_device *bdev, int wait)
 {
 	return 0;
@@ -51,25 +40,14 @@ static inline int __sync_blockdev(struct block_device *bdev, int wait)
  */
 extern void __init chrdev_init(void);
 
-/*
- * exec.c
- */
-extern int check_unsafe_exec(struct linux_binprm *);
-
 /*
  * namespace.c
  */
 extern int copy_mount_options(const void __user *, unsigned long *);
 extern int copy_mount_string(const void __user *, char **);
 
-extern unsigned int mnt_get_count(struct vfsmount *mnt);
 extern struct vfsmount *__lookup_mnt(struct vfsmount *, struct dentry *, int);
 extern struct vfsmount *lookup_mnt(struct path *);
-extern void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
-				struct vfsmount *);
-extern void release_mounts(struct list_head *);
-extern void umount_tree(struct vfsmount *, int, struct list_head *);
-extern struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
 extern int finish_automount(struct vfsmount *, struct path *);
 
 extern void mnt_make_longterm(struct vfsmount *);
@@ -98,8 +76,6 @@ extern struct file *get_empty_filp(void);
  */
 extern int do_remount_sb(struct super_block *, int, void *, int);
 extern bool grab_super_passive(struct super_block *sb);
-extern void __put_super(struct super_block *sb);
-extern void put_super(struct super_block *sb);
 extern struct dentry *mount_fs(struct file_system_type *,
 			       int, const char *, void *);
 

commit 12ad3ab66103e6582ca69c0c9de18b13487eaaef
Author: Dave Chinner <dchinner@redhat.com>
Date:   Fri Jul 8 14:14:41 2011 +1000

    superblock: move pin_sb_for_writeback() to fs/super.c
    
    The per-sb shrinker has the same requirement as the writeback
    threads of ensuring that the superblock is usable and pinned for the
    time it takes to run the work. Both need to take a passive reference
    to the sb, take a read lock on the s_umount lock and then only
    continue if an unmount is not in progress.
    
    pin_sb_for_writeback() does this exactly, so move it to fs/super.c
    and rename it to grab_super_passive() and exporting it via
    fs/internal.h for all the VFS code to be able to use.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index ae47c48bedde..fe327c20af83 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -97,6 +97,7 @@ extern struct file *get_empty_filp(void);
  * super.c
  */
 extern int do_remount_sb(struct super_block *, int, void *, int);
+extern bool grab_super_passive(struct super_block *sb);
 extern void __put_super(struct super_block *sb);
 extern void put_super(struct super_block *sb);
 extern struct dentry *mount_fs(struct file_system_type *,

commit a4464dbc0ca6a3ab8e9d1206bc05059dae2a559d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jul 7 15:03:58 2011 -0400

    Make ->d_sb assign-once and always non-NULL
    
    New helper (non-exported, fs/internal.h-only): __d_alloc(sb, name).
    Allocates dentry, sets its ->d_sb to given superblock and sets
    ->d_op accordingly.  Old d_alloc(NULL, name) callers are converted
    to that (all of them know what superblock they want).  d_alloc()
    itself is left only for parent != NULl case; uses __d_alloc(),
    inserts result into the list of parent's children.
    
    Note that now ->d_sb is assign-once and never NULL *and*
    ->d_parent is never NULL either.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index b29c46e4e32f..ae47c48bedde 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -135,3 +135,8 @@ extern void inode_wb_list_del(struct inode *inode);
 extern int get_nr_dirty_inodes(void);
 extern void evict_inodes(struct super_block *);
 extern int invalidate_inodes(struct super_block *, bool);
+
+/*
+ * dcache.c
+ */
+extern struct dentry *__d_alloc(struct super_block *, const struct qstr *);

commit a66979abad090b2765a6c6790c9fdeab996833f2
Author: Dave Chinner <dchinner@redhat.com>
Date:   Tue Mar 22 22:23:41 2011 +1100

    fs: move i_wb_list out from under inode_lock
    
    Protect the inode writeback list with a new global lock
    inode_wb_list_lock and use it to protect the list manipulations and
    traversals. This lock replaces the inode_lock as the inodes on the
    list can be validity checked while holding the inode->i_lock and
    hence the inode_lock is no longer needed to protect the list.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 7013ae0c88c1..b29c46e4e32f 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -127,6 +127,11 @@ extern long do_handle_open(int mountdirfd,
  */
 extern spinlock_t inode_sb_list_lock;
 
+/*
+ * fs-writeback.c
+ */
+extern void inode_wb_list_del(struct inode *inode);
+
 extern int get_nr_dirty_inodes(void);
 extern void evict_inodes(struct super_block *);
 extern int invalidate_inodes(struct super_block *, bool);

commit 55fa6091d83160ca772fc37cebae45d42695a708
Author: Dave Chinner <dchinner@redhat.com>
Date:   Tue Mar 22 22:23:40 2011 +1100

    fs: move i_sb_list out from under inode_lock
    
    Protect the per-sb inode list with a new global lock
    inode_sb_list_lock and use it to protect the list manipulations and
    traversals. This lock replaces the inode_lock as the inodes on the
    list can be validity checked while holding the inode->i_lock and
    hence the inode_lock is no longer needed to protect the list.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 8318059b42c6..7013ae0c88c1 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -125,6 +125,8 @@ extern long do_handle_open(int mountdirfd,
 /*
  * inode.c
  */
+extern spinlock_t inode_sb_list_lock;
+
 extern int get_nr_dirty_inodes(void);
 extern void evict_inodes(struct super_block *);
 extern int invalidate_inodes(struct super_block *, bool);

commit 0f60f240d522772467c7d2cebedb910748c78ed4
Author: David Howells <dhowells@redhat.com>
Date:   Mon Mar 21 14:28:58 2011 +0000

    FS: lookup_mnt() is only used in the core fs routines now
    
    lookup_mnt() is only used in the core fs routines now, so it doesn't need to
    be globally declared anymore.  It isn't exported to modules at the moment, so
    nothing that can be modularised seems to be using it.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 17191546d527..8318059b42c6 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -64,6 +64,7 @@ extern int copy_mount_string(const void __user *, char **);
 
 extern unsigned int mnt_get_count(struct vfsmount *mnt);
 extern struct vfsmount *__lookup_mnt(struct vfsmount *, struct dentry *, int);
+extern struct vfsmount *lookup_mnt(struct path *);
 extern void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
 				struct vfsmount *);
 extern void release_mounts(struct list_head *);

commit 9d412a43c3b26e1e549319e5eec26f0829f9f74d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Mar 17 22:08:28 2011 -0400

    vfs: split off vfsmount-related parts of vfs_kern_mount()
    
    new function: mount_fs().  Does all work done by vfs_kern_mount()
    except the allocation and filling of vfsmount; returns root dentry
    or ERR_PTR().
    
    vfs_kern_mount() switched to using it and taken to fs/namespace.c,
    along with its wrappers.
    
    alloc_vfsmnt()/free_vfsmnt() made static.
    
    functions in namespace.c slightly reordered.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index f3d15de44b15..17191546d527 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -12,6 +12,7 @@
 #include <linux/lglock.h>
 
 struct super_block;
+struct file_system_type;
 struct linux_binprm;
 struct path;
 
@@ -61,8 +62,6 @@ extern int check_unsafe_exec(struct linux_binprm *);
 extern int copy_mount_options(const void __user *, unsigned long *);
 extern int copy_mount_string(const void __user *, char **);
 
-extern void free_vfsmnt(struct vfsmount *);
-extern struct vfsmount *alloc_vfsmnt(const char *);
 extern unsigned int mnt_get_count(struct vfsmount *mnt);
 extern struct vfsmount *__lookup_mnt(struct vfsmount *, struct dentry *, int);
 extern void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
@@ -99,6 +98,8 @@ extern struct file *get_empty_filp(void);
 extern int do_remount_sb(struct super_block *, int, void *, int);
 extern void __put_super(struct super_block *sb);
 extern void put_super(struct super_block *sb);
+extern struct dentry *mount_fs(struct file_system_type *,
+			       int, const char *, void *);
 
 /*
  * open.c

commit becfd1f37544798cbdfd788f32c827160fab98c1
Author: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
Date:   Sat Jan 29 18:43:26 2011 +0530

    vfs: Add open by file handle support
    
    [AV: duplicate of open() guts removed; file_open_root() used instead]
    
    Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 52abc5287f50..f3d15de44b15 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -117,6 +117,9 @@ extern struct file *do_filp_open(int dfd, const char *pathname,
 extern struct file *do_file_open_root(struct dentry *, struct vfsmount *,
 		const char *, const struct open_flags *, int lookup_flags);
 
+extern long do_handle_open(int mountdirfd,
+			   struct file_handle __user *ufh, int open_flag);
+
 /*
  * inode.c
  */

commit 73d049a40fc6269189c4e2ba6792cb5dd054883c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 11 12:08:24 2011 -0500

    open-style analog of vfs_path_lookup()
    
    new function: file_open_root(dentry, mnt, name, flags) opens the file
    vfs_path_lookup would arrive to.
    
    Note that name can be empty; in that case the usual requirement that
    dentry should be a directory is lifted.
    
    open-coded equivalents switched to it, may_open() got down exactly
    one caller and became static.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 6fdbdf2c6047..52abc5287f50 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -114,6 +114,8 @@ struct open_flags {
 };
 extern struct file *do_filp_open(int dfd, const char *pathname,
 		const struct open_flags *op, int lookup_flags);
+extern struct file *do_file_open_root(struct dentry *, struct vfsmount *,
+		const char *, const struct open_flags *, int lookup_flags);
 
 /*
  * inode.c

commit 47c805dc2d2dff686962f5f0baa6bac2d703ba19
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Feb 23 17:44:09 2011 -0500

    switch do_filp_open() to struct open_flags
    
    take calculation of open_flags by open(2) arguments into new helper
    in fs/open.c, move filp_open() over there, have it and do_sys_open()
    use that helper, switch exec.c callers of do_filp_open() to explicit
    (and constant) struct open_flags.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 9b976b57d7fe..6fdbdf2c6047 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -106,6 +106,14 @@ extern void put_super(struct super_block *sb);
 struct nameidata;
 extern struct file *nameidata_to_filp(struct nameidata *);
 extern void release_open_intent(struct nameidata *);
+struct open_flags {
+	int open_flag;
+	int mode;
+	int acc_mode;
+	int intent;
+};
+extern struct file *do_filp_open(int dfd, const char *pathname,
+		const struct open_flags *op, int lookup_flags);
 
 /*
  * inode.c

commit 93b270f76e7ef3b81001576860c2701931cdc78b
Author: NeilBrown <neilb@suse.de>
Date:   Thu Feb 24 17:25:47 2011 +1100

    Fix over-zealous flush_disk when changing device size.
    
    There are two cases when we call flush_disk.
    In one, the device has disappeared (check_disk_change) so any
    data will hold becomes irrelevant.
    In the oter, the device has changed size (check_disk_size_change)
    so data we hold may be irrelevant.
    
    In both cases it makes sense to discard any 'clean' buffers,
    so they will be read back from the device if needed.
    
    In the former case it makes sense to discard 'dirty' buffers
    as there will never be anywhere safe to write the data.  In the
    second case it *does*not* make sense to discard dirty buffers
    as that will lead to file system corruption when you simply enlarge
    the containing devices.
    
    flush_disk calls __invalidate_devices.
    __invalidate_device calls both invalidate_inodes and invalidate_bdev.
    
    invalidate_inodes *does* discard I_DIRTY inodes and this does lead
    to fs corruption.
    
    invalidate_bev *does*not* discard dirty pages, but I don't really care
    about that at present.
    
    So this patch adds a flag to __invalidate_device (calling it
    __invalidate_device2) to indicate whether dirty buffers should be
    killed, and this is passed to invalidate_inodes which can choose to
    skip dirty inodes.
    
    flusk_disk then passes true from check_disk_change and false from
    check_disk_size_change.
    
    dm avoids tripping over this problem by calling i_size_write directly
    rathher than using check_disk_size_change.
    
    md does use check_disk_size_change and so is affected.
    
    This regression was introduced by commit 608aeef17a which causes
    check_disk_size_change to call flush_disk, so it is suitable for any
    kernel since 2.6.27.
    
    Cc: stable@kernel.org
    Acked-by: Jeff Moyer <jmoyer@redhat.com>
    Cc: Andrew Patterson <andrew.patterson@hp.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/fs/internal.h b/fs/internal.h
index 0663568b1247..9b976b57d7fe 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -112,4 +112,4 @@ extern void release_open_intent(struct nameidata *);
  */
 extern int get_nr_dirty_inodes(void);
 extern void evict_inodes(struct super_block *);
-extern int invalidate_inodes(struct super_block *);
+extern int invalidate_inodes(struct super_block *, bool);

commit b1e75df45a3d8a490b8648e44632debc5eea04b1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jan 17 01:47:59 2011 -0500

    tidy up around finish_automount()
    
    do_add_mount() and mnt_clear_expiry() are not needed outside of
    namespace.c anymore, now that namei has finish_automount() to
    use.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index e8a0b245177d..0663568b1247 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -71,8 +71,6 @@ extern void release_mounts(struct list_head *);
 extern void umount_tree(struct vfsmount *, int, struct list_head *);
 extern struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
 extern int finish_automount(struct vfsmount *, struct path *);
-extern int do_add_mount(struct vfsmount *, struct path *, int);
-extern void mnt_clear_expiry(struct vfsmount *);
 
 extern void mnt_make_longterm(struct vfsmount *);
 extern void mnt_make_shortterm(struct vfsmount *);

commit 19a167af7c97248ec646552ebc9140bc6aa3552a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jan 17 01:35:23 2011 -0500

    Take the completion of automount into new helper
    
    ... and shift it from namei.c to namespace.c
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 12ccb86edef7..e8a0b245177d 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -70,6 +70,7 @@ extern void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
 extern void release_mounts(struct list_head *);
 extern void umount_tree(struct vfsmount *, int, struct list_head *);
 extern struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
+extern int finish_automount(struct vfsmount *, struct path *);
 extern int do_add_mount(struct vfsmount *, struct path *, int);
 extern void mnt_clear_expiry(struct vfsmount *);
 

commit f03c65993b98eeb909a4012ce7833c5857d74755
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jan 14 22:30:21 2011 -0500

    sanitize vfsmount refcounting changes
    
    Instead of splitting refcount between (per-cpu) mnt_count
    and (SMP-only) mnt_longrefs, make all references contribute
    to mnt_count again and keep track of how many are longterm
    ones.
    
    Accounting rules for longterm count:
            * 1 for each fs_struct.root.mnt
            * 1 for each fs_struct.pwd.mnt
            * 1 for having non-NULL ->mnt_ns
            * decrement to 0 happens only under vfsmount lock exclusive
    
    That allows nice common case for mntput() - since we can't drop the
    final reference until after mnt_longterm has reached 0 due to the rules
    above, mntput() can grab vfsmount lock shared and check mnt_longterm.
    If it turns out to be non-zero (which is the common case), we know
    that this is not the final mntput() and can just blindly decrement
    percpu mnt_count.  Otherwise we grab vfsmount lock exclusive and
    do usual decrement-and-check of percpu mnt_count.
    
    For fs_struct.c we have mnt_make_longterm() and mnt_make_shortterm();
    namespace.c uses the latter in places where we don't already hold
    vfsmount lock exclusive and opencodes a few remaining spots where
    we need to manipulate mnt_longterm.
    
    Note that we mostly revert the code outside of fs/namespace.c back
    to what we used to have; in particular, normal code doesn't need
    to care about two kinds of references, etc.  And we get to keep
    the optimization Nick's variant had bought us...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 4931060fd089..12ccb86edef7 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -73,6 +73,9 @@ extern struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
 extern int do_add_mount(struct vfsmount *, struct path *, int);
 extern void mnt_clear_expiry(struct vfsmount *);
 
+extern void mnt_make_longterm(struct vfsmount *);
+extern void mnt_make_shortterm(struct vfsmount *);
+
 extern void __init mnt_init(void);
 
 DECLARE_BRLOCK(vfsmount_lock);

commit ea5b778a8b98c85a87d66bf844904f9c3802b869
Author: David Howells <dhowells@redhat.com>
Date:   Fri Jan 14 19:10:03 2011 +0000

    Unexport do_add_mount() and add in follow_automount(), not ->d_automount()
    
    Unexport do_add_mount() and make ->d_automount() return the vfsmount to be
    added rather than calling do_add_mount() itself.  follow_automount() will then
    do the addition.
    
    This slightly complicates things as ->d_automount() normally wants to add the
    new vfsmount to an expiration list and start an expiration timer.  The problem
    with that is that the vfsmount will be deleted if it has a refcount of 1 and
    the timer will not repeat if the expiration list is empty.
    
    To this end, we require the vfsmount to be returned from d_automount() with a
    refcount of (at least) 2.  One of these refs will be dropped unconditionally.
    In addition, follow_automount() must get a 3rd ref around the call to
    do_add_mount() lest it eat a ref and return an error, leaving the mount we
    have open to being expired as we would otherwise have only 1 ref on it.
    
    d_automount() should also add the the vfsmount to the expiration list (by
    calling mnt_set_expiry()) and start the expiration timer before returning, if
    this mechanism is to be used.  The vfsmount will be unlinked from the
    expiration list by follow_automount() if do_add_mount() fails.
    
    This patch also fixes the call to do_add_mount() for AFS to propagate the mount
    flags from the parent vfsmount.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 9687c2ee2735..4931060fd089 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -70,6 +70,8 @@ extern void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
 extern void release_mounts(struct list_head *);
 extern void umount_tree(struct vfsmount *, int, struct list_head *);
 extern struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
+extern int do_add_mount(struct vfsmount *, struct path *, int);
+extern void mnt_clear_expiry(struct vfsmount *);
 
 extern void __init mnt_init(void);
 

commit b3e19d924b6eaf2ca7d22cba99a517c5171007b6
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:50:11 2011 +1100

    fs: scale mntget/mntput
    
    The problem that this patch aims to fix is vfsmount refcounting scalability.
    We need to take a reference on the vfsmount for every successful path lookup,
    which often go to the same mount point.
    
    The fundamental difficulty is that a "simple" reference count can never be made
    scalable, because any time a reference is dropped, we must check whether that
    was the last reference. To do that requires communication with all other CPUs
    that may have taken a reference count.
    
    We can make refcounts more scalable in a couple of ways, involving keeping
    distributed counters, and checking for the global-zero condition less
    frequently.
    
    - check the global sum once every interval (this will delay zero detection
      for some interval, so it's probably a showstopper for vfsmounts).
    
    - keep a local count and only taking the global sum when local reaches 0 (this
      is difficult for vfsmounts, because we can't hold preempt off for the life of
      a reference, so a counter would need to be per-thread or tied strongly to a
      particular CPU which requires more locking).
    
    - keep a local difference of increments and decrements, which allows us to sum
      the total difference and hence find the refcount when summing all CPUs. Then,
      keep a single integer "long" refcount for slow and long lasting references,
      and only take the global sum of local counters when the long refcount is 0.
    
    This last scheme is what I implemented here. Attached mounts and process root
    and working directory references are "long" references, and everything else is
    a short reference.
    
    This allows scalable vfsmount references during path walking over mounted
    subtrees and unattached (lazy umounted) mounts with processes still running
    in them.
    
    This results in one fewer atomic op in the fastpath: mntget is now just a
    per-CPU inc, rather than an atomic inc; and mntput just requires a spinlock
    and non-atomic decrement in the common case. However code is otherwise bigger
    and heavier, so single threaded performance is basically a wash.
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/fs/internal.h b/fs/internal.h
index e43b9a4dbf4e..9687c2ee2735 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -63,6 +63,7 @@ extern int copy_mount_string(const void __user *, char **);
 
 extern void free_vfsmnt(struct vfsmount *);
 extern struct vfsmount *alloc_vfsmnt(const char *);
+extern unsigned int mnt_get_count(struct vfsmount *mnt);
 extern struct vfsmount *__lookup_mnt(struct vfsmount *, struct dentry *, int);
 extern void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
 				struct vfsmount *);

commit a4cdbd8bfb87ceff455aae85727077889b75001b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 29 05:49:13 2010 -0400

    braino in internal.h
    
    wrong return type...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index ebad3b90752d..e43b9a4dbf4e 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -106,5 +106,5 @@ extern void release_open_intent(struct nameidata *);
  * inode.c
  */
 extern int get_nr_dirty_inodes(void);
-extern int evict_inodes(struct super_block *);
+extern void evict_inodes(struct super_block *);
 extern int invalidate_inodes(struct super_block *);

commit 63997e98a3be68d7cec806d22bf9b02b2e1daabb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Oct 25 20:49:35 2010 -0400

    split invalidate_inodes()
    
    Pull removal of fsnotify marks into generic_shutdown_super().
    Split umount-time work into a new function - evict_inodes().
    Make sure that invalidate_inodes() will be able to cope with
    I_FREEING once we change locking in iput().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 4cc67eb6ed56..ebad3b90752d 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -106,4 +106,5 @@ extern void release_open_intent(struct nameidata *);
  * inode.c
  */
 extern int get_nr_dirty_inodes(void);
+extern int evict_inodes(struct super_block *);
 extern int invalidate_inodes(struct super_block *);

commit cffbc8aa334f55c9ed42d25202eb3ebf3a97c195
Author: Dave Chinner <dchinner@redhat.com>
Date:   Sat Oct 23 05:03:02 2010 -0400

    fs: Convert nr_inodes and nr_unused to per-cpu counters
    
    The number of inodes allocated does not need to be tied to the
    addition or removal of an inode to/from a list. If we are not tied
    to a list lock, we could update the counters when inodes are
    initialised or destroyed, but to do that we need to convert the
    counters to be per-cpu (i.e. independent of a lock). This means that
    we have the freedom to change the list/locking implementation
    without needing to care about the counters.
    
    Based on a patch originally from Eric Dumazet.
    
    [AV: cleaned up a bit, fixed build breakage on weird configs
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index f6dce46d80dc..4cc67eb6ed56 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -105,4 +105,5 @@ extern void release_open_intent(struct nameidata *);
 /*
  * inode.c
  */
+extern int get_nr_dirty_inodes(void);
 extern int invalidate_inodes(struct super_block *);

commit a8dade34e3df581bc36ca2afe6e27055e178801c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Oct 24 11:13:10 2010 -0400

    unexport invalidate_inodes
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index a6910e91cee8..f6dce46d80dc 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -101,3 +101,8 @@ extern void put_super(struct super_block *sb);
 struct nameidata;
 extern struct file *nameidata_to_filp(struct nameidata *);
 extern void release_open_intent(struct nameidata *);
+
+/*
+ * inode.c
+ */
+extern int invalidate_inodes(struct super_block *);

commit 99b7db7b8ffd6bb755eb0a175596421a0b581cb2
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Wed Aug 18 04:37:39 2010 +1000

    fs: brlock vfsmount_lock
    
    fs: brlock vfsmount_lock
    
    Use a brlock for the vfsmount lock. It must be taken for write whenever
    modifying the mount hash or associated fields, and may be taken for read when
    performing mount hash lookups.
    
    A new lock is added for the mnt-id allocator, so it doesn't need to take
    the heavy vfsmount write-lock.
    
    The number of atomics should remain the same for fastpath rlock cases, though
    code would be slightly slower due to per-cpu access. Scalability is not not be
    much improved in common cases yet, due to other locks (ie. dcache_lock) getting
    in the way. However path lookups crossing mountpoints should be one case where
    scalability is improved (currently requiring the global lock).
    
    The slowpath is slower due to use of brlock. On a 64 core, 64 socket, 32 node
    Altix system (high latency to remote nodes), a simple umount microbenchmark
    (mount --bind mnt mnt2 ; umount mnt2 loop 1000 times), before this patch it
    took 6.8s, afterwards took 7.1s, about 5% slower.
    
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 6a5c13a80660..a6910e91cee8 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -9,6 +9,8 @@
  * 2 of the License, or (at your option) any later version.
  */
 
+#include <linux/lglock.h>
+
 struct super_block;
 struct linux_binprm;
 struct path;
@@ -70,7 +72,8 @@ extern struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
 
 extern void __init mnt_init(void);
 
-extern spinlock_t vfsmount_lock;
+DECLARE_BRLOCK(vfsmount_lock);
+
 
 /*
  * fs_struct.c

commit d996b62a8df1d935b01319bf8defb95b5709f7b8
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Wed Aug 18 04:37:36 2010 +1000

    tty: fix fu_list abuse
    
    tty: fix fu_list abuse
    
    tty code abuses fu_list, which causes a bug in remount,ro handling.
    
    If a tty device node is opened on a filesystem, then the last link to the inode
    removed, the filesystem will be allowed to be remounted readonly. This is
    because fs_may_remount_ro does not find the 0 link tty inode on the file sb
    list (because the tty code incorrectly removed it to use for its own purpose).
    This can result in a filesystem with errors after it is marked "clean".
    
    Taking idea from Christoph's initial patch, allocate a tty private struct
    at file->private_data and put our required list fields in there, linking
    file and tty. This makes tty nodes behave the same way as other device nodes
    and avoid meddling with the vfs, and avoids this bug.
    
    The error handling is not trivial in the tty code, so for this bugfix, I take
    the simple approach of using __GFP_NOFAIL and don't worry about memory errors.
    This is not a problem because our allocator doesn't fail small allocs as a rule
    anyway. So proper error handling is left as an exercise for tty hackers.
    
    [ Arguably filesystem's device inode would ideally be divorced from the
    driver's pseudo inode when it is opened, but in practice it's not clear whether
    that will ever be worth implementing. ]
    
    Cc: linux-kernel@vger.kernel.org
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 6b706bc60a66..6a5c13a80660 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -80,6 +80,8 @@ extern void chroot_fs_refs(struct path *, struct path *);
 /*
  * file_table.c
  */
+extern void file_sb_list_add(struct file *f, struct super_block *sb);
+extern void file_sb_list_del(struct file *f);
 extern void mark_files_ro(struct super_block *);
 extern struct file *get_empty_filp(void);
 

commit 35cf7ba0b46dc3582a01c3860b14bff122662aa3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Mar 22 21:13:53 2010 -0400

    Bury __put_super_and_need_restart()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 8a03a5447bdf..6b706bc60a66 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -87,6 +87,8 @@ extern struct file *get_empty_filp(void);
  * super.c
  */
 extern int do_remount_sb(struct super_block *, int, void *, int);
+extern void __put_super(struct super_block *sb);
+extern void put_super(struct super_block *sb);
 
 /*
  * open.c

commit 47cd813f2984569570021ce3d34cdf9cb20aa6a2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Feb 5 02:01:14 2010 -0500

    Take vfsmount_lock to fs/internal.h
    
    no more users left outside of fs/*.c (and very few outside of
    fs/namespace.c, actually)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index e96a1667d749..8a03a5447bdf 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -70,6 +70,8 @@ extern struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
 
 extern void __init mnt_init(void);
 
+extern spinlock_t vfsmount_lock;
+
 /*
  * fs_struct.c
  */

commit 482928d59db668b8d82a48717f78986d8cea72e9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Dec 19 10:10:39 2009 -0500

    Fix f_flags/f_mode in case of lookup_instantiate_filp() from open(pathname, 3)
    
    Just set f_flags when shoving struct file into nameidata; don't
    postpone that until __dentry_open().  do_filp_open() has correct
    value; lookup_instantiate_filp() doesn't - we lose the difference
    between O_RDWR and 3 by that point.
    
    We still set .intent.open.flags, so no fs code needs to be changed.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index f67cd141d9a8..e96a1667d749 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -85,3 +85,10 @@ extern struct file *get_empty_filp(void);
  * super.c
  */
 extern int do_remount_sb(struct super_block *, int, void *, int);
+
+/*
+ * open.c
+ */
+struct nameidata;
+extern struct file *nameidata_to_filp(struct nameidata *);
+extern void release_open_intent(struct nameidata *);

commit e81e3f4dca6c54116a24aec217d2c15c6f58ada5
Author: Eric Paris <eparis@redhat.com>
Date:   Fri Dec 4 15:47:36 2009 -0500

    fs: move get_empty_filp() deffinition to internal.h
    
    All users outside of fs/ of get_empty_filp() have been removed.  This patch
    moves the definition from the include/ directory to internal.h so no new
    users crop up and removes the EXPORT_SYMBOL.  I'd love to see open intents
    stop using it too, but that's a problem for another day and a smarter
    developer!
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 515175b8b72e..f67cd141d9a8 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -79,6 +79,7 @@ extern void chroot_fs_refs(struct path *, struct path *);
  * file_table.c
  */
 extern void mark_files_ro(struct super_block *);
+extern struct file *get_empty_filp(void);
 
 /*
  * super.c

commit eca6f534e61919b28fb21aafbd1c2983deae75be
Author: Vegard Nossum <vegard.nossum@gmail.com>
Date:   Fri Sep 18 13:05:45 2009 -0700

    fs: fix overflow in sys_mount() for in-kernel calls
    
    sys_mount() reads/copies a whole page for its "type" parameter.  When
    do_mount_root() passes a kernel address that points to an object which is
    smaller than a whole page, copy_mount_options() will happily go past this
    memory object, possibly dereferencing "wild" pointers that could be in any
    state (hence the kmemcheck warning, which shows that parts of the next
    page are not even allocated).
    
    (The likelihood of something going wrong here is pretty low -- first of
    all this only applies to kernel calls to sys_mount(), which are mostly
    found in the boot code.  Secondly, I guess if the page was not mapped,
    exact_copy_from_user() _would_ in fact handle it correctly because of its
    access_ok(), etc.  checks.)
    
    But it is much nicer to avoid the dubious reads altogether, by stopping as
    soon as we find a NUL byte.  Is there a good reason why we can't do
    something like this, using the already existing strndup_from_user()?
    
    [akpm@linux-foundation.org: make copy_mount_string() static]
    [AV: fix compat mount breakage, which involves undoing akpm's change above]
    
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Vegard Nossum <vegard.nossum@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Pekka Enberg <penberg@cs.helsinki.fi>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: al <al@dizzy.pdmi.ras.ru>

diff --git a/fs/internal.h b/fs/internal.h
index d55ef562f0bb..515175b8b72e 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -57,6 +57,7 @@ extern int check_unsafe_exec(struct linux_binprm *);
  * namespace.c
  */
 extern int copy_mount_options(const void __user *, unsigned long *);
+extern int copy_mount_string(const void __user *, char **);
 
 extern void free_vfsmnt(struct vfsmount *);
 extern struct vfsmount *alloc_vfsmnt(const char *);

commit 62c6943b4b1e818aea60c11c5a68a50785b83119
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu May 7 03:12:29 2009 -0400

    Trim a bit of crap from fs.h
    
    do_remount_sb() is fs/internal.h fodder, fsync_no_super() is long gone.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index dbec3cc28338..d55ef562f0bb 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -78,3 +78,8 @@ extern void chroot_fs_refs(struct path *, struct path *);
  * file_table.c
  */
 extern void mark_files_ro(struct super_block *);
+
+/*
+ * super.c
+ */
+extern int do_remount_sb(struct super_block *, int, void *, int);

commit 5cee5815d1564bbbd505fea86f4550f1efdb5cd0
Author: Jan Kara <jack@suse.cz>
Date:   Mon Apr 27 16:43:51 2009 +0200

    vfs: Make sys_sync() use fsync_super() (version 4)
    
    It is unnecessarily fragile to have two places (fsync_super() and do_sync())
    doing data integrity sync of the filesystem. Alter __fsync_super() to
    accommodate needs of both callers and use it. So after this patch
    __fsync_super() is the only place where we gather all the calls needed to
    properly send all data on a filesystem to disk.
    
    Nice bonus is that we get a complete livelock avoidance and write_supers()
    is now only used for periodic writeback of superblocks.
    
    sync_blockdevs() introduced a couple of patches ago is gone now.
    
    [build fixes folded]
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 343a537ab809..dbec3cc28338 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -25,6 +25,8 @@ static inline int sb_is_blkdev_sb(struct super_block *sb)
 	return sb == blockdev_superblock;
 }
 
+extern int __sync_blockdev(struct block_device *bdev, int wait);
+
 #else
 static inline void bdev_cache_init(void)
 {
@@ -34,6 +36,11 @@ static inline int sb_is_blkdev_sb(struct super_block *sb)
 {
 	return 0;
 }
+
+static inline int __sync_blockdev(struct block_device *bdev, int wait)
+{
+	return 0;
+}
 #endif
 
 /*
@@ -71,12 +78,3 @@ extern void chroot_fs_refs(struct path *, struct path *);
  * file_table.c
  */
 extern void mark_files_ro(struct super_block *);
-
-/*
- * super.c
- */
-#ifdef CONFIG_BLOCK
-extern void sync_blockdevs(void);
-#else
-static inline void sync_blockdevs(void) { }
-#endif

commit 5a3e5cb8e08bd876e2542c1451c9a93dab1b0e39
Author: Jan Kara <jack@suse.cz>
Date:   Mon Apr 27 16:43:48 2009 +0200

    vfs: Fix sys_sync() and fsync_super() reliability (version 4)
    
    So far, do_sync() called:
      sync_inodes(0);
      sync_supers();
      sync_filesystems(0);
      sync_filesystems(1);
      sync_inodes(1);
    
    This ordering makes it kind of hard for filesystems as sync_inodes(0) need not
    submit all the IO (for example it skips inodes with I_SYNC set) so e.g. forcing
    transaction to disk in ->sync_fs() is not really enough. Therefore sys_sync has
    not been completely reliable on some filesystems (ext3, ext4, reiserfs, ocfs2
    and others are hit by this) when racing e.g. with background writeback. A
    similar problem hits also other filesystems (e.g. ext2) because of
    write_supers() being called before the sync_inodes(1).
    
    Change the ordering of calls in do_sync() - this requires a new function
    sync_blockdevs() to preserve the property that block devices are always synced
    after write_super() / sync_fs() call.
    
    The same issue is fixed in __fsync_super() function used on umount /
    remount read-only.
    
    [AV: build fixes]
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 6d4ef208ef65..343a537ab809 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -71,3 +71,12 @@ extern void chroot_fs_refs(struct path *, struct path *);
  * file_table.c
  */
 extern void mark_files_ro(struct super_block *);
+
+/*
+ * super.c
+ */
+#ifdef CONFIG_BLOCK
+extern void sync_blockdevs(void);
+#else
+static inline void sync_blockdevs(void) { }
+#endif

commit 864d7c4c068f23642efe91b33be3a84afe5f71e0
Author: npiggin@suse.de <npiggin@suse.de>
Date:   Sun Apr 26 20:25:56 2009 +1000

    fs: move mark_files_ro into file_table.c
    
    This function walks the s_files lock, and operates primarily on the
    files in a superblock, so it better belongs here (eg. see also
    fs_may_remount_ro).
    
    [AV: ... and it shouldn't be static after that move]
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index b4dac4fb6b61..6d4ef208ef65 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -66,3 +66,8 @@ extern void __init mnt_init(void);
  * fs_struct.c
  */
 extern void chroot_fs_refs(struct path *, struct path *);
+
+/*
+ * file_table.c
+ */
+extern void mark_files_ro(struct super_block *);

commit 498052bba55ecaff58db6a1436b0e25bfd75a7ff
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Mar 30 07:20:30 2009 -0400

    New locking/refcounting for fs_struct
    
    * all changes of current->fs are done under task_lock and write_lock of
      old fs->lock
    * refcount is not atomic anymore (same protection)
    * its decrements are done when removing reference from current; at the
      same time we decide whether to free it.
    * put_fs_struct() is gone
    * new field - ->in_exec.  Set by check_unsafe_exec() if we are trying to do
      execve() and only subthreads share fs_struct.  Cleared when finishing exec
      (success and failure alike).  Makes CLONE_FS fail with -EAGAIN if set.
    * check_unsafe_exec() may fail with -EAGAIN if another execve() from subthread
      is in progress.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 477a105f8df3..b4dac4fb6b61 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -44,7 +44,7 @@ extern void __init chrdev_init(void);
 /*
  * exec.c
  */
-extern void check_unsafe_exec(struct linux_binprm *);
+extern int check_unsafe_exec(struct linux_binprm *);
 
 /*
  * namespace.c

commit 3e93cd671813e204c258f1e6c797959920cf7772
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 29 19:00:13 2009 -0400

    Take fs_struct handling to new file (fs/fs_struct.c)
    
    Pure code move; two new helper functions for nfsd and daemonize
    (unshare_fs_struct() and daemonize_fs_struct() resp.; for now -
    the same code as used to be in callers).  unshare_fs_struct()
    exported (for nfsd, as copy_fs_struct()/exit_fs() used to be),
    copy_fs_struct() and exit_fs() don't need exports anymore.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 53af885f1732..477a105f8df3 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -11,6 +11,7 @@
 
 struct super_block;
 struct linux_binprm;
+struct path;
 
 /*
  * block_dev.c
@@ -60,3 +61,8 @@ extern void umount_tree(struct vfsmount *, int, struct list_head *);
 extern struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
 
 extern void __init mnt_init(void);
+
+/*
+ * fs_struct.c
+ */
+extern void chroot_fs_refs(struct path *, struct path *);

commit e426b64c412aaa3e9eb3e4b261dc5be0d5a83e78
Author: Hugh Dickins <hugh@veritas.com>
Date:   Sat Mar 28 23:20:19 2009 +0000

    fix setuid sometimes doesn't
    
    Joe Malicki reports that setuid sometimes doesn't: very rarely,
    a setuid root program does not get root euid; and, by the way,
    they have a health check running lsof every few minutes.
    
    Right, check_unsafe_exec() notes whether the files_struct is being
    shared by more threads than will get killed by the exec, and if so
    sets LSM_UNSAFE_SHARE to make bprm_set_creds() careful about euid.
    But /proc/<pid>/fd and /proc/<pid>/fdinfo lookups make transient
    use of get_files_struct(), which also raises that sharing count.
    
    There's a rather simple fix for this: exec's check on files->count
    has been redundant ever since 2.6.1 made it unshare_files() (except
    while compat_do_execve() omitted to do so) - just remove that check.
    
    [Note to -stable: this patch will not apply before 2.6.29: earlier
    releases should just remove the files->count line from unsafe_exec().]
    
    Reported-by: Joe Malicki <jmalicki@metacarta.com>
    Narrowed-down-by: Michael Itz <mitz@metacarta.com>
    Tested-by: Joe Malicki <jmalicki@metacarta.com>
    Signed-off-by: Hugh Dickins <hugh@veritas.com>
    Cc: stable@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/internal.h b/fs/internal.h
index 0d8ac497b3d5..53af885f1732 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -43,7 +43,7 @@ extern void __init chrdev_init(void);
 /*
  * exec.c
  */
-extern void check_unsafe_exec(struct linux_binprm *, struct files_struct *);
+extern void check_unsafe_exec(struct linux_binprm *);
 
 /*
  * namespace.c

commit 0bf2f3aec5474da80a60e1baca629af87ecb67b6
Author: David Howells <dhowells@redhat.com>
Date:   Fri Feb 6 11:45:46 2009 +0000

    CRED: Fix SUID exec regression
    
    The patch:
    
            commit a6f76f23d297f70e2a6b3ec607f7aeeea9e37e8d
            CRED: Make execve() take advantage of copy-on-write credentials
    
    moved the place in which the 'safeness' of a SUID/SGID exec was performed to
    before de_thread() was called.  This means that LSM_UNSAFE_SHARE is now
    calculated incorrectly.  This flag is set if any of the usage counts for
    fs_struct, files_struct and sighand_struct are greater than 1 at the time the
    determination is made.  All of which are true for threads created by the
    pthread library.
    
    However, since we wish to make the security calculation before irrevocably
    damaging the process so that we can return it an error code in the case where
    we decide we want to reject the exec request on this basis, we have to make the
    determination before calling de_thread().
    
    So, instead, we count up the number of threads (CLONE_THREAD) that are sharing
    our fs_struct (CLONE_FS), files_struct (CLONE_FILES) and sighand_structs
    (CLONE_SIGHAND/CLONE_THREAD) with us.  These will be killed by de_thread() and
    so can be discounted by check_unsafe_exec().
    
    We do have to be careful because CLONE_THREAD does not imply FS or FILES.
    
    We _assume_ that there will be no extra references to these structs held by the
    threads we're going to kill.
    
    This can be tested with the attached pair of programs.  Build the two programs
    using the Makefile supplied, and run ./test1 as a non-root user.  If
    successful, you should see something like:
    
            [dhowells@andromeda tmp]$ ./test1
            --TEST1--
            uid=4043, euid=4043 suid=4043
            exec ./test2
            --TEST2--
            uid=4043, euid=0 suid=0
            SUCCESS - Correct effective user ID
    
    and if unsuccessful, something like:
    
            [dhowells@andromeda tmp]$ ./test1
            --TEST1--
            uid=4043, euid=4043 suid=4043
            exec ./test2
            --TEST2--
            uid=4043, euid=4043 suid=4043
            ERROR - Incorrect effective user ID!
    
    The non-root user ID you see will depend on the user you run as.
    
    [test1.c]
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <pthread.h>
    
    static void *thread_func(void *arg)
    {
            while (1) {}
    }
    
    int main(int argc, char **argv)
    {
            pthread_t tid;
            uid_t uid, euid, suid;
    
            printf("--TEST1--\n");
            getresuid(&uid, &euid, &suid);
            printf("uid=%d, euid=%d suid=%d\n", uid, euid, suid);
    
            if (pthread_create(&tid, NULL, thread_func, NULL) < 0) {
                    perror("pthread_create");
                    exit(1);
            }
    
            printf("exec ./test2\n");
            execlp("./test2", "test2", NULL);
            perror("./test2");
            _exit(1);
    }
    
    [test2.c]
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    
    int main(int argc, char **argv)
    {
            uid_t uid, euid, suid;
    
            getresuid(&uid, &euid, &suid);
            printf("--TEST2--\n");
            printf("uid=%d, euid=%d suid=%d\n", uid, euid, suid);
    
            if (euid != 0) {
                    fprintf(stderr, "ERROR - Incorrect effective user ID!\n");
                    exit(1);
            }
            printf("SUCCESS - Correct effective user ID\n");
            exit(0);
    }
    
    [Makefile]
    CFLAGS = -D_GNU_SOURCE -Wall -Werror -Wunused
    all: test1 test2
    
    test1: test1.c
            gcc $(CFLAGS) -o test1 test1.c -lpthread
    
    test2: test2.c
            gcc $(CFLAGS) -o test2 test2.c
            sudo chown root.root test2
            sudo chmod +s test2
    
    Reported-by: David Smith <dsmith@redhat.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: David Smith <dsmith@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/fs/internal.h b/fs/internal.h
index 53af885f1732..0d8ac497b3d5 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -43,7 +43,7 @@ extern void __init chrdev_init(void);
 /*
  * exec.c
  */
-extern void check_unsafe_exec(struct linux_binprm *);
+extern void check_unsafe_exec(struct linux_binprm *, struct files_struct *);
 
 /*
  * namespace.c

commit a6f76f23d297f70e2a6b3ec607f7aeeea9e37e8d
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:24 2008 +1100

    CRED: Make execve() take advantage of copy-on-write credentials
    
    Make execve() take advantage of copy-on-write credentials, allowing it to set
    up the credentials in advance, and then commit the whole lot after the point
    of no return.
    
    This patch and the preceding patches have been tested with the LTP SELinux
    testsuite.
    
    This patch makes several logical sets of alteration:
    
     (1) execve().
    
         The credential bits from struct linux_binprm are, for the most part,
         replaced with a single credentials pointer (bprm->cred).  This means that
         all the creds can be calculated in advance and then applied at the point
         of no return with no possibility of failure.
    
         I would like to replace bprm->cap_effective with:
    
            cap_isclear(bprm->cap_effective)
    
         but this seems impossible due to special behaviour for processes of pid 1
         (they always retain their parent's capability masks where normally they'd
         be changed - see cap_bprm_set_creds()).
    
         The following sequence of events now happens:
    
         (a) At the start of do_execve, the current task's cred_exec_mutex is
             locked to prevent PTRACE_ATTACH from obsoleting the calculation of
             creds that we make.
    
         (a) prepare_exec_creds() is then called to make a copy of the current
             task's credentials and prepare it.  This copy is then assigned to
             bprm->cred.
    
             This renders security_bprm_alloc() and security_bprm_free()
             unnecessary, and so they've been removed.
    
         (b) The determination of unsafe execution is now performed immediately
             after (a) rather than later on in the code.  The result is stored in
             bprm->unsafe for future reference.
    
         (c) prepare_binprm() is called, possibly multiple times.
    
             (i) This applies the result of set[ug]id binaries to the new creds
                 attached to bprm->cred.  Personality bit clearance is recorded,
                 but now deferred on the basis that the exec procedure may yet
                 fail.
    
             (ii) This then calls the new security_bprm_set_creds().  This should
                 calculate the new LSM and capability credentials into *bprm->cred.
    
                 This folds together security_bprm_set() and parts of
                 security_bprm_apply_creds() (these two have been removed).
                 Anything that might fail must be done at this point.
    
             (iii) bprm->cred_prepared is set to 1.
    
                 bprm->cred_prepared is 0 on the first pass of the security
                 calculations, and 1 on all subsequent passes.  This allows SELinux
                 in (ii) to base its calculations only on the initial script and
                 not on the interpreter.
    
         (d) flush_old_exec() is called to commit the task to execution.  This
             performs the following steps with regard to credentials:
    
             (i) Clear pdeath_signal and set dumpable on certain circumstances that
                 may not be covered by commit_creds().
    
             (ii) Clear any bits in current->personality that were deferred from
                 (c.i).
    
         (e) install_exec_creds() [compute_creds() as was] is called to install the
             new credentials.  This performs the following steps with regard to
             credentials:
    
             (i) Calls security_bprm_committing_creds() to apply any security
                 requirements, such as flushing unauthorised files in SELinux, that
                 must be done before the credentials are changed.
    
                 This is made up of bits of security_bprm_apply_creds() and
                 security_bprm_post_apply_creds(), both of which have been removed.
                 This function is not allowed to fail; anything that might fail
                 must have been done in (c.ii).
    
             (ii) Calls commit_creds() to apply the new credentials in a single
                 assignment (more or less).  Possibly pdeath_signal and dumpable
                 should be part of struct creds.
    
             (iii) Unlocks the task's cred_replace_mutex, thus allowing
                 PTRACE_ATTACH to take place.
    
             (iv) Clears The bprm->cred pointer as the credentials it was holding
                 are now immutable.
    
             (v) Calls security_bprm_committed_creds() to apply any security
                 alterations that must be done after the creds have been changed.
                 SELinux uses this to flush signals and signal handlers.
    
         (f) If an error occurs before (d.i), bprm_free() will call abort_creds()
             to destroy the proposed new credentials and will then unlock
             cred_replace_mutex.  No changes to the credentials will have been
             made.
    
     (2) LSM interface.
    
         A number of functions have been changed, added or removed:
    
         (*) security_bprm_alloc(), ->bprm_alloc_security()
         (*) security_bprm_free(), ->bprm_free_security()
    
             Removed in favour of preparing new credentials and modifying those.
    
         (*) security_bprm_apply_creds(), ->bprm_apply_creds()
         (*) security_bprm_post_apply_creds(), ->bprm_post_apply_creds()
    
             Removed; split between security_bprm_set_creds(),
             security_bprm_committing_creds() and security_bprm_committed_creds().
    
         (*) security_bprm_set(), ->bprm_set_security()
    
             Removed; folded into security_bprm_set_creds().
    
         (*) security_bprm_set_creds(), ->bprm_set_creds()
    
             New.  The new credentials in bprm->creds should be checked and set up
             as appropriate.  bprm->cred_prepared is 0 on the first call, 1 on the
             second and subsequent calls.
    
         (*) security_bprm_committing_creds(), ->bprm_committing_creds()
         (*) security_bprm_committed_creds(), ->bprm_committed_creds()
    
             New.  Apply the security effects of the new credentials.  This
             includes closing unauthorised files in SELinux.  This function may not
             fail.  When the former is called, the creds haven't yet been applied
             to the process; when the latter is called, they have.
    
             The former may access bprm->cred, the latter may not.
    
     (3) SELinux.
    
         SELinux has a number of changes, in addition to those to support the LSM
         interface changes mentioned above:
    
         (a) The bprm_security_struct struct has been removed in favour of using
             the credentials-under-construction approach.
    
         (c) flush_unauthorized_files() now takes a cred pointer and passes it on
             to inode_has_perm(), file_has_perm() and dentry_open().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/fs/internal.h b/fs/internal.h
index 80aa9a023372..53af885f1732 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -10,6 +10,7 @@
  */
 
 struct super_block;
+struct linux_binprm;
 
 /*
  * block_dev.c
@@ -39,6 +40,11 @@ static inline int sb_is_blkdev_sb(struct super_block *sb)
  */
 extern void __init chrdev_init(void);
 
+/*
+ * exec.c
+ */
+extern void check_unsafe_exec(struct linux_binprm *);
+
 /*
  * namespace.c
  */

commit 6d59e7f582ef1c1988542d0fc3b36d0087b757ce
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 22 15:48:17 2008 -0400

    [PATCH] move a bunch of declarations to fs/internal.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/internal.h b/fs/internal.h
index 392e8ccd6fc4..80aa9a023372 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -43,3 +43,14 @@ extern void __init chrdev_init(void);
  * namespace.c
  */
 extern int copy_mount_options(const void __user *, unsigned long *);
+
+extern void free_vfsmnt(struct vfsmount *);
+extern struct vfsmount *alloc_vfsmnt(const char *);
+extern struct vfsmount *__lookup_mnt(struct vfsmount *, struct dentry *, int);
+extern void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
+				struct vfsmount *);
+extern void release_mounts(struct list_head *);
+extern void umount_tree(struct vfsmount *, int, struct list_head *);
+extern struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
+
+extern void __init mnt_init(void);

commit 6272e2667965dfb5b59199f462cd0f001fb304a6
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 8 00:29:21 2007 -0700

    cleanup compat ioctl handling
    
    Merge all compat ioctl handling into compat_ioctl.c instead of splitting it
    over compat.c and compat_ioctl.c.  This also allows to get rid of ioctl32.h
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Looks-good-to: Andi Kleen <ak@suse.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/internal.h b/fs/internal.h
index ea00126c9a59..392e8ccd6fc4 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -9,8 +9,6 @@
  * 2 of the License, or (at your option) any later version.
  */
 
-#include <linux/ioctl32.h>
-
 struct super_block;
 
 /*
@@ -41,14 +39,6 @@ static inline int sb_is_blkdev_sb(struct super_block *sb)
  */
 extern void __init chrdev_init(void);
 
-/*
- * compat_ioctl.c
- */
-#ifdef CONFIG_COMPAT
-extern struct ioctl_trans ioctl_start[];
-extern int ioctl_table_size;
-#endif
-
 /*
  * namespace.c
  */

commit 5e6d12b2c8be2cac099df6dcb8b26884f24d2621
Author: Andrew Morton <akpm@osdl.org>
Date:   Thu Aug 31 12:55:23 2006 +0200

    [PATCH] CONFIG_BLOCK internal.h cleanups
    
    - forward declare struct superblock
    - use inlines, not macros
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/internal.h b/fs/internal.h
index f07147d63255..ea00126c9a59 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -11,6 +11,8 @@
 
 #include <linux/ioctl32.h>
 
+struct super_block;
+
 /*
  * block_dev.c
  */
@@ -18,11 +20,20 @@
 extern struct super_block *blockdev_superblock;
 extern void __init bdev_cache_init(void);
 
-#define sb_is_blkdev_sb(sb) ((sb) == blockdev_superblock)
+static inline int sb_is_blkdev_sb(struct super_block *sb)
+{
+	return sb == blockdev_superblock;
+}
+
 #else
-static inline void bdev_cache_init(void) {}
+static inline void bdev_cache_init(void)
+{
+}
 
-#define sb_is_blkdev_sb(sb) 0
+static inline int sb_is_blkdev_sb(struct super_block *sb)
+{
+	return 0;
+}
 #endif
 
 /*

commit 9361401eb7619c033e2394e4f9f6d410d6719ac7
Author: David Howells <dhowells@redhat.com>
Date:   Sat Sep 30 20:45:40 2006 +0200

    [PATCH] BLOCK: Make it possible to disable the block layer [try #6]
    
    Make it possible to disable the block layer.  Not all embedded devices require
    it, some can make do with just JFFS2, NFS, ramfs, etc - none of which require
    the block layer to be present.
    
    This patch does the following:
    
     (*) Introduces CONFIG_BLOCK to disable the block layer, buffering and blockdev
         support.
    
     (*) Adds dependencies on CONFIG_BLOCK to any configuration item that controls
         an item that uses the block layer.  This includes:
    
         (*) Block I/O tracing.
    
         (*) Disk partition code.
    
         (*) All filesystems that are block based, eg: Ext3, ReiserFS, ISOFS.
    
         (*) The SCSI layer.  As far as I can tell, even SCSI chardevs use the
             block layer to do scheduling.  Some drivers that use SCSI facilities -
             such as USB storage - end up disabled indirectly from this.
    
         (*) Various block-based device drivers, such as IDE and the old CDROM
             drivers.
    
         (*) MTD blockdev handling and FTL.
    
         (*) JFFS - which uses set_bdev_super(), something it could avoid doing by
             taking a leaf out of JFFS2's book.
    
     (*) Makes most of the contents of linux/blkdev.h, linux/buffer_head.h and
         linux/elevator.h contingent on CONFIG_BLOCK being set.  sector_div() is,
         however, still used in places, and so is still available.
    
     (*) Also made contingent are the contents of linux/mpage.h, linux/genhd.h and
         parts of linux/fs.h.
    
     (*) Makes a number of files in fs/ contingent on CONFIG_BLOCK.
    
     (*) Makes mm/bounce.c (bounce buffering) contingent on CONFIG_BLOCK.
    
     (*) set_page_dirty() doesn't call __set_page_dirty_buffers() if CONFIG_BLOCK
         is not enabled.
    
     (*) fs/no-block.c is created to hold out-of-line stubs and things that are
         required when CONFIG_BLOCK is not set:
    
         (*) Default blockdev file operations (to give error ENODEV on opening).
    
     (*) Makes some /proc changes:
    
         (*) /proc/devices does not list any blockdevs.
    
         (*) /proc/diskstats and /proc/partitions are contingent on CONFIG_BLOCK.
    
     (*) Makes some compat ioctl handling contingent on CONFIG_BLOCK.
    
     (*) If CONFIG_BLOCK is not defined, makes sys_quotactl() return -ENODEV if
         given command other than Q_SYNC or if a special device is specified.
    
     (*) In init/do_mounts.c, no reference is made to the blockdev routines if
         CONFIG_BLOCK is not defined.  This does not prohibit NFS roots or JFFS2.
    
     (*) The bdflush, ioprio_set and ioprio_get syscalls can now be absent (return
         error ENOSYS by way of cond_syscall if so).
    
     (*) The seclvl_bd_claim() and seclvl_bd_release() security calls do nothing if
         CONFIG_BLOCK is not set, since they can't then happen.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/internal.h b/fs/internal.h
index f662b703bb97..f07147d63255 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -14,10 +14,16 @@
 /*
  * block_dev.c
  */
+#ifdef CONFIG_BLOCK
 extern struct super_block *blockdev_superblock;
 extern void __init bdev_cache_init(void);
 
 #define sb_is_blkdev_sb(sb) ((sb) == blockdev_superblock)
+#else
+static inline void bdev_cache_init(void) {}
+
+#define sb_is_blkdev_sb(sb) 0
+#endif
 
 /*
  * char_dev.c

commit 7b0de42d7c5a471741ede4e71727d88000e6ea59
Author: David Howells <dhowells@redhat.com>
Date:   Tue Aug 29 19:06:07 2006 +0100

    [PATCH] BLOCK: Remove dependence on existence of blockdev_superblock [try #6]
    
    Move blockdev_superblock extern declaration from fs/fs-writeback.c to a
    headerfile and remove the dependence on it by wrapping it in a macro.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/internal.h b/fs/internal.h
index c21ecd37b1e7..f662b703bb97 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -17,6 +17,8 @@
 extern struct super_block *blockdev_superblock;
 extern void __init bdev_cache_init(void);
 
+#define sb_is_blkdev_sb(sb) ((sb) == blockdev_superblock)
+
 /*
  * char_dev.c
  */

commit 07f3f05c1e3052b8656129b2a5aca9f888241a34
Author: David Howells <dhowells@redhat.com>
Date:   Sat Sep 30 20:52:18 2006 +0200

    [PATCH] BLOCK: Move extern declarations out of fs/*.c into header files [try #6]
    
    Create a new header file, fs/internal.h, for common definitions local to the
    sources in the fs/ directory.
    
    Move extern definitions that should be in header files from fs/*.c to
    fs/internal.h or other main header files where they span directories.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/internal.h b/fs/internal.h
new file mode 100644
index 000000000000..c21ecd37b1e7
--- /dev/null
+++ b/fs/internal.h
@@ -0,0 +1,36 @@
+/* fs/ internal definitions
+ *
+ * Copyright (C) 2006 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/ioctl32.h>
+
+/*
+ * block_dev.c
+ */
+extern struct super_block *blockdev_superblock;
+extern void __init bdev_cache_init(void);
+
+/*
+ * char_dev.c
+ */
+extern void __init chrdev_init(void);
+
+/*
+ * compat_ioctl.c
+ */
+#ifdef CONFIG_COMPAT
+extern struct ioctl_trans ioctl_start[];
+extern int ioctl_table_size;
+#endif
+
+/*
+ * namespace.c
+ */
+extern int copy_mount_options(const void __user *, unsigned long *);
