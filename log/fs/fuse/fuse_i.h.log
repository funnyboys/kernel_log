commit 6b2fb79963fbed7db3ef850926d913518fd5c62f
Author: Maxim Patlasov <mpatlasov@virtuozzo.com>
Date:   Thu Sep 19 17:11:20 2019 +0300

    fuse: optimize writepages search
    
    Re-work fi->writepages, replacing list with rb-tree.  This improves
    performance because kernel fuse iterates through fi->writepages for each
    writeback page and typical number of entries is about 800 (for 100MB of
    fuse writeback).
    
    Before patch:
    
    10240+0 records in
    10240+0 records out
    10737418240 bytes (11 GB) copied, 41.3473 s, 260 MB/s
    
     2  1      0 57445400  40416 6323676    0    0    33 374743 8633 19210  1  8 88  3  0
    
      29.86%  [kernel]               [k] _raw_spin_lock
      26.62%  [fuse]                 [k] fuse_page_is_writeback
    
    After patch:
    
    10240+0 records in
    10240+0 records out
    10737418240 bytes (11 GB) copied, 21.4954 s, 500 MB/s
    
     2  9      0 53676040  31744 10265984    0    0    64 854790 10956 48387  1  6 88  6  0
    
      23.55%  [kernel]             [k] copy_user_enhanced_fast_string
       9.87%  [kernel]             [k] __memcpy
       3.10%  [kernel]             [k] _raw_spin_lock
    
    Signed-off-by: Maxim Patlasov <mpatlasov@virtuozzo.com>
    Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index d7cde216fc87..740a8a7d7ae6 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -111,7 +111,7 @@ struct fuse_inode {
 			wait_queue_head_t page_waitq;
 
 			/* List of writepage requestst (pending or sent) */
-			struct list_head writepages;
+			struct rb_root writepages;
 		};
 
 		/* readdir cache (directory only) */

commit bb737bbe48bea9854455cb61ea1dc06e92ce586c
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Mon Apr 20 17:01:34 2020 +0200

    virtiofs: schedule blocking async replies in separate worker
    
    In virtiofs (unlike in regular fuse) processing of async replies is
    serialized.  This can result in a deadlock in rare corner cases when
    there's a circular dependency between the completion of two or more async
    replies.
    
    Such a deadlock can be reproduced with xfstests:generic/503 if TEST_DIR ==
    SCRATCH_MNT (which is a misconfiguration):
    
     - Process A is waiting for page lock in worker thread context and blocked
       (virtio_fs_requests_done_work()).
     - Process B is holding page lock and waiting for pending writes to
       finish (fuse_wait_on_page_writeback()).
     - Write requests are waiting in virtqueue and can't complete because
       worker thread is blocked on page lock (process A).
    
    Fix this by creating a unique work_struct for each async reply that can
    block (O_DIRECT read).
    
    Fixes: a62a8ef9d97d ("virtio-fs: add virtiofs filesystem")
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index ca344bf71404..d7cde216fc87 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -249,6 +249,7 @@ struct fuse_args {
 	bool out_argvar:1;
 	bool page_zeroing:1;
 	bool page_replace:1;
+	bool may_block:1;
 	struct fuse_in_arg in_args[3];
 	struct fuse_arg out_args[2];
 	void (*end)(struct fuse_conn *fc, struct fuse_args *args, int error);

commit 3e8cb8b2eaeb22f540f1cbc00cbb594047b7ba89
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Feb 13 09:16:07 2020 +0100

    fuse: fix stack use after return
    
    Normal, synchronous requests will have their args allocated on the stack.
    After the FR_FINISHED bit is set by receiving the reply from the userspace
    fuse server, the originating task may return and reuse the stack frame,
    resulting in an Oops if the args structure is dereferenced.
    
    Fix by setting a flag in the request itself upon initializing, indicating
    whether it has an asynchronous ->end() callback.
    
    Reported-by: Kyle Sanderson <kyle.leet@gmail.com>
    Reported-by: Michael Stapelberg <michael+lkml@stapelberg.ch>
    Fixes: 2b319d1f6f92 ("fuse: don't dereference req->args on finished request")
    Cc: <stable@vger.kernel.org> # v5.4
    Tested-by: Michael Stapelberg <michael+lkml@stapelberg.ch>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index aa75e2305b75..ca344bf71404 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -301,6 +301,7 @@ struct fuse_io_priv {
  * FR_SENT:		request is in userspace, waiting for an answer
  * FR_FINISHED:		request is finished
  * FR_PRIVATE:		request is on private list
+ * FR_ASYNC:		request is asynchronous
  */
 enum fuse_req_flag {
 	FR_ISREPLY,
@@ -314,6 +315,7 @@ enum fuse_req_flag {
 	FR_SENT,
 	FR_FINISHED,
 	FR_PRIVATE,
+	FR_ASYNC,
 };
 
 /**

commit eb59bd17d2fa6e5e84fba61a5ebdea984222e6d5
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Nov 12 11:49:04 2019 +0100

    fuse: verify attributes
    
    If a filesystem returns negative inode sizes, future reads on the file were
    causing the cpu to spin on truncate_pagecache.
    
    Create a helper to validate the attributes.  This now does two things:
    
     - check the file mode
     - check if the file size fits in i_size without overflowing
    
    Reported-by: Arijit Banerjee <arijit@rubrik.com>
    Fixes: d8a5ba45457e ("[PATCH] FUSE - core")
    Cc: <stable@vger.kernel.org> # v2.6.14
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index d148188cfca4..aa75e2305b75 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -989,6 +989,8 @@ void fuse_ctl_remove_conn(struct fuse_conn *fc);
  */
 int fuse_valid_type(int m);
 
+bool fuse_invalid_attr(struct fuse_attr *attr);
+
 /**
  * Is current process allowed to perform filesystem operation?
  */

commit 3f22c7467136adfa6d2a7baf7cd5c573f0641bd1
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Oct 15 16:11:41 2019 +0200

    virtio-fs: don't show mount options
    
    Virtio-fs does not accept any mount options, so it's confusing and wrong to
    show any in /proc/mounts.
    
    Reported-by: Stefan Hajnoczi <stefanha@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 956aeaf961ae..d148188cfca4 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -479,6 +479,7 @@ struct fuse_fs_context {
 	bool destroy:1;
 	bool no_control:1;
 	bool no_force_umount:1;
+	bool no_mount_options:1;
 	unsigned int max_read;
 	unsigned int blksize;
 	const char *subtype;
@@ -713,6 +714,9 @@ struct fuse_conn {
 	/** Do not allow MNT_FORCE umount */
 	unsigned int no_force_umount:1;
 
+	/* Do not show mount options */
+	unsigned int no_mount_options:1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 

commit a62a8ef9d97da23762a588592c8b8eb50a8deb6a
Author: Stefan Hajnoczi <stefanha@redhat.com>
Date:   Tue Jun 12 09:41:17 2018 +0100

    virtio-fs: add virtiofs filesystem
    
    Add a basic file system module for virtio-fs.  This does not yet contain
    shared data support between host and guest or metadata coherency speedups.
    However it is already significantly faster than virtio-9p.
    
    Design Overview
    ===============
    
    With the goal of designing something with better performance and local file
    system semantics, a bunch of ideas were proposed.
    
     - Use fuse protocol (instead of 9p) for communication between guest and
       host.  Guest kernel will be fuse client and a fuse server will run on
       host to serve the requests.
    
     - For data access inside guest, mmap portion of file in QEMU address space
       and guest accesses this memory using dax.  That way guest page cache is
       bypassed and there is only one copy of data (on host).  This will also
       enable mmap(MAP_SHARED) between guests.
    
     - For metadata coherency, there is a shared memory region which contains
       version number associated with metadata and any guest changing metadata
       updates version number and other guests refresh metadata on next access.
       This is yet to be implemented.
    
    How virtio-fs differs from existing approaches
    ==============================================
    
    The unique idea behind virtio-fs is to take advantage of the co-location of
    the virtual machine and hypervisor to avoid communication (vmexits).
    
    DAX allows file contents to be accessed without communication with the
    hypervisor.  The shared memory region for metadata avoids communication in
    the common case where metadata is unchanged.
    
    By replacing expensive communication with cheaper shared memory accesses,
    we expect to achieve better performance than approaches based on network
    file system protocols.  In addition, this also makes it easier to achieve
    local file system semantics (coherency).
    
    These techniques are not applicable to network file system protocols since
    the communications channel is bypassed by taking advantage of shared memory
    on a local machine.  This is why we decided to build virtio-fs rather than
    focus on 9P or NFS.
    
    Caching Modes
    =============
    
    Like virtio-9p, different caching modes are supported which determine the
    coherency level as well.  The “cache=FOO” and “writeback” options control
    the level of coherence between the guest and host filesystems.
    
     - cache=none
       metadata, data and pathname lookup are not cached in guest.  They are
       always fetched from host and any changes are immediately pushed to host.
    
     - cache=always
       metadata, data and pathname lookup are cached in guest and never expire.
    
     - cache=auto
       metadata and pathname lookup cache expires after a configured amount of
       time (default is 1 second).  Data is cached while the file is open
       (close to open consistency).
    
     - writeback/no_writeback
       These options control the writeback strategy.  If writeback is disabled,
       then normal writes will immediately be synchronized with the host fs.
       If writeback is enabled, then writes may be cached in the guest until
       the file is closed or an fsync(2) performed.  This option has no effect
       on mmap-ed writes or writes going through the DAX mechanism.
    
    Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index fc89cb40e874..956aeaf961ae 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -353,6 +353,10 @@ struct fuse_req {
 	/** Used to wake up the task waiting for completion of request*/
 	wait_queue_head_t waitq;
 
+#if IS_ENABLED(CONFIG_VIRTIO_FS)
+	/** virtio-fs's physically contiguous buffer for in and out args */
+	void *argbuf;
+#endif
 };
 
 struct fuse_iqueue;
@@ -383,6 +387,11 @@ struct fuse_iqueue_ops {
 	 */
 	void (*wake_pending_and_unlock)(struct fuse_iqueue *fiq)
 		__releases(fiq->lock);
+
+	/**
+	 * Clean up when fuse_iqueue is destroyed
+	 */
+	void (*release)(struct fuse_iqueue *fiq);
 };
 
 /** /dev/fuse input queue operations */

commit 15c8e72e88e0b707ffefd524ca33f28cdb3db487
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Mon May 6 15:35:43 2019 -0400

    fuse: allow skipping control interface and forced unmount
    
    virtio-fs does not support aborting requests which are being
    processed. That is requests which have been sent to fuse daemon on host.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 48d214df9172..fc89cb40e874 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -468,6 +468,8 @@ struct fuse_fs_context {
 	bool default_permissions:1;
 	bool allow_other:1;
 	bool destroy:1;
+	bool no_control:1;
+	bool no_force_umount:1;
 	unsigned int max_read;
 	unsigned int blksize;
 	const char *subtype;
@@ -696,6 +698,12 @@ struct fuse_conn {
 	/* Delete dentries that have gone stale */
 	unsigned int delete_stale:1;
 
+	/** Do not create entry in fusectl fs */
+	unsigned int no_control:1;
+
+	/** Do not allow MNT_FORCE umount */
+	unsigned int no_force_umount:1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 

commit 783863d6476ce9f27fa87227f76ae9134caf43fa
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Aug 29 11:01:20 2019 +0200

    fuse: dissociate DESTROY from fuseblk
    
    Allow virtio-fs to also send DESTROY request.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index fed68a427a4c..48d214df9172 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -467,6 +467,7 @@ struct fuse_fs_context {
 	bool group_id_present:1;
 	bool default_permissions:1;
 	bool allow_other:1;
+	bool destroy:1;
 	unsigned int max_read;
 	unsigned int blksize;
 	const char *subtype;
@@ -945,6 +946,13 @@ void fuse_send_init(struct fuse_conn *fc);
  */
 int fuse_fill_super_common(struct super_block *sb, struct fuse_fs_context *ctx);
 
+/**
+ * Disassociate fuse connection from superblock and kill the superblock
+ *
+ * Calls kill_anon_super(), do not use with bdev mounts.
+ */
+void fuse_kill_sb_anon(struct super_block *sb);
+
 /**
  * Add connection to control filesystem
  */
@@ -1057,5 +1065,6 @@ unsigned int fuse_len_args(unsigned int numargs, struct fuse_arg *args);
  * Get the next unique ID for a request
  */
 u64 fuse_get_unique(struct fuse_iqueue *fiq);
+void fuse_free_conn(struct fuse_conn *fc);
 
 #endif /* _FS_FUSE_I_H */

commit 8fab010644363f8f80194322aa7a81e38c867af3
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Aug 15 17:42:34 2018 +0200

    fuse: delete dentry if timeout is zero
    
    Don't hold onto dentry in lru list if need to re-lookup it anyway at next
    access.  Only do this if explicitly enabled, otherwise it could result in
    performance regression.
    
    More advanced version of this patch would periodically flush out dentries
    from the lru which have gone stale.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 242d47752e78..fed68a427a4c 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -692,6 +692,9 @@ struct fuse_conn {
 	/* Send DESTROY request */
 	unsigned int destroy:1;
 
+	/* Delete dentries that have gone stale */
+	unsigned int delete_stale:1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 

commit 0cd1eb9a4160a96e0ec9b93b2e7b489f449bf22d
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Wed Mar 6 16:51:40 2019 -0500

    fuse: separate fuse device allocation and installation in fuse_conn
    
    As of now fuse_dev_alloc() both allocates a fuse device and installs it in
    fuse_conn list.  fuse_dev_alloc() can fail if fuse_device allocation fails.
    
    virtio-fs needs to initialize multiple fuse devices (one per virtio queue).
    It initializes one fuse device as part of call to fuse_fill_super_common()
    and rest of the devices are allocated and installed after that.
    
    But, we can't afford to fail after calling fuse_fill_super_common() as we
    don't have a way to undo all the actions done by fuse_fill_super_common().
    So to avoid failures after the call to fuse_fill_super_common(),
    pre-allocate all fuse devices early and install them into fuse connection
    later.
    
    This patch provides two separate helpers for fuse device allocation and
    fuse device installation in fuse_conn.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 8c13865955d4..242d47752e78 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -929,7 +929,9 @@ void fuse_conn_init(struct fuse_conn *fc, struct user_namespace *user_ns,
  */
 void fuse_conn_put(struct fuse_conn *fc);
 
-struct fuse_dev *fuse_dev_alloc(struct fuse_conn *fc);
+struct fuse_dev *fuse_dev_alloc_install(struct fuse_conn *fc);
+struct fuse_dev *fuse_dev_alloc(void);
+void fuse_dev_install(struct fuse_dev *fud, struct fuse_conn *fc);
 void fuse_dev_free(struct fuse_dev *fud);
 void fuse_send_init(struct fuse_conn *fc);
 

commit ae3aad77f46fbba56eff7141b2fc49870b60827e
Author: Stefan Hajnoczi <stefanha@redhat.com>
Date:   Mon Jun 18 15:53:19 2018 +0100

    fuse: add fuse_iqueue_ops callbacks
    
    The /dev/fuse device uses fiq->waitq and fasync to signal that requests are
    available.  These mechanisms do not apply to virtio-fs.  This patch
    introduces callbacks so alternative behavior can be used.
    
    Note that queue_interrupt() changes along these lines:
    
      spin_lock(&fiq->waitq.lock);
      wake_up_locked(&fiq->waitq);
    + kill_fasync(&fiq->fasync, SIGIO, POLL_IN);
      spin_unlock(&fiq->waitq.lock);
    - kill_fasync(&fiq->fasync, SIGIO, POLL_IN);
    
    Since queue_request() and queue_forget() also call kill_fasync() inside
    the spinlock this should be safe.
    
    Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 1902148281cc..8c13865955d4 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -355,6 +355,39 @@ struct fuse_req {
 
 };
 
+struct fuse_iqueue;
+
+/**
+ * Input queue callbacks
+ *
+ * Input queue signalling is device-specific.  For example, the /dev/fuse file
+ * uses fiq->waitq and fasync to wake processes that are waiting on queue
+ * readiness.  These callbacks allow other device types to respond to input
+ * queue activity.
+ */
+struct fuse_iqueue_ops {
+	/**
+	 * Signal that a forget has been queued
+	 */
+	void (*wake_forget_and_unlock)(struct fuse_iqueue *fiq)
+		__releases(fiq->lock);
+
+	/**
+	 * Signal that an INTERRUPT request has been queued
+	 */
+	void (*wake_interrupt_and_unlock)(struct fuse_iqueue *fiq)
+		__releases(fiq->lock);
+
+	/**
+	 * Signal that a request has been queued
+	 */
+	void (*wake_pending_and_unlock)(struct fuse_iqueue *fiq)
+		__releases(fiq->lock);
+};
+
+/** /dev/fuse input queue operations */
+extern const struct fuse_iqueue_ops fuse_dev_fiq_ops;
+
 struct fuse_iqueue {
 	/** Connection established */
 	unsigned connected;
@@ -383,6 +416,12 @@ struct fuse_iqueue {
 
 	/** O_ASYNC requests */
 	struct fasync_struct *fasync;
+
+	/** Device-specific callbacks */
+	const struct fuse_iqueue_ops *ops;
+
+	/** Device-specific state */
+	void *priv;
 };
 
 #define FUSE_PQ_HASH_BITS 8
@@ -882,7 +921,8 @@ struct fuse_conn *fuse_conn_get(struct fuse_conn *fc);
 /**
  * Initialize fuse_conn
  */
-void fuse_conn_init(struct fuse_conn *fc, struct user_namespace *user_ns);
+void fuse_conn_init(struct fuse_conn *fc, struct user_namespace *user_ns,
+		    const struct fuse_iqueue_ops *fiq_ops, void *fiq_priv);
 
 /**
  * Release reference to fuse_conn

commit 0cc2656cdb0b1f234e6d29378cb061e29d7522bc
Author: Stefan Hajnoczi <stefanha@redhat.com>
Date:   Wed Jun 13 10:23:04 2018 +0100

    fuse: extract fuse_fill_super_common()
    
    fuse_fill_super() includes code to process the fd= option and link the
    struct fuse_dev to the fd's struct file.  In virtio-fs there is no file
    descriptor because /dev/fuse is not used.
    
    This patch extracts fuse_fill_super_common() so that both classic fuse and
    virtio-fs can share the code to initialize a mount.
    
    Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 5f910c99e8dd..1902148281cc 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -416,6 +416,26 @@ struct fuse_dev {
 	struct list_head entry;
 };
 
+struct fuse_fs_context {
+	int fd;
+	unsigned int rootmode;
+	kuid_t user_id;
+	kgid_t group_id;
+	bool is_bdev:1;
+	bool fd_present:1;
+	bool rootmode_present:1;
+	bool user_id_present:1;
+	bool group_id_present:1;
+	bool default_permissions:1;
+	bool allow_other:1;
+	unsigned int max_read;
+	unsigned int blksize;
+	const char *subtype;
+
+	/* fuse_dev pointer to fill in, should contain NULL on entry */
+	void **fudptr;
+};
+
 /**
  * A Fuse connection.
  *
@@ -873,6 +893,13 @@ struct fuse_dev *fuse_dev_alloc(struct fuse_conn *fc);
 void fuse_dev_free(struct fuse_dev *fud);
 void fuse_send_init(struct fuse_conn *fc);
 
+/**
+ * Fill in superblock and initialize fuse connection
+ * @sb: partially-initialized superblock to fill in
+ * @ctx: mount context
+ */
+int fuse_fill_super_common(struct super_block *sb, struct fuse_fs_context *ctx);
+
 /**
  * Add connection to control filesystem
  */

commit 4388c5aac4bae5c83a2c66882043942002ba09a2
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Wed Jun 5 15:50:43 2019 -0400

    fuse: export fuse_dequeue_forget() function
    
    File systems like virtio-fs need to do not have to play directly with
    forget list data structures. There is a helper function use that instead.
    
    Rename dequeue_forget() to fuse_dequeue_forget() and export it so that
    stacked filesystems can use it.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index b868b71d47d9..5f910c99e8dd 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -729,6 +729,10 @@ void fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,
 
 struct fuse_forget_link *fuse_alloc_forget(void);
 
+struct fuse_forget_link *fuse_dequeue_forget(struct fuse_iqueue *fiq,
+					     unsigned int max,
+					     unsigned int *countp);
+
 /*
  * Initialize READ or READDIR request
  */

commit 79d96efffda7597b41968d5d8813b39fc2965f1b
Author: Stefan Hajnoczi <stefanha@redhat.com>
Date:   Fri Jun 22 13:48:30 2018 +0100

    fuse: export fuse_get_unique()
    
    virtio-fs will need unique IDs for FORGET requests from outside
    fs/fuse/dev.c.  Make the symbol visible.
    
    Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 7192080a06d0..b868b71d47d9 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -977,4 +977,9 @@ int fuse_readdir(struct file *file, struct dir_context *ctx);
  */
 unsigned int fuse_len_args(unsigned int numargs, struct fuse_arg *args);
 
+/**
+ * Get the next unique ID for a request
+ */
+u64 fuse_get_unique(struct fuse_iqueue *fiq);
+
 #endif /* _FS_FUSE_I_H */

commit 95a84cdb11c26315a6d34664846f82c438c961a1
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Wed Mar 6 16:51:39 2019 -0500

    fuse: export fuse_send_init_request()
    
    This will be used by virtio-fs to send init request to fuse server after
    initialization of virt queues.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 39ef981a618c..7192080a06d0 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -867,6 +867,7 @@ void fuse_conn_put(struct fuse_conn *fc);
 
 struct fuse_dev *fuse_dev_alloc(struct fuse_conn *fc);
 void fuse_dev_free(struct fuse_dev *fud);
+void fuse_send_init(struct fuse_conn *fc);
 
 /**
  * Add connection to control filesystem

commit 14d46d7abc3973a47e8eb0eb5eb87ee8d910a505
Author: Stefan Hajnoczi <stefanha@redhat.com>
Date:   Thu Jun 21 09:34:25 2018 +0100

    fuse: export fuse_len_args()
    
    virtio-fs will need to query the length of fuse_arg lists.  Make the symbol
    visible.
    
    Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 5c50d3da1b0d..39ef981a618c 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -971,4 +971,9 @@ int fuse_set_acl(struct inode *inode, struct posix_acl *acl, int type);
 /* readdir.c */
 int fuse_readdir(struct file *file, struct dir_context *ctx);
 
+/**
+ * Return the number of bytes in an arguments list
+ */
+unsigned int fuse_len_args(unsigned int numargs, struct fuse_arg *args);
+
 #endif /* _FS_FUSE_I_H */

commit 04ec5af0776e9baefed59891f12adbcb5fa71a23
Author: Stefan Hajnoczi <stefanha@redhat.com>
Date:   Thu Jun 21 09:33:40 2018 +0100

    fuse: export fuse_end_request()
    
    virtio-fs will need to complete requests from outside fs/fuse/dev.c.  Make
    the symbol visible.
    
    Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 378f1fe69d07..5c50d3da1b0d 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -829,6 +829,11 @@ ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args);
 int fuse_simple_background(struct fuse_conn *fc, struct fuse_args *args,
 			   gfp_t gfp_flags);
 
+/**
+ * End a finished request
+ */
+void fuse_request_end(struct fuse_conn *fc, struct fuse_req *req);
+
 /* Abort all requests */
 void fuse_abort_conn(struct fuse_conn *fc);
 void fuse_wait_aborted(struct fuse_conn *fc);

commit 05ea48cc2b098c533193bb058b82aa016a8361bc
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:11 2019 +0200

    fuse: stop copying pages to fuse_req
    
    The page array pointers are also duplicated across fuse_args_pages and
    fuse_req.  Get rid of the fuse_req ones.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 9454f2328bd0..378f1fe69d07 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -353,15 +353,6 @@ struct fuse_req {
 	/** Used to wake up the task waiting for completion of request*/
 	wait_queue_head_t waitq;
 
-	/** page vector */
-	struct page **pages;
-
-	/** page-descriptor vector */
-	struct fuse_page_desc *page_descs;
-
-	/** number of pages in vector */
-	unsigned num_pages;
-
 };
 
 struct fuse_iqueue {

commit d49937749fef2597f6bcaf2a0ed67e88e347b7fb
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:11 2019 +0200

    fuse: stop copying args to fuse_req
    
    No need to duplicate the argument arrays in fuse_req, so just dereference
    req->args instead of copying to the fuse_req internal ones.
    
    This allows further cleanup of the fuse_req structure.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index a81fdbe62df9..9454f2328bd0 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -224,57 +224,12 @@ struct fuse_in_arg {
 	const void *value;
 };
 
-/** The request input */
-struct fuse_in {
-	/** The request header */
-	struct fuse_in_header h;
-
-	/** True if the data for the last argument is in req->pages */
-	unsigned argpages:1;
-
-	/** Number of arguments */
-	unsigned numargs;
-
-	/** Array of arguments */
-	struct fuse_in_arg args[3];
-};
-
 /** One output argument of a request */
 struct fuse_arg {
 	unsigned size;
 	void *value;
 };
 
-/** The request output */
-struct fuse_out {
-	/** Header returned from userspace */
-	struct fuse_out_header h;
-
-	/*
-	 * The following bitfields are not changed during the request
-	 * processing
-	 */
-
-	/** Last argument is variable length (can be shorter than
-	    arg->size) */
-	unsigned argvar:1;
-
-	/** Last argument is a list of pages to copy data to */
-	unsigned argpages:1;
-
-	/** Zero partially or not copied pages */
-	unsigned page_zeroing:1;
-
-	/** Pages may be replaced with new ones */
-	unsigned page_replace:1;
-
-	/** Number or arguments */
-	unsigned numargs;
-
-	/** Array of arguments */
-	struct fuse_arg args[2];
-};
-
 /** FUSE page descriptor */
 struct fuse_page_desc {
 	unsigned int length;
@@ -385,11 +340,15 @@ struct fuse_req {
 	/* Request flags, updated with test/set/clear_bit() */
 	unsigned long flags;
 
-	/** The request input */
-	struct fuse_in in;
+	/* The request input header */
+	struct {
+		struct fuse_in_header h;
+	} in;
 
-	/** The request output */
-	struct fuse_out out;
+	/* The request output header */
+	struct {
+		struct fuse_out_header h;
+	} out;
 
 	/** Used to wake up the task waiting for completion of request*/
 	wait_queue_head_t waitq;
@@ -403,9 +362,6 @@ struct fuse_req {
 	/** number of pages in vector */
 	unsigned num_pages;
 
-	/** Request completion callback */
-	void (*end)(struct fuse_conn *, struct fuse_req *);
-
 };
 
 struct fuse_iqueue {

commit 145b673bd208af97b2f98572f286111ab8e7bc59
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:11 2019 +0200

    fuse: clean up fuse_req
    
    Get rid of request specific fields in fuse_req that are not used anymore.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 90cb82d5d62d..a81fdbe62df9 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -47,9 +47,6 @@
 /** Number of dentries for each connection in the control filesystem */
 #define FUSE_CTL_NUM_DENTRIES 5
 
-/** Number of page pointers embedded in fuse_req */
-#define FUSE_REQ_INLINE_PAGES 1
-
 /** List of active connections */
 extern struct list_head fuse_conn_list;
 
@@ -397,57 +394,15 @@ struct fuse_req {
 	/** Used to wake up the task waiting for completion of request*/
 	wait_queue_head_t waitq;
 
-	/** Data for asynchronous requests */
-	union {
-		struct {
-			struct fuse_release_in in;
-			struct inode *inode;
-		} release;
-		struct fuse_init_in init_in;
-		struct fuse_init_out init_out;
-		struct cuse_init_in cuse_init_in;
-		struct {
-			struct fuse_read_in in;
-			u64 attr_ver;
-		} read;
-		struct {
-			struct fuse_write_in in;
-			struct fuse_write_out out;
-			struct fuse_req *next;
-		} write;
-		struct fuse_notify_retrieve_in retrieve_in;
-	} misc;
-
 	/** page vector */
 	struct page **pages;
 
 	/** page-descriptor vector */
 	struct fuse_page_desc *page_descs;
 
-	/** size of the 'pages' array */
-	unsigned max_pages;
-
-	/** inline page vector */
-	struct page *inline_pages[FUSE_REQ_INLINE_PAGES];
-
-	/** inline page-descriptor vector */
-	struct fuse_page_desc inline_page_descs[FUSE_REQ_INLINE_PAGES];
-
 	/** number of pages in vector */
 	unsigned num_pages;
 
-	/** File used in the request (or NULL) */
-	struct fuse_file *ff;
-
-	/** Inode used in the request or NULL */
-	struct inode *inode;
-
-	/** AIO control block */
-	struct fuse_io_priv *io;
-
-	/** Link on fi->writepages */
-	struct list_head writepages_entry;
-
 	/** Request completion callback */
 	void (*end)(struct fuse_conn *, struct fuse_req *);
 

commit 7213394c4e184b002d8011c13d916e7ac6d17520
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:11 2019 +0200

    fuse: simplify request allocation
    
    Page arrays are not allocated together with the request anymore.  Get rid
    of the dead code
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index ffbc2cd649e3..90cb82d5d62d 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -362,7 +362,6 @@ enum fuse_req_flag {
 	FR_SENT,
 	FR_FINISHED,
 	FR_PRIVATE,
-	FR_ALLOC_PAGES,
 };
 
 /**
@@ -921,12 +920,6 @@ void fuse_dev_cleanup(void);
 int fuse_ctl_init(void);
 void __exit fuse_ctl_cleanup(void);
 
-/**
- * Allocate a request
- */
-struct page **fuse_pages_alloc(unsigned int npages, gfp_t flags,
-			       struct fuse_page_desc **desc);
-
 /**
  * Simple request sending that does request allocation and freeing
  */

commit 66abc3599c3c8795861470f21ae149520a57153d
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:11 2019 +0200

    fuse: unexport request ops
    
    All requests are now sent with one of the fuse_simple_... helpers.  Get rid
    of the old api from the fuse internal header.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index a055a45361ef..ffbc2cd649e3 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -924,42 +924,9 @@ void __exit fuse_ctl_cleanup(void);
 /**
  * Allocate a request
  */
-struct fuse_req *fuse_request_alloc(unsigned npages);
-
-struct fuse_req *fuse_request_alloc_nofs(unsigned npages);
-
 struct page **fuse_pages_alloc(unsigned int npages, gfp_t flags,
 			       struct fuse_page_desc **desc);
 
-/**
- * Free a request
- */
-void fuse_request_free(struct fuse_req *req);
-
-/**
- * Get a request, may fail with -ENOMEM,
- * caller should specify # elements in req->pages[] explicitly
- */
-struct fuse_req *fuse_get_req(struct fuse_conn *fc, unsigned npages);
-struct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,
-					     unsigned npages);
-
-/*
- * Increment reference count on request
- */
-void __fuse_get_request(struct fuse_req *req);
-
-/**
- * Decrement reference count of a request.  If count goes to zero free
- * the request.
- */
-void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req);
-
-/**
- * Send a request (synchronous)
- */
-void fuse_request_send(struct fuse_conn *fc, struct fuse_req *req);
-
 /**
  * Simple request sending that does request allocation and freeing
  */
@@ -967,12 +934,6 @@ ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args);
 int fuse_simple_background(struct fuse_conn *fc, struct fuse_args *args,
 			   gfp_t gfp_flags);
 
-/**
- * Send a request in the background
- */
-void fuse_request_send_background(struct fuse_conn *fc, struct fuse_req *req);
-bool fuse_request_queue_background(struct fuse_conn *fc, struct fuse_req *req);
-
 /* Abort all requests */
 void fuse_abort_conn(struct fuse_conn *fc);
 void fuse_wait_aborted(struct fuse_conn *fc);

commit 4cb548666e4c13699904a063f6909b169d3f900c
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:10 2019 +0200

    fuse: convert release to simple api
    
    Since we cannot reserve the request structure up-front, make sure that the
    request allocation doesn't fail using __GFP_NOFAIL.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index a9d707bf2e69..a055a45361ef 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -164,17 +164,15 @@ enum {
 };
 
 struct fuse_conn;
+struct fuse_release_args;
 
 /** FUSE specific file data */
 struct fuse_file {
 	/** Fuse connection for this file */
 	struct fuse_conn *fc;
 
-	/*
-	 * Request reserved for flush and release.
-	 * Modified under relative fuse_inode::lock.
-	 */
-	struct fuse_req *reserved_req;
+	/* Argument space reserved for release */
+	struct fuse_release_args *release_args;
 
 	/** Kernel file handle guaranteed to be unique */
 	u64 kh;

commit 33826ebbbe4b45ccecf2f5a08b3457f5d59c6282
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:10 2019 +0200

    fuse: convert writepages to simple api
    
    Derive fuse_writepage_args from fuse_io_args.
    
    Sending the request is tricky since it was done with fi->lock held, hence
    we must either use atomic allocation or release the lock.  Both are
    possible so try atomic first and if it fails, release the lock and do the
    regular allocation with GFP_NOFS and __GFP_NOFAIL.  Both flags are
    necessary for correct operation.
    
    Move the page realloc function from dev.c to file.c and convert to using
    fuse_writepage_args.
    
    The last caller of fuse_write_fill() is gone, so get rid of it.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 4d7cd20967c2..a9d707bf2e69 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -932,9 +932,6 @@ struct fuse_req *fuse_request_alloc_nofs(unsigned npages);
 
 struct page **fuse_pages_alloc(unsigned int npages, gfp_t flags,
 			       struct fuse_page_desc **desc);
-bool fuse_req_realloc_pages(struct fuse_conn *fc, struct fuse_req *req,
-			    gfp_t flags);
-
 
 /**
  * Free a request

commit 43f5098eb82b1dbf3988cab0a26e729e88a004fc
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:10 2019 +0200

    fuse: convert readdir to simple api
    
    The old fuse_read_fill() helper can be deleted, now that the last user is
    gone.
    
    The fuse_io_args struct is moved to fuse_i.h so it can be shared between
    readdir/read code.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 8f46c5549e57..4d7cd20967c2 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -830,11 +830,28 @@ void fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,
 
 struct fuse_forget_link *fuse_alloc_forget(void);
 
-/**
+/*
  * Initialize READ or READDIR request
  */
-void fuse_read_fill(struct fuse_req *req, struct file *file,
-		    loff_t pos, size_t count, int opcode);
+struct fuse_io_args {
+	union {
+		struct {
+			struct fuse_read_in in;
+			u64 attr_ver;
+		} read;
+		struct {
+			struct fuse_write_in in;
+			struct fuse_write_out out;
+		} write;
+	};
+	struct fuse_args_pages ap;
+	struct fuse_io_priv *io;
+	struct fuse_file *ff;
+};
+
+void fuse_read_args_fill(struct fuse_io_args *ia, struct file *file, loff_t pos,
+			 size_t count, int opcode);
+
 
 /**
  * Send OPEN or OPENDIR request

commit 1259728731a7902c4965952c55fa16014b4fd0e7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:10 2019 +0200

    fuse: add simple background helper
    
    Create a helper named fuse_simple_background() that is similar to
    fuse_simple_request().  Unlike the latter, it returns immediately and calls
    the supplied 'end' callback when the reply is received.
    
    The supplied 'args' pointer is stored in 'fuse_req' which allows the
    callback to interpret the output arguments decoded from the reply.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index b62a3e37ea4c..8f46c5549e57 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -301,6 +301,7 @@ struct fuse_args {
 	bool page_replace:1;
 	struct fuse_in_arg in_args[3];
 	struct fuse_arg out_args[2];
+	void (*end)(struct fuse_conn *fc, struct fuse_args *args, int error);
 };
 
 struct fuse_args_pages {
@@ -381,6 +382,9 @@ struct fuse_req {
 	/** Entry on the interrupts list  */
 	struct list_head intr_entry;
 
+	/* Input/output arguments */
+	struct fuse_args *args;
+
 	/** refcount */
 	refcount_t count;
 
@@ -948,6 +952,8 @@ void fuse_request_send(struct fuse_conn *fc, struct fuse_req *req);
  * Simple request sending that does request allocation and freeing
  */
 ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args);
+int fuse_simple_background(struct fuse_conn *fc, struct fuse_args *args,
+			   gfp_t gfp_flags);
 
 /**
  * Send a request in the background

commit 4c4f03f78ca9ce41a158710b87ad7e6d363e881a
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:09 2019 +0200

    fuse: move page alloc
    
    fuse_req_pages_alloc() is moved to file.c, since its internal use by the
    device code will eventually be removed.
    
    Rename to fuse_pages_alloc() to signify that it's not only usable for
    fuse_req page array.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 1998d6ab4025..b62a3e37ea4c 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -909,6 +909,8 @@ struct fuse_req *fuse_request_alloc(unsigned npages);
 
 struct fuse_req *fuse_request_alloc_nofs(unsigned npages);
 
+struct page **fuse_pages_alloc(unsigned int npages, gfp_t flags,
+			       struct fuse_page_desc **desc);
 bool fuse_req_realloc_pages(struct fuse_conn *fc, struct fuse_req *req,
 			    gfp_t flags);
 

commit 68583165f962793a6fe7d11f54713045f43fc8bb
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:09 2019 +0200

    fuse: add pages to fuse_args
    
    Derive fuse_args_pages from fuse_args. This is used to handle requests
    which use pages for input or output.  The related flags are added to
    fuse_args.
    
    New FR_ALLOC_PAGES flags is added to indicate whether the page arrays in
    fuse_req need to be freed by fuse_put_request() or not.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 73f70f3872e7..1998d6ab4025 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -294,11 +294,22 @@ struct fuse_args {
 	bool force:1;
 	bool noreply:1;
 	bool nocreds:1;
+	bool in_pages:1;
+	bool out_pages:1;
 	bool out_argvar:1;
+	bool page_zeroing:1;
+	bool page_replace:1;
 	struct fuse_in_arg in_args[3];
 	struct fuse_arg out_args[2];
 };
 
+struct fuse_args_pages {
+	struct fuse_args args;
+	struct page **pages;
+	struct fuse_page_desc *descs;
+	unsigned int num_pages;
+};
+
 #define FUSE_ARGS(args) struct fuse_args args = {}
 
 /** The request IO state (for asynchronous processing) */
@@ -352,6 +363,7 @@ enum fuse_req_flag {
 	FR_SENT,
 	FR_FINISHED,
 	FR_PRIVATE,
+	FR_ALLOC_PAGES,
 };
 
 /**

commit 1ccd1ea24962276ca0548386889ef7bf57479c5d
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:09 2019 +0200

    fuse: convert destroy to simple api
    
    We can use the "force" flag to make sure the DESTROY request is always sent
    to userspace.  So no need to keep it allocated during the lifetime of the
    filesystem.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 43ae5b7f4dd4..73f70f3872e7 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -715,6 +715,9 @@ struct fuse_conn {
 	/** Does the filesystem support copy_file_range? */
 	unsigned no_copy_file_range:1;
 
+	/* Send DESTROY request */
+	unsigned int destroy:1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 
@@ -736,9 +739,6 @@ struct fuse_conn {
 	/** Key for lock owner ID scrambling */
 	u32 scramble_key[4];
 
-	/** Reserved request for the DESTROY message */
-	struct fuse_req *destroy_req;
-
 	/** Version counter for attribute changes */
 	atomic64_t attr_version;
 

commit e413754b267e0e47ed38b3eacfa7178f21aca883
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:08 2019 +0200

    fuse: add nocreds to fuse_args
    
    In some cases it makes no sense to set pid/uid/gid fields in the request
    header.  Allow fuse_simple_background() to omit these.  This is only
    required in the "force" case, so for now just WARN if set otherwise.
    
    Fold fuse_get_req_nofail_nopages() into its only caller.  Comment is
    obsolete anyway.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index e6a8e47d0e0b..43ae5b7f4dd4 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -293,6 +293,7 @@ struct fuse_args {
 	unsigned short out_numargs;
 	bool force:1;
 	bool noreply:1;
+	bool nocreds:1;
 	bool out_argvar:1;
 	struct fuse_in_arg in_args[3];
 	struct fuse_arg out_args[2];

commit 3545fe21128262d425dd476b6d31f9a9e4d1b7a7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:08 2019 +0200

    fuse: convert fuse_force_forget() to simple api
    
    Move this function to the readdir.c where its only caller resides.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index ed6538e01feb..e6a8e47d0e0b 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -813,9 +813,6 @@ void fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,
 
 struct fuse_forget_link *fuse_alloc_forget(void);
 
-/* Used by READDIRPLUS */
-void fuse_force_forget(struct file *file, u64 nodeid);
-
 /**
  * Initialize READ or READDIR request
  */

commit 454a7613f54e64a36b257812ae879ef8567c675e
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:08 2019 +0200

    fuse: add noreply to fuse_args
    
    This will be used by fuse_force_forget().
    
    We can expand fuse_request_send() into fuse_simple_request().  The
    FR_WAITING bit has already been set, no need to check.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 24269f470c0e..ed6538e01feb 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -292,6 +292,7 @@ struct fuse_args {
 	unsigned short in_numargs;
 	unsigned short out_numargs;
 	bool force:1;
+	bool noreply:1;
 	bool out_argvar:1;
 	struct fuse_in_arg in_args[3];
 	struct fuse_arg out_args[2];

commit c500ebaa908dbf6b3c562778a25d7e945b04f40f
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:08 2019 +0200

    fuse: convert flush to simple api
    
    Add 'force' to fuse_args and use fuse_get_req_nofail_nopages() to allocate
    the request in that case.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index dd199391d6b9..24269f470c0e 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -291,6 +291,7 @@ struct fuse_args {
 	uint32_t opcode;
 	unsigned short in_numargs;
 	unsigned short out_numargs;
+	bool force:1;
 	bool out_argvar:1;
 	struct fuse_in_arg in_args[3];
 	struct fuse_arg out_args[2];
@@ -919,11 +920,6 @@ struct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,
  */
 void __fuse_get_request(struct fuse_req *req);
 
-/**
- * Gets a requests for a file operation, always succeeds
- */
-struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc);
-
 /**
  * Decrement reference count of a request.  If count goes to zero free
  * the request.

commit 40ac7ab2d02176f8a70e37b88e41637ed97b304b
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:08 2019 +0200

    fuse: simplify 'nofail' request
    
    Instead of complex games with a reserved request, just use __GFP_NOFAIL.
    
    Both calers (flush, readdir) guarantee that connection was already
    initialized, so no need to wait for fc->initialized.
    
    Also remove unneeded clearing of FR_BACKGROUND flag.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index a89362ee46d9..dd199391d6b9 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -435,8 +435,6 @@ struct fuse_req {
 	/** Request completion callback */
 	void (*end)(struct fuse_conn *, struct fuse_req *);
 
-	/** Request is stolen from fuse_file->reserved_req */
-	struct file *stolen_file;
 };
 
 struct fuse_iqueue {
@@ -580,9 +578,6 @@ struct fuse_conn {
 	/** waitq for blocked connection */
 	wait_queue_head_t blocked_waitq;
 
-	/** waitq for reserved requests */
-	wait_queue_head_t reserved_req_waitq;
-
 	/** Connection established, cleared on umount, connection
 	    abort and device release */
 	unsigned connected;
@@ -927,8 +922,7 @@ void __fuse_get_request(struct fuse_req *req);
 /**
  * Gets a requests for a file operation, always succeeds
  */
-struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,
-					     struct file *file);
+struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc);
 
 /**
  * Decrement reference count of a request.  If count goes to zero free

commit 1f4e9d03d1fbff428a0e864d5456e0a2dace6f81
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:08 2019 +0200

    fuse: rearrange and resize fuse_args fields
    
    This makes the structure better packed.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 835c0671320c..a89362ee46d9 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -287,12 +287,12 @@ struct fuse_page_desc {
 };
 
 struct fuse_args {
-	uint32_t opcode;
 	uint64_t nodeid;
-	unsigned int in_numargs;
+	uint32_t opcode;
+	unsigned short in_numargs;
+	unsigned short out_numargs;
+	bool out_argvar:1;
 	struct fuse_in_arg in_args[3];
-	unsigned int out_argvar:1;
-	unsigned int out_numargs;
 	struct fuse_arg out_args[2];
 };
 

commit d5b4854357f47899ea5b0336b41b04e81b62b11d
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 10 15:04:08 2019 +0200

    fuse: flatten 'struct fuse_args'
    
    ...to make future expansion simpler.  The hiearachical structure is a
    historical thing that does not serve any practical purpose.
    
    The generated code is excatly the same before and after the patch.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 89bdc41e0d86..835c0671320c 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -287,20 +287,13 @@ struct fuse_page_desc {
 };
 
 struct fuse_args {
-	struct {
-		struct {
-			uint32_t opcode;
-			uint64_t nodeid;
-		} h;
-		unsigned numargs;
-		struct fuse_in_arg args[3];
-
-	} in;
-	struct {
-		unsigned argvar:1;
-		unsigned numargs;
-		struct fuse_arg args[2];
-	} out;
+	uint32_t opcode;
+	uint64_t nodeid;
+	unsigned int in_numargs;
+	struct fuse_in_arg in_args[3];
+	unsigned int out_argvar:1;
+	unsigned int out_numargs;
+	struct fuse_arg out_args[2];
 };
 
 #define FUSE_ARGS(args) struct fuse_args args = {}

commit 76e43c8ccaa35c30d5df853013561145a0f750a5
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Sep 8 20:15:18 2019 -0700

    fuse: fix deadlock with aio poll and fuse_iqueue::waitq.lock
    
    When IOCB_CMD_POLL is used on the FUSE device, aio_poll() disables IRQs
    and takes kioctx::ctx_lock, then fuse_iqueue::waitq.lock.
    
    This may have to wait for fuse_iqueue::waitq.lock to be released by one
    of many places that take it with IRQs enabled.  Since the IRQ handler
    may take kioctx::ctx_lock, lockdep reports that a deadlock is possible.
    
    Fix it by protecting the state of struct fuse_iqueue with a separate
    spinlock, and only accessing fuse_iqueue::waitq using the versions of
    the waitqueue functions which do IRQ-safe locking internally.
    
    Reproducer:
    
            #include <fcntl.h>
            #include <stdio.h>
            #include <sys/mount.h>
            #include <sys/stat.h>
            #include <sys/syscall.h>
            #include <unistd.h>
            #include <linux/aio_abi.h>
    
            int main()
            {
                    char opts[128];
                    int fd = open("/dev/fuse", O_RDWR);
                    aio_context_t ctx = 0;
                    struct iocb cb = { .aio_lio_opcode = IOCB_CMD_POLL, .aio_fildes = fd };
                    struct iocb *cbp = &cb;
    
                    sprintf(opts, "fd=%d,rootmode=040000,user_id=0,group_id=0", fd);
                    mkdir("mnt", 0700);
                    mount("foo",  "mnt", "fuse", 0, opts);
                    syscall(__NR_io_setup, 1, &ctx);
                    syscall(__NR_io_submit, ctx, 1, &cbp);
            }
    
    Beginning of lockdep output:
    
            =====================================================
            WARNING: SOFTIRQ-safe -> SOFTIRQ-unsafe lock order detected
            5.3.0-rc5 #9 Not tainted
            -----------------------------------------------------
            syz_fuse/135 [HC0[0]:SC0[0]:HE0:SE1] is trying to acquire:
            000000003590ceda (&fiq->waitq){+.+.}, at: spin_lock include/linux/spinlock.h:338 [inline]
            000000003590ceda (&fiq->waitq){+.+.}, at: aio_poll fs/aio.c:1751 [inline]
            000000003590ceda (&fiq->waitq){+.+.}, at: __io_submit_one.constprop.0+0x203/0x5b0 fs/aio.c:1825
    
            and this task is already holding:
            0000000075037284 (&(&ctx->ctx_lock)->rlock){..-.}, at: spin_lock_irq include/linux/spinlock.h:363 [inline]
            0000000075037284 (&(&ctx->ctx_lock)->rlock){..-.}, at: aio_poll fs/aio.c:1749 [inline]
            0000000075037284 (&(&ctx->ctx_lock)->rlock){..-.}, at: __io_submit_one.constprop.0+0x1f4/0x5b0 fs/aio.c:1825
            which would create a new lock dependency:
             (&(&ctx->ctx_lock)->rlock){..-.} -> (&fiq->waitq){+.+.}
    
            but this new dependency connects a SOFTIRQ-irq-safe lock:
             (&(&ctx->ctx_lock)->rlock){..-.}
    
            [...]
    
    Reported-by: syzbot+af05535bb79520f95431@syzkaller.appspotmail.com
    Reported-by: syzbot+d86c4426a01f60feddc7@syzkaller.appspotmail.com
    Fixes: bfe4037e722e ("aio: implement IOCB_CMD_POLL")
    Cc: <stable@vger.kernel.org> # v4.19+
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 24dbca777775..89bdc41e0d86 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -450,6 +450,9 @@ struct fuse_iqueue {
 	/** Connection established */
 	unsigned connected;
 
+	/** Lock protecting accesses to members of this structure */
+	spinlock_t lock;
+
 	/** Readers of the connection are waiting on this */
 	wait_queue_head_t waitq;
 

commit ad2ba64dd489805e7ddf5fecf166cae1e09fc5c0
Author: Kirill Smelkov <kirr@nexedi.com>
Date:   Wed Mar 27 11:14:15 2019 +0000

    fuse: allow filesystems to have precise control over data cache
    
    On networked filesystems file data can be changed externally.  FUSE
    provides notification messages for filesystem to inform kernel that
    metadata or data region of a file needs to be invalidated in local page
    cache. That provides the basis for filesystem implementations to invalidate
    kernel cache explicitly based on observed filesystem-specific events.
    
    FUSE has also "automatic" invalidation mode(*) when the kernel
    automatically invalidates data cache of a file if it sees mtime change.  It
    also automatically invalidates whole data cache of a file if it sees file
    size being changed.
    
    The automatic mode has corresponding capability - FUSE_AUTO_INVAL_DATA.
    However, due to probably historical reason, that capability controls only
    whether mtime change should be resulting in automatic invalidation or
    not. A change in file size always results in invalidating whole data cache
    of a file irregardless of whether FUSE_AUTO_INVAL_DATA was negotiated(+).
    
    The filesystem I write[1] represents data arrays stored in networked
    database as local files suitable for mmap. It is read-only filesystem -
    changes to data are committed externally via database interfaces and the
    filesystem only glues data into contiguous file streams suitable for mmap
    and traditional array processing. The files are big - starting from
    hundreds gigabytes and more. The files change regularly, and frequently by
    data being appended to their end. The size of files thus changes
    frequently.
    
    If a file was accessed locally and some part of its data got into page
    cache, we want that data to stay cached unless there is memory pressure, or
    unless corresponding part of the file was actually changed. However current
    FUSE behaviour - when it sees file size change - is to invalidate the whole
    file. The data cache of the file is thus completely lost even on small size
    change, and despite that the filesystem server is careful to accurately
    translate database changes into FUSE invalidation messages to kernel.
    
    Let's fix it: if a filesystem, through new FUSE_EXPLICIT_INVAL_DATA
    capability, indicates to kernel that it is fully responsible for data cache
    invalidation, then the kernel won't invalidate files data cache on size
    change and only truncate that cache to new size in case the size decreased.
    
    (*) see 72d0d248ca "fuse: add FUSE_AUTO_INVAL_DATA init flag",
    eed2179efe "fuse: invalidate inode mapping if mtime changes"
    
    (+) in writeback mode the kernel does not invalidate data cache on file
    size change, but neither it allows the filesystem to set the size due to
    external event (see 8373200b12 "fuse: Trust kernel i_size only")
    
    [1] https://lab.nexedi.com/kirr/wendelin.core/blob/a50f1d9f/wcfs/wcfs.go#L20
    
    Signed-off-by: Kirill Smelkov <kirr@nexedi.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index e6195bc8f836..24dbca777775 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -694,6 +694,9 @@ struct fuse_conn {
 	/** Use enhanced/automatic page cache invalidation. */
 	unsigned auto_inval_data:1;
 
+	/** Filesystem is fully reponsible for page cache invalidation. */
+	unsigned explicit_inval_data:1;
+
 	/** Does the filesystem support readdirplus? */
 	unsigned do_readdirplus:1;
 

commit f2294482ff65dd9c9c3c6ae1447f908c6aa60f52
Author: Kirill Smelkov <kirr@nexedi.com>
Date:   Wed Mar 27 09:15:17 2019 +0000

    fuse: convert printk -> pr_*
    
    Functions, like pr_err, are a more modern variant of printing compared to
    printk. They could be used to denoise sources by using needed level in
    the print function name, and by automatically inserting per-driver /
    function / ... print prefix as defined by pr_fmt macro. pr_* are also
    said to be used in Documentation/process/coding-style.rst and more
    recent code - for example overlayfs - uses them instead of printk.
    
    Convert CUSE and FUSE to use the new pr_* functions.
    
    CUSE output stays completely unchanged, while FUSE output is amended a
    bit for "trying to steal weird page" warning - the second line now comes
    also with "fuse:" prefix. I hope it is ok.
    
    Suggested-by: Kirill Tkhai <ktkhai@virtuozzo.com>
    Signed-off-by: Kirill Smelkov <kirr@nexedi.com>
    Reviewed-by: Kirill Tkhai <ktkhai@virtuozzo.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 0920c0c032a0..e6195bc8f836 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -9,6 +9,10 @@
 #ifndef _FS_FUSE_I_H
 #define _FS_FUSE_I_H
 
+#ifndef pr_fmt
+# define pr_fmt(fmt) "fuse: " fmt
+#endif
+
 #include <linux/fuse.h>
 #include <linux/fs.h>
 #include <linux/mount.h>

commit d9a9ea94f748f47b1d75c6c5e33edcf74476c445
Author: Chad Austin <chadaustin@fb.com>
Date:   Mon Jan 7 16:53:17 2019 -0800

    fuse: support clients that don't implement 'opendir'
    
    Allow filesystems to return ENOSYS from opendir, preventing the kernel from
    sending opendir and releasedir messages in the future. This avoids
    userspace transitions when filesystems don't need to keep track of state
    per directory handle.
    
    A new capability flag, FUSE_NO_OPENDIR_SUPPORT, parallels
    FUSE_NO_OPEN_SUPPORT, indicating the new semantics for returning ENOSYS
    from opendir.
    
    Signed-off-by: Chad Austin <chadaustin@fb.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 033e30af519f..0920c0c032a0 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -630,6 +630,9 @@ struct fuse_conn {
 	/** Is open/release not implemented by fs? */
 	unsigned no_open:1;
 
+	/** Is opendir/releasedir not implemented by fs? */
+	unsigned no_opendir:1;
+
 	/** Is fsync not implemented by fs? */
 	unsigned no_fsync:1;
 

commit 75126f5504524dd0f24753d8815db42d9ab23614
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Jan 24 10:40:17 2019 +0100

    fuse: use atomic64_t for khctr
    
    ...to get rid of one more fc->lock use.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index b1ac587671ac..033e30af519f 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -544,7 +544,7 @@ struct fuse_conn {
 	struct fuse_iqueue iq;
 
 	/** The next unique kernel file handle */
-	u64 khctr;
+	atomic64_t khctr;
 
 	/** rbtree of fuse_files waiting for poll events indexed by ph */
 	struct rb_root polled_files;

commit eb98e3bdf3aa7b15b40c65063ea935f953f60c6b
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Jan 24 10:40:16 2019 +0100

    fuse: clean up aborted
    
    The only caller that needs fc->aborted set is fuse_conn_abort_write().
    Setting fc->aborted is now racy (fuse_abort_conn() may already be in
    progress or finished) but there's no reason to care.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 4fdd098e422d..b1ac587671ac 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -947,7 +947,7 @@ void fuse_request_send_background(struct fuse_conn *fc, struct fuse_req *req);
 bool fuse_request_queue_background(struct fuse_conn *fc, struct fuse_req *req);
 
 /* Abort all requests */
-void fuse_abort_conn(struct fuse_conn *fc, bool is_abort);
+void fuse_abort_conn(struct fuse_conn *fc);
 void fuse_wait_aborted(struct fuse_conn *fc);
 
 /**

commit 6b675738ce900dac8f8478b1d8487df420a315f3
Author: Kirill Tkhai <ktkhai@virtuozzo.com>
Date:   Fri Nov 9 13:33:32 2018 +0300

    fuse: Protect ff->reserved_req via corresponding fi->lock
    
    This is rather natural action after previous patches, and it just decreases
    load of fc->lock.
    
    Signed-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 1c610b65b1bf..4fdd098e422d 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -166,7 +166,10 @@ struct fuse_file {
 	/** Fuse connection for this file */
 	struct fuse_conn *fc;
 
-	/** Request reserved for flush and release */
+	/*
+	 * Request reserved for flush and release.
+	 * Modified under relative fuse_inode::lock.
+	 */
 	struct fuse_req *reserved_req;
 
 	/** Kernel file handle guaranteed to be unique */

commit f15ecfef058d94d03bdb35dcdfda041b3de9d543
Author: Kirill Tkhai <ktkhai@virtuozzo.com>
Date:   Fri Nov 9 13:33:22 2018 +0300

    fuse: Introduce fi->lock to protect write related fields
    
    To minimize contention of fc->lock, this patch introduces a new spinlock
    for protection fuse_inode metadata:
    
    fuse_inode:
            writectr
            writepages
            write_files
            queued_writes
            attr_version
    
    inode:
            i_size
            i_nlink
            i_mtime
            i_ctime
    
    Also, it protects the fields changed in fuse_change_attributes_common()
    (too many to list).
    
    Signed-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 47c7b2238f91..1c610b65b1bf 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -96,7 +96,7 @@ struct fuse_inode {
 	union {
 		/* Write related fields (regular file only) */
 		struct {
-			/* Files usable in writepage.  Protected by fc->lock */
+			/* Files usable in writepage.  Protected by fi->lock */
 			struct list_head write_files;
 
 			/* Writepages pending on truncate or fsync */
@@ -144,6 +144,9 @@ struct fuse_inode {
 
 	/** Lock for serializing lookup and readdir for back compatibility*/
 	struct mutex mutex;
+
+	/** Lock to protect write related fields */
+	spinlock_t lock;
 };
 
 /** FUSE inode state bits */

commit 4510d86fbbb36872224482bb21836d47cce8be8c
Author: Kirill Tkhai <ktkhai@virtuozzo.com>
Date:   Fri Nov 9 13:33:17 2018 +0300

    fuse: Convert fc->attr_version into atomic64_t
    
    This patch makes fc->attr_version of atomic64_t type, so fc->lock won't be
    needed to read or modify it anymore.
    
    Signed-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 1b536b6c20f9..47c7b2238f91 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -730,7 +730,7 @@ struct fuse_conn {
 	struct fuse_req *destroy_req;
 
 	/** Version counter for attribute changes */
-	u64 attr_version;
+	atomic64_t attr_version;
 
 	/** Called on final put */
 	void (*release)(struct fuse_conn *);
@@ -770,6 +770,11 @@ static inline int invalid_nodeid(u64 nodeid)
 	return !nodeid || nodeid == FUSE_ROOT_ID;
 }
 
+static inline u64 fuse_get_attr_version(struct fuse_conn *fc)
+{
+	return atomic64_read(&fc->attr_version);
+}
+
 /** Device operations */
 extern const struct file_operations fuse_dev_operations;
 
@@ -1000,8 +1005,6 @@ void fuse_flush_writepages(struct inode *inode);
 void fuse_set_nowrite(struct inode *inode);
 void fuse_release_nowrite(struct inode *inode);
 
-u64 fuse_get_attr_version(struct fuse_conn *fc);
-
 /**
  * File-system tells the kernel to invalidate cache for the given node id.
  */

commit ebf84d0c7220c7c9b904c405e61175d2a50cfb39
Author: Kirill Tkhai <ktkhai@virtuozzo.com>
Date:   Fri Nov 9 13:33:11 2018 +0300

    fuse: Add fuse_inode argument to fuse_prepare_release()
    
    Here is preparation for next patches, which introduce new fi->lock for
    protection of ff->write_entry linked into fi->write_files.
    
    This patch just passes new argument to the function.
    
    Signed-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 2f2c92e6f8cb..1b536b6c20f9 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -817,7 +817,7 @@ struct fuse_file *fuse_file_alloc(struct fuse_conn *fc);
 void fuse_file_free(struct fuse_file *ff);
 void fuse_finish_open(struct inode *inode, struct file *file);
 
-void fuse_sync_release(struct fuse_file *ff, int flags);
+void fuse_sync_release(struct fuse_inode *fi, struct fuse_file *ff, int flags);
 
 /**
  * Send RELEASE or RELEASEDIR request

commit 2e64ff154ce6ce9a8dc0f9556463916efa6ff460
Author: Chad Austin <chadaustin@fb.com>
Date:   Mon Dec 10 10:54:52 2018 -0800

    fuse: continue to send FUSE_RELEASEDIR when FUSE_OPEN returns ENOSYS
    
    When FUSE_OPEN returns ENOSYS, the no_open bit is set on the connection.
    
    Because the FUSE_RELEASE and FUSE_RELEASEDIR paths share code, this
    incorrectly caused the FUSE_RELEASEDIR request to be dropped and never sent
    to userspace.
    
    Pass an isdir bool to distinguish between FUSE_RELEASE and FUSE_RELEASEDIR
    inside of fuse_file_put.
    
    Fixes: 7678ac50615d ("fuse: support clients that don't implement 'open'")
    Cc: <stable@vger.kernel.org> # v3.14
    Signed-off-by: Chad Austin <chadaustin@fb.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index afe1f231c758..2f2c92e6f8cb 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -822,7 +822,7 @@ void fuse_sync_release(struct fuse_file *ff, int flags);
 /**
  * Send RELEASE or RELEASEDIR request
  */
-void fuse_release_common(struct file *file, int opcode);
+void fuse_release_common(struct file *file, bool isdir);
 
 /**
  * Send FSYNC or FSYNCDIR request

commit a9c2d1e82fc2937baf43c0d400f0c9e87dcf035d
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Dec 3 10:14:43 2018 +0100

    fuse: fix fsync on directory
    
    Commit ab2257e9941b ("fuse: reduce size of struct fuse_inode") moved parts
    of fields related to writeback on regular file and to directory caching
    into a union.  However fuse_fsync_common() called from fuse_dir_fsync()
    touches some writeback related fields, resulting in a crash.
    
    Move writeback related parts from fuse_fsync_common() to fuse_fysnc().
    
    Reported-by: Brett Girton <btgirton@gmail.com>
    Tested-by: Brett Girton <btgirton@gmail.com>
    Fixes: ab2257e9941b ("fuse: reduce size of struct fuse_inode")
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index e9f712e81c7d..afe1f231c758 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -828,7 +828,7 @@ void fuse_release_common(struct file *file, int opcode);
  * Send FSYNC or FSYNCDIR request
  */
 int fuse_fsync_common(struct file *file, loff_t start, loff_t end,
-		      int datasync, int isdir);
+		      int datasync, int opcode);
 
 /**
  * Notify poll wakeup

commit 5571f1e65486be025f73fa6aa30fb03725d362a2
Author: Dan Schatzberg <dschatzberg@fb.com>
Date:   Thu Oct 11 08:17:00 2018 -0700

    fuse: enable caching of symlinks
    
    FUSE file reads are cached in the page cache, but symlink reads are
    not. This patch enables FUSE READLINK operations to be cached which
    can improve performance of some FUSE workloads.
    
    In particular, I'm working on a FUSE filesystem for access to source
    code and discovered that about a 10% improvement to build times is
    achieved with this patch (there are a lot of symlinks in the source
    tree).
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 0e32524e66bb..e9f712e81c7d 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -613,6 +613,9 @@ struct fuse_conn {
 	/** handle fs handles killing suid/sgid/cap on write/chown/trunc */
 	unsigned handle_killpriv:1;
 
+	/** cache READLINK responses in page cache */
+	unsigned cache_symlinks:1;
+
 	/*
 	 * The following bitfields are only for optimization purposes
 	 * and hence races in setting them will not cause malfunction

commit 2f1e81965fd0f672c3246e751385cdfe8f86bbee
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Oct 15 15:43:06 2018 +0200

    fuse: allow fine grained attr cache invaldation
    
    This patch adds the infrastructure for more fine grained attribute
    invalidation.  Currently only 'atime' is invalidated separately.
    
    The use of this infrastructure is extended to the statx(2) interface, which
    for now means that if only 'atime' is invalid and STATX_ATIME is not
    specified in the mask argument, then no GETATTR request will be generated.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index b7d96e7b5e0f..0e32524e66bb 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -80,6 +80,9 @@ struct fuse_inode {
 	/** Time in jiffies until the file attributes are valid */
 	u64 i_time;
 
+	/* Which attributes are invalid */
+	u32 inval_mask;
+
 	/** The sticky bit in inode->i_mode may have been removed, so
 	    preserve the original mode */
 	umode_t orig_i_mode;

commit e52a8250480acd3b26534793c61816e30d85fbb6
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Oct 1 10:07:06 2018 +0200

    fuse: realloc page array
    
    Writeback caching currently allocates requests with the maximum number of
    possible pages, while the actual number of pages per request depends on a
    couple of factors that cannot be determined when the request is allocated
    (whether page is already under writeback, whether page is contiguous with
    previous pages already added to a request).
    
    This patch allows such requests to start with no page allocation (all pages
    inline) and grow the page array on demand.
    
    If the max_pages tunable remains the default value, then this will mean
    just one allocation that is the same size as before.  If the tunable is
    larger, then this adds at most 3 additional memory allocations (which is
    generously compensated by the improved performance from the larger
    request).
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 3d578745c852..b7d96e7b5e0f 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -879,6 +879,10 @@ struct fuse_req *fuse_request_alloc(unsigned npages);
 
 struct fuse_req *fuse_request_alloc_nofs(unsigned npages);
 
+bool fuse_req_realloc_pages(struct fuse_conn *fc, struct fuse_req *req,
+			    gfp_t flags);
+
+
 /**
  * Free a request
  */

commit 5da784cce4308ae10a79e3c8c41b13fb9568e4e0
Author: Constantine Shulyupin <const@MakeLinux.com>
Date:   Thu Sep 6 15:37:06 2018 +0300

    fuse: add max_pages to init_out
    
    Replace FUSE_MAX_PAGES_PER_REQ with the configurable parameter max_pages to
    improve performance.
    
    Old RFC with detailed description of the problem and many fixes by Mitsuo
    Hayasaka (mitsuo.hayasaka.hu@hitachi.com):
     - https://lkml.org/lkml/2012/7/5/136
    
    We've encountered performance degradation and fixed it on a big and complex
    virtual environment.
    
    Environment to reproduce degradation and improvement:
    
    1. Add lag to user mode FUSE
    Add nanosleep(&(struct timespec){ 0, 1000 }, NULL); to xmp_write_buf in
    passthrough_fh.c
    
    2. patch UM fuse with configurable max_pages parameter. The patch will be
    provided latter.
    
    3. run test script and perform test on tmpfs
    fuse_test()
    {
    
           cd /tmp
           mkdir -p fusemnt
           passthrough_fh -o max_pages=$1 /tmp/fusemnt
           grep fuse /proc/self/mounts
           dd conv=fdatasync oflag=dsync if=/dev/zero of=fusemnt/tmp/tmp \
                    count=1K bs=1M 2>&1 | grep -v records
           rm fusemnt/tmp/tmp
           killall passthrough_fh
    }
    
    Test results:
    
    passthrough_fh /tmp/fusemnt fuse.passthrough_fh \
            rw,nosuid,nodev,relatime,user_id=0,group_id=0 0 0
    1073741824 bytes (1.1 GB) copied, 1.73867 s, 618 MB/s
    
    passthrough_fh /tmp/fusemnt fuse.passthrough_fh \
            rw,nosuid,nodev,relatime,user_id=0,group_id=0,max_pages=256 0 0
    1073741824 bytes (1.1 GB) copied, 1.15643 s, 928 MB/s
    
    Obviously with bigger lag the difference between 'before' and 'after'
    will be more significant.
    
    Mitsuo Hayasaka, in 2012 (https://lkml.org/lkml/2012/7/5/136),
    observed improvement from 400-550 to 520-740.
    
    Signed-off-by: Constantine Shulyupin <const@MakeLinux.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index f5bdce84e766..3d578745c852 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -28,8 +28,11 @@
 #include <linux/refcount.h>
 #include <linux/user_namespace.h>
 
-/** Max number of pages that can be used in a single read request */
-#define FUSE_MAX_PAGES_PER_REQ 32
+/** Default max number of pages that can be used in a single read request */
+#define FUSE_DEFAULT_MAX_PAGES_PER_REQ 32
+
+/** Maximum of max_pages received in init_out */
+#define FUSE_MAX_MAX_PAGES 256
 
 /** Bias for fi->writectr, meaning new writepages must not be sent */
 #define FUSE_NOWRITE INT_MIN
@@ -525,6 +528,9 @@ struct fuse_conn {
 	/** Maximum write size */
 	unsigned max_write;
 
+	/** Maxmum number of pages that can be used in a single request */
+	unsigned int max_pages;
+
 	/** Input queue */
 	struct fuse_iqueue iq;
 

commit ab2257e9941b9ef28d4a4a451e4b146d40a21e18
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Oct 1 10:07:05 2018 +0200

    fuse: reduce size of struct fuse_inode
    
    Do this by grouping fields used for cached writes and putting them into a
    union with fileds used for cached readdir (with obviously no overlap, since
    we don't have hybrid objects).
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index d9d1ea78efa6..f5bdce84e766 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -87,45 +87,51 @@ struct fuse_inode {
 	/** Version of last attribute change */
 	u64 attr_version;
 
-	/** Files usable in writepage.  Protected by fc->lock */
-	struct list_head write_files;
+	union {
+		/* Write related fields (regular file only) */
+		struct {
+			/* Files usable in writepage.  Protected by fc->lock */
+			struct list_head write_files;
 
-	/** Writepages pending on truncate or fsync */
-	struct list_head queued_writes;
+			/* Writepages pending on truncate or fsync */
+			struct list_head queued_writes;
 
-	/** Number of sent writes, a negative bias (FUSE_NOWRITE)
-	 * means more writes are blocked */
-	int writectr;
+			/* Number of sent writes, a negative bias
+			 * (FUSE_NOWRITE) means more writes are blocked */
+			int writectr;
 
-	/** Waitq for writepage completion */
-	wait_queue_head_t page_waitq;
+			/* Waitq for writepage completion */
+			wait_queue_head_t page_waitq;
 
-	/** List of writepage requestst (pending or sent) */
-	struct list_head writepages;
+			/* List of writepage requestst (pending or sent) */
+			struct list_head writepages;
+		};
 
-	/* readdir cache */
-	struct {
-		/* true if fully cached */
-		bool cached;
+		/* readdir cache (directory only) */
+		struct {
+			/* true if fully cached */
+			bool cached;
 
-		/* size of cache */
-		loff_t size;
+			/* size of cache */
+			loff_t size;
 
-		/* position at end of cache (position of next entry) */
-		loff_t pos;
+			/* position at end of cache (position of next entry) */
+			loff_t pos;
 
-		/* version of the cache */
-		u64 version;
+			/* version of the cache */
+			u64 version;
 
-		/* modification time of directory when cache was started */
-		struct timespec64 mtime;
+			/* modification time of directory when cache was
+			 * started */
+			struct timespec64 mtime;
 
-		/* iversion of directory when cache was started */
-		u64 iversion;
+			/* iversion of directory when cache was started */
+			u64 iversion;
 
-		/* protects above fields */
-		spinlock_t lock;
-	} rdc;
+			/* protects above fields */
+			spinlock_t lock;
+		} rdc;
+	};
 
 	/** Miscellaneous bits describing inode state */
 	unsigned long state;

commit 261aaba72fdba17b74a3a434d9f925b43d90e958
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Oct 1 10:07:05 2018 +0200

    fuse: use iversion for readdir cache verification
    
    Use the internal iversion counter to make sure modifications of the
    directory through this filesystem are not missed by the mtime check (due to
    mtime granularity).
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 3deb013a289e..d9d1ea78efa6 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -120,6 +120,9 @@ struct fuse_inode {
 		/* modification time of directory when cache was started */
 		struct timespec64 mtime;
 
+		/* iversion of directory when cache was started */
+		u64 iversion;
+
 		/* protects above fields */
 		spinlock_t lock;
 	} rdc;

commit 7118883b44b8edfea732aadeb0d4424da3f152b2
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Oct 1 10:07:04 2018 +0200

    fuse: use mtime for readdir cache verification
    
    Store the modification time of the directory in the cache, obtained before
    starting to fill the cache.
    
    When reading the cache, verify that the directory hasn't changed, by
    checking if current modification time is the same as the one stored in the
    cache.
    
    This only needs to be done when the current file position is at the
    beginning of the directory, as mandated by POSIX.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 8b24805e62ee..3deb013a289e 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -117,6 +117,9 @@ struct fuse_inode {
 		/* version of the cache */
 		u64 version;
 
+		/* modification time of directory when cache was started */
+		struct timespec64 mtime;
+
 		/* protects above fields */
 		spinlock_t lock;
 	} rdc;

commit 3494927e090bf511e54eecaf33a8e56e5c0463db
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Oct 1 10:07:04 2018 +0200

    fuse: add readdir cache version
    
    Allow the cache to be invalidated when page(s) have gone missing.  In this
    case increment the version of the cache and reset to an empty state.
    
    Add a version number to the directory stream in struct fuse_file as well,
    indicating the version of the cache it's supposed to be reading.  If the
    cache version doesn't match the stream's version, then reset the stream to
    the beginning of the cache.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 49e42635e3ac..8b24805e62ee 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -114,6 +114,9 @@ struct fuse_inode {
 		/* position at end of cache (position of next entry) */
 		loff_t pos;
 
+		/* version of the cache */
+		u64 version;
+
 		/* protects above fields */
 		spinlock_t lock;
 	} rdc;
@@ -176,6 +179,10 @@ struct fuse_file {
 
 		/* Offset in cache */
 		loff_t cache_off;
+
+		/* Version of cache we are reading */
+		u64 version;
+
 	} readdir;
 
 	/** RB node to be linked on fuse_conn->polled_files */

commit 5d7bc7e8680c7ca4c8a4f139ce2a54ccb8131ef0
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Oct 1 10:07:04 2018 +0200

    fuse: allow using readdir cache
    
    The cache is only used if it's completed, not while it's still being
    filled; this constraint could be lifted later, if it turns out to be
    useful.
    
    Introduce state in struct fuse_file that indicates the position within the
    cache.  After a seek, reset the position to the beginning of the cache and
    search the cache for the current position.  If the current position is not
    found in the cache, then fall back to uncached readdir.
    
    It can also happen that page(s) disappear from the cache, in which case we
    must also fall back to uncached readdir.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index d2fa7588533e..49e42635e3ac 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -163,6 +163,21 @@ struct fuse_file {
 	/** Entry on inode's write_files list */
 	struct list_head write_entry;
 
+	/* Readdir related */
+	struct {
+		/*
+		 * Protects below fields against (crazy) parallel readdir on
+		 * same open file.  Uncontended in the normal case.
+		 */
+		struct mutex lock;
+
+		/* Dir stream position */
+		loff_t pos;
+
+		/* Offset in cache */
+		loff_t cache_off;
+	} readdir;
+
 	/** RB node to be linked on fuse_conn->polled_files */
 	struct rb_node polled_node;
 

commit 69e34551152a286f827d54dcb5700da6aeaac1fb
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Oct 1 10:07:04 2018 +0200

    fuse: allow caching readdir
    
    This patch just adds the cache filling functions, which are invoked if
    FOPEN_CACHE_DIR flag is set in the OPENDIR reply.
    
    Cache reading and cache invalidation are added by subsequent patches.
    
    The directory cache uses the page cache.  Directory entries are packed into
    a page in the same format as in the READDIR reply.  A page only contains
    whole entries, the space at the end of the page is cleared.  The page is
    locked while being modified.
    
    Multiple parallel readdirs on the same directory can fill the cache; the
    only constraint is that continuity must be maintained (d_off of last entry
    points to position of current entry).
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index dfe10c2df6a9..d2fa7588533e 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -103,6 +103,21 @@ struct fuse_inode {
 	/** List of writepage requestst (pending or sent) */
 	struct list_head writepages;
 
+	/* readdir cache */
+	struct {
+		/* true if fully cached */
+		bool cached;
+
+		/* size of cache */
+		loff_t size;
+
+		/* position at end of cache (position of next entry) */
+		loff_t pos;
+
+		/* protects above fields */
+		spinlock_t lock;
+	} rdc;
+
 	/** Miscellaneous bits describing inode state */
 	unsigned long state;
 

commit d123d8e1833c5d854b56f2a7da17cafd0a901df8
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Sep 28 16:43:23 2018 +0200

    fuse: split out readdir.c
    
    Directory reading code is about to grow larger, so split it out from dir.c
    into a new source file.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 2c4272076f62..dfe10c2df6a9 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -704,6 +704,11 @@ static inline u64 get_node_id(struct inode *inode)
 	return get_fuse_inode(inode)->nodeid;
 }
 
+static inline int invalid_nodeid(u64 nodeid)
+{
+	return !nodeid || nodeid == FUSE_ROOT_ID;
+}
+
 /** Device operations */
 extern const struct file_operations fuse_dev_operations;
 
@@ -878,6 +883,9 @@ void fuse_invalidate_entry_cache(struct dentry *entry);
 
 void fuse_invalidate_atime(struct inode *inode);
 
+u64 entry_attr_timeout(struct fuse_entry_out *o);
+void fuse_change_entry_timeout(struct dentry *entry, struct fuse_entry_out *o);
+
 /**
  * Acquire reference to fuse_conn
  */
@@ -997,4 +1005,8 @@ struct posix_acl;
 struct posix_acl *fuse_get_acl(struct inode *inode, int type);
 int fuse_set_acl(struct inode *inode, struct posix_acl *acl, int type);
 
+
+/* readdir.c */
+int fuse_readdir(struct file *file, struct dir_context *ctx);
+
 #endif /* _FS_FUSE_I_H */

commit be2ff42c5d6ebc8552c82a7d1697afae30510ed9
Author: Kirill Tkhai <ktkhai@virtuozzo.com>
Date:   Tue Sep 11 13:12:14 2018 +0300

    fuse: Use hash table to link processing request
    
    We noticed the performance bottleneck in FUSE running our Virtuozzo storage
    over rdma. On some types of workload we observe 20% of times spent in
    request_find() in profiler.  This function is iterating over long requests
    list, and it scales bad.
    
    The patch introduces hash table to reduce the number of iterations, we do
    in this function. Hash generating algorithm is taken from hash_add()
    function, while 256 lines table is used to store pending requests.  This
    fixes problem and improves the performance.
    
    Reported-by: Alexey Kuznetsov <kuznet@virtuozzo.com>
    Signed-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 1d7b5b7a051d..2c4272076f62 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -408,6 +408,9 @@ struct fuse_iqueue {
 	struct fasync_struct *fasync;
 };
 
+#define FUSE_PQ_HASH_BITS 8
+#define FUSE_PQ_HASH_SIZE (1 << FUSE_PQ_HASH_BITS)
+
 struct fuse_pqueue {
 	/** Connection established */
 	unsigned connected;
@@ -415,8 +418,8 @@ struct fuse_pqueue {
 	/** Lock protecting accessess to  members of this structure */
 	spinlock_t lock;
 
-	/** The list of requests being processed */
-	struct list_head processing;
+	/** Hash table of requests being processed */
+	struct list_head *processing;
 
 	/** The list of requests under I/O */
 	struct list_head io;

commit 3a5358d1a1b70bb3360578f09894d6856629ecdf
Author: Kirill Tkhai <ktkhai@virtuozzo.com>
Date:   Tue Sep 11 13:12:05 2018 +0300

    fuse: kill req->intr_unique
    
    This field is not needed after the previous patch, since we can easily
    convert request ID to interrupt request ID and vice versa.
    
    Signed-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 6e6eab8127a4..1d7b5b7a051d 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -311,9 +311,6 @@ struct fuse_req {
 	/** refcount */
 	refcount_t count;
 
-	/** Unique ID for the interrupt request */
-	u64 intr_unique;
-
 	/* Request flags, updated with test/set/clear_bit() */
 	unsigned long flags;
 

commit 63825b4e1da5a3cba79d835a5925e5daf7db3a77
Author: Kirill Tkhai <ktkhai@virtuozzo.com>
Date:   Mon Aug 27 18:29:56 2018 +0300

    fuse: do not take fc->lock in fuse_request_send_background()
    
    Currently, we take fc->lock there only to check for fc->connected.
    But this flag is changed only on connection abort, which is very
    rare operation.
    
    So allow checking fc->connected under just fc->bg_lock and use this lock
    (as well as fc->lock) when resetting fc->connected.
    
    Signed-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index d6d55641a5a6..6e6eab8127a4 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -863,9 +863,7 @@ ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args);
  * Send a request in the background
  */
 void fuse_request_send_background(struct fuse_conn *fc, struct fuse_req *req);
-
-void fuse_request_send_background_nocheck(struct fuse_conn *fc,
-					  struct fuse_req *req);
+bool fuse_request_queue_background(struct fuse_conn *fc, struct fuse_req *req);
 
 /* Abort all requests */
 void fuse_abort_conn(struct fuse_conn *fc, bool is_abort);

commit ae2dffa39485c6fd4f22321814c7287c274b473a
Author: Kirill Tkhai <ktkhai@virtuozzo.com>
Date:   Mon Aug 27 18:29:46 2018 +0300

    fuse: introduce fc->bg_lock
    
    To reduce contention of fc->lock, this patch introduces bg_lock for
    protection of fields related to background queue. These are:
    max_background, congestion_threshold, num_background, active_background,
    bg_queue and blocked.
    
    This allows next patch to make async reads not requiring fc->lock, so async
    reads and writes will have better performance executed in parallel.
    
    Signed-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 3e45d408a644..d6d55641a5a6 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -500,6 +500,10 @@ struct fuse_conn {
 	/** The list of background requests set aside for later queuing */
 	struct list_head bg_queue;
 
+	/** Protects: max_background, congestion_threshold, num_background,
+	 * active_background, bg_queue, blocked */
+	spinlock_t bg_lock;
+
 	/** Flag indicating that INIT reply has been received. Allocating
 	 * any fuse request will be suspended until the flag is set */
 	int initialized;
@@ -860,8 +864,8 @@ ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args);
  */
 void fuse_request_send_background(struct fuse_conn *fc, struct fuse_req *req);
 
-void fuse_request_send_background_locked(struct fuse_conn *fc,
-					 struct fuse_req *req);
+void fuse_request_send_background_nocheck(struct fuse_conn *fc,
+					  struct fuse_req *req);
 
 /* Abort all requests */
 void fuse_abort_conn(struct fuse_conn *fc, bool is_abort);

commit 88bc7d5097a11d9bdcf08ecf85c81ba998353437
Author: Niels de Vos <ndevos@redhat.com>
Date:   Tue Aug 21 14:36:31 2018 +0200

    fuse: add support for copy_file_range()
    
    There are several FUSE filesystems that can implement server-side copy
    or other efficient copy/duplication/clone methods. The copy_file_range()
    syscall is the standard interface that users have access to while not
    depending on external libraries that bypass FUSE.
    
    Signed-off-by: Niels de Vos <ndevos@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index f78e9614bb5f..3e45d408a644 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -637,6 +637,9 @@ struct fuse_conn {
 	/** Allow other than the mounter user to access the filesystem ? */
 	unsigned allow_other:1;
 
+	/** Does the filesystem support copy_file_range? */
+	unsigned no_copy_file_range:1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 

commit 63576c13bd17848376c8ba4a98f5d5151140c4ac
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Jul 26 16:13:11 2018 +0200

    fuse: fix initial parallel dirops
    
    If parallel dirops are enabled in FUSE_INIT reply, then first operation may
    leave fi->mutex held.
    
    Reported-by: syzbot <syzbot+3f7b29af1baa9d0a55be@syzkaller.appspotmail.com>
    Fixes: 5c672ab3f0ee ("fuse: serialize dirops by default")
    Cc: <stable@vger.kernel.org> # v4.7
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 582b1756a011..f78e9614bb5f 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -975,8 +975,8 @@ int fuse_do_setattr(struct dentry *dentry, struct iattr *attr,
 
 void fuse_set_initialized(struct fuse_conn *fc);
 
-void fuse_unlock_inode(struct inode *inode);
-void fuse_lock_inode(struct inode *inode);
+void fuse_unlock_inode(struct inode *inode, bool locked);
+bool fuse_lock_inode(struct inode *inode);
 
 int fuse_setxattr(struct inode *inode, const char *name, const void *value,
 		  size_t size, int flags);

commit b8f95e5d13f5f0191dcb4b9113113d241636e7cb
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Jul 26 16:13:11 2018 +0200

    fuse: umount should wait for all requests
    
    fuse_abort_conn() does not guarantee that all async requests have actually
    finished aborting (i.e. their ->end() function is called).  This could
    actually result in still used inodes after umount.
    
    Add a helper to wait until all requests are fully done.  This is done by
    looking at the "num_waiting" counter.  When this counter drops to zero, we
    can be sure that no more requests are outstanding.
    
    Fixes: 0d8e84b0432b ("fuse: simplify request abort")
    Cc: <stable@vger.kernel.org> # v4.2
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 5256ad333b05..582b1756a011 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -862,6 +862,7 @@ void fuse_request_send_background_locked(struct fuse_conn *fc,
 
 /* Abort all requests */
 void fuse_abort_conn(struct fuse_conn *fc, bool is_abort);
+void fuse_wait_aborted(struct fuse_conn *fc);
 
 /**
  * Invalidate inode attributes

commit e45b2546e23c2d10f8585063a15c745a7603fac9
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri May 4 11:47:28 2018 -0500

    fuse: Ensure posix acls are translated outside of init_user_ns
    
    Ensure the translation happens by failing to read or write
    posix acls when the filesystem has not indicated it supports
    posix acls.
    
    This ensures that modern cached posix acl support is available
    and used when dealing with posix acls.  This is important
    because only that path has the code to convernt the uids and
    gids in posix acls into the user namespace of a fuse filesystem.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index f630951df8dc..5256ad333b05 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -985,6 +985,7 @@ ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size);
 int fuse_removexattr(struct inode *inode, const char *name);
 extern const struct xattr_handler *fuse_xattr_handlers[];
 extern const struct xattr_handler *fuse_acl_xattr_handlers[];
+extern const struct xattr_handler *fuse_no_acl_xattr_handlers[];
 
 struct posix_acl;
 struct posix_acl *fuse_get_acl(struct inode *inode, int type);

commit 8cb08329b0809453722bc12aa912be34355bcb66
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Feb 21 11:18:07 2018 -0600

    fuse: Support fuse filesystems outside of init_user_ns
    
    In order to support mounts from namespaces other than init_user_ns, fuse
    must translate uids and gids to/from the userns of the process servicing
    requests on /dev/fuse. This patch does that, with a couple of restrictions
    on the namespace:
    
     - The userns for the fuse connection is fixed to the namespace
       from which /dev/fuse is opened.
    
     - The namespace must be the same as s_user_ns.
    
    These restrictions simplify the implementation by avoiding the need to pass
    around userns references and by allowing fuse to rely on the checks in
    setattr_prepare for ownership changes.  Either restriction could be relaxed
    in the future if needed.
    
    For cuse the userns used is the opener of /dev/cuse.  Semantically the cuse
    support does not appear safe for unprivileged users.  Practically the
    permissions on /dev/cuse only make it accessible to the global root user.
    If something slips through the cracks in a user namespace the only users
    who will be able to use the cuse device are those users mapped into the
    user namespace.
    
    Translation in the posix acl is updated to use the uuser namespace of the
    filesystem.  Avoiding cases which might bypass this translation is handled
    in a following change.
    
    This change is stronlgy based on a similar change from Seth Forshee and
    Dongsu Park.
    
    Cc: Seth Forshee <seth.forshee@canonical.com>
    Cc: Dongsu Park <dongsu@kinvolk.io>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 7d2e7deea64b..f630951df8dc 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -26,6 +26,7 @@
 #include <linux/xattr.h>
 #include <linux/pid_namespace.h>
 #include <linux/refcount.h>
+#include <linux/user_namespace.h>
 
 /** Max number of pages that can be used in a single read request */
 #define FUSE_MAX_PAGES_PER_REQ 32
@@ -466,6 +467,9 @@ struct fuse_conn {
 	/** The pid namespace for this mount */
 	struct pid_namespace *pid_ns;
 
+	/** The user namespace for this mount */
+	struct user_namespace *user_ns;
+
 	/** Maximum read size */
 	unsigned max_read;
 
@@ -876,7 +880,7 @@ struct fuse_conn *fuse_conn_get(struct fuse_conn *fc);
 /**
  * Initialize fuse_conn
  */
-void fuse_conn_init(struct fuse_conn *fc);
+void fuse_conn_init(struct fuse_conn *fc, struct user_namespace *user_ns);
 
 /**
  * Release reference to fuse_conn

commit 3b7008b226f3de811d4ac34238e9cf670f7c9fe7
Author: Szymon Lukasz <noh4hss@gmail.com>
Date:   Thu Nov 9 21:23:35 2017 +0100

    fuse: return -ECONNABORTED on /dev/fuse read after abort
    
    Currently the userspace has no way of knowing whether the fuse
    connection ended because of umount or abort via sysfs. It makes it hard
    for filesystems to free the mountpoint after abort without worrying
    about removing some new mount.
    
    The patch fixes it by returning different errors when userspace reads
    from /dev/fuse (-ENODEV for umount and -ECONNABORTED for abort).
    
    Add a new capability flag FUSE_ABORT_ERROR. If set and the connection is
    gone because of sysfs abort, reading from the device will return
    -ECONNABORTED.
    
    Signed-off-by: Szymon Lukasz <noh4hss@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index c4c093bbf456..7d2e7deea64b 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -515,6 +515,9 @@ struct fuse_conn {
 	    abort and device release */
 	unsigned connected;
 
+	/** Connection aborted via sysfs */
+	bool aborted;
+
 	/** Connection failed (version mismatch).  Cannot race with
 	    setting other bitfields since it is only set once in INIT
 	    reply, before any other request, and never cleared */
@@ -526,6 +529,9 @@ struct fuse_conn {
 	/** Do readpages asynchronously?  Only set in INIT */
 	unsigned async_read:1;
 
+	/** Return an unique read error after abort.  Only set in INIT */
+	unsigned abort_err:1;
+
 	/** Do not send separate SETATTR request before open(O_TRUNC)  */
 	unsigned atomic_o_trunc:1;
 
@@ -851,7 +857,7 @@ void fuse_request_send_background_locked(struct fuse_conn *fc,
 					 struct fuse_req *req);
 
 /* Abort all requests */
-void fuse_abort_conn(struct fuse_conn *fc);
+void fuse_abort_conn(struct fuse_conn *fc, bool is_abort);
 
 /**
  * Invalidate inode attributes

commit 076ccb76e1a6cf0aa5371132efdd502a11e806f1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 3 01:02:18 2017 -0400

    fs: annotate ->poll() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index d5773ca67ad2..c4c093bbf456 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -951,7 +951,7 @@ long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,
 		   unsigned int flags);
 long fuse_ioctl_common(struct file *file, unsigned int cmd,
 		       unsigned long arg, unsigned int flags);
-unsigned fuse_file_poll(struct file *file, poll_table *wait);
+__poll_t fuse_file_poll(struct file *file, poll_table *wait);
 int fuse_dev_release(struct inode *inode, struct file *file);
 
 bool fuse_write_update_size(struct inode *inode, loff_t pos);

commit 5b97eeacbd80a7bb60f2534eb43304f821e1ba06
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 12 16:57:54 2017 +0200

    fuse: getattr cleanup
    
    The refreshed argument isn't used by any caller, get rid of it.
    
    Use a helper for just updating the inode (no need to fill in a kstat).
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 610514f6aadf..d5773ca67ad2 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -904,8 +904,7 @@ u64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id);
 
 void fuse_update_ctime(struct inode *inode);
 
-int fuse_update_attributes(struct inode *inode, struct kstat *stat,
-			   struct file *file, bool *refreshed);
+int fuse_update_attributes(struct inode *inode, struct file *file);
 
 void fuse_flush_writepages(struct inode *inode);
 

commit e1c0eecba1a4154c35c400f1cc9a035e6246bbcd
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 12 16:57:53 2017 +0200

    fuse: honor iocb sync flags on write
    
    If the IOCB_DSYNC flag is set a sync is not being performed by
    fuse_file_write_iter.
    
    Honor IOCB_DSYNC/IOCB_SYNC by setting O_DYSNC/O_SYNC respectively in the
    flags filed of the write request.
    
    We don't need to sync data or metadata, since fuse_perform_write() does
    write-through and the filesystem is responsible for updating file times.
    
    Original patch by Vitaly Zolotusky.
    
    Reported-by: Nate Clark <nate@neworld.us>
    Cc: Vitaly Zolotusky <vitaly@unitc.com>.
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index bd4d2a3e1ec1..610514f6aadf 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -252,16 +252,15 @@ struct fuse_io_priv {
 	bool should_dirty;
 	int err;
 	struct kiocb *iocb;
-	struct file *file;
 	struct completion *done;
 	bool blocking;
 };
 
-#define FUSE_IO_PRIV_SYNC(f) \
+#define FUSE_IO_PRIV_SYNC(i) \
 {					\
 	.refcnt = KREF_INIT(1),		\
 	.async = 0,			\
-	.file = f,			\
+	.iocb = i,			\
 }
 
 /**

commit 61c12b49e1c9c77d7a1bcc161de540d0fd21cf0c
Author: Ashish Samant <ashish.samant@oracle.com>
Date:   Wed Jul 12 19:26:58 2017 -0700

    fuse: Dont call set_page_dirty_lock() for ITER_BVEC pages for async_dio
    
    Commit 8fba54aebbdf ("fuse: direct-io: don't dirty ITER_BVEC pages") fixes
    the ITER_BVEC page deadlock for direct io in fuse by checking in
    fuse_direct_io(), whether the page is a bvec page or not, before locking
    it.  However, this check is missed when the "async_dio" mount option is
    enabled.  In this case, set_page_dirty_lock() is called from the req->end
    callback in request_end(), when the fuse thread is returning from userspace
    to respond to the read request.  This will cause the same deadlock because
    the bvec condition is not checked in this path.
    
    Here is the stack of the deadlocked thread, while returning from userspace:
    
    [13706.656686] INFO: task glusterfs:3006 blocked for more than 120 seconds.
    [13706.657808] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables
    this message.
    [13706.658788] glusterfs       D ffffffff816c80f0     0  3006      1
    0x00000080
    [13706.658797]  ffff8800d6713a58 0000000000000086 ffff8800d9ad7000
    ffff8800d9ad5400
    [13706.658799]  ffff88011ffd5cc0 ffff8800d6710008 ffff88011fd176c0
    7fffffffffffffff
    [13706.658801]  0000000000000002 ffffffff816c80f0 ffff8800d6713a78
    ffffffff816c790e
    [13706.658803] Call Trace:
    [13706.658809]  [<ffffffff816c80f0>] ? bit_wait_io_timeout+0x80/0x80
    [13706.658811]  [<ffffffff816c790e>] schedule+0x3e/0x90
    [13706.658813]  [<ffffffff816ca7e5>] schedule_timeout+0x1b5/0x210
    [13706.658816]  [<ffffffff81073ffb>] ? gup_pud_range+0x1db/0x1f0
    [13706.658817]  [<ffffffff810668fe>] ? kvm_clock_read+0x1e/0x20
    [13706.658819]  [<ffffffff81066909>] ? kvm_clock_get_cycles+0x9/0x10
    [13706.658822]  [<ffffffff810f5792>] ? ktime_get+0x52/0xc0
    [13706.658824]  [<ffffffff816c6f04>] io_schedule_timeout+0xa4/0x110
    [13706.658826]  [<ffffffff816c8126>] bit_wait_io+0x36/0x50
    [13706.658828]  [<ffffffff816c7d06>] __wait_on_bit_lock+0x76/0xb0
    [13706.658831]  [<ffffffffa0545636>] ? lock_request+0x46/0x70 [fuse]
    [13706.658834]  [<ffffffff8118800a>] __lock_page+0xaa/0xb0
    [13706.658836]  [<ffffffff810c8500>] ? wake_atomic_t_function+0x40/0x40
    [13706.658838]  [<ffffffff81194d08>] set_page_dirty_lock+0x58/0x60
    [13706.658841]  [<ffffffffa054d968>] fuse_release_user_pages+0x58/0x70 [fuse]
    [13706.658844]  [<ffffffffa0551430>] ? fuse_aio_complete+0x190/0x190 [fuse]
    [13706.658847]  [<ffffffffa0551459>] fuse_aio_complete_req+0x29/0x90 [fuse]
    [13706.658849]  [<ffffffffa05471e9>] request_end+0xd9/0x190 [fuse]
    [13706.658852]  [<ffffffffa0549126>] fuse_dev_do_write+0x336/0x490 [fuse]
    [13706.658854]  [<ffffffffa054963e>] fuse_dev_write+0x6e/0xa0 [fuse]
    [13706.658857]  [<ffffffff812a9ef3>] ? security_file_permission+0x23/0x90
    [13706.658859]  [<ffffffff81205300>] do_iter_readv_writev+0x60/0x90
    [13706.658862]  [<ffffffffa05495d0>] ? fuse_dev_splice_write+0x350/0x350
    [fuse]
    [13706.658863]  [<ffffffff812062a1>] do_readv_writev+0x171/0x1f0
    [13706.658866]  [<ffffffff810b3d00>] ? try_to_wake_up+0x210/0x210
    [13706.658868]  [<ffffffff81206361>] vfs_writev+0x41/0x50
    [13706.658870]  [<ffffffff81206496>] SyS_writev+0x56/0xf0
    [13706.658872]  [<ffffffff810257a1>] ? syscall_trace_leave+0xf1/0x160
    [13706.658874]  [<ffffffff816cbb2e>] system_call_fastpath+0x12/0x71
    
    Fix this by making should_dirty a fuse_io_priv parameter that can be
    checked in fuse_aio_complete_req().
    
    Reported-by: Tiger Yang <tiger.yang@oracle.com>
    Signed-off-by: Ashish Samant <ashish.samant@oracle.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 1bd7ffdad593..bd4d2a3e1ec1 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -249,6 +249,7 @@ struct fuse_io_priv {
 	size_t size;
 	__u64 offset;
 	bool write;
+	bool should_dirty;
 	int err;
 	struct kiocb *iocb;
 	struct file *file;

commit a2e5ad45a9741068f357de4dbff50bb37c233e1b
Merge: 26c5eaa1326e 0b6e9ea041e6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 10 08:45:30 2017 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/fuse
    
    Pull fuse updates from Miklos Szeredi:
     "Support for pid namespaces from Seth and refcount_t work from Elena"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/fuse:
      fuse: Add support for pid namespaces
      fuse: convert fuse_conn.count from atomic_t to refcount_t
      fuse: convert fuse_req.count from atomic_t to refcount_t
      fuse: convert fuse_file.count from atomic_t to refcount_t

commit 7fbbe972c3ec63a3391997e0cef09964f9236088
Author: Jan Kara <jack@suse.cz>
Date:   Wed Apr 12 12:24:41 2017 +0200

    fuse: Get rid of bdi_initialized
    
    It is not needed anymore since bdi is initialized whenever superblock
    exists.
    
    CC: Miklos Szeredi <miklos@szeredi.hu>
    CC: linux-fsdevel@vger.kernel.org
    Suggested-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 0e7c79a390e0..f33341d9501a 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -527,9 +527,6 @@ struct fuse_conn {
 	/** Filesystem supports NFS exporting.  Only set in INIT */
 	unsigned export_support:1;
 
-	/** Set if bdi is valid */
-	unsigned bdi_initialized:1;
-
 	/** write-back cache policy (default is write-through) */
 	unsigned writeback_cache:1;
 

commit 5f7f7543f52eee03ed35c9d671fbb1cdbd4bc9b5
Author: Jan Kara <jack@suse.cz>
Date:   Wed Apr 12 12:24:40 2017 +0200

    fuse: Convert to separately allocated bdi
    
    Allocate struct backing_dev_info separately instead of embedding it
    inside the superblock. This unifies handling of bdi among users.
    
    CC: Miklos Szeredi <miklos@szeredi.hu>
    CC: linux-fsdevel@vger.kernel.org
    Acked-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 32ac2c9b09c0..0e7c79a390e0 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -631,9 +631,6 @@ struct fuse_conn {
 	/** Negotiated minor version */
 	unsigned minor;
 
-	/** Backing dev info */
-	struct backing_dev_info bdi;
-
 	/** Entry on the fuse_conn_list */
 	struct list_head entry;
 

commit 0b6e9ea041e6c932f5b3a86fae2d60cbcfad4dd2
Author: Seth Forshee <seth.forshee@canonical.com>
Date:   Wed Jul 2 16:29:19 2014 -0500

    fuse: Add support for pid namespaces
    
    When the userspace process servicing fuse requests is running in
    a pid namespace then pids passed via the fuse fd are not being
    translated into that process' namespace. Translation is necessary
    for the pid to be useful to that process.
    
    Since no use case currently exists for changing namespaces all
    translations can be done relative to the pid namespace in use
    when fuse_conn_init() is called. For fuse this translates to
    mount time, and for cuse this is when /dev/cuse is opened. IO for
    this connection from another namespace will return errors.
    
    Requests from processes whose pid cannot be translated into the
    target namespace will have a value of 0 for in.h.pid.
    
    File locking changes based on previous work done by Eric
    Biederman.
    
    Signed-off-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 6c649f0c58f9..041521d29d33 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -24,6 +24,7 @@
 #include <linux/workqueue.h>
 #include <linux/kref.h>
 #include <linux/xattr.h>
+#include <linux/pid_namespace.h>
 #include <linux/refcount.h>
 
 /** Max number of pages that can be used in a single read request */
@@ -462,6 +463,9 @@ struct fuse_conn {
 	/** The group id for this mount */
 	kgid_t group_id;
 
+	/** The pid namespace for this mount */
+	struct pid_namespace *pid_ns;
+
 	/** Maximum read size */
 	unsigned max_read;
 

commit 095fc40ace5ffccd306f39fdd1a40b4faa41b8a0
Author: Elena Reshetova <elena.reshetova@intel.com>
Date:   Fri Mar 3 11:04:05 2017 +0200

    fuse: convert fuse_conn.count from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 9d4374032290..6c649f0c58f9 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -449,7 +449,7 @@ struct fuse_conn {
 	spinlock_t lock;
 
 	/** Refcount */
-	atomic_t count;
+	refcount_t count;
 
 	/** Number of fuse_dev's */
 	atomic_t dev_count;

commit ec99f6d31f2590a4c0ff2dae8fb1fa27f0647a42
Author: Elena Reshetova <elena.reshetova@intel.com>
Date:   Fri Mar 3 11:04:04 2017 +0200

    fuse: convert fuse_req.count from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 1d6d67e64f49..9d4374032290 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -307,7 +307,7 @@ struct fuse_req {
 	struct list_head intr_entry;
 
 	/** refcount */
-	atomic_t count;
+	refcount_t count;
 
 	/** Unique ID for the interrupt request */
 	u64 intr_unique;

commit 4e8c2eb54327a6f8b0ef6d6afb28ab24b721dbe0
Author: Elena Reshetova <elena.reshetova@intel.com>
Date:   Fri Mar 3 11:04:03 2017 +0200

    fuse: convert fuse_file.count from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 32ac2c9b09c0..1d6d67e64f49 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -24,6 +24,7 @@
 #include <linux/workqueue.h>
 #include <linux/kref.h>
 #include <linux/xattr.h>
+#include <linux/refcount.h>
 
 /** Max number of pages that can be used in a single read request */
 #define FUSE_MAX_PAGES_PER_REQ 32
@@ -137,7 +138,7 @@ struct fuse_file {
 	u64 nodeid;
 
 	/** Refcount */
-	atomic_t count;
+	refcount_t count;
 
 	/** FOPEN_* flags returned by open */
 	u32 open_flags;

commit 4e66c42c60fdf9be81837857454a41b39bf1b773
Merge: e58bc927835a 9a87ad3da905
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 3 12:14:13 2017 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/fuse
    
    Pull fuse update from Miklos Szeredi:
     "A bugfix and cleanups"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/fuse:
      fuse: release: private_data cannot be NULL
      fuse: cleanup fuse_file refcounting
      fuse: add missing FR_FORCE

commit 267d84449f52349ee252db684ed95ede18e51744
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Feb 22 20:08:25 2017 +0100

    fuse: cleanup fuse_file refcounting
    
    struct fuse_file is stored in file->private_data.  Make this always be a
    counting reference for consistency.
    
    This also allows fuse_sync_release() to call fuse_file_put() instead of
    partially duplicating its functionality.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 91307940c8ac..83f797271aef 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -732,7 +732,6 @@ void fuse_read_fill(struct fuse_req *req, struct file *file,
 int fuse_open_common(struct inode *inode, struct file *file, bool isdir);
 
 struct fuse_file *fuse_file_alloc(struct fuse_conn *fc);
-struct fuse_file *fuse_file_get(struct fuse_file *ff);
 void fuse_file_free(struct fuse_file *ff);
 void fuse_finish_open(struct inode *inode, struct file *file);
 

commit 1e24edca0557dba6486d39d3c24c288475432bcf
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Nov 14 17:12:23 2016 +0100

    locking/atomic, kref: Add KREF_INIT()
    
    Since we need to change the implementation, stop exposing internals.
    
    Provide KREF_INIT() to allow static initialization of struct kref.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 91307940c8ac..052f8d3c41cb 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -256,7 +256,7 @@ struct fuse_io_priv {
 
 #define FUSE_IO_PRIV_SYNC(f) \
 {					\
-	.refcnt = { ATOMIC_INIT(1) },	\
+	.refcnt = KREF_INIT(1),		\
 	.async = 0,			\
 	.file = f,			\
 }

commit 0ce267ff95a0302cf6fb2a552833abbfb7861a43
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Oct 18 15:36:48 2016 +0200

    fuse: fix root dentry initialization
    
    Add missing dentry initialization to root dentry.
    
    Fixes: f75fdf22b0a8 ("fuse: don't use ->d_time")
    Reported-by: Andreas Reis <andreas.reis@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 0dfbb136e59a..91307940c8ac 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -692,6 +692,7 @@ static inline u64 get_node_id(struct inode *inode)
 extern const struct file_operations fuse_dev_operations;
 
 extern const struct dentry_operations fuse_dentry_operations;
+extern const struct dentry_operations fuse_root_dentry_operations;
 
 /**
  * Inode to nodeid comparison.

commit abb5a14fa20fdd400995926134b7be9eb8ce6048
Merge: 911f9dab301e e55f1d1d13e7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 13:04:49 2016 -0700

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "Assorted misc bits and pieces.
    
      There are several single-topic branches left after this (rename2
      series from Miklos, current_time series from Deepa Dinamani, xattr
      series from Andreas, uaccess stuff from from me) and I'd prefer to
      send those separately"
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (39 commits)
      proc: switch auxv to use of __mem_open()
      hpfs: support FIEMAP
      cifs: get rid of unused arguments of CIFSSMBWrite()
      posix_acl: uapi header split
      posix_acl: xattr representation cleanups
      fs/aio.c: eliminate redundant loads in put_aio_ring_file
      fs/internal.h: add const to ns_dentry_operations declaration
      compat: remove compat_printk()
      fs/buffer.c: make __getblk_slow() static
      proc: unsigned file descriptors
      fs/file: more unsigned file descriptors
      fs: compat: remove redundant check of nr_segs
      cachefiles: Fix attempt to read i_blocks after deleting file [ver #2]
      cifs: don't use memcpy() to copy struct iov_iter
      get rid of separate multipage fault-in primitives
      fs: Avoid premature clearing of capabilities
      fs: Give dentry to inode_change_ok() instead of inode
      fuse: Propagate dentry down to inode_change_ok()
      ceph: Propagate dentry down to inode_change_ok()
      xfs: Propagate dentry down to inode_change_ok()
      ...

commit 29433a2991fa636c1fcd5bf5893cf92c37e0b26c
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Sat Oct 1 07:32:32 2016 +0200

    fuse: get rid of fc->flags
    
    Only two flags: "default_permissions" and "allow_other".  All other flags
    are handled via bitfields.  So convert these two as well.  They don't
    change during the lifetime of the filesystem, so this is quite safe.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index e8d96ec22533..24ada5dc4dae 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -37,15 +37,6 @@
 /** Number of dentries for each connection in the control filesystem */
 #define FUSE_CTL_NUM_DENTRIES 5
 
-/** If the FUSE_DEFAULT_PERMISSIONS flag is given, the filesystem
-    module will check permissions based on the file mode.  Otherwise no
-    permission checking is done in the kernel */
-#define FUSE_DEFAULT_PERMISSIONS (1 << 0)
-
-/** If the FUSE_ALLOW_OTHER flag is given, then not only the user
-    doing the mount will be allowed to access the filesystem */
-#define FUSE_ALLOW_OTHER         (1 << 1)
-
 /** Number of page pointers embedded in fuse_req */
 #define FUSE_REQ_INLINE_PAGES 1
 
@@ -470,9 +461,6 @@ struct fuse_conn {
 	/** The group id for this mount */
 	kgid_t group_id;
 
-	/** The fuse mount flags for this mount */
-	unsigned flags;
-
 	/** Maximum read size */
 	unsigned max_read;
 
@@ -631,6 +619,12 @@ struct fuse_conn {
 	/** Does the filesystem support posix acls? */
 	unsigned posix_acl:1;
 
+	/** Check permissions based on the file mode or not? */
+	unsigned default_permissions:1;
+
+	/** Allow other than the mounter user to access the filesystem ? */
+	unsigned allow_other:1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 

commit 60bcc88ad185d512f5718f2f8dcccb483ea8fb73
Author: Seth Forshee <seth.forshee@canonical.com>
Date:   Mon Aug 29 08:46:37 2016 -0500

    fuse: Add posix ACL support
    
    Add a new INIT flag, FUSE_POSIX_ACL, for negotiating ACL support with
    userspace.  When it is set in the INIT response, ACL support will be
    enabled.  ACL support also implies "default_permissions".
    
    When ACL support is enabled, the kernel will cache and have responsibility
    for enforcing ACLs.  ACL xattrs will be passed to userspace, which is
    responsible for updating the ACLs in the filesystem, keeping the file mode
    in sync, and inheritance of default ACLs when new filesystem nodes are
    created.
    
    Signed-off-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 9940a648c985..e8d96ec22533 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -23,6 +23,7 @@
 #include <linux/poll.h>
 #include <linux/workqueue.h>
 #include <linux/kref.h>
+#include <linux/xattr.h>
 
 /** Max number of pages that can be used in a single read request */
 #define FUSE_MAX_PAGES_PER_REQ 32
@@ -627,6 +628,9 @@ struct fuse_conn {
 	/** Is lseek not implemented by fs? */
 	unsigned no_lseek:1;
 
+	/** Does the filesystem support posix acls? */
+	unsigned posix_acl:1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 
@@ -971,7 +975,17 @@ void fuse_set_initialized(struct fuse_conn *fc);
 void fuse_unlock_inode(struct inode *inode);
 void fuse_lock_inode(struct inode *inode);
 
+int fuse_setxattr(struct inode *inode, const char *name, const void *value,
+		  size_t size, int flags);
+ssize_t fuse_getxattr(struct inode *inode, const char *name, void *value,
+		      size_t size);
 ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size);
+int fuse_removexattr(struct inode *inode, const char *name);
 extern const struct xattr_handler *fuse_xattr_handlers[];
+extern const struct xattr_handler *fuse_acl_xattr_handlers[];
+
+struct posix_acl;
+struct posix_acl *fuse_get_acl(struct inode *inode, int type);
+int fuse_set_acl(struct inode *inode, struct posix_acl *acl, int type);
 
 #endif /* _FS_FUSE_I_H */

commit 5e940c1dd3c1f7561924954eecee956ec277a79b
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Sat Oct 1 07:32:32 2016 +0200

    fuse: handle killpriv in userspace fs
    
    Only userspace filesystem can do the killing of suid/sgid without races.
    So introduce an INIT flag and negotiate support for this.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 6db54d0bd81b..9940a648c985 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -547,6 +547,9 @@ struct fuse_conn {
 	/** allow parallel lookups and readdir (default is serialized) */
 	unsigned parallel_dirops:1;
 
+	/** handle fs handles killing suid/sgid/cap on write/chown/trunc */
+	unsigned handle_killpriv:1;
+
 	/*
 	 * The following bitfields are only for optimization purposes
 	 * and hence races in setting them will not cause malfunction

commit 703c73629f93464ce210f5ad92d0c1fb95bfbadf
Author: Seth Forshee <seth.forshee@canonical.com>
Date:   Mon Aug 29 08:46:36 2016 -0500

    fuse: Use generic xattr ops
    
    In preparation for posix acl support, rework fuse to use xattr handlers and
    the generic setxattr/getxattr/listxattr callbacks.  Split the xattr code
    out into it's own file, and promote symbols to module-global scope as
    needed.
    
    Functionally these changes have no impact, as fuse still uses a single
    handler for all xattrs which uses the old callbacks.
    
    Signed-off-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index d98d8cc84def..6db54d0bd81b 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -902,6 +902,8 @@ int fuse_allow_current_process(struct fuse_conn *fc);
 
 u64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id);
 
+void fuse_update_ctime(struct inode *inode);
+
 int fuse_update_attributes(struct inode *inode, struct kstat *stat,
 			   struct file *file, bool *refreshed);
 
@@ -966,4 +968,7 @@ void fuse_set_initialized(struct fuse_conn *fc);
 void fuse_unlock_inode(struct inode *inode);
 void fuse_lock_inode(struct inode *inode);
 
+ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size);
+extern const struct xattr_handler *fuse_xattr_handlers[];
+
 #endif /* _FS_FUSE_I_H */

commit 62490330769c1ce5dcba3f1f3e8f4005e9b797e6
Author: Jan Kara <jack@suse.cz>
Date:   Thu May 26 17:12:41 2016 +0200

    fuse: Propagate dentry down to inode_change_ok()
    
    To avoid clearing of capabilities or security related extended
    attributes too early, inode_change_ok() will need to take dentry instead
    of inode. Propagate it down to fuse_do_setattr().
    
    Acked-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index d98d8cc84def..cace5526c6d6 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -958,7 +958,7 @@ bool fuse_write_update_size(struct inode *inode, loff_t pos);
 int fuse_flush_times(struct inode *inode, struct fuse_file *ff);
 int fuse_write_inode(struct inode *inode, struct writeback_control *wbc);
 
-int fuse_do_setattr(struct inode *inode, struct iattr *attr,
+int fuse_do_setattr(struct dentry *dentry, struct iattr *attr,
 		    struct file *file);
 
 void fuse_set_initialized(struct fuse_conn *fc);

commit 835c92d43b29eb354abdbd5475308a474d7efdfa
Merge: ce804bf598b5 19a6d89de2f1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 6 09:49:02 2016 -0400

    Merge branch 'work.const-qstr' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull qstr constification updates from Al Viro:
     "Fairly self-contained bunch - surprising lot of places passes struct
      qstr * as an argument when const struct qstr * would suffice; it
      complicates analysis for no good reason.
    
      I'd prefer to feed that separately from the assorted fixes (those are
      in #for-linus and with somewhat trickier topology)"
    
    * 'work.const-qstr' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      qstr: constify instances in adfs
      qstr: constify instances in lustre
      qstr: constify instances in f2fs
      qstr: constify instances in ext2
      qstr: constify instances in vfat
      qstr: constify instances in procfs
      qstr: constify instances in fuse
      qstr constify instances in fs/dcache.c
      qstr: constify instances in nfs
      qstr: constify instances in ocfs2
      qstr: constify instances in autofs4
      qstr: constify instances in hfs
      qstr: constify instances in hfsplus
      qstr: constify instances in logfs
      qstr: constify dentry_init_security

commit 13983d062f17fb69f249befeba81b5ca253ad641
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jul 20 22:34:44 2016 -0400

    qstr: constify instances in fuse
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 929c383432b0..9e42c0394196 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -703,7 +703,7 @@ struct inode *fuse_iget(struct super_block *sb, u64 nodeid,
 			int generation, struct fuse_attr *attr,
 			u64 attr_valid, u64 attr_version);
 
-int fuse_lookup_name(struct super_block *sb, u64 nodeid, struct qstr *name,
+int fuse_lookup_name(struct super_block *sb, u64 nodeid, const struct qstr *name,
 		     struct fuse_entry_out *outarg, struct inode **inode);
 
 /**

commit 7879c4e58b7c884ee62b9306721dd1106e624b52
Author: Ashish Sangwan <ashishsangwan2@gmail.com>
Date:   Thu Apr 7 17:18:11 2016 +0530

    fuse: improve aio directIO write performance for size extending writes
    
    While sending the blocking directIO in fuse, the write request is broken
    into sub-requests, each of default size 128k and all the requests are sent
    in non-blocking background mode if async_dio mode is supported by libfuse.
    The process which issue the write wait for the completion of all the
    sub-requests. Sending multiple requests parallely gives a chance to perform
    parallel writes in the user space fuse implementation if it is
    multi-threaded and hence improves the performance.
    
    When there is a size extending aio dio write, we switch to blocking mode so
    that we can properly update the size of the file after completion of the
    writes. However, in this situation all the sub-requests are sent in
    serialized manner where the next request is sent only after receiving the
    reply of the current request. Hence the multi-threaded user space
    implementation is not utilized properly.
    
    This patch changes the size extending aio dio behavior to exactly follow
    blocking dio. For multi threaded fuse implementation having 10 threads and
    using buffer size of 64MB to perform async directIO, we are getting double
    the speed.
    
    Signed-off-by: Ashish Sangwan <ashishsangwan2@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 929c383432b0..5db5d24f91a5 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -259,6 +259,7 @@ struct fuse_io_priv {
 	struct kiocb *iocb;
 	struct file *file;
 	struct completion *done;
+	bool blocking;
 };
 
 #define FUSE_IO_PRIV_SYNC(f) \

commit 5c672ab3f0ee0f78f7acad183f34db0f8781a200
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Jun 30 13:10:49 2016 +0200

    fuse: serialize dirops by default
    
    Negotiate with userspace filesystems whether they support parallel readdir
    and lookup.  Disable parallelism by default for fear of breaking fuse
    filesystems.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Fixes: 9902af79c01a ("parallel lookups: actual switch to rwsem")
    Fixes: d9b3dbdcfd62 ("fuse: switch to ->iterate_shared()")

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index eddbe02c4028..929c383432b0 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -110,6 +110,9 @@ struct fuse_inode {
 
 	/** Miscellaneous bits describing inode state */
 	unsigned long state;
+
+	/** Lock for serializing lookup and readdir for back compatibility*/
+	struct mutex mutex;
 };
 
 /** FUSE inode state bits */
@@ -540,6 +543,9 @@ struct fuse_conn {
 	/** write-back cache policy (default is write-through) */
 	unsigned writeback_cache:1;
 
+	/** allow parallel lookups and readdir (default is serialized) */
+	unsigned parallel_dirops:1;
+
 	/*
 	 * The following bitfields are only for optimization purposes
 	 * and hence races in setting them will not cause malfunction
@@ -956,4 +962,7 @@ int fuse_do_setattr(struct inode *inode, struct iattr *attr,
 
 void fuse_set_initialized(struct fuse_conn *fc);
 
+void fuse_unlock_inode(struct inode *inode);
+void fuse_lock_inode(struct inode *inode);
+
 #endif /* _FS_FUSE_I_H */

commit 744742d692e37ad5c20630e57d526c8f2e2fe3c9
Author: Seth Forshee <seth.forshee@canonical.com>
Date:   Fri Mar 11 10:35:34 2016 -0600

    fuse: Add reference counting for fuse_io_priv
    
    The 'reqs' member of fuse_io_priv serves two purposes. First is to track
    the number of oustanding async requests to the server and to signal that
    the io request is completed. The second is to be a reference count on the
    structure to know when it can be freed.
    
    For sync io requests these purposes can be at odds.  fuse_direct_IO() wants
    to block until the request is done, and since the signal is sent when
    'reqs' reaches 0 it cannot keep a reference to the object. Yet it needs to
    use the object after the userspace server has completed processing
    requests. This leads to some handshaking and special casing that it
    needlessly complicated and responsible for at least one race condition.
    
    It's much cleaner and safer to maintain a separate reference count for the
    object lifecycle and to let 'reqs' just be a count of outstanding requests
    to the userspace server. Then we can know for sure when it is safe to free
    the object without any handshaking or special cases.
    
    The catch here is that most of the time these objects are stack allocated
    and should not be freed. Initializing these objects with a single reference
    that is never released prevents accidental attempts to free the objects.
    
    Fixes: 9d5722b7777e ("fuse: handle synchronous iocbs internally")
    Cc: stable@vger.kernel.org # v4.1+
    Signed-off-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index ce394b5fe6b4..eddbe02c4028 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -22,6 +22,7 @@
 #include <linux/rbtree.h>
 #include <linux/poll.h>
 #include <linux/workqueue.h>
+#include <linux/kref.h>
 
 /** Max number of pages that can be used in a single read request */
 #define FUSE_MAX_PAGES_PER_REQ 32
@@ -243,6 +244,7 @@ struct fuse_args {
 
 /** The request IO state (for asynchronous processing) */
 struct fuse_io_priv {
+	struct kref refcnt;
 	int async;
 	spinlock_t lock;
 	unsigned reqs;
@@ -256,6 +258,13 @@ struct fuse_io_priv {
 	struct completion *done;
 };
 
+#define FUSE_IO_PRIV_SYNC(f) \
+{					\
+	.refcnt = { ATOMIC_INIT(1) },	\
+	.async = 0,			\
+	.file = f,			\
+}
+
 /**
  * Request flags
  *

commit 0b5da8db145bfd44266ac964a2636a0cf8d7c286
Author: Ravishankar N <ravishankar@redhat.com>
Date:   Tue Jun 30 23:40:22 2015 +0530

    fuse: add support for SEEK_HOLE and SEEK_DATA in lseek
    
    A useful performance improvement for accessing virtual machine images
    via FUSE mount.
    
    See https://bugzilla.redhat.com/show_bug.cgi?id=1220173 for a use-case
    for glusterFS.
    
    Signed-off-by: Ravishankar N <ravishankar@redhat.com>
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 405113101db8..ce394b5fe6b4 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -605,6 +605,9 @@ struct fuse_conn {
 	/** Does the filesystem support asynchronous direct-IO submission? */
 	unsigned async_dio:1;
 
+	/** Is lseek not implemented by fs? */
+	unsigned no_lseek:1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 

commit c3696046beb3a4479715b48f67f6a8a3aef4b3bb
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Jul 1 16:26:09 2015 +0200

    fuse: separate pqueue for clones
    
    Make each fuse device clone refer to a separate processing queue.  The only
    constraint on userspace code is that the request answer must be written to
    the same device clone as it was read off.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 42d59cbd47e7..405113101db8 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -424,6 +424,9 @@ struct fuse_dev {
 	/** Fuse connection for this device */
 	struct fuse_conn *fc;
 
+	/** Processing queue */
+	struct fuse_pqueue pq;
+
 	/** list entry on fc->devices */
 	struct list_head entry;
 };
@@ -442,6 +445,9 @@ struct fuse_conn {
 	/** Refcount */
 	atomic_t count;
 
+	/** Number of fuse_dev's */
+	atomic_t dev_count;
+
 	struct rcu_head rcu;
 
 	/** The user id for this mount */
@@ -462,9 +468,6 @@ struct fuse_conn {
 	/** Input queue */
 	struct fuse_iqueue iq;
 
-	/** Processing queue */
-	struct fuse_pqueue pq;
-
 	/** The next unique kernel file handle */
 	u64 khctr;
 

commit cc080e9e9be16ccf26135d366d7d2b65209f1d56
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Jul 1 16:26:08 2015 +0200

    fuse: introduce per-instance fuse_dev structure
    
    Allow fuse device clones to refer to be distinguished.  This patch just
    adds the infrastructure by associating a separate "struct fuse_dev" with
    each clone.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Reviewed-by: Ashish Samant <ashish.samant@oracle.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index a9507fd97d5e..42d59cbd47e7 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -417,6 +417,17 @@ struct fuse_pqueue {
 	struct list_head io;
 };
 
+/**
+ * Fuse device instance
+ */
+struct fuse_dev {
+	/** Fuse connection for this device */
+	struct fuse_conn *fc;
+
+	/** list entry on fc->devices */
+	struct list_head entry;
+};
+
 /**
  * A Fuse connection.
  *
@@ -629,6 +640,9 @@ struct fuse_conn {
 
 	/** Read/write semaphore to hold when accessing sb. */
 	struct rw_semaphore killsb;
+
+	/** List of device instances belonging to this connection */
+	struct list_head devices;
 };
 
 static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)
@@ -841,6 +855,9 @@ void fuse_conn_init(struct fuse_conn *fc);
  */
 void fuse_conn_put(struct fuse_conn *fc);
 
+struct fuse_dev *fuse_dev_alloc(struct fuse_conn *fc);
+void fuse_dev_free(struct fuse_dev *fud);
+
 /**
  * Add connection to control filesystem
  */

commit 77cd9d488b32d19be852ad4d310ef13701557d61
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Jul 1 16:26:06 2015 +0200

    fuse: add req flag for private list
    
    When an unlocked request is aborted, it is moved from fpq->io to a private
    list.  Then, after unlocking fpq->lock, the private list is processed and
    the requests are finished off.
    
    To protect the private list, we need to mark the request with a flag, so if
    in the meantime the request is unlocked the list is not corrupted.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Reviewed-by: Ashish Samant <ashish.samant@oracle.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index ad3799e57efd..a9507fd97d5e 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -269,6 +269,7 @@ struct fuse_io_priv {
  * FR_PENDING:		request is not yet in userspace
  * FR_SENT:		request is in userspace, waiting for an answer
  * FR_FINISHED:		request is finished
+ * FR_PRIVATE:		request is on private list
  */
 enum fuse_req_flag {
 	FR_ISREPLY,
@@ -281,6 +282,7 @@ enum fuse_req_flag {
 	FR_PENDING,
 	FR_SENT,
 	FR_FINISHED,
+	FR_PRIVATE,
 };
 
 /**

commit 45a91cb1a4fd9bb0e53c95e3dc9185dd5b5ba245
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Jul 1 16:26:06 2015 +0200

    fuse: pqueue locking
    
    Add a fpq->lock for protecting members of struct fuse_pqueue and FR_LOCKED
    request flag.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Reviewed-by: Ashish Samant <ashish.samant@oracle.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 5897d89ea2ba..ad3799e57efd 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -405,6 +405,9 @@ struct fuse_pqueue {
 	/** Connection established */
 	unsigned connected;
 
+	/** Lock protecting accessess to  members of this structure */
+	spinlock_t lock;
+
 	/** The list of requests being processed */
 	struct list_head processing;
 

commit e96edd94d0887707fc41c5d21d5b488edcd31689
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Jul 1 16:26:04 2015 +0200

    fuse: duplicate ->connected in pqueue
    
    This will allow checking ->connected just with the processing queue lock.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Reviewed-by: Ashish Samant <ashish.samant@oracle.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 3620eec018a4..5897d89ea2ba 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -402,6 +402,9 @@ struct fuse_iqueue {
 };
 
 struct fuse_pqueue {
+	/** Connection established */
+	unsigned connected;
+
 	/** The list of requests being processed */
 	struct list_head processing;
 

commit 3a2b5b9cd9610f789f5e5f91a010d9fa3ca78632
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Jul 1 16:26:04 2015 +0200

    fuse: separate out processing queue
    
    This is just two fields: fc->io and fc->processing.
    
    This patch just rearranges the fields, no functional change.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Reviewed-by: Ashish Samant <ashish.samant@oracle.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index e8be4611fb8e..3620eec018a4 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -401,6 +401,14 @@ struct fuse_iqueue {
 	struct fasync_struct *fasync;
 };
 
+struct fuse_pqueue {
+	/** The list of requests being processed */
+	struct list_head processing;
+
+	/** The list of requests under I/O */
+	struct list_head io;
+};
+
 /**
  * A Fuse connection.
  *
@@ -435,11 +443,8 @@ struct fuse_conn {
 	/** Input queue */
 	struct fuse_iqueue iq;
 
-	/** The list of requests being processed */
-	struct list_head processing;
-
-	/** The list of requests under I/O */
-	struct list_head io;
+	/** Processing queue */
+	struct fuse_pqueue pq;
 
 	/** The next unique kernel file handle */
 	u64 khctr;

commit e16714d8756dc1237a66994e139b61feebcf707a
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Jul 1 16:26:01 2015 +0200

    fuse: duplicate ->connected in iqueue
    
    This will allow checking ->connected just with the input queue lock.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Reviewed-by: Ashish Samant <ashish.samant@oracle.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 3d075417042a..e8be4611fb8e 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -375,6 +375,9 @@ struct fuse_req {
 };
 
 struct fuse_iqueue {
+	/** Connection established */
+	unsigned connected;
+
 	/** Readers of the connection are waiting on this */
 	wait_queue_head_t waitq;
 

commit f88996a93324483ff3ec027312bbacacf97a555b
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Jul 1 16:26:01 2015 +0200

    fuse: separate out input queue
    
    The input queue contains normal requests (fc->pending), forgets
    (fc->forget_*) and interrupts (fc->interrupts).  There's also fc->waitq and
    fc->fasync for waking up the readers of the fuse device when a request is
    available.
    
    The fc->reqctr is also moved to the input queue (assigned to the request
    when the request is added to the input queue.
    
    This patch just rearranges the fields, no functional change.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Reviewed-by: Ashish Samant <ashish.samant@oracle.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 8eaf3b0de033..3d075417042a 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -374,6 +374,30 @@ struct fuse_req {
 	struct file *stolen_file;
 };
 
+struct fuse_iqueue {
+	/** Readers of the connection are waiting on this */
+	wait_queue_head_t waitq;
+
+	/** The next unique request id */
+	u64 reqctr;
+
+	/** The list of pending requests */
+	struct list_head pending;
+
+	/** Pending interrupts */
+	struct list_head interrupts;
+
+	/** Queue of pending forgets */
+	struct fuse_forget_link forget_list_head;
+	struct fuse_forget_link *forget_list_tail;
+
+	/** Batching of FORGET requests (positive indicates FORGET batch) */
+	int forget_batch;
+
+	/** O_ASYNC requests */
+	struct fasync_struct *fasync;
+};
+
 /**
  * A Fuse connection.
  *
@@ -405,11 +429,8 @@ struct fuse_conn {
 	/** Maximum write size */
 	unsigned max_write;
 
-	/** Readers of the connection are waiting on this */
-	wait_queue_head_t waitq;
-
-	/** The list of pending requests */
-	struct list_head pending;
+	/** Input queue */
+	struct fuse_iqueue iq;
 
 	/** The list of requests being processed */
 	struct list_head processing;
@@ -438,16 +459,6 @@ struct fuse_conn {
 	/** The list of background requests set aside for later queuing */
 	struct list_head bg_queue;
 
-	/** Pending interrupts */
-	struct list_head interrupts;
-
-	/** Queue of pending forgets */
-	struct fuse_forget_link forget_list_head;
-	struct fuse_forget_link *forget_list_tail;
-
-	/** Batching of FORGET requests (positive indicates FORGET batch) */
-	int forget_batch;
-
 	/** Flag indicating that INIT reply has been received. Allocating
 	 * any fuse request will be suspended until the flag is set */
 	int initialized;
@@ -463,9 +474,6 @@ struct fuse_conn {
 	/** waitq for reserved requests */
 	wait_queue_head_t reserved_req_waitq;
 
-	/** The next unique request id */
-	u64 reqctr;
-
 	/** Connection established, cleared on umount, connection
 	    abort and device release */
 	unsigned connected;
@@ -588,9 +596,6 @@ struct fuse_conn {
 	/** number of dentries used in the above array */
 	int ctl_ndents;
 
-	/** O_ASYNC requests */
-	struct fasync_struct *fasync;
-
 	/** Key for lock owner ID scrambling */
 	u32 scramble_key[4];
 

commit 33e14b4dfdc477344efbcd9b4218f2b350f0f893
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Jul 1 16:26:01 2015 +0200

    fuse: req state use flags
    
    Use flags for representing the state in fuse_req.  This is needed since
    req->list will be protected by different locks in different states, hence
    we'll want the state itself to be split into distinct bits, each protected
    with the relevant lock in that state.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 3fd65f613515..8eaf3b0de033 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -241,14 +241,6 @@ struct fuse_args {
 
 #define FUSE_ARGS(args) struct fuse_args args = {}
 
-/** The request state */
-enum fuse_req_state {
-	FUSE_REQ_PENDING = 0,
-	FUSE_REQ_IO,
-	FUSE_REQ_SENT,
-	FUSE_REQ_FINISHED
-};
-
 /** The request IO state (for asynchronous processing) */
 struct fuse_io_priv {
 	int async;
@@ -274,6 +266,9 @@ struct fuse_io_priv {
  * FR_ABORTED:		the request was aborted
  * FR_INTERRUPTED:	the request has been interrupted
  * FR_LOCKED:		data is being copied to/from the request
+ * FR_PENDING:		request is not yet in userspace
+ * FR_SENT:		request is in userspace, waiting for an answer
+ * FR_FINISHED:		request is finished
  */
 enum fuse_req_flag {
 	FR_ISREPLY,
@@ -283,6 +278,9 @@ enum fuse_req_flag {
 	FR_ABORTED,
 	FR_INTERRUPTED,
 	FR_LOCKED,
+	FR_PENDING,
+	FR_SENT,
+	FR_FINISHED,
 };
 
 /**
@@ -309,9 +307,6 @@ struct fuse_req {
 	/* Request flags, updated with test/set/clear_bit() */
 	unsigned long flags;
 
-	/** State of the request */
-	enum fuse_req_state state;
-
 	/** The request input */
 	struct fuse_in in;
 

commit 7a3b2c754749c73b4a255b2a1070c24dba589098
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Jul 1 16:26:00 2015 +0200

    fuse: simplify req states
    
    FUSE_REQ_INIT is actually the same state as FUSE_REQ_PENDING and
    FUSE_REQ_READING and FUSE_REQ_WRITING can be merged into a common
    FUSE_REQ_IO state.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Reviewed-by: Ashish Samant <ashish.samant@oracle.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 7257adba7ecd..3fd65f613515 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -243,11 +243,9 @@ struct fuse_args {
 
 /** The request state */
 enum fuse_req_state {
-	FUSE_REQ_INIT = 0,
-	FUSE_REQ_PENDING,
-	FUSE_REQ_READING,
+	FUSE_REQ_PENDING = 0,
+	FUSE_REQ_IO,
 	FUSE_REQ_SENT,
-	FUSE_REQ_WRITING,
 	FUSE_REQ_FINISHED
 };
 

commit dc00809a53edd15369906b90407a2d5b976289f5
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Jul 1 16:25:58 2015 +0200

    fuse: use per req lock for lock/unlock_request()
    
    Reuse req->waitq.lock for protecting FR_ABORTED and FR_LOCKED flags.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Reviewed-by: Ashish Samant <ashish.samant@oracle.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 4503e995c7b2..7257adba7ecd 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -289,6 +289,10 @@ enum fuse_req_flag {
 
 /**
  * A request to the client
+ *
+ * .waitq.lock protects the following fields:
+ *   - FR_ABORTED
+ *   - FR_LOCKED (may also be modified under fc->lock, tested under both)
  */
 struct fuse_req {
 	/** This can be on either pending processing or io lists in

commit 825d6d3395e88a616e4c953984d77eeacbad4310
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Jul 1 16:25:58 2015 +0200

    fuse: req use bitops
    
    Finer grained locking will mean there's no single lock to protect
    modification of bitfileds in fuse_req.
    
    So move to using bitops.  Can use the non-atomic variants for those which
    happen while the request definitely has only one reference.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Reviewed-by: Ashish Samant <ashish.samant@oracle.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 7354dc142a50..4503e995c7b2 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -266,6 +266,27 @@ struct fuse_io_priv {
 	struct completion *done;
 };
 
+/**
+ * Request flags
+ *
+ * FR_ISREPLY:		set if the request has reply
+ * FR_FORCE:		force sending of the request even if interrupted
+ * FR_BACKGROUND:	request is sent in the background
+ * FR_WAITING:		request is counted as "waiting"
+ * FR_ABORTED:		the request was aborted
+ * FR_INTERRUPTED:	the request has been interrupted
+ * FR_LOCKED:		data is being copied to/from the request
+ */
+enum fuse_req_flag {
+	FR_ISREPLY,
+	FR_FORCE,
+	FR_BACKGROUND,
+	FR_WAITING,
+	FR_ABORTED,
+	FR_INTERRUPTED,
+	FR_LOCKED,
+};
+
 /**
  * A request to the client
  */
@@ -283,32 +304,8 @@ struct fuse_req {
 	/** Unique ID for the interrupt request */
 	u64 intr_unique;
 
-	/*
-	 * The following bitfields are either set once before the
-	 * request is queued or setting/clearing them is protected by
-	 * fuse_conn->lock
-	 */
-
-	/** True if the request has reply */
-	unsigned isreply:1;
-
-	/** Force sending of the request even if interrupted */
-	unsigned force:1;
-
-	/** The request was aborted */
-	unsigned aborted:1;
-
-	/** Request is sent in the background */
-	unsigned background:1;
-
-	/** The request has been interrupted */
-	unsigned interrupted:1;
-
-	/** Data is being copied to/from the request */
-	unsigned locked:1;
-
-	/** Request is counted as "waiting" */
-	unsigned waiting:1;
+	/* Request flags, updated with test/set/clear_bit() */
+	unsigned long flags;
 
 	/** State of the request */
 	enum fuse_req_state state;

commit 9d5722b7777e64de2d932f46cfee7765fdcc60d6
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Feb 2 14:59:43 2015 +0100

    fuse: handle synchronous iocbs internally
    
    Based on a patch from Maxim Patlasov <MPatlasov@parallels.com>.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 1cdfb07c1376..7354dc142a50 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -263,6 +263,7 @@ struct fuse_io_priv {
 	int err;
 	struct kiocb *iocb;
 	struct file *file;
+	struct completion *done;
 };
 
 /**

commit 9759bd51899458af4f4bcc11046f01285642ca10
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Jan 6 10:45:35 2015 +0100

    fuse: add memory barrier to INIT
    
    Theoretically we need to order setting of various fields in fc with
    fc->initialized.
    
    No known bug reports related to this yet.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index e0fc6725d1d0..1cdfb07c1376 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -906,4 +906,6 @@ int fuse_write_inode(struct inode *inode, struct writeback_control *wbc);
 int fuse_do_setattr(struct inode *inode, struct iattr *attr,
 		    struct file *file);
 
+void fuse_set_initialized(struct fuse_conn *fc);
+
 #endif /* _FS_FUSE_I_H */

commit 7078187a795f862465325bcadf3070867c0cb5f8
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Dec 12 09:49:05 2014 +0100

    fuse: introduce fuse_simple_request() helper
    
    The following pattern is repeated many times:
    
            req = fuse_get_req_nopages(fc);
            /* Initialize req->(in|out).args */
            fuse_request_send(fc, req);
            err = req->out.h.error;
            fuse_put_request(req);
    
    Create a new replacement helper:
    
            /* Initialize args */
            err = fuse_simple_request(fc, &args);
    
    In addition to reducing the code size, this will ease moving from the
    complex arg-based to a simpler page-based I/O on the fuse device.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 351c098307b8..e0fc6725d1d0 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -222,6 +222,25 @@ struct fuse_page_desc {
 	unsigned int offset;
 };
 
+struct fuse_args {
+	struct {
+		struct {
+			uint32_t opcode;
+			uint64_t nodeid;
+		} h;
+		unsigned numargs;
+		struct fuse_in_arg args[3];
+
+	} in;
+	struct {
+		unsigned argvar:1;
+		unsigned numargs;
+		struct fuse_arg args[2];
+	} out;
+};
+
+#define FUSE_ARGS(args) struct fuse_args args = {}
+
 /** The request state */
 enum fuse_req_state {
 	FUSE_REQ_INIT = 0,
@@ -321,7 +340,6 @@ struct fuse_req {
 			struct fuse_req *next;
 		} write;
 		struct fuse_notify_retrieve_in retrieve_in;
-		struct fuse_lk_in lk_in;
 	} misc;
 
 	/** page vector */
@@ -750,15 +768,6 @@ struct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,
  */
 void __fuse_get_request(struct fuse_req *req);
 
-/**
- * Get a request, may fail with -ENOMEM,
- * useful for callers who doesn't use req->pages[]
- */
-static inline struct fuse_req *fuse_get_req_nopages(struct fuse_conn *fc)
-{
-	return fuse_get_req(fc, 0);
-}
-
 /**
  * Gets a requests for a file operation, always succeeds
  */
@@ -776,6 +785,11 @@ void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req);
  */
 void fuse_request_send(struct fuse_conn *fc, struct fuse_req *req);
 
+/**
+ * Simple request sending that does request allocation and freeing
+ */
+ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args);
+
 /**
  * Send a request in the background
  */

commit f704dcb538eb80b7f5b26281a79b8e29a8e24d62
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Dec 12 09:49:05 2014 +0100

    fuse: reduce max out args
    
    The third out-arg is never actually used.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 416fee2ee1bc..351c098307b8 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -213,7 +213,7 @@ struct fuse_out {
 	unsigned numargs;
 
 	/** Array of arguments */
-	struct fuse_arg args[3];
+	struct fuse_arg args[2];
 };
 
 /** FUSE page descriptor */

commit baebccbe997d5023289e0fc9b4d0d71c6fc17a79
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Dec 12 09:49:04 2014 +0100

    fuse: hold inode instead of path after release
    
    path_put() in release could trigger a DESTROY request in fuseblk.  The
    possible deadlock was worked around by doing the path_put() with
    schedule_work().
    
    This complexity isn't needed if we just hold the inode instead of the path.
    Since we now flush all requests before destroying the super block we can be
    sure that all held inodes will be dropped.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index fbc63ab149b6..416fee2ee1bc 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -305,11 +305,8 @@ struct fuse_req {
 	/** Data for asynchronous requests */
 	union {
 		struct {
-			union {
-				struct fuse_release_in in;
-				struct work_struct work;
-			};
-			struct path path;
+			struct fuse_release_in in;
+			struct inode *inode;
 		} release;
 		struct fuse_init_in init_in;
 		struct fuse_init_out init_out;

commit 580640ba5d331eb5631a5de46941c98f5ed90886
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Dec 12 09:49:04 2014 +0100

    fuse: flush requests on umount
    
    Use fuse_abort_conn() instead of fuse_conn_kill() in fuse_put_super().
    This flushes and aborts requests still on any queues.  But since we've
    already reset fc->connected, those requests would not be useful anyway and
    would be flushed when the fuse device is closed.
    
    Next patches will rely on requests being flushed before the superblock is
    destroyed.
    
    Use fuse_abort_conn() in cuse_process_init_reply() too, since it makes no
    difference there, and we can get rid of fuse_conn_kill().
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index e8e47a6ab518..fbc63ab149b6 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -804,8 +804,6 @@ void fuse_invalidate_atime(struct inode *inode);
  */
 struct fuse_conn *fuse_conn_get(struct fuse_conn *fc);
 
-void fuse_conn_kill(struct fuse_conn *fc);
-
 /**
  * Initialize fuse_conn
  */

commit d22a943f44c79c98ac7a93653fdd330378581741
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 16 15:50:47 2014 -0400

    fuse: pull iov_iter initializations up
    
    ... to fuse_direct_{read,write}().  ->direct_IO() path uses the
    iov_iter passed by the caller instead.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 7aa5c75e0de1..e8e47a6ab518 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -880,9 +880,8 @@ int fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,
 /** CUSE pass fuse_direct_io() a file which f_mapping->host is not from FUSE */
 #define FUSE_DIO_CUSE  (1 << 1)
 
-ssize_t fuse_direct_io(struct fuse_io_priv *io, const struct iovec *iov,
-		       unsigned long nr_segs, size_t count, loff_t *ppos,
-		       int flags);
+ssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter *iter,
+		       loff_t *ppos, int flags);
 long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,
 		   unsigned int flags);
 long fuse_ioctl_common(struct file *file, unsigned int cmd,

commit 1560c974dcd40a8d3f193283acd7cc6aee13dc13
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Mon Apr 28 16:43:44 2014 +0200

    fuse: add renameat2 support
    
    Support RENAME_EXCHANGE and RENAME_NOREPLACE flags on the userspace ABI.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 40677e33504f..7aa5c75e0de1 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -542,6 +542,9 @@ struct fuse_conn {
 	/** Is fallocate not implemented by fs? */
 	unsigned no_fallocate:1;
 
+	/** Is rename with flags implemented by fs? */
+	unsigned no_rename2:1;
+
 	/** Use enhanced/automatic page cache invalidation. */
 	unsigned auto_inval_data:1;
 

commit ab9e13f7c771b511d8f71666e83cb27bcc635b98
Author: Maxim Patlasov <MPatlasov@parallels.com>
Date:   Mon Apr 28 14:19:24 2014 +0200

    fuse: allow ctime flushing to userspace
    
    The patch extends fuse_setattr_in, and extends the flush procedure
    (fuse_flush_times()) called on ->write_inode() to send the ctime as well as
    mtime.
    
    Signed-off-by: Maxim Patlasov <MPatlasov@parallels.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index d2f10054b9a1..40677e33504f 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -889,7 +889,7 @@ int fuse_dev_release(struct inode *inode, struct file *file);
 
 bool fuse_write_update_size(struct inode *inode, loff_t pos);
 
-int fuse_flush_mtime(struct inode *inode, struct fuse_file *ff);
+int fuse_flush_times(struct inode *inode, struct fuse_file *ff);
 int fuse_write_inode(struct inode *inode, struct writeback_control *wbc);
 
 int fuse_do_setattr(struct inode *inode, struct iattr *attr,

commit 1e18bda86e2dcc4ecb176213ee34649c93ad1396
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Mon Apr 28 14:19:23 2014 +0200

    fuse: add .write_inode
    
    ...and flush mtime from this.  This allows us to use the kernel
    infrastructure for writing out dirty metadata (mtime at this point, but
    ctime in the next patches and also maybe atime).
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index adfa2d505c1a..d2f10054b9a1 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -119,8 +119,6 @@ enum {
 	FUSE_I_INIT_RDPLUS,
 	/** An operation changing file size is in progress  */
 	FUSE_I_SIZE_UNSTABLE,
-	/** i_mtime has been updated locally; a flush to userspace needed */
-	FUSE_I_MTIME_DIRTY,
 };
 
 struct fuse_conn;
@@ -891,7 +889,8 @@ int fuse_dev_release(struct inode *inode, struct file *file);
 
 bool fuse_write_update_size(struct inode *inode, loff_t pos);
 
-int fuse_flush_mtime(struct file *file, bool nofail);
+int fuse_flush_mtime(struct inode *inode, struct fuse_file *ff);
+int fuse_write_inode(struct inode *inode, struct writeback_control *wbc);
 
 int fuse_do_setattr(struct inode *inode, struct iattr *attr,
 		    struct file *file);

commit 7736e8cc51bbfdbd538c1870c314eb3483fe04ed
Author: Fabian Frederick <fabf@skynet.be>
Date:   Wed Apr 23 18:14:42 2014 +0200

    fuse: add __exit to fuse_ctl_cleanup
    
    fuse_ctl_cleanup is only called by __exit fuse_exit
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index a257ed8ebee6..adfa2d505c1a 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -725,7 +725,7 @@ int fuse_dev_init(void);
 void fuse_dev_cleanup(void);
 
 int fuse_ctl_init(void);
-void fuse_ctl_cleanup(void);
+void __exit fuse_ctl_cleanup(void);
 
 /**
  * Allocate a request

commit ea8cd33390fafc1eca06a26e6a9c7bf1d386526f
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Thu Oct 10 17:12:05 2013 +0400

    fuse: Fix O_DIRECT operations vs cached writeback misorder
    
    The problem is:
    
    1. write cached data to a file
    2. read directly from the same file (via another fd)
    
    The 2nd operation may read stale data, i.e. the one that was in a file
    before the 1st op. Problem is in how fuse manages writeback.
    
    When direct op occurs the core kernel code calls filemap_write_and_wait
    to flush all the cached ops in flight. But fuse acks the writeback right
    after the ->writepages callback exits w/o waiting for the real write to
    happen. Thus the subsequent direct op proceeds while the real writeback
    is still in flight. This is a problem for backends that reorder operation.
    
    Fix this by making the fuse direct IO callback explicitly wait on the
    in-flight writeback to finish.
    
    Signed-off-by: Maxim Patlasov <MPatlasov@parallels.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 1e6ad6d43051..a257ed8ebee6 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -868,9 +868,20 @@ int fuse_reverse_inval_entry(struct super_block *sb, u64 parent_nodeid,
 
 int fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,
 		 bool isdir);
+
+/**
+ * fuse_direct_io() flags
+ */
+
+/** If set, it is WRITE; otherwise - READ */
+#define FUSE_DIO_WRITE (1 << 0)
+
+/** CUSE pass fuse_direct_io() a file which f_mapping->host is not from FUSE */
+#define FUSE_DIO_CUSE  (1 << 1)
+
 ssize_t fuse_direct_io(struct fuse_io_priv *io, const struct iovec *iov,
 		       unsigned long nr_segs, size_t count, loff_t *ppos,
-		       int write);
+		       int flags);
 long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,
 		   unsigned int flags);
 long fuse_ioctl_common(struct file *file, unsigned int cmd,

commit b0aa760652179072119582375f8dc896ed5b5dfd
Author: Maxim Patlasov <MPatlasov@parallels.com>
Date:   Thu Dec 26 19:51:11 2013 +0400

    fuse: Trust kernel i_mtime only
    
    Let the kernel maintain i_mtime locally:
     - clear S_NOCMTIME
     - implement i_op->update_time()
     - flush mtime on fsync and last close
     - update i_mtime explicitly on truncate and fallocate
    
    Fuse inode flag FUSE_I_MTIME_DIRTY serves as indication that local i_mtime
    should be flushed to the server eventually.
    
    Signed-off-by: Maxim Patlasov <MPatlasov@parallels.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 374a8be014fd..1e6ad6d43051 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -119,6 +119,8 @@ enum {
 	FUSE_I_INIT_RDPLUS,
 	/** An operation changing file size is in progress  */
 	FUSE_I_SIZE_UNSTABLE,
+	/** i_mtime has been updated locally; a flush to userspace needed */
+	FUSE_I_MTIME_DIRTY,
 };
 
 struct fuse_conn;
@@ -876,7 +878,9 @@ long fuse_ioctl_common(struct file *file, unsigned int cmd,
 unsigned fuse_file_poll(struct file *file, poll_table *wait);
 int fuse_dev_release(struct inode *inode, struct file *file);
 
-void fuse_write_update_size(struct inode *inode, loff_t pos);
+bool fuse_write_update_size(struct inode *inode, loff_t pos);
+
+int fuse_flush_mtime(struct file *file, bool nofail);
 
 int fuse_do_setattr(struct inode *inode, struct iattr *attr,
 		    struct file *file);

commit d5cd66c58edf10a7ee786659994595fd43995aab
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Thu Oct 10 17:10:30 2013 +0400

    fuse: Connection bit for enabling writeback
    
    Off (0) by default. Will be used in the next patches and will be turned
    on at the very end.
    
    Signed-off-by: Maxim Patlasov <MPatlasov@parallels.com>
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 2da5db2c8bdb..374a8be014fd 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -480,6 +480,9 @@ struct fuse_conn {
 	/** Set if bdi is valid */
 	unsigned bdi_initialized:1;
 
+	/** write-back cache policy (default is write-through) */
+	unsigned writeback_cache:1;
+
 	/*
 	 * The following bitfields are only for optimization purposes
 	 * and hence races in setting them will not cause malfunction

commit 7678ac50615d9c7a491d9861e020e4f5f71b594c
Author: Andrew Gallagher <agallagher@fb.com>
Date:   Tue Nov 5 16:05:52 2013 +0100

    fuse: support clients that don't implement 'open'
    
    open/release operations require userspace transitions to keep track
    of the open count and to perform any FS-specific setup.  However,
    for some purely read-only FSs which don't need to perform any setup
    at open/release time, we can avoid the performance overhead of
    calling into userspace for open/release calls.
    
    This patch adds the necessary support to the fuse kernel modules to prevent
    open/release operations from hitting in userspace. When the client returns
    ENOSYS, we avoid sending the subsequent release to userspace, and also
    remember this so that future opens also don't trigger a userspace
    operation.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index dc44b9e3a0c9..2da5db2c8bdb 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -485,6 +485,9 @@ struct fuse_conn {
 	 * and hence races in setting them will not cause malfunction
 	 */
 
+	/** Is open/release not implemented by fs? */
+	unsigned no_open:1;
+
 	/** Is fsync not implemented by fs? */
 	unsigned no_fsync:1;
 

commit 451418fc928b5ec1ee96a9afac807b6312811a2a
Author: Andrew Gallagher <andrewjcg@fb.com>
Date:   Tue Nov 5 03:55:43 2013 -0800

    fuse: don't invalidate attrs when not using atime
    
    Various read operations (e.g. readlink, readdir) invalidate the cached
    attrs for atime changes.  This patch adds a new function
    'fuse_invalidate_atime', which checks for a read-only super block and
    avoids the attr invalidation in that case.
    
    Signed-off-by: Andrew Gallagher <andrewjcg@fb.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 7d2730912667..dc44b9e3a0c9 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -788,6 +788,8 @@ void fuse_invalidate_attr(struct inode *inode);
 
 void fuse_invalidate_entry_cache(struct dentry *entry);
 
+void fuse_invalidate_atime(struct inode *inode);
+
 /**
  * Acquire reference to fuse_conn
  */

commit 9bc9ccd7db1c9f043f75380b5a5b94912046a60e
Merge: f0230294271f bdd353661844
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 13 15:34:18 2013 +0900

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
     "All kinds of stuff this time around; some more notable parts:
    
       - RCU'd vfsmounts handling
       - new primitives for coredump handling
       - files_lock is gone
       - Bruce's delegations handling series
       - exportfs fixes
    
      plus misc stuff all over the place"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (101 commits)
      ecryptfs: ->f_op is never NULL
      locks: break delegations on any attribute modification
      locks: break delegations on link
      locks: break delegations on rename
      locks: helper functions for delegation breaking
      locks: break delegations on unlink
      namei: minor vfs_unlink cleanup
      locks: implement delegations
      locks: introduce new FL_DELEG lock flag
      vfs: take i_mutex on renamed file
      vfs: rename I_MUTEX_QUOTA now that it's not used for quotas
      vfs: don't use PARENT/CHILD lock classes for non-directories
      vfs: pull ext4's double-i_mutex-locking into common code
      exportfs: fix quadratic behavior in filehandle lookup
      exportfs: better variable name
      exportfs: move most of reconnect_path to helper function
      exportfs: eliminate unused "noprogress" counter
      exportfs: stop retrying once we race with rename/remove
      exportfs: clear DISCONNECTED on all parents sooner
      exportfs: more detailed comment for path_reconnect
      ...

commit dd3e2c55a45fe75f3213b17b74f9a32380f4e84b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 3 21:21:39 2013 -0400

    fuse: rcu-delay freeing fuse_conn
    
    makes ->permission() and ->d_revalidate() safety in RCU mode independent
    from vfsmount_lock.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index fe446c222e3f..4715674f050c 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -377,6 +377,8 @@ struct fuse_conn {
 	/** Refcount */
 	atomic_t count;
 
+	struct rcu_head rcu;
+
 	/** The user id for this mount */
 	kuid_t user_id;
 

commit b70a80e7a133a0c86f2fa078e7c144597c516415
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Oct 1 16:44:54 2013 +0200

    vfs: introduce d_instantiate_no_diralias()
    
    ...which just returns -EBUSY if a directory alias would be created.
    
    This is to be used by fuse mkdir to make sure that a buggy or malicious
    userspace filesystem doesn't do anything nasty.  Previously fuse used a
    private mutex for this purpose, which can now go away.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 5b9e6f3b6aef..fe446c222e3f 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -374,9 +374,6 @@ struct fuse_conn {
 	/** Lock protecting accessess to  members of this structure */
 	spinlock_t lock;
 
-	/** Mutex protecting against directory alias creation */
-	struct mutex inst_mutex;
-
 	/** Refcount */
 	atomic_t count;
 

commit 8b284dc47291daf72fe300e1138a2e7ed56f38ab
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Oct 1 16:44:53 2013 +0200

    fuse: writepages: handle same page rewrites
    
    As Maxim Patlasov pointed out, it's possible to get a dirty page while it's
    copy is still under writeback, despite fuse_page_mkwrite() doing its thing
    (direct IO).
    
    This could result in two concurrent write request for the same offset, with
    data corruption if they get mixed up.
    
    To prevent this, fuse needs to check and delay such writes.  This
    implementation does this by:
    
     1. check if page is still under writeout, if so create a new, single page
        secondary request for it
    
     2. chain this secondary request onto the in-flight request
    
     2/a. if a seconday request for the same offset was already chained to the
        in-flight request, then just copy the contents of the page and discard
        the new secondary request.  This makes sure that for each page will
        have at most two requests associated with it
    
     3. when the in-flight request finished, send off all secondary requests
        chained onto it
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 5b9e6f3b6aef..643274852c8b 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -321,6 +321,7 @@ struct fuse_req {
 		struct {
 			struct fuse_write_in in;
 			struct fuse_write_out out;
+			struct fuse_req *next;
 		} write;
 		struct fuse_notify_retrieve_in retrieve_in;
 		struct fuse_lk_in lk_in;

commit 6314efee3cfeea2da12dbc05edfa20e5a42391bd
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Oct 1 16:41:22 2013 +0200

    fuse: readdirplus: fix RCU walk
    
    Doing dput(parent) is not valid in RCU walk mode.  In RCU mode it would
    probably be okay to update the parent flags, but it's actually not
    necessary most of the time...
    
    So only set the FUSE_I_ADVISE_RDPLUS flag on the parent when the entry was
    recently initialized by READDIRPLUS.
    
    This is achieved by setting FUSE_I_INIT_RDPLUS on entries added by
    READDIRPLUS and only dropping out of RCU mode if this flag is set.
    FUSE_I_INIT_RDPLUS is cleared once the FUSE_I_ADVISE_RDPLUS flag is set in
    the parent.
    
    Reported-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Cc: stable@vger.kernel.org

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 5ced199b50bb..5b9e6f3b6aef 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -115,6 +115,8 @@ struct fuse_inode {
 enum {
 	/** Advise readdirplus  */
 	FUSE_I_ADVISE_RDPLUS,
+	/** Initialized with readdirplus */
+	FUSE_I_INIT_RDPLUS,
 	/** An operation changing file size is in progress  */
 	FUSE_I_SIZE_UNSTABLE,
 };

commit 06a7c3c2781409af95000c60a5df743fd4e2f8b4
Author: Maxim Patlasov <MPatlasov@parallels.com>
Date:   Fri Aug 30 17:06:04 2013 +0400

    fuse: hotfix truncate_pagecache() issue
    
    The way how fuse calls truncate_pagecache() from fuse_change_attributes()
    is completely wrong. Because, w/o i_mutex held, we never sure whether
    'oldsize' and 'attr->size' are valid by the time of execution of
    truncate_pagecache(inode, oldsize, attr->size). In fact, as soon as we
    released fc->lock in the middle of fuse_change_attributes(), we completely
    loose control of actions which may happen with given inode until we reach
    truncate_pagecache. The list of potentially dangerous actions includes
    mmap-ed reads and writes, ftruncate(2) and write(2) extending file size.
    
    The typical outcome of doing truncate_pagecache() with outdated arguments
    is data corruption from user point of view. This is (in some sense)
    acceptable in cases when the issue is triggered by a change of the file on
    the server (i.e. externally wrt fuse operation), but it is absolutely
    intolerable in scenarios when a single fuse client modifies a file without
    any external intervention. A real life case I discovered by fsx-linux
    looked like this:
    
    1. Shrinking ftruncate(2) comes to fuse_do_setattr(). The latter sends
    FUSE_SETATTR to the server synchronously, but before getting fc->lock ...
    2. fuse_dentry_revalidate() is asynchronously called. It sends FUSE_LOOKUP
    to the server synchronously, then calls fuse_change_attributes(). The
    latter updates i_size, releases fc->lock, but before comparing oldsize vs
    attr->size..
    3. fuse_do_setattr() from the first step proceeds by acquiring fc->lock and
    updating attributes and i_size, but now oldsize is equal to
    outarg.attr.size because i_size has just been updated (step 2). Hence,
    fuse_do_setattr() returns w/o calling truncate_pagecache().
    4. As soon as ftruncate(2) completes, the user extends file size by
    write(2) making a hole in the middle of file, then reads data from the hole
    either by read(2) or mmap-ed read. The user expects to get zero data from
    the hole, but gets stale data because truncate_pagecache() is not executed
    yet.
    
    The scenario above illustrates one side of the problem: not truncating the
    page cache even though we should. Another side corresponds to truncating
    page cache too late, when the state of inode changed significantly.
    Theoretically, the following is possible:
    
    1. As in the previous scenario fuse_dentry_revalidate() discovered that
    i_size changed (due to our own fuse_do_setattr()) and is going to call
    truncate_pagecache() for some 'new_size' it believes valid right now. But
    by the time that particular truncate_pagecache() is called ...
    2. fuse_do_setattr() returns (either having called truncate_pagecache() or
    not -- it doesn't matter).
    3. The file is extended either by write(2) or ftruncate(2) or fallocate(2).
    4. mmap-ed write makes a page in the extended region dirty.
    
    The result will be the lost of data user wrote on the fourth step.
    
    The patch is a hotfix resolving the issue in a simplistic way: let's skip
    dangerous i_size update and truncate_pagecache if an operation changing
    file size is in progress. This simplistic approach looks correct for the
    cases w/o external changes. And to handle them properly, more sophisticated
    and intrusive techniques (e.g. NFS-like one) would be required. I'd like to
    postpone it until the issue is well discussed on the mailing list(s).
    
    Changed in v2:
     - improved patch description to cover both sides of the issue.
    
    Signed-off-by: Maxim Patlasov <mpatlasov@parallels.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Cc: stable@vger.kernel.org

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index fde7249a3a96..5ced199b50bb 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -115,6 +115,8 @@ struct fuse_inode {
 enum {
 	/** Advise readdirplus  */
 	FUSE_I_ADVISE_RDPLUS,
+	/** An operation changing file size is in progress  */
+	FUSE_I_SIZE_UNSTABLE,
 };
 
 struct fuse_conn;

commit 60b9df7a54804a965850db00beec4d3a2c002536
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed May 1 14:37:21 2013 +0200

    fuse: add flag to turn on async direct IO
    
    Without async DIO write requests to a single file were always serialized.
    With async DIO that's no longer the case.
    
    So don't turn on async DIO by default for fear of breaking backward
    compatibility.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 53b830e3b38f..fde7249a3a96 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -541,6 +541,9 @@ struct fuse_conn {
 	/** Does the filesystem want adaptive readdirplus? */
 	unsigned readdirplus_auto:1;
 
+	/** Does the filesystem support asynchronous direct-IO submission? */
+	unsigned async_dio:1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 

commit efb9fa9e911b23c7ea5330215bda778a7c69dba8
Author: Maxim Patlasov <mpatlasov@parallels.com>
Date:   Tue Dec 18 14:05:08 2012 +0400

    fuse: truncate file if async dio failed
    
    The patch improves error handling in fuse_direct_IO(): if we successfully
    submitted several fuse requests on behalf of synchronous direct write
    extending file and some of them failed, let's try to do our best to clean-up.
    
    Changed in v2: reuse fuse_do_setattr(). Thanks to Brian for suggestion.
    
    Signed-off-by: Maxim Patlasov <mpatlasov@parallels.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 337169a406c9..53b830e3b38f 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -863,4 +863,7 @@ int fuse_dev_release(struct inode *inode, struct file *file);
 
 void fuse_write_update_size(struct inode *inode, loff_t pos);
 
+int fuse_do_setattr(struct inode *inode, struct iattr *attr,
+		    struct file *file);
+
 #endif /* _FS_FUSE_I_H */

commit 36cf66ed9f871fc0d0911921fba5873df3ddb2dc
Author: Maxim Patlasov <mpatlasov@parallels.com>
Date:   Fri Dec 14 19:20:51 2012 +0400

    fuse: make fuse_direct_io() aware about AIO
    
    The patch implements passing "struct fuse_io_priv *io" down the stack up to
    fuse_send_read/write where it is used to submit request asynchronously.
    io->async==0 designates synchronous processing.
    
    Non-trivial part of the patch is changes in fuse_direct_io(): resources
    like fuse requests and user pages cannot be released immediately in async
    case.
    
    Signed-off-by: Maxim Patlasov <mpatlasov@parallels.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index aea072413c47..337169a406c9 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -732,6 +732,11 @@ struct fuse_req *fuse_get_req(struct fuse_conn *fc, unsigned npages);
 struct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,
 					     unsigned npages);
 
+/*
+ * Increment reference count on request
+ */
+void __fuse_get_request(struct fuse_req *req);
+
 /**
  * Get a request, may fail with -ENOMEM,
  * useful for callers who doesn't use req->pages[]
@@ -846,7 +851,7 @@ int fuse_reverse_inval_entry(struct super_block *sb, u64 parent_nodeid,
 
 int fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,
 		 bool isdir);
-ssize_t fuse_direct_io(struct file *file, const struct iovec *iov,
+ssize_t fuse_direct_io(struct fuse_io_priv *io, const struct iovec *iov,
 		       unsigned long nr_segs, size_t count, loff_t *ppos,
 		       int write);
 long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,

commit 01e9d11a3e79035ca5cd89b035435acd4ba61ee1
Author: Maxim Patlasov <mpatlasov@parallels.com>
Date:   Fri Dec 14 19:20:41 2012 +0400

    fuse: add support of async IO
    
    The patch implements a framework to process an IO request asynchronously. The
    idea is to associate several fuse requests with a single kiocb by means of
    fuse_io_priv structure. The structure plays the same role for FUSE as 'struct
    dio' for direct-io.c.
    
    The framework is supposed to be used like this:
     - someone (who wants to process an IO asynchronously) allocates fuse_io_priv
       and initializes it setting 'async' field to non-zero value.
     - as soon as fuse request is filled, it can be submitted (in non-blocking way)
       by fuse_async_req_send()
     - when all submitted requests are ACKed by userspace, io->reqs drops to zero
       triggering aio_complete()
    
    In case of IO initiated by libaio, aio_complete() will finish processing the
    same way as in case of dio_complete() calling aio_complete(). But the
    framework may be also used for internal FUSE use when initial IO request
    was synchronous (from user perspective), but it's beneficial to process it
    asynchronously. Then the caller should wait on kiocb explicitly and
    aio_complete() will wake the caller up.
    
    Signed-off-by: Maxim Patlasov <mpatlasov@parallels.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 6bf30f2af901..aea072413c47 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -228,6 +228,20 @@ enum fuse_req_state {
 	FUSE_REQ_FINISHED
 };
 
+/** The request IO state (for asynchronous processing) */
+struct fuse_io_priv {
+	int async;
+	spinlock_t lock;
+	unsigned reqs;
+	ssize_t bytes;
+	size_t size;
+	__u64 offset;
+	bool write;
+	int err;
+	struct kiocb *iocb;
+	struct file *file;
+};
+
 /**
  * A request to the client
  */
@@ -332,6 +346,9 @@ struct fuse_req {
 	/** Inode used in the request or NULL */
 	struct inode *inode;
 
+	/** AIO control block */
+	struct fuse_io_priv *io;
+
 	/** Link on fi->writepages */
 	struct list_head writepages_entry;
 

commit 796523fb24028639c007f71e02ca21730f7c0af6
Author: Maxim Patlasov <mpatlasov@parallels.com>
Date:   Thu Mar 21 18:02:15 2013 +0400

    fuse: add flag fc->initialized
    
    Existing flag fc->blocked is used to suspend request allocation both in case
    of many background request submitted and period of time before init_reply
    arrives from userspace. Next patch will skip blocking allocations of
    synchronous request (disregarding fc->blocked). This is mostly OK, but
    we still need to suspend allocations if init_reply is not arrived yet. The
    patch introduces flag fc->initialized which will serve this purpose.
    
    Signed-off-by: Maxim Patlasov <mpatlasov@parallels.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 47c94d28ff88..6bf30f2af901 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -417,6 +417,10 @@ struct fuse_conn {
 	/** Batching of FORGET requests (positive indicates FORGET batch) */
 	int forget_batch;
 
+	/** Flag indicating that INIT reply has been received. Allocating
+	 * any fuse request will be suspended until the flag is set */
+	int initialized;
+
 	/** Flag indicating if connection is blocked.  This will be
 	    the case before the INIT reply is received, and if there
 	    are too many outstading backgrounds requests */

commit 8b41e6715ed555e2d8e8dac52ec1f05a9f04dcb4
Author: Maxim Patlasov <mpatlasov@parallels.com>
Date:   Thu Mar 21 18:02:04 2013 +0400

    fuse: make request allocations for background processing explicit
    
    There are two types of processing requests in FUSE: synchronous (via
    fuse_request_send()) and asynchronous (via adding to fc->bg_queue).
    
    Fortunately, the type of processing is always known in advance, at the time
    of request allocation. This preparatory patch utilizes this fact making
    fuse_get_req() aware about the type. Next patches will use it.
    
    Signed-off-by: Maxim Patlasov <mpatlasov@parallels.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 6aeba864f070..47c94d28ff88 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -708,6 +708,8 @@ void fuse_request_free(struct fuse_req *req);
  * caller should specify # elements in req->pages[] explicitly
  */
 struct fuse_req *fuse_get_req(struct fuse_conn *fc, unsigned npages);
+struct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,
+					     unsigned npages);
 
 /**
  * Get a request, may fail with -ENOMEM,

commit 634734b63ac39e137a1c623ba74f3e062b6577db
Author: Eric Wong <normalperson@yhbt.net>
Date:   Wed Feb 6 22:29:01 2013 +0000

    fuse: allow control of adaptive readdirplus use
    
    For some filesystems (e.g. GlusterFS), the cost of performing a
    normal readdir and readdirplus are identical.  Since adaptively
    using readdirplus has no benefit for those systems, give
    users/filesystems the option to control adaptive readdirplus use.
    
    v2 of this patch incorporates Miklos's suggestion to simplify the code,
    as well as improving consistency of macro names and documentation.
    
    Signed-off-by: Eric Wong <normalperson@yhbt.net>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index fc55dd33c1e2..6aeba864f070 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -514,9 +514,12 @@ struct fuse_conn {
 	/** Use enhanced/automatic page cache invalidation. */
 	unsigned auto_inval_data:1;
 
-	/** Does the filesystem support readdir-plus? */
+	/** Does the filesystem support readdirplus? */
 	unsigned do_readdirplus:1;
 
+	/** Does the filesystem want adaptive readdirplus? */
+	unsigned readdirplus_auto:1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 

commit 4582a4ab2a0e7218449fb2e895d0aae9ea753c94
Author: Feng Shuo <steve.shuo.feng@gmail.com>
Date:   Tue Jan 15 11:23:28 2013 +0800

    FUSE: Adapt readdirplus to application usage patterns
    
    Use the same adaptive readdirplus mechanism as NFS:
    
    http://permalink.gmane.org/gmane.linux.nfs/49299
    
    If the user space implementation wants to disable readdirplus
    temporarily, it could just return ENOTSUPP. Then kernel will
    recall it with readdir.
    
    Signed-off-by: Feng Shuo <steve.shuo.feng@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index af51c146a9ae..fc55dd33c1e2 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -106,6 +106,15 @@ struct fuse_inode {
 
 	/** List of writepage requestst (pending or sent) */
 	struct list_head writepages;
+
+	/** Miscellaneous bits describing inode state */
+	unsigned long state;
+};
+
+/** FUSE inode state bits */
+enum {
+	/** Advise readdirplus  */
+	FUSE_I_ADVISE_RDPLUS,
 };
 
 struct fuse_conn;

commit c2132c1bc73d9a279cec148f74ea709c960b3d89
Author: Anatol Pomozov <anatol.pomozov@gmail.com>
Date:   Mon Jan 14 22:30:00 2013 -0800

    Do not use RCU for current process credentials
    
    Commit c69e8d9c0 added rcu lock to fuse/dir.c It was assuming
    that 'task' is some other process but in fact this parameter always
    equals to 'current'. Inline this parameter to make it more readable
    and remove RCU lock as it is not needed when access current process
    credentials.
    
    Signed-off-by: Anatol Pomozov <anatol.pomozov@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 13befcd29c5b..af51c146a9ae 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -774,9 +774,9 @@ void fuse_ctl_remove_conn(struct fuse_conn *fc);
 int fuse_valid_type(int m);
 
 /**
- * Is task allowed to perform filesystem operation?
+ * Is current process allowed to perform filesystem operation?
  */
-int fuse_allow_task(struct fuse_conn *fc, struct task_struct *task);
+int fuse_allow_current_process(struct fuse_conn *fc);
 
 u64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id);
 

commit fb05f41f5f96f7423c53da4d87913fb44fd0565d
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Sat Nov 10 16:55:56 2012 +0100

    fuse: cleanup fuse_direct_io()
    
    Fix the following sparse warnings:
    
    fs/fuse/file.c:1216:43: warning: cast removes address space of expression
    fs/fuse/file.c:1216:43: warning: incorrect type in initializer (different address spaces)
    fs/fuse/file.c:1216:43:    expected void [noderef] <asn:1>*iov_base
    fs/fuse/file.c:1216:43:    got void *<noident>
    fs/fuse/file.c:1241:43: warning: cast removes address space of expression
    fs/fuse/file.c:1241:43: warning: incorrect type in initializer (different address spaces)
    fs/fuse/file.c:1241:43:    expected void [noderef] <asn:1>*iov_base
    fs/fuse/file.c:1241:43:    got void *<noident>
    fs/fuse/file.c:1267:43: warning: cast removes address space of expression
    fs/fuse/file.c:1267:43: warning: incorrect type in initializer (different address spaces)
    fs/fuse/file.c:1267:43:    expected void [noderef] <asn:1>*iov_base
    fs/fuse/file.c:1267:43:    got void *<noident>
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 70cef60afe0e..13befcd29c5b 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -811,8 +811,9 @@ int fuse_reverse_inval_entry(struct super_block *sb, u64 parent_nodeid,
 
 int fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,
 		 bool isdir);
-ssize_t fuse_direct_io(struct file *file, const char __user *buf,
-		       size_t count, loff_t *ppos, int write);
+ssize_t fuse_direct_io(struct file *file, const struct iovec *iov,
+		       unsigned long nr_segs, size_t count, loff_t *ppos,
+		       int write);
 long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,
 		   unsigned int flags);
 long fuse_ioctl_common(struct file *file, unsigned int cmd,

commit b2430d7567a376b3685627ca7e9d712f6f27d49b
Author: Maxim Patlasov <mpatlasov@parallels.com>
Date:   Fri Oct 26 19:49:24 2012 +0400

    fuse: add per-page descriptor <offset, length> to fuse_req
    
    The ability to save page pointers along with lengths and offsets in fuse_req
    will be useful to cover several iovec-s with a single fuse_req.
    
    Per-request page_offset is removed because anybody who need it can use
    req->page_descs[0].offset instead.
    
    Signed-off-by: Maxim Patlasov <mpatlasov@parallels.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 5b21e6ab9e75..70cef60afe0e 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -203,6 +203,12 @@ struct fuse_out {
 	struct fuse_arg args[3];
 };
 
+/** FUSE page descriptor */
+struct fuse_page_desc {
+	unsigned int length;
+	unsigned int offset;
+};
+
 /** The request state */
 enum fuse_req_state {
 	FUSE_REQ_INIT = 0,
@@ -296,18 +302,21 @@ struct fuse_req {
 	/** page vector */
 	struct page **pages;
 
+	/** page-descriptor vector */
+	struct fuse_page_desc *page_descs;
+
 	/** size of the 'pages' array */
 	unsigned max_pages;
 
 	/** inline page vector */
 	struct page *inline_pages[FUSE_REQ_INLINE_PAGES];
 
+	/** inline page-descriptor vector */
+	struct fuse_page_desc inline_page_descs[FUSE_REQ_INLINE_PAGES];
+
 	/** number of pages in vector */
 	unsigned num_pages;
 
-	/** offset of data on first page */
-	unsigned page_offset;
-
 	/** File used in the request (or NULL) */
 	struct fuse_file *ff;
 

commit b111c8c0e3e5e780ae0758fc4c1c376a7c9d5997
Author: Maxim Patlasov <mpatlasov@parallels.com>
Date:   Fri Oct 26 19:48:30 2012 +0400

    fuse: categorize fuse_get_req()
    
    The patch categorizes all fuse_get_req() invocations into two categories:
     - fuse_get_req_nopages(fc) - when caller doesn't care about req->pages
     - fuse_get_req(fc, n) - when caller need n page pointers (n > 0)
    
    Adding fuse_get_req_nopages() helps to avoid numerous fuse_get_req(fc, 0)
    scattered over code. Now it's clear from the first glance when a caller need
    fuse_req with page pointers.
    
    The patch doesn't make any logic changes. In multi-page case, it silly
    allocates array of FUSE_MAX_PAGES_PER_REQ page pointers. This will be amended
    by future patches.
    
    Signed-off-by: Maxim Patlasov <mpatlasov@parallels.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 0c5b9310f930..5b21e6ab9e75 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -683,14 +683,25 @@ struct fuse_req *fuse_request_alloc_nofs(unsigned npages);
 void fuse_request_free(struct fuse_req *req);
 
 /**
- * Get a request, may fail with -ENOMEM
+ * Get a request, may fail with -ENOMEM,
+ * caller should specify # elements in req->pages[] explicitly
  */
-struct fuse_req *fuse_get_req(struct fuse_conn *fc);
+struct fuse_req *fuse_get_req(struct fuse_conn *fc, unsigned npages);
+
+/**
+ * Get a request, may fail with -ENOMEM,
+ * useful for callers who doesn't use req->pages[]
+ */
+static inline struct fuse_req *fuse_get_req_nopages(struct fuse_conn *fc)
+{
+	return fuse_get_req(fc, 0);
+}
 
 /**
  * Gets a requests for a file operation, always succeeds
  */
-struct fuse_req *fuse_get_req_nofail(struct fuse_conn *fc, struct file *file);
+struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,
+					     struct file *file);
 
 /**
  * Decrement reference count of a request.  If count goes to zero free

commit 4250c0668ea10a19f3d37b1733f54ce6c8a37234
Author: Maxim Patlasov <mpatlasov@parallels.com>
Date:   Fri Oct 26 19:48:07 2012 +0400

    fuse: general infrastructure for pages[] of variable size
    
    The patch removes inline array of FUSE_MAX_PAGES_PER_REQ page pointers from
    fuse_req. Instead of that, req->pages may now point either to small inline
    array or to an array allocated dynamically.
    
    This essentially means that all callers of fuse_request_alloc[_nofs] should
    pass the number of pages needed explicitly.
    
    The patch doesn't make any logic changes.
    
    Signed-off-by: Maxim Patlasov <mpatlasov@parallels.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 5c5055306d3c..0c5b9310f930 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -44,6 +44,9 @@
     doing the mount will be allowed to access the filesystem */
 #define FUSE_ALLOW_OTHER         (1 << 1)
 
+/** Number of page pointers embedded in fuse_req */
+#define FUSE_REQ_INLINE_PAGES 1
+
 /** List of active connections */
 extern struct list_head fuse_conn_list;
 
@@ -291,7 +294,13 @@ struct fuse_req {
 	} misc;
 
 	/** page vector */
-	struct page *pages[FUSE_MAX_PAGES_PER_REQ];
+	struct page **pages;
+
+	/** size of the 'pages' array */
+	unsigned max_pages;
+
+	/** inline page vector */
+	struct page *inline_pages[FUSE_REQ_INLINE_PAGES];
 
 	/** number of pages in vector */
 	unsigned num_pages;
@@ -664,9 +673,9 @@ void fuse_ctl_cleanup(void);
 /**
  * Allocate a request
  */
-struct fuse_req *fuse_request_alloc(void);
+struct fuse_req *fuse_request_alloc(unsigned npages);
 
-struct fuse_req *fuse_request_alloc_nofs(void);
+struct fuse_req *fuse_request_alloc_nofs(unsigned npages);
 
 /**
  * Free a request

commit 0b05b18381eea98c9c9ada95629bf659a88c9374
Author: Anand V. Avati <avati@redhat.com>
Date:   Sun Aug 19 08:53:23 2012 -0400

    fuse: implement NFS-like readdirplus support
    
    This patch implements readdirplus support in FUSE, similar to NFS.
    The payload returned in the readdirplus call contains
    'fuse_entry_out' structure thereby providing all the necessary inputs
    for 'faking' a lookup() operation on the spot.
    
    If the dentry and inode already existed (for e.g. in a re-run of ls -l)
    then just the inode attributes timeout and dentry timeout are refreshed.
    
    With a simple client->network->server implementation of a FUSE based
    filesystem, the following performance observations were made:
    
    Test: Performing a filesystem crawl over 20,000 files with
    
    sh# time ls -lR /mnt
    
    Without readdirplus:
    Run 1: 18.1s
    Run 2: 16.0s
    Run 3: 16.2s
    
    With readdirplus:
    Run 1: 4.1s
    Run 2: 3.8s
    Run 3: 3.8s
    
    The performance improvement is significant as it avoided 20,000 upcalls
    calls (lookup). Cache consistency is no worse than what already is.
    
    Signed-off-by: Anand V. Avati <avati@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index e105a53fc72d..5c5055306d3c 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -487,6 +487,9 @@ struct fuse_conn {
 	/** Use enhanced/automatic page cache invalidation. */
 	unsigned auto_inval_data:1;
 
+	/** Does the filesystem support readdir-plus? */
+	unsigned do_readdirplus:1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 
@@ -578,6 +581,9 @@ void fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,
 
 struct fuse_forget_link *fuse_alloc_forget(void);
 
+/* Used by READDIRPLUS */
+void fuse_force_forget(struct file *file, u64 nodeid);
+
 /**
  * Initialize READ or READDIR request
  */

commit 499dcf2024092e5cce41d05599a5b51d1f92031a
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Feb 7 16:26:03 2012 -0800

    userns: Support fuse interacting with multiple user namespaces
    
    Use kuid_t and kgid_t in struct fuse_conn and struct fuse_mount_data.
    
    The connection between between a fuse filesystem and a fuse daemon is
    established when a fuse filesystem is mounted and provided with a file
    descriptor the fuse daemon created by opening /dev/fuse.
    
    For now restrict the communication of uids and gids between the fuse
    filesystem and the fuse daemon to the initial user namespace.  Enforce
    this by verifying the file descriptor passed to the mount of fuse was
    opened in the initial user namespace.  Ensuring the mount happens in
    the initial user namespace is not necessary as mounts from non-initial
    user namespaces are not yet allowed.
    
    In fuse_req_init_context convert the currrent fsuid and fsgid into the
    initial user namespace for the request that will be sent to the fuse
    daemon.
    
    In fuse_fill_attr convert the uid and gid passed from the fuse daemon
    from the initial user namespace into kuids and kgids.
    
    In iattr_to_fattr called from fuse_setattr convert kuids and kgids
    into the uids and gids in the initial user namespace before passing
    them to the fuse filesystem.
    
    In fuse_change_attributes_common called from fuse_dentry_revalidate,
    fuse_permission, fuse_geattr, and fuse_setattr, and fuse_iget convert
    the uid and gid from the fuse daemon into a kuid and a kgid to store
    on the fuse inode.
    
    By default fuse mounts are restricted to task whose uid, suid, and
    euid matches the fuse user_id and whose gid, sgid, and egid matches
    the fuse group id.  Convert the user_id and group_id mount options
    into kuids and kgids at mount time, and use uid_eq and gid_eq to
    compare the in fuse_allow_task.
    
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index e24dd74e3068..e105a53fc72d 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -333,10 +333,10 @@ struct fuse_conn {
 	atomic_t count;
 
 	/** The user id for this mount */
-	uid_t user_id;
+	kuid_t user_id;
 
 	/** The group id for this mount */
-	gid_t group_id;
+	kgid_t group_id;
 
 	/** The fuse mount flags for this mount */
 	unsigned flags;

commit 72d0d248ca8232dbd30d35b42d0d86e39b3e322b
Author: Brian Foster <bfoster@redhat.com>
Date:   Mon Jul 16 15:23:48 2012 -0400

    fuse: add FUSE_AUTO_INVAL_DATA init flag
    
    FUSE_AUTO_INVAL_DATA is provided to enable updated/auto cache
    invalidation logic.
    
    Signed-off-by: Brian Foster <bfoster@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 771fb6322c07..e24dd74e3068 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -484,6 +484,9 @@ struct fuse_conn {
 	/** Is fallocate not implemented by fs? */
 	unsigned no_fallocate:1;
 
+	/** Use enhanced/automatic page cache invalidation. */
+	unsigned auto_inval_data:1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 

commit 45c72cd73c788dd18c8113d4a404d6b4a01decf1
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu May 10 19:49:38 2012 +0400

    fuse: fix stat call on 32 bit platforms
    
    Now we store attr->ino at inode->i_ino, return attr->ino at the
    first time and then return inode->i_ino if the attribute timeout
    isn't expired. That's wrong on 32 bit platforms because attr->ino
    is 64 bit and inode->i_ino is 32 bit in this case.
    
    Fix this by saving 64 bit ino in fuse_inode structure and returning
    it every time we call getattr. Also squash attr->ino into inode->i_ino
    explicitly.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index f38fb795f03c..771fb6322c07 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -82,6 +82,9 @@ struct fuse_inode {
 	    preserve the original mode */
 	umode_t orig_i_mode;
 
+	/** 64 bit inode number */
+	u64 orig_ino;
+
 	/** Version of last attribute change */
 	u64 attr_version;
 

commit 519c6040ce04474bc893774f866fd8d907b20429
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Thu Apr 26 10:56:36 2012 +0200

    fuse: optimize fallocate on permanent failure
    
    If userspace filesystem doesn't support fallocate, remember this and don't send
    request next time.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 572cefc78012..f38fb795f03c 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -478,6 +478,9 @@ struct fuse_conn {
 	/** Are BSD file locking primitives not implemented by fs? */
 	unsigned no_flock:1;
 
+	/** Is fallocate not implemented by fs? */
+	unsigned no_fallocate:1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 

commit 6733e54b669c600eb8e451939ad55130db664fed
Merge: bcf8a3dfcb27 451d0f599934
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 12 12:39:21 2012 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/fuse
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/fuse:
      FUSE: Notifying the kernel of deletion.
      fuse: support ioctl on directories
      fuse: Use kcalloc instead of kzalloc to allocate array
      fuse: llseek optimize SEEK_CUR and SEEK_SET

commit 541af6a07474352e2143a0527c2b62b732439815
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 26 03:17:33 2011 -0400

    fuse: propagate umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index cf6db0a93219..1964da0257d9 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -80,7 +80,7 @@ struct fuse_inode {
 
 	/** The sticky bit in inode->i_mode may have been removed, so
 	    preserve the original mode */
-	mode_t orig_i_mode;
+	umode_t orig_i_mode;
 
 	/** Version of last attribute change */
 	u64 attr_version;

commit 451d0f599934fd97faf54a5d7954b518e66192cb
Author: John Muir <john@jmuir.com>
Date:   Tue Dec 6 21:50:06 2011 +0100

    FUSE: Notifying the kernel of deletion.
    
    Allows a FUSE file-system to tell the kernel when a file or directory is
    deleted. If the specified dentry has the specified inode number, the kernel will
    unhash it.
    
    The current 'fuse_notify_inval_entry' does not cause the kernel to clean up
    directories that are in use properly, and as a result the users of those
    directories see incorrect semantics from the file-system. The error condition
    seen when 'fuse_notify_inval_entry' is used to notify of a deleted directory is
    avoided when 'fuse_notify_delete' is used instead.
    
    The following scenario demonstrates the difference:
    1. User A chdirs into 'testdir' and starts reading 'testfile'.
    2. User B rm -rf 'testdir'.
    3. User B creates 'testdir'.
    4. User C chdirs into 'testdir'.
    
    If you run the above within the same machine on any file-system (including fuse
    file-systems), there is no problem: user C is able to chdir into the new
    testdir. The old testdir is removed from the dentry tree, but still open by user
    A.
    
    If operations 2 and 3 are performed via the network such that the fuse
    file-system uses one of the notify functions to tell the kernel that the nodes
    are gone, then the following error occurs for user C while user A holds the
    original directory open:
    
    muirj@empacher:~> ls /test/testdir
    ls: cannot access /test/testdir: No such file or directory
    
    The issue here is that the kernel still has a dentry for testdir, and so it is
    requesting the attributes for the old directory, while the file-system is
    responding that the directory no longer exists.
    
    If on the other hand, if the file-system can notify the kernel that the
    directory is deleted using the new 'fuse_notify_delete' function, then the above
    ls will find the new directory as expected.
    
    Signed-off-by: John Muir <john@jmuir.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 09337bcc2554..a571584a091a 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -755,9 +755,15 @@ int fuse_reverse_inval_inode(struct super_block *sb, u64 nodeid,
 /**
  * File-system tells the kernel to invalidate parent attributes and
  * the dentry matching parent/name.
+ *
+ * If the child_nodeid is non-zero and:
+ *    - matches the inode number for the dentry matching parent/name,
+ *    - is not a mount point
+ *    - is a file or oan empty directory
+ * then the dentry is unhashed (d_delete()).
  */
 int fuse_reverse_inval_entry(struct super_block *sb, u64 parent_nodeid,
-			     struct qstr *name);
+			     u64 child_nodeid, struct qstr *name);
 
 int fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,
 		 bool isdir);

commit b18da0c56e9ff43a007b6c8e302c62e720964151
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Dec 13 11:58:49 2011 +0100

    fuse: support ioctl on directories
    
    Multiplexing filesystems may want to support ioctls on the underlying
    files and directores (e.g. FS_IOC_{GET,SET}FLAGS).
    
    Ioctl support on directories was missing so add it now.
    
    Reported-by: Antonio SJ Musumeci <bile@landofbile.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index cf6db0a93219..09337bcc2554 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -765,6 +765,8 @@ ssize_t fuse_direct_io(struct file *file, const char __user *buf,
 		       size_t count, loff_t *ppos, int write);
 long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,
 		   unsigned int flags);
+long fuse_ioctl_common(struct file *file, unsigned int cmd,
+		       unsigned long arg, unsigned int flags);
 unsigned fuse_file_poll(struct file *file, poll_table *wait);
 int fuse_dev_release(struct inode *inode, struct file *file);
 

commit 051732bcbe3cff3fea04dc9042266562fe8b0859
Merge: 2983573e491d c2183d1e9b3f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 24 09:14:42 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/fuse
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/fuse:
      fuse: check size of FUSE_NOTIFY_INVAL_ENTRY message
      fuse: mark pages accessed when written to
      fuse: delete dead .write_begin and .write_end aops
      fuse: fix flock
      fuse: fix non-ANSI void function notation

commit 37fb3a30b46237f23cfdf7ee09d49f9888dd13bf
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Mon Aug 8 16:08:08 2011 +0200

    fuse: fix flock
    
    Commit a9ff4f87 "fuse: support BSD locking semantics" overlooked a
    number of issues with supporing flock locks over existing POSIX
    locking infrastructure:
    
      - it's not backward compatible, passing flock(2) calls to userspace
        unconditionally (if userspace sets FUSE_POSIX_LOCKS)
    
      - it doesn't cater for the fact that flock locks are automatically
        unlocked on file release
    
      - it doesn't take into account the fact that flock exclusive locks
        (write locks) don't need an fd opened for write.
    
    The last one invalidates the original premise of the patch that flock
    locks can be emulated with POSIX locks.
    
    This patch fixes the first two issues.  The last one needs to be fixed
    in userspace if the filesystem assumed that a write lock will happen
    only on a file operned for write (as in the case of the current fuse
    library).
    
    Reported-by: Sebastian Pipping <webmaster@hartwork.org>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index b788becada76..eb8c6135fbbf 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -135,6 +135,9 @@ struct fuse_file {
 
 	/** Wait queue head for poll */
 	wait_queue_head_t poll_wait;
+
+	/** Has flock been performed on this file? */
+	bool flock:1;
 };
 
 /** One input argument of a request */
@@ -448,7 +451,7 @@ struct fuse_conn {
 	/** Is removexattr not implemented by fs? */
 	unsigned no_removexattr:1;
 
-	/** Are file locking primitives not implemented by fs? */
+	/** Are posix file locking primitives not implemented by fs? */
 	unsigned no_lock:1;
 
 	/** Is access not implemented by fs? */
@@ -472,6 +475,9 @@ struct fuse_conn {
 	/** Don't apply umask to creation modes */
 	unsigned dont_mask:1;
 
+	/** Are BSD file locking primitives not implemented by fs? */
+	unsigned no_flock:1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 

commit 02c24a82187d5a628c68edfe71ae60dc135cd178
Author: Josef Bacik <josef@redhat.com>
Date:   Sat Jul 16 20:44:56 2011 -0400

    fs: push i_mutex and filemap_write_and_wait down into ->fsync() handlers
    
    Btrfs needs to be able to control how filemap_write_and_wait_range() is called
    in fsync to make it less of a painful operation, so push down taking i_mutex and
    the calling of filemap_write_and_wait() down into the ->fsync() handlers.  Some
    file systems can drop taking the i_mutex altogether it seems, like ext3 and
    ocfs2.  For correctness sake I just pushed everything down in all cases to make
    sure that we keep the current behavior the same for everybody, and then each
    individual fs maintainer can make up their mind about what to do from there.
    Thanks,
    
    Acked-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index b788becada76..c6aa2d4b8517 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -589,7 +589,8 @@ void fuse_release_common(struct file *file, int opcode);
 /**
  * Send FSYNC or FSYNCDIR request
  */
-int fuse_fsync_common(struct file *file, int datasync, int isdir);
+int fuse_fsync_common(struct file *file, loff_t start, loff_t end,
+		      int datasync, int isdir);
 
 /**
  * Notify poll wakeup

commit 07d5f69b457019eda4ca568923b1d62b7ada89e1
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Mon Mar 21 13:58:05 2011 +0100

    fuse: reduce size of struct fuse_request
    
    Reduce the size of struct fuse_request by removing cuse_init_out from
    the request structure and allocating it dinamically instead.
    
    CC: Tejun Heo <tj@kernel.org>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index d4286947bc2c..b788becada76 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -272,7 +272,6 @@ struct fuse_req {
 		struct fuse_init_in init_in;
 		struct fuse_init_out init_out;
 		struct cuse_init_in cuse_init_in;
-		struct cuse_init_out cuse_init_out;
 		struct {
 			struct fuse_read_in in;
 			u64 attr_ver;

commit 5a18ec176c934ca1bc9dc61580a5e0e90a9b5733
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Feb 25 14:44:58 2011 +0100

    fuse: fix hang of single threaded fuseblk filesystem
    
    Single threaded NTFS-3G could get stuck if a delayed RELEASE reply
    triggered a DESTROY request via path_put().
    
    Fix this by
    
     a) making RELEASE requests synchronous, whenever possible, on fuseblk
     filesystems
    
     b) if not possible (triggered by an asynchronous read/write) then do
     the path_put() in a separate thread with schedule_work().
    
    Reported-by: Oliver Neukum <oneukum@suse.de>
    Cc: stable@kernel.org
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index ae5744a2f9e9..d4286947bc2c 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -21,6 +21,7 @@
 #include <linux/rwsem.h>
 #include <linux/rbtree.h>
 #include <linux/poll.h>
+#include <linux/workqueue.h>
 
 /** Max number of pages that can be used in a single read request */
 #define FUSE_MAX_PAGES_PER_REQ 32
@@ -262,7 +263,10 @@ struct fuse_req {
 	/** Data for asynchronous requests */
 	union {
 		struct {
-			struct fuse_release_in in;
+			union {
+				struct fuse_release_in in;
+				struct work_struct work;
+			};
 			struct path path;
 		} release;
 		struct fuse_init_in init_in;

commit 02c048b919455aaa38628563cdcc2e691c8a9f53
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Dec 7 20:16:56 2010 +0100

    fuse: allow batching of FORGET requests
    
    Terje Malmedal reports that a fuse filesystem with 32 million inodes
    on a machine with lots of memory can take up to 30 minutes to process
    FORGET requests when all those inodes are evicted from the icache.
    
    To solve this, create a BATCH_FORGET request that allows up to about
    8000 FORGET requests to be sent in a single message.
    
    This request is only sent if userspace supports interface version 7.16
    or later, otherwise fall back to sending individual FORGET messages.
    
    Reported-by: Terje Malmedal <terje.malmedal@usit.uio.no>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 33369c63a522..ae5744a2f9e9 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -55,8 +55,7 @@ extern unsigned max_user_congthresh;
 
 /* One forget request */
 struct fuse_forget_link {
-	u64	nodeid;
-	u64	nlookup;
+	struct fuse_forget_one forget_one;
 	struct fuse_forget_link *next;
 };
 

commit 07e77dca8a1f17a724a9b7449f0ca02e70e9d057
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Dec 7 20:16:56 2010 +0100

    fuse: separate queue for FORGET requests
    
    Terje Malmedal reports that a fuse filesystem with 32 million inodes
    on a machine with lots of memory can go unresponsive for up to 30
    minutes when all those inodes are evicted from the icache.
    
    The reason is that FORGET messages, sent when the inode is evicted,
    are queued up together with regular filesystem requests, and while the
    huge queue of FORGET messages are processed no other filesystem
    operation can proceed.
    
    Since a full fuse request structure is allocated for each inode, these
    take up quite a bit of memory as well.
    
    To solve these issues, create a slim 'fuse_forget_link' structure
    containing just the minimum of information required to send the FORGET
    request and chain these on a separate queue.
    
    When userspace is asking for a request make sure that FORGET and
    non-FORGET requests are selected fairly: for each 8 non-FORGET allow
    16 FORGET requests.  This will make sure FORGETs do not pile up, yet
    other requests are also allowed to proceed while the queued FORGETs
    are processed.
    
    Reported-by: Terje Malmedal <terje.malmedal@usit.uio.no>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 57d4a3a0f102..33369c63a522 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -53,6 +53,13 @@ extern struct mutex fuse_mutex;
 extern unsigned max_user_bgreq;
 extern unsigned max_user_congthresh;
 
+/* One forget request */
+struct fuse_forget_link {
+	u64	nodeid;
+	u64	nlookup;
+	struct fuse_forget_link *next;
+};
+
 /** FUSE inode */
 struct fuse_inode {
 	/** Inode data */
@@ -66,7 +73,7 @@ struct fuse_inode {
 	u64 nlookup;
 
 	/** The request used for sending the FORGET message */
-	struct fuse_req *forget_req;
+	struct fuse_forget_link *forget;
 
 	/** Time in jiffies until the file attributes are valid */
 	u64 i_time;
@@ -255,7 +262,6 @@ struct fuse_req {
 
 	/** Data for asynchronous requests */
 	union {
-		struct fuse_forget_in forget_in;
 		struct {
 			struct fuse_release_in in;
 			struct path path;
@@ -369,6 +375,13 @@ struct fuse_conn {
 	/** Pending interrupts */
 	struct list_head interrupts;
 
+	/** Queue of pending forgets */
+	struct fuse_forget_link forget_list_head;
+	struct fuse_forget_link *forget_list_tail;
+
+	/** Batching of FORGET requests (positive indicates FORGET batch) */
+	int forget_batch;
+
 	/** Flag indicating if connection is blocked.  This will be
 	    the case before the INIT reply is received, and if there
 	    are too many outstading backgrounds requests */
@@ -543,8 +556,10 @@ int fuse_lookup_name(struct super_block *sb, u64 nodeid, struct qstr *name,
 /**
  * Send FORGET command
  */
-void fuse_send_forget(struct fuse_conn *fc, struct fuse_req *req,
-		      u64 nodeid, u64 nlookup);
+void fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,
+		       u64 nodeid, u64 nlookup);
+
+struct fuse_forget_link *fuse_alloc_forget(void);
 
 /**
  * Initialize READ or READDIR request
@@ -655,11 +670,6 @@ void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req);
  */
 void fuse_request_send(struct fuse_conn *fc, struct fuse_req *req);
 
-/**
- * Send a request with no reply
- */
-void fuse_request_send_noreply(struct fuse_conn *fc, struct fuse_req *req);
-
 /**
  * Send a request in the background
  */

commit 2d45ba381a74a743eeaa2b06c7c5c0d2bf73ba1a
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Mon Jul 12 14:41:40 2010 +0200

    fuse: add retrieve request
    
    Userspace filesystem can request data to be retrieved from the inode's
    mapping.  This request is synchronous and the retrieved data is queued
    as a new request.  If the write to the fuse device returns an error
    then the retrieve request was not completed and a reply will not be
    sent.
    
    Only present pages are returned in the retrieve reply.  Retrieving
    stops when it finds a non-present page and only data prior to that is
    returned.
    
    This request doesn't change the dirty state of pages.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 61267d8d527b..57d4a3a0f102 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -272,6 +272,7 @@ struct fuse_req {
 			struct fuse_write_in in;
 			struct fuse_write_out out;
 		} write;
+		struct fuse_notify_retrieve_in retrieve_in;
 		struct fuse_lk_in lk_in;
 	} misc;
 

commit a1d75f258230b75d46aecdf28b2e732413028863
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Mon Jul 12 14:41:40 2010 +0200

    fuse: add store request
    
    Userspace filesystem can request data to be stored in the inode's
    mapping.  This request is synchronous and has no reply.  If the write
    to the fuse device returns an error then the store request was not
    fully completed (but may have updated some pages).
    
    If the stored data overflows the current file size, then the size is
    extended, similarly to a write(2) on the filesystem.
    
    Pages which have been completely stored are marked uptodate.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 8f309f04064e..61267d8d527b 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -748,4 +748,6 @@ long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,
 unsigned fuse_file_poll(struct file *file, poll_table *wait);
 int fuse_dev_release(struct inode *inode, struct file *file);
 
+void fuse_write_update_size(struct inode *inode, loff_t pos);
+
 #endif /* _FS_FUSE_I_H */

commit 003386fff3e02e51cea882e60f7d28290113964c
Merge: 092405cdb66f 51921cb746f5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun May 30 09:16:14 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/fuse
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/fuse:
      mm: export generic_pipe_buf_*() to modules
      fuse: support splice() reading from fuse device
      fuse: allow splice to move pages
      mm: export remove_from_page_cache() to modules
      mm: export lru_cache_add_*() to modules
      fuse: support splice() writing to fuse device
      fuse: get page reference for readpages
      fuse: use get_user_pages_fast()
      fuse: remove unneeded variable

commit 7ea8085910ef3dd4f3cad6845aaa2b580d39b115
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed May 26 17:53:25 2010 +0200

    drop unused dentry argument to ->fsync
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 01cc462ff45d..2c0d14a86779 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -568,8 +568,7 @@ void fuse_release_common(struct file *file, int opcode);
 /**
  * Send FSYNC or FSYNCDIR request
  */
-int fuse_fsync_common(struct file *file, struct dentry *de, int datasync,
-		      int isdir);
+int fuse_fsync_common(struct file *file, int datasync, int isdir);
 
 /**
  * Notify poll wakeup

commit ce534fb052928ce556639d7ecf01cbf4e01321e1
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue May 25 15:06:07 2010 +0200

    fuse: allow splice to move pages
    
    When splicing buffers to the fuse device with SPLICE_F_MOVE, try to
    move pages from the pipe buffer into the page cache.  This allows
    populating the fuse filesystem's cache without ever touching the page
    contents, i.e. zero copy read capability.
    
    The following steps are performed when trying to move a page into the
    page cache:
    
     - buf->ops->confirm() to make sure the new page is uptodate
     - buf->ops->steal() to try to remove the new page from it's previous place
     - remove_from_page_cache() on the old page
     - add_to_page_cache_locked() on the new page
    
    If any of the above steps fail (non fatally) then the code falls back
    to copying the page.  In particular ->steal() will fail if there are
    external references (other than the page cache and the pipe buffer) to
    the page.
    
    Also since the remove_from_page_cache() + add_to_page_cache_locked()
    are non-atomic it is possible that the page cache is repopulated in
    between the two and add_to_page_cache_locked() will fail.  This could
    be fixed by creating a new atomic replace_page_cache_page() function.
    
    fuse_readpages_end() needed to be reworked so it works even if
    page->mapping is NULL for some or all pages which can happen if the
    add_to_page_cache_locked() failed.
    
    A number of sanity checks were added to make sure the stolen pages
    don't have weird flags set, etc...  These could be moved into generic
    splice/steal code.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 01cc462ff45d..9d0a51852d8a 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -177,6 +177,9 @@ struct fuse_out {
 	/** Zero partially or not copied pages */
 	unsigned page_zeroing:1;
 
+	/** Pages may be replaced with new ones */
+	unsigned page_replace:1;
+
 	/** Number or arguments */
 	unsigned numargs;
 

commit c08d3b0e33edce28e9cfa7b64f7fe5bdeeb29248
Author: npiggin@suse.de <npiggin@suse.de>
Date:   Fri Aug 21 02:35:06 2009 +1000

    truncate: use new helpers
    
    Update some fs code to make use of new helper functions introduced
    in the previous patch. Should be no significant change in behaviour
    (except CIFS now calls send_sig under i_lock, via inode_newsize_ok).
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Miklos Szeredi <miklos@szeredi.hu>
    Cc: linux-nfs@vger.kernel.org
    Cc: Trond.Myklebust@netapp.com
    Cc: linux-cifs-client@lists.samba.org
    Cc: sfrench@samba.org
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index fc9c79feb5f7..01cc462ff45d 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -606,8 +606,6 @@ void fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,
 void fuse_change_attributes_common(struct inode *inode, struct fuse_attr *attr,
 				   u64 attr_valid);
 
-void fuse_truncate(struct address_space *mapping, loff_t offset);
-
 /**
  * Initialize the client device
  */

commit 79a9d99434b104c562f30f21b75317667f444793
Author: Csaba Henk <csaba@gluster.com>
Date:   Wed Aug 26 19:18:24 2009 +0200

    fuse: add fusectl interface to max_background
    
    Make the max_background and congestion_threshold parameters of a FUSE
    mount tunable at runtime by adding the respective knobs to its directory
    within the fusectl filesystem.
    
    Signed-off-by: Csaba Henk <csaba@gluster.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 6bcfab04396f..fc9c79feb5f7 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -32,7 +32,7 @@
 #define FUSE_NAME_MAX 1024
 
 /** Number of dentries for each connection in the control filesystem */
-#define FUSE_CTL_NUM_DENTRIES 3
+#define FUSE_CTL_NUM_DENTRIES 5
 
 /** If the FUSE_DEFAULT_PERMISSIONS flag is given, the filesystem
     module will check permissions based on the file mode.  Otherwise no
@@ -49,6 +49,10 @@ extern struct list_head fuse_conn_list;
 /** Global mutex protecting fuse_conn_list and the control filesystem */
 extern struct mutex fuse_mutex;
 
+/** Module parameters */
+extern unsigned max_user_bgreq;
+extern unsigned max_user_congthresh;
+
 /** FUSE inode */
 struct fuse_inode {
 	/** Inode data */

commit 7a6d3c8b3049d07123628f2bf57127bba2cc878f
Author: Csaba Henk <csaba@gluster.com>
Date:   Wed Jul 1 17:28:41 2009 -0700

    fuse: make the number of max background requests and congestion threshold tunable
    
    The practical values for these limits depend on the design of the
    filesystem server so let userspace set them at initialization time.
    
    Signed-off-by: Csaba Henk <csaba@gluster.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 52b641fc0faf..6bcfab04396f 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -25,12 +25,6 @@
 /** Max number of pages that can be used in a single read request */
 #define FUSE_MAX_PAGES_PER_REQ 32
 
-/** Maximum number of outstanding background requests */
-#define FUSE_MAX_BACKGROUND 12
-
-/** Congestion starts at 75% of maximum */
-#define FUSE_CONGESTION_THRESHOLD (FUSE_MAX_BACKGROUND * 75 / 100)
-
 /** Bias for fi->writectr, meaning new writepages must not be sent */
 #define FUSE_NOWRITE INT_MIN
 
@@ -349,6 +343,12 @@ struct fuse_conn {
 	/** rbtree of fuse_files waiting for poll events indexed by ph */
 	struct rb_root polled_files;
 
+	/** Maximum number of outstanding background requests */
+	unsigned max_background;
+
+	/** Number of background requests at which congestion starts */
+	unsigned congestion_threshold;
+
 	/** Number of requests currently in the background */
 	unsigned num_background;
 

commit 3b463ae0c6264f70e5d4c0a9c46af20fed43c96e
Author: John Muir <muirj@nortel.com>
Date:   Sun May 31 11:13:57 2009 -0400

    fuse: invalidation reverse calls
    
    Add notification messages that allow the filesystem to invalidate VFS
    caches.
    
    Two notifications are added:
    
     1) inode invalidation
    
       - invalidate cached attributes
       - invalidate a range of pages in the page cache (this is optional)
    
     2) dentry invalidation
    
       - try to invalidate a subtree in the dentry cache
    
    Care must be taken while accessing the 'struct super_block' for the
    mount, as it can go away while an invalidation is in progress.  To
    prevent this, introduce a rw-semaphore, that is taken for read during
    the invalidation and taken for write in the ->kill_sb callback.
    
    Cc: Csaba Henk <csaba@gluster.com>
    Cc: Anand Avati <avati@zresearch.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index ede4f77b2d6c..52b641fc0faf 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -484,6 +484,12 @@ struct fuse_conn {
 
 	/** Called on final put */
 	void (*release)(struct fuse_conn *);
+
+	/** Super block for this connection. */
+	struct super_block *sb;
+
+	/** Read/write semaphore to hold when accessing sb. */
+	struct rw_semaphore killsb;
 };
 
 static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)
@@ -511,6 +517,11 @@ extern const struct file_operations fuse_dev_operations;
 
 extern const struct dentry_operations fuse_dentry_operations;
 
+/**
+ * Inode to nodeid comparison.
+ */
+int fuse_inode_eq(struct inode *inode, void *_nodeidp);
+
 /**
  * Get a filled in inode
  */
@@ -711,6 +722,19 @@ void fuse_release_nowrite(struct inode *inode);
 
 u64 fuse_get_attr_version(struct fuse_conn *fc);
 
+/**
+ * File-system tells the kernel to invalidate cache for the given node id.
+ */
+int fuse_reverse_inval_inode(struct super_block *sb, u64 nodeid,
+			     loff_t offset, loff_t len);
+
+/**
+ * File-system tells the kernel to invalidate parent attributes and
+ * the dentry matching parent/name.
+ */
+int fuse_reverse_inval_entry(struct super_block *sb, u64 parent_nodeid,
+			     struct qstr *name);
+
 int fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,
 		 bool isdir);
 ssize_t fuse_direct_io(struct file *file, const char __user *buf,

commit e0a43ddcc08c34dbd666d93600fd23914505f4aa
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Jun 30 20:12:23 2009 +0200

    fuse: allow umask processing in userspace
    
    This patch lets filesystems handle masking the file mode on creation.
    This is needed if filesystem is using ACLs.
    
     - The CREATE, MKDIR and MKNOD requests are extended with a "umask"
       parameter.
    
     - A new FUSE_DONT_MASK flag is added to the INIT request/reply.  With
       this the filesystem may request that the create mode is not masked.
    
    CC: Jean-Pierre André <jean-pierre.andre@wanadoo.fr>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index aaf2f9ff970e..ede4f77b2d6c 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -446,6 +446,9 @@ struct fuse_conn {
 	/** Do multi-page cached writes */
 	unsigned big_writes:1;
 
+	/** Don't apply umask to creation modes */
+	unsigned dont_mask:1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 

commit 08cbf542bf24fb0481a54526b177347ae4046f5e
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Apr 14 10:54:53 2009 +0900

    fuse: export symbols to be used by CUSE
    
    Export the following symbols for CUSE.
    
    fuse_conn_put()
    fuse_conn_get()
    fuse_conn_kill()
    fuse_send_init()
    fuse_do_open()
    fuse_sync_release()
    fuse_direct_io()
    fuse_do_ioctl()
    fuse_file_poll()
    fuse_request_alloc()
    fuse_get_req()
    fuse_put_request()
    fuse_request_send()
    fuse_abort_conn()
    fuse_dev_release()
    fuse_dev_operations
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 2efcf12b763a..aaf2f9ff970e 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -261,6 +261,8 @@ struct fuse_req {
 		} release;
 		struct fuse_init_in init_in;
 		struct fuse_init_out init_out;
+		struct cuse_init_in cuse_init_in;
+		struct cuse_init_out cuse_init_out;
 		struct {
 			struct fuse_read_in in;
 			u64 attr_ver;
@@ -662,6 +664,8 @@ void fuse_invalidate_entry_cache(struct dentry *entry);
  */
 struct fuse_conn *fuse_conn_get(struct fuse_conn *fc);
 
+void fuse_conn_kill(struct fuse_conn *fc);
+
 /**
  * Initialize fuse_conn
  */
@@ -704,4 +708,13 @@ void fuse_release_nowrite(struct inode *inode);
 
 u64 fuse_get_attr_version(struct fuse_conn *fc);
 
+int fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,
+		 bool isdir);
+ssize_t fuse_direct_io(struct file *file, const char __user *buf,
+		       size_t count, loff_t *ppos, int write);
+long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,
+		   unsigned int flags);
+unsigned fuse_file_poll(struct file *file, poll_table *wait);
+int fuse_dev_release(struct inode *inode, struct file *file);
+
 #endif /* _FS_FUSE_I_H */

commit a325f9b92273d6c64ec56167905b951b9827ec33
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Apr 14 10:54:52 2009 +0900

    fuse: update fuse_conn_init() and separate out fuse_conn_kill()
    
    Update fuse_conn_init() such that it doesn't take @sb and move bdi
    registration into a separate function.  Also separate out
    fuse_conn_kill() from fuse_put_super().
    
    These will be used to implement cuse.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index ef2e1f3780b5..2efcf12b763a 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -394,6 +394,9 @@ struct fuse_conn {
 	/** Filesystem supports NFS exporting.  Only set in INIT */
 	unsigned export_support:1;
 
+	/** Set if bdi is valid */
+	unsigned bdi_initialized:1;
+
 	/*
 	 * The following bitfields are only for optimization purposes
 	 * and hence races in setting them will not cause malfunction
@@ -662,7 +665,7 @@ struct fuse_conn *fuse_conn_get(struct fuse_conn *fc);
 /**
  * Initialize fuse_conn
  */
-int fuse_conn_init(struct fuse_conn *fc, struct super_block *sb);
+void fuse_conn_init(struct fuse_conn *fc);
 
 /**
  * Release reference to fuse_conn

commit 8b0797a4984de4406de25808e1a424344de543e4
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Apr 28 16:56:39 2009 +0200

    fuse: don't use inode in fuse_sync_release()
    
    Make fuse_sync_release() a generic helper function that doesn't need a
    struct inode pointer.  This makes it suitable for use by CUSE.
    
    Change return value of fuse_release_common() from int to void.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 429e669d7859..ef2e1f3780b5 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -535,13 +535,12 @@ struct fuse_file *fuse_file_get(struct fuse_file *ff);
 void fuse_file_free(struct fuse_file *ff);
 void fuse_finish_open(struct inode *inode, struct file *file);
 
-/** Fill in ff->reserved_req with a RELEASE request */
-void fuse_release_fill(struct fuse_file *ff, int flags, int opcode);
+void fuse_sync_release(struct fuse_file *ff, int flags);
 
 /**
  * Send RELEASE or RELEASEDIR request
  */
-int fuse_release_common(struct inode *inode, struct file *file, int isdir);
+void fuse_release_common(struct file *file, int opcode);
 
 /**
  * Send FSYNC or FSYNCDIR request

commit 91fe96b403f8a0a4a8a045a39b1bd549b0da7941
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Apr 28 16:56:37 2009 +0200

    fuse: create fuse_do_open() helper for CUSE
    
    Create a helper for sending an OPEN request that doesn't need a struct
    inode pointer.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index ce46c120f48a..429e669d7859 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -528,7 +528,7 @@ void fuse_read_fill(struct fuse_req *req, struct file *file,
 /**
  * Send OPEN or OPENDIR request
  */
-int fuse_open_common(struct inode *inode, struct file *file, int isdir);
+int fuse_open_common(struct inode *inode, struct file *file, bool isdir);
 
 struct fuse_file *fuse_file_alloc(struct fuse_conn *fc);
 struct fuse_file *fuse_file_get(struct fuse_file *ff);

commit c7b7143c6342b8751d47b03a025ac5c0ac1ae809
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Apr 28 16:56:37 2009 +0200

    fuse: clean up args in fuse_finish_open() and fuse_release_fill()
    
    Move setting ff->fh, ff->nodeid and file->private_data outside
    fuse_finish_open().  Add ->open_flags member to struct fuse_file.
    
    This simplifies the argument passing to fuse_finish_open() and
    fuse_release_fill(), and paves the way for creating an open helper
    that doesn't need an inode pointer.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index a51f63c7d423..ce46c120f48a 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -119,6 +119,9 @@ struct fuse_file {
 	/** Refcount */
 	atomic_t count;
 
+	/** FOPEN_* flags returned by open */
+	u32 open_flags;
+
 	/** Entry on inode's write_files list */
 	struct list_head write_entry;
 
@@ -528,12 +531,12 @@ void fuse_read_fill(struct fuse_req *req, struct file *file,
 int fuse_open_common(struct inode *inode, struct file *file, int isdir);
 
 struct fuse_file *fuse_file_alloc(struct fuse_conn *fc);
+struct fuse_file *fuse_file_get(struct fuse_file *ff);
 void fuse_file_free(struct fuse_file *ff);
-void fuse_finish_open(struct inode *inode, struct file *file,
-		      struct fuse_file *ff, struct fuse_open_out *outarg);
+void fuse_finish_open(struct inode *inode, struct file *file);
 
 /** Fill in ff->reserved_req with a RELEASE request */
-void fuse_release_fill(struct fuse_file *ff, u64 nodeid, int flags, int opcode);
+void fuse_release_fill(struct fuse_file *ff, int flags, int opcode);
 
 /**
  * Send RELEASE or RELEASEDIR request

commit 2106cb18930312af9325d3418e138569c5b903cc
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Apr 28 16:56:37 2009 +0200

    fuse: don't use inode in helpers called by fuse_direct_io()
    
    Use ff->fc and ff->nodeid instead of passing down the inode.
    
    This prepares this function for use by CUSE, where the inode is not
    owned by a fuse filesystem.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 4469d9971588..a51f63c7d423 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -520,7 +520,7 @@ void fuse_send_forget(struct fuse_conn *fc, struct fuse_req *req,
  * Initialize READ or READDIR request
  */
 void fuse_read_fill(struct fuse_req *req, struct file *file,
-		    struct inode *inode, loff_t pos, size_t count, int opcode);
+		    loff_t pos, size_t count, int opcode);
 
 /**
  * Send OPEN or OPENDIR request

commit da5e4714578ff323f7a61af490fc3539e68f188b
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Apr 28 16:56:36 2009 +0200

    fuse: add members to struct fuse_file
    
    Add new members ->fc and ->nodeid to struct fuse_file.  This will aid
    in converting functions for use by CUSE, where the inode is not owned
    by a fuse filesystem.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 146317ff81b9..4469d9971588 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -97,8 +97,13 @@ struct fuse_inode {
 	struct list_head writepages;
 };
 
+struct fuse_conn;
+
 /** FUSE specific file data */
 struct fuse_file {
+	/** Fuse connection for this file */
+	struct fuse_conn *fc;
+
 	/** Request reserved for flush and release */
 	struct fuse_req *reserved_req;
 
@@ -108,6 +113,9 @@ struct fuse_file {
 	/** File handle used by userspace */
 	u64 fh;
 
+	/** Node id of this file */
+	u64 nodeid;
+
 	/** Refcount */
 	atomic_t count;
 
@@ -185,8 +193,6 @@ enum fuse_req_state {
 	FUSE_REQ_FINISHED
 };
 
-struct fuse_conn;
-
 /**
  * A request to the client
  */

commit b0be46ebf72ca7478c1c4bd0153c42f90e768a03
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Apr 28 16:56:36 2009 +0200

    fuse: use struct path in release structure
    
    Use struct path instead of separate dentry and vfsmount in
    req->misc.release.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 6fc5aedaa0d5..146317ff81b9 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -248,8 +248,7 @@ struct fuse_req {
 		struct fuse_forget_in forget_in;
 		struct {
 			struct fuse_release_in in;
-			struct vfsmount *vfsmount;
-			struct dentry *dentry;
+			struct path path;
 		} release;
 		struct fuse_init_in init_in;
 		struct fuse_init_out init_out;

commit 4269590a72934bb901b33b686e20605bf66653c4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Feb 20 05:59:13 2009 +0000

    constify dentry_operations: FUSE
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 5e64b815a5a1..6fc5aedaa0d5 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -493,7 +493,7 @@ static inline u64 get_node_id(struct inode *inode)
 /** Device operations */
 extern const struct file_operations fuse_dev_operations;
 
-extern struct dentry_operations fuse_dentry_operations;
+extern const struct dentry_operations fuse_dentry_operations;
 
 /**
  * Get a filled in inode

commit 43901aabd7a043e62e24e9459dc4949b4cd69f07
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Nov 26 12:03:56 2008 +0100

    fuse: add fuse_conn->release()
    
    Add fuse_conn->release() so that fuse_conn can be embedded in other
    structures.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index eb488d48b833..5e64b815a5a1 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -465,6 +465,9 @@ struct fuse_conn {
 
 	/** Version counter for attribute changes */
 	u64 attr_version;
+
+	/** Called on final put */
+	void (*release)(struct fuse_conn *);
 };
 
 static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)

commit 0d179aa59285ceef529c125e181cbb79ff5245c2
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Nov 26 12:03:55 2008 +0100

    fuse: separate out fuse_conn_init() from new_conn()
    
    Separate out fuse_conn_init() from new_conn() and while at it
    initialize fuse_conn->entry during conn initialization.
    
    This will be used by CUSE.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index c08e7e890923..eb488d48b833 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -649,6 +649,11 @@ void fuse_invalidate_entry_cache(struct dentry *entry);
  */
 struct fuse_conn *fuse_conn_get(struct fuse_conn *fc);
 
+/**
+ * Initialize fuse_conn
+ */
+int fuse_conn_init(struct fuse_conn *fc, struct super_block *sb);
+
 /**
  * Release reference to fuse_conn
  */

commit b93f858ab2a4bee779c360002f313ad6c3504cdc
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Nov 26 12:03:55 2008 +0100

    fuse: add fuse_ prefix to several functions
    
    Add fuse_ prefix to request_send*() and get_root_inode() as some of
    those functions will be exported for CUSE.  With or without CUSE
    export, having the function names scoped is a good idea for
    debuggability.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 986fbd4c1ff5..c08e7e890923 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -619,19 +619,20 @@ void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req);
 /**
  * Send a request (synchronous)
  */
-void request_send(struct fuse_conn *fc, struct fuse_req *req);
+void fuse_request_send(struct fuse_conn *fc, struct fuse_req *req);
 
 /**
  * Send a request with no reply
  */
-void request_send_noreply(struct fuse_conn *fc, struct fuse_req *req);
+void fuse_request_send_noreply(struct fuse_conn *fc, struct fuse_req *req);
 
 /**
  * Send a request in the background
  */
-void request_send_background(struct fuse_conn *fc, struct fuse_req *req);
+void fuse_request_send_background(struct fuse_conn *fc, struct fuse_req *req);
 
-void request_send_background_locked(struct fuse_conn *fc, struct fuse_req *req);
+void fuse_request_send_background_locked(struct fuse_conn *fc,
+					 struct fuse_req *req);
 
 /* Abort all requests */
 void fuse_abort_conn(struct fuse_conn *fc);

commit 95668a69a4bb862063c4d28a746e55107dee7b98
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Nov 26 12:03:55 2008 +0100

    fuse: implement poll support
    
    Implement poll support.  Polled files are indexed using kh in a RB
    tree rooted at fuse_conn->polled_files.
    
    Client should send FUSE_NOTIFY_POLL notification once after processing
    FUSE_POLL which has FUSE_POLL_SCHEDULE_NOTIFY set.  Sending
    notification unconditionally after the latest poll or everytime file
    content might have changed is inefficient but won't cause malfunction.
    
    fuse_file_poll() can sleep and requires patches from the following
    thread which allows f_op->poll() to sleep.
    
      http://thread.gmane.org/gmane.linux.kernel/726176
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 86f013303828..986fbd4c1ff5 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -19,6 +19,8 @@
 #include <linux/backing-dev.h>
 #include <linux/mutex.h>
 #include <linux/rwsem.h>
+#include <linux/rbtree.h>
+#include <linux/poll.h>
 
 /** Max number of pages that can be used in a single read request */
 #define FUSE_MAX_PAGES_PER_REQ 32
@@ -111,6 +113,12 @@ struct fuse_file {
 
 	/** Entry on inode's write_files list */
 	struct list_head write_entry;
+
+	/** RB node to be linked on fuse_conn->polled_files */
+	struct rb_node polled_node;
+
+	/** Wait queue head for poll */
+	wait_queue_head_t poll_wait;
 };
 
 /** One input argument of a request */
@@ -328,6 +336,9 @@ struct fuse_conn {
 	/** The next unique kernel file handle */
 	u64 khctr;
 
+	/** rbtree of fuse_files waiting for poll events indexed by ph */
+	struct rb_root polled_files;
+
 	/** Number of requests currently in the background */
 	unsigned num_background;
 
@@ -416,6 +427,9 @@ struct fuse_conn {
 	/** Is bmap not implemented by fs? */
 	unsigned no_bmap:1;
 
+	/** Is poll not implemented by fs? */
+	unsigned no_poll:1;
+
 	/** Do multi-page cached writes */
 	unsigned big_writes:1;
 
@@ -524,6 +538,12 @@ int fuse_release_common(struct inode *inode, struct file *file, int isdir);
 int fuse_fsync_common(struct file *file, struct dentry *de, int datasync,
 		      int isdir);
 
+/**
+ * Notify poll wakeup
+ */
+int fuse_notify_poll_wakeup(struct fuse_conn *fc,
+			    struct fuse_notify_poll_wakeup_out *outarg);
+
 /**
  * Initialize file operations on a regular file
  */

commit acf99433d98c2570a619d8fb8b51abce4e532059
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Nov 26 12:03:55 2008 +0100

    fuse: add file kernel handle
    
    The file handle, fuse_file->fh, is opaque value supplied by userland
    FUSE server and uniqueness is not guaranteed.  Add file kernel handle,
    fuse_file->kh, which is allocated by the kernel on file allocation and
    guaranteed to be unique.
    
    This will be used by poll to match notification to the respective file
    but can be used for other purposes where unique file handle is
    necessary.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 4fc5131f5c9d..86f013303828 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -100,6 +100,9 @@ struct fuse_file {
 	/** Request reserved for flush and release */
 	struct fuse_req *reserved_req;
 
+	/** Kernel file handle guaranteed to be unique */
+	u64 kh;
+
 	/** File handle used by userspace */
 	u64 fh;
 
@@ -322,6 +325,9 @@ struct fuse_conn {
 	/** The list of requests under I/O */
 	struct list_head io;
 
+	/** The next unique kernel file handle */
+	u64 khctr;
+
 	/** Number of requests currently in the background */
 	unsigned num_background;
 
@@ -499,7 +505,7 @@ void fuse_read_fill(struct fuse_req *req, struct file *file,
  */
 int fuse_open_common(struct inode *inode, struct file *file, int isdir);
 
-struct fuse_file *fuse_file_alloc(void);
+struct fuse_file *fuse_file_alloc(struct fuse_conn *fc);
 void fuse_file_free(struct fuse_file *ff);
 void fuse_finish_open(struct inode *inode, struct file *file,
 		      struct fuse_file *ff, struct fuse_open_out *outarg);

commit 1729a16c2c92bbd9e54ac7cad3101fea2e073aa5
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Nov 26 12:03:54 2008 +0100

    fuse: style fixes
    
    Fix coding style errors reported by checkpatch and others.  Uptdate
    copyright date to 2008.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 35accfdd747f..4fc5131f5c9d 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -1,6 +1,6 @@
 /*
   FUSE: Filesystem in Userspace
-  Copyright (C) 2001-2006  Miklos Szeredi <miklos@szeredi.hu>
+  Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>
 
   This program can be distributed under the terms of the GNU GPL.
   See the file COPYING.
@@ -355,19 +355,19 @@ struct fuse_conn {
 	/** Connection failed (version mismatch).  Cannot race with
 	    setting other bitfields since it is only set once in INIT
 	    reply, before any other request, and never cleared */
-	unsigned conn_error : 1;
+	unsigned conn_error:1;
 
 	/** Connection successful.  Only set in INIT */
-	unsigned conn_init : 1;
+	unsigned conn_init:1;
 
 	/** Do readpages asynchronously?  Only set in INIT */
-	unsigned async_read : 1;
+	unsigned async_read:1;
 
 	/** Do not send separate SETATTR request before open(O_TRUNC)  */
-	unsigned atomic_o_trunc : 1;
+	unsigned atomic_o_trunc:1;
 
 	/** Filesystem supports NFS exporting.  Only set in INIT */
-	unsigned export_support : 1;
+	unsigned export_support:1;
 
 	/*
 	 * The following bitfields are only for optimization purposes
@@ -375,43 +375,43 @@ struct fuse_conn {
 	 */
 
 	/** Is fsync not implemented by fs? */
-	unsigned no_fsync : 1;
+	unsigned no_fsync:1;
 
 	/** Is fsyncdir not implemented by fs? */
-	unsigned no_fsyncdir : 1;
+	unsigned no_fsyncdir:1;
 
 	/** Is flush not implemented by fs? */
-	unsigned no_flush : 1;
+	unsigned no_flush:1;
 
 	/** Is setxattr not implemented by fs? */
-	unsigned no_setxattr : 1;
+	unsigned no_setxattr:1;
 
 	/** Is getxattr not implemented by fs? */
-	unsigned no_getxattr : 1;
+	unsigned no_getxattr:1;
 
 	/** Is listxattr not implemented by fs? */
-	unsigned no_listxattr : 1;
+	unsigned no_listxattr:1;
 
 	/** Is removexattr not implemented by fs? */
-	unsigned no_removexattr : 1;
+	unsigned no_removexattr:1;
 
 	/** Are file locking primitives not implemented by fs? */
-	unsigned no_lock : 1;
+	unsigned no_lock:1;
 
 	/** Is access not implemented by fs? */
-	unsigned no_access : 1;
+	unsigned no_access:1;
 
 	/** Is create not implemented by fs? */
-	unsigned no_create : 1;
+	unsigned no_create:1;
 
 	/** Is interrupt not implemented by fs? */
-	unsigned no_interrupt : 1;
+	unsigned no_interrupt:1;
 
 	/** Is bmap not implemented by fs? */
-	unsigned no_bmap : 1;
+	unsigned no_bmap:1;
 
 	/** Do multi-page cached writes */
-	unsigned big_writes : 1;
+	unsigned big_writes:1;
 
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;

commit 29d434b39c807320fbe4bcdce0ab98a0b9fcb285
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Oct 16 16:08:57 2008 +0200

    fuse: add include protectors
    
    Add include protectors to include/linux/fuse.h and fs/fuse/fuse_i.h.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 3a876076bdd1..35accfdd747f 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -6,6 +6,9 @@
   See the file COPYING.
 */
 
+#ifndef _FS_FUSE_I_H
+#define _FS_FUSE_I_H
+
 #include <linux/fuse.h>
 #include <linux/fs.h>
 #include <linux/mount.h>
@@ -655,3 +658,5 @@ void fuse_set_nowrite(struct inode *inode);
 void fuse_release_nowrite(struct inode *inode);
 
 u64 fuse_get_attr_version(struct fuse_conn *fc);
+
+#endif /* _FS_FUSE_I_H */

commit 33670fa296860283f04a7975b8c790f101e43a6e
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Jul 25 01:49:02 2008 -0700

    fuse: nfs export special lookups
    
    Implement the get_parent export operation by sending a LOOKUP request with
    ".." as the name.
    
    Implement looking up an inode by node ID after it has been evicted from
    the cache.  This is done by seding a LOOKUP request with "." as the name
    (for all file types, not just directories).
    
    The filesystem can set the FUSE_EXPORT_SUPPORT flag in the INIT reply, to
    indicate that it supports these special lookups.
    
    Thanks to John Muir for the original implementation of this feature.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: David Teigland <teigland@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 5d3146da64e6..3a876076bdd1 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -363,6 +363,9 @@ struct fuse_conn {
 	/** Do not send separate SETATTR request before open(O_TRUNC)  */
 	unsigned atomic_o_trunc : 1;
 
+	/** Filesystem supports NFS exporting.  Only set in INIT */
+	unsigned export_support : 1;
+
 	/*
 	 * The following bitfields are only for optimization purposes
 	 * and hence races in setting them will not cause malfunction
@@ -473,6 +476,9 @@ struct inode *fuse_iget(struct super_block *sb, u64 nodeid,
 			int generation, struct fuse_attr *attr,
 			u64 attr_valid, u64 attr_version);
 
+int fuse_lookup_name(struct super_block *sb, u64 nodeid, struct qstr *name,
+		     struct fuse_entry_out *outarg, struct inode **inode);
+
 /**
  * Send FORGET command
  */

commit dbd561d236ff16f8143bc727d91758ddd190e8cb
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Jul 25 01:49:00 2008 -0700

    fuse: add export operations
    
    Implement export_operations, to allow fuse filesystems to be exported to
    NFS.  This feature has been in the out-of-tree fuse module, and is widely
    used and tested.
    
    It has not been originally merged into mainline, because doing the NFS
    export in userspace was thought to be a cleaner and more efficient way of
    doing it, than through the kernel.
    
    While that is true, it would also have involved a lot of duplicated effort
    at reimplementing NFS exporting (all the different versions of the
    protocol).  This effort was unfortunately not undertaken by anyone, so we
    are left with doing it the easy but less efficient way.
    
    If this feature goes in, the out-of-tree fuse module can go away,
    which would have several advantages:
    
      - not having to maintain two versions
      - less confusion for users
      - no bugs due to kernel API changes
    
    Comment from hch:
     - Use the same fh_type values as XFS, since we use the same fh encoding.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index bae948657c4f..5d3146da64e6 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -464,6 +464,8 @@ static inline u64 get_node_id(struct inode *inode)
 /** Device operations */
 extern const struct file_operations fuse_dev_operations;
 
+extern struct dentry_operations fuse_dentry_operations;
+
 /**
  * Get a filled in inode
  */
@@ -604,6 +606,8 @@ void fuse_abort_conn(struct fuse_conn *fc);
  */
 void fuse_invalidate_attr(struct inode *inode);
 
+void fuse_invalidate_entry_cache(struct dentry *entry);
+
 /**
  * Acquire reference to fuse_conn
  */

commit 78bb6cb9a890d3d50ca3b02fce9223d3e734ab9b
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Mon May 12 14:02:32 2008 -0700

    fuse: add flag to turn on big writes
    
    Prior to 2.6.26 fuse only supported single page write requests.  In theory all
    fuse filesystem should be able support bigger than 4k writes, as there's
    nothing in the API to prevent it.  Unfortunately there's a known case in
    NTFS-3G where big writes cause filesystem corruption.  There could also be
    other filesystems, where the lack of testing with big write requests would
    result in bugs.
    
    To prevent such problems on a kernel upgrade, disable big writes by default,
    but let filesystems set a flag to turn it on.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Cc: Szabolcs Szakacsits <szaka@ntfs-3g.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index dadffa21a206..bae948657c4f 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -404,6 +404,9 @@ struct fuse_conn {
 	/** Is bmap not implemented by fs? */
 	unsigned no_bmap : 1;
 
+	/** Do multi-page cached writes */
+	unsigned big_writes : 1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 

commit b48badf013018ef2aa4a46416454bdb18f77fb01
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Apr 30 00:54:44 2008 -0700

    fuse: fix node ID type
    
    Node ID is 64bit but it is passed as unsigned long to some functions.  This
    breakage wasn't noticed, because libfuse uses unsigned long too.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 934dd819a4ef..dadffa21a206 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -464,7 +464,7 @@ extern const struct file_operations fuse_dev_operations;
 /**
  * Get a filled in inode
  */
-struct inode *fuse_iget(struct super_block *sb, unsigned long nodeid,
+struct inode *fuse_iget(struct super_block *sb, u64 nodeid,
 			int generation, struct fuse_attr *attr,
 			u64 attr_valid, u64 attr_version);
 
@@ -472,7 +472,7 @@ struct inode *fuse_iget(struct super_block *sb, unsigned long nodeid,
  * Send FORGET command
  */
 void fuse_send_forget(struct fuse_conn *fc, struct fuse_req *req,
-		      unsigned long nodeid, u64 nlookup);
+		      u64 nodeid, u64 nlookup);
 
 /**
  * Initialize READ or READDIR request

commit 5c5c5e51b26413d50a9efae2ca7d6c5c6cd453ac
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Apr 30 00:54:43 2008 -0700

    fuse: update file size on short read
    
    If the READ request returned a short count, then either
    
      - cached size is incorrect
      - filesystem is buggy, as short reads are only allowed on EOF
    
    So assume that the size is wrong and refresh it, so that cached read() doesn't
    zero fill the missing chunk.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 4b094fbc9c7f..934dd819a4ef 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -239,7 +239,10 @@ struct fuse_req {
 		} release;
 		struct fuse_init_in init_in;
 		struct fuse_init_out init_out;
-		struct fuse_read_in read_in;
+		struct {
+			struct fuse_read_in in;
+			u64 attr_ver;
+		} read;
 		struct {
 			struct fuse_write_in in;
 			struct fuse_write_out out;
@@ -637,3 +640,5 @@ void fuse_flush_writepages(struct inode *inode);
 
 void fuse_set_nowrite(struct inode *inode);
 void fuse_release_nowrite(struct inode *inode);
+
+u64 fuse_get_attr_version(struct fuse_conn *fc);

commit 3be5a52b30aa5cf9d795b7634f728f612197b1c4
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Apr 30 00:54:41 2008 -0700

    fuse: support writable mmap
    
    Quoting Linus (3 years ago, FUSE inclusion discussions):
    
      "User-space filesystems are hard to get right. I'd claim that they
       are almost impossible, unless you limit them somehow (shared
       writable mappings are the nastiest part - if you don't have those,
       you can reasonably limit your problems by limiting the number of
       dirty pages you accept through normal "write()" calls)."
    
    Instead of attempting the impossible, I've just waited for the dirty page
    accounting infrastructure to materialize (thanks to Peter Zijlstra and
    others).  This nicely solved the biggest problem: limiting the number of pages
    used for write caching.
    
    Some small details remained, however, which this largish patch attempts to
    address.  It provides a page writeback implementation for fuse, which is
    completely safe against VM related deadlocks.  Performance may not be very
    good for certain usage patterns, but generally it should be acceptable.
    
    It has been tested extensively with fsx-linux and bash-shared-mapping.
    
    Fuse page writeback design
    --------------------------
    
    fuse_writepage() allocates a new temporary page with GFP_NOFS|__GFP_HIGHMEM.
    It copies the contents of the original page, and queues a WRITE request to the
    userspace filesystem using this temp page.
    
    The writeback is finished instantly from the MM's point of view: the page is
    removed from the radix trees, and the PageDirty and PageWriteback flags are
    cleared.
    
    For the duration of the actual write, the NR_WRITEBACK_TEMP counter is
    incremented.  The per-bdi writeback count is not decremented until the actual
    write completes.
    
    On dirtying the page, fuse waits for a previous write to finish before
    proceeding.  This makes sure, there can only be one temporary page used at a
    time for one cached page.
    
    This approach is wasteful in both memory and CPU bandwidth, so why is this
    complication needed?
    
    The basic problem is that there can be no guarantee about the time in which
    the userspace filesystem will complete a write.  It may be buggy or even
    malicious, and fail to complete WRITE requests.  We don't want unrelated parts
    of the system to grind to a halt in such cases.
    
    Also a filesystem may need additional resources (particularly memory) to
    complete a WRITE request.  There's a great danger of a deadlock if that
    allocation may wait for the writepage to finish.
    
    Currently there are several cases where the kernel can block on page
    writeback:
    
      - allocation order is larger than PAGE_ALLOC_COSTLY_ORDER
      - page migration
      - throttle_vm_writeout (through NR_WRITEBACK)
      - sync(2)
    
    Of course in some cases (fsync, msync) we explicitly want to allow blocking.
    So for these cases new code has to be added to fuse, since the VM is not
    tracking writeback pages for us any more.
    
    As an extra safetly measure, the maximum dirty ratio allocated to a single
    fuse filesystem is set to 1% by default.  This way one (or several) buggy or
    malicious fuse filesystems cannot slow down the rest of the system by hogging
    dirty memory.
    
    With appropriate privileges, this limit can be raised through
    '/sys/class/bdi/<bdi>/max_ratio'.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index c0481e48d161..4b094fbc9c7f 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -15,6 +15,7 @@
 #include <linux/mm.h>
 #include <linux/backing-dev.h>
 #include <linux/mutex.h>
+#include <linux/rwsem.h>
 
 /** Max number of pages that can be used in a single read request */
 #define FUSE_MAX_PAGES_PER_REQ 32
@@ -25,6 +26,9 @@
 /** Congestion starts at 75% of maximum */
 #define FUSE_CONGESTION_THRESHOLD (FUSE_MAX_BACKGROUND * 75 / 100)
 
+/** Bias for fi->writectr, meaning new writepages must not be sent */
+#define FUSE_NOWRITE INT_MIN
+
 /** It could be as large as PATH_MAX, but would that have any uses? */
 #define FUSE_NAME_MAX 1024
 
@@ -73,6 +77,19 @@ struct fuse_inode {
 
 	/** Files usable in writepage.  Protected by fc->lock */
 	struct list_head write_files;
+
+	/** Writepages pending on truncate or fsync */
+	struct list_head queued_writes;
+
+	/** Number of sent writes, a negative bias (FUSE_NOWRITE)
+	 * means more writes are blocked */
+	int writectr;
+
+	/** Waitq for writepage completion */
+	wait_queue_head_t page_waitq;
+
+	/** List of writepage requestst (pending or sent) */
+	struct list_head writepages;
 };
 
 /** FUSE specific file data */
@@ -242,6 +259,12 @@ struct fuse_req {
 	/** File used in the request (or NULL) */
 	struct fuse_file *ff;
 
+	/** Inode used in the request or NULL */
+	struct inode *inode;
+
+	/** Link on fi->writepages */
+	struct list_head writepages_entry;
+
 	/** Request completion callback */
 	void (*end)(struct fuse_conn *, struct fuse_req *);
 
@@ -504,6 +527,11 @@ void fuse_init_symlink(struct inode *inode);
 void fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,
 			    u64 attr_valid, u64 attr_version);
 
+void fuse_change_attributes_common(struct inode *inode, struct fuse_attr *attr,
+				   u64 attr_valid);
+
+void fuse_truncate(struct address_space *mapping, loff_t offset);
+
 /**
  * Initialize the client device
  */
@@ -522,6 +550,8 @@ void fuse_ctl_cleanup(void);
  */
 struct fuse_req *fuse_request_alloc(void);
 
+struct fuse_req *fuse_request_alloc_nofs(void);
+
 /**
  * Free a request
  */
@@ -558,6 +588,8 @@ void request_send_noreply(struct fuse_conn *fc, struct fuse_req *req);
  */
 void request_send_background(struct fuse_conn *fc, struct fuse_req *req);
 
+void request_send_background_locked(struct fuse_conn *fc, struct fuse_req *req);
+
 /* Abort all requests */
 void fuse_abort_conn(struct fuse_conn *fc);
 
@@ -600,3 +632,8 @@ u64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id);
 
 int fuse_update_attributes(struct inode *inode, struct kstat *stat,
 			   struct file *file, bool *refreshed);
+
+void fuse_flush_writepages(struct inode *inode);
+
+void fuse_set_nowrite(struct inode *inode);
+void fuse_release_nowrite(struct inode *inode);

commit b6f2fcbcfca9db2bd7aa24940224fcd3bbdbb8aa
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Apr 30 00:54:34 2008 -0700

    mm: bdi: expose the BDI object in sysfs for FUSE
    
    Register FUSE's backing_dev_info under sysfs with the name "fuse-MAJOR:MINOR"
    
    Make the fuse control filesystem use s_dev instead of a fuse specific ID.
    This makes it easier to match directories under /sys/fs/fuse/connections/ with
    directories under /sys/class/bdi, and with actual mounts.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 67aaf6ee38ea..c0481e48d161 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -390,8 +390,8 @@ struct fuse_conn {
 	/** Entry on the fuse_conn_list */
 	struct list_head entry;
 
-	/** Unique ID */
-	u64 id;
+	/** Device ID from super block */
+	dev_t dev;
 
 	/** Dentries in the control filesystem */
 	struct dentry *ctl_dentry[FUSE_CTL_NUM_DENTRIES];

commit d12def1bcb809b6172ee207a24e00a0a4398df1d
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Feb 6 01:38:39 2008 -0800

    fuse: limit queued background requests
    
    Libfuse basically creates a new thread for each new request.  This is fine for
    synchronous requests, which are naturally limited.  However background
    requests (especially writepage) can cause a thread creation storm.
    
    To avoid this, limit the number of background requests available to userspace.
    
    This is done by introducing another queue for background requests, and a
    counter for the number of "active" requests, which are currently available for
    userspace.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index c5c1ebff1e2d..67aaf6ee38ea 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -296,6 +296,12 @@ struct fuse_conn {
 	/** Number of requests currently in the background */
 	unsigned num_background;
 
+	/** Number of background requests currently queued for userspace */
+	unsigned active_background;
+
+	/** The list of background requests set aside for later queuing */
+	struct list_head bg_queue;
+
 	/** Pending interrupts */
 	struct list_head interrupts;
 

commit b57d426445c98789265de6a9338cdb06462d15fb
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Feb 6 01:38:39 2008 -0800

    fuse: save space in struct fuse_req
    
    Move the fields 'dentry' and 'vfsmount' into the request specific union, since
    these are only used for the RELEASE request.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 3ab8a3048e8b..c5c1ebff1e2d 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -215,7 +215,11 @@ struct fuse_req {
 	/** Data for asynchronous requests */
 	union {
 		struct fuse_forget_in forget_in;
-		struct fuse_release_in release_in;
+		struct {
+			struct fuse_release_in in;
+			struct vfsmount *vfsmount;
+			struct dentry *dentry;
+		} release;
 		struct fuse_init_in init_in;
 		struct fuse_init_out init_out;
 		struct fuse_read_in read_in;
@@ -238,12 +242,6 @@ struct fuse_req {
 	/** File used in the request (or NULL) */
 	struct fuse_file *ff;
 
-	/** vfsmount used in release */
-	struct vfsmount *vfsmount;
-
-	/** dentry used in release */
-	struct dentry *dentry;
-
 	/** Request completion callback */
 	void (*end)(struct fuse_conn *, struct fuse_req *);
 

commit a6643094e73247c1ebd36816f494f631fa7be348
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Nov 28 16:22:00 2007 -0800

    fuse: pass open flags to read and write
    
    Some open flags (O_APPEND, O_DIRECT) can be changed with fcntl(F_SETFL, ...)
    after open, but fuse currently only sends the flags to userspace in open.
    
    To make it possible to correcly handle changing flags, send the
    current value to userspace in each read and write.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 19b0129c9811..3ab8a3048e8b 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -447,7 +447,7 @@ void fuse_send_forget(struct fuse_conn *fc, struct fuse_req *req,
 /**
  * Initialize READ or READDIR request
  */
-void fuse_read_fill(struct fuse_req *req, struct fuse_file *ff,
+void fuse_read_fill(struct fuse_req *req, struct file *file,
 		    struct inode *inode, loff_t pos, size_t count, int opcode);
 
 /**

commit bcb4be809d2a804ff040d95db4a664113833e702
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Nov 28 16:21:59 2007 -0800

    fuse: fix reading past EOF
    
    Currently reading a fuse file will stop at cached i_size and return
    EOF, even though the file might have grown since the attributes were
    last updated.
    
    So detect if trying to read past EOF, and refresh the attributes
    before continuing with the read.
    
    Thanks to mpb for the report.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 6c5461de1a5f..19b0129c9811 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -593,3 +593,6 @@ int fuse_valid_type(int m);
 int fuse_allow_task(struct fuse_conn *fc, struct task_struct *task);
 
 u64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id);
+
+int fuse_update_attributes(struct inode *inode, struct kstat *stat,
+			   struct file *file, bool *refreshed);

commit f33321141b273d60cbb3a8f56a5489baad82ba5e
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Thu Oct 18 03:07:04 2007 -0700

    fuse: add support for mandatory locking
    
    For mandatory locking the userspace filesystem needs to know the lock
    ownership for read, write and truncate operations.
    
    This patch adds the necessary fields to the protocol.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 8b64a630e758..6c5461de1a5f 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -591,3 +591,5 @@ int fuse_valid_type(int m);
  * Is task allowed to perform filesystem operation?
  */
 int fuse_allow_task(struct fuse_conn *fc, struct task_struct *task);
+
+u64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id);

commit b25e82e5673c750116e8b01a4fc7d09be7809f8c
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Thu Oct 18 03:07:03 2007 -0700

    fuse: add helper for asynchronous writes
    
    This patch adds a new helper function fuse_write_fill() which makes it
    possible to send WRITE requests asynchronously.
    
    A new flag for WRITE requests is also added which indicates that this a write
    from the page cache, and not a "normal" file write.
    
    This patch is in preparation for writable mmap support.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 5657cca0d0cb..8b64a630e758 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -219,6 +219,10 @@ struct fuse_req {
 		struct fuse_init_in init_in;
 		struct fuse_init_out init_out;
 		struct fuse_read_in read_in;
+		struct {
+			struct fuse_write_in in;
+			struct fuse_write_out out;
+		} write;
 		struct fuse_lk_in lk_in;
 	} misc;
 

commit 93a8c3cd9e9834dc5f5c373336f3a0065521152d
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Thu Oct 18 03:07:03 2007 -0700

    fuse: add list of writable files to fuse_inode
    
    Each WRITE request must carry a valid file descriptor.  When a page is written
    back from a memory mapping, the file through which the page was dirtied is not
    available, so a new mechananism is needed to find a suitable file in
    ->writepage(s).
    
    A list of fuse_files is added to fuse_inode.  The file is removed from the
    list in fuse_release().
    
    This patch is in preparation for writable mmap support.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index b24fc9b386f8..5657cca0d0cb 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -70,6 +70,9 @@ struct fuse_inode {
 
 	/** Version of last attribute change */
 	u64 attr_version;
+
+	/** Files usable in writepage.  Protected by fc->lock */
+	struct list_head write_files;
 };
 
 /** FUSE specific file data */
@@ -82,6 +85,9 @@ struct fuse_file {
 
 	/** Refcount */
 	atomic_t count;
+
+	/** Entry on inode's write_files list */
+	struct list_head write_entry;
 };
 
 /** One input argument of a request */

commit 6ff958edbf39c014eb06b65ad25b736be08c4e63
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Thu Oct 18 03:07:02 2007 -0700

    fuse: add atomic open+truncate support
    
    This patch allows fuse filesystems to implement open(..., O_TRUNC) as a single
    request, instead of separate truncate and open requests.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index ffbcadaa7d67..b24fc9b386f8 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -320,6 +320,9 @@ struct fuse_conn {
 	/** Do readpages asynchronously?  Only set in INIT */
 	unsigned async_read : 1;
 
+	/** Do not send separate SETATTR request before open(O_TRUNC)  */
+	unsigned atomic_o_trunc : 1;
+
 	/*
 	 * The following bitfields are only for optimization purposes
 	 * and hence races in setting them will not cause malfunction

commit 1fb69e7817296da8a6824804bb206ca1e7f31425
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Thu Oct 18 03:06:58 2007 -0700

    fuse: fix race between getattr and write
    
    Getattr and lookup operations can be running in parallel to attribute changing
    operations, such as write and setattr.
    
    This means, that if for example getattr was slower than a write, the cached
    size attribute could be set to a stale value.
    
    To prevent this race, introduce a per-filesystem attribute version counter.
    This counter is incremented whenever cached attributes are modified, and the
    incremented value stored in the inode.
    
    Before storing new attributes in the cache, getattr and lookup check, using
    the version number, whether the attributes have been modified during the
    request's lifetime.  If so, the returned attributes are not cached, because
    they might be stale.
    
    Thanks to Jakub Bogusz for the bug report and test program.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Cc: Jakub Bogusz <jakub.bogusz@gemius.pl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index e7464b8ebbfb..ffbcadaa7d67 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -67,6 +67,9 @@ struct fuse_inode {
 	/** The sticky bit in inode->i_mode may have been removed, so
 	    preserve the original mode */
 	mode_t orig_i_mode;
+
+	/** Version of last attribute change */
+	u64 attr_version;
 };
 
 /** FUSE specific file data */
@@ -387,6 +390,9 @@ struct fuse_conn {
 
 	/** Reserved request for the DESTROY message */
 	struct fuse_req *destroy_req;
+
+	/** Version counter for attribute changes */
+	u64 attr_version;
 };
 
 static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)
@@ -416,7 +422,8 @@ extern const struct file_operations fuse_dev_operations;
  * Get a filled in inode
  */
 struct inode *fuse_iget(struct super_block *sb, unsigned long nodeid,
-			int generation, struct fuse_attr *attr);
+			int generation, struct fuse_attr *attr,
+			u64 attr_valid, u64 attr_version);
 
 /**
  * Send FORGET command
@@ -477,7 +484,8 @@ void fuse_init_symlink(struct inode *inode);
 /**
  * Change attributes of an inode
  */
-void fuse_change_attributes(struct inode *inode, struct fuse_attr *attr);
+void fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,
+			    u64 attr_valid, u64 attr_version);
 
 /**
  * Initialize the client device

commit e57ac68378a287d6336d187b26971f35f7ee7251
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Thu Oct 18 03:06:58 2007 -0700

    fuse: fix allowing operations
    
    The following operation didn't check if sending the request was allowed:
    
      setattr
      listxattr
      statfs
    
    Some other operations don't explicitly do the check, but VFS calls
    ->permission() which checks this.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 1764506fdd11..e7464b8ebbfb 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -565,3 +565,8 @@ void fuse_ctl_remove_conn(struct fuse_conn *fc);
  * Is file type valid?
  */
 int fuse_valid_type(int m);
+
+/**
+ * Is task allowed to perform filesystem operation?
+ */
+int fuse_allow_task(struct fuse_conn *fc, struct task_struct *task);

commit ebc14c4dbeb56195950058db9aa32de06c22de0d
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Oct 16 23:31:03 2007 -0700

    fuse: fix permission checking on sticky directories
    
    The VFS checks sticky bits on the parent directory even if the filesystem
    defines it's own ->permission().  In some situations (sshfs, mountlo, etc) the
    user does have permission to delete a file even if the attribute based
    checking would not allow it.
    
    So work around this by storing the permission bits separately and returning
    them in stat(), but cutting the permission bits off from inode->i_mode.
    
    This is slightly hackish, but it's probably not worth it to add new
    infrastructure in VFS and a slight performance penalty for all filesystems,
    just for the sake of fuse.
    
    [Jan Engelhardt] cosmetic fixes
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Cc: Jan Engelhardt <jengelh@linux01.gwdg.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index e0555d68b4a7..1764506fdd11 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -63,6 +63,10 @@ struct fuse_inode {
 
 	/** Time in jiffies until the file attributes are valid */
 	u64 i_time;
+
+	/** The sticky bit in inode->i_mode may have been removed, so
+	    preserve the original mode */
+	mode_t orig_i_mode;
 };
 
 /** FUSE specific file data */

commit 244f6385c2891e366a7de5f6746ccc257efd8952
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Oct 16 23:31:02 2007 -0700

    fuse: refresh stale attributes in fuse_permission()
    
    fuse_permission() didn't refresh inode attributes before using them, even if
    the validity has already expired.
    
    Thanks to Junjiro Okajima for spotting this.
    
    Also remove some old code to unconditionally refresh the attributes on the
    root inode.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 60683b787250..e0555d68b4a7 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -532,11 +532,6 @@ void request_send_background(struct fuse_conn *fc, struct fuse_req *req);
 /* Abort all requests */
 void fuse_abort_conn(struct fuse_conn *fc);
 
-/**
- * Get the attributes of a file
- */
-int fuse_do_getattr(struct inode *inode);
-
 /**
  * Invalidate inode attributes
  */

commit c756e0a4d79202535774806f148026e40466a5eb
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Oct 16 23:31:00 2007 -0700

    fuse: add reference counting to fuse_file
    
    Make lifetime of 'struct fuse_file' independent from 'struct file' by adding a
    reference counter and destructor.
    
    This will enable asynchronous page writeback, where it cannot be guaranteed,
    that the file is not released while a request with this file handle is being
    served.
    
    The actual RELEASE request is only sent when there are no more references to
    the fuse_file.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 95bcb433d1b4..60683b787250 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -72,6 +72,9 @@ struct fuse_file {
 
 	/** File handle used by userspace */
 	u64 fh;
+
+	/** Refcount */
+	atomic_t count;
 };
 
 /** One input argument of a request */
@@ -216,7 +219,7 @@ struct fuse_req {
 	unsigned page_offset;
 
 	/** File used in the request (or NULL) */
-	struct file *file;
+	struct fuse_file *ff;
 
 	/** vfsmount used in release */
 	struct vfsmount *vfsmount;
@@ -420,7 +423,7 @@ void fuse_send_forget(struct fuse_conn *fc, struct fuse_req *req,
 /**
  * Initialize READ or READDIR request
  */
-void fuse_read_fill(struct fuse_req *req, struct file *file,
+void fuse_read_fill(struct fuse_req *req, struct fuse_file *ff,
 		    struct inode *inode, loff_t pos, size_t count, int opcode);
 
 /**
@@ -433,9 +436,9 @@ void fuse_file_free(struct fuse_file *ff);
 void fuse_finish_open(struct inode *inode, struct file *file,
 		      struct fuse_file *ff, struct fuse_open_out *outarg);
 
-/** */
-struct fuse_req *fuse_release_fill(struct fuse_file *ff, u64 nodeid, int flags,
-				   int opcode);
+/** Fill in ff->reserved_req with a RELEASE request */
+void fuse_release_fill(struct fuse_file *ff, u64 nodeid, int flags, int opcode);
+
 /**
  * Send RELEASE or RELEASEDIR request
  */

commit de5e3dec421c44c999071b8f7e0580ad2ade92ae
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Oct 16 23:31:00 2007 -0700

    fuse: fix reserved request wake up
    
    Use wake_up_all instead of wake_up in put_reserved_req(), otherwise it is
    possible that the right task is not woken up.
    
    Also create a separate reserved_req_waitq in addition to the blocked_waitq,
    since they fulfill totally separate functions.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 9f4603beb9e8..95bcb433d1b4 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -289,6 +289,9 @@ struct fuse_conn {
 	/** waitq for blocked connection */
 	wait_queue_head_t blocked_waitq;
 
+	/** waitq for reserved requests */
+	wait_queue_head_t reserved_req_waitq;
+
 	/** The next unique request id */
 	u64 reqctr;
 

commit f92b99b9dccb61760b345baf40ed37f59b91f8af
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Oct 16 23:30:59 2007 -0700

    fuse: update backing_dev_info congestion state
    
    Set the read and write congestion state if the request queue is close to
    blocking, and clear it when it's not.
    
    This prevents unnecessary blocking in readahead and (when writable mmaps are
    allowed) writeback.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 68ae87cbafab..9f4603beb9e8 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -20,7 +20,10 @@
 #define FUSE_MAX_PAGES_PER_REQ 32
 
 /** Maximum number of outstanding background requests */
-#define FUSE_MAX_BACKGROUND 10
+#define FUSE_MAX_BACKGROUND 12
+
+/** Congestion starts at 75% of maximum */
+#define FUSE_CONGESTION_THRESHOLD (FUSE_MAX_BACKGROUND * 75 / 100)
 
 /** It could be as large as PATH_MAX, but would that have any uses? */
 #define FUSE_NAME_MAX 1024

commit a5bfffac645a7b2d8119f8bbae34df5c94832799
Author: Timo Savola <tsavola@movial.fi>
Date:   Sun Apr 8 16:04:00 2007 -0700

    [PATCH] fuse: validate rootmode mount option
    
    If rootmode isn't valid, we hit the BUG() in fuse_init_inode.  Now
    EINVAL is returned.
    
    Signed-off-by: Timo Savola <tsavola@movial.fi>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index b98b20de7405..68ae87cbafab 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -552,3 +552,8 @@ int fuse_ctl_add_conn(struct fuse_conn *fc);
  * Remove connection from control filesystem
  */
 void fuse_ctl_remove_conn(struct fuse_conn *fc);
+
+/**
+ * Is file type valid?
+ */
+int fuse_valid_type(int m);

commit 0ec7ca41f6f0f74a394a7d686bc0ee8afef84887
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Wed Dec 6 20:35:52 2006 -0800

    [PATCH] fuse: add DESTROY operation
    
    Add a DESTROY operation for block device based filesystems.  With the help of
    this operation, such a filesystem can flush dirty data to the device
    synchronously before the umount returns.
    
    This is needed in situations where the filesystem is assumed to be clean
    immediately after unmount (e.g.  ejecting removable media).
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 58d482d9f6bb..b98b20de7405 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -298,6 +298,9 @@ struct fuse_conn {
 	    reply, before any other request, and never cleared */
 	unsigned conn_error : 1;
 
+	/** Connection successful.  Only set in INIT */
+	unsigned conn_init : 1;
+
 	/** Do readpages asynchronously?  Only set in INIT */
 	unsigned async_read : 1;
 
@@ -368,6 +371,9 @@ struct fuse_conn {
 
 	/** Key for lock owner ID scrambling */
 	u32 scramble_key[4];
+
+	/** Reserved request for the DESTROY message */
+	struct fuse_req *destroy_req;
 };
 
 static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)

commit b2d2272fae1e1df26ec8f93a6d5baea891dcce37
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Wed Dec 6 20:35:51 2006 -0800

    [PATCH] fuse: add bmap support
    
    Add support for the BMAP operation for block device based filesystems.  This
    is needed to support swap-files and lilo.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 91edb8932d90..58d482d9f6bb 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -339,6 +339,9 @@ struct fuse_conn {
 	/** Is interrupt not implemented by fs? */
 	unsigned no_interrupt : 1;
 
+	/** Is bmap not implemented by fs? */
+	unsigned no_bmap : 1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 

commit d2a85164aaa8d514ef5efbf5d05746e85dd13ddd
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Tue Oct 17 00:10:11 2006 -0700

    [PATCH] fuse: fix handling of moved directory
    
    Fuse considered it an error (EIO) if lookup returned a directory inode, to
    which a dentry already refered.  This is because directory aliases are not
    allowed.
    
    But in a network filesystem this could happen legitimately, if a directory is
    moved on a remote client.  This patch attempts to relax the restriction by
    trying to first evict the offending alias from the cache.  If this fails, it
    still returns an error (EBUSY).
    
    A rarer situation is if an mkdir races with an indenpendent lookup, which
    finds the newly created directory already moved.  In this situation the mkdir
    should return success, but that would be incorrect, since the dentry cannot be
    instantiated, so return EBUSY.
    
    Previously checking for a directory alias and instantiation of the dentry
    weren't done atomically in lookup/mkdir, hence two such calls racing with each
    other could create aliased directories.  To prevent this introduce a new
    per-connection mutex: fuse_conn->inst_mutex, which is taken for instantiations
    with a directory inode.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 69c7750d55b8..91edb8932d90 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -239,6 +239,9 @@ struct fuse_conn {
 	/** Lock protecting accessess to  members of this structure */
 	spinlock_t lock;
 
+	/** Mutex protecting against directory alias creation */
+	struct mutex inst_mutex;
+
 	/** Refcount */
 	atomic_t count;
 

commit 0a0898cf413876d4ed6e371f3e04bf38600a9205
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Sun Jul 30 03:04:10 2006 -0700

    [PATCH] fuse: use jiffies_64
    
    It is entirely possible (though rare) that jiffies half-wraps around, while a
    dentry/inode remains in the cache.  This could mean that the dentry/inode is
    not invalidated for another half wraparound-time.
    
    To get around this problem, use 64-bit jiffies.  The only problem with this is
    that dentry->d_time is 32 bits on 32-bit archs.  So use d_fsdata as the high
    32 bits.  This is an ugly hack, but far simpler, than having to allocate
    private data just for this purpose.
    
    Since 64-bit jiffies can be assumed never to wrap around, simple comparison
    can be used, and a zero time value can represent "invalid".
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 0dbf96621841..69c7750d55b8 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -59,7 +59,7 @@ struct fuse_inode {
 	struct fuse_req *forget_req;
 
 	/** Time in jiffies until the file attributes are valid */
-	unsigned long i_time;
+	u64 i_time;
 };
 
 /** FUSE specific file data */

commit 9c8ef5614da22666e339b125263d315cfaa89109
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Sun Jun 25 05:48:55 2006 -0700

    [PATCH] fuse: scramble lock owner ID
    
    VFS uses current->files pointer as lock owner ID, and it wouldn't be
    prudent to expose this value to userspace.  So scramble it with XTEA using
    a per connection random key, known only to the kernel.  Only one direction
    needs to be implemented, since the ID is never sent in the reverse
    direction.
    
    The XTEA algorithm is implemented inline since it's simple enough to do so,
    and this adds less complexity than if the crypto API were used.
    
    Thanks to Jesper Juhl for the idea.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index c862df58da92..0dbf96621841 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -359,6 +359,9 @@ struct fuse_conn {
 
 	/** O_ASYNC requests */
 	struct fasync_struct *fasync;
+
+	/** Key for lock owner ID scrambling */
+	u32 scramble_key[4];
 };
 
 static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)

commit a4d27e75ffb7b8ecb7eed0c7db0df975525f3fd7
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Sun Jun 25 05:48:54 2006 -0700

    [PATCH] fuse: add request interruption
    
    Add synchronous request interruption.  This is needed for file locking
    operations which have to be interruptible.  However filesystem may implement
    interruptibility of other operations (e.g.  like NFS 'intr' mount option).
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index fd65e75e1622..c862df58da92 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -131,6 +131,7 @@ enum fuse_req_state {
 	FUSE_REQ_PENDING,
 	FUSE_REQ_READING,
 	FUSE_REQ_SENT,
+	FUSE_REQ_WRITING,
 	FUSE_REQ_FINISHED
 };
 
@@ -144,9 +145,15 @@ struct fuse_req {
 	    fuse_conn */
 	struct list_head list;
 
+	/** Entry on the interrupts list  */
+	struct list_head intr_entry;
+
 	/** refcount */
 	atomic_t count;
 
+	/** Unique ID for the interrupt request */
+	u64 intr_unique;
+
 	/*
 	 * The following bitfields are either set once before the
 	 * request is queued or setting/clearing them is protected by
@@ -165,6 +172,9 @@ struct fuse_req {
 	/** Request is sent in the background */
 	unsigned background:1;
 
+	/** The request has been interrupted */
+	unsigned interrupted:1;
+
 	/** Data is being copied to/from the request */
 	unsigned locked:1;
 
@@ -262,6 +272,9 @@ struct fuse_conn {
 	/** Number of requests currently in the background */
 	unsigned num_background;
 
+	/** Pending interrupts */
+	struct list_head interrupts;
+
 	/** Flag indicating if connection is blocked.  This will be
 	    the case before the INIT reply is received, and if there
 	    are too many outstading backgrounds requests */
@@ -320,6 +333,9 @@ struct fuse_conn {
 	/** Is create not implemented by fs? */
 	unsigned no_create : 1;
 
+	/** Is interrupt not implemented by fs? */
+	unsigned no_interrupt : 1;
+
 	/** The number of requests waiting for completion */
 	atomic_t num_waiting;
 

commit f9a2842e5612b93fa20a624a8baa6c2a7ecea504
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Sun Jun 25 05:48:53 2006 -0700

    [PATCH] fuse: rename the interrupted flag
    
    Rename the 'interrupted' flag to 'aborted', since it indicates exactly that,
    and next patch will introduce an 'interrupted' flag for a
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index f7c74516f3a6..fd65e75e1622 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -159,8 +159,8 @@ struct fuse_req {
 	/** Force sending of the request even if interrupted */
 	unsigned force:1;
 
-	/** The request was interrupted */
-	unsigned interrupted:1;
+	/** The request was aborted */
+	unsigned aborted:1;
 
 	/** Request is sent in the background */
 	unsigned background:1;

commit 33649c91a3df57c1090a657637d44b896de367e7
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Sun Jun 25 05:48:52 2006 -0700

    [PATCH] fuse: ensure FLUSH reaches userspace
    
    All POSIX locks owned by the current task are removed on close().  If the
    FLUSH request resulting initiated by close() fails to reach userspace, there
    might be locks remaining, which cannot be removed.
    
    The only reason it could fail, is if allocating the request fails.  In this
    case use the request reserved for RELEASE, or if that is currently used by
    another FLUSH, wait for it to become available.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index eb3166625ca9..f7c74516f3a6 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -65,7 +65,7 @@ struct fuse_inode {
 /** FUSE specific file data */
 struct fuse_file {
 	/** Request reserved for flush and release */
-	struct fuse_req *release_req;
+	struct fuse_req *reserved_req;
 
 	/** File handle used by userspace */
 	u64 fh;
@@ -213,6 +213,9 @@ struct fuse_req {
 
 	/** Request completion callback */
 	void (*end)(struct fuse_conn *, struct fuse_req *);
+
+	/** Request is stolen from fuse_file->reserved_req */
+	struct file *stolen_file;
 };
 
 /**
@@ -456,10 +459,15 @@ struct fuse_req *fuse_request_alloc(void);
 void fuse_request_free(struct fuse_req *req);
 
 /**
- * Reserve a preallocated request
+ * Get a request, may fail with -ENOMEM
  */
 struct fuse_req *fuse_get_req(struct fuse_conn *fc);
 
+/**
+ * Gets a requests for a file operation, always succeeds
+ */
+struct fuse_req *fuse_get_req_nofail(struct fuse_conn *fc, struct file *file);
+
 /**
  * Decrement reference count of a request.  If count goes to zero free
  * the request.

commit 7142125937e1482ad3ae4366594c6586153dfc86
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Sun Jun 25 05:48:52 2006 -0700

    [PATCH] fuse: add POSIX file locking support
    
    This patch adds POSIX file locking support to the fuse interface.
    
    This implementation doesn't keep any locking state in kernel.  Unlocking on
    close() is handled by the FLUSH message, which now contains the lock owner id.
    
    Mandatory locking is not supported.  The filesystem may enfoce mandatory
    locking in userspace if needed.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index ac12b01f4446..eb3166625ca9 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -190,6 +190,7 @@ struct fuse_req {
 		struct fuse_init_in init_in;
 		struct fuse_init_out init_out;
 		struct fuse_read_in read_in;
+		struct fuse_lk_in lk_in;
 	} misc;
 
 	/** page vector */
@@ -307,6 +308,9 @@ struct fuse_conn {
 	/** Is removexattr not implemented by fs? */
 	unsigned no_removexattr : 1;
 
+	/** Are file locking primitives not implemented by fs? */
+	unsigned no_lock : 1;
+
 	/** Is access not implemented by fs? */
 	unsigned no_access : 1;
 

commit bafa96541b250a7051e3fbc5de6e8369daf8ffec
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Sun Jun 25 05:48:51 2006 -0700

    [PATCH] fuse: add control filesystem
    
    Add a control filesystem to fuse, replacing the attributes currently exported
    through sysfs.  An empty directory '/sys/fs/fuse/connections' is still created
    in sysfs, and mounting the control filesystem here provides backward
    compatibility.
    
    Advantages of the control filesystem over the previous solution:
    
      - allows the object directory and the attributes to be owned by the
        filesystem owner, hence letting unpriviled users abort the
        filesystem connection
    
      - does not suffer from module unload race
    
    [akpm@osdl.org: fix this fs for recent dhowells depredations]
    [akpm@osdl.org: fix 64-bit printk warnings]
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 25f8581a770c..ac12b01f4446 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -14,6 +14,7 @@
 #include <linux/spinlock.h>
 #include <linux/mm.h>
 #include <linux/backing-dev.h>
+#include <linux/mutex.h>
 
 /** Max number of pages that can be used in a single read request */
 #define FUSE_MAX_PAGES_PER_REQ 32
@@ -24,6 +25,9 @@
 /** It could be as large as PATH_MAX, but would that have any uses? */
 #define FUSE_NAME_MAX 1024
 
+/** Number of dentries for each connection in the control filesystem */
+#define FUSE_CTL_NUM_DENTRIES 3
+
 /** If the FUSE_DEFAULT_PERMISSIONS flag is given, the filesystem
     module will check permissions based on the file mode.  Otherwise no
     permission checking is done in the kernel */
@@ -33,6 +37,11 @@
     doing the mount will be allowed to access the filesystem */
 #define FUSE_ALLOW_OTHER         (1 << 1)
 
+/** List of active connections */
+extern struct list_head fuse_conn_list;
+
+/** Global mutex protecting fuse_conn_list and the control filesystem */
+extern struct mutex fuse_mutex;
 
 /** FUSE inode */
 struct fuse_inode {
@@ -216,6 +225,9 @@ struct fuse_conn {
 	/** Lock protecting accessess to  members of this structure */
 	spinlock_t lock;
 
+	/** Refcount */
+	atomic_t count;
+
 	/** The user id for this mount */
 	uid_t user_id;
 
@@ -310,8 +322,17 @@ struct fuse_conn {
 	/** Backing dev info */
 	struct backing_dev_info bdi;
 
-	/** kobject */
-	struct kobject kobj;
+	/** Entry on the fuse_conn_list */
+	struct list_head entry;
+
+	/** Unique ID */
+	u64 id;
+
+	/** Dentries in the control filesystem */
+	struct dentry *ctl_dentry[FUSE_CTL_NUM_DENTRIES];
+
+	/** number of dentries used in the above array */
+	int ctl_ndents;
 
 	/** O_ASYNC requests */
 	struct fasync_struct *fasync;
@@ -327,11 +348,6 @@ static inline struct fuse_conn *get_fuse_conn(struct inode *inode)
 	return get_fuse_conn_super(inode->i_sb);
 }
 
-static inline struct fuse_conn *get_fuse_conn_kobj(struct kobject *obj)
-{
-	return container_of(obj, struct fuse_conn, kobj);
-}
-
 static inline struct fuse_inode *get_fuse_inode(struct inode *inode)
 {
 	return container_of(inode, struct fuse_inode, inode);
@@ -422,6 +438,9 @@ int fuse_dev_init(void);
  */
 void fuse_dev_cleanup(void);
 
+int fuse_ctl_init(void);
+void fuse_ctl_cleanup(void);
+
 /**
  * Allocate a request
  */
@@ -470,3 +489,23 @@ int fuse_do_getattr(struct inode *inode);
  * Invalidate inode attributes
  */
 void fuse_invalidate_attr(struct inode *inode);
+
+/**
+ * Acquire reference to fuse_conn
+ */
+struct fuse_conn *fuse_conn_get(struct fuse_conn *fc);
+
+/**
+ * Release reference to fuse_conn
+ */
+void fuse_conn_put(struct fuse_conn *fc);
+
+/**
+ * Add connection to control filesystem
+ */
+int fuse_ctl_add_conn(struct fuse_conn *fc);
+
+/**
+ * Remove connection from control filesystem
+ */
+void fuse_ctl_remove_conn(struct fuse_conn *fc);

commit 51eb01e73599efb88c6c20b1c226d20309a75450
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Sun Jun 25 05:48:50 2006 -0700

    [PATCH] fuse: no backgrounding on interrupt
    
    Don't put requests into the background when a fatal interrupt occurs while the
    request is in userspace.  This removes a major wart from the implementation.
    
    Backgrounding of requests was introduced to allow breaking of deadlocks.
    However now the same can be achieved by aborting the filesystem through the
    'abort' sysfs attribute.
    
    This is a change in the interface, but should not cause problems, since these
    kinds of deadlocks never happen during normal operation.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 0474202cb5dc..25f8581a770c 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -8,12 +8,12 @@
 
 #include <linux/fuse.h>
 #include <linux/fs.h>
+#include <linux/mount.h>
 #include <linux/wait.h>
 #include <linux/list.h>
 #include <linux/spinlock.h>
 #include <linux/mm.h>
 #include <linux/backing-dev.h>
-#include <asm/semaphore.h>
 
 /** Max number of pages that can be used in a single read request */
 #define FUSE_MAX_PAGES_PER_REQ 32
@@ -135,9 +135,6 @@ struct fuse_req {
 	    fuse_conn */
 	struct list_head list;
 
-	/** Entry on the background list */
-	struct list_head bg_entry;
-
 	/** refcount */
 	atomic_t count;
 
@@ -150,6 +147,9 @@ struct fuse_req {
 	/** True if the request has reply */
 	unsigned isreply:1;
 
+	/** Force sending of the request even if interrupted */
+	unsigned force:1;
+
 	/** The request was interrupted */
 	unsigned interrupted:1;
 
@@ -192,15 +192,15 @@ struct fuse_req {
 	/** offset of data on first page */
 	unsigned page_offset;
 
-	/** Inode used in the request */
-	struct inode *inode;
-
-	/** Second inode used in the request (or NULL) */
-	struct inode *inode2;
-
 	/** File used in the request (or NULL) */
 	struct file *file;
 
+	/** vfsmount used in release */
+	struct vfsmount *vfsmount;
+
+	/** dentry used in release */
+	struct dentry *dentry;
+
 	/** Request completion callback */
 	void (*end)(struct fuse_conn *, struct fuse_req *);
 };
@@ -243,10 +243,6 @@ struct fuse_conn {
 	/** The list of requests under I/O */
 	struct list_head io;
 
-	/** Requests put in the background (RELEASE or any other
-	    interrupted request) */
-	struct list_head background;
-
 	/** Number of requests currently in the background */
 	unsigned num_background;
 
@@ -258,15 +254,9 @@ struct fuse_conn {
 	/** waitq for blocked connection */
 	wait_queue_head_t blocked_waitq;
 
-	/** RW semaphore for exclusion with fuse_put_super() */
-	struct rw_semaphore sbput_sem;
-
 	/** The next unique request id */
 	u64 reqctr;
 
-	/** Mount is active */
-	unsigned mounted;
-
 	/** Connection established, cleared on umount, connection
 	    abort and device release */
 	unsigned connected;
@@ -383,12 +373,9 @@ void fuse_file_free(struct fuse_file *ff);
 void fuse_finish_open(struct inode *inode, struct file *file,
 		      struct fuse_file *ff, struct fuse_open_out *outarg);
 
-/**
- * Send a RELEASE request
- */
-void fuse_send_release(struct fuse_conn *fc, struct fuse_file *ff,
-		       u64 nodeid, struct inode *inode, int flags, int isdir);
-
+/** */
+struct fuse_req *fuse_release_fill(struct fuse_file *ff, u64 nodeid, int flags,
+				   int opcode);
 /**
  * Send RELEASE or RELEASEDIR request
  */
@@ -445,11 +432,6 @@ struct fuse_req *fuse_request_alloc(void);
  */
 void fuse_request_free(struct fuse_req *req);
 
-/**
- * Reinitialize a request, the preallocated flag is left unmodified
- */
-void fuse_reset_request(struct fuse_req *req);
-
 /**
  * Reserve a preallocated request
  */
@@ -476,11 +458,6 @@ void request_send_noreply(struct fuse_conn *fc, struct fuse_req *req);
  */
 void request_send_background(struct fuse_conn *fc, struct fuse_req *req);
 
-/**
- * Release inodes and file associated with background request
- */
-void fuse_release_background(struct fuse_conn *fc, struct fuse_req *req);
-
 /* Abort all requests */
 void fuse_abort_conn(struct fuse_conn *fc);
 

commit 5a5fb1ea74d8b82ca1461b885a1334fb21e037be
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Wed Apr 26 10:48:55 2006 +0200

    Revert "[fuse] fix deadlock between fuse_put_super() and request_end()"
    
    This reverts 73ce8355c243a434524a34c05cc417dd0467996e commit.
    
    It was wrong, because it didn't take into account the requirement,
    that iput() for background requests must be performed synchronously
    with ->put_super(), otherwise active inodes may remain after unmount.
    
    The right solution is to keep the sbput_sem and perform iput() within
    the locked region, but move fput() outside sbput_sem.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 59661c481d9d..0474202cb5dc 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -258,9 +258,15 @@ struct fuse_conn {
 	/** waitq for blocked connection */
 	wait_queue_head_t blocked_waitq;
 
+	/** RW semaphore for exclusion with fuse_put_super() */
+	struct rw_semaphore sbput_sem;
+
 	/** The next unique request id */
 	u64 reqctr;
 
+	/** Mount is active */
+	unsigned mounted;
+
 	/** Connection established, cleared on umount, connection
 	    abort and device release */
 	unsigned connected;
@@ -471,11 +477,11 @@ void request_send_noreply(struct fuse_conn *fc, struct fuse_req *req);
 void request_send_background(struct fuse_conn *fc, struct fuse_req *req);
 
 /**
- * Remove request from the the background list
+ * Release inodes and file associated with background request
  */
-void fuse_remove_background(struct fuse_conn *fc, struct fuse_req *req);
+void fuse_release_background(struct fuse_conn *fc, struct fuse_req *req);
 
-/** Abort all requests */
+/* Abort all requests */
 void fuse_abort_conn(struct fuse_conn *fc);
 
 /**

commit 9bc5dddad1294955e70eeb87325ba1505fb5fe2e
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Tue Apr 11 21:16:09 2006 +0200

    [fuse] Fix accounting the number of waiting requests
    
    Properly accounting the number of waiting requests was forgotten in
    "clean up request accounting" patch.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index ee9b83042510..59661c481d9d 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -159,6 +159,9 @@ struct fuse_req {
 	/** Data is being copied to/from the request */
 	unsigned locked:1;
 
+	/** Request is counted as "waiting" */
+	unsigned waiting:1;
+
 	/** State of the request */
 	enum fuse_req_state state;
 

commit 73ce8355c243a434524a34c05cc417dd0467996e
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Tue Apr 11 21:14:26 2006 +0200

    [fuse] fix deadlock between fuse_put_super() and request_end()
    
    A deadlock was possible, when the last reference to the superblock was
    held due to a background request containing a file reference.
    
    Releasing the file would release the vfsmount which in turn would
    release the superblock.  Since sbput_sem is held during the fput() and
    fuse_put_super() tries to acquire this same semaphore, a deadlock
    results.
    
    The chosen soltuion is to get rid of sbput_sem, and instead use the
    spinlock to ensure the referenced inodes/file are released only once.
    Since the actual release may sleep, defer these outside the locked
    region, but using local variables instead of the structure members.
    
    This is a much more rubust solution.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 19c7185a7546..ee9b83042510 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -255,15 +255,9 @@ struct fuse_conn {
 	/** waitq for blocked connection */
 	wait_queue_head_t blocked_waitq;
 
-	/** RW semaphore for exclusion with fuse_put_super() */
-	struct rw_semaphore sbput_sem;
-
 	/** The next unique request id */
 	u64 reqctr;
 
-	/** Mount is active */
-	unsigned mounted;
-
 	/** Connection established, cleared on umount, connection
 	    abort and device release */
 	unsigned connected;
@@ -474,11 +468,11 @@ void request_send_noreply(struct fuse_conn *fc, struct fuse_req *req);
 void request_send_background(struct fuse_conn *fc, struct fuse_req *req);
 
 /**
- * Release inodes and file associated with background request
+ * Remove request from the the background list
  */
-void fuse_release_background(struct fuse_conn *fc, struct fuse_req *req);
+void fuse_remove_background(struct fuse_conn *fc, struct fuse_req *req);
 
-/* Abort all requests */
+/** Abort all requests */
 void fuse_abort_conn(struct fuse_conn *fc);
 
 /**

commit 08a53cdce62d37d918530bbbf726cc01b21dc3d1
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Apr 10 22:54:59 2006 -0700

    [PATCH] fuse: account background requests
    
    The previous patch removed limiting the number of outstanding requests.  This
    patch adds a much simpler limiting, that is also compatible with file locking
    operations.
    
    A task may have at most one synchronous request allocated.  So these requests
    need not be otherwise limited.
    
    However the number of background requests (release, forget, asynchronous
    reads, interrupted requests) can grow indefinitely.  This can be used by a
    malicous user to cause FUSE to allocate arbitrary amounts of unswappable
    kernel memory, denying service.
    
    For this reason add a limit for the number of background requests, and block
    allocations of new requests until the number goes bellow the limit.
    
    Also use this mechanism to block all requests until the INIT reply is
    received.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 242e69cb1251..19c7185a7546 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -18,6 +18,9 @@
 /** Max number of pages that can be used in a single read request */
 #define FUSE_MAX_PAGES_PER_REQ 32
 
+/** Maximum number of outstanding background requests */
+#define FUSE_MAX_BACKGROUND 10
+
 /** It could be as large as PATH_MAX, but would that have any uses? */
 #define FUSE_NAME_MAX 1024
 
@@ -241,6 +244,17 @@ struct fuse_conn {
 	    interrupted request) */
 	struct list_head background;
 
+	/** Number of requests currently in the background */
+	unsigned num_background;
+
+	/** Flag indicating if connection is blocked.  This will be
+	    the case before the INIT reply is received, and if there
+	    are too many outstading backgrounds requests */
+	int blocked;
+
+	/** waitq for blocked connection */
+	wait_queue_head_t blocked_waitq;
+
 	/** RW semaphore for exclusion with fuse_put_super() */
 	struct rw_semaphore sbput_sem;
 

commit ce1d5a491f0ee50560416a73faa5e4ddbab074bd
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Apr 10 22:54:58 2006 -0700

    [PATCH] fuse: clean up request accounting
    
    FUSE allocated most requests from a fixed size pool filled at mount time.
    However in some cases (release/forget) non-pool requests were used.  File
    locking operations aren't well served by the request pool, since they may
    block indefinetly thus exhausting the pool.
    
    This patch removes the request pool and always allocates requests on demand.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 6ed812fd6200..242e69cb1251 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -18,9 +18,6 @@
 /** Max number of pages that can be used in a single read request */
 #define FUSE_MAX_PAGES_PER_REQ 32
 
-/** If more requests are outstanding, then the operation will block */
-#define FUSE_MAX_OUTSTANDING 10
-
 /** It could be as large as PATH_MAX, but would that have any uses? */
 #define FUSE_NAME_MAX 1024
 
@@ -131,8 +128,8 @@ struct fuse_conn;
  * A request to the client
  */
 struct fuse_req {
-	/** This can be on either unused_list, pending processing or
-	    io lists in fuse_conn */
+	/** This can be on either pending processing or io lists in
+	    fuse_conn */
 	struct list_head list;
 
 	/** Entry on the background list */
@@ -150,9 +147,6 @@ struct fuse_req {
 	/** True if the request has reply */
 	unsigned isreply:1;
 
-	/** The request is preallocated */
-	unsigned preallocated:1;
-
 	/** The request was interrupted */
 	unsigned interrupted:1;
 
@@ -247,19 +241,9 @@ struct fuse_conn {
 	    interrupted request) */
 	struct list_head background;
 
-	/** Controls the maximum number of outstanding requests */
-	struct semaphore outstanding_sem;
-
-	/** This counts the number of outstanding requests if
-	    outstanding_sem would go negative */
-	unsigned outstanding_debt;
-
 	/** RW semaphore for exclusion with fuse_put_super() */
 	struct rw_semaphore sbput_sem;
 
-	/** The list of unused requests */
-	struct list_head unused_list;
-
 	/** The next unique request id */
 	u64 reqctr;
 
@@ -452,11 +436,11 @@ void fuse_reset_request(struct fuse_req *req);
 /**
  * Reserve a preallocated request
  */
-struct fuse_req *fuse_get_request(struct fuse_conn *fc);
+struct fuse_req *fuse_get_req(struct fuse_conn *fc);
 
 /**
- * Decrement reference count of a request.  If count goes to zero put
- * on unused list (preallocated) or free request (not preallocated).
+ * Decrement reference count of a request.  If count goes to zero free
+ * the request.
  */
 void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req);
 

commit d713311464bcca73c990d1a1b5c9467eae87f5b4
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Apr 10 22:54:55 2006 -0700

    [PATCH] fuse: use a per-mount spinlock
    
    Remove the global spinlock in favor of a per-mount one.
    
    This patch is basically find & replace.  The difficult part has already been
    done by the previous patch.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index e5cb46b78437..6ed812fd6200 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -1,6 +1,6 @@
 /*
   FUSE: Filesystem in Userspace
-  Copyright (C) 2001-2005  Miklos Szeredi <miklos@szeredi.hu>
+  Copyright (C) 2001-2006  Miklos Szeredi <miklos@szeredi.hu>
 
   This program can be distributed under the terms of the GNU GPL.
   See the file COPYING.
@@ -144,7 +144,7 @@ struct fuse_req {
 	/*
 	 * The following bitfields are either set once before the
 	 * request is queued or setting/clearing them is protected by
-	 * fuse_lock
+	 * fuse_conn->lock
 	 */
 
 	/** True if the request has reply */
@@ -213,6 +213,9 @@ struct fuse_req {
  * unmounted.
  */
 struct fuse_conn {
+	/** Lock protecting accessess to  members of this structure */
+	spinlock_t lock;
+
 	/** The user id for this mount */
 	uid_t user_id;
 
@@ -351,21 +354,6 @@ static inline u64 get_node_id(struct inode *inode)
 /** Device operations */
 extern const struct file_operations fuse_dev_operations;
 
-/**
- * This is the single global spinlock which protects FUSE's structures
- *
- * The following data is protected by this lock:
- *
- *  - the private_data field of the device file
- *  - the s_fs_info field of the super block
- *  - unused_list, pending, processing lists in fuse_conn
- *  - background list in fuse_conn
- *  - the unique request ID counter reqctr in fuse_conn
- *  - the sb (super_block) field in fuse_conn
- *  - the file (device file) field in fuse_conn
- */
-extern spinlock_t fuse_lock;
-
 /**
  * Get a filled in inode
  */
@@ -490,7 +478,7 @@ void request_send_background(struct fuse_conn *fc, struct fuse_req *req);
 /**
  * Release inodes and file associated with background request
  */
-void fuse_release_background(struct fuse_req *req);
+void fuse_release_background(struct fuse_conn *fc, struct fuse_req *req);
 
 /* Abort all requests */
 void fuse_abort_conn(struct fuse_conn *fc);

commit 385a17bfc3cb035333c8a91eddc78a6e04c4625e
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Apr 10 22:54:52 2006 -0700

    [PATCH] fuse: add O_ASYNC support to FUSE device
    
    This adds asynchronous notification to FUSE - a FUSE server can request
    O_ASYNC on a /dev/fuse file descriptor and receive SIGIO when there is input
    available.
    
    One subtlety - fuse_dev_fasync, which is called when O_ASYNC is requested,
    does no locking, unlink the other methods.  I think it's unnecessary, as the
    fuse_conn.fasync list is manipulated only by fasync_helper and kill_fasync,
    which provide their own locking.  It would also be wrong to use the fuse_lock,
    as it's a spin lock and fasync_helper can sleep.  My one concern with this is
    the fuse_conn going away underneath fuse_dev_fasync - sys_fcntl takes a
    reference on the file struct, so this seems not to be a problem.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index a16a04fcf41e..e5cb46b78437 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -318,6 +318,9 @@ struct fuse_conn {
 
 	/** kobject */
 	struct kobject kobj;
+
+	/** O_ASYNC requests */
+	struct fasync_struct *fasync;
 };
 
 static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)

commit 4b6f5d20b04dcbc3d888555522b90ba6d36c4106
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Tue Mar 28 01:56:42 2006 -0800

    [PATCH] Make most file operations structs in fs/ const
    
    This is a conversion to make the various file_operations structs in fs/
    const.  Basically a regexp job, with a few manual fixups
    
    The goal is both to increase correctness (harder to accidentally write to
    shared datastructures) and reducing the false sharing of cachelines with
    things that get dirty in .data (while .rodata is nicely read only and thus
    cache clean)
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 4a83adfec968..a16a04fcf41e 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -346,7 +346,7 @@ static inline u64 get_node_id(struct inode *inode)
 }
 
 /** Device operations */
-extern struct file_operations fuse_dev_operations;
+extern const struct file_operations fuse_dev_operations;
 
 /**
  * This is the single global spinlock which protects FUSE's structures

commit 9cd684551124e71630ab96d238747051463f5b56
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Wed Feb 1 03:04:40 2006 -0800

    [PATCH] fuse: fix async read for legacy filesystems
    
    While asynchronous reads mean a performance improvement in most cases, if
    the filesystem assumed that reads are synchronous, then async reads may
    degrade performance (filesystem may receive reads out of order, which can
    confuse it's own readahead logic).
    
    With sshfs a 1.5 to 4 times slowdown can be measured.
    
    There's also a need for userspace filesystems to know whether asynchronous
    reads are supported by the kernel or not.
    
    To achive these, negotiate in the INIT request whether async reads will be
    used and the maximum readahead value.  Update interface version to 7.6
    
    If userspace uses a version earlier than 7.6, then disable async reads, and
    set maximum readahead value to the maximum read size, as done in previous
    versions.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 46cf933aa3bf..4a83adfec968 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -272,6 +272,9 @@ struct fuse_conn {
 	    reply, before any other request, and never cleared */
 	unsigned conn_error : 1;
 
+	/** Do readpages asynchronously?  Only set in INIT */
+	unsigned async_read : 1;
+
 	/*
 	 * The following bitfields are only for optimization purposes
 	 * and hence races in setting them will not cause malfunction

commit 095da6cbb6a1c54c19b11190218eb0fbac666b6d
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Jan 16 22:14:52 2006 -0800

    [PATCH] fuse: fix bitfield race
    
    Fix race in setting bitfields of fuse_conn.  Spotted by Andrew Morton.
    
    The two fields ->connected and ->mounted were always changed with the
    fuse_lock held.  But other bitfields in the same structure were changed
    without the lock.  In theory this could lead to losing the assignment of
    even the ones under lock.  The chosen solution is to change these two
    fields to be a full unsigned type.  The other bitfields aren't "important"
    enough to warrant the extra complexity of full locking or changing them to
    bitops.
    
    For all bitfields document why they are safe wrt. concurrent
    assignments.
    
    Also make the initialization of the 'num_waiting' atomic counter explicit.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 7ed1d3c53b8a..46cf933aa3bf 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -94,6 +94,11 @@ struct fuse_out {
 	/** Header returned from userspace */
 	struct fuse_out_header h;
 
+	/*
+	 * The following bitfields are not changed during the request
+	 * processing
+	 */
+
 	/** Last argument is variable length (can be shorter than
 	    arg->size) */
 	unsigned argvar:1;
@@ -136,6 +141,12 @@ struct fuse_req {
 	/** refcount */
 	atomic_t count;
 
+	/*
+	 * The following bitfields are either set once before the
+	 * request is queued or setting/clearing them is protected by
+	 * fuse_lock
+	 */
+
 	/** True if the request has reply */
 	unsigned isreply:1;
 
@@ -250,15 +261,22 @@ struct fuse_conn {
 	u64 reqctr;
 
 	/** Mount is active */
-	unsigned mounted : 1;
+	unsigned mounted;
 
 	/** Connection established, cleared on umount, connection
 	    abort and device release */
-	unsigned connected : 1;
+	unsigned connected;
 
-	/** Connection failed (version mismatch) */
+	/** Connection failed (version mismatch).  Cannot race with
+	    setting other bitfields since it is only set once in INIT
+	    reply, before any other request, and never cleared */
 	unsigned conn_error : 1;
 
+	/*
+	 * The following bitfields are only for optimization purposes
+	 * and hence races in setting them will not cause malfunction
+	 */
+
 	/** Is fsync not implemented by fs? */
 	unsigned no_fsync : 1;
 

commit 361b1eb55ea84181505c7f0674ca1205da1127ab
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Jan 16 22:14:45 2006 -0800

    [PATCH] fuse: READ request initialization
    
    Add a separate function for filling in the READ request.  This will make it
    possible to send asynchronous READ requests as well as synchronous ones.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 926b41c959d5..7ed1d3c53b8a 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -169,6 +169,7 @@ struct fuse_req {
 		struct fuse_release_in release_in;
 		struct fuse_init_in init_in;
 		struct fuse_init_out init_out;
+		struct fuse_read_in read_in;
 	} misc;
 
 	/** page vector */
@@ -354,11 +355,10 @@ void fuse_send_forget(struct fuse_conn *fc, struct fuse_req *req,
 		      unsigned long nodeid, u64 nlookup);
 
 /**
- * Send READ or READDIR request
+ * Initialize READ or READDIR request
  */
-size_t fuse_send_read_common(struct fuse_req *req, struct file *file,
-			     struct inode *inode, loff_t pos, size_t count,
-			     int isdir);
+void fuse_read_fill(struct fuse_req *req, struct file *file,
+		    struct inode *inode, loff_t pos, size_t count, int opcode);
 
 /**
  * Send OPEN or OPENDIR request

commit 9b9a04693fa2d9e60933154e4c4aca83c219ef0a
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Jan 16 22:14:44 2006 -0800

    [PATCH] fuse: move INIT handling to inode.c
    
    Now the INIT requests can be completely handled in inode.c and the
    fuse_send_init() function need not be global any more.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 145098056ca6..926b41c959d5 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -480,8 +480,3 @@ int fuse_do_getattr(struct inode *inode);
  * Invalidate inode attributes
  */
 void fuse_invalidate_attr(struct inode *inode);
-
-/**
- * Send the INIT message
- */
-void fuse_send_init(struct fuse_conn *fc);

commit 64c6d8ed4c55f0a99b1b81558851da80c8d58244
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Jan 16 22:14:42 2006 -0800

    [PATCH] fuse: add asynchronous request support
    
    Add possibility for requests to run asynchronously and call an 'end' callback
    when finished.
    
    With this, the special handling of the INIT and RELEASE requests can be
    cleaned up too.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index e6381db41df9..145098056ca6 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -120,6 +120,8 @@ enum fuse_req_state {
 	FUSE_REQ_FINISHED
 };
 
+struct fuse_conn;
+
 /**
  * A request to the client
  */
@@ -186,6 +188,9 @@ struct fuse_req {
 
 	/** File used in the request (or NULL) */
 	struct file *file;
+
+	/** Request completion callback */
+	void (*end)(struct fuse_conn *, struct fuse_req *);
 };
 
 /**

commit 69a53bf267fa58b89aa659d121dfe38436562a30
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Jan 16 22:14:41 2006 -0800

    [PATCH] fuse: add connection aborting
    
    Add ability to abort a filesystem connection.
    
    With the introduction of asynchronous reads, the ability to interrupt any
    request is not enough to dissolve deadlocks, since now waiting for the request
    completion (page unlocked) is independent of the actual request, so in a
    deadlock all threads will be uninterruptible.
    
    The solution is to make it possible to abort all requests, even those
    currently undergoing I/O to/from userspace.  The natural interface for this is
    'mount -f mountpoint', but that only works as long as the filesystem is
    attached.  So also add an 'abort' attribute to the sysfs view of the
    connection.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index bcb453f68111..e6381db41df9 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -246,8 +246,8 @@ struct fuse_conn {
 	/** Mount is active */
 	unsigned mounted : 1;
 
-	/** Connection established, cleared on umount and device
-	    release */
+	/** Connection established, cleared on umount, connection
+	    abort and device release */
 	unsigned connected : 1;
 
 	/** Connection failed (version mismatch) */
@@ -463,6 +463,9 @@ void request_send_background(struct fuse_conn *fc, struct fuse_req *req);
  */
 void fuse_release_background(struct fuse_req *req);
 
+/* Abort all requests */
+void fuse_abort_conn(struct fuse_conn *fc);
+
 /**
  * Get the attributes of a file
  */

commit 0cd5b88553acf0611474dbaf8e43770eed268060
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Jan 16 22:14:38 2006 -0800

    [PATCH] fuse: add number of waiting requests attribute
    
    This patch adds the 'waiting' attribute which indicates how many filesystem
    requests are currently waiting to be completed.  A non-zero value without any
    filesystem activity indicates a hung or deadlocked filesystem.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 6ef1e5f5873b..bcb453f68111 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -280,6 +280,9 @@ struct fuse_conn {
 	/** Is create not implemented by fs? */
 	unsigned no_create : 1;
 
+	/** The number of requests waiting for completion */
+	atomic_t num_waiting;
+
 	/** Negotiated minor version */
 	unsigned minor;
 

commit f543f253f3aa721a24557d7df8259145bb01b734
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Jan 16 22:14:35 2006 -0800

    [PATCH] fuse: make fuse connection a kobject
    
    Kobjectify fuse_conn, and make it visible under /sys/fs/fuse/connections.
    
    Lacking any natural naming, connections are numbered.
    
    This patch doesn't add any attributes, just the infrastructure.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index e824a09d3151..6ef1e5f5873b 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -196,9 +196,6 @@ struct fuse_req {
  * unmounted.
  */
 struct fuse_conn {
-	/** Reference count */
-	int count;
-
 	/** The user id for this mount */
 	uid_t user_id;
 
@@ -288,6 +285,9 @@ struct fuse_conn {
 
 	/** Backing dev info */
 	struct backing_dev_info bdi;
+
+	/** kobject */
+	struct kobject kobj;
 };
 
 static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)
@@ -300,6 +300,11 @@ static inline struct fuse_conn *get_fuse_conn(struct inode *inode)
 	return get_fuse_conn_super(inode->i_sb);
 }
 
+static inline struct fuse_conn *get_fuse_conn_kobj(struct kobject *obj)
+{
+	return container_of(obj, struct fuse_conn, kobj);
+}
+
 static inline struct fuse_inode *get_fuse_inode(struct inode *inode)
 {
 	return container_of(inode, struct fuse_inode, inode);
@@ -399,12 +404,6 @@ void fuse_init_symlink(struct inode *inode);
  */
 void fuse_change_attributes(struct inode *inode, struct fuse_attr *attr);
 
-/**
- * Check if the connection can be released, and if yes, then free the
- * connection structure
- */
-void fuse_release_conn(struct fuse_conn *fc);
-
 /**
  * Initialize the client device
  */

commit 9ba7cbba100bdaca7316d71d6c6298e61191f8b2
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Jan 16 22:14:34 2006 -0800

    [PATCH] fuse: extend semantics of connected flag
    
    The ->connected flag for a fuse_conn object previously only indicated whether
    the device file for this connection is currently open or not.
    
    Change it's meaning so that it indicates whether the connection is active or
    not: now either umount or device release will clear the flag.
    
    The separate ->mounted flag is still needed for handling background requests.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 5742253164d9..e824a09d3151 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -249,7 +249,8 @@ struct fuse_conn {
 	/** Mount is active */
 	unsigned mounted : 1;
 
-	/** Connection established */
+	/** Connection established, cleared on umount and device
+	    release */
 	unsigned connected : 1;
 
 	/** Connection failed (version mismatch) */

commit d77a1d5b611742c538364f041ff4610d27b14fe7
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Jan 16 22:14:31 2006 -0800

    [PATCH] fuse: introduce list for requests under I/O
    
    Create a new list for requests in the process of being transfered to/from
    userspace.  This will be needed to be able to abort all requests even those
    currently under I/O
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 8cc87ebeed2e..5742253164d9 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -124,8 +124,8 @@ enum fuse_req_state {
  * A request to the client
  */
 struct fuse_req {
-	/** This can be on either unused_list, pending or processing
-	    lists in fuse_conn */
+	/** This can be on either unused_list, pending processing or
+	    io lists in fuse_conn */
 	struct list_head list;
 
 	/** Entry on the background list */
@@ -223,6 +223,9 @@ struct fuse_conn {
 	/** The list of requests being processed */
 	struct list_head processing;
 
+	/** The list of requests under I/O */
+	struct list_head io;
+
 	/** Requests put in the background (RELEASE or any other
 	    interrupted request) */
 	struct list_head background;

commit 83cfd4935124b165e942c317dc3e9ebb0a3e6a63
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Jan 16 22:14:31 2006 -0800

    [PATCH] fuse: introduce unified request state
    
    The state of request was made up of 2 bitfields (->sent and ->finished) and of
    the fact that the request was on a list or not.
    
    Unify this into a single state field.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 27937e8018eb..8cc87ebeed2e 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -111,6 +111,15 @@ struct fuse_out {
 	struct fuse_arg args[3];
 };
 
+/** The request state */
+enum fuse_req_state {
+	FUSE_REQ_INIT = 0,
+	FUSE_REQ_PENDING,
+	FUSE_REQ_READING,
+	FUSE_REQ_SENT,
+	FUSE_REQ_FINISHED
+};
+
 /**
  * A request to the client
  */
@@ -140,11 +149,8 @@ struct fuse_req {
 	/** Data is being copied to/from the request */
 	unsigned locked:1;
 
-	/** Request has been sent to userspace */
-	unsigned sent:1;
-
-	/** The request is finished */
-	unsigned finished:1;
+	/** State of the request */
+	enum fuse_req_state state;
 
 	/** The request input */
 	struct fuse_in in;

commit 6383bdaa2ed2d461d9f4d369dfaa9d610fc972e3
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Jan 16 22:14:29 2006 -0800

    [PATCH] fuse: miscellaneous cleanup
    
     - remove some unneeded assignments
    
     - use kzalloc instead of kmalloc + memset
    
     - simplify setting sb->s_fs_info
    
     - in fuse_send_init() use fuse_get_request() instead of
       do_get_request() helper
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 74c8d098a14a..27937e8018eb 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -280,14 +280,9 @@ struct fuse_conn {
 	struct backing_dev_info bdi;
 };
 
-static inline struct fuse_conn **get_fuse_conn_super_p(struct super_block *sb)
-{
-	return (struct fuse_conn **) &sb->s_fs_info;
-}
-
 static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)
 {
-	return *get_fuse_conn_super_p(sb);
+	return sb->s_fs_info;
 }
 
 static inline struct fuse_conn *get_fuse_conn(struct inode *inode)

commit 3ec870d524c9150add120475c8ddcfa50574f98e
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Jan 6 00:19:41 2006 -0800

    [PATCH] fuse: make maximum write data configurable
    
    Make the maximum size of write data configurable by the filesystem.  The
    previous fixed 4096 limit only worked on architectures where the page size is
    less or equal to this.  This change make writing work on other architectures
    too, and also lets the filesystem receive bigger write requests in direct_io
    mode.
    
    Normal writes which go through the page cache are still limited to a page
    sized chunk per request.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 17fd368559cd..74c8d098a14a 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -21,9 +21,6 @@
 /** If more requests are outstanding, then the operation will block */
 #define FUSE_MAX_OUTSTANDING 10
 
-/** Maximum size of data in a write request */
-#define FUSE_MAX_WRITE 4096
-
 /** It could be as large as PATH_MAX, but would that have any uses? */
 #define FUSE_NAME_MAX 1024
 
@@ -162,7 +159,8 @@ struct fuse_req {
 	union {
 		struct fuse_forget_in forget_in;
 		struct fuse_release_in release_in;
-		struct fuse_init_in_out init_in_out;
+		struct fuse_init_in init_in;
+		struct fuse_init_out init_out;
 	} misc;
 
 	/** page vector */

commit 1d3d752b471d2a3a1d5e4fe177e5e7d52abb4e4c
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Jan 6 00:19:40 2006 -0800

    [PATCH] fuse: clean up request size limit checking
    
    Change the way a too large request is handled.  Until now in this case the
    device read returned -EINVAL and the operation returned -EIO.
    
    Make it more flexibible by not returning -EINVAL from the read, but restarting
    it instead.
    
    Also remove the fixed limit on setxattr data and let the filesystem provide as
    large a read buffer as it needs to handle the extended attribute data.
    
    The symbolic link length is already checked by VFS to be less than PATH_MAX,
    so the extra check against FUSE_SYMLINK_MAX is not needed.
    
    The check in fuse_create_open() against FUSE_NAME_MAX is not needed, since the
    dentry has already been looked up, and hence the name already checked.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 2d4835e54c90..17fd368559cd 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -21,6 +21,12 @@
 /** If more requests are outstanding, then the operation will block */
 #define FUSE_MAX_OUTSTANDING 10
 
+/** Maximum size of data in a write request */
+#define FUSE_MAX_WRITE 4096
+
+/** It could be as large as PATH_MAX, but would that have any uses? */
+#define FUSE_NAME_MAX 1024
+
 /** If the FUSE_DEFAULT_PERMISSIONS flag is given, the filesystem
     module will check permissions based on the file mode.  Otherwise no
     permission checking is done in the kernel */
@@ -108,9 +114,6 @@ struct fuse_out {
 	struct fuse_arg args[3];
 };
 
-struct fuse_req;
-struct fuse_conn;
-
 /**
  * A request to the client
  */

commit 45714d65618407bce1fd0271bc58303ce14b0785
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Jan 6 00:19:36 2006 -0800

    [PATCH] fuse: bump interface version
    
    Change interface version to 7.4.
    
    Following changes will need backward compatibility support, so store the minor
    version returned by userspace.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 0ea5301f86be..2d4835e54c90 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -272,6 +272,9 @@ struct fuse_conn {
 	/** Is create not implemented by fs? */
 	unsigned no_create : 1;
 
+	/** Negotiated minor version */
+	unsigned minor;
+
 	/** Backing dev info */
 	struct backing_dev_info bdi;
 };

commit fd72faac95d7e47610e981d7ed7b3c1529e55c88
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Nov 7 00:59:51 2005 -0800

    [PATCH] FUSE: atomic create+open
    
    This patch adds an atomic create+open operation.  This does not yet work if
    the file type changes between lookup and create+open, but solves the
    permission checking problems for the separte create and open methods.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index c4e8c3b47982..0ea5301f86be 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -269,6 +269,9 @@ struct fuse_conn {
 	/** Is access not implemented by fs? */
 	unsigned no_access : 1;
 
+	/** Is create not implemented by fs? */
+	unsigned no_create : 1;
+
 	/** Backing dev info */
 	struct backing_dev_info bdi;
 };
@@ -340,6 +343,17 @@ size_t fuse_send_read_common(struct fuse_req *req, struct file *file,
  */
 int fuse_open_common(struct inode *inode, struct file *file, int isdir);
 
+struct fuse_file *fuse_file_alloc(void);
+void fuse_file_free(struct fuse_file *ff);
+void fuse_finish_open(struct inode *inode, struct file *file,
+		      struct fuse_file *ff, struct fuse_open_out *outarg);
+
+/**
+ * Send a RELEASE request
+ */
+void fuse_send_release(struct fuse_conn *fc, struct fuse_file *ff,
+		       u64 nodeid, struct inode *inode, int flags, int isdir);
+
 /**
  * Send RELEASE or RELEASEDIR request
  */

commit 31d40d74b402a6fa18a006fb3745f64609f35b77
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Nov 7 00:59:50 2005 -0800

    [PATCH] FUSE: add access call
    
    Add a new access call, which will only be called if ->permission is invoked
    from sys_access().  In all other cases permission checking is delayed until
    the actual filesystem operation.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 5cb456f572c1..c4e8c3b47982 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -266,6 +266,9 @@ struct fuse_conn {
 	/** Is removexattr not implemented by fs? */
 	unsigned no_removexattr : 1;
 
+	/** Is access not implemented by fs? */
+	unsigned no_access : 1;
+
 	/** Backing dev info */
 	struct backing_dev_info bdi;
 };

commit 1779381dea3bada407396742c56bee31ffa8544e
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Sun Oct 30 15:02:51 2005 -0800

    [PATCH] fuse: spelling fixes
    
    Correct some typos and inconsistent use of "initialise" vs "initialize" in
    comments.  Reported by Ioannis Barkas.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 24d761518d86..5cb456f572c1 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -349,22 +349,22 @@ int fuse_fsync_common(struct file *file, struct dentry *de, int datasync,
 		      int isdir);
 
 /**
- * Initialise file operations on a regular file
+ * Initialize file operations on a regular file
  */
 void fuse_init_file_inode(struct inode *inode);
 
 /**
- * Initialise inode operations on regular files and special files
+ * Initialize inode operations on regular files and special files
  */
 void fuse_init_common(struct inode *inode);
 
 /**
- * Initialise inode and file operations on a directory
+ * Initialize inode and file operations on a directory
  */
 void fuse_init_dir(struct inode *inode);
 
 /**
- * Initialise inode operations on a symlink
+ * Initialize inode operations on a symlink
  */
 void fuse_init_symlink(struct inode *inode);
 
@@ -411,7 +411,7 @@ struct fuse_req *fuse_get_request(struct fuse_conn *fc);
 
 /**
  * Decrement reference count of a request.  If count goes to zero put
- * on unused list (preallocated) or free reqest (not preallocated).
+ * on unused list (preallocated) or free request (not preallocated).
  */
 void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req);
 
@@ -431,7 +431,7 @@ void request_send_noreply(struct fuse_conn *fc, struct fuse_req *req);
 void request_send_background(struct fuse_conn *fc, struct fuse_req *req);
 
 /**
- * Release inodes and file assiciated with background request
+ * Release inodes and file associated with background request
  */
 void fuse_release_background(struct fuse_req *req);
 

commit 7c352bdf048811b8128019ffc1e886161e09c11c
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Sep 9 13:10:39 2005 -0700

    [PATCH] FUSE: don't allow restarting of system calls
    
    This patch removes ability to interrupt and restart operations while there
    hasn't been any side-effect.
    
    The reason: applications.  There are some apps it seems that generate
    signals at a fast rate.  This means, that if the operation cannot make
    enough progress between two signals, it will be restarted for ever.  This
    bug actually manifested itself with 'krusader' trying to open a file for
    writing under sshfs.  Thanks to Eduard Czimbalmos for the report.
    
    The problem can be solved just by making open() uninterruptible, because in
    this case it was the truncate operation that slowed down the progress.  But
    it's better to solve this by simply not allowing interrupts at all (except
    SIGKILL), because applications don't expect file operations to be
    interruptible anyway.  As an added bonus the code is simplified somewhat.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index d7647289d8a1..24d761518d86 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -409,11 +409,6 @@ void fuse_reset_request(struct fuse_req *req);
  */
 struct fuse_req *fuse_get_request(struct fuse_conn *fc);
 
-/**
- * Reserve a preallocated request, only interruptible by SIGKILL
- */
-struct fuse_req *fuse_get_request_nonint(struct fuse_conn *fc);
-
 /**
  * Decrement reference count of a request.  If count goes to zero put
  * on unused list (preallocated) or free reqest (not preallocated).
@@ -421,15 +416,10 @@ struct fuse_req *fuse_get_request_nonint(struct fuse_conn *fc);
 void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req);
 
 /**
- * Send a request (synchronous, interruptible)
+ * Send a request (synchronous)
  */
 void request_send(struct fuse_conn *fc, struct fuse_req *req);
 
-/**
- * Send a request (synchronous, non-interruptible except by SIGKILL)
- */
-void request_send_nonint(struct fuse_conn *fc, struct fuse_req *req);
-
 /**
  * Send a request with no reply
  */

commit 8254798199332966e2ab647380c990193af7e854
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Sep 9 13:10:38 2005 -0700

    [PATCH] FUSE: add fsync operation for directories
    
    This patch adds a new FSYNCDIR request, which is sent when fsync is called
    on directories.  This operation is available in libfuse 2.3-pre1 or
    greater.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 84849601363e..d7647289d8a1 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -248,6 +248,9 @@ struct fuse_conn {
 	/** Is fsync not implemented by fs? */
 	unsigned no_fsync : 1;
 
+	/** Is fsyncdir not implemented by fs? */
+	unsigned no_fsyncdir : 1;
+
 	/** Is flush not implemented by fs? */
 	unsigned no_flush : 1;
 
@@ -339,6 +342,12 @@ int fuse_open_common(struct inode *inode, struct file *file, int isdir);
  */
 int fuse_release_common(struct inode *inode, struct file *file, int isdir);
 
+/**
+ * Send FSYNC or FSYNCDIR request
+ */
+int fuse_fsync_common(struct file *file, struct dentry *de, int datasync,
+		      int isdir);
+
 /**
  * Initialise file operations on a regular file
  */

commit 45323fb76465a9576220c7427dbac7b1e7ad3caf
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Sep 9 13:10:37 2005 -0700

    [PATCH] fuse: more flexible caching
    
    Make data caching behavior selectable on a per-open basis instead of
    per-mount.  Compatibility for the old mount options 'kernel_cache' and
    'direct_io' is retained in the userspace library (version 2.4.0-pre1 or
    later).
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 8593d5bae7a6..84849601363e 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -30,12 +30,6 @@
     doing the mount will be allowed to access the filesystem */
 #define FUSE_ALLOW_OTHER         (1 << 1)
 
-/** If the FUSE_KERNEL_CACHE flag is given, then cached data will not
-    be flushed on open */
-#define FUSE_KERNEL_CACHE        (1 << 2)
-
-/** Bypass the page cache for read and write operations  */
-#define FUSE_DIRECT_IO           (1 << 3)
 
 /** FUSE inode */
 struct fuse_inode {

commit 04730fef1f9c7277e5c730b193e681ac095b0507
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Sep 9 13:10:36 2005 -0700

    [PATCH] fuse: transfer readdir data through device
    
    This patch removes a long lasting "hack" in FUSE, which used a separate
    channel (a file descriptor refering to a disk-file) to transfer directory
    contents from userspace to the kernel.
    
    The patch adds three new operations (OPENDIR, READDIR, RELEASEDIR), which
    have semantics and implementation exactly maching the respective file
    operations (OPEN, READ, RELEASE).
    
    This simplifies the directory reading code.  Also disk space is not
    necessary, which can be important in embedded systems.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 0af1ac646927..8593d5bae7a6 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -273,11 +273,6 @@ struct fuse_conn {
 	struct backing_dev_info bdi;
 };
 
-struct fuse_getdir_out_i {
-	int fd;
-	void *file; /* Used by kernel only */
-};
-
 static inline struct fuse_conn **get_fuse_conn_super_p(struct super_block *sb)
 {
 	return (struct fuse_conn **) &sb->s_fs_info;
@@ -333,6 +328,23 @@ struct inode *fuse_iget(struct super_block *sb, unsigned long nodeid,
 void fuse_send_forget(struct fuse_conn *fc, struct fuse_req *req,
 		      unsigned long nodeid, u64 nlookup);
 
+/**
+ * Send READ or READDIR request
+ */
+size_t fuse_send_read_common(struct fuse_req *req, struct file *file,
+			     struct inode *inode, loff_t pos, size_t count,
+			     int isdir);
+
+/**
+ * Send OPEN or OPENDIR request
+ */
+int fuse_open_common(struct inode *inode, struct file *file, int isdir);
+
+/**
+ * Send RELEASE or RELEASEDIR request
+ */
+int fuse_release_common(struct inode *inode, struct file *file, int isdir);
+
 /**
  * Initialise file operations on a regular file
  */

commit 413ef8cb302511d8e995e2b0e5517ee1a65b9c77
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Sep 9 13:10:35 2005 -0700

    [PATCH] FUSE - direct I/O
    
    This patch adds support for the "direct_io" mount option of FUSE.
    
    When this mount option is specified, the page cache is bypassed for
    read and write operations.  This is useful for example, if the
    filesystem doesn't know the size of files before reading them, or when
    any kind of caching is harmful.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 3ec2aff3fdb5..0af1ac646927 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -34,6 +34,9 @@
     be flushed on open */
 #define FUSE_KERNEL_CACHE        (1 << 2)
 
+/** Bypass the page cache for read and write operations  */
+#define FUSE_DIRECT_IO           (1 << 3)
+
 /** FUSE inode */
 struct fuse_inode {
 	/** Inode data */
@@ -207,6 +210,9 @@ struct fuse_conn {
 	/** Maximum read size */
 	unsigned max_read;
 
+	/** Maximum write size */
+	unsigned max_write;
+
 	/** Readers of the connection are waiting on this */
 	wait_queue_head_t waitq;
 

commit 87729a5514e855ce2c71e3e33833a106b8caf2ae
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Sep 9 13:10:34 2005 -0700

    [PATCH] FUSE: tighten check for processes allowed access
    
    This patch tightens the check for allowing processes to access non-privileged
    mounts.  The rational is that the filesystem implementation can control the
    behavior or get otherwise unavailable information of the filesystem user.  If
    the filesystem user process has the same uid, gid, and is not suid or sgid
    application, then access is safe.  Otherwise access is not allowed unless the
    "allow_other" mount option is given (for which policy is controlled by the
    userspace mount utility).
    
    Thanks to everyone linux-fsdevel, especially Martin Mares who helped uncover
    problems with the previous approach.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index aff3a01ea02b..3ec2aff3fdb5 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -198,6 +198,9 @@ struct fuse_conn {
 	/** The user id for this mount */
 	uid_t user_id;
 
+	/** The group id for this mount */
+	gid_t group_id;
+
 	/** The fuse mount flags for this mount */
 	unsigned flags;
 

commit db50b96c0f28a21c5a4a19ecaba12d0972aab06a
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Sep 9 13:10:33 2005 -0700

    [PATCH] FUSE - readpages operation
    
    This patch adds readpages support to FUSE.
    
    With the help of the readpages() operation multiple reads are bundled
    together and sent as a single request to userspace.  This can improve
    reading performace.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 86183c562104..aff3a01ea02b 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -201,6 +201,9 @@ struct fuse_conn {
 	/** The fuse mount flags for this mount */
 	unsigned flags;
 
+	/** Maximum read size */
+	unsigned max_read;
+
 	/** Readers of the connection are waiting on this */
 	wait_queue_head_t waitq;
 

commit 92a8780e1136c5ca0c7ed940000d399943d1576e
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Sep 9 13:10:31 2005 -0700

    [PATCH] FUSE - extended attribute operations
    
    This patch adds the extended attribute operations to FUSE.
    
    The following operations are added:
    
     o getxattr
     o setxattr
     o listxattr
     o removexattr
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index c8e6c87496e0..86183c562104 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -245,6 +245,18 @@ struct fuse_conn {
 	/** Is flush not implemented by fs? */
 	unsigned no_flush : 1;
 
+	/** Is setxattr not implemented by fs? */
+	unsigned no_setxattr : 1;
+
+	/** Is getxattr not implemented by fs? */
+	unsigned no_getxattr : 1;
+
+	/** Is listxattr not implemented by fs? */
+	unsigned no_listxattr : 1;
+
+	/** Is removexattr not implemented by fs? */
+	unsigned no_removexattr : 1;
+
 	/** Backing dev info */
 	struct backing_dev_info bdi;
 };

commit 1e9a4ed9396e9c31139721b639550ffb1df17065
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Sep 9 13:10:31 2005 -0700

    [PATCH] FUSE - mount options
    
    This patch adds miscellaneous mount options to the FUSE filesystem.
    
    The following mount options are added:
    
     o default_permissions:  check permissions with generic_permission()
     o allow_other:          allow other users to access files
     o allow_root:           allow root to access files
     o kernel_cache:         don't invalidate page cache on open
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index b4aa8f7bc2c1..c8e6c87496e0 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -21,6 +21,19 @@
 /** If more requests are outstanding, then the operation will block */
 #define FUSE_MAX_OUTSTANDING 10
 
+/** If the FUSE_DEFAULT_PERMISSIONS flag is given, the filesystem
+    module will check permissions based on the file mode.  Otherwise no
+    permission checking is done in the kernel */
+#define FUSE_DEFAULT_PERMISSIONS (1 << 0)
+
+/** If the FUSE_ALLOW_OTHER flag is given, then not only the user
+    doing the mount will be allowed to access the filesystem */
+#define FUSE_ALLOW_OTHER         (1 << 1)
+
+/** If the FUSE_KERNEL_CACHE flag is given, then cached data will not
+    be flushed on open */
+#define FUSE_KERNEL_CACHE        (1 << 2)
+
 /** FUSE inode */
 struct fuse_inode {
 	/** Inode data */
@@ -109,6 +122,9 @@ struct fuse_req {
 	    lists in fuse_conn */
 	struct list_head list;
 
+	/** Entry on the background list */
+	struct list_head bg_entry;
+
 	/** refcount */
 	atomic_t count;
 
@@ -176,15 +192,15 @@ struct fuse_req {
  * unmounted.
  */
 struct fuse_conn {
-	/** The superblock of the mounted filesystem */
-	struct super_block *sb;
-
-	/** The opened client device */
-	struct file *file;
+	/** Reference count */
+	int count;
 
 	/** The user id for this mount */
 	uid_t user_id;
 
+	/** The fuse mount flags for this mount */
+	unsigned flags;
+
 	/** Readers of the connection are waiting on this */
 	wait_queue_head_t waitq;
 
@@ -194,6 +210,10 @@ struct fuse_conn {
 	/** The list of requests being processed */
 	struct list_head processing;
 
+	/** Requests put in the background (RELEASE or any other
+	    interrupted request) */
+	struct list_head background;
+
 	/** Controls the maximum number of outstanding requests */
 	struct semaphore outstanding_sem;
 
@@ -201,12 +221,21 @@ struct fuse_conn {
 	    outstanding_sem would go negative */
 	unsigned outstanding_debt;
 
+	/** RW semaphore for exclusion with fuse_put_super() */
+	struct rw_semaphore sbput_sem;
+
 	/** The list of unused requests */
 	struct list_head unused_list;
 
 	/** The next unique request id */
 	u64 reqctr;
 
+	/** Mount is active */
+	unsigned mounted : 1;
+
+	/** Connection established */
+	unsigned connected : 1;
+
 	/** Connection failed (version mismatch) */
 	unsigned conn_error : 1;
 
@@ -261,6 +290,7 @@ extern struct file_operations fuse_dev_operations;
  *  - the private_data field of the device file
  *  - the s_fs_info field of the super block
  *  - unused_list, pending, processing lists in fuse_conn
+ *  - background list in fuse_conn
  *  - the unique request ID counter reqctr in fuse_conn
  *  - the sb (super_block) field in fuse_conn
  *  - the file (device file) field in fuse_conn
@@ -371,6 +401,11 @@ void request_send_noreply(struct fuse_conn *fc, struct fuse_req *req);
  */
 void request_send_background(struct fuse_conn *fc, struct fuse_req *req);
 
+/**
+ * Release inodes and file assiciated with background request
+ */
+void fuse_release_background(struct fuse_req *req);
+
 /**
  * Get the attributes of a file
  */

commit b6aeadeda22a9aa322fdfcd3f4c69ccf0da5cbdd
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Sep 9 13:10:30 2005 -0700

    [PATCH] FUSE - file operations
    
    This patch adds the file operations of FUSE.
    
    The following operations are added:
    
     o open
     o flush
     o release
     o fsync
     o readpage
     o commit_write
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 87d25b8f2dc1..b4aa8f7bc2c1 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -40,6 +40,15 @@ struct fuse_inode {
 	unsigned long i_time;
 };
 
+/** FUSE specific file data */
+struct fuse_file {
+	/** Request reserved for flush and release */
+	struct fuse_req *release_req;
+
+	/** File handle used by userspace */
+	u64 fh;
+};
+
 /** One input argument of a request */
 struct fuse_in_arg {
 	unsigned size;
@@ -136,6 +145,7 @@ struct fuse_req {
 	/** Data for asynchronous requests */
 	union {
 		struct fuse_forget_in forget_in;
+		struct fuse_release_in release_in;
 		struct fuse_init_in_out init_in_out;
 	} misc;
 
@@ -200,6 +210,12 @@ struct fuse_conn {
 	/** Connection failed (version mismatch) */
 	unsigned conn_error : 1;
 
+	/** Is fsync not implemented by fs? */
+	unsigned no_fsync : 1;
+
+	/** Is flush not implemented by fs? */
+	unsigned no_flush : 1;
+
 	/** Backing dev info */
 	struct backing_dev_info bdi;
 };
@@ -263,6 +279,11 @@ struct inode *fuse_iget(struct super_block *sb, unsigned long nodeid,
 void fuse_send_forget(struct fuse_conn *fc, struct fuse_req *req,
 		      unsigned long nodeid, u64 nlookup);
 
+/**
+ * Initialise file operations on a regular file
+ */
+void fuse_init_file_inode(struct inode *inode);
+
 /**
  * Initialise inode operations on regular files and special files
  */

commit 9e6268db496a2592e89457537ea54a496feabb77
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Sep 9 13:10:29 2005 -0700

    [PATCH] FUSE - read-write operations
    
    This patch adds the write filesystem operations of FUSE.
    
    The following operations are added:
    
     o setattr
     o symlink
     o mknod
     o mkdir
     o create
     o unlink
     o rmdir
     o rename
     o link
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 8d91e1492f96..87d25b8f2dc1 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -30,6 +30,9 @@ struct fuse_inode {
 	 * and kernel */
 	u64 nodeid;
 
+	/** Number of lookups on this inode */
+	u64 nlookup;
+
 	/** The request used for sending the FORGET message */
 	struct fuse_req *forget_req;
 
@@ -252,13 +255,13 @@ extern spinlock_t fuse_lock;
  * Get a filled in inode
  */
 struct inode *fuse_iget(struct super_block *sb, unsigned long nodeid,
-			int generation, struct fuse_attr *attr, int version);
+			int generation, struct fuse_attr *attr);
 
 /**
  * Send FORGET command
  */
 void fuse_send_forget(struct fuse_conn *fc, struct fuse_req *req,
-		      unsigned long nodeid, int version);
+		      unsigned long nodeid, u64 nlookup);
 
 /**
  * Initialise inode operations on regular files and special files

commit e5e5558e923f35839108a12718494ecb73fb782f
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Sep 9 13:10:28 2005 -0700

    [PATCH] FUSE - read-only operations
    
    This patch adds the read-only filesystem operations of FUSE.
    
    This contains the following files:
    
     o dir.c
        - directory, symlink and file-inode operations
    
    The following operations are added:
    
     o lookup
     o getattr
     o readlink
     o follow_link
     o directory open
     o readdir
     o directory release
     o permission
     o dentry revalidate
     o statfs
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 50ad6a0c39bf..8d91e1492f96 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -30,6 +30,9 @@ struct fuse_inode {
 	 * and kernel */
 	u64 nodeid;
 
+	/** The request used for sending the FORGET message */
+	struct fuse_req *forget_req;
+
 	/** Time in jiffies until the file attributes are valid */
 	unsigned long i_time;
 };
@@ -129,6 +132,7 @@ struct fuse_req {
 
 	/** Data for asynchronous requests */
 	union {
+		struct fuse_forget_in forget_in;
 		struct fuse_init_in_out init_in_out;
 	} misc;
 
@@ -197,6 +201,11 @@ struct fuse_conn {
 	struct backing_dev_info bdi;
 };
 
+struct fuse_getdir_out_i {
+	int fd;
+	void *file; /* Used by kernel only */
+};
+
 static inline struct fuse_conn **get_fuse_conn_super_p(struct super_block *sb)
 {
 	return (struct fuse_conn **) &sb->s_fs_info;
@@ -239,6 +248,38 @@ extern struct file_operations fuse_dev_operations;
  */
 extern spinlock_t fuse_lock;
 
+/**
+ * Get a filled in inode
+ */
+struct inode *fuse_iget(struct super_block *sb, unsigned long nodeid,
+			int generation, struct fuse_attr *attr, int version);
+
+/**
+ * Send FORGET command
+ */
+void fuse_send_forget(struct fuse_conn *fc, struct fuse_req *req,
+		      unsigned long nodeid, int version);
+
+/**
+ * Initialise inode operations on regular files and special files
+ */
+void fuse_init_common(struct inode *inode);
+
+/**
+ * Initialise inode and file operations on a directory
+ */
+void fuse_init_dir(struct inode *inode);
+
+/**
+ * Initialise inode operations on a symlink
+ */
+void fuse_init_symlink(struct inode *inode);
+
+/**
+ * Change attributes of an inode
+ */
+void fuse_change_attributes(struct inode *inode, struct fuse_attr *attr);
+
 /**
  * Check if the connection can be released, and if yes, then free the
  * connection structure
@@ -306,6 +347,16 @@ void request_send_noreply(struct fuse_conn *fc, struct fuse_req *req);
  */
 void request_send_background(struct fuse_conn *fc, struct fuse_req *req);
 
+/**
+ * Get the attributes of a file
+ */
+int fuse_do_getattr(struct inode *inode);
+
+/**
+ * Invalidate inode attributes
+ */
+void fuse_invalidate_attr(struct inode *inode);
+
 /**
  * Send the INIT message
  */

commit 334f485df85ac7736ebe14940bf0a059c5f26d7d
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Sep 9 13:10:27 2005 -0700

    [PATCH] FUSE - device functions
    
    This adds the FUSE device handling functions.
    
    This contains the following files:
    
     o dev.c
        - fuse device operations (read, write, release, poll)
        - registers misc device
        - support for sending requests to userspace
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index eed6e89ce01f..50ad6a0c39bf 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -15,6 +15,12 @@
 #include <linux/backing-dev.h>
 #include <asm/semaphore.h>
 
+/** Max number of pages that can be used in a single read request */
+#define FUSE_MAX_PAGES_PER_REQ 32
+
+/** If more requests are outstanding, then the operation will block */
+#define FUSE_MAX_OUTSTANDING 10
+
 /** FUSE inode */
 struct fuse_inode {
 	/** Inode data */
@@ -28,6 +34,123 @@ struct fuse_inode {
 	unsigned long i_time;
 };
 
+/** One input argument of a request */
+struct fuse_in_arg {
+	unsigned size;
+	const void *value;
+};
+
+/** The request input */
+struct fuse_in {
+	/** The request header */
+	struct fuse_in_header h;
+
+	/** True if the data for the last argument is in req->pages */
+	unsigned argpages:1;
+
+	/** Number of arguments */
+	unsigned numargs;
+
+	/** Array of arguments */
+	struct fuse_in_arg args[3];
+};
+
+/** One output argument of a request */
+struct fuse_arg {
+	unsigned size;
+	void *value;
+};
+
+/** The request output */
+struct fuse_out {
+	/** Header returned from userspace */
+	struct fuse_out_header h;
+
+	/** Last argument is variable length (can be shorter than
+	    arg->size) */
+	unsigned argvar:1;
+
+	/** Last argument is a list of pages to copy data to */
+	unsigned argpages:1;
+
+	/** Zero partially or not copied pages */
+	unsigned page_zeroing:1;
+
+	/** Number or arguments */
+	unsigned numargs;
+
+	/** Array of arguments */
+	struct fuse_arg args[3];
+};
+
+struct fuse_req;
+struct fuse_conn;
+
+/**
+ * A request to the client
+ */
+struct fuse_req {
+	/** This can be on either unused_list, pending or processing
+	    lists in fuse_conn */
+	struct list_head list;
+
+	/** refcount */
+	atomic_t count;
+
+	/** True if the request has reply */
+	unsigned isreply:1;
+
+	/** The request is preallocated */
+	unsigned preallocated:1;
+
+	/** The request was interrupted */
+	unsigned interrupted:1;
+
+	/** Request is sent in the background */
+	unsigned background:1;
+
+	/** Data is being copied to/from the request */
+	unsigned locked:1;
+
+	/** Request has been sent to userspace */
+	unsigned sent:1;
+
+	/** The request is finished */
+	unsigned finished:1;
+
+	/** The request input */
+	struct fuse_in in;
+
+	/** The request output */
+	struct fuse_out out;
+
+	/** Used to wake up the task waiting for completion of request*/
+	wait_queue_head_t waitq;
+
+	/** Data for asynchronous requests */
+	union {
+		struct fuse_init_in_out init_in_out;
+	} misc;
+
+	/** page vector */
+	struct page *pages[FUSE_MAX_PAGES_PER_REQ];
+
+	/** number of pages in vector */
+	unsigned num_pages;
+
+	/** offset of data on first page */
+	unsigned page_offset;
+
+	/** Inode used in the request */
+	struct inode *inode;
+
+	/** Second inode used in the request (or NULL) */
+	struct inode *inode2;
+
+	/** File used in the request (or NULL) */
+	struct file *file;
+};
+
 /**
  * A Fuse connection.
  *
@@ -39,9 +162,37 @@ struct fuse_conn {
 	/** The superblock of the mounted filesystem */
 	struct super_block *sb;
 
+	/** The opened client device */
+	struct file *file;
+
 	/** The user id for this mount */
 	uid_t user_id;
 
+	/** Readers of the connection are waiting on this */
+	wait_queue_head_t waitq;
+
+	/** The list of pending requests */
+	struct list_head pending;
+
+	/** The list of requests being processed */
+	struct list_head processing;
+
+	/** Controls the maximum number of outstanding requests */
+	struct semaphore outstanding_sem;
+
+	/** This counts the number of outstanding requests if
+	    outstanding_sem would go negative */
+	unsigned outstanding_debt;
+
+	/** The list of unused requests */
+	struct list_head unused_list;
+
+	/** The next unique request id */
+	u64 reqctr;
+
+	/** Connection failed (version mismatch) */
+	unsigned conn_error : 1;
+
 	/** Backing dev info */
 	struct backing_dev_info bdi;
 };
@@ -71,13 +222,20 @@ static inline u64 get_node_id(struct inode *inode)
 	return get_fuse_inode(inode)->nodeid;
 }
 
+/** Device operations */
+extern struct file_operations fuse_dev_operations;
+
 /**
  * This is the single global spinlock which protects FUSE's structures
  *
  * The following data is protected by this lock:
  *
+ *  - the private_data field of the device file
  *  - the s_fs_info field of the super block
+ *  - unused_list, pending, processing lists in fuse_conn
+ *  - the unique request ID counter reqctr in fuse_conn
  *  - the sb (super_block) field in fuse_conn
+ *  - the file (device file) field in fuse_conn
  */
 extern spinlock_t fuse_lock;
 
@@ -87,3 +245,68 @@ extern spinlock_t fuse_lock;
  */
 void fuse_release_conn(struct fuse_conn *fc);
 
+/**
+ * Initialize the client device
+ */
+int fuse_dev_init(void);
+
+/**
+ * Cleanup the client device
+ */
+void fuse_dev_cleanup(void);
+
+/**
+ * Allocate a request
+ */
+struct fuse_req *fuse_request_alloc(void);
+
+/**
+ * Free a request
+ */
+void fuse_request_free(struct fuse_req *req);
+
+/**
+ * Reinitialize a request, the preallocated flag is left unmodified
+ */
+void fuse_reset_request(struct fuse_req *req);
+
+/**
+ * Reserve a preallocated request
+ */
+struct fuse_req *fuse_get_request(struct fuse_conn *fc);
+
+/**
+ * Reserve a preallocated request, only interruptible by SIGKILL
+ */
+struct fuse_req *fuse_get_request_nonint(struct fuse_conn *fc);
+
+/**
+ * Decrement reference count of a request.  If count goes to zero put
+ * on unused list (preallocated) or free reqest (not preallocated).
+ */
+void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req);
+
+/**
+ * Send a request (synchronous, interruptible)
+ */
+void request_send(struct fuse_conn *fc, struct fuse_req *req);
+
+/**
+ * Send a request (synchronous, non-interruptible except by SIGKILL)
+ */
+void request_send_nonint(struct fuse_conn *fc, struct fuse_req *req);
+
+/**
+ * Send a request with no reply
+ */
+void request_send_noreply(struct fuse_conn *fc, struct fuse_req *req);
+
+/**
+ * Send a request in the background
+ */
+void request_send_background(struct fuse_conn *fc, struct fuse_req *req);
+
+/**
+ * Send the INIT message
+ */
+void fuse_send_init(struct fuse_conn *fc);

commit d8a5ba45457e4a22aa39c939121efd7bb6c76672
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Sep 9 13:10:26 2005 -0700

    [PATCH] FUSE - core
    
    This patch adds FUSE core.
    
    This contains the following files:
    
     o inode.c
        - superblock operations (alloc_inode, destroy_inode, read_inode,
          clear_inode, put_super, show_options)
        - registers FUSE filesystem
    
     o fuse_i.h
        - private header file
    
    Requirements
    ============
    
     The most important difference between orinary filesystems and FUSE is
     the fact, that the filesystem data/metadata is provided by a userspace
     process run with the privileges of the mount "owner" instead of the
     kernel, or some remote entity usually running with elevated
     privileges.
    
     The security implication of this is that a non-privileged user must
     not be able to use this capability to compromise the system.  Obvious
     requirements arising from this are:
    
      - mount owner should not be able to get elevated privileges with the
        help of the mounted filesystem
    
      - mount owner should not be able to induce undesired behavior in
        other users' or the super user's processes
    
      - mount owner should not get illegitimate access to information from
        other users' and the super user's processes
    
     These are currently ensured with the following constraints:
    
      1) mount is only allowed to directory or file which the mount owner
        can modify without limitation (write access + no sticky bit for
        directories)
    
      2) nosuid,nodev mount options are forced
    
      3) any process running with fsuid different from the owner is denied
         all access to the filesystem
    
     1) and 2) are ensured by the "fusermount" mount utility which is a
        setuid root application doing the actual mount operation.
    
     3) is ensured by a check in the permission() method in kernel
    
     I started thinking about doing 3) in a different way because Christoph
     H. made a big deal out of it, saying that FUSE is unacceptable into
     mainline in this form.
    
     The suggested use of private namespaces would be OK, but in their
     current form have many limitations that make their use impractical (as
     discussed in this thread).
    
     Suggested improvements that would address these limitations:
    
       - implement shared subtrees
    
       - allow a process to join an existing namespace (make namespaces
         first-class objects)
    
       - implement the namespace creation/joining in a PAM module
    
     With all that in place the check of owner against current->fsuid may
     be removed from the FUSE kernel module, without compromising the
     security requirements.
    
     Suid programs still interesting questions, since they get access even
     to the private namespace causing some information leak (exact
     order/timing of filesystem operations performed), giving some
     ptrace-like capabilities to unprivileged users.  BTW this problem is
     not strictly limited to the namespace approach, since suid programs
     setting fsuid and accessing users' files will succeed with the current
     approach too.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
new file mode 100644
index 000000000000..eed6e89ce01f
--- /dev/null
+++ b/fs/fuse/fuse_i.h
@@ -0,0 +1,89 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2005  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU GPL.
+  See the file COPYING.
+*/
+
+#include <linux/fuse.h>
+#include <linux/fs.h>
+#include <linux/wait.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/backing-dev.h>
+#include <asm/semaphore.h>
+
+/** FUSE inode */
+struct fuse_inode {
+	/** Inode data */
+	struct inode inode;
+
+	/** Unique ID, which identifies the inode between userspace
+	 * and kernel */
+	u64 nodeid;
+
+	/** Time in jiffies until the file attributes are valid */
+	unsigned long i_time;
+};
+
+/**
+ * A Fuse connection.
+ *
+ * This structure is created, when the filesystem is mounted, and is
+ * destroyed, when the client device is closed and the filesystem is
+ * unmounted.
+ */
+struct fuse_conn {
+	/** The superblock of the mounted filesystem */
+	struct super_block *sb;
+
+	/** The user id for this mount */
+	uid_t user_id;
+
+	/** Backing dev info */
+	struct backing_dev_info bdi;
+};
+
+static inline struct fuse_conn **get_fuse_conn_super_p(struct super_block *sb)
+{
+	return (struct fuse_conn **) &sb->s_fs_info;
+}
+
+static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)
+{
+	return *get_fuse_conn_super_p(sb);
+}
+
+static inline struct fuse_conn *get_fuse_conn(struct inode *inode)
+{
+	return get_fuse_conn_super(inode->i_sb);
+}
+
+static inline struct fuse_inode *get_fuse_inode(struct inode *inode)
+{
+	return container_of(inode, struct fuse_inode, inode);
+}
+
+static inline u64 get_node_id(struct inode *inode)
+{
+	return get_fuse_inode(inode)->nodeid;
+}
+
+/**
+ * This is the single global spinlock which protects FUSE's structures
+ *
+ * The following data is protected by this lock:
+ *
+ *  - the s_fs_info field of the super block
+ *  - the sb (super_block) field in fuse_conn
+ */
+extern spinlock_t fuse_lock;
+
+/**
+ * Check if the connection can be released, and if yes, then free the
+ * connection structure
+ */
+void fuse_release_conn(struct fuse_conn *fc);
+
