commit 0ab575c5df5e4a7eb3a80c682de1165189d888e0
Author: zhengbin <zhengbin13@huawei.com>
Date:   Thu Dec 19 17:25:34 2019 +0800

    btrfs: Remove unneeded semicolon
    
    Fixes coccicheck warning:
    
    fs/btrfs/print-tree.c:320:3-4: Unneeded semicolon
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: zhengbin <zhengbin13@huawei.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 873b6b694107..61f44e78e3c9 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -317,7 +317,7 @@ void btrfs_print_leaf(struct extent_buffer *l)
 			print_uuid_item(l, btrfs_item_ptr_offset(l, i),
 					btrfs_item_size_nr(l, i));
 			break;
-		};
+		}
 	}
 }
 

commit 0222dfdd4af1be2e70db956db61f9b43386ab76b
Author: David Sterba <dsterba@suse.com>
Date:   Wed Oct 23 18:48:20 2019 +0200

    btrfs: rename extent buffer block group item accessors
    
    Accessors defined by BTRFS_SETGET_FUNCS take a raw extent buffer and
    manipulate the items there, there's no special prefix required. The
    block group accessors had _disk_ because previously the names were
    occupied by the on-stack accessors. As this has been addressed in the
    previous patch, we can now unify the naming.
    
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 9cb50577d982..873b6b694107 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -266,9 +266,9 @@ void btrfs_print_leaf(struct extent_buffer *l)
 					    struct btrfs_block_group_item);
 			pr_info(
 		   "\t\tblock group used %llu chunk_objectid %llu flags %llu\n",
-				btrfs_disk_block_group_used(l, bi),
-				btrfs_disk_block_group_chunk_objectid(l, bi),
-				btrfs_disk_block_group_flags(l, bi));
+				btrfs_block_group_used(l, bi),
+				btrfs_block_group_chunk_objectid(l, bi),
+				btrfs_block_group_flags(l, bi));
 			break;
 		case BTRFS_CHUNK_ITEM_KEY:
 			print_chunk(l, btrfs_item_ptr(l, i,

commit 00801ae4bb2be5f5af46502ef239ac5f4b536094
Author: David Sterba <dsterba@suse.com>
Date:   Thu May 2 16:53:47 2019 +0200

    btrfs: switch extent_buffer write_locks from atomic to int
    
    The write_locks is either 0 or 1 and always updated under the lock,
    so we don't need the atomic_t semantics.
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index c5cc435ed39a..9cb50577d982 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -153,7 +153,7 @@ static void print_eb_refs_lock(struct extent_buffer *eb)
 #ifdef CONFIG_BTRFS_DEBUG
 	btrfs_info(eb->fs_info,
 "refs %u lock (w:%d r:%d bw:%d br:%d sw:%d sr:%d) lock_owner %u current %u",
-		   atomic_read(&eb->refs), atomic_read(&eb->write_locks),
+		   atomic_read(&eb->refs), eb->write_locks,
 		   atomic_read(&eb->read_locks),
 		   eb->blocking_writers,
 		   atomic_read(&eb->blocking_readers),

commit f3dc24c52a28c700e35757dce7b38456888071e1
Author: David Sterba <dsterba@suse.com>
Date:   Thu May 2 16:51:53 2019 +0200

    btrfs: switch extent_buffer spinning_writers from atomic to int
    
    The spinning_writers is either 0 or 1 and always updated under the lock,
    so we don't need the atomic_t semantics.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 7cb4f1fbe043..c5cc435ed39a 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -157,7 +157,7 @@ static void print_eb_refs_lock(struct extent_buffer *eb)
 		   atomic_read(&eb->read_locks),
 		   eb->blocking_writers,
 		   atomic_read(&eb->blocking_readers),
-		   atomic_read(&eb->spinning_writers),
+		   eb->spinning_writers,
 		   atomic_read(&eb->spinning_readers),
 		   eb->lock_owner, current->pid);
 #endif

commit 06297d8cefcaa2029c4cb71b79285d2bfff06d4d
Author: David Sterba <dsterba@suse.com>
Date:   Thu May 2 16:47:23 2019 +0200

    btrfs: switch extent_buffer blocking_writers from atomic to int
    
    The blocking_writers is either 0 or 1 and always updated under the lock,
    so we don't need the atomic_t semantics.
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 1141ca5fae6a..7cb4f1fbe043 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -155,7 +155,7 @@ static void print_eb_refs_lock(struct extent_buffer *eb)
 "refs %u lock (w:%d r:%d bw:%d br:%d sw:%d sr:%d) lock_owner %u current %u",
 		   atomic_read(&eb->refs), atomic_read(&eb->write_locks),
 		   atomic_read(&eb->read_locks),
-		   atomic_read(&eb->blocking_writers),
+		   eb->blocking_writers,
 		   atomic_read(&eb->blocking_readers),
 		   atomic_read(&eb->spinning_writers),
 		   atomic_read(&eb->spinning_readers),

commit e902baac656479bdb956224ed693578424cf9e96
Author: David Sterba <dsterba@suse.com>
Date:   Wed Mar 20 14:36:46 2019 +0100

    btrfs: get fs_info from eb in btrfs_leaf_free_space
    
    We can read fs_info from extent buffer and can drop it from the
    parameters.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index df49931ffe92..1141ca5fae6a 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -189,7 +189,7 @@ void btrfs_print_leaf(struct extent_buffer *l)
 	btrfs_info(fs_info,
 		   "leaf %llu gen %llu total ptrs %d free space %d owner %llu",
 		   btrfs_header_bytenr(l), btrfs_header_generation(l), nr,
-		   btrfs_leaf_free_space(fs_info, l), btrfs_header_owner(l));
+		   btrfs_leaf_free_space(l), btrfs_header_owner(l));
 	print_eb_refs_lock(l);
 	for (i = 0 ; i < nr ; i++) {
 		item = btrfs_item_nr(i);

commit 6d8ff4e4584cd84093b751671351c8103ead551d
Author: David Sterba <dsterba@suse.com>
Date:   Tue Jun 26 16:20:59 2018 +0200

    btrfs: annotate unlikely branches after V0 extent type removal
    
    The v0 extent type checks are the right case for the unlikely
    annotations as we don't expect to ever see them, so let's give the
    compiler some hint.
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index cc945376c244..df49931ffe92 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -52,7 +52,7 @@ static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 	u64 offset;
 	int ref_index = 0;
 
-	if (item_size < sizeof(*ei)) {
+	if (unlikely(item_size < sizeof(*ei))) {
 		btrfs_print_v0_err(eb->fs_info);
 		btrfs_handle_fs_error(eb->fs_info, -EINVAL, NULL);
 	}

commit ba3c2b196bf59ba8574808fe6f8fd88d0fed7510
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Tue Jun 26 16:57:36 2018 +0300

    btrfs: Add graceful handling of V0 extents
    
    Following the removal of the v0 handling code let's be courteous and
    print an error message when such extents are handled. In the cases
    where we have a transaction just abort it, otherwise just call
    btrfs_handle_fs_error. Both cases result in the FS being re-mounted RO.
    
    In case the error handling would be too intrusive, leave the BUG_ON in
    place, like extent_data_ref_count, other proper handling would catch
    that earlier.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index c0dac9d7ce33..cc945376c244 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -52,8 +52,10 @@ static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 	u64 offset;
 	int ref_index = 0;
 
-	if (item_size < sizeof(*ei))
-		BUG();
+	if (item_size < sizeof(*ei)) {
+		btrfs_print_v0_err(eb->fs_info);
+		btrfs_handle_fs_error(eb->fs_info, -EINVAL, NULL);
+	}
 
 	ei = btrfs_item_ptr(eb, slot, struct btrfs_extent_item);
 	flags = btrfs_extent_flags(eb, ei);
@@ -256,7 +258,8 @@ void btrfs_print_leaf(struct extent_buffer *l)
 			       btrfs_file_extent_ram_bytes(l, fi));
 			break;
 		case BTRFS_EXTENT_REF_V0_KEY:
-			BUG();
+			btrfs_print_v0_err(fs_info);
+			btrfs_handle_fs_error(fs_info, -EINVAL, NULL);
 			break;
 		case BTRFS_BLOCK_GROUP_ITEM_KEY:
 			bi = btrfs_item_ptr(l, i,

commit a79865c680d81220a1355cd13098e75227dc2994
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Thu Jun 21 09:45:00 2018 +0300

    btrfs: Remove V0 extent support
    
    The v0 compat code was introduced in commit 5d4f98a28c7d
    ("Btrfs: Mixed back reference  (FORWARD ROLLING FORMAT CHANGE)") 9
    years ago, which was merged in 2.6.31. This means that the code is
    there to support filesystems which are _VERY_ old and if you are using
    btrfs on such an old kernel, you have much bigger problems. This coupled
    with the fact that no one is likely testing/maintining this code likely
    means it has bugs lurking. All things considered I think 43 kernel
    releases later it's high time this remnant of the past got removed.
    
    This patch removes all code wrapped in #ifdefs but leaves the BUG_ONs in case
    we have a v0 with no support intact as a sort of safety-net.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 59efcf2e0de8..c0dac9d7ce33 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -52,18 +52,8 @@ static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 	u64 offset;
 	int ref_index = 0;
 
-	if (item_size < sizeof(*ei)) {
-#ifdef BTRFS_COMPAT_EXTENT_TREE_V0
-		struct btrfs_extent_item_v0 *ei0;
-		BUG_ON(item_size != sizeof(*ei0));
-		ei0 = btrfs_item_ptr(eb, slot, struct btrfs_extent_item_v0);
-		pr_info("\t\textent refs %u\n",
-		       btrfs_extent_refs_v0(eb, ei0));
-		return;
-#else
+	if (item_size < sizeof(*ei))
 		BUG();
-#endif
-	}
 
 	ei = btrfs_item_ptr(eb, slot, struct btrfs_extent_item);
 	flags = btrfs_extent_flags(eb, ei);
@@ -133,20 +123,6 @@ static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 	WARN_ON(ptr > end);
 }
 
-#ifdef BTRFS_COMPAT_EXTENT_TREE_V0
-static void print_extent_ref_v0(struct extent_buffer *eb, int slot)
-{
-	struct btrfs_extent_ref_v0 *ref0;
-
-	ref0 = btrfs_item_ptr(eb, slot, struct btrfs_extent_ref_v0);
-	printk("\t\textent back ref root %llu gen %llu owner %llu num_refs %lu\n",
-		btrfs_ref_root_v0(eb, ref0),
-		btrfs_ref_generation_v0(eb, ref0),
-		btrfs_ref_objectid_v0(eb, ref0),
-		(unsigned long)btrfs_ref_count_v0(eb, ref0));
-}
-#endif
-
 static void print_uuid_item(struct extent_buffer *l, unsigned long offset,
 			    u32 item_size)
 {
@@ -280,11 +256,7 @@ void btrfs_print_leaf(struct extent_buffer *l)
 			       btrfs_file_extent_ram_bytes(l, fi));
 			break;
 		case BTRFS_EXTENT_REF_V0_KEY:
-#ifdef BTRFS_COMPAT_EXTENT_TREE_V0
-			print_extent_ref_v0(l, i);
-#else
 			BUG();
-#endif
 			break;
 		case BTRFS_BLOCK_GROUP_ITEM_KEY:
 			bi = btrfs_item_ptr(l, i,

commit e41ca5897489b1c18af75ff0cc8f5c80260b3281
Author: Qu Wenruo <wqu@suse.com>
Date:   Wed Jun 6 15:41:49 2018 +0800

    btrfs: Get rid of the confusing btrfs_file_extent_inline_len
    
    We used to call btrfs_file_extent_inline_len() to get the uncompressed
    data size of an inlined extent.
    
    However this function is hiding evil, for compressed extent, it has no
    choice but to directly read out ram_bytes from btrfs_file_extent_item.
    While for uncompressed extent, it uses item size to calculate the real
    data size, and ignoring ram_bytes completely.
    
    In fact, for corrupted ram_bytes, due to above behavior kernel
    btrfs_print_leaf() can't even print correct ram_bytes to expose the bug.
    
    Since we have the tree-checker to verify all EXTENT_DATA, such mismatch
    can be detected pretty easily, thus we can trust ram_bytes without the
    evil btrfs_file_extent_inline_len().
    
    Signed-off-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index a4e11cf04671..59efcf2e0de8 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -267,8 +267,8 @@ void btrfs_print_leaf(struct extent_buffer *l)
 					    struct btrfs_file_extent_item);
 			if (btrfs_file_extent_type(l, fi) ==
 			    BTRFS_FILE_EXTENT_INLINE) {
-				pr_info("\t\tinline extent data size %u\n",
-				       btrfs_file_extent_inline_len(l, i, fi));
+				pr_info("\t\tinline extent data size %llu\n",
+				       btrfs_file_extent_ram_bytes(l, fi));
 				break;
 			}
 			pr_info("\t\textent data disk bytenr %llu nr %llu\n",

commit b545993694a6e3bf6e801071df00e0ad47526bb8
Author: Qu Wenruo <wqu@suse.com>
Date:   Tue Apr 24 13:03:13 2018 +0800

    btrfs: print-tree: Add eb locking status output for debug build
    
    It's pretty handy if we can get the debug output for locking status of
    an extent buffer, specially for race condition related debugging.
    
    So add the following output for btrfs_print_tree() and
    btrfs_print_leaf():
    - refs
    - write_locks (as w:%d)
    - read_locks (as r:%d)
    - blocking_writers (as bw:%d)
    - blocking_readers (as br:%d)
    - spinning_writers (as sw:%d)
    - spinning_readers (as sr:%d)
    - lock_owner
    - current->pid
    
    Signed-off-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ update comment ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 21a831d3d087..a4e11cf04671 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -166,6 +166,25 @@ static void print_uuid_item(struct extent_buffer *l, unsigned long offset,
 	}
 }
 
+/*
+ * Helper to output refs and locking status of extent buffer.  Useful to debug
+ * race condition related problems.
+ */
+static void print_eb_refs_lock(struct extent_buffer *eb)
+{
+#ifdef CONFIG_BTRFS_DEBUG
+	btrfs_info(eb->fs_info,
+"refs %u lock (w:%d r:%d bw:%d br:%d sw:%d sr:%d) lock_owner %u current %u",
+		   atomic_read(&eb->refs), atomic_read(&eb->write_locks),
+		   atomic_read(&eb->read_locks),
+		   atomic_read(&eb->blocking_writers),
+		   atomic_read(&eb->blocking_readers),
+		   atomic_read(&eb->spinning_writers),
+		   atomic_read(&eb->spinning_readers),
+		   eb->lock_owner, current->pid);
+#endif
+}
+
 void btrfs_print_leaf(struct extent_buffer *l)
 {
 	struct btrfs_fs_info *fs_info;
@@ -193,6 +212,7 @@ void btrfs_print_leaf(struct extent_buffer *l)
 		   "leaf %llu gen %llu total ptrs %d free space %d owner %llu",
 		   btrfs_header_bytenr(l), btrfs_header_generation(l), nr,
 		   btrfs_leaf_free_space(fs_info, l), btrfs_header_owner(l));
+	print_eb_refs_lock(l);
 	for (i = 0 ; i < nr ; i++) {
 		item = btrfs_item_nr(i);
 		btrfs_item_key_to_cpu(l, &key, i);
@@ -347,6 +367,7 @@ void btrfs_print_tree(struct extent_buffer *c, bool follow)
 		   btrfs_header_bytenr(c), level, btrfs_header_generation(c),
 		   nr, (u32)BTRFS_NODEPTRS_PER_BLOCK(fs_info) - nr,
 		   btrfs_header_owner(c));
+	print_eb_refs_lock(c);
 	for (i = 0; i < nr; i++) {
 		btrfs_node_key_to_cpu(c, &key, i);
 		pr_info("\tkey %d (%llu %u %llu) block %llu gen %llu\n",

commit c0872323746e11fc79344e3738b283a8cda86654
Author: Qu Wenruo <wqu@suse.com>
Date:   Wed Apr 11 17:08:12 2018 +0800

    btrfs: print-tree: debugging output enhancement
    
    This patch enhances the following things:
    
    - tree block header
      * add generation and owner output for node and leaf
    - node pointer generation output
    - allow btrfs_print_tree() to not follow nodes
      * just like btrfs-progs
    
    Please note that, although function btrfs_print_tree() is not called by
    anyone right now, it's still a pretty useful function to debug kernel.
    So that function is still kept for later use.
    
    Signed-off-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: Lu Fengqi <lufq.fnst@cn.fujitsu.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 124276bba8cf..21a831d3d087 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -189,9 +189,10 @@ void btrfs_print_leaf(struct extent_buffer *l)
 	fs_info = l->fs_info;
 	nr = btrfs_header_nritems(l);
 
-	btrfs_info(fs_info, "leaf %llu total ptrs %d free space %d",
-		   btrfs_header_bytenr(l), nr,
-		   btrfs_leaf_free_space(fs_info, l));
+	btrfs_info(fs_info,
+		   "leaf %llu gen %llu total ptrs %d free space %d owner %llu",
+		   btrfs_header_bytenr(l), btrfs_header_generation(l), nr,
+		   btrfs_leaf_free_space(fs_info, l), btrfs_header_owner(l));
 	for (i = 0 ; i < nr ; i++) {
 		item = btrfs_item_nr(i);
 		btrfs_item_key_to_cpu(l, &key, i);
@@ -325,7 +326,7 @@ void btrfs_print_leaf(struct extent_buffer *l)
 	}
 }
 
-void btrfs_print_tree(struct extent_buffer *c)
+void btrfs_print_tree(struct extent_buffer *c, bool follow)
 {
 	struct btrfs_fs_info *fs_info;
 	int i; u32 nr;
@@ -342,15 +343,19 @@ void btrfs_print_tree(struct extent_buffer *c)
 		return;
 	}
 	btrfs_info(fs_info,
-		   "node %llu level %d total ptrs %d free spc %u",
-		   btrfs_header_bytenr(c), level, nr,
-		   (u32)BTRFS_NODEPTRS_PER_BLOCK(fs_info) - nr);
+		   "node %llu level %d gen %llu total ptrs %d free spc %u owner %llu",
+		   btrfs_header_bytenr(c), level, btrfs_header_generation(c),
+		   nr, (u32)BTRFS_NODEPTRS_PER_BLOCK(fs_info) - nr,
+		   btrfs_header_owner(c));
 	for (i = 0; i < nr; i++) {
 		btrfs_node_key_to_cpu(c, &key, i);
-		pr_info("\tkey %d (%llu %u %llu) block %llu\n",
+		pr_info("\tkey %d (%llu %u %llu) block %llu gen %llu\n",
 		       i, key.objectid, key.type, key.offset,
-		       btrfs_node_blockptr(c, i));
+		       btrfs_node_blockptr(c, i),
+		       btrfs_node_ptr_generation(c, i));
 	}
+	if (!follow)
+		return;
 	for (i = 0; i < nr; i++) {
 		struct btrfs_key first_key;
 		struct extent_buffer *next;
@@ -372,7 +377,7 @@ void btrfs_print_tree(struct extent_buffer *c)
 		if (btrfs_header_level(next) !=
 		       level - 1)
 			BUG();
-		btrfs_print_tree(next);
+		btrfs_print_tree(next, follow);
 		free_extent_buffer(next);
 	}
 }

commit c1d7c514f745628eb096c5cbb10737855879ae25
Author: David Sterba <dsterba@suse.com>
Date:   Tue Apr 3 19:23:33 2018 +0200

    btrfs: replace GPL boilerplate by SPDX -- sources
    
    Remove GPL boilerplate text (long, short, one-line) and keep the rest,
    ie. personal, company or original source copyright statements. Add the
    SPDX header.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 4a8770485f77..124276bba8cf 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -1,19 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2007 Oracle.  All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License v2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public
- * License along with this program; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 021110-1307, USA.
  */
 
 #include "ctree.h"

commit 581c1760415c48cca9349b198bba52dd38750765
Author: Qu Wenruo <wqu@suse.com>
Date:   Thu Mar 29 09:08:11 2018 +0800

    btrfs: Validate child tree block's level and first key
    
    We have several reports about node pointer points to incorrect child
    tree blocks, which could have even wrong owner and level but still with
    valid generation and checksum.
    
    Although btrfs check could handle it and print error message like:
    leaf parent key incorrect 60670574592
    
    Kernel doesn't have enough check on this type of corruption correctly.
    At least add such check to read_tree_block() and btrfs_read_buffer(),
    where we need two new parameters @level and @first_key to verify the
    child tree block.
    
    The new @level check is mandatory and all call sites are already
    modified to extract expected level from its call chain.
    
    While @first_key is optional, the following call sites are skipping such
    check:
    1) Root node/leaf
       As ROOT_ITEM doesn't contain the first key, skip @first_key check.
    2) Direct backref
       Only parent bytenr and level is known and we need to resolve the key
       all by ourselves, skip @first_key check.
    
    Another note of this verification is, it needs extra info from nodeptr
    or ROOT_ITEM, so it can't fit into current tree-checker framework, which
    is limited to node/leaf boundary.
    
    Signed-off-by: Qu Wenruo <wqu@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 569205e651c7..4a8770485f77 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -365,9 +365,13 @@ void btrfs_print_tree(struct extent_buffer *c)
 		       btrfs_node_blockptr(c, i));
 	}
 	for (i = 0; i < nr; i++) {
-		struct extent_buffer *next = read_tree_block(fs_info,
-					btrfs_node_blockptr(c, i),
-					btrfs_node_ptr_generation(c, i));
+		struct btrfs_key first_key;
+		struct extent_buffer *next;
+
+		btrfs_node_key_to_cpu(c, &first_key, i);
+		next = read_tree_block(fs_info, btrfs_node_blockptr(c, i),
+				       btrfs_node_ptr_generation(c, i),
+				       level - 1, &first_key);
 		if (IS_ERR(next)) {
 			continue;
 		} else if (!extent_buffer_uptodate(next)) {

commit 64ecdb647ddb83dcff9c8e2a5c40119f171ea004
Author: Liu Bo <bo.li.liu@oracle.com>
Date:   Fri Aug 18 15:15:24 2017 -0600

    Btrfs: add one more sanity check for shared ref type
    
    Every shared ref has a parent tree block, which can be get from
    btrfs_extent_inline_ref_offset().  And the tree block must be aligned
    to the nodesize, so we'd know this inline ref is not valid if this
    block's bytenr is not aligned to the nodesize, in which case, most
    likely the ref type has been misused.
    
    This adds the above mentioned check and also updates
    print_extent_item() called by btrfs_print_leaf() to point out the
    invalid ref while printing the tree structure.
    
    Signed-off-by: Liu Bo <bo.li.liu@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index c1acbdcb476c..569205e651c7 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -44,7 +44,7 @@ static void print_dev_item(struct extent_buffer *eb,
 static void print_extent_data_ref(struct extent_buffer *eb,
 				  struct btrfs_extent_data_ref *ref)
 {
-	pr_info("\t\textent data backref root %llu objectid %llu offset %llu count %u\n",
+	pr_cont("extent data backref root %llu objectid %llu offset %llu count %u\n",
 	       btrfs_extent_data_ref_root(eb, ref),
 	       btrfs_extent_data_ref_objectid(eb, ref),
 	       btrfs_extent_data_ref_offset(eb, ref),
@@ -63,6 +63,7 @@ static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 	u32 item_size = btrfs_item_size_nr(eb, slot);
 	u64 flags;
 	u64 offset;
+	int ref_index = 0;
 
 	if (item_size < sizeof(*ei)) {
 #ifdef BTRFS_COMPAT_EXTENT_TREE_V0
@@ -104,12 +105,20 @@ static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 		iref = (struct btrfs_extent_inline_ref *)ptr;
 		type = btrfs_extent_inline_ref_type(eb, iref);
 		offset = btrfs_extent_inline_ref_offset(eb, iref);
+		pr_info("\t\tref#%d: ", ref_index++);
 		switch (type) {
 		case BTRFS_TREE_BLOCK_REF_KEY:
-			pr_info("\t\ttree block backref root %llu\n", offset);
+			pr_cont("tree block backref root %llu\n", offset);
 			break;
 		case BTRFS_SHARED_BLOCK_REF_KEY:
-			pr_info("\t\tshared block backref parent %llu\n", offset);
+			pr_cont("shared block backref parent %llu\n", offset);
+			/*
+			 * offset is supposed to be a tree block which
+			 * must be aligned to nodesize.
+			 */
+			if (!IS_ALIGNED(offset, eb->fs_info->nodesize))
+				pr_info("\t\t\t(parent %llu is NOT ALIGNED to nodesize %llu)\n",
+					offset, (unsigned long long)eb->fs_info->nodesize);
 			break;
 		case BTRFS_EXTENT_DATA_REF_KEY:
 			dref = (struct btrfs_extent_data_ref *)(&iref->offset);
@@ -117,12 +126,18 @@ static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 			break;
 		case BTRFS_SHARED_DATA_REF_KEY:
 			sref = (struct btrfs_shared_data_ref *)(iref + 1);
-			pr_info("\t\tshared data backref parent %llu count %u\n",
+			pr_cont("shared data backref parent %llu count %u\n",
 			       offset, btrfs_shared_data_ref_count(eb, sref));
+			/*
+			 * offset is supposed to be a tree block which
+			 * must be aligned to nodesize.
+			 */
+			if (!IS_ALIGNED(offset, eb->fs_info->nodesize))
+				pr_info("\t\t\t(parent %llu is NOT ALIGNED to nodesize %llu)\n",
+				     offset, (unsigned long long)eb->fs_info->nodesize);
 			break;
 		default:
-			btrfs_err(eb->fs_info,
-				  "extent %llu has invalid ref type %d",
+			pr_cont("(extent %llu has INVALID ref type %d)\n",
 				  eb->start, type);
 			return;
 		}

commit 07638ea5987e51715b35eb5a9a9e908f18ffabf7
Author: Liu Bo <bo.li.liu@oracle.com>
Date:   Fri Aug 18 15:15:21 2017 -0600

    Btrfs: remove BUG() in print_extent_item
    
    btrfs_print_leaf() is used in btrfs_get_extent_inline_ref_type, so
    here we really want to print the invalid value of ref type instead of
    causing a kernel panic.
    
    Signed-off-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 6e7a8c40dcd9..c1acbdcb476c 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -121,7 +121,10 @@ static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 			       offset, btrfs_shared_data_ref_count(eb, sref));
 			break;
 		default:
-			BUG();
+			btrfs_err(eb->fs_info,
+				  "extent %llu has invalid ref type %d",
+				  eb->start, type);
+			return;
 		}
 		ptr += btrfs_extent_inline_ref_size(type);
 	}

commit abe60ba45c145db2d90609138755fbb3dbc47d00
Author: David Sterba <dsterba@suse.com>
Date:   Thu Jun 29 18:37:49 2017 +0200

    btrfs: get fs_info from eb in btrfs_print_tree, remove argument
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 9c3911f4a100..6e7a8c40dcd9 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -320,14 +320,16 @@ void btrfs_print_leaf(struct extent_buffer *l)
 	}
 }
 
-void btrfs_print_tree(struct btrfs_fs_info *fs_info, struct extent_buffer *c)
+void btrfs_print_tree(struct extent_buffer *c)
 {
+	struct btrfs_fs_info *fs_info;
 	int i; u32 nr;
 	struct btrfs_key key;
 	int level;
 
 	if (!c)
 		return;
+	fs_info = c->fs_info;
 	nr = btrfs_header_nritems(c);
 	level = btrfs_header_level(c);
 	if (level == 0) {
@@ -361,7 +363,7 @@ void btrfs_print_tree(struct btrfs_fs_info *fs_info, struct extent_buffer *c)
 		if (btrfs_header_level(next) !=
 		       level - 1)
 			BUG();
-		btrfs_print_tree(fs_info, next);
+		btrfs_print_tree(next);
 		free_extent_buffer(next);
 	}
 }

commit a4f78750ef1882e59bb4f947e216cf61ef2d67d2
Author: David Sterba <dsterba@suse.com>
Date:   Thu Jun 29 18:37:49 2017 +0200

    btrfs: get fs_info from eb in btrfs_print_leaf, remove argument
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index fcae61e175f3..9c3911f4a100 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -161,8 +161,9 @@ static void print_uuid_item(struct extent_buffer *l, unsigned long offset,
 	}
 }
 
-void btrfs_print_leaf(struct btrfs_fs_info *fs_info, struct extent_buffer *l)
+void btrfs_print_leaf(struct extent_buffer *l)
 {
+	struct btrfs_fs_info *fs_info;
 	int i;
 	u32 type, nr;
 	struct btrfs_item *item;
@@ -180,6 +181,7 @@ void btrfs_print_leaf(struct btrfs_fs_info *fs_info, struct extent_buffer *l)
 	if (!l)
 		return;
 
+	fs_info = l->fs_info;
 	nr = btrfs_header_nritems(l);
 
 	btrfs_info(fs_info, "leaf %llu total ptrs %d free space %d",
@@ -329,7 +331,7 @@ void btrfs_print_tree(struct btrfs_fs_info *fs_info, struct extent_buffer *c)
 	nr = btrfs_header_nritems(c);
 	level = btrfs_header_level(c);
 	if (level == 0) {
-		btrfs_print_leaf(fs_info, c);
+		btrfs_print_leaf(c);
 		return;
 	}
 	btrfs_info(fs_info,

commit 555ba411aa33c9241e78ff37afc40f6a33721620
Author: Liu Bo <bo.li.liu@oracle.com>
Date:   Thu May 25 18:08:12 2017 -0600

    Btrfs: let btrfs_print_leaf print more about block group
    
    This adds chunk_objectid and flags, with flags we can recognize whether
    the block group is about data or metadata.
    
    Signed-off-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index cdafbf92ef0c..fcae61e175f3 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -261,8 +261,11 @@ void btrfs_print_leaf(struct btrfs_fs_info *fs_info, struct extent_buffer *l)
 		case BTRFS_BLOCK_GROUP_ITEM_KEY:
 			bi = btrfs_item_ptr(l, i,
 					    struct btrfs_block_group_item);
-			pr_info("\t\tblock group used %llu\n",
-			       btrfs_disk_block_group_used(l, bi));
+			pr_info(
+		   "\t\tblock group used %llu chunk_objectid %llu flags %llu\n",
+				btrfs_disk_block_group_used(l, bi),
+				btrfs_disk_block_group_chunk_objectid(l, bi),
+				btrfs_disk_block_group_flags(l, bi));
 			break;
 		case BTRFS_CHUNK_ITEM_KEY:
 			print_chunk(l, btrfs_item_ptr(l, i,

commit 2ff7e61e0d30ff166a2ae94575526bffe11fd1a8
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jun 22 18:54:24 2016 -0400

    btrfs: take an fs_info directly when the root is not used otherwise
    
    There are loads of functions in btrfs that accept a root parameter
    but only use it to obtain an fs_info pointer.  Let's convert those to
    just accept an fs_info pointer directly.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 3251a0dd03a2..cdafbf92ef0c 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -161,9 +161,8 @@ static void print_uuid_item(struct extent_buffer *l, unsigned long offset,
 	}
 }
 
-void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
+void btrfs_print_leaf(struct btrfs_fs_info *fs_info, struct extent_buffer *l)
 {
-	struct btrfs_fs_info *fs_info = root->fs_info;
 	int i;
 	u32 type, nr;
 	struct btrfs_item *item;
@@ -184,7 +183,8 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 	nr = btrfs_header_nritems(l);
 
 	btrfs_info(fs_info, "leaf %llu total ptrs %d free space %d",
-		   btrfs_header_bytenr(l), nr, btrfs_leaf_free_space(root, l));
+		   btrfs_header_bytenr(l), nr,
+		   btrfs_leaf_free_space(fs_info, l));
 	for (i = 0 ; i < nr ; i++) {
 		item = btrfs_item_nr(i);
 		btrfs_item_key_to_cpu(l, &key, i);
@@ -315,9 +315,8 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 	}
 }
 
-void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
+void btrfs_print_tree(struct btrfs_fs_info *fs_info, struct extent_buffer *c)
 {
-	struct btrfs_fs_info *fs_info = root->fs_info;
 	int i; u32 nr;
 	struct btrfs_key key;
 	int level;
@@ -327,7 +326,7 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 	nr = btrfs_header_nritems(c);
 	level = btrfs_header_level(c);
 	if (level == 0) {
-		btrfs_print_leaf(root, c);
+		btrfs_print_leaf(fs_info, c);
 		return;
 	}
 	btrfs_info(fs_info,
@@ -341,7 +340,7 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 		       btrfs_node_blockptr(c, i));
 	}
 	for (i = 0; i < nr; i++) {
-		struct extent_buffer *next = read_tree_block(root,
+		struct extent_buffer *next = read_tree_block(fs_info,
 					btrfs_node_blockptr(c, i),
 					btrfs_node_ptr_generation(c, i));
 		if (IS_ERR(next)) {
@@ -357,7 +356,7 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 		if (btrfs_header_level(next) !=
 		       level - 1)
 			BUG();
-		btrfs_print_tree(root, next);
+		btrfs_print_tree(fs_info, next);
 		free_extent_buffer(next);
 	}
 }

commit 0b246afa62b0cf5b09d078121f543135f28492ad
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jun 22 18:54:23 2016 -0400

    btrfs: root->fs_info cleanup, add fs_info convenience variables
    
    In routines where someptr->fs_info is referenced multiple times, we
    introduce a convenience variable.  This makes the code considerably
    more readable.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 57c403b205a5..3251a0dd03a2 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -163,6 +163,7 @@ static void print_uuid_item(struct extent_buffer *l, unsigned long offset,
 
 void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 {
+	struct btrfs_fs_info *fs_info = root->fs_info;
 	int i;
 	u32 type, nr;
 	struct btrfs_item *item;
@@ -182,7 +183,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 
 	nr = btrfs_header_nritems(l);
 
-	btrfs_info(root->fs_info, "leaf %llu total ptrs %d free space %d",
+	btrfs_info(fs_info, "leaf %llu total ptrs %d free space %d",
 		   btrfs_header_bytenr(l), nr, btrfs_leaf_free_space(root, l));
 	for (i = 0 ; i < nr ; i++) {
 		item = btrfs_item_nr(i);
@@ -316,6 +317,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 
 void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 {
+	struct btrfs_fs_info *fs_info = root->fs_info;
 	int i; u32 nr;
 	struct btrfs_key key;
 	int level;
@@ -328,10 +330,10 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 		btrfs_print_leaf(root, c);
 		return;
 	}
-	btrfs_info(root->fs_info,
+	btrfs_info(fs_info,
 		   "node %llu level %d total ptrs %d free spc %u",
 		   btrfs_header_bytenr(c), level, nr,
-		   (u32)BTRFS_NODEPTRS_PER_BLOCK(root->fs_info) - nr);
+		   (u32)BTRFS_NODEPTRS_PER_BLOCK(fs_info) - nr);
 	for (i = 0; i < nr; i++) {
 		btrfs_node_key_to_cpu(c, &key, i);
 		pr_info("\tkey %d (%llu %u %llu) block %llu\n",

commit da17066c40472c2d6a1aab7bb0090c3d285531c9
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jun 15 09:22:56 2016 -0400

    btrfs: pull node/sector/stripe sizes out of root and into fs_info
    
    We track the node sizes per-root, but they never vary from the values
    in the superblock.  This patch messes with the 80-column style a bit,
    but subsequent patches to factor out root->fs_info into a convenience
    variable fix it up again.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 438575ea8d25..57c403b205a5 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -331,7 +331,7 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 	btrfs_info(root->fs_info,
 		   "node %llu level %d total ptrs %d free spc %u",
 		   btrfs_header_bytenr(c), level, nr,
-		   (u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
+		   (u32)BTRFS_NODEPTRS_PER_BLOCK(root->fs_info) - nr);
 	for (i = 0; i < nr; i++) {
 		btrfs_node_key_to_cpu(c, &key, i);
 		pr_info("\tkey %d (%llu %u %llu) block %llu\n",

commit 62e855771dacf7c4d6daf9741642a965e7066d31
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Tue Sep 20 10:05:01 2016 -0400

    btrfs: convert printk(KERN_* to use pr_* calls
    
    This patch converts printk(KERN_* style messages to use the pr_* versions.
    
    One side effect is that anything that was KERN_DEBUG is now automatically
    a dynamic debug message.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 2fa49f207ca0..438575ea8d25 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -24,11 +24,11 @@ static void print_chunk(struct extent_buffer *eb, struct btrfs_chunk *chunk)
 {
 	int num_stripes = btrfs_chunk_num_stripes(eb, chunk);
 	int i;
-	printk(KERN_INFO "\t\tchunk length %llu owner %llu type %llu num_stripes %d\n",
+	pr_info("\t\tchunk length %llu owner %llu type %llu num_stripes %d\n",
 	       btrfs_chunk_length(eb, chunk), btrfs_chunk_owner(eb, chunk),
 	       btrfs_chunk_type(eb, chunk), num_stripes);
 	for (i = 0 ; i < num_stripes ; i++) {
-		printk(KERN_INFO "\t\t\tstripe %d devid %llu offset %llu\n", i,
+		pr_info("\t\t\tstripe %d devid %llu offset %llu\n", i,
 		      btrfs_stripe_devid_nr(eb, chunk, i),
 		      btrfs_stripe_offset_nr(eb, chunk, i));
 	}
@@ -36,7 +36,7 @@ static void print_chunk(struct extent_buffer *eb, struct btrfs_chunk *chunk)
 static void print_dev_item(struct extent_buffer *eb,
 			   struct btrfs_dev_item *dev_item)
 {
-	printk(KERN_INFO "\t\tdev item devid %llu total_bytes %llu bytes used %llu\n",
+	pr_info("\t\tdev item devid %llu total_bytes %llu bytes used %llu\n",
 	       btrfs_device_id(eb, dev_item),
 	       btrfs_device_total_bytes(eb, dev_item),
 	       btrfs_device_bytes_used(eb, dev_item));
@@ -44,7 +44,7 @@ static void print_dev_item(struct extent_buffer *eb,
 static void print_extent_data_ref(struct extent_buffer *eb,
 				  struct btrfs_extent_data_ref *ref)
 {
-	printk(KERN_INFO "\t\textent data backref root %llu objectid %llu offset %llu count %u\n",
+	pr_info("\t\textent data backref root %llu objectid %llu offset %llu count %u\n",
 	       btrfs_extent_data_ref_root(eb, ref),
 	       btrfs_extent_data_ref_objectid(eb, ref),
 	       btrfs_extent_data_ref_offset(eb, ref),
@@ -69,7 +69,7 @@ static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 		struct btrfs_extent_item_v0 *ei0;
 		BUG_ON(item_size != sizeof(*ei0));
 		ei0 = btrfs_item_ptr(eb, slot, struct btrfs_extent_item_v0);
-		printk(KERN_INFO "\t\textent refs %u\n",
+		pr_info("\t\textent refs %u\n",
 		       btrfs_extent_refs_v0(eb, ei0));
 		return;
 #else
@@ -80,7 +80,7 @@ static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 	ei = btrfs_item_ptr(eb, slot, struct btrfs_extent_item);
 	flags = btrfs_extent_flags(eb, ei);
 
-	printk(KERN_INFO "\t\textent refs %llu gen %llu flags %llu\n",
+	pr_info("\t\textent refs %llu gen %llu flags %llu\n",
 	       btrfs_extent_refs(eb, ei), btrfs_extent_generation(eb, ei),
 	       flags);
 
@@ -89,7 +89,7 @@ static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 		struct btrfs_tree_block_info *info;
 		info = (struct btrfs_tree_block_info *)(ei + 1);
 		btrfs_tree_block_key(eb, info, &key);
-		printk(KERN_INFO "\t\ttree block key (%llu %u %llu) level %d\n",
+		pr_info("\t\ttree block key (%llu %u %llu) level %d\n",
 		       btrfs_disk_key_objectid(&key), key.type,
 		       btrfs_disk_key_offset(&key),
 		       btrfs_tree_block_level(eb, info));
@@ -106,10 +106,10 @@ static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 		offset = btrfs_extent_inline_ref_offset(eb, iref);
 		switch (type) {
 		case BTRFS_TREE_BLOCK_REF_KEY:
-			printk(KERN_INFO "\t\ttree block backref root %llu\n", offset);
+			pr_info("\t\ttree block backref root %llu\n", offset);
 			break;
 		case BTRFS_SHARED_BLOCK_REF_KEY:
-			printk(KERN_INFO "\t\tshared block backref parent %llu\n", offset);
+			pr_info("\t\tshared block backref parent %llu\n", offset);
 			break;
 		case BTRFS_EXTENT_DATA_REF_KEY:
 			dref = (struct btrfs_extent_data_ref *)(&iref->offset);
@@ -117,7 +117,7 @@ static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 			break;
 		case BTRFS_SHARED_DATA_REF_KEY:
 			sref = (struct btrfs_shared_data_ref *)(iref + 1);
-			printk(KERN_INFO "\t\tshared data backref parent %llu count %u\n",
+			pr_info("\t\tshared data backref parent %llu count %u\n",
 			       offset, btrfs_shared_data_ref_count(eb, sref));
 			break;
 		default:
@@ -154,7 +154,7 @@ static void print_uuid_item(struct extent_buffer *l, unsigned long offset,
 		__le64 subvol_id;
 
 		read_extent_buffer(l, &subvol_id, offset, sizeof(subvol_id));
-		printk(KERN_INFO "\t\tsubvol_id %llu\n",
+		pr_info("\t\tsubvol_id %llu\n",
 		       (unsigned long long)le64_to_cpu(subvol_id));
 		item_size -= sizeof(u64);
 		offset += sizeof(u64);
@@ -188,13 +188,13 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 		item = btrfs_item_nr(i);
 		btrfs_item_key_to_cpu(l, &key, i);
 		type = key.type;
-		printk(KERN_INFO "\titem %d key (%llu %u %llu) itemoff %d itemsize %d\n",
+		pr_info("\titem %d key (%llu %u %llu) itemoff %d itemsize %d\n",
 			i, key.objectid, type, key.offset,
 			btrfs_item_offset(l, item), btrfs_item_size(l, item));
 		switch (type) {
 		case BTRFS_INODE_ITEM_KEY:
 			ii = btrfs_item_ptr(l, i, struct btrfs_inode_item);
-			printk(KERN_INFO "\t\tinode generation %llu size %llu mode %o\n",
+			pr_info("\t\tinode generation %llu size %llu mode %o\n",
 			       btrfs_inode_generation(l, ii),
 			       btrfs_inode_size(l, ii),
 			       btrfs_inode_mode(l, ii));
@@ -202,13 +202,13 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 		case BTRFS_DIR_ITEM_KEY:
 			di = btrfs_item_ptr(l, i, struct btrfs_dir_item);
 			btrfs_dir_item_key_to_cpu(l, di, &found_key);
-			printk(KERN_INFO "\t\tdir oid %llu type %u\n",
+			pr_info("\t\tdir oid %llu type %u\n",
 				found_key.objectid,
 				btrfs_dir_type(l, di));
 			break;
 		case BTRFS_ROOT_ITEM_KEY:
 			ri = btrfs_item_ptr(l, i, struct btrfs_root_item);
-			printk(KERN_INFO "\t\troot data bytenr %llu refs %u\n",
+			pr_info("\t\troot data bytenr %llu refs %u\n",
 				btrfs_disk_root_bytenr(l, ri),
 				btrfs_disk_root_refs(l, ri));
 			break;
@@ -217,10 +217,10 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 			print_extent_item(l, i, type);
 			break;
 		case BTRFS_TREE_BLOCK_REF_KEY:
-			printk(KERN_INFO "\t\ttree block backref\n");
+			pr_info("\t\ttree block backref\n");
 			break;
 		case BTRFS_SHARED_BLOCK_REF_KEY:
-			printk(KERN_INFO "\t\tshared block backref\n");
+			pr_info("\t\tshared block backref\n");
 			break;
 		case BTRFS_EXTENT_DATA_REF_KEY:
 			dref = btrfs_item_ptr(l, i,
@@ -230,7 +230,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 		case BTRFS_SHARED_DATA_REF_KEY:
 			sref = btrfs_item_ptr(l, i,
 					      struct btrfs_shared_data_ref);
-			printk(KERN_INFO "\t\tshared data backref count %u\n",
+			pr_info("\t\tshared data backref count %u\n",
 			       btrfs_shared_data_ref_count(l, sref));
 			break;
 		case BTRFS_EXTENT_DATA_KEY:
@@ -238,14 +238,14 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 					    struct btrfs_file_extent_item);
 			if (btrfs_file_extent_type(l, fi) ==
 			    BTRFS_FILE_EXTENT_INLINE) {
-				printk(KERN_INFO "\t\tinline extent data size %u\n",
+				pr_info("\t\tinline extent data size %u\n",
 				       btrfs_file_extent_inline_len(l, i, fi));
 				break;
 			}
-			printk(KERN_INFO "\t\textent data disk bytenr %llu nr %llu\n",
+			pr_info("\t\textent data disk bytenr %llu nr %llu\n",
 			       btrfs_file_extent_disk_bytenr(l, fi),
 			       btrfs_file_extent_disk_num_bytes(l, fi));
-			printk(KERN_INFO "\t\textent data offset %llu nr %llu ram %llu\n",
+			pr_info("\t\textent data offset %llu nr %llu ram %llu\n",
 			       btrfs_file_extent_offset(l, fi),
 			       btrfs_file_extent_num_bytes(l, fi),
 			       btrfs_file_extent_ram_bytes(l, fi));
@@ -260,7 +260,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 		case BTRFS_BLOCK_GROUP_ITEM_KEY:
 			bi = btrfs_item_ptr(l, i,
 					    struct btrfs_block_group_item);
-			printk(KERN_INFO "\t\tblock group used %llu\n",
+			pr_info("\t\tblock group used %llu\n",
 			       btrfs_disk_block_group_used(l, bi));
 			break;
 		case BTRFS_CHUNK_ITEM_KEY:
@@ -274,36 +274,36 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 		case BTRFS_DEV_EXTENT_KEY:
 			dev_extent = btrfs_item_ptr(l, i,
 						    struct btrfs_dev_extent);
-			printk(KERN_INFO "\t\tdev extent chunk_tree %llu\n\t\tchunk objectid %llu chunk offset %llu length %llu\n",
+			pr_info("\t\tdev extent chunk_tree %llu\n\t\tchunk objectid %llu chunk offset %llu length %llu\n",
 			       btrfs_dev_extent_chunk_tree(l, dev_extent),
 			       btrfs_dev_extent_chunk_objectid(l, dev_extent),
 			       btrfs_dev_extent_chunk_offset(l, dev_extent),
 			       btrfs_dev_extent_length(l, dev_extent));
 			break;
 		case BTRFS_PERSISTENT_ITEM_KEY:
-			printk(KERN_INFO "\t\tpersistent item objectid %llu offset %llu\n",
+			pr_info("\t\tpersistent item objectid %llu offset %llu\n",
 					key.objectid, key.offset);
 			switch (key.objectid) {
 			case BTRFS_DEV_STATS_OBJECTID:
-				printk(KERN_INFO "\t\tdevice stats\n");
+				pr_info("\t\tdevice stats\n");
 				break;
 			default:
-				printk(KERN_INFO "\t\tunknown persistent item\n");
+				pr_info("\t\tunknown persistent item\n");
 			}
 			break;
 		case BTRFS_TEMPORARY_ITEM_KEY:
-			printk(KERN_INFO "\t\ttemporary item objectid %llu offset %llu\n",
+			pr_info("\t\ttemporary item objectid %llu offset %llu\n",
 					key.objectid, key.offset);
 			switch (key.objectid) {
 			case BTRFS_BALANCE_OBJECTID:
-				printk(KERN_INFO "\t\tbalance status\n");
+				pr_info("\t\tbalance status\n");
 				break;
 			default:
-				printk(KERN_INFO "\t\tunknown temporary item\n");
+				pr_info("\t\tunknown temporary item\n");
 			}
 			break;
 		case BTRFS_DEV_REPLACE_KEY:
-			printk(KERN_INFO "\t\tdev replace\n");
+			pr_info("\t\tdev replace\n");
 			break;
 		case BTRFS_UUID_KEY_SUBVOL:
 		case BTRFS_UUID_KEY_RECEIVED_SUBVOL:
@@ -334,7 +334,7 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 		   (u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
 	for (i = 0; i < nr; i++) {
 		btrfs_node_key_to_cpu(c, &key, i);
-		printk(KERN_INFO "\tkey %d (%llu %u %llu) block %llu\n",
+		pr_info("\tkey %d (%llu %u %llu) block %llu\n",
 		       i, key.objectid, key.type, key.offset,
 		       btrfs_node_blockptr(c, i));
 	}

commit 5d163e0e68ce743e1e919ddd3264c96ac02e9026
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Tue Sep 20 10:05:00 2016 -0400

    btrfs: unsplit printed strings
    
    CodingStyle chapter 2:
    "[...] never break user-visible strings such as printk messages,
    because that breaks the ability to grep for them."
    
    This patch unsplits user-visible strings.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index aaeee45d917d..2fa49f207ca0 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -24,8 +24,7 @@ static void print_chunk(struct extent_buffer *eb, struct btrfs_chunk *chunk)
 {
 	int num_stripes = btrfs_chunk_num_stripes(eb, chunk);
 	int i;
-	printk(KERN_INFO "\t\tchunk length %llu owner %llu type %llu "
-	       "num_stripes %d\n",
+	printk(KERN_INFO "\t\tchunk length %llu owner %llu type %llu num_stripes %d\n",
 	       btrfs_chunk_length(eb, chunk), btrfs_chunk_owner(eb, chunk),
 	       btrfs_chunk_type(eb, chunk), num_stripes);
 	for (i = 0 ; i < num_stripes ; i++) {
@@ -37,8 +36,7 @@ static void print_chunk(struct extent_buffer *eb, struct btrfs_chunk *chunk)
 static void print_dev_item(struct extent_buffer *eb,
 			   struct btrfs_dev_item *dev_item)
 {
-	printk(KERN_INFO "\t\tdev item devid %llu "
-	       "total_bytes %llu bytes used %llu\n",
+	printk(KERN_INFO "\t\tdev item devid %llu total_bytes %llu bytes used %llu\n",
 	       btrfs_device_id(eb, dev_item),
 	       btrfs_device_total_bytes(eb, dev_item),
 	       btrfs_device_bytes_used(eb, dev_item));
@@ -46,8 +44,7 @@ static void print_dev_item(struct extent_buffer *eb,
 static void print_extent_data_ref(struct extent_buffer *eb,
 				  struct btrfs_extent_data_ref *ref)
 {
-	printk(KERN_INFO "\t\textent data backref root %llu "
-	       "objectid %llu offset %llu count %u\n",
+	printk(KERN_INFO "\t\textent data backref root %llu objectid %llu offset %llu count %u\n",
 	       btrfs_extent_data_ref_root(eb, ref),
 	       btrfs_extent_data_ref_objectid(eb, ref),
 	       btrfs_extent_data_ref_offset(eb, ref),
@@ -92,8 +89,7 @@ static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 		struct btrfs_tree_block_info *info;
 		info = (struct btrfs_tree_block_info *)(ei + 1);
 		btrfs_tree_block_key(eb, info, &key);
-		printk(KERN_INFO "\t\ttree block key (%llu %u %llu) "
-		       "level %d\n",
+		printk(KERN_INFO "\t\ttree block key (%llu %u %llu) level %d\n",
 		       btrfs_disk_key_objectid(&key), key.type,
 		       btrfs_disk_key_offset(&key),
 		       btrfs_tree_block_level(eb, info));
@@ -110,12 +106,10 @@ static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 		offset = btrfs_extent_inline_ref_offset(eb, iref);
 		switch (type) {
 		case BTRFS_TREE_BLOCK_REF_KEY:
-			printk(KERN_INFO "\t\ttree block backref "
-				"root %llu\n", offset);
+			printk(KERN_INFO "\t\ttree block backref root %llu\n", offset);
 			break;
 		case BTRFS_SHARED_BLOCK_REF_KEY:
-			printk(KERN_INFO "\t\tshared block backref "
-				"parent %llu\n", offset);
+			printk(KERN_INFO "\t\tshared block backref parent %llu\n", offset);
 			break;
 		case BTRFS_EXTENT_DATA_REF_KEY:
 			dref = (struct btrfs_extent_data_ref *)(&iref->offset);
@@ -123,8 +117,7 @@ static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 			break;
 		case BTRFS_SHARED_DATA_REF_KEY:
 			sref = (struct btrfs_shared_data_ref *)(iref + 1);
-			printk(KERN_INFO "\t\tshared data backref "
-			       "parent %llu count %u\n",
+			printk(KERN_INFO "\t\tshared data backref parent %llu count %u\n",
 			       offset, btrfs_shared_data_ref_count(eb, sref));
 			break;
 		default:
@@ -141,8 +134,7 @@ static void print_extent_ref_v0(struct extent_buffer *eb, int slot)
 	struct btrfs_extent_ref_v0 *ref0;
 
 	ref0 = btrfs_item_ptr(eb, slot, struct btrfs_extent_ref_v0);
-	printk("\t\textent back ref root %llu gen %llu "
-		"owner %llu num_refs %lu\n",
+	printk("\t\textent back ref root %llu gen %llu owner %llu num_refs %lu\n",
 		btrfs_ref_root_v0(eb, ref0),
 		btrfs_ref_generation_v0(eb, ref0),
 		btrfs_ref_objectid_v0(eb, ref0),
@@ -196,15 +188,13 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 		item = btrfs_item_nr(i);
 		btrfs_item_key_to_cpu(l, &key, i);
 		type = key.type;
-		printk(KERN_INFO "\titem %d key (%llu %u %llu) itemoff %d "
-		       "itemsize %d\n",
+		printk(KERN_INFO "\titem %d key (%llu %u %llu) itemoff %d itemsize %d\n",
 			i, key.objectid, type, key.offset,
 			btrfs_item_offset(l, item), btrfs_item_size(l, item));
 		switch (type) {
 		case BTRFS_INODE_ITEM_KEY:
 			ii = btrfs_item_ptr(l, i, struct btrfs_inode_item);
-			printk(KERN_INFO "\t\tinode generation %llu size %llu "
-			       "mode %o\n",
+			printk(KERN_INFO "\t\tinode generation %llu size %llu mode %o\n",
 			       btrfs_inode_generation(l, ii),
 			       btrfs_inode_size(l, ii),
 			       btrfs_inode_mode(l, ii));
@@ -248,17 +238,14 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 					    struct btrfs_file_extent_item);
 			if (btrfs_file_extent_type(l, fi) ==
 			    BTRFS_FILE_EXTENT_INLINE) {
-				printk(KERN_INFO "\t\tinline extent data "
-				       "size %u\n",
+				printk(KERN_INFO "\t\tinline extent data size %u\n",
 				       btrfs_file_extent_inline_len(l, i, fi));
 				break;
 			}
-			printk(KERN_INFO "\t\textent data disk bytenr %llu "
-			       "nr %llu\n",
+			printk(KERN_INFO "\t\textent data disk bytenr %llu nr %llu\n",
 			       btrfs_file_extent_disk_bytenr(l, fi),
 			       btrfs_file_extent_disk_num_bytes(l, fi));
-			printk(KERN_INFO "\t\textent data offset %llu "
-			       "nr %llu ram %llu\n",
+			printk(KERN_INFO "\t\textent data offset %llu nr %llu ram %llu\n",
 			       btrfs_file_extent_offset(l, fi),
 			       btrfs_file_extent_num_bytes(l, fi),
 			       btrfs_file_extent_ram_bytes(l, fi));
@@ -287,9 +274,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 		case BTRFS_DEV_EXTENT_KEY:
 			dev_extent = btrfs_item_ptr(l, i,
 						    struct btrfs_dev_extent);
-			printk(KERN_INFO "\t\tdev extent chunk_tree %llu\n"
-			       "\t\tchunk objectid %llu chunk offset %llu "
-			       "length %llu\n",
+			printk(KERN_INFO "\t\tdev extent chunk_tree %llu\n\t\tchunk objectid %llu chunk offset %llu length %llu\n",
 			       btrfs_dev_extent_chunk_tree(l, dev_extent),
 			       btrfs_dev_extent_chunk_objectid(l, dev_extent),
 			       btrfs_dev_extent_chunk_offset(l, dev_extent),
@@ -343,9 +328,10 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 		btrfs_print_leaf(root, c);
 		return;
 	}
-	btrfs_info(root->fs_info, "node %llu level %d total ptrs %d free spc %u",
-		btrfs_header_bytenr(c), level, nr,
-		(u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
+	btrfs_info(root->fs_info,
+		   "node %llu level %d total ptrs %d free spc %u",
+		   btrfs_header_bytenr(c), level, nr,
+		   (u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
 	for (i = 0; i < nr; i++) {
 		btrfs_node_key_to_cpu(c, &key, i);
 		printk(KERN_INFO "\tkey %d (%llu %u %llu) block %llu\n",

commit a42cbec9c662ced87f1d0f22a1c114de4cf6e352
Author: Liu Bo <bo.li.liu@oracle.com>
Date:   Wed Sep 14 17:23:39 2016 -0700

    Btrfs: add error handling for extent buffer in print tree
    
    Somehow we missed btrfs_print_tree when last time we
    updated error handling for read_extent_block().
    
    This keeps us from getting a NULL pointer panic when
    btrfs_print_tree's read_extent_block() fails.
    
    Signed-off-by: Liu Bo <bo.li.liu@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 147dc6ca5de1..aaeee45d917d 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -356,6 +356,13 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 		struct extent_buffer *next = read_tree_block(root,
 					btrfs_node_blockptr(c, i),
 					btrfs_node_ptr_generation(c, i));
+		if (IS_ERR(next)) {
+			continue;
+		} else if (!extent_buffer_uptodate(next)) {
+			free_extent_buffer(next);
+			continue;
+		}
+
 		if (btrfs_is_leaf(next) &&
 		   level != 1)
 			BUG();

commit 9f07e1d76eaeeddedcf9651395b4a8f870df31f0
Author: David Sterba <dsterba@suse.com>
Date:   Mon Jan 25 18:44:13 2016 +0100

    btrfs: teach print_leaf about temporary item subtypes
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 7bd0bdfc9812..147dc6ca5de1 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -306,6 +306,17 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 				printk(KERN_INFO "\t\tunknown persistent item\n");
 			}
 			break;
+		case BTRFS_TEMPORARY_ITEM_KEY:
+			printk(KERN_INFO "\t\ttemporary item objectid %llu offset %llu\n",
+					key.objectid, key.offset);
+			switch (key.objectid) {
+			case BTRFS_BALANCE_OBJECTID:
+				printk(KERN_INFO "\t\tbalance status\n");
+				break;
+			default:
+				printk(KERN_INFO "\t\tunknown temporary item\n");
+			}
+			break;
 		case BTRFS_DEV_REPLACE_KEY:
 			printk(KERN_INFO "\t\tdev replace\n");
 			break;

commit 585a3d0d238dfe42909cb58b0d05f644365fed14
Author: David Sterba <dsterba@suse.com>
Date:   Mon Jan 25 18:44:13 2016 +0100

    btrfs: teach print_leaf about permanent item subtypes
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 647ab12fdf5d..7bd0bdfc9812 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -295,8 +295,16 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 			       btrfs_dev_extent_chunk_offset(l, dev_extent),
 			       btrfs_dev_extent_length(l, dev_extent));
 			break;
-		case BTRFS_DEV_STATS_KEY:
-			printk(KERN_INFO "\t\tdevice stats\n");
+		case BTRFS_PERSISTENT_ITEM_KEY:
+			printk(KERN_INFO "\t\tpersistent item objectid %llu offset %llu\n",
+					key.objectid, key.offset);
+			switch (key.objectid) {
+			case BTRFS_DEV_STATS_OBJECTID:
+				printk(KERN_INFO "\t\tdevice stats\n");
+				break;
+			default:
+				printk(KERN_INFO "\t\tunknown persistent item\n");
+			}
 			break;
 		case BTRFS_DEV_REPLACE_KEY:
 			printk(KERN_INFO "\t\tdev replace\n");

commit ce86cd59179279a6fe673d2a105d24fb7e70aef3
Author: David Sterba <dsterba@suse.cz>
Date:   Sun Jun 15 01:07:32 2014 +0200

    btrfs: remove parameter blocksize from read_tree_block
    
    We know the tree block size, no need to pass it around.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index eb309855d5c8..647ab12fdf5d 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -336,7 +336,6 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 	for (i = 0; i < nr; i++) {
 		struct extent_buffer *next = read_tree_block(root,
 					btrfs_node_blockptr(c, i),
-					root->nodesize,
 					btrfs_node_ptr_generation(c, i));
 		if (btrfs_is_leaf(next) &&
 		   level != 1)

commit 707e8a071528385a87b63a72a37c2322e463c7b8
Author: David Sterba <dsterba@suse.cz>
Date:   Wed Jun 4 19:22:26 2014 +0200

    btrfs: use nodesize everywhere, kill leafsize
    
    The nodesize and leafsize were never of different values. Unify the
    usage and make nodesize the one. Cleanup the redundant checks and
    helpers.
    
    Shaves a few bytes from .text:
    
      text    data     bss     dec     hex filename
    852418   24560   23112  900090   dbbfa btrfs.ko.before
    851074   24584   23112  898770   db6d2 btrfs.ko.after
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 1591620bee3d..eb309855d5c8 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -336,7 +336,7 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 	for (i = 0; i < nr; i++) {
 		struct extent_buffer *next = read_tree_block(root,
 					btrfs_node_blockptr(c, i),
-					btrfs_level_size(root, level - 1),
+					root->nodesize,
 					btrfs_node_ptr_generation(c, i));
 		if (btrfs_is_leaf(next) &&
 		   level != 1)

commit 962a298f35110edd8f326814ae41a3dd306ecb64
Author: David Sterba <dsterba@suse.cz>
Date:   Wed Jun 4 18:41:45 2014 +0200

    btrfs: kill the key type accessor helpers
    
    btrfs_set_key_type and btrfs_key_type are used inconsistently along with
    open coded variants. Other members of btrfs_key are accessed directly
    without any helpers anyway.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 9626b4ad3b9a..1591620bee3d 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -195,7 +195,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 	for (i = 0 ; i < nr ; i++) {
 		item = btrfs_item_nr(i);
 		btrfs_item_key_to_cpu(l, &key, i);
-		type = btrfs_key_type(&key);
+		type = key.type;
 		printk(KERN_INFO "\titem %d key (%llu %u %llu) itemoff %d "
 		       "itemsize %d\n",
 			i, key.objectid, type, key.offset,

commit be2c765dff9e5584965f78853c2addd2bb926946
Author: Josef Bacik <jbacik@fb.com>
Date:   Wed Jul 2 10:20:48 2014 -0700

    Btrfs: fix btrfs_print_leaf for skinny metadata
    
    We wouldn't actuall print the extent information if we had a skinny metadata
    item, this fixes that.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 6efd70d3b64f..9626b4ad3b9a 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -54,7 +54,7 @@ static void print_extent_data_ref(struct extent_buffer *eb,
 	       btrfs_extent_data_ref_count(eb, ref));
 }
 
-static void print_extent_item(struct extent_buffer *eb, int slot)
+static void print_extent_item(struct extent_buffer *eb, int slot, int type)
 {
 	struct btrfs_extent_item *ei;
 	struct btrfs_extent_inline_ref *iref;
@@ -63,7 +63,6 @@ static void print_extent_item(struct extent_buffer *eb, int slot)
 	struct btrfs_disk_key key;
 	unsigned long end;
 	unsigned long ptr;
-	int type;
 	u32 item_size = btrfs_item_size_nr(eb, slot);
 	u64 flags;
 	u64 offset;
@@ -88,7 +87,8 @@ static void print_extent_item(struct extent_buffer *eb, int slot)
 	       btrfs_extent_refs(eb, ei), btrfs_extent_generation(eb, ei),
 	       flags);
 
-	if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {
+	if ((type == BTRFS_EXTENT_ITEM_KEY) &&
+	    flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {
 		struct btrfs_tree_block_info *info;
 		info = (struct btrfs_tree_block_info *)(ei + 1);
 		btrfs_tree_block_key(eb, info, &key);
@@ -223,7 +223,8 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 				btrfs_disk_root_refs(l, ri));
 			break;
 		case BTRFS_EXTENT_ITEM_KEY:
-			print_extent_item(l, i);
+		case BTRFS_METADATA_ITEM_KEY:
+			print_extent_item(l, i, type);
 			break;
 		case BTRFS_TREE_BLOCK_REF_KEY:
 			printk(KERN_INFO "\t\ttree block backref\n");

commit 514ac8ad8793a097c0c9d89202c642479d6dfa34
Author: Chris Mason <clm@fb.com>
Date:   Fri Jan 3 21:07:00 2014 -0800

    Btrfs: don't use ram_bytes for uncompressed inline items
    
    If we truncate an uncompressed inline item, ram_bytes isn't updated to reflect
    the new size.  The fixe uses the size directly from the item header when
    reading uncompressed inlines, and also fixes truncate to update the
    size as it goes.
    
    Reported-by: Jens Axboe <axboe@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>
    CC: stable@vger.kernel.org

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 4eed002b7cf6..6efd70d3b64f 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -249,7 +249,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 			    BTRFS_FILE_EXTENT_INLINE) {
 				printk(KERN_INFO "\t\tinline extent data "
 				       "size %u\n",
-				       btrfs_file_extent_inline_len(l, fi));
+				       btrfs_file_extent_inline_len(l, i, fi));
 				break;
 			}
 			printk(KERN_INFO "\t\textent data disk bytenr %llu "

commit efe120a067c8674a8ae21b194f0e68f098b61ee2
Author: Frank Holton <fholton@gmail.com>
Date:   Fri Dec 20 11:37:06 2013 -0500

    Btrfs: convert printk to btrfs_ and fix BTRFS prefix
    
    Convert all applicable cases of printk and pr_* to the btrfs_* macros.
    
    Fix all uses of the BTRFS prefix.
    
    Signed-off-by: Frank Holton <fholton@gmail.com>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 417053b17181..4eed002b7cf6 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -154,7 +154,7 @@ static void print_uuid_item(struct extent_buffer *l, unsigned long offset,
 			    u32 item_size)
 {
 	if (!IS_ALIGNED(item_size, sizeof(u64))) {
-		pr_warn("btrfs: uuid item with illegal size %lu!\n",
+		pr_warn("BTRFS: uuid item with illegal size %lu!\n",
 			(unsigned long)item_size);
 		return;
 	}

commit dd3cc16b8750251ea9b1a843ce7806e82b015d5e
Author: Ross Kirk <ross.kirk@gmail.com>
Date:   Mon Sep 16 15:58:09 2013 +0100

    btrfs: drop unused parameter from btrfs_item_nr
    
    Remove unused eb parameter from btrfs_item_nr
    
    Signed-off-by: Ross Kirk <ross.kirk@gmail.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 0088bedc8631..417053b17181 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -193,7 +193,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 	btrfs_info(root->fs_info, "leaf %llu total ptrs %d free space %d",
 		   btrfs_header_bytenr(l), nr, btrfs_leaf_free_space(root, l));
 	for (i = 0 ; i < nr ; i++) {
-		item = btrfs_item_nr(l, i);
+		item = btrfs_item_nr(i);
 		btrfs_item_key_to_cpu(l, &key, i);
 		type = btrfs_key_type(&key);
 		printk(KERN_INFO "\titem %d key (%llu %u %llu) itemoff %d "

commit c1c9ff7c94e83fae89a742df74db51156869bad5
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Aug 20 13:20:07 2013 +0200

    Btrfs: Remove superfluous casts from u64 to unsigned long long
    
    u64 is "unsigned long long" on all architectures now, so there's no need to
    cast it when formatting it using the "ll" length modifier.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 32022f3f169b..0088bedc8631 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -26,14 +26,12 @@ static void print_chunk(struct extent_buffer *eb, struct btrfs_chunk *chunk)
 	int i;
 	printk(KERN_INFO "\t\tchunk length %llu owner %llu type %llu "
 	       "num_stripes %d\n",
-	       (unsigned long long)btrfs_chunk_length(eb, chunk),
-	       (unsigned long long)btrfs_chunk_owner(eb, chunk),
-	       (unsigned long long)btrfs_chunk_type(eb, chunk),
-	       num_stripes);
+	       btrfs_chunk_length(eb, chunk), btrfs_chunk_owner(eb, chunk),
+	       btrfs_chunk_type(eb, chunk), num_stripes);
 	for (i = 0 ; i < num_stripes ; i++) {
 		printk(KERN_INFO "\t\t\tstripe %d devid %llu offset %llu\n", i,
-		      (unsigned long long)btrfs_stripe_devid_nr(eb, chunk, i),
-		      (unsigned long long)btrfs_stripe_offset_nr(eb, chunk, i));
+		      btrfs_stripe_devid_nr(eb, chunk, i),
+		      btrfs_stripe_offset_nr(eb, chunk, i));
 	}
 }
 static void print_dev_item(struct extent_buffer *eb,
@@ -41,18 +39,18 @@ static void print_dev_item(struct extent_buffer *eb,
 {
 	printk(KERN_INFO "\t\tdev item devid %llu "
 	       "total_bytes %llu bytes used %llu\n",
-	       (unsigned long long)btrfs_device_id(eb, dev_item),
-	       (unsigned long long)btrfs_device_total_bytes(eb, dev_item),
-	       (unsigned long long)btrfs_device_bytes_used(eb, dev_item));
+	       btrfs_device_id(eb, dev_item),
+	       btrfs_device_total_bytes(eb, dev_item),
+	       btrfs_device_bytes_used(eb, dev_item));
 }
 static void print_extent_data_ref(struct extent_buffer *eb,
 				  struct btrfs_extent_data_ref *ref)
 {
 	printk(KERN_INFO "\t\textent data backref root %llu "
 	       "objectid %llu offset %llu count %u\n",
-	       (unsigned long long)btrfs_extent_data_ref_root(eb, ref),
-	       (unsigned long long)btrfs_extent_data_ref_objectid(eb, ref),
-	       (unsigned long long)btrfs_extent_data_ref_offset(eb, ref),
+	       btrfs_extent_data_ref_root(eb, ref),
+	       btrfs_extent_data_ref_objectid(eb, ref),
+	       btrfs_extent_data_ref_offset(eb, ref),
 	       btrfs_extent_data_ref_count(eb, ref));
 }
 
@@ -87,9 +85,8 @@ static void print_extent_item(struct extent_buffer *eb, int slot)
 	flags = btrfs_extent_flags(eb, ei);
 
 	printk(KERN_INFO "\t\textent refs %llu gen %llu flags %llu\n",
-	       (unsigned long long)btrfs_extent_refs(eb, ei),
-	       (unsigned long long)btrfs_extent_generation(eb, ei),
-	       (unsigned long long)flags);
+	       btrfs_extent_refs(eb, ei), btrfs_extent_generation(eb, ei),
+	       flags);
 
 	if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {
 		struct btrfs_tree_block_info *info;
@@ -97,9 +94,8 @@ static void print_extent_item(struct extent_buffer *eb, int slot)
 		btrfs_tree_block_key(eb, info, &key);
 		printk(KERN_INFO "\t\ttree block key (%llu %u %llu) "
 		       "level %d\n",
-		       (unsigned long long)btrfs_disk_key_objectid(&key),
-		       key.type,
-		       (unsigned long long)btrfs_disk_key_offset(&key),
+		       btrfs_disk_key_objectid(&key), key.type,
+		       btrfs_disk_key_offset(&key),
 		       btrfs_tree_block_level(eb, info));
 		iref = (struct btrfs_extent_inline_ref *)(info + 1);
 	} else {
@@ -115,11 +111,11 @@ static void print_extent_item(struct extent_buffer *eb, int slot)
 		switch (type) {
 		case BTRFS_TREE_BLOCK_REF_KEY:
 			printk(KERN_INFO "\t\ttree block backref "
-				"root %llu\n", (unsigned long long)offset);
+				"root %llu\n", offset);
 			break;
 		case BTRFS_SHARED_BLOCK_REF_KEY:
 			printk(KERN_INFO "\t\tshared block backref "
-				"parent %llu\n", (unsigned long long)offset);
+				"parent %llu\n", offset);
 			break;
 		case BTRFS_EXTENT_DATA_REF_KEY:
 			dref = (struct btrfs_extent_data_ref *)(&iref->offset);
@@ -129,8 +125,7 @@ static void print_extent_item(struct extent_buffer *eb, int slot)
 			sref = (struct btrfs_shared_data_ref *)(iref + 1);
 			printk(KERN_INFO "\t\tshared data backref "
 			       "parent %llu count %u\n",
-			       (unsigned long long)offset,
-			       btrfs_shared_data_ref_count(eb, sref));
+			       offset, btrfs_shared_data_ref_count(eb, sref));
 			break;
 		default:
 			BUG();
@@ -148,9 +143,9 @@ static void print_extent_ref_v0(struct extent_buffer *eb, int slot)
 	ref0 = btrfs_item_ptr(eb, slot, struct btrfs_extent_ref_v0);
 	printk("\t\textent back ref root %llu gen %llu "
 		"owner %llu num_refs %lu\n",
-		(unsigned long long)btrfs_ref_root_v0(eb, ref0),
-		(unsigned long long)btrfs_ref_generation_v0(eb, ref0),
-		(unsigned long long)btrfs_ref_objectid_v0(eb, ref0),
+		btrfs_ref_root_v0(eb, ref0),
+		btrfs_ref_generation_v0(eb, ref0),
+		btrfs_ref_objectid_v0(eb, ref0),
 		(unsigned long)btrfs_ref_count_v0(eb, ref0));
 }
 #endif
@@ -196,39 +191,34 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 	nr = btrfs_header_nritems(l);
 
 	btrfs_info(root->fs_info, "leaf %llu total ptrs %d free space %d",
-		(unsigned long long)btrfs_header_bytenr(l), nr,
-		btrfs_leaf_free_space(root, l));
+		   btrfs_header_bytenr(l), nr, btrfs_leaf_free_space(root, l));
 	for (i = 0 ; i < nr ; i++) {
 		item = btrfs_item_nr(l, i);
 		btrfs_item_key_to_cpu(l, &key, i);
 		type = btrfs_key_type(&key);
 		printk(KERN_INFO "\titem %d key (%llu %u %llu) itemoff %d "
 		       "itemsize %d\n",
-			i,
-			(unsigned long long)key.objectid, type,
-			(unsigned long long)key.offset,
+			i, key.objectid, type, key.offset,
 			btrfs_item_offset(l, item), btrfs_item_size(l, item));
 		switch (type) {
 		case BTRFS_INODE_ITEM_KEY:
 			ii = btrfs_item_ptr(l, i, struct btrfs_inode_item);
 			printk(KERN_INFO "\t\tinode generation %llu size %llu "
 			       "mode %o\n",
-			       (unsigned long long)
 			       btrfs_inode_generation(l, ii),
-			      (unsigned long long)btrfs_inode_size(l, ii),
+			       btrfs_inode_size(l, ii),
 			       btrfs_inode_mode(l, ii));
 			break;
 		case BTRFS_DIR_ITEM_KEY:
 			di = btrfs_item_ptr(l, i, struct btrfs_dir_item);
 			btrfs_dir_item_key_to_cpu(l, di, &found_key);
 			printk(KERN_INFO "\t\tdir oid %llu type %u\n",
-				(unsigned long long)found_key.objectid,
+				found_key.objectid,
 				btrfs_dir_type(l, di));
 			break;
 		case BTRFS_ROOT_ITEM_KEY:
 			ri = btrfs_item_ptr(l, i, struct btrfs_root_item);
 			printk(KERN_INFO "\t\troot data bytenr %llu refs %u\n",
-				(unsigned long long)
 				btrfs_disk_root_bytenr(l, ri),
 				btrfs_disk_root_refs(l, ri));
 			break;
@@ -264,17 +254,12 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 			}
 			printk(KERN_INFO "\t\textent data disk bytenr %llu "
 			       "nr %llu\n",
-			       (unsigned long long)
 			       btrfs_file_extent_disk_bytenr(l, fi),
-			       (unsigned long long)
 			       btrfs_file_extent_disk_num_bytes(l, fi));
 			printk(KERN_INFO "\t\textent data offset %llu "
 			       "nr %llu ram %llu\n",
-			       (unsigned long long)
 			       btrfs_file_extent_offset(l, fi),
-			       (unsigned long long)
 			       btrfs_file_extent_num_bytes(l, fi),
-			       (unsigned long long)
 			       btrfs_file_extent_ram_bytes(l, fi));
 			break;
 		case BTRFS_EXTENT_REF_V0_KEY:
@@ -288,7 +273,6 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 			bi = btrfs_item_ptr(l, i,
 					    struct btrfs_block_group_item);
 			printk(KERN_INFO "\t\tblock group used %llu\n",
-			       (unsigned long long)
 			       btrfs_disk_block_group_used(l, bi));
 			break;
 		case BTRFS_CHUNK_ITEM_KEY:
@@ -305,13 +289,9 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 			printk(KERN_INFO "\t\tdev extent chunk_tree %llu\n"
 			       "\t\tchunk objectid %llu chunk offset %llu "
 			       "length %llu\n",
-			       (unsigned long long)
 			       btrfs_dev_extent_chunk_tree(l, dev_extent),
-			       (unsigned long long)
 			       btrfs_dev_extent_chunk_objectid(l, dev_extent),
-			       (unsigned long long)
 			       btrfs_dev_extent_chunk_offset(l, dev_extent),
-			       (unsigned long long)
 			       btrfs_dev_extent_length(l, dev_extent));
 			break;
 		case BTRFS_DEV_STATS_KEY:
@@ -344,16 +324,13 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 		return;
 	}
 	btrfs_info(root->fs_info, "node %llu level %d total ptrs %d free spc %u",
-		(unsigned long long)btrfs_header_bytenr(c),
-		level, nr, (u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
+		btrfs_header_bytenr(c), level, nr,
+		(u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
 	for (i = 0; i < nr; i++) {
 		btrfs_node_key_to_cpu(c, &key, i);
 		printk(KERN_INFO "\tkey %d (%llu %u %llu) block %llu\n",
-		       i,
-		       (unsigned long long)key.objectid,
-		       key.type,
-		       (unsigned long long)key.offset,
-		       (unsigned long long)btrfs_node_blockptr(c, i));
+		       i, key.objectid, key.type, key.offset,
+		       btrfs_node_blockptr(c, i));
 	}
 	for (i = 0; i < nr; i++) {
 		struct extent_buffer *next = read_tree_block(root,

commit 8f8ae8e213300378d2506b68d581c80d9dfd2faf
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Thu Aug 15 17:11:18 2013 +0200

    Btrfs: support printing UUID tree elements
    
    This commit adds support to print UUID tree elements to print-tree.c.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index fe7bf4a12568..32022f3f169b 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -155,6 +155,25 @@ static void print_extent_ref_v0(struct extent_buffer *eb, int slot)
 }
 #endif
 
+static void print_uuid_item(struct extent_buffer *l, unsigned long offset,
+			    u32 item_size)
+{
+	if (!IS_ALIGNED(item_size, sizeof(u64))) {
+		pr_warn("btrfs: uuid item with illegal size %lu!\n",
+			(unsigned long)item_size);
+		return;
+	}
+	while (item_size) {
+		__le64 subvol_id;
+
+		read_extent_buffer(l, &subvol_id, offset, sizeof(subvol_id));
+		printk(KERN_INFO "\t\tsubvol_id %llu\n",
+		       (unsigned long long)le64_to_cpu(subvol_id));
+		item_size -= sizeof(u64);
+		offset += sizeof(u64);
+	}
+}
+
 void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 {
 	int i;
@@ -301,6 +320,11 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 		case BTRFS_DEV_REPLACE_KEY:
 			printk(KERN_INFO "\t\tdev replace\n");
 			break;
+		case BTRFS_UUID_KEY_SUBVOL:
+		case BTRFS_UUID_KEY_RECEIVED_SUBVOL:
+			print_uuid_item(l, btrfs_item_ptr_offset(l, i),
+					btrfs_item_size_nr(l, i));
+			break;
 		};
 	}
 }

commit d4c34f6bffe246bcf05a1471873667d678a47a54
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Tue Jul 16 15:38:33 2013 +0200

    Btrfs: Print key type in decimal everywhere
    
    This is confusing, sometimes the key type is printed in hex (without
    a leading "0x" which makes things even more complicated), sometimes
    in decimal...
    Change it to be in decimal everywhere.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index dc0024f17c1f..fe7bf4a12568 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -95,7 +95,7 @@ static void print_extent_item(struct extent_buffer *eb, int slot)
 		struct btrfs_tree_block_info *info;
 		info = (struct btrfs_tree_block_info *)(ei + 1);
 		btrfs_tree_block_key(eb, info, &key);
-		printk(KERN_INFO "\t\ttree block key (%llu %x %llu) "
+		printk(KERN_INFO "\t\ttree block key (%llu %u %llu) "
 		       "level %d\n",
 		       (unsigned long long)btrfs_disk_key_objectid(&key),
 		       key.type,
@@ -183,7 +183,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 		item = btrfs_item_nr(l, i);
 		btrfs_item_key_to_cpu(l, &key, i);
 		type = btrfs_key_type(&key);
-		printk(KERN_INFO "\titem %d key (%llu %x %llu) itemoff %d "
+		printk(KERN_INFO "\titem %d key (%llu %u %llu) itemoff %d "
 		       "itemsize %d\n",
 			i,
 			(unsigned long long)key.objectid, type,

commit c2cf52eb71aeb902682e0c1fa29e4e9e4a7f4ffc
Author: Simon Kirby <sim@hostway.ca>
Date:   Tue Mar 19 22:41:23 2013 +0000

    Btrfs: Include the device in most error printk()s
    
    With more than one btrfs volume mounted, it can be very difficult to find
    out which volume is hitting an error. btrfs_error() will print this, but
    it is currently rigged as more of a fatal error handler, while many of
    the printk()s are currently for debugging and yet-unhandled cases.
    
    This patch just changes the functions where the device information is
    already available. Some cases remain where the root or fs_info is not
    passed to the function emitting the error.
    
    This may introduce some confusion with volumes backed by multiple devices
    emitting errors referring to the primary device in the set instead of the
    one on which the error occurred.
    
    Use btrfs_printk(fs_info, format, ...) rather than writing the device
    string every time, and introduce macro wrappers ala XFS for brevity.
    Since the function already cannot be used for continuations, print a
    newline as part of the btrfs_printk() message rather than at each caller.
    
    Signed-off-by: Simon Kirby <sim@hostway.ca>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 920957ecb27e..dc0024f17c1f 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -176,7 +176,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 
 	nr = btrfs_header_nritems(l);
 
-	printk(KERN_INFO "leaf %llu total ptrs %d free space %d\n",
+	btrfs_info(root->fs_info, "leaf %llu total ptrs %d free space %d",
 		(unsigned long long)btrfs_header_bytenr(l), nr,
 		btrfs_leaf_free_space(root, l));
 	for (i = 0 ; i < nr ; i++) {
@@ -319,10 +319,9 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 		btrfs_print_leaf(root, c);
 		return;
 	}
-	printk(KERN_INFO "node %llu level %d total ptrs %d free spc %u\n",
-	       (unsigned long long)btrfs_header_bytenr(c),
-	      level, nr,
-	       (u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
+	btrfs_info(root->fs_info, "node %llu level %d total ptrs %d free spc %u",
+		(unsigned long long)btrfs_header_bytenr(c),
+		level, nr, (u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
 	for (i = 0; i < nr; i++) {
 		btrfs_node_key_to_cpu(c, &key, i);
 		printk(KERN_INFO "\tkey %d (%llu %u %llu) block %llu\n",

commit 0e6360274ff3bd4fb8cf97c5c3483cf5a42a49f4
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Thu Jan 31 00:54:57 2013 +0000

    btrfs: add missing break in btrfs_print_leaf()
    
    I don't think that BTRFS_DEV_EXTENT_KEY is supposed
    to fall through to BTRFS_DEV_STATS_KEY ...
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 50d95fd190a5..920957ecb27e 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -294,6 +294,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 			       btrfs_dev_extent_chunk_offset(l, dev_extent),
 			       (unsigned long long)
 			       btrfs_dev_extent_length(l, dev_extent));
+			break;
 		case BTRFS_DEV_STATS_KEY:
 			printk(KERN_INFO "\t\tdevice stats\n");
 			break;

commit a2bff64025d7a707ac49155bb6678a636e55096e
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Mon Nov 5 17:32:20 2012 +0100

    Btrfs: introduce a btrfs_dev_replace_item type
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 5e23684887eb..50d95fd190a5 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -297,6 +297,9 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 		case BTRFS_DEV_STATS_KEY:
 			printk(KERN_INFO "\t\tdevice stats\n");
 			break;
+		case BTRFS_DEV_REPLACE_KEY:
+			printk(KERN_INFO "\t\tdev replace\n");
+			break;
 		};
 	}
 }

commit 733f4fbbc1083aa343da739f46ee839705d6cfe3
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Fri May 25 16:06:10 2012 +0200

    Btrfs: read device stats on mount, write modified ones during commit
    
    The device statistics are written into the device tree with each
    transaction commit. Only modified statistics are written.
    When a filesystem is mounted, the device statistics for each involved
    device are read from the device tree and used to initialize the
    counters.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index f38e452486b8..5e23684887eb 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -294,6 +294,9 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 			       btrfs_dev_extent_chunk_offset(l, dev_extent),
 			       (unsigned long long)
 			       btrfs_dev_extent_length(l, dev_extent));
+		case BTRFS_DEV_STATS_KEY:
+			printk(KERN_INFO "\t\tdevice stats\n");
+			break;
 		};
 	}
 }

commit 068132bad1de70f85f5f6d12c36d64f8f7848d92
Author: Daniel J Blueman <daniel.blueman@gmail.com>
Date:   Thu Jun 23 23:01:01 2011 +0800

    btrfs: fix oops on failure path
    
    If lookup_extent_backref fails, path->nodes[0] reasonably could be
    null along with other callers of btrfs_print_leaf, so ensure we have a
    valid extent buffer before dereferencing.
    
    Signed-off-by: Daniel J Blueman <daniel.blueman@gmail.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index fb2605d998e9..f38e452486b8 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -158,8 +158,7 @@ static void print_extent_ref_v0(struct extent_buffer *eb, int slot)
 void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 {
 	int i;
-	u32 type;
-	u32 nr = btrfs_header_nritems(l);
+	u32 type, nr;
 	struct btrfs_item *item;
 	struct btrfs_root_item *ri;
 	struct btrfs_dir_item *di;
@@ -172,6 +171,11 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 	struct btrfs_key key;
 	struct btrfs_key found_key;
 
+	if (!l)
+		return;
+
+	nr = btrfs_header_nritems(l);
+
 	printk(KERN_INFO "leaf %llu total ptrs %d free space %d\n",
 		(unsigned long long)btrfs_header_bytenr(l), nr,
 		btrfs_leaf_free_space(root, l));

commit 333e8105445d4f51101fc3d23199a919d66730b3
Author: liubo <liubo2009@cn.fujitsu.com>
Date:   Wed Jan 26 06:22:33 2011 +0000

    btrfs: fix missing break in switch phrase
    
    There is a missing break in switch, fix it.
    
    Signed-off-by: Liu Bo <liubo2009@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 0d126be22b63..fb2605d998e9 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -260,6 +260,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 #else
 			BUG();
 #endif
+			break;
 		case BTRFS_BLOCK_GROUP_ITEM_KEY:
 			bi = btrfs_item_ptr(l, i,
 					    struct btrfs_block_group_item);

commit c271b492419a18908ba19ee02b231fb305a27023
Author: Daniel Cadete <danielcadete10@gmail.com>
Date:   Wed Jul 22 16:52:13 2009 -0400

    Btrfs: remove of redundant btrfs_header_level
    
    This removes the continues call's of btrfs_header_level. One call of
    btrfs_header_level(c) its enough.
    
    Signed-off-by Daniel Cadete <danielncadete10@gmail.com>
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 6d6523da0a30..0d126be22b63 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -309,7 +309,7 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 	}
 	printk(KERN_INFO "node %llu level %d total ptrs %d free spc %u\n",
 	       (unsigned long long)btrfs_header_bytenr(c),
-	       btrfs_header_level(c), nr,
+	      level, nr,
 	       (u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
 	for (i = 0; i < nr; i++) {
 		btrfs_node_key_to_cpu(c, &key, i);
@@ -326,10 +326,10 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 					btrfs_level_size(root, level - 1),
 					btrfs_node_ptr_generation(c, i));
 		if (btrfs_is_leaf(next) &&
-		    btrfs_header_level(c) != 1)
+		   level != 1)
 			BUG();
 		if (btrfs_header_level(next) !=
-			btrfs_header_level(c) - 1)
+		       level - 1)
 			BUG();
 		btrfs_print_tree(root, next);
 		free_extent_buffer(next);

commit 5d4f98a28c7d334091c1b7744f48a1acdd2a4ae0
Author: Yan Zheng <zheng.yan@oracle.com>
Date:   Wed Jun 10 10:45:14 2009 -0400

    Btrfs: Mixed back reference  (FORWARD ROLLING FORMAT CHANGE)
    
    This commit introduces a new kind of back reference for btrfs metadata.
    Once a filesystem has been mounted with this commit, IT WILL NO LONGER
    BE MOUNTABLE BY OLDER KERNELS.
    
    When a tree block in subvolume tree is cow'd, the reference counts of all
    extents it points to are increased by one.  At transaction commit time,
    the old root of the subvolume is recorded in a "dead root" data structure,
    and the btree it points to is later walked, dropping reference counts
    and freeing any blocks where the reference count goes to 0.
    
    The increments done during cow and decrements done after commit cancel out,
    and the walk is a very expensive way to go about freeing the blocks that
    are no longer referenced by the new btree root.  This commit reduces the
    transaction overhead by avoiding the need for dead root records.
    
    When a non-shared tree block is cow'd, we free the old block at once, and the
    new block inherits old block's references. When a tree block with reference
    count > 1 is cow'd, we increase the reference counts of all extents
    the new block points to by one, and decrease the old block's reference count by
    one.
    
    This dead tree avoidance code removes the need to modify the reference
    counts of lower level extents when a non-shared tree block is cow'd.
    But we still need to update back ref for all pointers in the block.
    This is because the location of the block is recorded in the back ref
    item.
    
    We can solve this by introducing a new type of back ref. The new
    back ref provides information about pointer's key, level and in which
    tree the pointer lives. This information allow us to find the pointer
    by searching the tree. The shortcoming of the new back ref is that it
    only works for pointers in tree blocks referenced by their owner trees.
    
    This is mostly a problem for snapshots, where resolving one of these
    fuzzy back references would be O(number_of_snapshots) and quite slow.
    The solution used here is to use the fuzzy back references in the common
    case where a given tree block is only referenced by one root,
    and use the full back references when multiple roots have a reference
    on a given block.
    
    This commit adds per subvolume red-black tree to keep trace of cached
    inodes. The red-black tree helps the balancing code to find cached
    inodes whose inode numbers within a given range.
    
    This commit improves the balancing code by introducing several data
    structures to keep the state of balancing. The most important one
    is the back ref cache. It caches how the upper level tree blocks are
    referenced. This greatly reduce the overhead of checking back ref.
    
    The improved balancing code scales significantly better with a large
    number of snapshots.
    
    This is a very large commit and was written in a number of
    pieces.  But, they depend heavily on the disk format change and were
    squashed together to make sure git bisect didn't end up in a
    bad state wrt space balancing or the format change.
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 5f8f218c1005..6d6523da0a30 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -45,22 +45,132 @@ static void print_dev_item(struct extent_buffer *eb,
 	       (unsigned long long)btrfs_device_total_bytes(eb, dev_item),
 	       (unsigned long long)btrfs_device_bytes_used(eb, dev_item));
 }
+static void print_extent_data_ref(struct extent_buffer *eb,
+				  struct btrfs_extent_data_ref *ref)
+{
+	printk(KERN_INFO "\t\textent data backref root %llu "
+	       "objectid %llu offset %llu count %u\n",
+	       (unsigned long long)btrfs_extent_data_ref_root(eb, ref),
+	       (unsigned long long)btrfs_extent_data_ref_objectid(eb, ref),
+	       (unsigned long long)btrfs_extent_data_ref_offset(eb, ref),
+	       btrfs_extent_data_ref_count(eb, ref));
+}
+
+static void print_extent_item(struct extent_buffer *eb, int slot)
+{
+	struct btrfs_extent_item *ei;
+	struct btrfs_extent_inline_ref *iref;
+	struct btrfs_extent_data_ref *dref;
+	struct btrfs_shared_data_ref *sref;
+	struct btrfs_disk_key key;
+	unsigned long end;
+	unsigned long ptr;
+	int type;
+	u32 item_size = btrfs_item_size_nr(eb, slot);
+	u64 flags;
+	u64 offset;
+
+	if (item_size < sizeof(*ei)) {
+#ifdef BTRFS_COMPAT_EXTENT_TREE_V0
+		struct btrfs_extent_item_v0 *ei0;
+		BUG_ON(item_size != sizeof(*ei0));
+		ei0 = btrfs_item_ptr(eb, slot, struct btrfs_extent_item_v0);
+		printk(KERN_INFO "\t\textent refs %u\n",
+		       btrfs_extent_refs_v0(eb, ei0));
+		return;
+#else
+		BUG();
+#endif
+	}
+
+	ei = btrfs_item_ptr(eb, slot, struct btrfs_extent_item);
+	flags = btrfs_extent_flags(eb, ei);
+
+	printk(KERN_INFO "\t\textent refs %llu gen %llu flags %llu\n",
+	       (unsigned long long)btrfs_extent_refs(eb, ei),
+	       (unsigned long long)btrfs_extent_generation(eb, ei),
+	       (unsigned long long)flags);
+
+	if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {
+		struct btrfs_tree_block_info *info;
+		info = (struct btrfs_tree_block_info *)(ei + 1);
+		btrfs_tree_block_key(eb, info, &key);
+		printk(KERN_INFO "\t\ttree block key (%llu %x %llu) "
+		       "level %d\n",
+		       (unsigned long long)btrfs_disk_key_objectid(&key),
+		       key.type,
+		       (unsigned long long)btrfs_disk_key_offset(&key),
+		       btrfs_tree_block_level(eb, info));
+		iref = (struct btrfs_extent_inline_ref *)(info + 1);
+	} else {
+		iref = (struct btrfs_extent_inline_ref *)(ei + 1);
+	}
+
+	ptr = (unsigned long)iref;
+	end = (unsigned long)ei + item_size;
+	while (ptr < end) {
+		iref = (struct btrfs_extent_inline_ref *)ptr;
+		type = btrfs_extent_inline_ref_type(eb, iref);
+		offset = btrfs_extent_inline_ref_offset(eb, iref);
+		switch (type) {
+		case BTRFS_TREE_BLOCK_REF_KEY:
+			printk(KERN_INFO "\t\ttree block backref "
+				"root %llu\n", (unsigned long long)offset);
+			break;
+		case BTRFS_SHARED_BLOCK_REF_KEY:
+			printk(KERN_INFO "\t\tshared block backref "
+				"parent %llu\n", (unsigned long long)offset);
+			break;
+		case BTRFS_EXTENT_DATA_REF_KEY:
+			dref = (struct btrfs_extent_data_ref *)(&iref->offset);
+			print_extent_data_ref(eb, dref);
+			break;
+		case BTRFS_SHARED_DATA_REF_KEY:
+			sref = (struct btrfs_shared_data_ref *)(iref + 1);
+			printk(KERN_INFO "\t\tshared data backref "
+			       "parent %llu count %u\n",
+			       (unsigned long long)offset,
+			       btrfs_shared_data_ref_count(eb, sref));
+			break;
+		default:
+			BUG();
+		}
+		ptr += btrfs_extent_inline_ref_size(type);
+	}
+	WARN_ON(ptr > end);
+}
+
+#ifdef BTRFS_COMPAT_EXTENT_TREE_V0
+static void print_extent_ref_v0(struct extent_buffer *eb, int slot)
+{
+	struct btrfs_extent_ref_v0 *ref0;
+
+	ref0 = btrfs_item_ptr(eb, slot, struct btrfs_extent_ref_v0);
+	printk("\t\textent back ref root %llu gen %llu "
+		"owner %llu num_refs %lu\n",
+		(unsigned long long)btrfs_ref_root_v0(eb, ref0),
+		(unsigned long long)btrfs_ref_generation_v0(eb, ref0),
+		(unsigned long long)btrfs_ref_objectid_v0(eb, ref0),
+		(unsigned long)btrfs_ref_count_v0(eb, ref0));
+}
+#endif
+
 void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 {
 	int i;
+	u32 type;
 	u32 nr = btrfs_header_nritems(l);
 	struct btrfs_item *item;
-	struct btrfs_extent_item *ei;
 	struct btrfs_root_item *ri;
 	struct btrfs_dir_item *di;
 	struct btrfs_inode_item *ii;
 	struct btrfs_block_group_item *bi;
 	struct btrfs_file_extent_item *fi;
+	struct btrfs_extent_data_ref *dref;
+	struct btrfs_shared_data_ref *sref;
+	struct btrfs_dev_extent *dev_extent;
 	struct btrfs_key key;
 	struct btrfs_key found_key;
-	struct btrfs_extent_ref *ref;
-	struct btrfs_dev_extent *dev_extent;
-	u32 type;
 
 	printk(KERN_INFO "leaf %llu total ptrs %d free space %d\n",
 		(unsigned long long)btrfs_header_bytenr(l), nr,
@@ -100,20 +210,25 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 				btrfs_disk_root_refs(l, ri));
 			break;
 		case BTRFS_EXTENT_ITEM_KEY:
-			ei = btrfs_item_ptr(l, i, struct btrfs_extent_item);
-			printk(KERN_INFO "\t\textent data refs %u\n",
-				btrfs_extent_refs(l, ei));
-			break;
-		case BTRFS_EXTENT_REF_KEY:
-			ref = btrfs_item_ptr(l, i, struct btrfs_extent_ref);
-			printk(KERN_INFO "\t\textent back ref root %llu "
-			       "gen %llu owner %llu num_refs %lu\n",
-			       (unsigned long long)btrfs_ref_root(l, ref),
-			       (unsigned long long)btrfs_ref_generation(l, ref),
-			       (unsigned long long)btrfs_ref_objectid(l, ref),
-			       (unsigned long)btrfs_ref_num_refs(l, ref));
+			print_extent_item(l, i);
+			break;
+		case BTRFS_TREE_BLOCK_REF_KEY:
+			printk(KERN_INFO "\t\ttree block backref\n");
+			break;
+		case BTRFS_SHARED_BLOCK_REF_KEY:
+			printk(KERN_INFO "\t\tshared block backref\n");
+			break;
+		case BTRFS_EXTENT_DATA_REF_KEY:
+			dref = btrfs_item_ptr(l, i,
+					      struct btrfs_extent_data_ref);
+			print_extent_data_ref(l, dref);
+			break;
+		case BTRFS_SHARED_DATA_REF_KEY:
+			sref = btrfs_item_ptr(l, i,
+					      struct btrfs_shared_data_ref);
+			printk(KERN_INFO "\t\tshared data backref count %u\n",
+			       btrfs_shared_data_ref_count(l, sref));
 			break;
-
 		case BTRFS_EXTENT_DATA_KEY:
 			fi = btrfs_item_ptr(l, i,
 					    struct btrfs_file_extent_item);
@@ -139,6 +254,12 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 			       (unsigned long long)
 			       btrfs_file_extent_ram_bytes(l, fi));
 			break;
+		case BTRFS_EXTENT_REF_V0_KEY:
+#ifdef BTRFS_COMPAT_EXTENT_TREE_V0
+			print_extent_ref_v0(l, i);
+#else
+			BUG();
+#endif
 		case BTRFS_BLOCK_GROUP_ITEM_KEY:
 			bi = btrfs_item_ptr(l, i,
 					    struct btrfs_block_group_item);

commit d397712bcc6a759a560fd247e6053ecae091f958
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Jan 5 21:25:51 2009 -0500

    Btrfs: Fix checkpatch.pl warnings
    
    There were many, most are fixed now.  struct-funcs.c generates some warnings
    but these are bogus.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 64725c13aa11..5f8f218c1005 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -24,13 +24,14 @@ static void print_chunk(struct extent_buffer *eb, struct btrfs_chunk *chunk)
 {
 	int num_stripes = btrfs_chunk_num_stripes(eb, chunk);
 	int i;
-	printk("\t\tchunk length %llu owner %llu type %llu num_stripes %d\n",
+	printk(KERN_INFO "\t\tchunk length %llu owner %llu type %llu "
+	       "num_stripes %d\n",
 	       (unsigned long long)btrfs_chunk_length(eb, chunk),
 	       (unsigned long long)btrfs_chunk_owner(eb, chunk),
 	       (unsigned long long)btrfs_chunk_type(eb, chunk),
 	       num_stripes);
 	for (i = 0 ; i < num_stripes ; i++) {
-		printk("\t\t\tstripe %d devid %llu offset %llu\n", i,
+		printk(KERN_INFO "\t\t\tstripe %d devid %llu offset %llu\n", i,
 		      (unsigned long long)btrfs_stripe_devid_nr(eb, chunk, i),
 		      (unsigned long long)btrfs_stripe_offset_nr(eb, chunk, i));
 	}
@@ -38,8 +39,8 @@ static void print_chunk(struct extent_buffer *eb, struct btrfs_chunk *chunk)
 static void print_dev_item(struct extent_buffer *eb,
 			   struct btrfs_dev_item *dev_item)
 {
-	printk("\t\tdev item devid %llu "
-	       "total_bytes %llu bytes used %Lu\n",
+	printk(KERN_INFO "\t\tdev item devid %llu "
+	       "total_bytes %llu bytes used %llu\n",
 	       (unsigned long long)btrfs_device_id(eb, dev_item),
 	       (unsigned long long)btrfs_device_total_bytes(eb, dev_item),
 	       (unsigned long long)btrfs_device_bytes_used(eb, dev_item));
@@ -61,14 +62,15 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 	struct btrfs_dev_extent *dev_extent;
 	u32 type;
 
-	printk("leaf %llu total ptrs %d free space %d\n",
+	printk(KERN_INFO "leaf %llu total ptrs %d free space %d\n",
 		(unsigned long long)btrfs_header_bytenr(l), nr,
 		btrfs_leaf_free_space(root, l));
 	for (i = 0 ; i < nr ; i++) {
 		item = btrfs_item_nr(l, i);
 		btrfs_item_key_to_cpu(l, &key, i);
 		type = btrfs_key_type(&key);
-		printk("\titem %d key (%llu %x %llu) itemoff %d itemsize %d\n",
+		printk(KERN_INFO "\titem %d key (%llu %x %llu) itemoff %d "
+		       "itemsize %d\n",
 			i,
 			(unsigned long long)key.objectid, type,
 			(unsigned long long)key.offset,
@@ -76,33 +78,36 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 		switch (type) {
 		case BTRFS_INODE_ITEM_KEY:
 			ii = btrfs_item_ptr(l, i, struct btrfs_inode_item);
-			printk("\t\tinode generation %llu size %llu mode %o\n",
-		              (unsigned long long)btrfs_inode_generation(l, ii),
+			printk(KERN_INFO "\t\tinode generation %llu size %llu "
+			       "mode %o\n",
+			       (unsigned long long)
+			       btrfs_inode_generation(l, ii),
 			      (unsigned long long)btrfs_inode_size(l, ii),
 			       btrfs_inode_mode(l, ii));
 			break;
 		case BTRFS_DIR_ITEM_KEY:
 			di = btrfs_item_ptr(l, i, struct btrfs_dir_item);
 			btrfs_dir_item_key_to_cpu(l, di, &found_key);
-			printk("\t\tdir oid %llu type %u\n",
+			printk(KERN_INFO "\t\tdir oid %llu type %u\n",
 				(unsigned long long)found_key.objectid,
 				btrfs_dir_type(l, di));
 			break;
 		case BTRFS_ROOT_ITEM_KEY:
 			ri = btrfs_item_ptr(l, i, struct btrfs_root_item);
-			printk("\t\troot data bytenr %llu refs %u\n",
-				(unsigned long long)btrfs_disk_root_bytenr(l, ri),
+			printk(KERN_INFO "\t\troot data bytenr %llu refs %u\n",
+				(unsigned long long)
+				btrfs_disk_root_bytenr(l, ri),
 				btrfs_disk_root_refs(l, ri));
 			break;
 		case BTRFS_EXTENT_ITEM_KEY:
 			ei = btrfs_item_ptr(l, i, struct btrfs_extent_item);
-			printk("\t\textent data refs %u\n",
+			printk(KERN_INFO "\t\textent data refs %u\n",
 				btrfs_extent_refs(l, ei));
 			break;
 		case BTRFS_EXTENT_REF_KEY:
 			ref = btrfs_item_ptr(l, i, struct btrfs_extent_ref);
-			printk("\t\textent back ref root %llu gen %llu "
-			       "owner %llu num_refs %lu\n",
+			printk(KERN_INFO "\t\textent back ref root %llu "
+			       "gen %llu owner %llu num_refs %lu\n",
 			       (unsigned long long)btrfs_ref_root(l, ref),
 			       (unsigned long long)btrfs_ref_generation(l, ref),
 			       (unsigned long long)btrfs_ref_objectid(l, ref),
@@ -114,26 +119,36 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 					    struct btrfs_file_extent_item);
 			if (btrfs_file_extent_type(l, fi) ==
 			    BTRFS_FILE_EXTENT_INLINE) {
-				printk("\t\tinline extent data size %u\n",
-			           btrfs_file_extent_inline_len(l, fi));
+				printk(KERN_INFO "\t\tinline extent data "
+				       "size %u\n",
+				       btrfs_file_extent_inline_len(l, fi));
 				break;
 			}
-			printk("\t\textent data disk bytenr %llu nr %llu\n",
-			       (unsigned long long)btrfs_file_extent_disk_bytenr(l, fi),
-			       (unsigned long long)btrfs_file_extent_disk_num_bytes(l, fi));
-			printk("\t\textent data offset %llu nr %llu ram %llu\n",
-			  (unsigned long long)btrfs_file_extent_offset(l, fi),
-			  (unsigned long long)btrfs_file_extent_num_bytes(l, fi),
-			  (unsigned long long)btrfs_file_extent_ram_bytes(l, fi));
+			printk(KERN_INFO "\t\textent data disk bytenr %llu "
+			       "nr %llu\n",
+			       (unsigned long long)
+			       btrfs_file_extent_disk_bytenr(l, fi),
+			       (unsigned long long)
+			       btrfs_file_extent_disk_num_bytes(l, fi));
+			printk(KERN_INFO "\t\textent data offset %llu "
+			       "nr %llu ram %llu\n",
+			       (unsigned long long)
+			       btrfs_file_extent_offset(l, fi),
+			       (unsigned long long)
+			       btrfs_file_extent_num_bytes(l, fi),
+			       (unsigned long long)
+			       btrfs_file_extent_ram_bytes(l, fi));
 			break;
 		case BTRFS_BLOCK_GROUP_ITEM_KEY:
 			bi = btrfs_item_ptr(l, i,
 					    struct btrfs_block_group_item);
-			printk("\t\tblock group used %llu\n",
-			       (unsigned long long)btrfs_disk_block_group_used(l, bi));
+			printk(KERN_INFO "\t\tblock group used %llu\n",
+			       (unsigned long long)
+			       btrfs_disk_block_group_used(l, bi));
 			break;
 		case BTRFS_CHUNK_ITEM_KEY:
-			print_chunk(l, btrfs_item_ptr(l, i, struct btrfs_chunk));
+			print_chunk(l, btrfs_item_ptr(l, i,
+						      struct btrfs_chunk));
 			break;
 		case BTRFS_DEV_ITEM_KEY:
 			print_dev_item(l, btrfs_item_ptr(l, i,
@@ -142,7 +157,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 		case BTRFS_DEV_EXTENT_KEY:
 			dev_extent = btrfs_item_ptr(l, i,
 						    struct btrfs_dev_extent);
-			printk("\t\tdev extent chunk_tree %llu\n"
+			printk(KERN_INFO "\t\tdev extent chunk_tree %llu\n"
 			       "\t\tchunk objectid %llu chunk offset %llu "
 			       "length %llu\n",
 			       (unsigned long long)
@@ -171,13 +186,13 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 		btrfs_print_leaf(root, c);
 		return;
 	}
-	printk("node %llu level %d total ptrs %d free spc %u\n",
+	printk(KERN_INFO "node %llu level %d total ptrs %d free spc %u\n",
 	       (unsigned long long)btrfs_header_bytenr(c),
 	       btrfs_header_level(c), nr,
 	       (u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
 	for (i = 0; i < nr; i++) {
 		btrfs_node_key_to_cpu(c, &key, i);
-		printk("\tkey %d (%llu %u %llu) block %llu\n",
+		printk(KERN_INFO "\tkey %d (%llu %u %llu) block %llu\n",
 		       i,
 		       (unsigned long long)key.objectid,
 		       key.type,

commit c8b978188c9a0fd3d535c13debd19d522b726f1f
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Oct 29 14:49:59 2008 -0400

    Btrfs: Add zlib compression support
    
    This is a large change for adding compression on reading and writing,
    both for inline and regular extents.  It does some fairly large
    surgery to the writeback paths.
    
    Compression is off by default and enabled by mount -o compress.  Even
    when the -o compress mount option is not used, it is possible to read
    compressed extents off the disk.
    
    If compression for a given set of pages fails to make them smaller, the
    file is flagged to avoid future compression attempts later.
    
    * While finding delalloc extents, the pages are locked before being sent down
    to the delalloc handler.  This allows the delalloc handler to do complex things
    such as cleaning the pages, marking them writeback and starting IO on their
    behalf.
    
    * Inline extents are inserted at delalloc time now.  This allows us to compress
    the data before inserting the inline extent, and it allows us to insert
    an inline extent that spans multiple pages.
    
    * All of the in-memory extent representations (extent_map.c, ordered-data.c etc)
    are changed to record both an in-memory size and an on disk size, as well
    as a flag for compression.
    
    From a disk format point of view, the extent pointers in the file are changed
    to record the on disk size of a given extent and some encoding flags.
    Space in the disk format is allocated for compression encoding, as well
    as encryption and a generic 'other' field.  Neither the encryption or the
    'other' field are currently used.
    
    In order to limit the amount of data read for a single random read in the
    file, the size of a compressed extent is limited to 128k.  This is a
    software only limit, the disk format supports u64 sized compressed extents.
    
    In order to limit the ram consumed while processing extents, the uncompressed
    size of a compressed extent is limited to 256k.  This is a software only limit
    and will be subject to tuning later.
    
    Checksumming is still done on compressed extents, and it is done on the
    uncompressed version of the data.  This way additional encodings can be
    layered on without having to figure out which encoding to checksum.
    
    Compression happens at delalloc time, which is basically singled threaded because
    it is usually done by a single pdflush thread.  This makes it tricky to
    spread the compression load across all the cpus on the box.  We'll have to
    look at parallel pdflush walks of dirty inodes at a later time.
    
    Decompression is hooked into readpages and it does spread across CPUs nicely.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index bd9ab3e9a7f2..64725c13aa11 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -115,15 +115,16 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 			if (btrfs_file_extent_type(l, fi) ==
 			    BTRFS_FILE_EXTENT_INLINE) {
 				printk("\t\tinline extent data size %u\n",
-			           btrfs_file_extent_inline_len(l, item));
+			           btrfs_file_extent_inline_len(l, fi));
 				break;
 			}
 			printk("\t\textent data disk bytenr %llu nr %llu\n",
 			       (unsigned long long)btrfs_file_extent_disk_bytenr(l, fi),
 			       (unsigned long long)btrfs_file_extent_disk_num_bytes(l, fi));
-			printk("\t\textent data offset %llu nr %llu\n",
+			printk("\t\textent data offset %llu nr %llu ram %llu\n",
 			  (unsigned long long)btrfs_file_extent_offset(l, fi),
-			  (unsigned long long)btrfs_file_extent_num_bytes(l, fi));
+			  (unsigned long long)btrfs_file_extent_num_bytes(l, fi),
+			  (unsigned long long)btrfs_file_extent_ram_bytes(l, fi));
 			break;
 		case BTRFS_BLOCK_GROUP_ITEM_KEY:
 			bi = btrfs_item_ptr(l, i,

commit 3bb1a1bc42f2ae9582c28adf620484efcd4da38d
Author: Yan Zheng <zheng.yan@oracle.com>
Date:   Thu Oct 9 11:46:24 2008 -0400

    Btrfs: Remove offset field from struct btrfs_extent_ref
    
    The offset field in struct btrfs_extent_ref records the position
    inside file that file extent is referenced by. In the new back
    reference system, tree leaves holding references to file extent
    are recorded explicitly. We can scan these tree leaves very quickly, so the
    offset field is not required.
    
    This patch also makes the back reference system check the objectid
    when extents are in deleting.
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 3577badfa5bc..bd9ab3e9a7f2 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -102,11 +102,10 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 		case BTRFS_EXTENT_REF_KEY:
 			ref = btrfs_item_ptr(l, i, struct btrfs_extent_ref);
 			printk("\t\textent back ref root %llu gen %llu "
-			       "owner %llu offset %llu num_refs %lu\n",
+			       "owner %llu num_refs %lu\n",
 			       (unsigned long long)btrfs_ref_root(l, ref),
 			       (unsigned long long)btrfs_ref_generation(l, ref),
 			       (unsigned long long)btrfs_ref_objectid(l, ref),
-			       (unsigned long long)btrfs_ref_offset(l, ref),
 			       (unsigned long)btrfs_ref_num_refs(l, ref));
 			break;
 

commit 31840ae1a6b433ca0e6a8d341756ff478bbf959e
Author: Zheng Yan <zheng.yan@oracle.com>
Date:   Tue Sep 23 13:14:14 2008 -0400

    Btrfs: Full back reference support
    
    This patch makes the back reference system to explicit record the
    location of parent node for all types of extents. The location of
    parent node is placed into the offset field of backref key. Every
    time a tree block is balanced, the back references for the affected
    lower level extents are updated.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index f1374d597a17..3577badfa5bc 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -102,11 +102,12 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 		case BTRFS_EXTENT_REF_KEY:
 			ref = btrfs_item_ptr(l, i, struct btrfs_extent_ref);
 			printk("\t\textent back ref root %llu gen %llu "
-			       "owner %llu offset %llu\n",
+			       "owner %llu offset %llu num_refs %lu\n",
 			       (unsigned long long)btrfs_ref_root(l, ref),
 			       (unsigned long long)btrfs_ref_generation(l, ref),
 			       (unsigned long long)btrfs_ref_objectid(l, ref),
-			       (unsigned long long)btrfs_ref_offset(l, ref));
+			       (unsigned long long)btrfs_ref_offset(l, ref),
+			       (unsigned long)btrfs_ref_num_refs(l, ref));
 			break;
 
 		case BTRFS_EXTENT_DATA_KEY:

commit bcc63abbf3e9bf948a1b0129b3e6120ec7d7f698
Author: Yan <zheng.yan@oracle.com>
Date:   Wed Jul 30 16:29:20 2008 -0400

    Btrfs: implement memory reclaim for leaf reference cache
    
    The memory reclaiming issue happens when snapshot exists. In that
    case, some cache entries may not be used during old snapshot dropping,
    so they will remain in the cache until umount.
    
    The patch adds a field to struct btrfs_leaf_ref to record create time. Besides,
    the patch makes all dead roots of a given snapshot linked together in order of
    create time. After a old snapshot was completely dropped, we check the dead
    root list and remove all cache entries created before the oldest dead root in
    the list.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 14d863720302..f1374d597a17 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -198,4 +198,3 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 		free_extent_buffer(next);
 	}
 }
-

commit ca7a79ad8dbe24669a8ced01f9fc0126b872745d
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon May 12 12:59:19 2008 -0400

    Btrfs: Pass down the expected generation number when reading tree blocks
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index e99f3249d05a..14d863720302 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -186,7 +186,8 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 	for (i = 0; i < nr; i++) {
 		struct extent_buffer *next = read_tree_block(root,
 					btrfs_node_blockptr(c, i),
-					btrfs_level_size(root, level - 1));
+					btrfs_level_size(root, level - 1),
+					btrfs_node_ptr_generation(c, i));
 		if (btrfs_is_leaf(next) &&
 		    btrfs_header_level(c) != 1)
 			BUG();

commit e17cade25ff8074101d653557a78df09c16ca276
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 15 15:41:47 2008 -0400

    Btrfs: Add chunk uuids and update multi-device back references
    
    Block headers now store the chunk tree uuid
    
    Chunk items records the device uuid for each stripes
    
    Device extent items record better back refs to the chunk tree
    
    Block groups record better back refs to the chunk tree
    
    The chunk tree format has also changed.  The objectid of BTRFS_CHUNK_ITEM_KEY
    used to be the logical offset of the chunk.  Now it is a chunk tree id,
    with the logical offset being stored in the offset field of the key.
    
    This allows a single chunk tree to record multiple logical address spaces,
    upping the number of bytes indexed by a chunk tree from 2^64 to
    2^128.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index ee0de112cf5a..e99f3249d05a 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -24,7 +24,8 @@ static void print_chunk(struct extent_buffer *eb, struct btrfs_chunk *chunk)
 {
 	int num_stripes = btrfs_chunk_num_stripes(eb, chunk);
 	int i;
-	printk("\t\tchunk owner %llu type %llu num_stripes %d\n",
+	printk("\t\tchunk length %llu owner %llu type %llu num_stripes %d\n",
+	       (unsigned long long)btrfs_chunk_length(eb, chunk),
 	       (unsigned long long)btrfs_chunk_owner(eb, chunk),
 	       (unsigned long long)btrfs_chunk_type(eb, chunk),
 	       num_stripes);
@@ -140,17 +141,24 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 		case BTRFS_DEV_EXTENT_KEY:
 			dev_extent = btrfs_item_ptr(l, i,
 						    struct btrfs_dev_extent);
-			printk("\t\tdev extent owner %llu length %llu\n",
-			       (unsigned long long)btrfs_dev_extent_owner(l, dev_extent),
-			       (unsigned long long)btrfs_dev_extent_length(l, dev_extent));
+			printk("\t\tdev extent chunk_tree %llu\n"
+			       "\t\tchunk objectid %llu chunk offset %llu "
+			       "length %llu\n",
+			       (unsigned long long)
+			       btrfs_dev_extent_chunk_tree(l, dev_extent),
+			       (unsigned long long)
+			       btrfs_dev_extent_chunk_objectid(l, dev_extent),
+			       (unsigned long long)
+			       btrfs_dev_extent_chunk_offset(l, dev_extent),
+			       (unsigned long long)
+			       btrfs_dev_extent_length(l, dev_extent));
 		};
 	}
 }
 
 void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 {
-	int i;
-	u32 nr;
+	int i; u32 nr;
 	struct btrfs_key key;
 	int level;
 

commit 0d81ba5dbedef0c3970d6aa318aa84920943e6e3
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Mar 24 15:02:07 2008 -0400

    Btrfs: Move device information into the super block so it can be scanned
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 9c1335dad40c..ee0de112cf5a 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -37,22 +37,11 @@ static void print_chunk(struct extent_buffer *eb, struct btrfs_chunk *chunk)
 static void print_dev_item(struct extent_buffer *eb,
 			   struct btrfs_dev_item *dev_item)
 {
-	char *name;
-	int name_len;
-
-	name_len = btrfs_device_name_len(eb, dev_item);
-	name = kmalloc(name_len, GFP_NOFS);
-	if (name) {
-		read_extent_buffer(eb, name,
-				   (unsigned long)btrfs_device_name(dev_item),
-				   name_len);
-	}
-	printk("\t\tdev item name %.*s devid %llu "
-	       "total_bytes %llu bytes used %Lu\n", name_len, name,
+	printk("\t\tdev item devid %llu "
+	       "total_bytes %llu bytes used %Lu\n",
 	       (unsigned long long)btrfs_device_id(eb, dev_item),
 	       (unsigned long long)btrfs_device_total_bytes(eb, dev_item),
 	       (unsigned long long)btrfs_device_bytes_used(eb, dev_item));
-	kfree(name);
 }
 void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 {

commit 0b86a832a1f38abec695864ec2eaedc9d2383f1b
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Mar 24 15:01:56 2008 -0400

    Btrfs: Add support for multiple devices per filesystem
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index da0b4dcf3617..9c1335dad40c 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -20,6 +20,40 @@
 #include "disk-io.h"
 #include "print-tree.h"
 
+static void print_chunk(struct extent_buffer *eb, struct btrfs_chunk *chunk)
+{
+	int num_stripes = btrfs_chunk_num_stripes(eb, chunk);
+	int i;
+	printk("\t\tchunk owner %llu type %llu num_stripes %d\n",
+	       (unsigned long long)btrfs_chunk_owner(eb, chunk),
+	       (unsigned long long)btrfs_chunk_type(eb, chunk),
+	       num_stripes);
+	for (i = 0 ; i < num_stripes ; i++) {
+		printk("\t\t\tstripe %d devid %llu offset %llu\n", i,
+		      (unsigned long long)btrfs_stripe_devid_nr(eb, chunk, i),
+		      (unsigned long long)btrfs_stripe_offset_nr(eb, chunk, i));
+	}
+}
+static void print_dev_item(struct extent_buffer *eb,
+			   struct btrfs_dev_item *dev_item)
+{
+	char *name;
+	int name_len;
+
+	name_len = btrfs_device_name_len(eb, dev_item);
+	name = kmalloc(name_len, GFP_NOFS);
+	if (name) {
+		read_extent_buffer(eb, name,
+				   (unsigned long)btrfs_device_name(dev_item),
+				   name_len);
+	}
+	printk("\t\tdev item name %.*s devid %llu "
+	       "total_bytes %llu bytes used %Lu\n", name_len, name,
+	       (unsigned long long)btrfs_device_id(eb, dev_item),
+	       (unsigned long long)btrfs_device_total_bytes(eb, dev_item),
+	       (unsigned long long)btrfs_device_bytes_used(eb, dev_item));
+	kfree(name);
+}
 void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 {
 	int i;
@@ -34,6 +68,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 	struct btrfs_key key;
 	struct btrfs_key found_key;
 	struct btrfs_extent_ref *ref;
+	struct btrfs_dev_extent *dev_extent;
 	u32 type;
 
 	printk("leaf %llu total ptrs %d free space %d\n",
@@ -106,6 +141,19 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 			printk("\t\tblock group used %llu\n",
 			       (unsigned long long)btrfs_disk_block_group_used(l, bi));
 			break;
+		case BTRFS_CHUNK_ITEM_KEY:
+			print_chunk(l, btrfs_item_ptr(l, i, struct btrfs_chunk));
+			break;
+		case BTRFS_DEV_ITEM_KEY:
+			print_dev_item(l, btrfs_item_ptr(l, i,
+					struct btrfs_dev_item));
+			break;
+		case BTRFS_DEV_EXTENT_KEY:
+			dev_extent = btrfs_item_ptr(l, i,
+						    struct btrfs_dev_extent);
+			printk("\t\tdev extent owner %llu length %llu\n",
+			       (unsigned long long)btrfs_dev_extent_owner(l, dev_extent),
+			       (unsigned long long)btrfs_dev_extent_length(l, dev_extent));
 		};
 	}
 }

commit 7bb86316c3961d1bc401ef184fd996f999556c7f
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Dec 11 09:25:06 2007 -0500

    Btrfs: Add back pointers from extents to the btree or file referencing them
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 030324febf6c..da0b4dcf3617 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -33,6 +33,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 	struct btrfs_file_extent_item *fi;
 	struct btrfs_key key;
 	struct btrfs_key found_key;
+	struct btrfs_extent_ref *ref;
 	u32 type;
 
 	printk("leaf %llu total ptrs %d free space %d\n",
@@ -73,6 +74,15 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 			printk("\t\textent data refs %u\n",
 				btrfs_extent_refs(l, ei));
 			break;
+		case BTRFS_EXTENT_REF_KEY:
+			ref = btrfs_item_ptr(l, i, struct btrfs_extent_ref);
+			printk("\t\textent back ref root %llu gen %llu "
+			       "owner %llu offset %llu\n",
+			       (unsigned long long)btrfs_ref_root(l, ref),
+			       (unsigned long long)btrfs_ref_generation(l, ref),
+			       (unsigned long long)btrfs_ref_objectid(l, ref),
+			       (unsigned long long)btrfs_ref_offset(l, ref));
+			break;
 
 		case BTRFS_EXTENT_DATA_KEY:
 			fi = btrfs_item_ptr(l, i,

commit 5103e947b9b7ac18ddb21a04ee3486e94c6504d7
Author: Josef Bacik <jbacik@redhat.com>
Date:   Fri Nov 16 11:45:54 2007 -0500

    xattr support for btrfs
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 9f8696c8a8e8..030324febf6c 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -58,9 +58,8 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 		case BTRFS_DIR_ITEM_KEY:
 			di = btrfs_item_ptr(l, i, struct btrfs_dir_item);
 			btrfs_dir_item_key_to_cpu(l, di, &found_key);
-			printk("\t\tdir oid %llu flags %u type %u\n",
+			printk("\t\tdir oid %llu type %u\n",
 				(unsigned long long)found_key.objectid,
-				btrfs_dir_flags(l, di),
 				btrfs_dir_type(l, di));
 			break;
 		case BTRFS_ROOT_ITEM_KEY:

commit db94535db75e67fab12ccbb7f5ee548e33fed891
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:15:53 2007 -0400

    Btrfs: Allow tree blocks larger than the page size
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index a825ce078a54..9f8696c8a8e8 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -36,7 +36,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 	u32 type;
 
 	printk("leaf %llu total ptrs %d free space %d\n",
-		(unsigned long long)btrfs_header_blocknr(l), nr,
+		(unsigned long long)btrfs_header_bytenr(l), nr,
 		btrfs_leaf_free_space(root, l));
 	for (i = 0 ; i < nr ; i++) {
 		item = btrfs_item_nr(l, i);
@@ -65,8 +65,8 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 			break;
 		case BTRFS_ROOT_ITEM_KEY:
 			ri = btrfs_item_ptr(l, i, struct btrfs_root_item);
-			printk("\t\troot data blocknr %llu refs %u\n",
-				(unsigned long long)btrfs_disk_root_blocknr(l, ri),
+			printk("\t\troot data bytenr %llu refs %u\n",
+				(unsigned long long)btrfs_disk_root_bytenr(l, ri),
 				btrfs_disk_root_refs(l, ri));
 			break;
 		case BTRFS_EXTENT_ITEM_KEY:
@@ -84,12 +84,12 @@ void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 			           btrfs_file_extent_inline_len(l, item));
 				break;
 			}
-			printk("\t\textent data disk block %llu nr %llu\n",
-			       (unsigned long long)btrfs_file_extent_disk_blocknr(l, fi),
-			       (unsigned long long)btrfs_file_extent_disk_num_blocks(l, fi));
+			printk("\t\textent data disk bytenr %llu nr %llu\n",
+			       (unsigned long long)btrfs_file_extent_disk_bytenr(l, fi),
+			       (unsigned long long)btrfs_file_extent_disk_num_bytes(l, fi));
 			printk("\t\textent data offset %llu nr %llu\n",
 			  (unsigned long long)btrfs_file_extent_offset(l, fi),
-			  (unsigned long long)btrfs_file_extent_num_blocks(l, fi));
+			  (unsigned long long)btrfs_file_extent_num_bytes(l, fi));
 			break;
 		case BTRFS_BLOCK_GROUP_ITEM_KEY:
 			bi = btrfs_item_ptr(l, i,
@@ -106,16 +106,18 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 	int i;
 	u32 nr;
 	struct btrfs_key key;
+	int level;
 
 	if (!c)
 		return;
 	nr = btrfs_header_nritems(c);
-	if (btrfs_is_leaf(c)) {
+	level = btrfs_header_level(c);
+	if (level == 0) {
 		btrfs_print_leaf(root, c);
 		return;
 	}
 	printk("node %llu level %d total ptrs %d free spc %u\n",
-	       (unsigned long long)btrfs_header_blocknr(c),
+	       (unsigned long long)btrfs_header_bytenr(c),
 	       btrfs_header_level(c), nr,
 	       (u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
 	for (i = 0; i < nr; i++) {
@@ -129,7 +131,8 @@ void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 	}
 	for (i = 0; i < nr; i++) {
 		struct extent_buffer *next = read_tree_block(root,
-						btrfs_node_blockptr(c, i));
+					btrfs_node_blockptr(c, i),
+					btrfs_level_size(root, level - 1));
 		if (btrfs_is_leaf(next) &&
 		    btrfs_header_level(c) != 1)
 			BUG();

commit 5f39d397dfbe140a14edecd4e73c34ce23c4f9ee
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:14:19 2007 -0400

    Btrfs: Create extent_buffer interface for large blocksizes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index bafa78603bd2..a825ce078a54 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -20,10 +20,10 @@
 #include "disk-io.h"
 #include "print-tree.h"
 
-void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
+void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)
 {
 	int i;
-	u32 nr = btrfs_header_nritems(&l->header);
+	u32 nr = btrfs_header_nritems(l);
 	struct btrfs_item *item;
 	struct btrfs_extent_item *ei;
 	struct btrfs_root_item *ri;
@@ -31,119 +31,113 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 	struct btrfs_inode_item *ii;
 	struct btrfs_block_group_item *bi;
 	struct btrfs_file_extent_item *fi;
+	struct btrfs_key key;
+	struct btrfs_key found_key;
 	u32 type;
 
 	printk("leaf %llu total ptrs %d free space %d\n",
-		(unsigned long long)btrfs_header_blocknr(&l->header), nr,
+		(unsigned long long)btrfs_header_blocknr(l), nr,
 		btrfs_leaf_free_space(root, l));
 	for (i = 0 ; i < nr ; i++) {
-		item = l->items + i;
-		type = btrfs_disk_key_type(&item->key);
+		item = btrfs_item_nr(l, i);
+		btrfs_item_key_to_cpu(l, &key, i);
+		type = btrfs_key_type(&key);
 		printk("\titem %d key (%llu %x %llu) itemoff %d itemsize %d\n",
 			i,
-			(unsigned long long)btrfs_disk_key_objectid(&item->key),
-			btrfs_disk_key_flags(&item->key),
-			(unsigned long long)btrfs_disk_key_offset(&item->key),
-			btrfs_item_offset(item),
-			btrfs_item_size(item));
+			(unsigned long long)key.objectid, type,
+			(unsigned long long)key.offset,
+			btrfs_item_offset(l, item), btrfs_item_size(l, item));
 		switch (type) {
 		case BTRFS_INODE_ITEM_KEY:
 			ii = btrfs_item_ptr(l, i, struct btrfs_inode_item);
 			printk("\t\tinode generation %llu size %llu mode %o\n",
-			       (unsigned long long)btrfs_inode_generation(ii),
-			       (unsigned long long)btrfs_inode_size(ii),
-			       btrfs_inode_mode(ii));
+		              (unsigned long long)btrfs_inode_generation(l, ii),
+			      (unsigned long long)btrfs_inode_size(l, ii),
+			       btrfs_inode_mode(l, ii));
 			break;
 		case BTRFS_DIR_ITEM_KEY:
 			di = btrfs_item_ptr(l, i, struct btrfs_dir_item);
+			btrfs_dir_item_key_to_cpu(l, di, &found_key);
 			printk("\t\tdir oid %llu flags %u type %u\n",
-				(unsigned long long)btrfs_disk_key_objectid(
-							    &di->location),
-				btrfs_dir_flags(di),
-				btrfs_dir_type(di));
-			printk("\t\tname %.*s\n",
-			       btrfs_dir_name_len(di),(char *)(di + 1));
+				(unsigned long long)found_key.objectid,
+				btrfs_dir_flags(l, di),
+				btrfs_dir_type(l, di));
 			break;
 		case BTRFS_ROOT_ITEM_KEY:
 			ri = btrfs_item_ptr(l, i, struct btrfs_root_item);
 			printk("\t\troot data blocknr %llu refs %u\n",
-				(unsigned long long)btrfs_root_blocknr(ri),
-				btrfs_root_refs(ri));
+				(unsigned long long)btrfs_disk_root_blocknr(l, ri),
+				btrfs_disk_root_refs(l, ri));
 			break;
 		case BTRFS_EXTENT_ITEM_KEY:
 			ei = btrfs_item_ptr(l, i, struct btrfs_extent_item);
 			printk("\t\textent data refs %u\n",
-				btrfs_extent_refs(ei));
+				btrfs_extent_refs(l, ei));
 			break;
 
 		case BTRFS_EXTENT_DATA_KEY:
 			fi = btrfs_item_ptr(l, i,
 					    struct btrfs_file_extent_item);
-			if (btrfs_file_extent_type(fi) ==
+			if (btrfs_file_extent_type(l, fi) ==
 			    BTRFS_FILE_EXTENT_INLINE) {
 				printk("\t\tinline extent data size %u\n",
-			           btrfs_file_extent_inline_len(l->items + i));
+			           btrfs_file_extent_inline_len(l, item));
 				break;
 			}
 			printk("\t\textent data disk block %llu nr %llu\n",
-			       (unsigned long long)btrfs_file_extent_disk_blocknr(fi),
-			       (unsigned long long)btrfs_file_extent_disk_num_blocks(fi));
+			       (unsigned long long)btrfs_file_extent_disk_blocknr(l, fi),
+			       (unsigned long long)btrfs_file_extent_disk_num_blocks(l, fi));
 			printk("\t\textent data offset %llu nr %llu\n",
-			  (unsigned long long)btrfs_file_extent_offset(fi),
-			  (unsigned long long)btrfs_file_extent_num_blocks(fi));
+			  (unsigned long long)btrfs_file_extent_offset(l, fi),
+			  (unsigned long long)btrfs_file_extent_num_blocks(l, fi));
 			break;
 		case BTRFS_BLOCK_GROUP_ITEM_KEY:
 			bi = btrfs_item_ptr(l, i,
 					    struct btrfs_block_group_item);
 			printk("\t\tblock group used %llu\n",
-			       (unsigned long long)btrfs_block_group_used(bi));
-			break;
-		case BTRFS_STRING_ITEM_KEY:
-			printk("\t\titem data %.*s\n", btrfs_item_size(item),
-				btrfs_leaf_data(l) + btrfs_item_offset(item));
+			       (unsigned long long)btrfs_disk_block_group_used(l, bi));
 			break;
 		};
 	}
 }
 
-void btrfs_print_tree(struct btrfs_root *root, struct buffer_head *t)
+void btrfs_print_tree(struct btrfs_root *root, struct extent_buffer *c)
 {
 	int i;
 	u32 nr;
-	struct btrfs_node *c;
+	struct btrfs_key key;
 
-	if (!t)
+	if (!c)
 		return;
-	c = btrfs_buffer_node(t);
-	nr = btrfs_header_nritems(&c->header);
+	nr = btrfs_header_nritems(c);
 	if (btrfs_is_leaf(c)) {
-		btrfs_print_leaf(root, (struct btrfs_leaf *)c);
+		btrfs_print_leaf(root, c);
 		return;
 	}
 	printk("node %llu level %d total ptrs %d free spc %u\n",
-	       (unsigned long long)btrfs_header_blocknr(&c->header),
-	       btrfs_header_level(&c->header), nr,
+	       (unsigned long long)btrfs_header_blocknr(c),
+	       btrfs_header_level(c), nr,
 	       (u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
 	for (i = 0; i < nr; i++) {
+		btrfs_node_key_to_cpu(c, &key, i);
 		printk("\tkey %d (%llu %u %llu) block %llu\n",
 		       i,
-		       (unsigned long long)c->ptrs[i].key.objectid,
-		       c->ptrs[i].key.flags,
-		       (unsigned long long)c->ptrs[i].key.offset,
+		       (unsigned long long)key.objectid,
+		       key.type,
+		       (unsigned long long)key.offset,
 		       (unsigned long long)btrfs_node_blockptr(c, i));
 	}
 	for (i = 0; i < nr; i++) {
-		struct buffer_head *next_buf = read_tree_block(root,
+		struct extent_buffer *next = read_tree_block(root,
 						btrfs_node_blockptr(c, i));
-		struct btrfs_node *next = btrfs_buffer_node(next_buf);
 		if (btrfs_is_leaf(next) &&
-		    btrfs_header_level(&c->header) != 1)
+		    btrfs_header_level(c) != 1)
 			BUG();
-		if (btrfs_header_level(&next->header) !=
-			btrfs_header_level(&c->header) - 1)
+		if (btrfs_header_level(next) !=
+			btrfs_header_level(c) - 1)
 			BUG();
-		btrfs_print_tree(root, next_buf);
-		btrfs_block_release(root, next_buf);
+		btrfs_print_tree(root, next);
+		free_extent_buffer(next);
 	}
 }
 

commit ec6b910fb330f29e169c9f502c3ac209515af8d1
Author: Zach Brown <zach.brown@oracle.com>
Date:   Wed Jul 11 10:00:37 2007 -0400

    Btrfs: trivial include fixups
    
    Almost none of the files including module.h need to do so,
    remove them.
    
    Include sched.h in extent-tree.c to silence a warning about cond_resched()
    being undeclared.
    
    Signed-off-by: Zach Brown <zach.brown@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index e66acd4e2745..bafa78603bd2 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -16,7 +16,6 @@
  * Boston, MA 021110-1307, USA.
  */
 
-#include <linux/module.h>
 #include "ctree.h"
 #include "disk-io.h"
 #include "print-tree.h"

commit 8c2383c3dd2cb5bb39598ce4fa97154bc591020a
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Jun 18 09:57:58 2007 -0400

    Subject: Rework btrfs_file_write to only allocate while page locks are held
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 1fa705683008..e66acd4e2745 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -31,6 +31,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 	struct btrfs_dir_item *di;
 	struct btrfs_inode_item *ii;
 	struct btrfs_block_group_item *bi;
+	struct btrfs_file_extent_item *fi;
 	u32 type;
 
 	printk("leaf %llu total ptrs %d free space %d\n",
@@ -75,6 +76,23 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 			printk("\t\textent data refs %u\n",
 				btrfs_extent_refs(ei));
 			break;
+
+		case BTRFS_EXTENT_DATA_KEY:
+			fi = btrfs_item_ptr(l, i,
+					    struct btrfs_file_extent_item);
+			if (btrfs_file_extent_type(fi) ==
+			    BTRFS_FILE_EXTENT_INLINE) {
+				printk("\t\tinline extent data size %u\n",
+			           btrfs_file_extent_inline_len(l->items + i));
+				break;
+			}
+			printk("\t\textent data disk block %llu nr %llu\n",
+			       (unsigned long long)btrfs_file_extent_disk_blocknr(fi),
+			       (unsigned long long)btrfs_file_extent_disk_num_blocks(fi));
+			printk("\t\textent data offset %llu nr %llu\n",
+			  (unsigned long long)btrfs_file_extent_offset(fi),
+			  (unsigned long long)btrfs_file_extent_num_blocks(fi));
+			break;
 		case BTRFS_BLOCK_GROUP_ITEM_KEY:
 			bi = btrfs_item_ptr(l, i,
 					    struct btrfs_block_group_item);

commit 6cbd55707802b98843f953d1ae6d8f5bcd9a76c0
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Jun 12 09:07:21 2007 -0400

    Btrfs: add GPLv2
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 21791f037561..1fa705683008 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -1,3 +1,21 @@
+/*
+ * Copyright (C) 2007 Oracle.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License v2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
 #include <linux/module.h>
 #include "ctree.h"
 #include "disk-io.h"

commit 5af3981c1878b0657b9babd2ef7ec98c2008cf2c
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Jun 12 07:50:13 2007 -0400

    Btrfs: printk fixes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 28813411de66..21791f037561 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -15,31 +15,32 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 	struct btrfs_block_group_item *bi;
 	u32 type;
 
-	printk("leaf %Lu total ptrs %d free space %d\n",
-		btrfs_header_blocknr(&l->header), nr,
+	printk("leaf %llu total ptrs %d free space %d\n",
+		(unsigned long long)btrfs_header_blocknr(&l->header), nr,
 		btrfs_leaf_free_space(root, l));
 	for (i = 0 ; i < nr ; i++) {
 		item = l->items + i;
 		type = btrfs_disk_key_type(&item->key);
-		printk("\titem %d key (%Lu %x %Lu) itemoff %d itemsize %d\n",
+		printk("\titem %d key (%llu %x %llu) itemoff %d itemsize %d\n",
 			i,
-			btrfs_disk_key_objectid(&item->key),
+			(unsigned long long)btrfs_disk_key_objectid(&item->key),
 			btrfs_disk_key_flags(&item->key),
-			btrfs_disk_key_offset(&item->key),
+			(unsigned long long)btrfs_disk_key_offset(&item->key),
 			btrfs_item_offset(item),
 			btrfs_item_size(item));
 		switch (type) {
 		case BTRFS_INODE_ITEM_KEY:
 			ii = btrfs_item_ptr(l, i, struct btrfs_inode_item);
-			printk("\t\tinode generation %Lu size %Lu mode %o\n",
-			       btrfs_inode_generation(ii),
-			       btrfs_inode_size(ii),
+			printk("\t\tinode generation %llu size %llu mode %o\n",
+			       (unsigned long long)btrfs_inode_generation(ii),
+			       (unsigned long long)btrfs_inode_size(ii),
 			       btrfs_inode_mode(ii));
 			break;
 		case BTRFS_DIR_ITEM_KEY:
 			di = btrfs_item_ptr(l, i, struct btrfs_dir_item);
-			printk("\t\tdir oid %Lu flags %u type %u\n",
-				btrfs_disk_key_objectid(&di->location),
+			printk("\t\tdir oid %llu flags %u type %u\n",
+				(unsigned long long)btrfs_disk_key_objectid(
+							    &di->location),
 				btrfs_dir_flags(di),
 				btrfs_dir_type(di));
 			printk("\t\tname %.*s\n",
@@ -47,8 +48,9 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 			break;
 		case BTRFS_ROOT_ITEM_KEY:
 			ri = btrfs_item_ptr(l, i, struct btrfs_root_item);
-			printk("\t\troot data blocknr %Lu refs %u\n",
-				btrfs_root_blocknr(ri), btrfs_root_refs(ri));
+			printk("\t\troot data blocknr %llu refs %u\n",
+				(unsigned long long)btrfs_root_blocknr(ri),
+				btrfs_root_refs(ri));
 			break;
 		case BTRFS_EXTENT_ITEM_KEY:
 			ei = btrfs_item_ptr(l, i, struct btrfs_extent_item);
@@ -58,8 +60,8 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 		case BTRFS_BLOCK_GROUP_ITEM_KEY:
 			bi = btrfs_item_ptr(l, i,
 					    struct btrfs_block_group_item);
-			printk("\t\tblock group used %Lu\n",
-			       btrfs_block_group_used(bi));
+			printk("\t\tblock group used %llu\n",
+			       (unsigned long long)btrfs_block_group_used(bi));
 			break;
 		case BTRFS_STRING_ITEM_KEY:
 			printk("\t\titem data %.*s\n", btrfs_item_size(item),
@@ -83,17 +85,17 @@ void btrfs_print_tree(struct btrfs_root *root, struct buffer_head *t)
 		btrfs_print_leaf(root, (struct btrfs_leaf *)c);
 		return;
 	}
-	printk("node %Lu level %d total ptrs %d free spc %u\n",
-	       btrfs_header_blocknr(&c->header),
+	printk("node %llu level %d total ptrs %d free spc %u\n",
+	       (unsigned long long)btrfs_header_blocknr(&c->header),
 	       btrfs_header_level(&c->header), nr,
 	       (u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
 	for (i = 0; i < nr; i++) {
-		printk("\tkey %d (%Lu %u %Lu) block %Lu\n",
+		printk("\tkey %d (%llu %u %llu) block %llu\n",
 		       i,
-		       c->ptrs[i].key.objectid,
+		       (unsigned long long)c->ptrs[i].key.objectid,
 		       c->ptrs[i].key.flags,
-		       c->ptrs[i].key.offset,
-		       btrfs_node_blockptr(c, i));
+		       (unsigned long long)c->ptrs[i].key.offset,
+		       (unsigned long long)btrfs_node_blockptr(c, i));
 	}
 	for (i = 0; i < nr; i++) {
 		struct buffer_head *next_buf = read_tree_block(root,

commit 35b7e476107e3d54f03384e0f2fa3dfd68933353
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed May 2 15:53:43 2007 -0400

    Btrfs: fix page cache memory leak
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 2f95fc67a036..28813411de66 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -1,6 +1,7 @@
 #include <linux/module.h>
 #include "ctree.h"
 #include "disk-io.h"
+#include "print-tree.h"
 
 void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 {

commit 9078a3e1e4e489dddc636c7bb8780349d4298743
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Apr 26 16:46:15 2007 -0400

    Btrfs: start of block group code
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 1e7038b070ae..2f95fc67a036 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -11,6 +11,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 	struct btrfs_root_item *ri;
 	struct btrfs_dir_item *di;
 	struct btrfs_inode_item *ii;
+	struct btrfs_block_group_item *bi;
 	u32 type;
 
 	printk("leaf %Lu total ptrs %d free space %d\n",
@@ -53,6 +54,12 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 			printk("\t\textent data refs %u\n",
 				btrfs_extent_refs(ei));
 			break;
+		case BTRFS_BLOCK_GROUP_ITEM_KEY:
+			bi = btrfs_item_ptr(l, i,
+					    struct btrfs_block_group_item);
+			printk("\t\tblock group used %Lu\n",
+			       btrfs_block_group_used(bi));
+			break;
 		case BTRFS_STRING_ITEM_KEY:
 			printk("\t\titem data %.*s\n", btrfs_item_size(item),
 				btrfs_leaf_data(l) + btrfs_item_offset(item));

commit a429e51371eee3c989160c003ee40bc3947c6a76
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Apr 18 16:15:28 2007 -0400

    Btrfs: working file_write, reorganized key flags
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 0732a2fbb23a..1e7038b070ae 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -19,7 +19,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 	for (i = 0 ; i < nr ; i++) {
 		item = l->items + i;
 		type = btrfs_disk_key_type(&item->key);
-		printk("\titem %d key (%Lu %u %Lu) itemoff %d itemsize %d\n",
+		printk("\titem %d key (%Lu %x %Lu) itemoff %d itemsize %d\n",
 			i,
 			btrfs_disk_key_objectid(&item->key),
 			btrfs_disk_key_flags(&item->key),

commit d0dbc6245cefa36e19dff49c557ccf05e3063e9c
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 10 12:36:36 2007 -0400

    Btrfs: drop owner and parentid
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 854d47d9bdc9..0732a2fbb23a 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -50,8 +50,8 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 			break;
 		case BTRFS_EXTENT_ITEM_KEY:
 			ei = btrfs_item_ptr(l, i, struct btrfs_extent_item);
-			printk("\t\textent data refs %u owner %Lu\n",
-				btrfs_extent_refs(ei), btrfs_extent_owner(ei));
+			printk("\t\textent data refs %u\n",
+				btrfs_extent_refs(ei));
 			break;
 		case BTRFS_STRING_ITEM_KEY:
 			printk("\t\titem data %.*s\n", btrfs_item_size(item),

commit 1b05da2ee6217e7d55460d04335813fec25be4ca
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 10 12:13:09 2007 -0400

    Btrfs: drop the inode map tree
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index f0da65c4f96b..854d47d9bdc9 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -10,7 +10,6 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 	struct btrfs_extent_item *ei;
 	struct btrfs_root_item *ri;
 	struct btrfs_dir_item *di;
-	struct btrfs_inode_map_item *mi;
 	struct btrfs_inode_item *ii;
 	u32 type;
 
@@ -54,13 +53,6 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 			printk("\t\textent data refs %u owner %Lu\n",
 				btrfs_extent_refs(ei), btrfs_extent_owner(ei));
 			break;
-		case BTRFS_INODE_MAP_ITEM_KEY:
-			mi = btrfs_item_ptr(l, i, struct btrfs_inode_map_item);
-			printk("\t\tinode map key %Lu %u %Lu\n",
-			       btrfs_disk_key_objectid(&mi->key),
-			       btrfs_disk_key_flags(&mi->key),
-			       btrfs_disk_key_offset(&mi->key));
-			break;
 		case BTRFS_STRING_ITEM_KEY:
 			printk("\t\titem data %.*s\n", btrfs_item_size(item),
 				btrfs_leaf_data(l) + btrfs_item_offset(item));

commit d6e4a428eb8f92bbb3537ccabadfb1195efb432b
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Apr 6 15:37:36 2007 -0400

    Btrfs: start of support for many FS volumes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index c8ee938c1251..f0da65c4f96b 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -38,7 +38,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 		case BTRFS_DIR_ITEM_KEY:
 			di = btrfs_item_ptr(l, i, struct btrfs_dir_item);
 			printk("\t\tdir oid %Lu flags %u type %u\n",
-				btrfs_dir_objectid(di),
+				btrfs_disk_key_objectid(&di->location),
 				btrfs_dir_flags(di),
 				btrfs_dir_type(di));
 			printk("\t\tname %.*s\n",

commit e20d96d64f9cf9288ffecc9ad4714e91c3b97ca8
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Mar 22 12:13:20 2007 -0400

    Mountable btrfs, with readdir
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index aa2d3fac8804..c8ee938c1251 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -17,7 +17,6 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 	printk("leaf %Lu total ptrs %d free space %d\n",
 		btrfs_header_blocknr(&l->header), nr,
 		btrfs_leaf_free_space(root, l));
-	fflush(stdout);
 	for (i = 0 ; i < nr ; i++) {
 		item = l->items + i;
 		type = btrfs_disk_key_type(&item->key);
@@ -67,10 +66,10 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 				btrfs_leaf_data(l) + btrfs_item_offset(item));
 			break;
 		};
-		fflush(stdout);
 	}
 }
-void btrfs_print_tree(struct btrfs_root *root, struct btrfs_buffer *t)
+
+void btrfs_print_tree(struct btrfs_root *root, struct buffer_head *t)
 {
 	int i;
 	u32 nr;
@@ -78,16 +77,16 @@ void btrfs_print_tree(struct btrfs_root *root, struct btrfs_buffer *t)
 
 	if (!t)
 		return;
-	c = &t->node;
+	c = btrfs_buffer_node(t);
 	nr = btrfs_header_nritems(&c->header);
 	if (btrfs_is_leaf(c)) {
 		btrfs_print_leaf(root, (struct btrfs_leaf *)c);
 		return;
 	}
-	printk("node %Lu level %d total ptrs %d free spc %u\n", t->blocknr,
-	        btrfs_header_level(&c->header), nr,
-		(u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
-	fflush(stdout);
+	printk("node %Lu level %d total ptrs %d free spc %u\n",
+	       btrfs_header_blocknr(&c->header),
+	       btrfs_header_level(&c->header), nr,
+	       (u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
 	for (i = 0; i < nr; i++) {
 		printk("\tkey %d (%Lu %u %Lu) block %Lu\n",
 		       i,
@@ -95,12 +94,11 @@ void btrfs_print_tree(struct btrfs_root *root, struct btrfs_buffer *t)
 		       c->ptrs[i].key.flags,
 		       c->ptrs[i].key.offset,
 		       btrfs_node_blockptr(c, i));
-		fflush(stdout);
 	}
 	for (i = 0; i < nr; i++) {
-		struct btrfs_buffer *next_buf = read_tree_block(root,
+		struct buffer_head *next_buf = read_tree_block(root,
 						btrfs_node_blockptr(c, i));
-		struct btrfs_node *next = &next_buf->node;
+		struct btrfs_node *next = btrfs_buffer_node(next_buf);
 		if (btrfs_is_leaf(next) &&
 		    btrfs_header_level(&c->header) != 1)
 			BUG();

commit 2e635a278354a1a7951e16cfea4c247d6d0e7c99
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Mar 21 11:12:56 2007 -0400

    Btrfs: initial move to kernel module land
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index f53b99da12f3..aa2d3fac8804 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -1,7 +1,4 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include "kerncompat.h"
-#include "radix-tree.h"
+#include <linux/module.h>
 #include "ctree.h"
 #include "disk-io.h"
 
@@ -17,14 +14,14 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 	struct btrfs_inode_item *ii;
 	u32 type;
 
-	printf("leaf %Lu total ptrs %d free space %d\n",
+	printk("leaf %Lu total ptrs %d free space %d\n",
 		btrfs_header_blocknr(&l->header), nr,
 		btrfs_leaf_free_space(root, l));
 	fflush(stdout);
 	for (i = 0 ; i < nr ; i++) {
 		item = l->items + i;
 		type = btrfs_disk_key_type(&item->key);
-		printf("\titem %d key (%Lu %u %Lu) itemoff %d itemsize %d\n",
+		printk("\titem %d key (%Lu %u %Lu) itemoff %d itemsize %d\n",
 			i,
 			btrfs_disk_key_objectid(&item->key),
 			btrfs_disk_key_flags(&item->key),
@@ -34,38 +31,39 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 		switch (type) {
 		case BTRFS_INODE_ITEM_KEY:
 			ii = btrfs_item_ptr(l, i, struct btrfs_inode_item);
-			printf("\t\tinode generation %Lu size %Lu\n",
+			printk("\t\tinode generation %Lu size %Lu mode %o\n",
 			       btrfs_inode_generation(ii),
-			       btrfs_inode_size(ii));
+			       btrfs_inode_size(ii),
+			       btrfs_inode_mode(ii));
 			break;
 		case BTRFS_DIR_ITEM_KEY:
 			di = btrfs_item_ptr(l, i, struct btrfs_dir_item);
-			printf("\t\tdir oid %Lu flags %u type %u\n",
+			printk("\t\tdir oid %Lu flags %u type %u\n",
 				btrfs_dir_objectid(di),
 				btrfs_dir_flags(di),
 				btrfs_dir_type(di));
-			printf("\t\tname %.*s\n",
+			printk("\t\tname %.*s\n",
 			       btrfs_dir_name_len(di),(char *)(di + 1));
 			break;
 		case BTRFS_ROOT_ITEM_KEY:
 			ri = btrfs_item_ptr(l, i, struct btrfs_root_item);
-			printf("\t\troot data blocknr %Lu refs %u\n",
+			printk("\t\troot data blocknr %Lu refs %u\n",
 				btrfs_root_blocknr(ri), btrfs_root_refs(ri));
 			break;
 		case BTRFS_EXTENT_ITEM_KEY:
 			ei = btrfs_item_ptr(l, i, struct btrfs_extent_item);
-			printf("\t\textent data refs %u owner %Lu\n",
+			printk("\t\textent data refs %u owner %Lu\n",
 				btrfs_extent_refs(ei), btrfs_extent_owner(ei));
 			break;
 		case BTRFS_INODE_MAP_ITEM_KEY:
 			mi = btrfs_item_ptr(l, i, struct btrfs_inode_map_item);
-			printf("\t\tinode map key %Lu %u %Lu\n",
+			printk("\t\tinode map key %Lu %u %Lu\n",
 			       btrfs_disk_key_objectid(&mi->key),
 			       btrfs_disk_key_flags(&mi->key),
 			       btrfs_disk_key_offset(&mi->key));
 			break;
 		case BTRFS_STRING_ITEM_KEY:
-			printf("\t\titem data %.*s\n", btrfs_item_size(item),
+			printk("\t\titem data %.*s\n", btrfs_item_size(item),
 				btrfs_leaf_data(l) + btrfs_item_offset(item));
 			break;
 		};
@@ -86,12 +84,12 @@ void btrfs_print_tree(struct btrfs_root *root, struct btrfs_buffer *t)
 		btrfs_print_leaf(root, (struct btrfs_leaf *)c);
 		return;
 	}
-	printf("node %Lu level %d total ptrs %d free spc %u\n", t->blocknr,
+	printk("node %Lu level %d total ptrs %d free spc %u\n", t->blocknr,
 	        btrfs_header_level(&c->header), nr,
 		(u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
 	fflush(stdout);
 	for (i = 0; i < nr; i++) {
-		printf("\tkey %d (%Lu %u %Lu) block %Lu\n",
+		printk("\tkey %d (%Lu %u %Lu) block %Lu\n",
 		       i,
 		       c->ptrs[i].key.objectid,
 		       c->ptrs[i].key.flags,

commit 293ffd5fd340428276fbbd24ce7b98bf6728466b
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Mar 20 15:57:25 2007 -0400

    Btrfs: change dir-test to insert inode_items
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index f250e5fad773..f53b99da12f3 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -14,6 +14,7 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 	struct btrfs_root_item *ri;
 	struct btrfs_dir_item *di;
 	struct btrfs_inode_map_item *mi;
+	struct btrfs_inode_item *ii;
 	u32 type;
 
 	printf("leaf %Lu total ptrs %d free space %d\n",
@@ -32,6 +33,10 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 			btrfs_item_size(item));
 		switch (type) {
 		case BTRFS_INODE_ITEM_KEY:
+			ii = btrfs_item_ptr(l, i, struct btrfs_inode_item);
+			printf("\t\tinode generation %Lu size %Lu\n",
+			       btrfs_inode_generation(ii),
+			       btrfs_inode_size(ii));
 			break;
 		case BTRFS_DIR_ITEM_KEY:
 			di = btrfs_item_ptr(l, i, struct btrfs_dir_item);

commit 9f5fae2fe6dc35b46bf56183f11398451851cb3f
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Mar 20 14:38:32 2007 -0400

    Btrfs: Add inode map, and the start of file extent items
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 0bb5c38427c9..f250e5fad773 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -13,8 +13,8 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 	struct btrfs_extent_item *ei;
 	struct btrfs_root_item *ri;
 	struct btrfs_dir_item *di;
+	struct btrfs_inode_map_item *mi;
 	u32 type;
-	u32 namelen;
 
 	printf("leaf %Lu total ptrs %d free space %d\n",
 		btrfs_header_blocknr(&l->header), nr,
@@ -34,15 +34,13 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 		case BTRFS_INODE_ITEM_KEY:
 			break;
 		case BTRFS_DIR_ITEM_KEY:
-			namelen = btrfs_item_size(l->items + i) - sizeof(*di);
 			di = btrfs_item_ptr(l, i, struct btrfs_dir_item);
 			printf("\t\tdir oid %Lu flags %u type %u\n",
 				btrfs_dir_objectid(di),
 				btrfs_dir_flags(di),
 				btrfs_dir_type(di));
 			printf("\t\tname %.*s\n",
-				namelen, (char *)(di + 1));
-
+			       btrfs_dir_name_len(di),(char *)(di + 1));
 			break;
 		case BTRFS_ROOT_ITEM_KEY:
 			ri = btrfs_item_ptr(l, i, struct btrfs_root_item);
@@ -54,6 +52,13 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 			printf("\t\textent data refs %u owner %Lu\n",
 				btrfs_extent_refs(ei), btrfs_extent_owner(ei));
 			break;
+		case BTRFS_INODE_MAP_ITEM_KEY:
+			mi = btrfs_item_ptr(l, i, struct btrfs_inode_map_item);
+			printf("\t\tinode map key %Lu %u %Lu\n",
+			       btrfs_disk_key_objectid(&mi->key),
+			       btrfs_disk_key_flags(&mi->key),
+			       btrfs_disk_key_offset(&mi->key));
+			break;
 		case BTRFS_STRING_ITEM_KEY:
 			printf("\t\titem data %.*s\n", btrfs_item_size(item),
 				btrfs_leaf_data(l) + btrfs_item_offset(item));

commit a8a2ee0c600a213d13170c2f4d7bd0b304bbec19
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Mar 16 08:46:49 2007 -0400

    Btrfs: add a name_len to dir items, reorder key
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index ad244d658117..0bb5c38427c9 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -23,11 +23,11 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 	for (i = 0 ; i < nr ; i++) {
 		item = l->items + i;
 		type = btrfs_disk_key_type(&item->key);
-		printf("\titem %d key (%Lu %Lu %u) itemoff %d itemsize %d\n",
+		printf("\titem %d key (%Lu %u %Lu) itemoff %d itemsize %d\n",
 			i,
 			btrfs_disk_key_objectid(&item->key),
-			btrfs_disk_key_offset(&item->key),
 			btrfs_disk_key_flags(&item->key),
+			btrfs_disk_key_offset(&item->key),
 			btrfs_item_offset(item),
 			btrfs_item_size(item));
 		switch (type) {
@@ -81,11 +81,11 @@ void btrfs_print_tree(struct btrfs_root *root, struct btrfs_buffer *t)
 		(u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
 	fflush(stdout);
 	for (i = 0; i < nr; i++) {
-		printf("\tkey %d (%Lu %Lu %u) block %Lu\n",
+		printf("\tkey %d (%Lu %u %Lu) block %Lu\n",
 		       i,
 		       c->ptrs[i].key.objectid,
-		       c->ptrs[i].key.offset,
 		       c->ptrs[i].key.flags,
+		       c->ptrs[i].key.offset,
 		       btrfs_node_blockptr(c, i));
 		fflush(stdout);
 	}

commit 1d4f6404de26df49eb8452f8fdf7672b59f407fc
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Mar 15 15:18:43 2007 -0400

    Btrfs: directory testing code and dir item fixes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index f2745b247473..ad244d658117 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -12,7 +12,10 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 	struct btrfs_item *item;
 	struct btrfs_extent_item *ei;
 	struct btrfs_root_item *ri;
+	struct btrfs_dir_item *di;
 	u32 type;
+	u32 namelen;
+
 	printf("leaf %Lu total ptrs %d free space %d\n",
 		btrfs_header_blocknr(&l->header), nr,
 		btrfs_leaf_free_space(root, l));
@@ -31,6 +34,15 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 		case BTRFS_INODE_ITEM_KEY:
 			break;
 		case BTRFS_DIR_ITEM_KEY:
+			namelen = btrfs_item_size(l->items + i) - sizeof(*di);
+			di = btrfs_item_ptr(l, i, struct btrfs_dir_item);
+			printf("\t\tdir oid %Lu flags %u type %u\n",
+				btrfs_dir_objectid(di),
+				btrfs_dir_flags(di),
+				btrfs_dir_type(di));
+			printf("\t\tname %.*s\n",
+				namelen, (char *)(di + 1));
+
 			break;
 		case BTRFS_ROOT_ITEM_KEY:
 			ri = btrfs_item_ptr(l, i, struct btrfs_root_item);

commit 62e2749e03a855d98855f9ce032dbe72d5fad148
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Mar 15 12:56:47 2007 -0400

    Btrfs: Use a chunk of the key flags to record the item type.
    Add (untested and simple) directory item code
    Fix comp_keys to use the new key ordering
    Add btrfs_insert_empty_item
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 4c710190343d..f2745b247473 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -12,27 +12,41 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 	struct btrfs_item *item;
 	struct btrfs_extent_item *ei;
 	struct btrfs_root_item *ri;
+	u32 type;
 	printf("leaf %Lu total ptrs %d free space %d\n",
 		btrfs_header_blocknr(&l->header), nr,
 		btrfs_leaf_free_space(root, l));
 	fflush(stdout);
 	for (i = 0 ; i < nr ; i++) {
 		item = l->items + i;
+		type = btrfs_disk_key_type(&item->key);
 		printf("\titem %d key (%Lu %Lu %u) itemoff %d itemsize %d\n",
 			i,
-			btrfs_key_objectid(&item->key),
-			btrfs_key_offset(&item->key),
-			btrfs_key_flags(&item->key),
+			btrfs_disk_key_objectid(&item->key),
+			btrfs_disk_key_offset(&item->key),
+			btrfs_disk_key_flags(&item->key),
 			btrfs_item_offset(item),
 			btrfs_item_size(item));
-		printf("\t\titem data %.*s\n", btrfs_item_size(item),
-			btrfs_leaf_data(l) + btrfs_item_offset(item));
-		ei = btrfs_item_ptr(l, i, struct btrfs_extent_item);
-		printf("\t\textent data refs %u owner %Lu\n",
-			btrfs_extent_refs(ei), btrfs_extent_owner(ei));
-		ri = btrfs_item_ptr(l, i, struct btrfs_root_item);
-		printf("\t\troot data blocknr %Lu refs %u\n",
-			btrfs_root_blocknr(ri), btrfs_root_refs(ri));
+		switch (type) {
+		case BTRFS_INODE_ITEM_KEY:
+			break;
+		case BTRFS_DIR_ITEM_KEY:
+			break;
+		case BTRFS_ROOT_ITEM_KEY:
+			ri = btrfs_item_ptr(l, i, struct btrfs_root_item);
+			printf("\t\troot data blocknr %Lu refs %u\n",
+				btrfs_root_blocknr(ri), btrfs_root_refs(ri));
+			break;
+		case BTRFS_EXTENT_ITEM_KEY:
+			ei = btrfs_item_ptr(l, i, struct btrfs_extent_item);
+			printf("\t\textent data refs %u owner %Lu\n",
+				btrfs_extent_refs(ei), btrfs_extent_owner(ei));
+			break;
+		case BTRFS_STRING_ITEM_KEY:
+			printf("\t\titem data %.*s\n", btrfs_item_size(item),
+				btrfs_leaf_data(l) + btrfs_item_offset(item));
+			break;
+		};
 		fflush(stdout);
 	}
 }

commit a1516c8921ce2c148b69493e858d95bc79c92f01
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Mar 14 14:26:53 2007 -0400

    Btrfs: reorder key offset and flags
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 7a189eaa589f..4c710190343d 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -18,11 +18,11 @@ void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 	fflush(stdout);
 	for (i = 0 ; i < nr ; i++) {
 		item = l->items + i;
-		printf("\titem %d key (%Lu %u %Lu) itemoff %d itemsize %d\n",
+		printf("\titem %d key (%Lu %Lu %u) itemoff %d itemsize %d\n",
 			i,
 			btrfs_key_objectid(&item->key),
-			btrfs_key_flags(&item->key),
 			btrfs_key_offset(&item->key),
+			btrfs_key_flags(&item->key),
 			btrfs_item_offset(item),
 			btrfs_item_size(item));
 		printf("\t\titem data %.*s\n", btrfs_item_size(item),
@@ -55,10 +55,12 @@ void btrfs_print_tree(struct btrfs_root *root, struct btrfs_buffer *t)
 		(u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
 	fflush(stdout);
 	for (i = 0; i < nr; i++) {
-		printf("\tkey %d (%Lu %u %Lu) block %Lu\n",
+		printf("\tkey %d (%Lu %Lu %u) block %Lu\n",
 		       i,
-		       c->ptrs[i].key.objectid, c->ptrs[i].key.flags,
-		       c->ptrs[i].key.offset, btrfs_node_blockptr(c, i));
+		       c->ptrs[i].key.objectid,
+		       c->ptrs[i].key.offset,
+		       c->ptrs[i].key.flags,
+		       btrfs_node_blockptr(c, i));
 		fflush(stdout);
 	}
 	for (i = 0; i < nr; i++) {

commit 123abc88c9087b9c5605566ee3491aaef17fd837
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Mar 14 14:14:43 2007 -0400

    Btrfs: variable block size support
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index e769f36cf051..7a189eaa589f 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -5,7 +5,7 @@
 #include "ctree.h"
 #include "disk-io.h"
 
-void btrfs_print_leaf(struct btrfs_leaf *l)
+void btrfs_print_leaf(struct btrfs_root *root, struct btrfs_leaf *l)
 {
 	int i;
 	u32 nr = btrfs_header_nritems(&l->header);
@@ -13,7 +13,8 @@ void btrfs_print_leaf(struct btrfs_leaf *l)
 	struct btrfs_extent_item *ei;
 	struct btrfs_root_item *ri;
 	printf("leaf %Lu total ptrs %d free space %d\n",
-		btrfs_header_blocknr(&l->header), nr, btrfs_leaf_free_space(l));
+		btrfs_header_blocknr(&l->header), nr,
+		btrfs_leaf_free_space(root, l));
 	fflush(stdout);
 	for (i = 0 ; i < nr ; i++) {
 		item = l->items + i;
@@ -25,7 +26,7 @@ void btrfs_print_leaf(struct btrfs_leaf *l)
 			btrfs_item_offset(item),
 			btrfs_item_size(item));
 		printf("\t\titem data %.*s\n", btrfs_item_size(item),
-			l->data + btrfs_item_offset(item));
+			btrfs_leaf_data(l) + btrfs_item_offset(item));
 		ei = btrfs_item_ptr(l, i, struct btrfs_extent_item);
 		printf("\t\textent data refs %u owner %Lu\n",
 			btrfs_extent_refs(ei), btrfs_extent_owner(ei));
@@ -46,18 +47,18 @@ void btrfs_print_tree(struct btrfs_root *root, struct btrfs_buffer *t)
 	c = &t->node;
 	nr = btrfs_header_nritems(&c->header);
 	if (btrfs_is_leaf(c)) {
-		btrfs_print_leaf((struct btrfs_leaf *)c);
+		btrfs_print_leaf(root, (struct btrfs_leaf *)c);
 		return;
 	}
 	printf("node %Lu level %d total ptrs %d free spc %u\n", t->blocknr,
 	        btrfs_header_level(&c->header), nr,
-		(u32)NODEPTRS_PER_BLOCK - nr);
+		(u32)BTRFS_NODEPTRS_PER_BLOCK(root) - nr);
 	fflush(stdout);
 	for (i = 0; i < nr; i++) {
 		printf("\tkey %d (%Lu %u %Lu) block %Lu\n",
 		       i,
-		       c->keys[i].objectid, c->keys[i].flags, c->keys[i].offset,
-		       btrfs_node_blockptr(c, i));
+		       c->ptrs[i].key.objectid, c->ptrs[i].key.flags,
+		       c->ptrs[i].key.offset, btrfs_node_blockptr(c, i));
 		fflush(stdout);
 	}
 	for (i = 0; i < nr; i++) {

commit 4beb1b8b75a86373f6020103ab840448d14c8880
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Mar 14 10:31:29 2007 -0400

    Btrfs: add leaf data casting helper
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 64829b6b90f9..e769f36cf051 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -26,11 +26,10 @@ void btrfs_print_leaf(struct btrfs_leaf *l)
 			btrfs_item_size(item));
 		printf("\t\titem data %.*s\n", btrfs_item_size(item),
 			l->data + btrfs_item_offset(item));
-		ei = (struct btrfs_extent_item *)(l->data +
-						  btrfs_item_offset(item));
+		ei = btrfs_item_ptr(l, i, struct btrfs_extent_item);
 		printf("\t\textent data refs %u owner %Lu\n",
 			btrfs_extent_refs(ei), btrfs_extent_owner(ei));
-		ri = (struct btrfs_root_item *)ei;
+		ri = btrfs_item_ptr(l, i, struct btrfs_root_item);
 		printf("\t\troot data blocknr %Lu refs %u\n",
 			btrfs_root_blocknr(ri), btrfs_root_refs(ri));
 		fflush(stdout);

commit 3768f3689fc76ecea17414936dff7a02746a4355
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Mar 13 16:47:54 2007 -0400

    Btrfs: Change the super to point to a tree of trees to enable persistent snapshots
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index c95c85640aa9..64829b6b90f9 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -11,6 +11,7 @@ void btrfs_print_leaf(struct btrfs_leaf *l)
 	u32 nr = btrfs_header_nritems(&l->header);
 	struct btrfs_item *item;
 	struct btrfs_extent_item *ei;
+	struct btrfs_root_item *ri;
 	printf("leaf %Lu total ptrs %d free space %d\n",
 		btrfs_header_blocknr(&l->header), nr, btrfs_leaf_free_space(l));
 	fflush(stdout);
@@ -23,13 +24,15 @@ void btrfs_print_leaf(struct btrfs_leaf *l)
 			btrfs_key_offset(&item->key),
 			btrfs_item_offset(item),
 			btrfs_item_size(item));
-		fflush(stdout);
 		printf("\t\titem data %.*s\n", btrfs_item_size(item),
 			l->data + btrfs_item_offset(item));
 		ei = (struct btrfs_extent_item *)(l->data +
 						  btrfs_item_offset(item));
-		printf("\t\textent data refs %u owner %Lu\n", ei->refs,
-			ei->owner);
+		printf("\t\textent data refs %u owner %Lu\n",
+			btrfs_extent_refs(ei), btrfs_extent_owner(ei));
+		ri = (struct btrfs_root_item *)ei;
+		printf("\t\troot data blocknr %Lu refs %u\n",
+			btrfs_root_blocknr(ri), btrfs_root_refs(ri));
 		fflush(stdout);
 	}
 }
@@ -71,6 +74,5 @@ void btrfs_print_tree(struct btrfs_root *root, struct btrfs_buffer *t)
 		btrfs_print_tree(root, next_buf);
 		btrfs_block_release(root, next_buf);
 	}
-
 }
 

commit 234b63a091e1df6bd4261dd7b3a7490074830628
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Mar 13 10:46:10 2007 -0400

    rename funcs and structs to btrfs
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 101278e1139a..c95c85640aa9 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -5,14 +5,14 @@
 #include "ctree.h"
 #include "disk-io.h"
 
-void print_leaf(struct leaf *l)
+void btrfs_print_leaf(struct btrfs_leaf *l)
 {
 	int i;
 	u32 nr = btrfs_header_nritems(&l->header);
 	struct btrfs_item *item;
-	struct extent_item *ei;
+	struct btrfs_extent_item *ei;
 	printf("leaf %Lu total ptrs %d free space %d\n",
-		btrfs_header_blocknr(&l->header), nr, leaf_free_space(l));
+		btrfs_header_blocknr(&l->header), nr, btrfs_leaf_free_space(l));
 	fflush(stdout);
 	for (i = 0 ; i < nr ; i++) {
 		item = l->items + i;
@@ -26,24 +26,25 @@ void print_leaf(struct leaf *l)
 		fflush(stdout);
 		printf("\t\titem data %.*s\n", btrfs_item_size(item),
 			l->data + btrfs_item_offset(item));
-		ei = (struct extent_item *)(l->data + btrfs_item_offset(item));
+		ei = (struct btrfs_extent_item *)(l->data +
+						  btrfs_item_offset(item));
 		printf("\t\textent data refs %u owner %Lu\n", ei->refs,
 			ei->owner);
 		fflush(stdout);
 	}
 }
-void print_tree(struct ctree_root *root, struct tree_buffer *t)
+void btrfs_print_tree(struct btrfs_root *root, struct btrfs_buffer *t)
 {
 	int i;
 	u32 nr;
-	struct node *c;
+	struct btrfs_node *c;
 
 	if (!t)
 		return;
 	c = &t->node;
 	nr = btrfs_header_nritems(&c->header);
 	if (btrfs_is_leaf(c)) {
-		print_leaf((struct leaf *)c);
+		btrfs_print_leaf((struct btrfs_leaf *)c);
 		return;
 	}
 	printf("node %Lu level %d total ptrs %d free spc %u\n", t->blocknr,
@@ -58,17 +59,17 @@ void print_tree(struct ctree_root *root, struct tree_buffer *t)
 		fflush(stdout);
 	}
 	for (i = 0; i < nr; i++) {
-		struct tree_buffer *next_buf = read_tree_block(root,
+		struct btrfs_buffer *next_buf = read_tree_block(root,
 						btrfs_node_blockptr(c, i));
-		struct node *next = &next_buf->node;
+		struct btrfs_node *next = &next_buf->node;
 		if (btrfs_is_leaf(next) &&
 		    btrfs_header_level(&c->header) != 1)
 			BUG();
 		if (btrfs_header_level(&next->header) !=
 			btrfs_header_level(&c->header) - 1)
 			BUG();
-		print_tree(root, next_buf);
-		tree_block_release(root, next_buf);
+		btrfs_print_tree(root, next_buf);
+		btrfs_block_release(root, next_buf);
 	}
 
 }

commit 1d4f8a0c1eca5586134b56a4114a7cd5e85e3560
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Mar 13 09:28:32 2007 -0400

    Btrfs: node->blockptrs endian fixes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 33f5ee4052c1..101278e1139a 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -54,12 +54,12 @@ void print_tree(struct ctree_root *root, struct tree_buffer *t)
 		printf("\tkey %d (%Lu %u %Lu) block %Lu\n",
 		       i,
 		       c->keys[i].objectid, c->keys[i].flags, c->keys[i].offset,
-		       c->blockptrs[i]);
+		       btrfs_node_blockptr(c, i));
 		fflush(stdout);
 	}
 	for (i = 0; i < nr; i++) {
 		struct tree_buffer *next_buf = read_tree_block(root,
-							    c->blockptrs[i]);
+						btrfs_node_blockptr(c, i));
 		struct node *next = &next_buf->node;
 		if (btrfs_is_leaf(next) &&
 		    btrfs_header_level(&c->header) != 1)

commit 0783fcfc4dc19b8bb99bd51b7afa669ba4cbd377
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Mar 12 20:12:07 2007 -0400

    Btrfs: struct item endian fixes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 7df16b1e4733..33f5ee4052c1 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -9,7 +9,7 @@ void print_leaf(struct leaf *l)
 {
 	int i;
 	u32 nr = btrfs_header_nritems(&l->header);
-	struct item *item;
+	struct btrfs_item *item;
 	struct extent_item *ei;
 	printf("leaf %Lu total ptrs %d free space %d\n",
 		btrfs_header_blocknr(&l->header), nr, leaf_free_space(l));
@@ -18,12 +18,15 @@ void print_leaf(struct leaf *l)
 		item = l->items + i;
 		printf("\titem %d key (%Lu %u %Lu) itemoff %d itemsize %d\n",
 			i,
-			item->key.objectid, item->key.flags, item->key.offset,
-			item->offset, item->size);
+			btrfs_key_objectid(&item->key),
+			btrfs_key_flags(&item->key),
+			btrfs_key_offset(&item->key),
+			btrfs_item_offset(item),
+			btrfs_item_size(item));
 		fflush(stdout);
-		printf("\t\titem data %.*s\n", item->size,
-			l->data+item->offset);
-		ei = (struct extent_item *)(l->data + item->offset);
+		printf("\t\titem data %.*s\n", btrfs_item_size(item),
+			l->data + btrfs_item_offset(item));
+		ei = (struct extent_item *)(l->data + btrfs_item_offset(item));
 		printf("\t\textent data refs %u owner %Lu\n", ei->refs,
 			ei->owner);
 		fflush(stdout);

commit 7518a238ea0152dc849d1ed76d3cae8b44e12f46
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Mar 12 12:01:18 2007 -0400

    Btrfs: get/set for struct header fields
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index e32a959dd3e5..7df16b1e4733 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -8,11 +8,11 @@
 void print_leaf(struct leaf *l)
 {
 	int i;
-	int nr = l->header.nritems;
+	u32 nr = btrfs_header_nritems(&l->header);
 	struct item *item;
 	struct extent_item *ei;
-	printf("leaf %Lu total ptrs %d free space %d\n", l->header.blocknr, nr,
-	       leaf_free_space(l));
+	printf("leaf %Lu total ptrs %d free space %d\n",
+		btrfs_header_blocknr(&l->header), nr, leaf_free_space(l));
 	fflush(stdout);
 	for (i = 0 ; i < nr ; i++) {
 		item = l->items + i;
@@ -32,22 +32,20 @@ void print_leaf(struct leaf *l)
 void print_tree(struct ctree_root *root, struct tree_buffer *t)
 {
 	int i;
-	int nr;
+	u32 nr;
 	struct node *c;
 
 	if (!t)
 		return;
 	c = &t->node;
-	nr = c->header.nritems;
-	if (c->header.blocknr != t->blocknr)
-		BUG();
-	if (is_leaf(c->header.flags)) {
+	nr = btrfs_header_nritems(&c->header);
+	if (btrfs_is_leaf(c)) {
 		print_leaf((struct leaf *)c);
 		return;
 	}
 	printf("node %Lu level %d total ptrs %d free spc %u\n", t->blocknr,
-	        node_level(c->header.flags), c->header.nritems,
-		(u32)NODEPTRS_PER_BLOCK - c->header.nritems);
+	        btrfs_header_level(&c->header), nr,
+		(u32)NODEPTRS_PER_BLOCK - nr);
 	fflush(stdout);
 	for (i = 0; i < nr; i++) {
 		printf("\tkey %d (%Lu %u %Lu) block %Lu\n",
@@ -60,11 +58,11 @@ void print_tree(struct ctree_root *root, struct tree_buffer *t)
 		struct tree_buffer *next_buf = read_tree_block(root,
 							    c->blockptrs[i]);
 		struct node *next = &next_buf->node;
-		if (is_leaf(next->header.flags) &&
-		    node_level(c->header.flags) != 1)
+		if (btrfs_is_leaf(next) &&
+		    btrfs_header_level(&c->header) != 1)
 			BUG();
-		if (node_level(next->header.flags) !=
-			node_level(c->header.flags) - 1)
+		if (btrfs_header_level(&next->header) !=
+			btrfs_header_level(&c->header) - 1)
 			BUG();
 		print_tree(root, next_buf);
 		tree_block_release(root, next_buf);

commit a28ec19775d62d673b034082128aca95780d3737
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Mar 6 20:08:01 2007 -0500

    Btrfs: Fixup reference counting on cows
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index dda08f32c154..e32a959dd3e5 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -21,9 +21,11 @@ void print_leaf(struct leaf *l)
 			item->key.objectid, item->key.flags, item->key.offset,
 			item->offset, item->size);
 		fflush(stdout);
-		printf("\t\titem data %.*s\n", item->size, l->data+item->offset);
+		printf("\t\titem data %.*s\n", item->size,
+			l->data+item->offset);
 		ei = (struct extent_item *)(l->data + item->offset);
-		printf("\t\textent data %u %Lu\n", ei->refs, ei->owner);
+		printf("\t\textent data refs %u owner %Lu\n", ei->refs,
+			ei->owner);
 		fflush(stdout);
 	}
 }

commit d16302ab0ed26e236e9bde8cd54fd604d7d97297
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Feb 26 14:26:58 2007 -0500

    Btrfs: more 32 bit cleanups
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index a9a14223e186..dda08f32c154 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -45,7 +45,7 @@ void print_tree(struct ctree_root *root, struct tree_buffer *t)
 	}
 	printf("node %Lu level %d total ptrs %d free spc %u\n", t->blocknr,
 	        node_level(c->header.flags), c->header.nritems,
-		NODEPTRS_PER_BLOCK - c->header.nritems);
+		(u32)NODEPTRS_PER_BLOCK - c->header.nritems);
 	fflush(stdout);
 	for (i = 0; i < nr; i++) {
 		printf("\tkey %d (%Lu %u %Lu) block %Lu\n",

commit 41903fe666ff8e7b1d47ac7b2f5f9a91c7749498
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Feb 26 10:55:42 2007 -0500

    Btrfs: 32bit cleanups
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 1d591270f4c4..a9a14223e186 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -43,7 +43,7 @@ void print_tree(struct ctree_root *root, struct tree_buffer *t)
 		print_leaf((struct leaf *)c);
 		return;
 	}
-	printf("node %Lu level %d total ptrs %d free spc %lu\n", t->blocknr,
+	printf("node %Lu level %d total ptrs %d free spc %u\n", t->blocknr,
 	        node_level(c->header.flags), c->header.nritems,
 		NODEPTRS_PER_BLOCK - c->header.nritems);
 	fflush(stdout);

commit 7cf75962acd27ed0f819df791486e7b803c7109c
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Feb 26 10:55:01 2007 -0500

    Btrfs: u64 cleanups
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index 594d23b5b24c..1d591270f4c4 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -11,19 +11,19 @@ void print_leaf(struct leaf *l)
 	int nr = l->header.nritems;
 	struct item *item;
 	struct extent_item *ei;
-	printf("leaf %lu total ptrs %d free space %d\n", l->header.blocknr, nr,
+	printf("leaf %Lu total ptrs %d free space %d\n", l->header.blocknr, nr,
 	       leaf_free_space(l));
 	fflush(stdout);
 	for (i = 0 ; i < nr ; i++) {
 		item = l->items + i;
-		printf("\titem %d key (%lu %u %lu) itemoff %d itemsize %d\n",
+		printf("\titem %d key (%Lu %u %Lu) itemoff %d itemsize %d\n",
 			i,
 			item->key.objectid, item->key.flags, item->key.offset,
 			item->offset, item->size);
 		fflush(stdout);
 		printf("\t\titem data %.*s\n", item->size, l->data+item->offset);
 		ei = (struct extent_item *)(l->data + item->offset);
-		printf("\t\textent data %u %lu\n", ei->refs, ei->owner);
+		printf("\t\textent data %u %Lu\n", ei->refs, ei->owner);
 		fflush(stdout);
 	}
 }
@@ -43,12 +43,12 @@ void print_tree(struct ctree_root *root, struct tree_buffer *t)
 		print_leaf((struct leaf *)c);
 		return;
 	}
-	printf("node %lu level %d total ptrs %d free spc %lu\n", t->blocknr,
+	printf("node %Lu level %d total ptrs %d free spc %lu\n", t->blocknr,
 	        node_level(c->header.flags), c->header.nritems,
 		NODEPTRS_PER_BLOCK - c->header.nritems);
 	fflush(stdout);
 	for (i = 0; i < nr; i++) {
-		printf("\tkey %d (%lu %u %lu) block %lu\n",
+		printf("\tkey %d (%Lu %u %Lu) block %Lu\n",
 		       i,
 		       c->keys[i].objectid, c->keys[i].flags, c->keys[i].offset,
 		       c->blockptrs[i]);

commit 5de08d7d50ba535b968d97101ed2ab07c2b8eb7d
Author: Chris Mason <chris.mason@oracle.com>
Date:   Sat Feb 24 06:24:44 2007 -0500

    Btrfs: Break up ctree.c a little
    Extent fixes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
new file mode 100644
index 000000000000..594d23b5b24c
--- /dev/null
+++ b/fs/btrfs/print-tree.c
@@ -0,0 +1,72 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include "kerncompat.h"
+#include "radix-tree.h"
+#include "ctree.h"
+#include "disk-io.h"
+
+void print_leaf(struct leaf *l)
+{
+	int i;
+	int nr = l->header.nritems;
+	struct item *item;
+	struct extent_item *ei;
+	printf("leaf %lu total ptrs %d free space %d\n", l->header.blocknr, nr,
+	       leaf_free_space(l));
+	fflush(stdout);
+	for (i = 0 ; i < nr ; i++) {
+		item = l->items + i;
+		printf("\titem %d key (%lu %u %lu) itemoff %d itemsize %d\n",
+			i,
+			item->key.objectid, item->key.flags, item->key.offset,
+			item->offset, item->size);
+		fflush(stdout);
+		printf("\t\titem data %.*s\n", item->size, l->data+item->offset);
+		ei = (struct extent_item *)(l->data + item->offset);
+		printf("\t\textent data %u %lu\n", ei->refs, ei->owner);
+		fflush(stdout);
+	}
+}
+void print_tree(struct ctree_root *root, struct tree_buffer *t)
+{
+	int i;
+	int nr;
+	struct node *c;
+
+	if (!t)
+		return;
+	c = &t->node;
+	nr = c->header.nritems;
+	if (c->header.blocknr != t->blocknr)
+		BUG();
+	if (is_leaf(c->header.flags)) {
+		print_leaf((struct leaf *)c);
+		return;
+	}
+	printf("node %lu level %d total ptrs %d free spc %lu\n", t->blocknr,
+	        node_level(c->header.flags), c->header.nritems,
+		NODEPTRS_PER_BLOCK - c->header.nritems);
+	fflush(stdout);
+	for (i = 0; i < nr; i++) {
+		printf("\tkey %d (%lu %u %lu) block %lu\n",
+		       i,
+		       c->keys[i].objectid, c->keys[i].flags, c->keys[i].offset,
+		       c->blockptrs[i]);
+		fflush(stdout);
+	}
+	for (i = 0; i < nr; i++) {
+		struct tree_buffer *next_buf = read_tree_block(root,
+							    c->blockptrs[i]);
+		struct node *next = &next_buf->node;
+		if (is_leaf(next->header.flags) &&
+		    node_level(c->header.flags) != 1)
+			BUG();
+		if (node_level(next->header.flags) !=
+			node_level(c->header.flags) - 1)
+			BUG();
+		print_tree(root, next_buf);
+		tree_block_release(root, next_buf);
+	}
+
+}
+
