commit 63f018be577f7cb4787f594400976b4e779b5cfb
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Tue Mar 10 10:59:31 2020 +0200

    btrfs: Remove __ prefix from btrfs_block_rsv_release
    
    Currently the non-prefixed version is a simple wrapper used to hide
    the 4th argument of the prefixed version. This doesn't bring much value
    in practice and only makes the code harder to follow by adding another
    level of indirection. Rectify this by removing the __ prefix and
    have only one public function to release bytes from a block reservation.
    No semantic changes.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index d5c9c69d8263..6009e0e939b5 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -515,7 +515,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	trace_btrfs_space_reservation(fs_info, "ino_cache", trans->transid,
 				      trans->bytes_reserved, 0);
 	btrfs_block_rsv_release(fs_info, trans->block_rsv,
-				trans->bytes_reserved);
+				trans->bytes_reserved, NULL);
 out:
 	trans->block_rsv = rsv;
 	trans->bytes_reserved = num_bytes;

commit a7ccb255852413dd59263e551fd0ef13f76fc9b9
Author: Dennis Zhou <dennis@kernel.org>
Date:   Fri Dec 13 16:22:12 2019 -0800

    btrfs: keep track of which extents have been discarded
    
    Async discard will use the free space cache as backing knowledge for
    which extents to discard. This patch plumbs knowledge about which
    extents need to be discarded into the free space cache from
    unpin_extent_range().
    
    An untrimmed extent can merge with everything as this is a new region.
    Absorbing trimmed extents is a tradeoff to for greater coalescing which
    makes life better for find_free_extent(). Additionally, it seems the
    size of a trim isn't as problematic as the trim io itself.
    
    When reading in the free space cache from disk, if sync is set, mark all
    extents as trimmed. The current code ensures at transaction commit that
    all free space is trimmed when sync is set, so this reflects that.
    
    Signed-off-by: Dennis Zhou <dennis@kernel.org>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 37345fb6191d..d5c9c69d8263 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -107,7 +107,7 @@ static int caching_kthread(void *data)
 
 		if (last != (u64)-1 && last + 1 != key.objectid) {
 			__btrfs_add_free_space(fs_info, ctl, last + 1,
-					       key.objectid - last - 1);
+					       key.objectid - last - 1, 0);
 			wake_up(&root->ino_cache_wait);
 		}
 
@@ -118,7 +118,7 @@ static int caching_kthread(void *data)
 
 	if (last < root->highest_objectid - 1) {
 		__btrfs_add_free_space(fs_info, ctl, last + 1,
-				       root->highest_objectid - last - 1);
+				       root->highest_objectid - last - 1, 0);
 	}
 
 	spin_lock(&root->ino_cache_lock);
@@ -175,7 +175,8 @@ static void start_caching(struct btrfs_root *root)
 	ret = btrfs_find_free_objectid(root, &objectid);
 	if (!ret && objectid <= BTRFS_LAST_FREE_OBJECTID) {
 		__btrfs_add_free_space(fs_info, ctl, objectid,
-				       BTRFS_LAST_FREE_OBJECTID - objectid + 1);
+				       BTRFS_LAST_FREE_OBJECTID - objectid + 1,
+				       0);
 		wake_up(&root->ino_cache_wait);
 	}
 
@@ -221,7 +222,7 @@ void btrfs_return_ino(struct btrfs_root *root, u64 objectid)
 		return;
 again:
 	if (root->ino_cache_state == BTRFS_CACHE_FINISHED) {
-		__btrfs_add_free_space(fs_info, pinned, objectid, 1);
+		__btrfs_add_free_space(fs_info, pinned, objectid, 1, 0);
 	} else {
 		down_write(&fs_info->commit_root_sem);
 		spin_lock(&root->ino_cache_lock);
@@ -234,7 +235,7 @@ void btrfs_return_ino(struct btrfs_root *root, u64 objectid)
 
 		start_caching(root);
 
-		__btrfs_add_free_space(fs_info, pinned, objectid, 1);
+		__btrfs_add_free_space(fs_info, pinned, objectid, 1, 0);
 
 		up_write(&fs_info->commit_root_sem);
 	}
@@ -281,7 +282,7 @@ void btrfs_unpin_free_ino(struct btrfs_root *root)
 		spin_unlock(rbroot_lock);
 		if (count)
 			__btrfs_add_free_space(root->fs_info, ctl,
-					       info->offset, count);
+					       info->offset, count, 0);
 		kmem_cache_free(btrfs_free_space_cachep, info);
 	}
 }

commit 8702ba9396bf7bbae2ab93c94acd4bd37cfa4f09
Author: Qu Wenruo <wqu@suse.com>
Date:   Mon Oct 14 14:34:51 2019 +0800

    btrfs: qgroup: Always free PREALLOC META reserve in btrfs_delalloc_release_extents()
    
    [Background]
    Btrfs qgroup uses two types of reserved space for METADATA space,
    PERTRANS and PREALLOC.
    
    PERTRANS is metadata space reserved for each transaction started by
    btrfs_start_transaction().
    While PREALLOC is for delalloc, where we reserve space before joining a
    transaction, and finally it will be converted to PERTRANS after the
    writeback is done.
    
    [Inconsistency]
    However there is inconsistency in how we handle PREALLOC metadata space.
    
    The most obvious one is:
    In btrfs_buffered_write():
            btrfs_delalloc_release_extents(BTRFS_I(inode), reserve_bytes, true);
    
    We always free qgroup PREALLOC meta space.
    
    While in btrfs_truncate_block():
            btrfs_delalloc_release_extents(BTRFS_I(inode), blocksize, (ret != 0));
    
    We only free qgroup PREALLOC meta space when something went wrong.
    
    [The Correct Behavior]
    The correct behavior should be the one in btrfs_buffered_write(), we
    should always free PREALLOC metadata space.
    
    The reason is, the btrfs_delalloc_* mechanism works by:
    - Reserve metadata first, even it's not necessary
      In btrfs_delalloc_reserve_metadata()
    
    - Free the unused metadata space
      Normally in:
      btrfs_delalloc_release_extents()
      |- btrfs_inode_rsv_release()
         Here we do calculation on whether we should release or not.
    
    E.g. for 64K buffered write, the metadata rsv works like:
    
    /* The first page */
    reserve_meta:   num_bytes=calc_inode_reservations()
    free_meta:      num_bytes=0
    total:          num_bytes=calc_inode_reservations()
    /* The first page caused one outstanding extent, thus needs metadata
       rsv */
    
    /* The 2nd page */
    reserve_meta:   num_bytes=calc_inode_reservations()
    free_meta:      num_bytes=calc_inode_reservations()
    total:          not changed
    /* The 2nd page doesn't cause new outstanding extent, needs no new meta
       rsv, so we free what we have reserved */
    
    /* The 3rd~16th pages */
    reserve_meta:   num_bytes=calc_inode_reservations()
    free_meta:      num_bytes=calc_inode_reservations()
    total:          not changed (still space for one outstanding extent)
    
    This means, if btrfs_delalloc_release_extents() determines to free some
    space, then those space should be freed NOW.
    So for qgroup, we should call btrfs_qgroup_free_meta_prealloc() other
    than btrfs_qgroup_convert_reserved_meta().
    
    The good news is:
    - The callers are not that hot
      The hottest caller is in btrfs_buffered_write(), which is already
      fixed by commit 336a8bb8e36a ("btrfs: Fix wrong
      btrfs_delalloc_release_extents parameter"). Thus it's not that
      easy to cause false EDQUOT.
    
    - The trans commit in advance for qgroup would hide the bug
      Since commit f5fef4593653 ("btrfs: qgroup: Make qgroup async transaction
      commit more aggressive"), when btrfs qgroup metadata free space is slow,
      it will try to commit transaction and free the wrongly converted
      PERTRANS space, so it's not that easy to hit such bug.
    
    [FIX]
    So to fix the problem, remove the @qgroup_free parameter for
    btrfs_delalloc_release_extents(), and always pass true to
    btrfs_inode_rsv_release().
    
    Reported-by: Filipe Manana <fdmanana@suse.com>
    Fixes: 43b18595d660 ("btrfs: qgroup: Use separate meta reservation type for delalloc")
    CC: stable@vger.kernel.org # 4.19+
    Reviewed-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: Qu Wenruo <wqu@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 63cad7865d75..37345fb6191d 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -501,13 +501,13 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	ret = btrfs_prealloc_file_range_trans(inode, trans, 0, 0, prealloc,
 					      prealloc, prealloc, &alloc_hint);
 	if (ret) {
-		btrfs_delalloc_release_extents(BTRFS_I(inode), prealloc, true);
+		btrfs_delalloc_release_extents(BTRFS_I(inode), prealloc);
 		btrfs_delalloc_release_metadata(BTRFS_I(inode), prealloc, true);
 		goto out_put;
 	}
 
 	ret = btrfs_write_out_ino_cache(root, trans, path, inode);
-	btrfs_delalloc_release_extents(BTRFS_I(inode), prealloc, false);
+	btrfs_delalloc_release_extents(BTRFS_I(inode), prealloc);
 out_put:
 	iput(inode);
 out_release:

commit 2bd36e7b4fd60d4ff5f9ba6a0ad84557ae4803c4
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Thu Aug 22 15:14:33 2019 -0400

    btrfs: rename the btrfs_calc_*_metadata_size helpers
    
    btrfs_calc_trunc_metadata_size differs from trans_metadata_size in that
    it doesn't take into account any splitting at the levels, because
    truncate will never split nodes.  However truncate _and_ changing will
    never split nodes, so rename btrfs_calc_trunc_metadata_size to
    btrfs_calc_metadata_size.  Also btrfs_calc_trans_metadata_size is purely
    for inserting items, so rename this to btrfs_calc_insert_metadata_size.
    Making these clearer will help when I start using them differently in
    upcoming patches.
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Josef Bacik <josef@toxicpanda.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 86031cdfc356..63cad7865d75 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -436,7 +436,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	 * 1 item for free space object
 	 * 3 items for pre-allocation
 	 */
-	trans->bytes_reserved = btrfs_calc_trans_metadata_size(fs_info, 10);
+	trans->bytes_reserved = btrfs_calc_insert_metadata_size(fs_info, 10);
 	ret = btrfs_block_rsv_add(root, trans->block_rsv,
 				  trans->bytes_reserved,
 				  BTRFS_RESERVE_NO_FLUSH);

commit 32e534402ad52e9f35c32be68e25213db722892b
Author: Filipe Manana <fdmanana@suse.com>
Date:   Thu Jul 4 16:25:00 2019 +0100

    Btrfs: wake up inode cache waiters sooner to reduce waiting time
    
    If we need to start an inode caching thread, because none currently exists
    on disk, we can wake up all waiters as soon as we mark the range starting
    at root's highest objectid + 1 and ending at BTRFS_LAST_FREE_OBJECTID as
    free, so that they don't need to wait for the caching thread to start and
    do some progress. We follow the same approach within the caching thread,
    since as soon as it finds a free range and marks it as free space in the
    cache, it wakes up all waiters. So improve this by adding such a wakeup
    call after marking that initial range as free space.
    
    Fixes: a47d6b70e28040 ("Btrfs: setup free ino caching in a more asynchronous way")
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index c692c8b6e371..86031cdfc356 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -176,6 +176,7 @@ static void start_caching(struct btrfs_root *root)
 	if (!ret && objectid <= BTRFS_LAST_FREE_OBJECTID) {
 		__btrfs_add_free_space(fs_info, ctl, objectid,
 				       BTRFS_LAST_FREE_OBJECTID - objectid + 1);
+		wake_up(&root->ino_cache_wait);
 	}
 
 	tsk = kthread_run(caching_kthread, root, "btrfs-ino-cache-%llu",

commit 9d123a35d7e97bb2139747b16127c9b22b6a593e
Author: Filipe Manana <fdmanana@suse.com>
Date:   Thu Jul 4 16:24:44 2019 +0100

    Btrfs: fix inode cache waiters hanging on path allocation failure
    
    If the caching thread fails to allocate a path, it returns without waking
    up any cache waiters, leaving them hang forever. Fix this by following the
    same approach as when we fail to start the caching thread: print an error
    message, disable inode caching and make the wakers fallback to non-caching
    mode behaviour (calling btrfs_find_free_objectid()).
    
    Fixes: 581bb050941b4f ("Btrfs: Cache free inode numbers in memory")
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index c242ae434355..c692c8b6e371 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -42,8 +42,10 @@ static int caching_kthread(void *data)
 		return 0;
 
 	path = btrfs_alloc_path();
-	if (!path)
+	if (!path) {
+		fail_caching_thread(root);
 		return -ENOMEM;
+	}
 
 	/* Since the commit root is read-only, we can safely skip locking. */
 	path->skip_locking = 1;

commit a68ebe0790fc88b4314d17984a2cf99ce2361901
Author: Filipe Manana <fdmanana@suse.com>
Date:   Thu Jul 4 16:24:32 2019 +0100

    Btrfs: fix inode cache waiters hanging on failure to start caching thread
    
    If we fail to start the inode caching thread, we print an error message
    and disable the inode cache, however we never wake up any waiters, so they
    hang forever waiting for the caching to finish. Fix this by waking them
    up and have them fallback to a call to btrfs_find_free_objectid().
    
    Fixes: e60efa84252c05 ("Btrfs: avoid triggering bug_on() when we fail to start inode caching task")
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 45db4fb4b959..c242ae434355 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -13,6 +13,19 @@
 #include "transaction.h"
 #include "delalloc-space.h"
 
+static void fail_caching_thread(struct btrfs_root *root)
+{
+	struct btrfs_fs_info *fs_info = root->fs_info;
+
+	btrfs_warn(fs_info, "failed to start inode caching task");
+	btrfs_clear_pending_and_info(fs_info, INODE_MAP_CACHE,
+				     "disabling inode map caching");
+	spin_lock(&root->ino_cache_lock);
+	root->ino_cache_state = BTRFS_CACHE_ERROR;
+	spin_unlock(&root->ino_cache_lock);
+	wake_up(&root->ino_cache_wait);
+}
+
 static int caching_kthread(void *data)
 {
 	struct btrfs_root *root = data;
@@ -165,11 +178,8 @@ static void start_caching(struct btrfs_root *root)
 
 	tsk = kthread_run(caching_kthread, root, "btrfs-ino-cache-%llu",
 			  root->root_key.objectid);
-	if (IS_ERR(tsk)) {
-		btrfs_warn(fs_info, "failed to start inode caching task");
-		btrfs_clear_pending_and_info(fs_info, INODE_MAP_CACHE,
-					     "disabling inode map caching");
-	}
+	if (IS_ERR(tsk))
+		fail_caching_thread(root);
 }
 
 int btrfs_find_free_ino(struct btrfs_root *root, u64 *objectid)
@@ -187,11 +197,14 @@ int btrfs_find_free_ino(struct btrfs_root *root, u64 *objectid)
 
 	wait_event(root->ino_cache_wait,
 		   root->ino_cache_state == BTRFS_CACHE_FINISHED ||
+		   root->ino_cache_state == BTRFS_CACHE_ERROR ||
 		   root->free_ino_ctl->free_space > 0);
 
 	if (root->ino_cache_state == BTRFS_CACHE_FINISHED &&
 	    root->free_ino_ctl->free_space == 0)
 		return -ENOSPC;
+	else if (root->ino_cache_state == BTRFS_CACHE_ERROR)
+		return btrfs_find_free_objectid(root, objectid);
 	else
 		goto again;
 }

commit 29d47d00e0ae61668ee0c5d90bef2893c8abbafa
Author: Filipe Manana <fdmanana@suse.com>
Date:   Thu Jul 4 16:24:19 2019 +0100

    Btrfs: fix inode cache block reserve leak on failure to allocate data space
    
    If we failed to allocate the data extent(s) for the inode space cache, we
    were bailing out without releasing the previously reserved metadata. This
    was triggering the following warnings when unmounting a filesystem:
    
      $ cat -n fs/btrfs/inode.c
      (...)
      9268  void btrfs_destroy_inode(struct inode *inode)
      9269  {
      (...)
      9276          WARN_ON(BTRFS_I(inode)->block_rsv.reserved);
      9277          WARN_ON(BTRFS_I(inode)->block_rsv.size);
      (...)
      9281          WARN_ON(BTRFS_I(inode)->csum_bytes);
      9282          WARN_ON(BTRFS_I(inode)->defrag_bytes);
      (...)
    
    Several fstests test cases triggered this often, such as generic/083,
    generic/102, generic/172, generic/269 and generic/300 at least, producing
    stack traces like the following in dmesg/syslog:
    
      [82039.079546] WARNING: CPU: 2 PID: 13167 at fs/btrfs/inode.c:9276 btrfs_destroy_inode+0x203/0x270 [btrfs]
      (...)
      [82039.081543] CPU: 2 PID: 13167 Comm: umount Tainted: G        W         5.2.0-rc4-btrfs-next-50 #1
      [82039.081912] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.11.2-0-gf9626ccb91-prebuilt.qemu-project.org 04/01/2014
      [82039.082673] RIP: 0010:btrfs_destroy_inode+0x203/0x270 [btrfs]
      (...)
      [82039.083913] RSP: 0018:ffffac0b426a7d30 EFLAGS: 00010206
      [82039.084320] RAX: ffff8ddf77691158 RBX: ffff8dde29b34660 RCX: 0000000000000002
      [82039.084736] RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffff8dde29b34660
      [82039.085156] RBP: ffff8ddf5fbec000 R08: 0000000000000000 R09: 0000000000000000
      [82039.085578] R10: ffffac0b426a7c90 R11: ffffffffb9aad768 R12: ffffac0b426a7db0
      [82039.086000] R13: ffff8ddf5fbec0a0 R14: dead000000000100 R15: 0000000000000000
      [82039.086416] FS:  00007f8db96d12c0(0000) GS:ffff8de036b00000(0000) knlGS:0000000000000000
      [82039.086837] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
      [82039.087253] CR2: 0000000001416108 CR3: 00000002315cc001 CR4: 00000000003606e0
      [82039.087672] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
      [82039.088089] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
      [82039.088504] Call Trace:
      [82039.088918]  destroy_inode+0x3b/0x70
      [82039.089340]  btrfs_free_fs_root+0x16/0xa0 [btrfs]
      [82039.089768]  btrfs_free_fs_roots+0xd8/0x160 [btrfs]
      [82039.090183]  ? wait_for_completion+0x65/0x1a0
      [82039.090607]  close_ctree+0x172/0x370 [btrfs]
      [82039.091021]  generic_shutdown_super+0x6c/0x110
      [82039.091427]  kill_anon_super+0xe/0x30
      [82039.091832]  btrfs_kill_super+0x12/0xa0 [btrfs]
      [82039.092233]  deactivate_locked_super+0x3a/0x70
      [82039.092636]  cleanup_mnt+0x3b/0x80
      [82039.093039]  task_work_run+0x93/0xc0
      [82039.093457]  exit_to_usermode_loop+0xfa/0x100
      [82039.093856]  do_syscall_64+0x162/0x1d0
      [82039.094244]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
      [82039.094634] RIP: 0033:0x7f8db8fbab37
      (...)
      [82039.095876] RSP: 002b:00007ffdce35b468 EFLAGS: 00000246 ORIG_RAX: 00000000000000a6
      [82039.096290] RAX: 0000000000000000 RBX: 0000560d20b00060 RCX: 00007f8db8fbab37
      [82039.096700] RDX: 0000000000000001 RSI: 0000000000000000 RDI: 0000560d20b00240
      [82039.097110] RBP: 0000560d20b00240 R08: 0000560d20b00270 R09: 0000000000000015
      [82039.097522] R10: 00000000000006b4 R11: 0000000000000246 R12: 00007f8db94bce64
      [82039.097937] R13: 0000000000000000 R14: 0000000000000000 R15: 00007ffdce35b6f0
      [82039.098350] irq event stamp: 0
      [82039.098750] hardirqs last  enabled at (0): [<0000000000000000>] 0x0
      [82039.099150] hardirqs last disabled at (0): [<ffffffffb7884ff2>] copy_process.part.33+0x7f2/0x1f00
      [82039.099545] softirqs last  enabled at (0): [<ffffffffb7884ff2>] copy_process.part.33+0x7f2/0x1f00
      [82039.099925] softirqs last disabled at (0): [<0000000000000000>] 0x0
      [82039.100292] ---[ end trace f2521afa616ddccc ]---
      [82039.100707] WARNING: CPU: 2 PID: 13167 at fs/btrfs/inode.c:9277 btrfs_destroy_inode+0x1ac/0x270 [btrfs]
      (...)
      [82039.103050] CPU: 2 PID: 13167 Comm: umount Tainted: G        W         5.2.0-rc4-btrfs-next-50 #1
      [82039.103428] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.11.2-0-gf9626ccb91-prebuilt.qemu-project.org 04/01/2014
      [82039.104203] RIP: 0010:btrfs_destroy_inode+0x1ac/0x270 [btrfs]
      (...)
      [82039.105461] RSP: 0018:ffffac0b426a7d30 EFLAGS: 00010206
      [82039.105866] RAX: ffff8ddf77691158 RBX: ffff8dde29b34660 RCX: 0000000000000002
      [82039.106270] RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffff8dde29b34660
      [82039.106673] RBP: ffff8ddf5fbec000 R08: 0000000000000000 R09: 0000000000000000
      [82039.107078] R10: ffffac0b426a7c90 R11: ffffffffb9aad768 R12: ffffac0b426a7db0
      [82039.107487] R13: ffff8ddf5fbec0a0 R14: dead000000000100 R15: 0000000000000000
      [82039.107894] FS:  00007f8db96d12c0(0000) GS:ffff8de036b00000(0000) knlGS:0000000000000000
      [82039.108309] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
      [82039.108723] CR2: 0000000001416108 CR3: 00000002315cc001 CR4: 00000000003606e0
      [82039.109146] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
      [82039.109567] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
      [82039.109989] Call Trace:
      [82039.110405]  destroy_inode+0x3b/0x70
      [82039.110830]  btrfs_free_fs_root+0x16/0xa0 [btrfs]
      [82039.111257]  btrfs_free_fs_roots+0xd8/0x160 [btrfs]
      [82039.111675]  ? wait_for_completion+0x65/0x1a0
      [82039.112101]  close_ctree+0x172/0x370 [btrfs]
      [82039.112519]  generic_shutdown_super+0x6c/0x110
      [82039.112988]  kill_anon_super+0xe/0x30
      [82039.113439]  btrfs_kill_super+0x12/0xa0 [btrfs]
      [82039.113861]  deactivate_locked_super+0x3a/0x70
      [82039.114278]  cleanup_mnt+0x3b/0x80
      [82039.114685]  task_work_run+0x93/0xc0
      [82039.115083]  exit_to_usermode_loop+0xfa/0x100
      [82039.115476]  do_syscall_64+0x162/0x1d0
      [82039.115863]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
      [82039.116254] RIP: 0033:0x7f8db8fbab37
      (...)
      [82039.117463] RSP: 002b:00007ffdce35b468 EFLAGS: 00000246 ORIG_RAX: 00000000000000a6
      [82039.117882] RAX: 0000000000000000 RBX: 0000560d20b00060 RCX: 00007f8db8fbab37
      [82039.118330] RDX: 0000000000000001 RSI: 0000000000000000 RDI: 0000560d20b00240
      [82039.118743] RBP: 0000560d20b00240 R08: 0000560d20b00270 R09: 0000000000000015
      [82039.119159] R10: 00000000000006b4 R11: 0000000000000246 R12: 00007f8db94bce64
      [82039.119574] R13: 0000000000000000 R14: 0000000000000000 R15: 00007ffdce35b6f0
      [82039.119987] irq event stamp: 0
      [82039.120387] hardirqs last  enabled at (0): [<0000000000000000>] 0x0
      [82039.120787] hardirqs last disabled at (0): [<ffffffffb7884ff2>] copy_process.part.33+0x7f2/0x1f00
      [82039.121182] softirqs last  enabled at (0): [<ffffffffb7884ff2>] copy_process.part.33+0x7f2/0x1f00
      [82039.121563] softirqs last disabled at (0): [<0000000000000000>] 0x0
      [82039.121933] ---[ end trace f2521afa616ddccd ]---
      [82039.122353] WARNING: CPU: 2 PID: 13167 at fs/btrfs/inode.c:9278 btrfs_destroy_inode+0x1bc/0x270 [btrfs]
      (...)
      [82039.124606] CPU: 2 PID: 13167 Comm: umount Tainted: G        W         5.2.0-rc4-btrfs-next-50 #1
      [82039.125008] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.11.2-0-gf9626ccb91-prebuilt.qemu-project.org 04/01/2014
      [82039.125801] RIP: 0010:btrfs_destroy_inode+0x1bc/0x270 [btrfs]
      (...)
      [82039.126998] RSP: 0018:ffffac0b426a7d30 EFLAGS: 00010202
      [82039.127399] RAX: ffff8ddf77691158 RBX: ffff8dde29b34660 RCX: 0000000000000002
      [82039.127803] RDX: 0000000000000001 RSI: 0000000000000001 RDI: ffff8dde29b34660
      [82039.128206] RBP: ffff8ddf5fbec000 R08: 0000000000000000 R09: 0000000000000000
      [82039.128611] R10: ffffac0b426a7c90 R11: ffffffffb9aad768 R12: ffffac0b426a7db0
      [82039.129020] R13: ffff8ddf5fbec0a0 R14: dead000000000100 R15: 0000000000000000
      [82039.129428] FS:  00007f8db96d12c0(0000) GS:ffff8de036b00000(0000) knlGS:0000000000000000
      [82039.129846] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
      [82039.130261] CR2: 0000000001416108 CR3: 00000002315cc001 CR4: 00000000003606e0
      [82039.130684] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
      [82039.131142] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
      [82039.131561] Call Trace:
      [82039.131990]  destroy_inode+0x3b/0x70
      [82039.132417]  btrfs_free_fs_root+0x16/0xa0 [btrfs]
      [82039.132844]  btrfs_free_fs_roots+0xd8/0x160 [btrfs]
      [82039.133262]  ? wait_for_completion+0x65/0x1a0
      [82039.133688]  close_ctree+0x172/0x370 [btrfs]
      [82039.134157]  generic_shutdown_super+0x6c/0x110
      [82039.134575]  kill_anon_super+0xe/0x30
      [82039.134997]  btrfs_kill_super+0x12/0xa0 [btrfs]
      [82039.135415]  deactivate_locked_super+0x3a/0x70
      [82039.135832]  cleanup_mnt+0x3b/0x80
      [82039.136239]  task_work_run+0x93/0xc0
      [82039.136637]  exit_to_usermode_loop+0xfa/0x100
      [82039.137029]  do_syscall_64+0x162/0x1d0
      [82039.137418]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
      [82039.137812] RIP: 0033:0x7f8db8fbab37
      (...)
      [82039.139059] RSP: 002b:00007ffdce35b468 EFLAGS: 00000246 ORIG_RAX: 00000000000000a6
      [82039.139475] RAX: 0000000000000000 RBX: 0000560d20b00060 RCX: 00007f8db8fbab37
      [82039.139890] RDX: 0000000000000001 RSI: 0000000000000000 RDI: 0000560d20b00240
      [82039.140302] RBP: 0000560d20b00240 R08: 0000560d20b00270 R09: 0000000000000015
      [82039.140719] R10: 00000000000006b4 R11: 0000000000000246 R12: 00007f8db94bce64
      [82039.141138] R13: 0000000000000000 R14: 0000000000000000 R15: 00007ffdce35b6f0
      [82039.141597] irq event stamp: 0
      [82039.142043] hardirqs last  enabled at (0): [<0000000000000000>] 0x0
      [82039.142443] hardirqs last disabled at (0): [<ffffffffb7884ff2>] copy_process.part.33+0x7f2/0x1f00
      [82039.142839] softirqs last  enabled at (0): [<ffffffffb7884ff2>] copy_process.part.33+0x7f2/0x1f00
      [82039.143220] softirqs last disabled at (0): [<0000000000000000>] 0x0
      [82039.143588] ---[ end trace f2521afa616ddcce ]---
      [82039.167472] WARNING: CPU: 3 PID: 13167 at fs/btrfs/extent-tree.c:10120 btrfs_free_block_groups+0x30d/0x460 [btrfs]
      (...)
      [82039.173800] CPU: 3 PID: 13167 Comm: umount Tainted: G        W         5.2.0-rc4-btrfs-next-50 #1
      [82039.174847] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.11.2-0-gf9626ccb91-prebuilt.qemu-project.org 04/01/2014
      [82039.177031] RIP: 0010:btrfs_free_block_groups+0x30d/0x460 [btrfs]
      (...)
      [82039.180397] RSP: 0018:ffffac0b426a7dd8 EFLAGS: 00010206
      [82039.181574] RAX: ffff8de010a1db40 RBX: ffff8de010a1db40 RCX: 0000000000170014
      [82039.182711] RDX: ffff8ddff4380040 RSI: ffff8de010a1da58 RDI: 0000000000000246
      [82039.183817] RBP: ffff8ddf5fbec000 R08: 0000000000000000 R09: 0000000000000000
      [82039.184925] R10: ffff8de036404380 R11: ffffffffb8a5ea00 R12: ffff8de010a1b2b8
      [82039.186090] R13: ffff8de010a1b2b8 R14: 0000000000000000 R15: dead000000000100
      [82039.187208] FS:  00007f8db96d12c0(0000) GS:ffff8de036b80000(0000) knlGS:0000000000000000
      [82039.188345] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
      [82039.189481] CR2: 00007fb044005170 CR3: 00000002315cc006 CR4: 00000000003606e0
      [82039.190674] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
      [82039.191829] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
      [82039.192978] Call Trace:
      [82039.194160]  close_ctree+0x19a/0x370 [btrfs]
      [82039.195315]  generic_shutdown_super+0x6c/0x110
      [82039.196486]  kill_anon_super+0xe/0x30
      [82039.197645]  btrfs_kill_super+0x12/0xa0 [btrfs]
      [82039.198696]  deactivate_locked_super+0x3a/0x70
      [82039.199619]  cleanup_mnt+0x3b/0x80
      [82039.200559]  task_work_run+0x93/0xc0
      [82039.201505]  exit_to_usermode_loop+0xfa/0x100
      [82039.202436]  do_syscall_64+0x162/0x1d0
      [82039.203339]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
      [82039.204091] RIP: 0033:0x7f8db8fbab37
      (...)
      [82039.206360] RSP: 002b:00007ffdce35b468 EFLAGS: 00000246 ORIG_RAX: 00000000000000a6
      [82039.207132] RAX: 0000000000000000 RBX: 0000560d20b00060 RCX: 00007f8db8fbab37
      [82039.207906] RDX: 0000000000000001 RSI: 0000000000000000 RDI: 0000560d20b00240
      [82039.208621] RBP: 0000560d20b00240 R08: 0000560d20b00270 R09: 0000000000000015
      [82039.209285] R10: 00000000000006b4 R11: 0000000000000246 R12: 00007f8db94bce64
      [82039.209984] R13: 0000000000000000 R14: 0000000000000000 R15: 00007ffdce35b6f0
      [82039.210642] irq event stamp: 0
      [82039.211306] hardirqs last  enabled at (0): [<0000000000000000>] 0x0
      [82039.211971] hardirqs last disabled at (0): [<ffffffffb7884ff2>] copy_process.part.33+0x7f2/0x1f00
      [82039.212643] softirqs last  enabled at (0): [<ffffffffb7884ff2>] copy_process.part.33+0x7f2/0x1f00
      [82039.213304] softirqs last disabled at (0): [<0000000000000000>] 0x0
      [82039.213875] ---[ end trace f2521afa616ddccf ]---
    
    Fix this by releasing the reserved metadata on failure to allocate data
    extent(s) for the inode cache.
    
    Fixes: 69fe2d75dd91d0 ("btrfs: make the delalloc block rsv per inode")
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 84b2c9ee52a7..45db4fb4b959 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -486,6 +486,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 					      prealloc, prealloc, &alloc_hint);
 	if (ret) {
 		btrfs_delalloc_release_extents(BTRFS_I(inode), prealloc, true);
+		btrfs_delalloc_release_metadata(BTRFS_I(inode), prealloc, true);
 		goto out_put;
 	}
 

commit 7764d56baa844d7f6206394f21a0e8c1f303c476
Author: Filipe Manana <fdmanana@suse.com>
Date:   Thu Jul 4 16:24:09 2019 +0100

    Btrfs: fix hang when loading existing inode cache off disk
    
    If we are able to load an existing inode cache off disk, we set the state
    of the cache to BTRFS_CACHE_FINISHED, but we don't wake up any one waiting
    for the cache to be available. This means that anyone waiting for the
    cache to be available, waiting on the condition that either its state is
    BTRFS_CACHE_FINISHED or its available free space is greather than zero,
    can hang forever.
    
    This could be observed running fstests with MOUNT_OPTIONS="-o inode_cache",
    in particular test case generic/161 triggered it very frequently for me,
    producing a trace like the following:
    
      [63795.739712] BTRFS info (device sdc): enabling inode map caching
      [63795.739714] BTRFS info (device sdc): disk space caching is enabled
      [63795.739716] BTRFS info (device sdc): has skinny extents
      [64036.653886] INFO: task btrfs-transacti:3917 blocked for more than 120 seconds.
      [64036.654079]       Not tainted 5.2.0-rc4-btrfs-next-50 #1
      [64036.654143] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
      [64036.654232] btrfs-transacti D    0  3917      2 0x80004000
      [64036.654239] Call Trace:
      [64036.654258]  ? __schedule+0x3ae/0x7b0
      [64036.654271]  schedule+0x3a/0xb0
      [64036.654325]  btrfs_commit_transaction+0x978/0xae0 [btrfs]
      [64036.654339]  ? remove_wait_queue+0x60/0x60
      [64036.654395]  transaction_kthread+0x146/0x180 [btrfs]
      [64036.654450]  ? btrfs_cleanup_transaction+0x620/0x620 [btrfs]
      [64036.654456]  kthread+0x103/0x140
      [64036.654464]  ? kthread_create_worker_on_cpu+0x70/0x70
      [64036.654476]  ret_from_fork+0x3a/0x50
      [64036.654504] INFO: task xfs_io:3919 blocked for more than 120 seconds.
      [64036.654568]       Not tainted 5.2.0-rc4-btrfs-next-50 #1
      [64036.654617] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
      [64036.654685] xfs_io          D    0  3919   3633 0x00000000
      [64036.654691] Call Trace:
      [64036.654703]  ? __schedule+0x3ae/0x7b0
      [64036.654716]  schedule+0x3a/0xb0
      [64036.654756]  btrfs_find_free_ino+0xa9/0x120 [btrfs]
      [64036.654764]  ? remove_wait_queue+0x60/0x60
      [64036.654809]  btrfs_create+0x72/0x1f0 [btrfs]
      [64036.654822]  lookup_open+0x6bc/0x790
      [64036.654849]  path_openat+0x3bc/0xc00
      [64036.654854]  ? __lock_acquire+0x331/0x1cb0
      [64036.654869]  do_filp_open+0x99/0x110
      [64036.654884]  ? __alloc_fd+0xee/0x200
      [64036.654895]  ? do_raw_spin_unlock+0x49/0xc0
      [64036.654909]  ? do_sys_open+0x132/0x220
      [64036.654913]  do_sys_open+0x132/0x220
      [64036.654926]  do_syscall_64+0x60/0x1d0
      [64036.654933]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    Fix this by adding a wake_up() call right after setting the cache state to
    BTRFS_CACHE_FINISHED, at start_caching(), when we are able to load the
    cache from disk.
    
    Fixes: 82d5902d9c681b ("Btrfs: Support reading/writing on disk free ino cache")
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 2e8bb402050b..84b2c9ee52a7 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -146,6 +146,7 @@ static void start_caching(struct btrfs_root *root)
 		spin_lock(&root->ino_cache_lock);
 		root->ino_cache_state = BTRFS_CACHE_FINISHED;
 		spin_unlock(&root->ino_cache_lock);
+		wake_up(&root->ino_cache_wait);
 		return;
 	}
 

commit 867363429d706984915cb4b1f299ce05f8413e23
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Wed Jun 19 15:12:00 2019 -0400

    btrfs: migrate the delalloc space stuff to it's own home
    
    We have code for data and metadata reservations for delalloc.  There's
    quite a bit of code here, and it's used in a lot of places so I've
    separated it out to it's own file.  inode.c and file.c are already
    pretty large, and this code is complicated enough to live in its own
    space.
    
    Signed-off-by: Josef Bacik <josef@toxicpanda.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index ffca2abf13d0..2e8bb402050b 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -11,6 +11,7 @@
 #include "free-space-cache.h"
 #include "inode-map.h"
 #include "transaction.h"
+#include "delalloc-space.h"
 
 static int caching_kthread(void *data)
 {

commit d7f663fa3ff906247a979c1115bc92cbabfb19ba
Author: David Sterba <dsterba@suse.com>
Date:   Fri Jun 29 10:56:47 2018 +0200

    btrfs: prune unused includes
    
    Remove includes if none of the interfaces and exports is used in the
    given source file.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index a56f88ea9c73..ffca2abf13d0 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -3,7 +3,6 @@
  * Copyright (C) 2007 Oracle.  All rights reserved.
  */
 
-#include <linux/delay.h>
 #include <linux/kthread.h>
 #include <linux/pagemap.h>
 

commit bc931c0ef8f9e21ed5732ea148aeea9d0fffd3f8
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Jun 22 09:18:29 2018 +0200

    btrfs: Refactor count handling in btrfs_unpin_free_ino
    
    With gcc 4.1.2:
    
        fs/btrfs/inode-map.c: In function ‘btrfs_unpin_free_ino’:
        fs/btrfs/inode-map.c:241: warning: ‘count’ may be used uninitialized in this function
    
    While this warning is a false-positive, it can easily be killed by
    refactoring the code.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 12fcd8897c33..a56f88ea9c73 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -244,8 +244,6 @@ void btrfs_unpin_free_ino(struct btrfs_root *root)
 		return;
 
 	while (1) {
-		bool add_to_ctl = true;
-
 		spin_lock(rbroot_lock);
 		n = rb_first(rbroot);
 		if (!n) {
@@ -257,15 +255,14 @@ void btrfs_unpin_free_ino(struct btrfs_root *root)
 		BUG_ON(info->bitmap); /* Logic error */
 
 		if (info->offset > root->ino_cache_progress)
-			add_to_ctl = false;
-		else if (info->offset + info->bytes > root->ino_cache_progress)
-			count = root->ino_cache_progress - info->offset + 1;
+			count = 0;
 		else
-			count = info->bytes;
+			count = min(root->ino_cache_progress - info->offset + 1,
+				    info->bytes);
 
 		rb_erase(&info->offset_index, rbroot);
 		spin_unlock(rbroot_lock);
-		if (add_to_ctl)
+		if (count)
 			__btrfs_add_free_space(root->fs_info, ctl,
 					       info->offset, count);
 		kmem_cache_free(btrfs_free_space_cachep, info);

commit c1d7c514f745628eb096c5cbb10737855879ae25
Author: David Sterba <dsterba@suse.com>
Date:   Tue Apr 3 19:23:33 2018 +0200

    btrfs: replace GPL boilerplate by SPDX -- sources
    
    Remove GPL boilerplate text (long, short, one-line) and keep the rest,
    ie. personal, company or original source copyright statements. Add the
    SPDX header.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 9409dcc7020d..12fcd8897c33 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -1,19 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2007 Oracle.  All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License v2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public
- * License along with this program; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 021110-1307, USA.
  */
 
 #include <linux/delay.h>

commit 43b18595d6603cb4197fb9b063915cd7802141a6
Author: Qu Wenruo <wqu@suse.com>
Date:   Tue Dec 12 15:34:32 2017 +0800

    btrfs: qgroup: Use separate meta reservation type for delalloc
    
    Before this patch, btrfs qgroup is mixing per-transcation meta rsv with
    preallocated meta rsv, making it quite easy to underflow qgroup meta
    reservation.
    
    Since we have the new qgroup meta rsv types, apply it to delalloc
    reservation.
    
    Now for delalloc, most of its reserved space will use META_PREALLOC qgroup
    rsv type.
    
    And for callers reducing outstanding extent like btrfs_finish_ordered_io(),
    they will convert corresponding META_PREALLOC reservation to
    META_PERTRANS.
    
    This is mainly due to the fact that current qgroup numbers will only be
    updated in btrfs_commit_transaction(), that's to say if we don't keep
    such placeholder reservation, we can exceed qgroup limitation.
    
    And for callers freeing outstanding extent in error handler, we will
    just free META_PREALLOC bytes.
    
    This behavior makes callers of btrfs_qgroup_release_meta() or
    btrfs_qgroup_convert_meta() to be aware of which type they are.
    So in this patch, btrfs_delalloc_release_metadata() and its callers get
    an extra parameter to info qgroup to do correct meta convert/release.
    
    The good news is, even we use the wrong type (convert or free), it won't
    cause obvious bug, as prealloc type is always in good shape, and the
    type only affects how per-trans meta is increased or not.
    
    So the worst case will be at most metadata limitation can be sometimes
    exceeded (no convert at all) or metadata limitation is reached too soon
    (no free at all).
    
    Signed-off-by: Qu Wenruo <wqu@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 022b19336fee..9409dcc7020d 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -500,12 +500,12 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	ret = btrfs_prealloc_file_range_trans(inode, trans, 0, 0, prealloc,
 					      prealloc, prealloc, &alloc_hint);
 	if (ret) {
-		btrfs_delalloc_release_extents(BTRFS_I(inode), prealloc);
+		btrfs_delalloc_release_extents(BTRFS_I(inode), prealloc, true);
 		goto out_put;
 	}
 
 	ret = btrfs_write_out_ino_cache(root, trans, path, inode);
-	btrfs_delalloc_release_extents(BTRFS_I(inode), prealloc);
+	btrfs_delalloc_release_extents(BTRFS_I(inode), prealloc, false);
 out_put:
 	iput(inode);
 out_release:

commit 8b62f87bad9cf06e536799bf8cb942ab95f6bfa4
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Thu Oct 19 14:15:55 2017 -0400

    Btrfs: rework outstanding_extents
    
    Right now we do a lot of weird hoops around outstanding_extents in order
    to keep the extent count consistent.  This is because we logically
    transfer the outstanding_extent count from the initial reservation
    through the set_delalloc_bits.  This makes it pretty difficult to get a
    handle on how and when we need to mess with outstanding_extents.
    
    Fix this by revamping the rules of how we deal with outstanding_extents.
    Now instead everybody that is holding on to a delalloc extent is
    required to increase the outstanding extents count for itself.  This
    means we'll have something like this
    
    btrfs_delalloc_reserve_metadata - outstanding_extents = 1
     btrfs_set_extent_delalloc      - outstanding_extents = 2
    btrfs_release_delalloc_extents  - outstanding_extents = 1
    
    for an initial file write.  Now take the append write where we extend an
    existing delalloc range but still under the maximum extent size
    
    btrfs_delalloc_reserve_metadata - outstanding_extents = 2
      btrfs_set_extent_delalloc
        btrfs_set_bit_hook          - outstanding_extents = 3
        btrfs_merge_extent_hook     - outstanding_extents = 2
    btrfs_delalloc_release_extents  - outstanding_extnets = 1
    
    In order to make the ordered extent transition we of course must now
    make ordered extents carry their own outstanding_extent reservation, so
    for cow_file_range we end up with
    
    btrfs_add_ordered_extent        - outstanding_extents = 2
    clear_extent_bit                - outstanding_extents = 1
    btrfs_remove_ordered_extent     - outstanding_extents = 0
    
    This makes all manipulations of outstanding_extents much more explicit.
    Every successful call to btrfs_delalloc_reserve_metadata _must_ now be
    combined with btrfs_release_delalloc_extents, even in the error case, as
    that is the only function that actually modifies the
    outstanding_extents counter.
    
    The drawback to this is now we are much more likely to have transient
    cases where outstanding_extents is much larger than it actually should
    be.  This could happen before as we manipulated the delalloc bits, but
    now it happens basically at every write.  This may put more pressure on
    the ENOSPC flushing code, but I think making this code simpler is worth
    the cost.  I have another change coming to mitigate this side-effect
    somewhat.
    
    I also added trace points for the counter manipulation.  These were used
    by a bpf script I wrote to help track down leak issues.
    
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index d02019747d00..022b19336fee 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -500,11 +500,12 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	ret = btrfs_prealloc_file_range_trans(inode, trans, 0, 0, prealloc,
 					      prealloc, prealloc, &alloc_hint);
 	if (ret) {
-		btrfs_delalloc_release_metadata(BTRFS_I(inode), prealloc);
+		btrfs_delalloc_release_extents(BTRFS_I(inode), prealloc);
 		goto out_put;
 	}
 
 	ret = btrfs_write_out_ino_cache(root, trans, path, inode);
+	btrfs_delalloc_release_extents(BTRFS_I(inode), prealloc);
 out_put:
 	iput(inode);
 out_release:

commit 364ecf3651e0862152c8b340d7cb3021dc0122c7
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Mon Feb 27 15:10:38 2017 +0800

    btrfs: qgroup: Introduce extent changeset for qgroup reserve functions
    
    Introduce a new parameter, struct extent_changeset for
    btrfs_qgroup_reserved_data() and its callers.
    
    Such extent_changeset was used in btrfs_qgroup_reserve_data() to record
    which range it reserved in current reserve, so it can free it in error
    paths.
    
    The reason we need to export it to callers is, at buffered write error
    path, without knowing what exactly which range we reserved in current
    allocation, we can free space which is not reserved by us.
    
    This will lead to qgroup reserved space underflow.
    
    Reviewed-by: Chandan Rajendra <chandan@linux.vnet.ibm.com>
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 5c6c20ec64d8..d02019747d00 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -400,6 +400,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	struct btrfs_path *path;
 	struct inode *inode;
 	struct btrfs_block_rsv *rsv;
+	struct extent_changeset *data_reserved = NULL;
 	u64 num_bytes;
 	u64 alloc_hint = 0;
 	int ret;
@@ -492,7 +493,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	/* Just to make sure we have enough space */
 	prealloc += 8 * PAGE_SIZE;
 
-	ret = btrfs_delalloc_reserve_space(inode, 0, prealloc);
+	ret = btrfs_delalloc_reserve_space(inode, &data_reserved, 0, prealloc);
 	if (ret)
 		goto out_put;
 
@@ -516,6 +517,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	trans->bytes_reserved = num_bytes;
 
 	btrfs_free_path(path);
+	extent_changeset_free(data_reserved);
 	return ret;
 }
 

commit 691fa059673b3b33c25d7925acb0a58e8204dbd6
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Mon Feb 20 13:50:42 2017 +0200

    btrfs: all btrfs_delalloc_release_metadata take btrfs_inode
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 3bbb8f095953..5c6c20ec64d8 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -499,7 +499,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	ret = btrfs_prealloc_file_range_trans(inode, trans, 0, 0, prealloc,
 					      prealloc, prealloc, &alloc_hint);
 	if (ret) {
-		btrfs_delalloc_release_metadata(inode, prealloc);
+		btrfs_delalloc_release_metadata(BTRFS_I(inode), prealloc);
 		goto out_put;
 	}
 

commit 77ab86bf1c64ab282f2230521c7d4d7f69ea3a3f
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Feb 15 16:28:30 2017 -0500

    btrfs: free-space-cache, clean up unnecessary root arguments
    
    The free space cache APIs accept a root but always use the tree root.
    
    Also, btrfs_truncate_free_space_cache accepts a root AND an inode but
    the inode always points to the root anyway, so let's just pass the inode.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 144b119ff43f..3bbb8f095953 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -467,7 +467,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	}
 
 	if (i_size_read(inode) > 0) {
-		ret = btrfs_truncate_free_space_cache(root, trans, NULL, inode);
+		ret = btrfs_truncate_free_space_cache(trans, NULL, inode);
 		if (ret) {
 			if (ret != -ENOSPC)
 				btrfs_abort_transaction(trans, ret);

commit 2ff7e61e0d30ff166a2ae94575526bffe11fd1a8
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jun 22 18:54:24 2016 -0400

    btrfs: take an fs_info directly when the root is not used otherwise
    
    There are loads of functions in btrfs that accept a root parameter
    but only use it to obtain an fs_info pointer.  Let's convert those to
    just accept an fs_info pointer directly.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 79921f6fb8e5..144b119ff43f 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -509,7 +509,8 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 out_release:
 	trace_btrfs_space_reservation(fs_info, "ino_cache", trans->transid,
 				      trans->bytes_reserved, 0);
-	btrfs_block_rsv_release(root, trans->block_rsv, trans->bytes_reserved);
+	btrfs_block_rsv_release(fs_info, trans->block_rsv,
+				trans->bytes_reserved);
 out:
 	trans->block_rsv = rsv;
 	trans->bytes_reserved = num_bytes;

commit 0b246afa62b0cf5b09d078121f543135f28492ad
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jun 22 18:54:23 2016 -0400

    btrfs: root->fs_info cleanup, add fs_info convenience variables
    
    In routines where someptr->fs_info is referenced multiple times, we
    introduce a convenience variable.  This makes the code considerably
    more readable.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 0c4926728b6a..79921f6fb8e5 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -38,7 +38,7 @@ static int caching_kthread(void *data)
 	int slot;
 	int ret;
 
-	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(fs_info, INODE_MAP_CACHE))
 		return 0;
 
 	path = btrfs_alloc_path();
@@ -180,7 +180,7 @@ static void start_caching(struct btrfs_root *root)
 	if (IS_ERR(tsk)) {
 		btrfs_warn(fs_info, "failed to start inode caching task");
 		btrfs_clear_pending_and_info(fs_info, INODE_MAP_CACHE,
-				"disabling inode map caching");
+					     "disabling inode map caching");
 	}
 }
 
@@ -395,6 +395,7 @@ void btrfs_init_free_ino_ctl(struct btrfs_root *root)
 int btrfs_save_ino_cache(struct btrfs_root *root,
 			 struct btrfs_trans_handle *trans)
 {
+	struct btrfs_fs_info *fs_info = root->fs_info;
 	struct btrfs_free_space_ctl *ctl = root->free_ino_ctl;
 	struct btrfs_path *path;
 	struct inode *inode;
@@ -415,7 +416,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	if (btrfs_root_refs(&root->root_item) == 0)
 		return 0;
 
-	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(fs_info, INODE_MAP_CACHE))
 		return 0;
 
 	path = btrfs_alloc_path();
@@ -423,7 +424,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 		return -ENOMEM;
 
 	rsv = trans->block_rsv;
-	trans->block_rsv = &root->fs_info->trans_block_rsv;
+	trans->block_rsv = &fs_info->trans_block_rsv;
 
 	num_bytes = trans->bytes_reserved;
 	/*
@@ -433,15 +434,14 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	 * 1 item for free space object
 	 * 3 items for pre-allocation
 	 */
-	trans->bytes_reserved = btrfs_calc_trans_metadata_size(root->fs_info,
-							       10);
+	trans->bytes_reserved = btrfs_calc_trans_metadata_size(fs_info, 10);
 	ret = btrfs_block_rsv_add(root, trans->block_rsv,
 				  trans->bytes_reserved,
 				  BTRFS_RESERVE_NO_FLUSH);
 	if (ret)
 		goto out;
-	trace_btrfs_space_reservation(root->fs_info, "ino_cache",
-				      trans->transid, trans->bytes_reserved, 1);
+	trace_btrfs_space_reservation(fs_info, "ino_cache", trans->transid,
+				      trans->bytes_reserved, 1);
 again:
 	inode = lookup_free_ino_inode(root, path);
 	if (IS_ERR(inode) && (PTR_ERR(inode) != -ENOENT || retry)) {
@@ -507,8 +507,8 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 out_put:
 	iput(inode);
 out_release:
-	trace_btrfs_space_reservation(root->fs_info, "ino_cache",
-				      trans->transid, trans->bytes_reserved, 0);
+	trace_btrfs_space_reservation(fs_info, "ino_cache", trans->transid,
+				      trans->bytes_reserved, 0);
 	btrfs_block_rsv_release(root, trans->block_rsv, trans->bytes_reserved);
 out:
 	trans->block_rsv = rsv;

commit 27965b6c2cad220f6c512334665808bf3d895e5e
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Jun 16 11:07:27 2016 -0400

    btrfs: root->fs_info cleanup, btrfs_calc_{trans,trunc}_metadata_size
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index d27014b8bf72..0c4926728b6a 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -433,7 +433,8 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	 * 1 item for free space object
 	 * 3 items for pre-allocation
 	 */
-	trans->bytes_reserved = btrfs_calc_trans_metadata_size(root, 10);
+	trans->bytes_reserved = btrfs_calc_trans_metadata_size(root->fs_info,
+							       10);
 	ret = btrfs_block_rsv_add(root, trans->block_rsv,
 				  trans->bytes_reserved,
 				  BTRFS_RESERVE_NO_FLUSH);

commit ab8d0fc48dba09e0a2b8b0dbfe144d4de9eb874f
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Tue Sep 20 10:05:02 2016 -0400

    btrfs: convert pr_* to btrfs_* where possible
    
    For many printks, we want to know which file system issued the message.
    
    This patch converts most pr_* calls to use the btrfs_* versions instead.
    In some cases, this means adding plumbing to allow call sites access to
    an fs_info pointer.
    
    fs/btrfs/check-integrity.c is left alone for another day.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 359ee861b5a4..d27014b8bf72 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -104,7 +104,7 @@ static int caching_kthread(void *data)
 			break;
 
 		if (last != (u64)-1 && last + 1 != key.objectid) {
-			__btrfs_add_free_space(ctl, last + 1,
+			__btrfs_add_free_space(fs_info, ctl, last + 1,
 					       key.objectid - last - 1);
 			wake_up(&root->ino_cache_wait);
 		}
@@ -115,7 +115,7 @@ static int caching_kthread(void *data)
 	}
 
 	if (last < root->highest_objectid - 1) {
-		__btrfs_add_free_space(ctl, last + 1,
+		__btrfs_add_free_space(fs_info, ctl, last + 1,
 				       root->highest_objectid - last - 1);
 	}
 
@@ -136,12 +136,13 @@ static int caching_kthread(void *data)
 
 static void start_caching(struct btrfs_root *root)
 {
+	struct btrfs_fs_info *fs_info = root->fs_info;
 	struct btrfs_free_space_ctl *ctl = root->free_ino_ctl;
 	struct task_struct *tsk;
 	int ret;
 	u64 objectid;
 
-	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(fs_info, INODE_MAP_CACHE))
 		return;
 
 	spin_lock(&root->ino_cache_lock);
@@ -153,7 +154,7 @@ static void start_caching(struct btrfs_root *root)
 	root->ino_cache_state = BTRFS_CACHE_STARTED;
 	spin_unlock(&root->ino_cache_lock);
 
-	ret = load_free_ino_cache(root->fs_info, root);
+	ret = load_free_ino_cache(fs_info, root);
 	if (ret == 1) {
 		spin_lock(&root->ino_cache_lock);
 		root->ino_cache_state = BTRFS_CACHE_FINISHED;
@@ -170,15 +171,15 @@ static void start_caching(struct btrfs_root *root)
 	 */
 	ret = btrfs_find_free_objectid(root, &objectid);
 	if (!ret && objectid <= BTRFS_LAST_FREE_OBJECTID) {
-		__btrfs_add_free_space(ctl, objectid,
+		__btrfs_add_free_space(fs_info, ctl, objectid,
 				       BTRFS_LAST_FREE_OBJECTID - objectid + 1);
 	}
 
 	tsk = kthread_run(caching_kthread, root, "btrfs-ino-cache-%llu",
 			  root->root_key.objectid);
 	if (IS_ERR(tsk)) {
-		btrfs_warn(root->fs_info, "failed to start inode caching task");
-		btrfs_clear_pending_and_info(root->fs_info, INODE_MAP_CACHE,
+		btrfs_warn(fs_info, "failed to start inode caching task");
+		btrfs_clear_pending_and_info(fs_info, INODE_MAP_CACHE,
 				"disabling inode map caching");
 	}
 }
@@ -209,28 +210,29 @@ int btrfs_find_free_ino(struct btrfs_root *root, u64 *objectid)
 
 void btrfs_return_ino(struct btrfs_root *root, u64 objectid)
 {
+	struct btrfs_fs_info *fs_info = root->fs_info;
 	struct btrfs_free_space_ctl *pinned = root->free_ino_pinned;
 
-	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(fs_info, INODE_MAP_CACHE))
 		return;
 again:
 	if (root->ino_cache_state == BTRFS_CACHE_FINISHED) {
-		__btrfs_add_free_space(pinned, objectid, 1);
+		__btrfs_add_free_space(fs_info, pinned, objectid, 1);
 	} else {
-		down_write(&root->fs_info->commit_root_sem);
+		down_write(&fs_info->commit_root_sem);
 		spin_lock(&root->ino_cache_lock);
 		if (root->ino_cache_state == BTRFS_CACHE_FINISHED) {
 			spin_unlock(&root->ino_cache_lock);
-			up_write(&root->fs_info->commit_root_sem);
+			up_write(&fs_info->commit_root_sem);
 			goto again;
 		}
 		spin_unlock(&root->ino_cache_lock);
 
 		start_caching(root);
 
-		__btrfs_add_free_space(pinned, objectid, 1);
+		__btrfs_add_free_space(fs_info, pinned, objectid, 1);
 
-		up_write(&root->fs_info->commit_root_sem);
+		up_write(&fs_info->commit_root_sem);
 	}
 }
 
@@ -277,7 +279,8 @@ void btrfs_unpin_free_ino(struct btrfs_root *root)
 		rb_erase(&info->offset_index, rbroot);
 		spin_unlock(rbroot_lock);
 		if (add_to_ctl)
-			__btrfs_add_free_space(ctl, info->offset, count);
+			__btrfs_add_free_space(root->fs_info, ctl,
+					       info->offset, count);
 		kmem_cache_free(btrfs_free_space_cachep, info);
 	}
 }

commit 18513091af9483ba84328d42092bd4d42a3c958f
Author: Wang Xiaoguang <wangxg.fnst@cn.fujitsu.com>
Date:   Mon Jul 25 15:51:40 2016 +0800

    btrfs: update btrfs_space_info's bytes_may_use timely
    
    This patch can fix some false ENOSPC errors, below test script can
    reproduce one false ENOSPC error:
            #!/bin/bash
            dd if=/dev/zero of=fs.img bs=$((1024*1024)) count=128
            dev=$(losetup --show -f fs.img)
            mkfs.btrfs -f -M $dev
            mkdir /tmp/mntpoint
            mount $dev /tmp/mntpoint
            cd /tmp/mntpoint
            xfs_io -f -c "falloc 0 $((64*1024*1024))" testfile
    
    Above script will fail for ENOSPC reason, but indeed fs still has free
    space to satisfy this request. Please see call graph:
    btrfs_fallocate()
    |-> btrfs_alloc_data_chunk_ondemand()
    |   bytes_may_use += 64M
    |-> btrfs_prealloc_file_range()
        |-> btrfs_reserve_extent()
            |-> btrfs_add_reserved_bytes()
            |   alloc_type is RESERVE_ALLOC_NO_ACCOUNT, so it does not
            |   change bytes_may_use, and bytes_reserved += 64M. Now
            |   bytes_may_use + bytes_reserved == 128M, which is greater
            |   than btrfs_space_info's total_bytes, false enospc occurs.
            |   Note, the bytes_may_use decrease operation will be done in
            |   end of btrfs_fallocate(), which is too late.
    
    Here is another simple case for buffered write:
                        CPU 1              |              CPU 2
                                           |
    |-> cow_file_range()                   |-> __btrfs_buffered_write()
        |-> btrfs_reserve_extent()         |   |
        |                                  |   |
        |                                  |   |
        |    .....                         |   |-> btrfs_check_data_free_space()
        |                                  |
        |                                  |
        |-> extent_clear_unlock_delalloc() |
    
    In CPU 1, btrfs_reserve_extent()->find_free_extent()->
    btrfs_add_reserved_bytes() do not decrease bytes_may_use, the decrease
    operation will be delayed to be done in extent_clear_unlock_delalloc().
    Assume in this case, btrfs_reserve_extent() reserved 128MB data, CPU2's
    btrfs_check_data_free_space() tries to reserve 100MB data space.
    If
            100MB > data_sinfo->total_bytes - data_sinfo->bytes_used -
                    data_sinfo->bytes_reserved - data_sinfo->bytes_pinned -
                    data_sinfo->bytes_readonly - data_sinfo->bytes_may_use
    btrfs_check_data_free_space() will try to allcate new data chunk or call
    btrfs_start_delalloc_roots(), or commit current transaction in order to
    reserve some free space, obviously a lot of work. But indeed it's not
    necessary as long as decreasing bytes_may_use timely, we still have
    free space, decreasing 128M from bytes_may_use.
    
    To fix this issue, this patch chooses to update bytes_may_use for both
    data and metadata in btrfs_add_reserved_bytes(). For compress path, real
    extent length may not be equal to file content length, so introduce a
    ram_bytes argument for btrfs_reserve_extent(), find_free_extent() and
    btrfs_add_reserved_bytes(), it's becasue bytes_may_use is increased by
    file content length. Then compress path can update bytes_may_use
    correctly. Also now we can discard RESERVE_ALLOC_NO_ACCOUNT, RESERVE_ALLOC
    and RESERVE_FREE.
    
    As we know, usually EXTENT_DO_ACCOUNTING is used for error path. In
    run_delalloc_nocow(), for inode marked as NODATACOW or extent marked as
    PREALLOC, we also need to update bytes_may_use, but can not pass
    EXTENT_DO_ACCOUNTING, because it also clears metadata reservation, so
    here we introduce EXTENT_CLEAR_DATA_RESV flag to indicate btrfs_clear_bit_hook()
    to update btrfs_space_info's bytes_may_use.
    
    Meanwhile __btrfs_prealloc_file_range() will call
    btrfs_free_reserved_data_space() internally for both sucessful and failed
    path, btrfs_prealloc_file_range()'s callers does not need to call
    btrfs_free_reserved_data_space() any more.
    
    Signed-off-by: Wang Xiaoguang <wangxg.fnst@cn.fujitsu.com>
    Reviewed-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index aa6fabaee72e..359ee861b5a4 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -495,10 +495,9 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	ret = btrfs_prealloc_file_range_trans(inode, trans, 0, 0, prealloc,
 					      prealloc, prealloc, &alloc_hint);
 	if (ret) {
-		btrfs_delalloc_release_space(inode, 0, prealloc);
+		btrfs_delalloc_release_metadata(inode, prealloc);
 		goto out_put;
 	}
-	btrfs_free_reserved_data_space(inode, 0, prealloc);
 
 	ret = btrfs_write_out_ino_cache(root, trans, path, inode);
 out_put:

commit 66642832f06a4351e23cea6cf254967c227f8224
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Jun 10 18:19:25 2016 -0400

    btrfs: btrfs_abort_transaction, drop root parameter
    
    __btrfs_abort_transaction doesn't use its root parameter except to
    obtain an fs_info pointer.  We can obtain that from trans->root->fs_info
    for now and from trans->fs_info in a later patch.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index e3ad8c197997..aa6fabaee72e 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -458,7 +458,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	BTRFS_I(inode)->generation = 0;
 	ret = btrfs_update_inode(trans, root, inode);
 	if (ret) {
-		btrfs_abort_transaction(trans, root, ret);
+		btrfs_abort_transaction(trans, ret);
 		goto out_put;
 	}
 
@@ -466,7 +466,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 		ret = btrfs_truncate_free_space_cache(root, trans, NULL, inode);
 		if (ret) {
 			if (ret != -ENOSPC)
-				btrfs_abort_transaction(trans, root, ret);
+				btrfs_abort_transaction(trans, ret);
 			goto out_put;
 		}
 	}

commit 3cdde2240d4533ff71fbb8dc9c32d5d57d3cdeed
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Jun 9 21:38:35 2016 -0400

    btrfs: btrfs_test_opt and friends should take a btrfs_fs_info
    
    btrfs_test_opt and friends only use the root pointer to access
    the fs_info.  Let's pass the fs_info directly in preparation to
    eliminate similar patterns all over btrfs.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 70107f7c9307..e3ad8c197997 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -38,7 +38,7 @@ static int caching_kthread(void *data)
 	int slot;
 	int ret;
 
-	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
 		return 0;
 
 	path = btrfs_alloc_path();
@@ -141,7 +141,7 @@ static void start_caching(struct btrfs_root *root)
 	int ret;
 	u64 objectid;
 
-	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
 		return;
 
 	spin_lock(&root->ino_cache_lock);
@@ -185,7 +185,7 @@ static void start_caching(struct btrfs_root *root)
 
 int btrfs_find_free_ino(struct btrfs_root *root, u64 *objectid)
 {
-	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
 		return btrfs_find_free_objectid(root, objectid);
 
 again:
@@ -211,7 +211,7 @@ void btrfs_return_ino(struct btrfs_root *root, u64 objectid)
 {
 	struct btrfs_free_space_ctl *pinned = root->free_ino_pinned;
 
-	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
 		return;
 again:
 	if (root->ino_cache_state == BTRFS_CACHE_FINISHED) {
@@ -251,7 +251,7 @@ void btrfs_unpin_free_ino(struct btrfs_root *root)
 	struct rb_node *n;
 	u64 count;
 
-	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
 		return;
 
 	while (1) {
@@ -412,7 +412,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	if (btrfs_root_refs(&root->root_item) == 0)
 		return 0;
 
-	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
 		return 0;
 
 	path = btrfs_alloc_path();

commit 09cbfeaf1a5a67bfb3201e0c83c810cecb2efa5a
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Fri Apr 1 15:29:47 2016 +0300

    mm, fs: get rid of PAGE_CACHE_* and page_cache_{get,release} macros
    
    PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} macros were introduced *long* time
    ago with promise that one day it will be possible to implement page
    cache with bigger chunks than PAGE_SIZE.
    
    This promise never materialized.  And unlikely will.
    
    We have many places where PAGE_CACHE_SIZE assumed to be equal to
    PAGE_SIZE.  And it's constant source of confusion on whether
    PAGE_CACHE_* or PAGE_* constant should be used in a particular case,
    especially on the border between fs and mm.
    
    Global switching to PAGE_CACHE_SIZE != PAGE_SIZE would cause to much
    breakage to be doable.
    
    Let's stop pretending that pages in page cache are special.  They are
    not.
    
    The changes are pretty straight-forward:
    
     - <foo> << (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - <foo> >> (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} -> PAGE_{SIZE,SHIFT,MASK,ALIGN};
    
     - page_cache_get() -> get_page();
    
     - page_cache_release() -> put_page();
    
    This patch contains automated changes generated with coccinelle using
    script below.  For some reason, coccinelle doesn't patch header files.
    I've called spatch for them manually.
    
    The only adjustment after coccinelle is revert of changes to
    PAGE_CAHCE_ALIGN definition: we are going to drop it later.
    
    There are few places in the code where coccinelle didn't reach.  I'll
    fix them manually in a separate patch.  Comments and documentation also
    will be addressed with the separate patch.
    
    virtual patch
    
    @@
    expression E;
    @@
    - E << (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    expression E;
    @@
    - E >> (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    @@
    - PAGE_CACHE_SHIFT
    + PAGE_SHIFT
    
    @@
    @@
    - PAGE_CACHE_SIZE
    + PAGE_SIZE
    
    @@
    @@
    - PAGE_CACHE_MASK
    + PAGE_MASK
    
    @@
    expression E;
    @@
    - PAGE_CACHE_ALIGN(E)
    + PAGE_ALIGN(E)
    
    @@
    expression E;
    @@
    - page_cache_get(E)
    + get_page(E)
    
    @@
    expression E;
    @@
    - page_cache_release(E)
    + put_page(E)
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 1f0ec19b23f6..70107f7c9307 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -283,7 +283,7 @@ void btrfs_unpin_free_ino(struct btrfs_root *root)
 }
 
 #define INIT_THRESHOLD	((SZ_32K / 2) / sizeof(struct btrfs_free_space))
-#define INODES_PER_BITMAP (PAGE_CACHE_SIZE * 8)
+#define INODES_PER_BITMAP (PAGE_SIZE * 8)
 
 /*
  * The goal is to keep the memory used by the free_ino tree won't
@@ -317,7 +317,7 @@ static void recalculate_thresholds(struct btrfs_free_space_ctl *ctl)
 	}
 
 	ctl->extents_thresh = (max_bitmaps - ctl->total_bitmaps) *
-				PAGE_CACHE_SIZE / sizeof(*info);
+				PAGE_SIZE / sizeof(*info);
 }
 
 /*
@@ -481,12 +481,12 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 
 	spin_lock(&ctl->tree_lock);
 	prealloc = sizeof(struct btrfs_free_space) * ctl->free_extents;
-	prealloc = ALIGN(prealloc, PAGE_CACHE_SIZE);
-	prealloc += ctl->total_bitmaps * PAGE_CACHE_SIZE;
+	prealloc = ALIGN(prealloc, PAGE_SIZE);
+	prealloc += ctl->total_bitmaps * PAGE_SIZE;
 	spin_unlock(&ctl->tree_lock);
 
 	/* Just to make sure we have enough space */
-	prealloc += 8 * PAGE_CACHE_SIZE;
+	prealloc += 8 * PAGE_SIZE;
 
 	ret = btrfs_delalloc_reserve_space(inode, 0, prealloc);
 	if (ret)

commit 3c1d84b71ebee2757b6c8691494a5716a7806bfa
Author: Satoru Takeuchi <takeuchi_satoru@jp.fujitsu.com>
Date:   Wed Mar 9 15:18:57 2016 +0900

    Btrfs: Show a warning message if one of objectid reaches its highest value
    
    It's better to show a warning message for the exceptional case
    that one of objectid (in most case, inode number) reaches its
    highest value. For example, if inode cache is off and this event
    happens, we can't create any file even if there are not so many files.
    This message ease detecting such problem.
    
    Signed-off-by: Satoru Takeuchi <takeuchi_satoru@jp.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index e50316c4af15..1f0ec19b23f6 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -556,6 +556,9 @@ int btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)
 	mutex_lock(&root->objectid_mutex);
 
 	if (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {
+		btrfs_warn(root->fs_info,
+			   "the objectid of root %llu reaches its highest value",
+			   root->root_key.objectid);
 		ret = -ENOSPC;
 		goto out;
 	}

commit 326f784281fbbdcd91bb401b2a3e32132c0f5c72
Merge: acc308556c81 546bed631203
Author: Chris Mason <clm@fb.com>
Date:   Tue Jan 19 18:21:30 2016 -0800

    Merge branch 'misc-for-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux into for-linus-4.5

commit f32e48e925964c4f8ab917850788a87e1cef3bad
Author: Chandan Rajendra <chandan@linux.vnet.ibm.com>
Date:   Thu Jan 7 18:56:59 2016 +0530

    Btrfs: Initialize btrfs_root->highest_objectid when loading tree root and subvolume roots
    
    The following call trace is seen when btrfs/031 test is executed in a loop,
    
    [  158.661848] ------------[ cut here ]------------
    [  158.662634] WARNING: CPU: 2 PID: 890 at /home/chandan/repos/linux/fs/btrfs/ioctl.c:558 create_subvol+0x3d1/0x6ea()
    [  158.664102] BTRFS: Transaction aborted (error -2)
    [  158.664774] Modules linked in:
    [  158.665266] CPU: 2 PID: 890 Comm: btrfs Not tainted 4.4.0-rc6-g511711a #2
    [  158.666251] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
    [  158.667392]  ffffffff81c0a6b0 ffff8806c7c4f8e8 ffffffff81431fc8 ffff8806c7c4f930
    [  158.668515]  ffff8806c7c4f920 ffffffff81051aa1 ffff880c85aff000 ffff8800bb44d000
    [  158.669647]  ffff8808863b5c98 0000000000000000 00000000fffffffe ffff8806c7c4f980
    [  158.670769] Call Trace:
    [  158.671153]  [<ffffffff81431fc8>] dump_stack+0x44/0x5c
    [  158.671884]  [<ffffffff81051aa1>] warn_slowpath_common+0x81/0xc0
    [  158.672769]  [<ffffffff81051b27>] warn_slowpath_fmt+0x47/0x50
    [  158.673620]  [<ffffffff813bc98d>] create_subvol+0x3d1/0x6ea
    [  158.674440]  [<ffffffff813777c9>] btrfs_mksubvol.isra.30+0x369/0x520
    [  158.675376]  [<ffffffff8108a4aa>] ? percpu_down_read+0x1a/0x50
    [  158.676235]  [<ffffffff81377a81>] btrfs_ioctl_snap_create_transid+0x101/0x180
    [  158.677268]  [<ffffffff81377b52>] btrfs_ioctl_snap_create+0x52/0x70
    [  158.678183]  [<ffffffff8137afb4>] btrfs_ioctl+0x474/0x2f90
    [  158.678975]  [<ffffffff81144b8e>] ? vma_merge+0xee/0x300
    [  158.679751]  [<ffffffff8115be31>] ? alloc_pages_vma+0x91/0x170
    [  158.680599]  [<ffffffff81123f62>] ? lru_cache_add_active_or_unevictable+0x22/0x70
    [  158.681686]  [<ffffffff813d99cf>] ? selinux_file_ioctl+0xff/0x1d0
    [  158.682581]  [<ffffffff8117b791>] do_vfs_ioctl+0x2c1/0x490
    [  158.683399]  [<ffffffff813d3cde>] ? security_file_ioctl+0x3e/0x60
    [  158.684297]  [<ffffffff8117b9d4>] SyS_ioctl+0x74/0x80
    [  158.685051]  [<ffffffff819b2bd7>] entry_SYSCALL_64_fastpath+0x12/0x6a
    [  158.685958] ---[ end trace 4b63312de5a2cb76 ]---
    [  158.686647] BTRFS: error (device loop0) in create_subvol:558: errno=-2 No such entry
    [  158.709508] BTRFS info (device loop0): forced readonly
    [  158.737113] BTRFS info (device loop0): disk space caching is enabled
    [  158.738096] BTRFS error (device loop0): Remounting read-write after error is not allowed
    [  158.851303] BTRFS error (device loop0): cleaner transaction attach returned -30
    
    This occurs because,
    
    Mount filesystem
    Create subvol with ID 257
    Unmount filesystem
    Mount filesystem
    Delete subvol with ID 257
      btrfs_drop_snapshot()
        Add root corresponding to subvol 257 into
        btrfs_transaction->dropped_roots list
    Create new subvol (i.e. create_subvol())
      257 is returned as the next free objectid
      btrfs_read_fs_root_no_name()
        Finds the btrfs_root instance corresponding to the old subvol with ID 257
        in btrfs_fs_info->fs_roots_radix.
        Returns error since btrfs_root_item->refs has the value of 0.
    
    To fix the issue the commit initializes tree root's and subvolume root's
    highest_objectid when loading the roots from disk.
    
    Signed-off-by: Chandan Rajendra <chandan@linux.vnet.ibm.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 1951ad69382f..29e23a57d6f3 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -515,7 +515,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	return ret;
 }
 
-static int btrfs_find_highest_objectid(struct btrfs_root *root, u64 *objectid)
+int btrfs_find_highest_objectid(struct btrfs_root *root, u64 *objectid)
 {
 	struct btrfs_path *path;
 	int ret;
@@ -555,13 +555,6 @@ int btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)
 	int ret;
 	mutex_lock(&root->objectid_mutex);
 
-	if (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {
-		ret = btrfs_find_highest_objectid(root,
-						  &root->highest_objectid);
-		if (ret)
-			goto out;
-	}
-
 	if (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {
 		ret = -ENOSPC;
 		goto out;

commit b28cf57246d5b797ba725bb033110c247f2c301f
Merge: a3058101c17d a7ca42256d9f
Author: Chris Mason <clm@fb.com>
Date:   Mon Jan 11 06:08:37 2016 -0800

    Merge branch 'misc-cleanups-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux into for-linus-4.5
    
    Signed-off-by: Chris Mason <clm@fb.com>

commit e4058b54d1e442b6b3eca949f0d63d49ba2b020d
Author: David Sterba <dsterba@suse.com>
Date:   Fri Nov 27 16:31:35 2015 +0100

    btrfs: cleanup, use enum values for btrfs_path reada
    
    Replace the integers by enums for better readability. The value 2 does
    not have any meaning since a717531942f488209dded30f6bc648167bcefa72
    "Btrfs: do less aggressive btree readahead" (2009-01-22).
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 53014e963617..1951ad69382f 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -48,7 +48,7 @@ static int caching_kthread(void *data)
 	/* Since the commit root is read-only, we can safely skip locking. */
 	path->skip_locking = 1;
 	path->search_commit_root = 1;
-	path->reada = 2;
+	path->reada = READA_FORWARD;
 
 	key.objectid = BTRFS_FIRST_FREE_OBJECTID;
 	key.offset = 0;

commit 20e5506baf3fd651e245bc970d8c11a734ee1b8a
Author: David Sterba <dsterba@suse.com>
Date:   Thu Nov 19 11:42:28 2015 +0100

    btrfs: constify remaining structs with function pointers
    
    * struct extent_io_ops
    * struct btrfs_free_space_op
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 767a6056ac45..53014e963617 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -334,7 +334,7 @@ static bool use_bitmap(struct btrfs_free_space_ctl *ctl,
 	return true;
 }
 
-static struct btrfs_free_space_op free_ino_op = {
+static const struct btrfs_free_space_op free_ino_op = {
 	.recalc_thresholds	= recalculate_thresholds,
 	.use_bitmap		= use_bitmap,
 };
@@ -356,7 +356,7 @@ static bool pinned_use_bitmap(struct btrfs_free_space_ctl *ctl,
 	return false;
 }
 
-static struct btrfs_free_space_op pinned_free_ino_op = {
+static const struct btrfs_free_space_op pinned_free_ino_op = {
 	.recalc_thresholds	= pinned_recalc_thresholds,
 	.use_bitmap		= pinned_use_bitmap,
 };

commit ee22184b53c823f6956314c2815d4068e3820737
Author: Byongho Lee <bhlee.kernel@gmail.com>
Date:   Tue Dec 15 01:42:10 2015 +0900

    Btrfs: use linux/sizes.h to represent constants
    
    We use many constants to represent size and offset value.  And to make
    code readable we use '256 * 1024 * 1024' instead of '268435456' to
    represent '256MB'.  However we can make far more readable with 'SZ_256MB'
    which is defined in the 'linux/sizes.h'.
    
    So this patch replaces 'xxx * 1024 * 1024' kind of expression with
    single 'SZ_xxxMB' if 'xxx' is a power of 2 then 'xxx * SZ_1M' if 'xxx' is
    not a power of 2. And I haven't touched to '4096' & '8192' because it's
    more intuitive than 'SZ_4KB' & 'SZ_8KB'.
    
    Signed-off-by: Byongho Lee <bhlee.kernel@gmail.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 767a6056ac45..e5eb40cb2d53 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -282,7 +282,7 @@ void btrfs_unpin_free_ino(struct btrfs_root *root)
 	}
 }
 
-#define INIT_THRESHOLD	(((1024 * 32) / 2) / sizeof(struct btrfs_free_space))
+#define INIT_THRESHOLD	((SZ_32K / 2) / sizeof(struct btrfs_free_space))
 #define INODES_PER_BITMAP (PAGE_CACHE_SIZE * 8)
 
 /*

commit 7cf5b97650f2ecefbd5afa2d58b61b289b6e3750
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Tue Sep 8 17:25:55 2015 +0800

    btrfs: qgroup: Cleanup old inaccurate facilities
    
    Cleanup the old facilities which use old btrfs_qgroup_reserve() function
    call, replace them with the newer version, and remove the "__" prefix in
    them.
    
    Also, make btrfs_qgroup_reserve/free() functions private, as they are
    now only used inside qgroup codes.
    
    Now, the whole btrfs qgroup is swithed to use the new reserve facilities.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 78bc09c552ab..767a6056ac45 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -488,17 +488,17 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	/* Just to make sure we have enough space */
 	prealloc += 8 * PAGE_CACHE_SIZE;
 
-	ret = __btrfs_delalloc_reserve_space(inode, 0, prealloc);
+	ret = btrfs_delalloc_reserve_space(inode, 0, prealloc);
 	if (ret)
 		goto out_put;
 
 	ret = btrfs_prealloc_file_range_trans(inode, trans, 0, 0, prealloc,
 					      prealloc, prealloc, &alloc_hint);
 	if (ret) {
-		__btrfs_delalloc_release_space(inode, 0, prealloc);
+		btrfs_delalloc_release_space(inode, 0, prealloc);
 		goto out_put;
 	}
-	__btrfs_free_reserved_data_space(inode, 0, prealloc);
+	btrfs_free_reserved_data_space(inode, 0, prealloc);
 
 	ret = btrfs_write_out_ino_cache(root, trans, path, inode);
 out_put:

commit df480633b891cf03301d87e56024a8ec3251da5b
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Tue Sep 8 17:25:54 2015 +0800

    btrfs: extent-tree: Switch to new delalloc space reserve and release
    
    Use new __btrfs_delalloc_reserve_space() and
    __btrfs_delalloc_release_space() to reserve and release space for
    delalloc.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index d4a582ac3f73..78bc09c552ab 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -488,17 +488,17 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	/* Just to make sure we have enough space */
 	prealloc += 8 * PAGE_CACHE_SIZE;
 
-	ret = btrfs_delalloc_reserve_space(inode, prealloc);
+	ret = __btrfs_delalloc_reserve_space(inode, 0, prealloc);
 	if (ret)
 		goto out_put;
 
 	ret = btrfs_prealloc_file_range_trans(inode, trans, 0, 0, prealloc,
 					      prealloc, prealloc, &alloc_hint);
 	if (ret) {
-		btrfs_delalloc_release_space(inode, prealloc);
+		__btrfs_delalloc_release_space(inode, 0, prealloc);
 		goto out_put;
 	}
-	btrfs_free_reserved_data_space(inode, prealloc);
+	__btrfs_free_reserved_data_space(inode, 0, prealloc);
 
 	ret = btrfs_write_out_ino_cache(root, trans, path, inode);
 out_put:

commit ae9d8f17118551bedd797406a6768b87c2146234
Author: Filipe Manana <fdmanana@suse.com>
Date:   Sat Jun 13 06:52:57 2015 +0100

    Btrfs: fix race between caching kthread and returning inode to inode cache
    
    While the inode cache caching kthread is calling btrfs_unpin_free_ino(),
    we could have a concurrent call to btrfs_return_ino() that adds a new
    entry to the root's free space cache of pinned inodes. This concurrent
    call does not acquire the fs_info->commit_root_sem before adding a new
    entry if the caching state is BTRFS_CACHE_FINISHED, which is a problem
    because the caching kthread calls btrfs_unpin_free_ino() after setting
    the caching state to BTRFS_CACHE_FINISHED and therefore races with
    the task calling btrfs_return_ino(), which is adding a new entry, while
    the former (caching kthread) is navigating the cache's rbtree, removing
    and freeing nodes from the cache's rbtree without acquiring the spinlock
    that protects the rbtree.
    
    This race resulted in memory corruption due to double free of struct
    btrfs_free_space objects because both tasks can end up doing freeing the
    same objects. Note that adding a new entry can result in merging it with
    other entries in the cache, in which case those entries are freed.
    This is particularly important as btrfs_free_space structures are also
    used for the block group free space caches.
    
    This memory corruption can be detected by a debugging kernel, which
    reports it with the following trace:
    
    [132408.501148] slab error in verify_redzone_free(): cache `btrfs_free_space': double free detected
    [132408.505075] CPU: 15 PID: 12248 Comm: btrfs-ino-cache Tainted: G        W       4.1.0-rc5-btrfs-next-10+ #1
    [132408.505075] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.8.1-0-g4adadbd-20150316_085822-nilsson.home.kraxel.org 04/01/2014
    [132408.505075]  ffff880023e7d320 ffff880163d73cd8 ffffffff8145eec7 ffffffff81095dce
    [132408.505075]  ffff880009735d40 ffff880163d73ce8 ffffffff81154e1e ffff880163d73d68
    [132408.505075]  ffffffff81155733 ffffffffa054a95a ffff8801b6099f00 ffffffffa0505b5f
    [132408.505075] Call Trace:
    [132408.505075]  [<ffffffff8145eec7>] dump_stack+0x4f/0x7b
    [132408.505075]  [<ffffffff81095dce>] ? console_unlock+0x356/0x3a2
    [132408.505075]  [<ffffffff81154e1e>] __slab_error.isra.28+0x25/0x36
    [132408.505075]  [<ffffffff81155733>] __cache_free+0xe2/0x4b6
    [132408.505075]  [<ffffffffa054a95a>] ? __btrfs_add_free_space+0x2f0/0x343 [btrfs]
    [132408.505075]  [<ffffffffa0505b5f>] ? btrfs_unpin_free_ino+0x8e/0x99 [btrfs]
    [132408.505075]  [<ffffffff810f3b30>] ? time_hardirqs_off+0x15/0x28
    [132408.505075]  [<ffffffff81084d42>] ? trace_hardirqs_off+0xd/0xf
    [132408.505075]  [<ffffffff811563a1>] ? kfree+0xb6/0x14e
    [132408.505075]  [<ffffffff811563d0>] kfree+0xe5/0x14e
    [132408.505075]  [<ffffffffa0505b5f>] btrfs_unpin_free_ino+0x8e/0x99 [btrfs]
    [132408.505075]  [<ffffffffa0505e08>] caching_kthread+0x29e/0x2d9 [btrfs]
    [132408.505075]  [<ffffffffa0505b6a>] ? btrfs_unpin_free_ino+0x99/0x99 [btrfs]
    [132408.505075]  [<ffffffff8106698f>] kthread+0xef/0xf7
    [132408.505075]  [<ffffffff810f3b08>] ? time_hardirqs_on+0x15/0x28
    [132408.505075]  [<ffffffff810668a0>] ? __kthread_parkme+0xad/0xad
    [132408.505075]  [<ffffffff814653d2>] ret_from_fork+0x42/0x70
    [132408.505075]  [<ffffffff810668a0>] ? __kthread_parkme+0xad/0xad
    [132408.505075] ffff880023e7d320: redzone 1:0x9f911029d74e35b, redzone 2:0x9f911029d74e35b.
    [132409.501654] slab: double free detected in cache 'btrfs_free_space', objp ffff880023e7d320
    [132409.503355] ------------[ cut here ]------------
    [132409.504241] kernel BUG at mm/slab.c:2571!
    
    Therefore fix this by having btrfs_unpin_free_ino() acquire the lock
    that protects the rbtree while doing the searches and removing entries.
    
    Fixes: 1c70d8fb4dfa ("Btrfs: fix inode caching vs tree log")
    Cc: stable@vger.kernel.org
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 218df701e607..d4a582ac3f73 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -246,6 +246,7 @@ void btrfs_unpin_free_ino(struct btrfs_root *root)
 {
 	struct btrfs_free_space_ctl *ctl = root->free_ino_ctl;
 	struct rb_root *rbroot = &root->free_ino_pinned->free_space_offset;
+	spinlock_t *rbroot_lock = &root->free_ino_pinned->tree_lock;
 	struct btrfs_free_space *info;
 	struct rb_node *n;
 	u64 count;
@@ -254,23 +255,29 @@ void btrfs_unpin_free_ino(struct btrfs_root *root)
 		return;
 
 	while (1) {
+		bool add_to_ctl = true;
+
+		spin_lock(rbroot_lock);
 		n = rb_first(rbroot);
-		if (!n)
+		if (!n) {
+			spin_unlock(rbroot_lock);
 			break;
+		}
 
 		info = rb_entry(n, struct btrfs_free_space, offset_index);
 		BUG_ON(info->bitmap); /* Logic error */
 
 		if (info->offset > root->ino_cache_progress)
-			goto free;
+			add_to_ctl = false;
 		else if (info->offset + info->bytes > root->ino_cache_progress)
 			count = root->ino_cache_progress - info->offset + 1;
 		else
 			count = info->bytes;
 
-		__btrfs_add_free_space(ctl, info->offset, count);
-free:
 		rb_erase(&info->offset_index, rbroot);
+		spin_unlock(rbroot_lock);
+		if (add_to_ctl)
+			__btrfs_add_free_space(ctl, info->offset, count);
 		kmem_cache_free(btrfs_free_space_cachep, info);
 	}
 }

commit c3f4a1685bb87e59c886ee68f7967eae07d4dffa
Author: Filipe Manana <fdmanana@suse.com>
Date:   Sat Jun 13 06:52:56 2015 +0100

    Btrfs: use kmem_cache_free when freeing entry in inode cache
    
    The free space entries are allocated using kmem_cache_zalloc(),
    through __btrfs_add_free_space(), therefore we should use
    kmem_cache_free() and not kfree() to avoid any confusion and
    any potential problem. Looking at the kfree() definition at
    mm/slab.c it has the following comment:
    
      /*
       * (...)
       *
       * Don't free memory not originally allocated by kmalloc()
       * or you will run into trouble.
       */
    
    So better be safe and use kmem_cache_free().
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index f6a596d5a637..218df701e607 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -271,7 +271,7 @@ void btrfs_unpin_free_ino(struct btrfs_root *root)
 		__btrfs_add_free_space(ctl, info->offset, count);
 free:
 		rb_erase(&info->offset_index, rbroot);
-		kfree(info);
+		kmem_cache_free(btrfs_free_space_cachep, info);
 	}
 }
 

commit 1bbc621ef28462456131c035eaeb5567a1a2a2fe
Author: Chris Mason <clm@fb.com>
Date:   Mon Apr 6 12:46:08 2015 -0700

    Btrfs: allow block group cache writeout outside critical section in commit
    
    We loop through all of the dirty block groups during commit and write
    the free space cache.  In order to make sure the cache is currect, we do
    this while no other writers are allowed in the commit.
    
    If a large number of block groups are dirty, this can introduce long
    stalls during the final stages of the commit, which can block new procs
    trying to change the filesystem.
    
    This commit changes the block group cache writeout to take appropriate
    locks and allow it to run earlier in the commit.  We'll still have to
    redo some of the block groups, but it means we can get most of the work
    out of the way without blocking the entire FS.
    
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 74faea3a516e..f6a596d5a637 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -456,7 +456,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	}
 
 	if (i_size_read(inode) > 0) {
-		ret = btrfs_truncate_free_space_cache(root, trans, inode);
+		ret = btrfs_truncate_free_space_cache(root, trans, NULL, inode);
 		if (ret) {
 			if (ret != -ENOSPC)
 				btrfs_abort_transaction(trans, root, ret);

commit 55507ce3612365a5173dfb080a4baf45d1ef8cd1
Author: Filipe Manana <fdmanana@suse.com>
Date:   Mon Dec 1 17:04:09 2014 +0000

    Btrfs: fix race between writing free space cache and trimming
    
    Trimming is completely transactionless, and the way it operates consists
    of hiding free space entries from a block group, perform the trim/discard
    and then make the free space entries visible again.
    Therefore while a free space entry is being trimmed, we can have free space
    cache writing running in parallel (as part of a transaction commit) which
    will miss the free space entry. This means that an unmount (or crash/reboot)
    after that transaction commit and mount again before another transaction
    starts/commits after the discard finishes, we will have some free space
    that won't be used again unless the free space cache is rebuilt. After the
    unmount, fsck (btrfsck, btrfs check) reports the issue like the following
    example:
    
            *** fsck.btrfs output ***
            checking extents
            checking free space cache
            There is no free space entry for 521764864-521781248
            There is no free space entry for 521764864-1103101952
            cache appears valid but isnt 29360128
            Checking filesystem on /dev/sdc
            UUID: b4789e27-4774-4626-98e9-ae8dfbfb0fb5
            found 1235681286 bytes used err is -22
            (...)
    
    Another issue caused by this race is a crash while writing bitmap entries
    to the cache, because while the cache writeout task accesses the bitmaps,
    the trim task can be concurrently modifying the bitmap or worse might
    be freeing the bitmap. The later case results in the following crash:
    
    [55650.804460] general protection fault: 0000 [#1] SMP DEBUG_PAGEALLOC
    [55650.804835] Modules linked in: btrfs dm_flakey dm_mod crc32c_generic xor raid6_pq nfsd auth_rpcgss oid_registry nfs_acl nfs lockd fscache sunrpc loop parport_pc parport i2c_piix4 psmouse evdev pcspkr microcode processor i2ccore serio_raw thermal_sys button ext4 crc16 jbd2 mbcache sg sd_mod crc_t10dif sr_mod cdrom crct10dif_generic crct10dif_common ata_generic virtio_scsi floppy ata_piix libata virtio_pci virtio_ring virtio scsi_mod e1000 [last unloaded: btrfs]
    [55650.806169] CPU: 1 PID: 31002 Comm: btrfs-transacti Tainted: G        W      3.17.0-rc5-btrfs-next-1+ #1
    [55650.806493] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.7.5-0-ge51488c-20140602_164612-nilsson.home.kraxel.org 04/01/2014
    [55650.806867] task: ffff8800b12f6410 ti: ffff880071538000 task.ti: ffff880071538000
    [55650.807166] RIP: 0010:[<ffffffffa037cf45>]  [<ffffffffa037cf45>] write_bitmap_entries+0x65/0xbb [btrfs]
    [55650.807514] RSP: 0018:ffff88007153bc30  EFLAGS: 00010246
    [55650.807687] RAX: 000000005d1ec000 RBX: ffff8800a665df08 RCX: 0000000000000400
    [55650.807885] RDX: ffff88005d1ec000 RSI: 6b6b6b6b6b6b6b6b RDI: ffff88005d1ec000
    [55650.808017] RBP: ffff88007153bc58 R08: 00000000ddd51536 R09: 00000000000001e0
    [55650.808017] R10: 0000000000000000 R11: 0000000000000037 R12: 6b6b6b6b6b6b6b6b
    [55650.808017] R13: ffff88007153bca8 R14: 6b6b6b6b6b6b6b6b R15: ffff88007153bc98
    [55650.808017] FS:  0000000000000000(0000) GS:ffff88023ec80000(0000) knlGS:0000000000000000
    [55650.808017] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    [55650.808017] CR2: 0000000002273b88 CR3: 00000000b18f6000 CR4: 00000000000006e0
    [55650.808017] Stack:
    [55650.808017]  ffff88020e834e00 ffff880172d68db0 0000000000000000 ffff88019257c800
    [55650.808017]  ffff8801d42ea720 ffff88007153bd10 ffffffffa037d2fa ffff880224e99180
    [55650.808017]  ffff8801469a6188 ffff880224e99140 ffff880172d68c50 00000003000000b7
    [55650.808017] Call Trace:
    [55650.808017]  [<ffffffffa037d2fa>] __btrfs_write_out_cache+0x1ea/0x37f [btrfs]
    [55650.808017]  [<ffffffffa037d959>] btrfs_write_out_cache+0xa1/0xd8 [btrfs]
    [55650.808017]  [<ffffffffa033936b>] btrfs_write_dirty_block_groups+0x4b5/0x505 [btrfs]
    [55650.808017]  [<ffffffffa03aa98e>] commit_cowonly_roots+0x15e/0x1f7 [btrfs]
    [55650.808017]  [<ffffffff813eb9c7>] ? _raw_spin_lock+0xe/0x10
    [55650.808017]  [<ffffffffa0346e46>] btrfs_commit_transaction+0x411/0x882 [btrfs]
    [55650.808017]  [<ffffffffa03432a4>] transaction_kthread+0xf2/0x1a4 [btrfs]
    [55650.808017]  [<ffffffffa03431b2>] ? btrfs_cleanup_transaction+0x3d8/0x3d8 [btrfs]
    [55650.808017]  [<ffffffff8105966b>] kthread+0xb7/0xbf
    [55650.808017]  [<ffffffff810595b4>] ? __kthread_parkme+0x67/0x67
    [55650.808017]  [<ffffffff813ebeac>] ret_from_fork+0x7c/0xb0
    [55650.808017]  [<ffffffff810595b4>] ? __kthread_parkme+0x67/0x67
    [55650.808017] Code: 4c 89 ef 8d 70 ff e8 d4 fc ff ff 41 8b 45 34 41 39 45 30 7d 5c 31 f6 4c 89 ef e8 80 f6 ff ff 49 8b 7d 00 4c 89 f6 b9 00 04 00 00 <f3> a5 4c 89 ef 41 8b 45 30 8d 70 ff e8 a3 fc ff ff 41 8b 45 34
    [55650.808017] RIP  [<ffffffffa037cf45>] write_bitmap_entries+0x65/0xbb [btrfs]
    [55650.808017]  RSP <ffff88007153bc30>
    [55650.815725] ---[ end trace 1c032e96b149ff86 ]---
    
    Fix this by serializing both tasks in such a way that cache writeout
    doesn't wait for the trim/discard of free space entries to finish and
    doesn't miss any free space entry.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 4ebd5ebb1ea1..74faea3a516e 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -364,6 +364,8 @@ void btrfs_init_free_ino_ctl(struct btrfs_root *root)
 	ctl->start = 0;
 	ctl->private = NULL;
 	ctl->op = &free_ino_op;
+	INIT_LIST_HEAD(&ctl->trimming_ranges);
+	mutex_init(&ctl->cache_writeout_mutex);
 
 	/*
 	 * Initially we allow to use 16K of ram to cache chunks of

commit 7e1876aca815029d5c3023a66a91e249eca3e533
Author: David Sterba <dsterba@suse.cz>
Date:   Wed Feb 5 15:26:17 2014 +0100

    btrfs: switch inode_cache option handling to pending changes
    
    The pending mount option(s) now share namespace and bits with the normal
    options, and the existing one for (inode_cache) is unset unconditionally
    at each transaction commit.
    
    Introduce a separate namespace for pending changes and enhance the
    descriptions of the intended change to use separate bits for each
    action.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 83d646bd2e4b..4ebd5ebb1ea1 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -178,7 +178,7 @@ static void start_caching(struct btrfs_root *root)
 			  root->root_key.objectid);
 	if (IS_ERR(tsk)) {
 		btrfs_warn(root->fs_info, "failed to start inode caching task");
-		btrfs_clear_and_info(root, CHANGE_INODE_CACHE,
+		btrfs_clear_pending_and_info(root->fs_info, INODE_MAP_CACHE,
 				"disabling inode map caching");
 	}
 }

commit 57cdc8db21bf9cfa6b2e45310d56e74e263e8609
Author: David Sterba <dsterba@suse.cz>
Date:   Wed Feb 5 02:37:48 2014 +0100

    btrfs: cleanup ino cache members of btrfs_root
    
    The naming is confusing, generic yet used for a specific cache. Add a
    prefix 'ino_' or rename appropriately.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 888fbe19079f..83d646bd2e4b 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -87,7 +87,7 @@ static int caching_kthread(void *data)
 				 */
 				btrfs_item_key_to_cpu(leaf, &key, 0);
 				btrfs_release_path(path);
-				root->cache_progress = last;
+				root->ino_cache_progress = last;
 				up_read(&fs_info->commit_root_sem);
 				schedule_timeout(1);
 				goto again;
@@ -106,7 +106,7 @@ static int caching_kthread(void *data)
 		if (last != (u64)-1 && last + 1 != key.objectid) {
 			__btrfs_add_free_space(ctl, last + 1,
 					       key.objectid - last - 1);
-			wake_up(&root->cache_wait);
+			wake_up(&root->ino_cache_wait);
 		}
 
 		last = key.objectid;
@@ -119,14 +119,14 @@ static int caching_kthread(void *data)
 				       root->highest_objectid - last - 1);
 	}
 
-	spin_lock(&root->cache_lock);
-	root->cached = BTRFS_CACHE_FINISHED;
-	spin_unlock(&root->cache_lock);
+	spin_lock(&root->ino_cache_lock);
+	root->ino_cache_state = BTRFS_CACHE_FINISHED;
+	spin_unlock(&root->ino_cache_lock);
 
-	root->cache_progress = (u64)-1;
+	root->ino_cache_progress = (u64)-1;
 	btrfs_unpin_free_ino(root);
 out:
-	wake_up(&root->cache_wait);
+	wake_up(&root->ino_cache_wait);
 	up_read(&fs_info->commit_root_sem);
 
 	btrfs_free_path(path);
@@ -144,20 +144,20 @@ static void start_caching(struct btrfs_root *root)
 	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
 		return;
 
-	spin_lock(&root->cache_lock);
-	if (root->cached != BTRFS_CACHE_NO) {
-		spin_unlock(&root->cache_lock);
+	spin_lock(&root->ino_cache_lock);
+	if (root->ino_cache_state != BTRFS_CACHE_NO) {
+		spin_unlock(&root->ino_cache_lock);
 		return;
 	}
 
-	root->cached = BTRFS_CACHE_STARTED;
-	spin_unlock(&root->cache_lock);
+	root->ino_cache_state = BTRFS_CACHE_STARTED;
+	spin_unlock(&root->ino_cache_lock);
 
 	ret = load_free_ino_cache(root->fs_info, root);
 	if (ret == 1) {
-		spin_lock(&root->cache_lock);
-		root->cached = BTRFS_CACHE_FINISHED;
-		spin_unlock(&root->cache_lock);
+		spin_lock(&root->ino_cache_lock);
+		root->ino_cache_state = BTRFS_CACHE_FINISHED;
+		spin_unlock(&root->ino_cache_lock);
 		return;
 	}
 
@@ -196,11 +196,11 @@ int btrfs_find_free_ino(struct btrfs_root *root, u64 *objectid)
 
 	start_caching(root);
 
-	wait_event(root->cache_wait,
-		   root->cached == BTRFS_CACHE_FINISHED ||
+	wait_event(root->ino_cache_wait,
+		   root->ino_cache_state == BTRFS_CACHE_FINISHED ||
 		   root->free_ino_ctl->free_space > 0);
 
-	if (root->cached == BTRFS_CACHE_FINISHED &&
+	if (root->ino_cache_state == BTRFS_CACHE_FINISHED &&
 	    root->free_ino_ctl->free_space == 0)
 		return -ENOSPC;
 	else
@@ -214,17 +214,17 @@ void btrfs_return_ino(struct btrfs_root *root, u64 objectid)
 	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
 		return;
 again:
-	if (root->cached == BTRFS_CACHE_FINISHED) {
+	if (root->ino_cache_state == BTRFS_CACHE_FINISHED) {
 		__btrfs_add_free_space(pinned, objectid, 1);
 	} else {
 		down_write(&root->fs_info->commit_root_sem);
-		spin_lock(&root->cache_lock);
-		if (root->cached == BTRFS_CACHE_FINISHED) {
-			spin_unlock(&root->cache_lock);
+		spin_lock(&root->ino_cache_lock);
+		if (root->ino_cache_state == BTRFS_CACHE_FINISHED) {
+			spin_unlock(&root->ino_cache_lock);
 			up_write(&root->fs_info->commit_root_sem);
 			goto again;
 		}
-		spin_unlock(&root->cache_lock);
+		spin_unlock(&root->ino_cache_lock);
 
 		start_caching(root);
 
@@ -235,10 +235,10 @@ void btrfs_return_ino(struct btrfs_root *root, u64 objectid)
 }
 
 /*
- * When a transaction is committed, we'll move those inode numbers which
- * are smaller than root->cache_progress from pinned tree to free_ino tree,
- * and others will just be dropped, because the commit root we were
- * searching has changed.
+ * When a transaction is committed, we'll move those inode numbers which are
+ * smaller than root->ino_cache_progress from pinned tree to free_ino tree, and
+ * others will just be dropped, because the commit root we were searching has
+ * changed.
  *
  * Must be called with root->fs_info->commit_root_sem held
  */
@@ -261,10 +261,10 @@ void btrfs_unpin_free_ino(struct btrfs_root *root)
 		info = rb_entry(n, struct btrfs_free_space, offset_index);
 		BUG_ON(info->bitmap); /* Logic error */
 
-		if (info->offset > root->cache_progress)
+		if (info->offset > root->ino_cache_progress)
 			goto free;
-		else if (info->offset + info->bytes > root->cache_progress)
-			count = root->cache_progress - info->offset + 1;
+		else if (info->offset + info->bytes > root->ino_cache_progress)
+			count = root->ino_cache_progress - info->offset + 1;
 		else
 			count = info->bytes;
 
@@ -462,13 +462,13 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 		}
 	}
 
-	spin_lock(&root->cache_lock);
-	if (root->cached != BTRFS_CACHE_FINISHED) {
+	spin_lock(&root->ino_cache_lock);
+	if (root->ino_cache_state != BTRFS_CACHE_FINISHED) {
 		ret = -1;
-		spin_unlock(&root->cache_lock);
+		spin_unlock(&root->ino_cache_lock);
 		goto out_put;
 	}
-	spin_unlock(&root->cache_lock);
+	spin_unlock(&root->ino_cache_lock);
 
 	spin_lock(&ctl->tree_lock);
 	prealloc = sizeof(struct btrfs_free_space) * ctl->free_extents;

commit 67a77eb147a36fdc346f1b9ff84649209d51f1da
Author: David Sterba <dsterba@suse.cz>
Date:   Fri May 16 15:15:45 2014 +0200

    btrfs: remove newline from inode cache kthread name
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 86935f5ae291..888fbe19079f 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -174,7 +174,7 @@ static void start_caching(struct btrfs_root *root)
 				       BTRFS_LAST_FREE_OBJECTID - objectid + 1);
 	}
 
-	tsk = kthread_run(caching_kthread, root, "btrfs-ino-cache-%llu\n",
+	tsk = kthread_run(caching_kthread, root, "btrfs-ino-cache-%llu",
 			  root->root_key.objectid);
 	if (IS_ERR(tsk)) {
 		btrfs_warn(root->fs_info, "failed to start inode caching task");

commit 1c70d8fb4dfa95bee491816b2a6767b5ca1080e7
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Apr 23 19:33:36 2014 +0800

    Btrfs: fix inode caching vs tree log
    
    Currently, with inode cache enabled, we will reuse its inode id immediately
    after unlinking file, we may hit something like following:
    
    |->iput inode
    |->return inode id into inode cache
    |->create dir,fsync
    |->power off
    
    An easy way to reproduce this problem is:
    
    mkfs.btrfs -f /dev/sdb
    mount /dev/sdb /mnt -o inode_cache,commit=100
    dd if=/dev/zero of=/mnt/data bs=1M count=10 oflag=sync
    inode_id=`ls -i /mnt/data | awk '{print $1}'`
    rm -f /mnt/data
    
    i=1
    while [ 1 ]
    do
            mkdir /mnt/dir_$i
            test1=`stat /mnt/dir_$i | grep Inode: | awk '{print $4}'`
            if [ $test1 -eq $inode_id ]
            then
                    dd if=/dev/zero of=/mnt/dir_$i/data bs=1M count=1 oflag=sync
                    echo b > /proc/sysrq-trigger
            fi
            sleep 1
            i=$(($i+1))
    done
    
    mount /dev/sdb /mnt
    umount /dev/sdb
    btrfs check /dev/sdb
    
    We fix this problem by adding unlinked inode's id into pinned tree,
    and we can not reuse them until committing transaction.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 8ad529e3e67e..86935f5ae291 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -209,24 +209,14 @@ int btrfs_find_free_ino(struct btrfs_root *root, u64 *objectid)
 
 void btrfs_return_ino(struct btrfs_root *root, u64 objectid)
 {
-	struct btrfs_free_space_ctl *ctl = root->free_ino_ctl;
 	struct btrfs_free_space_ctl *pinned = root->free_ino_pinned;
 
 	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
 		return;
-
 again:
 	if (root->cached == BTRFS_CACHE_FINISHED) {
-		__btrfs_add_free_space(ctl, objectid, 1);
+		__btrfs_add_free_space(pinned, objectid, 1);
 	} else {
-		/*
-		 * If we are in the process of caching free ino chunks,
-		 * to avoid adding the same inode number to the free_ino
-		 * tree twice due to cross transaction, we'll leave it
-		 * in the pinned tree until a transaction is committed
-		 * or the caching work is done.
-		 */
-
 		down_write(&root->fs_info->commit_root_sem);
 		spin_lock(&root->cache_lock);
 		if (root->cached == BTRFS_CACHE_FINISHED) {
@@ -238,11 +228,7 @@ void btrfs_return_ino(struct btrfs_root *root, u64 objectid)
 
 		start_caching(root);
 
-		if (objectid <= root->cache_progress ||
-		    objectid >= root->highest_objectid)
-			__btrfs_add_free_space(ctl, objectid, 1);
-		else
-			__btrfs_add_free_space(pinned, objectid, 1);
+		__btrfs_add_free_space(pinned, objectid, 1);
 
 		up_write(&root->fs_info->commit_root_sem);
 	}

commit e60efa84252c059bde5f65fccc6af94478d39e3b
Author: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
Date:   Wed Apr 23 19:33:34 2014 +0800

    Btrfs: avoid triggering bug_on() when we fail to start inode caching task
    
    When running stress test(including snapshots,balance,fstress), we trigger
    the following BUG_ON() which is because we fail to start inode caching task.
    
    [  181.131945] kernel BUG at fs/btrfs/inode-map.c:179!
    [  181.137963] invalid opcode: 0000 [#1] SMP
    [  181.217096] CPU: 11 PID: 2532 Comm: btrfs Not tainted 3.14.0 #1
    [  181.240521] task: ffff88013b621b30 ti: ffff8800b6ada000 task.ti: ffff8800b6ada000
    [  181.367506] Call Trace:
    [  181.371107]  [<ffffffffa036c1be>] btrfs_return_ino+0x9e/0x110 [btrfs]
    [  181.379191]  [<ffffffffa038082b>] btrfs_evict_inode+0x46b/0x4c0 [btrfs]
    [  181.387464]  [<ffffffff810b5a70>] ? autoremove_wake_function+0x40/0x40
    [  181.395642]  [<ffffffff811dc5fe>] evict+0x9e/0x190
    [  181.401882]  [<ffffffff811dcde3>] iput+0xf3/0x180
    [  181.408025]  [<ffffffffa03812de>] btrfs_orphan_cleanup+0x1ee/0x430 [btrfs]
    [  181.416614]  [<ffffffffa03a6abd>] btrfs_mksubvol.isra.29+0x3bd/0x450 [btrfs]
    [  181.425399]  [<ffffffffa03a6cd6>] btrfs_ioctl_snap_create_transid+0x186/0x190 [btrfs]
    [  181.435059]  [<ffffffffa03a6e3b>] btrfs_ioctl_snap_create_v2+0xeb/0x130 [btrfs]
    [  181.444148]  [<ffffffffa03a9656>] btrfs_ioctl+0xf76/0x2b90 [btrfs]
    [  181.451971]  [<ffffffff8117e565>] ? handle_mm_fault+0x475/0xe80
    [  181.459509]  [<ffffffff8167ba0c>] ? __do_page_fault+0x1ec/0x520
    [  181.467046]  [<ffffffff81185b35>] ? do_mmap_pgoff+0x2f5/0x3c0
    [  181.474393]  [<ffffffff811d4da8>] do_vfs_ioctl+0x2d8/0x4b0
    [  181.481450]  [<ffffffff811d5001>] SyS_ioctl+0x81/0xa0
    [  181.488021]  [<ffffffff81680b69>] system_call_fastpath+0x16/0x1b
    
    We should avoid triggering BUG_ON() here, instead, we output warning messages
    and clear inode_cache option.
    
    Signed-off-by: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index cc8ca193d830..8ad529e3e67e 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -176,7 +176,11 @@ static void start_caching(struct btrfs_root *root)
 
 	tsk = kthread_run(caching_kthread, root, "btrfs-ino-cache-%llu\n",
 			  root->root_key.objectid);
-	BUG_ON(IS_ERR(tsk)); /* -ENOMEM */
+	if (IS_ERR(tsk)) {
+		btrfs_warn(root->fs_info, "failed to start inode caching task");
+		btrfs_clear_and_info(root, CHANGE_INODE_CACHE,
+				"disabling inode map caching");
+	}
 }
 
 int btrfs_find_free_ino(struct btrfs_root *root, u64 *objectid)

commit 9e351cc862b098d8ec8f8022d110932490794925
Author: Josef Bacik <jbacik@fb.com>
Date:   Thu Mar 13 15:42:13 2014 -0400

    Btrfs: remove transaction from send
    
    Lets try this again.  We can deadlock the box if we send on a box and try to
    write onto the same fs with the app that is trying to listen to the send pipe.
    This is because the writer could get stuck waiting for a transaction commit
    which is being blocked by the send.  So fix this by making sure looking at the
    commit roots is always going to be consistent.  We do this by keeping track of
    which roots need to have their commit roots swapped during commit, and then
    taking the commit_root_sem and swapping them all at once.  Then make sure we
    take a read lock on the commit_root_sem in cases where we search the commit root
    to make sure we're always looking at a consistent view of the commit roots.
    Previously we had problems with this because we would swap a fs tree commit root
    and then swap the extent tree commit root independently which would cause the
    backref walking code to screw up sometimes.  With this patch we no longer
    deadlock and pass all the weird send/receive corner cases.  Thanks,
    
    Reportedy-by: Hugo Mills <hugo@carfax.org.uk>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index ab485e57b6fe..cc8ca193d830 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -55,7 +55,7 @@ static int caching_kthread(void *data)
 	key.type = BTRFS_INODE_ITEM_KEY;
 again:
 	/* need to make sure the commit_root doesn't disappear */
-	mutex_lock(&root->fs_commit_mutex);
+	down_read(&fs_info->commit_root_sem);
 
 	ret = btrfs_search_slot(NULL, root, &key, path, 0, 0);
 	if (ret < 0)
@@ -88,7 +88,7 @@ static int caching_kthread(void *data)
 				btrfs_item_key_to_cpu(leaf, &key, 0);
 				btrfs_release_path(path);
 				root->cache_progress = last;
-				mutex_unlock(&root->fs_commit_mutex);
+				up_read(&fs_info->commit_root_sem);
 				schedule_timeout(1);
 				goto again;
 			} else
@@ -127,7 +127,7 @@ static int caching_kthread(void *data)
 	btrfs_unpin_free_ino(root);
 out:
 	wake_up(&root->cache_wait);
-	mutex_unlock(&root->fs_commit_mutex);
+	up_read(&fs_info->commit_root_sem);
 
 	btrfs_free_path(path);
 
@@ -223,11 +223,11 @@ void btrfs_return_ino(struct btrfs_root *root, u64 objectid)
 		 * or the caching work is done.
 		 */
 
-		mutex_lock(&root->fs_commit_mutex);
+		down_write(&root->fs_info->commit_root_sem);
 		spin_lock(&root->cache_lock);
 		if (root->cached == BTRFS_CACHE_FINISHED) {
 			spin_unlock(&root->cache_lock);
-			mutex_unlock(&root->fs_commit_mutex);
+			up_write(&root->fs_info->commit_root_sem);
 			goto again;
 		}
 		spin_unlock(&root->cache_lock);
@@ -240,7 +240,7 @@ void btrfs_return_ino(struct btrfs_root *root, u64 objectid)
 		else
 			__btrfs_add_free_space(pinned, objectid, 1);
 
-		mutex_unlock(&root->fs_commit_mutex);
+		up_write(&root->fs_info->commit_root_sem);
 	}
 }
 
@@ -250,7 +250,7 @@ void btrfs_return_ino(struct btrfs_root *root, u64 objectid)
  * and others will just be dropped, because the commit root we were
  * searching has changed.
  *
- * Must be called with root->fs_commit_mutex held
+ * Must be called with root->fs_info->commit_root_sem held
  */
 void btrfs_unpin_free_ino(struct btrfs_root *root)
 {

commit fae7f21cece9a4c181a8d8131870c7247e153f65
Author: Dulshani Gunawardhana <dulshani.gunawardhana89@gmail.com>
Date:   Thu Oct 31 10:30:08 2013 +0530

    btrfs: Use WARN_ON()'s return value in place of WARN_ON(1)
    
    Use WARN_ON()'s return value in place of WARN_ON(1) for cleaner source
    code that outputs a more descriptive warnings. Also fix the styling
    warning of redundant braces that came up as a result of this fix.
    
    Signed-off-by: Dulshani Gunawardhana <dulshani.gunawardhana89@gmail.com>
    Reviewed-by: Zach Brown <zab@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index ec08004a6a20..ab485e57b6fe 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -78,10 +78,8 @@ static int caching_kthread(void *data)
 			    btrfs_transaction_in_commit(fs_info)) {
 				leaf = path->nodes[0];
 
-				if (btrfs_header_nritems(leaf) == 0) {
-					WARN_ON(1);
+				if (WARN_ON(btrfs_header_nritems(leaf) == 0))
 					break;
-				}
 
 				/*
 				 * Save the key so we can advances forward

commit ff76b0565523319d7c1c0b51d5a5a8915d33efab
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Tue Oct 15 20:08:15 2013 +0200

    Btrfs: Don't allocate inode that is already in use
    
    Due to an off-by-one error, it is possible to reproduce a bug
    when the inode cache is used.
    
    The same inode number is assigned twice, the second time this
    leads to an EEXIST in btrfs_insert_empty_items().
    
    The issue can happen when a file is removed right after a subvolume
    is created and then a new inode number is created before the
    inodes in free_inode_pinned are processed.
    unlink() calls btrfs_return_ino() which calls start_caching() in this
    case which adds [highest_ino + 1, BTRFS_LAST_FREE_OBJECTID] by
    searching for the highest inode (which already cannot find the
    unlinked one anymore in btrfs_find_free_objectid()). So if this
    unlinked inode's number is equal to the highest_ino + 1 (or >= this value
    instead of > this value which was the off-by-one error), we mustn't add
    the inode number to free_ino_pinned (caching_thread() does it right).
    In this case we need to try directly to add the number to the inode_cache
    which will fail in this case.
    
    When this inode number is allocated while it is still in free_ino_pinned,
    it is allocated and still added to the free inode cache when the
    pinned inodes are processed, thus one of the following inode number
    allocations will get an inode that is already in use and fail with EEXIST
    in btrfs_insert_empty_items().
    
    One example which was created with the reproducer below:
    Create a snapshot, work in the newly created snapshot for the rest.
    In unlink(inode 34284) call btrfs_return_ino() which calls start_caching().
    start_caching() calls add_free_space [34284, 18446744073709517077].
    In btrfs_return_ino(), call start_caching pinned [34284, 1] which is wrong.
    mkdir() call btrfs_find_ino_for_alloc() which returns the number 34284.
    btrfs_unpin_free_ino calls add_free_space [34284, 1].
    mkdir() call btrfs_find_ino_for_alloc() which returns the number 34284.
    EEXIST when the new inode is inserted.
    
    One possible reproducer is this one:
     #!/bin/sh
     # preparation
    TEST_DEV=/dev/sdc1
    TEST_MNT=/mnt
    umount ${TEST_MNT} 2>/dev/null || true
    mkfs.btrfs -f ${TEST_DEV}
    mount ${TEST_DEV} ${TEST_MNT} -o \
     rw,relatime,compress=lzo,space_cache,inode_cache
    btrfs subv create ${TEST_MNT}/s1
    for i in `seq 34027`; do touch ${TEST_MNT}/s1/${i}; done
    btrfs subv snap ${TEST_MNT}/s1 ${TEST_MNT}/s2
    FILENAME=`find ${TEST_MNT}/s1/ -inum 4085 | sed 's|^.*/\([^/]*\)$|\1|'`
    rm ${TEST_MNT}/s2/$FILENAME
    touch ${TEST_MNT}/s2/$FILENAME
     # the following steps can be repeated to reproduce the issue again and again
    [ -e ${TEST_MNT}/s3 ] && btrfs subv del ${TEST_MNT}/s3
    btrfs subv snap ${TEST_MNT}/s2 ${TEST_MNT}/s3
    rm ${TEST_MNT}/s3/$FILENAME
    touch ${TEST_MNT}/s3/$FILENAME
    ls -alFi ${TEST_MNT}/s?/$FILENAME
    touch ${TEST_MNT}/s3/_1 || logger FAILED
    ls -alFi ${TEST_MNT}/s?/_1
    touch ${TEST_MNT}/s3/_2 || logger FAILED
    ls -alFi ${TEST_MNT}/s?/_2
    touch ${TEST_MNT}/s3/__1 || logger FAILED
    ls -alFi ${TEST_MNT}/s?/__1
    touch ${TEST_MNT}/s3/__2 || logger FAILED
    ls -alFi ${TEST_MNT}/s?/__2
     # if the above is not enough, add the following loop:
    for i in `seq 3 9`; do touch ${TEST_MNT}/s3/__${i} || logger FAILED; done
     #for i in `seq 3 34027`; do touch ${TEST_MNT}/s3/__${i} || logger FAILED; done
     # one of the touch(1) calls in s3 fail due to EEXIST because the inode is
     # already in use that btrfs_find_ino_for_alloc() returns.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Reviewed-by: Jan Schmidt <list.btrfs@jan-o-sch.net>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 014de497e888..ec08004a6a20 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -237,7 +237,7 @@ void btrfs_return_ino(struct btrfs_root *root, u64 objectid)
 		start_caching(root);
 
 		if (objectid <= root->cache_progress ||
-		    objectid > root->highest_objectid)
+		    objectid >= root->highest_objectid)
 			__btrfs_add_free_space(ctl, objectid, 1);
 		else
 			__btrfs_add_free_space(pinned, objectid, 1);

commit 74514323947ef27347564bfd7a663fdb3429cb20
Author: Filipe David Borba Manana <fdmanana@gmail.com>
Date:   Fri Sep 20 14:46:51 2013 +0100

    Btrfs: remove path arg from btrfs_truncate_free_space_cache
    
    Not used for anything, and removing it avoids caller's need to
    allocate a path structure.
    
    Signed-off-by: Filipe David Borba Manana <fdmanana@gmail.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index b863e45d373b..014de497e888 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -466,7 +466,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	}
 
 	if (i_size_read(inode) > 0) {
-		ret = btrfs_truncate_free_space_cache(root, trans, path, inode);
+		ret = btrfs_truncate_free_space_cache(root, trans, inode);
 		if (ret) {
 			if (ret != -ENOSPC)
 				btrfs_abort_transaction(trans, root, ret);

commit 53645a91f4baed059ec5dfb22340cf3e6b8fdd2c
Author: Filipe David Borba Manana <fdmanana@gmail.com>
Date:   Fri Sep 20 14:43:28 2013 +0100

    Btrfs: remove duplicated ino cache's inode lookup
    
    We're doing a unnecessary extra lookup of the ino cache's
    inode when we already have it (and holding a reference)
    during the process of saving the ino cache contents to disk.
    Therefore remove this extra lookup.
    
    Signed-off-by: Filipe David Borba Manana <fdmanana@gmail.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index d11e1c6610b6..b863e45d373b 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -503,7 +503,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	}
 	btrfs_free_reserved_data_space(inode, prealloc);
 
-	ret = btrfs_write_out_ino_cache(root, trans, path);
+	ret = btrfs_write_out_ino_cache(root, trans, path, inode);
 out_put:
 	iput(inode);
 out_release:

commit 69e9c6c6dc87587d8846e447febedefe037c14f8
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Thu Sep 5 16:58:43 2013 +0200

    Btrfs: eliminate the exceptional root_tree refs=0
    
    The fact that btrfs_root_refs() returned 0 for the tree_root caused
    bugs in the past, therefore it is set to 1 with this patch and
    (hopefully) all affected code is adapted to this change.
    
    I verified this change by temporarily adding WARN_ON() checks
    everywhere where btrfs_root_refs() is used, checking whether the
    logic of the code is changed by btrfs_root_refs() returning 1
    instead of 0 for root->root_key.objectid == BTRFS_ROOT_TREE_OBJECTID.
    With these added checks, I ran the xfstests './check -g auto'.
    
    The two roots chunk_root and log_root_tree that are only referenced
    by the superblock and the log_roots below the log_root_tree still
    have btrfs_root_refs() == 0, only the tree_root is changed.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 2c66ddbbe670..d11e1c6610b6 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -412,8 +412,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 		return 0;
 
 	/* Don't save inode cache if we are deleting this root */
-	if (btrfs_root_refs(&root->root_item) == 0 &&
-	    root != root->fs_info->tree_root)
+	if (btrfs_root_refs(&root->root_item) == 0)
 		return 0;
 
 	if (!btrfs_test_opt(root, INODE_MAP_CACHE))

commit 7b61cd92242542944fc27024900c495a6a7b3396
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Mon May 13 13:55:09 2013 +0000

    Btrfs: don't use global block reservation for inode cache truncation
    
    It is very likely that there are lots of subvolumes/snapshots in the filesystem,
    so if we use global block reservation to do inode cache truncation, we may hog
    all the free space that is reserved in global rsv. So it is better that we do
    the free space reservation for inode cache truncation by ourselves.
    
    Cc: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 9818d4a3f829..2c66ddbbe670 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -429,11 +429,12 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	num_bytes = trans->bytes_reserved;
 	/*
 	 * 1 item for inode item insertion if need
-	 * 3 items for inode item update (in the worst case)
+	 * 4 items for inode item update (in the worst case)
+	 * 1 items for slack space if we need do truncation
 	 * 1 item for free space object
 	 * 3 items for pre-allocation
 	 */
-	trans->bytes_reserved = btrfs_calc_trans_metadata_size(root, 8);
+	trans->bytes_reserved = btrfs_calc_trans_metadata_size(root, 10);
 	ret = btrfs_block_rsv_add(root, trans->block_rsv,
 				  trans->bytes_reserved,
 				  BTRFS_RESERVE_NO_FLUSH);

commit 7cfa9e51d2948ae90e7599cc114dcce2c7c2b1fc
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Mon May 13 13:55:08 2013 +0000

    Btrfs: don't abort the current transaction if there is no enough space for inode cache
    
    The filesystem with inode cache was forced to be read-only when we umounted it.
    
    Steps to reproduce:
     # mkfs.btrfs -f ${DEV}
     # mount -o inode_cache ${DEV} ${MNT}
     # dd if=/dev/zero of=${MNT}/file1 bs=1M count=8192
     # btrfs fi syn ${MNT}
     # dd if=${MNT}/file1 of=/dev/null bs=1M
     # rm -f ${MNT}/file1
     # btrfs fi syn ${MNT}
     # umount ${MNT}
    
    It is because there was no enough space to do inode cache truncation, and then
    we aborted the current transaction.
    
    But no space error is not a serious problem when we write out the inode cache,
    and it is safe that we just skip this step if we meet this problem. So we need
    not abort the current transaction.
    
    Reported-by: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Tested-by: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index d26f67a59e36..9818d4a3f829 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -468,7 +468,8 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	if (i_size_read(inode) > 0) {
 		ret = btrfs_truncate_free_space_cache(root, trans, path, inode);
 		if (ret) {
-			btrfs_abort_transaction(trans, root, ret);
+			if (ret != -ENOSPC)
+				btrfs_abort_transaction(trans, root, ret);
 			goto out_put;
 		}
 	}

commit 08e007d2e57744472a9424735a368ffe6d625597
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Tue Oct 16 11:33:38 2012 +0000

    Btrfs: improve the noflush reservation
    
    In some places(such as: evicting inode), we just can not flush the reserved
    space of delalloc, flushing the delayed directory index and delayed inode
    is OK, but we don't try to flush those things and just go back when there is
    no enough space to be reserved. This patch fixes this problem.
    
    We defined 3 types of the flush operations: NO_FLUSH, FLUSH_LIMIT and FLUSH_ALL.
    If we can in the transaction, we should not flush anything, or the deadlock
    would happen, so use NO_FLUSH. If we flushing the reserved space of delalloc
    would cause deadlock, use FLUSH_LIMIT. In the other cases, FLUSH_ALL is used,
    and we will flush all things.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index b1a1c929ba80..d26f67a59e36 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -434,8 +434,9 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	 * 3 items for pre-allocation
 	 */
 	trans->bytes_reserved = btrfs_calc_trans_metadata_size(root, 8);
-	ret = btrfs_block_rsv_add_noflush(root, trans->block_rsv,
-					  trans->bytes_reserved);
+	ret = btrfs_block_rsv_add(root, trans->block_rsv,
+				  trans->bytes_reserved,
+				  BTRFS_RESERVE_NO_FLUSH);
 	if (ret)
 		goto out;
 	trace_btrfs_space_reservation(root->fs_info, "ino_cache",

commit 2bcc0328c3a043880796a602c75fbeb1537aa1e1
Author: Liu Bo <liubo2009@cn.fujitsu.com>
Date:   Thu Mar 29 09:57:44 2012 -0400

    Btrfs: show useful info in space reservation tracepoint
    
    o For space info, the type of space info is useful for debug.
    o For transaction handle, its transid is useful.
    
    Signed-off-by: Liu Bo <liubo2009@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 7ca46e6e11ae..b1a1c929ba80 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -439,8 +439,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	if (ret)
 		goto out;
 	trace_btrfs_space_reservation(root->fs_info, "ino_cache",
-				      (u64)(unsigned long)trans,
-				      trans->bytes_reserved, 1);
+				      trans->transid, trans->bytes_reserved, 1);
 again:
 	inode = lookup_free_ino_inode(root, path);
 	if (IS_ERR(inode) && (PTR_ERR(inode) != -ENOENT || retry)) {
@@ -507,8 +506,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	iput(inode);
 out_release:
 	trace_btrfs_space_reservation(root->fs_info, "ino_cache",
-				      (u64)(unsigned long)trans,
-				      trans->bytes_reserved, 0);
+				      trans->transid, trans->bytes_reserved, 0);
 	btrfs_block_rsv_release(root, trans->block_rsv, trans->bytes_reserved);
 out:
 	trans->block_rsv = rsv;

commit 79787eaab46121d4713ed03c8fc63b9ec3eaec76
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 12 16:03:00 2012 +0100

    btrfs: replace many BUG_ONs with proper error handling
    
     btrfs currently handles most errors with BUG_ON. This patch is a work-in-
     progress but aims to handle most errors other than internal logic
     errors and ENOMEM more gracefully.
    
     This iteration prevents most crashes but can run into lockups with
     the page lock on occasion when the timing "works out."
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index ee15d88b33d2..7ca46e6e11ae 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -178,7 +178,7 @@ static void start_caching(struct btrfs_root *root)
 
 	tsk = kthread_run(caching_kthread, root, "btrfs-ino-cache-%llu\n",
 			  root->root_key.objectid);
-	BUG_ON(IS_ERR(tsk));
+	BUG_ON(IS_ERR(tsk)); /* -ENOMEM */
 }
 
 int btrfs_find_free_ino(struct btrfs_root *root, u64 *objectid)
@@ -271,7 +271,7 @@ void btrfs_unpin_free_ino(struct btrfs_root *root)
 			break;
 
 		info = rb_entry(n, struct btrfs_free_space, offset_index);
-		BUG_ON(info->bitmap);
+		BUG_ON(info->bitmap); /* Logic error */
 
 		if (info->offset > root->cache_progress)
 			goto free;
@@ -443,13 +443,13 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 				      trans->bytes_reserved, 1);
 again:
 	inode = lookup_free_ino_inode(root, path);
-	if (IS_ERR(inode) && PTR_ERR(inode) != -ENOENT) {
+	if (IS_ERR(inode) && (PTR_ERR(inode) != -ENOENT || retry)) {
 		ret = PTR_ERR(inode);
 		goto out_release;
 	}
 
 	if (IS_ERR(inode)) {
-		BUG_ON(retry);
+		BUG_ON(retry); /* Logic error */
 		retry = true;
 
 		ret = create_free_ino_inode(root, trans, path);
@@ -460,12 +460,17 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 
 	BTRFS_I(inode)->generation = 0;
 	ret = btrfs_update_inode(trans, root, inode);
-	WARN_ON(ret);
+	if (ret) {
+		btrfs_abort_transaction(trans, root, ret);
+		goto out_put;
+	}
 
 	if (i_size_read(inode) > 0) {
 		ret = btrfs_truncate_free_space_cache(root, trans, path, inode);
-		if (ret)
+		if (ret) {
+			btrfs_abort_transaction(trans, root, ret);
 			goto out_put;
+		}
 	}
 
 	spin_lock(&root->cache_lock);
@@ -532,7 +537,7 @@ static int btrfs_find_highest_objectid(struct btrfs_root *root, u64 *objectid)
 	ret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);
 	if (ret < 0)
 		goto error;
-	BUG_ON(ret == 0);
+	BUG_ON(ret == 0); /* Corruption */
 	if (path->slots[0] > 0) {
 		slot = path->slots[0] - 1;
 		l = path->nodes[0];

commit e77266e4c4be6f9dc91bf688bce015a8babd5fe0
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Feb 24 10:39:05 2012 -0500

    Btrfs: fix compiler warnings on 32 bit systems
    
    The enospc tracing code added some interesting uses of
    u64 pointer casts.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 213ffa86ce1b..ee15d88b33d2 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -438,7 +438,8 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 					  trans->bytes_reserved);
 	if (ret)
 		goto out;
-	trace_btrfs_space_reservation(root->fs_info, "ino_cache", (u64)trans,
+	trace_btrfs_space_reservation(root->fs_info, "ino_cache",
+				      (u64)(unsigned long)trans,
 				      trans->bytes_reserved, 1);
 again:
 	inode = lookup_free_ino_inode(root, path);
@@ -500,7 +501,8 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 out_put:
 	iput(inode);
 out_release:
-	trace_btrfs_space_reservation(root->fs_info, "ino_cache", (u64)trans,
+	trace_btrfs_space_reservation(root->fs_info, "ino_cache",
+				      (u64)(unsigned long)trans,
 				      trans->bytes_reserved, 0);
 	btrfs_block_rsv_release(root, trans->block_rsv, trans->bytes_reserved);
 out:

commit 8c2a3ca20f6233677ac3222c6506174010eb414f
Author: Josef Bacik <josef@redhat.com>
Date:   Tue Jan 10 10:31:31 2012 -0500

    Btrfs: space leak tracepoints
    
    This in addition to a script in my btrfs-tracing tree will help track down space
    leaks when we're getting space left over in block groups on umount.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index f8962a957d65..213ffa86ce1b 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -438,6 +438,8 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 					  trans->bytes_reserved);
 	if (ret)
 		goto out;
+	trace_btrfs_space_reservation(root->fs_info, "ino_cache", (u64)trans,
+				      trans->bytes_reserved, 1);
 again:
 	inode = lookup_free_ino_inode(root, path);
 	if (IS_ERR(inode) && PTR_ERR(inode) != -ENOENT) {
@@ -498,6 +500,8 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 out_put:
 	iput(inode);
 out_release:
+	trace_btrfs_space_reservation(root->fs_info, "ino_cache", (u64)trans,
+				      trans->bytes_reserved, 0);
 	btrfs_block_rsv_release(root, trans->block_rsv, trans->bytes_reserved);
 out:
 	trans->block_rsv = rsv;

commit ba38eb4de354d228f2792f93cde2c748a3a3f3b2
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Thu Nov 10 20:45:04 2011 -0500

    Btrfs: fix no reserved space for writing out inode cache
    
    I-node cache forgets to reserve the space when writing out it. And when
    we do some stress test, such as synctest, it will trigger WARN_ON() in
    use_block_rsv().
    
    WARNING: at fs/btrfs/extent-tree.c:5718 btrfs_alloc_free_block+0xbf/0x281 [btrfs]()
    ...
    Call Trace:
     [<ffffffff8104df86>] warn_slowpath_common+0x80/0x98
     [<ffffffff8104dfb3>] warn_slowpath_null+0x15/0x17
     [<ffffffffa0369c60>] btrfs_alloc_free_block+0xbf/0x281 [btrfs]
     [<ffffffff810cbcb8>] ? __set_page_dirty_nobuffers+0xfe/0x108
     [<ffffffffa035c040>] __btrfs_cow_block+0x118/0x3b5 [btrfs]
     [<ffffffffa035c7ba>] btrfs_cow_block+0x103/0x14e [btrfs]
     [<ffffffffa035e4c4>] btrfs_search_slot+0x249/0x6a4 [btrfs]
     [<ffffffffa036d086>] btrfs_lookup_inode+0x2a/0x8a [btrfs]
     [<ffffffffa03788b7>] btrfs_update_inode+0xaa/0x141 [btrfs]
     [<ffffffffa036d7ec>] btrfs_save_ino_cache+0xea/0x202 [btrfs]
     [<ffffffffa03a761e>] ? btrfs_update_reloc_root+0x17e/0x197 [btrfs]
     [<ffffffffa0373867>] commit_fs_roots+0xaa/0x158 [btrfs]
     [<ffffffffa03746a6>] btrfs_commit_transaction+0x405/0x731 [btrfs]
     [<ffffffff810690df>] ? wake_up_bit+0x25/0x25
     [<ffffffffa039d652>] ? btrfs_log_dentry_safe+0x43/0x51 [btrfs]
     [<ffffffffa0381c5f>] btrfs_sync_file+0x16a/0x198 [btrfs]
     [<ffffffff81122806>] ? mntput+0x21/0x23
     [<ffffffff8112d150>] vfs_fsync_range+0x18/0x21
     [<ffffffff8112d170>] vfs_fsync+0x17/0x19
     [<ffffffff8112d316>] do_fsync+0x29/0x3e
     [<ffffffff8112d348>] sys_fsync+0xb/0xf
     [<ffffffff81468352>] system_call_fastpath+0x16/0x1b
    
    Sometimes it causes BUG_ON() in the reservation code of the delayed inode
    is triggered.
    
    So we must reserve enough space for inode cache.
    
    Note: If we can not reserve the enough space for inode cache, we will
    give up writing out it.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 53dcbdf446cd..f8962a957d65 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -398,6 +398,8 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	struct btrfs_free_space_ctl *ctl = root->free_ino_ctl;
 	struct btrfs_path *path;
 	struct inode *inode;
+	struct btrfs_block_rsv *rsv;
+	u64 num_bytes;
 	u64 alloc_hint = 0;
 	int ret;
 	int prealloc;
@@ -421,11 +423,26 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	if (!path)
 		return -ENOMEM;
 
+	rsv = trans->block_rsv;
+	trans->block_rsv = &root->fs_info->trans_block_rsv;
+
+	num_bytes = trans->bytes_reserved;
+	/*
+	 * 1 item for inode item insertion if need
+	 * 3 items for inode item update (in the worst case)
+	 * 1 item for free space object
+	 * 3 items for pre-allocation
+	 */
+	trans->bytes_reserved = btrfs_calc_trans_metadata_size(root, 8);
+	ret = btrfs_block_rsv_add_noflush(root, trans->block_rsv,
+					  trans->bytes_reserved);
+	if (ret)
+		goto out;
 again:
 	inode = lookup_free_ino_inode(root, path);
 	if (IS_ERR(inode) && PTR_ERR(inode) != -ENOENT) {
 		ret = PTR_ERR(inode);
-		goto out;
+		goto out_release;
 	}
 
 	if (IS_ERR(inode)) {
@@ -434,7 +451,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 
 		ret = create_free_ino_inode(root, trans, path);
 		if (ret)
-			goto out;
+			goto out_release;
 		goto again;
 	}
 
@@ -477,11 +494,14 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	}
 	btrfs_free_reserved_data_space(inode, prealloc);
 
+	ret = btrfs_write_out_ino_cache(root, trans, path);
 out_put:
 	iput(inode);
+out_release:
+	btrfs_block_rsv_release(root, trans->block_rsv, trans->bytes_reserved);
 out:
-	if (ret == 0)
-		ret = btrfs_write_out_ino_cache(root, trans, path);
+	trans->block_rsv = rsv;
+	trans->bytes_reserved = num_bytes;
 
 	btrfs_free_path(path);
 	return ret;

commit c09544e07f8cdc455ed8615d4c067d694c33bd18
Author: Josef Bacik <josef@redhat.com>
Date:   Tue Aug 30 10:19:10 2011 -0400

    Btrfs: handle enospc accounting for free space inodes
    
    Since free space inodes now use normal checksumming we need to make sure to
    account for their metadata use.  So reserve metadata space, and then if we fail
    to write out the metadata we can just release it, otherwise it will be freed up
    when the io completes.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index b4087e0fa871..53dcbdf446cd 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -465,14 +465,16 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	/* Just to make sure we have enough space */
 	prealloc += 8 * PAGE_CACHE_SIZE;
 
-	ret = btrfs_check_data_free_space(inode, prealloc);
+	ret = btrfs_delalloc_reserve_space(inode, prealloc);
 	if (ret)
 		goto out_put;
 
 	ret = btrfs_prealloc_file_range_trans(inode, trans, 0, 0, prealloc,
 					      prealloc, prealloc, &alloc_hint);
-	if (ret)
+	if (ret) {
+		btrfs_delalloc_release_space(inode, prealloc);
 		goto out_put;
+	}
 	btrfs_free_reserved_data_space(inode, prealloc);
 
 out_put:

commit 7841cb2898f66a73062c64d0ef5733dde7279e46
Author: David Sterba <dsterba@suse.cz>
Date:   Tue May 31 18:07:27 2011 +0200

    btrfs: add helper for fs_info->closing
    
    wrap checking of filesystem 'closing' flag and fix a few missing memory
    barriers.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index cb79b8975c9f..b4087e0fa871 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -62,8 +62,7 @@ static int caching_kthread(void *data)
 		goto out;
 
 	while (1) {
-		smp_mb();
-		if (fs_info->closing)
+		if (btrfs_fs_closing(fs_info))
 			goto out;
 
 		leaf = path->nodes[0];

commit 4b9465cb9e3859186eefa1ca3b990a5849386320
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Jun 3 09:36:29 2011 -0400

    Btrfs: add mount -o inode_cache
    
    This makes the inode map cache default to off until we
    fix the overflow problem when the free space crcs don't fit
    inside a single page.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 2d0d50067a7b..cb79b8975c9f 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -38,6 +38,9 @@ static int caching_kthread(void *data)
 	int slot;
 	int ret;
 
+	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+		return 0;
+
 	path = btrfs_alloc_path();
 	if (!path)
 		return -ENOMEM;
@@ -141,6 +144,9 @@ static void start_caching(struct btrfs_root *root)
 	int ret;
 	u64 objectid;
 
+	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+		return;
+
 	spin_lock(&root->cache_lock);
 	if (root->cached != BTRFS_CACHE_NO) {
 		spin_unlock(&root->cache_lock);
@@ -178,6 +184,9 @@ static void start_caching(struct btrfs_root *root)
 
 int btrfs_find_free_ino(struct btrfs_root *root, u64 *objectid)
 {
+	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+		return btrfs_find_free_objectid(root, objectid);
+
 again:
 	*objectid = btrfs_find_ino_for_alloc(root);
 
@@ -201,6 +210,10 @@ void btrfs_return_ino(struct btrfs_root *root, u64 objectid)
 {
 	struct btrfs_free_space_ctl *ctl = root->free_ino_ctl;
 	struct btrfs_free_space_ctl *pinned = root->free_ino_pinned;
+
+	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+		return;
+
 again:
 	if (root->cached == BTRFS_CACHE_FINISHED) {
 		__btrfs_add_free_space(ctl, objectid, 1);
@@ -250,6 +263,9 @@ void btrfs_unpin_free_ino(struct btrfs_root *root)
 	struct rb_node *n;
 	u64 count;
 
+	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+		return;
+
 	while (1) {
 		n = rb_first(rbroot);
 		if (!n)
@@ -399,9 +415,13 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	    root != root->fs_info->tree_root)
 		return 0;
 
+	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+		return 0;
+
 	path = btrfs_alloc_path();
 	if (!path)
 		return -ENOMEM;
+
 again:
 	inode = lookup_free_ino_inode(root, path);
 	if (IS_ERR(inode) && PTR_ERR(inode) != -ENOENT) {

commit d132a538d258f8f52fd0cd8b5017755f4e915386
Author: Josef Bacik <josef@redhat.com>
Date:   Tue May 31 19:33:33 2011 +0000

    Btrfs: don't save the inode cache if we are deleting this root
    
    With xfstest 254 I can panic the box every time with the inode number caching
    stuff on.  This is because we clean the inodes out when we delete the subvolume,
    but then we write out the inode cache which adds an inode to the subvolume inode
    tree, and then when it gets evicted again the root gets added back on the dead
    roots list and is deleted again, so we have a double free.  To stop this from
    happening just return 0 if refs is 0 (and we're not the tree root since tree
    root always has refs of 0).  With this fix 254 no longer panics.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Tested-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 04f7199facb4..2d0d50067a7b 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -394,6 +394,11 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	     root->root_key.objectid > BTRFS_LAST_FREE_OBJECTID))
 		return 0;
 
+	/* Don't save inode cache if we are deleting this root */
+	if (btrfs_root_refs(&root->root_item) == 0 &&
+	    root != root->fs_info->tree_root)
+		return 0;
+
 	path = btrfs_alloc_path();
 	if (!path)
 		return -ENOMEM;

commit ca456ae280c0646e1e571c3b9a3834c55e90adfe
Author: liubo <liubo2009@cn.fujitsu.com>
Date:   Wed Jun 1 09:42:49 2011 +0000

    Btrfs: don't save the inode cache in non-FS roots
    
    This adds extra checks to make sure the inode map we are caching really
    belongs to a FS root instead of a special relocation tree.  It
    prevents crashes during balancing operations.
    
    Signed-off-by: Liu Bo <liubo2009@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 3262cd17a12f..04f7199facb4 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -388,6 +388,12 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	int prealloc;
 	bool retry = false;
 
+	/* only fs tree and subvol/snap needs ino cache */
+	if (root->root_key.objectid != BTRFS_FS_TREE_OBJECTID &&
+	    (root->root_key.objectid < BTRFS_FIRST_FREE_OBJECTID ||
+	     root->root_key.objectid > BTRFS_LAST_FREE_OBJECTID))
+		return 0;
+
 	path = btrfs_alloc_path();
 	if (!path)
 		return -ENOMEM;

commit a47d6b70e280401d553e7cac6f5750870de1ad21
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Thu May 26 06:38:30 2011 +0000

    Btrfs: setup free ino caching in a more asynchronous way
    
    For a filesystem that has lots of files in it, the first time we mount
    it with free ino caching support, it can take quite a long time to
    setup the caching before we can create new files.
    
    Here we fill the cache with [highest_ino, BTRFS_LAST_FREE_OBJECTID]
    before we start the caching thread to search through the extent tree.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 000970512624..3262cd17a12f 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -60,12 +60,12 @@ static int caching_kthread(void *data)
 
 	while (1) {
 		smp_mb();
-		if (fs_info->closing > 1)
+		if (fs_info->closing)
 			goto out;
 
 		leaf = path->nodes[0];
 		slot = path->slots[0];
-		if (path->slots[0] >= btrfs_header_nritems(leaf)) {
+		if (slot >= btrfs_header_nritems(leaf)) {
 			ret = btrfs_next_leaf(root, path);
 			if (ret < 0)
 				goto out;
@@ -100,7 +100,7 @@ static int caching_kthread(void *data)
 		if (key.type != BTRFS_INODE_ITEM_KEY)
 			goto next;
 
-		if (key.objectid >= BTRFS_LAST_FREE_OBJECTID)
+		if (key.objectid >= root->highest_objectid)
 			break;
 
 		if (last != (u64)-1 && last + 1 != key.objectid) {
@@ -114,9 +114,9 @@ static int caching_kthread(void *data)
 		path->slots[0]++;
 	}
 
-	if (last < BTRFS_LAST_FREE_OBJECTID - 1) {
+	if (last < root->highest_objectid - 1) {
 		__btrfs_add_free_space(ctl, last + 1,
-				       BTRFS_LAST_FREE_OBJECTID - last - 1);
+				       root->highest_objectid - last - 1);
 	}
 
 	spin_lock(&root->cache_lock);
@@ -136,8 +136,10 @@ static int caching_kthread(void *data)
 
 static void start_caching(struct btrfs_root *root)
 {
+	struct btrfs_free_space_ctl *ctl = root->free_ino_ctl;
 	struct task_struct *tsk;
 	int ret;
+	u64 objectid;
 
 	spin_lock(&root->cache_lock);
 	if (root->cached != BTRFS_CACHE_NO) {
@@ -156,6 +158,19 @@ static void start_caching(struct btrfs_root *root)
 		return;
 	}
 
+	/*
+	 * It can be quite time-consuming to fill the cache by searching
+	 * through the extent tree, and this can keep ino allocation path
+	 * waiting. Therefore at start we quickly find out the highest
+	 * inode number and we know we can use inode numbers which fall in
+	 * [highest_ino + 1, BTRFS_LAST_FREE_OBJECTID].
+	 */
+	ret = btrfs_find_free_objectid(root, &objectid);
+	if (!ret && objectid <= BTRFS_LAST_FREE_OBJECTID) {
+		__btrfs_add_free_space(ctl, objectid,
+				       BTRFS_LAST_FREE_OBJECTID - objectid + 1);
+	}
+
 	tsk = kthread_run(caching_kthread, root, "btrfs-ino-cache-%llu\n",
 			  root->root_key.objectid);
 	BUG_ON(IS_ERR(tsk));
@@ -209,7 +224,8 @@ void btrfs_return_ino(struct btrfs_root *root, u64 objectid)
 
 		start_caching(root);
 
-		if (objectid <= root->cache_progress)
+		if (objectid <= root->cache_progress ||
+		    objectid > root->highest_objectid)
 			__btrfs_add_free_space(ctl, objectid, 1);
 		else
 			__btrfs_add_free_space(pinned, objectid, 1);

commit 945d8962ceee6bb273365d0bdf42f763225b290f
Merge: 0d0ca30f1809 4ea028859bbd
Author: Chris Mason <chris.mason@oracle.com>
Date:   Sun May 22 12:33:42 2011 -0400

    Merge branch 'cleanups' of git://repo.or.cz/linux-2.6/btrfs-unstable into inode_numbers
    
    Conflicts:
            fs/btrfs/extent-tree.c
            fs/btrfs/free-space-cache.c
            fs/btrfs/inode.c
            fs/btrfs/tree-log.c
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

commit 82d5902d9c681be37ffa9d70482907f9f0b7ec1f
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Wed Apr 20 10:33:24 2011 +0800

    Btrfs: Support reading/writing on disk free ino cache
    
    This is similar to block group caching.
    
    We dedicate a special inode in fs tree to save free ino cache.
    
    At the very first time we create/delete a file after mount, the free ino
    cache will be loaded from disk into memory. When the fs tree is commited,
    the cache will be written back to disk.
    
    To keep compatibility, we check the root generation against the generation
    of the special inode when loading the cache, so the loading will fail
    if the btrfs filesystem was mounted in an older kernel before.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 5be62df90c4f..7967e85c72f5 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -137,6 +137,7 @@ static int caching_kthread(void *data)
 static void start_caching(struct btrfs_root *root)
 {
 	struct task_struct *tsk;
+	int ret;
 
 	spin_lock(&root->cache_lock);
 	if (root->cached != BTRFS_CACHE_NO) {
@@ -147,6 +148,14 @@ static void start_caching(struct btrfs_root *root)
 	root->cached = BTRFS_CACHE_STARTED;
 	spin_unlock(&root->cache_lock);
 
+	ret = load_free_ino_cache(root->fs_info, root);
+	if (ret == 1) {
+		spin_lock(&root->cache_lock);
+		root->cached = BTRFS_CACHE_FINISHED;
+		spin_unlock(&root->cache_lock);
+		return;
+	}
+
 	tsk = kthread_run(caching_kthread, root, "btrfs-ino-cache-%llu\n",
 			  root->root_key.objectid);
 	BUG_ON(IS_ERR(tsk));
@@ -352,6 +361,84 @@ void btrfs_init_free_ino_ctl(struct btrfs_root *root)
 	pinned->op = &pinned_free_ino_op;
 }
 
+int btrfs_save_ino_cache(struct btrfs_root *root,
+			 struct btrfs_trans_handle *trans)
+{
+	struct btrfs_free_space_ctl *ctl = root->free_ino_ctl;
+	struct btrfs_path *path;
+	struct inode *inode;
+	u64 alloc_hint = 0;
+	int ret;
+	int prealloc;
+	bool retry = false;
+
+	path = btrfs_alloc_path();
+	if (!path)
+		return -ENOMEM;
+again:
+	inode = lookup_free_ino_inode(root, path);
+	if (IS_ERR(inode) && PTR_ERR(inode) != -ENOENT) {
+		ret = PTR_ERR(inode);
+		goto out;
+	}
+
+	if (IS_ERR(inode)) {
+		BUG_ON(retry);
+		retry = true;
+
+		ret = create_free_ino_inode(root, trans, path);
+		if (ret)
+			goto out;
+		goto again;
+	}
+
+	BTRFS_I(inode)->generation = 0;
+	ret = btrfs_update_inode(trans, root, inode);
+	WARN_ON(ret);
+
+	if (i_size_read(inode) > 0) {
+		ret = btrfs_truncate_free_space_cache(root, trans, path, inode);
+		if (ret)
+			goto out_put;
+	}
+
+	spin_lock(&root->cache_lock);
+	if (root->cached != BTRFS_CACHE_FINISHED) {
+		ret = -1;
+		spin_unlock(&root->cache_lock);
+		goto out_put;
+	}
+	spin_unlock(&root->cache_lock);
+
+	spin_lock(&ctl->tree_lock);
+	prealloc = sizeof(struct btrfs_free_space) * ctl->free_extents;
+	prealloc = ALIGN(prealloc, PAGE_CACHE_SIZE);
+	prealloc += ctl->total_bitmaps * PAGE_CACHE_SIZE;
+	spin_unlock(&ctl->tree_lock);
+
+	/* Just to make sure we have enough space */
+	prealloc += 8 * PAGE_CACHE_SIZE;
+
+	ret = btrfs_check_data_free_space(inode, prealloc);
+	if (ret)
+		goto out_put;
+
+	ret = btrfs_prealloc_file_range_trans(inode, trans, 0, 0, prealloc,
+					      prealloc, prealloc, &alloc_hint);
+	if (ret)
+		goto out_put;
+	btrfs_free_reserved_data_space(inode, prealloc);
+
+out_put:
+	iput(inode);
+out:
+	if (ret == 0)
+		ret = btrfs_write_out_ino_cache(root, trans, path);
+
+	btrfs_free_path(path);
+	return ret;
+}
+
 static int btrfs_find_highest_objectid(struct btrfs_root *root, u64 *objectid)
 {
 	struct btrfs_path *path;

commit 581bb050941b4f220f84d3e5ed6dace3d42dd382
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Wed Apr 20 10:06:11 2011 +0800

    Btrfs: Cache free inode numbers in memory
    
    Currently btrfs stores the highest objectid of the fs tree, and it always
    returns (highest+1) inode number when we create a file, so inode numbers
    won't be reclaimed when we delete files, so we'll run out of inode numbers
    as we keep create/delete files in 32bits machines.
    
    This fixes it, and it works similarly to how we cache free space in block
    cgroups.
    
    We start a kernel thread to read the file tree. By scanning inode items,
    we know which chunks of inode numbers are free, and we cache them in
    an rb-tree.
    
    Because we are searching the commit root, we have to carefully handle the
    cross-transaction case.
    
    The rb-tree is a hybrid extent+bitmap tree, so if we have too many small
    chunks of inode numbers, we'll use bitmaps. Initially we allow 16K ram
    of extents, and a bitmap will be used if we exceed this threshold. The
    extents threshold is adjusted in runtime.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index c05a08f4c411..5be62df90c4f 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -16,11 +16,343 @@
  * Boston, MA 021110-1307, USA.
  */
 
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/pagemap.h>
+
 #include "ctree.h"
 #include "disk-io.h"
+#include "free-space-cache.h"
+#include "inode-map.h"
 #include "transaction.h"
 
-int btrfs_find_highest_inode(struct btrfs_root *root, u64 *objectid)
+static int caching_kthread(void *data)
+{
+	struct btrfs_root *root = data;
+	struct btrfs_fs_info *fs_info = root->fs_info;
+	struct btrfs_free_space_ctl *ctl = root->free_ino_ctl;
+	struct btrfs_key key;
+	struct btrfs_path *path;
+	struct extent_buffer *leaf;
+	u64 last = (u64)-1;
+	int slot;
+	int ret;
+
+	path = btrfs_alloc_path();
+	if (!path)
+		return -ENOMEM;
+
+	/* Since the commit root is read-only, we can safely skip locking. */
+	path->skip_locking = 1;
+	path->search_commit_root = 1;
+	path->reada = 2;
+
+	key.objectid = BTRFS_FIRST_FREE_OBJECTID;
+	key.offset = 0;
+	key.type = BTRFS_INODE_ITEM_KEY;
+again:
+	/* need to make sure the commit_root doesn't disappear */
+	mutex_lock(&root->fs_commit_mutex);
+
+	ret = btrfs_search_slot(NULL, root, &key, path, 0, 0);
+	if (ret < 0)
+		goto out;
+
+	while (1) {
+		smp_mb();
+		if (fs_info->closing > 1)
+			goto out;
+
+		leaf = path->nodes[0];
+		slot = path->slots[0];
+		if (path->slots[0] >= btrfs_header_nritems(leaf)) {
+			ret = btrfs_next_leaf(root, path);
+			if (ret < 0)
+				goto out;
+			else if (ret > 0)
+				break;
+
+			if (need_resched() ||
+			    btrfs_transaction_in_commit(fs_info)) {
+				leaf = path->nodes[0];
+
+				if (btrfs_header_nritems(leaf) == 0) {
+					WARN_ON(1);
+					break;
+				}
+
+				/*
+				 * Save the key so we can advances forward
+				 * in the next search.
+				 */
+				btrfs_item_key_to_cpu(leaf, &key, 0);
+				btrfs_release_path(root, path);
+				root->cache_progress = last;
+				mutex_unlock(&root->fs_commit_mutex);
+				schedule_timeout(1);
+				goto again;
+			} else
+				continue;
+		}
+
+		btrfs_item_key_to_cpu(leaf, &key, slot);
+
+		if (key.type != BTRFS_INODE_ITEM_KEY)
+			goto next;
+
+		if (key.objectid >= BTRFS_LAST_FREE_OBJECTID)
+			break;
+
+		if (last != (u64)-1 && last + 1 != key.objectid) {
+			__btrfs_add_free_space(ctl, last + 1,
+					       key.objectid - last - 1);
+			wake_up(&root->cache_wait);
+		}
+
+		last = key.objectid;
+next:
+		path->slots[0]++;
+	}
+
+	if (last < BTRFS_LAST_FREE_OBJECTID - 1) {
+		__btrfs_add_free_space(ctl, last + 1,
+				       BTRFS_LAST_FREE_OBJECTID - last - 1);
+	}
+
+	spin_lock(&root->cache_lock);
+	root->cached = BTRFS_CACHE_FINISHED;
+	spin_unlock(&root->cache_lock);
+
+	root->cache_progress = (u64)-1;
+	btrfs_unpin_free_ino(root);
+out:
+	wake_up(&root->cache_wait);
+	mutex_unlock(&root->fs_commit_mutex);
+
+	btrfs_free_path(path);
+
+	return ret;
+}
+
+static void start_caching(struct btrfs_root *root)
+{
+	struct task_struct *tsk;
+
+	spin_lock(&root->cache_lock);
+	if (root->cached != BTRFS_CACHE_NO) {
+		spin_unlock(&root->cache_lock);
+		return;
+	}
+
+	root->cached = BTRFS_CACHE_STARTED;
+	spin_unlock(&root->cache_lock);
+
+	tsk = kthread_run(caching_kthread, root, "btrfs-ino-cache-%llu\n",
+			  root->root_key.objectid);
+	BUG_ON(IS_ERR(tsk));
+}
+
+int btrfs_find_free_ino(struct btrfs_root *root, u64 *objectid)
+{
+again:
+	*objectid = btrfs_find_ino_for_alloc(root);
+
+	if (*objectid != 0)
+		return 0;
+
+	start_caching(root);
+
+	wait_event(root->cache_wait,
+		   root->cached == BTRFS_CACHE_FINISHED ||
+		   root->free_ino_ctl->free_space > 0);
+
+	if (root->cached == BTRFS_CACHE_FINISHED &&
+	    root->free_ino_ctl->free_space == 0)
+		return -ENOSPC;
+	else
+		goto again;
+}
+
+void btrfs_return_ino(struct btrfs_root *root, u64 objectid)
+{
+	struct btrfs_free_space_ctl *ctl = root->free_ino_ctl;
+	struct btrfs_free_space_ctl *pinned = root->free_ino_pinned;
+again:
+	if (root->cached == BTRFS_CACHE_FINISHED) {
+		__btrfs_add_free_space(ctl, objectid, 1);
+	} else {
+		/*
+		 * If we are in the process of caching free ino chunks,
+		 * to avoid adding the same inode number to the free_ino
+		 * tree twice due to cross transaction, we'll leave it
+		 * in the pinned tree until a transaction is committed
+		 * or the caching work is done.
+		 */
+
+		mutex_lock(&root->fs_commit_mutex);
+		spin_lock(&root->cache_lock);
+		if (root->cached == BTRFS_CACHE_FINISHED) {
+			spin_unlock(&root->cache_lock);
+			mutex_unlock(&root->fs_commit_mutex);
+			goto again;
+		}
+		spin_unlock(&root->cache_lock);
+
+		start_caching(root);
+
+		if (objectid <= root->cache_progress)
+			__btrfs_add_free_space(ctl, objectid, 1);
+		else
+			__btrfs_add_free_space(pinned, objectid, 1);
+
+		mutex_unlock(&root->fs_commit_mutex);
+	}
+}
+
+/*
+ * When a transaction is committed, we'll move those inode numbers which
+ * are smaller than root->cache_progress from pinned tree to free_ino tree,
+ * and others will just be dropped, because the commit root we were
+ * searching has changed.
+ *
+ * Must be called with root->fs_commit_mutex held
+ */
+void btrfs_unpin_free_ino(struct btrfs_root *root)
+{
+	struct btrfs_free_space_ctl *ctl = root->free_ino_ctl;
+	struct rb_root *rbroot = &root->free_ino_pinned->free_space_offset;
+	struct btrfs_free_space *info;
+	struct rb_node *n;
+	u64 count;
+
+	while (1) {
+		n = rb_first(rbroot);
+		if (!n)
+			break;
+
+		info = rb_entry(n, struct btrfs_free_space, offset_index);
+		BUG_ON(info->bitmap);
+
+		if (info->offset > root->cache_progress)
+			goto free;
+		else if (info->offset + info->bytes > root->cache_progress)
+			count = root->cache_progress - info->offset + 1;
+		else
+			count = info->bytes;
+
+		__btrfs_add_free_space(ctl, info->offset, count);
+free:
+		rb_erase(&info->offset_index, rbroot);
+		kfree(info);
+	}
+}
+
+#define INIT_THRESHOLD	(((1024 * 32) / 2) / sizeof(struct btrfs_free_space))
+#define INODES_PER_BITMAP (PAGE_CACHE_SIZE * 8)
+
+/*
+ * The goal is to keep the memory used by the free_ino tree won't
+ * exceed the memory if we use bitmaps only.
+ */
+static void recalculate_thresholds(struct btrfs_free_space_ctl *ctl)
+{
+	struct btrfs_free_space *info;
+	struct rb_node *n;
+	int max_ino;
+	int max_bitmaps;
+
+	n = rb_last(&ctl->free_space_offset);
+	if (!n) {
+		ctl->extents_thresh = INIT_THRESHOLD;
+		return;
+	}
+	info = rb_entry(n, struct btrfs_free_space, offset_index);
+
+	/*
+	 * Find the maximum inode number in the filesystem. Note we
+	 * ignore the fact that this can be a bitmap, because we are
+	 * not doing precise calculation.
+	 */
+	max_ino = info->bytes - 1;
+
+	max_bitmaps = ALIGN(max_ino, INODES_PER_BITMAP) / INODES_PER_BITMAP;
+	if (max_bitmaps <= ctl->total_bitmaps) {
+		ctl->extents_thresh = 0;
+		return;
+	}
+
+	ctl->extents_thresh = (max_bitmaps - ctl->total_bitmaps) *
+				PAGE_CACHE_SIZE / sizeof(*info);
+}
+
+/*
+ * We don't fall back to bitmap, if we are below the extents threshold
+ * or this chunk of inode numbers is a big one.
+ */
+static bool use_bitmap(struct btrfs_free_space_ctl *ctl,
+		       struct btrfs_free_space *info)
+{
+	if (ctl->free_extents < ctl->extents_thresh ||
+	    info->bytes > INODES_PER_BITMAP / 10)
+		return false;
+
+	return true;
+}
+
+static struct btrfs_free_space_op free_ino_op = {
+	.recalc_thresholds	= recalculate_thresholds,
+	.use_bitmap		= use_bitmap,
+};
+
+static void pinned_recalc_thresholds(struct btrfs_free_space_ctl *ctl)
+{
+}
+
+static bool pinned_use_bitmap(struct btrfs_free_space_ctl *ctl,
+			      struct btrfs_free_space *info)
+{
+	/*
+	 * We always use extents for two reasons:
+	 *
+	 * - The pinned tree is only used during the process of caching
+	 *   work.
+	 * - Make code simpler. See btrfs_unpin_free_ino().
+	 */
+	return false;
+}
+
+static struct btrfs_free_space_op pinned_free_ino_op = {
+	.recalc_thresholds	= pinned_recalc_thresholds,
+	.use_bitmap		= pinned_use_bitmap,
+};
+
+void btrfs_init_free_ino_ctl(struct btrfs_root *root)
+{
+	struct btrfs_free_space_ctl *ctl = root->free_ino_ctl;
+	struct btrfs_free_space_ctl *pinned = root->free_ino_pinned;
+
+	spin_lock_init(&ctl->tree_lock);
+	ctl->unit = 1;
+	ctl->start = 0;
+	ctl->private = NULL;
+	ctl->op = &free_ino_op;
+
+	/*
+	 * Initially we allow to use 16K of ram to cache chunks of
+	 * inode numbers before we resort to bitmaps. This is somewhat
+	 * arbitrary, but it will be adjusted in runtime.
+	 */
+	ctl->extents_thresh = INIT_THRESHOLD;
+
+	spin_lock_init(&pinned->tree_lock);
+	pinned->unit = 1;
+	pinned->start = 0;
+	pinned->private = NULL;
+	pinned->extents_thresh = 0;
+	pinned->op = &pinned_free_ino_op;
+}
+
+static int btrfs_find_highest_objectid(struct btrfs_root *root, u64 *objectid)
 {
 	struct btrfs_path *path;
 	int ret;
@@ -55,15 +387,14 @@ int btrfs_find_highest_inode(struct btrfs_root *root, u64 *objectid)
 	return ret;
 }
 
-int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
-			     struct btrfs_root *root,
-			     u64 dirid, u64 *objectid)
+int btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)
 {
 	int ret;
 	mutex_lock(&root->objectid_mutex);
 
 	if (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {
-		ret = btrfs_find_highest_inode(root, &root->highest_objectid);
+		ret = btrfs_find_highest_objectid(root,
+						  &root->highest_objectid);
 		if (ret)
 			goto out;
 	}

commit db5b493ac78e46c7b6bad22cd25d8041564cd8ea
Author: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
Date:   Wed Mar 23 08:14:16 2011 +0000

    Btrfs: cleanup some BUG_ON()
    
    This patch changes some BUG_ON() to the error return.
    (but, most callers still use BUG_ON())
    
    Signed-off-by: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index c56eb5909172..c05a08f4c411 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -30,7 +30,8 @@ int btrfs_find_highest_inode(struct btrfs_root *root, u64 *objectid)
 	int slot;
 
 	path = btrfs_alloc_path();
-	BUG_ON(!path);
+	if (!path)
+		return -ENOMEM;
 
 	search_key.objectid = BTRFS_LAST_FREE_OBJECTID;
 	search_key.type = -1;

commit 13a8a7c8c47e542b3cdb45bec3f431f96af79361
Author: Yan, Zheng <zheng.yan@oracle.com>
Date:   Mon Sep 21 15:56:00 2009 -0400

    Btrfs: do not reuse objectid of deleted snapshot/subvol
    
    The new back reference format does not allow reusing objectid of
    deleted snapshot/subvol. So we use ++highest_objectid to allocate
    objectid for new snapshot/subvol.
    
    Now we use ++highest_objectid to allocate objectid for both new inode
    and new snapshot/subvolume, so this patch removes 'find hole' code in
    btrfs_find_free_objectid.
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 9abbced1123d..c56eb5909172 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -43,9 +43,10 @@ int btrfs_find_highest_inode(struct btrfs_root *root, u64 *objectid)
 		slot = path->slots[0] - 1;
 		l = path->nodes[0];
 		btrfs_item_key_to_cpu(l, &found_key, slot);
-		*objectid = found_key.objectid;
+		*objectid = max_t(u64, found_key.objectid,
+				  BTRFS_FIRST_FREE_OBJECTID - 1);
 	} else {
-		*objectid = BTRFS_FIRST_FREE_OBJECTID;
+		*objectid = BTRFS_FIRST_FREE_OBJECTID - 1;
 	}
 	ret = 0;
 error:
@@ -53,91 +54,27 @@ int btrfs_find_highest_inode(struct btrfs_root *root, u64 *objectid)
 	return ret;
 }
 
-/*
- * walks the btree of allocated inodes and find a hole.
- */
 int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 			     struct btrfs_root *root,
 			     u64 dirid, u64 *objectid)
 {
-	struct btrfs_path *path;
-	struct btrfs_key key;
 	int ret;
-	int slot = 0;
-	u64 last_ino = 0;
-	int start_found;
-	struct extent_buffer *l;
-	struct btrfs_key search_key;
-	u64 search_start = dirid;
-
 	mutex_lock(&root->objectid_mutex);
-	if (root->last_inode_alloc >= BTRFS_FIRST_FREE_OBJECTID &&
-	    root->last_inode_alloc < BTRFS_LAST_FREE_OBJECTID) {
-		*objectid = ++root->last_inode_alloc;
-		mutex_unlock(&root->objectid_mutex);
-		return 0;
-	}
-	path = btrfs_alloc_path();
-	BUG_ON(!path);
-	search_start = max(search_start, (u64)BTRFS_FIRST_FREE_OBJECTID);
-	search_key.objectid = search_start;
-	search_key.type = 0;
-	search_key.offset = 0;
-
-	start_found = 0;
-	ret = btrfs_search_slot(trans, root, &search_key, path, 0, 0);
-	if (ret < 0)
-		goto error;
 
-	while (1) {
-		l = path->nodes[0];
-		slot = path->slots[0];
-		if (slot >= btrfs_header_nritems(l)) {
-			ret = btrfs_next_leaf(root, path);
-			if (ret == 0)
-				continue;
-			if (ret < 0)
-				goto error;
-			if (!start_found) {
-				*objectid = search_start;
-				start_found = 1;
-				goto found;
-			}
-			*objectid = last_ino > search_start ?
-				last_ino : search_start;
-			goto found;
-		}
-		btrfs_item_key_to_cpu(l, &key, slot);
-		if (key.objectid >= search_start) {
-			if (start_found) {
-				if (last_ino < search_start)
-					last_ino = search_start;
-				if (key.objectid > last_ino) {
-					*objectid = last_ino;
-					goto found;
-				}
-			} else if (key.objectid > search_start) {
-				*objectid = search_start;
-				goto found;
-			}
-		}
-		if (key.objectid >= BTRFS_LAST_FREE_OBJECTID)
-			break;
+	if (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {
+		ret = btrfs_find_highest_inode(root, &root->highest_objectid);
+		if (ret)
+			goto out;
+	}
 
-		start_found = 1;
-		last_ino = key.objectid + 1;
-		path->slots[0]++;
+	if (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {
+		ret = -ENOSPC;
+		goto out;
 	}
-	BUG_ON(1);
-found:
-	btrfs_release_path(root, path);
-	btrfs_free_path(path);
-	BUG_ON(*objectid < search_start);
-	mutex_unlock(&root->objectid_mutex);
-	return 0;
-error:
-	btrfs_release_path(root, path);
-	btrfs_free_path(path);
+
+	*objectid = ++root->highest_objectid;
+	ret = 0;
+out:
 	mutex_unlock(&root->objectid_mutex);
 	return ret;
 }

commit e63b6a6c0ffa2ebd8617cc1a10969000296831aa
Author: Joel Becker <joel.becker@oracle.com>
Date:   Tue Apr 21 12:38:30 2009 -0700

    Btrfs: Fix a trivial warning using max() of u64 vs ULL.
    
    A small warning popped up on ia64 because inode-map.c was comparing a
    u64 object id with the ULL FIRST_FREE_OBJECTID.  My first thought was
    that all the OBJECTID constants should contain the u64 cast because
    btrfs code deals entirely in u64s.  But then I saw how large that was,
    and figured I'd just fix the max() call.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index cc7334d833c9..9abbced1123d 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -79,7 +79,7 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	}
 	path = btrfs_alloc_path();
 	BUG_ON(!path);
-	search_start = max(search_start, BTRFS_FIRST_FREE_OBJECTID);
+	search_start = max(search_start, (u64)BTRFS_FIRST_FREE_OBJECTID);
 	search_key.objectid = search_start;
 	search_key.type = 0;
 	search_key.offset = 0;

commit e00f7308658622fbd483cb0d9fe41165bf9050d0
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Feb 12 14:11:25 2009 -0500

    Btrfs: remove btrfs_init_path
    
    btrfs_init_path was initially used when the path objects were on the
    stack.  Now all the work is done by btrfs_alloc_path and btrfs_init_path
    isn't required.
    
    This patch removes it, and just uses kmem_cache_zalloc to zero out the object.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 2aa79873eb46..cc7334d833c9 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -84,7 +84,6 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	search_key.type = 0;
 	search_key.offset = 0;
 
-	btrfs_init_path(path);
 	start_found = 0;
 	ret = btrfs_search_slot(trans, root, &search_key, path, 0, 0);
 	if (ret < 0)

commit d397712bcc6a759a560fd247e6053ecae091f958
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Jan 5 21:25:51 2009 -0500

    Btrfs: Fix checkpatch.pl warnings
    
    There were many, most are fixed now.  struct-funcs.c generates some warnings
    but these are bogus.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 80038c5ef7cf..2aa79873eb46 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -129,7 +129,6 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 		last_ino = key.objectid + 1;
 		path->slots[0]++;
 	}
-	// FIXME -ENOSPC
 	BUG_ON(1);
 found:
 	btrfs_release_path(root, path);

commit 5b21f2ed3f2947b5195b65c9fdbdd9e52904cc03
Author: Zheng Yan <zheng.yan@oracle.com>
Date:   Fri Sep 26 10:05:38 2008 -0400

    Btrfs: extent_map and data=ordered fixes for space balancing
    
    * Add an EXTENT_BOUNDARY state bit to keep the writepage code
    from merging data extents that are in the process of being
    relocated.  This allows us to do accounting for them properly.
    
    * The balancing code relocates data extents indepdent of the underlying
    inode.  The extent_map code was modified to properly account for
    things moving around (invalidating extent_map caches in the inode).
    
    * Don't take the drop_mutex in the create_subvol ioctl.  It isn't
    required.
    
    * Fix walking of the ordered extent list to avoid races with sys_unlink
    
    * Change the lock ordering rules.  Transaction start goes outside
    the drop_mutex.  This allows btrfs_commit_transaction to directly
    drop the relocation trees.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index cd6171c2da42..80038c5ef7cf 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -117,10 +117,14 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 					*objectid = last_ino;
 					goto found;
 				}
+			} else if (key.objectid > search_start) {
+				*objectid = search_start;
+				goto found;
 			}
 		}
 		if (key.objectid >= BTRFS_LAST_FREE_OBJECTID)
 			break;
+
 		start_found = 1;
 		last_ino = key.objectid + 1;
 		path->slots[0]++;

commit 6527cdbe68a27a2ee745f36d001aa32d0f46f370
Author: Zheng Yan <zheng.yan@oracle.com>
Date:   Fri Sep 5 16:43:53 2008 -0400

    Btrfs: Update find free objectid function for orphan cleanup code
    
    Orphan items use BTRFS_ORPHAN_OBJECTID (-5UUL) as key objectid. This
    affects the find free objectid functions, inode objectid can easily
    overflow after orphan file cleanup.
    
    ---
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 298346ae1481..cd6171c2da42 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -32,7 +32,8 @@ int btrfs_find_highest_inode(struct btrfs_root *root, u64 *objectid)
 	path = btrfs_alloc_path();
 	BUG_ON(!path);
 
-	search_key.objectid = (u64)-1;
+	search_key.objectid = BTRFS_LAST_FREE_OBJECTID;
+	search_key.type = -1;
 	search_key.offset = (u64)-1;
 	ret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);
 	if (ret < 0)
@@ -70,16 +71,17 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	u64 search_start = dirid;
 
 	mutex_lock(&root->objectid_mutex);
-	if (root->last_inode_alloc) {
+	if (root->last_inode_alloc >= BTRFS_FIRST_FREE_OBJECTID &&
+	    root->last_inode_alloc < BTRFS_LAST_FREE_OBJECTID) {
 		*objectid = ++root->last_inode_alloc;
 		mutex_unlock(&root->objectid_mutex);
 		return 0;
 	}
 	path = btrfs_alloc_path();
 	BUG_ON(!path);
-	search_start = root->last_inode_alloc;
 	search_start = max(search_start, BTRFS_FIRST_FREE_OBJECTID);
 	search_key.objectid = search_start;
+	search_key.type = 0;
 	search_key.offset = 0;
 
 	btrfs_init_path(path);
@@ -88,9 +90,6 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	if (ret < 0)
 		goto error;
 
-	if (path->slots[0] > 0)
-		path->slots[0]--;
-
 	while (1) {
 		l = path->nodes[0];
 		slot = path->slots[0];
@@ -120,13 +119,15 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 				}
 			}
 		}
+		if (key.objectid >= BTRFS_LAST_FREE_OBJECTID)
+			break;
 		start_found = 1;
 		last_ino = key.objectid + 1;
 		path->slots[0]++;
 	}
 	// FIXME -ENOSPC
+	BUG_ON(1);
 found:
-	root->last_inode_alloc = *objectid;
 	btrfs_release_path(root, path);
 	btrfs_free_path(path);
 	BUG_ON(*objectid < search_start);

commit a213501153fd66e2359e091b1612841305ba6551
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Jun 25 16:01:30 2008 -0400

    Btrfs: Replace the big fs_mutex with a collection of other locks
    
    Extent alloctions are still protected by a large alloc_mutex.
    Objectid allocations are covered by a objectid mutex
    Other btree operations are protected by a lock on individual btree nodes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index a0925eabdaa2..298346ae1481 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -69,6 +69,12 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	struct btrfs_key search_key;
 	u64 search_start = dirid;
 
+	mutex_lock(&root->objectid_mutex);
+	if (root->last_inode_alloc) {
+		*objectid = ++root->last_inode_alloc;
+		mutex_unlock(&root->objectid_mutex);
+		return 0;
+	}
 	path = btrfs_alloc_path();
 	BUG_ON(!path);
 	search_start = root->last_inode_alloc;
@@ -124,9 +130,11 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	btrfs_release_path(root, path);
 	btrfs_free_path(path);
 	BUG_ON(*objectid < search_start);
+	mutex_unlock(&root->objectid_mutex);
 	return 0;
 error:
 	btrfs_release_path(root, path);
 	btrfs_free_path(path);
+	mutex_unlock(&root->objectid_mutex);
 	return ret;
 }

commit b17854275cd297d40c6c5562fa44a472314c6c7f
Author: Yan <yanzheng@21cn.com>
Date:   Tue Jan 22 12:46:56 2008 -0500

    Fix for btrfs_find_free_objectid
    
    btrfs_find_free_objectid may return a used objectid due to arithmetic
    underflow. This bug may happen when parameter 'root' is tree root,  so
    it may cause serious problems when creating snapshot or sub-volume.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index ab74977adf5c..a0925eabdaa2 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -62,7 +62,6 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	struct btrfs_path *path;
 	struct btrfs_key key;
 	int ret;
-	u64 hole_size = 0;
 	int slot = 0;
 	u64 last_ino = 0;
 	int start_found;
@@ -109,8 +108,7 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 			if (start_found) {
 				if (last_ino < search_start)
 					last_ino = search_start;
-				hole_size = key.objectid - last_ino;
-				if (hole_size > 0) {
+				if (key.objectid > last_ino) {
 					*objectid = last_ino;
 					goto found;
 				}

commit 5f39d397dfbe140a14edecd4e73c34ce23c4f9ee
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:14:19 2007 -0400

    Btrfs: Create extent_buffer interface for large blocksizes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 405470866254..ab74977adf5c 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -24,8 +24,9 @@ int btrfs_find_highest_inode(struct btrfs_root *root, u64 *objectid)
 {
 	struct btrfs_path *path;
 	int ret;
-	struct btrfs_leaf *l;
+	struct extent_buffer *l;
 	struct btrfs_key search_key;
+	struct btrfs_key found_key;
 	int slot;
 
 	path = btrfs_alloc_path();
@@ -39,8 +40,9 @@ int btrfs_find_highest_inode(struct btrfs_root *root, u64 *objectid)
 	BUG_ON(ret == 0);
 	if (path->slots[0] > 0) {
 		slot = path->slots[0] - 1;
-		l = btrfs_buffer_leaf(path->nodes[0]);
-		*objectid = btrfs_disk_key_objectid(&l->items[slot].key);
+		l = path->nodes[0];
+		btrfs_item_key_to_cpu(l, &found_key, slot);
+		*objectid = found_key.objectid;
 	} else {
 		*objectid = BTRFS_FIRST_FREE_OBJECTID;
 	}
@@ -64,13 +66,12 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	int slot = 0;
 	u64 last_ino = 0;
 	int start_found;
-	struct btrfs_leaf *l;
+	struct extent_buffer *l;
 	struct btrfs_key search_key;
 	u64 search_start = dirid;
 
 	path = btrfs_alloc_path();
 	BUG_ON(!path);
-	search_key.flags = 0;
 	search_start = root->last_inode_alloc;
 	search_start = max(search_start, BTRFS_FIRST_FREE_OBJECTID);
 	search_key.objectid = search_start;
@@ -86,9 +87,9 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 		path->slots[0]--;
 
 	while (1) {
-		l = btrfs_buffer_leaf(path->nodes[0]);
+		l = path->nodes[0];
 		slot = path->slots[0];
-		if (slot >= btrfs_header_nritems(&l->header)) {
+		if (slot >= btrfs_header_nritems(l)) {
 			ret = btrfs_next_leaf(root, path);
 			if (ret == 0)
 				continue;
@@ -103,7 +104,7 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 				last_ino : search_start;
 			goto found;
 		}
-		btrfs_disk_key_to_cpu(&key, &l->items[slot].key);
+		btrfs_item_key_to_cpu(l, &key, slot);
 		if (key.objectid >= search_start) {
 			if (start_found) {
 				if (last_ino < search_start)

commit ec6b910fb330f29e169c9f502c3ac209515af8d1
Author: Zach Brown <zach.brown@oracle.com>
Date:   Wed Jul 11 10:00:37 2007 -0400

    Btrfs: trivial include fixups
    
    Almost none of the files including module.h need to do so,
    remove them.
    
    Include sched.h in extent-tree.c to silence a warning about cond_resched()
    being undeclared.
    
    Signed-off-by: Zach Brown <zach.brown@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 58930fc48be6..405470866254 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -16,7 +16,6 @@
  * Boston, MA 021110-1307, USA.
  */
 
-#include <linux/module.h>
 #include "ctree.h"
 #include "disk-io.h"
 #include "transaction.h"

commit 6cbd55707802b98843f953d1ae6d8f5bcd9a76c0
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Jun 12 09:07:21 2007 -0400

    Btrfs: add GPLv2
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 318e27a6378b..58930fc48be6 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -1,3 +1,21 @@
+/*
+ * Copyright (C) 2007 Oracle.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License v2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
 #include <linux/module.h>
 #include "ctree.h"
 #include "disk-io.h"

commit 1b05da2ee6217e7d55460d04335813fec25be4ca
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 10 12:13:09 2007 -0400

    Btrfs: drop the inode map tree
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index f665221409ac..318e27a6378b 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -3,12 +3,11 @@
 #include "disk-io.h"
 #include "transaction.h"
 
-int btrfs_find_highest_inode(struct btrfs_root *fs_root, u64 *objectid)
+int btrfs_find_highest_inode(struct btrfs_root *root, u64 *objectid)
 {
 	struct btrfs_path *path;
 	int ret;
 	struct btrfs_leaf *l;
-	struct btrfs_root *root = fs_root->fs_info->inode_root;
 	struct btrfs_key search_key;
 	int slot;
 
@@ -38,7 +37,7 @@ int btrfs_find_highest_inode(struct btrfs_root *fs_root, u64 *objectid)
  * walks the btree of allocated inodes and find a hole.
  */
 int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
-			     struct btrfs_root *fs_root,
+			     struct btrfs_root *root,
 			     u64 dirid, u64 *objectid)
 {
 	struct btrfs_path *path;
@@ -49,16 +48,13 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	u64 last_ino = 0;
 	int start_found;
 	struct btrfs_leaf *l;
-	struct btrfs_root *root = fs_root->fs_info->inode_root;
 	struct btrfs_key search_key;
 	u64 search_start = dirid;
 
 	path = btrfs_alloc_path();
 	BUG_ON(!path);
 	search_key.flags = 0;
-	btrfs_set_key_type(&search_key, BTRFS_INODE_MAP_ITEM_KEY);
-
-	search_start = fs_root->fs_info->last_inode_alloc;
+	search_start = root->last_inode_alloc;
 	search_start = max(search_start, BTRFS_FIRST_FREE_OBJECTID);
 	search_key.objectid = search_start;
 	search_key.offset = 0;
@@ -108,7 +104,7 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	}
 	// FIXME -ENOSPC
 found:
-	root->fs_info->last_inode_alloc = *objectid;
+	root->last_inode_alloc = *objectid;
 	btrfs_release_path(root, path);
 	btrfs_free_path(path);
 	BUG_ON(*objectid < search_start);
@@ -118,56 +114,3 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	btrfs_free_path(path);
 	return ret;
 }
-
-int btrfs_insert_inode_map(struct btrfs_trans_handle *trans,
-			   struct btrfs_root *fs_root,
-			   u64 objectid, struct btrfs_key *location)
-{
-	int ret = 0;
-	struct btrfs_path *path;
-	struct btrfs_inode_map_item *inode_item;
-	struct btrfs_key key;
-	struct btrfs_root *inode_root = fs_root->fs_info->inode_root;
-
-	key.objectid = objectid;
-	key.flags = 0;
-	btrfs_set_key_type(&key, BTRFS_INODE_MAP_ITEM_KEY);
-	key.offset = 0;
-	path = btrfs_alloc_path();
-	BUG_ON(!path);
-	btrfs_init_path(path);
-	ret = btrfs_insert_empty_item(trans, inode_root, path, &key,
-				      sizeof(struct btrfs_inode_map_item));
-	if (ret)
-		goto out;
-
-	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
-				    path->slots[0], struct btrfs_inode_map_item);
-	btrfs_cpu_key_to_disk(&inode_item->key, location);
-	btrfs_mark_buffer_dirty(path->nodes[0]);
-	if (objectid > fs_root->fs_info->highest_inode)
-		fs_root->fs_info->highest_inode = objectid;
-out:
-	btrfs_release_path(inode_root, path);
-	btrfs_free_path(path);
-	return ret;
-}
-
-int btrfs_lookup_inode_map(struct btrfs_trans_handle *trans,
-			   struct btrfs_root *fs_root, struct btrfs_path *path,
-			   u64 objectid, int mod)
-{
-	int ret;
-	struct btrfs_key key;
-	int ins_len = mod < 0 ? -1 : 0;
-	int cow = mod != 0;
-	struct btrfs_root *inode_root = fs_root->fs_info->inode_root;
-
-	key.objectid = objectid;
-	key.flags = 0;
-	key.offset = 0;
-	btrfs_set_key_type(&key, BTRFS_INODE_MAP_ITEM_KEY);
-	ret = btrfs_search_slot(trans, inode_root, &key, path, ins_len, cow);
-	return ret;
-}
-

commit 5be6f7f174146d91039a27ebb2f1b4ac599172b3
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Apr 5 13:35:25 2007 -0400

    Btrfs: dirindex optimizations
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 329edb42897e..f665221409ac 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -3,6 +3,37 @@
 #include "disk-io.h"
 #include "transaction.h"
 
+int btrfs_find_highest_inode(struct btrfs_root *fs_root, u64 *objectid)
+{
+	struct btrfs_path *path;
+	int ret;
+	struct btrfs_leaf *l;
+	struct btrfs_root *root = fs_root->fs_info->inode_root;
+	struct btrfs_key search_key;
+	int slot;
+
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
+
+	search_key.objectid = (u64)-1;
+	search_key.offset = (u64)-1;
+	ret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);
+	if (ret < 0)
+		goto error;
+	BUG_ON(ret == 0);
+	if (path->slots[0] > 0) {
+		slot = path->slots[0] - 1;
+		l = btrfs_buffer_leaf(path->nodes[0]);
+		*objectid = btrfs_disk_key_objectid(&l->items[slot].key);
+	} else {
+		*objectid = BTRFS_FIRST_FREE_OBJECTID;
+	}
+	ret = 0;
+error:
+	btrfs_free_path(path);
+	return ret;
+}
+
 /*
  * walks the btree of allocated inodes and find a hole.
  */
@@ -28,21 +59,6 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	btrfs_set_key_type(&search_key, BTRFS_INODE_MAP_ITEM_KEY);
 
 	search_start = fs_root->fs_info->last_inode_alloc;
-	if (search_start == 0) {
-		struct btrfs_disk_key *last_key;
-		btrfs_init_path(path);
-		search_key.objectid = (u64)-1;
-		search_key.offset = (u64)-1;
-		ret = btrfs_search_slot(trans, root, &search_key, path, 0, 0);
-		if (ret < 0)
-			goto error;
-		BUG_ON(ret == 0);
-		if (path->slots[0] > 0)
-			path->slots[0]--;
-		l = btrfs_buffer_leaf(path->nodes[0]);
-		last_key = &l->items[path->slots[0]].key;
-		search_start = btrfs_disk_key_objectid(last_key);
-	}
 	search_start = max(search_start, BTRFS_FIRST_FREE_OBJECTID);
 	search_key.objectid = search_start;
 	search_key.offset = 0;
@@ -129,6 +145,8 @@ int btrfs_insert_inode_map(struct btrfs_trans_handle *trans,
 				    path->slots[0], struct btrfs_inode_map_item);
 	btrfs_cpu_key_to_disk(&inode_item->key, location);
 	btrfs_mark_buffer_dirty(path->nodes[0]);
+	if (objectid > fs_root->fs_info->highest_inode)
+		fs_root->fs_info->highest_inode = objectid;
 out:
 	btrfs_release_path(inode_root, path);
 	btrfs_free_path(path);

commit b1a4d96509a78ad234d94e0b914b289c60d2969d
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Apr 4 15:27:52 2007 -0400

    Btrfs: tweak the inode-map and free extent search starts on cold mount
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index b3de823eb628..329edb42897e 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -22,17 +22,31 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	struct btrfs_key search_key;
 	u64 search_start = dirid;
 
-	if (fs_root->fs_info->last_inode_alloc_dirid == dirid)
-		search_start = fs_root->fs_info->last_inode_alloc;
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
+	search_key.flags = 0;
+	btrfs_set_key_type(&search_key, BTRFS_INODE_MAP_ITEM_KEY);
 
+	search_start = fs_root->fs_info->last_inode_alloc;
+	if (search_start == 0) {
+		struct btrfs_disk_key *last_key;
+		btrfs_init_path(path);
+		search_key.objectid = (u64)-1;
+		search_key.offset = (u64)-1;
+		ret = btrfs_search_slot(trans, root, &search_key, path, 0, 0);
+		if (ret < 0)
+			goto error;
+		BUG_ON(ret == 0);
+		if (path->slots[0] > 0)
+			path->slots[0]--;
+		l = btrfs_buffer_leaf(path->nodes[0]);
+		last_key = &l->items[path->slots[0]].key;
+		search_start = btrfs_disk_key_objectid(last_key);
+	}
 	search_start = max(search_start, BTRFS_FIRST_FREE_OBJECTID);
 	search_key.objectid = search_start;
-	search_key.flags = 0;
-	btrfs_set_key_type(&search_key, BTRFS_INODE_MAP_ITEM_KEY);
 	search_key.offset = 0;
 
-	path = btrfs_alloc_path();
-	BUG_ON(!path);
 	btrfs_init_path(path);
 	start_found = 0;
 	ret = btrfs_search_slot(trans, root, &search_key, path, 0, 0);
@@ -79,7 +93,6 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	// FIXME -ENOSPC
 found:
 	root->fs_info->last_inode_alloc = *objectid;
-	root->fs_info->last_inode_alloc_dirid = dirid;
 	btrfs_release_path(root, path);
 	btrfs_free_path(path);
 	BUG_ON(*objectid < search_start);

commit 7cfcc17e7f2334a0503331264c1340de4e564c85
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Apr 2 14:53:59 2007 -0400

    Btrfs: corruptions fixed
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index fa4adb81b149..b3de823eb628 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -10,7 +10,7 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 			     struct btrfs_root *fs_root,
 			     u64 dirid, u64 *objectid)
 {
-	struct btrfs_path path;
+	struct btrfs_path *path;
 	struct btrfs_key key;
 	int ret;
 	u64 hole_size = 0;
@@ -31,20 +31,22 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	btrfs_set_key_type(&search_key, BTRFS_INODE_MAP_ITEM_KEY);
 	search_key.offset = 0;
 
-	btrfs_init_path(&path);
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
+	btrfs_init_path(path);
 	start_found = 0;
-	ret = btrfs_search_slot(trans, root, &search_key, &path, 0, 0);
+	ret = btrfs_search_slot(trans, root, &search_key, path, 0, 0);
 	if (ret < 0)
 		goto error;
 
-	if (path.slots[0] > 0)
-		path.slots[0]--;
+	if (path->slots[0] > 0)
+		path->slots[0]--;
 
 	while (1) {
-		l = btrfs_buffer_leaf(path.nodes[0]);
-		slot = path.slots[0];
+		l = btrfs_buffer_leaf(path->nodes[0]);
+		slot = path->slots[0];
 		if (slot >= btrfs_header_nritems(&l->header)) {
-			ret = btrfs_next_leaf(root, &path);
+			ret = btrfs_next_leaf(root, path);
 			if (ret == 0)
 				continue;
 			if (ret < 0)
@@ -72,17 +74,19 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 		}
 		start_found = 1;
 		last_ino = key.objectid + 1;
-		path.slots[0]++;
+		path->slots[0]++;
 	}
 	// FIXME -ENOSPC
 found:
 	root->fs_info->last_inode_alloc = *objectid;
 	root->fs_info->last_inode_alloc_dirid = dirid;
-	btrfs_release_path(root, &path);
+	btrfs_release_path(root, path);
+	btrfs_free_path(path);
 	BUG_ON(*objectid < search_start);
 	return 0;
 error:
-	btrfs_release_path(root, &path);
+	btrfs_release_path(root, path);
+	btrfs_free_path(path);
 	return ret;
 }
 
@@ -91,7 +95,7 @@ int btrfs_insert_inode_map(struct btrfs_trans_handle *trans,
 			   u64 objectid, struct btrfs_key *location)
 {
 	int ret = 0;
-	struct btrfs_path path;
+	struct btrfs_path *path;
 	struct btrfs_inode_map_item *inode_item;
 	struct btrfs_key key;
 	struct btrfs_root *inode_root = fs_root->fs_info->inode_root;
@@ -100,18 +104,21 @@ int btrfs_insert_inode_map(struct btrfs_trans_handle *trans,
 	key.flags = 0;
 	btrfs_set_key_type(&key, BTRFS_INODE_MAP_ITEM_KEY);
 	key.offset = 0;
-	btrfs_init_path(&path);
-	ret = btrfs_insert_empty_item(trans, inode_root, &path, &key,
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
+	btrfs_init_path(path);
+	ret = btrfs_insert_empty_item(trans, inode_root, path, &key,
 				      sizeof(struct btrfs_inode_map_item));
 	if (ret)
 		goto out;
 
-	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]),
-				    path.slots[0], struct btrfs_inode_map_item);
+	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
+				    path->slots[0], struct btrfs_inode_map_item);
 	btrfs_cpu_key_to_disk(&inode_item->key, location);
-	btrfs_mark_buffer_dirty(path.nodes[0]);
+	btrfs_mark_buffer_dirty(path->nodes[0]);
 out:
-	btrfs_release_path(inode_root, &path);
+	btrfs_release_path(inode_root, path);
+	btrfs_free_path(path);
 	return ret;
 }
 

commit d6025579531b7ea170ba283b171ff7a6bf7d0e12
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Mar 30 14:27:56 2007 -0400

    Btrfs: corruption hunt continues
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 1b2c5e043508..fa4adb81b149 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -109,7 +109,7 @@ int btrfs_insert_inode_map(struct btrfs_trans_handle *trans,
 	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]),
 				    path.slots[0], struct btrfs_inode_map_item);
 	btrfs_cpu_key_to_disk(&inode_item->key, location);
-	mark_buffer_dirty(path.nodes[0]);
+	btrfs_mark_buffer_dirty(path.nodes[0]);
 out:
 	btrfs_release_path(inode_root, &path);
 	return ret;

commit 6407bf6d7c449cbfb0a39d985194e265eda3baf4
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Mar 27 06:33:00 2007 -0400

    Btrfs: reference counts on data extents
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index ad2d375b830d..1b2c5e043508 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -25,6 +25,7 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	if (fs_root->fs_info->last_inode_alloc_dirid == dirid)
 		search_start = fs_root->fs_info->last_inode_alloc;
 
+	search_start = max(search_start, BTRFS_FIRST_FREE_OBJECTID);
 	search_key.objectid = search_start;
 	search_key.flags = 0;
 	btrfs_set_key_type(&search_key, BTRFS_INODE_MAP_ITEM_KEY);

commit d571976292839cec05a2820b08f7629b145ed157
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Mar 23 10:01:08 2007 -0400

    btrfs_create, btrfs_write_super, btrfs_sync_fs
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index c45aec258bd5..ad2d375b830d 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -108,6 +108,7 @@ int btrfs_insert_inode_map(struct btrfs_trans_handle *trans,
 	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]),
 				    path.slots[0], struct btrfs_inode_map_item);
 	btrfs_cpu_key_to_disk(&inode_item->key, location);
+	mark_buffer_dirty(path.nodes[0]);
 out:
 	btrfs_release_path(inode_root, &path);
 	return ret;

commit e20d96d64f9cf9288ffecc9ad4714e91c3b97ca8
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Mar 22 12:13:20 2007 -0400

    Mountable btrfs, with readdir
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index c7fda3bf7b21..c45aec258bd5 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -15,7 +15,7 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 	int ret;
 	u64 hole_size = 0;
 	int slot = 0;
-	u64 last_ino;
+	u64 last_ino = 0;
 	int start_found;
 	struct btrfs_leaf *l;
 	struct btrfs_root *root = fs_root->fs_info->inode_root;
@@ -40,7 +40,7 @@ int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
 		path.slots[0]--;
 
 	while (1) {
-		l = &path.nodes[0]->leaf;
+		l = btrfs_buffer_leaf(path.nodes[0]);
 		slot = path.slots[0];
 		if (slot >= btrfs_header_nritems(&l->header)) {
 			ret = btrfs_next_leaf(root, &path);
@@ -105,8 +105,8 @@ int btrfs_insert_inode_map(struct btrfs_trans_handle *trans,
 	if (ret)
 		goto out;
 
-	inode_item = btrfs_item_ptr(&path.nodes[0]->leaf, path.slots[0],
-				  struct btrfs_inode_map_item);
+	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]),
+				    path.slots[0], struct btrfs_inode_map_item);
 	btrfs_cpu_key_to_disk(&inode_item->key, location);
 out:
 	btrfs_release_path(inode_root, &path);

commit 2e635a278354a1a7951e16cfea4c247d6d0e7c99
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Mar 21 11:12:56 2007 -0400

    Btrfs: initial move to kernel module land
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index f412b3392135..c7fda3bf7b21 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -1,7 +1,4 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include "kerncompat.h"
-#include "radix-tree.h"
+#include <linux/module.h>
 #include "ctree.h"
 #include "disk-io.h"
 #include "transaction.h"

commit 9f5fae2fe6dc35b46bf56183f11398451851cb3f
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Mar 20 14:38:32 2007 -0400

    Btrfs: Add inode map, and the start of file extent items
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
new file mode 100644
index 000000000000..f412b3392135
--- /dev/null
+++ b/fs/btrfs/inode-map.c
@@ -0,0 +1,136 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include "kerncompat.h"
+#include "radix-tree.h"
+#include "ctree.h"
+#include "disk-io.h"
+#include "transaction.h"
+
+/*
+ * walks the btree of allocated inodes and find a hole.
+ */
+int btrfs_find_free_objectid(struct btrfs_trans_handle *trans,
+			     struct btrfs_root *fs_root,
+			     u64 dirid, u64 *objectid)
+{
+	struct btrfs_path path;
+	struct btrfs_key key;
+	int ret;
+	u64 hole_size = 0;
+	int slot = 0;
+	u64 last_ino;
+	int start_found;
+	struct btrfs_leaf *l;
+	struct btrfs_root *root = fs_root->fs_info->inode_root;
+	struct btrfs_key search_key;
+	u64 search_start = dirid;
+
+	if (fs_root->fs_info->last_inode_alloc_dirid == dirid)
+		search_start = fs_root->fs_info->last_inode_alloc;
+
+	search_key.objectid = search_start;
+	search_key.flags = 0;
+	btrfs_set_key_type(&search_key, BTRFS_INODE_MAP_ITEM_KEY);
+	search_key.offset = 0;
+
+	btrfs_init_path(&path);
+	start_found = 0;
+	ret = btrfs_search_slot(trans, root, &search_key, &path, 0, 0);
+	if (ret < 0)
+		goto error;
+
+	if (path.slots[0] > 0)
+		path.slots[0]--;
+
+	while (1) {
+		l = &path.nodes[0]->leaf;
+		slot = path.slots[0];
+		if (slot >= btrfs_header_nritems(&l->header)) {
+			ret = btrfs_next_leaf(root, &path);
+			if (ret == 0)
+				continue;
+			if (ret < 0)
+				goto error;
+			if (!start_found) {
+				*objectid = search_start;
+				start_found = 1;
+				goto found;
+			}
+			*objectid = last_ino > search_start ?
+				last_ino : search_start;
+			goto found;
+		}
+		btrfs_disk_key_to_cpu(&key, &l->items[slot].key);
+		if (key.objectid >= search_start) {
+			if (start_found) {
+				if (last_ino < search_start)
+					last_ino = search_start;
+				hole_size = key.objectid - last_ino;
+				if (hole_size > 0) {
+					*objectid = last_ino;
+					goto found;
+				}
+			}
+		}
+		start_found = 1;
+		last_ino = key.objectid + 1;
+		path.slots[0]++;
+	}
+	// FIXME -ENOSPC
+found:
+	root->fs_info->last_inode_alloc = *objectid;
+	root->fs_info->last_inode_alloc_dirid = dirid;
+	btrfs_release_path(root, &path);
+	BUG_ON(*objectid < search_start);
+	return 0;
+error:
+	btrfs_release_path(root, &path);
+	return ret;
+}
+
+int btrfs_insert_inode_map(struct btrfs_trans_handle *trans,
+			   struct btrfs_root *fs_root,
+			   u64 objectid, struct btrfs_key *location)
+{
+	int ret = 0;
+	struct btrfs_path path;
+	struct btrfs_inode_map_item *inode_item;
+	struct btrfs_key key;
+	struct btrfs_root *inode_root = fs_root->fs_info->inode_root;
+
+	key.objectid = objectid;
+	key.flags = 0;
+	btrfs_set_key_type(&key, BTRFS_INODE_MAP_ITEM_KEY);
+	key.offset = 0;
+	btrfs_init_path(&path);
+	ret = btrfs_insert_empty_item(trans, inode_root, &path, &key,
+				      sizeof(struct btrfs_inode_map_item));
+	if (ret)
+		goto out;
+
+	inode_item = btrfs_item_ptr(&path.nodes[0]->leaf, path.slots[0],
+				  struct btrfs_inode_map_item);
+	btrfs_cpu_key_to_disk(&inode_item->key, location);
+out:
+	btrfs_release_path(inode_root, &path);
+	return ret;
+}
+
+int btrfs_lookup_inode_map(struct btrfs_trans_handle *trans,
+			   struct btrfs_root *fs_root, struct btrfs_path *path,
+			   u64 objectid, int mod)
+{
+	int ret;
+	struct btrfs_key key;
+	int ins_len = mod < 0 ? -1 : 0;
+	int cow = mod != 0;
+	struct btrfs_root *inode_root = fs_root->fs_info->inode_root;
+
+	key.objectid = objectid;
+	key.flags = 0;
+	key.offset = 0;
+	btrfs_set_key_type(&key, BTRFS_INODE_MAP_ITEM_KEY);
+	ret = btrfs_search_slot(trans, inode_root, &key, path, ins_len, cow);
+	return ret;
+}
+
