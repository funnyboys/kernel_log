commit e3de9b159a927fc1fd65e4d090b981b781c58926
Author: Anand Jain <anand.jain@oracle.com>
Date:   Fri Apr 12 16:02:59 2019 +0800

    btrfs: cleanup btrfs_setxattr_trans and drop transaction parameter
    
    Previous patch made sure that btrfs_setxattr_trans() is called only when
    transaction NULL.  Clean up btrfs_setxattr_trans() and drop the
    parameter.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 7fe6551bc59b..a0af1b952c4d 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -96,7 +96,7 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
 	if (trans)
 		ret = btrfs_setxattr(trans, inode, name, value, size, 0);
 	else
-		ret = btrfs_setxattr_trans(NULL, inode, name, value, size, 0);
+		ret = btrfs_setxattr_trans(inode, name, value, size, 0);
 
 out:
 	kfree(value);

commit 04e6863b19c72279bcbeffa26d85d649ab9c8205
Author: Anand Jain <anand.jain@oracle.com>
Date:   Fri Apr 12 16:02:58 2019 +0800

    btrfs: split btrfs_setxattr calls regarding transaction
    
    When the caller has already created the transaction handle,
    btrfs_setxattr() will use it. Also adds assert in btrfs_setxattr().
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index d3b04c6abc61..7fe6551bc59b 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -93,7 +93,11 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
 			goto out;
 	}
 
-	ret = btrfs_setxattr_trans(trans, inode, name, value, size, 0);
+	if (trans)
+		ret = btrfs_setxattr(trans, inode, name, value, size, 0);
+	else
+		ret = btrfs_setxattr_trans(NULL, inode, name, value, size, 0);
+
 out:
 	kfree(value);
 

commit cac237ae095f6d92bda05ccd6df349d20f1a4bfc
Author: Anand Jain <anand.jain@oracle.com>
Date:   Fri Apr 12 16:02:54 2019 +0800

    btrfs: rename btrfs_setxattr to btrfs_setxattr_trans
    
    Rename btrfs_setxattr() to btrfs_setxattr_trans(), so that do_setxattr()
    can be renamed to btrfs_setxattr().
    Preparatory patch, no functional changes.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 5810463dc6d2..d3b04c6abc61 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -93,7 +93,7 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
 			goto out;
 	}
 
-	ret = btrfs_setxattr(trans, inode, name, value, size, 0);
+	ret = btrfs_setxattr_trans(trans, inode, name, value, size, 0);
 out:
 	kfree(value);
 

commit a0873490660246db587849a9e172f2b7b21fa88a
Author: Filipe Manana <fdmanana@suse.com>
Date:   Thu Dec 13 21:16:56 2018 +0000

    Btrfs: setup a nofs context for memory allocation at __btrfs_set_acl
    
    We are holding a transaction handle when setting an acl, therefore we can
    not allocate the xattr value buffer using GFP_KERNEL, as we could deadlock
    if reclaim is triggered by the allocation, therefore setup a nofs context.
    
    Fixes: 39a27ec1004e8 ("btrfs: use GFP_KERNEL for xattr and acl allocations")
    CC: stable@vger.kernel.org # 4.9+
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 3b66c957ea6f..5810463dc6d2 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -9,6 +9,7 @@
 #include <linux/posix_acl_xattr.h>
 #include <linux/posix_acl.h>
 #include <linux/sched.h>
+#include <linux/sched/mm.h>
 #include <linux/slab.h>
 
 #include "ctree.h"
@@ -72,8 +73,16 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
 	}
 
 	if (acl) {
+		unsigned int nofs_flag;
+
 		size = posix_acl_xattr_size(acl->a_count);
+		/*
+		 * We're holding a transaction handle, so use a NOFS memory
+		 * allocation context to avoid deadlock if reclaim happens.
+		 */
+		nofs_flag = memalloc_nofs_save();
 		value = kmalloc(size, GFP_KERNEL);
+		memalloc_nofs_restore(nofs_flag);
 		if (!value) {
 			ret = -ENOMEM;
 			goto out;

commit 4de426cd394e4de4d3039aff7d20724d7d988dcf
Author: Chengguang Xu <cgxu519@gmx.com>
Date:   Wed Jun 27 12:16:38 2018 +0800

    btrfs: remove unnecessary curly braces in btrfs_get_acl
    
    It's only coding style fix not functinal change.  When if/else has only
    one statement then the braces are not needed.
    
    Signed-off-by: Chengguang Xu <cgxu519@gmx.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 7d673ec9e54a..3b66c957ea6f 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -40,13 +40,12 @@ struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 			return ERR_PTR(-ENOMEM);
 		size = btrfs_getxattr(inode, name, value, size);
 	}
-	if (size > 0) {
+	if (size > 0)
 		acl = posix_acl_from_xattr(&init_user_ns, value, size);
-	} else if (size == -ENODATA || size == 0) {
+	else if (size == -ENODATA || size == 0)
 		acl = NULL;
-	} else {
+	else
 		acl = ERR_PTR(size);
-	}
 	kfree(value);
 
 	return acl;

commit dc7789ef8785ea996ecf302a89415439ccf10faa
Author: Chengguang Xu <cgxu519@gmx.com>
Date:   Wed Jun 27 12:16:37 2018 +0800

    btrfs: avoid error code override in btrfs_get_acl
    
    It's not good to override the error code when failing from
    btrfs_getxattr() in btrfs_get_acl() because it hides the real reason of
    the failure.
    
    Signed-off-by: Chengguang Xu <cgxu519@gmx.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index a1d7211c8884..7d673ec9e54a 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -45,7 +45,7 @@ struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 	} else if (size == -ENODATA || size == 0) {
 		acl = NULL;
 	} else {
-		acl = ERR_PTR(-EIO);
+		acl = ERR_PTR(size);
 	}
 	kfree(value);
 

commit 5ee552da503961e6df785b8495bcfc98eb30eb2a
Author: Chengguang Xu <cgxu519@gmx.com>
Date:   Wed Jun 27 12:16:36 2018 +0800

    btrfs: remove unnecessary -ERANGE check in btrfs_get_acl
    
    There is no chance to get into -ERANGE error condition because we first
    call btrfs_getxattr to get the length of the attribute, then we do a
    subsequent call with the size from the first call.  Between the 2 calls
    the size shouldn't change. So remove the unnecessary -ERANGE error
    check.
    
    Signed-off-by: Chengguang Xu <cgxu519@gmx.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 83fdd80c51c6..a1d7211c8884 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -42,7 +42,7 @@ struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 	}
 	if (size > 0) {
 		acl = posix_acl_from_xattr(&init_user_ns, value, size);
-	} else if (size == -ERANGE || size == -ENODATA || size == 0) {
+	} else if (size == -ENODATA || size == 0) {
 		acl = NULL;
 	} else {
 		acl = ERR_PTR(-EIO);

commit 7e35eab958e30d15743b1f9928d15b559a6e432d
Author: Chengguang Xu <cgxu519@gmx.com>
Date:   Wed Jun 27 12:16:35 2018 +0800

    btrfs: replace empty string with NULL when getting attribute length in btrfs_get_acl
    
    In btrfs_get_acl() the first call of btr_getxattr() is for getting the
    length of attribute, the value buffer is never used in this case. So
    it's better to replace empty string with NULL.
    
    Signed-off-by: Chengguang Xu <cgxu519@gmx.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 60f83a3bd77c..83fdd80c51c6 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -33,7 +33,7 @@ struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 		return ERR_PTR(-EINVAL);
 	}
 
-	size = btrfs_getxattr(inode, name, "", 0);
+	size = btrfs_getxattr(inode, name, NULL, 0);
 	if (size > 0) {
 		value = kzalloc(size, GFP_KERNEL);
 		if (!value)

commit ab3629ed86ec43e7d95cf087d0b5a9d403fcd822
Author: Chengguang Xu <cgxu519@gmx.com>
Date:   Wed Jun 27 12:16:34 2018 +0800

    btrfs: return error instead of crash when detecting unexpected type in btrfs_get_acl
    
    The caller of btrfs_get_acl() checks error condition so there is no
    impact from this change. In practice there is no chance to get into
    default case of switch statement because VFS has already checked the
    type.
    
    Signed-off-by: Chengguang Xu <cgxu519@gmx.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 15e1dfef56a5..60f83a3bd77c 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -30,7 +30,7 @@ struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 		name = XATTR_NAME_POSIX_ACL_DEFAULT;
 		break;
 	default:
-		BUG();
+		return ERR_PTR(-EINVAL);
 	}
 
 	size = btrfs_getxattr(inode, name, "", 0);

commit c1d7c514f745628eb096c5cbb10737855879ae25
Author: David Sterba <dsterba@suse.com>
Date:   Tue Apr 3 19:23:33 2018 +0200

    btrfs: replace GPL boilerplate by SPDX -- sources
    
    Remove GPL boilerplate text (long, short, one-line) and keep the rest,
    ie. personal, company or original source copyright statements. Add the
    SPDX header.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 0066d95b133f..15e1dfef56a5 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -1,19 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2007 Red Hat.  All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License v2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public
- * License along with this program; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 021110-1307, USA.
  */
 
 #include <linux/fs.h>

commit e7ab0af6c30f763e41a1206318d4756d270e93a0
Author: David Sterba <dsterba@suse.com>
Date:   Tue Mar 27 20:08:28 2018 +0200

    btrfs: remove stale comments about fs_mutex
    
    The fs_mutex has been killed in 2008, a213501153fd66e2 ("Btrfs: Replace
    the big fs_mutex with a collection of other locks"), still remembered in
    some comments.
    
    We don't have any extra needs for locking in the ACL handlers.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index f8a1bdf06b2a..0066d95b133f 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -65,9 +65,6 @@ struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 	return acl;
 }
 
-/*
- * Needs to be called with fs_mutex held
- */
 static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
 			 struct inode *inode, struct posix_acl *acl, int type)
 {
@@ -127,11 +124,6 @@ int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 	return ret;
 }
 
-/*
- * btrfs_init_acl is already generally called under fs_mutex, so the locking
- * stuff has been fixed to work with that.  If the locking stuff changes, we
- * need to re-evaluate the acl locking stuff.
- */
 int btrfs_init_acl(struct btrfs_trans_handle *trans,
 		   struct inode *inode, struct inode *dir)
 {

commit 7852781d94b30096ca0f273aa776d2dbcca6d640
Author: David Sterba <dsterba@suse.com>
Date:   Tue Feb 27 15:48:52 2018 +0100

    btrfs: drop underscores from exported xattr functions
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 1ba49ebe67da..f8a1bdf06b2a 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -46,12 +46,12 @@ struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 		BUG();
 	}
 
-	size = __btrfs_getxattr(inode, name, "", 0);
+	size = btrfs_getxattr(inode, name, "", 0);
 	if (size > 0) {
 		value = kzalloc(size, GFP_KERNEL);
 		if (!value)
 			return ERR_PTR(-ENOMEM);
-		size = __btrfs_getxattr(inode, name, value, size);
+		size = btrfs_getxattr(inode, name, value, size);
 	}
 	if (size > 0) {
 		acl = posix_acl_from_xattr(&init_user_ns, value, size);
@@ -101,7 +101,7 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
 			goto out;
 	}
 
-	ret = __btrfs_setxattr(trans, inode, name, value, size, 0);
+	ret = btrfs_setxattr(trans, inode, name, value, size, 0);
 out:
 	kfree(value);
 

commit d7d824966530acfe32b94d1ed672e6fe1638cd68
Author: Ernesto A. Fernández <ernesto.mnd.fernandez@gmail.com>
Date:   Wed Aug 2 03:18:27 2017 -0300

    btrfs: preserve i_mode if __btrfs_set_acl() fails
    
    When changing a file's acl mask, btrfs_set_acl() will first set the
    group bits of i_mode to the value of the mask, and only then set the
    actual extended attribute representing the new acl.
    
    If the second part fails (due to lack of space, for example) and the
    file had no acl attribute to begin with, the system will from now on
    assume that the mask permission bits are actual group permission bits,
    potentially granting access to the wrong users.
    
    Prevent this by restoring the original mode bits if __btrfs_set_acl
    fails.
    
    Signed-off-by: Ernesto A. Fernández <ernesto.mnd.fernandez@gmail.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 8d8370ddb6b2..1ba49ebe67da 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -114,13 +114,17 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
 int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 {
 	int ret;
+	umode_t old_mode = inode->i_mode;
 
 	if (type == ACL_TYPE_ACCESS && acl) {
 		ret = posix_acl_update_mode(inode, &inode->i_mode, &acl);
 		if (ret)
 			return ret;
 	}
-	return __btrfs_set_acl(NULL, inode, acl, type);
+	ret = __btrfs_set_acl(NULL, inode, acl, type);
+	if (ret)
+		inode->i_mode = old_mode;
+	return ret;
 }
 
 /*

commit b7f8a09f8097db776b8d160862540e4fc1f51296
Author: Jan Kara <jack@suse.cz>
Date:   Thu Jun 22 15:31:07 2017 +0200

    btrfs: Don't clear SGID when inheriting ACLs
    
    When new directory 'DIR1' is created in a directory 'DIR0' with SGID bit
    set, DIR1 is expected to have SGID bit set (and owning group equal to
    the owning group of 'DIR0'). However when 'DIR0' also has some default
    ACLs that 'DIR1' inherits, setting these ACLs will result in SGID bit on
    'DIR1' to get cleared if user is not member of the owning group.
    
    Fix the problem by moving posix_acl_update_mode() out of
    __btrfs_set_acl() into btrfs_set_acl(). That way the function will not be
    called when inheriting ACLs which is what we want as it prevents SGID
    bit clearing and the mode has been properly set by posix_acl_create()
    anyway.
    
    Fixes: 073931017b49d9458aa351605b43a7e34598caef
    CC: stable@vger.kernel.org
    CC: linux-btrfs@vger.kernel.org
    CC: David Sterba <dsterba@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 247b8dfaf6e5..8d8370ddb6b2 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -78,12 +78,6 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
-		if (acl) {
-			ret = posix_acl_update_mode(inode, &inode->i_mode, &acl);
-			if (ret)
-				return ret;
-		}
-		ret = 0;
 		break;
 	case ACL_TYPE_DEFAULT:
 		if (!S_ISDIR(inode->i_mode))
@@ -119,6 +113,13 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
 
 int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 {
+	int ret;
+
+	if (type == ACL_TYPE_ACCESS && acl) {
+		ret = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+		if (ret)
+			return ret;
+	}
 	return __btrfs_set_acl(NULL, inode, acl, type);
 }
 

commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 53bb7af4e5f0..247b8dfaf6e5 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -79,11 +79,9 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
-			ret = posix_acl_equiv_mode(acl, &inode->i_mode);
-			if (ret < 0)
+			ret = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+			if (ret)
 				return ret;
-			if (ret == 0)
-				acl = NULL;
 		}
 		ret = 0;
 		break;

commit a60617d0ae51c22f652b6fcf4ca56558c76e5aad
Author: Salah Triki <salah.triki@gmail.com>
Date:   Sun Jul 3 05:40:10 2016 +0100

    btrfs: Replace -ENOENT by -ERANGE in btrfs_get_acl()
    
    size contains the value returned by posix_acl_from_xattr(), which
    returns -ERANGE, -ENODATA, zero, or an integer greater than zero. So
    replace -ENOENT by -ERANGE.
    
    Signed-off-by: Salah Triki <salah.triki@gmail.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 67a607709d4f..53bb7af4e5f0 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -55,8 +55,7 @@ struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 	}
 	if (size > 0) {
 		acl = posix_acl_from_xattr(&init_user_ns, value, size);
-	} else if (size == -ENOENT || size == -ENODATA || size == 0) {
-		/* FIXME, who returns -ENOENT?  I think nobody */
+	} else if (size == -ERANGE || size == -ENODATA || size == 0) {
 		acl = NULL;
 	} else {
 		acl = ERR_PTR(-EIO);

commit b8a7a3a6674725d7ca0ff6e322f6c1cab6e6a11d
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Mar 24 14:38:37 2016 +0100

    posix_acl: Inode acl caching fixes
    
    When get_acl() is called for an inode whose ACL is not cached yet, the
    get_acl inode operation is called to fetch the ACL from the filesystem.
    The inode operation is responsible for updating the cached acl with
    set_cached_acl().  This is done without locking at the VFS level, so
    another task can call set_cached_acl() or forget_cached_acl() before the
    get_acl inode operation gets to calling set_cached_acl(), and then
    get_acl's call to set_cached_acl() results in caching an outdate ACL.
    
    Prevent this from happening by setting the cached ACL pointer to a
    task-specific sentinel value before calling the get_acl inode operation.
    Move the responsibility for updating the cached ACL from the get_acl
    inode operations to get_acl().  There, only set the cached ACL if the
    sentinel value hasn't changed.
    
    The sentinel values are chosen to have odd values.  Likewise, the value
    of ACL_NOT_CACHED is odd.  In contrast, ACL object pointers always have
    an even value (ACLs are aligned in memory).  This allows to distinguish
    uncached ACLs values from ACL objects.
    
    In addition, switch from guarding inode->i_acl and inode->i_default_acl
    upates by the inode->i_lock spinlock to using xchg() and cmpxchg().
    
    Filesystems that do not want ACLs returned from their get_acl inode
    operations to be cached must call forget_cached_acl() to prevent the VFS
    from doing so.
    
    (Patch written by Al Viro and Andreas Gruenbacher.)
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 6d263bb1621c..67a607709d4f 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -63,9 +63,6 @@ struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 	}
 	kfree(value);
 
-	if (!IS_ERR(acl))
-		set_cached_acl(inode, type, acl);
-
 	return acl;
 }
 

commit c1a198d9235b9e7d6942027374e44f78ebdcb455
Merge: 48f58ba9cbff 988f1f576d4f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 18 12:44:40 2016 -0800

    Merge branch 'for-linus-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull btrfs updates from Chris Mason:
     "This has our usual assortment of fixes and cleanups, but the biggest
      change included is Omar Sandoval's free space tree.  It's not the
      default yet, mounting -o space_cache=v2 enables it and sets a readonly
      compat bit.  The tree can actually be deleted and regenerated if there
      are any problems, but it has held up really well in testing so far.
    
      For very large filesystems (30T+) our existing free space caching code
      can end up taking a huge amount of time during commits.  The new tree
      based code is faster and less work overall to update as the commit
      progresses.
    
      Omar worked on this during the summer and we'll hammer on it in
      production here at FB over the next few months"
    
    * 'for-linus-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (73 commits)
      Btrfs: fix fitrim discarding device area reserved for boot loader's use
      Btrfs: Check metadata redundancy on balance
      btrfs: statfs: report zero available if metadata are exhausted
      btrfs: preallocate path for snapshot creation at ioctl time
      btrfs: allocate root item at snapshot ioctl time
      btrfs: do an allocation earlier during snapshot creation
      btrfs: use smaller type for btrfs_path locks
      btrfs: use smaller type for btrfs_path lowest_level
      btrfs: use smaller type for btrfs_path reada
      btrfs: cleanup, use enum values for btrfs_path reada
      btrfs: constify static arrays
      btrfs: constify remaining structs with function pointers
      btrfs tests: replace whole ops structure for free space tests
      btrfs: use list_for_each_entry* in backref.c
      btrfs: use list_for_each_entry_safe in free-space-cache.c
      btrfs: use list_for_each_entry* in check-integrity.c
      Btrfs: use linux/sizes.h to represent constants
      btrfs: cleanup, remove stray return statements
      btrfs: zero out delayed node upon allocation
      btrfs: pass proper enum type to start_transaction()
      ...

commit 97d79299223baab330b194437e676d301f12d5f6
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Wed Dec 2 14:44:35 2015 +0100

    posix acls: Remove duplicate xattr name definitions
    
    Remove POSIX_ACL_XATTR_{ACCESS,DEFAULT} and GFS2_POSIX_ACL_{ACCESS,DEFAULT}
    and replace them with the definitions in <include/uapi/linux/xattr.h>.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Reviewed-by: James Morris <james.l.morris@oracle.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 9a0124a95851..f89db0c21b51 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -37,10 +37,10 @@ struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 
 	switch (type) {
 	case ACL_TYPE_ACCESS:
-		name = POSIX_ACL_XATTR_ACCESS;
+		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		break;
 	case ACL_TYPE_DEFAULT:
-		name = POSIX_ACL_XATTR_DEFAULT;
+		name = XATTR_NAME_POSIX_ACL_DEFAULT;
 		break;
 	default:
 		BUG();
@@ -81,7 +81,7 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
 
 	switch (type) {
 	case ACL_TYPE_ACCESS:
-		name = POSIX_ACL_XATTR_ACCESS;
+		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
 			ret = posix_acl_equiv_mode(acl, &inode->i_mode);
 			if (ret < 0)
@@ -94,7 +94,7 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
 	case ACL_TYPE_DEFAULT:
 		if (!S_ISDIR(inode->i_mode))
 			return acl ? -EINVAL : 0;
-		name = POSIX_ACL_XATTR_DEFAULT;
+		name = XATTR_NAME_POSIX_ACL_DEFAULT;
 		break;
 	default:
 		return -EINVAL;

commit 39a27ec1004e886f1d949bdb8f2616896d02c5c2
Author: David Sterba <dsterba@suse.com>
Date:   Thu Dec 3 12:49:48 2015 +0100

    btrfs: use GFP_KERNEL for xattr and acl allocations
    
    We don't have to use GFP_NOFS in context of ACL or XATTR actions, not
    possible to loop through the allocator and it's safe to fail with
    ENOMEM.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 9a0124a95851..dbbb8ed53a51 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -48,7 +48,7 @@ struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 
 	size = __btrfs_getxattr(inode, name, "", 0);
 	if (size > 0) {
-		value = kzalloc(size, GFP_NOFS);
+		value = kzalloc(size, GFP_KERNEL);
 		if (!value)
 			return ERR_PTR(-ENOMEM);
 		size = __btrfs_getxattr(inode, name, value, size);
@@ -102,7 +102,7 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
 
 	if (acl) {
 		size = posix_acl_xattr_size(acl->a_count);
-		value = kmalloc(size, GFP_NOFS);
+		value = kmalloc(size, GFP_KERNEL);
 		if (!value) {
 			ret = -ENOMEM;
 			goto out;

commit 776e4aae5508848730a82b4695edfbd7bc802c33
Author: ZhangZhen <zhenzhang.zhang@huawei.com>
Date:   Tue Apr 8 19:30:19 2014 +0800

    btrfs: remove useless ACL check
    
    posix_acl_xattr_set() already does the check, and it's the only
    way to feed in an ACL from userspace.
    So the check here is useless, remove it.
    
    Signed-off-by: zhang zhen <zhenzhang.zhang@huawei.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index ff9b3995d453..9a0124a95851 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -79,13 +79,6 @@ static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
 	const char *name;
 	char *value = NULL;
 
-	if (acl) {
-		ret = posix_acl_valid(acl);
-		if (ret < 0)
-			return ret;
-		ret = 0;
-	}
-
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;

commit 996a710d46418cacb5b4a519ab9341a74066551d
Author: Christoph Hellwig <hch@infradead.org>
Date:   Fri Dec 20 05:16:43 2013 -0800

    btrfs: use generic posix ACL infrastructure
    
    Also don't bother to set up a .get_acl method for symlinks as we do not
    support access control (ACLs or even mode bits) for symlinks in Linux.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index b56519d47268..ff9b3995d453 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -35,13 +35,6 @@ struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 	char *value = NULL;
 	struct posix_acl *acl;
 
-	if (!IS_POSIXACL(inode))
-		return NULL;
-
-	acl = get_cached_acl(inode, type);
-	if (acl != ACL_NOT_CACHED)
-		return acl;
-
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
@@ -76,31 +69,10 @@ struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 	return acl;
 }
 
-static int btrfs_xattr_acl_get(struct dentry *dentry, const char *name,
-		void *value, size_t size, int type)
-{
-	struct posix_acl *acl;
-	int ret = 0;
-
-	if (!IS_POSIXACL(dentry->d_inode))
-		return -EOPNOTSUPP;
-
-	acl = btrfs_get_acl(dentry->d_inode, type);
-
-	if (IS_ERR(acl))
-		return PTR_ERR(acl);
-	if (acl == NULL)
-		return -ENODATA;
-	ret = posix_acl_to_xattr(&init_user_ns, acl, value, size);
-	posix_acl_release(acl);
-
-	return ret;
-}
-
 /*
  * Needs to be called with fs_mutex held
  */
-static int btrfs_set_acl(struct btrfs_trans_handle *trans,
+static int __btrfs_set_acl(struct btrfs_trans_handle *trans,
 			 struct inode *inode, struct posix_acl *acl, int type)
 {
 	int ret, size = 0;
@@ -158,35 +130,9 @@ static int btrfs_set_acl(struct btrfs_trans_handle *trans,
 	return ret;
 }
 
-static int btrfs_xattr_acl_set(struct dentry *dentry, const char *name,
-		const void *value, size_t size, int flags, int type)
+int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 {
-	int ret;
-	struct posix_acl *acl = NULL;
-
-	if (!inode_owner_or_capable(dentry->d_inode))
-		return -EPERM;
-
-	if (!IS_POSIXACL(dentry->d_inode))
-		return -EOPNOTSUPP;
-
-	if (value) {
-		acl = posix_acl_from_xattr(&init_user_ns, value, size);
-		if (IS_ERR(acl))
-			return PTR_ERR(acl);
-
-		if (acl) {
-			ret = posix_acl_valid(acl);
-			if (ret)
-				goto out;
-		}
-	}
-
-	ret = btrfs_set_acl(NULL, dentry->d_inode, acl, type);
-out:
-	posix_acl_release(acl);
-
-	return ret;
+	return __btrfs_set_acl(NULL, inode, acl, type);
 }
 
 /*
@@ -197,83 +143,31 @@ static int btrfs_xattr_acl_set(struct dentry *dentry, const char *name,
 int btrfs_init_acl(struct btrfs_trans_handle *trans,
 		   struct inode *inode, struct inode *dir)
 {
-	struct posix_acl *acl = NULL;
+	struct posix_acl *default_acl, *acl;
 	int ret = 0;
 
 	/* this happens with subvols */
 	if (!dir)
 		return 0;
 
-	if (!S_ISLNK(inode->i_mode)) {
-		if (IS_POSIXACL(dir)) {
-			acl = btrfs_get_acl(dir, ACL_TYPE_DEFAULT);
-			if (IS_ERR(acl))
-				return PTR_ERR(acl);
-		}
+	ret = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);
+	if (ret)
+		return ret;
 
-		if (!acl)
-			inode->i_mode &= ~current_umask();
+	if (default_acl) {
+		ret = __btrfs_set_acl(trans, inode, default_acl,
+				      ACL_TYPE_DEFAULT);
+		posix_acl_release(default_acl);
 	}
 
-	if (IS_POSIXACL(dir) && acl) {
-		if (S_ISDIR(inode->i_mode)) {
-			ret = btrfs_set_acl(trans, inode, acl,
-					    ACL_TYPE_DEFAULT);
-			if (ret)
-				goto failed;
-		}
-		ret = __posix_acl_create(&acl, GFP_NOFS, &inode->i_mode);
-		if (ret < 0)
-			return ret;
-
-		if (ret > 0) {
-			/* we need an acl */
-			ret = btrfs_set_acl(trans, inode, acl, ACL_TYPE_ACCESS);
-		} else if (ret < 0) {
-			cache_no_acl(inode);
-		}
-	} else {
-		cache_no_acl(inode);
+	if (acl) {
+		if (!ret)
+			ret = __btrfs_set_acl(trans, inode, acl,
+					      ACL_TYPE_ACCESS);
+		posix_acl_release(acl);
 	}
-failed:
-	posix_acl_release(acl);
-
-	return ret;
-}
 
-int btrfs_acl_chmod(struct inode *inode)
-{
-	struct posix_acl *acl;
-	int ret = 0;
-
-	if (S_ISLNK(inode->i_mode))
-		return -EOPNOTSUPP;
-
-	if (!IS_POSIXACL(inode))
-		return 0;
-
-	acl = btrfs_get_acl(inode, ACL_TYPE_ACCESS);
-	if (IS_ERR_OR_NULL(acl))
-		return PTR_ERR(acl);
-
-	ret = __posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
-	if (ret)
-		return ret;
-	ret = btrfs_set_acl(NULL, inode, acl, ACL_TYPE_ACCESS);
-	posix_acl_release(acl);
+	if (!default_acl && !acl)
+		cache_no_acl(inode);
 	return ret;
 }
-
-const struct xattr_handler btrfs_xattr_acl_default_handler = {
-	.prefix = POSIX_ACL_XATTR_DEFAULT,
-	.flags	= ACL_TYPE_DEFAULT,
-	.get	= btrfs_xattr_acl_get,
-	.set	= btrfs_xattr_acl_set,
-};
-
-const struct xattr_handler btrfs_xattr_acl_access_handler = {
-	.prefix = POSIX_ACL_XATTR_ACCESS,
-	.flags	= ACL_TYPE_ACCESS,
-	.get	= btrfs_xattr_acl_get,
-	.set	= btrfs_xattr_acl_set,
-};

commit 37bc15392a2363ca822b2c2828e0ccafbea32f75
Author: Christoph Hellwig <hch@infradead.org>
Date:   Fri Dec 20 05:16:42 2013 -0800

    fs: make posix_acl_create more useful
    
    Rename the current posix_acl_created to __posix_acl_create and add
    a fully featured helper to set up the ACLs on file creation that
    uses get_acl().
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 1af04ff88986..b56519d47268 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -222,7 +222,7 @@ int btrfs_init_acl(struct btrfs_trans_handle *trans,
 			if (ret)
 				goto failed;
 		}
-		ret = posix_acl_create(&acl, GFP_NOFS, &inode->i_mode);
+		ret = __posix_acl_create(&acl, GFP_NOFS, &inode->i_mode);
 		if (ret < 0)
 			return ret;
 

commit 5bf3258fd2acd8515450ab8efcd97c9d3b69f7f9
Author: Christoph Hellwig <hch@infradead.org>
Date:   Fri Dec 20 05:16:41 2013 -0800

    fs: make posix_acl_chmod more useful
    
    Rename the current posix_acl_chmod to __posix_acl_chmod and add
    a fully featured ACL chmod helper that uses the ->set_acl inode
    operation.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 0890c83643e9..1af04ff88986 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -256,7 +256,7 @@ int btrfs_acl_chmod(struct inode *inode)
 	if (IS_ERR_OR_NULL(acl))
 		return PTR_ERR(acl);
 
-	ret = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
+	ret = __posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
 	if (ret)
 		return ret;
 	ret = btrfs_set_acl(NULL, inode, acl, ACL_TYPE_ACCESS);

commit 8185554d3eb09d23a805456b6fa98dcbb34aa518
Author: Filipe David Borba Manana <fdmanana@gmail.com>
Date:   Tue Oct 15 18:44:00 2013 +0100

    Btrfs: fix incorrect inode acl reset
    
    When a directory has a default ACL and a subdirectory is created
    under that directory, btrfs_init_acl() is called when the
    subdirectory's inode is created to initialize the inode's ACL
    (inherited from the parent directory) but it was clearing the ACL
    from the inode after setting it if posix_acl_create() returned
    success, instead of clearing it only if it returned an error.
    
    To reproduce this issue:
    
    $ mkfs.btrfs -f /dev/loop0
    $ mount /dev/loop0 /mnt
    $ mkdir /mnt/acl
    $ setfacl -d --set u::rwx,g::rwx,o::- /mnt/acl
    $ getfacl /mnt/acl
    user::rwx
    group::rwx
    other::r-x
    default:user::rwx
    default:group::rwx
    default:other::---
    
    $ mkdir /mnt/acl/dir1
    $ getfacl /mnt/acl/dir1
    user::rwx
    group::rwx
    other::---
    
    After unmounting and mounting again the filesystem, fgetacl returned the
    expected ACL:
    
    $ umount /mnt/acl
    $ mount /dev/loop0 /mnt
    $ getfacl /mnt/acl/dir1
    user::rwx
    group::rwx
    other::---
    default:user::rwx
    default:group::rwx
    default:other::---
    
    Meaning that the underlying xattr was persisted.
    
    Reported-by: Giuseppe Fierro <giuseppe@fierro.org>
    Signed-off-by: Filipe David Borba Manana <fdmanana@gmail.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index e15d2b0d8d3b..0890c83643e9 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -229,7 +229,7 @@ int btrfs_init_acl(struct btrfs_trans_handle *trans,
 		if (ret > 0) {
 			/* we need an acl */
 			ret = btrfs_set_acl(trans, inode, acl, ACL_TYPE_ACCESS);
-		} else {
+		} else if (ret < 0) {
 			cache_no_acl(inode);
 		}
 	} else {

commit 755ac67f83e515af55adbfe55134eb7d90839cdb
Author: Liu Bo <bo.li.liu@oracle.com>
Date:   Wed Nov 28 10:43:11 2012 +0000

    Btrfs: skip adding an acl attribute if we don't have to
    
    If the acl can be exactly represented in the traditional file
    mode permission bits, we don't set another acl attribute.
    
    Signed-off-by: Liu Bo <bo.li.liu@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 0c16e3dbfd56..e15d2b0d8d3b 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -121,6 +121,8 @@ static int btrfs_set_acl(struct btrfs_trans_handle *trans,
 			ret = posix_acl_equiv_mode(acl, &inode->i_mode);
 			if (ret < 0)
 				return ret;
+			if (ret == 0)
+				acl = NULL;
 		}
 		ret = 0;
 		break;

commit 5f3a4a28ec140a90e6058d1d09f6b1f235d485e5
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Sep 10 20:17:44 2012 -0700

    userns: Pass a userns parameter into posix_acl_to_xattr and posix_acl_from_xattr
    
     - Pass the user namespace the uid and gid values in the xattr are stored
       in into posix_acl_from_xattr.
    
     - Pass the user namespace kuid and kgid values should be converted into
       when storing uid and gid values in an xattr in posix_acl_to_xattr.
    
    - Modify all callers of posix_acl_from_xattr and posix_acl_to_xattr to
      pass in &init_user_ns.
    
    In the short term this change is not strictly needed but it makes the
    code clearer.  In the longer term this change is necessary to be able to
    mount filesystems outside of the initial user namespace that natively
    store posix acls in the linux xattr format.
    
    Cc: Theodore Tso <tytso@mit.edu>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andreas Dilger <adilger.kernel@dilger.ca>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 761e2cd8fed1..0c16e3dbfd56 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -61,7 +61,7 @@ struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 		size = __btrfs_getxattr(inode, name, value, size);
 	}
 	if (size > 0) {
-		acl = posix_acl_from_xattr(value, size);
+		acl = posix_acl_from_xattr(&init_user_ns, value, size);
 	} else if (size == -ENOENT || size == -ENODATA || size == 0) {
 		/* FIXME, who returns -ENOENT?  I think nobody */
 		acl = NULL;
@@ -91,7 +91,7 @@ static int btrfs_xattr_acl_get(struct dentry *dentry, const char *name,
 		return PTR_ERR(acl);
 	if (acl == NULL)
 		return -ENODATA;
-	ret = posix_acl_to_xattr(acl, value, size);
+	ret = posix_acl_to_xattr(&init_user_ns, acl, value, size);
 	posix_acl_release(acl);
 
 	return ret;
@@ -141,7 +141,7 @@ static int btrfs_set_acl(struct btrfs_trans_handle *trans,
 			goto out;
 		}
 
-		ret = posix_acl_to_xattr(acl, value, size);
+		ret = posix_acl_to_xattr(&init_user_ns, acl, value, size);
 		if (ret < 0)
 			goto out;
 	}
@@ -169,7 +169,7 @@ static int btrfs_xattr_acl_set(struct dentry *dentry, const char *name,
 		return -EOPNOTSUPP;
 
 	if (value) {
-		acl = posix_acl_from_xattr(value, size);
+		acl = posix_acl_from_xattr(&init_user_ns, value, size);
 		if (IS_ERR(acl))
 			return PTR_ERR(acl);
 

commit 30f8fe3e47c5bb5715aa80b2a2fa0cab8b218fae
Author: Josef Bacik <josef@redhat.com>
Date:   Mon Apr 23 13:55:30 2012 -0400

    Btrfs: cache no acl on new inodes
    
    When running compilebench I noticed we were spending some time looking up
    acls on new inodes, which shouldn't be happening since there were no acls.
    This is because when we init acls on the inode after creating them we don't
    cache the fact there are no acls if there aren't any.  Doing this adds a
    little bit of a bump to my compilebench runs.  Thanks,
    Btrfs: cache no acl on new inodes
    
    Signed-off-by: Josef Bacik <josef@redhat.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 89b156d85d63..761e2cd8fed1 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -227,7 +227,11 @@ int btrfs_init_acl(struct btrfs_trans_handle *trans,
 		if (ret > 0) {
 			/* we need an acl */
 			ret = btrfs_set_acl(trans, inode, acl, ACL_TYPE_ACCESS);
+		} else {
+			cache_no_acl(inode);
 		}
+	} else {
+		cache_no_acl(inode);
 	}
 failed:
 	posix_acl_release(acl);

commit cfbffc39ac89dbd5197cbeec2599a1128eb928f8
Author: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
Date:   Thu Oct 6 13:37:08 2011 +0900

    Btrfs: fix return value of btrfs_get_acl()
    
    In btrfs_get_acl(), when the second __btrfs_getxattr() call fails,
    acl is not correctly set.
    Therefore, a wrong value might return to the caller.
    
    Signed-off-by: Tsutomu Itoh <t-itoh@jp.fujitsu.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index eb159aaa5a11..89b156d85d63 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -59,22 +59,19 @@ struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 		if (!value)
 			return ERR_PTR(-ENOMEM);
 		size = __btrfs_getxattr(inode, name, value, size);
-		if (size > 0) {
-			acl = posix_acl_from_xattr(value, size);
-			if (IS_ERR(acl)) {
-				kfree(value);
-				return acl;
-			}
-			set_cached_acl(inode, type, acl);
-		}
-		kfree(value);
+	}
+	if (size > 0) {
+		acl = posix_acl_from_xattr(value, size);
 	} else if (size == -ENOENT || size == -ENODATA || size == 0) {
 		/* FIXME, who returns -ENOENT?  I think nobody */
 		acl = NULL;
-		set_cached_acl(inode, type, acl);
 	} else {
 		acl = ERR_PTR(-EIO);
 	}
+	kfree(value);
+
+	if (!IS_ERR(acl))
+		set_cached_acl(inode, type, acl);
 
 	return acl;
 }

commit ed8f37370d83e695c0a4fa5d5fc7a83ecb947526
Merge: a6b11f533889 0d10ee2e6deb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 2 21:14:05 2011 -1000

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable: (31 commits)
      Btrfs: don't call writepages from within write_full_page
      Btrfs: Remove unused variable 'last_index' in file.c
      Btrfs: clean up for find_first_extent_bit()
      Btrfs: clean up for wait_extent_bit()
      Btrfs: clean up for insert_state()
      Btrfs: remove unused members from struct extent_state
      Btrfs: clean up code for merging extent maps
      Btrfs: clean up code for extent_map lookup
      Btrfs: clean up search_extent_mapping()
      Btrfs: remove redundant code for dir item lookup
      Btrfs: make acl functions really no-op if acl is not enabled
      Btrfs: remove remaining ref-cache code
      Btrfs: remove a BUG_ON() in btrfs_commit_transaction()
      Btrfs: use wait_event()
      Btrfs: check the nodatasum flag when writing compressed files
      Btrfs: copy string correctly in INO_LOOKUP ioctl
      Btrfs: don't print the leaf if we had an error
      btrfs: make btrfs_set_root_node void
      Btrfs: fix oops while writing data to SSD partitions
      Btrfs: Protect the readonly flag of block group
      ...
    
    Fix up trivial conflicts (due to acl and writeback cleanups) in
     - fs/btrfs/acl.c
     - fs/btrfs/ctree.h
     - fs/btrfs/extent_io.c

commit 9b89d95a143bb0a9abc4ba0fdcdda78211930f1a
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Thu Jul 14 03:17:39 2011 +0000

    Btrfs: make acl functions really no-op if acl is not enabled
    
    So there's no overhead for something we don't use.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index f66fc9959733..b206d4c2720b 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -28,8 +28,6 @@
 #include "btrfs_inode.h"
 #include "xattr.h"
 
-#ifdef CONFIG_BTRFS_FS_POSIX_ACL
-
 static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 {
 	int size;
@@ -318,18 +316,3 @@ const struct xattr_handler btrfs_xattr_acl_access_handler = {
 	.get	= btrfs_xattr_acl_get,
 	.set	= btrfs_xattr_acl_set,
 };
-
-#else /* CONFIG_BTRFS_FS_POSIX_ACL */
-
-int btrfs_acl_chmod(struct inode *inode)
-{
-	return 0;
-}
-
-int btrfs_init_acl(struct btrfs_trans_handle *trans,
-		   struct inode *inode, struct inode *dir)
-{
-	return 0;
-}
-
-#endif /* CONFIG_BTRFS_FS_POSIX_ACL */

commit d6952123b53cc8b334df69bba2cd0063b0d88f68
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 23 18:56:36 2011 -0400

    switch posix_acl_equiv_mode() to umode_t *
    
    ... so that &inode->i_mode could be passed to it
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 59086142c14d..4cc5c0164ed6 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -111,7 +111,6 @@ static int btrfs_set_acl(struct btrfs_trans_handle *trans,
 	int ret, size = 0;
 	const char *name;
 	char *value = NULL;
-	mode_t mode;
 
 	if (acl) {
 		ret = posix_acl_valid(acl);
@@ -122,13 +121,11 @@ static int btrfs_set_acl(struct btrfs_trans_handle *trans,
 
 	switch (type) {
 	case ACL_TYPE_ACCESS:
-		mode = inode->i_mode;
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
-			ret = posix_acl_equiv_mode(acl, &mode);
+			ret = posix_acl_equiv_mode(acl, &inode->i_mode);
 			if (ret < 0)
 				return ret;
-			inode->i_mode = mode;
 		}
 		ret = 0;
 		break;

commit d3fb612076eebec6f67257db0c7a9666ac7e5892
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 23 18:37:50 2011 -0400

    switch posix_acl_create() to umode_t *
    
    so we can pass &inode->i_mode to it
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 65a735d8f6e4..59086142c14d 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -222,19 +222,16 @@ int btrfs_init_acl(struct btrfs_trans_handle *trans,
 	}
 
 	if (IS_POSIXACL(dir) && acl) {
-		mode_t mode = inode->i_mode;
-
 		if (S_ISDIR(inode->i_mode)) {
 			ret = btrfs_set_acl(trans, inode, acl,
 					    ACL_TYPE_DEFAULT);
 			if (ret)
 				goto failed;
 		}
-		ret = posix_acl_create(&acl, GFP_NOFS, &mode);
+		ret = posix_acl_create(&acl, GFP_NOFS, &inode->i_mode);
 		if (ret < 0)
 			return ret;
 
-		inode->i_mode = mode;
 		if (ret > 0) {
 			/* we need an acl */
 			ret = btrfs_set_acl(trans, inode, acl, ACL_TYPE_ACCESS);

commit 4e34e719e457f2e031297175410fc0bd4016a085
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jul 23 17:37:31 2011 +0200

    fs: take the ACL checks to common code
    
    Replace the ->check_acl method with a ->get_acl method that simply reads an
    ACL from disk after having a cache miss.  This means we can replace the ACL
    checking boilerplate code with a single implementation in namei.c.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 9508ad14c924..65a735d8f6e4 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -30,7 +30,7 @@
 
 #ifdef CONFIG_BTRFS_FS_POSIX_ACL
 
-static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
+struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 {
 	int size;
 	const char *name;
@@ -195,22 +195,6 @@ static int btrfs_xattr_acl_set(struct dentry *dentry, const char *name,
 	return ret;
 }
 
-int btrfs_check_acl(struct inode *inode, int mask)
-{
-	int error = -EAGAIN;
-	struct posix_acl *acl;
-
-	acl = btrfs_get_acl(inode, ACL_TYPE_ACCESS);
-	if (IS_ERR(acl))
-		return PTR_ERR(acl);
-	if (acl) {
-		error = posix_acl_permission(inode, acl, mask);
-		posix_acl_release(acl);
-	}
-
-	return error;
-}
-
 /*
  * btrfs_init_acl is already generally called under fs_mutex, so the locking
  * stuff has been fixed to work with that.  If the locking stuff changes, we

commit 826cae2f2b4d726b925f43bc208a571639da4761
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 23 03:10:32 2011 -0400

    kill boilerplates around posix_acl_create_masq()
    
    new helper: posix_acl_create(&acl, gfp, mode_p).  Replaces acl with
    modified clone, on failure releases acl and replaces with NULL.
    Returns 0 or -ve on error.  All callers of posix_acl_create_masq()
    switched.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 88bca53b302a..9508ad14c924 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -238,8 +238,7 @@ int btrfs_init_acl(struct btrfs_trans_handle *trans,
 	}
 
 	if (IS_POSIXACL(dir) && acl) {
-		struct posix_acl *clone;
-		mode_t mode;
+		mode_t mode = inode->i_mode;
 
 		if (S_ISDIR(inode->i_mode)) {
 			ret = btrfs_set_acl(trans, inode, acl,
@@ -247,22 +246,15 @@ int btrfs_init_acl(struct btrfs_trans_handle *trans,
 			if (ret)
 				goto failed;
 		}
-		clone = posix_acl_clone(acl, GFP_NOFS);
-		ret = -ENOMEM;
-		if (!clone)
-			goto failed;
+		ret = posix_acl_create(&acl, GFP_NOFS, &mode);
+		if (ret < 0)
+			return ret;
 
-		mode = inode->i_mode;
-		ret = posix_acl_create_masq(clone, &mode);
-		if (ret >= 0) {
-			inode->i_mode = mode;
-			if (ret > 0) {
-				/* we need an acl */
-				ret = btrfs_set_acl(trans, inode, clone,
-						    ACL_TYPE_ACCESS);
-			}
+		inode->i_mode = mode;
+		if (ret > 0) {
+			/* we need an acl */
+			ret = btrfs_set_acl(trans, inode, acl, ACL_TYPE_ACCESS);
 		}
-		posix_acl_release(clone);
 	}
 failed:
 	posix_acl_release(acl);

commit bc26ab5f65ae41b71df86ea46df3c3833d1d8d83
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 23 00:18:02 2011 -0400

    kill boilerplate around posix_acl_chmod_masq()
    
    new helper: posix_acl_chmod(&acl, gfp, mode).  Replaces acl with modified
    clone or with NULL if that has failed; returns 0 or -ve on error.  All
    callers of posix_acl_chmod_masq() switched to that - they'd been doing
    exactly the same thing.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index c13ea9fbf36b..88bca53b302a 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -272,7 +272,7 @@ int btrfs_init_acl(struct btrfs_trans_handle *trans,
 
 int btrfs_acl_chmod(struct inode *inode)
 {
-	struct posix_acl *acl, *clone;
+	struct posix_acl *acl;
 	int ret = 0;
 
 	if (S_ISLNK(inode->i_mode))
@@ -285,17 +285,11 @@ int btrfs_acl_chmod(struct inode *inode)
 	if (IS_ERR_OR_NULL(acl))
 		return PTR_ERR(acl);
 
-	clone = posix_acl_clone(acl, GFP_KERNEL);
+	ret = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
+	if (ret)
+		return ret;
+	ret = btrfs_set_acl(NULL, inode, acl, ACL_TYPE_ACCESS);
 	posix_acl_release(acl);
-	if (!clone)
-		return -ENOMEM;
-
-	ret = posix_acl_chmod_masq(clone, inode->i_mode);
-	if (!ret)
-		ret = btrfs_set_acl(NULL, inode, clone, ACL_TYPE_ACCESS);
-
-	posix_acl_release(clone);
-
 	return ret;
 }
 

commit e77819e57f0817c6dc7cadd061acd70c604cbce2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 22 19:30:19 2011 -0700

    vfs: move ACL cache lookup into generic code
    
    This moves logic for checking the cached ACL values from low-level
    filesystems into generic code.  The end result is a streamlined ACL
    check that doesn't need to load the inode->i_op->check_acl pointer at
    all for the common cached case.
    
    The filesystems also don't need to check for a non-blocking RCU walk
    case in their acl_check() functions, because that is all handled at a
    VFS layer.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 9f62ab2a7282..c13ea9fbf36b 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -198,19 +198,14 @@ static int btrfs_xattr_acl_set(struct dentry *dentry, const char *name,
 int btrfs_check_acl(struct inode *inode, int mask)
 {
 	int error = -EAGAIN;
+	struct posix_acl *acl;
 
-	if (mask & MAY_NOT_BLOCK) {
-		if (!negative_cached_acl(inode, ACL_TYPE_ACCESS))
-			error = -ECHILD;
-	} else {
-		struct posix_acl *acl;
-		acl = btrfs_get_acl(inode, ACL_TYPE_ACCESS);
-		if (IS_ERR(acl))
-			return PTR_ERR(acl);
-		if (acl) {
-			error = posix_acl_permission(inode, acl, mask);
-			posix_acl_release(acl);
-		}
+	acl = btrfs_get_acl(inode, ACL_TYPE_ACCESS);
+	if (IS_ERR(acl))
+		return PTR_ERR(acl);
+	if (acl) {
+		error = posix_acl_permission(inode, acl, mask);
+		posix_acl_release(acl);
 	}
 
 	return error;

commit 7e40145eb111a5192e6d819f764db9d6828d1abb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 19:12:17 2011 -0400

    ->permission() sanitizing: don't pass flags to ->check_acl()
    
    not used in the instances anymore.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index a25a4a2e0df2..9f62ab2a7282 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -195,7 +195,7 @@ static int btrfs_xattr_acl_set(struct dentry *dentry, const char *name,
 	return ret;
 }
 
-int btrfs_check_acl(struct inode *inode, int mask, unsigned int flags)
+int btrfs_check_acl(struct inode *inode, int mask)
 {
 	int error = -EAGAIN;
 

commit 9c2c703929e4c41210cfa6e3f599514421bab8dc
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 19:06:22 2011 -0400

    ->permission() sanitizing: pass MAY_NOT_BLOCK to ->check_acl()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index f66fc9959733..a25a4a2e0df2 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -199,10 +199,9 @@ int btrfs_check_acl(struct inode *inode, int mask, unsigned int flags)
 {
 	int error = -EAGAIN;
 
-	if (flags & IPERM_FLAG_RCU) {
+	if (mask & MAY_NOT_BLOCK) {
 		if (!negative_cached_acl(inode, ACL_TYPE_ACCESS))
 			error = -ECHILD;
-
 	} else {
 		struct posix_acl *acl;
 		acl = btrfs_get_acl(inode, ACL_TYPE_ACCESS);

commit 945d8962ceee6bb273365d0bdf42f763225b290f
Merge: 0d0ca30f1809 4ea028859bbd
Author: Chris Mason <chris.mason@oracle.com>
Date:   Sun May 22 12:33:42 2011 -0400

    Merge branch 'cleanups' of git://repo.or.cz/linux-2.6/btrfs-unstable into inode_numbers
    
    Conflicts:
            fs/btrfs/extent-tree.c
            fs/btrfs/free-space-cache.c
            fs/btrfs/inode.c
            fs/btrfs/tree-log.c
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

commit eed631e0d741d1a1067cfc6d709fdf2363126f9c
Merge: bd1a643e10eb ebcb904dfe31
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun May 15 10:22:10 2011 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable:
      Btrfs: fix FS_IOC_SETFLAGS ioctl
      Btrfs: fix FS_IOC_GETFLAGS ioctl
      fs: remove FS_COW_FL
      Btrfs: fix easily get into ENOSPC in mixed case
      Prevent oopsing in posix_acl_valid()

commit f5de93914983bf04b92a786d1d205286fc53b49b
Author: Daniel J Blueman <daniel.blueman@gmail.com>
Date:   Tue May 3 16:44:13 2011 +0000

    Prevent oopsing in posix_acl_valid()
    
    If posix_acl_from_xattr() returns an error code, a negative address is
    dereferenced causing an oops; fix by checking for error code first.
    
    Signed-off-by: Daniel J Blueman <daniel.blueman@gmail.com>
    Reviewed-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index a892bc27f13a..827be9a6ca33 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -178,12 +178,13 @@ static int btrfs_xattr_acl_set(struct dentry *dentry, const char *name,
 
 	if (value) {
 		acl = posix_acl_from_xattr(value, size);
+		if (IS_ERR(acl))
+			return PTR_ERR(acl);
+
 		if (acl) {
 			ret = posix_acl_valid(acl);
 			if (ret)
 				goto out;
-		} else if (IS_ERR(acl)) {
-			return PTR_ERR(acl);
 		}
 	}
 

commit c704005d886cf0bc9bc3974eb009b22fe0da32c7
Author: David Sterba <dsterba@suse.cz>
Date:   Tue Apr 19 18:00:01 2011 +0200

    btrfs: unify checking of IS_ERR and null
    
    use IS_ERR_OR_NULL when possible, done by this coccinelle script:
    
    @ match @
    identifier id;
    @@
    (
    - BUG_ON(IS_ERR(id) || !id);
    + BUG_ON(IS_ERR_OR_NULL(id));
    |
    - IS_ERR(id) || !id
    + IS_ERR_OR_NULL(id)
    |
    - !id || IS_ERR(id)
    + IS_ERR_OR_NULL(id)
    )
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 5d505aaa72fb..1a21c99a91b8 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -287,7 +287,7 @@ int btrfs_acl_chmod(struct inode *inode)
 		return 0;
 
 	acl = btrfs_get_acl(inode, ACL_TYPE_ACCESS);
-	if (IS_ERR(acl) || !acl)
+	if (IS_ERR_OR_NULL(acl))
 		return PTR_ERR(acl);
 
 	clone = posix_acl_clone(acl, GFP_KERNEL);

commit adff377bb1010ec65aada1f94ef2be7c7805c711
Merge: d8bdc59f215e f65647c29b14
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 18 12:24:05 2011 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable: (24 commits)
      Btrfs: fix free space cache leak
      Btrfs: avoid taking the chunk_mutex in do_chunk_alloc
      Btrfs end_bio_extent_readpage should look for locked bits
      Btrfs: don't force chunk allocation in find_free_extent
      Btrfs: Check validity before setting an acl
      Btrfs: Fix incorrect inode nlink in btrfs_link()
      Btrfs: Check if btrfs_next_leaf() returns error in btrfs_real_readdir()
      Btrfs: Check if btrfs_next_leaf() returns error in btrfs_listxattr()
      Btrfs: make uncache_state unconditional
      btrfs: using cached extent_state in set/unlock combinations
      Btrfs: avoid taking the trans_mutex in btrfs_end_transaction
      Btrfs: fix subvolume mount by name problem when default mount subvolume is set
      fix user annotation in ioctl.c
      Btrfs: check for duplicate iov_base's when doing dio reads
      btrfs: properly handle overlapping areas in memmove_extent_buffer
      Btrfs: fix memory leaks in btrfs_new_inode()
      Btrfs: check for duplicate iov_base's when doing dio reads
      Btrfs: reuse the extent_map we found when calling btrfs_get_extent
      Btrfs: do not use async submit for small DIO io's
      Btrfs: don't split dio bios if we don't have to
      ...

commit 329c5056be8774255db04b01242a9ff4f02eb8ea
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Apr 13 14:07:59 2011 +0800

    Btrfs: Check validity before setting an acl
    
    Call posix_acl_valid() to check if an acl is valid or not.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 9c949348510b..a892bc27f13a 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -178,16 +178,17 @@ static int btrfs_xattr_acl_set(struct dentry *dentry, const char *name,
 
 	if (value) {
 		acl = posix_acl_from_xattr(value, size);
-		if (acl == NULL) {
-			value = NULL;
-			size = 0;
+		if (acl) {
+			ret = posix_acl_valid(acl);
+			if (ret)
+				goto out;
 		} else if (IS_ERR(acl)) {
 			return PTR_ERR(acl);
 		}
 	}
 
 	ret = btrfs_set_acl(NULL, dentry->d_inode, acl, type);
-
+out:
 	posix_acl_release(acl);
 
 	return ret;

commit 2e1496707560ecf98e9b0604622c0990f94861d3
Author: Serge E. Hallyn <serge@hallyn.com>
Date:   Wed Mar 23 16:43:26 2011 -0700

    userns: rename is_owner_or_cap to inode_owner_or_capable
    
    And give it a kernel-doc comment.
    
    [akpm@linux-foundation.org: btrfs changed in linux-next]
    Signed-off-by: Serge E. Hallyn <serge.hallyn@canonical.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Daniel Lezcano <daniel.lezcano@free.fr>
    Acked-by: David Howells <dhowells@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 9c949348510b..de34bfad9ec3 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -170,7 +170,7 @@ static int btrfs_xattr_acl_set(struct dentry *dentry, const char *name,
 	int ret;
 	struct posix_acl *acl = NULL;
 
-	if (!is_owner_or_cap(dentry->d_inode))
+	if (!inode_owner_or_capable(dentry->d_inode))
 		return -EPERM;
 
 	if (!IS_POSIXACL(dentry->d_inode))

commit cb5520f02c010e3cb974b9ac06f30aafa2eebc38
Merge: eee4da2cef8e 3a90983dbdcb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 7 14:06:18 2011 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable: (33 commits)
      Btrfs: Fix page count calculation
      btrfs: Drop __exit attribute on btrfs_exit_compress
      btrfs: cleanup error handling in btrfs_unlink_inode()
      Btrfs: exclude super blocks when we read in block groups
      Btrfs: make sure search_bitmap finds something in remove_from_bitmap
      btrfs: fix return value check of btrfs_start_transaction()
      btrfs: checking NULL or not in some functions
      Btrfs: avoid uninit variable warnings in ordered-data.c
      Btrfs: catch errors from btrfs_sync_log
      Btrfs: make shrink_delalloc a little friendlier
      Btrfs: handle no memory properly in prepare_pages
      Btrfs: do error checking in btrfs_del_csums
      Btrfs: use the global block reserve if we cannot reserve space
      Btrfs: do not release more reserved bytes to the global_block_rsv than we need
      Btrfs: fix check_path_shared so it returns the right value
      btrfs: check return value of btrfs_start_ioctl_transaction() properly
      btrfs: fix return value check of btrfs_join_transaction()
      fs/btrfs/inode.c: Add missing IS_ERR test
      btrfs: fix missing break in switch phrase
      btrfs: fix several uncheck memory allocations
      ...

commit eab49bec41136460b12ac0fbeceeb88386d538c7
Merge: acce952b0263 4d728ec7aefd
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Jan 28 16:24:59 2011 -0500

    Merge branch 'bug-fixes' of git://repo.or.cz/linux-btrfs-devel into btrfs-38

commit d0f69686c2ae775529aadc7a8acc6f13ad41de66
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Tue Jan 25 15:46:17 2011 +0800

    Btrfs: Don't return acl info when mounting with noacl option
    
    Steps to reproduce:
    
      # mkfs.btrfs /dev/sda2
      # mount /dev/sda2 /mnt
      # touch /mnt/file0
      # setfacl -m 'u:root:x,g::x,o::x' /mnt/file0
      # umount /mnt
      # mount /dev/sda2 -o noacl /mnt
      # getfacl /mnt/file0
      ...
      user::rw-
      user:root:--x
      group::--x
      mask::--x
      other::--x
    
    The output should be:
    
      user::rw-
      group::--x
      other::--x
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 2222d161c7b6..3c52fc8afe29 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -37,6 +37,9 @@ static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 	char *value = NULL;
 	struct posix_acl *acl;
 
+	if (!IS_POSIXACL(inode))
+		return NULL;
+
 	acl = get_cached_acl(inode, type);
 	if (acl != ACL_NOT_CACHED)
 		return acl;
@@ -82,6 +85,9 @@ static int btrfs_xattr_acl_get(struct dentry *dentry, const char *name,
 	struct posix_acl *acl;
 	int ret = 0;
 
+	if (!IS_POSIXACL(dentry->d_inode))
+		return -EOPNOTSUPP;
+
 	acl = btrfs_get_acl(dentry->d_inode, type);
 
 	if (IS_ERR(acl))

commit eee2a817df7c5a6e569f353f8be78cc1b3604bb6
Merge: 83896fb5e515 acce952b0263
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 17 14:43:43 2011 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable: (25 commits)
      Btrfs: forced readonly mounts on errors
      btrfs: Require CAP_SYS_ADMIN for filesystem rebalance
      Btrfs: don't warn if we get ENOSPC in btrfs_block_rsv_check
      btrfs: Fix memory leak in btrfs_read_fs_root_no_radix()
      btrfs: check NULL or not
      btrfs: Don't pass NULL ptr to func that may deref it.
      btrfs: mount failure return value fix
      btrfs: Mem leak in btrfs_get_acl()
      btrfs: fix wrong free space information of btrfs
      btrfs: make the chunk allocator utilize the devices better
      btrfs: restructure find_free_dev_extent()
      btrfs: fix wrong calculation of stripe size
      btrfs: try to reclaim some space when chunk allocation fails
      btrfs: fix wrong data space statistics
      fs/btrfs: Fix build of ctree
      Btrfs: fix off by one while setting block groups readonly
      Btrfs: Add BTRFS_IOC_SUBVOL_GETFLAGS/SETFLAGS ioctls
      Btrfs: Add readonly snapshots support
      Btrfs: Refactor btrfs_ioctl_snap_create()
      btrfs: Extract duplicate decompress code
      ...

commit 42838bb265b9cff3de9587fcacc398b5112dc2d9
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Thu Jan 6 21:45:21 2011 +0000

    btrfs: Mem leak in btrfs_get_acl()
    
    It seems to me that we leak the memory allocated to 'value' in
    btrfs_get_acl() if the call to posix_acl_from_xattr() fails.
    Here's a patch that attempts to correct that problem.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 2222d161c7b6..6d1410e392d3 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -60,8 +60,10 @@ static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 		size = __btrfs_getxattr(inode, name, value, size);
 		if (size > 0) {
 			acl = posix_acl_from_xattr(value, size);
-			if (IS_ERR(acl))
+			if (IS_ERR(acl)) {
+				kfree(value);
 				return acl;
+			}
 			set_cached_acl(inode, type, acl);
 		}
 		kfree(value);

commit 258a5aa8dfc6294f5f7df892023ee4d3e57c9841
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:50:01 2011 +1100

    btrfs: provide simple rcu-walk ACL implementation
    
    This simple implementation just checks for no ACLs on the inode, and
    if so, then the rcu-walk may proceed, otherwise fail it.
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index cb518a4b917c..6ae2c8cac9d5 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -187,18 +187,21 @@ static int btrfs_xattr_acl_set(struct dentry *dentry, const char *name,
 
 int btrfs_check_acl(struct inode *inode, int mask, unsigned int flags)
 {
-	struct posix_acl *acl;
 	int error = -EAGAIN;
 
-	if (flags & IPERM_FLAG_RCU)
-		return -ECHILD;
+	if (flags & IPERM_FLAG_RCU) {
+		if (!negative_cached_acl(inode, ACL_TYPE_ACCESS))
+			error = -ECHILD;
 
-	acl = btrfs_get_acl(inode, ACL_TYPE_ACCESS);
-	if (IS_ERR(acl))
-		return PTR_ERR(acl);
-	if (acl) {
-		error = posix_acl_permission(inode, acl, mask);
-		posix_acl_release(acl);
+	} else {
+		struct posix_acl *acl;
+		acl = btrfs_get_acl(inode, ACL_TYPE_ACCESS);
+		if (IS_ERR(acl))
+			return PTR_ERR(acl);
+		if (acl) {
+			error = posix_acl_permission(inode, acl, mask);
+			posix_acl_release(acl);
+		}
 	}
 
 	return error;

commit b74c79e99389cd79b31fcc08f82c24e492e63c7e
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:49:58 2011 +1100

    fs: provide rcu-walk aware permission i_ops
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 2222d161c7b6..cb518a4b917c 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -185,13 +185,15 @@ static int btrfs_xattr_acl_set(struct dentry *dentry, const char *name,
 	return ret;
 }
 
-int btrfs_check_acl(struct inode *inode, int mask)
+int btrfs_check_acl(struct inode *inode, int mask, unsigned int flags)
 {
 	struct posix_acl *acl;
 	int error = -EAGAIN;
 
-	acl = btrfs_get_acl(inode, ACL_TYPE_ACCESS);
+	if (flags & IPERM_FLAG_RCU)
+		return -ECHILD;
 
+	acl = btrfs_get_acl(inode, ACL_TYPE_ACCESS);
 	if (IS_ERR(acl))
 		return PTR_ERR(acl);
 	if (acl) {

commit b25b550bb153626df6a48eb8583e923e3dfcf64a
Merge: eda054770e5c 6f902af400b2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 11 14:18:47 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable:
      Btrfs: The file argument for fsync() is never null
      Btrfs: handle ERR_PTR from posix_acl_from_xattr()
      Btrfs: avoid BUG when dropping root and reference in same transaction
      Btrfs: prohibit a operation of changing acl's mask when noacl mount option used
      Btrfs: should add a permission check for setfacl
      Btrfs: btrfs_lookup_dir_item() can return ERR_PTR
      Btrfs: btrfs_read_fs_root_no_name() returns ERR_PTRs
      Btrfs: unwind after btrfs_start_transaction() errors
      Btrfs: btrfs_iget() returns ERR_PTR
      Btrfs: handle kzalloc() failure in open_ctree()
      Btrfs: handle error returns from btrfs_lookup_dir_item()
      Btrfs: Fix BUG_ON for fs converted from extN
      Btrfs: Fix null dereference in relocation.c
      Btrfs: fix remap_file_pages error
      Btrfs: uninitialized data is check_path_shared()
      Btrfs: fix fallocate regression
      Btrfs: fix loop device on top of btrfs

commit 834e74759a473f8101a273e843d1edec2778801d
Author: Dan Carpenter <error27@gmail.com>
Date:   Sat May 29 09:48:35 2010 +0000

    Btrfs: handle ERR_PTR from posix_acl_from_xattr()
    
    posix_acl_from_xattr() returns both ERR_PTRs and null, but it's OK to
    pass null values to set_cached_acl()
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index a372985b3a9a..1606dc1e8d4a 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -60,6 +60,8 @@ static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 		size = __btrfs_getxattr(inode, name, value, size);
 		if (size > 0) {
 			acl = posix_acl_from_xattr(value, size);
+			if (IS_ERR(acl))
+				return acl;
 			set_cached_acl(inode, type, acl);
 		}
 		kfree(value);

commit 731e3d1b4348a96d53de6c084774424dedc64a3b
Author: Shi Weihua <shiwh@cn.fujitsu.com>
Date:   Tue May 18 00:51:54 2010 +0000

    Btrfs: prohibit a operation of changing acl's mask when noacl mount option used
    
    when used Posix File System Test Suite(pjd-fstest) to test btrfs,
    some cases about setfacl failed when noacl mount option used.
    I simplified used commands in pjd-fstest, and the following steps
    can reproduce it.
    ------------------------
    # cd btrfs-part/
    # mkdir aaa
    # setfacl -m m::rw aaa    <- successed, but not expected by pjd-fstest.
    ------------------------
    I checked ext3, a warning message occured, like as:
      setfacl: aaa/: Operation not supported
    Certainly, it's expected by pjd-fstest.
    
    So, i compared acl.c of btrfs and ext3. Based on that, a patch created.
    Fortunately, it works.
    
    Signed-off-by: Shi Weihua <shiwh@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 6b4d0cca5c7f..a372985b3a9a 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -163,6 +163,9 @@ static int btrfs_xattr_acl_set(struct dentry *dentry, const char *name,
 	if (!is_owner_or_cap(dentry->d_inode))
 		return -EPERM;
 
+	if (!IS_POSIXACL(dentry->d_inode))
+		return -EOPNOTSUPP;
+
 	if (value) {
 		acl = posix_acl_from_xattr(value, size);
 		if (acl == NULL) {

commit 2f26afba46f0ebf155cf9be746496a0304a5b7cf
Author: Shi Weihua <shiwh@cn.fujitsu.com>
Date:   Tue May 18 00:50:32 2010 +0000

    Btrfs: should add a permission check for setfacl
    
    On btrfs, do the following
    ------------------
    # su user1
    # cd btrfs-part/
    # touch aaa
    # getfacl aaa
      # file: aaa
      # owner: user1
      # group: user1
      user::rw-
      group::rw-
      other::r--
    # su user2
    # cd btrfs-part/
    # setfacl -m u::rwx aaa
    # getfacl aaa
      # file: aaa
      # owner: user1
      # group: user1
      user::rwx           <- successed to setfacl
      group::rw-
      other::r--
    ------------------
    but we should prohibit it that user2 changing user1's acl.
    In fact, on ext3 and other fs, a message occurs:
      setfacl: aaa: Operation not permitted
    
    This patch fixed it.
    Signed-off-by: Shi Weihua <shiwh@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 6ef7b26724ec..6b4d0cca5c7f 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -160,6 +160,9 @@ static int btrfs_xattr_acl_set(struct dentry *dentry, const char *name,
 	int ret;
 	struct posix_acl *acl = NULL;
 
+	if (!is_owner_or_cap(dentry->d_inode))
+		return -EPERM;
+
 	if (value) {
 		acl = posix_acl_from_xattr(value, size);
 		if (acl == NULL) {

commit f01cbd3f8148f2056567f829e07c157b28b2dd1e
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Thu May 13 17:53:15 2010 -0700

    btrfs: constify xattr_handler
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 6ef7b26724ec..8d432cd9d580 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -282,14 +282,14 @@ int btrfs_acl_chmod(struct inode *inode)
 	return ret;
 }
 
-struct xattr_handler btrfs_xattr_acl_default_handler = {
+const struct xattr_handler btrfs_xattr_acl_default_handler = {
 	.prefix = POSIX_ACL_XATTR_DEFAULT,
 	.flags	= ACL_TYPE_DEFAULT,
 	.get	= btrfs_xattr_acl_get,
 	.set	= btrfs_xattr_acl_set,
 };
 
-struct xattr_handler btrfs_xattr_acl_access_handler = {
+const struct xattr_handler btrfs_xattr_acl_access_handler = {
 	.prefix = POSIX_ACL_XATTR_ACCESS,
 	.flags	= ACL_TYPE_ACCESS,
 	.get	= btrfs_xattr_acl_get,

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 6df6d6ed74fd..6ef7b26724ec 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -22,6 +22,7 @@
 #include <linux/posix_acl_xattr.h>
 #include <linux/posix_acl.h>
 #include <linux/sched.h>
+#include <linux/slab.h>
 
 #include "ctree.h"
 #include "btrfs_inode.h"

commit 67f15b06c1a7e5417b7042b515ca2695de30beda
Merge: 94673e968cbc 035fe03a7ad5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 29 10:27:37 2010 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable:
      Btrfs: check total number of devices when removing missing
      Btrfs: check return value of open_bdev_exclusive properly
      Btrfs: do not mark the chunk as readonly if in degraded mode
      Btrfs: run orphan cleanup on default fs root
      Btrfs: fix a memory leak in btrfs_init_acl
      Btrfs: Use correct values when updating inode i_size on fallocate
      Btrfs: remove tree_search() in extent_map.c
      Btrfs: Add mount -o compress-force

commit f858153c367a397235d3e81136741e40e44faf1d
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Tue Jan 26 00:48:23 2010 +0000

    Btrfs: fix a memory leak in btrfs_init_acl
    
    In btrfs_init_acl() cloned acl is not released
    
    Signed-off-by: Yang Hongyang <yanghy@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index fa44e92e9b8f..da3133c69830 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -269,6 +269,7 @@ int btrfs_init_acl(struct btrfs_trans_handle *trans,
 						    ACL_TYPE_ACCESS);
 			}
 		}
+		posix_acl_release(clone);
 	}
 failed:
 	posix_acl_release(acl);

commit 30a0f5e1fb510f17c25ff159a9fffbe01ae0f34e
Merge: 88f5004430ba 11dfe35a0108
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 21 07:28:05 2010 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable:
      Btrfs: fix possible panic on unmount
      Btrfs: deal with NULL acl sent to btrfs_set_acl
      Btrfs: fix regression in orphan cleanup
      Btrfs: Fix race in btrfs_mark_extent_written
      Btrfs, fix memory leaks in error paths
      Btrfs: align offsets for btrfs_ordered_update_i_size
      btrfs: fix missing last-entry in readdir(3)

commit a9cc71a60c29a09174bee2fcef8f924c529fd4b7
Author: Chris Mason <chris.mason@oracle.com>
Date:   Sun Jan 17 20:36:18 2010 -0500

    Btrfs: deal with NULL acl sent to btrfs_set_acl
    
    It is legal for btrfs_set_acl to be sent a NULL acl.  This
    makes sure we don't dereference it.  A similar patch was sent by
    Johannes Hirte <johannes.hirte@fem.tu-ilmenau.de>
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 1898f8555f06..fa44e92e9b8f 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -112,12 +112,14 @@ static int btrfs_set_acl(struct btrfs_trans_handle *trans,
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		mode = inode->i_mode;
-		ret = posix_acl_equiv_mode(acl, &mode);
-		if (ret < 0)
-			return ret;
-		ret = 0;
-		inode->i_mode = mode;
 		name = POSIX_ACL_XATTR_ACCESS;
+		if (acl) {
+			ret = posix_acl_equiv_mode(acl, &mode);
+			if (ret < 0)
+				return ret;
+			inode->i_mode = mode;
+		}
+		ret = 0;
 		break;
 	case ACL_TYPE_DEFAULT:
 		if (!S_ISDIR(inode->i_mode))

commit ebfee3d71d5a29102aac1fb2e756b8258f753592
Merge: b8a7f3cd7e82 83d3c9696fed
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Dec 17 15:02:22 2009 -0500

    Merge branch btrfs-master into for-linus
    
    Conflicts:
            fs/btrfs/acl.c

commit f34f57a3ab4e73304d78c125682f1a53cd3975f2
Author: Yan, Zheng <zheng.yan@oracle.com>
Date:   Thu Nov 12 09:35:27 2009 +0000

    Btrfs: Pass transaction handle to security and ACL initialization functions
    
    Pass transaction handle down to security and ACL initialization
    functions, so we can avoid starting nested transactions
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 361604244271..1898f8555f06 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -94,7 +94,8 @@ static int btrfs_xattr_get_acl(struct inode *inode, int type,
 /*
  * Needs to be called with fs_mutex held
  */
-static int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
+static int btrfs_set_acl(struct btrfs_trans_handle *trans,
+			 struct inode *inode, struct posix_acl *acl, int type)
 {
 	int ret, size = 0;
 	const char *name;
@@ -140,8 +141,7 @@ static int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 			goto out;
 	}
 
-	ret = __btrfs_setxattr(inode, name, value, size, 0);
-
+	ret = __btrfs_setxattr(trans, inode, name, value, size, 0);
 out:
 	kfree(value);
 
@@ -154,7 +154,7 @@ static int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 static int btrfs_xattr_set_acl(struct inode *inode, int type,
 			       const void *value, size_t size)
 {
-	int ret = 0;
+	int ret;
 	struct posix_acl *acl = NULL;
 
 	if (value) {
@@ -167,7 +167,7 @@ static int btrfs_xattr_set_acl(struct inode *inode, int type,
 		}
 	}
 
-	ret = btrfs_set_acl(inode, acl, type);
+	ret = btrfs_set_acl(NULL, inode, acl, type);
 
 	posix_acl_release(acl);
 
@@ -221,7 +221,8 @@ int btrfs_check_acl(struct inode *inode, int mask)
  * stuff has been fixed to work with that.  If the locking stuff changes, we
  * need to re-evaluate the acl locking stuff.
  */
-int btrfs_init_acl(struct inode *inode, struct inode *dir)
+int btrfs_init_acl(struct btrfs_trans_handle *trans,
+		   struct inode *inode, struct inode *dir)
 {
 	struct posix_acl *acl = NULL;
 	int ret = 0;
@@ -246,7 +247,8 @@ int btrfs_init_acl(struct inode *inode, struct inode *dir)
 		mode_t mode;
 
 		if (S_ISDIR(inode->i_mode)) {
-			ret = btrfs_set_acl(inode, acl, ACL_TYPE_DEFAULT);
+			ret = btrfs_set_acl(trans, inode, acl,
+					    ACL_TYPE_DEFAULT);
 			if (ret)
 				goto failed;
 		}
@@ -261,7 +263,7 @@ int btrfs_init_acl(struct inode *inode, struct inode *dir)
 			inode->i_mode = mode;
 			if (ret > 0) {
 				/* we need an acl */
-				ret = btrfs_set_acl(inode, clone,
+				ret = btrfs_set_acl(trans, inode, clone,
 						    ACL_TYPE_ACCESS);
 			}
 		}
@@ -294,7 +296,7 @@ int btrfs_acl_chmod(struct inode *inode)
 
 	ret = posix_acl_chmod_masq(clone, inode->i_mode);
 	if (!ret)
-		ret = btrfs_set_acl(inode, clone, ACL_TYPE_ACCESS);
+		ret = btrfs_set_acl(NULL, inode, clone, ACL_TYPE_ACCESS);
 
 	posix_acl_release(clone);
 
@@ -320,7 +322,8 @@ int btrfs_acl_chmod(struct inode *inode)
 	return 0;
 }
 
-int btrfs_init_acl(struct inode *inode, struct inode *dir)
+int btrfs_init_acl(struct btrfs_trans_handle *trans,
+		   struct inode *inode, struct inode *dir)
 {
 	return 0;
 }

commit 431547b3c4533b8c7fd150ab36980b9a3147797b
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Nov 13 09:52:56 2009 +0000

    sanitize xattr handler prototypes
    
    Add a flags argument to struct xattr_handler and pass it to all xattr
    handler methods.  This allows using the same methods for multiple
    handlers, e.g. for the ACL methods which perform exactly the same action
    for the access and default ACLs, just using a different underlying
    attribute.  With a little more groundwork it'll also allow sharing the
    methods for the regular user/trusted/secure handlers in extN, ocfs2 and
    jffs2 like it's already done for xfs in this patch.
    
    Also change the inode argument to the handlers to a dentry to allow
    using the handlers mechnism for filesystems that require it later,
    e.g. cifs.
    
    [with GFS2 bits updated by Steven Whitehouse <swhiteho@redhat.com>]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: James Morris <jmorris@namei.org>
    Acked-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 361604244271..52cbe47022bf 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -73,13 +73,13 @@ static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 	return acl;
 }
 
-static int btrfs_xattr_get_acl(struct inode *inode, int type,
-			       void *value, size_t size)
+static int btrfs_xattr_acl_get(struct dentry *dentry, const char *name,
+		void *value, size_t size, int type)
 {
 	struct posix_acl *acl;
 	int ret = 0;
 
-	acl = btrfs_get_acl(inode, type);
+	acl = btrfs_get_acl(dentry->d_inode, type);
 
 	if (IS_ERR(acl))
 		return PTR_ERR(acl);
@@ -151,8 +151,8 @@ static int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 	return ret;
 }
 
-static int btrfs_xattr_set_acl(struct inode *inode, int type,
-			       const void *value, size_t size)
+static int btrfs_xattr_acl_set(struct dentry *dentry, const char *name,
+		const void *value, size_t size, int flags, int type)
 {
 	int ret = 0;
 	struct posix_acl *acl = NULL;
@@ -167,38 +167,13 @@ static int btrfs_xattr_set_acl(struct inode *inode, int type,
 		}
 	}
 
-	ret = btrfs_set_acl(inode, acl, type);
+	ret = btrfs_set_acl(dentry->d_inode, acl, type);
 
 	posix_acl_release(acl);
 
 	return ret;
 }
 
-
-static int btrfs_xattr_acl_access_get(struct inode *inode, const char *name,
-				      void *value, size_t size)
-{
-	return btrfs_xattr_get_acl(inode, ACL_TYPE_ACCESS, value, size);
-}
-
-static int btrfs_xattr_acl_access_set(struct inode *inode, const char *name,
-				      const void *value, size_t size, int flags)
-{
-	return btrfs_xattr_set_acl(inode, ACL_TYPE_ACCESS, value, size);
-}
-
-static int btrfs_xattr_acl_default_get(struct inode *inode, const char *name,
-				       void *value, size_t size)
-{
-	return btrfs_xattr_get_acl(inode, ACL_TYPE_DEFAULT, value, size);
-}
-
-static int btrfs_xattr_acl_default_set(struct inode *inode, const char *name,
-			       const void *value, size_t size, int flags)
-{
-	return btrfs_xattr_set_acl(inode, ACL_TYPE_DEFAULT, value, size);
-}
-
 int btrfs_check_acl(struct inode *inode, int mask)
 {
 	struct posix_acl *acl;
@@ -303,14 +278,16 @@ int btrfs_acl_chmod(struct inode *inode)
 
 struct xattr_handler btrfs_xattr_acl_default_handler = {
 	.prefix = POSIX_ACL_XATTR_DEFAULT,
-	.get	= btrfs_xattr_acl_default_get,
-	.set	= btrfs_xattr_acl_default_set,
+	.flags	= ACL_TYPE_DEFAULT,
+	.get	= btrfs_xattr_acl_get,
+	.set	= btrfs_xattr_acl_set,
 };
 
 struct xattr_handler btrfs_xattr_acl_access_handler = {
 	.prefix = POSIX_ACL_XATTR_ACCESS,
-	.get	= btrfs_xattr_acl_access_get,
-	.set	= btrfs_xattr_acl_access_set,
+	.flags	= ACL_TYPE_ACCESS,
+	.get	= btrfs_xattr_acl_get,
+	.set	= btrfs_xattr_acl_set,
 };
 
 #else /* CONFIG_BTRFS_FS_POSIX_ACL */

commit 0eda294dfc980c1cbe4f8a0564bf543f86a01ddb
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Oct 13 13:50:18 2009 -0400

    Btrfs: fix btrfs acl #ifdef checks
    
    The btrfs acl code was #ifdefing for a define
    that didn't exist.  This correctly matches it
    to the values used by the Kconfig file.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 69b355ae7f49..361604244271 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -27,7 +27,7 @@
 #include "btrfs_inode.h"
 #include "xattr.h"
 
-#ifdef CONFIG_BTRFS_POSIX_ACL
+#ifdef CONFIG_BTRFS_FS_POSIX_ACL
 
 static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 {
@@ -313,7 +313,7 @@ struct xattr_handler btrfs_xattr_acl_access_handler = {
 	.set	= btrfs_xattr_acl_access_set,
 };
 
-#else /* CONFIG_BTRFS_POSIX_ACL */
+#else /* CONFIG_BTRFS_FS_POSIX_ACL */
 
 int btrfs_acl_chmod(struct inode *inode)
 {
@@ -325,4 +325,4 @@ int btrfs_init_acl(struct inode *inode, struct inode *dir)
 	return 0;
 }
 
-#endif /* CONFIG_BTRFS_POSIX_ACL */
+#endif /* CONFIG_BTRFS_FS_POSIX_ACL */

commit 3baf0bed0a5adab95c7599d2f27124c74692ef28
Author: Chris Ball <cjb@laptop.org>
Date:   Tue Sep 29 13:51:05 2009 -0400

    Btrfs: Use CONFIG_BTRFS_POSIX_ACL to enable ACL code
    
    We've already defined CONFIG_BTRFS_POSIX_ACL in Kconfig, but we're
    currently not using it and are testing CONFIG_FS_POSIX_ACL instead.
    CONFIG_FS_POSIX_ACL states "Never use this symbol for ifdefs".
    
    Signed-off-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index f128427b995b..69b355ae7f49 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -27,7 +27,7 @@
 #include "btrfs_inode.h"
 #include "xattr.h"
 
-#ifdef CONFIG_FS_POSIX_ACL
+#ifdef CONFIG_BTRFS_POSIX_ACL
 
 static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 {
@@ -313,7 +313,7 @@ struct xattr_handler btrfs_xattr_acl_access_handler = {
 	.set	= btrfs_xattr_acl_access_set,
 };
 
-#else /* CONFIG_FS_POSIX_ACL */
+#else /* CONFIG_BTRFS_POSIX_ACL */
 
 int btrfs_acl_chmod(struct inode *inode)
 {
@@ -325,4 +325,4 @@ int btrfs_init_acl(struct inode *inode, struct inode *dir)
 	return 0;
 }
 
-#endif /* CONFIG_FS_POSIX_ACL */
+#endif /* CONFIG_BTRFS_POSIX_ACL */

commit 073aaa1b142461d91f83da66db1184d7c1b1edea
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jun 9 12:11:54 2009 -0400

    helpers for acl caching + switch to those
    
    helpers: get_cached_acl(inode, type), set_cached_acl(inode, type, acl),
    forget_cached_acl(inode, type).
    
    ubifs/xattr.c needed includes reordered, the rest is a plain switchover.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 6db8a42a3e5e..f128427b995b 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -29,51 +29,28 @@
 
 #ifdef CONFIG_FS_POSIX_ACL
 
-static void btrfs_update_cached_acl(struct inode *inode,
-				    struct posix_acl **p_acl,
-				    struct posix_acl *acl)
-{
-	spin_lock(&inode->i_lock);
-	if (*p_acl && *p_acl != ACL_NOT_CACHED)
-		posix_acl_release(*p_acl);
-	*p_acl = posix_acl_dup(acl);
-	spin_unlock(&inode->i_lock);
-}
-
 static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 {
 	int size;
 	const char *name;
 	char *value = NULL;
-	struct posix_acl *acl = NULL, **p_acl;
+	struct posix_acl *acl;
+
+	acl = get_cached_acl(inode, type);
+	if (acl != ACL_NOT_CACHED)
+		return acl;
 
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
-		p_acl = &inode->i_acl;
 		break;
 	case ACL_TYPE_DEFAULT:
 		name = POSIX_ACL_XATTR_DEFAULT;
-		p_acl = &inode->i_default_acl;
 		break;
 	default:
-		return ERR_PTR(-EINVAL);
+		BUG();
 	}
 
-	/* Handle the cached NULL acl case without locking */
-	acl = ACCESS_ONCE(*p_acl);
-	if (!acl)
-		return acl;
-
-	spin_lock(&inode->i_lock);
-	acl = *p_acl;
-	if (acl != ACL_NOT_CACHED)
-		acl = posix_acl_dup(acl);
-	spin_unlock(&inode->i_lock);
-
-	if (acl != ACL_NOT_CACHED)
-		return acl;
-
 	size = __btrfs_getxattr(inode, name, "", 0);
 	if (size > 0) {
 		value = kzalloc(size, GFP_NOFS);
@@ -82,13 +59,13 @@ static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 		size = __btrfs_getxattr(inode, name, value, size);
 		if (size > 0) {
 			acl = posix_acl_from_xattr(value, size);
-			btrfs_update_cached_acl(inode, p_acl, acl);
+			set_cached_acl(inode, type, acl);
 		}
 		kfree(value);
 	} else if (size == -ENOENT || size == -ENODATA || size == 0) {
 		/* FIXME, who returns -ENOENT?  I think nobody */
 		acl = NULL;
-		btrfs_update_cached_acl(inode, p_acl, acl);
+		set_cached_acl(inode, type, acl);
 	} else {
 		acl = ERR_PTR(-EIO);
 	}
@@ -121,7 +98,6 @@ static int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 {
 	int ret, size = 0;
 	const char *name;
-	struct posix_acl **p_acl;
 	char *value = NULL;
 	mode_t mode;
 
@@ -141,13 +117,11 @@ static int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 		ret = 0;
 		inode->i_mode = mode;
 		name = POSIX_ACL_XATTR_ACCESS;
-		p_acl = &inode->i_acl;
 		break;
 	case ACL_TYPE_DEFAULT:
 		if (!S_ISDIR(inode->i_mode))
 			return acl ? -EINVAL : 0;
 		name = POSIX_ACL_XATTR_DEFAULT;
-		p_acl = &inode->i_default_acl;
 		break;
 	default:
 		return -EINVAL;
@@ -172,7 +146,7 @@ static int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 	kfree(value);
 
 	if (!ret)
-		btrfs_update_cached_acl(inode, p_acl, acl);
+		set_cached_acl(inode, type, acl);
 
 	return ret;
 }

commit 5affd88a104af43f0063a12ad1ee4c7a587945dc
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 8 19:55:32 2009 -0400

    switch btrfs to inode->i_acl
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 603972576f0f..6db8a42a3e5e 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -34,7 +34,7 @@ static void btrfs_update_cached_acl(struct inode *inode,
 				    struct posix_acl *acl)
 {
 	spin_lock(&inode->i_lock);
-	if (*p_acl && *p_acl != BTRFS_ACL_NOT_CACHED)
+	if (*p_acl && *p_acl != ACL_NOT_CACHED)
 		posix_acl_release(*p_acl);
 	*p_acl = posix_acl_dup(acl);
 	spin_unlock(&inode->i_lock);
@@ -50,11 +50,11 @@ static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
-		p_acl = &BTRFS_I(inode)->i_acl;
+		p_acl = &inode->i_acl;
 		break;
 	case ACL_TYPE_DEFAULT:
 		name = POSIX_ACL_XATTR_DEFAULT;
-		p_acl = &BTRFS_I(inode)->i_default_acl;
+		p_acl = &inode->i_default_acl;
 		break;
 	default:
 		return ERR_PTR(-EINVAL);
@@ -67,11 +67,11 @@ static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 
 	spin_lock(&inode->i_lock);
 	acl = *p_acl;
-	if (acl != BTRFS_ACL_NOT_CACHED)
+	if (acl != ACL_NOT_CACHED)
 		acl = posix_acl_dup(acl);
 	spin_unlock(&inode->i_lock);
 
-	if (acl != BTRFS_ACL_NOT_CACHED)
+	if (acl != ACL_NOT_CACHED)
 		return acl;
 
 	size = __btrfs_getxattr(inode, name, "", 0);
@@ -141,13 +141,13 @@ static int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 		ret = 0;
 		inode->i_mode = mode;
 		name = POSIX_ACL_XATTR_ACCESS;
-		p_acl = &BTRFS_I(inode)->i_acl;
+		p_acl = &inode->i_acl;
 		break;
 	case ACL_TYPE_DEFAULT:
 		if (!S_ISDIR(inode->i_mode))
 			return acl ? -EINVAL : 0;
 		name = POSIX_ACL_XATTR_DEFAULT;
-		p_acl = &BTRFS_I(inode)->i_default_acl;
+		p_acl = &inode->i_default_acl;
 		break;
 	default:
 		return -EINVAL;

commit 7df336ec1266dccbb253bac52c529d3dcc7c22d0
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Wed Jun 10 11:36:43 2009 -0400

    Fix btrfs when ACLs are configured out
    
    ... otherwise generic_permission() will allow *anything* for all
    files you don't own and that have some group permissions.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index cbba000dccbe..603972576f0f 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -351,9 +351,4 @@ int btrfs_init_acl(struct inode *inode, struct inode *dir)
 	return 0;
 }
 
-int btrfs_check_acl(struct inode *inode, int mask)
-{
-	return 0;
-}
-
 #endif /* CONFIG_FS_POSIX_ACL */

commit 7b1a14bbb0e547aaa4d30cc376e6c8c12539ab0f
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Apr 27 10:49:53 2009 -0400

    Btrfs: fix acl caching
    
    Linus noticed the btrfs code to cache acls wasn't properly caching
    a NULL acl when the inode didn't have any acls.  This meant the common
    case of no acls resulted in expensive btree searches every time the
    kernel checked permissions (which is quite often).
    
    This is a modified version of Linus' original patch:
    
    Properly set initial acl fields to BTRFS_ACL_NOT_CACHED in the inode.
    This forces an acl lookup when permission checks are done.
    
    Fix btrfs_get_acl to avoid lookups and locking when the inode acls fields
    are set to null.
    
    Fix btrfs_get_acl to use the right return value from __btrfs_getxattr
    when deciding to cache a NULL acl.  It was storing a NULL acl when
    __btrfs_getxattr return -ENOENT, but __btrfs_getxattr was actually returning
    -ENODATA for this case.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 7fdd184a528d..cbba000dccbe 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -60,15 +60,20 @@ static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 		return ERR_PTR(-EINVAL);
 	}
 
+	/* Handle the cached NULL acl case without locking */
+	acl = ACCESS_ONCE(*p_acl);
+	if (!acl)
+		return acl;
+
 	spin_lock(&inode->i_lock);
-	if (*p_acl != BTRFS_ACL_NOT_CACHED)
-		acl = posix_acl_dup(*p_acl);
+	acl = *p_acl;
+	if (acl != BTRFS_ACL_NOT_CACHED)
+		acl = posix_acl_dup(acl);
 	spin_unlock(&inode->i_lock);
 
-	if (acl)
+	if (acl != BTRFS_ACL_NOT_CACHED)
 		return acl;
 
-
 	size = __btrfs_getxattr(inode, name, "", 0);
 	if (size > 0) {
 		value = kzalloc(size, GFP_NOFS);
@@ -80,9 +85,12 @@ static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 			btrfs_update_cached_acl(inode, p_acl, acl);
 		}
 		kfree(value);
-	} else if (size == -ENOENT) {
+	} else if (size == -ENOENT || size == -ENODATA || size == 0) {
+		/* FIXME, who returns -ENOENT?  I think nobody */
 		acl = NULL;
 		btrfs_update_cached_acl(inode, p_acl, acl);
+	} else {
+		acl = ERR_PTR(-EIO);
 	}
 
 	return acl;

commit ce3b0f8d5c2203301fc87f3aaaed73e5819e2a48
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 29 19:08:22 2009 -0400

    New helper - current_umask()
    
    current->fs->umask is what most of fs_struct users are doing.
    Put that into a helper function.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 1d53b62dbba5..7fdd184a528d 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -256,7 +256,7 @@ int btrfs_init_acl(struct inode *inode, struct inode *dir)
 		}
 
 		if (!acl)
-			inode->i_mode &= ~current->fs->umask;
+			inode->i_mode &= ~current_umask();
 	}
 
 	if (IS_POSIXACL(dir) && acl) {

commit d397712bcc6a759a560fd247e6053ecae091f958
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Jan 5 21:25:51 2009 -0500

    Btrfs: Fix checkpatch.pl warnings
    
    There were many, most are fixed now.  struct-funcs.c generates some warnings
    but these are bogus.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 867eaf1f8efb..1d53b62dbba5 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -161,8 +161,7 @@ static int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 	ret = __btrfs_setxattr(inode, name, value, size, 0);
 
 out:
-	if (value)
-		kfree(value);
+	kfree(value);
 
 	if (!ret)
 		btrfs_update_cached_acl(inode, p_acl, acl);
@@ -213,7 +212,7 @@ static int btrfs_xattr_acl_default_get(struct inode *inode, const char *name,
 }
 
 static int btrfs_xattr_acl_default_set(struct inode *inode, const char *name,
-				       const void *value, size_t size, int flags)
+			       const void *value, size_t size, int flags)
 {
 	return btrfs_xattr_set_acl(inode, ACL_TYPE_DEFAULT, value, size);
 }

commit 95819c05732c511338b43c115ffbcee978c02888
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Aug 28 06:21:17 2008 -0400

    Btrfs: optimize btrget/set/removexattr
    
    btrfs actually stores the whole xattr name, including the prefix ondisk,
    so using the generic resolver that strips off the prefix is not very
    helpful.  Instead do the real ondisk xattrs manually and only use the
    generic resolver for synthetic xattrs like ACLs.
    
    (Sorry Josef for guiding you towards the wrong direction here intially)
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 2f865311460c..867eaf1f8efb 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -42,17 +42,18 @@ static void btrfs_update_cached_acl(struct inode *inode,
 
 static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 {
-	int size, name_index;
+	int size;
+	const char *name;
 	char *value = NULL;
 	struct posix_acl *acl = NULL, **p_acl;
 
 	switch (type) {
 	case ACL_TYPE_ACCESS:
-		name_index = BTRFS_XATTR_INDEX_POSIX_ACL_ACCESS;
+		name = POSIX_ACL_XATTR_ACCESS;
 		p_acl = &BTRFS_I(inode)->i_acl;
 		break;
 	case ACL_TYPE_DEFAULT:
-		name_index = BTRFS_XATTR_INDEX_POSIX_ACL_DEFAULT;
+		name = POSIX_ACL_XATTR_DEFAULT;
 		p_acl = &BTRFS_I(inode)->i_default_acl;
 		break;
 	default:
@@ -68,12 +69,12 @@ static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 		return acl;
 
 
-	size = btrfs_xattr_get(inode, name_index, "", NULL, 0);
+	size = __btrfs_getxattr(inode, name, "", 0);
 	if (size > 0) {
 		value = kzalloc(size, GFP_NOFS);
 		if (!value)
 			return ERR_PTR(-ENOMEM);
-		size = btrfs_xattr_get(inode, name_index, "", value, size);
+		size = __btrfs_getxattr(inode, name, value, size);
 		if (size > 0) {
 			acl = posix_acl_from_xattr(value, size);
 			btrfs_update_cached_acl(inode, p_acl, acl);
@@ -110,7 +111,8 @@ static int btrfs_xattr_get_acl(struct inode *inode, int type,
  */
 static int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 {
-	int ret, name_index = 0, size = 0;
+	int ret, size = 0;
+	const char *name;
 	struct posix_acl **p_acl;
 	char *value = NULL;
 	mode_t mode;
@@ -130,13 +132,13 @@ static int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 			return ret;
 		ret = 0;
 		inode->i_mode = mode;
-		name_index = BTRFS_XATTR_INDEX_POSIX_ACL_ACCESS;
+		name = POSIX_ACL_XATTR_ACCESS;
 		p_acl = &BTRFS_I(inode)->i_acl;
 		break;
 	case ACL_TYPE_DEFAULT:
 		if (!S_ISDIR(inode->i_mode))
 			return acl ? -EINVAL : 0;
-		name_index = BTRFS_XATTR_INDEX_POSIX_ACL_DEFAULT;
+		name = POSIX_ACL_XATTR_DEFAULT;
 		p_acl = &BTRFS_I(inode)->i_default_acl;
 		break;
 	default:
@@ -156,7 +158,7 @@ static int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 			goto out;
 	}
 
-	ret = btrfs_xattr_set(inode, name_index, "", value, size, 0);
+	ret = __btrfs_setxattr(inode, name, value, size, 0);
 
 out:
 	if (value)

commit eaa47d8612783807ef9703ebc9bf0d0f0455bf62
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Aug 28 06:21:16 2008 -0400

    btrfs: optmize listxattr
    
    The ->list handler is really not useful at all, because we always call
    btrfs_xattr_generic_list anyway.  After this is done
    find_btrfs_xattr_handler becomes unused, and it becomes obvious that the
    temporary name buffer allocation isn't needed but we can directly copy
    into the supplied buffer.
    
    Tested with various getfattr -d calls on varying xattr lists.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index b95147ef1c77..2f865311460c 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -320,14 +320,12 @@ int btrfs_acl_chmod(struct inode *inode)
 
 struct xattr_handler btrfs_xattr_acl_default_handler = {
 	.prefix = POSIX_ACL_XATTR_DEFAULT,
-	.list	= btrfs_xattr_generic_list,
 	.get	= btrfs_xattr_acl_default_get,
 	.set	= btrfs_xattr_acl_default_set,
 };
 
 struct xattr_handler btrfs_xattr_acl_access_handler = {
 	.prefix = POSIX_ACL_XATTR_ACCESS,
-	.list	= btrfs_xattr_generic_list,
 	.get	= btrfs_xattr_acl_access_get,
 	.set	= btrfs_xattr_acl_access_set,
 };

commit eab922ec8907b8c506e799785e7e2d16eabe50e4
Author: Josef Bacik <jbacik@redhat.com>
Date:   Thu Aug 28 06:21:15 2008 -0400

    Btrfs: compile when posix acl's are disabled
    
    This patch makes btrfs so it will compile properly when acls are disabled.  I
    tested this and it worked with CONFIG_FS_POSIX_ACL off and on.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index b192659b4f5f..b95147ef1c77 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -27,6 +27,8 @@
 #include "btrfs_inode.h"
 #include "xattr.h"
 
+#ifdef CONFIG_FS_POSIX_ACL
+
 static void btrfs_update_cached_acl(struct inode *inode,
 				    struct posix_acl **p_acl,
 				    struct posix_acl *acl)
@@ -329,3 +331,22 @@ struct xattr_handler btrfs_xattr_acl_access_handler = {
 	.get	= btrfs_xattr_acl_access_get,
 	.set	= btrfs_xattr_acl_access_set,
 };
+
+#else /* CONFIG_FS_POSIX_ACL */
+
+int btrfs_acl_chmod(struct inode *inode)
+{
+	return 0;
+}
+
+int btrfs_init_acl(struct inode *inode, struct inode *dir)
+{
+	return 0;
+}
+
+int btrfs_check_acl(struct inode *inode, int mask)
+{
+	return 0;
+}
+
+#endif /* CONFIG_FS_POSIX_ACL */

commit 33268eaf0b3db5e2bd12c0ada81a8e8f87a46d68
Author: Josef Bacik <jbacik@redhat.com>
Date:   Thu Jul 24 12:16:36 2008 -0400

    Btrfs: Add ACL support
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index ff0fcc72848a..b192659b4f5f 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -20,76 +20,302 @@
 #include <linux/string.h>
 #include <linux/xattr.h>
 #include <linux/posix_acl_xattr.h>
+#include <linux/posix_acl.h>
 #include <linux/sched.h>
+
 #include "ctree.h"
+#include "btrfs_inode.h"
 #include "xattr.h"
-#ifndef is_owner_or_cap
-#define is_owner_or_cap(inode)	\
-	((current->fsuid == (inode)->i_uid) || capable(CAP_FOWNER))
-#endif
+
+static void btrfs_update_cached_acl(struct inode *inode,
+				    struct posix_acl **p_acl,
+				    struct posix_acl *acl)
+{
+	spin_lock(&inode->i_lock);
+	if (*p_acl && *p_acl != BTRFS_ACL_NOT_CACHED)
+		posix_acl_release(*p_acl);
+	*p_acl = posix_acl_dup(acl);
+	spin_unlock(&inode->i_lock);
+}
+
+static struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
+{
+	int size, name_index;
+	char *value = NULL;
+	struct posix_acl *acl = NULL, **p_acl;
+
+	switch (type) {
+	case ACL_TYPE_ACCESS:
+		name_index = BTRFS_XATTR_INDEX_POSIX_ACL_ACCESS;
+		p_acl = &BTRFS_I(inode)->i_acl;
+		break;
+	case ACL_TYPE_DEFAULT:
+		name_index = BTRFS_XATTR_INDEX_POSIX_ACL_DEFAULT;
+		p_acl = &BTRFS_I(inode)->i_default_acl;
+		break;
+	default:
+		return ERR_PTR(-EINVAL);
+	}
+
+	spin_lock(&inode->i_lock);
+	if (*p_acl != BTRFS_ACL_NOT_CACHED)
+		acl = posix_acl_dup(*p_acl);
+	spin_unlock(&inode->i_lock);
+
+	if (acl)
+		return acl;
+
+
+	size = btrfs_xattr_get(inode, name_index, "", NULL, 0);
+	if (size > 0) {
+		value = kzalloc(size, GFP_NOFS);
+		if (!value)
+			return ERR_PTR(-ENOMEM);
+		size = btrfs_xattr_get(inode, name_index, "", value, size);
+		if (size > 0) {
+			acl = posix_acl_from_xattr(value, size);
+			btrfs_update_cached_acl(inode, p_acl, acl);
+		}
+		kfree(value);
+	} else if (size == -ENOENT) {
+		acl = NULL;
+		btrfs_update_cached_acl(inode, p_acl, acl);
+	}
+
+	return acl;
+}
+
+static int btrfs_xattr_get_acl(struct inode *inode, int type,
+			       void *value, size_t size)
+{
+	struct posix_acl *acl;
+	int ret = 0;
+
+	acl = btrfs_get_acl(inode, type);
+
+	if (IS_ERR(acl))
+		return PTR_ERR(acl);
+	if (acl == NULL)
+		return -ENODATA;
+	ret = posix_acl_to_xattr(acl, value, size);
+	posix_acl_release(acl);
+
+	return ret;
+}
+
+/*
+ * Needs to be called with fs_mutex held
+ */
+static int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
+{
+	int ret, name_index = 0, size = 0;
+	struct posix_acl **p_acl;
+	char *value = NULL;
+	mode_t mode;
+
+	if (acl) {
+		ret = posix_acl_valid(acl);
+		if (ret < 0)
+			return ret;
+		ret = 0;
+	}
+
+	switch (type) {
+	case ACL_TYPE_ACCESS:
+		mode = inode->i_mode;
+		ret = posix_acl_equiv_mode(acl, &mode);
+		if (ret < 0)
+			return ret;
+		ret = 0;
+		inode->i_mode = mode;
+		name_index = BTRFS_XATTR_INDEX_POSIX_ACL_ACCESS;
+		p_acl = &BTRFS_I(inode)->i_acl;
+		break;
+	case ACL_TYPE_DEFAULT:
+		if (!S_ISDIR(inode->i_mode))
+			return acl ? -EINVAL : 0;
+		name_index = BTRFS_XATTR_INDEX_POSIX_ACL_DEFAULT;
+		p_acl = &BTRFS_I(inode)->i_default_acl;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (acl) {
+		size = posix_acl_xattr_size(acl->a_count);
+		value = kmalloc(size, GFP_NOFS);
+		if (!value) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		ret = posix_acl_to_xattr(acl, value, size);
+		if (ret < 0)
+			goto out;
+	}
+
+	ret = btrfs_xattr_set(inode, name_index, "", value, size, 0);
+
+out:
+	if (value)
+		kfree(value);
+
+	if (!ret)
+		btrfs_update_cached_acl(inode, p_acl, acl);
+
+	return ret;
+}
 
 static int btrfs_xattr_set_acl(struct inode *inode, int type,
 			       const void *value, size_t size)
 {
 	int ret = 0;
-	struct posix_acl *acl;
+	struct posix_acl *acl = NULL;
 
-	if (!is_owner_or_cap(inode))
-		return -EPERM;
 	if (value) {
 		acl = posix_acl_from_xattr(value, size);
 		if (acl == NULL) {
 			value = NULL;
 			size = 0;
 		} else if (IS_ERR(acl)) {
-			ret = PTR_ERR(acl);
-		} else {
-			ret = posix_acl_valid(acl);
-			posix_acl_release(acl);
+			return PTR_ERR(acl);
 		}
-		if (ret)
-			return ret;
 	}
-	return btrfs_xattr_set(inode, type, "", value, size, 0);
-}
 
-static int btrfs_xattr_get_acl(struct inode *inode, int type,
-			       void *value, size_t size)
-{
-	return btrfs_xattr_get(inode, type, "", value, size);
+	ret = btrfs_set_acl(inode, acl, type);
+
+	posix_acl_release(acl);
+
+	return ret;
 }
+
+
 static int btrfs_xattr_acl_access_get(struct inode *inode, const char *name,
 				      void *value, size_t size)
 {
-	if (*name != '\0')
-	       return -EINVAL;
-	return btrfs_xattr_get_acl(inode, BTRFS_XATTR_INDEX_POSIX_ACL_ACCESS,
-				   value, size);
+	return btrfs_xattr_get_acl(inode, ACL_TYPE_ACCESS, value, size);
 }
+
 static int btrfs_xattr_acl_access_set(struct inode *inode, const char *name,
 				      const void *value, size_t size, int flags)
 {
-	if (*name != '\0')
-	       return -EINVAL;
-	return btrfs_xattr_set_acl(inode, BTRFS_XATTR_INDEX_POSIX_ACL_ACCESS,
-				   value, size);
+	return btrfs_xattr_set_acl(inode, ACL_TYPE_ACCESS, value, size);
 }
+
 static int btrfs_xattr_acl_default_get(struct inode *inode, const char *name,
 				       void *value, size_t size)
 {
-	if (*name != '\0')
-	       return -EINVAL;
-	return btrfs_xattr_get_acl(inode, BTRFS_XATTR_INDEX_POSIX_ACL_DEFAULT,
-				   value, size);
+	return btrfs_xattr_get_acl(inode, ACL_TYPE_DEFAULT, value, size);
 }
+
 static int btrfs_xattr_acl_default_set(struct inode *inode, const char *name,
 				       const void *value, size_t size, int flags)
 {
-	if (*name != '\0')
-	       return -EINVAL;
-	return btrfs_xattr_set_acl(inode, BTRFS_XATTR_INDEX_POSIX_ACL_DEFAULT,
-				   value, size);
+	return btrfs_xattr_set_acl(inode, ACL_TYPE_DEFAULT, value, size);
+}
+
+int btrfs_check_acl(struct inode *inode, int mask)
+{
+	struct posix_acl *acl;
+	int error = -EAGAIN;
+
+	acl = btrfs_get_acl(inode, ACL_TYPE_ACCESS);
+
+	if (IS_ERR(acl))
+		return PTR_ERR(acl);
+	if (acl) {
+		error = posix_acl_permission(inode, acl, mask);
+		posix_acl_release(acl);
+	}
+
+	return error;
+}
+
+/*
+ * btrfs_init_acl is already generally called under fs_mutex, so the locking
+ * stuff has been fixed to work with that.  If the locking stuff changes, we
+ * need to re-evaluate the acl locking stuff.
+ */
+int btrfs_init_acl(struct inode *inode, struct inode *dir)
+{
+	struct posix_acl *acl = NULL;
+	int ret = 0;
+
+	/* this happens with subvols */
+	if (!dir)
+		return 0;
+
+	if (!S_ISLNK(inode->i_mode)) {
+		if (IS_POSIXACL(dir)) {
+			acl = btrfs_get_acl(dir, ACL_TYPE_DEFAULT);
+			if (IS_ERR(acl))
+				return PTR_ERR(acl);
+		}
+
+		if (!acl)
+			inode->i_mode &= ~current->fs->umask;
+	}
+
+	if (IS_POSIXACL(dir) && acl) {
+		struct posix_acl *clone;
+		mode_t mode;
+
+		if (S_ISDIR(inode->i_mode)) {
+			ret = btrfs_set_acl(inode, acl, ACL_TYPE_DEFAULT);
+			if (ret)
+				goto failed;
+		}
+		clone = posix_acl_clone(acl, GFP_NOFS);
+		ret = -ENOMEM;
+		if (!clone)
+			goto failed;
+
+		mode = inode->i_mode;
+		ret = posix_acl_create_masq(clone, &mode);
+		if (ret >= 0) {
+			inode->i_mode = mode;
+			if (ret > 0) {
+				/* we need an acl */
+				ret = btrfs_set_acl(inode, clone,
+						    ACL_TYPE_ACCESS);
+			}
+		}
+	}
+failed:
+	posix_acl_release(acl);
+
+	return ret;
+}
+
+int btrfs_acl_chmod(struct inode *inode)
+{
+	struct posix_acl *acl, *clone;
+	int ret = 0;
+
+	if (S_ISLNK(inode->i_mode))
+		return -EOPNOTSUPP;
+
+	if (!IS_POSIXACL(inode))
+		return 0;
+
+	acl = btrfs_get_acl(inode, ACL_TYPE_ACCESS);
+	if (IS_ERR(acl) || !acl)
+		return PTR_ERR(acl);
+
+	clone = posix_acl_clone(acl, GFP_KERNEL);
+	posix_acl_release(acl);
+	if (!clone)
+		return -ENOMEM;
+
+	ret = posix_acl_chmod_masq(clone, inode->i_mode);
+	if (!ret)
+		ret = btrfs_set_acl(inode, clone, ACL_TYPE_ACCESS);
+
+	posix_acl_release(clone);
+
+	return ret;
 }
+
 struct xattr_handler btrfs_xattr_acl_default_handler = {
 	.prefix = POSIX_ACL_XATTR_DEFAULT,
 	.list	= btrfs_xattr_generic_list,

commit c1e32da616a17813f11b701a7a87775d35c12e3a
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Jan 22 12:46:56 2008 -0500

    Btrfs: Include sched.h in the acl code for current (fixes compile on 2.6.23)
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 27bb841fafeb..ff0fcc72848a 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -20,6 +20,7 @@
 #include <linux/string.h>
 #include <linux/xattr.h>
 #include <linux/posix_acl_xattr.h>
+#include <linux/sched.h>
 #include "ctree.h"
 #include "xattr.h"
 #ifndef is_owner_or_cap

commit fb4bc1e0565a842d704846005ac0ec739e608ede
Author: Yan <yanzheng@21cn.com>
Date:   Thu Jan 17 11:59:51 2008 -0500

    Btrfs: Fix compile on 2.6.22 kernel
    
    This patch fixes compile error on kernel-2.6.22
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index b4f85ebe1bd6..27bb841fafeb 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -22,6 +22,11 @@
 #include <linux/posix_acl_xattr.h>
 #include "ctree.h"
 #include "xattr.h"
+#ifndef is_owner_or_cap
+#define is_owner_or_cap(inode)	\
+	((current->fsuid == (inode)->i_uid) || capable(CAP_FOWNER))
+#endif
+
 static int btrfs_xattr_set_acl(struct inode *inode, int type,
 			       const void *value, size_t size)
 {

commit 744f52f997b21de2a01931f79cf6c198bf688120
Author: Yan <yanzheng@21cn.com>
Date:   Mon Jan 14 13:26:08 2008 -0500

    Btrfs: Implement ACLs setting and getting
    
    ACLs are stored but not used for permission checks (yet)
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 889ba89d3f9f..b4f85ebe1bd6 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -22,53 +22,68 @@
 #include <linux/posix_acl_xattr.h>
 #include "ctree.h"
 #include "xattr.h"
+static int btrfs_xattr_set_acl(struct inode *inode, int type,
+			       const void *value, size_t size)
+{
+	int ret = 0;
+	struct posix_acl *acl;
 
-/*
- * FIXME: At this point this is all place holder stuff, we just return
- * -EOPNOTSUPP so cp won't complain when it tries to copy over a file with an
- *  acl on it.
- */
+	if (!is_owner_or_cap(inode))
+		return -EPERM;
+	if (value) {
+		acl = posix_acl_from_xattr(value, size);
+		if (acl == NULL) {
+			value = NULL;
+			size = 0;
+		} else if (IS_ERR(acl)) {
+			ret = PTR_ERR(acl);
+		} else {
+			ret = posix_acl_valid(acl);
+			posix_acl_release(acl);
+		}
+		if (ret)
+			return ret;
+	}
+	return btrfs_xattr_set(inode, type, "", value, size, 0);
+}
 
+static int btrfs_xattr_get_acl(struct inode *inode, int type,
+			       void *value, size_t size)
+{
+	return btrfs_xattr_get(inode, type, "", value, size);
+}
 static int btrfs_xattr_acl_access_get(struct inode *inode, const char *name,
 				      void *value, size_t size)
 {
-	/*
-	return btrfs_xattr_get(inode, BTRFS_XATTR_INDEX_POSIX_ACL_ACCESS, name,
-			       value, size);
-	*/
-	return -EOPNOTSUPP;
+	if (*name != '\0')
+	       return -EINVAL;
+	return btrfs_xattr_get_acl(inode, BTRFS_XATTR_INDEX_POSIX_ACL_ACCESS,
+				   value, size);
 }
-
 static int btrfs_xattr_acl_access_set(struct inode *inode, const char *name,
 				      const void *value, size_t size, int flags)
 {
-	/*
-	return btrfs_xattr_set(inode, BTRFS_XATTR_INDEX_POSIX_ACL_ACCESS, name,
-			       value, size, flags);
-	*/
-	return -EOPNOTSUPP;
+	if (*name != '\0')
+	       return -EINVAL;
+	return btrfs_xattr_set_acl(inode, BTRFS_XATTR_INDEX_POSIX_ACL_ACCESS,
+				   value, size);
 }
-
 static int btrfs_xattr_acl_default_get(struct inode *inode, const char *name,
 				       void *value, size_t size)
 {
-	/*
-	return btrfs_xattr_get(inode, BTRFS_XATTR_INDEX_POSIX_ACL_DEFAULT,
-			       name, value, size);
-	*/
-	return -EOPNOTSUPP;
+	if (*name != '\0')
+	       return -EINVAL;
+	return btrfs_xattr_get_acl(inode, BTRFS_XATTR_INDEX_POSIX_ACL_DEFAULT,
+				   value, size);
 }
-
 static int btrfs_xattr_acl_default_set(struct inode *inode, const char *name,
 				       const void *value, size_t size, int flags)
 {
-	/*
-	return btrfs_xattr_set(inode, BTRFS_XATTR_INDEX_POSIX_ACL_DEFAULT,
-			       name, value, size, flags);
-	*/
-	return -EOPNOTSUPP;
+	if (*name != '\0')
+	       return -EINVAL;
+	return btrfs_xattr_set_acl(inode, BTRFS_XATTR_INDEX_POSIX_ACL_DEFAULT,
+				   value, size);
 }
-
 struct xattr_handler btrfs_xattr_acl_default_handler = {
 	.prefix = POSIX_ACL_XATTR_DEFAULT,
 	.list	= btrfs_xattr_generic_list,

commit 1caf9342fc71d020e788a59598a44d4ea0136b36
Author: Josef Bacik <jbacik@redhat.com>
Date:   Mon Nov 19 10:18:17 2007 -0500

    Btrfs: Make ACLs return EOPNOTSUPP for now
    
    There was a slight problem with ACL's returning EINVAL when you tried to set an
    ACL.  This isn't correct, we should be returning EOPNOTSUPP, so I did a very
    ugly thing and just commented everybody out and made them return EOPNOTSUPP.
    This is only temporary, I'm going back to implement ACL's, but Chris wants to
    push out a release so this will suffice for now.
    
    Also Yan suggested setting reada to -1 in the delete case to enable backwards
    readahead, and in the listxattr case I moved path->reada = 2; to after the if
    (!path) check so we can avoid a possible null dereference.  Thank you,
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index aee9f0657c35..889ba89d3f9f 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -23,32 +23,50 @@
 #include "ctree.h"
 #include "xattr.h"
 
+/*
+ * FIXME: At this point this is all place holder stuff, we just return
+ * -EOPNOTSUPP so cp won't complain when it tries to copy over a file with an
+ *  acl on it.
+ */
+
 static int btrfs_xattr_acl_access_get(struct inode *inode, const char *name,
 				      void *value, size_t size)
 {
+	/*
 	return btrfs_xattr_get(inode, BTRFS_XATTR_INDEX_POSIX_ACL_ACCESS, name,
 			       value, size);
+	*/
+	return -EOPNOTSUPP;
 }
 
 static int btrfs_xattr_acl_access_set(struct inode *inode, const char *name,
 				      const void *value, size_t size, int flags)
 {
+	/*
 	return btrfs_xattr_set(inode, BTRFS_XATTR_INDEX_POSIX_ACL_ACCESS, name,
 			       value, size, flags);
+	*/
+	return -EOPNOTSUPP;
 }
 
 static int btrfs_xattr_acl_default_get(struct inode *inode, const char *name,
 				       void *value, size_t size)
 {
+	/*
 	return btrfs_xattr_get(inode, BTRFS_XATTR_INDEX_POSIX_ACL_DEFAULT,
 			       name, value, size);
+	*/
+	return -EOPNOTSUPP;
 }
 
 static int btrfs_xattr_acl_default_set(struct inode *inode, const char *name,
 				       const void *value, size_t size, int flags)
 {
+	/*
 	return btrfs_xattr_set(inode, BTRFS_XATTR_INDEX_POSIX_ACL_DEFAULT,
 			       name, value, size, flags);
+	*/
+	return -EOPNOTSUPP;
 }
 
 struct xattr_handler btrfs_xattr_acl_default_handler = {

commit 5103e947b9b7ac18ddb21a04ee3486e94c6504d7
Author: Josef Bacik <jbacik@redhat.com>
Date:   Fri Nov 16 11:45:54 2007 -0500

    xattr support for btrfs
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
new file mode 100644
index 000000000000..aee9f0657c35
--- /dev/null
+++ b/fs/btrfs/acl.c
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2007 Red Hat.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License v2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/xattr.h>
+#include <linux/posix_acl_xattr.h>
+#include "ctree.h"
+#include "xattr.h"
+
+static int btrfs_xattr_acl_access_get(struct inode *inode, const char *name,
+				      void *value, size_t size)
+{
+	return btrfs_xattr_get(inode, BTRFS_XATTR_INDEX_POSIX_ACL_ACCESS, name,
+			       value, size);
+}
+
+static int btrfs_xattr_acl_access_set(struct inode *inode, const char *name,
+				      const void *value, size_t size, int flags)
+{
+	return btrfs_xattr_set(inode, BTRFS_XATTR_INDEX_POSIX_ACL_ACCESS, name,
+			       value, size, flags);
+}
+
+static int btrfs_xattr_acl_default_get(struct inode *inode, const char *name,
+				       void *value, size_t size)
+{
+	return btrfs_xattr_get(inode, BTRFS_XATTR_INDEX_POSIX_ACL_DEFAULT,
+			       name, value, size);
+}
+
+static int btrfs_xattr_acl_default_set(struct inode *inode, const char *name,
+				       const void *value, size_t size, int flags)
+{
+	return btrfs_xattr_set(inode, BTRFS_XATTR_INDEX_POSIX_ACL_DEFAULT,
+			       name, value, size, flags);
+}
+
+struct xattr_handler btrfs_xattr_acl_default_handler = {
+	.prefix = POSIX_ACL_XATTR_DEFAULT,
+	.list	= btrfs_xattr_generic_list,
+	.get	= btrfs_xattr_acl_default_get,
+	.set	= btrfs_xattr_acl_default_set,
+};
+
+struct xattr_handler btrfs_xattr_acl_access_handler = {
+	.prefix = POSIX_ACL_XATTR_ACCESS,
+	.list	= btrfs_xattr_generic_list,
+	.get	= btrfs_xattr_acl_access_get,
+	.set	= btrfs_xattr_acl_access_set,
+};
