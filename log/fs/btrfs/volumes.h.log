commit c730ae0c6bb3125ccb776fb2ab6abbdff500c02c
Author: Marcos Paulo de Souza <mpdesouza@suse.com>
Date:   Tue Jun 16 15:54:29 2020 -0300

    btrfs: convert comments to fallthrough annotations
    
    Convert fall through comments to the pseudo-keyword which is now the
    preferred way.
    
    Signed-off-by: Marcos Paulo de Souza <mpdesouza@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index f067b5934c46..75af2334b2e3 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -408,7 +408,7 @@ static inline enum btrfs_map_op btrfs_op(struct bio *bio)
 		return BTRFS_MAP_WRITE;
 	default:
 		WARN_ON_ONCE(1);
-		/* fall through */
+		fallthrough;
 	case REQ_OP_READ:
 		return BTRFS_MAP_READ;
 	}

commit c4a816c67c396b1a06abf77bd249ac6ad02861b3
Author: Naohiro Aota <naohiro.aota@wdc.com>
Date:   Tue Feb 25 12:56:08 2020 +0900

    btrfs: introduce chunk allocation policy
    
    Introduce chunk allocation policy for btrfs. This policy controls how
    chunks and device extents are allocated from devices.
    
    Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Reviewed-by: Josef Bacik <josef@toxicpanda.com>
    Signed-off-by: Naohiro Aota <naohiro.aota@wdc.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 7b657f2cba57..f067b5934c46 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -207,6 +207,10 @@ BTRFS_DEVICE_GETSET_FUNCS(total_bytes);
 BTRFS_DEVICE_GETSET_FUNCS(disk_total_bytes);
 BTRFS_DEVICE_GETSET_FUNCS(bytes_used);
 
+enum btrfs_chunk_allocation_policy {
+	BTRFS_CHUNK_ALLOC_REGULAR,
+};
+
 struct btrfs_fs_devices {
 	u8 fsid[BTRFS_FSID_SIZE]; /* FS specific uuid */
 	u8 metadata_uuid[BTRFS_FSID_SIZE];
@@ -258,6 +262,8 @@ struct btrfs_fs_devices {
 	struct kobject *devices_kobj;
 	struct kobject *devinfo_kobj;
 	struct completion kobj_unregister;
+
+	enum btrfs_chunk_allocation_policy chunk_alloc_policy;
 };
 
 #define BTRFS_BIO_INLINE_CSUM_SIZE	64

commit 97f4dd09dad05943a9c4184ace47258ed09e8e74
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Tue Feb 18 16:56:08 2020 +0200

    btrfs: make btrfs_check_uuid_tree private to disk-io.c
    
    It's used only during filesystem mount as such it can be made private to
    disk-io.c file. Also use the occasion to move btrfs_uuid_rescan_kthread
    as btrfs_check_uuid_tree is its sole caller.
    
    Reviewed-by: Josef Bacik <josef@toxicpanda.com>
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 7fa392f38262..7b657f2cba57 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -459,7 +459,7 @@ int btrfs_recover_balance(struct btrfs_fs_info *fs_info);
 int btrfs_pause_balance(struct btrfs_fs_info *fs_info);
 int btrfs_cancel_balance(struct btrfs_fs_info *fs_info);
 int btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info);
-int btrfs_check_uuid_tree(struct btrfs_fs_info *fs_info);
+int btrfs_uuid_scan_kthread(void *data);
 int btrfs_chunk_readonly(struct btrfs_fs_info *fs_info, u64 chunk_offset);
 int find_free_dev_extent(struct btrfs_device *device, u64 num_bytes,
 			 u64 *start, u64 *max_avail);

commit 8f32380d3f2904ad0e98574ae17f2018f6dd277e
Author: Johannes Thumshirn <johannes.thumshirn@wdc.com>
Date:   Fri Feb 14 00:24:32 2020 +0900

    btrfs: use the page cache for super block reading
    
    Super-block reading in BTRFS is done using buffer_heads. Buffer_heads
    have some drawbacks, like not being able to propagate errors from the
    lower layers.
    
    Directly use the page cache for reading the super blocks from disk or
    invalidating an on-disk super block. We have to use the page cache so to
    avoid races between mkfs and udev. See also 6f60cbd3ae44 ("btrfs: access
    superblock via pagecache in scan_one_device").
    
    This patch unwraps the buffer head API and does not change the way the
    super block is actually read.
    
    Signed-off-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 52181897446e..7fa392f38262 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -17,8 +17,6 @@ extern struct mutex uuid_mutex;
 
 #define BTRFS_STRIPE_LEN	SZ_64K
 
-struct buffer_head;
-
 struct btrfs_io_geometry {
 	/* remaining bytes before crossing a stripe */
 	u64 len;
@@ -483,7 +481,7 @@ int btrfs_finish_chunk_alloc(struct btrfs_trans_handle *trans,
 int btrfs_remove_chunk(struct btrfs_trans_handle *trans, u64 chunk_offset);
 struct extent_map *btrfs_get_chunk_map(struct btrfs_fs_info *fs_info,
 				       u64 logical, u64 length);
-void btrfs_release_disk_super(struct page *page);
+void btrfs_release_disk_super(struct btrfs_super_block *super);
 
 static inline void btrfs_dev_stat_inc(struct btrfs_device *dev,
 				      int index)

commit 6fbceb9fa4f6749445bc0e2ac6750f0ae8e85b42
Author: Johannes Thumshirn <johannes.thumshirn@wdc.com>
Date:   Fri Feb 14 00:24:31 2020 +0900

    btrfs: reduce scope of btrfs_scratch_superblocks()
    
    btrfs_scratch_superblocks() isn't used anywhere outside volumes.c so
    remove it from the header file and mark it as static.  Also move it
    above it's callers so we don't need a forward declaration.
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index f197fac0a3ae..52181897446e 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -474,7 +474,6 @@ int btrfs_run_dev_stats(struct btrfs_trans_handle *trans);
 void btrfs_rm_dev_replace_remove_srcdev(struct btrfs_device *srcdev);
 void btrfs_rm_dev_replace_free_srcdev(struct btrfs_device *srcdev);
 void btrfs_destroy_dev_replace_tgtdev(struct btrfs_device *tgtdev);
-void btrfs_scratch_superblocks(struct block_device *bdev, const char *device_path);
 int btrfs_is_parity_mirror(struct btrfs_fs_info *fs_info,
 			   u64 logical, u64 len);
 unsigned long btrfs_full_stripe_len(struct btrfs_fs_info *fs_info,

commit f6d9abbc1f957f0fcf88d567ae2523d37d2731da
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Fri Feb 14 00:24:29 2020 +0900

    btrfs: Export btrfs_release_disk_super
    
    Preparatory patch for removal of buffer_head usage in btrfs.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index f01552a0785e..f197fac0a3ae 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -484,6 +484,7 @@ int btrfs_finish_chunk_alloc(struct btrfs_trans_handle *trans,
 int btrfs_remove_chunk(struct btrfs_trans_handle *trans, u64 chunk_offset);
 struct extent_map *btrfs_get_chunk_map(struct btrfs_fs_info *fs_info,
 				       u64 logical, u64 length);
+void btrfs_release_disk_super(struct page *page);
 
 static inline void btrfs_dev_stat_inc(struct btrfs_device *dev,
 				      int index)

commit 713db356041071d16360e82247de3107ec9ed57f
Merge: 288b27a06e4f 1b9867eb6120
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 16 11:43:45 2020 -0800

    Merge tag 'for-5.6-rc1-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux
    
    Pull btrfs fixes from David Sterba:
     "Two races fixed, memory leak fix, sysfs directory fixup and two new
      log messages:
    
       - two fixed race conditions: extent map merging and truncate vs
         fiemap
    
       - create the right sysfs directory with device information and move
         the individual device dirs under it
    
       - print messages when the tree-log is replayed at mount time or
         cannot be replayed on remount"
    
    * tag 'for-5.6-rc1-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux:
      btrfs: sysfs, move device id directories to UUID/devinfo
      btrfs: sysfs, add UUID/devinfo kobject
      Btrfs: fix race between shrinking truncate and fiemap
      btrfs: log message when rw remount is attempted with unclean tree-log
      btrfs: print message when tree-log replay starts
      Btrfs: fix race between using extent maps and merging them
      btrfs: ref-verify: fix memory leaks

commit a013d141eceee0f7747385e900da2858141aa0f3
Author: Anand Jain <anand.jain@oracle.com>
Date:   Wed Feb 12 17:28:10 2020 +0800

    btrfs: sysfs, add UUID/devinfo kobject
    
    Create directory /sys/fs/btrfs/UUID/devinfo to hold devices directories
    by the id (unlike /devices).
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 690d4f5a0653..309cda477589 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -258,6 +258,7 @@ struct btrfs_fs_devices {
 	/* sysfs kobjects */
 	struct kobject fsid_kobj;
 	struct kobject *devices_kobj;
+	struct kobject *devinfo_kobj;
 	struct completion kobj_unregister;
 };
 

commit 81a046b18b331ed6192e6fd9ff6d12a1f18058cf
Merge: 511fdb784422 4e19443da194
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 28 14:53:31 2020 -0800

    Merge tag 'for-5.6-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux
    
    Pull btrfs updates from David Sterba:
     "Features, highlights:
    
       - async discard
           - "mount -o discard=async" to enable it
           - freed extents are not discarded immediatelly, but grouped
             together and trimmed later, with IO rate limiting
           - the "sync" mode submits short extents that could have been
             ignored completely by the device, for SATA prior to 3.1 the
             requests are unqueued and have a big impact on performance
           - the actual discard IO requests have been moved out of
             transaction commit to a worker thread, improving commit latency
           - IO rate and request size can be tuned by sysfs files, for now
             enabled only with CONFIG_BTRFS_DEBUG as we might need to
             add/delete the files and don't have a stable-ish ABI for
             general use, defaults are conservative
    
       - export device state info in sysfs, eg. missing, writeable
    
       - no discard of extents known to be untouched on disk (eg. after
         reservation)
    
       - device stats reset is logged with process name and PID that called
         the ioctl
    
      Fixes:
    
       - fix missing hole after hole punching and fsync when using NO_HOLES
    
       - writeback: range cyclic mode could miss some dirty pages and lead
         to OOM
    
       - two more corner cases for metadata_uuid change after power loss
         during the change
    
       - fix infinite loop during fsync after mix of rename operations
    
      Core changes:
    
       - qgroup assign returns ENOTCONN when quotas not enabled, used to
         return EINVAL that was confusing
    
       - device closing does not need to allocate memory anymore
    
       - snapshot aware code got removed, disabled for years due to
         performance problems, reimplmentation will allow to select wheter
         defrag breaks or does not break COW on shared extents
    
       - tree-checker:
           - check leaf chunk item size, cross check against number of
             stripes
           - verify location keys for DIR_ITEM, DIR_INDEX and XATTR items
    
       - new self test for physical -> logical mapping code, used for super
         block range exclusion
    
       - assertion helpers/macros updated to avoid objtool "unreachable
         code" reports on older compilers or config option combinations"
    
    * tag 'for-5.6-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux: (84 commits)
      btrfs: free block groups after free'ing fs trees
      btrfs: Fix split-brain handling when changing FSID to metadata uuid
      btrfs: Handle another split brain scenario with metadata uuid feature
      btrfs: Factor out metadata_uuid code from find_fsid.
      btrfs: Call find_fsid from find_fsid_inprogress
      Btrfs: fix infinite loop during fsync after rename operations
      btrfs: set trans->drity in btrfs_commit_transaction
      btrfs: drop log root for dropped roots
      btrfs: sysfs, add devid/dev_state kobject and device attributes
      btrfs: Refactor btrfs_rmap_block to improve readability
      btrfs: Add self-tests for btrfs_rmap_block
      btrfs: selftests: Add support for dummy devices
      btrfs: Move and unexport btrfs_rmap_block
      btrfs: separate definition of assertion failure handlers
      btrfs: device stats, log when stats are zeroed
      btrfs: fix improper setting of scanned for range cyclic write cache pages
      btrfs: safely advance counter when looking up bio csums
      btrfs: remove unused member btrfs_device::work
      btrfs: remove unnecessary wrapper get_alloc_profile
      btrfs: add correction to handle -1 edge case in async discard
      ...

commit 668e48af7a94985be7cf3b97a860d9819271d8bf
Author: Anand Jain <anand.jain@oracle.com>
Date:   Mon Jan 6 19:38:31 2020 +0800

    btrfs: sysfs, add devid/dev_state kobject and device attributes
    
    New sysfs attributes that track the filesystem status of devices, stored
    in the per-filesystem directory in /sys/fs/btrfs/FSID/devinfo . There's
    a directory for each device, with name corresponding to the numerical
    device id.
    
      in_fs_metadata    - device is in the list of fs metadata
      missing           - device is missing (no device node or block device)
      replace_target    - device is target of replace
      writeable         - writes from fs are allowed
    
    These attributes reflect the state of the device::dev_state and created
    at mount time.
    
    Sample output:
      $ pwd
       /sys/fs/btrfs/6e1961f1-5918-4ecc-a22f-948897b409f7/devinfo/1/
      $ ls
        in_fs_metadata  missing  replace_target  writeable
      $ cat missing
        0
    
    The output from these attributes are 0 or 1. 0 indicates unset and 1
    indicates set.  These attributes are readonly.
    
    It is observed that the device delete thread and sysfs read thread will
    not race because the delete thread calls sysfs kobject_put() which in
    turn waits for existing sysfs read to complete.
    
    Note for device replace devid swap:
    
    During the replace the target device temporarily assumes devid 0 before
    assigning the devid of the soruce device.
    
    In btrfs_dev_replace_finishing() we remove source sysfs devid using the
    function btrfs_sysfs_remove_devices_attr(), so after that call
    kobject_rename() to update the devid in the sysfs.  This adds and calls
    btrfs_sysfs_update_devid() helper function to update the device id.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ update changelog ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 9c7d4fe5c39a..690d4f5a0653 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -136,6 +136,10 @@ struct btrfs_device {
 	atomic_t dev_stat_values[BTRFS_DEV_STAT_VALUES_MAX];
 
 	struct extent_io_tree alloc_state;
+
+	struct completion kobj_unregister;
+	/* For sysfs/FSID/devinfo/devid/ */
+	struct kobject devid_kobj;
 };
 
 /*

commit 96a14336bd8fc13cc3db036a5745acdf3bc185f4
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Tue Dec 10 19:57:51 2019 +0200

    btrfs: Move and unexport btrfs_rmap_block
    
    It's used only during initial block group reading to map physical
    address of super block to a list of logical ones. Make it private to
    block-group.c, add proper kernel doc and ensure it's exported only for
    tests.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 81f21e42b887..9c7d4fe5c39a 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -415,8 +415,6 @@ int btrfs_map_sblock(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
 		     struct btrfs_bio **bbio_ret);
 int btrfs_get_io_geometry(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
 		u64 logical, u64 len, struct btrfs_io_geometry *io_geom);
-int btrfs_rmap_block(struct btrfs_fs_info *fs_info, u64 chunk_start,
-		     u64 physical, u64 **logical, int *naddrs, int *stripe_len);
 int btrfs_read_sys_array(struct btrfs_fs_info *fs_info);
 int btrfs_read_chunk_tree(struct btrfs_fs_info *fs_info);
 int btrfs_alloc_chunk(struct btrfs_trans_handle *trans, u64 type);

commit 94f8c46566485974c155c5cb4507f03873cf4d71
Author: David Sterba <dsterba@suse.com>
Date:   Mon Jan 6 17:14:23 2020 +0100

    btrfs: remove unused member btrfs_device::work
    
    This is a leftover from recently removed bio scheduling framework.
    
    Fixes: ba8a9d079543 ("Btrfs: delete the entire async bio submission framework")
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 3c56ef571b00..81f21e42b887 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -120,8 +120,6 @@ struct btrfs_device {
 	/* per-device scrub information */
 	struct scrub_ctx *scrub_ctx;
 
-	struct btrfs_work work;
-
 	/* readahead state */
 	atomic_t reada_in_flight;
 	u64 reada_next;

commit b5501504cb6a70d55c3dcf1b2ceb15386e615237
Author: Anand Jain <anand.jain@oracle.com>
Date:   Thu Nov 21 17:33:30 2019 +0800

    btrfs: sysfs, rename devices kobject holder to devices_kobj
    
    The struct member btrfs_device::device_dir_kobj holds the kobj of the
    sysfs directory /sys/fs/btrfs/UUID/devices, so rename it from
    device_dir_kobj to devices_kobj. No functional changes.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index fc1b564b9cfe..3c56ef571b00 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -255,7 +255,7 @@ struct btrfs_fs_devices {
 	struct btrfs_fs_info *fs_info;
 	/* sysfs kobjects */
 	struct kobject fsid_kobj;
-	struct kobject *device_dir_kobj;
+	struct kobject *devices_kobj;
 	struct completion kobj_unregister;
 };
 

commit 94545870b14b5eb6d8a887fab845d1918f4f62ac
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Oct 15 21:18:11 2019 +0200

    sched/rt, btrfs: Use CONFIG_PREEMPTION
    
    CONFIG_PREEMPTION is selected by CONFIG_PREEMPT and by CONFIG_PREEMPT_RT.
    Both PREEMPT and PREEMPT_RT require the same functionality which today
    depends on CONFIG_PREEMPT.
    
    Switch the btrfs_device_set_â€¦() macro over to use CONFIG_PREEMPTION.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: David Sterba <dsterba@suse.com>
    Cc: Chris Mason <clm@fb.com>
    Cc: Josef Bacik <josef@toxicpanda.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: linux-btrfs@vger.kernel.org
    Link: https://lore.kernel.org/r/20191015191821.11479-25-bigeasy@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index fc1b564b9cfe..0ee5386926fa 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -168,7 +168,7 @@ btrfs_device_set_##name(struct btrfs_device *dev, u64 size)		\
 	write_seqcount_end(&dev->data_seqcount);			\
 	preempt_enable();						\
 }
-#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPT)
+#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPTION)
 #define BTRFS_DEVICE_GETSET_FUNCS(name)					\
 static inline u64							\
 btrfs_device_get_##name(const struct btrfs_device *dev)			\

commit 7f0432d0d8dc1d29ab5276805d648c5b0a408105
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Nov 13 11:27:28 2019 +0100

    btrfs: change btrfs_fs_devices::rotating to bool
    
    struct btrfs_fs_devices::rotating currently is declared as an integer
    variable but only used as a boolean.
    
    Change the variable definition to bool and update to code touching it to
    set 'true' and 'false'.
    
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 8e9513b3fe9d..fc1b564b9cfe 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -250,7 +250,7 @@ struct btrfs_fs_devices {
 	/* set when we find or add a device that doesn't have the
 	 * nonrot flag set
 	 */
-	int rotating;
+	bool rotating;
 
 	struct btrfs_fs_info *fs_info;
 	/* sysfs kobjects */

commit 0395d84f8edc6c28ce270e6eda5c7e6ff4c18545
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Nov 13 11:27:27 2019 +0100

    btrfs: change btrfs_fs_devices::seeding to bool
    
    struct btrfs_fs_devices::seeding currently is declared as an integer
    variable but only used as a boolean.
    
    Change the variable definition to bool and update to code touching it to
    set 'true' and 'false'.
    
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 46987a2da786..8e9513b3fe9d 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -243,7 +243,7 @@ struct btrfs_fs_devices {
 	struct list_head alloc_list;
 
 	struct btrfs_fs_devices *seed;
-	int seeding;
+	bool seeding;
 
 	int opened;
 

commit 8d6fac0087e538173f34ca7431ed9b58581acf28
Author: David Sterba <dsterba@suse.com>
Date:   Fri Mar 2 22:56:53 2018 +0100

    btrfs: add support for 4-copy replication (raid1c4)
    
    Add new block group profile to store 4 copies in a simliar way that
    current RAID1 does.  The profile attributes and constraints are defined
    in the raid table and used by the same code that already handles the 2-
    and 3-copy RAID1.
    
    The minimum number of devices is 4, the maximum number of devices/chunks
    that can be lost/damaged is 3. There is no comparable traditional RAID
    level, the profile is added for future needs to accompany triple-parity
    and beyond.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index a4e26b84e1b9..46987a2da786 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -547,6 +547,8 @@ static inline enum btrfs_raid_types btrfs_bg_flags_to_raid_index(u64 flags)
 		return BTRFS_RAID_RAID1;
 	else if (flags & BTRFS_BLOCK_GROUP_RAID1C3)
 		return BTRFS_RAID_RAID1C3;
+	else if (flags & BTRFS_BLOCK_GROUP_RAID1C4)
+		return BTRFS_RAID_RAID1C4;
 	else if (flags & BTRFS_BLOCK_GROUP_DUP)
 		return BTRFS_RAID_DUP;
 	else if (flags & BTRFS_BLOCK_GROUP_RAID0)

commit 47e6f7423b9196ad6832d26cae52b7015f81ee7f
Author: David Sterba <dsterba@suse.com>
Date:   Fri Mar 2 22:56:53 2018 +0100

    btrfs: add support for 3-copy replication (raid1c3)
    
    Add new block group profile to store 3 copies in a simliar way that
    current RAID1 does. The profile attributes and constraints are defined
    in the raid table and used by the same code that already handles the
    2-copy RAID1.
    
    The minimum number of devices is 3, the maximum number of devices/chunks
    that can be lost/damaged is 2. Like RAID6 but with 33% space
    utilization.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index ac4ba8c57283..a4e26b84e1b9 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -545,6 +545,8 @@ static inline enum btrfs_raid_types btrfs_bg_flags_to_raid_index(u64 flags)
 		return BTRFS_RAID_RAID10;
 	else if (flags & BTRFS_BLOCK_GROUP_RAID1)
 		return BTRFS_RAID_RAID1;
+	else if (flags & BTRFS_BLOCK_GROUP_RAID1C3)
+		return BTRFS_RAID_RAID1C3;
 	else if (flags & BTRFS_BLOCK_GROUP_DUP)
 		return BTRFS_RAID_DUP;
 	else if (flags & BTRFS_BLOCK_GROUP_RAID0)

commit 34b127aecd4fe8e6a3903e10f204a7b7ffddca22
Author: Qu Wenruo <wqu@suse.com>
Date:   Thu Oct 24 09:38:29 2019 +0800

    btrfs: Remove btrfs_bio::flags member
    
    The last user of btrfs_bio::flags was removed in commit 326e1dbb5736
    ("block: remove management of bi_remaining when restoring original
    bi_end_io"), remove it.
    
    (Tagged for stable as the structure is heavily used and space savings
    are desirable.)
    
    CC: stable@vger.kernel.org # 4.4+
    Signed-off-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 9b5fba4d6f6b..ac4ba8c57283 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -319,7 +319,6 @@ struct btrfs_bio {
 	u64 map_type; /* get from map_lookup->type */
 	bio_end_io_t *end_io;
 	struct bio *orig_bio;
-	unsigned long flags;
 	void *private;
 	atomic_t error;
 	int max_errors;

commit ba8a9d07954397f0645cf62bcc1ef536e8e7ba24
Author: Chris Mason <clm@fb.com>
Date:   Wed Jul 10 12:28:15 2019 -0700

    Btrfs: delete the entire async bio submission framework
    
    Now that we're not using btrfs_schedule_bio() anymore, delete all the
    code that supported it.
    
    Reviewed-by: Josef Bacik <josef@toxicpanda.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index bc2bbaa485b7..9b5fba4d6f6b 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -18,10 +18,6 @@ extern struct mutex uuid_mutex;
 #define BTRFS_STRIPE_LEN	SZ_64K
 
 struct buffer_head;
-struct btrfs_pending_bios {
-	struct bio *head;
-	struct bio *tail;
-};
 
 struct btrfs_io_geometry {
 	/* remaining bytes before crossing a stripe */
@@ -68,13 +64,6 @@ struct btrfs_device {
 
 	u64 generation;
 
-	spinlock_t io_lock ____cacheline_aligned;
-	int running_pending;
-	/* regular prio bios */
-	struct btrfs_pending_bios pending_bios;
-	/* sync bios */
-	struct btrfs_pending_bios pending_sync_bios;
-
 	struct block_device *bdev;
 
 	/* the mode sent to blkdev_get */

commit 08635bae0b4ceb08fe4c156a11c83baec397d36d
Author: Chris Mason <clm@fb.com>
Date:   Wed Jul 10 12:28:14 2019 -0700

    Btrfs: stop using btrfs_schedule_bio()
    
    btrfs_schedule_bio() hands IO off to a helper thread to do the actual
    submit_bio() call.  This has been used to make sure async crc and
    compression helpers don't get stuck on IO submission.  To maintain good
    performance, over time the IO submission threads duplicated some IO
    scheduler characteristics such as high and low priority IOs and they
    also made some ugly assumptions about request allocation batch sizes.
    
    All of this cost at least one extra context switch during IO submission,
    and doesn't fit well with the modern blkmq IO stack.  So, this commit stops
    using btrfs_schedule_bio().  We may need to adjust the number of async
    helper threads for crcs and compression, but long term it's a better
    path.
    
    Reviewed-by: Josef Bacik <josef@toxicpanda.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 0ae0677a8d86..bc2bbaa485b7 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -436,7 +436,7 @@ int btrfs_read_chunk_tree(struct btrfs_fs_info *fs_info);
 int btrfs_alloc_chunk(struct btrfs_trans_handle *trans, u64 type);
 void btrfs_mapping_tree_free(struct extent_map_tree *tree);
 blk_status_t btrfs_map_bio(struct btrfs_fs_info *fs_info, struct bio *bio,
-			   int mirror_num, int async_submit);
+			   int mirror_num);
 int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
 		       fmode_t flags, void *holder);
 struct btrfs_device *btrfs_scan_one_device(const char *path,

commit 4143cb8b6f00910e73a7503fd922211b9f08cf48
Author: David Sterba <dsterba@suse.com>
Date:   Tue Oct 1 19:57:37 2019 +0200

    btrfs: add const function attribute
    
    For some reason the attribute is called __attribute_const__ and not
    __const, marks functions that have no observable effects on program
    state, IOW not reading pointers, just the arguments and calculating a
    value. Allows the compiler to do some optimizations, based on
    -Wsuggest-attribute=const . The effects are rather small, though, about
    60 bytes decrese of btrfs.ko.
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index a7da1f3e3627..0ae0677a8d86 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -571,7 +571,7 @@ static inline enum btrfs_raid_types btrfs_bg_flags_to_raid_index(u64 flags)
 
 void btrfs_commit_device_sizes(struct btrfs_transaction *trans);
 
-struct list_head *btrfs_get_fs_uuids(void);
+struct list_head * __attribute_const__ btrfs_get_fs_uuids(void);
 void btrfs_set_fs_info_ptr(struct btrfs_fs_info *fs_info);
 void btrfs_reset_fs_info_ptr(struct btrfs_fs_info *fs_info);
 bool btrfs_check_rw_degradable(struct btrfs_fs_info *fs_info,

commit 4e411a7d044168520d936264c9fe40847cf031eb
Author: Anand Jain <anand.jain@oracle.com>
Date:   Wed Aug 7 16:21:19 2019 +0800

    btrfs: reset device stat using btrfs_dev_stat_set
    
    btrfs_dev_stat_reset() is an overdo in terms of wrapping. So this patch
    open codes btrfs_dev_stat_reset().
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 081cb734a239..a7da1f3e3627 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -547,12 +547,6 @@ static inline void btrfs_dev_stat_set(struct btrfs_device *dev,
 	atomic_inc(&dev->dev_stats_ccnt);
 }
 
-static inline void btrfs_dev_stat_reset(struct btrfs_device *dev,
-					int index)
-{
-	btrfs_dev_stat_set(dev, index, 0);
-}
-
 /*
  * Convert block group flags (BTRFS_BLOCK_GROUP_*) to btrfs_raid_types, which
  * can be used as index to access btrfs_raid_array[].

commit adf4c0c53a987205b95513a160c11b9600e31220
Author: David Sterba <dsterba@suse.com>
Date:   Thu Aug 1 19:53:02 2019 +0200

    btrfs: remove unused btrfs_device::flush_bio_sent
    
    The status of flush bio is tracked as a status bit, changed in commit
    1c3063b6dbfa ("btrfs: cleanup device states define
    BTRFS_DEV_STATE_FLUSH_SENT"), the flush_bio_sent was forgotten.
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index c71354fe1363..081cb734a239 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -82,7 +82,6 @@ struct btrfs_device {
 
 	unsigned long dev_state;
 	blk_status_t last_flush_error;
-	int flush_bio_sent;
 
 #ifdef __BTRFS_NEED_DEVICE_DATA_ORDERED
 	seqcount_t data_seqcount;

commit 9e3246a5f675932079cf4cc1818b7c1b02f93e36
Author: Qu Wenruo <wqu@suse.com>
Date:   Fri Jul 19 14:51:41 2019 +0800

    btrfs: volumes: Unexport find_free_dev_extent_start()
    
    This function is only used locally in find_free_dev_extent(), no
    external callers.
    
    So unexport it.
    
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 7f6aa1816409..c71354fe1363 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -475,8 +475,6 @@ int btrfs_cancel_balance(struct btrfs_fs_info *fs_info);
 int btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info);
 int btrfs_check_uuid_tree(struct btrfs_fs_info *fs_info);
 int btrfs_chunk_readonly(struct btrfs_fs_info *fs_info, u64 chunk_offset);
-int find_free_dev_extent_start(struct btrfs_device *device, u64 num_bytes,
-			       u64 search_start, u64 *start, u64 *max_avail);
 int find_free_dev_extent(struct btrfs_device *device, u64 num_bytes,
 			 u64 *start, u64 *max_avail);
 void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index);

commit 89b798ad1b42b1de10d64feda241e35e90c7b102
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Mon Jun 3 12:05:05 2019 +0300

    btrfs: Use btrfs_get_io_geometry appropriately
    
    Presently btrfs_map_block is used not only to do everything necessary to
    map a bio to the underlying allocation profile but it's also used to
    identify how much data could be written based on btrfs' stripe logic
    without actually submitting anything. This is achieved by passing NULL
    for 'bbio_ret' parameter.
    
    This patch refactors all callers that require just the mapping length
    by switching them to using btrfs_io_geometry instead of calling
    btrfs_map_block with a special NULL value for 'bbio_ret'. No functional
    change.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 2a8e398a8742..7f6aa1816409 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -429,7 +429,7 @@ int btrfs_map_sblock(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
 		     u64 logical, u64 *length,
 		     struct btrfs_bio **bbio_ret);
 int btrfs_get_io_geometry(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
-			  u64 logical, u64 len, struct btrfs_io_geometry *io_geom);
+		u64 logical, u64 len, struct btrfs_io_geometry *io_geom);
 int btrfs_rmap_block(struct btrfs_fs_info *fs_info, u64 chunk_start,
 		     u64 physical, u64 **logical, int *naddrs, int *stripe_len);
 int btrfs_read_sys_array(struct btrfs_fs_info *fs_info);

commit 5f1411265e16b257a945a5c9044aecbc7bb99443
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Mon Jun 3 12:05:03 2019 +0300

    btrfs: Introduce btrfs_io_geometry infrastructure
    
    Add a structure that holds various parameters for IO calculations and a
    helper that fills the values. This will help further refactoring and
    reduction of functions that in some way open-coded the calculations.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index fea7b65a712e..2a8e398a8742 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -23,6 +23,21 @@ struct btrfs_pending_bios {
 	struct bio *tail;
 };
 
+struct btrfs_io_geometry {
+	/* remaining bytes before crossing a stripe */
+	u64 len;
+	/* offset of logical address in chunk */
+	u64 offset;
+	/* length of single IO stripe */
+	u64 stripe_len;
+	/* number of stripe where address falls */
+	u64 stripe_nr;
+	/* offset of address in stripe */
+	u64 stripe_offset;
+	/* offset of raid56 stripe into the chunk */
+	u64 raid56_stripe_offset;
+};
+
 /*
  * Use sequence counter to get consistent device stat data on
  * 32-bit processors.
@@ -413,6 +428,8 @@ int btrfs_map_block(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
 int btrfs_map_sblock(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
 		     u64 logical, u64 *length,
 		     struct btrfs_bio **bbio_ret);
+int btrfs_get_io_geometry(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
+			  u64 logical, u64 len, struct btrfs_io_geometry *io_geom);
 int btrfs_rmap_block(struct btrfs_fs_info *fs_info, u64 chunk_start,
 		     u64 physical, u64 **logical, int *naddrs, int *stripe_len);
 int btrfs_read_sys_array(struct btrfs_fs_info *fs_info);

commit 0b6f5d408bb5df3101eb1944b1f301dea50c7e7e
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Thu May 9 18:11:11 2019 +0300

    btrfs: Add comments on locking of several device-related fields
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 4a7a4d90ded8..fea7b65a712e 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -43,8 +43,8 @@ struct btrfs_pending_bios {
 #define BTRFS_DEV_STATE_FLUSH_SENT	(4)
 
 struct btrfs_device {
-	struct list_head dev_list;
-	struct list_head dev_alloc_list;
+	struct list_head dev_list; /* device_list_mutex */
+	struct list_head dev_alloc_list; /* chunk mutex */
 	struct list_head post_commit_list; /* chunk mutex */
 	struct btrfs_fs_devices *fs_devices;
 	struct btrfs_fs_info *fs_info;
@@ -229,9 +229,14 @@ struct btrfs_fs_devices {
 	 * this mutex lock.
 	 */
 	struct mutex device_list_mutex;
+
+	/* List of all devices, protected by device_list_mutex */
 	struct list_head devices;
 
-	/* devices not currently being allocated */
+	/*
+	 * Devices which can satisfy space allocation. Protected by
+	 * chunk_mutex
+	 */
 	struct list_head alloc_list;
 
 	struct btrfs_fs_devices *seed;

commit 158da513b13deb04b266e4ad171871d1a8531f26
Author: David Sterba <dsterba@suse.com>
Date:   Fri May 17 11:43:41 2019 +0200

    btrfs: refactor helper for bg flags to name conversion
    
    The helper lacks the btrfs_ prefix and the parameter is the raw
    blockgroup type, so none of the callers has to do the flags -> index
    conversion.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 73520a6ed90a..4a7a4d90ded8 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -556,8 +556,6 @@ static inline enum btrfs_raid_types btrfs_bg_flags_to_raid_index(u64 flags)
 	return BTRFS_RAID_SINGLE; /* BTRFS_BLOCK_GROUP_SINGLE */
 }
 
-const char *get_raid_name(enum btrfs_raid_types type);
-
 void btrfs_commit_device_sizes(struct btrfs_transaction *trans);
 
 struct list_head *btrfs_get_fs_uuids(void);
@@ -567,6 +565,7 @@ bool btrfs_check_rw_degradable(struct btrfs_fs_info *fs_info,
 					struct btrfs_device *failing_dev);
 
 int btrfs_bg_type_to_factor(u64 flags);
+const char *btrfs_bg_type_to_raid_name(u64 flags);
 int btrfs_verify_dev_extents(struct btrfs_fs_info *fs_info);
 
 #endif

commit 8c3e3582a4f0dbdaea49cfd71640a626c8bb7134
Author: David Sterba <dsterba@suse.com>
Date:   Fri May 17 11:43:36 2019 +0200

    btrfs: use u8 for raid_array members
    
    The raid_attr table is now 7 * 56 = 392 bytes long, consisting of just
    small numbers so we don't have to use ints. New size is 7 * 32 = 224,
    saving 3 cachelines.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 07156d974ac4..73520a6ed90a 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -336,16 +336,16 @@ struct btrfs_device_info {
 };
 
 struct btrfs_raid_attr {
-	int sub_stripes;	/* sub_stripes info for map */
-	int dev_stripes;	/* stripes per dev */
-	int devs_max;		/* max devs to use */
-	int devs_min;		/* min devs needed */
-	int tolerated_failures; /* max tolerated fail devs */
-	int devs_increment;	/* ndevs has to be a multiple of this */
-	int ncopies;		/* how many copies to data has */
-	int nparity;		/* number of stripes worth of bytes to store
+	u8 sub_stripes;		/* sub_stripes info for map */
+	u8 dev_stripes;		/* stripes per dev */
+	u8 devs_max;		/* max devs to use */
+	u8 devs_min;		/* min devs needed */
+	u8 tolerated_failures;	/* max tolerated fail devs */
+	u8 devs_increment;	/* ndevs has to be a multiple of this */
+	u8 ncopies;		/* how many copies to data has */
+	u8 nparity;		/* number of stripes worth of bytes to store
 				 * parity information */
-	int mindev_error;	/* error code if min devs requisite is unmet */
+	u8 mindev_error;	/* error code if min devs requisite is unmet */
 	const char raid_name[8]; /* name of the raid */
 	u64 bg_flag;		/* block group flag of the raid */
 };

commit c8bf1b67039556884d0532f7b06acd524c90ed87
Author: David Sterba <dsterba@suse.com>
Date:   Fri May 17 11:43:17 2019 +0200

    btrfs: remove mapping tree structures indirection
    
    fs_info::mapping_tree is the physical<->logical mapping tree and uses
    the same underlying structure as extents, but is embedded to another
    structure. There are no other members and this indirection is useless.
    No functional change.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 136a3eb64604..07156d974ac4 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -413,8 +413,7 @@ int btrfs_rmap_block(struct btrfs_fs_info *fs_info, u64 chunk_start,
 int btrfs_read_sys_array(struct btrfs_fs_info *fs_info);
 int btrfs_read_chunk_tree(struct btrfs_fs_info *fs_info);
 int btrfs_alloc_chunk(struct btrfs_trans_handle *trans, u64 type);
-void btrfs_mapping_init(struct btrfs_mapping_tree *tree);
-void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree);
+void btrfs_mapping_tree_free(struct extent_map_tree *tree);
 blk_status_t btrfs_map_bio(struct btrfs_fs_info *fs_info, struct bio *bio,
 			   int mirror_num, int async_submit);
 int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,

commit b4b52b881cf08e13d110eac811d4becc0775abbf
Merge: 2d60d96b6f00 ccaa75187a5f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 12:48:10 2019 -0700

    Merge tag 'Wimplicit-fallthrough-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gustavoars/linux
    
    Pull Wimplicit-fallthrough updates from Gustavo A. R. Silva:
     "Mark switch cases where we are expecting to fall through.
    
      This is part of the ongoing efforts to enable -Wimplicit-fallthrough.
    
      Most of them have been baking in linux-next for a whole development
      cycle. And with Stephen Rothwell's help, we've had linux-next
      nag-emails going out for newly introduced code that triggers
      -Wimplicit-fallthrough to avoid gaining more of these cases while we
      work to remove the ones that are already present.
    
      We are getting close to completing this work. Currently, there are
      only 32 of 2311 of these cases left to be addressed in linux-next. I'm
      auditing every case; I take a look into the code and analyze it in
      order to determine if I'm dealing with an actual bug or a false
      positive, as explained here:
    
          https://lore.kernel.org/lkml/c2fad584-1705-a5f2-d63c-824e9b96cf50@embeddedor.com/
    
      While working on this, I've found and fixed the several missing
      break/return bugs, some of them introduced more than 5 years ago.
    
      Once this work is finished, we'll be able to universally enable
      "-Wimplicit-fallthrough" to avoid any of these kinds of bugs from
      entering the kernel again"
    
    * tag 'Wimplicit-fallthrough-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gustavoars/linux: (27 commits)
      memstick: mark expected switch fall-throughs
      drm/nouveau/nvkm: mark expected switch fall-throughs
      NFC: st21nfca: Fix fall-through warnings
      NFC: pn533: mark expected switch fall-throughs
      block: Mark expected switch fall-throughs
      ASN.1: mark expected switch fall-through
      lib/cmdline.c: mark expected switch fall-throughs
      lib: zstd: Mark expected switch fall-throughs
      scsi: sym53c8xx_2: sym_nvram: Mark expected switch fall-through
      scsi: sym53c8xx_2: sym_hipd: mark expected switch fall-throughs
      scsi: ppa: mark expected switch fall-through
      scsi: osst: mark expected switch fall-throughs
      scsi: lpfc: lpfc_scsi: Mark expected switch fall-throughs
      scsi: lpfc: lpfc_nvme: Mark expected switch fall-through
      scsi: lpfc: lpfc_nportdisc: Mark expected switch fall-through
      scsi: lpfc: lpfc_hbadisc: Mark expected switch fall-throughs
      scsi: lpfc: lpfc_els: Mark expected switch fall-throughs
      scsi: lpfc: lpfc_ct: Mark expected switch fall-throughs
      scsi: imm: mark expected switch fall-throughs
      scsi: csiostor: csio_wr: mark expected switch fall-through
      ...

commit 65237ee3b6b3c529548438054a819f63fb50757d
Author: David Sterba <dsterba@suse.com>
Date:   Wed Mar 20 16:34:54 2019 +0100

    btrfs: get fs_info from device in btrfs_rm_dev_replace_free_srcdev
    
    We can read fs_info from the device and can drop it from the parameters.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index b3a89d767512..b8a0e8d0672d 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -464,8 +464,7 @@ void btrfs_init_devices_late(struct btrfs_fs_info *fs_info);
 int btrfs_init_dev_stats(struct btrfs_fs_info *fs_info);
 int btrfs_run_dev_stats(struct btrfs_trans_handle *trans);
 void btrfs_rm_dev_replace_remove_srcdev(struct btrfs_device *srcdev);
-void btrfs_rm_dev_replace_free_srcdev(struct btrfs_fs_info *fs_info,
-				      struct btrfs_device *srcdev);
+void btrfs_rm_dev_replace_free_srcdev(struct btrfs_device *srcdev);
 void btrfs_destroy_dev_replace_tgtdev(struct btrfs_device *tgtdev);
 void btrfs_scratch_superblocks(struct block_device *bdev, const char *device_path);
 int btrfs_is_parity_mirror(struct btrfs_fs_info *fs_info,

commit 196c9d8de8389643318c22259fd5bcfccbc7fb91
Author: David Sterba <dsterba@suse.com>
Date:   Wed Mar 20 16:50:38 2019 +0100

    btrfs: get fs_info from trans in btrfs_run_dev_stats
    
    We can read fs_info from the transaction and can drop it from the
    parameters.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 986eaeba1a07..b3a89d767512 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -462,8 +462,7 @@ int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,
 			struct btrfs_ioctl_get_dev_stats *stats);
 void btrfs_init_devices_late(struct btrfs_fs_info *fs_info);
 int btrfs_init_dev_stats(struct btrfs_fs_info *fs_info);
-int btrfs_run_dev_stats(struct btrfs_trans_handle *trans,
-			struct btrfs_fs_info *fs_info);
+int btrfs_run_dev_stats(struct btrfs_trans_handle *trans);
 void btrfs_rm_dev_replace_remove_srcdev(struct btrfs_device *srcdev);
 void btrfs_rm_dev_replace_free_srcdev(struct btrfs_fs_info *fs_info,
 				      struct btrfs_device *srcdev);

commit 60dfdf25bd31b94d0ed8e0ea50964ff22cc36a87
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Wed Mar 27 14:24:14 2019 +0200

    btrfs: Remove 'trans' argument from find_free_dev_extent(_start)
    
    Now that these functions no longer require a handle to transaction to
    inspect pending/pinned chunks the argument can be removed. At the same
    time also remove any surrounding code which acquired the handle.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 6c466ac27c2e..986eaeba1a07 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -453,11 +453,9 @@ int btrfs_cancel_balance(struct btrfs_fs_info *fs_info);
 int btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info);
 int btrfs_check_uuid_tree(struct btrfs_fs_info *fs_info);
 int btrfs_chunk_readonly(struct btrfs_fs_info *fs_info, u64 chunk_offset);
-int find_free_dev_extent_start(struct btrfs_transaction *transaction,
-			 struct btrfs_device *device, u64 num_bytes,
-			 u64 search_start, u64 *start, u64 *max_avail);
-int find_free_dev_extent(struct btrfs_trans_handle *trans,
-			 struct btrfs_device *device, u64 num_bytes,
+int find_free_dev_extent_start(struct btrfs_device *device, u64 num_bytes,
+			       u64 search_start, u64 *start, u64 *max_avail);
+int find_free_dev_extent(struct btrfs_device *device, u64 num_bytes,
 			 u64 *start, u64 *max_avail);
 void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index);
 int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,

commit 1c11b63eff2a67906cb9137bc6b2ee27767f313b
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Mar 27 14:24:12 2019 +0200

    btrfs: replace pending/pinned chunks lists with io tree
    
    The pending chunks list contains chunks that are allocated in the
    current transaction but haven't been created yet. The pinned chunks
    list contains chunks that are being released in the current transaction.
    Both describe chunks that are not reflected on disk as in use but are
    unavailable just the same.
    
    The pending chunks list is anchored by the transaction handle, which
    means that we need to hold a reference to a transaction when working
    with the list.
    
    The way we use them is by iterating over both lists to perform
    comparisons on the stripes they describe for each device. This is
    backwards and requires that we keep a transaction handle open while
    we're trimming.
    
    This patchset adds an extent_io_tree to btrfs_device that maintains
    the allocation state of the device.  Extents are set dirty when
    chunks are first allocated -- when the extent maps are added to the
    mapping tree. They're cleared when last removed -- when the extent
    maps are removed from the mapping tree. This matches the lifespan
    of the pending and pinned chunks list and allows us to do trims
    on unallocated space safely without pinning the transaction for what
    may be a lengthy operation. We can also use this io tree to mark
    which chunks have already been trimmed so we don't repeat the operation.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index d3658a4e65db..6c466ac27c2e 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -133,6 +133,8 @@ struct btrfs_device {
 	/* Counter to record the change of device stats */
 	atomic_t dev_stats_ccnt;
 	atomic_t dev_stat_values[BTRFS_DEV_STAT_VALUES_MAX];
+
+	struct extent_io_tree alloc_state;
 };
 
 /*

commit 8e75fd893b0608aa3a45f8654b71960423df5f3e
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Wed Mar 27 14:24:11 2019 +0200

    btrfs: Stop using call_rcu for device freeing
    
    btrfs_device structs are freed from RCU context since device iteration
    is protected by RCU. Currently this is achieved by using call_rcu since
    no blocking functions are called within btrfs_free_device. Future
    refactoring of pending/pinned chunks will require calling sleeping
    functions.
    
    This patch is in preparation for these changes by simply switching from
    RCU callbacks to explicit calls of synchronize_rcu and calling
    btrfs_free_device directly. This is functionally equivalent, making sure
    that there are no readers at that time.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index b9912b910d6d..d3658a4e65db 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -118,7 +118,6 @@ struct btrfs_device {
 	struct scrub_ctx *scrub_ctx;
 
 	struct btrfs_work work;
-	struct rcu_head rcu;
 
 	/* readahead state */
 	atomic_t reada_in_flight;

commit bbbf7243d62d8be73b7ef60721c127b36b2d523e
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Mon Mar 25 14:31:22 2019 +0200

    btrfs: combine device update operations during transaction commit
    
    We currently overload the pending_chunks list to handle updating
    btrfs_device->commit_bytes used.  We don't actually care about the
    extent mapping or even the device mapping for the chunk - we just need
    the device, and we can end up processing it multiple times.  The
    fs_devices->resized_list does more or less the same thing, but with the
    disk size.  They are called consecutively during commit and have more or
    less the same purpose.
    
    We can combine the two lists into a single list that attaches to the
    transaction and contains a list of devices that need updating.  Since we
    always add the device to a list when we change bytes_used or
    disk_total_size, there's no harm in copying both values at once.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 38ed94b77202..b9912b910d6d 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -45,6 +45,7 @@ struct btrfs_pending_bios {
 struct btrfs_device {
 	struct list_head dev_list;
 	struct list_head dev_alloc_list;
+	struct list_head post_commit_list; /* chunk mutex */
 	struct btrfs_fs_devices *fs_devices;
 	struct btrfs_fs_info *fs_info;
 
@@ -102,18 +103,12 @@ struct btrfs_device {
 	 * size of the device on the current transaction
 	 *
 	 * This variant is update when committing the transaction,
-	 * and protected by device_list_mutex
+	 * and protected by chunk mutex
 	 */
 	u64 commit_total_bytes;
 
 	/* bytes used on the current transaction */
 	u64 commit_bytes_used;
-	/*
-	 * used to manage the device which is resized
-	 *
-	 * It is protected by chunk_lock.
-	 */
-	struct list_head resized_list;
 
 	/* for sending down flush barriers */
 	struct bio *flush_bio;
@@ -235,7 +230,6 @@ struct btrfs_fs_devices {
 	struct mutex device_list_mutex;
 	struct list_head devices;
 
-	struct list_head resized_devices;
 	/* devices not currently being allocated */
 	struct list_head alloc_list;
 
@@ -567,8 +561,7 @@ static inline enum btrfs_raid_types btrfs_bg_flags_to_raid_index(u64 flags)
 
 const char *get_raid_name(enum btrfs_raid_types type);
 
-void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info);
-void btrfs_update_commit_device_bytes_used(struct btrfs_transaction *trans);
+void btrfs_commit_device_sizes(struct btrfs_transaction *trans);
 
 struct list_head *btrfs_get_fs_uuids(void);
 void btrfs_set_fs_info_ptr(struct btrfs_fs_info *fs_info);

commit ab4ba2e133463c702b37242560d7fabedd2dc750
Author: Qu Wenruo <wqu@suse.com>
Date:   Fri Mar 8 14:20:03 2019 +0800

    btrfs: tree-checker: Verify dev item
    
    [BUG]
    For fuzzed image whose DEV_ITEM has invalid total_bytes as 0, then
    kernel will just panic:
      BUG: unable to handle kernel NULL pointer dereference at 0000000000000098
      #PF error: [normal kernel read fault]
      PGD 800000022b2bd067 P4D 800000022b2bd067 PUD 22b2bc067 PMD 0
      Oops: 0000 [#1] SMP PTI
      CPU: 0 PID: 1106 Comm: mount Not tainted 5.0.0-rc8+ #9
      RIP: 0010:btrfs_verify_dev_extents+0x2a5/0x5a0
      Call Trace:
       open_ctree+0x160d/0x2149
       btrfs_mount_root+0x5b2/0x680
    
    [CAUSE]
    If device extent verification finds a deivce with 0 total_bytes, then it
    assumes it's a seed dummy, then search for seed devices.
    
    But in this case, there is no seed device at all, causing NULL pointer.
    
    [FIX]
    Since this is caused by fuzzed image, let's go the tree-check way, just
    add a new verification for device item.
    
    Reported-by: Yoon Jungyeon <jungyeon@gatech.edu>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=202691
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 3ad9d58d1b66..38ed94b77202 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -258,6 +258,15 @@ struct btrfs_fs_devices {
 
 #define BTRFS_BIO_INLINE_CSUM_SIZE	64
 
+#define BTRFS_MAX_DEVS(info) ((BTRFS_MAX_ITEM_SIZE(info)	\
+			- sizeof(struct btrfs_chunk))		\
+			/ sizeof(struct btrfs_stripe) + 1)
+
+#define BTRFS_MAX_DEVS_SYS_CHUNK ((BTRFS_SYSTEM_CHUNK_ARRAY_SIZE	\
+				- 2 * sizeof(struct btrfs_disk_key)	\
+				- 2 * sizeof(struct btrfs_chunk))	\
+				/ sizeof(struct btrfs_stripe) + 1)
+
 /*
  * we need the mirror number and stripe index to be passed around
  * the call chain while we are processing end_io (especially errors).

commit 0a4c92657f2543bb8fd480c5af90c6bb87f18e00
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Wed Jan 23 02:48:28 2019 -0600

    fs: mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    This patch fixes the following warnings:
    
    fs/affs/affs.h:124:38: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/configfs/dir.c:1692:11: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/configfs/dir.c:1694:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ceph/file.c:249:3: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ext4/hash.c:233:15: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ext4/hash.c:246:15: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ext2/inode.c:1237:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ext2/inode.c:1244:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ext4/indirect.c:1182:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ext4/indirect.c:1188:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ext4/indirect.c:1432:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ext4/indirect.c:1440:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/f2fs/node.c:618:8: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/f2fs/node.c:620:8: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/btrfs/ref-verify.c:522:15: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/gfs2/bmap.c:711:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/gfs2/bmap.c:722:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/jffs2/fs.c:339:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/nfsd/nfs4proc.c:429:12: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ufs/util.h:62:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/ufs/util.h:43:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/fcntl.c:770:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/seq_file.c:319:10: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/libfs.c:148:11: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/libfs.c:150:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/signalfd.c:178:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
    fs/locks.c:1473:16: warning: this statement may fall through [-Wimplicit-fallthrough=]
    
    Warning level 3 was used: -Wimplicit-fallthrough=3
    
    This patch is part of the ongoing efforts to enabling
    -Wimplicit-fallthrough.
    
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 3ad9d58d1b66..adcbb4e7b1a0 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -390,6 +390,7 @@ static inline enum btrfs_map_op btrfs_op(struct bio *bio)
 		return BTRFS_MAP_WRITE;
 	default:
 		WARN_ON_ONCE(1);
+		/* fall through */
 	case REQ_OP_READ:
 		return BTRFS_MAP_READ;
 	}

commit 228a73abde5c04428678e917b271f8526cfd90ed
Author: Anand Jain <anand.jain@oracle.com>
Date:   Fri Jan 4 13:31:54 2019 +0800

    btrfs: introduce new ioctl to unregister a btrfs device
    
    Support for a new command that can be used eg. as a command
    
      $ btrfs device scan --forget [dev]'
    (the final name may change though)
    
    to undo the effects of 'btrfs device scan [dev]'. For this purpose
    this patch proposes to use ioctl #5 as it was empty and is next to the
    SCAN ioctl.
    
    The new ioctl BTRFS_IOC_FORGET_DEV works only on the control device
    (/dev/btrfs-control) to unregister one or all devices, devices that are
    not mounted.
    
    The argument is struct btrfs_ioctl_vol_args, ::name specifies the device
    path. To unregister all device, the path is an empty string.
    
    Again, the devices are removed only if they aren't part of a mounte
    filesystem.
    
    This new ioctl provides:
    
    - release of unwanted btrfs_fs_devices and btrfs_devices structures
      from memory if the device is not going to be mounted
    
    - ability to mount filesystem in degraded mode, when one devices is
      corrupted like in split brain raid1
    
    - running test cases which would require reloading the kernel module
      but this is not possible eg. due to mounted filesystem or built-in
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ update changelog ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 656ea8d85770..3ad9d58d1b66 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -416,6 +416,7 @@ int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
 		       fmode_t flags, void *holder);
 struct btrfs_device *btrfs_scan_one_device(const char *path,
 					   fmode_t flags, void *holder);
+int btrfs_forget_devices(const char *path);
 int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
 void btrfs_free_extra_devids(struct btrfs_fs_devices *fs_devices, int step);
 void btrfs_assign_next_active_device(struct btrfs_device *device,

commit 09ba3bc9dd150457c506e4661380a6183af651c1
Author: Anand Jain <anand.jain@oracle.com>
Date:   Sat Jan 19 14:48:55 2019 +0800

    btrfs: merge btrfs_find_device and find_device
    
    Both btrfs_find_device() and find_device() does the same thing except
    that the latter does not take the seed device onto account in the device
    scanning context. We can merge them.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 4b7c049c8c7c..656ea8d85770 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -434,7 +434,7 @@ int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len);
 int btrfs_grow_device(struct btrfs_trans_handle *trans,
 		      struct btrfs_device *device, u64 new_size);
 struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices,
-				       u64 devid, u8 *uuid, u8 *fsid);
+				       u64 devid, u8 *uuid, u8 *fsid, bool seed);
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_fs_info *fs_info, const char *path);
 int btrfs_balance(struct btrfs_fs_info *fs_info,

commit e4319cd9cacef80a2d289f235b939ab8bd614683
Author: Anand Jain <anand.jain@oracle.com>
Date:   Thu Jan 17 23:32:31 2019 +0800

    btrfs: refactor btrfs_find_device() take fs_devices as argument
    
    btrfs_find_device() accepts fs_info as an argument and retrieves
    fs_devices from fs_info.
    
    Instead use fs_devices, so that this function can be used in non-mount
    (during device scanning) context as well.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index ed806649a473..4b7c049c8c7c 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -433,8 +433,8 @@ void __exit btrfs_cleanup_fs_uuids(void);
 int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len);
 int btrfs_grow_device(struct btrfs_trans_handle *trans,
 		      struct btrfs_device *device, u64 new_size);
-struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,
-				       u8 *uuid, u8 *fsid);
+struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices,
+				       u64 devid, u8 *uuid, u8 *fsid);
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_fs_info *fs_info, const char *path);
 int btrfs_balance(struct btrfs_fs_info *fs_info,

commit 7b41ba71c1a08ae35805b562ae5e2f8ddfb8e00d
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Fri Nov 23 09:42:27 2018 +0100

    btrfs: remove btrfs_bio_end_io_t
    
    The btrfs_bio_end_io_t typedef was introduced with commit
    a1d3c4786a4b ("btrfs: btrfs_multi_bio replaced with btrfs_bio")
    but never used anywhere. This commit also introduced a forward declaration
    of 'struct btrfs_bio' which is only needed for btrfs_bio_end_io_t.
    
    Remove both as they're not needed anywhere.
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 48e8bb546780..ed806649a473 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -300,9 +300,6 @@ struct btrfs_bio_stripe {
 	u64 length; /* only used for discard mappings */
 };
 
-struct btrfs_bio;
-typedef void (btrfs_bio_end_io_t) (struct btrfs_bio *bio, int err);
-
 struct btrfs_bio {
 	refcount_t refs;
 	atomic_t stripes_pending;

commit b3a0dd50c3951ec1b9a12ec39034194022fd8693
Author: David Sterba <dsterba@suse.com>
Date:   Thu Nov 22 17:16:49 2018 +0100

    btrfs: replace btrfs_io_bio::end_io with a simple helper
    
    The end_io callback implemented as btrfs_io_bio_endio_readpage only
    calls kfree. Also the callback is set only in case the csum buffer is
    allocated and not pointing to the inline buffer. We can use that
    information to drop the indirection and call a helper that will free the
    csums only in the right case.
    
    This shrinks struct btrfs_io_bio by 8 bytes.
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 702c78cf2b4d..48e8bb546780 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -267,14 +267,12 @@ struct btrfs_fs_devices {
  * we allocate are actually btrfs_io_bios.  We'll cram as much of
  * struct btrfs_bio as we can into this over time.
  */
-typedef void (btrfs_io_bio_end_io_t) (struct btrfs_io_bio *bio, int err);
 struct btrfs_io_bio {
 	unsigned int mirror_num;
 	unsigned int stripe_index;
 	u64 logical;
 	u8 *csum;
 	u8 csum_inline[BTRFS_BIO_INLINE_CSUM_SIZE];
-	btrfs_io_bio_end_io_t *end_io;
 	struct bvec_iter iter;
 	/*
 	 * This member must come last, bio_alloc_bioset will allocate enough
@@ -288,6 +286,14 @@ static inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)
 	return container_of(bio, struct btrfs_io_bio, bio);
 }
 
+static inline void btrfs_io_bio_free_csum(struct btrfs_io_bio *io_bio)
+{
+	if (io_bio->csum != io_bio->csum_inline) {
+		kfree(io_bio->csum);
+		io_bio->csum = NULL;
+	}
+}
+
 struct btrfs_bio_stripe {
 	struct btrfs_device *dev;
 	u64 physical;

commit 31fecccbd7b2174487a6b7361153b60a4eda6108
Author: David Sterba <dsterba@suse.com>
Date:   Thu Nov 22 17:16:46 2018 +0100

    btrfs: remove redundant csum buffer in btrfs_io_bio
    
    The io_bio tracks checksums and has an inline buffer or an allocated
    one. And there's a third member that points to the right one, but we
    don't need to use an extra pointer for that. Let btrfs_io_bio::csum
    point to the right buffer and check that the inline buffer is not
    accidentally freed.
    
    This shrinks struct btrfs_io_bio by 8 bytes.
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 8b092bb1e2ee..702c78cf2b4d 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -274,7 +274,6 @@ struct btrfs_io_bio {
 	u64 logical;
 	u8 *csum;
 	u8 csum_inline[BTRFS_BIO_INLINE_CSUM_SIZE];
-	u8 *csum_allocated;
 	btrfs_io_bio_end_io_t *end_io;
 	struct bvec_iter iter;
 	/*

commit f89e09cf45533eb25ca8e7fbedec697ecb37eb94
Author: Anand Jain <anand.jain@oracle.com>
Date:   Tue Nov 20 16:12:55 2018 +0800

    btrfs: add helper to describe block group flags
    
    Factor out helper that describes block group flags from
    describe_relocation. The result will not be longer than the given size.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ add comments ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 1d936ce282c3..8b092bb1e2ee 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -438,6 +438,7 @@ int btrfs_init_new_device(struct btrfs_fs_info *fs_info, const char *path);
 int btrfs_balance(struct btrfs_fs_info *fs_info,
 		  struct btrfs_balance_control *bctl,
 		  struct btrfs_ioctl_balance_args *bargs);
+void btrfs_describe_block_groups(u64 flags, char *buf, u32 size_buf);
 int btrfs_resume_balance_async(struct btrfs_fs_info *fs_info);
 int btrfs_recover_balance(struct btrfs_fs_info *fs_info);
 int btrfs_pause_balance(struct btrfs_fs_info *fs_info);

commit d1a63002829a4d8014de20dc141b404cc808405e
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Tue Oct 30 16:43:26 2018 +0200

    btrfs: add members to fs_devices to track fsid changes
    
    In order to gracefully handle split-brain scenario during fsid change
    (which are very unlikely, yet possible), two more pieces of information
    will be necessary:
    
    1. The highest generation number among all devices registered to a
       particular btrfs_fs_devices
    
    2. A boolean flag whether a given btrfs_fs_devices was created by a
       device which had the FSID_CHANGING_V2 flag set.
    
    This is a preparatory patch and just introduces the variables as well
    as code which sets them, their actual use is going to happen in a later
    patch.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index bdee4b60e0ba..1d936ce282c3 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -211,6 +211,7 @@ BTRFS_DEVICE_GETSET_FUNCS(bytes_used);
 struct btrfs_fs_devices {
 	u8 fsid[BTRFS_FSID_SIZE]; /* FS specific uuid */
 	u8 metadata_uuid[BTRFS_FSID_SIZE];
+	bool fsid_change;
 	struct list_head fs_list;
 
 	u64 num_devices;
@@ -219,6 +220,10 @@ struct btrfs_fs_devices {
 	u64 missing_devices;
 	u64 total_rw_bytes;
 	u64 total_devices;
+
+	/* Highest generation number of seen devices */
+	u64 latest_generation;
+
 	struct block_device *latest_bdev;
 
 	/* all of the devices in the FS, protected by a mutex

commit 7239ff4b2be8ec0c3160da7fdd1475785fdb4cb9
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Tue Oct 30 16:43:23 2018 +0200

    btrfs: Introduce support for FSID change without metadata rewrite
    
    This field is going to be used when the user wants to change the UUID
    of the filesystem without having to rewrite all metadata blocks. This
    field adds another level of indirection such that when the FSID is
    changed what really happens is the current UUID (the one with which the
    fs was created) is copied to the 'metadata_uuid' field in the superblock
    as well as a new incompat flag is set METADATA_UUID. When the kernel
    detects this flag is set it knows that the superblock in fact has 2
    UUIDs:
    
    1. Is the UUID which is user-visible, currently known as FSID.
    2. Metadata UUID - this is the UUID which is stamped into all on-disk
       datastructures belonging to this file system.
    
    When the new incompat flag is present device scanning checks whether
    both fsid/metadata_uuid of the scanned device match any of the
    registered filesystems. When the flag is not set then both UUIDs are
    equal and only the FSID is retained on disk, metadata_uuid is set only
    in-memory during mount.
    
    Additionally a new metadata_uuid field is also added to the fs_info
    struct. It's initialised either with the FSID in case METADATA_UUID
    incompat flag is not set or with the metdata_uuid of the superblock
    otherwise.
    
    This commit introduces the new fields as well as the new incompat flag
    and switches all users of the fsid to the new logic.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ minor updates in comments ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 40820e0ec5a4..bdee4b60e0ba 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -210,6 +210,7 @@ BTRFS_DEVICE_GETSET_FUNCS(bytes_used);
 
 struct btrfs_fs_devices {
 	u8 fsid[BTRFS_FSID_SIZE]; /* FS specific uuid */
+	u8 metadata_uuid[BTRFS_FSID_SIZE];
 	struct list_head fs_list;
 
 	u64 num_devices;

commit b50836edf9fe531c66310071df59eac2d8dfc708
Author: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
Date:   Thu Oct 4 23:24:42 2018 +0200

    btrfs: introduce nparity raid_attr
    
    Instead of hardcoding exceptions for RAID5 and RAID6 in the code, use an
    nparity field in raid_attr.
    
    Signed-off-by: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index bca18f70650a..40820e0ec5a4 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -331,6 +331,8 @@ struct btrfs_raid_attr {
 	int tolerated_failures; /* max tolerated fail devs */
 	int devs_increment;	/* ndevs has to be a multiple of this */
 	int ncopies;		/* how many copies to data has */
+	int nparity;		/* number of stripes worth of bytes to store
+				 * parity information */
 	int mindev_error;	/* error code if min devs requisite is unmet */
 	const char raid_name[8]; /* name of the raid */
 	u64 bg_flag;		/* block group flag of the raid */

commit 60ca842e345716eb8c3f7df070511848b9f1a796
Author: Omar Sandoval <osandov@fb.com>
Date:   Wed May 16 16:34:31 2018 -0700

    Btrfs: rename and export get_chunk_map
    
    The Btrfs swap code is going to need it, so give it a btrfs_ prefix and
    make it non-static.
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Omar Sandoval <osandov@fb.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index aefce895e994..bca18f70650a 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -462,6 +462,8 @@ unsigned long btrfs_full_stripe_len(struct btrfs_fs_info *fs_info,
 int btrfs_finish_chunk_alloc(struct btrfs_trans_handle *trans,
 			     u64 chunk_offset, u64 chunk_size);
 int btrfs_remove_chunk(struct btrfs_trans_handle *trans, u64 chunk_offset);
+struct extent_map *btrfs_get_chunk_map(struct btrfs_fs_info *fs_info,
+				       u64 logical, u64 length);
 
 static inline void btrfs_dev_stat_inc(struct btrfs_device *dev,
 				      int index)

commit a27a94c2b0c727517c17cf2ca3a9f7291caadfbc
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Mon Sep 3 12:46:14 2018 +0300

    btrfs: Make btrfs_find_device_by_devspec return btrfs_device directly
    
    Instead of returning an error value and using one of the parameters for
    returning the actual object we are interested in just refactor the
    function to directly return btrfs_device *. Also bubble up the error
    handling for the special BTRFS_ERROR_DEV_MISSING_NOT_FOUND value into
    btrfs_rm_device. No functional changes.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index e7811473024d..aefce895e994 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -410,9 +410,9 @@ int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
 void btrfs_free_extra_devids(struct btrfs_fs_devices *fs_devices, int step);
 void btrfs_assign_next_active_device(struct btrfs_device *device,
 				     struct btrfs_device *this_dev);
-int btrfs_find_device_by_devspec(struct btrfs_fs_info *fs_info, u64 devid,
-					 const char *devpath,
-					 struct btrfs_device **device);
+struct btrfs_device *btrfs_find_device_by_devspec(struct btrfs_fs_info *fs_info,
+						  u64 devid,
+						  const char *devpath);
 struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,
 					const u64 *devid,
 					const u8 *uuid);

commit 6c05040702e7793e8ee63bb8384ac2f9235c926e
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Mon Sep 3 12:46:13 2018 +0300

    btrfs: Make btrfs_find_device_missing_or_by_path return directly a device
    
    This function returns a numeric error value and additionally the
    device found in one of its input parameters. Simplify this by making
    the function directly return a pointer to btrfs_device. Additionally
    adjust the caller to handle the case when we want to remove the
    'missing' device and ENOENT is returned to return the expected
    positive error value, parsed by progs. Finally, unexport the function
    since it's not called outside of volume.c. No functional changes.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 23e9285d88de..e7811473024d 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -410,9 +410,6 @@ int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
 void btrfs_free_extra_devids(struct btrfs_fs_devices *fs_devices, int step);
 void btrfs_assign_next_active_device(struct btrfs_device *device,
 				     struct btrfs_device *this_dev);
-int btrfs_find_device_missing_or_by_path(struct btrfs_fs_info *fs_info,
-					 const char *device_path,
-					 struct btrfs_device **device);
 int btrfs_find_device_by_devspec(struct btrfs_fs_info *fs_info, u64 devid,
 					 const char *devpath,
 					 struct btrfs_device **device);

commit cf90d884b347c50a1e8c1effc4093e497dd68b4b
Author: Qu Wenruo <wqu@suse.com>
Date:   Wed Aug 1 10:37:19 2018 +0800

    btrfs: Introduce mount time chunk <-> dev extent mapping check
    
    This patch will introduce chunk <-> dev extent mapping check, to protect
    us against invalid dev extents or chunks.
    
    Since chunk mapping is the fundamental infrastructure of btrfs, extra
    check at mount time could prevent a lot of unexpected behavior (BUG_ON).
    
    Reported-by: Xu Wen <wen.xu@gatech.edu>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=200403
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=200407
    Signed-off-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: Su Yue <suy.fnst@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 049619176831..23e9285d88de 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -345,6 +345,7 @@ struct map_lookup {
 	u64 stripe_len;
 	int num_stripes;
 	int sub_stripes;
+	int verified_stripes; /* For mount time dev extent verification */
 	struct btrfs_bio_stripe stripes[];
 };
 
@@ -556,5 +557,6 @@ bool btrfs_check_rw_degradable(struct btrfs_fs_info *fs_info,
 					struct btrfs_device *failing_dev);
 
 int btrfs_bg_type_to_factor(u64 flags);
+int btrfs_verify_dev_extents(struct btrfs_fs_info *fs_info);
 
 #endif

commit 97aff912a2fa75555641303d42bd4c723a98df5d
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Fri Jul 20 19:37:53 2018 +0300

    btrfs: Remove fs_info from btrfs_finish_chunk_alloc
    
    It can be referenced from the passed transaction handle.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: Lu Fengqi <lufq.fnst@cn.fujitsu.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 69a028058c43..049619176831 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -462,10 +462,8 @@ int btrfs_is_parity_mirror(struct btrfs_fs_info *fs_info,
 unsigned long btrfs_full_stripe_len(struct btrfs_fs_info *fs_info,
 				    u64 logical);
 int btrfs_finish_chunk_alloc(struct btrfs_trans_handle *trans,
-				struct btrfs_fs_info *fs_info,
-				u64 chunk_offset, u64 chunk_size);
-int btrfs_remove_chunk(struct btrfs_trans_handle *trans,
-		       struct btrfs_fs_info *fs_info, u64 chunk_offset);
+			     u64 chunk_offset, u64 chunk_size);
+int btrfs_remove_chunk(struct btrfs_trans_handle *trans, u64 chunk_offset);
 
 static inline void btrfs_dev_stat_inc(struct btrfs_device *dev,
 				      int index)

commit 4f5ad7bd6315528ed50a11d53c66854a5d16425b
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Fri Jul 20 19:37:51 2018 +0300

    btrfs: Remove fs_info from btrfs_destroy_dev_replace_tgtdev
    
    This function is always passed a well-formed tgtdevice so the fs_info
    can be referenced from there.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: Lu Fengqi <lufq.fnst@cn.fujitsu.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 1bcf0f34e8dc..69a028058c43 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -455,8 +455,7 @@ int btrfs_run_dev_stats(struct btrfs_trans_handle *trans,
 void btrfs_rm_dev_replace_remove_srcdev(struct btrfs_device *srcdev);
 void btrfs_rm_dev_replace_free_srcdev(struct btrfs_fs_info *fs_info,
 				      struct btrfs_device *srcdev);
-void btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,
-				      struct btrfs_device *tgtdev);
+void btrfs_destroy_dev_replace_tgtdev(struct btrfs_device *tgtdev);
 void btrfs_scratch_superblocks(struct block_device *bdev, const char *device_path);
 int btrfs_is_parity_mirror(struct btrfs_fs_info *fs_info,
 			   u64 logical, u64 len);

commit d6507cf1e2dfa4f6888cd90e4c9a307f7ac9b383
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Fri Jul 20 19:37:50 2018 +0300

    btrfs: Remove fs_info from btrfs_assign_next_active_device
    
    It can be referenced from the passed 'device' argument which is always
    a well-formed device.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: Lu Fengqi <lufq.fnst@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 0ae45ff1961b..1bcf0f34e8dc 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -407,8 +407,8 @@ struct btrfs_device *btrfs_scan_one_device(const char *path,
 					   fmode_t flags, void *holder);
 int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
 void btrfs_free_extra_devids(struct btrfs_fs_devices *fs_devices, int step);
-void btrfs_assign_next_active_device(struct btrfs_fs_info *fs_info,
-		struct btrfs_device *device, struct btrfs_device *this_dev);
+void btrfs_assign_next_active_device(struct btrfs_device *device,
+				     struct btrfs_device *this_dev);
 int btrfs_find_device_missing_or_by_path(struct btrfs_fs_info *fs_info,
 					 const char *device_path,
 					 struct btrfs_device **device);

commit 68a9db5f2395cdef98b387bbb816604f6f298056
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Fri Jul 20 19:37:48 2018 +0300

    btrfs: Remove fs_info from btrfs_rm_dev_replace_remove_srcdev
    
    It can be referenced from the passed srcdev argument.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: Lu Fengqi <lufq.fnst@cn.fujitsu.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 6943aab9bdd7..0ae45ff1961b 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -452,8 +452,7 @@ void btrfs_init_devices_late(struct btrfs_fs_info *fs_info);
 int btrfs_init_dev_stats(struct btrfs_fs_info *fs_info);
 int btrfs_run_dev_stats(struct btrfs_trans_handle *trans,
 			struct btrfs_fs_info *fs_info);
-void btrfs_rm_dev_replace_remove_srcdev(struct btrfs_fs_info *fs_info,
-					struct btrfs_device *srcdev);
+void btrfs_rm_dev_replace_remove_srcdev(struct btrfs_device *srcdev);
 void btrfs_rm_dev_replace_free_srcdev(struct btrfs_fs_info *fs_info,
 				      struct btrfs_device *srcdev);
 void btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,

commit 46df06b85e28eaf430aa5c8f8aa26120fa746b72
Author: David Sterba <dsterba@suse.com>
Date:   Fri Jul 13 20:46:30 2018 +0200

    btrfs: refactor block group replication factor calculation to a helper
    
    There are many places that open code the duplicity factor of the block
    group profiles, create a common helper. This can be easily extended for
    more copies.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 06d8bb7dd557..6943aab9bdd7 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -559,4 +559,6 @@ void btrfs_reset_fs_info_ptr(struct btrfs_fs_info *fs_info);
 bool btrfs_check_rw_degradable(struct btrfs_fs_info *fs_info,
 					struct btrfs_device *failing_dev);
 
+int btrfs_bg_type_to_factor(u64 flags);
+
 #endif

commit 36350e95a2b1feed6382fe38cc80f79ec35a1323
Author: Gu Jinxiang <gujx@cn.fujitsu.com>
Date:   Thu Jul 12 14:23:16 2018 +0800

    btrfs: return device pointer from btrfs_scan_one_device
    
    Return device pointer (with the IS_ERR semantics) from
    btrfs_scan_one_device so we don't have to return in through pointer.
    
    And since btrfs_fs_devices can be obtained from btrfs_device, return that.
    
    Signed-off-by: Gu Jinxiang <gujx@cn.fujitsu.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ fixed conflics after recent changes to btrfs_scan_one_device ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 9665b84b1026..06d8bb7dd557 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -403,8 +403,8 @@ blk_status_t btrfs_map_bio(struct btrfs_fs_info *fs_info, struct bio *bio,
 			   int mirror_num, int async_submit);
 int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
 		       fmode_t flags, void *holder);
-int btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,
-			  struct btrfs_fs_devices **fs_devices_ret);
+struct btrfs_device *btrfs_scan_one_device(const char *path,
+					   fmode_t flags, void *holder);
 int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
 void btrfs_free_extra_devids(struct btrfs_fs_devices *fs_devices, int step);
 void btrfs_assign_next_active_device(struct btrfs_fs_info *fs_info,

commit 621567a28ce081424bdcaaef7763a34b204d5be0
Author: Qu Wenruo <wqu@suse.com>
Date:   Mon Jul 9 14:52:54 2018 +0800

    btrfs: Remove unused function btrfs_account_dev_extents_size
    
    This function is not used since the alloc_start parameter has been
    obsoleted in commit 0d0c71b317207082856 ("btrfs: obsolete and remove
    mount option alloc_start").
    
    Signed-off-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 275c31c730cf..9665b84b1026 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -384,8 +384,6 @@ static inline enum btrfs_map_op btrfs_op(struct bio *bio)
 	}
 }
 
-int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,
-				   u64 end, u64 *length);
 void btrfs_get_bbio(struct btrfs_bio *bbio);
 void btrfs_put_bbio(struct btrfs_bio *bbio);
 int btrfs_map_block(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,

commit fce466eab7ac6baa9d2dcd88abcf945be3d4a089
Author: Qu Wenruo <wqu@suse.com>
Date:   Tue Jul 3 17:10:05 2018 +0800

    btrfs: tree-checker: Verify block_group_item
    
    A crafted image with invalid block group items could make free space cache
    code to cause panic.
    
    We could detect such invalid block group item by checking:
    1) Item size
       Known fixed value.
    2) Block group size (key.offset)
       We have an upper limit on block group item (10G)
    3) Chunk objectid
       Known fixed value.
    4) Type
       Only 4 valid type values, DATA, METADATA, SYSTEM and DATA|METADATA.
       No more than 1 bit set for profile type.
    5) Used space
       No more than the block group size.
    
    This should allow btrfs to detect and refuse to mount the crafted image.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=199849
    Reported-by: Xu Wen <wen.xu@gatech.edu>
    Signed-off-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: Gu Jinxiang <gujx@cn.fujitsu.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Tested-by: Gu Jinxiang <gujx@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index df2d8bdf8c9a..275c31c730cf 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -11,6 +11,8 @@
 #include <linux/btrfs.h>
 #include "async-thread.h"
 
+#define BTRFS_MAX_DATA_CHUNK_SIZE	(10ULL * SZ_1G)
+
 extern struct mutex uuid_mutex;
 
 #define BTRFS_STRIPE_LEN	SZ_64K

commit c216b2039aa06f9be23a9f385cb2d2f6434927d7
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Wed Jun 20 15:49:06 2018 +0300

    btrfs: Remove fs_info from btrfs_alloc_chunk
    
    It can be referenced from trans since the function is always called
    within a transaction.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 5139ec8daf4c..df2d8bdf8c9a 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -396,8 +396,7 @@ int btrfs_rmap_block(struct btrfs_fs_info *fs_info, u64 chunk_start,
 		     u64 physical, u64 **logical, int *naddrs, int *stripe_len);
 int btrfs_read_sys_array(struct btrfs_fs_info *fs_info);
 int btrfs_read_chunk_tree(struct btrfs_fs_info *fs_info);
-int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
-		      struct btrfs_fs_info *fs_info, u64 type);
+int btrfs_alloc_chunk(struct btrfs_trans_handle *trans, u64 type);
 void btrfs_mapping_init(struct btrfs_mapping_tree *tree);
 void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree);
 blk_status_t btrfs_map_bio(struct btrfs_fs_info *fs_info, struct bio *bio,

commit 6fcf6e2bffb6cfe26f05795f4fba4e6bb6aa84bf
Author: David Sterba <dsterba@suse.com>
Date:   Mon May 7 17:44:03 2018 +0200

    btrfs: remove redundant btrfs_balance_control::fs_info
    
    The fs_info is always available from the context so we don't need to
    store it in the structure.
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 39787a2f5fb4..5139ec8daf4c 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -352,8 +352,6 @@ struct map_lookup {
 struct btrfs_balance_args;
 struct btrfs_balance_progress;
 struct btrfs_balance_control {
-	struct btrfs_fs_info *fs_info;
-
 	struct btrfs_balance_args data;
 	struct btrfs_balance_args meta;
 	struct btrfs_balance_args sys;
@@ -432,7 +430,8 @@ struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,
 				       u8 *uuid, u8 *fsid);
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_fs_info *fs_info, const char *path);
-int btrfs_balance(struct btrfs_balance_control *bctl,
+int btrfs_balance(struct btrfs_fs_info *fs_info,
+		  struct btrfs_balance_control *bctl,
 		  struct btrfs_ioctl_balance_args *bargs);
 int btrfs_resume_balance_async(struct btrfs_fs_info *fs_info);
 int btrfs_recover_balance(struct btrfs_fs_info *fs_info);

commit 63a9c7b9ceaad9b2d8bd482abd44e2068b828b00
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Fri May 4 10:53:05 2018 +0300

    btrfs: Remove devid parameter from btrfs_rmap_block
    
    This function is used in only one place and devid argument is always
    passed 0. So just remove it, similarly to how it was removed in the
    userspace code.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 3a6dbbce650a..39787a2f5fb4 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -394,9 +394,8 @@ int btrfs_map_block(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
 int btrfs_map_sblock(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
 		     u64 logical, u64 *length,
 		     struct btrfs_bio **bbio_ret);
-int btrfs_rmap_block(struct btrfs_fs_info *fs_info,
-		     u64 chunk_start, u64 physical, u64 devid,
-		     u64 **logical, int *naddrs, int *stripe_len);
+int btrfs_rmap_block(struct btrfs_fs_info *fs_info, u64 chunk_start,
+		     u64 physical, u64 **logical, int *naddrs, int *stripe_len);
 int btrfs_read_sys_array(struct btrfs_fs_info *fs_info);
 int btrfs_read_chunk_tree(struct btrfs_fs_info *fs_info);
 int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,

commit f9fbcaa2a3221f55a8eee319e4b2d532635e002e
Author: Anand Jain <anand.jain@oracle.com>
Date:   Wed Apr 25 19:01:44 2018 +0800

    btrfs: move btrfs_raid_mindev_errorvalues to btrfs_raid_attr table
    
    Add a new member struct btrfs_raid_attr::mindev_error so that
    btrfs_raid_array can maintain the error code to return if the minimum
    number of devices condition is not met while trying to delete a device
    in the given raid. And so we can drop btrfs_raid_mindev_error.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index b26f53462e8d..3a6dbbce650a 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -329,12 +329,12 @@ struct btrfs_raid_attr {
 	int tolerated_failures; /* max tolerated fail devs */
 	int devs_increment;	/* ndevs has to be a multiple of this */
 	int ncopies;		/* how many copies to data has */
+	int mindev_error;	/* error code if min devs requisite is unmet */
 	const char raid_name[8]; /* name of the raid */
 	u64 bg_flag;		/* block group flag of the raid */
 };
 
 extern const struct btrfs_raid_attr btrfs_raid_array[BTRFS_NR_RAID_TYPES];
-extern const int btrfs_raid_mindev_error[BTRFS_NR_RAID_TYPES];
 
 struct map_lookup {
 	u64 type;

commit 41a6e8913cdff6b30ac53a24641259d117c0b101
Author: Anand Jain <anand.jain@oracle.com>
Date:   Wed Apr 25 19:01:43 2018 +0800

    btrfs: move btrfs_raid_group values to btrfs_raid_attr table
    
    Add a new member struct btrfs_raid_attr::bg_flag so that
    btrfs_raid_array can maintain the bit map flag of the raid type, and
    so we can drop btrfs_raid_group.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 9056a900aace..b26f53462e8d 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -330,11 +330,11 @@ struct btrfs_raid_attr {
 	int devs_increment;	/* ndevs has to be a multiple of this */
 	int ncopies;		/* how many copies to data has */
 	const char raid_name[8]; /* name of the raid */
+	u64 bg_flag;		/* block group flag of the raid */
 };
 
 extern const struct btrfs_raid_attr btrfs_raid_array[BTRFS_NR_RAID_TYPES];
 extern const int btrfs_raid_mindev_error[BTRFS_NR_RAID_TYPES];
-extern const u64 btrfs_raid_group[BTRFS_NR_RAID_TYPES];
 
 struct map_lookup {
 	u64 type;

commit ed23467b180421d37f9a6ce26c8fa8f03aef0a4a
Author: Anand Jain <anand.jain@oracle.com>
Date:   Wed Apr 25 19:01:42 2018 +0800

    btrfs: move btrfs_raid_type_names values to btrfs_raid_attr table
    
    Add a new member struct btrfs_raid_attr::raid_name so that
    btrfs_raid_array can maintain the name of the raid type, and so we can
    drop btrfs_raid_type_names.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 5737e6e68f8b..9056a900aace 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -329,6 +329,7 @@ struct btrfs_raid_attr {
 	int tolerated_failures; /* max tolerated fail devs */
 	int devs_increment;	/* ndevs has to be a multiple of this */
 	int ncopies;		/* how many copies to data has */
+	const char raid_name[8]; /* name of the raid */
 };
 
 extern const struct btrfs_raid_attr btrfs_raid_array[BTRFS_NR_RAID_TYPES];
@@ -550,6 +551,8 @@ static inline enum btrfs_raid_types btrfs_bg_flags_to_raid_index(u64 flags)
 	return BTRFS_RAID_SINGLE; /* BTRFS_BLOCK_GROUP_SINGLE */
 }
 
+const char *get_raid_name(enum btrfs_raid_types type);
+
 void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info);
 void btrfs_update_commit_device_bytes_used(struct btrfs_transaction *trans);
 

commit d48f39d5a529244f59454386208c6da92bb1c493
Author: David Sterba <dsterba@suse.com>
Date:   Tue Mar 20 16:09:48 2018 +0100

    btrfs: move btrfs_init_dev_replace_tgtdev to dev-replace.c and make static
    
    The function logically belongs there and there's only a single caller,
    no need to export it. No code changes.
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 316cce159969..5737e6e68f8b 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -432,10 +432,6 @@ struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,
 				       u8 *uuid, u8 *fsid);
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_fs_info *fs_info, const char *path);
-int btrfs_init_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,
-				  const char *device_path,
-				  struct btrfs_device *srcdev,
-				  struct btrfs_device **device_out);
 int btrfs_balance(struct btrfs_balance_control *bctl,
 		  struct btrfs_ioctl_balance_args *bargs);
 int btrfs_resume_balance_async(struct btrfs_fs_info *fs_info);

commit a425f9d4755a14fd8b9d2648a23ebe1dea11bd57
Author: David Sterba <dsterba@suse.com>
Date:   Tue Mar 20 15:47:33 2018 +0100

    btrfs: export and rename free_device
    
    The function will be used outside of volumes.c, the allocation
    btrfs_alloc_device is also exported.
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 62a92e472f65..316cce159969 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -421,6 +421,7 @@ int btrfs_find_device_by_devspec(struct btrfs_fs_info *fs_info, u64 devid,
 struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,
 					const u64 *devid,
 					const u8 *uuid);
+void btrfs_free_device(struct btrfs_device *device);
 int btrfs_rm_device(struct btrfs_fs_info *fs_info,
 		    const char *device_path, u64 devid);
 void __exit btrfs_cleanup_fs_uuids(void);

commit c4babc5e38e94e70058218ebfbf7846fd2f8a24d
Author: Anand Jain <anand.jain@oracle.com>
Date:   Thu Apr 12 10:29:25 2018 +0800

    btrfs: rename struct btrfs_fs_devices::list
    
    btrfs_fs_devices::list is the list of BTRFS fsid in the kernel, a generic
    name 'list' makes it's search very difficult, rename it to fs_list.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 79096884654f..62a92e472f65 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -208,6 +208,7 @@ BTRFS_DEVICE_GETSET_FUNCS(bytes_used);
 
 struct btrfs_fs_devices {
 	u8 fsid[BTRFS_FSID_SIZE]; /* FS specific uuid */
+	struct list_head fs_list;
 
 	u64 num_devices;
 	u64 open_devices;
@@ -229,7 +230,6 @@ struct btrfs_fs_devices {
 	struct list_head resized_devices;
 	/* devices not currently being allocated */
 	struct list_head alloc_list;
-	struct list_head list;
 
 	struct btrfs_fs_devices *seed;
 	int seeding;

commit 9888c3402c8567a977de37f61e9dd87792723064
Author: David Sterba <dsterba@suse.com>
Date:   Tue Apr 3 19:16:55 2018 +0200

    btrfs: replace GPL boilerplate by SPDX -- headers
    
    Remove GPL boilerplate text (long, short, one-line) and keep the rest,
    ie. personal, company or original source copyright statements. Add the
    SPDX header.
    
    Unify the include protection macros to match the file names.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index d1fcaea9fef5..79096884654f 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -1,23 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Copyright (C) 2007 Oracle.  All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License v2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public
- * License along with this program; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 021110-1307, USA.
  */
 
-#ifndef __BTRFS_VOLUMES_
-#define __BTRFS_VOLUMES_
+#ifndef BTRFS_VOLUMES_H
+#define BTRFS_VOLUMES_H
 
 #include <linux/bio.h>
 #include <linux/sort.h>

commit 9b99b11564446600f3a3ce394a841d525b7993e7
Author: Anand Jain <anand.jain@oracle.com>
Date:   Tue Feb 27 12:41:59 2018 +0800

    btrfs: rename btrfs_close_extra_device to btrfs_free_extra_devids
    
    This function btrfs_close_extra_devices() is about freeing
    extra devids which once it may have belonged to this filesystem.
    So rename it and add the comment. The _devid suffix is
    appropriate as this function won't handle devices which are
    outside of the filesytem being mounted.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index d28f5745fee2..d1fcaea9fef5 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -422,7 +422,7 @@ int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
 int btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,
 			  struct btrfs_fs_devices **fs_devices_ret);
 int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
-void btrfs_close_extra_devices(struct btrfs_fs_devices *fs_devices, int step);
+void btrfs_free_extra_devids(struct btrfs_fs_devices *fs_devices, int step);
 void btrfs_assign_next_active_device(struct btrfs_fs_info *fs_info,
 		struct btrfs_device *device, struct btrfs_device *this_dev);
 int btrfs_find_device_missing_or_by_path(struct btrfs_fs_info *fs_info,

commit ffc5a3794f9779c1a09e18e6d75bb6cc22b37523
Author: David Sterba <dsterba@suse.com>
Date:   Mon Feb 19 17:24:15 2018 +0100

    btrfs: add (the only possible) __exit annotation
    
    Recently, the __init annotations have been added. There's unfortunatelly
    only one case where we can add __exit, because most of the cleanup
    helpers are also called from the __init phase.
    
    As the __exit annotated functions get discarded completely for a
    built-in code, we'd miss them from the init phase.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index d110fb03ec0d..d28f5745fee2 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -436,7 +436,7 @@ struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,
 					const u8 *uuid);
 int btrfs_rm_device(struct btrfs_fs_info *fs_info,
 		    const char *device_path, u64 devid);
-void btrfs_cleanup_fs_uuids(void);
+void __exit btrfs_cleanup_fs_uuids(void);
 int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len);
 int btrfs_grow_device(struct btrfs_trans_handle *trans,
 		      struct btrfs_device *device, u64 new_size);

commit 3e72ee8874f42ddbe72a090044f7c03740158183
Author: Qu Wenruo <wqu@suse.com>
Date:   Tue Jan 30 18:20:45 2018 +0800

    btrfs: Refactor __get_raid_index() to btrfs_bg_flags_to_raid_index()
    
    Function __get_raid_index() is used to convert block group flags into
    raid index, which can be used to get various info directly from
    btrfs_raid_array[].
    
    Refactor this function a little:
    
    1) Rename to btrfs_bg_flags_to_raid_index()
       Double underline prefix is normally for internal functions, while the
       function is used by both extent-tree and volumes.
    
       Although the name is a little longer, but it should explain its usage
       quite well.
    
    2) Move it to volumes.h and make it static inline
       Just several if-else branches, really no need to define it as a normal
       function.
    
       This also makes later code re-use between kernel and btrfs-progs
       easier.
    
    3) Remove function get_block_group_index()
       Really no need to do such a simple thing as an exported function.
    
    Signed-off-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 654df38faa7a..d110fb03ec0d 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -544,6 +544,28 @@ static inline void btrfs_dev_stat_reset(struct btrfs_device *dev,
 	btrfs_dev_stat_set(dev, index, 0);
 }
 
+/*
+ * Convert block group flags (BTRFS_BLOCK_GROUP_*) to btrfs_raid_types, which
+ * can be used as index to access btrfs_raid_array[].
+ */
+static inline enum btrfs_raid_types btrfs_bg_flags_to_raid_index(u64 flags)
+{
+	if (flags & BTRFS_BLOCK_GROUP_RAID10)
+		return BTRFS_RAID_RAID10;
+	else if (flags & BTRFS_BLOCK_GROUP_RAID1)
+		return BTRFS_RAID_RAID1;
+	else if (flags & BTRFS_BLOCK_GROUP_DUP)
+		return BTRFS_RAID_DUP;
+	else if (flags & BTRFS_BLOCK_GROUP_RAID0)
+		return BTRFS_RAID_RAID0;
+	else if (flags & BTRFS_BLOCK_GROUP_RAID5)
+		return BTRFS_RAID_RAID5;
+	else if (flags & BTRFS_BLOCK_GROUP_RAID6)
+		return BTRFS_RAID_RAID6;
+
+	return BTRFS_RAID_SINGLE; /* BTRFS_BLOCK_GROUP_SINGLE */
+}
+
 void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info);
 void btrfs_update_commit_device_bytes_used(struct btrfs_transaction *trans);
 

commit e9b919b1f73f1a363988ae1b9fba66f83a221f2e
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Wed Feb 7 17:55:49 2018 +0200

    btrfs: Remove fs_info argument from btrfs_update_commit_device_bytes_used
    
    We already pass the btrfs_transaction which references fs_info so no
    need to pass the later as an argument. Also use the opportunity to
    shorten transaction->trans. No functional changes.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 2a171f9b2c04..654df38faa7a 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -545,8 +545,7 @@ static inline void btrfs_dev_stat_reset(struct btrfs_device *dev,
 }
 
 void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info);
-void btrfs_update_commit_device_bytes_used(struct btrfs_fs_info *fs_info,
-					struct btrfs_transaction *transaction);
+void btrfs_update_commit_device_bytes_used(struct btrfs_transaction *trans);
 
 struct list_head *btrfs_get_fs_uuids(void);
 void btrfs_set_fs_info_ptr(struct btrfs_fs_info *fs_info);

commit 15fc1283f631552ffedebd14e4fd5a36438e7d2a
Author: Anand Jain <anand.jain@oracle.com>
Date:   Mon Feb 12 23:36:25 2018 +0800

    btrfs: open code btrfs_init_dev_replace_tgtdev_for_resume()
    
    btrfs_init_dev_replace_tgtdev_for_resume() initializes replace
    target device in a few simple steps, so do it at the parent function.
    Moreover, there isn't any other caller so just open code it.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 28c28eeadff3..2a171f9b2c04 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -476,8 +476,6 @@ void btrfs_rm_dev_replace_free_srcdev(struct btrfs_fs_info *fs_info,
 				      struct btrfs_device *srcdev);
 void btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,
 				      struct btrfs_device *tgtdev);
-void btrfs_init_dev_replace_tgtdev_for_resume(struct btrfs_fs_info *fs_info,
-					      struct btrfs_device *tgtdev);
 void btrfs_scratch_superblocks(struct block_device *bdev, const char *device_path);
 int btrfs_is_parity_mirror(struct btrfs_fs_info *fs_info,
 			   u64 logical, u64 len);

commit 3cbf26da5ec85f1d3177eee534e377c707ed89e1
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Wed Jan 17 12:21:49 2018 -0800

    btrfs: Remove unused readahead spinlock
    
    The reada_lock in struct btrfs_device was only initialised, and not
    actually used.  That's good because there's another lock also called
    reada_lock in the btrfs_fs_info that was quite heavily used.  Remove
    this one.
    
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 15216fed918b..28c28eeadff3 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -137,7 +137,6 @@ struct btrfs_device {
 	struct rcu_head rcu;
 
 	/* readahead state */
-	spinlock_t reada_lock;
 	atomic_t reada_in_flight;
 	u64 reada_next;
 	struct reada_zone *reada_curr_zone;

commit cadbc0a0670e32e42282b388ac8b7539100ac0f2
Author: Anand Jain <anand.jain@oracle.com>
Date:   Wed Jan 3 16:08:30 2018 +0800

    btrfs: rename btrfs_device::scrub_device to scrub_ctx
    
    btrfs_device::scrub_device is not a device which is being scrubbed,
    but it holds the scrub context, so rename to reflect the same. No
    functional changes here.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index a339bcf72feb..15216fed918b 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -131,7 +131,7 @@ struct btrfs_device {
 	struct completion flush_wait;
 
 	/* per-device scrub information */
-	struct scrub_ctx *scrub_device;
+	struct scrub_ctx *scrub_ctx;
 
 	struct btrfs_work work;
 	struct rcu_head rcu;

commit 6528b99d3d20795ff947d9b3fd736affe901acef
Author: Anand Jain <Anand.Jain@oracle.com>
Date:   Mon Dec 18 17:08:59 2017 +0800

    btrfs: factor btrfs_check_rw_degradable() to check given device
    
    Update btrfs_check_rw_degradable() to check against the given device if
    its lost.
    
    We can use this function to know if the volume is going to be in
    degraded mode OR failed state, when the given device fails.  Which is
    needed when we are handling the device failed state.
    
    A preparatory patch does not affect the flow as such.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    [ enhance comment ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 3e3ae44b6ccc..a339bcf72feb 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -554,7 +554,7 @@ void btrfs_update_commit_device_bytes_used(struct btrfs_fs_info *fs_info,
 struct list_head *btrfs_get_fs_uuids(void);
 void btrfs_set_fs_info_ptr(struct btrfs_fs_info *fs_info);
 void btrfs_reset_fs_info_ptr(struct btrfs_fs_info *fs_info);
-
-bool btrfs_check_rw_degradable(struct btrfs_fs_info *fs_info);
+bool btrfs_check_rw_degradable(struct btrfs_fs_info *fs_info,
+					struct btrfs_device *failing_dev);
 
 #endif

commit 1c3063b6dbfa03e469a53371fae149a022a41bfd
Author: Anand Jain <anand.jain@oracle.com>
Date:   Mon Dec 4 12:54:56 2017 +0800

    btrfs: cleanup device states define BTRFS_DEV_STATE_FLUSH_SENT
    
    Currently device state is being managed by each individual int
    variable such as struct btrfs_device::is_tgtdev_for_dev_replace.
    Instead of that declare btrfs_device::dev_state
    BTRFS_DEV_STATE_FLUSH_SENT and use the bit operations.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 2ac123154c8d..3e3ae44b6ccc 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -51,6 +51,7 @@ struct btrfs_pending_bios {
 #define BTRFS_DEV_STATE_IN_FS_METADATA	(1)
 #define BTRFS_DEV_STATE_MISSING		(2)
 #define BTRFS_DEV_STATE_REPLACE_TGT	(3)
+#define BTRFS_DEV_STATE_FLUSH_SENT	(4)
 
 struct btrfs_device {
 	struct list_head dev_list;

commit 401e29c124eac2b9373eb72f36f202561da339d2
Author: Anand Jain <anand.jain@oracle.com>
Date:   Mon Dec 4 12:54:55 2017 +0800

    btrfs: cleanup device states define BTRFS_DEV_STATE_REPLACE_TGT
    
    Currently device state is being managed by each individual int
    variable such as struct btrfs_device::is_tgtdev_for_dev_replace.
    Instead of that declare btrfs_device::dev_state
    BTRFS_DEV_STATE_MISSING and use the bit operations.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    [ whitespace adjustments ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 68affb06502a..2ac123154c8d 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -50,6 +50,7 @@ struct btrfs_pending_bios {
 #define BTRFS_DEV_STATE_WRITEABLE	(0)
 #define BTRFS_DEV_STATE_IN_FS_METADATA	(1)
 #define BTRFS_DEV_STATE_MISSING		(2)
+#define BTRFS_DEV_STATE_REPLACE_TGT	(3)
 
 struct btrfs_device {
 	struct list_head dev_list;
@@ -74,7 +75,6 @@ struct btrfs_device {
 	fmode_t mode;
 
 	unsigned long dev_state;
-	int is_tgtdev_for_dev_replace;
 	blk_status_t last_flush_error;
 	int flush_bio_sent;
 

commit e6e674bd4d54fe8d47a06914f3b90752785b4882
Author: Anand Jain <anand.jain@oracle.com>
Date:   Mon Dec 4 12:54:54 2017 +0800

    btrfs: cleanup device states define BTRFS_DEV_STATE_MISSING
    
    Currently device state is being managed by each individual int
    variable such as struct btrfs_device::missing. Instead of that
    declare btrfs_device::dev_state BTRFS_DEV_STATE_MISSING and use
    the bit operations.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by : Nikolay Borisov <nborisov@suse.com>
    [ whitespace adjustments ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index d290641658cc..68affb06502a 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -49,6 +49,7 @@ struct btrfs_pending_bios {
 
 #define BTRFS_DEV_STATE_WRITEABLE	(0)
 #define BTRFS_DEV_STATE_IN_FS_METADATA	(1)
+#define BTRFS_DEV_STATE_MISSING		(2)
 
 struct btrfs_device {
 	struct list_head dev_list;
@@ -73,7 +74,6 @@ struct btrfs_device {
 	fmode_t mode;
 
 	unsigned long dev_state;
-	int missing;
 	int is_tgtdev_for_dev_replace;
 	blk_status_t last_flush_error;
 	int flush_bio_sent;

commit e12c96214d28f9211b4035cf20e76d677ff5611f
Author: Anand Jain <anand.jain@oracle.com>
Date:   Mon Dec 4 12:54:53 2017 +0800

    btrfs: cleanup device states define BTRFS_DEV_STATE_IN_FS_METADATA
    
    Currently device state is being managed by each individual int
    variable such as struct btrfs_device::in_fs_metadata. Instead of
    that declare device state BTRFS_DEV_STATE_IN_FS_METADATA and use
    the bit operations.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    [ whitespace adjustments ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 893e283c7f15..d290641658cc 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -48,6 +48,7 @@ struct btrfs_pending_bios {
 #endif
 
 #define BTRFS_DEV_STATE_WRITEABLE	(0)
+#define BTRFS_DEV_STATE_IN_FS_METADATA	(1)
 
 struct btrfs_device {
 	struct list_head dev_list;
@@ -72,7 +73,6 @@ struct btrfs_device {
 	fmode_t mode;
 
 	unsigned long dev_state;
-	int in_fs_metadata;
 	int missing;
 	int is_tgtdev_for_dev_replace;
 	blk_status_t last_flush_error;

commit ebbede42d47dc77d1c20e7468418826e5efa6b29
Author: Anand Jain <anand.jain@oracle.com>
Date:   Mon Dec 4 12:54:52 2017 +0800

    btrfs: cleanup device states define BTRFS_DEV_STATE_WRITEABLE
    
    Currently device state is being managed by each individual int
    variable such as struct btrfs_device::writeable. Instead of that
    declare device state BTRFS_DEV_STATE_WRITEABLE and use the
    bit operations.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    [ whitespace adjustments ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 60588c259665..893e283c7f15 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -47,6 +47,8 @@ struct btrfs_pending_bios {
 #define btrfs_device_data_ordered_init(device) do { } while (0)
 #endif
 
+#define BTRFS_DEV_STATE_WRITEABLE	(0)
+
 struct btrfs_device {
 	struct list_head dev_list;
 	struct list_head dev_alloc_list;
@@ -69,7 +71,7 @@ struct btrfs_device {
 	/* the mode sent to blkdev_get */
 	fmode_t mode;
 
-	int writeable;
+	unsigned long dev_state;
 	int in_fs_metadata;
 	int missing;
 	int is_tgtdev_for_dev_replace;

commit 38b5f68e98117daa221c7df813608f48c374aef4
Author: Anand Jain <anand.jain@oracle.com>
Date:   Wed Nov 29 18:53:43 2017 +0800

    btrfs: drop btrfs_device::can_discard to query directly
    
    We can query the bdev directly when needed at btrfs_discard_extent()
    so drop btrfs_device::can_discard.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Suggested-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 294c4eb6a272..60588c259665 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -72,7 +72,6 @@ struct btrfs_device {
 	int writeable;
 	int in_fs_metadata;
 	int missing;
-	int can_discard;
 	int is_tgtdev_for_dev_replace;
 	blk_status_t last_flush_error;
 	int flush_bio_sent;

commit ac244ef1da76383842a9a4c3404e35d0669f2e53
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Fri Oct 20 18:10:59 2017 +0300

    btrfs: Remove unused function
    
    It's sole callsite was removed in a previous patch so just nuke it for good.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 177814a7c758..294c4eb6a272 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -488,11 +488,6 @@ int btrfs_finish_chunk_alloc(struct btrfs_trans_handle *trans,
 int btrfs_remove_chunk(struct btrfs_trans_handle *trans,
 		       struct btrfs_fs_info *fs_info, u64 chunk_offset);
 
-static inline int btrfs_dev_stats_dirty(struct btrfs_device *dev)
-{
-	return atomic_read(&dev->dev_stats_ccnt);
-}
-
 static inline void btrfs_dev_stat_inc(struct btrfs_device *dev,
 				      int index)
 {

commit 4660c49f9b4ad50eab410de09eeacc2e3aebf1f5
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Fri Oct 20 18:10:58 2017 +0300

    btrfs: Remove redundant memory barrier in dev stats
    
    As per atomic_t.txt documentation :
     - RMW operations that have a return value are fully ordered;
    
    atomic_xchg is one such operation so it already includes everything it
    needs w.r.t memory ordering and add a comment to be more explicit about
    that.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 38fd368ddfe7..177814a7c758 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -519,7 +519,13 @@ static inline int btrfs_dev_stat_read_and_reset(struct btrfs_device *dev,
 	int ret;
 
 	ret = atomic_xchg(dev->dev_stat_values + index, 0);
-	smp_mb__before_atomic();
+	/*
+	 * atomic_xchg implies a full memory barriers as per atomic_t.txt:
+	 * - RMW operations that have a return value are fully ordered;
+	 *
+	 * This implicit memory barriers is paired with the smp_rmb in
+	 * btrfs_run_dev_stats
+	 */
 	atomic_inc(&dev->dev_stats_ccnt);
 	return ret;
 }

commit 9deae9689231964972a94bb56a79b669f9d47ac1
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Tue Oct 24 13:47:37 2017 +0300

    btrfs: Fix memory barriers usage with device stats counters
    
    Commit addc3fa74e5b ("Btrfs: Fix the problem that the dirty flag of dev
    stats is cleared") reworked the way device stats changes are tracked. A
    new atomic dev_stats_ccnt counter was introduced which is incremented
    every time any of the device stats counters are changed. This serves as
    a flag whether there are any pending stats changes. However, this patch
    only partially implemented the correct memory barriers necessary:
    
    - It only ordered the stores to the counters but not the reads e.g.
      btrfs_run_dev_stats
    - It completely omitted any comments documenting the intended design and
      how the memory barriers pair with each-other
    
    This patch provides the necessary comments as well as adds a missing
    smp_rmb in btrfs_run_dev_stats. Furthermore since dev_stats_cnt is only
    a snapshot at best there was no point in reading the counter twice -
    once in btrfs_dev_stats_dirty and then again when assigning stats_cnt.
    Just collapse both reads into 1.
    
    Fixes: addc3fa74e5b ("Btrfs: Fix the problem that the dirty flag of dev stats is cleared")
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index bf0d53a96b4a..38fd368ddfe7 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -497,6 +497,12 @@ static inline void btrfs_dev_stat_inc(struct btrfs_device *dev,
 				      int index)
 {
 	atomic_inc(dev->dev_stat_values + index);
+	/*
+	 * This memory barrier orders stores updating statistics before stores
+	 * updating dev_stats_ccnt.
+	 *
+	 * It pairs with smp_rmb() in btrfs_run_dev_stats().
+	 */
 	smp_mb__before_atomic();
 	atomic_inc(&dev->dev_stats_ccnt);
 }
@@ -522,6 +528,12 @@ static inline void btrfs_dev_stat_set(struct btrfs_device *dev,
 				      int index, unsigned long val)
 {
 	atomic_set(dev->dev_stat_values + index, val);
+	/*
+	 * This memory barrier orders stores updating statistics before stores
+	 * updating dev_stats_ccnt.
+	 *
+	 * It pairs with smp_rmb() in btrfs_run_dev_stats().
+	 */
 	smp_mb__before_atomic();
 	atomic_inc(&dev->dev_stats_ccnt);
 }

commit 9f5316c17b0833c606b94d91beb6518c2e8a8012
Author: Liu Bo <bo.li.liu@oracle.com>
Date:   Mon Oct 23 23:02:54 2017 -0600

    Btrfs: free btrfs_device in place
    
    It's pointless to defer it to a kthread helper as we're not under a
    special context.
    
    For reference, commit 1f78160ce1b1 ("Btrfs: using rcu lock in the reader
    side of devices list") introduced RCU freeing for device structures.
    
    Originally the blkdev_put was called from free_device and rcu_barrier had
    to be called. This is no longer required, bdev and our device structures
    are now freed separately.
    
    Signed-off-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ enhance changelog ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index ff15208344a7..bf0d53a96b4a 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -133,7 +133,6 @@ struct btrfs_device {
 
 	struct btrfs_work work;
 	struct rcu_head rcu;
-	struct work_struct rcu_work;
 
 	/* readahead state */
 	spinlock_t reada_lock;

commit 5a2b8e601c572527adfc4986941311c21effae6c
Author: Anand Jain <anand.jain@oracle.com>
Date:   Mon Oct 9 11:07:45 2017 +0800

    btrfs: declare btrfs_report_missing_device() static
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 6108fdfec67f..ff15208344a7 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -542,7 +542,5 @@ void btrfs_set_fs_info_ptr(struct btrfs_fs_info *fs_info);
 void btrfs_reset_fs_info_ptr(struct btrfs_fs_info *fs_info);
 
 bool btrfs_check_rw_degradable(struct btrfs_fs_info *fs_info);
-void btrfs_report_missing_device(struct btrfs_fs_info *fs_info, u64 devid,
-				 u8 *uuid);
 
 #endif

commit 66ba772ee3119849fcdd8ac9766c6c25ede4a982
Merge: 126e76ffbf78 db95c876c568
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 9 13:27:51 2017 -0700

    Merge branch 'for-4.14' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux
    
    Pull btrfs updates from David Sterba:
     "The changes range through all types: cleanups, core chagnes, sanity
      checks, fixes, other user visible changes, detailed list below:
    
       - deprecated: user transaction ioctl
    
       - mount option ssd does not change allocation alignments
    
       - degraded read-write mount is allowed if all the raid profile
         constraints are met, now based on more accurate check
    
       - defrag: do not reset compression afterwards; the NOCOMPRESS flag
         can be now overriden by defrag
    
       - prep work for better extent reference tracking (related to the
         qgroup slowness with balance)
    
       - prep work for compression heuristics
    
       - memory allocation reductions (may help latencies on a loaded
         system)
    
       - better accounting for io waiting states
    
       - error handling improvements (removed BUGs)
    
       - added more sanity checks for shared refs
    
       - fix readdir vs pagefault deadlock under some circumstances
    
       - fix for 'no-hole' mode, certain combination of compressed and
         inline extents
    
       - send: fix emission of invalid clone operations
    
       - fixup file mode if setting acls fail
    
       - more fixes from fuzzing
    
       - oher cleanups"
    
    * 'for-4.14' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux: (104 commits)
      btrfs: submit superblock io with REQ_META and REQ_PRIO
      btrfs: remove unnecessary memory barrier in btrfs_direct_IO
      btrfs: remove superfluous chunk_tree argument from btrfs_alloc_dev_extent
      btrfs: Remove chunk_objectid parameter of btrfs_alloc_dev_extent
      btrfs: pass fs_info to btrfs_del_root instead of tree_root
      Btrfs: add one more sanity check for shared ref type
      Btrfs: remove BUG_ON in __add_tree_block
      Btrfs: remove BUG() in add_data_reference
      Btrfs: remove BUG() in print_extent_item
      Btrfs: remove BUG() in btrfs_extent_inline_ref_size
      Btrfs: convert to use btrfs_get_extent_inline_ref_type
      Btrfs: add a helper to retrive extent inline ref type
      btrfs: scrub: simplify scrub worker initialization
      btrfs: scrub: clean up division in scrub_find_csum
      btrfs: scrub: clean up division in __scrub_mark_bitmap
      btrfs: scrub: use bool for flush_all_writes
      btrfs: preserve i_mode if __btrfs_set_acl() fails
      btrfs: Remove extraneous chunk_objectid variable
      btrfs: Remove chunk_objectid argument from btrfs_make_block_group
      btrfs: Remove extra parentheses from condition in copy_items()
      ...

commit 58efbc9f5463308c43d812fd0748a4dee44c8a16
Author: Omar Sandoval <osandov@fb.com>
Date:   Tue Aug 22 23:45:59 2017 -0700

    Btrfs: fix blk_status_t/errno confusion
    
    This fixes several instances of blk_status_t and bare errno ints being
    mixed up, some of which are real bugs.
    
    In the normal case, 0 matches BLK_STS_OK, so we don't observe any
    effects of the missing conversion, but in case of errors or passes
    through the repair/retry paths, the errors get mixed up.
    
    The changes were identified using 'sparse', we don't have reports of the
    buggy behaviour.
    
    Fixes: 4e4cbee93d56 ("block: switch bios to blk_status_t")
    Signed-off-by: Omar Sandoval <osandov@fb.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 6f45fd60d15a..93277fc60930 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -74,7 +74,7 @@ struct btrfs_device {
 	int missing;
 	int can_discard;
 	int is_tgtdev_for_dev_replace;
-	int last_flush_error;
+	blk_status_t last_flush_error;
 	int flush_bio_sent;
 
 #ifdef __BTRFS_NEED_DEVICE_DATA_ORDERED
@@ -416,8 +416,8 @@ int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
 		      struct btrfs_fs_info *fs_info, u64 type);
 void btrfs_mapping_init(struct btrfs_mapping_tree *tree);
 void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree);
-int btrfs_map_bio(struct btrfs_fs_info *fs_info, struct bio *bio,
-		  int mirror_num, int async_submit);
+blk_status_t btrfs_map_bio(struct btrfs_fs_info *fs_info, struct bio *bio,
+			   int mirror_num, int async_submit);
 int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
 		       fmode_t flags, void *holder);
 int btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,

commit db7c942ce84cabbf740a1e5654d58b9201a4a5f0
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Wed Aug 16 18:41:44 2017 +0300

    btrfs: Remove unused sectorsize variable from struct map_lookup
    
    This variable was added in 1abe9b8a138c ("Btrfs: add initial tracepointi
    support for btrfs"), yet it never really got used, only assigned to. So
    let's remove it.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 181b365cab0c..eebe2f871dc7 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -353,7 +353,6 @@ struct map_lookup {
 	int io_align;
 	int io_width;
 	u64 stripe_len;
-	int sector_size;
 	int num_stripes;
 	int sub_stripes;
 	struct btrfs_bio_stripe stripes[];

commit e4ff5fb5dc3742b126a2f4d1f18706509812d084
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Wed Jul 19 10:48:42 2017 +0300

    btrfs: Remove unused parameters from volume.c functions
    
    This also adjusts the respective callers in other files. Those were
    found with -Wunused-parameter.
    
    btrfs_full_stripe_len's mapping_tree - introduced by 53b381b3abeb
    ("Btrfs: RAID5 and RAID6") but it was never really used even in that
    commit
    
    btrfs_is_parity_mirror's mirror_num - same as above
    
    chunk_drange_filter's chunk_offset - introduced by 94e60d5a5c4b ("Btrfs:
    devid subset filter") and never used.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index e906377ed329..181b365cab0c 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -481,9 +481,8 @@ void btrfs_init_dev_replace_tgtdev_for_resume(struct btrfs_fs_info *fs_info,
 					      struct btrfs_device *tgtdev);
 void btrfs_scratch_superblocks(struct block_device *bdev, const char *device_path);
 int btrfs_is_parity_mirror(struct btrfs_fs_info *fs_info,
-			   u64 logical, u64 len, int mirror_num);
+			   u64 logical, u64 len);
 unsigned long btrfs_full_stripe_len(struct btrfs_fs_info *fs_info,
-				    struct btrfs_mapping_tree *map_tree,
 				    u64 logical);
 int btrfs_finish_chunk_alloc(struct btrfs_trans_handle *trans,
 				struct btrfs_fs_info *fs_info,

commit c55024514852930a6a31b6794aad44a56b117d9d
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Thu Mar 9 09:34:42 2017 +0800

    btrfs: Enhance message when a device is missing during mount
    
    For a missing device, btrfs will just refuse to mount with almost
    meaningless kernel message like:
    
     BTRFS info (device vdb6): disk space caching is enabled
     BTRFS info (device vdb6): has skinny extents
     BTRFS error (device vdb6): failed to read the system array: -5
     BTRFS error (device vdb6): open_ctree failed
    
    This patch will print a new message about the missing device:
    
     BTRFS info (device vdb6): disk space caching is enabled
     BTRFS info (device vdb6): has skinny extents
     BTRFS warning (device vdb6): devid 2 uuid 80470722-cad2-4b90-b7c3-fee294552f1b is missing
     BTRFS error (device vdb6): failed to read the system array: -5
     BTRFS error (device vdb6): open_ctree failed
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 5824cdc0b3fc..e906377ed329 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -544,5 +544,7 @@ void btrfs_set_fs_info_ptr(struct btrfs_fs_info *fs_info);
 void btrfs_reset_fs_info_ptr(struct btrfs_fs_info *fs_info);
 
 bool btrfs_check_rw_degradable(struct btrfs_fs_info *fs_info);
+void btrfs_report_missing_device(struct btrfs_fs_info *fs_info, u64 devid,
+				 u8 *uuid);
 
 #endif

commit 21634a19f6467674ef67fba9714c835a1c0a1e67
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Thu Mar 9 09:34:36 2017 +0800

    btrfs: Introduce a function to check if all chunks a OK for degraded rw mount
    
    Introduce a new function, btrfs_check_rw_degradable(), to check if all
    chunks in btrfs is OK for degraded rw mount.
    
    It provides the new basis for accurate btrfs mount/remount and even
    runtime degraded mount check other than old one-size-fit-all method.
    
    Btrfs currently uses num_tolerated_disk_barrier_failures to do global
    check for tolerated missing device.
    
    Although the one-size-fit-all solution is quite safe, it's too strict
    if data and metadata has different duplication level.
    
    For example, if one use Single data and RAID1 metadata for 2 disks, it
    means any missing device will make the fs unable to be degraded
    mounted.
    
    But in fact, some times all single chunks may be in the existing
    device and in that case, we should allow it to be rw degraded mounted.
    
    Such case can be easily reproduced using the following script:
     # mkfs.btrfs -f -m raid1 -d sing /dev/sdb /dev/sdc
     # wipefs -f /dev/sdc
     # mount /dev/sdb -o degraded,rw
    
    If using btrfs-debug-tree to check /dev/sdb, one should find that the
    data chunk is only in sdb, so in fact it should allow degraded mount.
    
    This patchset will introduce a new per-chunk degradable check for
    btrfs, allow above case to succeed, and it's quite small anyway.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ copied text from cover letter with more details about the problem being
      solved ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 6f45fd60d15a..5824cdc0b3fc 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -543,4 +543,6 @@ struct list_head *btrfs_get_fs_uuids(void);
 void btrfs_set_fs_info_ptr(struct btrfs_fs_info *fs_info);
 void btrfs_reset_fs_info_ptr(struct btrfs_fs_info *fs_info);
 
+bool btrfs_check_rw_degradable(struct btrfs_fs_info *fs_info);
+
 #endif

commit e0ae999414238aa9c0a116844813982effb68a02
Author: David Sterba <dsterba@suse.com>
Date:   Tue Jun 6 17:06:06 2017 +0200

    btrfs: preallocate device flush bio
    
    For devices that support flushing, we allocate a bio, submit, wait for
    it and then free it. The bio allocation does not fail so ENOMEM is not a
    problem but we still may unnecessarily stress the allocation subsystem.
    
    Instead, we can allocate the bio at the same time we allocate the device
    and reuse it each time we need to flush the barriers. The bio is reset
    before each use. Reference counting is simplified to just device
    allocation (get) and freeing (put).
    
    The bio used to be submitted through the integrity checker which will
    find out that bio has no data attached and call submit_bio.
    
    Status of the bio in flight needs to be tracked separately in case the
    device caches get switched off between write and wait.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 35327efecdbb..6f45fd60d15a 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -75,6 +75,7 @@ struct btrfs_device {
 	int can_discard;
 	int is_tgtdev_for_dev_replace;
 	int last_flush_error;
+	int flush_bio_sent;
 
 #ifdef __BTRFS_NEED_DEVICE_DATA_ORDERED
 	seqcount_t data_seqcount;

commit fa1bcbe0a54c67a293c557a21641565516c96a8f
Author: David Sterba <dsterba@suse.com>
Date:   Mon Jun 12 17:29:36 2017 +0200

    btrfs: document mandatory order of bio in btrfs_io_bio
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 58b97b6f5f02..35327efecdbb 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -281,6 +281,10 @@ struct btrfs_io_bio {
 	u8 *csum_allocated;
 	btrfs_io_bio_end_io_t *end_io;
 	struct bvec_iter iter;
+	/*
+	 * This member must come last, bio_alloc_bioset will allocate enough
+	 * bytes for entire btrfs_io_bio but relies on bio being last.
+	 */
 	struct bio bio;
 };
 

commit 17347cec15f919901c90cdbf98af47ed2ed28b9f
Author: Liu Bo <bo.li.liu@oracle.com>
Date:   Mon May 15 15:33:27 2017 -0700

    Btrfs: change how we iterate bios in endio
    
    Since dio submit has used bio_clone_fast, the submitted bio may not have a
    reliable bi_vcnt, for the bio vector iterations in checksum related
    functions, bio->bi_iter is not modified yet and it's safe to use
    bio_for_each_segment, while for those bio vector iterations in dio read's
    endio, we now save a copy of bvec_iter in struct btrfs_io_bio when cloning
    bios and use the helper __bio_for_each_segment with the saved bvec_iter to
    access each bvec.
    
    Also for dio reads which don't get split, we also need to save a copy of
    bio iterator in btrfs_bio_clone to let __bio_for_each_segments to access
    each bvec in dio read's endio.  Note that it doesn't affect other calls of
    btrfs_bio_clone() because they don't need to use this iterator.
    
    Signed-off-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 094521729df1..58b97b6f5f02 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -280,6 +280,7 @@ struct btrfs_io_bio {
 	u8 csum_inline[BTRFS_BIO_INLINE_CSUM_SIZE];
 	u8 *csum_allocated;
 	btrfs_io_bio_end_io_t *end_io;
+	struct bvec_iter iter;
 	struct bio bio;
 };
 

commit 401b41e5a85a635fd9888ba8969c5006a5dbd399
Author: Anand Jain <anand.jain@oracle.com>
Date:   Sat May 6 07:17:54 2017 +0800

    btrfs: add framework to handle device flush error as a volume
    
    This adds comments to the flush error handling part of the code, and
    hopes to maintain the same logic with a framework which can be used to
    handle the errors at the volume level.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index c7d0fbc915ca..094521729df1 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -74,6 +74,7 @@ struct btrfs_device {
 	int missing;
 	int can_discard;
 	int is_tgtdev_for_dev_replace;
+	int last_flush_error;
 
 #ifdef __BTRFS_NEED_DEVICE_DATA_ORDERED
 	seqcount_t data_seqcount;

commit 13e88e1560d6014838e2dd9f8b9cf8ec9a8d86e6
Author: Anand Jain <anand.jain@oracle.com>
Date:   Thu Apr 6 11:22:52 2017 +0800

    btrfs: delete unused member nobarriers
    
    The last consumer of nobarriers is removed by the commit [1] and sync
    won't fail with EOPNOTSUPP anymore. Thus, now when write cache is write
    through it just return success without actually transpiring such a
    request to the block device/lun.
    
    [1]
    commit b25de9d6da49b1a8760a89672283128aa8c78345
    block: remove BIO_EOPNOTSUPP
    
    And, as the device/lun write cache state may change dynamically saving
    such as state won't help either. So deleting the member nobarriers.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index def39b5a8d9e..c7d0fbc915ca 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -123,7 +123,6 @@ struct btrfs_device {
 	struct list_head resized_list;
 
 	/* for sending down flush barriers */
-	int nobarriers;
 	struct bio *flush_bio;
 	struct completion flush_wait;
 

commit 825ad4c96432a3908625dd1a79d6528e969e1a09
Author: David Sterba <dsterba@suse.com>
Date:   Tue Mar 28 14:45:22 2017 +0200

    btrfs: drop redundant parameters from btrfs_map_sblock
    
    All callers pass 0 for mirror_num and 1 for need_raid_map.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 9ee6b706db31..def39b5a8d9e 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -400,8 +400,7 @@ int btrfs_map_block(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
 		    struct btrfs_bio **bbio_ret, int mirror_num);
 int btrfs_map_sblock(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
 		     u64 logical, u64 *length,
-		     struct btrfs_bio **bbio_ret, int mirror_num,
-		     int need_raid_map);
+		     struct btrfs_bio **bbio_ret);
 int btrfs_rmap_block(struct btrfs_fs_info *fs_info,
 		     u64 chunk_start, u64 physical, u64 devid,
 		     u64 **logical, int *naddrs, int *stripe_len);

commit 592d92eeab3770b2525d2fc5589b205c9f8c33e3
Author: Liu Bo <bo.li.liu@oracle.com>
Date:   Tue Mar 14 13:33:55 2017 -0700

    Btrfs: create a helper for getting chunk map
    
    We have similar code here and there, this merges them into a helper.
    
    Signed-off-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index ac0bf7d0df60..9ee6b706db31 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -475,7 +475,7 @@ void btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,
 void btrfs_init_dev_replace_tgtdev_for_resume(struct btrfs_fs_info *fs_info,
 					      struct btrfs_device *tgtdev);
 void btrfs_scratch_superblocks(struct block_device *bdev, const char *device_path);
-int btrfs_is_parity_mirror(struct btrfs_mapping_tree *map_tree,
+int btrfs_is_parity_mirror(struct btrfs_fs_info *fs_info,
 			   u64 logical, u64 len, int mirror_num);
 unsigned long btrfs_full_stripe_len(struct btrfs_fs_info *fs_info,
 				    struct btrfs_mapping_tree *map_tree,

commit 140475ae4ad10d140bb69572499b1ff87367e807
Author: Elena Reshetova <elena.reshetova@intel.com>
Date:   Fri Mar 3 10:55:10 2017 +0200

    btrfs: convert btrfs_bio.refs from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 59be81206dd7..ac0bf7d0df60 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -298,7 +298,7 @@ struct btrfs_bio;
 typedef void (btrfs_bio_end_io_t) (struct btrfs_bio *bio, int err);
 
 struct btrfs_bio {
-	atomic_t refs;
+	refcount_t refs;
 	atomic_t stripes_pending;
 	struct btrfs_fs_info *fs_info;
 	u64 map_type; /* get from map_lookup->type */

commit da353f6b30bc02da29b54f5f024039698fbd23f4
Author: David Sterba <dsterba@suse.com>
Date:   Tue Feb 14 17:55:53 2017 +0100

    btrfs: constify device path passed to relevant helpers
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 24ba6bc3ec34..59be81206dd7 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -422,16 +422,16 @@ void btrfs_close_extra_devices(struct btrfs_fs_devices *fs_devices, int step);
 void btrfs_assign_next_active_device(struct btrfs_fs_info *fs_info,
 		struct btrfs_device *device, struct btrfs_device *this_dev);
 int btrfs_find_device_missing_or_by_path(struct btrfs_fs_info *fs_info,
-					 char *device_path,
+					 const char *device_path,
 					 struct btrfs_device **device);
 int btrfs_find_device_by_devspec(struct btrfs_fs_info *fs_info, u64 devid,
-					 char *devpath,
+					 const char *devpath,
 					 struct btrfs_device **device);
 struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,
 					const u64 *devid,
 					const u8 *uuid);
 int btrfs_rm_device(struct btrfs_fs_info *fs_info,
-		    char *device_path, u64 devid);
+		    const char *device_path, u64 devid);
 void btrfs_cleanup_fs_uuids(void);
 int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len);
 int btrfs_grow_device(struct btrfs_trans_handle *trans,
@@ -439,9 +439,9 @@ int btrfs_grow_device(struct btrfs_trans_handle *trans,
 struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,
 				       u8 *uuid, u8 *fsid);
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
-int btrfs_init_new_device(struct btrfs_fs_info *fs_info, char *path);
+int btrfs_init_new_device(struct btrfs_fs_info *fs_info, const char *path);
 int btrfs_init_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,
-				  char *device_path,
+				  const char *device_path,
 				  struct btrfs_device *srcdev,
 				  struct btrfs_device **device_out);
 int btrfs_balance(struct btrfs_balance_control *bctl,
@@ -474,7 +474,7 @@ void btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,
 				      struct btrfs_device *tgtdev);
 void btrfs_init_dev_replace_tgtdev_for_resume(struct btrfs_fs_info *fs_info,
 					      struct btrfs_device *tgtdev);
-void btrfs_scratch_superblocks(struct block_device *bdev, char *device_path);
+void btrfs_scratch_superblocks(struct block_device *bdev, const char *device_path);
 int btrfs_is_parity_mirror(struct btrfs_mapping_tree *map_tree,
 			   u64 logical, u64 len, int mirror_num);
 unsigned long btrfs_full_stripe_len(struct btrfs_fs_info *fs_info,

commit 087a76d390cbb8c0d21ea0cb3672ab4a7bb76362
Merge: 759b2656b259 2939e1a86f75
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 16 10:53:01 2016 -0800

    Merge branch 'for-linus-4.10' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull btrfs updates from Chris Mason:
     "Jeff Mahoney and Dave Sterba have a really nice set of cleanups in
      here, and Christoph pitched in corrections/improvements to make btrfs
      use proper helpers for bio walking instead of doing it by hand.
    
      There are some key fixes as well, including some long standing bugs
      that took forever to track down in btrfs_drop_extents and during
      balance"
    
    * 'for-linus-4.10' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (77 commits)
      btrfs: limit async_work allocation and worker func duration
      Revert "Btrfs: adjust len of writes if following a preallocated extent"
      Btrfs: don't WARN() in btrfs_transaction_abort() for IO errors
      btrfs: opencode chunk locking, remove helpers
      btrfs: remove root parameter from transaction commit/end routines
      btrfs: split btrfs_wait_marked_extents into normal and tree log functions
      btrfs: take an fs_info directly when the root is not used otherwise
      btrfs: simplify btrfs_wait_cache_io prototype
      btrfs: convert extent-tree tracepoints to use fs_info
      btrfs: root->fs_info cleanup, access fs_info->delayed_root directly
      btrfs: root->fs_info cleanup, add fs_info convenience variables
      btrfs: root->fs_info cleanup, update_block_group{,flags}
      btrfs: root->fs_info cleanup, lock/unlock_chunks
      btrfs: root->fs_info cleanup, btrfs_calc_{trans,trunc}_metadata_size
      btrfs: pull node/sector/stripe sizes out of root and into fs_info
      btrfs: root->fs_info cleanup, io_ctl_init
      btrfs: root->fs_info cleanup, use fs_info->dev_root everywhere
      btrfs: struct reada_control.root -> reada_control.fs_info
      btrfs: struct btrfsic_state->root should be an fs_info
      btrfs: alloc_reserved_file_extent trace point should use extent_root
      ...

commit 34441361c4f52a5f6e41d8de8e5debbeb415dbf0
Author: David Sterba <dsterba@suse.com>
Date:   Tue Oct 4 19:34:27 2016 +0200

    btrfs: opencode chunk locking, remove helpers
    
    The helpers are trivial and we don't use them consistently.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 18b4449fa5a5..811328984702 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -534,16 +534,6 @@ void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info);
 void btrfs_update_commit_device_bytes_used(struct btrfs_fs_info *fs_info,
 					struct btrfs_transaction *transaction);
 
-static inline void lock_chunks(struct btrfs_fs_info *fs_info)
-{
-	mutex_lock(&fs_info->chunk_mutex);
-}
-
-static inline void unlock_chunks(struct btrfs_fs_info *fs_info)
-{
-	mutex_unlock(&fs_info->chunk_mutex);
-}
-
 struct list_head *btrfs_get_fs_uuids(void);
 void btrfs_set_fs_info_ptr(struct btrfs_fs_info *fs_info);
 void btrfs_reset_fs_info_ptr(struct btrfs_fs_info *fs_info);

commit 2ff7e61e0d30ff166a2ae94575526bffe11fd1a8
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jun 22 18:54:24 2016 -0400

    btrfs: take an fs_info directly when the root is not used otherwise
    
    There are loads of functions in btrfs that accept a root parameter
    but only use it to obtain an fs_info pointer.  Let's convert those to
    just accept an fs_info pointer directly.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 724d18ca7ff0..18b4449fa5a5 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -408,10 +408,10 @@ int btrfs_rmap_block(struct btrfs_fs_info *fs_info,
 int btrfs_read_sys_array(struct btrfs_fs_info *fs_info);
 int btrfs_read_chunk_tree(struct btrfs_fs_info *fs_info);
 int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
-		      struct btrfs_root *extent_root, u64 type);
+		      struct btrfs_fs_info *fs_info, u64 type);
 void btrfs_mapping_init(struct btrfs_mapping_tree *tree);
 void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree);
-int btrfs_map_bio(struct btrfs_root *root, struct bio *bio,
+int btrfs_map_bio(struct btrfs_fs_info *fs_info, struct bio *bio,
 		  int mirror_num, int async_submit);
 int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
 		       fmode_t flags, void *holder);
@@ -421,16 +421,17 @@ int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
 void btrfs_close_extra_devices(struct btrfs_fs_devices *fs_devices, int step);
 void btrfs_assign_next_active_device(struct btrfs_fs_info *fs_info,
 		struct btrfs_device *device, struct btrfs_device *this_dev);
-int btrfs_find_device_missing_or_by_path(struct btrfs_root *root,
+int btrfs_find_device_missing_or_by_path(struct btrfs_fs_info *fs_info,
 					 char *device_path,
 					 struct btrfs_device **device);
-int btrfs_find_device_by_devspec(struct btrfs_root *root, u64 devid,
+int btrfs_find_device_by_devspec(struct btrfs_fs_info *fs_info, u64 devid,
 					 char *devpath,
 					 struct btrfs_device **device);
 struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,
 					const u64 *devid,
 					const u8 *uuid);
-int btrfs_rm_device(struct btrfs_root *root, char *device_path, u64 devid);
+int btrfs_rm_device(struct btrfs_fs_info *fs_info,
+		    char *device_path, u64 devid);
 void btrfs_cleanup_fs_uuids(void);
 int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len);
 int btrfs_grow_device(struct btrfs_trans_handle *trans,
@@ -439,7 +440,8 @@ struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,
 				       u8 *uuid, u8 *fsid);
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_fs_info *fs_info, char *path);
-int btrfs_init_dev_replace_tgtdev(struct btrfs_root *root, char *device_path,
+int btrfs_init_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,
+				  char *device_path,
 				  struct btrfs_device *srcdev,
 				  struct btrfs_device **device_out);
 int btrfs_balance(struct btrfs_balance_control *bctl,
@@ -450,7 +452,7 @@ int btrfs_pause_balance(struct btrfs_fs_info *fs_info);
 int btrfs_cancel_balance(struct btrfs_fs_info *fs_info);
 int btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info);
 int btrfs_check_uuid_tree(struct btrfs_fs_info *fs_info);
-int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
+int btrfs_chunk_readonly(struct btrfs_fs_info *fs_info, u64 chunk_offset);
 int find_free_dev_extent_start(struct btrfs_transaction *transaction,
 			 struct btrfs_device *device, u64 num_bytes,
 			 u64 search_start, u64 *start, u64 *max_avail);
@@ -458,7 +460,7 @@ int find_free_dev_extent(struct btrfs_trans_handle *trans,
 			 struct btrfs_device *device, u64 num_bytes,
 			 u64 *start, u64 *max_avail);
 void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index);
-int btrfs_get_dev_stats(struct btrfs_root *root,
+int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,
 			struct btrfs_ioctl_get_dev_stats *stats);
 void btrfs_init_devices_late(struct btrfs_fs_info *fs_info);
 int btrfs_init_dev_stats(struct btrfs_fs_info *fs_info);
@@ -475,7 +477,7 @@ void btrfs_init_dev_replace_tgtdev_for_resume(struct btrfs_fs_info *fs_info,
 void btrfs_scratch_superblocks(struct block_device *bdev, char *device_path);
 int btrfs_is_parity_mirror(struct btrfs_mapping_tree *map_tree,
 			   u64 logical, u64 len, int mirror_num);
-unsigned long btrfs_full_stripe_len(struct btrfs_root *root,
+unsigned long btrfs_full_stripe_len(struct btrfs_fs_info *fs_info,
 				    struct btrfs_mapping_tree *map_tree,
 				    u64 logical);
 int btrfs_finish_chunk_alloc(struct btrfs_trans_handle *trans,
@@ -529,7 +531,7 @@ static inline void btrfs_dev_stat_reset(struct btrfs_device *dev,
 }
 
 void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info);
-void btrfs_update_commit_device_bytes_used(struct btrfs_root *root,
+void btrfs_update_commit_device_bytes_used(struct btrfs_fs_info *fs_info,
 					struct btrfs_transaction *transaction);
 
 static inline void lock_chunks(struct btrfs_fs_info *fs_info)

commit 3796d335356acccd03282547d852f41e48063766
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Jun 16 11:30:29 2016 -0400

    btrfs: root->fs_info cleanup, lock/unlock_chunks
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 859221769696..724d18ca7ff0 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -532,14 +532,14 @@ void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info);
 void btrfs_update_commit_device_bytes_used(struct btrfs_root *root,
 					struct btrfs_transaction *transaction);
 
-static inline void lock_chunks(struct btrfs_root *root)
+static inline void lock_chunks(struct btrfs_fs_info *fs_info)
 {
-	mutex_lock(&root->fs_info->chunk_mutex);
+	mutex_lock(&fs_info->chunk_mutex);
 }
 
-static inline void unlock_chunks(struct btrfs_root *root)
+static inline void unlock_chunks(struct btrfs_fs_info *fs_info)
 {
-	mutex_unlock(&root->fs_info->chunk_mutex);
+	mutex_unlock(&fs_info->chunk_mutex);
 }
 
 struct list_head *btrfs_get_fs_uuids(void);

commit fb456252d3d9c05dfad09b603868e1ef9097a220
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jun 22 18:54:56 2016 -0400

    btrfs: root->fs_info cleanup, use fs_info->dev_root everywhere
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 0c8e77bfa8f6..859221769696 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -51,8 +51,7 @@ struct btrfs_device {
 	struct list_head dev_list;
 	struct list_head dev_alloc_list;
 	struct btrfs_fs_devices *fs_devices;
-
-	struct btrfs_root *dev_root;
+	struct btrfs_fs_info *fs_info;
 
 	struct rcu_string *name;
 

commit 5112febbc772830f8b1a981570d75c8cb4b93a36
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Tue Jun 21 20:16:08 2016 -0400

    btrfs: btrfs_init_new_device should use fs_info->dev_root
    
    btrfs_init_new_device only uses the root passed in via the ioctl to
    start the transaction.  Nothing else that happens is related to whatever
    root the user used to initiate the ioctl.  We can drop the root requirement
    and just use fs_info->dev_root instead.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 471a619787e8..0c8e77bfa8f6 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -439,7 +439,7 @@ int btrfs_grow_device(struct btrfs_trans_handle *trans,
 struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,
 				       u8 *uuid, u8 *fsid);
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
-int btrfs_init_new_device(struct btrfs_root *root, char *path);
+int btrfs_init_new_device(struct btrfs_fs_info *fs_info, char *path);
 int btrfs_init_dev_replace_tgtdev(struct btrfs_root *root, char *device_path,
 				  struct btrfs_device *srcdev,
 				  struct btrfs_device **device_out);

commit 6bccf3ab1e1f0913268bfcd1c09cadb1f4f2857d
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Tue Jun 21 21:16:51 2016 -0400

    btrfs: call functions that always use the same root with fs_info instead
    
    There are many functions that are always called with the same root
    argument.  Rather than passing the same root every time, we can
    pass an fs_info pointer instead and have the function get the root
    pointer itself.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 416574f9dfc2..471a619787e8 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -406,7 +406,7 @@ int btrfs_map_sblock(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
 int btrfs_rmap_block(struct btrfs_fs_info *fs_info,
 		     u64 chunk_start, u64 physical, u64 devid,
 		     u64 **logical, int *naddrs, int *stripe_len);
-int btrfs_read_sys_array(struct btrfs_root *root);
+int btrfs_read_sys_array(struct btrfs_fs_info *fs_info);
 int btrfs_read_chunk_tree(struct btrfs_fs_info *fs_info);
 int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
 		      struct btrfs_root *extent_root, u64 type);
@@ -480,7 +480,7 @@ unsigned long btrfs_full_stripe_len(struct btrfs_root *root,
 				    struct btrfs_mapping_tree *map_tree,
 				    u64 logical);
 int btrfs_finish_chunk_alloc(struct btrfs_trans_handle *trans,
-				struct btrfs_root *extent_root,
+				struct btrfs_fs_info *fs_info,
 				u64 chunk_offset, u64 chunk_size);
 int btrfs_remove_chunk(struct btrfs_trans_handle *trans,
 		       struct btrfs_fs_info *fs_info, u64 chunk_offset);

commit 5b4aacefb8fbfc996e68b9b083d30f8bc0972449
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Tue Jun 21 10:40:19 2016 -0400

    btrfs: call functions that overwrite their root parameter with fs_info
    
    There are 11 functions that accept a root parameter and immediately
    overwrite it.  We can pass those an fs_info pointer instead.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 9029a3134922..416574f9dfc2 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -407,7 +407,7 @@ int btrfs_rmap_block(struct btrfs_fs_info *fs_info,
 		     u64 chunk_start, u64 physical, u64 devid,
 		     u64 **logical, int *naddrs, int *stripe_len);
 int btrfs_read_sys_array(struct btrfs_root *root);
-int btrfs_read_chunk_tree(struct btrfs_root *root);
+int btrfs_read_chunk_tree(struct btrfs_fs_info *fs_info);
 int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
 		      struct btrfs_root *extent_root, u64 type);
 void btrfs_mapping_init(struct btrfs_mapping_tree *tree);
@@ -483,7 +483,7 @@ int btrfs_finish_chunk_alloc(struct btrfs_trans_handle *trans,
 				struct btrfs_root *extent_root,
 				u64 chunk_offset, u64 chunk_size);
 int btrfs_remove_chunk(struct btrfs_trans_handle *trans,
-		       struct btrfs_root *root, u64 chunk_offset);
+		       struct btrfs_fs_info *fs_info, u64 chunk_offset);
 
 static inline int btrfs_dev_stats_dirty(struct btrfs_device *dev)
 {

commit cf8cddd38bab31b284af8d51fee536be9914f6ef
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Oct 27 09:27:36 2016 +0200

    btrfs: don't abuse REQ_OP_* flags for btrfs_map_block
    
    btrfs_map_block supports different types of mappings, which to a large
    extent resemble block layer operations.  But they don't always do, and
    currently btrfs dangerously overlays it's own flag over the block layer
    flags.  This is just asking for a conflict, so introduce a different
    map flags enum inside of btrfs instead.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 09ed29c67848..9029a3134922 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -371,14 +371,35 @@ struct btrfs_balance_control {
 	struct btrfs_balance_progress stat;
 };
 
+enum btrfs_map_op {
+	BTRFS_MAP_READ,
+	BTRFS_MAP_WRITE,
+	BTRFS_MAP_DISCARD,
+	BTRFS_MAP_GET_READ_MIRRORS,
+};
+
+static inline enum btrfs_map_op btrfs_op(struct bio *bio)
+{
+	switch (bio_op(bio)) {
+	case REQ_OP_DISCARD:
+		return BTRFS_MAP_DISCARD;
+	case REQ_OP_WRITE:
+		return BTRFS_MAP_WRITE;
+	default:
+		WARN_ON_ONCE(1);
+	case REQ_OP_READ:
+		return BTRFS_MAP_READ;
+	}
+}
+
 int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,
 				   u64 end, u64 *length);
 void btrfs_get_bbio(struct btrfs_bio *bbio);
 void btrfs_put_bbio(struct btrfs_bio *bbio);
-int btrfs_map_block(struct btrfs_fs_info *fs_info, int op,
+int btrfs_map_block(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
 		    u64 logical, u64 *length,
 		    struct btrfs_bio **bbio_ret, int mirror_num);
-int btrfs_map_sblock(struct btrfs_fs_info *fs_info, int op,
+int btrfs_map_sblock(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
 		     u64 logical, u64 *length,
 		     struct btrfs_bio **bbio_ret, int mirror_num,
 		     int need_raid_map);

commit 70fd76140a6cb63262bd47b68d57b42e889c10ee
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 1 07:40:10 2016 -0600

    block,fs: use REQ_* flags directly
    
    Remove the WRITE_* and READ_SYNC wrappers, and just use the flags
    directly.  Where applicable this also drops usage of the
    bio_set_op_attrs wrapper.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 09ed29c67848..f137ffe6654c 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -62,7 +62,7 @@ struct btrfs_device {
 	int running_pending;
 	/* regular prio bios */
 	struct btrfs_pending_bios pending_bios;
-	/* WRITE_SYNC bios */
+	/* sync bios */
 	struct btrfs_pending_bios pending_sync_bios;
 
 	struct block_device *bdev;

commit ab8d0fc48dba09e0a2b8b0dbfe144d4de9eb874f
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Tue Sep 20 10:05:02 2016 -0400

    btrfs: convert pr_* to btrfs_* where possible
    
    For many printks, we want to know which file system issued the message.
    
    This patch converts most pr_* calls to use the btrfs_* versions instead.
    In some cases, this means adding plumbing to allow call sites access to
    an fs_info pointer.
    
    fs/btrfs/check-integrity.c is left alone for another day.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 6613e6335ca2..09ed29c67848 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -382,7 +382,7 @@ int btrfs_map_sblock(struct btrfs_fs_info *fs_info, int op,
 		     u64 logical, u64 *length,
 		     struct btrfs_bio **bbio_ret, int mirror_num,
 		     int need_raid_map);
-int btrfs_rmap_block(struct btrfs_mapping_tree *map_tree,
+int btrfs_rmap_block(struct btrfs_fs_info *fs_info,
 		     u64 chunk_start, u64 physical, u64 devid,
 		     u64 **logical, int *naddrs, int *stripe_len);
 int btrfs_read_sys_array(struct btrfs_root *root);

commit 81a75f6781deb7a3b5274b4c683e327e5cb5b883
Author: Mike Christie <mchristi@redhat.com>
Date:   Sun Jun 5 14:31:54 2016 -0500

    btrfs: use bio fields for op and flags
    
    The bio REQ_OP and bi_rw rq_flag_bits are now always setup, so there is
    no need to pass around the rq_flag_bits bits too. btrfs users should
    should access the bio insead.
    
    Signed-off-by: Mike Christie <mchristi@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 3b78700cf30a..6613e6335ca2 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -391,7 +391,7 @@ int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
 		      struct btrfs_root *extent_root, u64 type);
 void btrfs_mapping_init(struct btrfs_mapping_tree *tree);
 void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree);
-int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,
+int btrfs_map_bio(struct btrfs_root *root, struct bio *bio,
 		  int mirror_num, int async_submit);
 int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
 		       fmode_t flags, void *holder);

commit b3d3fa51990599732571bf1a6b1509f7ee887865
Author: Mike Christie <mchristi@redhat.com>
Date:   Sun Jun 5 14:31:53 2016 -0500

    btrfs: update __btrfs_map_block for REQ_OP transition
    
    We no longer pass in a bitmap of rq_flag_bits bits to __btrfs_map_block.
    It will always be a REQ_OP, or the btrfs specific REQ_GET_READ_MIRRORS,
    so this drops the bit tests.
    
    Signed-off-by: Mike Christie <mchristi@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 0ac90f8d85bd..3b78700cf30a 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -375,10 +375,10 @@ int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,
 				   u64 end, u64 *length);
 void btrfs_get_bbio(struct btrfs_bio *bbio);
 void btrfs_put_bbio(struct btrfs_bio *bbio);
-int btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,
+int btrfs_map_block(struct btrfs_fs_info *fs_info, int op,
 		    u64 logical, u64 *length,
 		    struct btrfs_bio **bbio_ret, int mirror_num);
-int btrfs_map_sblock(struct btrfs_fs_info *fs_info, int rw,
+int btrfs_map_sblock(struct btrfs_fs_info *fs_info, int op,
 		     u64 logical, u64 *length,
 		     struct btrfs_bio **bbio_ret, int mirror_num,
 		     int need_raid_map);

commit 680834ca0ad4e9827048d4bda1e38db69c3dd1e4
Merge: 36fac9e9ff20 14b05c510631
Author: David Sterba <dsterba@suse.com>
Date:   Mon May 16 15:46:29 2016 +0200

    Merge branch 'foreign/jeffm/uapi' into for-chris-4.7-20160516
    
    # Conflicts:
    #       include/uapi/linux/btrfs.h

commit 36fac9e9ff20f71fe7ba21978f5949a38d390a4b
Merge: 5ef64a3e757c 88acff64c621
Author: David Sterba <dsterba@suse.com>
Date:   Mon May 16 15:46:26 2016 +0200

    Merge branch 'foreign/anand/dev-del-by-id-ext' into for-chris-4.7-20160516

commit 3d8da67817606380fdadfa483d4dba5c3a5446c6
Author: Liu Bo <bo.li.liu@oracle.com>
Date:   Tue Apr 26 17:53:31 2016 -0700

    Btrfs: fix divide error upon chunk's stripe_len
    
    The struct 'map_lookup' uses type int for @stripe_len, while
    btrfs_chunk_stripe_len() can return a u64 value, and it may end up with
    @stripe_len being undefined value and it can lead to 'divide error' in
     __btrfs_map_block().
    
    This changes 'map_lookup' to use type u64 for stripe_len, also right now
    we only use BTRFS_STRIPE_LEN for stripe_len, so this adds a valid checker for
    BTRFS_STRIPE_LEN.
    
    Reported-by: Vegard Nossum <vegard.nossum@oracle.com>
    Reported-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Signed-off-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ folded division fix to scrub_raid56_parity ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 1939ebde63df..7507be74f7da 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -347,7 +347,7 @@ struct map_lookup {
 	u64 type;
 	int io_align;
 	int io_width;
-	int stripe_len;
+	u64 stripe_len;
 	int sector_size;
 	int num_stripes;
 	int sub_stripes;

commit 88acff64c621aaeee2a4fe0ed124c77358069bce
Author: Anand Jain <anand.jain@oracle.com>
Date:   Tue May 3 17:44:43 2016 +0800

    btrfs: cleanup assigning next active device with a check
    
    Creates helper fucntion as needed by the device delete
    and replace operations. Also now it checks if the next
    device being assigned is an active device.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index febdb7bc9370..7038017bf93b 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -445,6 +445,8 @@ int btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,
 			  struct btrfs_fs_devices **fs_devices_ret);
 int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
 void btrfs_close_extra_devices(struct btrfs_fs_devices *fs_devices, int step);
+void btrfs_assign_next_active_device(struct btrfs_fs_info *fs_info,
+		struct btrfs_device *device, struct btrfs_device *this_dev);
 int btrfs_find_device_missing_or_by_path(struct btrfs_root *root,
 					 char *device_path,
 					 struct btrfs_device **device);

commit 04cd01dffbf9be14ccc51595280c8dc8c318a9c9
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Apr 1 16:14:27 2016 -0400

    btrfs: uapi/linux/btrfs.h migration, move balance flags
    
    The BTRFS_BALANCE_* flags are used by struct btrfs_ioctl_balance_args.flags
    and btrfs_ioctl_balance_args.{data,meta,sys}.flags in the BTRFS_IOC_BALANCE
    ioctl.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 1939ebde63df..144cec33357a 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -357,52 +357,6 @@ struct map_lookup {
 #define map_lookup_size(n) (sizeof(struct map_lookup) + \
 			    (sizeof(struct btrfs_bio_stripe) * (n)))
 
-/*
- * Restriper's general type filter
- */
-#define BTRFS_BALANCE_DATA		(1ULL << 0)
-#define BTRFS_BALANCE_SYSTEM		(1ULL << 1)
-#define BTRFS_BALANCE_METADATA		(1ULL << 2)
-
-#define BTRFS_BALANCE_TYPE_MASK		(BTRFS_BALANCE_DATA |	    \
-					 BTRFS_BALANCE_SYSTEM |	    \
-					 BTRFS_BALANCE_METADATA)
-
-#define BTRFS_BALANCE_FORCE		(1ULL << 3)
-#define BTRFS_BALANCE_RESUME		(1ULL << 4)
-
-/*
- * Balance filters
- */
-#define BTRFS_BALANCE_ARGS_PROFILES	(1ULL << 0)
-#define BTRFS_BALANCE_ARGS_USAGE	(1ULL << 1)
-#define BTRFS_BALANCE_ARGS_DEVID	(1ULL << 2)
-#define BTRFS_BALANCE_ARGS_DRANGE	(1ULL << 3)
-#define BTRFS_BALANCE_ARGS_VRANGE	(1ULL << 4)
-#define BTRFS_BALANCE_ARGS_LIMIT	(1ULL << 5)
-#define BTRFS_BALANCE_ARGS_LIMIT_RANGE	(1ULL << 6)
-#define BTRFS_BALANCE_ARGS_STRIPES_RANGE (1ULL << 7)
-#define BTRFS_BALANCE_ARGS_USAGE_RANGE	(1ULL << 10)
-
-#define BTRFS_BALANCE_ARGS_MASK			\
-	(BTRFS_BALANCE_ARGS_PROFILES |		\
-	 BTRFS_BALANCE_ARGS_USAGE |		\
-	 BTRFS_BALANCE_ARGS_DEVID | 		\
-	 BTRFS_BALANCE_ARGS_DRANGE |		\
-	 BTRFS_BALANCE_ARGS_VRANGE |		\
-	 BTRFS_BALANCE_ARGS_LIMIT |		\
-	 BTRFS_BALANCE_ARGS_LIMIT_RANGE |	\
-	 BTRFS_BALANCE_ARGS_STRIPES_RANGE |	\
-	 BTRFS_BALANCE_ARGS_USAGE_RANGE)
-
-/*
- * Profile changing flags.  When SOFT is set we won't relocate chunk if
- * it already has the target profile (even though it may be
- * half-filled).
- */
-#define BTRFS_BALANCE_ARGS_CONVERT	(1ULL << 8)
-#define BTRFS_BALANCE_ARGS_SOFT		(1ULL << 9)
-
 struct btrfs_balance_args;
 struct btrfs_balance_progress;
 struct btrfs_balance_control {

commit 5c5c0df05deaebcdcc9bb31bdca3812a7c22230f
Author: David Sterba <dsterba@suse.com>
Date:   Mon Feb 15 16:39:55 2016 +0100

    btrfs: rename btrfs_find_device_by_user_input
    
    For clarity how we are going to find the device, let's call it a device
    specifier, devspec for short. Also rename the arguments that are a
    leftover from previous function purpose.
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index a13a538cb01e..febdb7bc9370 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -448,8 +448,8 @@ void btrfs_close_extra_devices(struct btrfs_fs_devices *fs_devices, int step);
 int btrfs_find_device_missing_or_by_path(struct btrfs_root *root,
 					 char *device_path,
 					 struct btrfs_device **device);
-int btrfs_find_device_by_user_input(struct btrfs_root *root, u64 srcdevid,
-					 char *srcdev_name,
+int btrfs_find_device_by_devspec(struct btrfs_root *root, u64 devid,
+					 char *devpath,
 					 struct btrfs_device **device);
 struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,
 					const u64 *devid,

commit 621292bae6ae3b25cd3124b63603d01df4cccfb6
Author: David Sterba <dsterba@suse.com>
Date:   Mon Feb 15 16:28:03 2016 +0100

    btrfs: introduce raid-type to error-code table, for minimum device constraint
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index c73d027e2f8b..a13a538cb01e 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -340,7 +340,7 @@ struct btrfs_raid_attr {
 };
 
 extern const struct btrfs_raid_attr btrfs_raid_array[BTRFS_NR_RAID_TYPES];
-
+extern const int btrfs_raid_mindev_error[BTRFS_NR_RAID_TYPES];
 extern const u64 btrfs_raid_group[BTRFS_NR_RAID_TYPES];
 
 struct map_lookup {

commit 6b526ed70cf189660d009ea6f17af77a9cca0f38
Author: Anand Jain <anand.jain@oracle.com>
Date:   Sat Feb 13 10:01:39 2016 +0800

    btrfs: introduce device delete by devid
    
    This introduces new ioctl BTRFS_IOC_RM_DEV_V2, which uses enhanced struct
    btrfs_ioctl_vol_args_v2 to carry devid as an user argument.
    
    The patch won't delete the old ioctl interface and so kernel remains
    backward compatible with user land progs.
    
    Test case/script:
    echo "0 $(blockdev --getsz /dev/sdf) linear /dev/sdf 0" | dmsetup create bad_disk
    mkfs.btrfs -f -d raid1 -m raid1 /dev/sdd /dev/sde /dev/mapper/bad_disk
    mount /dev/sdd /btrfs
    dmsetup suspend bad_disk
    echo "0 $(blockdev --getsz /dev/sdf) error /dev/sdf 0" | dmsetup load bad_disk
    dmsetup resume bad_disk
    echo "bad disk failed. now deleting/replacing"
    btrfs dev del  3  /btrfs
    echo $?
    btrfs fi show /btrfs
    umount /btrfs
    btrfs-show-super /dev/sdd | egrep num_device
    dmsetup remove bad_disk
    wipefs -a /dev/sdf
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reported-by: Martin <m_btrfs@ml1.co.uk>
    [ adjust messages, s/disk/device/ ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 508739314e43..c73d027e2f8b 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -454,7 +454,7 @@ int btrfs_find_device_by_user_input(struct btrfs_root *root, u64 srcdevid,
 struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,
 					const u64 *devid,
 					const u8 *uuid);
-int btrfs_rm_device(struct btrfs_root *root, char *device_path);
+int btrfs_rm_device(struct btrfs_root *root, char *device_path, u64 devid);
 void btrfs_cleanup_fs_uuids(void);
 int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len);
 int btrfs_grow_device(struct btrfs_trans_handle *trans,

commit 24e0474b59538cdb9d2b7318ec7c7ae9f6faf85d
Author: Anand Jain <anand.jain@oracle.com>
Date:   Sat Feb 13 10:01:35 2016 +0800

    btrfs: create helper btrfs_find_device_by_user_input()
    
    The patch renames btrfs_dev_replace_find_srcdev() to
    btrfs_find_device_by_user_input() and moves it to volumes.c, so that
    delete device can use it.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 1939ebde63df..508739314e43 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -448,6 +448,9 @@ void btrfs_close_extra_devices(struct btrfs_fs_devices *fs_devices, int step);
 int btrfs_find_device_missing_or_by_path(struct btrfs_root *root,
 					 char *device_path,
 					 struct btrfs_device **device);
+int btrfs_find_device_by_user_input(struct btrfs_root *root, u64 srcdevid,
+					 char *srcdev_name,
+					 struct btrfs_device **device);
 struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,
 					const u64 *devid,
 					const u8 *uuid);

commit b28cf57246d5b797ba725bb033110c247f2c301f
Merge: a3058101c17d a7ca42256d9f
Author: Chris Mason <clm@fb.com>
Date:   Mon Jan 11 06:08:37 2016 -0800

    Merge branch 'misc-cleanups-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux into for-linus-4.5
    
    Signed-off-by: Chris Mason <clm@fb.com>

commit ee22184b53c823f6956314c2815d4068e3820737
Author: Byongho Lee <bhlee.kernel@gmail.com>
Date:   Tue Dec 15 01:42:10 2015 +0900

    Btrfs: use linux/sizes.h to represent constants
    
    We use many constants to represent size and offset value.  And to make
    code readable we use '256 * 1024 * 1024' instead of '268435456' to
    represent '256MB'.  However we can make far more readable with 'SZ_256MB'
    which is defined in the 'linux/sizes.h'.
    
    So this patch replaces 'xxx * 1024 * 1024' kind of expression with
    single 'SZ_xxxMB' if 'xxx' is a power of 2 then 'xxx * SZ_1M' if 'xxx' is
    not a power of 2. And I haven't touched to '4096' & '8192' because it's
    more intuitive than 'SZ_4KB' & 'SZ_8KB'.
    
    Signed-off-by: Byongho Lee <bhlee.kernel@gmail.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index d5c84f6b1353..30bbc3e96cb3 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -26,7 +26,7 @@
 
 extern struct mutex uuid_mutex;
 
-#define BTRFS_STRIPE_LEN	(64 * 1024)
+#define BTRFS_STRIPE_LEN	SZ_64K
 
 struct buffer_head;
 struct btrfs_pending_bios {

commit afa427cf9d6ef64e73df68882cbabde0e6a61639
Merge: 4ef7675344d6 35de6db28f26
Author: Chris Mason <clm@fb.com>
Date:   Wed Dec 23 13:10:26 2015 -0800

    Merge branch 'cleanup/misc-simplify' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux into for-linus-4.5

commit 87ad58c5f07444ab2fa083c62b154f38ef0a3035
Author: David Sterba <dsterba@suse.com>
Date:   Fri Nov 27 18:49:39 2015 +0100

    btrfs: make btrfs_close_one_device static
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index ec5712372732..2dc59eba188d 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -566,6 +566,5 @@ static inline void unlock_chunks(struct btrfs_root *root)
 struct list_head *btrfs_get_fs_uuids(void);
 void btrfs_set_fs_info_ptr(struct btrfs_fs_info *fs_info);
 void btrfs_reset_fs_info_ptr(struct btrfs_fs_info *fs_info);
-void btrfs_close_one_device(struct btrfs_device *device);
 
 #endif

commit da02c6898952a2bc251dd51ed9f897e0a72a853e
Author: David Sterba <dsterba@suse.com>
Date:   Mon Nov 16 16:50:13 2015 +0100

    btrfs: fix clashing number of the enhanced balance usage filter
    
    I've accidentally picked an already used number for the enhanced usage
    filter represented by BTRFS_BALANCE_ARGS_USAGE_RANGE, clashing with
    BTRFS_BALANCE_ARGS_CONVERT. Introduced during the development phase,
    no backward compatibility issues.
    
    Reported-by: Holger HoffstÃ¤tte <holger.hoffstaette@googlemail.com>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Fixes: bc3094673f22 ("btrfs: extend balance filter usage to take minimum and maximum")
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index ec5712372732..d5c84f6b1353 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -382,7 +382,7 @@ struct map_lookup {
 #define BTRFS_BALANCE_ARGS_LIMIT	(1ULL << 5)
 #define BTRFS_BALANCE_ARGS_LIMIT_RANGE	(1ULL << 6)
 #define BTRFS_BALANCE_ARGS_STRIPES_RANGE (1ULL << 7)
-#define BTRFS_BALANCE_ARGS_USAGE_RANGE	(1ULL << 8)
+#define BTRFS_BALANCE_ARGS_USAGE_RANGE	(1ULL << 10)
 
 #define BTRFS_BALANCE_ARGS_MASK			\
 	(BTRFS_BALANCE_ARGS_PROFILES |		\

commit b66d62ba1e0d7ada5b89afffe19d12662b5c92c9
Author: David Sterba <dsterba@suse.com>
Date:   Fri Oct 16 19:15:50 2015 +0200

    btrfs: add balance filters limits, stripes and usage to supported mask
    
    Enable the extended 'limit' syntax (a range), the new 'stripes' and
    extended 'usage' syntax (a range) filters in the filters mask. The patch
    comes separate and not within the series that introduced the new filters
    because the patch adding the mask was merged in a late rc. The
    integration branch was based on an older rc and could not merge the
    patch due to the missing changes.
    
    Prerequisities:
    * btrfs: check unsupported filters in balance arguments
    * btrfs: extend balance filter limit to take minimum and maximum
    * btrfs: add balance filter for stripes
    * btrfs: extend balance filter usage to take minimum and maximum
    
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 2a396cbb14a5..ec5712372732 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -390,7 +390,10 @@ struct map_lookup {
 	 BTRFS_BALANCE_ARGS_DEVID | 		\
 	 BTRFS_BALANCE_ARGS_DRANGE |		\
 	 BTRFS_BALANCE_ARGS_VRANGE |		\
-	 BTRFS_BALANCE_ARGS_LIMIT)
+	 BTRFS_BALANCE_ARGS_LIMIT |		\
+	 BTRFS_BALANCE_ARGS_LIMIT_RANGE |	\
+	 BTRFS_BALANCE_ARGS_STRIPES_RANGE |	\
+	 BTRFS_BALANCE_ARGS_USAGE_RANGE)
 
 /*
  * Profile changing flags.  When SOFT is set we won't relocate chunk if

commit bc3094673f22d00794a8606200788e411b4ec80d
Author: David Sterba <dsterba@suse.com>
Date:   Tue Oct 20 18:22:13 2015 +0200

    btrfs: extend balance filter usage to take minimum and maximum
    
    Similar to the 'limit' filter, we can enhance the 'usage' filter to
    accept a range. The change is backward compatible, the range is applied
    only in connection with the BTRFS_BALANCE_ARGS_USAGE_RANGE flag.
    
    We don't have a usecase yet, the current syntax has been sufficient. The
    enhancement should provide parity with other range-like filters.
    
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index a5bf224d3c65..2a396cbb14a5 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -382,6 +382,7 @@ struct map_lookup {
 #define BTRFS_BALANCE_ARGS_LIMIT	(1ULL << 5)
 #define BTRFS_BALANCE_ARGS_LIMIT_RANGE	(1ULL << 6)
 #define BTRFS_BALANCE_ARGS_STRIPES_RANGE (1ULL << 7)
+#define BTRFS_BALANCE_ARGS_USAGE_RANGE	(1ULL << 8)
 
 #define BTRFS_BALANCE_ARGS_MASK			\
 	(BTRFS_BALANCE_ARGS_PROFILES |		\

commit dee32d0ac3719ef8d640efaf0884111df444730f
Author: GabrÃ­el ArthÃºr PÃ©tursson <gabriel@system.is>
Date:   Mon Sep 28 22:32:41 2015 +0000

    btrfs: add balance filter for stripes
    
    Balance block groups which have the given number of stripes, defined by
    a range min..max. This is useful to selectively rebalance only chunks
    that do not span enough devices, applies to RAID0/10/5/6.
    
    Signed-off-by: GabrÃ­el ArthÃºr PÃ©tursson <gabriel@system.is>
    [ renamed bargs members, added to the UAPI, wrote the changelog ]
    Signed-off-by: David Sterba <dsterba@suse.com>
    
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 628d4e17019d..a5bf224d3c65 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -381,6 +381,7 @@ struct map_lookup {
 #define BTRFS_BALANCE_ARGS_VRANGE	(1ULL << 4)
 #define BTRFS_BALANCE_ARGS_LIMIT	(1ULL << 5)
 #define BTRFS_BALANCE_ARGS_LIMIT_RANGE	(1ULL << 6)
+#define BTRFS_BALANCE_ARGS_STRIPES_RANGE (1ULL << 7)
 
 #define BTRFS_BALANCE_ARGS_MASK			\
 	(BTRFS_BALANCE_ARGS_PROFILES |		\

commit 12907fc79818a62a2478f84f7795afa774bf7f9c
Author: David Sterba <dsterba@suse.com>
Date:   Sat Oct 10 17:16:50 2015 +0200

    btrfs: extend balance filter limit to take minimum and maximum
    
    The 'limit' filter is underdesigned, it should have been a range for
    [min,max], with some relaxed semantics when one of the bounds is
    missing. Besides that, using a full u64 for a single value is a waste of
    bytes.
    
    Let's fix both by extending the use of the u64 bytes for the [min,max]
    range. This can be done in a backward compatible way, the range will be
    interpreted only if the appropriate flag is set
    (BTRFS_BALANCE_ARGS_LIMIT_RANGE).
    
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index b8e64ea984f1..628d4e17019d 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -380,6 +380,7 @@ struct map_lookup {
 #define BTRFS_BALANCE_ARGS_DRANGE	(1ULL << 3)
 #define BTRFS_BALANCE_ARGS_VRANGE	(1ULL << 4)
 #define BTRFS_BALANCE_ARGS_LIMIT	(1ULL << 5)
+#define BTRFS_BALANCE_ARGS_LIMIT_RANGE	(1ULL << 6)
 
 #define BTRFS_BALANCE_ARGS_MASK			\
 	(BTRFS_BALANCE_ARGS_PROFILES |		\

commit 849ef9286f30c88113906dc35f44a499c0cb385d
Author: David Sterba <dsterba@suse.com>
Date:   Mon Oct 12 16:55:54 2015 +0200

    btrfs: check unsupported filters in balance arguments
    
    We don't verify that all the balance filter arguments supplemented by
    the flags are actually known to the kernel. Thus we let it silently pass
    and do nothing.
    
    At the moment this means only the 'limit' filter, but we're going to add
    a few more soon so it's better to have that fixed. Also in older stable
    kernels so that it works with newer userspace tools.
    
    Cc: stable@vger.kernel.org # 3.16+
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 99c208f6718d..b8e64ea984f1 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -381,6 +381,14 @@ struct map_lookup {
 #define BTRFS_BALANCE_ARGS_VRANGE	(1ULL << 4)
 #define BTRFS_BALANCE_ARGS_LIMIT	(1ULL << 5)
 
+#define BTRFS_BALANCE_ARGS_MASK			\
+	(BTRFS_BALANCE_ARGS_PROFILES |		\
+	 BTRFS_BALANCE_ARGS_USAGE |		\
+	 BTRFS_BALANCE_ARGS_DEVID | 		\
+	 BTRFS_BALANCE_ARGS_DRANGE |		\
+	 BTRFS_BALANCE_ARGS_VRANGE |		\
+	 BTRFS_BALANCE_ARGS_LIMIT)
+
 /*
  * Profile changing flags.  When SOFT is set we won't relocate chunk if
  * it already has the target profile (even though it may be

commit a0d58e48db58801a0e764e9b9c87e1782d390fcb
Merge: 6db4a7335dd7 ddd664f4478a
Author: Chris Mason <clm@fb.com>
Date:   Wed Oct 21 18:21:40 2015 -0700

    Merge branch 'cleanups/for-4.4' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux into for-linus-4.4

commit 8789f4fe608922f484369382a8e507ca12df7f4e
Author: Zhao Lei <zhaolei@cn.fujitsu.com>
Date:   Tue Sep 15 21:08:07 2015 +0800

    btrfs: use btrfs_raid_array for btrfs_get_num_tolerated_disk_barrier_failures()
    
    btrfs_raid_array[] is used to define all raid attributes, use it
    to get tolerated_failures in btrfs_get_num_tolerated_disk_barrier_failures(),
    instead of complex condition in function.
    
    It can make code simple and auto-support other possible raid-type in
    future.
    
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 75d6083d9b3b..04ff0efe2f58 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -334,6 +334,7 @@ struct btrfs_raid_attr {
 	int dev_stripes;	/* stripes per dev */
 	int devs_max;		/* max devs to use */
 	int devs_min;		/* min devs needed */
+	int tolerated_failures; /* max tolerated fail devs */
 	int devs_increment;	/* ndevs has to be a multiple of this */
 	int ncopies;		/* how many copies to data has */
 };

commit af902047508d3619499cbbc2f7c4c5e16428b2e3
Author: Zhao Lei <zhaolei@cn.fujitsu.com>
Date:   Tue Sep 15 21:08:06 2015 +0800

    btrfs: Move btrfs_raid_array to public
    
    This array is used to record attributes of each raid type,
    make it public, and many functions will benifit with this array.
    
    For example, num_tolerated_disk_barrier_failures(), we can
    avoid complex conditions in this function, and get raid attribute
    simply by accessing above array.
    
    It can also make code logic simple, reduce duplication code, and
    increase maintainability.
    
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 2ca784a14e84..75d6083d9b3b 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -338,6 +338,10 @@ struct btrfs_raid_attr {
 	int ncopies;		/* how many copies to data has */
 };
 
+extern const struct btrfs_raid_attr btrfs_raid_array[BTRFS_NR_RAID_TYPES];
+
+extern const u64 btrfs_raid_group[BTRFS_NR_RAID_TYPES];
+
 struct map_lookup {
 	u64 type;
 	int io_align;

commit f190aa471a7a703444f6587ed79c24a04a22d848
Author: Anand Jain <anand.jain@oracle.com>
Date:   Fri Aug 14 18:33:05 2015 +0800

    Btrfs: add helper for closing one device
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    [reworded subject and changelog]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 8663bf7c5051..38450dc28837 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -547,5 +547,6 @@ static inline void unlock_chunks(struct btrfs_root *root)
 struct list_head *btrfs_get_fs_uuids(void);
 void btrfs_set_fs_info_ptr(struct btrfs_fs_info *fs_info);
 void btrfs_reset_fs_info_ptr(struct btrfs_fs_info *fs_info);
+void btrfs_close_one_device(struct btrfs_device *device);
 
 #endif

commit 12b1c2637b6e0763121648d637ffe603b422e986
Author: Anand Jain <anand.jain@oracle.com>
Date:   Fri Aug 14 18:32:59 2015 +0800

    Btrfs: enhance btrfs_scratch_superblock to scratch all superblocks
    
    This patch updates and renames btrfs_scratch_superblocks, (which is used
    by the replace device thread), with those fixes from the scratch
    superblock code section of btrfs_rm_device(). The fixes are:
      Scratch all copies of superblock
      Notify kobject that superblock has been changed
      Update time on the device
    
    So that btrfs_rm_device() can use the function
    btrfs_scratch_superblocks() instead of its own scratch code. And further
    replace deivce code which similarly releases device back to the system,
    will have the fixes from the btrfs device delete.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    [renamed to btrfs_scratch_superblock]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 413a70c66f4c..8663bf7c5051 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -474,7 +474,7 @@ void btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,
 				      struct btrfs_device *tgtdev);
 void btrfs_init_dev_replace_tgtdev_for_resume(struct btrfs_fs_info *fs_info,
 					      struct btrfs_device *tgtdev);
-int btrfs_scratch_superblock(struct btrfs_device *device);
+void btrfs_scratch_superblocks(struct block_device *bdev, char *device_path);
 int btrfs_is_parity_mirror(struct btrfs_mapping_tree *map_tree,
 			   u64 logical, u64 len, int mirror_num);
 unsigned long btrfs_full_stripe_len(struct btrfs_root *root,

commit c1b7e474595b1b3a4463450cc22aa18b926093a3
Author: Anand Jain <anand.jain@oracle.com>
Date:   Fri Aug 14 18:32:50 2015 +0800

    Btrfs: rename super_kobj to fsid_kobj
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 2ca784a14e84..413a70c66f4c 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -256,7 +256,7 @@ struct btrfs_fs_devices {
 
 	struct btrfs_fs_info *fs_info;
 	/* sysfs kobjects */
-	struct kobject super_kobj;
+	struct kobject fsid_kobj;
 	struct kobject *device_dir_kobj;
 	struct completion kobj_unregister;
 };

commit 46cd28555ffaa40162290dba203daad0ff6f7abd
Merge: da2f0f74cf7d e33e17ee1098
Author: Chris Mason <clm@fb.com>
Date:   Sun Aug 9 07:35:33 2015 -0700

    Merge branch 'jeffm-discard-4.3' into for-linus-4.3

commit 499f377f49f085ee4aa214c738e948e88626f39b
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Jun 15 09:41:17 2015 -0400

    btrfs: iterate over unused chunk space in FITRIM
    
    Since we now clean up block groups automatically as they become
    empty, iterating over block groups is no longer sufficient to discard
    unused space.
    
    This patch iterates over the unused chunk space and discards any regions
    that are unallocated, regardless of whether they were ever used.  This is
    a change for btrfs but is consistent with other file systems.
    
    We do this in a transactionless manner since the discard process can take
    a substantial amount of time and a transaction would need to be started
    before the acquisition of the device list lock.  That would mean a
    transaction would be held open across /all/ of the discards collectively.
    In order to prevent other threads from allocating or freeing chunks, we
    hold the chunks lock across the search and discard calls.  We release it
    between searches to allow the file system to perform more-or-less
    normally.  Since the running transaction can commit and disappear while
    we're using the transaction pointer, we take a reference to it and
    release it after the search.  This is safe since it would happen normally
    at the end of the transaction commit after any locks are released anyway.
    We also take the commit_root_sem to protect against a transaction starting
    and committing while we're running.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: Filipe Manana <fdmanana@suse.com>
    Tested-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 210a64390f40..57b0217b5300 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -455,6 +455,9 @@ int btrfs_cancel_balance(struct btrfs_fs_info *fs_info);
 int btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info);
 int btrfs_check_uuid_tree(struct btrfs_fs_info *fs_info);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
+int find_free_dev_extent_start(struct btrfs_transaction *transaction,
+			 struct btrfs_device *device, u64 num_bytes,
+			 u64 search_start, u64 *start, u64 *max_avail);
 int find_free_dev_extent(struct btrfs_trans_handle *trans,
 			 struct btrfs_device *device, u64 num_bytes,
 			 u64 *start, u64 *max_avail);

commit 043cd04950431f206f784d1ed9b3fcc5993045f2
Merge: 43baed34bc6b 5a5003df98d5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 30 20:07:45 2015 -0700

    Merge branch 'for-linus-4.2' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull btrfs updates from Chris Mason:
     "Outside of our usual batch of fixes, this integrates the subvolume
      quota updates that Qu Wenruo from Fujitsu has been working on for a
      few releases now.  He gets an extra gold star for making btrfs smaller
      this time, and fixing a number of quota corners in the process.
    
      Dave Sterba tested and integrated Anand Jain's sysfs improvements.
      Outside of exporting a symbol (ack'd by Greg) these are all internal
      to btrfs and it's mostly cleanups and fixes.  Anand also attached some
      of our sysfs objects to our internal device management structs instead
      of an object off the super block.  It will make device management
      easier overall and it's a better fit for how the sysfs files are used.
      None of the existing sysfs files are moved around.
    
      Thanks for all the fixes everyone"
    
    * 'for-linus-4.2' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (87 commits)
      btrfs: delayed-ref: double free in btrfs_add_delayed_tree_ref()
      Btrfs: Check if kobject is initialized before put
      lib: export symbol kobject_move()
      Btrfs: sysfs: add support to show replacing target in the sysfs
      Btrfs: free the stale device
      Btrfs: use received_uuid of parent during send
      Btrfs: fix use-after-free in btrfs_replay_log
      btrfs: wait for delayed iputs on no space
      btrfs: qgroup: Make snapshot accounting work with new extent-oriented qgroup.
      btrfs: qgroup: Add the ability to skip given qgroup for old/new_roots.
      btrfs: ulist: Add ulist_del() function.
      btrfs: qgroup: Cleanup the old ref_node-oriented mechanism.
      btrfs: qgroup: Switch self test to extent-oriented qgroup mechanism.
      btrfs: qgroup: Switch to new extent-oriented qgroup mechanism.
      btrfs: qgroup: Switch rescan to new mechanism.
      btrfs: qgroup: Add new qgroup calculation function btrfs_qgroup_account_extents().
      btrfs: backref: Add special time_seq == (u64)-1 case for btrfs_find_all_roots().
      btrfs: qgroup: Add new function to record old_roots.
      btrfs: qgroup: Record possible quota-related extent for qgroup.
      btrfs: qgroup: Add function qgroup_update_counters().
      ...

commit 5a13f4308c5b4af28c01ca9cacdd8a6db777dfcb
Author: Anand Jain <Anand.Jain@oracle.com>
Date:   Tue Mar 10 06:38:31 2015 +0800

    Btrfs: sysfs: add pointer to access fs_info from fs_devices
    
    adds fs_info pointer with struct btrfs_fs_devices.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index ac7e938c6977..210a64390f40 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -254,6 +254,7 @@ struct btrfs_fs_devices {
 	 */
 	int rotating;
 
+	struct btrfs_fs_info *fs_info;
 	/* sysfs kobjects */
 	struct kobject super_kobj;
 	struct kobject *device_dir_kobj;
@@ -543,5 +544,7 @@ static inline void unlock_chunks(struct btrfs_root *root)
 }
 
 struct list_head *btrfs_get_fs_uuids(void);
+void btrfs_set_fs_info_ptr(struct btrfs_fs_info *fs_info);
+void btrfs_reset_fs_info_ptr(struct btrfs_fs_info *fs_info);
 
 #endif

commit c73eccf75bf92e49be30884da32a169b04eb5bc9
Author: Anand Jain <anand.jain@oracle.com>
Date:   Tue Mar 10 06:38:30 2015 +0800

    Btrfs: introduce btrfs_get_fs_uuids to get fs_uuids
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index e9780e9e6d97..ac7e938c6977 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -542,5 +542,6 @@ static inline void unlock_chunks(struct btrfs_root *root)
 	mutex_unlock(&root->fs_info->chunk_mutex);
 }
 
+struct list_head *btrfs_get_fs_uuids(void);
 
 #endif

commit 2e7910d6ca359ff1dbe05b74e3d7f353b5b65362
Author: Anand Jain <Anand.Jain@oracle.com>
Date:   Tue Mar 10 06:38:29 2015 +0800

    Btrfs: sysfs: move super_kobj and device_dir_kobj from fs_info to btrfs_fs_devices
    
    This patch will provide a framework and help to create attributes
    from the structure btrfs_fs_devices which are available even before
    fs_info is created. So by moving the parent kobject super_kobj from
    fs_info to btrfs_fs_devices, it will help to create attributes
    from the btrfs_fs_devices as well.
    
    Patches on top of this patch now will be able to create the
    sys/fs/btrfs/fsid kobject and attributes from btrfs_fs_devices
    when devices are scanned and registered to the kernel.
    
    Just to note, this does not change any of the existing btrfs sysfs
    external kobject names and its attributes and not even the life
    cycle of them. Changes are internal only. And to ensure the same,
    this path has been tested with various device operations and,
    checking and comparing the sysfs kobjects and attributes with
    sysfs kobject and attributes with out this patch, and they remain
    same.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index ebc31331a837..e9780e9e6d97 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -253,6 +253,11 @@ struct btrfs_fs_devices {
 	 * nonrot flag set
 	 */
 	int rotating;
+
+	/* sysfs kobjects */
+	struct kobject super_kobj;
+	struct kobject *device_dir_kobj;
+	struct completion kobj_unregister;
 };
 
 #define BTRFS_BIO_INLINE_CSUM_SIZE	64

commit 326e1dbb57368087a36607aaebe9795b8d5453e5
Author: Mike Snitzer <snitzer@redhat.com>
Date:   Fri May 22 09:14:03 2015 -0400

    block: remove management of bi_remaining when restoring original bi_end_io
    
    Commit c4cf5261 ("bio: skip atomic inc/dec of ->bi_remaining for
    non-chains") regressed all existing callers that followed this pattern:
     1) saving a bio's original bi_end_io
     2) wiring up an intermediate bi_end_io
     3) restoring the original bi_end_io from intermediate bi_end_io
     4) calling bio_endio() to execute the restored original bi_end_io
    
    The regression was due to BIO_CHAIN only ever getting set if
    bio_inc_remaining() is called.  For the above pattern it isn't set until
    step 3 above (step 2 would've needed to establish BIO_CHAIN).  As such
    the first bio_endio(), in step 2 above, never decremented __bi_remaining
    before calling the intermediate bi_end_io -- leaving __bi_remaining with
    the value 1 instead of 0.  When bio_inc_remaining() occurred during step
    3 it brought it to a value of 2.  When the second bio_endio() was
    called, in step 4 above, it should've called the original bi_end_io but
    it didn't because there was an extra reference that wasn't dropped (due
    to atomic operations being optimized away since BIO_CHAIN wasn't set
    upfront).
    
    Fix this issue by removing the __bi_remaining management complexity for
    all callers that use the above pattern -- bio_chain() is the only
    interface that _needs_ to be concerned with __bi_remaining.  For the
    above pattern callers just expect the bi_end_io they set to get called!
    Remove bio_endio_nodec() and also remove all bio_inc_remaining() calls
    that aren't associated with the bio_chain() interface.
    
    Also, the bio_inc_remaining() interface has been moved local to bio.c.
    
    Fixes: c4cf5261 ("bio: skip atomic inc/dec of ->bi_remaining for non-chains")
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Mike Snitzer <snitzer@redhat.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index ebc31331a837..cedae0356558 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -292,8 +292,6 @@ struct btrfs_bio_stripe {
 struct btrfs_bio;
 typedef void (btrfs_bio_end_io_t) (struct btrfs_bio *bio, int err);
 
-#define BTRFS_BIO_ORIG_BIO_SUBMITTED	(1 << 0)
-
 struct btrfs_bio {
 	atomic_t refs;
 	atomic_t stripes_pending;

commit 9eaed21ef94b5da30eaf1b2503df1d41c2025175
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Fri Aug 1 18:12:35 2014 -0500

    btrfs: remove unused fs_info arg from btrfs_close_extra_devices()
    
    The commit:
    8dabb74 Btrfs: change core code of btrfs to support the
            device replace operations
    added the fs_info argument, but never used it -
    just remove it again.
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 83069dec6898..ebc31331a837 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -421,8 +421,7 @@ int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
 int btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,
 			  struct btrfs_fs_devices **fs_devices_ret);
 int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
-void btrfs_close_extra_devices(struct btrfs_fs_info *fs_info,
-			       struct btrfs_fs_devices *fs_devices, int step);
+void btrfs_close_extra_devices(struct btrfs_fs_devices *fs_devices, int step);
 int btrfs_find_device_missing_or_by_path(struct btrfs_root *root,
 					 char *device_path,
 					 struct btrfs_device **device);

commit 10f11900167a83e0c229c4c27e73e720ebd55b5c
Author: Zhao Lei <zhaolei@cn.fujitsu.com>
Date:   Tue Jan 20 15:11:43 2015 +0800

    Btrfs: Include map_type in raid_bio
    
    Corrent code use many kinds of "clever" way to determine operation
    target's raid type, as:
      raid_map != NULL
      or
      raid_map[MAX_NR] == RAID[56]_Q_STRIPE
    
    To make code easy to maintenance, this patch put raid type into
    bbio, and we can always get raid type from bbio with a "stupid"
    way.
    
    Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 4313e8ff91e5..83069dec6898 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -298,6 +298,7 @@ struct btrfs_bio {
 	atomic_t refs;
 	atomic_t stripes_pending;
 	struct btrfs_fs_info *fs_info;
+	u64 map_type; /* get from map_lookup->type */
 	bio_end_io_t *end_io;
 	struct bio *orig_bio;
 	unsigned long flags;

commit 6e9606d2a2dce098c1739fb3cd82a1c34fd73d3a
Author: Zhao Lei <zhaolei@cn.fujitsu.com>
Date:   Tue Jan 20 15:11:34 2015 +0800

    Btrfs: add ref_count and free function for btrfs_bio
    
    1: ref_count is simple than current RBIO_HOLD_BBIO_MAP_BIT flag
       to keep btrfs_bio's memory in raid56 recovery implement.
    2: free function for bbio will make code clean and flexible, plus
       forced data type checking in compile.
    
    Changelog v1->v2:
     Rename following by David Sterba's suggestion:
     put_btrfs_bio() -> btrfs_put_bio()
     get_btrfs_bio() -> btrfs_get_bio()
     bbio->ref_count -> bbio->refs
    
    Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index fb0e8c3f296e..4313e8ff91e5 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -295,6 +295,7 @@ typedef void (btrfs_bio_end_io_t) (struct btrfs_bio *bio, int err);
 #define BTRFS_BIO_ORIG_BIO_SUBMITTED	(1 << 0)
 
 struct btrfs_bio {
+	atomic_t refs;
 	atomic_t stripes_pending;
 	struct btrfs_fs_info *fs_info;
 	bio_end_io_t *end_io;
@@ -394,13 +395,8 @@ struct btrfs_balance_control {
 
 int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,
 				   u64 end, u64 *length);
-
-#define btrfs_bio_size(total_stripes, real_stripes)		\
-	(sizeof(struct btrfs_bio) +				\
-	 (sizeof(struct btrfs_bio_stripe) * (total_stripes)) +	\
-	 (sizeof(int) * (real_stripes)) +			\
-	 (sizeof(u64) * (real_stripes)))
-
+void btrfs_get_bbio(struct btrfs_bio *bbio);
+void btrfs_put_bbio(struct btrfs_bio *bbio);
 int btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,
 		    u64 logical, u64 *length,
 		    struct btrfs_bio **bbio_ret, int mirror_num);

commit 8e5cfb55d3f7dc764cd7f4c966d4c2687eaf7569
Author: Zhao Lei <zhaolei@cn.fujitsu.com>
Date:   Tue Jan 20 15:11:33 2015 +0800

    Btrfs: Make raid_map array be inlined in btrfs_bio structure
    
    It can make code more simple and clear, we need not care about
    free bbio and raid_map together.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index d6fe73c0f4a2..fb0e8c3f296e 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -307,6 +307,12 @@ struct btrfs_bio {
 	int mirror_num;
 	int num_tgtdevs;
 	int *tgtdev_map;
+	/*
+	 * logical block numbers for the start of each stripe
+	 * The last one or two are p/q.  These are sorted,
+	 * so raid_map[0] is the start of our full stripe
+	 */
+	u64 *raid_map;
 	struct btrfs_bio_stripe stripes[];
 };
 
@@ -392,7 +398,8 @@ int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,
 #define btrfs_bio_size(total_stripes, real_stripes)		\
 	(sizeof(struct btrfs_bio) +				\
 	 (sizeof(struct btrfs_bio_stripe) * (total_stripes)) +	\
-	 (sizeof(int) * (real_stripes)))
+	 (sizeof(int) * (real_stripes)) +			\
+	 (sizeof(u64) * (real_stripes)))
 
 int btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,
 		    u64 logical, u64 *length,
@@ -400,7 +407,7 @@ int btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,
 int btrfs_map_sblock(struct btrfs_fs_info *fs_info, int rw,
 		     u64 logical, u64 *length,
 		     struct btrfs_bio **bbio_ret, int mirror_num,
-		     u64 **raid_map_ret);
+		     int need_raid_map);
 int btrfs_rmap_block(struct btrfs_mapping_tree *map_tree,
 		     u64 chunk_start, u64 physical, u64 devid,
 		     u64 **logical, int *naddrs, int *stripe_len);

commit 9627aeee3e203e30679549e4962633698a6bf87f
Merge: cb83b7b81698 5d3edd8f44aa
Author: Chris Mason <clm@fb.com>
Date:   Tue Dec 2 18:42:03 2014 -0800

    Merge branch 'raid56-scrub-replace' of git://github.com/miaoxie/linux-btrfs into for-linus

commit 04216820fe83d5e27322065ba989de27dbfc104d
Author: Filipe Manana <fdmanana@suse.com>
Date:   Thu Nov 27 21:14:15 2014 +0000

    Btrfs: fix race between fs trimming and block group remove/allocation
    
    Our fs trim operation, which is completely transactionless (doesn't start
    or joins an existing transaction) consists of visiting all block groups
    and then for each one to iterate its free space entries and perform a
    discard operation against the space range represented by the free space
    entries. However before performing a discard, the corresponding free space
    entry is removed from the free space rbtree, and when the discard completes
    it is added back to the free space rbtree.
    
    If a block group remove operation happens while the discard is ongoing (or
    before it starts and after a free space entry is hidden), we end up not
    waiting for the discard to complete, remove the extent map that maps
    logical address to physical addresses and the corresponding chunk metadata
    from the the chunk and device trees. After that and before the discard
    completes, the current running transaction can finish and a new one start,
    allowing for new block groups that map to the same physical addresses to
    be allocated and written to.
    
    So fix this by keeping the extent map in memory until the discard completes
    so that the same physical addresses aren't reused before it completes.
    
    If the physical locations that are under a discard operation end up being
    used for a new metadata block group for example, and dirty metadata extents
    are written before the discard finishes (the VM might call writepages() of
    our btree inode's i_mapping for example, or an fsync log commit happens) we
    end up overwriting metadata with zeroes, which leads to errors from fsck
    like the following:
    
            checking extents
            Check tree block failed, want=833912832, have=0
            Check tree block failed, want=833912832, have=0
            Check tree block failed, want=833912832, have=0
            Check tree block failed, want=833912832, have=0
            Check tree block failed, want=833912832, have=0
            read block failed check_tree_block
            owner ref check failed [833912832 16384]
            Errors found in extent allocation tree or chunk allocation
            checking free space cache
            checking fs roots
            Check tree block failed, want=833912832, have=0
            Check tree block failed, want=833912832, have=0
            Check tree block failed, want=833912832, have=0
            Check tree block failed, want=833912832, have=0
            Check tree block failed, want=833912832, have=0
            read block failed check_tree_block
            root 5 root dir 256 error
            root 5 inode 260 errors 2001, no inode item, link count wrong
                    unresolved ref dir 256 index 0 namelen 8 name foobar_3 filetype 1 errors 6, no dir index, no inode ref
            root 5 inode 262 errors 2001, no inode item, link count wrong
                    unresolved ref dir 256 index 0 namelen 8 name foobar_5 filetype 1 errors 6, no dir index, no inode ref
            root 5 inode 263 errors 2001, no inode item, link count wrong
            (...)
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 4cc00e64427e..637bcfadadb2 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -515,4 +515,16 @@ static inline void btrfs_dev_stat_reset(struct btrfs_device *dev,
 void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info);
 void btrfs_update_commit_device_bytes_used(struct btrfs_root *root,
 					struct btrfs_transaction *transaction);
+
+static inline void lock_chunks(struct btrfs_root *root)
+{
+	mutex_lock(&root->fs_info->chunk_mutex);
+}
+
+static inline void unlock_chunks(struct btrfs_root *root)
+{
+	mutex_unlock(&root->fs_info->chunk_mutex);
+}
+
+
 #endif

commit 2c8cdd6ee4e7f637b0486c6798117e7859dee586
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Fri Nov 14 16:06:25 2014 +0800

    Btrfs, replace: write dirty pages into the replace target device
    
    The implementation is simple:
    - In order to avoid changing the code logic of btrfs_map_bio and
      RAID56, we add the stripes of the replace target devices at the
      end of the stripe array in btrfs bio, and we sort those target
      device stripes in the array. And we keep the number of the target
      device stripes in the btrfs bio.
    - Except write operation on RAID56, all the other operation don't
      take the target device stripes into account.
    - When we do write operation, we read the data from the common devices
      and calculate the parity. Then write the dirty data and new parity
      out, at this time, we will find the relative replace target stripes
      and wirte the relative data into it.
    
    Note: The function that copying old data on the source device to
    the target device was implemented in the past, it is similar to
    the other RAID type.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 01094bb804c7..70be2571cedf 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -292,7 +292,7 @@ struct btrfs_bio_stripe {
 struct btrfs_bio;
 typedef void (btrfs_bio_end_io_t) (struct btrfs_bio *bio, int err);
 
-#define BTRFS_BIO_ORIG_BIO_SUBMITTED	0x1
+#define BTRFS_BIO_ORIG_BIO_SUBMITTED	(1 << 0)
 
 struct btrfs_bio {
 	atomic_t stripes_pending;
@@ -305,6 +305,8 @@ struct btrfs_bio {
 	int max_errors;
 	int num_stripes;
 	int mirror_num;
+	int num_tgtdevs;
+	int *tgtdev_map;
 	struct btrfs_bio_stripe stripes[];
 };
 
@@ -387,8 +389,10 @@ struct btrfs_balance_control {
 int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,
 				   u64 end, u64 *length);
 
-#define btrfs_bio_size(n) (sizeof(struct btrfs_bio) + \
-			    (sizeof(struct btrfs_bio_stripe) * (n)))
+#define btrfs_bio_size(total_stripes, real_stripes)		\
+	(sizeof(struct btrfs_bio) +				\
+	 (sizeof(struct btrfs_bio_stripe) * (total_stripes)) +	\
+	 (sizeof(int) * (real_stripes)))
 
 int btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,
 		    u64 logical, u64 *length,

commit af8e2d1df9848b39dd86b1e696bf8781d2020a88
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Thu Oct 23 14:42:50 2014 +0800

    Btrfs, scrub: repair the common data on RAID5/6 if it is corrupted
    
    This patch implement the RAID5/6 common data repair function, the
    implementation is similar to the scrub on the other RAID such as
    RAID1, the differentia is that we don't read the data from the
    mirror, we use the data repair function of RAID5/6.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 08980fa23039..01094bb804c7 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -393,6 +393,10 @@ int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,
 int btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,
 		    u64 logical, u64 *length,
 		    struct btrfs_bio **bbio_ret, int mirror_num);
+int btrfs_map_sblock(struct btrfs_fs_info *fs_info, int rw,
+		     u64 logical, u64 *length,
+		     struct btrfs_bio **bbio_ret, int mirror_num,
+		     u64 **raid_map_ret);
 int btrfs_rmap_block(struct btrfs_mapping_tree *map_tree,
 		     u64 chunk_start, u64 physical, u64 devid,
 		     u64 **logical, int *naddrs, int *stripe_len);

commit 084b6e7c7607bbeb28544da659c3f5981a4689b0
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Thu Oct 30 16:52:31 2014 +0800

    btrfs: Fix a lockdep warning when running xfstest.
    
    The following lockdep warning is triggered during xfstests:
    
    [ 1702.980872] =========================================================
    [ 1702.981181] [ INFO: possible irq lock inversion dependency detected ]
    [ 1702.981482] 3.18.0-rc1 #27 Not tainted
    [ 1702.981781] ---------------------------------------------------------
    [ 1702.982095] kswapd0/77 just changed the state of lock:
    [ 1702.982415]  (&delayed_node->mutex){+.+.-.}, at: [<ffffffffa03b0b51>] __btrfs_release_delayed_node+0x41/0x1f0 [btrfs]
    [ 1702.982794] but this lock took another, RECLAIM_FS-unsafe lock in the past:
    [ 1702.983160]  (&fs_info->dev_replace.lock){+.+.+.}
    
    and interrupts could create inverse lock ordering between them.
    
    [ 1702.984675]
    other info that might help us debug this:
    [ 1702.985524] Chain exists of:
      &delayed_node->mutex --> &found->groups_sem --> &fs_info->dev_replace.lock
    
    [ 1702.986799]  Possible interrupt unsafe locking scenario:
    
    [ 1702.987681]        CPU0                    CPU1
    [ 1702.988137]        ----                    ----
    [ 1702.988598]   lock(&fs_info->dev_replace.lock);
    [ 1702.989069]                                local_irq_disable();
    [ 1702.989534]                                lock(&delayed_node->mutex);
    [ 1702.990038]                                lock(&found->groups_sem);
    [ 1702.990494]   <Interrupt>
    [ 1702.990938]     lock(&delayed_node->mutex);
    [ 1702.991407]
     *** DEADLOCK ***
    
    It is because the btrfs_kobj_{add/rm}_device() will call memory
    allocation with GFP_KERNEL,
    which may flush fs page cache to free space, waiting for it self to do
    the commit, causing the deadlock.
    
    To solve the problem, move btrfs_kobj_{add/rm}_device() out of the
    dev_replace lock range, also involing split the
    btrfs_rm_dev_replace_srcdev() function into remove and free parts.
    
    Now only btrfs_rm_dev_replace_remove_srcdev() is called in dev_replace
    lock range, and kobj_{add/rm} and btrfs_rm_dev_replace_free_srcdev() are
    called out of the lock range.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 08980fa23039..4cc00e64427e 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -448,8 +448,10 @@ void btrfs_init_devices_late(struct btrfs_fs_info *fs_info);
 int btrfs_init_dev_stats(struct btrfs_fs_info *fs_info);
 int btrfs_run_dev_stats(struct btrfs_trans_handle *trans,
 			struct btrfs_fs_info *fs_info);
-void btrfs_rm_dev_replace_srcdev(struct btrfs_fs_info *fs_info,
-				 struct btrfs_device *srcdev);
+void btrfs_rm_dev_replace_remove_srcdev(struct btrfs_fs_info *fs_info,
+					struct btrfs_device *srcdev);
+void btrfs_rm_dev_replace_free_srcdev(struct btrfs_fs_info *fs_info,
+				      struct btrfs_device *srcdev);
 void btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,
 				      struct btrfs_device *tgtdev);
 void btrfs_init_dev_replace_tgtdev_for_resume(struct btrfs_fs_info *fs_info,

commit 47ab2a6c689913db23ccae38349714edf8365e0a
Author: Josef Bacik <jbacik@fb.com>
Date:   Thu Sep 18 11:20:02 2014 -0400

    Btrfs: remove empty block groups automatically
    
    One problem that has plagued us is that a user will use up all of his space with
    data, remove a bunch of that data, and then try to create a bunch of small files
    and run out of space.  This happens because all the chunks were allocated for
    data since the metadata requirements were so low.  But now there's a bunch of
    empty data block groups and not enough metadata space to do anything.  This
    patch solves this problem by automatically deleting empty block groups.  If we
    notice the used count go down to 0 when deleting or on mount notice that a block
    group has a used count of 0 then we will queue it to be deleted.
    
    When the cleaner thread runs we will double check to make sure the block group
    is still empty and then we will delete it.  This patch has the side effect of no
    longer having a bunch of BUG_ON()'s in the chunk delete code, which will be
    helpful for both this and relocate.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 91998bc0b4c4..08980fa23039 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -463,6 +463,8 @@ unsigned long btrfs_full_stripe_len(struct btrfs_root *root,
 int btrfs_finish_chunk_alloc(struct btrfs_trans_handle *trans,
 				struct btrfs_root *extent_root,
 				u64 chunk_offset, u64 chunk_size);
+int btrfs_remove_chunk(struct btrfs_trans_handle *trans,
+		       struct btrfs_root *root, u64 chunk_offset);
 
 static inline int btrfs_dev_stats_dirty(struct btrfs_device *dev)
 {

commit c1dc08967f69c6b5067f8302c600f6628123f3bf
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Fri Sep 12 18:43:56 2014 +0800

    Btrfs: do file data check by sub-bio's self
    
    Direct IO splits the original bio to several sub-bios because of the limit of
    raid stripe, and the filesystem will wait for all sub-bios and then run final
    end io process.
    
    But it was very hard to implement the data repair when dio read failure happens,
    because at the final end io function, we didn't know which mirror the data was
    read from. So in order to implement the data repair, we have to move the file data
    check in the final end io function to the sub-bio end io function, in which we can
    get the mirror number of the device we access. This patch did this work as the
    first step of the direct io data repair implementation.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 2b37da3dd408..91998bc0b4c4 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -268,8 +268,9 @@ struct btrfs_fs_devices {
  */
 typedef void (btrfs_io_bio_end_io_t) (struct btrfs_io_bio *bio, int err);
 struct btrfs_io_bio {
-	unsigned long mirror_num;
-	unsigned long stripe_index;
+	unsigned int mirror_num;
+	unsigned int stripe_index;
+	u64 logical;
 	u8 *csum;
 	u8 csum_inline[BTRFS_BIO_INLINE_CSUM_SIZE];
 	u8 *csum_allocated;

commit 67a2c45ee7f4f250458279a2e1244679c5d9735c
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Sep 3 21:35:43 2014 +0800

    Btrfs: fix use-after-free problem of the device during device replace
    
    The problem is:
            Task0(device scan task)         Task1(device replace task)
            scan_one_device()
            mutex_lock(&uuid_mutex)
            device = find_device()
                                            mutex_lock(&device_list_mutex)
                                            lock_chunk()
                                            rm_and_free_source_device
                                            unlock_chunk()
                                            mutex_unlock(&device_list_mutex)
            check device
    
    Destroying the target device if device replace fails also has the same problem.
    
    We fix this problem by locking uuid_mutex during destroying source device or
    target device, just like the device remove operation.
    
    It is a temporary solution, we can fix this problem and make the code more
    clear by atomic counter in the future.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 76600a3fedbe..2b37da3dd408 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -24,6 +24,8 @@
 #include <linux/btrfs.h>
 #include "async-thread.h"
 
+extern struct mutex uuid_mutex;
+
 #define BTRFS_STRIPE_LEN	(64 * 1024)
 
 struct buffer_head;

commit 7cc8e58d53cd2295c3c1cee7b503bd1790ea4486
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Sep 3 21:35:38 2014 +0800

    Btrfs: fix unprotected device's variants on 32bits machine
    
    ->total_bytes,->disk_total_bytes,->bytes_used is protected by chunk
    lock when we change them, but sometimes we read them without any lock,
    and we might get unexpected value. We fix this problem like inode's
    i_size.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index f79d532fedb0..76600a3fedbe 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -32,6 +32,19 @@ struct btrfs_pending_bios {
 	struct bio *tail;
 };
 
+/*
+ * Use sequence counter to get consistent device stat data on
+ * 32-bit processors.
+ */
+#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+#include <linux/seqlock.h>
+#define __BTRFS_NEED_DEVICE_DATA_ORDERED
+#define btrfs_device_data_ordered_init(device)	\
+	seqcount_init(&device->data_seqcount)
+#else
+#define btrfs_device_data_ordered_init(device) do { } while (0)
+#endif
+
 struct btrfs_device {
 	struct list_head dev_list;
 	struct list_head dev_alloc_list;
@@ -61,6 +74,10 @@ struct btrfs_device {
 	int can_discard;
 	int is_tgtdev_for_dev_replace;
 
+#ifdef __BTRFS_NEED_DEVICE_DATA_ORDERED
+	seqcount_t data_seqcount;
+#endif
+
 	/* the internal btrfs device id */
 	u64 devid;
 
@@ -133,6 +150,73 @@ struct btrfs_device {
 	atomic_t dev_stat_values[BTRFS_DEV_STAT_VALUES_MAX];
 };
 
+/*
+ * If we read those variants at the context of their own lock, we needn't
+ * use the following helpers, reading them directly is safe.
+ */
+#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+#define BTRFS_DEVICE_GETSET_FUNCS(name)					\
+static inline u64							\
+btrfs_device_get_##name(const struct btrfs_device *dev)			\
+{									\
+	u64 size;							\
+	unsigned int seq;						\
+									\
+	do {								\
+		seq = read_seqcount_begin(&dev->data_seqcount);		\
+		size = dev->name;					\
+	} while (read_seqcount_retry(&dev->data_seqcount, seq));	\
+	return size;							\
+}									\
+									\
+static inline void							\
+btrfs_device_set_##name(struct btrfs_device *dev, u64 size)		\
+{									\
+	preempt_disable();						\
+	write_seqcount_begin(&dev->data_seqcount);			\
+	dev->name = size;						\
+	write_seqcount_end(&dev->data_seqcount);			\
+	preempt_enable();						\
+}
+#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPT)
+#define BTRFS_DEVICE_GETSET_FUNCS(name)					\
+static inline u64							\
+btrfs_device_get_##name(const struct btrfs_device *dev)			\
+{									\
+	u64 size;							\
+									\
+	preempt_disable();						\
+	size = dev->name;						\
+	preempt_enable();						\
+	return size;							\
+}									\
+									\
+static inline void							\
+btrfs_device_set_##name(struct btrfs_device *dev, u64 size)		\
+{									\
+	preempt_disable();						\
+	dev->name = size;						\
+	preempt_enable();						\
+}
+#else
+#define BTRFS_DEVICE_GETSET_FUNCS(name)					\
+static inline u64							\
+btrfs_device_get_##name(const struct btrfs_device *dev)			\
+{									\
+	return dev->name;						\
+}									\
+									\
+static inline void							\
+btrfs_device_set_##name(struct btrfs_device *dev, u64 size)		\
+{									\
+	dev->name = size;						\
+}
+#endif
+
+BTRFS_DEVICE_GETSET_FUNCS(total_bytes);
+BTRFS_DEVICE_GETSET_FUNCS(disk_total_bytes);
+BTRFS_DEVICE_GETSET_FUNCS(bytes_used);
+
 struct btrfs_fs_devices {
 	u8 fsid[BTRFS_FSID_SIZE]; /* FS specific uuid */
 

commit ce7213c70c37e3a66bc0b50c45edcbfea505f62f
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Sep 3 21:35:34 2014 +0800

    Btrfs: fix wrong device bytes_used in the super block
    
    device->bytes_used will be changed when allocating a new chunk, and
    disk_total_size will be changed if resizing is successful.
    Meanwhile, the on-disk super blocks of the previous transaction
    might not be updated. Considering the consistency of the metadata
    in the previous transaction, We should use the size in the previous
    transaction to check if the super block is beyond the boundary
    of the device.
    
    Though it is not big problem because we don't use it now, but anyway
    it is better that we make it be consistent with the common metadata,
    maybe we will use it in the future.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index b30d018fa359..f79d532fedb0 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -95,6 +95,8 @@ struct btrfs_device {
 	 */
 	u64 commit_total_bytes;
 
+	/* bytes used on the current transaction */
+	u64 commit_bytes_used;
 	/*
 	 * used to manage the device which is resized
 	 *
@@ -420,4 +422,6 @@ static inline void btrfs_dev_stat_reset(struct btrfs_device *dev,
 }
 
 void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info);
+void btrfs_update_commit_device_bytes_used(struct btrfs_root *root,
+					struct btrfs_transaction *transaction);
 #endif

commit 935e5cc935bcbf9b3d0dd59fed7dbc0f2ebca6bc
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Sep 3 21:35:33 2014 +0800

    Btrfs: fix wrong disk size when writing super blocks
    
    total_size will be changed when resizing a device, and disk_total_size
    will be changed if resizing is successful. Meanwhile, the on-disk super
    blocks of the previous transaction might not be updated. Considering
    the consistency of the metadata in the previous transaction, We should
    use the size in the previous transaction to check if the super block is
    beyond the boundary of the device. Fix it.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index e15f2886d33e..b30d018fa359 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -87,6 +87,21 @@ struct btrfs_device {
 	/* physical drive uuid (or lvm uuid) */
 	u8 uuid[BTRFS_UUID_SIZE];
 
+	/*
+	 * size of the device on the current transaction
+	 *
+	 * This variant is update when committing the transaction,
+	 * and protected by device_list_mutex
+	 */
+	u64 commit_total_bytes;
+
+	/*
+	 * used to manage the device which is resized
+	 *
+	 * It is protected by chunk_lock.
+	 */
+	struct list_head resized_list;
+
 	/* for sending down flush barriers */
 	int nobarriers;
 	struct bio *flush_bio;
@@ -136,6 +151,7 @@ struct btrfs_fs_devices {
 	struct mutex device_list_mutex;
 	struct list_head devices;
 
+	struct list_head resized_devices;
 	/* devices not currently being allocated */
 	struct list_head alloc_list;
 	struct list_head list;
@@ -402,4 +418,6 @@ static inline void btrfs_dev_stat_reset(struct btrfs_device *dev,
 {
 	btrfs_dev_stat_set(dev, index, 0);
 }
+
+void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info);
 #endif

commit 1c43366d3b3f0fa6c6e81aaf3aa18e0550245dad
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Sep 3 21:35:32 2014 +0800

    Btrfs: fix unprotected assignment of the target device
    
    We didn't protect the assignment of the target device, it might cause the
    problem that the super block update was skipped because we might find wrong
    size of the target device during the assignment. Fix it by moving the
    assignment sentences into the initialization function of the target device.
    And there is another merit that we can check if the target device is suitable
    more early.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 37f8bff97df1..e15f2886d33e 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -322,6 +322,7 @@ struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_root *root, char *path);
 int btrfs_init_dev_replace_tgtdev(struct btrfs_root *root, char *device_path,
+				  struct btrfs_device *srcdev,
 				  struct btrfs_device **device_out);
 int btrfs_balance(struct btrfs_balance_control *bctl,
 		  struct btrfs_ioctl_balance_args *bargs);

commit 90180da42c38a83b050452aa555d3d2df6ae2ad4
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Sep 3 21:35:30 2014 +0800

    Btrfs: cleanup unused num_can_discard in fs_devices
    
    The member variants - num_can_discard - of fs_devices structure
    are set, but no one use them to do anything. so remove them.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index e894ac696889..37f8bff97df1 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -124,7 +124,6 @@ struct btrfs_fs_devices {
 	u64 rw_devices;
 	u64 missing_devices;
 	u64 total_rw_bytes;
-	u64 num_can_discard;
 	u64 total_devices;
 	struct block_device *latest_bdev;
 

commit 443f24fee731703345e2e6eec8177bb7b7d094c6
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Thu Jul 24 11:37:15 2014 +0800

    Btrfs: cleanup unused latest_devid and latest_trans in fs_devices
    
    The member variants - latest_devid and latest_trans - of fs_devices structure
    are set, but no one use them to do anything. so remove them.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 90d4fa80bd58..e894ac696889 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -119,9 +119,6 @@ struct btrfs_device {
 struct btrfs_fs_devices {
 	u8 fsid[BTRFS_FSID_SIZE]; /* FS specific uuid */
 
-	/* the device with this id has the most recent copy of the super */
-	u64 latest_devid;
-	u64 latest_trans;
 	u64 num_devices;
 	u64 open_devices;
 	u64 rw_devices;

commit 6ba40b615f6e2aac40c24b649c0170d43ae19165
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Thu Jul 24 11:37:12 2014 +0800

    Btrfs: update the comment of total_bytes and disk_total_bytes of btrfs_devie
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 0defd232e290..90d4fa80bd58 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -64,10 +64,10 @@ struct btrfs_device {
 	/* the internal btrfs device id */
 	u64 devid;
 
-	/* size of the device */
+	/* size of the device in memory */
 	u64 total_bytes;
 
-	/* size of the disk */
+	/* size of the device on disk */
 	u64 disk_total_bytes;
 
 	/* bytes used */

commit addc3fa74e5bcfabc0766f934a8895d1f9f6a67c
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Thu Jul 24 11:37:11 2014 +0800

    Btrfs: Fix the problem that the dirty flag of dev stats is cleared
    
    The io error might happen during writing out the device stats, and the
    device stats information and dirty flag would be update at that time,
    but the current code didn't consider this case, just clear the dirty
    flag, it would cause that we forgot to write out the new device stats
    information. Fix it.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 6fcc8eae7834..0defd232e290 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -110,7 +110,9 @@ struct btrfs_device {
 	/* disk I/O failure stats. For detailed description refer to
 	 * enum btrfs_dev_stat_values in ioctl.h */
 	int dev_stats_valid;
-	int dev_stats_dirty; /* counters need to be written to disk */
+
+	/* Counter to record the change of device stats */
+	atomic_t dev_stats_ccnt;
 	atomic_t dev_stat_values[BTRFS_DEV_STAT_VALUES_MAX];
 };
 
@@ -359,11 +361,18 @@ unsigned long btrfs_full_stripe_len(struct btrfs_root *root,
 int btrfs_finish_chunk_alloc(struct btrfs_trans_handle *trans,
 				struct btrfs_root *extent_root,
 				u64 chunk_offset, u64 chunk_size);
+
+static inline int btrfs_dev_stats_dirty(struct btrfs_device *dev)
+{
+	return atomic_read(&dev->dev_stats_ccnt);
+}
+
 static inline void btrfs_dev_stat_inc(struct btrfs_device *dev,
 				      int index)
 {
 	atomic_inc(dev->dev_stat_values + index);
-	dev->dev_stats_dirty = 1;
+	smp_mb__before_atomic();
+	atomic_inc(&dev->dev_stats_ccnt);
 }
 
 static inline int btrfs_dev_stat_read(struct btrfs_device *dev,
@@ -378,7 +387,8 @@ static inline int btrfs_dev_stat_read_and_reset(struct btrfs_device *dev,
 	int ret;
 
 	ret = atomic_xchg(dev->dev_stat_values + index, 0);
-	dev->dev_stats_dirty = 1;
+	smp_mb__before_atomic();
+	atomic_inc(&dev->dev_stats_ccnt);
 	return ret;
 }
 
@@ -386,7 +396,8 @@ static inline void btrfs_dev_stat_set(struct btrfs_device *dev,
 				      int index, unsigned long val)
 {
 	atomic_set(dev->dev_stat_values + index, val);
-	dev->dev_stats_dirty = 1;
+	smp_mb__before_atomic();
+	atomic_inc(&dev->dev_stats_ccnt);
 }
 
 static inline void btrfs_dev_stat_reset(struct btrfs_device *dev,

commit d5ee37bcb1dff9c1d1cac5f7e5752309f1ff66b6
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Thu Jul 24 11:37:10 2014 +0800

    Btrfs: make the device lock and its protected data in the same cacheline
    
    The lock in btrfs_device structure was far away from its protected data, it would
    make CPU load the cache line twice when we accessed them, move them together.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 2aaa00c47816..6fcc8eae7834 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -36,30 +36,31 @@ struct btrfs_device {
 	struct list_head dev_list;
 	struct list_head dev_alloc_list;
 	struct btrfs_fs_devices *fs_devices;
+
 	struct btrfs_root *dev_root;
 
+	struct rcu_string *name;
+
+	u64 generation;
+
+	spinlock_t io_lock ____cacheline_aligned;
+	int running_pending;
 	/* regular prio bios */
 	struct btrfs_pending_bios pending_bios;
 	/* WRITE_SYNC bios */
 	struct btrfs_pending_bios pending_sync_bios;
 
-	u64 generation;
-	int running_pending;
+	struct block_device *bdev;
+
+	/* the mode sent to blkdev_get */
+	fmode_t mode;
+
 	int writeable;
 	int in_fs_metadata;
 	int missing;
 	int can_discard;
 	int is_tgtdev_for_dev_replace;
 
-	spinlock_t io_lock;
-	/* the mode sent to blkdev_get */
-	fmode_t mode;
-
-	struct block_device *bdev;
-
-
-	struct rcu_string *name;
-
 	/* the internal btrfs device id */
 	u64 devid;
 
@@ -83,7 +84,6 @@ struct btrfs_device {
 	/* minimal io size for this device */
 	u32 sector_size;
 
-
 	/* physical drive uuid (or lvm uuid) */
 	u8 uuid[BTRFS_UUID_SIZE];
 
@@ -107,7 +107,6 @@ struct btrfs_device {
 	struct radix_tree_root reada_zones;
 	struct radix_tree_root reada_extents;
 
-
 	/* disk I/O failure stats. For detailed description refer to
 	 * enum btrfs_dev_stat_values in ioctl.h */
 	int dev_stats_valid;

commit c55f13964008bfea7c5bee268f28b699cbad7f00
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Thu Jun 19 10:42:54 2014 +0800

    Btrfs: fix deadlock when mounting a degraded fs
    
    The deadlock happened when we mount degraded filesystem, the reproduced
    steps are following:
     # mkfs.btrfs -f -m raid1 -d raid1 <dev0> <dev1>
     # echo 1 > /sys/block/`basename <dev0>`/device/delete
     # mount -o degraded <dev1> <mnt>
    
    The reason was that the counter -- bi_remaining was wrong. If the missing
    or unwriteable device was the last device in the mapping array, we would
    not submit the original bio, so we shouldn't increase bi_remaining of it
    in btrfs_end_bio(), or we would skip the final endio handle.
    
    Fix this problem by adding a flag into btrfs bio structure. If we submit
    the original bio, we will set the flag, and we increase bi_remaining counter,
    or we don't.
    
    Though there is another way to fix it -- decrease bi_remaining counter of the
    original bio when we make sure the original bio is not submitted, this method
    need add more check and is easy to make mistake.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 1a15bbeb65e2..2aaa00c47816 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -190,11 +190,14 @@ struct btrfs_bio_stripe {
 struct btrfs_bio;
 typedef void (btrfs_bio_end_io_t) (struct btrfs_bio *bio, int err);
 
+#define BTRFS_BIO_ORIG_BIO_SUBMITTED	0x1
+
 struct btrfs_bio {
 	atomic_t stripes_pending;
 	struct btrfs_fs_info *fs_info;
 	bio_end_io_t *end_io;
 	struct bio *orig_bio;
+	unsigned long flags;
 	void *private;
 	atomic_t error;
 	int max_errors;

commit 7d824b6f9cf28917d8a05891ef423fb0e4e34c69
Author: David Sterba <dsterba@suse.cz>
Date:   Wed May 7 17:37:51 2014 +0200

    btrfs: balance filter: add limit of processed chunks
    
    This started as debugging helper, to watch the effects of converting
    between raid levels on multiple devices, but could be useful standalone.
    
    In my case the usage filter was not finegrained enough and led to
    converting too many chunks at once. Another example use is in connection
    with drange+devid or vrange filters that allow to work with a specific
    chunk or even with a chunk on a given device.
    
    The limit filter applies last, the value of 0 means no limiting.
    
    CC: Ilya Dryomov <idryomov@gmail.com>
    CC: Hugo Mills <hugo@carfax.org.uk>
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 80754f9dd3df..1a15bbeb65e2 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -255,6 +255,7 @@ struct map_lookup {
 #define BTRFS_BALANCE_ARGS_DEVID	(1ULL << 2)
 #define BTRFS_BALANCE_ARGS_DRANGE	(1ULL << 3)
 #define BTRFS_BALANCE_ARGS_VRANGE	(1ULL << 4)
+#define BTRFS_BALANCE_ARGS_LIMIT	(1ULL << 5)
 
 /*
  * Profile changing flags.  When SOFT is set we won't relocate chunk if

commit d458b0540ebd728b4d6ef47cc5ef0dbfd4dd361a
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Fri Feb 28 10:46:19 2014 +0800

    btrfs: Cleanup the "_struct" suffix in btrfs_workequeue
    
    Since the "_struct" suffix is mainly used for distinguish the differnt
    btrfs_work between the original and the newly created one,
    there is no need using the suffix since all btrfs_workers are changed
    into btrfs_workqueue.
    
    Also this patch fixed some codes whose code style is changed due to the
    too long "_struct" suffix.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Tested-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 5d9a03773ca6..80754f9dd3df 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -95,7 +95,7 @@ struct btrfs_device {
 	/* per-device scrub information */
 	struct scrub_ctx *scrub_device;
 
-	struct btrfs_work_struct work;
+	struct btrfs_work work;
 	struct rcu_head rcu;
 	struct work_struct rcu_work;
 

commit a8c93d4ef6f6727764a61a2ee1c1878a755637c5
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Fri Feb 28 10:46:08 2014 +0800

    btrfs: Replace fs_info->submit_workers with btrfs_workqueue.
    
    Much like the fs_info->workers, replace the fs_info->submit_workers
    use the same btrfs_workqueue.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Tested-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 80754f9dd3df..5d9a03773ca6 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -95,7 +95,7 @@ struct btrfs_device {
 	/* per-device scrub information */
 	struct scrub_ctx *scrub_device;
 
-	struct btrfs_work work;
+	struct btrfs_work_struct work;
 	struct rcu_head rcu;
 	struct work_struct rcu_work;
 

commit c404e0dc2c843b154f9a36c3aec10d0a715d88eb
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Thu Jan 30 16:46:55 2014 +0800

    Btrfs: fix use-after-free in the finishing procedure of the device replace
    
    During device replace test, we hit a null pointer deference (It was very easy
    to reproduce it by running xfstests' btrfs/011 on the devices with the virtio
    scsi driver). There were two bugs that caused this problem:
    - We might allocate new chunks on the replaced device after we updated
      the mapping tree. And we forgot to replace the source device in those
      mapping of the new chunks.
    - We might get the mapping information which including the source device
      before the mapping information update. And then submit the bio which was
      based on that mapping information after we freed the source device.
    
    For the first bug, we can fix it by doing mapping tree update and source
    device remove in the same context of the chunk mutex. The chunk mutex is
    used to protect the allocable device list, the above method can avoid
    the new chunk allocation, and after we remove the source device, all
    the new chunks will be allocated on the new device. So it can fix
    the first bug.
    
    For the second bug, we need make sure all flighting bios are finished and
    no new bios are produced during we are removing the source device. To fix
    this problem, we introduced a global @bio_counter, we not only inc/dec
    @bio_counter outsize of map_blocks, but also inc it before submitting bio
    and dec @bio_counter when ending bios.
    
    Since Raid56 is a little different and device replace dosen't support raid56
    yet, it is not addressed in the patch and I add comments to make sure we will
    fix it in the future.
    
    Reported-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Signed-off-by: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fb.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 8b3cd142b373..80754f9dd3df 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -192,6 +192,7 @@ typedef void (btrfs_bio_end_io_t) (struct btrfs_bio *bio, int err);
 
 struct btrfs_bio {
 	atomic_t stripes_pending;
+	struct btrfs_fs_info *fs_info;
 	bio_end_io_t *end_io;
 	struct bio *orig_bio;
 	void *private;

commit 3c45bfc1528ccb8b94c06d5740854bb75f8a92fb
Author: Dulshani Gunawardhana <dulshani.gunawardhana89@gmail.com>
Date:   Thu Oct 31 09:57:33 2013 +0530

    btrfs: Pack struct btrfs_device
    
    Pack the structure btrfs_device in volumes.h to eliminate holes detected
    by pahole, thus reducing binary memory footprint.
    
    Signed-off-by: Dulshani Gunawardhana <dulshani.gunawardhana89@gmail.com>
    Reviewed-by: Zach Brown <zab@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 49e0ff01143f..8b3cd142b373 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -43,9 +43,8 @@ struct btrfs_device {
 	/* WRITE_SYNC bios */
 	struct btrfs_pending_bios pending_sync_bios;
 
-	int running_pending;
 	u64 generation;
-
+	int running_pending;
 	int writeable;
 	int in_fs_metadata;
 	int missing;
@@ -53,11 +52,11 @@ struct btrfs_device {
 	int is_tgtdev_for_dev_replace;
 
 	spinlock_t io_lock;
+	/* the mode sent to blkdev_get */
+	fmode_t mode;
 
 	struct block_device *bdev;
 
-	/* the mode sent to blkdev_get */
-	fmode_t mode;
 
 	struct rcu_string *name;
 
@@ -78,16 +77,21 @@ struct btrfs_device {
 
 	/* optimal io width for this device */
 	u32 io_width;
+	/* type and info about this device */
+	u64 type;
 
 	/* minimal io size for this device */
 	u32 sector_size;
 
-	/* type and info about this device */
-	u64 type;
 
 	/* physical drive uuid (or lvm uuid) */
 	u8 uuid[BTRFS_UUID_SIZE];
 
+	/* for sending down flush barriers */
+	int nobarriers;
+	struct bio *flush_bio;
+	struct completion flush_wait;
+
 	/* per-device scrub information */
 	struct scrub_ctx *scrub_device;
 
@@ -103,10 +107,6 @@ struct btrfs_device {
 	struct radix_tree_root reada_zones;
 	struct radix_tree_root reada_extents;
 
-	/* for sending down flush barriers */
-	struct bio *flush_bio;
-	struct completion flush_wait;
-	int nobarriers;
 
 	/* disk I/O failure stats. For detailed description refer to
 	 * enum btrfs_dev_stat_values in ioctl.h */

commit 9b011adfe14977fcda977234609d43ca52463a3d
Author: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
Date:   Fri Oct 25 19:12:02 2013 +0800

    Btrfs: remove scrub_super_lock holding in btrfs_sync_log()
    
    Originally, we introduced scrub_super_lock to synchronize
    tree log code with scrubbing super.
    
    However we can replace scrub_super_lock with device_list_mutex,
    because writing super will hold this mutex, this will reduce an extra
    lock holding when writing supers in sync log code.
    
    Signed-off-by: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index b72f540c8b29..49e0ff01143f 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -132,7 +132,9 @@ struct btrfs_fs_devices {
 
 	/* all of the devices in the FS, protected by a mutex
 	 * so we can safely walk it to write out the supers without
-	 * worrying about add/remove by the multi-device code
+	 * worrying about add/remove by the multi-device code.
+	 * Scrubbing super can kick off supers writing by holding
+	 * this mutex lock.
 	 */
 	struct mutex device_list_mutex;
 	struct list_head devices;

commit 12bd2fc0d2f589f9605b8f497eee2e7724f3af24
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Fri Aug 23 13:20:17 2013 +0300

    Btrfs: add btrfs_alloc_device and switch to it
    
    Currently btrfs_device is allocated ad-hoc in a few different places,
    and as a result not all fields are initialized properly.  In particular,
    readahead state is only initialized in device_list_add (at scan time),
    and not in btrfs_init_new_device (when the new device is added with
    'btrfs dev add').  Fix this by adding an allocation helper and switch
    everybody but __btrfs_close_devices to it.  (__btrfs_close_devices is
    dealt with in a later commit.)
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index d98b942c3896..b72f540c8b29 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -305,6 +305,9 @@ void btrfs_close_extra_devices(struct btrfs_fs_info *fs_info,
 int btrfs_find_device_missing_or_by_path(struct btrfs_root *root,
 					 char *device_path,
 					 struct btrfs_device **device);
+struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,
+					const u64 *devid,
+					const u8 *uuid);
 int btrfs_rm_device(struct btrfs_root *root, char *device_path);
 void btrfs_cleanup_fs_uuids(void);
 int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len);

commit 70f801754728017ebc909d603c69255dc1e6f06f
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Thu Aug 15 17:11:23 2013 +0200

    Btrfs: check UUID tree during mount if required
    
    If the filesystem was mounted with an old kernel that was not
    aware of the UUID tree, this is detected by looking at the
    uuid_tree_generation field of the superblock (similar to how
    the free space cache is doing it). If a mismatch is detected
    at mount time, a thread is started that does two things:
    1. Iterate through the UUID tree, check each entry, delete those
       entries that are not valid anymore (i.e., the subvol does not
       exist anymore or the value changed).
    2. Iterate through the root tree, for each found subvolume, add
       the UUID tree entries for the subvolume (if they are not
       already there).
    
    This mechanism is also used to handle and repair errors that
    happened during the initial creation and filling of the tree.
    The update of the uuid_tree_generation field (which indicates
    that the state of the UUID tree is up to date) is blocked until
    all create and repair operations are successfully completed.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 7071b2988305..d98b942c3896 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -323,6 +323,7 @@ int btrfs_recover_balance(struct btrfs_fs_info *fs_info);
 int btrfs_pause_balance(struct btrfs_fs_info *fs_info);
 int btrfs_cancel_balance(struct btrfs_fs_info *fs_info);
 int btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info);
+int btrfs_check_uuid_tree(struct btrfs_fs_info *fs_info);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
 int find_free_dev_extent(struct btrfs_trans_handle *trans,
 			 struct btrfs_device *device, u64 num_bytes,

commit f7a81ea4cc6bdb51d8267d2f3ff485f0b4070074
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Thu Aug 15 17:11:19 2013 +0200

    Btrfs: create UUID tree if required
    
    This tree is not created by mkfs.btrfs. Therefore when a filesystem
    is mounted writable and the UUID tree does not exist, this tree is
    created if required. The tree is also added to the fs_info structure
    and initialized, but this commit does not yet read or write UUID tree
    elements.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 08c44d9059b1..7071b2988305 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -322,6 +322,7 @@ int btrfs_resume_balance_async(struct btrfs_fs_info *fs_info);
 int btrfs_recover_balance(struct btrfs_fs_info *fs_info);
 int btrfs_pause_balance(struct btrfs_fs_info *fs_info);
 int btrfs_cancel_balance(struct btrfs_fs_info *fs_info);
+int btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
 int find_free_dev_extent(struct btrfs_trans_handle *trans,
 			 struct btrfs_device *device, u64 num_bytes,

commit facc8a2247340a9735fe8cc123c5da2102f5ef1b
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Thu Jul 25 19:22:34 2013 +0800

    Btrfs: don't cache the csum value into the extent state tree
    
    Before applying this patch, we cached the csum value into the extent state
    tree when reading some data from the disk, this operation increased the lock
    contention of the state tree.
    
    Now, we just store the csum value into the bio structure or other unshared
    structure, so we can reduce the lock contention.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 86705583480d..08c44d9059b1 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -152,6 +152,8 @@ struct btrfs_fs_devices {
 	int rotating;
 };
 
+#define BTRFS_BIO_INLINE_CSUM_SIZE	64
+
 /*
  * we need the mirror number and stripe index to be passed around
  * the call chain while we are processing end_io (especially errors).
@@ -161,9 +163,14 @@ struct btrfs_fs_devices {
  * we allocate are actually btrfs_io_bios.  We'll cram as much of
  * struct btrfs_bio as we can into this over time.
  */
+typedef void (btrfs_io_bio_end_io_t) (struct btrfs_io_bio *bio, int err);
 struct btrfs_io_bio {
 	unsigned long mirror_num;
 	unsigned long stripe_index;
+	u8 *csum;
+	u8 csum_inline[BTRFS_BIO_INLINE_CSUM_SIZE];
+	u8 *csum_allocated;
+	btrfs_io_bio_end_io_t *end_io;
 	struct bio bio;
 };
 

commit 6df9a95e63395f595d0d1eb5d561dd6c91c40270
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Thu Jun 27 13:22:46 2013 -0400

    Btrfs: make the chunk allocator completely tree lockless
    
    When adjusting the enospc rules for relocation I ran into a deadlock because we
    were relocating the only system chunk and that forced us to try and allocate a
    new system chunk while holding locks in the chunk tree, which caused us to
    deadlock.  To fix this I've moved all of the dev extent addition and chunk
    addition out to the delayed chunk completion stuff.  We still keep the in-memory
    stuff which makes sure everything is consistent.
    
    One change I had to make was to search the commit root of the device tree to
    find a free dev extent, and hold onto any chunk em's that we allocated in that
    transaction so we do not allocate the same dev extent twice.  This has the side
    effect of fixing a bug with balance that has been there ever since balance
    existed.  Basically you can free a block group and it's dev extent and then
    immediately allocate that dev extent for a new block group and write stuff to
    that dev extent, all within the same transaction.  So if you happen to crash
    during a balance you could come back to a completely broken file system.  This
    patch should keep these sort of things from happening in the future since we
    won't be able to allocate free'd dev extents until after the transaction
    commits.  This has passed all of the xfstests and my super annoying stress test
    followed by a balance.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 857acd34ccde..86705583480d 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -316,7 +316,8 @@ int btrfs_recover_balance(struct btrfs_fs_info *fs_info);
 int btrfs_pause_balance(struct btrfs_fs_info *fs_info);
 int btrfs_cancel_balance(struct btrfs_fs_info *fs_info);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
-int find_free_dev_extent(struct btrfs_device *device, u64 num_bytes,
+int find_free_dev_extent(struct btrfs_trans_handle *trans,
+			 struct btrfs_device *device, u64 num_bytes,
 			 u64 *start, u64 *max_avail);
 void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index);
 int btrfs_get_dev_stats(struct btrfs_root *root,
@@ -337,6 +338,9 @@ int btrfs_is_parity_mirror(struct btrfs_mapping_tree *map_tree,
 unsigned long btrfs_full_stripe_len(struct btrfs_root *root,
 				    struct btrfs_mapping_tree *map_tree,
 				    u64 logical);
+int btrfs_finish_chunk_alloc(struct btrfs_trans_handle *trans,
+				struct btrfs_root *extent_root,
+				u64 chunk_offset, u64 chunk_size);
 static inline void btrfs_dev_stat_inc(struct btrfs_device *dev,
 				      int index)
 {

commit cb517eabba4f109810dba2e5f37b0dcf22103065
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed May 15 07:48:19 2013 +0000

    Btrfs: cleanup the similar code of the fs root read
    
    There are several functions whose code is similar, such as
      btrfs_find_last_root()
      btrfs_read_fs_root_no_radix()
    
    Besides that, some functions are invoked twice, it is unnecessary,
    for example, we are sure that all roots which is found in
      btrfs_find_orphan_roots()
    have their orphan items, so it is unnecessary to check the orphan
    item again.
    
    So cleanup it.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index f6247e2a47f7..857acd34ccde 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -321,6 +321,7 @@ int find_free_dev_extent(struct btrfs_device *device, u64 num_bytes,
 void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index);
 int btrfs_get_dev_stats(struct btrfs_root *root,
 			struct btrfs_ioctl_get_dev_stats *stats);
+void btrfs_init_devices_late(struct btrfs_fs_info *fs_info);
 int btrfs_init_dev_stats(struct btrfs_fs_info *fs_info);
 int btrfs_run_dev_stats(struct btrfs_trans_handle *trans,
 			struct btrfs_fs_info *fs_info);

commit 9be3395bcd4ad4af76476ac38152b4cafa6b6159
Author: Chris Mason <chris.mason@fusionio.com>
Date:   Fri May 17 18:30:14 2013 -0400

    Btrfs: use a btrfs bioset instead of abusing bio internals
    
    Btrfs has been pointer tagging bi_private and using bi_bdev
    to store the stripe index and mirror number of failed IOs.
    
    As bios bubble back up through the call chain, we use these
    to decide if and how to retry our IOs.  They are also used
    to count IO failures on a per device basis.
    
    Recently a bio tracepoint was added lead to crashes because
    we were abusing bi_bdev.
    
    This commit adds a btrfs bioset, and creates explicit fields
    for the mirror number and stripe index.  The plan is to
    extend this structure for all of the fields currently in
    struct btrfs_bio, which will mean one less kmalloc in
    our IO path.
    
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>
    Reported-by: Tejun Heo <tj@kernel.org>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 845ccbb0d2e3..f6247e2a47f7 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -152,6 +152,26 @@ struct btrfs_fs_devices {
 	int rotating;
 };
 
+/*
+ * we need the mirror number and stripe index to be passed around
+ * the call chain while we are processing end_io (especially errors).
+ * Really, what we need is a btrfs_bio structure that has this info
+ * and is properly sized with its stripe array, but we're not there
+ * quite yet.  We have our own btrfs bioset, and all of the bios
+ * we allocate are actually btrfs_io_bios.  We'll cram as much of
+ * struct btrfs_bio as we can into this over time.
+ */
+struct btrfs_io_bio {
+	unsigned long mirror_num;
+	unsigned long stripe_index;
+	struct bio bio;
+};
+
+static inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)
+{
+	return container_of(bio, struct btrfs_io_bio, bio);
+}
+
 struct btrfs_bio_stripe {
 	struct btrfs_device *dev;
 	u64 physical;

commit 48a3b6366f6913683563d934eb16fea67dead9c1
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Thu Apr 25 20:41:01 2013 +0000

    btrfs: make static code static & remove dead code
    
    Big patch, but all it does is add statics to functions which
    are in fact static, then remove the associated dead-code fallout.
    
    removed functions:
    
    btrfs_iref_to_path()
    __btrfs_lookup_delayed_deletion_item()
    __btrfs_search_delayed_insertion_item()
    __btrfs_search_delayed_deletion_item()
    find_eb_for_page()
    btrfs_find_block_group()
    range_straddles_pages()
    extent_range_uptodate()
    btrfs_file_extent_length()
    btrfs_scrub_cancel_devid()
    btrfs_start_transaction_lflush()
    
    btrfs_print_tree() is left because it is used for debugging.
    btrfs_start_transaction_lflush() and btrfs_reada_detach() are
    left for symmetry.
    
    ulist.c functions are left, another patch will take care of those.
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 062d8604d35b..845ccbb0d2e3 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -254,10 +254,6 @@ int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,
 #define btrfs_bio_size(n) (sizeof(struct btrfs_bio) + \
 			    (sizeof(struct btrfs_bio_stripe) * (n)))
 
-int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,
-			   struct btrfs_device *device,
-			   u64 chunk_tree, u64 chunk_objectid,
-			   u64 chunk_offset, u64 start, u64 num_bytes);
 int btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,
 		    u64 logical, u64 *length,
 		    struct btrfs_bio **bbio_ret, int mirror_num);
@@ -282,11 +278,6 @@ void btrfs_close_extra_devices(struct btrfs_fs_info *fs_info,
 int btrfs_find_device_missing_or_by_path(struct btrfs_root *root,
 					 char *device_path,
 					 struct btrfs_device **device);
-int btrfs_find_device_by_path(struct btrfs_root *root, char *device_path,
-			      struct btrfs_device **device);
-int btrfs_add_device(struct btrfs_trans_handle *trans,
-		     struct btrfs_root *root,
-		     struct btrfs_device *device);
 int btrfs_rm_device(struct btrfs_root *root, char *device_path);
 void btrfs_cleanup_fs_uuids(void);
 int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len);
@@ -307,7 +298,6 @@ int btrfs_cancel_balance(struct btrfs_fs_info *fs_info);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
 int find_free_dev_extent(struct btrfs_device *device, u64 num_bytes,
 			 u64 *start, u64 *max_avail);
-void btrfs_dev_stat_print_on_error(struct btrfs_device *device);
 void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index);
 int btrfs_get_dev_stats(struct btrfs_root *root,
 			struct btrfs_ioctl_get_dev_stats *stats);
@@ -321,9 +311,6 @@ void btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,
 void btrfs_init_dev_replace_tgtdev_for_resume(struct btrfs_fs_info *fs_info,
 					      struct btrfs_device *tgtdev);
 int btrfs_scratch_superblock(struct btrfs_device *device);
-void btrfs_schedule_bio(struct btrfs_root *root,
-			struct btrfs_device *device,
-			int rw, struct bio *bio);
 int btrfs_is_parity_mirror(struct btrfs_mapping_tree *map_tree,
 			   u64 logical, u64 len, int mirror_num);
 unsigned long btrfs_full_stripe_len(struct btrfs_root *root,

commit e942f883bc6651d50be139477baf6fb0eed3d5bb
Merge: b2c6b3e0611c 0e4e02636611
Author: Chris Mason <chris.mason@fusionio.com>
Date:   Wed Feb 20 14:06:05 2013 -0500

    Merge branch 'raid56-experimental' into for-linus-3.9
    
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>
    
    Conflicts:
            fs/btrfs/ctree.h
            fs/btrfs/extent-tree.c
            fs/btrfs/inode.c
            fs/btrfs/volumes.c

commit 55e301fd57a6239ec14b91a1cf2e70b3dd135194
Author: Filipe Brandenburger <filbranden@google.com>
Date:   Tue Jan 29 06:04:50 2013 +0000

    Btrfs: move fs/btrfs/ioctl.h to include/uapi/linux/btrfs.h
    
    The header file will then be installed under /usr/include/linux so that
    userspace applications can refer to Btrfs ioctls by name and use the same
    structs used internally in the kernel.
    
    Signed-off-by: Filipe Brandenburger <filbranden@google.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index d3c3939ac751..12bb84166a5f 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -21,8 +21,8 @@
 
 #include <linux/bio.h>
 #include <linux/sort.h>
+#include <linux/btrfs.h>
 #include "async-thread.h"
-#include "ioctl.h"
 
 #define BTRFS_STRIPE_LEN	(64 * 1024)
 

commit 53b381b3abeb86f12787a6c40fee9b2f71edc23b
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Tue Jan 29 18:40:14 2013 -0500

    Btrfs: RAID5 and RAID6
    
    This builds on David Woodhouse's original Btrfs raid5/6 implementation.
    The code has changed quite a bit, blame Chris Mason for any bugs.
    
    Read/modify/write is done after the higher levels of the filesystem have
    prepared a given bio.  This means the higher layers are not responsible
    for building full stripes, and they don't need to query for the topology
    of the extents that may get allocated during delayed allocation runs.
    It also means different files can easily share the same stripe.
    
    But, it does expose us to incorrect parity if we crash or lose power
    while doing a read/modify/write cycle.  This will be addressed in a
    later commit.
    
    Scrub is unable to repair crc errors on raid5/6 chunks.
    
    Discard does not work on raid5/6 (yet)
    
    The stripe size is fixed at 64KiB per disk.  This will be tunable
    in a later commit.
    
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index d3c3939ac751..0c2b856ecd98 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -321,7 +321,14 @@ void btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,
 void btrfs_init_dev_replace_tgtdev_for_resume(struct btrfs_fs_info *fs_info,
 					      struct btrfs_device *tgtdev);
 int btrfs_scratch_superblock(struct btrfs_device *device);
-
+void btrfs_schedule_bio(struct btrfs_root *root,
+			struct btrfs_device *device,
+			int rw, struct bio *bio);
+int btrfs_is_parity_mirror(struct btrfs_mapping_tree *map_tree,
+			   u64 logical, u64 len, int mirror_num);
+unsigned long btrfs_full_stripe_len(struct btrfs_root *root,
+				    struct btrfs_mapping_tree *map_tree,
+				    u64 logical);
 static inline void btrfs_dev_stat_inc(struct btrfs_device *dev,
 				      int index)
 {

commit 31e502298d80e2af9001d17dc419a3fd4b0bebef
Author: Liu Bo <bo.li.liu@oracle.com>
Date:   Wed Nov 21 14:18:10 2012 +0000

    Btrfs: put raid properties into global table
    
    Raid properties can be shared among raid calculation code, we can put
    them into a global table to keep it simple.
    
    Signed-off-by: Liu Bo <bo.li.liu@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 37d0157167b0..d3c3939ac751 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -180,6 +180,15 @@ struct btrfs_device_info {
 	u64 total_avail;
 };
 
+struct btrfs_raid_attr {
+	int sub_stripes;	/* sub_stripes info for map */
+	int dev_stripes;	/* stripes per dev */
+	int devs_max;		/* max devs to use */
+	int devs_min;		/* min devs needed */
+	int devs_increment;	/* ndevs has to be a multiple of this */
+	int ncopies;		/* how many copies to data has */
+};
+
 struct map_lookup {
 	u64 type;
 	int io_align;

commit 8dabb7420f014ab0f9f04afae8ae046c0f48b270
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Tue Nov 6 13:15:27 2012 +0100

    Btrfs: change core code of btrfs to support the device replace operations
    
    This commit contains all the essential changes to the core code
    of Btrfs for support of the device replace procedure.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 58d79375deaf..37d0157167b0 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -268,7 +268,8 @@ int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
 int btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,
 			  struct btrfs_fs_devices **fs_devices_ret);
 int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
-void btrfs_close_extra_devices(struct btrfs_fs_devices *fs_devices);
+void btrfs_close_extra_devices(struct btrfs_fs_info *fs_info,
+			       struct btrfs_fs_devices *fs_devices, int step);
 int btrfs_find_device_missing_or_by_path(struct btrfs_root *root,
 					 char *device_path,
 					 struct btrfs_device **device);

commit e93c89c1aaaaaec3487c4c18dd02360371790722
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Mon Nov 5 17:33:06 2012 +0100

    Btrfs: add new sources for device replace code
    
    This adds a new file to the sources together with the header file
    and the changes to ioctl.h and ctree.h that are required by the
    new C source file. Additionally, 4 new functions are added to
    volume.c that deal with device creation and destruction.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 8fd5a4d8acc8..58d79375deaf 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -286,6 +286,8 @@ struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,
 				       u8 *uuid, u8 *fsid);
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_root *root, char *path);
+int btrfs_init_dev_replace_tgtdev(struct btrfs_root *root, char *device_path,
+				  struct btrfs_device **device_out);
 int btrfs_balance(struct btrfs_balance_control *bctl,
 		  struct btrfs_ioctl_balance_args *bargs);
 int btrfs_resume_balance_async(struct btrfs_fs_info *fs_info);
@@ -302,6 +304,12 @@ int btrfs_get_dev_stats(struct btrfs_root *root,
 int btrfs_init_dev_stats(struct btrfs_fs_info *fs_info);
 int btrfs_run_dev_stats(struct btrfs_trans_handle *trans,
 			struct btrfs_fs_info *fs_info);
+void btrfs_rm_dev_replace_srcdev(struct btrfs_fs_info *fs_info,
+				 struct btrfs_device *srcdev);
+void btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,
+				      struct btrfs_device *tgtdev);
+void btrfs_init_dev_replace_tgtdev_for_resume(struct btrfs_fs_info *fs_info,
+					      struct btrfs_device *tgtdev);
 int btrfs_scratch_superblock(struct btrfs_device *device);
 
 static inline void btrfs_dev_stat_inc(struct btrfs_device *dev,

commit 63a212abc2315972b245f93cb11ae3acf3c0b513
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Mon Nov 5 18:29:28 2012 +0100

    Btrfs: disallow some operations on the device replace target device
    
    This patch adds some code to disallow operations on the device that
    is used as the target for the device replace operation.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 802e2ba02f09..8fd5a4d8acc8 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -50,6 +50,7 @@ struct btrfs_device {
 	int in_fs_metadata;
 	int missing;
 	int can_discard;
+	int is_tgtdev_for_dev_replace;
 
 	spinlock_t io_lock;
 

commit aa1b8cd409f05e1489ec77ff219eff6ed4b801b8
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Mon Nov 5 17:03:39 2012 +0100

    Btrfs: pass fs_info instead of root
    
    A small number of functions that are used in a device replace
    procedure when the operation is resumed at mount time are unable
    to pass the same root pointer that would be used in the regular
    (ioctl) context. And since the root pointer is not required, only
    the fs_info is, the root pointer argument is replaced with the
    fs_info pointer argument.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 7eaaf4e61959..802e2ba02f09 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -281,7 +281,7 @@ void btrfs_cleanup_fs_uuids(void);
 int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len);
 int btrfs_grow_device(struct btrfs_trans_handle *trans,
 		      struct btrfs_device *device, u64 new_size);
-struct btrfs_device *btrfs_find_device(struct btrfs_root *root, u64 devid,
+struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,
 				       u8 *uuid, u8 *fsid);
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_root *root, char *path);

commit a8a6dab77997a371f1925a4001021eea3ee5cb88
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Mon Nov 5 15:50:14 2012 +0100

    Btrfs: add btrfs_scratch_superblock() function
    
    This new function is used by the device replace procedure in
    a later patch.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index ad5566d4f2c8..7eaaf4e61959 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -301,6 +301,7 @@ int btrfs_get_dev_stats(struct btrfs_root *root,
 int btrfs_init_dev_stats(struct btrfs_fs_info *fs_info);
 int btrfs_run_dev_stats(struct btrfs_trans_handle *trans,
 			struct btrfs_fs_info *fs_info);
+int btrfs_scratch_superblock(struct btrfs_device *device);
 
 static inline void btrfs_dev_stat_inc(struct btrfs_device *dev,
 				      int index)

commit 3ec706c831d4c96905c287013c8228b21619a1d9
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Mon Nov 5 15:46:42 2012 +0100

    Btrfs: pass fs_info to btrfs_map_block() instead of mapping_tree
    
    This is required for the device replace procedure in a later step.
    Two calling functions also had to be changed to have the fs_info
    pointer: repair_io_failure() and scrub_setup_recheck_block().
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 35ea4424963b..ad5566d4f2c8 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -248,7 +248,7 @@ int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,
 			   struct btrfs_device *device,
 			   u64 chunk_tree, u64 chunk_objectid,
 			   u64 chunk_offset, u64 start, u64 num_bytes);
-int btrfs_map_block(struct btrfs_mapping_tree *map_tree, int rw,
+int btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,
 		    u64 logical, u64 *length,
 		    struct btrfs_bio **bbio_ret, int mirror_num);
 int btrfs_rmap_block(struct btrfs_mapping_tree *map_tree,

commit 5d9640517d92d05843711ea982cbeff42d7ed32d
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Mon Nov 5 14:59:07 2012 +0100

    Btrfs: Pass fs_info to btrfs_num_copies() instead of mapping_tree
    
    This is required for the device replace procedure in a later step.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 657bb12b3069..35ea4424963b 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -278,7 +278,7 @@ int btrfs_add_device(struct btrfs_trans_handle *trans,
 		     struct btrfs_device *device);
 int btrfs_rm_device(struct btrfs_root *root, char *device_path);
 void btrfs_cleanup_fs_uuids(void);
-int btrfs_num_copies(struct btrfs_mapping_tree *map_tree, u64 logical, u64 len);
+int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len);
 int btrfs_grow_device(struct btrfs_trans_handle *trans,
 		      struct btrfs_device *device, u64 new_size);
 struct btrfs_device *btrfs_find_device(struct btrfs_root *root, u64 devid,

commit 7ba15b7d211846c187a7c5dc75a5964476f8bc89
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Mon Nov 5 14:42:30 2012 +0100

    Btrfs: add two more find_device() methods
    
    The new function btrfs_find_device_missing_or_by_path() will be
    used for the device replace procedure. This function itself calls
    the second new function btrfs_find_device_by_path().
    Unfortunately, it is not possible to currently make the rest of the
    code use these functions as well, since all functions that look
    similar at first view are all a little bit different in what they
    are doing. But in the future, new code could benefit from these
    two new functions, and currently, device replace uses them.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 1789cda57efb..657bb12b3069 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -268,6 +268,11 @@ int btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,
 			  struct btrfs_fs_devices **fs_devices_ret);
 int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
 void btrfs_close_extra_devices(struct btrfs_fs_devices *fs_devices);
+int btrfs_find_device_missing_or_by_path(struct btrfs_root *root,
+					 char *device_path,
+					 struct btrfs_device **device);
+int btrfs_find_device_by_path(struct btrfs_root *root, char *device_path,
+			      struct btrfs_device **device);
 int btrfs_add_device(struct btrfs_trans_handle *trans,
 		     struct btrfs_root *root,
 		     struct btrfs_device *device);

commit d9d181c1ba7aa09a6d2698e8c7e75b515524d504
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Fri Nov 2 09:58:09 2012 +0100

    Btrfs: rename the scrub context structure
    
    The device replace procedure makes use of the scrub code. The scrub
    code is the most efficient code to read the allocated data of a disk,
    i.e. it reads sequentially in order to avoid disk head movements, it
    skips unallocated blocks, it uses read ahead mechanisms, and it
    contains all the code to detect and repair defects.
    This commit is a first preparation step to adapt the scrub code to
    be shareable for the device replace procedure.
    The block device will be removed from the scrub context state
    structure in a later step. It used to be the source block device.
    The scrub code as it is used for the device replace procedure reads
    the source data from whereever it is optimal. The source device might
    even be gone (disconnected, for instance due to a hardware failure).
    Or the drive can be so faulty so that the device replace procedure
    tries to avoid access to the faulty source drive as much as possible,
    and only if all other mirrors are damaged, as a last resort, the
    source disk is accessed.
    The modified scrub code operates as if it would handle the source
    drive and thereby generates an exact copy of the source disk on the
    target disk, even if the source disk is not present at all. Therefore
    the block device pointer to the source disk is removed in a later
    patch, and therefore the context structure is renamed (this is the
    goal of the current patch) to reflect that no source block device
    scope is there anymore.
    
    Summary:
    This first preparation step consists of a textual substitution of the
    term "dev" to the term "ctx" whereever the scrub context is used.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 53c06af92e8d..1789cda57efb 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -88,7 +88,7 @@ struct btrfs_device {
 	u8 uuid[BTRFS_UUID_SIZE];
 
 	/* per-device scrub information */
-	struct scrub_dev *scrub_device;
+	struct scrub_ctx *scrub_device;
 
 	struct btrfs_work work;
 	struct rcu_head rcu;

commit 5ee0844d6427e7338e0aba748f62b62d07ea2ed0
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Mon Aug 27 08:30:03 2012 -0600

    Btrfs: revert checksum error statistic which can cause a BUG()
    
    Commit 442a4f6308e694e0fa6025708bd5e4e424bbf51c added btrfs device
    statistic counters for detected IO and checksum errors to Linux 3.5.
    The statistic part that counts checksum errors in
    end_bio_extent_readpage() can cause a BUG() in a subfunction:
    "kernel BUG at fs/btrfs/volumes.c:3762!"
    That part is reverted with the current patch.
    However, the counting of checksum errors in the scrub context remains
    active, and the counting of detected IO errors (read, write or flush
    errors) in all contexts remains active.
    
    Cc: stable <stable@vger.kernel.org> # 3.5
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 5479325987b3..53c06af92e8d 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -289,8 +289,6 @@ int btrfs_cancel_balance(struct btrfs_fs_info *fs_info);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
 int find_free_dev_extent(struct btrfs_device *device, u64 num_bytes,
 			 u64 *start, u64 *max_avail);
-struct btrfs_device *btrfs_find_device_for_logical(struct btrfs_root *root,
-						   u64 logical, int mirror_num);
 void btrfs_dev_stat_print_on_error(struct btrfs_device *device);
 void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index);
 int btrfs_get_dev_stats(struct btrfs_root *root,

commit 02db0844beffc1c4e99d750be58ffb3ed95d6d62
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Thu Jun 21 16:03:58 2012 -0400

    Btrfs: add DEVICE_READY ioctl
    
    This will be used in conjunction with btrfs device ready <dev>.  This is
    needed for initrd's to have a nice and lightweight way to tell if all of the
    devices needed for a file system are in the cache currently.  This keeps
    them from having to do mount+sleep loops waiting for devices to show up.
    Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index e404414a95a9..5479325987b3 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -126,6 +126,7 @@ struct btrfs_fs_devices {
 	u64 missing_devices;
 	u64 total_rw_bytes;
 	u64 num_can_discard;
+	u64 total_devices;
 	struct block_device *latest_bdev;
 
 	/* all of the devices in the FS, protected by a mutex

commit b27f7c0c150f74564b5d4c6c24a03c5226bf6327
Author: David Sterba <dsterba@suse.cz>
Date:   Fri Jun 22 06:30:39 2012 -0600

    btrfs: join DEV_STATS ioctls to one
    
    Commit c11d2c236cc260b36 (Btrfs: add ioctl to get and reset the device
    stats) introduced two ioctls doing almost the same thing distinguished
    by just the ioctl number which encodes "do reset after read". I have
    suggested
    
    http://www.mail-archive.com/linux-btrfs@vger.kernel.org/msg16604.html
    
    to implement it via the ioctl args. This hasn't happen, and I think we
    should use a more clean way to pass flags and should not waste ioctl
    numbers.
    
    CC: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 95f6637614db..e404414a95a9 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -293,8 +293,7 @@ struct btrfs_device *btrfs_find_device_for_logical(struct btrfs_root *root,
 void btrfs_dev_stat_print_on_error(struct btrfs_device *device);
 void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index);
 int btrfs_get_dev_stats(struct btrfs_root *root,
-			struct btrfs_ioctl_get_dev_stats *stats,
-			int reset_after_read);
+			struct btrfs_ioctl_get_dev_stats *stats);
 int btrfs_init_dev_stats(struct btrfs_fs_info *fs_info);
 int btrfs_run_dev_stats(struct btrfs_trans_handle *trans,
 			struct btrfs_fs_info *fs_info);

commit 2b6ba629b5aac51e7099efbb43e2b403213aa7fb
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Fri Jun 22 12:24:13 2012 -0600

    Btrfs: resume balance on rw (re)mounts properly
    
    This introduces btrfs_resume_balance_async(), which, given that
    restriper state was recovered earlier by btrfs_recover_balance(),
    resumes balance in btrfs-balance kthread.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index e1b1a649fc5a..95f6637614db 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -281,6 +281,7 @@ int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_root *root, char *path);
 int btrfs_balance(struct btrfs_balance_control *bctl,
 		  struct btrfs_ioctl_balance_args *bargs);
+int btrfs_resume_balance_async(struct btrfs_fs_info *fs_info);
 int btrfs_recover_balance(struct btrfs_fs_info *fs_info);
 int btrfs_pause_balance(struct btrfs_fs_info *fs_info);
 int btrfs_cancel_balance(struct btrfs_fs_info *fs_info);

commit 68310a5e42f93c2242ec1836c3b18d531e0065e2
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Fri Jun 22 12:24:12 2012 -0600

    Btrfs: restore restriper state on all mounts
    
    Fix a bug that triggered asserts in btrfs_balance() in both normal and
    resume modes -- restriper state was not properly restored on read-only
    mounts.  This factors out resuming code from btrfs_restore_balance(),
    which is now also called earlier in the mount sequence to avoid the
    problem of some early writes getting the old profile.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 74366f27a76b..e1b1a649fc5a 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -281,7 +281,7 @@ int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_root *root, char *path);
 int btrfs_balance(struct btrfs_balance_control *bctl,
 		  struct btrfs_ioctl_balance_args *bargs);
-int btrfs_recover_balance(struct btrfs_root *tree_root);
+int btrfs_recover_balance(struct btrfs_fs_info *fs_info);
 int btrfs_pause_balance(struct btrfs_fs_info *fs_info);
 int btrfs_cancel_balance(struct btrfs_fs_info *fs_info);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);

commit 606686eeac4550d2212bf3d621a810407ef5e9bf
Author: Josef Bacik <josef@redhat.com>
Date:   Mon Jun 4 14:03:51 2012 -0400

    Btrfs: use rcu to protect device->name
    
    Al pointed out that we can just toss out the old name on a device and add a
    new one arbitrarily, so anybody who uses device->name in printk could
    possibly use free'd memory.  Instead of adding locking around all of this he
    suggested doing it with RCU, so I've introduced a struct rcu_string that
    does just that and have gone through and protected all accesses to
    device->name that aren't under the uuid_mutex with rcu_read_lock().  This
    protects us and I will use it for dealing with removing the device that we
    used to mount the file system in a later patch.  Thanks,
    
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <josef@redhat.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 3406a88ca83e..74366f27a76b 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -58,7 +58,7 @@ struct btrfs_device {
 	/* the mode sent to blkdev_get */
 	fmode_t mode;
 
-	char *name;
+	struct rcu_string *name;
 
 	/* the internal btrfs device id */
 	u64 devid;

commit 733f4fbbc1083aa343da739f46ee839705d6cfe3
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Fri May 25 16:06:10 2012 +0200

    Btrfs: read device stats on mount, write modified ones during commit
    
    The device statistics are written into the device tree with each
    transaction commit. Only modified statistics are written.
    When a filesystem is mounted, the device statistics for each involved
    device are read from the device tree and used to initialize the
    counters.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 6798f8674b13..3406a88ca83e 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -109,6 +109,7 @@ struct btrfs_device {
 
 	/* disk I/O failure stats. For detailed description refer to
 	 * enum btrfs_dev_stat_values in ioctl.h */
+	int dev_stats_valid;
 	int dev_stats_dirty; /* counters need to be written to disk */
 	atomic_t dev_stat_values[BTRFS_DEV_STAT_VALUES_MAX];
 };
@@ -293,6 +294,9 @@ void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index);
 int btrfs_get_dev_stats(struct btrfs_root *root,
 			struct btrfs_ioctl_get_dev_stats *stats,
 			int reset_after_read);
+int btrfs_init_dev_stats(struct btrfs_fs_info *fs_info);
+int btrfs_run_dev_stats(struct btrfs_trans_handle *trans,
+			struct btrfs_fs_info *fs_info);
 
 static inline void btrfs_dev_stat_inc(struct btrfs_device *dev,
 				      int index)

commit c11d2c236cc260b36ef644700fbe99bcc7e7da33
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Fri May 25 16:06:09 2012 +0200

    Btrfs: add ioctl to get and reset the device stats
    
    An ioctl interface is added to get the device statistic counters.
    A second ioctl is added to atomically get and reset these counters.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 193b2835e6ae..6798f8674b13 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -290,6 +290,9 @@ struct btrfs_device *btrfs_find_device_for_logical(struct btrfs_root *root,
 						   u64 logical, int mirror_num);
 void btrfs_dev_stat_print_on_error(struct btrfs_device *device);
 void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index);
+int btrfs_get_dev_stats(struct btrfs_root *root,
+			struct btrfs_ioctl_get_dev_stats *stats,
+			int reset_after_read);
 
 static inline void btrfs_dev_stat_inc(struct btrfs_device *dev,
 				      int index)

commit 442a4f6308e694e0fa6025708bd5e4e424bbf51c
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Fri May 25 16:06:08 2012 +0200

    Btrfs: add device counters for detected IO and checksum errors
    
    The goal is to detect when drives start to get an increased error rate,
    when drives should be replaced soon. Therefore statistic counters are
    added that count IO errors (read, write and flush). Additionally, the
    software detected errors like checksum errors and corrupted blocks are
    counted.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index bb6b03f97aaa..193b2835e6ae 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -22,6 +22,7 @@
 #include <linux/bio.h>
 #include <linux/sort.h>
 #include "async-thread.h"
+#include "ioctl.h"
 
 #define BTRFS_STRIPE_LEN	(64 * 1024)
 
@@ -106,6 +107,10 @@ struct btrfs_device {
 	struct completion flush_wait;
 	int nobarriers;
 
+	/* disk I/O failure stats. For detailed description refer to
+	 * enum btrfs_dev_stat_values in ioctl.h */
+	int dev_stats_dirty; /* counters need to be written to disk */
+	atomic_t dev_stat_values[BTRFS_DEV_STAT_VALUES_MAX];
 };
 
 struct btrfs_fs_devices {
@@ -281,4 +286,44 @@ int btrfs_cancel_balance(struct btrfs_fs_info *fs_info);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
 int find_free_dev_extent(struct btrfs_device *device, u64 num_bytes,
 			 u64 *start, u64 *max_avail);
+struct btrfs_device *btrfs_find_device_for_logical(struct btrfs_root *root,
+						   u64 logical, int mirror_num);
+void btrfs_dev_stat_print_on_error(struct btrfs_device *device);
+void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index);
+
+static inline void btrfs_dev_stat_inc(struct btrfs_device *dev,
+				      int index)
+{
+	atomic_inc(dev->dev_stat_values + index);
+	dev->dev_stats_dirty = 1;
+}
+
+static inline int btrfs_dev_stat_read(struct btrfs_device *dev,
+				      int index)
+{
+	return atomic_read(dev->dev_stat_values + index);
+}
+
+static inline int btrfs_dev_stat_read_and_reset(struct btrfs_device *dev,
+						int index)
+{
+	int ret;
+
+	ret = atomic_xchg(dev->dev_stat_values + index, 0);
+	dev->dev_stats_dirty = 1;
+	return ret;
+}
+
+static inline void btrfs_dev_stat_set(struct btrfs_device *dev,
+				      int index, unsigned long val)
+{
+	atomic_set(dev->dev_stat_values + index, val);
+	dev->dev_stats_dirty = 1;
+}
+
+static inline void btrfs_dev_stat_reset(struct btrfs_device *dev,
+					int index)
+{
+	btrfs_dev_stat_set(dev, index, 0);
+}
 #endif

commit 143bede527b054a271053f41bfaca2b57baa9408
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Mar 1 14:56:26 2012 +0100

    btrfs: return void in functions without error conditions
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 19ac95048b88..bb6b03f97aaa 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -260,12 +260,12 @@ int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
 int btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,
 			  struct btrfs_fs_devices **fs_devices_ret);
 int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
-int btrfs_close_extra_devices(struct btrfs_fs_devices *fs_devices);
+void btrfs_close_extra_devices(struct btrfs_fs_devices *fs_devices);
 int btrfs_add_device(struct btrfs_trans_handle *trans,
 		     struct btrfs_root *root,
 		     struct btrfs_device *device);
 int btrfs_rm_device(struct btrfs_root *root, char *device_path);
-int btrfs_cleanup_fs_uuids(void);
+void btrfs_cleanup_fs_uuids(void);
 int btrfs_num_copies(struct btrfs_mapping_tree *map_tree, u64 logical, u64 len);
 int btrfs_grow_device(struct btrfs_trans_handle *trans,
 		      struct btrfs_device *device, u64 new_size);

commit d756bd2d9339447c29bde950910586df8f8941ec
Merge: 27263e28321d b367e47fb3a7
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Jan 16 15:26:17 2012 -0500

    Merge branch 'for-chris' of git://repo.or.cz/linux-btrfs-devel into integration
    
    Conflicts:
            fs/btrfs/volumes.c
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

commit 19a39dce3b9bf0244d19a446718ad6f7605ff099
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Jan 16 22:04:49 2012 +0200

    Btrfs: add balance progress reporting
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index caa9abd218ef..6faec9dd1f93 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -218,6 +218,7 @@ struct map_lookup {
 #define BTRFS_BALANCE_ARGS_SOFT		(1ULL << 9)
 
 struct btrfs_balance_args;
+struct btrfs_balance_progress;
 struct btrfs_balance_control {
 	struct btrfs_fs_info *fs_info;
 
@@ -226,6 +227,8 @@ struct btrfs_balance_control {
 	struct btrfs_balance_args sys;
 
 	u64 flags;
+
+	struct btrfs_balance_progress stat;
 };
 
 int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,

commit a7e99c691af553fc15ac46a51f130b7c59a65f76
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Jan 16 22:04:49 2012 +0200

    Btrfs: allow for canceling restriper
    
    Implement an ioctl for canceling restriper.  Currently we wait until
    relocation of the current block group is finished, in future this can be
    done by triggering a commit.  Balance item is deleted and no memory
    about the interrupted balance is kept.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 80953afb12b9..caa9abd218ef 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -274,6 +274,7 @@ int btrfs_balance(struct btrfs_balance_control *bctl,
 		  struct btrfs_ioctl_balance_args *bargs);
 int btrfs_recover_balance(struct btrfs_root *tree_root);
 int btrfs_pause_balance(struct btrfs_fs_info *fs_info);
+int btrfs_cancel_balance(struct btrfs_fs_info *fs_info);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
 int find_free_dev_extent(struct btrfs_trans_handle *trans,
 			 struct btrfs_device *device, u64 num_bytes,

commit 837d5b6e46d1a4af5b6cc8f2fe83cb5de79a2961
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Jan 16 22:04:49 2012 +0200

    Btrfs: allow for pausing restriper
    
    Implement an ioctl for pausing restriper.  This pauses the relocation,
    but balance is still considered to be "in progress": balance item is
    not deleted, other volume operations cannot be started, etc.  If paused
    in the middle of profile changing operation we will continue making
    allocations with the target profile.
    
    Add a hook to close_ctree() to pause restriper and free its data
    structures on unmount.  (It's safe to unmount when restriper is in
    "paused" state, we will resume with the same parameters on the next
    mount)
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index cd25ea58ec35..80953afb12b9 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -273,6 +273,7 @@ int btrfs_init_new_device(struct btrfs_root *root, char *path);
 int btrfs_balance(struct btrfs_balance_control *bctl,
 		  struct btrfs_ioctl_balance_args *bargs);
 int btrfs_recover_balance(struct btrfs_root *tree_root);
+int btrfs_pause_balance(struct btrfs_fs_info *fs_info);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
 int find_free_dev_extent(struct btrfs_trans_handle *trans,
 			 struct btrfs_device *device, u64 num_bytes,

commit 596410151ed71819b9e8a8018c6c9992796b256d
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Jan 16 22:04:48 2012 +0200

    Btrfs: recover balance on mount
    
    On mount, if balance item is found, resume balance in a separate
    kernel thread.
    
    Try to be smart to continue roughly where previous balance (or convert)
    was interrupted.  For chunk types that were being converted to some
    profile we turn on soft convert, in case of a simple balance we turn on
    usage filter and relocate only less-than-90%-full chunks of that type.
    These are just heuristics but they help quite a bit, and can be improved
    in future.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 6c143c98017a..cd25ea58ec35 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -198,6 +198,7 @@ struct map_lookup {
 					 BTRFS_BALANCE_METADATA)
 
 #define BTRFS_BALANCE_FORCE		(1ULL << 3)
+#define BTRFS_BALANCE_RESUME		(1ULL << 4)
 
 /*
  * Balance filters
@@ -271,6 +272,7 @@ int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_root *root, char *path);
 int btrfs_balance(struct btrfs_balance_control *bctl,
 		  struct btrfs_ioctl_balance_args *bargs);
+int btrfs_recover_balance(struct btrfs_root *tree_root);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
 int find_free_dev_extent(struct btrfs_trans_handle *trans,
 			 struct btrfs_device *device, u64 num_bytes,

commit cfa4c961cc69ffb7bda450972320a25cbd413e19
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Jan 16 22:04:48 2012 +0200

    Btrfs: soft profile changing mode (aka soft convert)
    
    When doing convert from one profile to another if soft mode is on
    restriper won't touch chunks that already have the profile we are
    converting to.  This is useful if e.g. half of the FS was converted
    earlier.
    
    The soft mode switch is (like every other filter) per-type.  This means
    that we can convert for example meta chunks the "hard" way while
    converting data chunks selectively with soft switch.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 79ee9c324562..6c143c98017a 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -208,7 +208,13 @@ struct map_lookup {
 #define BTRFS_BALANCE_ARGS_DRANGE	(1ULL << 3)
 #define BTRFS_BALANCE_ARGS_VRANGE	(1ULL << 4)
 
+/*
+ * Profile changing flags.  When SOFT is set we won't relocate chunk if
+ * it already has the target profile (even though it may be
+ * half-filled).
+ */
 #define BTRFS_BALANCE_ARGS_CONVERT	(1ULL << 8)
+#define BTRFS_BALANCE_ARGS_SOFT		(1ULL << 9)
 
 struct btrfs_balance_args;
 struct btrfs_balance_control {

commit e4d8ec0f65b91bfb4984a4927632ded95f9825ad
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Jan 16 22:04:48 2012 +0200

    Btrfs: implement online profile changing
    
    Profile changing is done by launching a balance with
    BTRFS_BALANCE_CONVERT bits set and target fields of respective
    btrfs_balance_args structs initialized.  Profile reducing code in this
    case will pick restriper's target profile if it's available instead of
    doing a blind reduce.  If target profile is not yet available it goes
    back to a plain reduce.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index eac26c359312..79ee9c324562 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -196,6 +196,9 @@ struct map_lookup {
 #define BTRFS_BALANCE_TYPE_MASK		(BTRFS_BALANCE_DATA |	    \
 					 BTRFS_BALANCE_SYSTEM |	    \
 					 BTRFS_BALANCE_METADATA)
+
+#define BTRFS_BALANCE_FORCE		(1ULL << 3)
+
 /*
  * Balance filters
  */
@@ -205,6 +208,8 @@ struct map_lookup {
 #define BTRFS_BALANCE_ARGS_DRANGE	(1ULL << 3)
 #define BTRFS_BALANCE_ARGS_VRANGE	(1ULL << 4)
 
+#define BTRFS_BALANCE_ARGS_CONVERT	(1ULL << 8)
+
 struct btrfs_balance_args;
 struct btrfs_balance_control {
 	struct btrfs_fs_info *fs_info;

commit ea67176ae8c024f64d85ec33873e5eadf1af7247
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Jan 16 22:04:48 2012 +0200

    Btrfs: virtual address space subset filter
    
    Select chunks which have at least one byte located inside a given
    [vstart, vend) virtual address space range.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 844b08e388f2..eac26c359312 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -203,6 +203,7 @@ struct map_lookup {
 #define BTRFS_BALANCE_ARGS_USAGE	(1ULL << 1)
 #define BTRFS_BALANCE_ARGS_DEVID	(1ULL << 2)
 #define BTRFS_BALANCE_ARGS_DRANGE	(1ULL << 3)
+#define BTRFS_BALANCE_ARGS_VRANGE	(1ULL << 4)
 
 struct btrfs_balance_args;
 struct btrfs_balance_control {

commit 94e60d5a5c4b98a32b1077dec88df09ada712376
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Jan 16 22:04:48 2012 +0200

    Btrfs: devid subset filter
    
    Select chunks which have at least one byte of at least one stripe
    located on a device with devid X in a given [pstart,pend) physical
    address range.
    
    This filter only works when devid filter is turned on.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 7cfec03c29b8..844b08e388f2 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -202,6 +202,7 @@ struct map_lookup {
 #define BTRFS_BALANCE_ARGS_PROFILES	(1ULL << 0)
 #define BTRFS_BALANCE_ARGS_USAGE	(1ULL << 1)
 #define BTRFS_BALANCE_ARGS_DEVID	(1ULL << 2)
+#define BTRFS_BALANCE_ARGS_DRANGE	(1ULL << 3)
 
 struct btrfs_balance_args;
 struct btrfs_balance_control {

commit 409d404b461afa9738619f249fd7f62a366b68c2
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Jan 16 22:04:47 2012 +0200

    Btrfs: devid filter
    
    Relocate chunks which have at least one stripe located on a device with
    devid X.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index eee77fcf812a..7cfec03c29b8 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -201,6 +201,7 @@ struct map_lookup {
  */
 #define BTRFS_BALANCE_ARGS_PROFILES	(1ULL << 0)
 #define BTRFS_BALANCE_ARGS_USAGE	(1ULL << 1)
+#define BTRFS_BALANCE_ARGS_DEVID	(1ULL << 2)
 
 struct btrfs_balance_args;
 struct btrfs_balance_control {

commit 5ce5b3c0916ba3a2e34cf648b94044adc5ef9e76
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Jan 16 22:04:47 2012 +0200

    Btrfs: usage filter
    
    Select chunks that are less than X percent full.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index fb20d7740440..eee77fcf812a 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -200,6 +200,7 @@ struct map_lookup {
  * Balance filters
  */
 #define BTRFS_BALANCE_ARGS_PROFILES	(1ULL << 0)
+#define BTRFS_BALANCE_ARGS_USAGE	(1ULL << 1)
 
 struct btrfs_balance_args;
 struct btrfs_balance_control {

commit ed25e9b26f898d8d63ae4a836489f1923534143b
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Jan 16 22:04:47 2012 +0200

    Btrfs: profiles filter
    
    Select chunks based on a given profile mask.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 003e54216069..fb20d7740440 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -196,6 +196,10 @@ struct map_lookup {
 #define BTRFS_BALANCE_TYPE_MASK		(BTRFS_BALANCE_DATA |	    \
 					 BTRFS_BALANCE_SYSTEM |	    \
 					 BTRFS_BALANCE_METADATA)
+/*
+ * Balance filters
+ */
+#define BTRFS_BALANCE_ARGS_PROFILES	(1ULL << 0)
 
 struct btrfs_balance_args;
 struct btrfs_balance_control {

commit f43ffb60fd94e98be02780944e182ade6653b916
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Jan 16 22:04:47 2012 +0200

    Btrfs: add basic infrastructure for selective balancing
    
    This allows to have a separate set of filters for each chunk type
    (data,meta,sys).  The code however is generic and switch on chunk type
    is only done once.
    
    This commit also adds a type filter: it allows to balance for example
    meta and system chunks w/o touching data ones.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 882582385283..003e54216069 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -186,6 +186,17 @@ struct map_lookup {
 #define map_lookup_size(n) (sizeof(struct map_lookup) + \
 			    (sizeof(struct btrfs_bio_stripe) * (n)))
 
+/*
+ * Restriper's general type filter
+ */
+#define BTRFS_BALANCE_DATA		(1ULL << 0)
+#define BTRFS_BALANCE_SYSTEM		(1ULL << 1)
+#define BTRFS_BALANCE_METADATA		(1ULL << 2)
+
+#define BTRFS_BALANCE_TYPE_MASK		(BTRFS_BALANCE_DATA |	    \
+					 BTRFS_BALANCE_SYSTEM |	    \
+					 BTRFS_BALANCE_METADATA)
+
 struct btrfs_balance_args;
 struct btrfs_balance_control {
 	struct btrfs_fs_info *fs_info;

commit c9e9f97bdfb64d06e9520f8e4f37674ac21cc9bc
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Jan 16 22:04:47 2012 +0200

    Btrfs: add basic restriper infrastructure
    
    Add basic restriper infrastructure: extended balancing ioctl and all
    related ioctl data structures, add data structure for tracking
    restriper's state to fs_info, etc.  The semantics of the old balancing
    ioctl are fully preserved.
    
    Explicitly disallow any volume operations when balance is in progress.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 78f2d4d4f37f..882582385283 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -186,6 +186,17 @@ struct map_lookup {
 #define map_lookup_size(n) (sizeof(struct map_lookup) + \
 			    (sizeof(struct btrfs_bio_stripe) * (n)))
 
+struct btrfs_balance_args;
+struct btrfs_balance_control {
+	struct btrfs_fs_info *fs_info;
+
+	struct btrfs_balance_args data;
+	struct btrfs_balance_args meta;
+	struct btrfs_balance_args sys;
+
+	u64 flags;
+};
+
 int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,
 				   u64 end, u64 *length);
 
@@ -228,7 +239,8 @@ struct btrfs_device *btrfs_find_device(struct btrfs_root *root, u64 devid,
 				       u8 *uuid, u8 *fsid);
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_root *root, char *path);
-int btrfs_balance(struct btrfs_root *dev_root);
+int btrfs_balance(struct btrfs_balance_control *bctl,
+		  struct btrfs_ioctl_balance_args *bargs);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
 int find_free_dev_extent(struct btrfs_trans_handle *trans,
 			 struct btrfs_device *device, u64 num_bytes,

commit 125ccb0ae6806dbec31abf4a85448971df3b4e39
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Thu Dec 8 15:07:24 2011 +0800

    Btrfs: don't pass a trans handle unnecessarily in volumes.c
    
    Some functions never use the transaction handle passed to them.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 78f2d4d4f37f..c1701ec9d49f 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -230,7 +230,6 @@ int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_root *root, char *path);
 int btrfs_balance(struct btrfs_root *dev_root);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
-int find_free_dev_extent(struct btrfs_trans_handle *trans,
-			 struct btrfs_device *device, u64 num_bytes,
+int find_free_dev_extent(struct btrfs_device *device, u64 num_bytes,
 			 u64 *start, u64 *max_avail);
 #endif

commit 387125fc722a8ed432066b85a552917343bdafca
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Nov 18 15:07:51 2011 -0500

    Btrfs: fix barrier flushes
    
    When btrfs is writing the super blocks, it send barrier flushes to make
    sure writeback caching drives get all the metadata on disk in the
    right order.
    
    But, we have two bugs in the way these are sent down.  When doing
    full commits (not via the tree log), we are sending the barrier down
    before the last super when it should be going down before the first.
    
    In multi-device setups, we should be waiting for the barriers to
    complete on all devices before writing any of the supers.
    
    Both of these bugs can cause corruptions on power failures.  We fix it
    with some new code to send down empty barriers to all devices before
    writing the first super.
    
    Alexandre Oliva found the multi-device bug.  Arne Jansen did the async
    barrier loop.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>
    Reported-by: Alexandre Oliva <oliva@lsd.ic.unicamp.br>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index ab5b1c49f352..78f2d4d4f37f 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -100,6 +100,12 @@ struct btrfs_device {
 	struct reada_zone *reada_curr_zone;
 	struct radix_tree_root reada_zones;
 	struct radix_tree_root reada_extents;
+
+	/* for sending down flush barriers */
+	struct bio *flush_bio;
+	struct completion flush_wait;
+	int nobarriers;
+
 };
 
 struct btrfs_fs_devices {

commit 806468f8bf76a3cb2b626dd282946a6c9c0a50f0
Merge: 531f4b1ae5e0 5da6fcbc4eb5
Author: Chris Mason <chris.mason@oracle.com>
Date:   Sun Nov 6 03:07:10 2011 -0500

    Merge git://git.jan-o-sch.net/btrfs-unstable into integration
    
    Conflicts:
            fs/btrfs/Makefile
            fs/btrfs/extent_io.c
            fs/btrfs/extent_io.h
            fs/btrfs/scrub.c
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

commit 90519d66abbccc251d14719ac76f191f70826e40
Author: Arne Jansen <sensille@gmx.net>
Date:   Mon May 23 14:30:00 2011 +0200

    btrfs: state information for readahead
    
    Add state information for readahead to btrfs_fs_info and btrfs_device
    
    Changes v2:
     - don't wait in radix_trees
     - add own set of workers for readahead
    
    Reviewed-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Arne Jansen <sensille@gmx.net>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 6d866db4e177..2a751246188a 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -92,6 +92,14 @@ struct btrfs_device {
 	struct btrfs_work work;
 	struct rcu_head rcu;
 	struct work_struct rcu_work;
+
+	/* readahead state */
+	spinlock_t reada_lock;
+	atomic_t reada_in_flight;
+	u64 reada_next;
+	struct reada_zone *reada_curr_zone;
+	struct radix_tree_root reada_zones;
+	struct radix_tree_root reada_extents;
 };
 
 struct btrfs_fs_devices {

commit a1d3c4786a4b9c71c0767aa656a759968f7554b6
Author: Jan Schmidt <list.btrfs@jan-o-sch.net>
Date:   Thu Aug 4 17:15:33 2011 +0200

    btrfs: btrfs_multi_bio replaced with btrfs_bio
    
    btrfs_bio is a bio abstraction able to split and not complete after the last
    bio has returned (like the old btrfs_multi_bio). Additionally, btrfs_bio
    tracks the mirror_num used to read data which can be used for error
    correction purposes.
    
    Signed-off-by: Jan Schmidt <list.btrfs@jan-o-sch.net>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 6d866db4e177..71f4f3f67495 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -136,7 +136,10 @@ struct btrfs_bio_stripe {
 	u64 length; /* only used for discard mappings */
 };
 
-struct btrfs_multi_bio {
+struct btrfs_bio;
+typedef void (btrfs_bio_end_io_t) (struct btrfs_bio *bio, int err);
+
+struct btrfs_bio {
 	atomic_t stripes_pending;
 	bio_end_io_t *end_io;
 	struct bio *orig_bio;
@@ -144,6 +147,7 @@ struct btrfs_multi_bio {
 	atomic_t error;
 	int max_errors;
 	int num_stripes;
+	int mirror_num;
 	struct btrfs_bio_stripe stripes[];
 };
 
@@ -171,7 +175,7 @@ struct map_lookup {
 int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,
 				   u64 end, u64 *length);
 
-#define btrfs_multi_bio_size(n) (sizeof(struct btrfs_multi_bio) + \
+#define btrfs_bio_size(n) (sizeof(struct btrfs_bio) + \
 			    (sizeof(struct btrfs_bio_stripe) * (n)))
 
 int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,
@@ -180,7 +184,7 @@ int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,
 			   u64 chunk_offset, u64 start, u64 num_bytes);
 int btrfs_map_block(struct btrfs_mapping_tree *map_tree, int rw,
 		    u64 logical, u64 *length,
-		    struct btrfs_multi_bio **multi_ret, int mirror_num);
+		    struct btrfs_bio **bbio_ret, int mirror_num);
 int btrfs_rmap_block(struct btrfs_mapping_tree *map_tree,
 		     u64 chunk_start, u64 physical, u64 devid,
 		     u64 **logical, int *naddrs, int *stripe_len);

commit d5e2003c2bcda93a8f2e668eb4642d70c9c38301
Author: Josef Bacik <josef@redhat.com>
Date:   Thu Aug 4 14:52:27 2011 +0000

    Btrfs: detect wether a device supports discard
    
    We have a problem where if a user specifies discard but doesn't actually support
    it we will return EOPNOTSUPP from btrfs_discard_extent.  This is a problem
    because this gets called (in a fashion) from the tree log recovery code, which
    has a nice little BUG_ON(ret) after it, which causes us to fail the tree log
    replay.  So instead detect wether our devices support discard when we're adding
    them and then don't issue discards if we know that the device doesn't support
    it.  And just for good measure set ret = 0 in btrfs_issue_discard just in case
    we still get EOPNOTSUPP so we don't screw anybody up like this again.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 7c12d61ae7ae..6d866db4e177 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -48,6 +48,7 @@ struct btrfs_device {
 	int writeable;
 	int in_fs_metadata;
 	int missing;
+	int can_discard;
 
 	spinlock_t io_lock;
 
@@ -104,6 +105,7 @@ struct btrfs_fs_devices {
 	u64 rw_devices;
 	u64 missing_devices;
 	u64 total_rw_bytes;
+	u64 num_can_discard;
 	struct block_device *latest_bdev;
 
 	/* all of the devices in the FS, protected by a mutex

commit d6c0cb379c5198487e4ac124728cbb2346d63b1f
Merge: 8e531cdfeb75 1f78160ce1b1
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon May 23 14:37:47 2011 -0400

    Merge branch 'cleanups_and_fixes' into inode_numbers
    
    Conflicts:
            fs/btrfs/tree-log.c
            fs/btrfs/volumes.c
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

commit 1f78160ce1b1b8e657e2248118c4d91f881763f0
Author: Xiao Guangrong <xiaoguangrong@cn.fujitsu.com>
Date:   Wed Apr 20 10:09:16 2011 +0000

    Btrfs: using rcu lock in the reader side of devices list
    
    fs_devices->devices is only updated on remove and add device paths, so we can
    use rcu to protect it in the reader side
    
    Signed-off-by: Xiao Guangrong <xiaoguangrong@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index cc2eadaf7a27..f1b2e4f53fc2 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -86,6 +86,8 @@ struct btrfs_device {
 	u8 uuid[BTRFS_UUID_SIZE];
 
 	struct btrfs_work work;
+	struct rcu_head rcu;
+	struct work_struct rcu_work;
 };
 
 struct btrfs_fs_devices {

commit 712673339a0d085358fd1cd3a6477cc7979bb69f
Merge: aa2dfb372a2a 8628764e1a5e
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon May 23 06:30:52 2011 -0400

    Merge branch 'for-chris' of git://git.kernel.org/pub/scm/linux/kernel/git/arne/btrfs-unstable-arne into inode_numbers
    
    Conflicts:
            fs/btrfs/Makefile
            fs/btrfs/ctree.h
            fs/btrfs/volumes.h
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

commit aa2dfb372a2a647beedac163ce6f8b0fcbefac29
Merge: 945d8962ceee 73c5de005153
Author: Chris Mason <chris.mason@oracle.com>
Date:   Sun May 22 12:36:34 2011 -0400

    Merge branch 'allocator' of git://git.kernel.org/pub/scm/linux/kernel/git/arne/btrfs-unstable-arne into inode_numbers
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

commit 73c5de0051533cbdf2bb656586c3eb21a475aa7d
Author: Arne Jansen <sensille@gmx.net>
Date:   Tue Apr 12 12:07:57 2011 +0200

    btrfs: quasi-round-robin for chunk allocation
    
    In a multi device setup, the chunk allocator currently always allocates
    chunks on the devices in the same order. This leads to a very uneven
    distribution, especially with RAID1 or RAID10 and an uneven number of
    devices.
    This patch always sorts the devices before allocating, and allocates the
    stripes on the devices with the most available space, as long as there
    is enough space available. In a low space situation, it first tries to
    maximize striping.
    The patch also simplifies the allocator and reduces the checks for
    corner cases.
    The simplification is done by several means. First, it defines the
    properties of each RAID type upfront. These properties are used afterwards
    instead of differentiating cases in several places.
    Second, the old allocator defined a minimum stripe size for each block
    group type, tried to find a large enough chunk, and if this fails just
    allocates a smaller one. This is now done in one step. The largest possible
    chunk (up to max_chunk_size) is searched and allocated.
    Because we now have only one pass, the allocation of the map (struct
    map_lookup) is moved down to the point where the number of stripes is
    already known. This way we avoid reallocation of the map.
    We still avoid allocating stripes that are not a multiple of STRIPE_SIZE.

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index b502f01f79ed..37ae6e2126a1 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -144,6 +144,7 @@ struct btrfs_device_info {
 	struct btrfs_device *dev;
 	u64 dev_offset;
 	u64 max_avail;
+	u64 total_avail;
 };
 
 struct map_lookup {

commit bcd53741cc2af4342ac3ff6983bddc4a1b63b9b4
Author: Arne Jansen <sensille@gmx.net>
Date:   Tue Apr 12 10:43:21 2011 +0200

    btrfs: move btrfs_cmp_device_free_bytes to super.c
    
    this function won't be used here anymore, so move it super.c where it is
    used for df-calculation

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index cc2eadaf7a27..b502f01f79ed 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -157,21 +157,6 @@ struct map_lookup {
 	struct btrfs_bio_stripe stripes[];
 };
 
-/* Used to sort the devices by max_avail(descending sort) */
-int btrfs_cmp_device_free_bytes(const void *dev_info1, const void *dev_info2);
-
-/*
- * sort the devices by max_avail, in which max free extent size of each device
- * is stored.(Descending Sort)
- */
-static inline void btrfs_descending_sort_devices(
-					struct btrfs_device_info *devices,
-					size_t nr_devices)
-{
-	sort(devices, nr_devices, sizeof(struct btrfs_device_info),
-	     btrfs_cmp_device_free_bytes, NULL);
-}
-
 int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,
 				   u64 end, u64 *length);
 

commit a2de733c78fa7af51ba9670482fa7d392aa67c57
Author: Arne Jansen <sensille@gmx.net>
Date:   Tue Mar 8 14:14:00 2011 +0100

    btrfs: scrub
    
    This adds an initial implementation for scrub. It works quite
    straightforward. The usermode issues an ioctl for each device in the
    fs. For each device, it enumerates the allocated device chunks. For
    each chunk, the contained extents are enumerated and the data checksums
    fetched. The extents are read sequentially and the checksums verified.
    If an error occurs (checksum or EIO), a good copy is searched for. If
    one is found, the bad copy will be rewritten.
    All enumerations happen from the commit roots. During a transaction
    commit, the scrubs get paused and afterwards continue from the new
    roots.
    
    This commit is based on the series originally posted to linux-btrfs
    with some improvements that resulted from comments from David Sterba,
    Ilya Dryomov and Jan Schmidt.
    
    Signed-off-by: Arne Jansen <sensille@gmx.net>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index cc2eadaf7a27..f7c20123a1fe 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -85,6 +85,9 @@ struct btrfs_device {
 	/* physical drive uuid (or lvm uuid) */
 	u8 uuid[BTRFS_UUID_SIZE];
 
+	/* per-device scrub information */
+	struct scrub_dev *scrub_device;
+
 	struct btrfs_work work;
 };
 
@@ -157,6 +160,9 @@ struct map_lookup {
 	struct btrfs_bio_stripe stripes[];
 };
 
+#define map_lookup_size(n) (sizeof(struct map_lookup) + \
+			    (sizeof(struct btrfs_bio_stripe) * (n)))
+
 /* Used to sort the devices by max_avail(descending sort) */
 int btrfs_cmp_device_free_bytes(const void *dev_info1, const void *dev_info2);
 

commit f2a97a9dbd86eb1ef956bdf20e05c507b32beb96
Author: David Sterba <dsterba@suse.cz>
Date:   Thu May 5 12:44:41 2011 +0200

    btrfs: remove all unused functions
    
    Remove static and global declarations and/or definitions. Reduces size
    of btrfs.ko by ~3.4kB.
    
      text    data     bss     dec     hex filename
    402081    7464     200  409745   64091 btrfs.ko.base
    398620    7144     200  405964   631cc btrfs.ko.remove-all
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 036b276b4860..5669ae8ea1c9 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -196,7 +196,6 @@ void btrfs_mapping_init(struct btrfs_mapping_tree *tree);
 void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree);
 int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,
 		  int mirror_num, int async_submit);
-int btrfs_read_super_device(struct btrfs_root *root, struct extent_buffer *buf);
 int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
 		       fmode_t flags, void *holder);
 int btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,
@@ -216,8 +215,6 @@ struct btrfs_device *btrfs_find_device(struct btrfs_root *root, u64 devid,
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_root *root, char *path);
 int btrfs_balance(struct btrfs_root *dev_root);
-void btrfs_unlock_volumes(void);
-void btrfs_lock_volumes(void);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
 int find_free_dev_extent(struct btrfs_trans_handle *trans,
 			 struct btrfs_device *device, u64 num_bytes,

commit 621496f4fd56195b7b273521f467c2945165481f
Author: David Sterba <dsterba@suse.cz>
Date:   Wed May 4 12:56:49 2011 +0200

    btrfs: remove unused function prototypes
    
    function prototypes without a body
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index cc2eadaf7a27..036b276b4860 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -209,8 +209,6 @@ int btrfs_add_device(struct btrfs_trans_handle *trans,
 int btrfs_rm_device(struct btrfs_root *root, char *device_path);
 int btrfs_cleanup_fs_uuids(void);
 int btrfs_num_copies(struct btrfs_mapping_tree *map_tree, u64 logical, u64 len);
-int btrfs_unplug_page(struct btrfs_mapping_tree *map_tree,
-		      u64 logical, struct page *page);
 int btrfs_grow_device(struct btrfs_trans_handle *trans,
 		      struct btrfs_device *device, u64 new_size);
 struct btrfs_device *btrfs_find_device(struct btrfs_root *root, u64 devid,

commit fce3bb9a1bd492793170e117c60d5718b7896af4
Author: Li Dongyang <lidongyang@novell.com>
Date:   Thu Mar 24 10:24:26 2011 +0000

    Btrfs: make btrfs_map_block() return entire free extent for each device of RAID0/1/10/DUP
    
    btrfs_map_block() will only return a single stripe length, but we want the
    full extent be mapped to each disk when we are trimming the extent,
    so we add length to btrfs_bio_stripe and fill it if we are mapping for REQ_DISCARD.
    
    Signed-off-by: Li Dongyang <lidongyang@novell.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 7b38d0668b51..cc2eadaf7a27 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -126,6 +126,7 @@ struct btrfs_fs_devices {
 struct btrfs_bio_stripe {
 	struct btrfs_device *dev;
 	u64 physical;
+	u64 length; /* only used for discard mappings */
 };
 
 struct btrfs_multi_bio {

commit 1abe9b8a138c9988ba8f7bfded6453649a31541f
Author: liubo <liubo2009@cn.fujitsu.com>
Date:   Thu Mar 24 11:18:59 2011 +0000

    Btrfs: add initial tracepoint support for btrfs
    
    Tracepoints can provide insight into why btrfs hits bugs and be greatly
    helpful for debugging, e.g
                  dd-7822  [000]  2121.641088: btrfs_inode_request: root = 5(FS_TREE), gen = 4, ino = 256, blocks = 8, disk_i_size = 0, last_trans = 8, logged_trans = 0
                  dd-7822  [000]  2121.641100: btrfs_inode_new: root = 5(FS_TREE), gen = 8, ino = 257, blocks = 0, disk_i_size = 0, last_trans = 0, logged_trans = 0
     btrfs-transacti-7804  [001]  2146.935420: btrfs_cow_block: root = 2(EXTENT_TREE), refs = 2, orig_buf = 29368320 (orig_level = 0), cow_buf = 29388800 (cow_level = 0)
     btrfs-transacti-7804  [001]  2146.935473: btrfs_cow_block: root = 1(ROOT_TREE), refs = 2, orig_buf = 29364224 (orig_level = 0), cow_buf = 29392896 (cow_level = 0)
     btrfs-transacti-7804  [001]  2146.972221: btrfs_transaction_commit: root = 1(ROOT_TREE), gen = 8
       flush-btrfs-2-7821  [001]  2155.824210: btrfs_chunk_alloc: root = 3(CHUNK_TREE), offset = 1103101952, size = 1073741824, num_stripes = 1, sub_stripes = 0, type = DATA
       flush-btrfs-2-7821  [001]  2155.824241: btrfs_cow_block: root = 2(EXTENT_TREE), refs = 2, orig_buf = 29388800 (orig_level = 0), cow_buf = 29396992 (cow_level = 0)
       flush-btrfs-2-7821  [001]  2155.824255: btrfs_cow_block: root = 4(DEV_TREE), refs = 2, orig_buf = 29372416 (orig_level = 0), cow_buf = 29401088 (cow_level = 0)
       flush-btrfs-2-7821  [000]  2155.824329: btrfs_cow_block: root = 3(CHUNK_TREE), refs = 2, orig_buf = 20971520 (orig_level = 0), cow_buf = 20975616 (cow_level = 0)
     btrfs-endio-wri-7800  [001]  2155.898019: btrfs_cow_block: root = 5(FS_TREE), refs = 2, orig_buf = 29384704 (orig_level = 0), cow_buf = 29405184 (cow_level = 0)
     btrfs-endio-wri-7800  [001]  2155.898043: btrfs_cow_block: root = 7(CSUM_TREE), refs = 2, orig_buf = 29376512 (orig_level = 0), cow_buf = 29409280 (cow_level = 0)
    
    Here is what I have added:
    
    1) ordere_extent:
            btrfs_ordered_extent_add
            btrfs_ordered_extent_remove
            btrfs_ordered_extent_start
            btrfs_ordered_extent_put
    
    These provide critical information to understand how ordered_extents are
    updated.
    
    2) extent_map:
            btrfs_get_extent
    
    extent_map is used in both read and write cases, and it is useful for tracking
    how btrfs specific IO is running.
    
    3) writepage:
            __extent_writepage
            btrfs_writepage_end_io_hook
    
    Pages are cirtical resourses and produce a lot of corner cases during writeback,
    so it is valuable to know how page is written to disk.
    
    4) inode:
            btrfs_inode_new
            btrfs_inode_request
            btrfs_inode_evict
    
    These can show where and when a inode is created, when a inode is evicted.
    
    5) sync:
            btrfs_sync_file
            btrfs_sync_fs
    
    These show sync arguments.
    
    6) transaction:
            btrfs_transaction_commit
    
    In transaction based filesystem, it will be useful to know the generation and
    who does commit.
    
    7) back reference and cow:
            btrfs_delayed_tree_ref
            btrfs_delayed_data_ref
            btrfs_delayed_ref_head
            btrfs_cow_block
    
    Btrfs natively supports back references, these tracepoints are helpful on
    understanding btrfs's COW mechanism.
    
    8) chunk:
            btrfs_chunk_alloc
            btrfs_chunk_free
    
    Chunk is a link between physical offset and logical offset, and stands for space
    infomation in btrfs, and these are helpful on tracing space things.
    
    9) reserved_extent:
            btrfs_reserved_extent_alloc
            btrfs_reserved_extent_free
    
    These can show how btrfs uses its space.
    
    Signed-off-by: Liu Bo <liubo2009@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 7fb59d45fe8c..7b38d0668b51 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -145,6 +145,17 @@ struct btrfs_device_info {
 	u64 max_avail;
 };
 
+struct map_lookup {
+	u64 type;
+	int io_align;
+	int io_width;
+	int stripe_len;
+	int sector_size;
+	int num_stripes;
+	int sub_stripes;
+	struct btrfs_bio_stripe stripes[];
+};
+
 /* Used to sort the devices by max_avail(descending sort) */
 int btrfs_cmp_device_free_bytes(const void *dev_info1, const void *dev_info2);
 

commit eee2a817df7c5a6e569f353f8be78cc1b3604bb6
Merge: 83896fb5e515 acce952b0263
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 17 14:43:43 2011 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable: (25 commits)
      Btrfs: forced readonly mounts on errors
      btrfs: Require CAP_SYS_ADMIN for filesystem rebalance
      Btrfs: don't warn if we get ENOSPC in btrfs_block_rsv_check
      btrfs: Fix memory leak in btrfs_read_fs_root_no_radix()
      btrfs: check NULL or not
      btrfs: Don't pass NULL ptr to func that may deref it.
      btrfs: mount failure return value fix
      btrfs: Mem leak in btrfs_get_acl()
      btrfs: fix wrong free space information of btrfs
      btrfs: make the chunk allocator utilize the devices better
      btrfs: restructure find_free_dev_extent()
      btrfs: fix wrong calculation of stripe size
      btrfs: try to reclaim some space when chunk allocation fails
      btrfs: fix wrong data space statistics
      fs/btrfs: Fix build of ctree
      Btrfs: fix off by one while setting block groups readonly
      Btrfs: Add BTRFS_IOC_SUBVOL_GETFLAGS/SETFLAGS ioctls
      Btrfs: Add readonly snapshots support
      Btrfs: Refactor btrfs_ioctl_snap_create()
      btrfs: Extract duplicate decompress code
      ...

commit 6d07bcec969af335d4e35b3921131b7929bd634e
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Jan 5 10:07:31 2011 +0000

    btrfs: fix wrong free space information of btrfs
    
    When we store data by raid profile in btrfs with two or more different size
    disks, df command shows there is some free space in the filesystem, but the
    user can not write any data in fact, df command shows the wrong free space
    information of btrfs.
    
     # mkfs.btrfs -d raid1 /dev/sda9 /dev/sda10
     # btrfs-show
     Label: none  uuid: a95cd49e-6e33-45b8-8741-a36153ce4b64
            Total devices 2 FS bytes used 28.00KB
            devid    1 size 5.01GB used 2.03GB path /dev/sda9
            devid    2 size 10.00GB used 2.01GB path /dev/sda10
     # btrfs device scan /dev/sda9 /dev/sda10
     # mount /dev/sda9 /mnt
     # dd if=/dev/zero of=tmpfile0 bs=4K count=9999999999
       (fill the filesystem)
     # sync
     # df -TH
     Filesystem     Type    Size    Used    Avail   Use%    Mounted on
     /dev/sda9      btrfs   17G     8.6G    5.4G    62%     /mnt
     # btrfs-show
     Label: none  uuid: a95cd49e-6e33-45b8-8741-a36153ce4b64
            Total devices 2 FS bytes used 3.99GB
            devid    1 size 5.01GB used 5.01GB path /dev/sda9
            devid    2 size 10.00GB used 4.99GB path /dev/sda10
    
    It is because btrfs cannot allocate chunks when one of the pairing disks has
    no space, the free space on the other disks can not be used for ever, and should
    be subtracted from the total space, but btrfs doesn't subtract this space from
    the total. It is strange to the user.
    
    This patch fixes it by calcing the free space that can be used to allocate
    chunks.
    
    Implementation:
    1. get all the devices free space, and align them by stripe length.
    2. sort the devices by the free space.
    3. check the free space of the devices,
       3.1. if it is not zero, and then check the number of the devices that has
            more free space than this device,
            if the number of the devices is beyond the min stripe number, the free
            space can be used, and add into total free space.
            if the number of the devices is below the min stripe number, we can not
            use the free space, the check ends.
       3.2. if the free space is zero, check the next devices, goto 3.1
    
    This implementation is just likely fake chunk allocation.
    
    After appling this patch, df can show correct space information:
     # df -TH
     Filesystem     Type    Size    Used    Avail   Use%    Mounted on
     /dev/sda9      btrfs   17G     8.6G    0       100%    /mnt
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index a5cfedf393f9..7af6144a7954 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -161,6 +161,9 @@ static inline void btrfs_descending_sort_devices(
 	     btrfs_cmp_device_free_bytes, NULL);
 }
 
+int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,
+				   u64 end, u64 *length);
+
 #define btrfs_multi_bio_size(n) (sizeof(struct btrfs_multi_bio) + \
 			    (sizeof(struct btrfs_bio_stripe) * (n)))
 

commit b2117a39fa96cf4814e7cab8c11494149ba6f29d
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Jan 5 10:07:28 2011 +0000

    btrfs: make the chunk allocator utilize the devices better
    
    With this patch, we change the handling method when we can not get enough free
    extents with default size.
    
    Implementation:
    1. Look up the suitable free extent on each device and keep the search result.
       If not find a suitable free extent, keep the max free extent
    2. If we get enough suitable free extents with default size, chunk allocation
       succeeds.
    3. If we can not get enough free extents, but the number of the extent with
       default size is >= min_stripes, we just change the mapping information
       (reduce the number of stripes in the extent map), and chunk allocation
       succeeds.
    4. If the number of the extent with default size is < min_stripes, sort the
       devices by its max free extent's size descending
    5. Use the size of the max free extent on the (num_stripes - 1)th device as the
       stripe size to allocate the device space
    
    By this way, the chunk allocator can allocate chunks as large as possible when
    the devices' space is not enough and make full use of the devices.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index a668c0116982..a5cfedf393f9 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -20,8 +20,11 @@
 #define __BTRFS_VOLUMES_
 
 #include <linux/bio.h>
+#include <linux/sort.h>
 #include "async-thread.h"
 
+#define BTRFS_STRIPE_LEN	(64 * 1024)
+
 struct buffer_head;
 struct btrfs_pending_bios {
 	struct bio *head;
@@ -137,6 +140,27 @@ struct btrfs_multi_bio {
 	struct btrfs_bio_stripe stripes[];
 };
 
+struct btrfs_device_info {
+	struct btrfs_device *dev;
+	u64 dev_offset;
+	u64 max_avail;
+};
+
+/* Used to sort the devices by max_avail(descending sort) */
+int btrfs_cmp_device_free_bytes(const void *dev_info1, const void *dev_info2);
+
+/*
+ * sort the devices by max_avail, in which max free extent size of each device
+ * is stored.(Descending Sort)
+ */
+static inline void btrfs_descending_sort_devices(
+					struct btrfs_device_info *devices,
+					size_t nr_devices)
+{
+	sort(devices, nr_devices, sizeof(struct btrfs_device_info),
+	     btrfs_cmp_device_free_bytes, NULL);
+}
+
 #define btrfs_multi_bio_size(n) (sizeof(struct btrfs_multi_bio) + \
 			    (sizeof(struct btrfs_bio_stripe) * (n)))
 

commit 275220f0fcff1adf28a717076e00f575edf05fda
Merge: fe3c560b8a22 81c5e2ae33c4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 13 10:45:01 2011 -0800

    Merge branch 'for-2.6.38/core' of git://git.kernel.dk/linux-2.6-block
    
    * 'for-2.6.38/core' of git://git.kernel.dk/linux-2.6-block: (43 commits)
      block: ensure that completion error gets properly traced
      blktrace: add missing probe argument to block_bio_complete
      block cfq: don't use atomic_t for cfq_group
      block cfq: don't use atomic_t for cfq_queue
      block: trace event block fix unassigned field
      block: add internal hd part table references
      block: fix accounting bug on cross partition merges
      kref: add kref_test_and_get
      bio-integrity: mark kintegrityd_wq highpri and CPU intensive
      block: make kblockd_workqueue smarter
      Revert "sd: implement sd_check_events()"
      block: Clean up exit_io_context() source code.
      Fix compile warnings due to missing removal of a 'ret' variable
      fs/block: type signature of major_to_index(int) to major_to_index(unsigned)
      block: convert !IS_ERR(p) && p to !IS_ERR_NOR_NULL(p)
      cfq-iosched: don't check cfqg in choose_service_tree()
      fs/splice: Pull buf->ops->confirm() from splice_from_pipe actors
      cdrom: export cdrom_check_events()
      sd: implement sd_check_events()
      sr: implement sr_check_events()
      ...

commit e13cf63f2bbd38721af557f0205da994ea068427
Merge: 073f21ae1319 83a50de97fe9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 14 11:08:13 2010 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable:
      Btrfs: prevent RAID level downgrades when space is low
      Btrfs: account for missing devices in RAID allocation profiles
      Btrfs: EIO when we fail to read tree roots
      Btrfs: fix compiler warnings
      Btrfs: Make async snapshot ioctl more generic
      Btrfs: pwrite blocked when writing from the mmaped buffer of the same page
      Btrfs: Fix a crash when mounting a subvolume
      Btrfs: fix sync subvol/snapshot creation
      Btrfs: Fix page leak in compressed writeback path
      Btrfs: do not BUG if we fail to remove the orphan item for dead snapshots
      Btrfs: fixup return code for btrfs_del_orphan_item
      Btrfs: do not do fast caching if we are allocating blocks for tree_root
      Btrfs: deal with space cache errors better
      Btrfs: fix use after free in O_DIRECT

commit cd02dca56442e1504fd6bc5b96f7f1870162b266
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Dec 13 14:56:23 2010 -0500

    Btrfs: account for missing devices in RAID allocation profiles
    
    When we mount in RAID degraded mode without adding a new device to
    replace the failed one, we can end up using the wrong RAID flags for
    allocations.
    
    This results in strange combinations of block groups (raid1 in a raid10
    filesystem) and corruptions when we try to allocate blocks from single
    spindle chunks on drives that are actually missing.
    
    The first device has two small 4MB chunks in it that mkfs creates and
    these are usually unused in a raid1 or raid10 setup.  But, in -o degraded,
    the allocator will fall back to these because the mask of desired raid groups
    isn't correct.
    
    The fix here is to count the missing devices as we build up the list
    of devices in the system.  This count is used when picking the
    raid level to make sure we continue using the same levels that were
    in place before we lost a drive.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 31b0fabdd2ea..a668c0116982 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -45,6 +45,7 @@ struct btrfs_device {
 	int barriers;
 	int writeable;
 	int in_fs_metadata;
+	int missing;
 
 	spinlock_t io_lock;
 
@@ -94,6 +95,7 @@ struct btrfs_fs_devices {
 	u64 num_devices;
 	u64 open_devices;
 	u64 rw_devices;
+	u64 missing_devices;
 	u64 total_rw_bytes;
 	struct block_device *latest_bdev;
 

commit d4d77629953eabd3c14f6fa5746f6b28babfc55f
Author: Tejun Heo <tj@kernel.org>
Date:   Sat Nov 13 11:55:18 2010 +0100

    block: clean up blkdev_get() wrappers and their users
    
    After recent blkdev_get() modifications, open_by_devnum() and
    open_bdev_exclusive() are simple wrappers around blkdev_get().
    Replace them with blkdev_get_by_dev() and blkdev_get_by_path().
    
    blkdev_get_by_dev() is identical to open_by_devnum().
    blkdev_get_by_path() is slightly different in that it doesn't
    automatically add %FMODE_EXCL to @mode.
    
    All users are converted.  Most conversions are mechanical and don't
    introduce any behavior difference.  There are several exceptions.
    
    * btrfs now sets FMODE_EXCL in btrfs_device->mode, so there's no
      reason to OR it explicitly on blkdev_put().
    
    * gfs2, nilfs2 and the generic mount_bdev() now set FMODE_EXCL in
      sb->s_mode.
    
    * With the above changes, sb->s_mode now always should contain
      FMODE_EXCL.  WARN_ON_ONCE() added to kill_block_super() to detect
      errors.
    
    The new blkdev_get_*() functions are with proper docbook comments.
    While at it, add function description to blkdev_get() too.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Philipp Reisner <philipp.reisner@linbit.com>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Joern Engel <joern@lazybastard.org>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: KONISHI Ryusuke <konishi.ryusuke@lab.ntt.co.jp>
    Cc: reiserfs-devel@vger.kernel.org
    Cc: xfs-masters@oss.sgi.com
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 2b638b6e4eea..856e75770304 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -49,7 +49,7 @@ struct btrfs_device {
 
 	struct block_device *bdev;
 
-	/* the mode sent to open_bdev_exclusive */
+	/* the mode sent to blkdev_get */
 	fmode_t mode;
 
 	char *name;

commit c3b9a62c8f932f32a733d6b628f61f3f28345727
Author: Christoph Hellwig <hch@infradead.org>
Date:   Wed Aug 18 05:29:12 2010 -0400

    btrfs: replace barriers with explicit flush / FUA usage
    
    Switch to the WRITE_FLUSH_FUA flag for log writes, remove the EOPNOTSUPP
    detection for barriers and stop setting the barrier flag for discards.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Chris Mason <chris.mason@oracle.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 31b0fabdd2ea..2b638b6e4eea 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -42,7 +42,6 @@ struct btrfs_device {
 	int running_pending;
 	u64 generation;
 
-	int barriers;
 	int writeable;
 	int in_fs_metadata;
 

commit ba1bf4818baf68d914ef9e3b06fbea6acb674fe4
Author: Josef Bacik <josef@redhat.com>
Date:   Fri Sep 11 16:11:19 2009 -0400

    Btrfs: make balance code choose more wisely when relocating
    
    Currently, we can panic the box if the first block group we go to move is of a
    type where there is no space left to move those extents.  For example, if we
    fill the disk up with data, and then we try to balance and we have no room to
    move the data nor room to allocate new chunks, we will panic.  Change this by
    checking to see if we have room to move this chunk around, and if not, return
    -ENOSPC and move on to the next chunk.  This will make sure we remove block
    groups that are moveable, like if we have alot of empty metadata block groups,
    and then that way we make room to be able to balance our data chunks as well.
    Tested this with an fs that would panic on btrfs-vol -b normally, but no longer
    panics with this patch.
    
    V1->V2:
    -actually search for a free extent on the device to make sure we can allocate a
    chunk if need be.
    
    -fix btrfs_shrink_device to make sure we actually try to relocate all the
    chunks, and then if we can't return -ENOSPC so if we are doing a btrfs-vol -r
    we don't remove the device with data still on it.
    
    -check to make sure the block group we are going to relocate isn't the last one
    in that particular space
    
    -fix a bug in btrfs_shrink_device where we would change the device's size and
    not fix it if we fail to do our relocate
    
    Signed-off-by: Josef Bacik <jbacik@redhat.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 5139a833f721..31b0fabdd2ea 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -181,4 +181,7 @@ int btrfs_balance(struct btrfs_root *dev_root);
 void btrfs_unlock_volumes(void);
 void btrfs_lock_volumes(void);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
+int find_free_dev_extent(struct btrfs_trans_handle *trans,
+			 struct btrfs_device *device, u64 num_bytes,
+			 u64 *start, u64 *max_avail);
 #endif

commit e5e9a5206a171b2c467e494aebcdcf70c47289bc
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Jun 10 15:17:02 2009 -0400

    Btrfs: avoid races between super writeout and device list updates
    
    On multi-device filesystems, btrfs writes supers to all of the devices
    before considering a sync complete.  There wasn't any additional
    locking between super writeout and the device list management code
    because device management was done inside a transaction and
    super writeout only happened  with no transation writers running.
    
    With the btrfs fsync log and other async transaction updates, this
    has been racey for some time.  This adds a mutex to protect
    the device list.  The existing volume mutex could not be reused due to
    transaction lock ordering requirements.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 3c1f7310421e..5139a833f721 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -96,7 +96,12 @@ struct btrfs_fs_devices {
 	u64 rw_devices;
 	u64 total_rw_bytes;
 	struct block_device *latest_bdev;
-	/* all of the devices in the FS */
+
+	/* all of the devices in the FS, protected by a mutex
+	 * so we can safely walk it to write out the supers without
+	 * worrying about add/remove by the multi-device code
+	 */
+	struct mutex device_list_mutex;
 	struct list_head devices;
 
 	/* devices not currently being allocated */

commit c289811cc096c57ff35550ee8132793a4f9b5b59
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Jun 10 09:51:32 2009 -0400

    Btrfs: autodetect SSD devices
    
    During mount, btrfs will check the queue nonrot flag
    for all the devices found in the FS.  If they are all
    non-rotating, SSD mode is enabled by default.
    
    If the FS was mounted with -o nossd, the non-rotating
    flag is ignored.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 5c3ff6d02fd7..3c1f7310421e 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -107,6 +107,11 @@ struct btrfs_fs_devices {
 	int seeding;
 
 	int opened;
+
+	/* set when we find or add a device that doesn't have the
+	 * nonrot flag set
+	 */
+	int rotating;
 };
 
 struct btrfs_bio_stripe {

commit d6397baee468809ef311e763dfc6e9f73418f8a6
Author: Chris Ball <cjb@laptop.org>
Date:   Mon Apr 27 07:29:03 2009 -0400

    Btrfs: When shrinking, only update disk size on success
    
    Previously, we updated a device's size prior to attempting a shrink
    operation.  This patch moves the device resizing logic to only happen if
    the shrink completes successfully.  In the process, it introduces a new
    field to btrfs_device -- disk_total_bytes -- to track the on-disk size.
    
    Signed-off-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 5836327ba5dd..5c3ff6d02fd7 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -61,6 +61,9 @@ struct btrfs_device {
 	/* size of the device */
 	u64 total_bytes;
 
+	/* size of the disk */
+	u64 disk_total_bytes;
+
 	/* bytes used */
 	u64 bytes_used;
 

commit ffbd517d5a8c8e93ddd11046434fb029f3df73aa
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Apr 20 15:50:09 2009 -0400

    Btrfs: use WRITE_SYNC for synchronous writes
    
    Part of reducing fsync/O_SYNC/O_DIRECT latencies is using WRITE_SYNC for
    writes we plan on waiting on in the near future.  This patch
    mirrors recent changes in other filesystems and the generic code to
    use WRITE_SYNC when WB_SYNC_ALL is passed and to use WRITE_SYNC for
    other latency critical writes.
    
    Btrfs uses async worker threads for checksumming before the write is done,
    and then again to actually submit the bios.  The bio submission code just
    runs a per-device list of bios that need to be sent down the pipe.
    
    This list is split into low priority and high priority lists so the
    WRITE_SYNC IO happens first.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 2185de72ff7d..5836327ba5dd 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -23,13 +23,22 @@
 #include "async-thread.h"
 
 struct buffer_head;
+struct btrfs_pending_bios {
+	struct bio *head;
+	struct bio *tail;
+};
+
 struct btrfs_device {
 	struct list_head dev_list;
 	struct list_head dev_alloc_list;
 	struct btrfs_fs_devices *fs_devices;
 	struct btrfs_root *dev_root;
-	struct bio *pending_bios;
-	struct bio *pending_bio_tail;
+
+	/* regular prio bios */
+	struct btrfs_pending_bios pending_bios;
+	/* WRITE_SYNC bios */
+	struct btrfs_pending_bios pending_sync_bios;
+
 	int running_pending;
 	u64 generation;
 

commit d4a789474a6213d1b55b363fb1787b0abf877bba
Author: Wu Fengguang <fengguang.wu@intel.com>
Date:   Thu Apr 2 16:46:06 2009 -0400

    Btrfs: fix typos in comments
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 86c44e9ae110..2185de72ff7d 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -76,7 +76,7 @@ struct btrfs_device {
 struct btrfs_fs_devices {
 	u8 fsid[BTRFS_FSID_SIZE]; /* FS specific uuid */
 
-	/* the device with this id has the most recent coyp of the super */
+	/* the device with this id has the most recent copy of the super */
 	u64 latest_devid;
 	u64 latest_trans;
 	u64 num_devices;

commit e4404d6e8da678d852b7f767f665f8edf76c9e9f
Author: Yan Zheng <zheng.yan@oracle.com>
Date:   Fri Dec 12 10:03:26 2008 -0500

    Btrfs: shared seed device
    
    This patch makes seed device possible to be shared by
    multiple mounted file systems. The sharing is achieved
    by cloning seed device's btrfs_fs_devices structure.
    Thanks you,
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index bdebe83c3195..86c44e9ae110 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -93,7 +93,6 @@ struct btrfs_fs_devices {
 
 	struct btrfs_fs_devices *seed;
 	int seeding;
-	int sprouted;
 
 	int opened;
 };
@@ -127,7 +126,7 @@ int btrfs_map_block(struct btrfs_mapping_tree *map_tree, int rw,
 int btrfs_rmap_block(struct btrfs_mapping_tree *map_tree,
 		     u64 chunk_start, u64 physical, u64 devid,
 		     u64 **logical, int *naddrs, int *stripe_len);
-int btrfs_read_sys_array(struct btrfs_root *root, u64 sb_bytenr);
+int btrfs_read_sys_array(struct btrfs_root *root);
 int btrfs_read_chunk_tree(struct btrfs_root *root);
 int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
 		      struct btrfs_root *extent_root, u64 type);

commit a512bbf855ff0af474257475f2e6da7acd854f52
Author: Yan Zheng <zheng.yan@oracle.com>
Date:   Mon Dec 8 16:46:26 2008 -0500

    Btrfs: superblock duplication
    
    This patch implements superblock duplication. Superblocks
    are stored at offset 16K, 64M and 256G on every devices.
    Spaces used by superblocks are preserved by the allocator,
    which uses a reverse mapping function to find the logical
    addresses that correspond to superblocks. Thank you,
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index fcbdcb3ae13e..bdebe83c3195 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -28,7 +28,6 @@ struct btrfs_device {
 	struct list_head dev_alloc_list;
 	struct btrfs_fs_devices *fs_devices;
 	struct btrfs_root *dev_root;
-	struct buffer_head *pending_io;
 	struct bio *pending_bios;
 	struct bio *pending_bio_tail;
 	int running_pending;
@@ -125,7 +124,10 @@ int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,
 int btrfs_map_block(struct btrfs_mapping_tree *map_tree, int rw,
 		    u64 logical, u64 *length,
 		    struct btrfs_multi_bio **multi_ret, int mirror_num);
-int btrfs_read_sys_array(struct btrfs_root *root);
+int btrfs_rmap_block(struct btrfs_mapping_tree *map_tree,
+		     u64 chunk_start, u64 physical, u64 devid,
+		     u64 **logical, int *naddrs, int *stripe_len);
+int btrfs_read_sys_array(struct btrfs_root *root, u64 sb_bytenr);
 int btrfs_read_chunk_tree(struct btrfs_root *root);
 int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
 		      struct btrfs_root *extent_root, u64 type);

commit 97288f2c71e46965a2010baea10548fcb5f3af73
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Dec 2 06:36:09 2008 -0500

    Btrfs: corret fmode_t annotations
    
    Make sure to propagate fmode_t properly and use the right constants for
    it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 9b41e4d3984d..fcbdcb3ae13e 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -135,8 +135,8 @@ int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,
 		  int mirror_num, int async_submit);
 int btrfs_read_super_device(struct btrfs_root *root, struct extent_buffer *buf);
 int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
-		       int flags, void *holder);
-int btrfs_scan_one_device(const char *path, int flags, void *holder,
+		       fmode_t flags, void *holder);
+int btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,
 			  struct btrfs_fs_devices **fs_devices_ret);
 int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
 int btrfs_close_extra_devices(struct btrfs_fs_devices *fs_devices);

commit 15916de835a683bd8133a0d1ac0c982b795ab4ff
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Nov 19 21:17:22 2008 -0500

    Btrfs: Fixes for 2.6.28-rc API changes
    
    * open/close_bdev_excl -> open/close_bdev_exclusive
    * blkdev_issue_discard takes a GFP mask now
    * Fix blkdev_issue_discard usage now that it is enabled
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 1f6f25a5787f..9b41e4d3984d 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -42,6 +42,9 @@ struct btrfs_device {
 
 	struct block_device *bdev;
 
+	/* the mode sent to open_bdev_exclusive */
+	fmode_t mode;
+
 	char *name;
 
 	/* the internal btrfs device id */

commit 2b82032c34ec40515d3c45c36cd1961f37977de8
Author: Yan Zheng <zheng.yan@oracle.com>
Date:   Mon Nov 17 21:11:30 2008 -0500

    Btrfs: Seed device support
    
    Seed device is a special btrfs with SEEDING super flag
    set and can only be mounted in read-only mode. Seed
    devices allow people to create new btrfs on top of it.
    
    The new FS contains the same contents as the seed device,
    but it can be mounted in read-write mode.
    
    This patch does the following:
    
    1) split code in btrfs_alloc_chunk into two parts. The first part does makes
    the newly allocated chunk usable, but does not do any operation that modifies
    the chunk tree. The second part does the the chunk tree modifications. This
    division is for the bootstrap step of adding storage to the seed device.
    
    2) Update device management code to handle seed device.
    The basic idea is: For an FS grown from seed devices, its
    seed devices are put into a list. Seed devices are
    opened on demand at mounting time. If any seed device is
    missing or has been changed, btrfs kernel module will
    refuse to mount the FS.
    
    3) make btrfs_find_block_group not return NULL when all
    block groups are read-only.
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index c50e50580b51..1f6f25a5787f 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -26,6 +26,7 @@ struct buffer_head;
 struct btrfs_device {
 	struct list_head dev_list;
 	struct list_head dev_alloc_list;
+	struct btrfs_fs_devices *fs_devices;
 	struct btrfs_root *dev_root;
 	struct buffer_head *pending_io;
 	struct bio *pending_bios;
@@ -34,6 +35,7 @@ struct btrfs_device {
 	u64 generation;
 
 	int barriers;
+	int writeable;
 	int in_fs_metadata;
 
 	spinlock_t io_lock;
@@ -77,6 +79,8 @@ struct btrfs_fs_devices {
 	u64 latest_trans;
 	u64 num_devices;
 	u64 open_devices;
+	u64 rw_devices;
+	u64 total_rw_bytes;
 	struct block_device *latest_bdev;
 	/* all of the devices in the FS */
 	struct list_head devices;
@@ -84,7 +88,12 @@ struct btrfs_fs_devices {
 	/* devices not currently being allocated */
 	struct list_head alloc_list;
 	struct list_head list;
-	int mounted;
+
+	struct btrfs_fs_devices *seed;
+	int seeding;
+	int sprouted;
+
+	int opened;
 };
 
 struct btrfs_bio_stripe {
@@ -109,16 +118,14 @@ struct btrfs_multi_bio {
 int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,
 			   struct btrfs_device *device,
 			   u64 chunk_tree, u64 chunk_objectid,
-			   u64 chunk_offset,
-			   u64 num_bytes, u64 *start);
+			   u64 chunk_offset, u64 start, u64 num_bytes);
 int btrfs_map_block(struct btrfs_mapping_tree *map_tree, int rw,
 		    u64 logical, u64 *length,
 		    struct btrfs_multi_bio **multi_ret, int mirror_num);
 int btrfs_read_sys_array(struct btrfs_root *root);
 int btrfs_read_chunk_tree(struct btrfs_root *root);
 int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
-		      struct btrfs_root *extent_root, u64 *start,
-		      u64 *num_bytes, u64 type);
+		      struct btrfs_root *extent_root, u64 type);
 void btrfs_mapping_init(struct btrfs_mapping_tree *tree);
 void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree);
 int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,
@@ -141,10 +148,11 @@ int btrfs_unplug_page(struct btrfs_mapping_tree *map_tree,
 int btrfs_grow_device(struct btrfs_trans_handle *trans,
 		      struct btrfs_device *device, u64 new_size);
 struct btrfs_device *btrfs_find_device(struct btrfs_root *root, u64 devid,
-				       u8 *uuid);
+				       u8 *uuid, u8 *fsid);
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_root *root, char *path);
 int btrfs_balance(struct btrfs_root *dev_root);
 void btrfs_unlock_volumes(void);
 void btrfs_lock_volumes(void);
+int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
 #endif

commit 7d2b4daa67379960477568abda62b8ba9ee3a8aa
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Aug 5 10:13:57 2008 -0400

    Btrfs: Fix the multi-bio code to save the original bio for completion
    
    The multi-bio code is responsible for duplicating blocks in raid1 and
    single spindle duplication.  It has counters to make sure all of
    the locations for a given extent are properly written before io completion
    is returned to the higher layers.
    
    But, it didn't always complete the same bio it was given, sometimes a
    clone was completed instead.  This lead to problems with the async
    work queues because they saved a pointer to the bio in a struct off
    bi_private.
    
    The fix is to remember the original bio and only complete that one.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 48a44f7a9385..c50e50580b51 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -95,6 +95,7 @@ struct btrfs_bio_stripe {
 struct btrfs_multi_bio {
 	atomic_t stripes_pending;
 	bio_end_io_t *end_io;
+	struct bio *orig_bio;
 	void *private;
 	atomic_t error;
 	int max_errors;

commit 8b7128429235d9bd72cfd5ed20c77c4f3118f744
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Jun 11 16:50:36 2008 -0400

    Btrfs: Add async worker threads for pre and post IO checksumming
    
    Btrfs has been using workqueues to spread the checksumming load across
    other CPUs in the system.  But, workqueues only schedule work on the
    same CPU that queued the work, giving them a limited benefit for systems with
    higher CPU counts.
    
    This code adds a generic facility to schedule work with pools of kthreads,
    and changes the bio submission code to queue bios up.  The queueing is
    important to make sure large numbers of procs on the system don't
    turn streaming workloads into random workloads by sending IO down
    concurrently.
    
    The end result of all of this is much higher performance (and CPU usage) when
    doing checksumming on large machines.  Two worker pools are created,
    one for writes and one for endio processing.  The two could deadlock if
    we tried to service both from a single pool.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 4df6b1608f91..48a44f7a9385 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -20,6 +20,7 @@
 #define __BTRFS_VOLUMES_
 
 #include <linux/bio.h>
+#include "async-thread.h"
 
 struct buffer_head;
 struct btrfs_device {
@@ -27,6 +28,9 @@ struct btrfs_device {
 	struct list_head dev_alloc_list;
 	struct btrfs_root *dev_root;
 	struct buffer_head *pending_io;
+	struct bio *pending_bios;
+	struct bio *pending_bio_tail;
+	int running_pending;
 	u64 generation;
 
 	int barriers;
@@ -36,8 +40,6 @@ struct btrfs_device {
 
 	struct block_device *bdev;
 
-	u64 total_ios;
-
 	char *name;
 
 	/* the internal btrfs device id */
@@ -63,6 +65,8 @@ struct btrfs_device {
 
 	/* physical drive uuid (or lvm uuid) */
 	u8 uuid[BTRFS_UUID_SIZE];
+
+	struct btrfs_work work;
 };
 
 struct btrfs_fs_devices {
@@ -117,7 +121,7 @@ int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
 void btrfs_mapping_init(struct btrfs_mapping_tree *tree);
 void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree);
 int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,
-		  int mirror_num);
+		  int mirror_num, int async_submit);
 int btrfs_read_super_device(struct btrfs_root *root, struct extent_buffer *buf);
 int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
 		       int flags, void *holder);

commit a0af469b58944f6e8c5c8ecbebb42997baf0cb9e
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue May 13 16:03:06 2008 -0400

    Fix btrfs_open_devices to deal with changes since the scan ioctls
    
    Devices can change after the scan ioctls are done, and btrfs_open_devices
    needs to be able to verify them as they are opened and used by the FS.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 454fe8103329..4df6b1608f91 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -71,16 +71,16 @@ struct btrfs_fs_devices {
 	/* the device with this id has the most recent coyp of the super */
 	u64 latest_devid;
 	u64 latest_trans;
-	u64 lowest_devid;
 	u64 num_devices;
+	u64 open_devices;
 	struct block_device *latest_bdev;
-	struct block_device *lowest_bdev;
 	/* all of the devices in the FS */
 	struct list_head devices;
 
 	/* devices not currently being allocated */
 	struct list_head alloc_list;
 	struct list_head list;
+	int mounted;
 };
 
 struct btrfs_bio_stripe {

commit dfe25020689bb2d318782d2c9c7141203583fc70
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue May 13 13:46:40 2008 -0400

    Btrfs: Add mount -o degraded to allow mounts to continue with missing devices
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 0f94a69e6eb6..454fe8103329 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -27,8 +27,10 @@ struct btrfs_device {
 	struct list_head dev_alloc_list;
 	struct btrfs_root *dev_root;
 	struct buffer_head *pending_io;
+	u64 generation;
 
 	int barriers;
+	int in_fs_metadata;
 
 	spinlock_t io_lock;
 
@@ -122,6 +124,7 @@ int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
 int btrfs_scan_one_device(const char *path, int flags, void *holder,
 			  struct btrfs_fs_devices **fs_devices_ret);
 int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
+int btrfs_close_extra_devices(struct btrfs_fs_devices *fs_devices);
 int btrfs_add_device(struct btrfs_trans_handle *trans,
 		     struct btrfs_root *root,
 		     struct btrfs_device *device);

commit a061fc8da7b990faa41ca503e66faef3ecdeead0
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed May 7 11:43:44 2008 -0400

    Btrfs: Add support for online device removal
    
    This required a few structural changes to the code that manages bdev pointers:
    
    The VFS super block now gets an anon-bdev instead of a pointer to the
    lowest bdev.  This allows us to avoid swapping the super block bdev pointer
    around at run time.
    
    The code to read in the super block no longer goes through the extent
    buffer interface.  Things got ugly keeping the mapping constant.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index a9663e92bb14..0f94a69e6eb6 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -125,6 +125,7 @@ int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
 int btrfs_add_device(struct btrfs_trans_handle *trans,
 		     struct btrfs_root *root,
 		     struct btrfs_device *device);
+int btrfs_rm_device(struct btrfs_root *root, char *device_path);
 int btrfs_cleanup_fs_uuids(void);
 int btrfs_num_copies(struct btrfs_mapping_tree *map_tree, u64 logical, u64 len);
 int btrfs_unplug_page(struct btrfs_mapping_tree *map_tree,
@@ -136,4 +137,6 @@ struct btrfs_device *btrfs_find_device(struct btrfs_root *root, u64 devid,
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_root *root, char *path);
 int btrfs_balance(struct btrfs_root *dev_root);
+void btrfs_unlock_volumes(void);
+void btrfs_lock_volumes(void);
 #endif

commit a236aed14ccb0661611d4416f6b573d892bdc60a
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 29 09:38:00 2008 -0400

    Btrfs: Deal with failed writes in mirrored configurations
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 3f9a17f2e41b..a9663e92bb14 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -90,7 +90,8 @@ struct btrfs_multi_bio {
 	atomic_t stripes_pending;
 	bio_end_io_t *end_io;
 	void *private;
-	int error;
+	atomic_t error;
+	int max_errors;
 	int num_stripes;
 	struct btrfs_bio_stripe stripes[];
 };

commit ec44a35cbeb26ab2da84cb280d778260f2312feb
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Apr 28 15:29:52 2008 -0400

    Btrfs: Add balance ioctl to restripe the chunks
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 6f173450378b..3f9a17f2e41b 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -134,4 +134,5 @@ struct btrfs_device *btrfs_find_device(struct btrfs_root *root, u64 devid,
 				       u8 *uuid);
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_root *root, char *path);
+int btrfs_balance(struct btrfs_root *dev_root);
 #endif

commit 788f20eb5affef584e75ea84bb80a4c3352a2c0e
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Apr 28 15:29:42 2008 -0400

    Btrfs: Add new ioctl to add devices
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 6fe8440b37a7..6f173450378b 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -133,4 +133,5 @@ int btrfs_grow_device(struct btrfs_trans_handle *trans,
 struct btrfs_device *btrfs_find_device(struct btrfs_root *root, u64 devid,
 				       u8 *uuid);
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
+int btrfs_init_new_device(struct btrfs_root *root, char *path);
 #endif

commit 8f18cf13396caae5a3d7ae91201cfb15181a9642
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Apr 25 16:53:30 2008 -0400

    Btrfs: Make the resizer work based on shrinking and growing devices
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index a2660d2b6b34..6fe8440b37a7 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -128,4 +128,9 @@ int btrfs_cleanup_fs_uuids(void);
 int btrfs_num_copies(struct btrfs_mapping_tree *map_tree, u64 logical, u64 len);
 int btrfs_unplug_page(struct btrfs_mapping_tree *map_tree,
 		      u64 logical, struct page *page);
+int btrfs_grow_device(struct btrfs_trans_handle *trans,
+		      struct btrfs_device *device, u64 new_size);
+struct btrfs_device *btrfs_find_device(struct btrfs_root *root, u64 devid,
+				       u8 *uuid);
+int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 #endif

commit b30757178dad19a0388d958ff9eea66e674d39ed
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 22 09:22:07 2008 -0400

    Btrfs: Add a special device list for chunk allocations
    
    This allows other code that needs to walk every device in the FS to do so
    without locking against allocations.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index dfe7e8a9507c..a2660d2b6b34 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -24,9 +24,12 @@
 struct buffer_head;
 struct btrfs_device {
 	struct list_head dev_list;
+	struct list_head dev_alloc_list;
 	struct btrfs_root *dev_root;
 	struct buffer_head *pending_io;
+
 	int barriers;
+
 	spinlock_t io_lock;
 
 	struct block_device *bdev;
@@ -70,7 +73,11 @@ struct btrfs_fs_devices {
 	u64 num_devices;
 	struct block_device *latest_bdev;
 	struct block_device *lowest_bdev;
+	/* all of the devices in the FS */
 	struct list_head devices;
+
+	/* devices not currently being allocated */
+	struct list_head alloc_list;
 	struct list_head list;
 };
 

commit f2d8d74d7874f8f81222363cd6459a365796e35a
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Apr 21 10:03:05 2008 -0400

    Btrfs: Make an unplug function that doesn't unplug every spindle
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index f9cae3072171..dfe7e8a9507c 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -119,4 +119,6 @@ int btrfs_add_device(struct btrfs_trans_handle *trans,
 		     struct btrfs_device *device);
 int btrfs_cleanup_fs_uuids(void);
 int btrfs_num_copies(struct btrfs_mapping_tree *map_tree, u64 logical, u64 len);
+int btrfs_unplug_page(struct btrfs_mapping_tree *map_tree,
+		      u64 logical, struct page *page);
 #endif

commit e17cade25ff8074101d653557a78df09c16ca276
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 15 15:41:47 2008 -0400

    Btrfs: Add chunk uuids and update multi-device back references
    
    Block headers now store the chunk tree uuid
    
    Chunk items records the device uuid for each stripes
    
    Device extent items record better back refs to the chunk tree
    
    Block groups record better back refs to the chunk tree
    
    The chunk tree format has also changed.  The objectid of BTRFS_CHUNK_ITEM_KEY
    used to be the logical offset of the chunk.  Now it is a chunk tree id,
    with the logical offset being stored in the offset field of the key.
    
    This allows a single chunk tree to record multiple logical address spaces,
    upping the number of bytes indexed by a chunk tree from 2^64 to
    2^128.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 89548837a1cc..f9cae3072171 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -57,7 +57,7 @@ struct btrfs_device {
 	u64 type;
 
 	/* physical drive uuid (or lvm uuid) */
-	u8 uuid[BTRFS_DEV_UUID_SIZE];
+	u8 uuid[BTRFS_UUID_SIZE];
 };
 
 struct btrfs_fs_devices {
@@ -93,7 +93,9 @@ struct btrfs_multi_bio {
 
 int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,
 			   struct btrfs_device *device,
-			   u64 owner, u64 num_bytes, u64 *start);
+			   u64 chunk_tree, u64 chunk_objectid,
+			   u64 chunk_offset,
+			   u64 num_bytes, u64 *start);
 int btrfs_map_block(struct btrfs_mapping_tree *map_tree, int rw,
 		    u64 logical, u64 *length,
 		    struct btrfs_multi_bio **multi_ret, int mirror_num);

commit f29844623de29a12358d7fba35d0959465b64adf
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Apr 10 16:19:33 2008 -0400

    Btrfs: Write out all super blocks on commit, and bring back proper barrier support
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 3d5d0a9cb827..89548837a1cc 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -21,9 +21,12 @@
 
 #include <linux/bio.h>
 
+struct buffer_head;
 struct btrfs_device {
 	struct list_head dev_list;
 	struct btrfs_root *dev_root;
+	struct buffer_head *pending_io;
+	int barriers;
 	spinlock_t io_lock;
 
 	struct block_device *bdev;

commit f188591e987e21b6f7f8864c66a02858b95b530e
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Apr 9 16:28:12 2008 -0400

    Btrfs: Retry metadata reads in the face of checksum failures
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 10ca0104750c..3d5d0a9cb827 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -93,7 +93,7 @@ int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,
 			   u64 owner, u64 num_bytes, u64 *start);
 int btrfs_map_block(struct btrfs_mapping_tree *map_tree, int rw,
 		    u64 logical, u64 *length,
-		    struct btrfs_multi_bio **multi_ret);
+		    struct btrfs_multi_bio **multi_ret, int mirror_num);
 int btrfs_read_sys_array(struct btrfs_root *root);
 int btrfs_read_chunk_tree(struct btrfs_root *root);
 int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
@@ -101,7 +101,8 @@ int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
 		      u64 *num_bytes, u64 type);
 void btrfs_mapping_init(struct btrfs_mapping_tree *tree);
 void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree);
-int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio);
+int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,
+		  int mirror_num);
 int btrfs_read_super_device(struct btrfs_root *root, struct extent_buffer *buf);
 int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
 		       int flags, void *holder);
@@ -112,4 +113,5 @@ int btrfs_add_device(struct btrfs_trans_handle *trans,
 		     struct btrfs_root *root,
 		     struct btrfs_device *device);
 int btrfs_cleanup_fs_uuids(void);
+int btrfs_num_copies(struct btrfs_mapping_tree *map_tree, u64 logical, u64 len);
 #endif

commit cea9e4452ebaf18dd0951e90dc84d82a5dee40b2
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Apr 9 16:28:12 2008 -0400

    Change btrfs_map_block to return a structure with mappings for all stripes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 35dec3efd78c..10ca0104750c 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -19,6 +19,8 @@
 #ifndef __BTRFS_VOLUMES_
 #define __BTRFS_VOLUMES_
 
+#include <linux/bio.h>
+
 struct btrfs_device {
 	struct list_head dev_list;
 	struct btrfs_root *dev_root;
@@ -69,12 +71,29 @@ struct btrfs_fs_devices {
 	struct list_head list;
 };
 
+struct btrfs_bio_stripe {
+	struct btrfs_device *dev;
+	u64 physical;
+};
+
+struct btrfs_multi_bio {
+	atomic_t stripes_pending;
+	bio_end_io_t *end_io;
+	void *private;
+	int error;
+	int num_stripes;
+	struct btrfs_bio_stripe stripes[];
+};
+
+#define btrfs_multi_bio_size(n) (sizeof(struct btrfs_multi_bio) + \
+			    (sizeof(struct btrfs_bio_stripe) * (n)))
+
 int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,
 			   struct btrfs_device *device,
 			   u64 owner, u64 num_bytes, u64 *start);
-int btrfs_map_block(struct btrfs_mapping_tree *map_tree, int rw, int stripe_nr,
-		    u64 logical, u64 *phys, u64 *length,
-		    struct btrfs_device **dev, int *total_stripes);
+int btrfs_map_block(struct btrfs_mapping_tree *map_tree, int rw,
+		    u64 logical, u64 *length,
+		    struct btrfs_multi_bio **multi_ret);
 int btrfs_read_sys_array(struct btrfs_root *root);
 int btrfs_read_chunk_tree(struct btrfs_root *root);
 int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,

commit 8790d502e4401a4a3a4175b83a3a47e8d595c771
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Apr 3 16:29:03 2008 -0400

    Btrfs: Add support for mirroring across drives
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 12f297eb0559..35dec3efd78c 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -18,12 +18,16 @@
 
 #ifndef __BTRFS_VOLUMES_
 #define __BTRFS_VOLUMES_
+
 struct btrfs_device {
 	struct list_head dev_list;
 	struct btrfs_root *dev_root;
+	spinlock_t io_lock;
 
 	struct block_device *bdev;
 
+	u64 total_ios;
+
 	char *name;
 
 	/* the internal btrfs device id */
@@ -68,9 +72,9 @@ struct btrfs_fs_devices {
 int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,
 			   struct btrfs_device *device,
 			   u64 owner, u64 num_bytes, u64 *start);
-int btrfs_map_block(struct btrfs_mapping_tree *map_tree,
+int btrfs_map_block(struct btrfs_mapping_tree *map_tree, int rw, int stripe_nr,
 		    u64 logical, u64 *phys, u64 *length,
-		    struct btrfs_device **dev);
+		    struct btrfs_device **dev, int *total_stripes);
 int btrfs_read_sys_array(struct btrfs_root *root);
 int btrfs_read_chunk_tree(struct btrfs_root *root);
 int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
@@ -80,9 +84,6 @@ void btrfs_mapping_init(struct btrfs_mapping_tree *tree);
 void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree);
 int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio);
 int btrfs_read_super_device(struct btrfs_root *root, struct extent_buffer *buf);
-int btrfs_map_block(struct btrfs_mapping_tree *map_tree,
-		    u64 logical, u64 *phys, u64 *length,
-		    struct btrfs_device **dev);
 int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
 		       int flags, void *holder);
 int btrfs_scan_one_device(const char *path, int flags, void *holder,

commit 8a4b83cc8bd75fca29ac68615896d9e92820e7c2
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Mar 24 15:02:07 2008 -0400

    Btrfs: Add support for device scanning and detection ioctls
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 20259128152e..12f297eb0559 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -24,6 +24,8 @@ struct btrfs_device {
 
 	struct block_device *bdev;
 
+	char *name;
+
 	/* the internal btrfs device id */
 	u64 devid;
 
@@ -49,6 +51,20 @@ struct btrfs_device {
 	u8 uuid[BTRFS_DEV_UUID_SIZE];
 };
 
+struct btrfs_fs_devices {
+	u8 fsid[BTRFS_FSID_SIZE]; /* FS specific uuid */
+
+	/* the device with this id has the most recent coyp of the super */
+	u64 latest_devid;
+	u64 latest_trans;
+	u64 lowest_devid;
+	u64 num_devices;
+	struct block_device *latest_bdev;
+	struct block_device *lowest_bdev;
+	struct list_head devices;
+	struct list_head list;
+};
+
 int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,
 			   struct btrfs_device *device,
 			   u64 owner, u64 num_bytes, u64 *start);
@@ -67,4 +83,13 @@ int btrfs_read_super_device(struct btrfs_root *root, struct extent_buffer *buf);
 int btrfs_map_block(struct btrfs_mapping_tree *map_tree,
 		    u64 logical, u64 *phys, u64 *length,
 		    struct btrfs_device **dev);
+int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
+		       int flags, void *holder);
+int btrfs_scan_one_device(const char *path, int flags, void *holder,
+			  struct btrfs_fs_devices **fs_devices_ret);
+int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
+int btrfs_add_device(struct btrfs_trans_handle *trans,
+		     struct btrfs_root *root,
+		     struct btrfs_device *device);
+int btrfs_cleanup_fs_uuids(void);
 #endif

commit 239b14b32dc39232ebf9cce29ff77c4c564355fd
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Mar 24 15:02:07 2008 -0400

    Btrfs: Bring back mount -o ssd optimizations
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 77fa6efd79cf..20259128152e 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -64,4 +64,7 @@ void btrfs_mapping_init(struct btrfs_mapping_tree *tree);
 void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree);
 int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio);
 int btrfs_read_super_device(struct btrfs_root *root, struct extent_buffer *buf);
+int btrfs_map_block(struct btrfs_mapping_tree *map_tree,
+		    u64 logical, u64 *phys, u64 *length,
+		    struct btrfs_device **dev);
 #endif

commit 0d81ba5dbedef0c3970d6aa318aa84920943e6e3
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Mar 24 15:02:07 2008 -0400

    Btrfs: Move device information into the super block so it can be scanned
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 4ab9891878a8..77fa6efd79cf 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -21,7 +21,6 @@
 struct btrfs_device {
 	struct list_head dev_list;
 	struct btrfs_root *dev_root;
-	struct btrfs_key dev_key;
 
 	struct block_device *bdev;
 
@@ -43,22 +42,11 @@ struct btrfs_device {
 	/* minimal io size for this device */
 	u32 sector_size;
 
-	/* the kernel device number */
-	u64 rdev;
-
 	/* type and info about this device */
 	u64 type;
 
-	/* partition number, 0 for whole dev */
-	int partition;
-
-	/* length of the name data at the end of the item */
-	int name_len;
-
 	/* physical drive uuid (or lvm uuid) */
 	u8 uuid[BTRFS_DEV_UUID_SIZE];
-
-	char *name;
 };
 
 int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,
@@ -75,4 +63,5 @@ int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
 void btrfs_mapping_init(struct btrfs_mapping_tree *tree);
 void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree);
 int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio);
+int btrfs_read_super_device(struct btrfs_root *root, struct extent_buffer *buf);
 #endif

commit 6324fbf334f4586325057197da7752f4ffa409d3
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Mar 24 15:01:59 2008 -0400

    Btrfs: Dynamic chunk and block group allocation
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 4a47dcb00a73..4ab9891878a8 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -71,7 +71,7 @@ int btrfs_read_sys_array(struct btrfs_root *root);
 int btrfs_read_chunk_tree(struct btrfs_root *root);
 int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
 		      struct btrfs_root *extent_root, u64 *start,
-		      u64 *num_bytes, u32 type);
+		      u64 *num_bytes, u64 type);
 void btrfs_mapping_init(struct btrfs_mapping_tree *tree);
 void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree);
 int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio);

commit 0b86a832a1f38abec695864ec2eaedc9d2383f1b
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Mar 24 15:01:56 2008 -0400

    Btrfs: Add support for multiple devices per filesystem
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
new file mode 100644
index 000000000000..4a47dcb00a73
--- /dev/null
+++ b/fs/btrfs/volumes.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2007 Oracle.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License v2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#ifndef __BTRFS_VOLUMES_
+#define __BTRFS_VOLUMES_
+struct btrfs_device {
+	struct list_head dev_list;
+	struct btrfs_root *dev_root;
+	struct btrfs_key dev_key;
+
+	struct block_device *bdev;
+
+	/* the internal btrfs device id */
+	u64 devid;
+
+	/* size of the device */
+	u64 total_bytes;
+
+	/* bytes used */
+	u64 bytes_used;
+
+	/* optimal io alignment for this device */
+	u32 io_align;
+
+	/* optimal io width for this device */
+	u32 io_width;
+
+	/* minimal io size for this device */
+	u32 sector_size;
+
+	/* the kernel device number */
+	u64 rdev;
+
+	/* type and info about this device */
+	u64 type;
+
+	/* partition number, 0 for whole dev */
+	int partition;
+
+	/* length of the name data at the end of the item */
+	int name_len;
+
+	/* physical drive uuid (or lvm uuid) */
+	u8 uuid[BTRFS_DEV_UUID_SIZE];
+
+	char *name;
+};
+
+int btrfs_alloc_dev_extent(struct btrfs_trans_handle *trans,
+			   struct btrfs_device *device,
+			   u64 owner, u64 num_bytes, u64 *start);
+int btrfs_map_block(struct btrfs_mapping_tree *map_tree,
+		    u64 logical, u64 *phys, u64 *length,
+		    struct btrfs_device **dev);
+int btrfs_read_sys_array(struct btrfs_root *root);
+int btrfs_read_chunk_tree(struct btrfs_root *root);
+int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
+		      struct btrfs_root *extent_root, u64 *start,
+		      u64 *num_bytes, u32 type);
+void btrfs_mapping_init(struct btrfs_mapping_tree *tree);
+void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree);
+int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio);
+#endif
